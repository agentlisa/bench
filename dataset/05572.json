{
  "Title": "[H-01] Incorrect calculations for Surplus Auction creation cause massive surplus imbalances",
  "Content": "\nThere are two big issues in `AccountingEngine.sol::auctionSurplus()` when calculating values for the creating a Surplus Auction; specifically in [Lines 213 - 217](https://github.com/open-dollar/od-contracts/blob/dev/src/contracts/AccountingEngine.sol#L213-L217).\n\n1.  The first issue is the `if` statement at [line 213](https://github.com/open-dollar/od-contracts/blob/dev/src/contracts/AccountingEngine.sol#L213-L217) which incorrectly checks if `_params.surplusTransferPercentage` is less than `ONE_HUNDRED_WAD` when it should check if it is less than `WAD`.\n\n```\n\n        if (_params.surplusTransferPercentage < ONE_HUNDRED_WAD) {\n```\n\nThe maximum value for `_params.surplusTransferPercentage`, as checked by the function at [line 199](https://github.com/open-dollar/od-contracts/blob/dev/src/contracts/AccountingEngine.sol#L199), is `1e18` so the check at [line 213](https://github.com/open-dollar/od-contracts/blob/dev/src/contracts/AccountingEngine.sol#L213-L217) will always return `TRUE`.\n\nHowever, the check should return `FALSE` when `_params.surplusTransferPercentage` is `1e18` or `100%` because in that case an auction shouldn't be created; rather the full `surplusAmount` should be transferred to `extraSurplusReceiver` in the next code block.\n\n2.  The second issue is the use of `ONE_HUNDRED_WAD` to calculate `_amountToSell` at [Line 215](https://github.com/open-dollar/od-contracts/blob/dev/src/contracts/AccountingEngine.sol#L213-L217) which results in a hugely inflated figure in the newly created surplus auction.\n\nThe use of `ONE_HUNDRED_WAD` causes the calculated figure to be `100 times` greater than it should be.\n\n        _amountToSell: _params.surplusAmount.wmul(ONE_HUNDRED_WAD - _params.surplusTransferPercentage)\n\n### Impact\n\nIssue 1. For the first issue; when `_params.surplusTransferPercentage` is `100%`, a ghost surplus Auction will be created and the entire `surplusAmount` amount will also be sent to the `extraSurplusReceiver` essentially double-counting a large amount of the surplus. This double accounting can destabilise the system and lead to underflows elsewhere.\n\nIssue 2. Surplus auctions are created with massively inflated figures for `_amountToSell`. This has the potential to cause massive price imbalances and crash the protocol. There is potential here for a malicious actor to leverage the vulnerability to their advantage by creating lots of false surplus in system coins which they purchase cheaply.\n\n### Proof of Concept\n\nThe following combines both issues into one PoC to show the worst case scenario.\n\nGiven the following values and assuming the initial all checks pass in function before reaching Line 213 `AccountingEngine.sol::auctionSurplus()`:\n\n    WAD = 1e18\n    surplusTransferPercentage = 1e18 (representative of 100%)\n    surplusAmount = 3e18\n    ONE_HUNDRED_WAD = 100e18\n\nThe following condition at Line 213 will always return TRUE:\n\n    if (_params.surplusTransferPercentage < ONE_HUNDRED_WAD)\n\nSo an auction will be created with `_amountToSell` 100 times higher than it should be:\n\n        _amountToSell: _params.surplusAmount.wmul(ONE_HUNDRED_WAD - _params.surplusTransferPercentage),\n\n    Returns 297e18; where coin surplusAmount is only 3e18:\n    _amountToSell = 3e18 * (100e18 - 1e18) / 1e18\n                  = 3e18 * 99e18 / 1e18\n                  = 297e18\n                  = 297 WAD\n\nFollowing this, a coin amount of `surplusAmount` is also sent to the `extraSurplusReceiver` calculated in [Lines 224-231](https://github.com/open-dollar/od-contracts/blob/dev/src/contracts/AccountingEngine.sol#L224-L231) which is actually the intended behaviour.\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nUpdate the function on the two affected lines to use `WAD` instead of `ONE_HUNDRED_WAD` as:\n\n<details>\n\n```diff\n  function auctionSurplus() external returns (uint256 _id) {\n    if(_params.surplusTransferPercentage > WAD) revert AccEng_surplusTransferPercentOverLimit();\n    if (_params.surplusAmount == 0) revert AccEng_NullAmount();\n    if (extraSurplusReceiver == address(0)) revert AccEng_NullSurplusReceiver();\n    if (block.timestamp < lastSurplusTime + _params.surplusDelay) revert AccEng_SurplusCooldown();\n\n    uint256 _coinBalance = safeEngine.coinBalance(address(this));\n    uint256 _debtBalance = safeEngine.debtBalance(address(this));\n    (_coinBalance, _debtBalance) = _settleDebt(_coinBalance, _debtBalance, _unqueuedUnauctionedDebt(_debtBalance));\n\n    if (_coinBalance < _debtBalance + _params.surplusAmount + _params.surplusBuffer) {\n      revert AccEng_InsufficientSurplus();\n    }\n\n    // auction surplus percentage\n-   if (_params.surplusTransferPercentage < ONE_HUNDRED_WAD) {\n+   if (_params.surplusTransferPercentage < WAD) {\n      _id = surplusAuctionHouse.startAuction({\n-        _amountToSell: _params.surplusAmount.wmul(ONE_HUNDRED_WAD - _params.surplusTransferPercentage),\n+        _amountToSell: _params.surplusAmount.wmul(WAD - _params.surplusTransferPercentage),\n        _initialBid: 0\n      });\n\n      lastSurplusTime = block.timestamp;\n      emit AuctionSurplus(_id, 0, _params.surplusAmount.wmul(ONE_HUNDRED_WAD - _params.surplusTransferPercentage));\n    }\n\n    // transfer surplus percentage\n    if (_params.surplusTransferPercentage > 0) {\n      if (extraSurplusReceiver == address(0)) revert AccEng_NullSurplusReceiver();\n\n      safeEngine.transferInternalCoins({\n        _source: address(this),\n        _destination: extraSurplusReceiver,\n        _rad: _params.surplusAmount.wmul(_params.surplusTransferPercentage)\n      });\n\n      lastSurplusTime = block.timestamp;\n      emit TransferSurplus(extraSurplusReceiver, _params.surplusAmount.wmul(_params.surplusTransferPercentage));\n    }\n  }\n```\n</details>\n\n**[RaymondFam (Lookout) commented](https://github.com/code-423n4/2023-10-opendollar-findings/issues/26#issuecomment-1780191087):**\n > `_amountToSell` is indeed very close to 100 times (99% plus).\n\n**[pi0neerpat (OpenDollar) confirmed](https://github.com/code-423n4/2023-10-opendollar-findings/issues/26#issuecomment-1783550386)**\n\n**[MiloTruck (Judge) commented](https://github.com/code-423n4/2023-10-opendollar-findings/issues/26#issuecomment-1792490617):**\n > The warden has demonstrated how due to the incorrect use of `ONE_HUNDRED_WAD` instead of `WAD` when calculating percentages, surplus auctions will be created with massively inflated values, breaking the accounting of the protocol. As such, I agree with high severity.\n> \n> Selected this report for best as it outlines the issues, impacts and recommended mitigation really well despite the lack of a coded PoC.\n\n**[pi0neerpat (OpenDollar) commented](https://github.com/code-423n4/2023-10-opendollar-findings/issues/26#issuecomment-1861161709)**\n >Resolved [here](https://github.com/open-dollar/od-contracts/pull/254).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-10-opendollar",
  "Code": [
    {
      "filename": "src/contracts/AccountingEngine.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport {IAccountingEngine} from '@interfaces/IAccountingEngine.sol';\nimport {IDebtAuctionHouse} from '@interfaces/IDebtAuctionHouse.sol';\nimport {ISurplusAuctionHouse} from '@interfaces/ISurplusAuctionHouse.sol';\nimport {ISAFEEngine} from '@interfaces/ISAFEEngine.sol';\n\nimport {Authorizable, IAuthorizable} from '@contracts/utils/Authorizable.sol';\nimport {Disableable} from '@contracts/utils/Disableable.sol';\nimport {Modifiable} from '@contracts/utils/Modifiable.sol';\n\nimport {Encoding} from '@libraries/Encoding.sol';\nimport {Math, WAD} from '@libraries/Math.sol';\nimport {Assertions} from '@libraries/Assertions.sol';\n\n/**\n * @title  AccountingEngine\n * @notice This contract is responsible for handling protocol surplus and debt\n * @notice It allows the system to auction surplus and debt, as well as transfer surplus\n * @dev    This is a system contract, therefore it is not meant to be used by users directly\n */\ncontract AccountingEngine is Authorizable, Modifiable, Disableable, IAccountingEngine {\n  using Encoding for bytes;\n  using Assertions for address;\n  using Assertions for uint256;\n  using Math for uint256;\n\n  uint256 internal constant ONE_HUNDRED_WAD = 100 * WAD;\n\n  // --- Auth ---\n\n  /**\n   * @notice Overriding method allows new authorizations only if the contract is enabled\n   * @param  _account The account to authorize\n   * @inheritdoc IAuthorizable\n   */\n  function addAuthorization(address _account) external override(Authorizable, IAuthorizable) isAuthorized whenEnabled {\n    _addAuthorization(_account);\n  }\n\n  // --- Registry ---\n\n  /// @inheritdoc IAccountingEngine\n  ISAFEEngine public safeEngine;\n  /// @inheritdoc IAccountingEngine\n  ISurplusAuctionHouse public surplusAuctionHouse;\n  /// @inheritdoc IAccountingEngine\n  IDebtAuctionHouse public debtAuctionHouse;\n  /// @inheritdoc IAccountingEngine\n  address public postSettlementSurplusDrain;\n  /// @inheritdoc IAccountingEngine\n  address public extraSurplusReceiver;\n\n  // --- Params ---\n\n  /// @inheritdoc IAccountingEngine\n  // solhint-disable-next-line private-vars-leading-underscore\n  AccountingEngineParams public _params;\n\n  /// @inheritdoc IAccountingEngine\n  function params() external view returns (AccountingEngineParams memory _accEngineParams) {\n    return _params;\n  }\n\n  // --- Data ---\n\n  /// @inheritdoc IAccountingEngine\n  mapping(uint256 _timestamp => uint256 _rad) public debtQueue;\n  /// @inheritdoc IAccountingEngine\n  uint256 public /* RAD */ totalOnAuctionDebt;\n  /// @inheritdoc IAccountingEngine\n  uint256 public /* RAD */ totalQueuedDebt;\n  /// @inheritdoc IAccountingEngine\n  uint256 public lastSurplusTime;\n  /// @inheritdoc IAccountingEngine\n  uint256 public disableTimestamp;\n\n  // --- Init ---\n\n  /**\n   * @param  _safeEngine Address of the SAFEEngine\n   * @param  _surplusAuctionHouse Address of the SurplusAuctionHouse\n   * @param  _debtAuctionHouse Address of the DebtAuctionHouse\n   * @param  _accEngineParams Initial valid AccountingEngine parameters struct\n   */\n  constructor(\n    address _safeEngine,\n    address _surplusAuctionHouse,\n    address _debtAuctionHouse,\n    AccountingEngineParams memory _accEngineParams\n  ) Authorizable(msg.sender) validParams {\n    _debtAuctionHouse.assertNonNull();\n    safeEngine = ISAFEEngine(_safeEngine.assertNonNull());\n    _setSurplusAuctionHouse(_surplusAuctionHouse);\n    debtAuctionHouse = IDebtAuctionHouse(_debtAuctionHouse);\n\n    lastSurplusTime = block.timestamp;\n\n    _params = _accEngineParams;\n  }\n\n  // --- Getters ---\n\n  /// @inheritdoc IAccountingEngine\n  function unqueuedUnauctionedDebt() external view returns (uint256 __unqueuedUnauctionedDebt) {\n    return _unqueuedUnauctionedDebt(safeEngine.debtBalance(address(this)));\n  }\n\n  function _unqueuedUnauctionedDebt(uint256 _debtBalance) internal view returns (uint256 __unqueuedUnauctionedDebt) {\n    return (_debtBalance - totalQueuedDebt) - totalOnAuctionDebt;\n  }\n\n  // --- Debt Queueing ---\n\n  /// @inheritdoc IAccountingEngine\n  function pushDebtToQueue(uint256 _debtBlock) external isAuthorized {\n    debtQueue[block.timestamp] = debtQueue[block.timestamp] + _debtBlock;\n    totalQueuedDebt = totalQueuedDebt + _debtBlock;\n\n    emit PushDebtToQueue(block.timestamp, _debtBlock);\n  }\n\n  /// @inheritdoc IAccountingEngine\n  function popDebtFromQueue(uint256 _debtBlockTimestamp) external {\n    if (block.timestamp < _debtBlockTimestamp + _params.popDebtDelay) revert AccEng_PopDebtCooldown();\n\n    uint256 _debtBlock = debtQueue[_debtBlockTimestamp];\n\n    if (_debtBlock == 0) revert AccEng_NullAmount();\n\n    totalQueuedDebt = totalQueuedDebt - _debtBlock;\n    debtQueue[_debtBlockTimestamp] = 0;\n\n    emit PopDebtFromQueue(_debtBlockTimestamp, _debtBlock);\n  }\n\n  // Debt settlement\n\n  /// @inheritdoc IAccountingEngine\n  function settleDebt(uint256 _rad) external {\n    _settleDebt(safeEngine.coinBalance(address(this)), safeEngine.debtBalance(address(this)), _rad);\n  }\n\n  function _settleDebt(\n    uint256 _coinBalance,\n    uint256 _debtBalance,\n    uint256 _rad\n  ) internal returns (uint256 _newCoinBalance, uint256 _newDebtBalance) {\n    if (_rad > _coinBalance) revert AccEng_InsufficientSurplus();\n    if (_rad > _unqueuedUnauctionedDebt(_debtBalance)) revert AccEng_InsufficientDebt();\n\n    safeEngine.settleDebt(_rad);\n    _newCoinBalance = _coinBalance - _rad;\n    _newDebtBalance = _debtBalance - _rad;\n\n    emit SettleDebt(_rad, _newCoinBalance, _newDebtBalance);\n  }\n\n  /// @inheritdoc IAccountingEngine\n  function cancelAuctionedDebtWithSurplus(uint256 _rad) external {\n    if (_rad > totalOnAuctionDebt) revert AccEng_InsufficientDebt();\n\n    uint256 _coinBalance = safeEngine.coinBalance(address(this));\n\n    if (_rad > _coinBalance) revert AccEng_InsufficientSurplus();\n\n    safeEngine.settleDebt(_rad);\n    totalOnAuctionDebt -= _rad;\n\n    emit CancelDebt(_rad, _coinBalance - _rad, safeEngine.debtBalance(address(this)));\n  }\n\n  // Debt auction\n\n  /// @inheritdoc IAccountingEngine\n  function auctionDebt() external returns (uint256 _id) {\n    if (_params.debtAuctionBidSize == 0) revert AccEng_DebtAuctionDisabled();\n\n    uint256 _coinBalance = safeEngine.coinBalance(address(this));\n    uint256 _debtBalance = safeEngine.debtBalance(address(this));\n    (_coinBalance, _debtBalance) = _settleDebt(_coinBalance, _debtBalance, _coinBalance);\n\n    (_coinBalance, _debtBalance) = _settleDebt(_coinBalance, _debtBalance, _coinBalance);\n\n    if (_params.debtAuctionBidSize > _unqueuedUnauctionedDebt(_debtBalance)) revert AccEng_InsufficientDebt();\n\n    totalOnAuctionDebt += _params.debtAuctionBidSize;\n    _id = debtAuctionHouse.startAuction({\n      _incomeReceiver: address(this),\n      _amountToSell: _params.debtAuctionMintedTokens,\n      _initialBid: _params.debtAuctionBidSize\n    });\n\n    emit AuctionDebt(_id, _params.debtAuctionMintedTokens, _params.debtAuctionBidSize);\n  }\n\n  // Surplus auction\n\n  /// @inheritdoc IAccountingEngine\n  function auctionSurplus() external returns (uint256 _id) {\n    if (_params.surplusTransferPercentage > WAD) revert AccEng_surplusTransferPercentOverLimit();\n    if (_params.surplusAmount == 0) revert AccEng_NullAmount();\n    if (extraSurplusReceiver == address(0)) revert AccEng_NullSurplusReceiver();\n    if (block.timestamp < lastSurplusTime + _params.surplusDelay) revert AccEng_SurplusCooldown();\n\n    uint256 _coinBalance = safeEngine.coinBalance(address(this));\n    uint256 _debtBalance = safeEngine.debtBalance(address(this));\n    (_coinBalance, _debtBalance) = _settleDebt(_coinBalance, _debtBalance, _unqueuedUnauctionedDebt(_debtBalance));\n\n    if (_coinBalance < _debtBalance + _params.surplusAmount + _params.surplusBuffer) {\n      revert AccEng_InsufficientSurplus();\n    }\n\n    // auction surplus percentage\n    if (_params.surplusTransferPercentage < WAD) {\n      _id = surplusAuctionHouse.startAuction({\n        _amountToSell: _params.surplusAmount.wmul(WAD - _params.surplusTransferPercentage),\n        _initialBid: 0\n      });\n\n      lastSurplusTime = block.timestamp;\n      emit AuctionSurplus(_id, 0, _params.surplusAmount.wmul(WAD - _params.surplusTransferPercentage));\n    }\n\n    // transfer surplus percentage\n    if (_params.surplusTransferPercentage > 0) {\n      if (extraSurplusReceiver == address(0)) revert AccEng_NullSurplusReceiver();\n\n      safeEngine.transferInternalCoins({\n        _source: address(this),\n        _destination: extraSurplusReceiver,\n        _rad: _params.surplusAmount.wmul(_params.surplusTransferPercentage)\n      });\n\n      lastSurplusTime = block.timestamp;\n      emit TransferSurplus(extraSurplusReceiver, _params.surplusAmount.wmul(_params.surplusTransferPercentage));\n    }\n  }\n\n  // --- Shutdown ---\n\n  /**\n   * @notice Runtime to be run when the contract is disabled (normally triggered by GlobalSettlement)\n   * @dev When it's being disabled, the contract will record the current timestamp. Afterwards,\n   *      the contract tries to settle as much debt as possible (if there's any) with any surplus that's\n   *      left in the AccountingEngine\n   * @inheritdoc Disableable\n   */\n  function _onContractDisable() internal override {\n    totalQueuedDebt = 0;\n    totalOnAuctionDebt = 0;\n    disableTimestamp = block.timestamp;\n\n    surplusAuctionHouse.disableContract();\n    debtAuctionHouse.disableContract();\n\n    uint256 _debtToSettle = Math.min(safeEngine.coinBalance(address(this)), safeEngine.debtBalance(address(this)));\n    safeEngine.settleDebt(_debtToSettle);\n  }\n\n  /// @inheritdoc IAccountingEngine\n  function transferPostSettlementSurplus() external whenDisabled {\n    if (address(postSettlementSurplusDrain) == address(0)) revert AccEng_NullSurplusReceiver();\n    if (block.timestamp < disableTimestamp + _params.disableCooldown) revert AccEng_PostSettlementCooldown();\n\n    uint256 _coinBalance = safeEngine.coinBalance(address(this));\n    uint256 _debtBalance = safeEngine.debtBalance(address(this));\n    uint256 _debtToSettle = Math.min(_coinBalance, _debtBalance);\n    (_coinBalance,) = _settleDebt(_coinBalance, _debtBalance, _debtToSettle);\n\n    if (_coinBalance > 0) {\n      safeEngine.transferInternalCoins({\n        _source: address(this),\n        _destination: postSettlementSurplusDrain,\n        _rad: _coinBalance\n      });\n\n      emit TransferSurplus(postSettlementSurplusDrain, _coinBalance);\n    }\n  }\n\n  // --- Administration ---\n\n  /// @inheritdoc Modifiable\n  function _modifyParameters(bytes32 _param, bytes memory _data) internal override {\n    uint256 _uint256 = _data.toUint256();\n    address _address = _data.toAddress();\n\n    // params\n    if (_param == 'surplusTransferPercentage') _params.surplusTransferPercentage = _uint256;\n    else if (_param == 'surplusDelay') _params.surplusDelay = _uint256;\n    else if (_param == 'popDebtDelay') _params.popDebtDelay = _uint256;\n    else if (_param == 'disableCooldown') _params.disableCooldown = _uint256;\n    else if (_param == 'surplusAmount') _params.surplusAmount = _uint256;\n    else if (_param == 'debtAuctionBidSize') _params.debtAuctionBidSize = _uint256;\n    else if (_param == 'debtAuctionMintedTokens') _params.debtAuctionMintedTokens = _uint256;\n    else if (_param == 'surplusBuffer') _params.surplusBuffer = _uint256;\n    // registry\n    else if (_param == 'surplusAuctionHouse') _setSurplusAuctionHouse(_address);\n    else if (_param == 'debtAuctionHouse') debtAuctionHouse = IDebtAuctionHouse(_address);\n    else if (_param == 'postSettlementSurplusDrain') postSettlementSurplusDrain = _address;\n    else if (_param == 'extraSurplusReceiver') extraSurplusReceiver = _address;\n    else revert UnrecognizedParam();\n  }\n\n  /// @dev Set the surplus auction house, deny permissions on the old one and approve on the new one\n  function _setSurplusAuctionHouse(address _surplusAuctionHouse) internal {\n    if (address(surplusAuctionHouse) != address(0)) {\n      safeEngine.denySAFEModification(address(surplusAuctionHouse));\n    }\n    surplusAuctionHouse = ISurplusAuctionHouse(_surplusAuctionHouse);\n    safeEngine.approveSAFEModification(_surplusAuctionHouse);\n  }\n\n  /// @inheritdoc Modifiable\n  function _validateParameters() internal view override {\n    address(surplusAuctionHouse).assertHasCode();\n    address(debtAuctionHouse).assertHasCode();\n    _params.debtAuctionMintedTokens.assertGt(0);\n  }\n}"
    },
    {
      "filename": "src/contracts/AccountingEngine.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport {IAccountingEngine} from '@interfaces/IAccountingEngine.sol';\nimport {IDebtAuctionHouse} from '@interfaces/IDebtAuctionHouse.sol';\nimport {ISurplusAuctionHouse} from '@interfaces/ISurplusAuctionHouse.sol';\nimport {ISAFEEngine} from '@interfaces/ISAFEEngine.sol';\n\nimport {Authorizable, IAuthorizable} from '@contracts/utils/Authorizable.sol';\nimport {Disableable} from '@contracts/utils/Disableable.sol';\nimport {Modifiable} from '@contracts/utils/Modifiable.sol';\n\nimport {Encoding} from '@libraries/Encoding.sol';\nimport {Math, WAD} from '@libraries/Math.sol';\nimport {Assertions} from '@libraries/Assertions.sol';\n\n/**\n * @title  AccountingEngine\n * @notice This contract is responsible for handling protocol surplus and debt\n * @notice It allows the system to auction surplus and debt, as well as transfer surplus\n * @dev    This is a system contract, therefore it is not meant to be used by users directly\n */\ncontract AccountingEngine is Authorizable, Modifiable, Disableable, IAccountingEngine {\n  using Encoding for bytes;\n  using Assertions for address;\n  using Assertions for uint256;\n  using Math for uint256;\n\n  uint256 internal constant ONE_HUNDRED_WAD = 100 * WAD;\n\n  // --- Auth ---\n\n  /**\n   * @notice Overriding method allows new authorizations only if the contract is enabled\n   * @param  _account The account to authorize\n   * @inheritdoc IAuthorizable\n   */\n  function addAuthorization(address _account) external override(Authorizable, IAuthorizable) isAuthorized whenEnabled {\n    _addAuthorization(_account);\n  }\n\n  // --- Registry ---\n\n  /// @inheritdoc IAccountingEngine\n  ISAFEEngine public safeEngine;\n  /// @inheritdoc IAccountingEngine\n  ISurplusAuctionHouse public surplusAuctionHouse;\n  /// @inheritdoc IAccountingEngine\n  IDebtAuctionHouse public debtAuctionHouse;\n  /// @inheritdoc IAccountingEngine\n  address public postSettlementSurplusDrain;\n  /// @inheritdoc IAccountingEngine\n  address public extraSurplusReceiver;\n\n  // --- Params ---\n\n  /// @inheritdoc IAccountingEngine\n  // solhint-disable-next-line private-vars-leading-underscore\n  AccountingEngineParams public _params;\n\n  /// @inheritdoc IAccountingEngine\n  function params() external view returns (AccountingEngineParams memory _accEngineParams) {\n    return _params;\n  }\n\n  // --- Data ---\n\n  /// @inheritdoc IAccountingEngine\n  mapping(uint256 _timestamp => uint256 _rad) public debtQueue;\n  /// @inheritdoc IAccountingEngine\n  uint256 public /* RAD */ totalOnAuctionDebt;\n  /// @inheritdoc IAccountingEngine\n  uint256 public /* RAD */ totalQueuedDebt;\n  /// @inheritdoc IAccountingEngine\n  uint256 public lastSurplusTime;\n  /// @inheritdoc IAccountingEngine\n  uint256 public disableTimestamp;\n\n  // --- Init ---\n\n  /**\n   * @param  _safeEngine Address of the SAFEEngine\n   * @param  _surplusAuctionHouse Address of the SurplusAuctionHouse\n   * @param  _debtAuctionHouse Address of the DebtAuctionHouse\n   * @param  _accEngineParams Initial valid AccountingEngine parameters struct\n   */\n  constructor(\n    address _safeEngine,\n    address _surplusAuctionHouse,\n    address _debtAuctionHouse,\n    AccountingEngineParams memory _accEngineParams\n  ) Authorizable(msg.sender) validParams {\n    _debtAuctionHouse.assertNonNull();\n    safeEngine = ISAFEEngine(_safeEngine.assertNonNull());\n    _setSurplusAuctionHouse(_surplusAuctionHouse);\n    debtAuctionHouse = IDebtAuctionHouse(_debtAuctionHouse);\n\n    lastSurplusTime = block.timestamp;\n\n    _params = _accEngineParams;\n  }\n\n  // --- Getters ---\n\n  /// @inheritdoc IAccountingEngine\n  function unqueuedUnauctionedDebt() external view returns (uint256 __unqueuedUnauctionedDebt) {\n    return _unqueuedUnauctionedDebt(safeEngine.debtBalance(address(this)));\n  }\n\n  function _unqueuedUnauctionedDebt(uint256 _debtBalance) internal view returns (uint256 __unqueuedUnauctionedDebt) {\n    return (_debtBalance - totalQueuedDebt) - totalOnAuctionDebt;\n  }\n\n  // --- Debt Queueing ---\n\n  /// @inheritdoc IAccountingEngine\n  function pushDebtToQueue(uint256 _debtBlock) external isAuthorized {\n    debtQueue[block.timestamp] = debtQueue[block.timestamp] + _debtBlock;\n    totalQueuedDebt = totalQueuedDebt + _debtBlock;\n\n    emit PushDebtToQueue(block.timestamp, _debtBlock);\n  }\n\n  /// @inheritdoc IAccountingEngine\n  function popDebtFromQueue(uint256 _debtBlockTimestamp) external {\n    if (block.timestamp < _debtBlockTimestamp + _params.popDebtDelay) revert AccEng_PopDebtCooldown();\n\n    uint256 _debtBlock = debtQueue[_debtBlockTimestamp];\n\n    if (_debtBlock == 0) revert AccEng_NullAmount();\n\n    totalQueuedDebt = totalQueuedDebt - _debtBlock;\n    debtQueue[_debtBlockTimestamp] = 0;\n\n    emit PopDebtFromQueue(_debtBlockTimestamp, _debtBlock);\n  }\n\n  // Debt settlement\n\n  /// @inheritdoc IAccountingEngine\n  function settleDebt(uint256 _rad) external {\n    _settleDebt(safeEngine.coinBalance(address(this)), safeEngine.debtBalance(address(this)), _rad);\n  }\n\n  function _settleDebt(\n    uint256 _coinBalance,\n    uint256 _debtBalance,\n    uint256 _rad\n  ) internal returns (uint256 _newCoinBalance, uint256 _newDebtBalance) {\n    if (_rad > _coinBalance) revert AccEng_InsufficientSurplus();\n    if (_rad > _unqueuedUnauctionedDebt(_debtBalance)) revert AccEng_InsufficientDebt();\n\n    safeEngine.settleDebt(_rad);\n    _newCoinBalance = _coinBalance - _rad;\n    _newDebtBalance = _debtBalance - _rad;\n\n    emit SettleDebt(_rad, _newCoinBalance, _newDebtBalance);\n  }\n\n  /// @inheritdoc IAccountingEngine\n  function cancelAuctionedDebtWithSurplus(uint256 _rad) external {\n    if (_rad > totalOnAuctionDebt) revert AccEng_InsufficientDebt();\n\n    uint256 _coinBalance = safeEngine.coinBalance(address(this));\n\n    if (_rad > _coinBalance) revert AccEng_InsufficientSurplus();\n\n    safeEngine.settleDebt(_rad);\n    totalOnAuctionDebt -= _rad;\n\n    emit CancelDebt(_rad, _coinBalance - _rad, safeEngine.debtBalance(address(this)));\n  }\n\n  // Debt auction\n\n  /// @inheritdoc IAccountingEngine\n  function auctionDebt() external returns (uint256 _id) {\n    if (_params.debtAuctionBidSize == 0) revert AccEng_DebtAuctionDisabled();\n\n    uint256 _coinBalance = safeEngine.coinBalance(address(this));\n    uint256 _debtBalance = safeEngine.debtBalance(address(this));\n    (_coinBalance, _debtBalance) = _settleDebt(_coinBalance, _debtBalance, _coinBalance);\n\n    (_coinBalance, _debtBalance) = _settleDebt(_coinBalance, _debtBalance, _coinBalance);\n\n    if (_params.debtAuctionBidSize > _unqueuedUnauctionedDebt(_debtBalance)) revert AccEng_InsufficientDebt();\n\n    totalOnAuctionDebt += _params.debtAuctionBidSize;\n    _id = debtAuctionHouse.startAuction({\n      _incomeReceiver: address(this),\n      _amountToSell: _params.debtAuctionMintedTokens,\n      _initialBid: _params.debtAuctionBidSize\n    });\n\n    emit AuctionDebt(_id, _params.debtAuctionMintedTokens, _params.debtAuctionBidSize);\n  }\n\n  // Surplus auction\n\n  /// @inheritdoc IAccountingEngine\n  function auctionSurplus() external returns (uint256 _id) {\n    if (_params.surplusTransferPercentage > WAD) revert AccEng_surplusTransferPercentOverLimit();\n    if (_params.surplusAmount == 0) revert AccEng_NullAmount();\n    if (extraSurplusReceiver == address(0)) revert AccEng_NullSurplusReceiver();\n    if (block.timestamp < lastSurplusTime + _params.surplusDelay) revert AccEng_SurplusCooldown();\n\n    uint256 _coinBalance = safeEngine.coinBalance(address(this));\n    uint256 _debtBalance = safeEngine.debtBalance(address(this));\n    (_coinBalance, _debtBalance) = _settleDebt(_coinBalance, _debtBalance, _unqueuedUnauctionedDebt(_debtBalance));\n\n    if (_coinBalance < _debtBalance + _params.surplusAmount + _params.surplusBuffer) {\n      revert AccEng_InsufficientSurplus();\n    }\n\n    // auction surplus percentage\n    if (_params.surplusTransferPercentage < WAD) {\n      _id = surplusAuctionHouse.startAuction({\n        _amountToSell: _params.surplusAmount.wmul(WAD - _params.surplusTransferPercentage),\n        _initialBid: 0\n      });\n\n      lastSurplusTime = block.timestamp;\n      emit AuctionSurplus(_id, 0, _params.surplusAmount.wmul(WAD - _params.surplusTransferPercentage));\n    }\n\n    // transfer surplus percentage\n    if (_params.surplusTransferPercentage > 0) {\n      if (extraSurplusReceiver == address(0)) revert AccEng_NullSurplusReceiver();\n\n      safeEngine.transferInternalCoins({\n        _source: address(this),\n        _destination: extraSurplusReceiver,\n        _rad: _params.surplusAmount.wmul(_params.surplusTransferPercentage)\n      });\n\n      lastSurplusTime = block.timestamp;\n      emit TransferSurplus(extraSurplusReceiver, _params.surplusAmount.wmul(_params.surplusTransferPercentage));\n    }\n  }\n\n  // --- Shutdown ---\n\n  /**\n   * @notice Runtime to be run when the contract is disabled (normally triggered by GlobalSettlement)\n   * @dev When it's being disabled, the contract will record the current timestamp. Afterwards,\n   *      the contract tries to settle as much debt as possible (if there's any) with any surplus that's\n   *      left in the AccountingEngine\n   * @inheritdoc Disableable\n   */\n  function _onContractDisable() internal override {\n    totalQueuedDebt = 0;\n    totalOnAuctionDebt = 0;\n    disableTimestamp = block.timestamp;\n\n    surplusAuctionHouse.disableContract();\n    debtAuctionHouse.disableContract();\n\n    uint256 _debtToSettle = Math.min(safeEngine.coinBalance(address(this)), safeEngine.debtBalance(address(this)));\n    safeEngine.settleDebt(_debtToSettle);\n  }\n\n  /// @inheritdoc IAccountingEngine\n  function transferPostSettlementSurplus() external whenDisabled {\n    if (address(postSettlementSurplusDrain) == address(0)) revert AccEng_NullSurplusReceiver();\n    if (block.timestamp < disableTimestamp + _params.disableCooldown) revert AccEng_PostSettlementCooldown();\n\n    uint256 _coinBalance = safeEngine.coinBalance(address(this));\n    uint256 _debtBalance = safeEngine.debtBalance(address(this));\n    uint256 _debtToSettle = Math.min(_coinBalance, _debtBalance);\n    (_coinBalance,) = _settleDebt(_coinBalance, _debtBalance, _debtToSettle);\n\n    if (_coinBalance > 0) {\n      safeEngine.transferInternalCoins({\n        _source: address(this),\n        _destination: postSettlementSurplusDrain,\n        _rad: _coinBalance\n      });\n\n      emit TransferSurplus(postSettlementSurplusDrain, _coinBalance);\n    }\n  }\n\n  // --- Administration ---\n\n  /// @inheritdoc Modifiable\n  function _modifyParameters(bytes32 _param, bytes memory _data) internal override {\n    uint256 _uint256 = _data.toUint256();\n    address _address = _data.toAddress();\n\n    // params\n    if (_param == 'surplusTransferPercentage') _params.surplusTransferPercentage = _uint256;\n    else if (_param == 'surplusDelay') _params.surplusDelay = _uint256;\n    else if (_param == 'popDebtDelay') _params.popDebtDelay = _uint256;\n    else if (_param == 'disableCooldown') _params.disableCooldown = _uint256;\n    else if (_param == 'surplusAmount') _params.surplusAmount = _uint256;\n    else if (_param == 'debtAuctionBidSize') _params.debtAuctionBidSize = _uint256;\n    else if (_param == 'debtAuctionMintedTokens') _params.debtAuctionMintedTokens = _uint256;\n    else if (_param == 'surplusBuffer') _params.surplusBuffer = _uint256;\n    // registry\n    else if (_param == 'surplusAuctionHouse') _setSurplusAuctionHouse(_address);\n    else if (_param == 'debtAuctionHouse') debtAuctionHouse = IDebtAuctionHouse(_address);\n    else if (_param == 'postSettlementSurplusDrain') postSettlementSurplusDrain = _address;\n    else if (_param == 'extraSurplusReceiver') extraSurplusReceiver = _address;\n    else revert UnrecognizedParam();\n  }\n\n  /// @dev Set the surplus auction house, deny permissions on the old one and approve on the new one\n  function _setSurplusAuctionHouse(address _surplusAuctionHouse) internal {\n    if (address(surplusAuctionHouse) != address(0)) {\n      safeEngine.denySAFEModification(address(surplusAuctionHouse));\n    }\n    surplusAuctionHouse = ISurplusAuctionHouse(_surplusAuctionHouse);\n    safeEngine.approveSAFEModification(_surplusAuctionHouse);\n  }\n\n  /// @inheritdoc Modifiable\n  function _validateParameters() internal view override {\n    address(surplusAuctionHouse).assertHasCode();\n    address(debtAuctionHouse).assertHasCode();\n    _params.debtAuctionMintedTokens.assertGt(0);\n  }\n}"
    },
    {
      "filename": "src/contracts/AccountingEngine.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport {IAccountingEngine} from '@interfaces/IAccountingEngine.sol';\nimport {IDebtAuctionHouse} from '@interfaces/IDebtAuctionHouse.sol';\nimport {ISurplusAuctionHouse} from '@interfaces/ISurplusAuctionHouse.sol';\nimport {ISAFEEngine} from '@interfaces/ISAFEEngine.sol';\n\nimport {Authorizable, IAuthorizable} from '@contracts/utils/Authorizable.sol';\nimport {Disableable} from '@contracts/utils/Disableable.sol';\nimport {Modifiable} from '@contracts/utils/Modifiable.sol';\n\nimport {Encoding} from '@libraries/Encoding.sol';\nimport {Math, WAD} from '@libraries/Math.sol';\nimport {Assertions} from '@libraries/Assertions.sol';\n\n/**\n * @title  AccountingEngine\n * @notice This contract is responsible for handling protocol surplus and debt\n * @notice It allows the system to auction surplus and debt, as well as transfer surplus\n * @dev    This is a system contract, therefore it is not meant to be used by users directly\n */\ncontract AccountingEngine is Authorizable, Modifiable, Disableable, IAccountingEngine {\n  using Encoding for bytes;\n  using Assertions for address;\n  using Assertions for uint256;\n  using Math for uint256;\n\n  uint256 internal constant ONE_HUNDRED_WAD = 100 * WAD;\n\n  // --- Auth ---\n\n  /**\n   * @notice Overriding method allows new authorizations only if the contract is enabled\n   * @param  _account The account to authorize\n   * @inheritdoc IAuthorizable\n   */\n  function addAuthorization(address _account) external override(Authorizable, IAuthorizable) isAuthorized whenEnabled {\n    _addAuthorization(_account);\n  }\n\n  // --- Registry ---\n\n  /// @inheritdoc IAccountingEngine\n  ISAFEEngine public safeEngine;\n  /// @inheritdoc IAccountingEngine\n  ISurplusAuctionHouse public surplusAuctionHouse;\n  /// @inheritdoc IAccountingEngine\n  IDebtAuctionHouse public debtAuctionHouse;\n  /// @inheritdoc IAccountingEngine\n  address public postSettlementSurplusDrain;\n  /// @inheritdoc IAccountingEngine\n  address public extraSurplusReceiver;\n\n  // --- Params ---\n\n  /// @inheritdoc IAccountingEngine\n  // solhint-disable-next-line private-vars-leading-underscore\n  AccountingEngineParams public _params;\n\n  /// @inheritdoc IAccountingEngine\n  function params() external view returns (AccountingEngineParams memory _accEngineParams) {\n    return _params;\n  }\n\n  // --- Data ---\n\n  /// @inheritdoc IAccountingEngine\n  mapping(uint256 _timestamp => uint256 _rad) public debtQueue;\n  /// @inheritdoc IAccountingEngine\n  uint256 public /* RAD */ totalOnAuctionDebt;\n  /// @inheritdoc IAccountingEngine\n  uint256 public /* RAD */ totalQueuedDebt;\n  /// @inheritdoc IAccountingEngine\n  uint256 public lastSurplusTime;\n  /// @inheritdoc IAccountingEngine\n  uint256 public disableTimestamp;\n\n  // --- Init ---\n\n  /**\n   * @param  _safeEngine Address of the SAFEEngine\n   * @param  _surplusAuctionHouse Address of the SurplusAuctionHouse\n   * @param  _debtAuctionHouse Address of the DebtAuctionHouse\n   * @param  _accEngineParams Initial valid AccountingEngine parameters struct\n   */\n  constructor(\n    address _safeEngine,\n    address _surplusAuctionHouse,\n    address _debtAuctionHouse,\n    AccountingEngineParams memory _accEngineParams\n  ) Authorizable(msg.sender) validParams {\n    _debtAuctionHouse.assertNonNull();\n    safeEngine = ISAFEEngine(_safeEngine.assertNonNull());\n    _setSurplusAuctionHouse(_surplusAuctionHouse);\n    debtAuctionHouse = IDebtAuctionHouse(_debtAuctionHouse);\n\n    lastSurplusTime = block.timestamp;\n\n    _params = _accEngineParams;\n  }\n\n  // --- Getters ---\n\n  /// @inheritdoc IAccountingEngine\n  function unqueuedUnauctionedDebt() external view returns (uint256 __unqueuedUnauctionedDebt) {\n    return _unqueuedUnauctionedDebt(safeEngine.debtBalance(address(this)));\n  }\n\n  function _unqueuedUnauctionedDebt(uint256 _debtBalance) internal view returns (uint256 __unqueuedUnauctionedDebt) {\n    return (_debtBalance - totalQueuedDebt) - totalOnAuctionDebt;\n  }\n\n  // --- Debt Queueing ---\n\n  /// @inheritdoc IAccountingEngine\n  function pushDebtToQueue(uint256 _debtBlock) external isAuthorized {\n    debtQueue[block.timestamp] = debtQueue[block.timestamp] + _debtBlock;\n    totalQueuedDebt = totalQueuedDebt + _debtBlock;\n\n    emit PushDebtToQueue(block.timestamp, _debtBlock);\n  }\n\n  /// @inheritdoc IAccountingEngine\n  function popDebtFromQueue(uint256 _debtBlockTimestamp) external {\n    if (block.timestamp < _debtBlockTimestamp + _params.popDebtDelay) revert AccEng_PopDebtCooldown();\n\n    uint256 _debtBlock = debtQueue[_debtBlockTimestamp];\n\n    if (_debtBlock == 0) revert AccEng_NullAmount();\n\n    totalQueuedDebt = totalQueuedDebt - _debtBlock;\n    debtQueue[_debtBlockTimestamp] = 0;\n\n    emit PopDebtFromQueue(_debtBlockTimestamp, _debtBlock);\n  }\n\n  // Debt settlement\n\n  /// @inheritdoc IAccountingEngine\n  function settleDebt(uint256 _rad) external {\n    _settleDebt(safeEngine.coinBalance(address(this)), safeEngine.debtBalance(address(this)), _rad);\n  }\n\n  function _settleDebt(\n    uint256 _coinBalance,\n    uint256 _debtBalance,\n    uint256 _rad\n  ) internal returns (uint256 _newCoinBalance, uint256 _newDebtBalance) {\n    if (_rad > _coinBalance) revert AccEng_InsufficientSurplus();\n    if (_rad > _unqueuedUnauctionedDebt(_debtBalance)) revert AccEng_InsufficientDebt();\n\n    safeEngine.settleDebt(_rad);\n    _newCoinBalance = _coinBalance - _rad;\n    _newDebtBalance = _debtBalance - _rad;\n\n    emit SettleDebt(_rad, _newCoinBalance, _newDebtBalance);\n  }\n\n  /// @inheritdoc IAccountingEngine\n  function cancelAuctionedDebtWithSurplus(uint256 _rad) external {\n    if (_rad > totalOnAuctionDebt) revert AccEng_InsufficientDebt();\n\n    uint256 _coinBalance = safeEngine.coinBalance(address(this));\n\n    if (_rad > _coinBalance) revert AccEng_InsufficientSurplus();\n\n    safeEngine.settleDebt(_rad);\n    totalOnAuctionDebt -= _rad;\n\n    emit CancelDebt(_rad, _coinBalance - _rad, safeEngine.debtBalance(address(this)));\n  }\n\n  // Debt auction\n\n  /// @inheritdoc IAccountingEngine\n  function auctionDebt() external returns (uint256 _id) {\n    if (_params.debtAuctionBidSize == 0) revert AccEng_DebtAuctionDisabled();\n\n    uint256 _coinBalance = safeEngine.coinBalance(address(this));\n    uint256 _debtBalance = safeEngine.debtBalance(address(this));\n    (_coinBalance, _debtBalance) = _settleDebt(_coinBalance, _debtBalance, _coinBalance);\n\n    (_coinBalance, _debtBalance) = _settleDebt(_coinBalance, _debtBalance, _coinBalance);\n\n    if (_params.debtAuctionBidSize > _unqueuedUnauctionedDebt(_debtBalance)) revert AccEng_InsufficientDebt();\n\n    totalOnAuctionDebt += _params.debtAuctionBidSize;\n    _id = debtAuctionHouse.startAuction({\n      _incomeReceiver: address(this),\n      _amountToSell: _params.debtAuctionMintedTokens,\n      _initialBid: _params.debtAuctionBidSize\n    });\n\n    emit AuctionDebt(_id, _params.debtAuctionMintedTokens, _params.debtAuctionBidSize);\n  }\n\n  // Surplus auction\n\n  /// @inheritdoc IAccountingEngine\n  function auctionSurplus() external returns (uint256 _id) {\n    if (_params.surplusTransferPercentage > WAD) revert AccEng_surplusTransferPercentOverLimit();\n    if (_params.surplusAmount == 0) revert AccEng_NullAmount();\n    if (extraSurplusReceiver == address(0)) revert AccEng_NullSurplusReceiver();\n    if (block.timestamp < lastSurplusTime + _params.surplusDelay) revert AccEng_SurplusCooldown();\n\n    uint256 _coinBalance = safeEngine.coinBalance(address(this));\n    uint256 _debtBalance = safeEngine.debtBalance(address(this));\n    (_coinBalance, _debtBalance) = _settleDebt(_coinBalance, _debtBalance, _unqueuedUnauctionedDebt(_debtBalance));\n\n    if (_coinBalance < _debtBalance + _params.surplusAmount + _params.surplusBuffer) {\n      revert AccEng_InsufficientSurplus();\n    }\n\n    // auction surplus percentage\n    if (_params.surplusTransferPercentage < WAD) {\n      _id = surplusAuctionHouse.startAuction({\n        _amountToSell: _params.surplusAmount.wmul(WAD - _params.surplusTransferPercentage),\n        _initi"
    }
  ]
}