{
  "Title": "[M-02] Market expiry behaviour differs in implementation and documentation",
  "Content": "_Submitted by GreyArt, also found by leastwood and rayn_\n\n[prePO Docs: Expiry](https://docs.prepo.io/concepts/markets#expiry)<br>\n[PrePOMarket.sol#L145-L156](https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/PrePOMarket.sol#L145-L156)<br>\n\nThe docs say that “If a market has not settled by its expiry date, it will automatically settle at the lower bound of its Valuation Range.”\n\nHowever, in the implementation, the expiry date is entirely ignored. The default settlement after expiry is a 1:1 ratio of long and short token for 1 collateral token.\n\n### Impact\n\nShould users believe that the market will settle at the lower bound, they would swap and hold long for short tokens instead of at a 1:1 ratio upon expiry. Thereafter, they would incur swap fees from having to swap some short tokens back for long tokens for redemption. User funds are also  affected should long tokens are repurchased at a higher price than when they were sold.\n\n### Recommended Mitigation Steps\n\nIf the market is to settle at the lower valuation after expiry, then the following logic should be added:\n\n```jsx\n// market has expired\n// settle at lower bound\nif (block.timestamp > _expiryTime) {\n\tuint256 _shortPrice = MAX_PRICE - _floorLongPrice;\n\t_collateralOwed =\n\t\t(_floorLongPrice * _longAmount + _shortPrice * _shortAmount) /\n\t\tMAX_PRICE;\n} else if (_finalLongPrice <= MAX_PRICE) {\n\t...\n} else {\n\t...\n}\n```\n\nOtherwise, the documentation should be updated to reflect the default behaviour of 1:1 redemption.\n\n**[ramenforbreakfast (prePO) disagreed with Medium severity](https://github.com/code-423n4/2022-03-prepo-findings/issues/28)**\n\n**[ramenforbreakfast (prePO) agreed with Medium severity and commented](https://github.com/code-423n4/2022-03-prepo-findings/issues/28#issuecomment-1075730207):**\n > This is a valid submission, no longer disagreeing with severity as we clearly stated that expiry should be enforceable. \n> \n> This was a mistake on our part and I think we ended up not using `expiryTime` since the only thing that really mattered was if the `finalLongPrice` was set. We should decide whether to enforce it or remove it altogether.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-03-prepo-findings/issues/28#issuecomment-1086869183):**\n > Agree with sponsor.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-03-prepo-contest",
  "Code": [
    {
      "filename": "contracts/core/PrePOMarket.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"./interfaces/ILongShortToken.sol\";\nimport \"./interfaces/IPrePOMarket.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract PrePOMarket is IPrePOMarket, Ownable, ReentrancyGuard {\n    address private _treasury;\n\n    IERC20 private immutable _collateral;\n    ILongShortToken private immutable _longToken;\n    ILongShortToken private immutable _shortToken;\n\n    uint256 private immutable _floorLongPrice;\n    uint256 private immutable _ceilingLongPrice;\n    uint256 private _finalLongPrice;\n\n    uint256 private immutable _floorValuation;\n    uint256 private immutable _ceilingValuation;\n\n    uint256 private _mintingFee;\n    uint256 private _redemptionFee;\n\n    uint256 private immutable _expiryTime;\n\n    bool private _publicMinting;\n\n    uint256 private constant MAX_PRICE = 1e18;\n    uint256 private constant FEE_DENOMINATOR = 1000000;\n    uint256 private constant FEE_LIMIT = 50000;\n\n    /**\n     * Assumes `_newCollateral`, `_newLongToken`, and `_newShortToken` are\n     * valid, since they will be handled by the PrePOMarketFactory. The\n     * treasury is initialized to governance due to stack limitations.\n     *\n     * Assumes that ownership of `_longToken` and `_shortToken` has been\n     * transferred to this contract via `createMarket()` in\n     * `PrePOMarketFactory.sol`.\n     */\n    constructor(\n        address _governance,\n        address _newCollateral,\n        ILongShortToken _newLongToken,\n        ILongShortToken _newShortToken,\n        uint256 _newFloorLongPrice,\n        uint256 _newCeilingLongPrice,\n        uint256 _newFloorValuation,\n        uint256 _newCeilingValuation,\n        uint256 _newMintingFee,\n        uint256 _newRedemptionFee,\n        uint256 _newExpiryTime,\n        bool _allowed\n    ) {\n        require(\n            _newCeilingLongPrice > _newFloorLongPrice,\n            \"Ceiling must exceed floor\"\n        );\n        require(_newExpiryTime > block.timestamp, \"Invalid expiry\");\n        require(_newMintingFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        require(_newRedemptionFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        require(_newCeilingLongPrice <= MAX_PRICE, \"Ceiling cannot exceed 1\");\n\n        transferOwnership(_governance);\n        _treasury = _governance;\n\n        _collateral = IERC20(_newCollateral);\n        _longToken = _newLongToken;\n        _shortToken = _newShortToken;\n\n        _floorLongPrice = _newFloorLongPrice;\n        _ceilingLongPrice = _newCeilingLongPrice;\n        _finalLongPrice = MAX_PRICE + 1;\n\n        _floorValuation = _newFloorValuation;\n        _ceilingValuation = _newCeilingValuation;\n\n        _mintingFee = _newMintingFee;\n        _redemptionFee = _newRedemptionFee;\n\n        _expiryTime = _newExpiryTime;\n\n        _publicMinting = _allowed;\n\n        emit MarketCreated(\n            address(_newLongToken),\n            address(_newShortToken),\n            _newFloorLongPrice,\n            _newCeilingLongPrice,\n            _newFloorValuation,\n            _newCeilingValuation,\n            _newMintingFee,\n            _newRedemptionFee,\n            _newExpiryTime\n        );\n    }\n\n    function mintLongShortTokens(uint256 _amount)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        if (msg.sender != owner()) {\n            require(_publicMinting, \"Public minting disabled\");\n        }\n        require(_finalLongPrice > MAX_PRICE, \"Market ended\");\n        require(\n            _collateral.balanceOf(msg.sender) >= _amount,\n            \"Insufficient collateral\"\n        );\n        /**\n         * Add 1 to avoid rounding to zero, only process if user is minting\n         * an amount large enough to pay a fee\n         */\n        uint256 _fee = (_amount * _mintingFee) / FEE_DENOMINATOR + 1;\n        require(_amount > _fee, \"Minting amount too small\");\n        _collateral.transferFrom(msg.sender, _treasury, _fee);\n        _amount -= _fee;\n        _collateral.transferFrom(msg.sender, address(this), _amount);\n        _longToken.mint(msg.sender, _amount);\n        _shortToken.mint(msg.sender, _amount);\n        emit Mint(msg.sender, _amount);\n        return _amount;\n    }\n\n    function redeem(uint256 _longAmount, uint256 _shortAmount)\n        external\n        override\n        nonReentrant\n    {\n        require(\n            _longToken.balanceOf(msg.sender) >= _longAmount,\n            \"Insufficient long tokens\"\n        );\n        require(\n            _shortToken.balanceOf(msg.sender) >= _shortAmount,\n            \"Insufficient short tokens\"\n        );\n\n        uint256 _collateralOwed;\n        if (_finalLongPrice <= MAX_PRICE) {\n            uint256 _shortPrice = MAX_PRICE - _finalLongPrice;\n            _collateralOwed =\n                (_finalLongPrice * _longAmount + _shortPrice * _shortAmount) /\n                MAX_PRICE;\n        } else {\n            require(\n                _longAmount == _shortAmount,\n                \"Long and Short must be equal\"\n            );\n            _collateralOwed = _longAmount;\n        }\n\n        _longToken.burnFrom(msg.sender, _longAmount);\n        _shortToken.burnFrom(msg.sender, _shortAmount);\n        /**\n         * Add 1 to avoid rounding to zero, only process if user is redeeming\n         * an amount large enough to pay a fee\n         */\n        uint256 _fee = (_collateralOwed * _redemptionFee) /\n            FEE_DENOMINATOR +\n            1;\n        require(_collateralOwed > _fee, \"Redemption amount too small\");\n        _collateral.transfer(_treasury, _fee);\n        _collateralOwed -= _fee;\n        _collateral.transfer(msg.sender, _collateralOwed);\n\n        emit Redemption(msg.sender, _collateralOwed);\n    }\n\n    function setTreasury(address _newTreasury) external override onlyOwner {\n        _treasury = _newTreasury;\n        emit TreasuryChanged(_newTreasury);\n    }\n\n    function setFinalLongPrice(uint256 _newFinalLongPrice)\n        external\n        override\n        onlyOwner\n    {\n        require(\n            _newFinalLongPrice >= _floorLongPrice,\n            \"Price cannot be below floor\"\n        );\n        require(\n            _newFinalLongPrice <= _ceilingLongPrice,\n            \"Price cannot exceed ceiling\"\n        );\n        _finalLongPrice = _newFinalLongPrice;\n        emit FinalLongPriceSet(_newFinalLongPrice);\n    }\n\n    function setMintingFee(uint256 _newMintingFee)\n        external\n        override\n        onlyOwner\n    {\n        require(_newMintingFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        _mintingFee = _newMintingFee;\n        emit MintingFeeChanged(_newMintingFee);\n    }\n\n    function setRedemptionFee(uint256 _newRedemptionFee)\n        external\n        override\n        onlyOwner\n    {\n        require(_newRedemptionFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        _redemptionFee = _newRedemptionFee;\n        emit RedemptionFeeChanged(_newRedemptionFee);\n    }\n\n    function setPublicMinting(bool _allowed) external override onlyOwner {\n        _publicMinting = _allowed;\n        emit PublicMintingChanged(_allowed);\n    }\n\n    function getTreasury() external view override returns (address) {\n        return _treasury;\n    }\n\n    function getCollateral() external view override returns (IERC20) {\n        return _collateral;\n    }\n\n    function getLongToken() external view override returns (ILongShortToken) {\n        return _longToken;\n    }\n\n    function getShortToken() external view override returns (ILongShortToken) {\n        return _shortToken;\n    }\n\n    function getFloorLongPrice() external view override returns (uint256) {\n        return _floorLongPrice;\n    }\n\n    function getCeilingLongPrice() external view override returns (uint256) {\n        return _ceilingLongPrice;\n    }\n\n    function getFinalLongPrice() external view override returns (uint256) {\n        return _finalLongPrice;\n    }\n\n    function getFloorValuation() external view override returns (uint256) {\n        return _floorValuation;\n    }\n\n    function getCeilingValuation() external view override returns (uint256) {\n        return _ceilingValuation;\n    }\n\n    function getMintingFee() external view override returns (uint256) {\n        return _mintingFee;\n    }\n\n    function getRedemptionFee() external view override returns (uint256) {\n        return _redemptionFee;\n    }\n\n    function getExpiryTime() external view override returns (uint256) {\n        return _expiryTime;\n    }\n\n    function isPublicMintingAllowed() external view override returns (bool) {\n        return _publicMinting;\n    }\n\n    function getMaxPrice() external pure override returns (uint256) {\n        return MAX_PRICE;\n    }\n\n    function getFeeDenominator() external pure override returns (uint256) {\n        return FEE_DENOMINATOR;\n    }\n\n    function getFeeLimit() external pure override returns (uint256) {\n        return FEE_LIMIT;\n    }\n}"
    }
  ]
}