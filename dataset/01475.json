{
  "Title": "M-2: `getPrice` in `WeightedBPTOracle.sol`  uses `totalSupply` for price calculations which can lead to wrong results",
  "Content": "# Issue M-2: `getPrice` in `WeightedBPTOracle.sol`  uses `totalSupply` for price calculations which can lead to wrong results \n\nSource: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/18 \n\n## Found by \nVagner\n`getPrice` is used to calculate the price in USD of a given balancer LP, and it respects the recommendations  of Balancer docs by calculating the invariant and using it to protect from manipulations, but it uses `totalSupply` for every LP calculated which can lead to wrong results and assumptions.\n## Vulnerability Detail\nIn the Balancer docs it is specified that `There are three potential functions to query when determining the BPT supply depending on pool type.` https://docs.balancer.fi/concepts/advanced/valuing-bpt/valuing-bpt.html#getting-bpt-supply\n- `getActualSupply` : which is used by the most recent Weighted and Stable Pools and it accounts for pre-minted BPT as well as due protocol fees:\n- `getVirtualSupply` : which is used by Linear Pools and \"legacy\" Stable Phantom Pools and it accounts just for pre-minted BPT\n- `totalSupply` : which makes sense to be called only by older `legacy` pools since those doesn't have pre-minted BPT\nThe `getPrice` uses every time `totalSupply`\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/WeightedBPTOracle.sol#L71-L73\nwhich in the case of most recent pools can lead to very wrong calculations because of all the pre-minted BPT.\n## Impact\nImpact is a medium one, since it can lead to wrong price assumptions\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/WeightedBPTOracle.sol#L71-L73\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider implementing the more recent `getActualSupply` even if older pools doesn't have this functions , because it can lead to wrong assumptions and calculations.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**YakuzaKiawe** commented:\n>  invalid as this could be a factor to exploit the pool in future\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/104",
  "Code": [
    {
      "filename": "blueberry-core/contracts/oracle/WeightedBPTOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./UsingBaseOracle.sol\";\nimport \"../interfaces/IBaseOracle.sol\";\nimport \"../interfaces/balancer/IBalancerPool.sol\";\nimport \"../interfaces/balancer/IBalancerVault.sol\";\nimport \"../libraries/balancer/FixedPoint.sol\";\n\n/// @title WeightedBPTOracle\n/// @dev Provides price feeds for Weighted Balancer LP tokens.\n/// @author BlueberryProtocol\n///\n/// This contract fetches and computes the value of a Balancer LP token in terms of USD.\n/// It uses the base oracle to fetch underlying token values and then computes the\n/// value of the LP token using Balancer's formula.\ncontract WeightedBPTOracle is UsingBaseOracle, IBaseOracle {\n    using FixedPoint for uint256;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @notice Constructs the WeightedBPTOracle contract.\n    /// @dev Initializes the contract with the base oracle address.\n    /// @param _base Address of the base oracle contract.\n    constructor(IBaseOracle _base) UsingBaseOracle(_base) {}\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Return the USD value of given Balancer Lp, with 18 decimals of precision.\n    /// @param token The ERC-20 token to check the value.\n    function getPrice(address token) external override returns (uint256) {\n        IBalancerPool pool = IBalancerPool(token);\n        IBalancerVault vault = IBalancerVault(pool.getVault());\n\n        // Reentrancy guard to prevent flashloan attack\n        checkReentrancy(vault);\n\n        (address[] memory tokens, uint256[] memory balances, ) = vault\n            .getPoolTokens(pool.getPoolId());\n\n        uint256[] memory weights = pool.getNormalizedWeights();\n\n        uint256 length = weights.length;\n        uint256 temp = 1e18;\n        uint256 invariant = 1e18;\n        for(uint256 i; i < length; i++) {\n            temp = temp.mulDown(\n                (base.getPrice(tokens[i]).divDown(weights[i]))\n                .powDown(weights[i])\n            );\n            invariant = invariant.mulDown(\n                (balances[i] * 10 ** (18 - IERC20Metadata(tokens[i]).decimals()))\n                .powDown(weights[i])\n            );\n        }\n        return invariant\n            .mulDown(temp)\n            .divDown(IBalancerPool(token).totalSupply());\n    }\n\n    /// @dev Checks for reentrancy by calling a no-op function on the Balancer Vault.\n    ///      This is a preventative measure against potential reentrancy attacks.\n    /// @param vault The Balancer Vault contract instance.\n    function checkReentrancy(IBalancerVault vault) internal {\n        vault.manageUserBalance(new IBalancerVault.UserBalanceOp[](0));\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/oracle/WeightedBPTOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./UsingBaseOracle.sol\";\nimport \"../interfaces/IBaseOracle.sol\";\nimport \"../interfaces/balancer/IBalancerPool.sol\";\nimport \"../interfaces/balancer/IBalancerVault.sol\";\nimport \"../libraries/balancer/FixedPoint.sol\";\n\n/// @title WeightedBPTOracle\n/// @dev Provides price feeds for Weighted Balancer LP tokens.\n/// @author BlueberryProtocol\n///\n/// This contract fetches and computes the value of a Balancer LP token in terms of USD.\n/// It uses the base oracle to fetch underlying token values and then computes the\n/// value of the LP token using Balancer's formula.\ncontract WeightedBPTOracle is UsingBaseOracle, IBaseOracle {\n    using FixedPoint for uint256;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @notice Constructs the WeightedBPTOracle contract.\n    /// @dev Initializes the contract with the base oracle address.\n    /// @param _base Address of the base oracle contract.\n    constructor(IBaseOracle _base) UsingBaseOracle(_base) {}\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Return the USD value of given Balancer Lp, with 18 decimals of precision.\n    /// @param token The ERC-20 token to check the value.\n    function getPrice(address token) external override returns (uint256) {\n        IBalancerPool pool = IBalancerPool(token);\n        IBalancerVault vault = IBalancerVault(pool.getVault());\n\n        // Reentrancy guard to prevent flashloan attack\n        checkReentrancy(vault);\n\n        (address[] memory tokens, uint256[] memory balances, ) = vault\n            .getPoolTokens(pool.getPoolId());\n\n        uint256[] memory weights = pool.getNormalizedWeights();\n\n        uint256 length = weights.length;\n        uint256 temp = 1e18;\n        uint256 invariant = 1e18;\n        for(uint256 i; i < length; i++) {\n            temp = temp.mulDown(\n                (base.getPrice(tokens[i]).divDown(weights[i]))\n                .powDown(weights[i])\n            );\n            invariant = invariant.mulDown(\n                (balances[i] * 10 ** (18 - IERC20Metadata(tokens[i]).decimals()))\n                .powDown(weights[i])\n            );\n        }\n        return invariant\n            .mulDown(temp)\n            .divDown(IBalancerPool(token).totalSupply());\n    }\n\n    /// @dev Checks for reentrancy by calling a no-op function on the Balancer Vault.\n    ///      This is a preventative measure against potential reentrancy attacks.\n    /// @param vault The Balancer Vault contract instance.\n    function checkReentrancy(IBalancerVault vault) internal {\n        vault.manageUserBalance(new IBalancerVault.UserBalanceOp[](0));\n    }\n}"
    }
  ]
}