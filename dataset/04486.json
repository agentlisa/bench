{
  "Title": "There are magic constants in theÂ code",
  "Content": "There are magic constants in several Solo contracts. For example, [Require.sol, line 203](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/lib/Require.sol#L203) and [Require.sol, line 207](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/lib/Require.sol#L207). These values make the code harder to understand and to maintain.\n\n\nConsider defining a constant variable for every hard-coded value (including booleans), giving it a clear and explanatory name. For complex values, consider adding a comment explaining how they were calculated or why they were chosen.\n\n\n***Update:*** *Comments were added to the constants in* [*pull request #233*](https://github.com/dydxprotocol/solo/pull/233)*.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/protocol/lib/Require.sol",
      "content": "/*\n\n    Copyright 2018 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.4;\n\n\n/**\n * @title Require\n * @author dYdX\n *\n * Stringifies parameters to pretty-print revert messages. Costs more gas than regular require()\n */\nlibrary Require {\n\n    // ============ Constants ============\n\n    uint256 constant ASCII_ZERO = 48; // '0'\n    uint256 constant ASCII_RELATIVE_ZERO = 87; // 'a' - 10\n    uint256 constant ASCII_LOWER_EX = 120; // 'x'\n    bytes2 constant COLON = 0x3a20; // ': '\n    bytes2 constant COMMA = 0x2c20; // ', '\n    bytes2 constant LPAREN = 0x203c; // ' <'\n    byte constant RPAREN = 0x3e; // '>'\n\n    // ============ Library Functions ============\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringify(file),\n                        COLON,\n                        stringify(reason)\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        uint256 payloadA\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringify(file),\n                        COLON,\n                        stringify(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        uint256 payloadA,\n        uint256 payloadB\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringify(file),\n                        COLON,\n                        stringify(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        COMMA,\n                        stringify(payloadB),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        address payloadA\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringify(file),\n                        COLON,\n                        stringify(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    // ============ Private Functions ============\n\n    function stringify(\n        bytes32 b\n    )\n        private\n        pure\n        returns (bytes memory)\n    {\n        bytes memory r = abi.encodePacked(b);\n        for (uint256 i = 0; i < 32; i++) {\n            if (r[i] == 0) {\n                /* solium-disable-next-line security/no-inline-assembly */\n                assembly {\n                    mstore(r, i) // r.length = i;\n                }\n                return r;\n            }\n        }\n        return r;\n    }\n\n    function stringify(\n        uint256 i\n    )\n        private\n        pure\n        returns (bytes memory)\n    {\n        if (i == 0) {\n            return \"0\";\n        }\n\n        // get length\n        uint256 j = i;\n        uint256 length;\n        while (j != 0) {\n            length++;\n            j /= 10;\n        }\n\n        // get string\n        j = i;\n        bytes memory bstr = new bytes(length);\n        uint256 k = length - 1;\n        while (j != 0) {\n            bstr[k--] = byte(uint8(ASCII_ZERO + (j % 10)));\n            j /= 10;\n        }\n\n        return bstr;\n    }\n\n    function stringify(\n        address a\n    )\n        private\n        pure\n        returns (bytes memory)\n    {\n        uint256 z = uint256(a);\n\n        bytes memory result = new bytes(42);\n        result[0] = byte(uint8(ASCII_ZERO));\n        result[1] = byte(uint8(ASCII_LOWER_EX));\n\n        for (uint256 i = 0; i < 20; i++) {\n            uint256 shift = i * 2;\n            result[41 - shift] = char(z & 0xf);\n            z = z >> 4;\n            result[40 - shift] = char(z & 0xf);\n            z = z >> 4;\n        }\n\n        return result;\n    }\n\n    function char(\n        uint256 b\n    )\n        private\n        pure\n        returns (byte)\n    {\n        if (b < 10) {\n            return byte(uint8(b + ASCII_ZERO));\n        }\n        return byte(uint8(b + ASCII_RELATIVE_ZERO));\n    }\n}"
    }
  ]
}