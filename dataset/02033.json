{
  "Title": "Misleading behavior of ManualKey functionality",
  "Content": "ink! smart contracts include the [`ManualKey`](https://github.com/paritytech/ink/blob/ad4f5e579e39926704e182736af4fa945982ac2b/crates/storage/traits/src/impls/mod.rs#L50) feature, which allows developers to specify the value of the key for a Mapping or a Lazy collection. However, a potential issue with this feature is that the key can be set to zero in the code while appearing as a different value in the metadata, leading to confusion and possible errors.\n\n\nTo avoid this issue, it may be worth disallowing users from setting the key of a variable to 0 when using ManualKey. Since developers may rely on the value specified in the code, this change could prevent confusion and improve the reliability of the code.\n\n\n***Update:** Resolved in [pull request #1670](https://github.com/paritytech/ink/pull/1670) at commit [63c846d](https://github.com/paritytech/ink/pull/1670/commits/63c846d8c0e274cc3ff483818ad6c8dcbf7e6c41).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "crates/storage/traits/src/impls/mod.rs",
      "content": "// Copyright 2018-2022 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::{\n    AutoStorableHint,\n    Packed,\n    StorableHint,\n    StorageKey,\n};\nuse core::{\n    fmt::Debug,\n    marker::PhantomData,\n};\nuse ink_primitives::{\n    Key,\n    KeyComposer,\n};\n\n/// Auto key type means that the storage key should be calculated automatically.\n#[derive(Default, Copy, Clone, PartialEq, Eq, PartialOrd)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\npub struct AutoKey;\n\nimpl StorageKey for AutoKey {\n    const KEY: Key = 0;\n}\n\nimpl Debug for AutoKey {\n    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n        f.debug_struct(\"AutoKey\")\n            .field(\"key\", &<Self as StorageKey>::KEY)\n            .finish()\n    }\n}\n\n/// Manual key type specifies the storage key.\n#[derive(Default, Copy, Clone, Eq, PartialEq, PartialOrd)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\npub struct ManualKey<const KEY: Key, ParentKey: StorageKey = ()>(\n    PhantomData<fn() -> ParentKey>,\n);\n\nimpl<const KEY: Key, ParentKey: StorageKey> StorageKey for ManualKey<KEY, ParentKey> {\n    const KEY: Key = KeyComposer::concat(KEY, ParentKey::KEY);\n}\n\nimpl<const KEY: Key, ParentKey: StorageKey> Debug for ManualKey<KEY, ParentKey> {\n    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n        f.debug_struct(\"ManualKey\")\n            .field(\"key\", &<Self as StorageKey>::KEY)\n            .finish()\n    }\n}\n\n/// Resolver key type selects between preferred key and autogenerated key.\n/// If the `L` type is `AutoKey` it returns auto-generated `R` else `L`.\n#[derive(Default, Copy, Clone, PartialEq, Eq, PartialOrd, Debug)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\npub struct ResolverKey<L: StorageKey, R: StorageKey>(PhantomData<fn() -> (L, R)>);\n\nimpl<L: StorageKey, R: StorageKey> StorageKey for ResolverKey<L, R> {\n    /// `KEY` of the `AutoKey` is zero. If left key is zero, then use right manual key.\n    const KEY: Key = if L::KEY == 0 { R::KEY } else { L::KEY };\n}\n\ntype FinalKey<T, const KEY: Key, ParentKey> =\n    ResolverKey<<T as StorableHint<ParentKey>>::PreferredKey, ManualKey<KEY, ParentKey>>;\n\n// `AutoStorableHint` trait figures out that storage key it should use.\n// - If the `PreferredKey` is `AutoKey` it will use an auto-generated key passed as generic\n// into `AutoStorableHint`.\n// - If `PreferredKey` is `ManualKey`, then it will use it.\nimpl<T, const KEY: Key, ParentKey> AutoStorableHint<ManualKey<KEY, ParentKey>> for T\nwhere\n    T: StorableHint<ParentKey>,\n    T: StorableHint<FinalKey<T, KEY, ParentKey>>,\n    ParentKey: StorageKey,\n{\n    type Type = <T as StorableHint<FinalKey<T, KEY, ParentKey>>>::Type;\n}\n\nimpl<P> super::storage::private::Sealed for P where P: scale::Decode + scale::Encode {}\nimpl<P> Packed for P where P: scale::Decode + scale::Encode {}\n\nimpl<P> StorageKey for P\nwhere\n    P: Packed,\n{\n    const KEY: Key = 0;\n}\n\nimpl<P, Key> StorableHint<Key> for P\nwhere\n    P: Packed,\n    Key: StorageKey,\n{\n    type Type = P;\n    type PreferredKey = AutoKey;\n}\n\n#[cfg(test)]\nmod tests {\n    /// Creates test to verify that the primitive types are packed.\n    #[macro_export]\n    macro_rules! storage_hint_works_for_primitive {\n        ( $ty:ty ) => {\n            paste::item! {\n                #[test]\n                #[allow(non_snake_case)]\n                fn [<$ty _storage_hint_works>] () {\n                    assert_eq!(\n                        ::core::any::TypeId::of::<$ty>(),\n                        ::core::any::TypeId::of::<<$ty as $crate::StorableHint<$crate::ManualKey<123>>>::Type>()\n                    );\n                }\n            }\n        };\n    }\n    mod arrays {\n        use crate::storage_hint_works_for_primitive;\n\n        type Array = [i32; 4];\n        storage_hint_works_for_primitive!(Array);\n\n        type ArrayTuples = [(i32, i32); 2];\n        storage_hint_works_for_primitive!(ArrayTuples);\n    }\n\n    mod prims {\n        use crate::storage_hint_works_for_primitive;\n        use ink_primitives::AccountId;\n\n        storage_hint_works_for_primitive!(bool);\n        storage_hint_works_for_primitive!(String);\n        storage_hint_works_for_primitive!(AccountId);\n        storage_hint_works_for_primitive!(i8);\n        storage_hint_works_for_primitive!(i16);\n        storage_hint_works_for_primitive!(i32);\n        storage_hint_works_for_primitive!(i64);\n        storage_hint_works_for_primitive!(i128);\n        storage_hint_works_for_primitive!(u8);\n        storage_hint_works_for_primitive!(u16);\n        storage_hint_works_for_primitive!(u32);\n        storage_hint_works_for_primitive!(u64);\n        storage_hint_works_for_primitive!(u128);\n\n        type OptionU8 = Option<u8>;\n        storage_hint_works_for_primitive!(OptionU8);\n\n        type ResultU8 = Result<u8, bool>;\n        storage_hint_works_for_primitive!(ResultU8);\n\n        type BoxU8 = Box<u8>;\n        storage_hint_works_for_primitive!(BoxU8);\n\n        type BoxOptionU8 = Box<Option<u8>>;\n        storage_hint_works_for_primitive!(BoxOptionU8);\n    }\n\n    mod tuples {\n        use crate::storage_hint_works_for_primitive;\n\n        type TupleSix = (i32, u32, String, u8, bool, Box<Option<i32>>);\n        storage_hint_works_for_primitive!(TupleSix);\n    }\n}"
    }
  ]
}