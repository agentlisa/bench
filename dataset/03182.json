{
  "Title": "[L05] Incorrect balance check comparison in TokenPaymaster [sample]",
  "Content": "In the `TokenPaymaster` contract, the `validatePaymasterUserOp` function performs a check to verify that the sender’s token balance is sufficient to pay the `tokenPrefund` cost for the user operation. In [both cases](https://github.com/eth-infinitism/account-abstraction/blob/8832d6e04b9f4f706f612261c6e46b3f1745d61a/contracts/samples/TokenPaymaster.sol#L60-L63) where this check occurs in the function, `>` is used for the comparison when `>=` should also be valid. A user could have exactly the required prefund amount and still fail to pass validation.\n\n\nConsider modifying the balance checks to support the case where the user’s token balance exactly matches the `tokenPrefund` amount.\n\n\n***Update**: Fixed in pull request [#60](https://github.com/eth-infinitism/account-abstraction/pull/60/files).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/samples/TokenPaymaster.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./SimpleWalletForTokens.sol\";\nimport \"hardhat/console.sol\";\nimport \"../BasePaymaster.sol\";\n/**\n * A sample paymaster that define itself as a token to pay for gas.\n * The paymaster IS the token to use, since a paymaster cannot use an external contract.\n * Also, the exchange rate has to be fixed, since it can't reference an external Uniswap os other exchange contract.\n * subclass should override \"getTokenToEthOutputPrice to provide actual token exchange rate, settable by the owner.\n * Known Limitation: this paymaster is exploitable when put into a batch with multiple ops (of different wallets):\n * - while a single op can't exploit the paymaster (if postOp fails to withdraw the tokens, the user's op is reverted,\n *   and then we know we can withdraw the tokens), multiple ops with different senders (all using this paymaster)\n *   in a batch can withdraw funds from 2nd and further ops, forcing the paymaster itself to pay (from its stake)\n * - Possible workarounds are either use a more complex paymaster scheme (e.g. the DepositPaymaster) or\n *   to whitelist the wallet and the called method-ids.\n */\ncontract TokenPaymaster is BasePaymaster, ERC20 {\n\n    //calculated cost of the postOp\n    uint COST_OF_POST = 15000;\n\n    bytes32 immutable knownWallet;\n\n    constructor(string memory _symbol, EntryPoint _entryPoint) ERC20(_symbol, _symbol) BasePaymaster(_entryPoint) {\n        knownWallet = _knownWallet();\n        //make it non-empty\n        _mint(address (this),1);\n        approve(owner(), type(uint).max);\n    }\n\n    // known wallet construct we support the creation of.\n    function _knownWallet() internal view virtual returns (bytes32) {\n        return keccak256(type(SimpleWallet).creationCode);\n    }\n\n    //helpers for owner, to mint and withdraw tokens.\n    function mintTokens(address recipient, uint amount) external onlyOwner {\n        _mint(recipient, amount);\n    }\n\n    //TODO: this method assumes a fixed ratio of token-to-eth. subclass should override to supply oracle\n    // or a setter.\n    function getTokenToEthOutputPrice(uint valueEth) internal view virtual returns (uint valueToken) {\n        return valueEth / 100;\n    }\n\n    // verify that the user has enough tokens.\n    function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*requestId*/, uint requiredPreFund)\n    external view override returns (bytes memory context) {\n        uint tokenPrefund = getTokenToEthOutputPrice(requiredPreFund);\n\n        // make sure that verificationGas is high enough to handle postOp\n        require(userOp.verificationGas > 16000, \"TokenPaymaster: gas too low for postOp\");\n\n        if (userOp.initCode.length != 0) {\n            _validateConstructor(userOp);\n            require(balanceOf(userOp.sender) > tokenPrefund, \"TokenPaymaster: no balance (pre-create)\");\n        } else {\n\n            require(balanceOf(userOp.sender) > tokenPrefund, \"TokenPaymaster: no balance\");\n        }\n\n        return abi.encode(userOp.sender);\n    }\n\n    // when constructing a wallet, validate constructor code and parameters\n    function _validateConstructor(UserOperation calldata userOp) internal virtual view {\n        bytes32 bytecodeHash = keccak256(userOp.initCode[0 : userOp.initCode.length - 64]);\n        require(knownWallet == bytecodeHash, \"TokenPaymaster: unknown wallet constructor\");\n\n        //verify the token constructor params:\n        // first param (of 2) should be our entryPoint\n        bytes32 entryPointParam = bytes32(userOp.initCode[userOp.initCode.length - 64 :]);\n        require(address(uint160(uint256(entryPointParam))) == address(entryPoint), \"wrong paymaster in constructor\");\n\n        //the 2nd parameter is the owner, but we don't need to validate it (it is done in validateUserOp)\n    }\n\n    //actual charge of user.\n    // this method will be called just after the user's TX with mode==OpSucceeded|OpReverted.\n    // BUT: if the user changed its balance in a way that will cause  postOp to revert, then it gets called again, after reverting\n    // the user's TX\n    function _postOp(PostOpMode mode, bytes calldata context, uint actualGasCost) internal override {\n        //we don't really care about the mode, we just pay the gas with the user's tokens.\n        (mode);\n        address sender = abi.decode(context, (address));\n        uint charge = getTokenToEthOutputPrice(actualGasCost + COST_OF_POST);\n        //actualGasCost is known to be no larger than the above requiredPreFund, so the transfer should succeed.\n        _transfer(sender, address(this), charge);\n    }\n}"
    }
  ]
}