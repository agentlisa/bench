{
  "Title": "3S-LENFT-N09 Throughout codebase: remove imports of unused libraries",
  "Content": "#### Description\nIn several files in the codebase, several libraries are imported but never used.\n\n[LendingMarket:](https://github.com/leNFT/contracts/blob/9113329743b3e0511434df51c529ed006adf043d/contracts/protocol/Lending/LendingMarket.sol#L4-L25) ILoanCenter, ERC721Upgradeable\n[LoanCenter](https://github.com/leNFT/contracts/blob/9113329743b3e0511434df51c529ed006adf043d/contracts/protocol/Lending/LoanCenter.sol#L4-L13): IERC721Upgradeable, Trustus\n[GenesisNFT](https://github.com/leNFT/contracts/blob/9113329743b3e0511434df51c529ed006adf043d/contracts/protocol/GenesisNFT.sol#L4-L27): Initializable\n[TradingPoolFactory](https://github.com/leNFT/contracts/blob/9113329743b3e0511434df51c529ed006adf043d/contracts/protocol/Trading/TradingPoolFactory.sol#L4-L15): ERC721Upgradeable\n\n#### Recommendation\nRemove the mentioned imports.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/protocol/Lending/LendingMarket.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nimport {ILendingMarket} from \"../../interfaces/ILendingMarket.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ITokenOracle} from \"../../interfaces/ITokenOracle.sol\";\nimport {LiquidationLogic} from \"../../libraries/logic/LiquidationLogic.sol\";\nimport {BorrowLogic} from \"../../libraries/logic/BorrowLogic.sol\";\nimport {DataTypes} from \"../../libraries/types/DataTypes.sol\";\nimport {ConfigTypes} from \"../../libraries/types/ConfigTypes.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IAddressProvider} from \"../../interfaces/IAddressProvider.sol\";\nimport {ILoanCenter} from \"../../interfaces/ILoanCenter.sol\";\nimport {ILendingPool} from \"../../interfaces/ILendingPool.sol\";\nimport {IERC20MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC4626Upgradeable} from \"@openzeppelin/contracts-upgradeable/interfaces/IERC4626Upgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {ERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport {ERC721HolderUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\nimport {ERC165CheckerUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {Trustus} from \"../Trustus/Trustus.sol\";\nimport {LendingPool} from \"./LendingPool.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\n\n/// @title LendingMarket Contract\n/// @author leNFT\n/// @notice This contract is the entrypoint for the leNFT lending protocol\n/// @dev Call these contract functions to interact with the lending part of the protocol\ncontract LendingMarket is\n    ILendingMarket,\n    OwnableUpgradeable,\n    ERC721HolderUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using ERC165CheckerUpgradeable for address;\n\n    // collection + asset = pool\n    mapping(address => mapping(address => address)) private _pools;\n\n    // Number of pools per asset\n    mapping(address => uint256) private _poolsCount;\n\n    // The TVL safeguard for the lending pools\n    uint256 private _tvlSafeguard;\n\n    IAddressProvider private _addressProvider;\n    ConfigTypes.LendingPoolConfig private _defaultLendingPoolConfig;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the LendingMarket contract\n    /// @param addressProvider Address of the addresses provider contract\n    /// @param tvlSafeguard The TVL safeguard for the lending pools\n    /// @param defaultLendingPoolConfig The default lending pool configuration\n    function initialize(\n        IAddressProvider addressProvider,\n        uint256 tvlSafeguard,\n        ConfigTypes.LendingPoolConfig calldata defaultLendingPoolConfig\n    ) external initializer {\n        __Ownable_init();\n        __ERC721Holder_init();\n        __ReentrancyGuard_init();\n        _addressProvider = addressProvider;\n        _tvlSafeguard = tvlSafeguard;\n        _defaultLendingPoolConfig = defaultLendingPoolConfig;\n    }\n\n    /// @notice Borrow an asset from a lending pool using an NFT as collateral\n    /// @dev NFT approval needs to be given to the LoanCenter contract\n    /// @param onBehalfOf The address of the user who will receive the borrowed tokens\n    /// @param asset The address of the asset to be borrowed\n    /// @param amount Amount of the asset to be borrowed\n    /// @param nftAddress Address of the NFT collateral\n    /// @param nftTokenIds Token id of the NFT collateral\n    /// @param genesisNFTId Token id of the genesis NFT to be used for LTV boost\n    /// @param request ID of the collateral price request sent by the trusted server\n    /// @param packet Signed collateral price request sent by the trusted server\n    function borrow(\n        address onBehalfOf,\n        address asset,\n        uint256 amount,\n        address nftAddress,\n        uint256[] memory nftTokenIds,\n        uint256 genesisNFTId,\n        bytes32 request,\n        Trustus.TrustusPacket calldata packet\n    ) external override nonReentrant {\n        BorrowLogic.borrow(\n            _addressProvider,\n            _pools[nftAddress][asset],\n            DataTypes.BorrowParams({\n                caller: msg.sender,\n                onBehalfOf: onBehalfOf,\n                asset: asset,\n                amount: amount,\n                nftAddress: nftAddress,\n                nftTokenIds: nftTokenIds,\n                genesisNFTId: genesisNFTId,\n                request: request,\n                packet: packet\n            })\n        );\n\n        emit Borrow(onBehalfOf, asset, nftAddress, nftTokenIds, amount);\n    }\n\n    /// @notice Repay an an active loan\n    /// @param loanId The ID of the loan to be paid\n    /// @param amount Amount to be repaid\n    function repay(\n        uint256 loanId,\n        uint256 amount\n    ) external override nonReentrant {\n        BorrowLogic.repay(\n            _addressProvider,\n            DataTypes.RepayParams({\n                caller: msg.sender,\n                loanId: loanId,\n                amount: amount\n            })\n        );\n\n        emit Repay(msg.sender, loanId);\n    }\n\n    /// @notice Liquidate an active loan\n    /// @dev Needs to approve WETH transfers from Market address\n    /// @param loanId The ID of the loan to be paid\n    /// @param bid The amount to bid on the collateral\n    /// @param request ID of the collateral price request sent by the trusted server\n    /// @param packet Signed collateral price request sent by the trusted server\n    function createLiquidationAuction(\n        address onBehalfOf,\n        uint256 loanId,\n        uint256 bid,\n        bytes32 request,\n        Trustus.TrustusPacket calldata packet\n    ) external override nonReentrant {\n        LiquidationLogic.createLiquidationAuction(\n            _addressProvider,\n            DataTypes.CreateAuctionParams({\n                caller: msg.sender,\n                onBehalfOf: onBehalfOf,\n                loanId: loanId,\n                bid: bid,\n                request: request,\n                packet: packet\n            })\n        );\n\n        emit CreateLiquidationAuction(onBehalfOf, loanId, bid);\n    }\n\n    /// @notice Bid on a liquidation auction\n    /// @dev Needs to approve WETH transfers from Market address\n    /// @param loanId The ID of the loan to be paid\n    /// @param bid The bid amount\n    function bidLiquidationAuction(\n        address onBehalfOf,\n        uint256 loanId,\n        uint256 bid\n    ) external override nonReentrant {\n        LiquidationLogic.bidLiquidationAuction(\n            _addressProvider,\n            DataTypes.BidAuctionParams({\n                caller: msg.sender,\n                onBehalfOf: onBehalfOf,\n                loanId: loanId,\n                bid: bid\n            })\n        );\n\n        emit BidLiquidationAuction(onBehalfOf, loanId, bid);\n    }\n\n    /// @notice Claim the collateral of a liquidated loan\n    /// @param loanId The ID of the loan to be claimmed\n    function claimLiquidation(uint256 loanId) external override nonReentrant {\n        LiquidationLogic.claimLiquidation(\n            _addressProvider,\n            DataTypes.ClaimLiquidationParams({loanId: loanId})\n        );\n        emit ClaimLiquidation(msg.sender, loanId);\n    }\n\n    /// @notice Set the lending pool address for a certain collection and asset\n    /// @param collection The collection using this lending vault\n    /// @param asset The address of the asset the lending vault controls\n    /// @param lendingPool The address of the lending pool\n    function _setLendingPool(\n        address collection,\n        address asset,\n        address lendingPool\n    ) internal {\n        _pools[collection][asset] = lendingPool;\n\n        emit SetLendingPool(collection, asset, lendingPool);\n    }\n\n    /// @notice Create a new lending vault for a certain collection\n    /// @param collection The collection using this lending pool\n    /// @param asset The address of the asset the lending pool controls\n    /// @return The address of the new lending pool\n    function createLendingPool(\n        address collection,\n        address asset\n    ) external returns (address) {\n        require(\n            collection.supportsInterface(type(IERC721Upgradeable).interfaceId),\n            \"LM:CLP:COLLECTION_NOT_NFT\"\n        );\n        require(\n            ITokenOracle(_addressProvider.getTokenOracle()).isTokenSupported(\n                asset\n            ),\n            \"LM:CLP:ASSET_NOT_SUPPORTED_TO\"\n        );\n        require(\n            IInterestRate(_addressProvider.getInterestRate()).isTokenSupported(\n                asset\n            ),\n            \"LM:CLP:ASSET_NOT_SUPPORTED_IR\"\n        );\n        require(\n            _pools[collection][asset] == address(0),\n            \"LM:CLP:LENDING_POOL_EXISTS\"\n        );\n        ILendingPool newLendingPool = new LendingPool(\n            _addressProvider,\n            owner(),\n            asset,\n            string.concat(\n                \"leNFT \",\n                IERC20MetadataUpgradeable(asset).symbol(),\n                \" Lending #\",\n                Strings.toString(_poolsCount[asset])\n            ),\n            string.concat(\n                \"leL\",\n                IERC20MetadataUpgradeable(asset).symbol(),\n                \"-\",\n                Strings.toString(_poolsCount[asset])\n            ),\n            _defaultLendingPoolConfig\n        );\n\n        // Approve lending pool use of market balance (to receive funds from claimed liquidations)\n        IERC20Upgradeable(asset).approve(address(newLendingPool), 2 ** 256 - 1);\n\n        _setLendingPool(collection, asset, address(newLendingPool));\n        _poolsCount[asset] += 1;\n\n        emit CreateLendingPool(address(newLendingPool));\n\n        return address(newLendingPool);\n    }\n\n    /// @notice Get the Lending Pool address responsible to a certain asset\n    /// @param collection The collection supported by the Lending Pool\n    /// @param asset The asset supported by the Lending Pool\n    /// @return The address of the Lending Pool\n    function getLendingPool(\n        address collection,\n        address asset\n    ) external view override returns (address) {\n        return _pools[collection][asset];\n    }\n\n    /// @notice Sets the lending pool addresses for a given collection, asset, and lending pool\n    /// @dev To be used when migrating an asset's lending pool\n    /// @param collection The collection address\n    /// @param asset The asset address\n    /// @param pool The lending pool address\n    function setLendingPool(\n        address collection,\n        address asset,\n        address pool\n    ) external onlyOwner {\n        require(\n            pool.supportsInterface(type(ILendingPool).interfaceId) ||\n                pool == address(0),\n            \"LM:SLP:NOT_POOL\"\n        );\n\n        // If setting the pool to an existing pool, make sure it's the asset is the expected one\n        if (pool != address(0)) {\n            require(\n                IERC4626Upgradeable(pool).asset() == asset,\n                \"LM:SLP:ASSET_MISMATCH\"\n            );\n        }\n        _setLendingPool(collection, asset, pool);\n    }\n\n    /// @notice Sets the default pool configuration\n    /// @param poolConfig The new pool configuration\n    function setDefaultPoolConfig(\n        ConfigTypes.LendingPoolConfig memory poolConfig\n    ) external onlyOwner {\n        _defaultLendingPoolConfig = poolConfig;\n    }\n\n    /// @notice Returns the default pool configuration\n    /// @return The default pool configuration\n    function getDefaultPoolConfig()\n        external\n        view\n        returns (ConfigTypes.LendingPoolConfig memory)\n    {\n        return _defaultLendingPoolConfig;\n    }\n\n    /// @notice Sets the TVL safeguard value\n    /// @param tvlSafeguard The new TVL safeguard value\n    function setTVLSafeguard(uint256 tvlSafeguard) external onlyOwner {\n        _tvlSafeguard = tvlSafeguard;\n    }\n\n    /// @notice Returns the current TVL safeguard value\n    /// @return The current TVL safeguard value\n    function getTVLSafeguard() external view returns (uint256) {\n        return _tvlSafeguard;\n    }\n}"
    },
    {
      "filename": "contracts/protocol/Lending/LoanCenter.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nimport {ILoanCenter} from \"../../interfaces/ILoanCenter.sol\";\nimport {PercentageMath} from \"../../libraries/utils/PercentageMath.sol\";\nimport {DataTypes} from \"../../libraries/types/DataTypes.sol\";\nimport {LoanLogic} from \"../../libraries/logic/LoanLogic.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IAddressProvider} from \"../../interfaces/IAddressProvider.sol\";\nimport {Trustus} from \"../../protocol/Trustus/Trustus.sol\";\nimport {SafeCast} from \"../../libraries/utils/SafeCast.sol\";\nimport {ILendingPool} from \"../../interfaces/ILendingPool.sol\";\n\n/// @title LoanCenter contract\n/// @author leNFT\n/// @notice Manages loans\n/// @dev Keeps the list of loans, their states and their liquidation data\ncontract LoanCenter is ILoanCenter, OwnableUpgradeable {\n    // NFT address + NFT ID to loan ID mapping\n    mapping(address => mapping(uint256 => uint256)) private _nftToLoanId;\n\n    // Loan ID to loan info mapping\n    mapping(uint256 => DataTypes.LoanData) private _loans;\n\n    // Loan id to liquidation data\n    mapping(uint256 => DataTypes.LoanLiquidationData)\n        private _loansLiquidationData;\n\n    uint256 private _loansCount;\n    IAddressProvider private _addressProvider;\n\n    // Collection to liquidation threshold\n    mapping(address => DataTypes.CollectionRiskParameters)\n        private _collectionsRiskParameters;\n\n    DataTypes.CollectionRiskParameters\n        private _defaultCollectionsRiskParameters;\n\n    // Mapping from address to active loans\n    mapping(address => uint256[]) private _activeLoans;\n\n    using LoanLogic for DataTypes.LoanData;\n\n    modifier onlyMarket() {\n        _requireOnlyMarket();\n        _;\n    }\n\n    modifier loanExists(uint256 loanId) {\n        _requireLoanExists(loanId);\n        _;\n    }\n\n    modifier loanAuctioned(uint256 loanId) {\n        _requireLoanAuctioned(loanId);\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract\n    /// @param addressProvider The address of the addressProvider contract\n    /// @param defaultCollectionsRiskParameters The default collection Risk Parameters\n    function initialize(\n        IAddressProvider addressProvider,\n        DataTypes.CollectionRiskParameters\n            calldata defaultCollectionsRiskParameters\n    ) external initializer {\n        __Ownable_init();\n        _addressProvider = addressProvider;\n        _defaultCollectionsRiskParameters = defaultCollectionsRiskParameters;\n    }\n\n    /// @notice Create a new loan with the specified parameters and add it to the loans list\n    /// @dev Only the market contract can call this function\n    /// @param borrower The address of the borrower\n    /// @param pool The address of the lending pool\n    /// @param amount The amount of the lending pool token to be borrowed\n    /// @param genesisNFTId The ID of the genesis NFT\n    /// @param nftAddress The address of the NFT contract\n    /// @param nftTokenIds An array of NFT token IDs that will be used as collateral\n    /// @param borrowRate The interest rate for the loan\n    /// @return The ID of the newly created loan\n    function createLoan(\n        address borrower,\n        address pool,\n        uint256 amount,\n        uint256 genesisNFTId,\n        address nftAddress,\n        uint256[] calldata nftTokenIds,\n        uint256 borrowRate\n    ) public override onlyMarket returns (uint256) {\n        // Create the loan and add it to the list\n        _loans[_loansCount].init(\n            borrower,\n            pool,\n            amount,\n            genesisNFTId,\n            nftAddress,\n            nftTokenIds,\n            borrowRate\n        );\n\n        // Add NFT to loanId mapping\n        for (uint256 i = 0; i < nftTokenIds.length; i++) {\n            _nftToLoanId[nftAddress][nftTokenIds[i]] = _loansCount;\n        }\n\n        // Add loan to active loans\n        _activeLoans[borrower].push(_loansCount);\n\n        // Increment the loans count and then return it\n        return _loansCount++;\n    }\n\n    /// @notice Activate a loan by setting its state to Active\n    /// @dev Only the market contract can call this function\n    /// @param loanId The ID of the loan to be activated\n    function activateLoan(uint256 loanId) external override onlyMarket {\n        // Update loan state\n        _loans[loanId].state = DataTypes.LoanState.Active;\n    }\n\n    /// @notice Repay a loan by setting its state to Repaid\n    /// @dev Only the market contract can call this function\n    /// @param loanId The ID of the loan to be repaid\n    function repayLoan(uint256 loanId) external override onlyMarket {\n        // Update loan state\n        _loans[loanId].state = DataTypes.LoanState.Repaid;\n\n        // Close the loan\n        _closeLoan(loanId);\n    }\n\n    /// @notice Liquidate a loan by setting its state to Liquidated and freeing up the NFT collateral pointers\n    /// @dev Only the market contract can call this function\n    /// @param loanId The ID of the loan to be liquidated\n    function liquidateLoan(uint256 loanId) external override onlyMarket {\n        // Update loan state\n        _loans[loanId].state = DataTypes.LoanState.Liquidated;\n\n        // Close the loan\n        _closeLoan(loanId);\n    }\n\n    /// @notice Auxiliary function to close the loan\n    /// @param loanId The ID of the loan to close\n    function _closeLoan(uint256 loanId) internal {\n        // Cache loan NFTs array\n        uint256[] memory loanTokenIds = _loans[loanId].nftTokenIds;\n        // Get loans nft mapping\n        address loanCollection = _loans[loanId].nftAsset;\n\n        // Remove nft to loan id mapping\n        for (uint256 i = 0; i < loanTokenIds.length; i++) {\n            delete _nftToLoanId[loanCollection][loanTokenIds[i]];\n        }\n\n        // Remove loan from user active loans\n        uint256[] memory userActiveLoans = _activeLoans[_loans[loanId].owner];\n        for (uint256 i = 0; i < userActiveLoans.length; i++) {\n            if (userActiveLoans[i] == loanId) {\n                _activeLoans[_loans[loanId].owner][i] = userActiveLoans[\n                    userActiveLoans.length - 1\n                ];\n                _activeLoans[_loans[loanId].owner].pop();\n                break;\n            }\n        }\n    }\n\n    /// @notice Start an auction for a loan\n    /// @dev Sets its state to Auctioned and creates the liquidation data\n    /// @dev Only the market contract can call this function\n    /// @param loanId The ID of the loan to be auctioned\n    /// @param user The address of the user who started the auction\n    /// @param bid The initial bid for the auction\n    function auctionLoan(\n        uint256 loanId,\n        address user,\n        uint256 bid\n    ) external override onlyMarket {\n        // Update state\n        _loans[loanId].state = DataTypes.LoanState.Auctioned;\n\n        // Create the liquidation data\n        _loansLiquidationData[loanId] = DataTypes.LoanLiquidationData({\n            auctioneer: user,\n            liquidator: user,\n            auctionStartTimestamp: SafeCast.toUint40(block.timestamp),\n            auctionMaxBid: bid\n        });\n    }\n\n    /// @notice Update the auction data for a loan\n    /// @dev Only the market contract can call this function\n    /// @param loanId The ID of the loan to be updated\n    /// @param user The address of the user who updated the auction\n    /// @param bid The new bid for the auction\n    function updateLoanAuctionBid(\n        uint256 loanId,\n        address user,\n        uint256 bid\n    ) external override onlyMarket {\n        // Update the liquidation data\n        _loansLiquidationData[loanId].liquidator = user;\n        _loansLiquidationData[loanId].auctionMaxBid = bid;\n    }\n\n    /// @notice Get the number of loans in the loans list\n    /// @return The number of loans\n    function getLoansCount() external view override returns (uint256) {\n        return _loansCount;\n    }\n\n    /// @notice Get the active loans for a user\n    /// @param user The address of the user\n    /// @return An array of loan IDs\n    function getUserActiveLoans(\n        address user\n    ) external view returns (uint256[] memory) {\n        return _activeLoans[user];\n    }\n\n    /// @notice Get a loan by its ID\n    /// @param loanId The ID of the loan to be retrieved\n    /// @return The loan data\n    function getLoan(\n        uint256 loanId\n    )\n        external\n        view\n        override\n        loanExists(loanId)\n        returns (DataTypes.LoanData memory)\n    {\n        return _loans[loanId];\n    }\n\n    /// @notice Get the liquidation data for a loan\n    /// @param loanId The loan ID associated with the liquidation data to be retrieved\n    function getLoanLiquidationData(\n        uint256 loanId\n    )\n        external\n        view\n        override\n        loanExists(loanId)\n        loanAuctioned(loanId)\n        returns (DataTypes.LoanLiquidationData memory)\n    {\n        return _loansLiquidationData[loanId];\n    }\n\n    /// @notice Get the maximum debt a loan can reach before entering the liquidation zone\n    /// @param loanId The ID of the loan to be queried\n    /// @param collateralPrice The price of the tokens collateralizing the loan\n    /// @return The maximum debt quoted in the same asset as the price of the collateral tokens\n    function getLoanMaxDebt(\n        uint256 loanId,\n        uint256 collateralPrice\n    ) external view override loanExists(loanId) returns (uint256) {\n        return\n            PercentageMath.percentMul(\n                collateralPrice,\n                getCollectionLiquidationThreshold(_loans[loanId].nftAsset)\n            );\n    }\n\n    /// @notice Get the loan ID associated with the specified NFT\n    /// @param nftAddress The address of the NFT contract\n    /// @param nftTokenId The ID of the NFT\n    /// @return The ID of the loan associated with the NFT\n    function getNFTLoanId(\n        address nftAddress,\n        uint256 nftTokenId\n    ) external view override returns (uint256) {\n        return _nftToLoanId[nftAddress][nftTokenId];\n    }\n\n    /// @notice Internal function to get the debt owed on a loan\n    /// @param loanId The ID of the loan\n    /// @return The total amount of debt owed on the loan\n    function _getLoanDebt(uint256 loanId) internal view returns (uint256) {\n        return\n            _loans[loanId].getInterest(block.timestamp) + _loans[loanId].amount;\n    }\n\n    /// @notice Get the debt owed on a loan\n    /// @param loanId The ID of the loan\n    /// @return The total amount of debt owed on the loan quoted in the same asset of the loan's lending pool\n    function getLoanDebt(\n        uint256 loanId\n    ) public view override loanExists(loanId) returns (uint256) {\n        return _getLoanDebt(loanId);\n    }\n\n    /// @notice Get the interest owed on a loan\n    /// @param loanId The ID of the loan\n    /// @return The amount of interest owed on the loan\n    function getLoanInterest(\n        uint256 loanId\n    ) external view override loanExists(loanId) returns (uint256) {\n        return _loans[loanId].getInterest(block.timestamp);\n    }\n\n    /// @notice Get the NFT token IDs associated with a loan\n    /// @param loanId The ID of the loan\n    /// @return An array of the NFT token IDs associated with the loan\n    function getLoanTokenIds(\n        uint256 loanId\n    ) external view override loanExists(loanId) returns (uint256[] memory) {\n        return _loans[loanId].nftTokenIds;\n    }\n\n    /// @notice Get the NFT contract address associated with a loan\n    /// @param loanId The ID of the loan\n    /// @return The address of the NFT contract associated with the loan\n    function getLoanCollectionAddress(\n        uint256 loanId\n    ) external view override loanExists(loanId) returns (address) {\n        return _loans[loanId].nftAsset;\n    }\n\n    /// @notice Get the lending pool address associated with a loan\n    /// @param loanId The ID of the loan\n    /// @return The address of the lending pool associated with the loan\n    function getLoanLendingPool(\n        uint256 loanId\n    ) external view override loanExists(loanId) returns (address) {\n        return _loans[loanId].pool;\n    }\n\n    /// @notice Get the state of a loan\n    /// @param loanId The ID of the loan\n    /// @return The state of the loan\n    function getLoanState(\n        uint256 loanId\n    ) external view override returns (DataTypes.LoanState) {\n        return _loans[loanId].state;\n    }\n\n    /// @notice Get auctioner fee for a repayment of an auctioned loan\n    /// @param loanId The ID of the loan\n    /// @return The auctioner fee\n    function getLoanAuctioneerFee(\n        uint256 loanId\n    ) external view loanExists(loanId) loanAuctioned(loanId) returns (uint256) {\n        return\n            PercentageMath.percentMul(\n                getLoanDebt(loanId),\n                ILendingPool(_loans[loanId].pool)\n                    .getPoolConfig()\n                    .auctioneerFeeRate\n            );\n    }\n\n    /// @notice Get the owner of a loan\n    /// @param loanId The ID of the loan\n    /// @return The address of the owner of the loan\n    function getLoanOwner(\n        uint256 loanId\n    ) external view loanExists(loanId) returns (address) {\n        return _loans[loanId].owner;\n    }\n\n    /// @notice Updates the debt timestamp of a loan.\n    /// @param loanId The ID of the loan to update.\n    /// @param newDebtTimestamp The new debt timestamp to set.\n    function updateLoanDebtTimestamp(\n        uint256 loanId,\n        uint256 newDebtTimestamp\n    ) external override onlyMarket {\n        _loans[loanId].debtTimestamp = uint40(newDebtTimestamp);\n    }\n\n    /// @notice Updates the amount of a loan.\n    /// @param loanId The ID of the loan to update.\n    /// @param newAmount The new amount to set.\n    function updateLoanAmount(\n        uint256 loanId,\n        uint256 newAmount\n    ) external override onlyMarket {\n        _loans[loanId].amount = newAmount;\n    }\n\n    /// @notice Gets the Liquidation Threshold for a collection.\n    /// @param collection The address of the collection to get the max collaterization price for.\n    /// @return The Liquidation Threshold for the collection (10000 = 100%).\n    function getCollectionLiquidationThreshold(\n        address collection\n    ) public view override returns (uint256) {\n        if (_collectionsRiskParameters[collection].maxLTV == 0) {\n            return _defaultCollectionsRiskParameters.liquidationThreshold;\n        }\n        return _collectionsRiskParameters[collection].liquidationThreshold;\n    }\n\n    /// @notice Gets the Max LTV for a collection, this is the maximum amount of debt that can be taken out against a collection in a borrow operation.\n    /// @param collection The address of the collection to get the max collaterization price for.\n    /// @return The Max LTV for the collection (10000 = 100%).\n    function getCollectionMaxLTV(\n        address collection\n    ) external view override returns (uint256) {\n        if (_collectionsRiskParameters[collection].maxLTV == 0) {\n            return _defaultCollectionsRiskParameters.maxLTV;\n        }\n        return _collectionsRiskParameters[collection].maxLTV;\n    }\n\n    /// @notice Changes the Risk Parameters for a collection.\n    /// @param collection The address of the collection to change the max collaterization price for.\n    /// @param maxLTV The new max LTV to set (10000 = 100%).\n    /// @param liquidationThreshold The new liquidation Threshold to set (10000 = 100%).\n    function setCollectionRiskParameters(\n        address collection,\n        uint256 maxLTV,\n        uint256 liquidationThreshold\n    ) external onlyOwner {\n        //Set the max collaterization\n        _collectionsRiskParameters[collection] = DataTypes\n            .CollectionRiskParameters({\n                maxLTV: SafeCast.toUint16(maxLTV),\n                liquidationThreshold: SafeCast.toUint16(liquidationThreshold)\n            });\n    }\n\n    function _requireOnlyMarket() internal view {\n        require(\n            msg.sender == _addressProvider.getLendingMarket(),\n            \"LC:NOT_MARKET\"\n        );\n    }\n\n    function _requireLoanExists(uint256 loanId) internal view {\n        require(\n            _loans[loanId].state != DataTypes.LoanState.None,\n            \"LC:UNEXISTENT_LOAN\"\n        );\n    }\n\n    function _requireLoanAuctioned(uint256 loanId) internal view {\n        require(\n            _loans[loanId].state == DataTypes.LoanState.Auctioned,\n            \"LC:NOT_AUCTIONED\"\n        );\n    }\n}"
    },
    {
      "filename": "contracts/protocol/GenesisNFT.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nimport {IAddressProvider} from \"../interfaces/IAddressProvider.sol\";\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport {Base64} from \"@openzeppelin/contracts/utils/Base64.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {IGenesisNFT} from \"../interfaces/IGenesisNFT.sol\";\nimport {INativeToken} from \"../interfaces/INativeToken.sol\";\nimport {IVotingEscrow} from \"../interfaces/IVotingEscrow.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {ERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport {CountersUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport {ERC721EnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {IVault} from \"@balancer-labs/v2-interfaces/contracts/vault/IVault.sol\";\nimport {WeightedPoolUserData} from \"@balancer-labs/v2-interfaces/contracts/pool-weighted/WeightedPoolUserData.sol\";\nimport {IBalancerQueries} from \"@balancer-labs/v2-interfaces/contracts/standalone-utils/IBalancerQueries.sol\";\nimport {SafeCast} from \"../libraries/utils/SafeCast.sol\";\n// solhint-disable-next-line no-global-import\nimport \"../libraries/balancer/ERC20Helpers.sol\"; // Custom (pragma ^0.8.0) ERC20 helpers for Balancer tokens\n\n/// @title GenesisNFT\n/// @author leNFT\n/// @notice This contract manages the creation and minting of Genesis NFTs\n/// @dev Interacts with a balancer pool to provide liquidty on mint\ncontract GenesisNFT is\n    ERC165Upgradeable,\n    ERC721EnumerableUpgradeable,\n    OwnableUpgradeable,\n    IGenesisNFT,\n    ReentrancyGuardUpgradeable\n{\n    uint256 private constant LP_LE_AMOUNT = 4e22; // 40000 LE\n    uint256 private constant LP_ETH_AMOUNT = 1e17; // 0.1 ETH\n    uint256 private constant MAX_CAP = 1337; // 1337 NFTs\n    uint256 private constant PRICE = 25e16; // 0.25 ETH\n    uint256 private constant MAX_LOCKTIME = 180 days;\n    uint256 private constant MIN_LOCKTIME = 14 days;\n    uint256 private constant NATIVE_TOKEN_FACTOR = 400000; // Controls the amount of native tokens minted per NFT\n\n    IAddressProvider private _addressProvider;\n    address payable private _devAddress;\n    DataTypes.BalancerDetails private _balancerDetails;\n    uint256 private _maxLTVBoost;\n    CountersUpgradeable.Counter private _tokenIdCounter;\n    // Mapping from owner to create loan operator approvals\n    mapping(address => mapping(address => bool)) private _loanOperatorApprovals;\n    // NFT to"
    }
  ]
}