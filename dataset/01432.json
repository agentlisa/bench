{
  "Title": "Malicious/Compromised organiser can reclaw all funds, stealing work from supporters",
  "Content": "# Malicious/Compromised organiser can reclaw all funds, stealing work from supporters\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-08-sparkn/blob/main/src/Distributor.sol#L116\">https://github.com/Cyfrin/2023-08-sparkn/blob/main/src/Distributor.sol#L116</a>\n\n\n## Summary\n\nThe contest details state that 'If a contest is created and funded, there is no way to refund. All the funds belong to the persons who wants to help solve the problem, we call them \"supporters\".' (see More Context section). This is untrue, as the organizer is able to refund all of the contest funds.\n\n## Vulnerability Details\n\nIn `Distributor#_distribute`, there is no input validation on the `winners` array. A malicious or compromised organizer can, with little effort, simply pass an array of length one containing a wallet address that they control as the `winners` parameter, and `[10000]` as the `percentages` parameter in order to receive 100% of the funds initially deposited to the contract. Due to the design of the protocol, they would have 7 days after the contest ends (the value of the `EXPIRATION_TIME` constant in the `ProxyFactory` contract) to perform this action without the owner being able to prevent it.\n\n## Impact\n\nMalicious/Compromised organizer can refund 100% of the contest funds, stealing work from sponsors.\n\n## Tools Used\n\nManual review\n\n## Recommendations\n\nUse a two step procedure for distributing funds:\n1. The organizer submits an array of winners and percentages to the `Proxy` contract and they are cached using storage variables\n2. The owner of `ProxyFactor` (a trusted admin) checks the arrays to ensure the organizer is not distributing all of the money to themselves, and if satisfied, triggers the distribution of funds\n\nThis removes the risk of having to trust the organizer, and although it requires the trust of the admin, they were already a required trusted party and so the mitigation is beneficial overall. Also, this new system adds more truth to the statement from the contest details mentioned in the summary section of this report.",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/cllcnja1h0001lc08z7w0orxx",
  "Code": [
    {
      "filename": "src/Distributor.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// Layout of Contract:\n// version\n// imports\n// errors\n// interfaces, libraries, contracts\n// Type declarations\n// State variables\n// Events\n// Modifiers\n// Functions\n\n// Layout of Functions:\n// constructor\n// receive function (if exists)\n// fallback function (if exists)\n// external\n// public\n// internal\n// private\n// view & pure functions\n\npragma solidity 0.8.18;\n\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport {ProxyFactory} from \"./ProxyFactory.sol\";\n\n/**\n * @title Distributor contract\n * @notice General ERC20 stable coin tokens, e.g. JPYC, USDC, USDT, DAI, etc, are suppsoed to be used in SPARKN.\n * @notice This contract is used as the implementation of proxy contracts to distribute ERC20 token(e.g. JPYC) to winners\n * @dev The main logic of prize token distribution sits in this contract waiting to be called by factory contract\n * @dev Although the contract is immutable after deployment, If we want to upgrade the implementation contract\n * we can deploy a new one and change the implementation address of proxy contract.\n */\ncontract Distributor {\n    using SafeERC20 for IERC20;\n    //////////////////////\n    /////// Error ////////\n    //////////////////////\n\n    error Distributor__InvalidCommissionFee();\n    error Distributor__NoZeroAddress();\n    error Distributor__OnlyFactoryAddressIsAllowed();\n    error Distributor__InvalidTokenAddress();\n    error Distributor__MismatchedArrays();\n    error Distributor__MismatchedPercentages();\n    error Distributor__NoTokenToDistribute();\n\n    //////////////////////////////////////\n    /////// Immutable Variables //////////\n    //////////////////////////////////////\n    /* solhint-disable */\n    uint8 private constant VERSION = 1; // version is 1 for now\n    address private immutable FACTORY_ADDRESS;\n    address private immutable STADIUM_ADDRESS;\n    uint256 private constant COMMISSION_FEE = 500; // this can be changed in the future\n    // a constant value of 10,000 (basis points) = 100%\n    uint256 private constant BASIS_POINTS = 10000;\n\n    // prize distribution event. data is for logging purpose\n    event Distributed(address token, address[] winners, uint256[] percentages, bytes data);\n\n    ////////////////////////////\n    /////// Constructor ////////\n    ////////////////////////////\n    /// @dev initiate the contract with factory address and other key addresses, fee rate\n    constructor(\n        // uint256 version, // for future use\n        address factoryAddress,\n        address stadiumAddress\n    ) \n    /* solhint-enable */\n    {\n        if (factoryAddress == address(0) || stadiumAddress == address(0)) revert Distributor__NoZeroAddress();\n        FACTORY_ADDRESS = factoryAddress; // initialize with deployed factory address beforehand\n        STADIUM_ADDRESS = stadiumAddress; // official address to receive commission fee\n    }\n\n    ////////////////////////////////////////////\n    /////// External & Public functions ////////\n    ////////////////////////////////////////////\n    /**\n     * @notice Distribute token to winners according to the percentages\n     * @dev Only factory contract can call this function\n     * @param token The token address to distribute\n     * @param winners The addresses array of winners\n     * @param percentages The percentages array of winners\n     */\n    function distribute(address token, address[] memory winners, uint256[] memory percentages, bytes memory data)\n        external\n    {\n        if (msg.sender != FACTORY_ADDRESS) {\n            revert Distributor__OnlyFactoryAddressIsAllowed();\n        }\n        _distribute(token, winners, percentages, data);\n    }\n\n    ////////////////////////////////////////////\n    /////// Internal & Private functions ///////\n    ////////////////////////////////////////////\n    /**\n     * @notice An internal function to distribute JPYC to winners\n     * @dev Main logic of distribution is implemented here. The length of winners and percentages must be the same\n     * The token address must be one of the whitelisted tokens\n     * The winners and percentages array are supposed not to be so long, so the loop can stay unbounded\n     * The total percentage must be correct. It must be (100 - COMMITION_FEE).\n     * Finally send the remained token(fee) to STADIUM_ADDRESS with no dust in the contract\n     * @param token The token address\n     * @param winners The addresses of winners\n     * @param percentages The percentages of winners\n     * @param data The data to be logged. It is supposed to be used for showing the realation bbetween winners and proposals.\n     */\n    function _distribute(address token, address[] memory winners, uint256[] memory percentages, bytes memory data)\n        internal\n    {\n        // token address input check\n        if (token == address(0)) revert Distributor__NoZeroAddress();\n        if (!_isWhiteListed(token)) {\n            revert Distributor__InvalidTokenAddress();\n        }\n        // winners and percentages input check\n        if (winners.length == 0 || winners.length != percentages.length) revert Distributor__MismatchedArrays();\n        uint256 percentagesLength = percentages.length;\n        uint256 totalPercentage;\n        for (uint256 i; i < percentagesLength;) {\n            totalPercentage += percentages[i];\n            unchecked {\n                ++i;\n            }\n        }\n        // check if totalPercentage is correct\n        if (totalPercentage != (10000 - COMMISSION_FEE)) {\n            revert Distributor__MismatchedPercentages();\n        }\n        IERC20 erc20 = IERC20(token);\n        uint256 totalAmount = erc20.balanceOf(address(this));\n\n        // if there is no token to distribute, then revert\n        if (totalAmount == 0) revert Distributor__NoTokenToDistribute();\n\n        uint256 winnersLength = winners.length; // cache length\n        for (uint256 i; i < winnersLength;) {\n            uint256 amount = totalAmount * percentages[i] / BASIS_POINTS;\n            erc20.safeTransfer(winners[i], amount);\n            unchecked {\n                ++i;\n            }\n        }\n\n        // send commission fee as well as all the remaining tokens to STADIUM_ADDRESS to avoid dust remaining\n        _commissionTransfer(erc20);\n        emit Distributed(token, winners, percentages, data);\n    }\n\n    /**\n     * @notice Transfer commission fee to STADIUM_ADDRESS\n     * @dev This internal function is called after distribution in `_distribute` function\n     * @param token The token address\n     */\n    function _commissionTransfer(IERC20 token) internal {\n        token.safeTransfer(STADIUM_ADDRESS, token.balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Check if the token is whitelisted. calling FACTORY_ADDRESS\n     * @param token The token address\n     * @return true if the token is whitelisted, vice versa\n     */\n    function _isWhiteListed(address token) internal view returns (bool) {\n        return ProxyFactory(FACTORY_ADDRESS).whitelistedTokens(token);\n    }\n\n    ///////////////////////////////////////////\n    /////// Getter pure/view functions ////////\n    ///////////////////////////////////////////\n    /**\n     * @notice returns all the immutable and constant addresses and values\n     * @dev This function is for convenience to check the addresses and values\n     */\n    function getConstants()\n        external\n        view\n        returns (address _FACTORY_ADDRESS, address _STADIUM_ADDRESS, uint256 _COMMISSION_FEE, uint8 _VERSION)\n    {\n        /* solhint-disable */\n        _FACTORY_ADDRESS = FACTORY_ADDRESS;\n        _STADIUM_ADDRESS = STADIUM_ADDRESS;\n        _COMMISSION_FEE = COMMISSION_FEE;\n        _VERSION = VERSION;\n        /* solhint-enable */\n    }\n}"
    }
  ]
}