{
  "Title": "[M-03] THE first AMM Staker may not receive according rewards because of poor checkpoints",
  "Content": "_Submitted by 0xNineDec_\n\n<https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L56>\n\n<https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L140>\n\n### Impact\n\nThe first staker within the `AmmGauge` may not get the rewards if the pool is not checkpointed right after he stakes and before he wants to claim the rewards.\n\n### Proof of Concept\n\nA testing environment that reproduces how the protocol is going to be deployed and managed is used to evaluate this case under the following assumptions and simplifications.\n\n1.  The inflation rate is fixed for simplicity (`0.001`).\n2.  For the testing environment performed by the team, a DummyERC20 was used as testing token. The same is done on the exploit environment.\n3.  The minting of tokens impact both on the inflation calculation and their balance. But this test evaluates the states just before minting (claimable balances). Following how the pools are updated, they are checkpointed in the end of the `_executeInflationRateUpdate` call. Not while staking.\n\nIn order to illustrate this scenario we will show both the vulnerable and non vulnerable situations.\n\nVulnerable Situation:\n\n1.  Alice, Bob, Charlie and David are future users of the pool. They all notice the inception of this project and decide to stake.\n2.  They all stake the same amount. Their transactions are mined with 1min of difference starting from Alice and finishing with David.\n3.  There is no external pool checkpoint between Alice and Bob (besides the one that is triggered when Bob stakes).\n4.  Sometime happens and they all want to check their accumulated reward balance. Alice accumulated much less than the others.\n\nNon Vulnerable Situation:\n\n*   The same as before but calling externally `_poolCheckpoint()` between Alice stake call and Bobs' and before checking the accumulated rewards.\n\nThe code to show this has a `secureCheckpoints` toggle that can be set as true or false to trigger (or not) the intermediate poolCheckpoints.\n\n        it('First Staker Rewards Calculation', async function () { \n            \n            let secureCheckpoints = false;\n            let currentShare, currentStakedIntegral, balances;\n            await this.ammgauge.poolCheckpoint();\n            await ethers.provider.send(\"evm_increaseTime\", [1 * 24 * 60 * 60]); // 10 days\n            \n            const updateStates = async (from) => { \n                currentShare = await this.ammgauge.perUserShare(from.address);\n                currentStakedIntegral = await this.ammgauge.perUserStakedIntegral(from.address);\n                balances = await this.ammgauge.balances(from.address);\n            }\n\n            const stake = async (to, amount) => {\n                await updateStates(to)\n                console.log(\" \")\n                // Balance before\n                let balanceBefore = await this.ammgauge.balances(to.address);\n                // Stake\n                await this.ammgauge.connect(to).stake(amount);\n                expect(await this.ammgauge.balances(to.address)).to.be.eq(balanceBefore.add(amount));\n                await updateStates(to);\n                console.log(\" \")\n            }\n\n            const unstake = async (to, amount) => {\n                await updateStates(to)\n                console.log(\" \")\n                // Balance before\n                let balanceBefore = await this.ammgauge.balances(to.address);\n                // Stake\n                await this.ammgauge.connect(to).unstake(amount);\n                expect(await this.ammgauge.balances(to.address)).to.be.eq(balanceBefore.sub(amount));\n                await updateStates(to);\n                console.log(\" \")\n            }\n\n            // Each user stakes tokens\n            let initialStaking = ethers.utils.parseEther(\"10\")\n            console.log(\" \")\n            console.log(\"USERS STAKE\");\n            for (const user of users) {\n            await stake(user, initialStaking)\n            if(secureCheckpoints){await this.ammgauge.poolCheckpoint()};\n            await ethers.provider.send(\"evm_increaseTime\", [60 * 60]); // 1hr between stakes\n            }\n            console.log(\" \")\n\n            await ethers.provider.send(\"evm_increaseTime\", [ 5 * 24 * 60 * 60]); // 5 days\n            if(secureCheckpoints){await this.ammgauge.poolCheckpoint()};\n\n            let claimableRewards = [];\n            let claimedRewards = [];\n            console.log(\" \")\n            console.log(\"USERS CLAIMABLE REWARDS AFTER 5 days\");\n            console.log(\" \")\n            for (const user of users) {\n                let stepClaimable = await this.ammgauge.claimableRewards(user.address);\n                claimableRewards.push(ethers.utils.formatEther(stepClaimable))\n\n                let rewardsClaim = await (await this.ammgauge.claimRewards(user.address)).wait()\n                claimedRewards.push(ethers.utils.formatEther(rewardsClaim.logs[0][\"data\"]))\n            }\n\n            console.log(\"Claimable calculated\")\n            console.log(\"   ALICE - BOB -  CHARLIE - DAVID\")\n            console.log(claimableRewards)\n\n            console.log(\" \")\n            console.log(\"Effectively Claimed\")\n            console.log(\"   ALICE - BOB -  CHARLIE - DAVID\")\n            console.log(claimableRewards)\n        })\n\nThe outputs for both cases are shown on the following chart. The initial staking amount is 10eth amount of the DummyERC20 token.\n\n|         | Without Checkpoints | With Checkpoints |\n| :-----: | :-----------------: | :--------------: |\n|  Alice  |         6.6         |       115.5      |\n|   Bob   |        111.9        |       111.9      |\n| Charlie |        110.1        |       110.1      |\n|  David  |        108.9        |       108.9      |\n\n### Recommended Mitigation Steps\n\n*   Check how is calculated the staking variables while the pool has no tokens staked and also how the updates and checkpoints are performed.\n\n**[chase-manning (Backd) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-05-backd-findings/issues/111#issuecomment-1148642951):**\n > This can only impact one user and only in an edge case so should be Medium severity.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-05-backd-findings/issues/111#issuecomment-1159748160):**\n > The warden has shown how the first depositor may end up not getting the correct amount of points due to how zero is handled in `poolCheckpoint`\n> \n> Am not fully confident this should be kept separate from [M-02](https://github.com/code-423n4/2022-05-backd-findings/issues/100).\n> \n> However at this time, I believe the finding to be of Medium Severity.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-05-backd-findings/issues/111#issuecomment-1172523467):**\n > At this time, while the underlying solution may be the same, I believe this finding and [M-02](https://github.com/code-423n4/2022-05-backd-findings/issues/100) to be distinct.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-backd-tokenomics-contest",
  "Code": [
    {
      "filename": "protocol/contracts/tokenomics/AmmGauge.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/tokenomics/IAmmGauge.sol\";\n\nimport \"../../libraries/ScaledMath.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/AddressProviderHelpers.sol\";\n\nimport \"../access/Authorization.sol\";\n\ncontract AmmGauge is Authorization, IAmmGauge {\n    using AddressProviderHelpers for IAddressProvider;\n    using ScaledMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IController public immutable controller;\n\n    mapping(address => uint256) public balances;\n\n    // All the data fields required for the staking tracking\n    uint256 public ammStakedIntegral;\n    uint256 public totalStaked;\n    mapping(address => uint256) public perUserStakedIntegral;\n    mapping(address => uint256) public perUserShare;\n\n    address public immutable ammToken;\n    bool public killed;\n    uint48 public ammLastUpdated;\n\n    event RewardClaimed(address indexed account, uint256 amount);\n\n    constructor(IController _controller, address _ammToken)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        ammToken = _ammToken;\n        controller = _controller;\n        ammLastUpdated = uint48(block.timestamp);\n    }\n\n    /**\n     * @notice Shut down the gauge.\n     * @dev Accrued inflation can still be claimed from the gauge after shutdown.\n     * @return `true` if successful.\n     */\n    function kill() external override returns (bool) {\n        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);\n        poolCheckpoint();\n        killed = true;\n        return true;\n    }\n\n    function claimRewards(address beneficiary) external virtual override returns (uint256) {\n        require(\n            msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender),\n            Error.UNAUTHORIZED_ACCESS\n        );\n        _userCheckpoint(beneficiary);\n        uint256 amount = perUserShare[beneficiary];\n        if (amount <= 0) return 0;\n        perUserShare[beneficiary] = 0;\n        controller.inflationManager().mintRewards(beneficiary, amount);\n        emit RewardClaimed(beneficiary, amount);\n        return amount;\n    }\n\n    function stake(uint256 amount) external virtual override returns (bool) {\n        return stakeFor(msg.sender, amount);\n    }\n\n    function unstake(uint256 amount) external virtual override returns (bool) {\n        return unstakeFor(msg.sender, amount);\n    }\n\n    function getAmmToken() external view override returns (address) {\n        return ammToken;\n    }\n\n    function isAmmToken(address token) external view override returns (bool) {\n        return token == ammToken;\n    }\n\n    function claimableRewards(address user) external view virtual override returns (uint256) {\n        uint256 ammStakedIntegral_ = ammStakedIntegral;\n        if (!killed && totalStaked > 0) {\n            ammStakedIntegral_ += (controller.inflationManager().getAmmRateForToken(ammToken) *\n                (block.timestamp - uint256(ammLastUpdated))).scaledDiv(totalStaked);\n        }\n        return\n            perUserShare[user] +\n            balances[user].scaledMul(ammStakedIntegral_ - perUserStakedIntegral[user]);\n    }\n\n    /**\n     * @notice Stake amount of AMM token on behalf of another account.\n     * @param account Account for which tokens will be staked.\n     * @param amount Amount of token to stake.\n     * @return `true` if success.\n     */\n    function stakeFor(address account, uint256 amount) public virtual override returns (bool) {\n        require(amount > 0, Error.INVALID_AMOUNT);\n\n        _userCheckpoint(account);\n\n        uint256 oldBal = IERC20(ammToken).balanceOf(address(this));\n        IERC20(ammToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = IERC20(ammToken).balanceOf(address(this));\n        uint256 staked = newBal - oldBal;\n        balances[account] += staked;\n        totalStaked += staked;\n        emit AmmStaked(account, ammToken, amount);\n        return true;\n    }\n\n    /**\n     * @notice Unstake amount of AMM token and send to another account.\n     * @param dst Account to which unstaked AMM tokens will be sent.\n     * @param amount Amount of token to unstake.\n     * @return `true` if success.\n     */\n    function unstakeFor(address dst, uint256 amount) public virtual override returns (bool) {\n        require(amount > 0, Error.INVALID_AMOUNT);\n        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE);\n\n        _userCheckpoint(msg.sender);\n\n        uint256 oldBal = IERC20(ammToken).balanceOf(address(this));\n        IERC20(ammToken).safeTransfer(dst, amount);\n        uint256 newBal = IERC20(ammToken).balanceOf(address(this));\n        uint256 unstaked = oldBal - newBal;\n        balances[msg.sender] -= unstaked;\n        totalStaked -= unstaked;\n        emit AmmUnstaked(msg.sender, ammToken, amount);\n        return true;\n    }\n\n    function poolCheckpoint() public virtual override returns (bool) {\n        if (killed) {\n            return false;\n        }\n        uint256 currentRate = controller.inflationManager().getAmmRateForToken(ammToken);\n        // Update the integral of total token supply for the pool\n        uint256 timeElapsed = block.timestamp - uint256(ammLastUpdated);\n        if (totalStaked > 0) {\n            ammStakedIntegral += (currentRate * timeElapsed).scaledDiv(totalStaked);\n        }\n        ammLastUpdated = uint48(block.timestamp);\n        return true;\n    }\n\n    function _userCheckpoint(address user) internal virtual returns (bool) {\n        poolCheckpoint();\n        perUserShare[user] += balances[user].scaledMul(\n            ammStakedIntegral - perUserStakedIntegral[user]\n        );\n        perUserStakedIntegral[user] = ammStakedIntegral;\n        return true;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/tokenomics/AmmGauge.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/tokenomics/IAmmGauge.sol\";\n\nimport \"../../libraries/ScaledMath.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/AddressProviderHelpers.sol\";\n\nimport \"../access/Authorization.sol\";\n\ncontract AmmGauge is Authorization, IAmmGauge {\n    using AddressProviderHelpers for IAddressProvider;\n    using ScaledMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IController public immutable controller;\n\n    mapping(address => uint256) public balances;\n\n    // All the data fields required for the staking tracking\n    uint256 public ammStakedIntegral;\n    uint256 public totalStaked;\n    mapping(address => uint256) public perUserStakedIntegral;\n    mapping(address => uint256) public perUserShare;\n\n    address public immutable ammToken;\n    bool public killed;\n    uint48 public ammLastUpdated;\n\n    event RewardClaimed(address indexed account, uint256 amount);\n\n    constructor(IController _controller, address _ammToken)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        ammToken = _ammToken;\n        controller = _controller;\n        ammLastUpdated = uint48(block.timestamp);\n    }\n\n    /**\n     * @notice Shut down the gauge.\n     * @dev Accrued inflation can still be claimed from the gauge after shutdown.\n     * @return `true` if successful.\n     */\n    function kill() external override returns (bool) {\n        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);\n        poolCheckpoint();\n        killed = true;\n        return true;\n    }\n\n    function claimRewards(address beneficiary) external virtual override returns (uint256) {\n        require(\n            msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender),\n            Error.UNAUTHORIZED_ACCESS\n        );\n        _userCheckpoint(beneficiary);\n        uint256 amount = perUserShare[beneficiary];\n        if (amount <= 0) return 0;\n        perUserShare[beneficiary] = 0;\n        controller.inflationManager().mintRewards(beneficiary, amount);\n        emit RewardClaimed(beneficiary, amount);\n        return amount;\n    }\n\n    function stake(uint256 amount) external virtual override returns (bool) {\n        return stakeFor(msg.sender, amount);\n    }\n\n    function unstake(uint256 amount) external virtual override returns (bool) {\n        return unstakeFor(msg.sender, amount);\n    }\n\n    function getAmmToken() external view override returns (address) {\n        return ammToken;\n    }\n\n    function isAmmToken(address token) external view override returns (bool) {\n        return token == ammToken;\n    }\n\n    function claimableRewards(address user) external view virtual override returns (uint256) {\n        uint256 ammStakedIntegral_ = ammStakedIntegral;\n        if (!killed && totalStaked > 0) {\n            ammStakedIntegral_ += (controller.inflationManager().getAmmRateForToken(ammToken) *\n                (block.timestamp - uint256(ammLastUpdated))).scaledDiv(totalStaked);\n        }\n        return\n            perUserShare[user] +\n            balances[user].scaledMul(ammStakedIntegral_ - perUserStakedIntegral[user]);\n    }\n\n    /**\n     * @notice Stake amount of AMM token on behalf of another account.\n     * @param account Account for which tokens will be staked.\n     * @param amount Amount of token to stake.\n     * @return `true` if success.\n     */\n    function stakeFor(address account, uint256 amount) public virtual override returns (bool) {\n        require(amount > 0, Error.INVALID_AMOUNT);\n\n        _userCheckpoint(account);\n\n        uint256 oldBal = IERC20(ammToken).balanceOf(address(this));\n        IERC20(ammToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = IERC20(ammToken).balanceOf(address(this));\n        uint256 staked = newBal - oldBal;\n        balances[account] += staked;\n        totalStaked += staked;\n        emit AmmStaked(account, ammToken, amount);\n        return true;\n    }\n\n    /**\n     * @notice Unstake amount of AMM token and send to another account.\n     * @param dst Account to which unstaked AMM tokens will be sent.\n     * @param amount Amount of token to unstake.\n     * @return `true` if success.\n     */\n    function unstakeFor(address dst, uint256 amount) public virtual override returns (bool) {\n        require(amount > 0, Error.INVALID_AMOUNT);\n        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE);\n\n        _userCheckpoint(msg.sender);\n\n        uint256 oldBal = IERC20(ammToken).balanceOf(address(this));\n        IERC20(ammToken).safeTransfer(dst, amount);\n        uint256 newBal = IERC20(ammToken).balanceOf(address(this));\n        uint256 unstaked = oldBal - newBal;\n        balances[msg.sender] -= unstaked;\n        totalStaked -= unstaked;\n        emit AmmUnstaked(msg.sender, ammToken, amount);\n        return true;\n    }\n\n    function poolCheckpoint() public virtual override returns (bool) {\n        if (killed) {\n            return false;\n        }\n        uint256 currentRate = controller.inflationManager().getAmmRateForToken(ammToken);\n        // Update the integral of total token supply for the pool\n        uint256 timeElapsed = block.timestamp - uint256(ammLastUpdated);\n        if (totalStaked > 0) {\n            ammStakedIntegral += (currentRate * timeElapsed).scaledDiv(totalStaked);\n        }\n        ammLastUpdated = uint48(block.timestamp);\n        return true;\n    }\n\n    function _userCheckpoint(address user) internal virtual returns (bool) {\n        poolCheckpoint();\n        perUserShare[user] += balances[user].scaledMul(\n            ammStakedIntegral - perUserStakedIntegral[user]\n        );\n        perUserStakedIntegral[user] = ammStakedIntegral;\n        return true;\n    }\n}"
    }
  ]
}