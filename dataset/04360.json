{
  "Title": "[H01] Implementation of EIP 777 does not fully match the specification",
  "Content": "The following mismatches between the [EIP 777 specification](https://eips.ethereum.org/EIPS/eip-777) and the related implementation contracts (*i.e.* [`ERC777Token`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777Token.sol), [`ERC777BaseToken`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777BaseToken.sol), [`ERC777TokensRecipient`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777TokensRecipient.sol) and [`ERC777TokensSender`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777TokensSender.sol)) were identified.\n\n\n* In [`ERC777Token`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777Token.sol), the following functions are missing from the ERC777 interface: `name()`, `symbol()`, `totalSupply()`, `balanceOf(address)`, `granularity()`, `burn(uint256,bytes)` and `operatorBurn(address,uint256,bytes,bytes)`. It is worth highlighting that `burn(uint256,bytes)` and `operatorBurn(address,uint256,bytes,bytes)` are the only functions never implemented in child contracts.\n* In [`ERC777Token`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777Token.sol), [`ERC777TokensSender`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777TokensSender.sol) and [`ERC777TokensRecipient`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777TokensRecipient.sol), all function and event parameters defined as type `bytes32` should be defined as `bytes`.\n* In [`ERC777Token`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777Token.sol), the `authorizeOperator(address)`, `revokeOperator(address)`, `send(address,uint256,bytes)` and `operatorSend(address,address,uint256,bytes,bytes)` functions return a success `bool` while the EIP 777 standard does not specify a return value for any of those functions.\n* The [`ERC777BaseToken`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777BaseToken.sol) [contract](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777BaseToken.sol) does not implement the `burn(uint256,bytes)` and `operatorBurn(address,uint256,bytes,bytes)` functions, which as mentioned, are missing from the [`ERC777Token`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777Token.sol) interface. Augur developers acknowledge this situation in [an inline comment](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777Token.sol#L17).\n* The [`ERC777BaseToken`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777BaseToken.sol) [contract](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777BaseToken.sol) implements a public [`sendNoHooks`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777BaseToken.sol#L49) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777BaseToken.sol#L49) that allows the caller to transfer tokens bypassing the `tokensReceived` and `tokensToSend` hooks of the sender and receiver, a feature [completely opposite to the EIP 777 specification](https://eips.ethereum.org/EIPS/eip-777#sending-tokens).\n* The [`mint`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/VariableSupplyToken.sol#L13) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/VariableSupplyToken.sol#L13) of `VariableSupplyToken` does not call the [`callRecipient`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777BaseToken.sol#L122) function of `ERC777BaseToken`, thus never calling the receiver’s `tokensReceived` hook. According to [the EIP 777 spec](https://eips.ethereum.org/EIPS/eip-777#minting-tokens), calling such hook is a MUST when minting tokens.\n* The [`Minted`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777Token.sol#L29) [event](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777Token.sol#L29) defined in `ERC777Token` is never emitted when minting tokens in the [`mint`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/VariableSupplyToken.sol#L13) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/VariableSupplyToken.sol#L13) of `VariableSupplyToken`. According to [the EIP 777 spec](https://eips.ethereum.org/EIPS/eip-777#minting-tokens), emitting such event is a MUST when minting tokens.\n* According to the spec, the `tokensToSend` hook MUST be called *before* the token’s state is updated. Similarly, the `tokensReceived` hook MUST be called *after* the token’s state is updated. However, the function [`transferFrom`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/StandardToken.sol#L26) of the `StandardToken` contract [modifies the token’s state](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/StandardToken.sol#L31) (*i.e.* the allowances) before the `tokensToSend` hook is called.\n\n\nMany of these particular noncompliances seem to be known by Augur’s development team, who still decided to move forward with their custom implementation of EIP 777. This kind of decisions come with trade-offs. While the deviations from the spec may be more suitable for the Augur protocol, they might potentially cause errors in clients interacting with Augur that expect a fully-compliant implementation of the EIP 777. Therefore, it is advisable to either avoid calling the implemented token ERC777 altogether (its similarities and differences with the standard spec could be described in end-user documentation), or instead fully comply with the EIP’s specification by following [OpenZeppelin’s ERC777 implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/v2.3.0/contracts/token/ERC777), released in the 2.3.0 version.\n\n\n***Update:*** *in an* [*attempt to fix*](https://github.com/AugurProject/augur/pull/2510) *this issue, where the* *`mint`* *function of the* *`VariableSupplyToken`* *was modified to call the ERC777* *`tokensReceived`* *hook, a critical regression error has been introduced. The* *`migrateBalanceFromLegacyRep`* *function of the* *`OldLegacyRepToken`* *contract must be called for every token holder to complete the migration, and as* *`mint`* *now calls the* *`tokensReceived`* *hook, any holder can revert attempts to mint new tokens for them. As a result, malicious tokens holders can prevent the migration from finishing (i.e. potentially never allowing the* *`isMigratingFromLegacy`* *flag to be set to* *`false`**).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "packages/augur-core/source/contracts/libraries/token/VariableSupplyToken.sol",
      "content": "pragma solidity 0.5.4;\n\n\nimport 'ROOT/libraries/token/StandardToken.sol';\n\n\ncontract VariableSupplyToken is StandardToken {\n    using SafeMathUint256 for uint256;\n\n    event Mint(address indexed target, uint256 value);\n    event Burn(address indexed target, uint256 value);\n\n    function mint(address _target, uint256 _amount) internal returns (bool) {\n        balances[_target] = balances[_target].add(_amount);\n        supply = supply.add(_amount);\n        emit Mint(_target, _amount);\n        emit Transfer(address(0), _target, _amount);\n        onMint(_target, _amount);\n        return true;\n    }\n\n    function burn(address _target, uint256 _amount) internal returns (bool) {\n        doBurn(address(this), _target, _amount, \"\", \"\");\n        onBurn(_target, _amount);\n        return true;\n    }\n\n    // Subclasses of this token may want to send additional logs through the centralized Augur log emitter contract\n    function onMint(address, uint256) internal returns (bool);\n\n    // Subclasses of this token may want to send additional logs through the centralized Augur log emitter contract\n    function onBurn(address, uint256) internal returns (bool);\n}"
    },
    {
      "filename": "packages/augur-core/source/contracts/libraries/token/ERC777Token.sol",
      "content": "pragma solidity 0.5.4;\n\n\ncontract ERC777Token {\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address _owner) public view returns (uint256);\n\n    function defaultOperators() public view returns (address[] memory);\n    function isOperatorFor(address _operator, address _tokenHolder) public view returns (bool);\n    function authorizeOperator(address _operator) public returns (bool);\n    function revokeOperator(address _operator) public returns (bool);\n\n    function send(address _to, uint256 _amount, bytes32 _data) public returns (bool);\n    function operatorSend(address _from, address _to, uint256 _amount, bytes32 _data, bytes32 _operatorData) public returns (bool);\n\n    // Note: We choose to disallow manual burning since according to spec this would alter the total supply as well and that does not play cleanly with some of our token tracking and dependencies. ERC777 states we MAY dissallow burning in this way.\n    //function burn(uint256 _amount, bytes32 _data) public returns (bool);\n    //function operatorBurn(address _from, uint256 _amount, bytes32 _data, bytes32 _operatorData) public;\n\n    event Sent(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes32 data,\n        bytes32 operatorData\n    );\n\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes32 operatorData);\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes32 data, bytes32 operatorData);\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n}"
    },
    {
      "filename": "packages/augur-core/source/contracts/libraries/token/StandardToken.sol",
      "content": "pragma solidity 0.5.4;\n\n\nimport 'ROOT/libraries/token/ERC20Token.sol';\nimport 'ROOT/libraries/token/ERC777BaseToken.sol';\n\n\ncontract StandardToken is ERC20Token, ERC777BaseToken {\n    // Approvals of this amount are simply considered an everlasting approval which is not decremented when transfers occur\n    uint256 public constant ETERNAL_APPROVAL_VALUE = 2 ** 256 - 1;\n\n    mapping(address => mapping(address => uint256)) internal allowed;\n\n    function initialize820InterfaceImplementations() internal returns (bool) {\n        super.initialize820InterfaceImplementations();\n        setInterfaceImplementation(\"ERC20Token\", address(this));\n        return true;\n    }\n\n    function transfer(address _to, uint256 _amount) public returns (bool) {\n        require(_to != address(0), \"Cannot send to 0x0\");\n        internalTransfer(msg.sender, _to, _amount, true);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool) {\n        uint256 _allowance = allowed[_from][msg.sender];\n        require(_amount <= _allowance, \"Not enough funds allowed\");\n\n        if (_allowance != ETERNAL_APPROVAL_VALUE) {\n            allowed[_from][msg.sender] = _allowance.sub(_amount);\n        }\n\n        internalTransfer(_from, _to, _amount, true);\n        return true;\n    }\n\n    function internalTransfer(address _from, address _to, uint256 _amount, bool _callHooks) internal returns (bool) {\n        doSend(msg.sender, _from, _to, _amount, \"\", \"\", false, _callHooks);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _amount) public returns (bool) {\n        approveInternal(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n        approveInternal(msg.sender, _spender, allowed[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n        uint oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            approveInternal(msg.sender, _spender, 0);\n        } else {\n            approveInternal(msg.sender, _spender, oldValue.sub(_subtractedValue));\n        }\n        return true;\n    }\n\n    function approveInternal(address _owner, address _spender, uint256 _allowance) internal returns (bool) {\n        allowed[_owner][_spender] = _allowance;\n        emit Approval(_owner, _spender, _allowance);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n\n    function doSend(address _operator, address _from, address _to, uint256 _amount, bytes32  _data, bytes32  _operatorData, bool _preventLocking, bool _callHooks) internal returns (bool) {\n        super.doSend(_operator, _from, _to, _amount, _data, _operatorData, _preventLocking, _callHooks);\n        emit Transfer(_from, _to, _amount);\n        onTokenTransfer(_from, _to, _amount);\n        return true;\n    }\n\n    function doBurn(address _operator, address _tokenHolder, uint256 _amount, bytes32  _data, bytes32  _operatorData) internal returns (bool) {\n        super.doBurn(_operator, _tokenHolder, _amount, _data, _operatorData);\n        emit Transfer(_tokenHolder, address(0x0), _amount);\n        return true;\n    }\n\n    // Subclasses of this token generally want to send additional logs through the centralized Augur log emitter contract\n    function onTokenTransfer(address _from, address _to, uint256 _value) internal returns (bool);\n}"
    }
  ]
}