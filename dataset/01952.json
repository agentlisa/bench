{
  "Title": "M-5: Merkle leaf values for _clubDivsMerkleRoot are 64 bytes before hashing which can lead to merkle tree collisions",
  "Content": "# Issue M-5: Merkle leaf values for _clubDivsMerkleRoot are 64 bytes before hashing which can lead to merkle tree collisions \n\nSource: https://github.com/sherlock-audit/2023-04-footium-judging/issues/300 \n\n## Found by \n0x52, 0xRan4212, GimelSec, cergyk, qpzm\n## Summary\n\nFootiumAcademy hashes 64 bytes when calculating leaf allowing it to collide with the internal nodes of the merkle tree.\n\n## Vulnerability Detail\n\nMerkleProofUpgradeable.sol puts the following warning at the beginning of the contract:\n\n     * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n     * hashing, or use a hash function other than keccak256 for hashing leaves.\n     * This is because the concatenation of a sorted pair of internal nodes in\n     * the merkle tree could be reinterpreted as a leaf value.\n\n[FootiumAcademy.sol#L235-L240](https://github.com/sherlock-audit/2023-04-footium/blob/main/footium-eth-shareable/contracts/FootiumAcademy.sol#L235-L240)\n\n        if (\n            !MerkleProofUpgradeable.verify(\n                divisionProof,\n                _clubDivsMerkleRoot,\n                keccak256(abi.encodePacked(clubId, divisionTier)) <- @audit-issue 64 bytes before hashing allows collisions with internal nodes\n            )\n\nThis is problematic because FootiumAcademy uses clubId and divisionTier as the base of the leaf, which are both uint256 (32 bytes each for 64 bytes total). This allows collision between leaves and internal nodes. These collisions could allow users to mint to divisions that otherwise would be impossible.\n\n## Impact\n\nUsers can abuse merkle tree collisions to mint in non-existent divisions and bypass minting fees\n\n## Code Snippet\n\n[FootiumAcademy.sol#L228-L272](https://github.com/sherlock-audit/2023-04-footium/blob/main/footium-eth-shareable/contracts/FootiumAcademy.sol#L228-L272)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse a combination of variables that doesn't sum to 64 bytes\n\n\n\n## Discussion\n\n**0xRobocop**\n\nEscalate for 10 USDC\n\nI encountered the same issue, and I will provide my analysis on why this is not an issue in the current codebase, not even to classify as a medium.\n\nThe problem described is that the concatenation (which will be of 64 bytes long, if keccak256 is used) of 2 internal nodes of a merkle tree could collide with leaf values that also are 64 bytes long. For example:\n\nLeaf Value (64 bytes), ignore the `=` symbols, they are used to separate the leaf value into two tranches of 32 bytes for illustration purposes: \n\n`0x9c644f34f630d76b78c6ccecfceabcf6b9f0def47e637403ac15c63bc6030920=====d6a1fb97571351113887953420cffc381edf9874c13f336e0c2c01bffe2214f4`\n\nInternal Node 1: `0x9c644f34f630d76b78c6ccecfceabcf6b9f0def47e637403ac15c63bc6030920`\n\nInternal Node 2: `0xd6a1fb97571351113887953420cffc381edf9874c13f336e0c2c01bffe2214f4`\n\nThere we have a collision of a leaf value with the concatenation of the hash values of 2 sorted internal nodes. \n\nIn the current codebase, the probability of this to happen is negligible. The leaf value is computed as the concatenation of `clubId` and `divisionTier`. `clubId` is a variable that increments 1 by 1 (when a club is minted), if we were to mint 1 club in each second until the year 2106, we could mint a maximum amount of 2^32 clubs and the maximum `divisionTier` will be way lower than this number, but for illustration purposes I will assume that it is also 2^32. \n\nThen, the maximum value the leaf can have is (again the `=` symbols are for illustration purposes to show the concatenation):\n\n`0x0000000000000000000000000000000000000000000000000000000100000000====0000000000000000000000000000000000000000000000000000000100000000`\n\nFor a potential collision to happen, the concatenation of 2 internal nodes (which are keccak256 values) must be equal or smaller than the above number. Due to the inequality (equal or smaller) we are only interested in the internal node that will end-up on the left side. The hash value of the left-side internal node will need to be smaller than:\n\n`0x0000000000000000000000000000000000000000000000000000000100000000`\n\nWhich has 55 leading zeros. The lowest hash found in the bitcoin network has 23 leading zeros [reference](https://blog.bitmex.com/bitcoins-lowest-block-hash-values/).\n\nPlease keep in mind that OZ contracts are too general and that's why they put the warning, not to mention that the warning is a \"should\" not a \"must\" since the exploitation of this phenomenon will depend highly on the contracts which uses their MerkleProof library.\n\nIf the values that make up the leaf were to be controllable by the users, I would agree this is a medium or even a high vulnerability, but the leaf is made up of values, `clubId` and `divisionTier`, that are not controllable by the users and that we can predict their values.\n\nPD: I would argue that issues reported based on warnings written in general-purpose libraries, should be accompanied with proof of concepts (coded or not) on how can be exploited in the codebase, even if it has some hypotheticals in the case of mediums, but not too hypothetical like producing a hash value with 55 leading zeros.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> I encountered the same issue, and I will provide my analysis on why this is not an issue in the current codebase, not even to classify as a medium.\n> \n> The problem described is that the concatenation (which will be of 64 bytes long, if keccak256 is used) of 2 internal nodes of a merkle tree could collide with leaf values that also are 64 bytes long. For example:\n> \n> Leaf Value (64 bytes), ignore the `=` symbols, they are used to separate the leaf value into two tranches of 32 bytes for illustration purposes: \n> \n> `0x9c644f34f630d76b78c6ccecfceabcf6b9f0def47e637403ac15c63bc6030920=====d6a1fb97571351113887953420cffc381edf9874c13f336e0c2c01bffe2214f4`\n> \n> Internal Node 1: `0x9c644f34f630d76b78c6ccecfceabcf6b9f0def47e637403ac15c63bc6030920`\n> \n> Internal Node 2: `0xd6a1fb97571351113887953420cffc381edf9874c13f336e0c2c01bffe2214f4`\n> \n> There we have a collision of a leaf value with the concatenation of the hash values of 2 sorted internal nodes. \n> \n> In the current codebase, the probability of this to happen is negligible. The leaf value is computed as the concatenation of `clubId` and `divisionTier`. `clubId` is a variable that increments 1 by 1 (when a club is minted), if we were to mint 1 club in each second until the year 2106, we could mint a maximum amount of 2^32 clubs and the maximum `divisionTier` will be way lower than this number, but for illustration purposes I will assume that it is also 2^32. \n> \n> Then, the maximum value the leaf can have is (again the `=` symbols are for illustration purposes to show the concatenation):\n> \n> `0x0000000000000000000000000000000000000000000000000000000100000000====0000000000000000000000000000000000000000000000000000000100000000`\n> \n> For a potential collision to happen, the concatenation of 2 internal nodes (which are keccak256 values) must be equal or smaller than the above number. Due to the inequality (equal or smaller) we are only interested in the internal node that will end-up on the left side. The hash value of the left-side internal node will need to be smaller than:\n> \n> `0x0000000000000000000000000000000000000000000000000000000100000000`\n> \n> Which has 55 leading zeros. The lowest hash found in the bitcoin network has 23 leading zeros [reference](https://blog.bitmex.com/bitcoins-lowest-block-hash-values/).\n> \n> Please keep in mind that OZ contracts are too general and that's why they put the warning, not to mention that the warning is a \"should\" not a \"must\" since the exploitation of this phenomenon will depend highly on the contracts which uses their MerkleProof library.\n> \n> If the values that make up the leaf were to be controllable by the users, I would agree this is a medium or even a high vulnerability, but the leaf is made up of values, `clubId` and `divisionTier`, that are not controllable by the users and that we can predict their values.\n> \n> PD: I would argue that issues reported based on warnings written in general-purpose libraries, should be accompanied with proof of concepts (coded or not) on how can be exploited in the codebase, even if it has some hypotheticals in the case of mediums, but not too hypothetical like producing a hash value with 55 leading zeros.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**SergeKireev**\n\nEscalate for 10 USDC,\n\nAs per my report of the issue:\nhttps://github.com/sherlock-audit/2023-04-footium-judging/issues/170\n\nFor the issue to be valid there only needs to be a very specific value of `clubId` crafted. Indeed the `divisionId` arg should not be an existent division id for the exploit to work.\n\nThe specific value which the clubId should be equal to is: `any left internal node of the merkle tree`.\n\nThe owner of the contract has the power to mint arbitrary values (nowhere it is stated that it would be an auto-incremented id):\nhttps://github.com/sherlock-audit/2023-04-footium/blob/main/footium-eth-shareable/contracts/FootiumClubMinter.sol#L68-L82\n\nSo the `maximums` determined in the first escalation do not hold.\n\nGiven that the vulnerability is only exploitable if the team decides to open the mint to the public in the future or if the owner account is compromised, the severity can be lowered. However the reasons for which the sponsor found this issue interesting and worth to fix still hold.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC,\n> \n> As per my report of the issue:\n> https://github.com/sherlock-audit/2023-04-footium-judging/issues/170\n> \n> For the issue to be valid there only needs to be a very specific value of `clubId` crafted. Indeed the `divisionId` arg should not be an existent division id for the exploit to work.\n> \n> The specific value which the clubId should be equal to is: `any left internal node of the merkle tree`.\n> \n> The owner of the contract has the power to mint arbitrary values (nowhere it is stated that it would be an auto-incremented id):\n> https://github.com/sherlock-audit/2023-04-footium/blob/main/footium-eth-shareable/contracts/FootiumClubMinter.sol#L68-L82\n> \n> So the `maximums` determined in the first escalation do not hold.\n> \n> Given that the vulnerability is only exploitable if the team decides to open the mint to the public in the future or if the owner account is compromised, the severity can be lowered. However the reasons for which the sponsor found this issue interesting and worth to fix still hold.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**0xRobocop**\n\nEscalate for 10 USDC\n\nI totally agree with SergeKireev, I missed that clubID is not incremented 1 by 1 but controlled by the protocol owner. But I think the severity is still low / informational since this is not exploitable unless owner makes a mistake.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> I totally agree with SergeKireev, I missed that clubID is not incremented 1 by 1 but controlled by the protocol owner. But I think the severity is still low / informational since this is not exploitable unless owner makes a mistake.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nBased on the escalation and other duplicate report, can be a valid medium, severity is not high\n\n**0xRan4212**\n\nEscalate for 10 USDC.\n\nI disagree with the downgrade to medium, even though I had originally reported this issue with a medium severity (see my report on 209).\n\nThe sponsor considered *realistic* the scenario where the user can control the tokenId value, so much so that stated that after audit they will explicitly prevent it that case (see the sponsor comment on report 179).\n\nBefore the sponsor acknowledgment, as I said on my report, the exploitability was theoretical, therefore a medium severity was adequate. Basically, it violated the \"attack path is possible with reasonable assumptions that mimic on-chain conditions\" requirement from the high severity definition [here](https://docs.sherlock.xyz/audits/judging/judging). However, post-acknowledgment I strongly believe this requirement is now satisfied.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC.\n> \n> I disagree with the downgrade to medium, even though I had originally reported this issue with a medium severity (see my report on 209).\n> \n> The sponsor considered *realistic* the scenario where the user can control the tokenId value, so much so that stated that after audit they will explicitly prevent it that case (see the sponsor comment on report 179).\n> \n> Before the sponsor acknowledgment, as I said on my report, the exploitability was theoretical, therefore a medium severity was adequate. Basically, it violated the \"attack path is possible with reasonable assumptions that mimic on-chain conditions\" requirement from the high severity definition [here](https://docs.sherlock.xyz/audits/judging/judging). However, post-acknowledgment I strongly believe this requirement is now satisfied.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nValid medium\nAlthough the documentation mentions that user is allowed to use choose their club ID this is definitely a valid issue, however the implementation of the code still happens through an admin function, and for that reason considering this issue a valid medium.\n\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Valid medium\n> Although the documentation mentions that user is allowed to use choose their club ID this is definitely a valid issue, however the implementation of the code still happens through an admin function, and for that reason considering this issue a valid medium.\n> \n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/71",
  "Code": [
    {
      "filename": "footium-eth-shareable/contracts/FootiumAcademy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport {MerkleProofUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {IFootiumPlayer} from \"./interfaces/IFootiumPlayer.sol\";\nimport {IFootiumClub} from \"./interfaces/IFootiumClub.sol\";\nimport \"./common/Errors.sol\";\n\ntype SeasonID is uint256;\n\nerror GenerationIDTooHigh(uint256 generationId, uint256 maxGenerationId);\nerror PlayerAlreadyRedeemed(uint256 generationId);\nerror ClubNotInDivision(uint256 clubId, uint256 divisionTier);\nerror PlayerTooOld(uint256 currentSeasonId);\nerror PlayerTooYoung(SeasonID seasonId);\nerror InvalidSeasonId(SeasonID seasonId);\n\n/**\n * @title Footium Football Academy\n * @notice An NFT football academy.\n */\ncontract FootiumAcademy is\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable\n{\n    /* Storage */\n    IFootiumPlayer private _footiumPlayer;\n    IFootiumClub private _footiumClub;\n    address private _prizeDistributorAddress;\n    uint256 private _maxGenerationId;\n    uint256 public currentSeasonId;\n    uint256 public academyMinAge;\n    uint256 public academyMaxAge;\n\n    bytes32 private _clubDivsMerkleRoot;\n\n    mapping(SeasonID => mapping(uint256 => mapping(uint256 => bool)))\n        private redeemed;\n\n    mapping(uint256 => uint256) public divisionToFee; //Maps a divisionTier to a fee\n\n    /* Events */\n\n    event ChangedMaxGenerationId(uint256 indexed maxGenerationId);\n    event ChangedCurrentSeasonId(uint256 indexed currentSeasonId);\n    event AcademyPlayerMinted(\n        SeasonID indexed seasonId,\n        uint256 indexed clubId,\n        uint256 indexed generationId,\n        uint256 playerId\n    );\n    event ChangedClubDivsMerkleRoot(bytes32 merkleRoot);\n    event ChangedDivisionFees(uint256[] fees);\n\n    /**\n     * @dev Initializes the FootiumAcademy contract.\n     * @param footiumPlayer Footium Players contract address.\n     * @param footiumClub Footium Clubs contract address.\n     * @param prizeDistributorAddress FootiumPrizeDistributor contract address.\n     * @param maxGenerationId The maximum integer generationId can be.\n     * @param fees Division fees.\n     */\n    function initialize(\n        IFootiumPlayer footiumPlayer,\n        IFootiumClub footiumClub,\n        address prizeDistributorAddress,\n        uint256 maxGenerationId,\n        uint256[] memory fees\n    ) external initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n\n        _footiumPlayer = footiumPlayer;\n        _footiumClub = footiumClub;\n        _prizeDistributorAddress = prizeDistributorAddress;\n        currentSeasonId = 1;\n        academyMinAge = 18;\n        academyMaxAge = 20;\n\n        setDivisionFees(fees);\n        changeMaxGenerationId(maxGenerationId);\n    }\n\n    /**\n     * @notice Changes the `_maxGenerationId` storage variable.\n     * @param maxGenerationId The new value for the `maxGenerationId` storage variable.\n     * @dev Only owner address allowed.\n     */\n    function changeMaxGenerationId(uint256 maxGenerationId) public onlyOwner {\n        _maxGenerationId = maxGenerationId;\n        emit ChangedMaxGenerationId(_maxGenerationId);\n    }\n\n    /**\n     * @notice Changes the `_clubDivsMerkleRoot` variable.\n     * @param _merkleRoot is the value for the `_clubDivsMerkleRoot` variable.\n     * @dev Only owner address allowed.\n     */\n    function setClubDivsMerkleRoot(bytes32 _merkleRoot) external onlyOwner {\n        _clubDivsMerkleRoot = _merkleRoot;\n\n        emit ChangedClubDivsMerkleRoot(_clubDivsMerkleRoot);\n    }\n\n    /**\n     * @notice Updates division fees.\n     * @param _fees an array of division fees to be set.\n     * @dev Only owner address allowed.\n     */\n    function setDivisionFees(uint256[] memory _fees) public onlyOwner {\n        uint256 max = _fees.length;\n\n        for (uint256 i = 0; i < max; ) {\n            uint256 fee = _fees[i];\n            divisionToFee[i + 1] = fee;\n\n            unchecked {\n                i++;\n            }\n        }\n\n        emit ChangedDivisionFees(_fees);\n    }\n\n    /**\n     * @notice Changes the `currentSeasonId` storage variable.\n     * @param _newSeasonId The new value for the `currentSeasonId` storage variable.\n     * @dev Only owner address allowed\n     */\n    function changeCurrentSeasonId(uint256 _newSeasonId) external onlyOwner {\n        currentSeasonId = _newSeasonId;\n\n        emit ChangedCurrentSeasonId(currentSeasonId);\n    }\n\n    /**\n     * @notice Unpause the contract\n     * @dev Only owner address allowed.\n     */\n    function activateContract() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @notice Pause the contract\n     * @dev Only owner address allowed.\n     */\n    function pauseContract() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Mint players corresponding to `generationIds` from the `seasonId` cohort.\n     * @param seasonId The season cohort to mint players from.\n     * @param clubId The ID of the club to receive the players.\n     * @param divisionTier The tier of the division.\n     * @param generationIds The unique identifier of each player within the season cohort.\n     * @param divisionProof Sibling hashes on the branch from the leaf to the division root of the merkel tree.\n     * @dev Only the owner can mint players to their club.\n     */\n    function mintPlayers(\n        SeasonID seasonId,\n        uint256 clubId,\n        uint256 divisionTier,\n        uint256[] calldata generationIds,\n        bytes32[] calldata divisionProof\n    ) external payable whenNotPaused nonReentrant {\n        uint256 totalFee = _validateMintingParams(\n            seasonId,\n            clubId,\n            divisionTier,\n            generationIds,\n            divisionProof\n        );\n\n        uint256 generationId;\n\n        for (uint256 i = 0; i < generationIds.length; ) {\n            generationId = generationIds[i];\n\n            if (generationId > _maxGenerationId) {\n                revert GenerationIDTooHigh(generationId, _maxGenerationId);\n            }\n\n            if (redeemed[seasonId][clubId][generationId]) {\n                revert PlayerAlreadyRedeemed(generationId);\n            }\n\n            redeemed[seasonId][clubId][generationId] = true;\n\n            uint256 playerId = _footiumPlayer.safeMint(\n                _footiumClub.clubToEscrow(clubId)\n            );\n\n            emit AcademyPlayerMinted(seasonId, clubId, generationId, playerId);\n\n            unchecked {\n                i++;\n            }\n        }\n\n        // forward total fee to the prize distributor contract\n        (bool sent, ) = _prizeDistributorAddress.call{value: totalFee}(\"\");\n        if (!sent) {\n            revert FailedToSendETH(totalFee);\n        }\n    }\n\n    /**\n     * @notice Transfers contract available ether balance to the contact owner address\n     * @dev Only owner address allowed\n     */\n    function withdraw() external onlyOwner {\n        uint256 balance = address(this).balance;\n        if (balance > 0) {\n            (bool sent, ) = payable(owner()).call{value: balance}(\"\");\n            if (!sent) {\n                revert FailedToSendETH(balance);\n            }\n        }\n    }\n\n    function _validateMintingParams(\n        SeasonID seasonId,\n        uint256 clubId,\n        uint256 divisionTier,\n        uint256[] calldata generationIds,\n        bytes32[] calldata divisionProof\n    ) private returns (uint256) {\n        if (\n            !MerkleProofUpgradeable.verify(\n                divisionProof,\n                _clubDivsMerkleRoot,\n                keccak256(abi.encodePacked(clubId, divisionTier))\n            )\n        ) {\n            revert ClubNotInDivision(clubId, divisionTier);\n        }\n\n        if (msg.sender != _footiumClub.ownerOf(clubId)) {\n            revert NotClubOwner(clubId, msg.sender);\n        }\n\n        if (SeasonID.unwrap(seasonId) <= 0) {\n            revert InvalidSeasonId(seasonId);\n        }\n\n        if (SeasonID.unwrap(seasonId) > currentSeasonId) {\n            revert PlayerTooYoung(seasonId);\n        }\n\n        uint256 playerCount = generationIds.length;\n        uint256 totalFee = playerCount * divisionToFee[divisionTier];\n        if (msg.value < totalFee) {\n            revert IncorrectETHAmount(msg.value);\n        }\n\n        uint256 maxSeasonId = SeasonID.unwrap(seasonId) +\n            academyMaxAge -\n            academyMinAge;\n\n        if (maxSeasonId < currentSeasonId) {\n            revert PlayerTooOld(currentSeasonId);\n        }\n\n        return totalFee;\n    }\n}"
    },
    {
      "filename": "footium-eth-shareable/contracts/FootiumAcademy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport {MerkleProofUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {IFootiumPlayer} from \"./interfaces/IFootiumPlayer.sol\";\nimport {IFootiumClub} from \"./interfaces/IFootiumClub.sol\";\nimport \"./common/Errors.sol\";\n\ntype SeasonID is uint256;\n\nerror GenerationIDTooHigh(uint256 generationId, uint256 maxGenerationId);\nerror PlayerAlreadyRedeemed(uint256 generationId);\nerror ClubNotInDivision(uint256 clubId, uint256 divisionTier);\nerror PlayerTooOld(uint256 currentSeasonId);\nerror PlayerTooYoung(SeasonID seasonId);\nerror InvalidSeasonId(SeasonID seasonId);\n\n/**\n * @title Footium Football Academy\n * @notice An NFT football academy.\n */\ncontract FootiumAcademy is\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable\n{\n    /* Storage */\n    IFootiumPlayer private _footiumPlayer;\n    IFootiumClub private _footiumClub;\n    address private _prizeDistributorAddress;\n    uint256 private _maxGenerationId;\n    uint256 public currentSeasonId;\n    uint256 public academyMinAge;\n    uint256 public academyMaxAge;\n\n    bytes32 private _clubDivsMerkleRoot;\n\n    mapping(SeasonID => mapping(uint256 => mapping(uint256 => bool)))\n        private redeemed;\n\n    mapping(uint256 => uint256) public divisionToFee; //Maps a divisionTier to a fee\n\n    /* Events */\n\n    event ChangedMaxGenerationId(uint256 indexed maxGenerationId);\n    event ChangedCurrentSeasonId(uint256 indexed currentSeasonId);\n    event AcademyPlayerMinted(\n        SeasonID indexed seasonId,\n        uint256 indexed clubId,\n        uint256 indexed generationId,\n        uint256 playerId\n    );\n    event ChangedClubDivsMerkleRoot(bytes32 merkleRoot);\n    event ChangedDivisionFees(uint256[] fees);\n\n    /**\n     * @dev Initializes the FootiumAcademy contract.\n     * @param footiumPlayer Footium Players contract address.\n     * @param footiumClub Footium Clubs contract address.\n     * @param prizeDistributorAddress FootiumPrizeDistributor contract address.\n     * @param maxGenerationId The maximum integer generationId can be.\n     * @param fees Division fees.\n     */\n    function initialize(\n        IFootiumPlayer footiumPlayer,\n        IFootiumClub footiumClub,\n        address prizeDistributorAddress,\n        uint256 maxGenerationId,\n        uint256[] memory fees\n    ) external initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n\n        _footiumPlayer = footiumPlayer;\n        _footiumClub = footiumClub;\n        _prizeDistributorAddress = prizeDistributorAddress;\n        currentSeasonId = 1;\n        academyMinAge = 18;\n        academyMaxAge = 20;\n\n        setDivisionFees(fees);\n        changeMaxGenerationId(maxGenerationId);\n    }\n\n    /**\n     * @notice Changes the `_maxGenerationId` storage variable.\n     * @param maxGenerationId The new value for the `maxGenerationId` storage variable.\n     * @dev Only owner address allowed.\n     */\n    function changeMaxGenerationId(uint256 maxGenerationId) public onlyOwner {\n        _maxGenerationId = maxGenerationId;\n        emit ChangedMaxGenerationId(_maxGenerationId);\n    }\n\n    /**\n     * @notice Changes the `_clubDivsMerkleRoot` variable.\n     * @param _merkleRoot is the value for the `_clubDivsMerkleRoot` variable.\n     * @dev Only owner address allowed.\n     */\n    function setClubDivsMerkleRoot(bytes32 _merkleRoot) external onlyOwner {\n        _clubDivsMerkleRoot = _merkleRoot;\n\n        emit ChangedClubDivsMerkleRoot(_clubDivsMerkleRoot);\n    }\n\n    /**\n     * @notice Updates division fees.\n     * @param _fees an array of division fees to be set.\n     * @dev Only owner address allowed.\n     */\n    function setDivisionFees(uint256[] memory _fees) public onlyOwner {\n        uint256 max = _fees.length;\n\n        for (uint256 i = 0; i < max; ) {\n            uint256 fee = _fees[i];\n            divisionToFee[i + 1] = fee;\n\n            unchecked {\n                i++;\n            }\n        }\n\n        emit ChangedDivisionFees(_fees);\n    }\n\n    /**\n     * @notice Changes the `currentSeasonId` storage variable.\n     * @param _newSeasonId The new value for the `currentSeasonId` storage variable.\n     * @dev Only owner address allowed\n     */\n    function changeCurrentSeasonId(uint256 _newSeasonId) external onlyOwner {\n        currentSeasonId = _newSeasonId;\n\n        emit ChangedCurrentSeasonId(currentSeasonId);\n    }\n\n    /**\n     * @notice Unpause the contract\n     * @dev Only owner address allowed.\n     */\n    function activateContract() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @notice Pause the contract\n     * @dev Only owner address allowed.\n     */\n    function pauseContract() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Mint players corresponding to `generationIds` from the `seasonId` cohort.\n     * @param seasonId The season cohort to mint players from.\n     * @param clubId The ID of the club to receive the players.\n     * @param divisionTier The tier of the division.\n     * @param generationIds The unique identifier of each player within the season cohort.\n     * @param divisionProof Sibling hashes on the branch from the leaf to the division root of the merkel tree.\n     * @dev Only the owner can mint players to their club.\n     */\n    function mintPlayers(\n        SeasonID seasonId,\n        uint256 clubId,\n        uint256 divisionTier,\n        uint256[] calldata generationIds,\n        bytes32[] calldata divisionProof\n    ) external payable whenNotPaused nonReentrant {\n        uint256 totalFee = _validateMintingParams(\n            seasonId,\n            clubId,\n            divisionTier,\n            generationIds,\n            divisionProof\n        );\n\n        uint256 generationId;\n\n        for (uint256 i = 0; i < generationIds.length; ) {\n            generationId = generationIds[i];\n\n            if (generationId > _maxGenerationId) {\n                revert GenerationIDTooHigh(generationId, _maxGenerationId);\n            }\n\n            if (redeemed[seasonId][clubId][generationId]) {\n                revert PlayerAlreadyRedeemed(generationId);\n            }\n\n            redeemed[seasonId][clubId][generationId] = true;\n\n            uint256 playerId = _footiumPlayer.safeMint(\n                _footiumClub.clubToEscrow(clubId)\n            );\n\n            emit AcademyPlayerMinted(seasonId, clubId, generationId, playerId);\n\n            unchecked {\n                i++;\n            }\n        }\n\n        // forward total fee to the prize distributor contract\n        (bool sent, ) = _prizeDistributorAddress.call{value: totalFee}(\"\");\n        if (!sent) {\n            revert FailedToSendETH(totalFee);\n        }\n    }\n\n    /**\n     * @notice Transfers contract available ether balance to the contact owner address\n     * @dev Only owner address allowed\n     */\n    function withdraw() external onlyOwner {\n        uint256 balance = address(this).balance;\n        if (balance > 0) {\n            (bool sent, ) = payable(owner()).call{value: balance}(\"\");\n            if (!sent) {\n                revert FailedToSendETH(balance);\n            }\n        }\n    }\n\n    function _validateMintingParams(\n        SeasonID seasonId,\n        uint256 clubId,\n        uint256 divisionTier,\n        uint256[] calldata generationIds,\n        bytes32[] calldata divisionProof\n    ) private returns (uint256) {\n        if (\n            !MerkleProofUpgradeable.verify(\n                divisionProof,\n                _clubDivsMerkleRoot,\n                keccak256(abi.encodePacked(clubId, divisionTier))\n            )\n        ) {\n            revert ClubNotInDivision(clubId, divisionTier);\n        }\n\n        if (msg.sender != _footiumClub.ownerOf(clubId)) {\n            revert NotClubOwner(clubId, msg.sender);\n        }\n\n        if (SeasonID.unwrap(seasonId) <= 0) {\n            revert InvalidSeasonId(seasonId);\n        }\n\n        if (SeasonID.unwrap(seasonId) > currentSeasonId) {\n            revert PlayerTooYoung(seasonId);\n        }\n\n        uint256 playerCount = generationIds.length;\n        uint256 totalFee = playerCount * divisionToFee[divisionTier];\n        if (msg.value < totalFee) {\n            revert IncorrectETHAmount(msg.value);\n        }\n\n        uint256 maxSeasonId = SeasonID.unwrap(seasonId) +\n            academyMaxAge -\n            academyMinAge;\n\n        if (maxSeasonId < currentSeasonId) {\n            revert PlayerTooOld(currentSeasonId);\n        }\n\n        return totalFee;\n    }\n}"
    },
    {
      "filename": "footium-eth-shareable/contracts/FootiumClubMinter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IFootiumPlayer} from \"./interfaces/IFootiumPlayer.sol\";\nimport {IFootiumClub} from \"./interfaces/IFootiumClub.sol\";\n\n/**\n * @title Footium Club Minter contract.\n * @notice Allows the contract owner to mint a Footium club and starting squad of players.\n */\ncontract FootiumClubMinter is OwnableUpgradeable {\n    uint256 private constant INITIAL_MINT = 20;\n\n    IFootiumPlayer public footiumPlayer;\n    IFootiumClub public footiumClub;\n\n    /* Events */\n\n    event InitialPlayerMinted(\n        uint256 indexed clubId,\n        uint256 indexed index,\n        uint256 playerId\n    );\n\n    /**\n     * @dev Initializes the FootiumClubMinter contract.\n     * @param _footiumPlayer Footium players contract address.\n     * @param _footiumClub Footium clubs contract address.\n     */\n    function initialize(\n        IFootiumPlayer _footiumPlayer,\n        IFootiumClub _footiumClub\n    ) external initializer {\n        __Ownable_init();\n\n        footiumPlayer = _footiumPlayer;\n        footiumClub = _footiumClub;\n    }\n\n    /**\n     * @dev Updates Footium Players contract address.\n     * @param _footiumPlayer Footium Players contract address.\n     * @dev Only owner address allowed.\n     */\n    function setPlayerAddress(IFootiumPlayer _footiumPlayer)\n        external\n        onlyOwner\n    {\n        footiumPlayer = _footiumPlayer;\n    }\n\n    /**\n     * @dev Updates Footium Clubs contract address.\n     * @param _footiumClub Footium Clubs contract address.\n     * @dev Only owner address allowed.\n     */\n    function setClubAddress(IFootiumClub _footiumClub) external onlyOwner {\n        footiumClub = _footiumClub;\n    }\n\n    /**\n     * @notice Mint a Footium club and starting squad of players.\n     * @dev Only the contract owner can mint.\n     * @param to The account to mint to.\n     * @param tokenId The club ID to mint.\n     */\n    function mint(address to, uint256 tokenId) external onlyOwner {\n        footiumClub.safeMint(to, tokenId);\n\n        address escrowAddress = footiumClub.clubToEscrow(tokenId);\n\n        for (uint256 i; i < INITIAL_MINT; ) {\n            uint256 playerId = footiumPlayer.safeMint(escrowAddress);\n            emit InitialPlayerMinted(tokenId, i, playerId);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "footium-eth-shareable/contracts/FootiumClubMinter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IFootiumPlayer} from \"./interfaces/IFootiumPlayer.sol\";\nimport {IFootiumClub} from \"./interfaces/IFootiumClub.sol\";\n\n/**\n * @title Footium Club Minter contract.\n * @notice Allows the contract owner to mint a Footium club and starting squad of players.\n */\ncontract FootiumClubMinter is OwnableUpgradeable {\n    uint256 private constant INITIAL_MINT = 20;\n\n    IFootiumPlayer public footiumPlayer;\n    IFootiumClub public footiumClub;\n\n    /* Events */\n\n    event InitialPlayerMinted(\n        uint256 indexed clubId,\n        uint256 indexed index,\n        uint256 playerId\n    );\n\n    /**\n     * @dev Initializes the FootiumClubMinter contract.\n     * @param _footiumPlayer Footium players contract address.\n     * @param _footiumClub Footium clubs contract address.\n     */\n    function initialize(\n        IFootiumPlayer _footiumPlayer,\n        IFootiumClub _footiumClub\n    ) external initializer {\n        __Ownable_init();\n\n        footiumPlayer = _footiumPlayer;\n        footiumClub = _footiumClub;\n    }\n\n    /**\n     * @dev Updates Footium Players contract address.\n     * @param _footiumPlayer Footium Players contract address.\n     * @dev Only owner address allowed.\n     */\n    function setPlayerAddress(IFootiumPlayer _footiumPlayer)\n        external\n        onlyOwner\n    {\n        footiumPlayer = _footiumPlayer;\n    }\n\n    /**\n     * @dev Updates Footium Clubs contract address.\n     * @param _footiumClub Footium Clubs contract address.\n     * @dev Only owner address allowed.\n     */\n    function setClubAddress(IFootiumClub _footiumClub) external onlyOwner {\n        footiumClub = _footiumClub;\n    }\n\n    /**\n     * @notice Mint a Footium club and starting squad of players.\n     * @dev Only the contract owner can mint.\n     * @param to The account to mint to.\n     * @param tokenId The club ID to mint.\n     */\n    function mint(address to, uint256 tokenId) external onlyOwner {\n        footiumClub.safeMint(to, tokenId);\n\n        address escrowAddress = footiumClub.clubToEscrow(tokenId);\n\n        for (uint256 i; i < INITIAL_MINT; ) {\n            uint256 playerId = footiumPlayer.safeMint(escrowAddress);\n            emit InitialPlayerMinted(tokenId, i, playerId);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n}"
    }
  ]
}