{
  "Title": "BNK-1 | Bank Cannot Receive ETH",
  "Content": "**Description - [PoC](https://github.com/GuardianAudits/GMX/blob/af740b1972788f429219d1381183c68b244e00d8/test/guardianTestSuite/testPOCS.js#L99)**\nBank.sol has no receive/fallback function defined to be able to accept ether, therefore it is impossible for the Bank to withdraw ether from the WETH contract and by extension it is impossible to transfer ether out of the Bank.sol contract.\n\nBecause of this:\n- Swap orders with `hasCollateralInEth == true` lead to complete loss of funds for users.\n- Orders, deposits, and withdrawals using `hasCollateralInEth == true` are unable to be canceled. This means users are unable to cancel `hasCollateralInEth` orders and the keeper is unable to cancel failing orders, deposits, and withdrawals leading to phantom entries in each corresponding store.\n- `StopLoss` orders with no `swapPath` and `hasCollateralInEth == true` cannot be executed as they attempt to pay the user in ether from the bank.\n- Additionally, users are unable to use the `hasCollateralInEth` flag to receive ether when withdrawing or exercising a decrease order.\n\n**Recommendation**\n\nImplement a receive function in the Bank.sol contract.\n\n**Resolution**\n\nGMX Team: The recommendation was implemented.",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "test/guardianTestSuite/testPOCS.js",
      "content": "const { expect } = require(\"chai\");\nconst { loadFixture } = require(\"@nomicfoundation/hardhat-network-helpers\");\n\nconst { deployFixture } = require(\"../../utils/fixture\");\nconst { getOracleParams } = require(\"../../utils/oracle\");\nconst { printGasUsage } = require(\"../../utils/gas\");\nconst { bigNumberify, expandDecimals, expandFloatDecimals } = require(\"../../utils/math\");\nconst { getBalanceOf } = require(\"../../utils/token\");\nconst { OrderType } = require(\"../../utils/order\");\nconst hre = require(\"hardhat\");\nconst { network, ethers } = require(\"hardhat\");\nconst { grantRole } = require(\"./../../utils/role\");\nconst { PANIC_CODES } = require(\"@nomicfoundation/hardhat-chai-matchers/panic\");\n\ndescribe(\"Guardian POCs\", () => {\n  const executionFee = \"1000000000000000\";\n  const { AddressZero, HashZero } = ethers.constants;\n  const { provider } = ethers;\n\n  let wallet, user0, user1, user2, signers, signerIndexes;\n  let orderHandler,\n    depositHandler,\n    depositStore,\n    feeReceiver,\n    reader,\n    dataStore,\n    keys,\n    orderStore,\n    positionStore,\n    ethUsdMarket,\n    btcUsdMarket,\n    weth,\n    usdc,\n    wbtc,\n    liquidationHandler,\n    roleStore,\n    withdrawalStore,\n    withdrawalHandler,\n    exchangeRouter,\n    increaseOrderUtils,\n    decreaseOrderUtils,\n    gasUtils;\n  let oracleSalt;\n  let marketUtils;\n\n  beforeEach(async () => {\n    const fixture = await loadFixture(deployFixture);\n    ({ wallet, user0, user1, user2, signers } = fixture.accounts);\n    ({\n      orderHandler,\n      depositHandler,\n      depositStore,\n      feeReceiver,\n      reader,\n      dataStore,\n      keys,\n      orderStore,\n      positionStore,\n      ethUsdMarket,\n      btcUsdMarket,\n      weth,\n      usdc,\n      wbtc,\n      marketUtils,\n      roleStore,\n      withdrawalStore,\n      withdrawalHandler,\n      exchangeRouter,\n      liquidationHandler,\n      increaseOrderUtils,\n      decreaseOrderUtils,\n      gasUtils,\n    } = fixture.contracts);\n    ({ oracleSalt, signerIndexes } = fixture.props);\n\n    await weth.mint(depositStore.address, expandDecimals(1000, 18));\n    await depositHandler\n      .connect(wallet)\n      .createDeposit(user0.address, ethUsdMarket.marketToken, 100, false, executionFee);\n    const depositKeys = await depositStore.getDepositKeys(0, 1);\n    const deposit = await depositStore.get(depositKeys[0]);\n\n    let block = await provider.getBlock(deposit.updatedAtBlock.toNumber());\n\n    let oracleParams = await getOracleParams({\n      oracleSalt,\n      oracleBlockNumbers: [block.number, block.number],\n      blockHashes: [block.hash, block.hash],\n      signerIndexes,\n      tokens: [weth.address, usdc.address],\n      prices: [expandDecimals(5000, 4), expandDecimals(1, 6)],\n      signers,\n      priceFeedTokens: [],\n    });\n\n    await depositHandler.executeDeposit(depositKeys[0], oracleParams);\n  });\n\n  it(\"CRITICAL::BNK-1 Swap orders with hasCollateralInEth == true lead to complete loss of funds\", async () => {\n    const USDC_AMOUNT = expandDecimals(50000, 6);\n    const user0BalBefore = await ethers.provider.getBalance(user0.address);\n\n    await usdc.mint(orderStore.address, USDC_AMOUNT);\n\n    expect(await orderStore.getOrderCount()).eq(0);\n    const params = {\n      market: ethers.constants.AddressZero,\n      initialCollateralToken: usdc.address,\n      swapPath: [ethUsdMarket.marketToken],\n      sizeDeltaUsd: 0,\n      acceptablePrice: 0,\n      acceptableUsdAdjustment: expandDecimals(-5, 12),\n      executionFee: expandDecimals(0, 15),\n      minOutputAmount: 0,\n      orderType: OrderType.MarketSwap,\n      isLong: true,\n      hasCollateralInETH: true,\n    };\n    await orderHandler.connect(wallet).createOrder(user0.address, params);\n\n    let orderKeys = await orderStore.getOrderKeys(0, 1);\n\n    let order = await orderStore.get(orderKeys[0]);\n\n    let oracleBlockNumber = order.numbers.updatedAtBlock;\n    let block = await provider.getBlock(oracleBlockNumber.toNumber());\n\n    oracleParams = await getOracleParams({\n      oracleSalt,\n      oracleBlockNumbers: [oracleBlockNumber, oracleBlockNumber],\n      blockHashes: [block.hash, block.hash],\n      signerIndexes,\n      tokens: [weth.address, usdc.address],\n      prices: [expandDecimals(1000, 4), expandDecimals(1, 6)],\n      signers,\n      priceFeedTokens: [],\n    });\n\n    // Order is still there in the store, but nobody can cancel it or execute it.\n    await expect(orderHandler.executeOrder(orderKeys[0], oracleParams)).to.be.reverted;\n    await expect(orderHandler.cancelOrder(orderKeys[0])).to.be.reverted;\n\n    orderKeys = await orderStore.getOrderKeys(0, 1);\n    order = await orderStore.get(orderKeys[0]);\n\n    expect(order.numbers.initialCollateralDeltaAmount).to.eq(USDC_AMOUNT);\n    const user0BalAfter = await ethers.provider.getBalance(user0.address);\n    expect(user0BalBefore).to.eq(user0BalAfter);\n  });\n\n  it(\"MEDIUM::DPU-1 Cannot liquidate position whose pnl exactly negates their collateral\", async () => {\n    expect(await usdc.balanceOf(user0.address)).to.eq(0);\n    await usdc.mint(orderStore.address, expandDecimals(50000, 6));\n\n    expect(await weth.balanceOf(user0.address)).eq(0);\n\n    expect(await orderStore.getOrderCount()).eq(0);\n    const params = {\n      market: ethUsdMarket.marketToken,\n      initialCollateralToken: usdc.address,\n      swapPath: [],\n      sizeDeltaUsd: expandFloatDecimals(100 * 1000), // 2x leverage\n      acceptablePrice: expandDecimals(1000, 12),\n      acceptableUsdAdjustment: expandDecimals(-5, 12),\n      executionFee: expandDecimals(0, 15),\n      minOutputAmount: 0,\n      orderType: OrderType.MarketIncrease,\n      isLong: true,\n      hasCollateralInETH: false,\n    };\n    await orderHandler.connect(wallet).createOrder(user0.address, params);\n\n    let orderKeys = await orderStore.getOrderKeys(0, 1);\n\n    let order = await orderStore.get(orderKeys[0]);\n\n    let oracleBlockNumber = order.numbers.updatedAtBlock;\n    let block = await provider.getBlock(oracleBlockNumber.toNumber());\n\n    let oracleParams = await getOracleParams({\n      oracleSalt,\n      oracleBlockNumbers: [oracleBlockNumber, oracleBlockNumber],\n      blockHashes: [block.hash, block.hash],\n      signerIndexes,\n      tokens: [weth.address, usdc.address],\n      prices: [expandDecimals(1000, 4), expandDecimals(1, 6)],\n      signers,\n      priceFeedTokens: [],\n    });\n\n    await expect(orderHandler.executeOrder(orderKeys[0], oracleParams));\n\n    await dataStore.setUint(await keys.MAX_LEVERAGE(), expandFloatDecimals(1));\n    await dataStore.setUint(await keys.MIN_COLLATERAL_USD(), 0);\n\n    await hre.network.provider.send(\"hardhat_mine\", []);\n\n    block = await provider.getBlock();\n\n    let liquidationOracleParams = await getOracleParams({\n      oracleSalt,\n      oracleBlockNumbers: [block.number, block.number],\n      blockHashes: [block.hash, block.hash],\n      signerIndexes,\n      tokens: [weth.address, usdc.address],\n      prices: [expandDecimals(500, 4), expandDecimals(1, 6)],\n      signers,\n      priceFeedTokens: [],\n    });\n    await grantRole(roleStore, wallet.address, \"LIQUIDATION_KEEPER\");\n\n    // The position is unable to be liquidated due to division by 0\n    await expect(\n      liquidationHandler\n        .connect(wallet)\n        .liquidatePosition(user0.address, ethUsdMarket.marketToken, usdc.address, true, liquidationOracleParams)\n    ).to.be.revertedWithPanic(PANIC_CODES.DIVISION_BY_ZERO);\n  });\n\n  it(\"CRITICAL::GLOBAL-1 market w/min + stop loss = low risk profit\", async () => {\n    await usdc.mint(orderStore.address, expandDecimals(50000, 6)); // $50,000\n\n    expect(await orderStore.getOrderCount()).eq(0);\n    const params = {\n      market: ethUsdMarket.marketToken,\n      initialCollateralToken: usdc.address,\n      swapPath: [ethUsdMarket.marketToken], // swap USDC for WETH\n      sizeDeltaUsd: expandFloatDecimals(200 * 1000),\n      acceptablePrice: expandDecimals(5000, 12),\n      acceptableUsdAdjustment: expandDecimals(-5, 12),\n      executionFee: expandDecimals(0, 15),\n      minOutputAmount: expandDecimals(11, 18),\n      orderType: OrderType.MarketIncrease,\n      isLong: true,\n      hasCollateralInETH: false,\n    };\n    await orderHandler.connect(wallet).createOrder(user0.address, params);\n    // Order created\n    expect(await orderStore.getOrderCount()).eq(1);\n\n    let orderKeys = await orderStore.getOrderKeys(0, 1);\n    let order = await orderStore.get(orderKeys[0]);\n\n    let oracleBlockNumber = order.numbers.updatedAtBlock;\n    let block = await provider.getBlock(oracleBlockNumber.toNumber());\n\n    let badOracleParams = await getOracleParams({\n      oracleSalt,\n      oracleBlockNumbers: [oracleBlockNumber, oracleBlockNumber],\n      blockHashes: [block.hash, block.hash],\n      signerIndexes,\n      tokens: [weth.address, usdc.address],\n      prices: [expandDecimals(4600, 4), expandDecimals(1, 6)],\n      signers,\n      priceFeedTokens: [],\n    });\n\n    // This order won't execute above ether price $50,000/11 = $4,545.4. Therefore, imitates a limit order.\n    await expect(orderHandler.executeOrder(orderKeys[0], badOracleParams)).to.be.reverted;\n\n    let oracleParams = await getOracleParams({\n      oracleSalt,\n      oracleBlockNumbers: [oracleBlockNumber, oracleBlockNumber],\n      blockHashes: [block.hash, block.hash],\n      signerIndexes,\n      tokens: [weth.address, usdc.address],\n      prices: [expandDecimals(4500, 4), expandDecimals(1, 6)],\n      signers,\n      priceFeedTokens: [],\n    });\n    // Will execute at this price\n    await orderHandler.executeOrder(orderKeys[0], oracleParams);\n\n    let posKeys = await positionStore.getPositionKeys(0, 1);\n    let pos = await positionStore.get(posKeys[0]);\n    expect(pos.collateralAmount).to.eq(\"11111111111111111111\"); // Collateral / Oracle Price = 50,000/4500 = 11.11\n    expect(pos.sizeInTokens).to.eq(\"44444444444444444444\"); // Size Delta / Oracle Price = 200,000/4500 = 44.44\n\n    const stopLossParams = {\n      market: ethUsdMarket.marketToken,\n      initialCollateralToken: weth.address,\n      swapPath: [],\n      sizeDeltaUsd: expandFloatDecimals(200 * 1000),\n      acceptablePrice: expandDecimals(5000, 12),\n      acceptableUsdAdjustment: expandDecimals(-5, 12),\n      executionFee: expandDecimals(0, 15),\n      minOutputAmount: expandDecimals(0, 18),\n      orderType: OrderType.StopLossDecrease,\n      isLong: true,\n      hasCollateralInETH: false,\n    };\n    await orderHandler.connect(wallet).createOrder(user0.address, stopLossParams);\n\n    expect(await orderStore.getOrderCount()).eq(1);\n    orderKeys = await orderStore.getOrderKeys(0, 1);\n    order = await orderStore.get(orderKeys[0]);\n    oracleBlockNumber = order.numbers.updatedAtBlock;\n    await network.provider.send(\"evm_mine\");\n    await network.provider.send(\"evm_mine\");\n    await network.provider.send(\"evm_mine\");\n\n    block = await provider.getBlock(oracleBlockNumber.add(1).toNumber());\n    oracleParams = await getOracleParams({\n      oracleSalt,\n      oracleBlockNumbers: [oracleBlockNumber.add(1), oracleBlockNumber.add(1), oracleBlockNumber.add(1)],\n      blockHashes: [block.hash, block.hash, block.hash],\n      signerIndexes,\n      tokens: [weth.address, usdc.address, weth.address],\n      prices: [expandDecimals(5010, 4), expandDecimals(1, 6), expandDecimals(5000, 4)],\n      signers,\n      priceFeedTokens: [],\n    });\n    expect(await weth.balanceOf(user0.address)).to.eq(0);\n    await orderHandler.executeOrder(orderKeys[0], oracleParams);\n    // User profits without capital risk\n    expect(await weth.balanceOf(user0.address)).to.eq(\"15546684408959858061\"); // 11.11 + 4.44 = 15.55\n  });\n\n  it(\"CRITICAL::ORDU-1 limit increase must take prices at orderUpdatedAtBlock\", async () => {\n    await usdc.mint(orderStore.address, expandDecimals(50000, 6));\n\n    expect(await orderStore.getOrderCount()).eq(0);\n    const params = {\n      market: ethUsdMarket.marketToken,\n      initialCollateralToken: usdc.address,\n      swapPath: [],\n      sizeDeltaUsd: expandFloatDecimals(100 * 1000),\n      acceptablePrice: expandDecimals(5000, 12),\n      acceptableUsdAdjustment: expandDecimals(-5, 12),\n      executionFee: expandDecimals(0, 15),\n      minOutputAmount: expandDecimals(0, 18),\n      orderType: OrderType.LimitIncrease,\n      isLong: true,\n      hasCollateralInETH: false,\n    };\n    await orderHandler.connect(wallet).createOrder(user0.address, params);\n\n    expect(await orderStore.getOrderCount()).eq(1);\n\n    let orderKeys = await orderStore.getOrderKeys(0, 1);\n    let order = await orderStore.get(orderKeys[0]);\n\n    let oracleBlockNumber = order.numbers.updatedAtBlock;\n    let block = await provider.getBlock(oracleBlockNumber.toNumber());\n    await network.provider.send(\"evm_mine\");\n    let futureBlock = await provider.getBlock(oracleBlockNumber.add(1).toNumber());\n\n    let futureOracleParams = await getOracleParams({\n      oracleSalt,\n      oracleBlockNumbers: [oracleBlockNumber.add(1), oracleBlockNumber.add(1)],\n      blockHashes: [futureBlock.hash, futureBlock.hash],\n      signerIndexes,\n      tokens: [weth.address, usdc.address],\n      prices: [expandDecimals(5000, 4), expandDecimals(1, 6)],\n      signers,\n      priceFeedTokens: [],\n    });\n\n    // Cannot execute the limit increase at a block number that is past the order's updatedAtBlock\n    await expect(orderHandler.executeOrder(orderKeys[0], futureOracleParams)).to.be.revertedWith(\"ORACLE_ERROR\");\n\n    let oracleParams = await getOracleParams({\n      oracleSalt,\n      oracleBlockNumbers: [oracleBlockNumber, oracleBlockNumber],\n      blockHashes: [block.hash, block.hash],\n      signerIndexes,\n      tokens: [weth.address, usdc.address],\n      prices: [expandDecimals(5000, 4), expandDecimals(1, 6)],\n      signers,\n      priceFeedTokens: [],\n    });\n\n    // Limit increases are only able to be executed with prices from their orderUpdatedAtBlock, rendering them nearly useless\n    await orderHandler.executeOrder(orderKeys[0], oracleParams);\n    let posKeys = await positionStore.getPositionKeys(0, 1);\n    let pos = await positionStore.get(posKeys[0]);\n\n    expect(pos.sizeInTokens).to.eq(ethers.utils.parseEther(\"20\")); // 20 ETH position\n    expect(pos.sizeInUsd).to.eq(expandFloatDecimals(100000)); // $100,000\n  });\n\n  it(\"MEDIUM::ORDH-2 Phantom market decrease order\", async () => {\n    await usdc.mint(orderStore.address, expandDecimals(50000, 6));\n\n    expect(await orderStore.getOrderCount()).eq(0);\n    const params = {\n      market: ethUsdMarket.marketToken,\n      initialCollateralToken: usdc.address,\n      swapPath: [],\n      sizeDeltaUsd: expandFloatDecimals(100 * 1000),\n      acceptablePrice: expandDecimals(5000, 12),\n      acceptableUsdAdjustment: expandDecimals(-5, 12),\n      executionFee: expandDecimals(0, 15),\n      minOutputAmount: expandDecimals(0, 18),\n      orderType: OrderType.MarketIncrease,\n      isLong: true,\n      hasCollateralInETH: false,\n    };\n    await orderHandler.connect(wallet).createOrder(user0.address, params);\n\n    expect(await orderStore.getOrderCount()).eq(1);\n\n    let orderKeys = await orderStore.getOrderKeys(0, 1);\n    let order = await orderStore.get(orderKeys[0]);\n\n    let oracleBlockNumber = order.numbers.updatedAtBlock;\n    let block = await provider.getBlock(oracleBlockNumber.toNumber());\n\n    let oracleParams = await getOracleParams({\n      oracleSalt,\n      oracleBlockNumbers: [oracleBlockNumber, oracleBlockNumber],\n      blockHashes: [block.hash, block.hash],\n      signerIndexes,\n      tokens: [weth.address, usdc.address],\n      prices: [expandDecimals(5000, 4), expandDecimals(1, 6)],\n      signers,\n      priceFeedTokens: [],\n    });\n\n    const tx0 = await orderHandler.executeOrder(orderKeys[0], oracleParams);\n    let posKeys = await positionStore.getPositionKeys(0, 1);\n    let pos = await positionStore.get(posKeys[0]);\n\n    expect(pos.sizeInTokens).to.eq(ethers.utils.parseEther(\"20\")); // 20 ETH position\n    expect(pos.sizeInUsd).to.eq(expandFloatDecimals(100000)); // $100,000\n\n    // Now that we have a position, let's create 2 decrease Orders\n    const paramsDecrease = {\n      market: ethUsdMarket.marketToken,\n      initialCollateralToken: usdc.address,\n      swapPath: [],\n      sizeDeltaUsd: expandFloatDecimals(100 * 1000),\n      acceptablePrice: expandDecimals(5000, 12),\n      acceptableUsdAdjustment: expandDecimals(-5, 12),\n      executionFee: expandDecimals(0, 15),\n      minOutputAmount: expandDecimals(0, 18),\n      orderType: OrderType.MarketDecrease,\n      isLong: true,\n      hasCollateralInETH: false,\n    };\n    await orderHandler.connect(wallet).createOrder(user0.address, paramsDecrease);\n    await orderHandler.connect(wallet).createOrder(user0.address, paramsDecrease);\n\n    expect(await orderStore.getOrderCount()).eq(2);\n\n    orderKeys = await orderStore.getOrderKeys(0, 2);\n    order = await orderStore.get(orderKeys[0]);\n\n    oracleBlockNumber = order.numbers.updatedAtBlock;\n    block = await provider.getBlock(oracleBlockNumber.toNumber());\n\n    let decreaseOracleParams = await getOracleParams({\n      oracleSalt,\n      oracleBlockNumbers: [oracleBlockNumber, oracleBlockNumber],\n      blockHashes: [block.hash, block.hash],\n      signerIndexes,\n      tokens: [weth.address, usdc.address],\n      prices: [expandDecimals(5000, 4), expandDecimals(1, 6)],\n      signers,\n      priceFeedTokens: [],\n    });\n    // First decrease order is successful\n    await orderHandler.executeOrder(orderKeys[0], decreaseOracleParams);\n\n    // Second decrease order, reverts as it is for a now empty position.\n    // It is not cancelled by the keeper\n    posKeys = await positionStore.getPositionKeys(0, 1);\n    expect(posKeys.length).to.eq(0);\n    await expect(orderHandler.executeOrder(orderKeys[1], decreaseOracleParams)).to.be.revertedWith(\n      \"EMPTY_POSITION_ERROR\"\n    );\n    // Phantom market decrease order, still exists\n    expect(await orderStore.getOrderCount()).eq(1);\n\n    // Now let's make another market increase\n    await usdc.mint(orderStore.address, expandDecimals(50000, 6));\n    await orderHandler.connect(wallet).createOrder(user0.address, params);\n    expect(await orderStore.getOrderCount()).eq(2);\n\n    orderKeys = await orderStore.getOrderKeys(0, 2);\n    order = await orderStore.get(orderKeys[1]);\n    expect(order.flags.orderType).to.eq(2); // MarketIncrease;\n    let phantomDecreaseOrder = await orderStore.get(orderKeys[0]);\n    expect(phantomDecreaseOrder.flags.orderType).to.eq(4); // MarketDecrease;\n\n    oracleBlockNumber = order.numbers.updatedAtBlock;\n    block = await provider.getBlock(oracleBlockNumber.toNumber());\n\n    oracleParams = await getOracleParams({\n      oracleSalt,\n      oracleBlockNumbers: [oracleBlockNumber, oracleBlockNumber],\n      blockHashes: [block.hash, block.hash],\n      signerIndexes,\n      tokens: [weth.address, usdc.address],\n      prices: [expandDecimals(5000, 4), expandDecimals(1, 6)],\n      signers,\n      priceFeedTokens: [],\n    });\n\n    // Execute new MarketIncrease order\n    const increaseTx = await orderHandler.executeOrder(orderKeys[1], oracleParams);\n\n    oracleBlockNumber = phantomDecreaseOrder.numbers.updatedAtBlock;\n    block = await provider.getBlock(oracleBlockNumber.toNumber());\n\n    decreaseOracleParams = await getOracleParams({\n      oracleSalt,\n      oracleBlockNumbers: [oracleBlockNumber, oracleBlockNumber],\n      blockHashes: [block.hash, block.hash],\n      signerIndexes,\n      tokens: [weth.address, usdc.address],\n      prices: [expandDecimals(5000, 4), expandDecimals(1, 6)],\n      signers,\n      priceFeedTokens: [],\n    });\n    // Execute phantom decrease order\n    const decreaseTx = await orderHandler.executeOrder(orderKeys[0], decreaseOracleParams);\n    posKeys = await positionStore.getPositionKeys(0, 1);\n    expect(posKeys.length).to.eq(0); // No position\n  });\n\n  it(\"CRITICAL::GLOBAL-2 User can withdraw without depositing anything, the keeper tries to execute it and the execution is reverted without cancelling\", async () => {\n    /*\n          Users are able to create withdrawals for 0 value and they continually fail without being canceled.\n          This allows an attacker to expend the keepers gas in multiples of the executionFee they provide\n          and potentially delay execution of other deposits, withdrawals, and orders.\n        */\n    const wethAmount = expandDecimals(10, 18);\n    const usdcAmount = expandDecimals(10 * 5000, 6);\n\n    let block = await provider.getBlock();\n\n    expect(await withdrawalStore.getWithdrawalCount()).eq(0);\n    await exchangeRouter\n      .connect(user0)\n      .createWithdrawal(ethUsdMarket.marketToken, wethAmount, usdcAmount, 0, 0, false, expandDecimals(0, 15));\n    expect(await withdrawalStore.getWithdrawalCount()).eq(1);\n\n    let withdrawalKeys = await withdrawalStore.getWithdrawalKeys(0, 1);\n    let withdrawal = await withdrawalStore.get(withdrawalKeys[0]);\n\n    expect(withdrawal.account).eq(user0.address);\n    expect(withdrawal.market).eq(ethUsdMarket.marketToken);\n    expect(withdrawal.marketTokensLongAmount).eq(wethAmount);\n    expect(withdrawal.marketTokensShortAmount).eq(usdcAmount);\n    expect(withdrawal.minLongTokenAmount).eq(0);\n    expect(withdrawal.minShortTokenAmount).eq(0);\n    expect(withdrawal.updatedAtBlock).eq(block.number + 1);\n\n    block = await provider.getBlock(block.number + 1);\n    const oracleBlockNumber = block.number;\n\n    const oracleParams = await getOracleParams({\n      oracleSalt,\n      oracleBlockNumbers: [oracleBlockNumber, oracleBlockNumber],\n      blockHashes: [block.hash, block.hash],\n      signerIndexes,\n      tokens: [weth.address, usdc.address],\n      prices: [expandDecimals(5000, 4), expandDecimals(1, 6)],\n      signers,\n      priceFeedTokens: [],\n    });\n\n    const withdrawalKeeperBalanceBefore = await ethers.provider.getBalance(wallet.address);\n\n    // Try/catch does not catch this revert and order is not cancelled\n    await expect(withdrawalHandler.executeWithdrawal(withdrawalKeys[0], oracleParams)).to.be.revertedWithPanic(\n      PANIC_CODES.ARITHMETIC_UNDER_OR_OVERFLOW\n    );\n    // Withdrawal is still in the withdrawal store, the keeper may continue to attempt\n    // to execute without success nor cancellation, therefore wasting gas and potentially\n    // delaying the execution of other transactions on the exchange\n    expect(await withdrawalStore.getWithdrawalCount()).eq(1);\n\n    // Keeper attempts to retry the withdrawal, fails again\n    await expect(withdrawalHandler.executeWithdrawal(withdrawalKeys[0], oracleParams)).to.be.revertedWithPanic(\n      PANIC_CODES.ARITHMETIC_UNDER_OR_OVERFLOW\n    );\n\n    const withdrawalKeeperBalanceAfter = await ethers.provider.getBalance(wallet.address);\n    // Notice that the keeper expends more gas than the user initially provided with the executionFee\n    expect(withdrawalKeeperBalanceBefore.sub(withdrawalKeeperBalanceAfter)).to.be.gt(executionFee);\n  });\n\n  it(\"HIGH::GLOBAL-3 Decrease order lacks cross-liquidity to execute\", async () => {\n    expect(await usdc.balanceOf(ethUsdMarket.marketToken)).eq(0);\n    expect(await getBalanceOf(weth.address, ethUsdMarket.marketToken)).to.eq(\"999999000000000000000\");\n\n    await usdc.mint(orderStore.address, expandDecimals(50000, 6));\n\n    expect(await orderStore.getOrderCount()).eq(0);\n    const params = {\n      market: ethUsdMarket.marketToken,\n      initialCollateralToken: usdc.address,\n      swapPath: [],\n      sizeDeltaUsd: expandFloatDecimals(1000 * 1000),\n      acceptablePrice: expandDecimals(5000, 12),\n      acceptableUsdAdjustment: expandDecimals(-5, 12),\n      executionFee: expandDecimals(0, 15),\n      minOutputAmount: expandDecimals(0, 18),\n      orderType: OrderType.MarketIncrease,\n      isLong: true,\n      hasCollateralInETH: false,\n    };\n    await orderHandler.connect(wallet).createOrder(user0.address, params);\n    expect(await orderStore.getOrderCount()).eq(1);\n\n    let orderKeys = await orderStore.getOrderKeys(0, 1);\n    let order = await orderStore.get(orderKeys[0]);\n\n    let oracleBlockNumber = order.numbers.updatedAtBlock;\n    let block = await provider.getBlock(oracleBlockNumber.toNumber());\n\n    let oracleParams = await getOracleParams({\n      oracleSalt,\n      oracleBlockNumbers: [oracleBlockNumber, oracleBlockNumber],\n      blockHashes: [block.hash, block.hash],\n      signerIndexes,\n      tokens: [weth.address, usdc.address],\n      prices: [expandDecimals(5000, 4), expandDecimals(1, 6)],\n      signers,\n      priceFeedTokens: [],\n    });\n\n    // Open a position with $50,000 usdc collateral @ 20x long eth\n    const initIncreaseOrder = await orderHandler.executeOrder(orderKeys[0], oracleParams);\n    let posKeys = await positionStore.getPositionKeys(0, 1);\n    let pos = await positionStore.get(posKeys[0]);\n    expect(pos.sizeInUsd).to.eq(expandFloatDecimals(1000000)); // $1,000,000\n    expect(await usdc.balanceOf(ethUsdMarket.marketToken)).eq(expandDecimals(50000, 6));\n\n    // Now that we have a position, let's create a decrease order\n    const paramsDecrease = {\n      market: ethUsdMarket.marketToken,\n      // Must provide usdc as the initialCollateralToken -- as the initial position\n      // was opened with usdc as collateral and positions are keyed based on initialCollateralToken\n      initialCollateralToken: usdc.address,\n      swapPath: [],\n      sizeDeltaUsd: expandFloatDecimals(1000 * 1000),\n      acceptablePrice: expandDecimals(5000, 12),\n      acceptableUsdAdjustment: expandDecimals(-5, 12),\n      executionFee: expandDecimals(0, 15),\n      minOutputAmount: expandDecimals(0, 18),\n      orderType: OrderType.MarketDecrease,\n      isLong: true,\n      hasCollateralInETH: false,\n    };\n    await orderHandler.connect(wallet).createOrder(user0.address, paramsDecrease);\n    expect(await orderStore.getOrderCount()).eq(1);\n\n    orderKeys = await orderStore.getOrderKeys(0, 1);\n    let decreaseKey = orderKeys[0];\n    let decreaseOrder = await orderStore.get(decreaseKey);\n\n    let decreaseOracleBlockNumber = decreaseOrder.numbers.updatedAtBlock;\n    let decreaseBlock = await provider.getBlock(decreaseOracleBlockNumber.toNumber());\n\n    let decreaseOracleParams = await getOracleParams({\n      oracleSalt,\n      oracleBlockNumbers: [decreaseOracleBlockNumber, decreaseOracleBlockNumber],\n      blockHashes: [decreaseBlock.hash, decreaseBlock.hash],\n      signerIndexes,\n      tokens: [weth.address, usdc.address],\n      prices: [expandDecimals(5001, 4), expandDecimals(1, 6)], // Price up by only $1\n      signers,\n      priceFeedTokens: [],\n    });\n\n    // Notice that the user is unable to withdraw their profit or recoup any of their\n    // collateral, until more usdc liquidity is available.\n    await expect(orderHandler.executeOrder(decreaseKey, decreaseOracleParams)).to.be.revertedWithCustomError(\n      marketUtils,\n      \"InsufficientPoolAmount\"\n    );\n    // However there is more than enough ether in the market to allow the user to withdraw their collateral + profit\n    // But because the position is keyed based on initialCollateralToken, the user cannot\n    // use this capital -- even though they have a right to it.\n    expect(await getBalanceOf(weth.address, ethUsdMarket.marketToken)).to.eq(\"999999000000000000000\");\n    decreaseOrder = await orderStore.get(decreaseKey);\n    // Decrease order still in store due to revert\n    expect(decreaseOrder.numbers.sizeDeltaUsd).to.be.eq(expandFloatDecimals(1000 * 1000));\n  });\n\n  it(\"CRITICAL::DOU-1 Can create a phantom MarketDecrease order to game the exchange\", async () => {\n    // Increase order at size x, decrease at size y where y > x, decrease still exists at size x\n    // post-execution. This means the prices from the block the decrease order was created\n    // can be used to someone's advantage.\n\n    // Increase order -> decrease order -> increase order executed -> decrease order executed\n    // 0 position and a decrease order\n    // create an increase order, execute it ($4500 at block 50), then I can execute decrease order ($5000 at block 1) and make profit\n\n    await weth.mint(orderStore.address, expandDecimals(1000, 18));\n\n    expect(await orderStore.getOrderCount()).eq(0);\n    const params = {\n      market: ethUsdMarket.marketToken,\n      initialCollateralToken: weth.address,\n      swapPath: [],\n      sizeDeltaUsd: expandFloatDecimals(100 * 1000),\n      acceptablePrice: expandDecimals(5000, 12),\n      acceptableUsdAdjustment: expandDecimals(-5, 12),\n      executionFee: expandDecimals(0, 15),\n      minOutputAmount: expandDecimals(0, 18),\n      orderType: OrderType.MarketIncrease,\n      isLong: true,\n      hasCollateralInETH: false,\n    };\n    await orderHandler.connect(wallet).createOrder(user0.address, params);\n    expect(await orderStore.getOrderCount()).eq(1);\n\n    let orderKeys = await orderStore.getOrderKeys(0, 1);\n    let order = await orderStore.get(orderKeys[0]);\n\n    let oracleBlockNumber = order.numbers.updatedAtBlock;\n    let block = await provider.getBlock(oracleBlockNumber.toNumber());\n\n    let oracleParams = await getOracleParams({\n      oracleSalt,\n      oracleBlockNumbers: [oracleBlockNumber, oracleBlockNumber],\n      blockHashes: [block.hash, block.hash],\n      signerIndexes,\n      tokens: [weth.address, usdc.address],\n      prices: [expandDecimals(5000, 4), expandDecimals(1, 6)],\n      signers,\n      priceFeedTokens: [],\n    });\n\n    const tx0 = await orderHandler.executeOrder(orderKeys[0], oracleParams);\n    let posKeys = await positionStore.getPositionKeys(0, 1);\n    let pos = await positionStore.get(posKeys[0]);\n    expect(pos.sizeInUsd).to.eq(expandFloatDecimals(100000)); // $100,000\n\n    // Now that we have a position, let's create a decrease order that is greater in usdSize than the increase\n    const paramsDecrease = {\n      market: ethUsdMarket.marketToken,\n      initialCollateralToken: weth.address,\n      swapPath: [],\n      sizeDeltaUsd: expandFloatDecimals(100 * 1001),\n      acceptablePrice: expandDecimals(5000, 12),\n      acceptableUsdAdjustment: expandDecimals(-5, 12),\n      executionFee: expandDecimals(0, 15),\n      minOutputAmount: expandDecimals(0, 18),\n      orderType: OrderType.MarketDecrease,\n      isLong: true,\n      hasCollateralInETH: false,\n    };\n    await orderHandler.connect(wallet).createOrder(user0.address, paramsDecrease);\n    expect(await orderStore.getOrderCount()).eq(1);\n\n    orderKeys = await orderStore.getOrderKeys(0, 1);\n    order = await orderStore.get(orderKeys[0]);\n\n    let decreaseOracleBlockNumber = order.numbers.updatedAtBlock;\n    let decreaseBlock = await provider.getBlock(decreaseOracleBlockNumber.toNumber());\n\n    let decreaseOracleParams = await getOracleParams({\n      oracleSalt,\n      oracleBlockNumbers: [decreaseOracleBlockNumber, decreaseOracleBlockNumber],\n      blockHashes: [decreaseBlock.hash, decreaseBlock.hash],\n      signerIndexes,\n      tokens: [weth.address, usdc.address],\n      prices: [expandDecimals(5000, 4), expandDecimals(1, 6)],\n      signers,\n      priceFeedTokens: [],\n    });\n    const tx1 = await orderHandler.executeOrder(orderKeys[0], decreaseOracleParams);\n    // At this point we should no longer have a position, and we should have a decrease order in the store\n    posKeys = await positionStore.getPositionKeys(0, 1);\n    expect(posKeys.length).to.eq(0);\n    let wethBefore = await weth.balanceOf(user0.address);\n\n    // Phantom market decrease order -- exists with the size of the position you just removed\n    expect(await orderStore.getOrderCount()).eq(1);\n    orderKeys = await orderStore.getOrderKeys(0, 1);\n    order = await orderStore.get(orderKeys[0]);\n    expect(order.numbers.sizeDeltaUsd).to.eq(expandFloatDecimals(100 * 1000));\n\n    // Now let's make another market increase\n    await weth.mint(orderStore.address, expandDecimals(1000, 18));\n    await orderHandler\n      .connect(wallet)\n      .createOrder(user0.address, { ...params, sizeDeltaUsd: expandFloatDecimals(99 * 1000) });\n    expect(await orderStore.getOrderCount()).eq(2);\n\n    // Verify both order types are present\n    orderKeys = await orderStore.getOrderKeys(0, 2);\n    order = await orderStore.get(orderKeys[1]);\n    expect(order.flags.orderType).to.eq(2); // MarketIncrease;\n    let phantomDecreaseOrder = await orderStore.get(orderKeys[0]);\n    expect(phantomDecreaseOrder.flags.orderType).to.eq(4); // MarketDecrease;\n\n    oracleBlockNumber = order.numbers.updatedAtBlock;\n    block = await provider.getBlock(oracleBlockNumber.toNumber());\n\n    oracleParams = await getOracleParams({\n      oracleSalt,\n      oracleBlockNumbers: [oracleBlockNumber, oracleBlockNumber],\n      blockHashes: [block.hash, block.hash],\n      signerIndexes,\n      tokens: [weth.address, usdc.address],\n      prices: [expandDecimals(1000, 4), expandDecimals(1, 6)], // price is lower than that of decrease\n      signers,\n      priceFeedTokens: [],\n    });\n\n    // Execute new MarketIncrease order"
    }
  ]
}