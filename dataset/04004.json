{
  "Title": "[L03] Downtime slash is frontrunnable",
  "Content": "The [`DowntimeSlasher` contract](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/governance/DowntimeSlasher.sol#L9) holds the logic for the offline-validators protocol’s slashing process. The [`bitmaps` mapping](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/governance/DowntimeSlasher.sol#L17) is a complex data structure which is written in the [`setBitmapForInterval` function](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/governance/DowntimeSlasher.sol#L121), and maps the bitmap information to the address of the reporter of the downtime. The `bitmaps` mapping is then used to validate if a certain validator was down in a specific interval in the [`wasDownForInterval` function](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/governance/DowntimeSlasher.sol#L136-L148). This last function is the core component that will eventually be used by the [`slash` function](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/governance/DowntimeSlasher.sol#L245-L298) to perform the slash.\n\n\nThe `slash` function is frontrunnable; any new reporter that sees other `slash` function call in the mempool of the node can write the `bitmaps` mapping by calling the `setBitmapForInterval` function and then calling the `slash` function with the same parameters as the original transaction in the mempool.\n\n\nThis behavior seems to be expected and probably incouraged as it is in the best interest of the network to slash misbehaving validators as quickly as possible. However, this behavior could also generate a war between different frontrunning bots, adding noise and higher gas prices when the Celo network is more mature and in high demand.\n\n\nIn the future, consider penalizing reporters that send false downtime proofs so that frontrunning bots need to calculate whether the `slash` transactions in the mempool are correct instead of spamming the network.\n\n\n***Update**: Acknowledged, and will not fix. The cLabs team’s response was:*\n\n\n\n> \n> The reward received for slashing a validator is unlikely to warrant intense competition, and is simply meant to subsidize the cost of the slash transaction itself. The relative cost of the failed clone transactions is likely to make these frontrunning attempts unprofitable, and the network can govern the penalty/reward ratio if this ever becomes a throughput bottleneck.\n> \n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/governance/DowntimeSlasher.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\nimport \"./SlasherUtil.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\n\ncontract DowntimeSlasher is ICeloVersionedContract, SlasherUtil {\n  using SafeMath for uint256;\n\n  // Maps validator address -> end block of the latest interval for which it has been slashed.\n  mapping(address => uint256) public lastSlashedBlock;\n\n  // Maps user address -> startBlock -> endBlock -> signature bitmap for that interval.\n  // Note that startBlock and endBlock must always be in the same epoch.\n  mapping(address => mapping(uint256 => mapping(uint256 => bytes32))) public bitmaps;\n\n  uint256 public slashableDowntime;\n\n  event SlashableDowntimeSet(uint256 interval);\n  event DowntimeSlashPerformed(\n    address indexed validator,\n    uint256 indexed startBlock,\n    uint256 indexed endBlock\n  );\n  event BitmapSetForInterval(uint256 indexed startBlock, uint256 indexed endBlock, bytes32 bitmap);\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return The storage, major, minor, and patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (2, 0, 0, 0);\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   * @param _penalty Penalty for the slashed validator.\n   * @param _reward Reward that the observer gets.\n   * @param _slashableDowntime Slashable downtime in blocks.\n   */\n  function initialize(\n    address registryAddress,\n    uint256 _penalty,\n    uint256 _reward,\n    uint256 _slashableDowntime\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setSlashingIncentives(_penalty, _reward);\n    setSlashableDowntime(_slashableDowntime);\n  }\n\n  /**\n   * @notice Sets the slashable downtime.\n   * @param interval Slashable downtime in blocks.\n   */\n  function setSlashableDowntime(uint256 interval) public onlyOwner {\n    require(interval != 0, \"slashable downtime cannot be zero\");\n    slashableDowntime = interval;\n    emit SlashableDowntimeSet(interval);\n  }\n\n  /**\n   * @notice Calculates and returns the signature bitmap for the specified interval.\n   * This bitmap will contain a one for any validator that signed at least one block in that\n   * interval, and zero otherwise.\n   * @param startBlock First block of the interval.\n   * @param endBlock Last block of the interval.\n   * @return The signature uptime bitmap for the specified interval.\n   * @dev startBlock and endBlock must be in the same epoch.\n   * @dev The getParentSealBitmap precompile requires that startBlock must be within 4 epochs of \n   * the current block.\n   */\n  function getBitmapForInterval(uint256 startBlock, uint256 endBlock)\n    public\n    view\n    returns (bytes32)\n  {\n    require(endBlock >= startBlock, \"endBlock must be greater or equal than startBlock\");\n    // The signature bitmap for block N is stored in block N+1.\n    // The latest block is `block.number - 1`, which stores the signature bitmap for\n    // `block.number - 2`.\n    uint256 lastBlockWithSignatureBitmap = block.number.sub(2);\n    require(\n      endBlock <= lastBlockWithSignatureBitmap,\n      \"the signature bitmap for endBlock is not yet available\"\n    );\n    uint256 epochSize = getEpochSize();\n    require(\n      block.number.sub(startBlock) < epochSize.mul(4),\n      \"startBlock must be within 4 epochs of the current head\"\n    );\n    require(\n      epochNumberOfBlock(startBlock, epochSize) == epochNumberOfBlock(endBlock, epochSize),\n      \"startBlock and endBlock must be in the same epoch\"\n    );\n\n    bytes32 bitmap;\n    for (uint256 blockNumber = startBlock; blockNumber <= endBlock; blockNumber++) {\n      // The canonical signatures for block N are stored in the parent seal bitmap for block N+1.\n      bitmap |= getParentSealBitmap(blockNumber.add(1));\n    }\n\n    return bitmap;\n  }\n\n  /**\n   * @notice Calculates and sets the signature bitmap for the specified interval.\n   * @param startBlock First block of the interval.\n   * @param endBlock Last block of the interval.\n   * @return The signature bitmap for the specified interval.\n   * @dev startBlock and endBlock must be in the same epoch.\n   */\n  function setBitmapForInterval(uint256 startBlock, uint256 endBlock) public returns (bytes32) {\n    require(!isBitmapSetForInterval(startBlock, endBlock), \"bitmap already set\");\n\n    bytes32 bitmap = getBitmapForInterval(startBlock, endBlock);\n    bitmaps[msg.sender][startBlock][endBlock] = bitmap;\n\n    emit BitmapSetForInterval(startBlock, endBlock, bitmap);\n\n    return bitmap;\n  }\n\n  /**\n   * @notice Returns true if the validator did not sign any blocks in the specified interval.\n   * @param startBlock First block of the interval.\n   * @param endBlock Last block of the interval.\n   * @param signerIndex Index of the signer within the validator set.\n   * @return True if the validator did not sign any blocks in the specified interval.\n   * @dev Both startBlock and endBlock should be part of the same epoch.\n   */\n  function wasDownForInterval(uint256 startBlock, uint256 endBlock, uint256 signerIndex)\n    public\n    view\n    returns (bool)\n  {\n    require(signerIndex < numberValidatorsInSet(startBlock), \"bad validator index at start block\");\n    require(\n      isBitmapSetForInterval(startBlock, endBlock),\n      \"bitmap for specified interval not yet set\"\n    );\n\n    return (bitmaps[msg.sender][startBlock][endBlock] & bytes32(1 << signerIndex)) == 0;\n  }\n\n  /**\n   * @notice Returns true if the bitmap has been set for the specified interval.\n   * @param startBlock First block of the interval.\n   * @param endBlock Last block of the interval.\n   * @return True if the bitmap has been set for the specified interval.\n   */\n  function isBitmapSetForInterval(uint256 startBlock, uint256 endBlock) public view returns (bool) {\n    // It's impossible to have all the validators down in an interval.\n    return bitmaps[msg.sender][startBlock][endBlock] != 0;\n  }\n\n  /**\n   * @notice Returns true if a validator has been down for the specified overlapping or adjacent\n   * intervals.\n   * @param startBlocks A list of interval start blocks for which signature bitmaps have already\n   * been set.\n   * @param endBlocks A list of interval end blocks for which signature bitmaps have already\n   * been set.\n   * @param signerIndices Indices of the signer within the validator set for every epoch change.\n   * @return True if the validator signature does not appear in any block within the window.\n   */\n  function wasDownForIntervals(\n    uint256[] memory startBlocks,\n    uint256[] memory endBlocks,\n    uint256[] memory signerIndices\n  ) public view returns (bool) {\n    require(startBlocks.length > 0, \"requires at least one interval\");\n    require(\n      startBlocks.length == endBlocks.length,\n      \"startBlocks and endBlocks must have the same length\"\n    );\n    require(signerIndices.length > 0, \"requires at least one signerIndex\");\n\n    uint256 epochSize = getEpochSize();\n    uint256 signerIndicesIndex = 0;\n    for (uint256 i = 0; i < startBlocks.length; i = i.add(1)) {\n      if (i > 0) {\n        require(\n          startBlocks[i.sub(1)] < startBlocks[i],\n          \"each interval must start after the start of the previous interval\"\n        );\n        require(\n          startBlocks[i] <= endBlocks[i.sub(1)].add(1),\n          \"each interval must start at most one block after the end of the previous interval\"\n        );\n        require(\n          endBlocks[i.sub(1)] < endBlocks[i],\n          \"each interval must end after the end of the previous interval\"\n        );\n        // The signer index of a particular validator may change from epoch to epoch.\n        // Because the intervals for which bitmaps are calculated in this contract do not span\n        // epochs, and because intervals processed by this function are guaranteed to be\n        // overlapping or contiguous, whenever we cross epoch boundaries we are guaranteed to\n        // process an interval that starts with the first block of that epoch.\n        if (startBlocks[i].mod(epochSize) == 1) {\n          require(\n            getValidatorAccountFromSignerIndex(\n              signerIndices[signerIndicesIndex],\n              startBlocks[i].sub(1)\n            ) ==\n              getValidatorAccountFromSignerIndex(\n                signerIndices[signerIndicesIndex.add(1)],\n                startBlocks[i]\n              ),\n            \"indices do not point to the same validator\"\n          );\n          signerIndicesIndex = signerIndicesIndex.add(1);\n        }\n      }\n      if (!wasDownForInterval(startBlocks[i], endBlocks[i], signerIndices[signerIndicesIndex])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * @notice Slashes a validator that did not sign any blocks for at least `slashableDowntime`.\n   * @param startBlocks A list of interval start blocks for which signature bitmaps have already\n   * been set.\n   * @param endBlocks A list of interval end blocks for which signature bitmaps have already\n   * been set.\n   * @param signerIndices The index of the provided validator for each epoch over which the\n   * provided intervals span.\n   * @param groupMembershipHistoryIndex Group membership index from where\n   * the group should be found (For start block).\n   * @param validatorElectionLessers Lesser pointers for validator slashing.\n   * @param validatorElectionGreaters Greater pointers for validator slashing.\n   * @param validatorElectionIndices Vote indices for validator slashing.\n   * @param groupElectionLessers Lesser pointers for group slashing.\n   * @param groupElectionGreaters Greater pointers for group slashing.\n   * @param groupElectionIndices Vote indices for group slashing.\n   * @dev startBlocks[0] will be use as the startBlock of the slashableDowntime.\n   */\n  function slash(\n    uint256[] memory startBlocks,\n    uint256[] memory endBlocks,\n    uint256[] memory signerIndices,\n    uint256 groupMembershipHistoryIndex,\n    address[] memory validatorElectionLessers,\n    address[] memory validatorElectionGreaters,\n    uint256[] memory validatorElectionIndices,\n    address[] memory groupElectionLessers,\n    address[] memory groupElectionGreaters,\n    uint256[] memory groupElectionIndices\n  ) public {\n    uint256 startBlock = startBlocks[0];\n    uint256 endBlock = endBlocks[endBlocks.length.sub(1)];\n    require(\n      endBlock.sub(startBlock).add(1) >= slashableDowntime,\n      \"the provided intervals must span slashableDowntime blocks\"\n    );\n    address validator = getValidatorAccountFromSignerIndex(signerIndices[0], startBlock);\n    require(\n      startBlock > lastSlashedBlock[validator],\n      \"cannot slash validator for downtime for which they may already have been slashed\"\n    );\n    require(wasDownForIntervals(startBlocks, endBlocks, signerIndices), \"not down\");\n    lastSlashedBlock[validator] = endBlock;\n    performSlashing(\n      validator,\n      msg.sender,\n      startBlock,\n      groupMembershipHistoryIndex,\n      validatorElectionLessers,\n      validatorElectionGreaters,\n      validatorElectionIndices,\n      groupElectionLessers,\n      groupElectionGreaters,\n      groupElectionIndices\n    );\n    emit DowntimeSlashPerformed(validator, startBlock, endBlock);\n  }\n\n  /**\n   * @notice Returns the validator's address of the signer for a specific block number.\n   * @param signerIndex Index of the signer within the validator set for a specific epoch.\n   * @param blockNumber Block number where the validator was elected.\n   * @return Validator's address.\n   */\n  function getValidatorAccountFromSignerIndex(uint256 signerIndex, uint256 blockNumber)\n    internal\n    view\n    returns (address)\n  {\n    return getAccounts().signerToAccount(validatorSignerAddressFromSet(signerIndex, blockNumber));\n  }\n}"
    }
  ]
}