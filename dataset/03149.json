{
  "Title": "Callback verification",
  "Content": "##### Description\nBy mistake a callback which has no implementation of the`processLidoOracleReport()` method can be added at the line:\nhttps://github.com/lidofinance/lido-dao/blob/801d3e854efb33ff33a59fe51187e187047a6be2/contracts/0.8.9/OrderedCallbacksArray.sol#L60\nIn case you set the `IBeaconReportReceiver`  address, the  execution of the following lines will be reverted.\nhttps://github.com/lidofinance/lido-dao/blob/801d3e854efb33ff33a59fe51187e187047a6be2/contracts/0.4.24/oracle/LidoOracle.sol#L644\n##### Recommendation\nIt is necessary to add verification of the existing `processLidoOracleReport()` method in callback or callbacks should be double-checked before adding.\nSee this standard: https://eips.ethereum.org/EIPS/eip-165.",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/0.8.9/OrderedCallbacksArray.sol",
      "content": "// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\n\n// SPDX-License-Identifier: GPL-3.0\n\n/* See contracts/COMPILERS.md */\npragma solidity 0.8.9;\n\nimport \"./interfaces/IOrderedCallbacksArray.sol\";\n\n/**\n  * @title Contract defining an ordered callbacks array supporting add/insert/remove ops\n  *\n  * Contract adds permission modifiers ontop of `IOderedCallbacksArray` interface functions.\n  * Only the `VOTING` address can invoke storage mutating (add/insert/remove) functions.\n  */\ncontract OrderedCallbacksArray is IOrderedCallbacksArray {\n    uint256 public constant MAX_CALLBACKS_COUNT = 16;\n\n    address public immutable VOTING;\n\n    address[] public callbacks;\n\n    modifier onlyVoting() {\n        require(msg.sender == VOTING, \"MSG_SENDER_MUST_BE_VOTING\");\n        _;\n    }\n\n    constructor(address _voting) {\n        require(_voting != address(0), \"VOTING_ZERO_ADDRESS\");\n\n        VOTING = _voting;\n    }\n\n    function callbacksLength() public view override returns (uint256) {\n        return callbacks.length;\n    }\n\n    function addCallback(address _callback) external override onlyVoting {\n        _insertCallback(_callback, callbacks.length);\n    }\n\n    function insertCallback(address _callback, uint256 _atIndex) external override onlyVoting {\n        _insertCallback(_callback, _atIndex);\n    }\n\n    function removeCallback(uint256 _atIndex) external override onlyVoting {\n        uint256 oldCArrayLength = callbacks.length;\n        require(_atIndex < oldCArrayLength, \"INDEX_IS_OUT_OF_RANGE\");\n\n        emit CallbackRemoved(callbacks[_atIndex], _atIndex);\n\n        for (uint256 cIndex = _atIndex; cIndex < oldCArrayLength-1; cIndex++) {\n            callbacks[cIndex] = callbacks[cIndex+1];\n        }\n\n        callbacks.pop();\n    }\n\n    function _insertCallback(address _callback, uint256 _atIndex) private {\n        require(_callback != address(0), \"CALLBACK_ZERO_ADDRESS\");\n\n        uint256 oldCArrayLength = callbacks.length;\n        require(_atIndex <= oldCArrayLength, \"INDEX_IS_OUT_OF_RANGE\");\n        require(oldCArrayLength < MAX_CALLBACKS_COUNT, \"MAX_CALLBACKS_COUNT_EXCEEDED\");\n\n        emit CallbackAdded(_callback, _atIndex);\n\n        callbacks.push();\n\n        if (oldCArrayLength > 0) {\n            for (uint256 cIndex = oldCArrayLength; cIndex > _atIndex; cIndex--) {\n                callbacks[cIndex] = callbacks[cIndex-1];\n            }\n        }\n\n        callbacks[_atIndex] = _callback;\n    }\n}"
    },
    {
      "filename": "contracts/0.4.24/oracle/LidoOracle.sol",
      "content": "// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\n\n// SPDX-License-Identifier: GPL-3.0\n\n/* See contracts/COMPILERS.md */\npragma solidity 0.4.24;\n\nimport \"@aragon/os/contracts/apps/AragonApp.sol\";\nimport \"@aragon/os/contracts/lib/math/SafeMath.sol\";\n\nimport \"../interfaces/IBeaconReportReceiver.sol\";\nimport \"../interfaces/ILido.sol\";\nimport \"../interfaces/ILidoOracle.sol\";\n\nimport \"./ReportUtils.sol\";\n\n/**\n * @title Implementation of an ETH 2.0 -> ETH oracle\n *\n * The goal of the oracle is to inform other parts of the system about balances controlled by the\n * DAO on the ETH 2.0 side. The balances can go up because of reward accumulation and can go down\n * because of slashing.\n *\n * The timeline is divided into consecutive frames. Every oracle member may push its report once\n * per frame. When the equal reports reach the configurable 'quorum' value, this frame is\n * considered finalized and the resulting report is pushed to Lido.\n *\n * Not all frames may come to a quorum. Oracles may report only to the first epoch of the frame and\n * only if no quorum is reached for this epoch yet.\n */\ncontract LidoOracle is ILidoOracle, AragonApp {\n    using SafeMath for uint256;\n    using ReportUtils for uint256;\n\n    struct BeaconSpec {\n        uint64 epochsPerFrame;\n        uint64 slotsPerEpoch;\n        uint64 secondsPerSlot;\n        uint64 genesisTime;\n    }\n\n    /// ACL\n    bytes32 constant public MANAGE_MEMBERS =\n        0xbf6336045918ae0015f4cdb3441a2fdbfaa4bcde6558c8692aac7f56c69fb067; // keccak256(\"MANAGE_MEMBERS\")\n    bytes32 constant public MANAGE_QUORUM =\n        0xa5ffa9f45fa52c446078e834e1914561bd9c2ab1e833572d62af775da092ccbc; // keccak256(\"MANAGE_QUORUM\")\n    bytes32 constant public SET_BEACON_SPEC =\n        0x16a273d48baf8111397316e6d961e6836913acb23b181e6c5fb35ec0bd2648fc; // keccak256(\"SET_BEACON_SPEC\")\n    bytes32 constant public SET_REPORT_BOUNDARIES =\n        0x44adaee26c92733e57241cb0b26ffaa2d182ed7120ba3ecd7e0dce3635c01dc1; // keccak256(\"SET_REPORT_BOUNDARIES\")\n    bytes32 constant public SET_BEACON_REPORT_RECEIVER =\n        0xe22a455f1bfbaf705ac3e891a64e156da92cb0b42cfc389158e6e82bd57f37be; // keccak256(\"SET_BEACON_REPORT_RECEIVER\")\n\n    /// Maximum number of oracle committee members\n    uint256 public constant MAX_MEMBERS = 256;\n\n    /// Eth1 denomination is 18 digits, while Eth2 has 9 digits. Because we work with Eth2\n    /// balances and to support old interfaces expecting eth1 format, we multiply by this\n    /// coefficient.\n    uint128 internal constant DENOMINATION_OFFSET = 1e9;\n\n    uint256 internal constant MEMBER_NOT_FOUND = uint256(-1);\n\n    /// Number of exactly the same reports needed to finalize the epoch\n    bytes32 internal constant QUORUM_POSITION =\n        0xd43b42c1ba05a1ab3c178623a49b2cdb55f000ec70b9ccdba5740b3339a7589e; // keccak256(\"lido.LidoOracle.quorum\")\n\n    /// Address of the Lido contract\n    bytes32 internal constant LIDO_POSITION =\n        0xf6978a4f7e200f6d3a24d82d44c48bddabce399a3b8ec42a480ea8a2d5fe6ec5; // keccak256(\"lido.LidoOracle.lido\")\n\n    /// Storage for the actual beacon chain specification\n    bytes32 internal constant BEACON_SPEC_POSITION =\n        0x805e82d53a51be3dfde7cfed901f1f96f5dad18e874708b082adb8841e8ca909; // keccak256(\"lido.LidoOracle.beaconSpec\")\n\n    /// Version of the initialized contract data\n    /// NB: Contract versioning starts from 1.\n    /// This version sotred in CONTRACT_VERSION_POSITION equals to\n    /// - 0 right after deployment when no initializer is invoked yet\n    /// - N after calling initialize() during  deployment from scratch, where N is the current contract version\n    /// - N after upgrading contract from the previous version (after calling finalize_vN())\n    bytes32 internal constant CONTRACT_VERSION_POSITION =\n        0x75be19a3f314d89bd1f84d30a6c84e2f1cd7afc7b6ca21876564c265113bb7e4; // keccak256(\"lido.LidoOracle.contractVersion\")\n\n    /// Epoch that we currently collect reports\n    bytes32 internal constant EXPECTED_EPOCH_ID_POSITION =\n        0x65f1a0ee358a8a4000a59c2815dc768eb87d24146ca1ac5555cb6eb871aee915; // keccak256(\"lido.LidoOracle.expectedEpochId\")\n\n    /// The bitmask of the oracle members that pushed their reports\n    bytes32 internal constant REPORTS_BITMASK_POSITION =\n        0xea6fa022365e4737a3bb52facb00ddc693a656fb51ffb2b4bd24fb85bdc888be; // keccak256(\"lido.LidoOracle.reportsBitMask\")\n\n    /// Historic data about 2 last completed reports and their times\n    bytes32 internal constant POST_COMPLETED_TOTAL_POOLED_ETHER_POSITION =\n        0xaa8433b13d2b111d4f84f6f374bc7acbe20794944308876aa250fa9a73dc7f53; // keccak256(\"lido.LidoOracle.postCompletedTotalPooledEther\")\n    bytes32 internal constant PRE_COMPLETED_TOTAL_POOLED_ETHER_POSITION =\n        0x1043177539af09a67d747435df3ff1155a64cd93a347daaac9132a591442d43e; // keccak256(\"lido.LidoOracle.preCompletedTotalPooledEther\")\n    bytes32 internal constant LAST_COMPLETED_EPOCH_ID_POSITION =\n        0xdad15c0beecd15610092d84427258e369d2582df22869138b4c5265f049f574c; // keccak256(\"lido.LidoOracle.lastCompletedEpochId\")\n    bytes32 internal constant TIME_ELAPSED_POSITION =\n        0x8fe323f4ecd3bf0497252a90142003855cc5125cee76a5b5ba5d508c7ec28c3a; // keccak256(\"lido.LidoOracle.timeElapsed\")\n\n    /// Receiver address to be called when the report is pushed to Lido\n    bytes32 internal constant BEACON_REPORT_RECEIVER_POSITION =\n        0xb59039ed37776bc23c5d272e10b525a957a1dfad97f5006c84394b6b512c1564; // keccak256(\"lido.LidoOracle.beaconReportReceiver\")\n\n    /// Upper bound of the reported balance possible increase in APR, controlled by the governance\n    bytes32 internal constant ALLOWED_BEACON_BALANCE_ANNUAL_RELATIVE_INCREASE_POSITION =\n        0x613075ab597bed8ce2e18342385ce127d3e5298bc7a84e3db68dc64abd4811ac; // keccak256(\"lido.LidoOracle.allowedBeaconBalanceAnnualRelativeIncrease\")\n\n    /// Lower bound of the reported balance possible decrease, controlled by the governance\n    ///\n    /// @notice When slashing happens, the balance may decrease at a much faster pace. Slashing are\n    /// one-time events that decrease the balance a fair amount - a few percent at a time in a\n    /// realistic scenario. Thus, instead of sanity check for an APR, we check if the plain relative\n    /// decrease is within bounds.  Note that it's not annual value, its just one-jump value.\n    bytes32 internal constant ALLOWED_BEACON_BALANCE_RELATIVE_DECREASE_POSITION =\n        0x92ba7776ed6c5d13cf023555a94e70b823a4aebd56ed522a77345ff5cd8a9109; // keccak256(\"lido.LidoOracle.allowedBeaconBalanceDecrease\")\n\n    /// This is a dead variable: it was used only in v1 and in upgrade v1 --> v2\n    /// Just keep in mind that storage at this position is occupied but with no actual usage\n    bytes32 internal constant V1_LAST_REPORTED_EPOCH_ID_POSITION =\n        0xfe0250ed0c5d8af6526c6d133fccb8e5a55dd6b1aa6696ed0c327f8e517b5a94; // keccak256(\"lido.LidoOracle.lastReportedEpochId\")\n\n    /// Contract structured storage\n    address[] private members;                /// slot 0: oracle committee members\n    uint256[] private currentReportVariants;  /// slot 1: reporting storage\n\n\n    /**\n     * @notice Return the Lido contract address\n     */\n    function getLido() public view returns (ILido) {\n        return ILido(LIDO_POSITION.getStorageAddress());\n    }\n\n    /**\n     * @notice Return the number of exactly the same reports needed to finalize the epoch\n     */\n    function getQuorum() public view returns (uint256) {\n        return QUORUM_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Return the upper bound of the reported balance possible increase in APR\n     */\n    function getAllowedBeaconBalanceAnnualRelativeIncrease() external view returns (uint256) {\n        return ALLOWED_BEACON_BALANCE_ANNUAL_RELATIVE_INCREASE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Return the lower bound of the reported balance possible decrease\n     */\n    function getAllowedBeaconBalanceRelativeDecrease() external view returns (uint256) {\n        return ALLOWED_BEACON_BALANCE_RELATIVE_DECREASE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Set the upper bound of the reported balance possible increase in APR to `_value`\n     */\n    function setAllowedBeaconBalanceAnnualRelativeIncrease(uint256 _value) external auth(SET_REPORT_BOUNDARIES) {\n        ALLOWED_BEACON_BALANCE_ANNUAL_RELATIVE_INCREASE_POSITION.setStorageUint256(_value);\n        emit AllowedBeaconBalanceAnnualRelativeIncreaseSet(_value);\n    }\n\n    /**\n     * @notice Set the lower bound of the reported balance possible decrease to `_value`\n     */\n    function setAllowedBeaconBalanceRelativeDecrease(uint256 _value) external auth(SET_REPORT_BOUNDARIES) {\n        ALLOWED_BEACON_BALANCE_RELATIVE_DECREASE_POSITION.setStorageUint256(_value);\n        emit AllowedBeaconBalanceRelativeDecreaseSet(_value);\n    }\n\n    /**\n     * @notice Return the receiver contract address to be called when the report is pushed to Lido\n     */\n    function getBeaconReportReceiver() external view returns (address) {\n        return address(BEACON_REPORT_RECEIVER_POSITION.getStorageUint256());\n    }\n\n    /**\n     * @notice Set the receiver contract address to `_addr` to be called when the report is pushed\n     * @dev Specify 0 to disable this functionality\n     */\n    function setBeaconReportReceiver(address _addr) external auth(SET_BEACON_REPORT_RECEIVER) {\n        BEACON_REPORT_RECEIVER_POSITION.setStorageUint256(uint256(_addr));\n        emit BeaconReportReceiverSet(_addr);\n    }\n\n    /**\n     * @notice Return the current reporting bitmap, representing oracles who have already pushed\n     * their version of report during the expected epoch\n     * @dev Every oracle bit corresponds to the index of the oracle in the current members list\n     */\n    function getCurrentOraclesReportStatus() external view returns (uint256) {\n        return REPORTS_BITMASK_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Return the current reporting variants array size\n     */\n    function getCurrentReportVariantsSize() external view returns (uint256) {\n        return currentReportVariants.length;\n    }\n\n    /**\n     * @notice Return the current reporting array element with index `_index`\n     */\n    function getCurrentReportVariant(uint256 _index)\n        external\n        view\n        returns (\n            uint64 beaconBalance,\n            uint32 beaconValidators,\n            uint16 count\n        )\n    {\n        return currentReportVariants[_index].decodeWithCount();\n    }\n\n    /**\n     * @notice Returns epoch that can be reported by oracles\n     */\n    function getExpectedEpochId() external view returns (uint256) {\n        return EXPECTED_EPOCH_ID_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Return the current oracle member committee list\n     */\n    function getOracleMembers() external view returns (address[]) {\n        return members;\n    }\n\n    /**\n     * @notice Return the initialized version of this contract starting from 0\n     */\n    function getVersion() external view returns (uint256) {\n        return CONTRACT_VERSION_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Return beacon specification data\n     */\n    function getBeaconSpec()\n        external\n        view\n        returns (\n            uint64 epochsPerFrame,\n            uint64 slotsPerEpoch,\n            uint64 secondsPerSlot,\n            uint64 genesisTime\n        )\n    {\n        BeaconSpec memory beaconSpec = _getBeaconSpec();\n        return (\n            beaconSpec.epochsPerFrame,\n            beaconSpec.slotsPerEpoch,\n            beaconSpec.secondsPerSlot,\n            beaconSpec.genesisTime\n        );\n    }\n\n    /**\n     * @notice Update beacon specification data\n     */\n    function setBeaconSpec(\n        uint64 _epochsPerFrame,\n        uint64 _slotsPerEpoch,\n        uint64 _secondsPerSlot,\n        uint64 _genesisTime\n    )\n        external\n        auth(SET_BEACON_SPEC)\n    {\n        _setBeaconSpec(\n            _epochsPerFrame,\n            _slotsPerEpoch,\n            _secondsPerSlot,\n            _genesisTime\n        );\n    }\n\n    /**\n     * @notice Return the epoch calculated from current timestamp\n     */\n    function getCurrentEpochId() external view returns (uint256) {\n        BeaconSpec memory beaconSpec = _getBeaconSpec();\n        return _getCurrentEpochId(beaconSpec);\n    }\n\n    /**\n     * @notice Return currently reportable epoch (the first epoch of the current frame) as well as\n     * its start and end times in seconds\n     */\n    function getCurrentFrame()\n        external\n        view\n        returns (\n            uint256 frameEpochId,\n            uint256 frameStartTime,\n            uint256 frameEndTime\n        )\n    {\n        BeaconSpec memory beaconSpec = _getBeaconSpec();\n        uint64 genesisTime = beaconSpec.genesisTime;\n        uint64 secondsPerEpoch = beaconSpec.secondsPerSlot * beaconSpec.slotsPerEpoch;\n\n        frameEpochId = _getFrameFirstEpochId(_getCurrentEpochId(beaconSpec), beaconSpec);\n        frameStartTime = frameEpochId * secondsPerEpoch + genesisTime;\n        frameEndTime = (frameEpochId + beaconSpec.epochsPerFrame) * secondsPerEpoch + genesisTime - 1;\n    }\n\n    /**\n     * @notice Return last completed epoch\n     */\n    function getLastCompletedEpochId() external view returns (uint256) {\n        return LAST_COMPLETED_EPOCH_ID_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Report beacon balance and its change during the last frame\n     */\n    function getLastCompletedReportDelta()\n        external\n        view\n        returns (\n            uint256 postTotalPooledEther,\n            uint256 preTotalPooledEther,\n            uint256 timeElapsed\n        )\n    {\n        postTotalPooledEther = POST_COMPLETED_TOTAL_POOLED_ETHER_POSITION.getStorageUint256();\n        preTotalPooledEther = PRE_COMPLETED_TOTAL_POOLED_ETHER_POSITION.getStorageUint256();\n        timeElapsed = TIME_ELAPSED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Initialize the contract (version 3 for now) from scratch\n     * @dev For details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     * @param _lido Address of Lido contract\n     * @param _epochsPerFrame Number of epochs per frame\n     * @param _slotsPerEpoch Number of slots per epoch\n     * @param _secondsPerSlot Number of seconds per slot\n     * @param _genesisTime Genesis time\n     * @param _allowedBeaconBalanceAnnualRelativeIncrease Allowed beacon balance annual relative increase (e.g. 1000 means 10% yearly increase)\n     * @param _allowedBeaconBalanceRelativeDecrease Allowed beacon balance moment descreat (e.g. 500 means 5% moment decrease)\n     */\n    function initialize(\n        address _lido,\n        uint64 _epochsPerFrame,\n        uint64 _slotsPerEpoch,\n        uint64 _secondsPerSlot,\n        uint64 _genesisTime,\n        uint256 _allowedBeaconBalanceAnnualRelativeIncrease,\n        uint256 _allowedBeaconBalanceRelativeDecrease\n    )\n        external onlyInit\n    {\n        assert(1 == ((1 << (MAX_MEMBERS - 1)) >> (MAX_MEMBERS - 1)));  // static assert\n\n        // We consider storage state right after deployment (no initialize() called yet) as version 0\n\n        // Initializations for v0 --> v1 (considering version semantically)\n        require(CONTRACT_VERSION_POSITION.getStorageUint256() == 0, \"BASE_VERSION_MUST_BE_ZERO\");\n\n        _setBeaconSpec(\n            _epochsPerFrame,\n            _slotsPerEpoch,\n            _secondsPerSlot,\n            _genesisTime\n        );\n\n        LIDO_POSITION.setStorageAddress(_lido);\n\n        QUORUM_POSITION.setStorageUint256(1);\n        emit QuorumChanged(1);\n\n\n        // Initializations for v1 --> v2 (considering version semantically)\n        ALLOWED_BEACON_BALANCE_ANNUAL_RELATIVE_INCREASE_POSITION\n            .setStorageUint256(_allowedBeaconBalanceAnnualRelativeIncrease);\n        emit AllowedBeaconBalanceAnnualRelativeIncreaseSet(_allowedBeaconBalanceAnnualRelativeIncrease);\n\n        ALLOWED_BEACON_BALANCE_RELATIVE_DECREASE_POSITION\n            .setStorageUint256(_allowedBeaconBalanceRelativeDecrease);\n        emit AllowedBeaconBalanceRelativeDecreaseSet(_allowedBeaconBalanceRelativeDecrease);\n\n        // // set expected epoch to the first epoch for the next frame\n        BeaconSpec memory beaconSpec = _getBeaconSpec();\n        uint256 expectedEpoch = _getFrameFirstEpochId(0, beaconSpec) + beaconSpec.epochsPerFrame;\n        EXPECTED_EPOCH_ID_POSITION.setStorageUint256(expectedEpoch);\n        emit ExpectedEpochIdUpdated(expectedEpoch);\n\n        // Initializations for v2 --> v3 (considering version semantically)\n        _initialize_v3();\n\n        // Need this despite contract version check because Aragon requires it to handle auth() modificators properly\n        initialized();\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v3 (from v1). Can be called only once\n     * @dev Value 2 in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v3() external {\n        require(CONTRACT_VERSION_POSITION.getStorageUint256() == 1, \"WRONG_BASE_VERSION\");\n\n        _initialize_v3();\n    }\n\n    /**\n     * @notice A dummy incremental v1/v2 --> v3 initialize function. Just corrects version number in storage\n     * @dev This function is introduced just to set in correspondence version number in storage,\n     * semantic version of the contract and number N used in naming of _initialize_nN/finalizeUpgrade_vN.\n     * NB, that thus version 2 is skipped \n     */\n    function _initialize_v3() internal {\n        CONTRACT_VERSION_POSITION.setStorageUint256(3);\n        emit ContractVersionSet(3);\n    }\n\n    /**\n     * @notice Add `_member` to the oracle member committee list\n     */\n    function addOracleMember(address _member) external auth(MANAGE_MEMBERS) {\n        require(address(0) != _member, \"BAD_ARGUMENT\");\n        require(MEMBER_NOT_FOUND == _getMemberId(_member), \"MEMBER_EXISTS\");\n\n        members.push(_member);\n        require(members.length < MAX_MEMBERS, \"TOO_MANY_MEMBERS\");\n        emit MemberAdded(_member);\n    }\n\n    /**\n     * @notice Remove '_member` from the oracle member committee list\n     */\n    function removeOracleMember(address _member) external auth(MANAGE_MEMBERS) {\n        uint256 index = _getMemberId(_member);\n        require(index != MEMBER_NOT_FOUND, \"MEMBER_NOT_FOUND\");\n        uint256 last = members.length - 1;\n        if (index != last) members[index] = members[last];\n        members.length--;\n        emit MemberRemoved(_member);\n\n        // delete the data for the last epoch, let remained oracles report it again\n        REPORTS_BITMASK_POSITION.setStorageUint256(0);\n        delete currentReportVariants;\n    }\n\n    /**\n     * @notice Set the number of exactly the same reports needed to finalize the epoch to `_quorum`\n     */\n    function setQuorum(uint256 _quorum) external auth(MANAGE_QUORUM) {\n        require(0 != _quorum, \"QUORUM_WONT_BE_MADE\");\n        uint256 oldQuorum = QUORUM_POSITION.getStorageUint256();\n        QUORUM_POSITION.setStorageUint256(_quorum);\n        emit QuorumChanged(_quorum);\n\n        // If the quorum value lowered, check existing reports whether it is time to push\n        if (oldQuorum > _quorum) {\n            (bool isQuorum, uint256 report) = _getQuorumReport(_quorum);\n            if (isQuorum) {\n                (uint64 beaconBalance, uint32 beaconValidators) = report.decode();\n                _push(\n                     EXPECTED_EPOCH_ID_POSITION.getStorageUint256(),\n                     DENOMINATION_OFFSET * uint128(beaconBalance),\n                     beaconValidators,\n                     _getBeaconSpec()\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Accept oracle committee member reports from the ETH 2.0 side\n     * @param _epochId Beacon chain epoch\n     * @param _beaconBalance Balance in gwei on the ETH 2.0 side (9-digit denomination)\n     * @param _beaconValidators Number of validators visible in this epoch\n     */\n    function reportBeacon(uint256 _epochId, uint64 _beaconBalance, uint32 _beaconValidators) external {\n        BeaconSpec memory beaconSpec = _getBeaconSpec();\n        uint256 expectedEpoch = EXPECTED_EPOCH_ID_POSITION.getStorageUint256();\n        require(_epochId >= expectedEpoch, \"EPOCH_IS_TOO_OLD\");\n\n        // if expected epoch has advanced, check that this is the first epoch of the current frame\n        // and clear the last unsuccessful reporting\n        if (_epochId > expectedEpoch) {\n            require(_epochId == _getFrameFirstEpochId(_getCurrentEpochId(beaconSpec), beaconSpec), \"UNEXPECTED_EPOCH\");\n            _clearReportingAndAdvanceTo(_epochId);\n        }\n\n        uint128 beaconBalanceEth1 = DENOMINATION_OFFSET * uint128(_beaconBalance);\n        emit BeaconReported(_epochId, beaconBalanceEth1, _beaconValidators, msg.sender);\n\n        // make sure the oracle is from members list and has not yet voted\n        uint256 index = _getMemberId(msg.sender);\n        require(index != MEMBER_NOT_FOUND, \"MEMBER_NOT_FOUND\");\n        uint256 bitMask = REPORTS_BITMASK_POSITION.getStorageUint256();\n        uint256 mask = 1 << index;\n        require(bitMask & mask == 0, \"ALREADY_SUBMITTED\");\n        REPORTS_BITMASK_POSITION.setStorageUint256(bitMask | mask);\n\n        // push this report to the matching kind\n        uint256 report = ReportUtils.encode(_beaconBalance, _beaconValidators);\n        uint256 quorum = getQuorum();\n        uint256 i = 0;\n\n        // iterate on all report variants we already have, limited by the oracle members maximum\n        while (i < currentReportVariants.length && currentReportVariants[i].isDifferent(report)) ++i;\n        if (i < currentReportVariants.length) {\n            if (currentReportVariants[i].getCount() + 1 >= quorum) {\n                _push(_epochId, beaconBalanceEth1, _beaconValidators, beaconSpec);\n            } else {\n                ++currentReportVariants[i]; // increment report counter, see ReportUtils for details\n            }\n        } else {\n            if (quorum == 1) {\n                _push(_epochId, beaconBalanceEth1, _beaconValidators, beaconSpec);\n            } else {\n                currentReportVariants.push(report + 1);\n            }\n        }\n    }\n\n    /**\n     * @notice Return beacon specification data\n     */\n    function _getBeaconSpec()\n        internal\n        view\n        returns (BeaconSpec memory beaconSpec)\n    {\n        uint256 data = BEACON_SPEC_POSITION.getStorageUint256();\n        beaconSpec.epochsPerFrame = uint64(data >> 192);\n        beaconSpec.slotsPerEpoch = uint64(data >> 128);\n        beaconSpec.secondsPerSlot = uint64(data >> 64);\n        beaconSpec.genesisTime = uint64(data);\n        return beaconSpec;\n    }\n\n    /**\n     * @notice Return whether the `_quorum` is reached and the final report\n     */\n    function _getQuorumReport(uint256 _quorum) internal view returns (bool isQuorum, uint256 report) {\n        // check most frequent cases first: all reports are the same or no reports yet\n        if (currentReportVariants.length == 1) {\n            return (currentReportVariants[0].getCount() >= _quorum, currentReportVariants[0]);\n        } else if (currentReportVariants.length == 0) {\n            return (false, 0);\n        }\n\n        // if more than 2 kind of reports exist, choose the most frequent\n        uint256 maxind = 0;\n        uint256 repeat = 0;\n        uint16 maxval = 0;\n        uint16 cur = 0;\n        for (uint256 i = 0; i < currentReportVariants.length; ++i) {\n            cur = currentReportVariants[i].getCount();\n            if (cur >= maxval) {\n                if (cur == maxval) {\n                    ++repeat;\n                } else {\n                    maxind = i;\n                    maxval = cur;\n                    repeat = 0;\n                }\n            }\n        }\n        return (maxval >= _quorum && repeat == 0, currentReportVariants[maxind]);\n    }\n\n    /**\n     * @notice Set beacon specification data\n     */\n    function _setBeaconSpec(\n        uint64 _epochsPerFrame,\n        uint64 _slotsPerEpoch,\n        uint64 _secondsPerSlot,\n        uint64 _genesisTime\n    )\n        internal\n    {\n        require(_epochsPerFrame > 0, \"BAD_EPOCHS_PER_FRAME\");\n        require(_slotsPerEpoch > 0, \"BAD_SLOTS_PER_EPOCH\");\n        require(_secondsPerSlot > 0, \"BAD_SECONDS_PER_SLOT\");\n        require(_genesisTime > 0, \"BAD_GENESIS_TIME\");\n\n        uint256 data = (\n            uint256(_epochsPerFrame) << 192 |\n            uint256(_slotsPerEpoch) << 128 |\n            uint256(_secondsPerSlot) << 64 |\n            uint256(_genesisTime)\n        );\n        BEACON_SPEC_POSITION.setStorageUint256(data);\n        emit BeaconSpecSet(\n            _epochsPerFrame,\n            _slotsPerEpoch,\n            _secondsPerSlot,\n            _genesisTime);\n    }\n\n    /**\n     * @notice Push the given report to Lido and performs accompanying accounting\n     * @param _epochId Beacon chain epoch, proven to be >= expected epoch and <= current epoch\n     * @param _beaconBalanceEth1 Validators balance in eth1 (18-digit denomination)\n     * @param _beaconSpec current beacon specification data\n     */\n    function _push(\n        uint256 _epochId,\n        uint128 _beaconBalanceEth1,\n        uint128 _beaconValidators,\n        BeaconSpec memory _beaconSpec\n    )\n        internal\n    {\n        emit Completed(_epochId, _beaconBalanceEth1, _beaconValidators);\n\n        // now this frame is completed, so the expected epoch should be advanced to the first epoch\n        // of the next frame\n        _clearReportingAndAdvanceTo(_epochId + _beaconSpec.epochsPerFrame);\n\n        // report to the Lido and collect stats\n        ILido lido = getLido();\n        uint256 prevTotalPooledEther = lido.totalSupply();\n        lido.handleOracleReport(_beaconValidators, _beaconBalanceEth1);\n        uint256 postTotalPooledEther = lido.totalSupply();\n\n        PRE_COMPLETED_TOTAL_POOLED_ETHER_POSITION.setStorageUint256(prevTotalPooledEther);\n        POST_COMPLETED_TOTAL_POOLED_ETHER_POSITION.setStorageUint256(postTotalPooledEther);\n        uint256 timeElapsed = (_epochId - LAST_COMPLETED_EPOCH_ID_POSITION.getStorageUint256()) *\n            _beaconSpec.slotsPerEpoch * _beaconSpec.secondsPerSlot;\n        TIME_ELAPSED_POSITION.setStorageUint256(timeElapsed);\n        LAST_COMPLETED_EPOCH_ID_POSITION.setStorageUint256(_epochId);\n\n        // rollback on boundaries violation\n        _reportSanityChecks(postTotalPooledEther, prevTotalPooledEther, timeElapsed);\n\n        // emit detailed statistics and call the quorum delegate with this data\n        emit PostTotalShares(postTotalPooledEther, prevTotalPooledEther, timeElapsed, lido.getTotalShares());\n        IBeaconReportReceiver receiver = IBeaconReportReceiver(BEACON_REPORT_RECEIVER_POSITION.getStorageUint256());\n        if (address(receiver) != address(0)) {\n            receiver.processLidoOracleReport(postTotalPooledEther, prevTotalPooledEther, timeElapsed);\n        }\n    }\n\n    /**\n     * @notice Remove the current reporting progress and advances to accept the later epoch `_epochId`\n     */\n    function _clearReportingAndAdvanceTo(uint256 _epochId) internal {\n        REPORTS_BITMASK_POSITION.setStorageUint256(0);\n        EXPECTED_EPOCH_ID_POSITION.setStorageUint256(_epochId);\n        delete currentReportVariants;\n        emit ExpectedEpochIdUpdated(_epochId);\n    }\n\n    /**\n     * @notice Performs logical consistency check of the Lido changes as the result of reports push\n     * @dev To make oracles less dangerous, we limit rewards report by 10% _annual_ increase and 5%\n     * _instant_ decrease in stake, with both values configurable by the governance in case of\n     * extremely unusual circumstances.\n     **/\n    function _reportSanityChecks(\n        uint256 _postTotalPooledEther,\n        uint256 _preTotalPooledEther,\n        uint256 _timeElapsed)\n        internal\n        view\n    {\n        if (_postTotalPooledEther >= _preTotalPooledEther) {\n            // increase                 = _postTotalPooledEther - _preTotalPooledEther,\n            // relativeIncrease         = increase / _preTotalPooledEther,\n            // annualRelativeIncrease   = relativeIncrease / (timeElapsed / 365 days),\n            // annualRelativeIncreaseBp = annualRelativeIncrease * 10000, in basis points 0.01% (1e-4)\n            uint256 allowedAnnualRelativeIncreaseBp =\n                ALLOWED_BEACON_BALANCE_ANNUAL_RELATIVE_INCREASE_POSITION.getStorageUint256();\n            // check that annualRelativeIncreaseBp <= allowedAnnualRelativeIncreaseBp\n            require(uint256(10000 * 365 days).mul(_postTotalPooledEther - _preTotalPooledEther) <=\n                    allowedAnnualRelativeIncreaseBp.mul(_preTotalPooledEther).mul(_timeElapsed),\n                    \"ALLOWED_BEACON_BALANCE_INCREASE\");\n        } else {\n            // decrease           = _preTotalPooledEther - _postTotalPooledEther\n            // relativeDecrease   = decrease / _preTotalPooledEther\n            // relativeDecreaseBp = relativeDecrease * 10000, in basis points 0.01% (1e-4)\n            uint256 allowedRelativeDecreaseBp =\n                ALLOWED_BEACON_BALANCE_RELATIVE_DECREASE_POSITION.getStorageUint256();\n            // check that relativeDecreaseBp <= allowedRelativeDecreaseBp\n            require(uint256(10000).mul(_preTotalPooledEther - _postTotalPooledEther) <=\n                    allowedRelativeDecreaseBp.mul(_preTotalPooledEther),\n                    \"ALLOWED_BEACON_BALANCE_DECREASE\");\n        }\n    }\n\n    /**\n     * @notice Return `_member` index in the members list or MEMBER_NOT_FOUND\n     */\n    function _getMemberId(address _member) internal view returns (uint256) {\n        uint256 length = members.length;\n        for (uint256 i = 0; i < length; ++i) {\n            if (members[i] == _member) {\n                return i;\n            }\n        }\n        return MEMBER_NOT_FOUND;\n    }\n\n    /**\n     * @notice Return the epoch calculated from current timestamp\n     */\n    function _getCurrentEpochId(BeaconSpec memory _beaconSpec) internal view returns (uint256) {\n        return (_getTime() - _beaconSpec.gen"
    }
  ]
}