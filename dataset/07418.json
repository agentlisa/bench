{
  "Title": "[M-05] Bypass whenNotPaused modifier",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/Staking.sol#L328-L332\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/ClaimNodeOp.sol#L89-L114\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/ClaimProtocolDAO.sol#L20-L35\n\n\n# Vulnerability details\n\n## Impact\n\nThe `whenNotPaused` modifier is used to pause minipool creation and staking/withdrawing GGP. However, there are several cases this modifier could be bypassed, which breaks the intended admin control function and special mode.\n\n\n## Proof of Concept\n\n### `stake()`\n\nIn paused mode, no more `stakeGGP()` is allowed, \n```solidity\nFile: contract/Staking.sol\n319: \tfunction stakeGGP(uint256 amount) external whenNotPaused {\n320: \t\t// Transfer GGP tokens from staker to this contract\n321: \t\tggp.safeTransferFrom(msg.sender, address(this), amount);\n322: \t\t_stakeGGP(msg.sender, amount);\n323: \t}\n```\n\nHowever, `restakeGGP()` is still available, which potentially violate the purpose of pause mode.\n```solidity\nFile: contract/Staking.sol\n328: \tfunction restakeGGP(address stakerAddr, uint256 amount) public onlySpecificRegisteredContract(\"ClaimNodeOp\", msg.sender) {\n329: \t\t// Transfer GGP tokens from the ClaimNodeOp contract to this contract\n330: \t\tggp.safeTransferFrom(msg.sender, address(this), amount);\n331: \t\t_stakeGGP(stakerAddr, amount);\n332: \t}\n```\n\n### `withdraw()`\n\nIn paused mode, no more `withdrawGGP()` is allowed, \n```solidity\nFile: contract/Staking.sol\n358: \tfunction withdrawGGP(uint256 amount) external whenNotPaused {\n\n373: \t\tvault.withdrawToken(msg.sender, ggp, amount);\n```\n\nHowever, `claimAndRestake()` is still available, which can withdraw from the vault.\n```solidity\nFile: contract/ClaimNodeOp.sol\n089: \tfunction claimAndRestake(uint256 claimAmt) external {\n\n103: \t\tif (restakeAmt > 0) {\n104: \t\t\tvault.withdrawToken(address(this), ggp, restakeAmt);\n105: \t\t\tggp.approve(address(staking), restakeAmt);\n106: \t\t\tstaking.restakeGGP(msg.sender, restakeAmt);\n107: \t\t}\n108: \n109: \t\tif (claimAmt > 0) {\n110: \t\t\tvault.withdrawToken(msg.sender, ggp, claimAmt);\n111: \t\t}\n```\n\nTHe function `spend()` can also ignore the pause mode to withdraw from the vault. But this is a guardian function. It could be intended behavior.\n```solidity\nFile: contract/ClaimProtocolDAO.sol\n20: \tfunction spend(\n21: \t\tstring memory invoiceID,\n22: \t\taddress recipientAddress,\n23: \t\tuint256 amount\n24: \t) external onlyGuardian {\n\n32: \t\tvault.withdrawToken(recipientAddress, ggpToken, amount);\n```\n\n\n\n## Tools Used\nManual analysis.\n\n## Recommended Mitigation Steps\n\n- add the `whenNotPaused` modifier to `restakeGGP()` and `claimAndRestake()`\n- maybe also for guardian function `spend()`.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-gogopool-contest",
  "Code": [
    {
      "filename": "contracts/contract/Staking.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport \"./Base.sol\";\nimport {MinipoolManager} from \"./MinipoolManager.sol\";\nimport {Oracle} from \"./Oracle.sol\";\nimport {ProtocolDAO} from \"./ProtocolDAO.sol\";\nimport {Storage} from \"./Storage.sol\";\nimport {Vault} from \"./Vault.sol\";\n\nimport {ERC20} from \"@rari-capital/solmate/src/mixins/ERC4626.sol\";\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\n\n/*\n\tData Storage Schema\n\tA \"staker\" is a user of the protocol who stakes GGP into this contract\n\n\tstaker.count = Starts at 0 and counts up by 1 after a staker is added.\n\n\tstaker.index<stakerAddr> = <index> of stakerAddr\n\tstaker.item<index>.stakerAddr = wallet address of staker, used as primary key\n\tstaker.item<index>.ggpStaked = Total amt of GGP staked across all minipools\n\tstaker.item<index>.avaxStaked = Total amt of AVAX staked across all minipools\n\tstaker.item<index>.avaxAssigned = Total amt of liquid staker funds assigned across all minipools\n\tstaker.item<index>.avaxAssignedHighWater = Highest amt of liquid staker funds assigned during a GGP rewards cycle\n*/\n\n/// @title GGP staking and staker attributes\ncontract Staking is Base {\n\tusing SafeTransferLib for ERC20;\n\tusing SafeTransferLib for address;\n\tusing FixedPointMathLib for uint256;\n\n\terror CannotWithdrawUnder150CollateralizationRatio();\n\terror InsufficientBalance();\n\terror InvalidRewardsStartTime();\n\terror StakerNotFound();\n\n\tevent GGPStaked(address indexed from, uint256 amount);\n\tevent GGPWithdrawn(address indexed to, uint256 amount);\n\n\t/// @dev Not used for storage, just for returning data from view functions\n\tstruct Staker {\n\t\taddress stakerAddr;\n\t\tuint256 ggpStaked;\n\t\tuint256 avaxStaked;\n\t\tuint256 avaxAssigned;\n\t\tuint256 avaxAssignedHighWater;\n\t\tuint256 minipoolCount;\n\t\tuint256 rewardsStartTime;\n\t\tuint256 ggpRewards;\n\t\tuint256 lastRewardsCycleCompleted;\n\t}\n\n\tuint256 internal constant TENTH = 0.1 ether;\n\n\tERC20 public immutable ggp;\n\n\tconstructor(Storage storageAddress, ERC20 ggp_) Base(storageAddress) {\n\t\tversion = 1;\n\t\tggp = ggp_;\n\t}\n\n\t/// @notice Total GGP (stored in vault) assigned to this contract\n\tfunction getTotalGGPStake() public view returns (uint256) {\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\t\treturn vault.balanceOfToken(\"Staking\", ggp);\n\t}\n\n\t/// @notice Total count of GGP stakers in the protocol\n\tfunction getStakerCount() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"staker.count\"));\n\t}\n\n\t/* GGP STAKE */\n\n\t/// @notice The amount of GGP a given staker is staking\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getGGPStake(address stakerAddr) public view returns (uint256) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\treturn getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".ggpStaked\")));\n\t}\n\n\t/// @notice Increase the amount of GGP a given staker is staking\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction increaseGGPStake(address stakerAddr, uint256 amount) internal {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\taddUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".ggpStaked\")), amount);\n\t}\n\n\t/// @notice Decrease the amount of GGP a given staker is staking\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction decreaseGGPStake(address stakerAddr, uint256 amount) internal {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\tsubUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".ggpStaked\")), amount);\n\t}\n\n\t/* AVAX STAKE */\n\n\t/// @notice The amount of AVAX a given staker is staking\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getAVAXStake(address stakerAddr) public view returns (uint256) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\treturn getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxStaked\")));\n\t}\n\n\t/// @notice Increase the amount of AVAX a given staker is staking\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction increaseAVAXStake(address stakerAddr, uint256 amount) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\taddUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxStaked\")), amount);\n\t}\n\n\t/// @notice Decrease the amount of AVAX a given staker is staking\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction decreaseAVAXStake(address stakerAddr, uint256 amount) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\tsubUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxStaked\")), amount);\n\t}\n\n\t/* AVAX ASSIGNED */\n\n\t/// @notice The amount of AVAX a given staker is assigned by the protocol (for minipool creation)\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getAVAXAssigned(address stakerAddr) public view returns (uint256) {\n\t\tint256 stakerIndex = getIndexOf(stakerAddr);\n\t\treturn getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxAssigned\")));\n\t}\n\n\t/// @notice Increase the amount of AVAX a given staker is assigned by the protocol (for minipool creation)\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction increaseAVAXAssigned(address stakerAddr, uint256 amount) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\taddUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxAssigned\")), amount);\n\t}\n\n\t/// @notice Decrease the amount of AVAX a given staker is assigned by the protocol (for minipool creation)\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction decreaseAVAXAssigned(address stakerAddr, uint256 amount) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\tsubUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxAssigned\")), amount);\n\t}\n\n\t/* AVAX ASSIGNED HIGH-WATER */\n\n\t/// @notice Largest total AVAX amt assigned to a staker during a rewards period\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getAVAXAssignedHighWater(address stakerAddr) public view returns (uint256) {\n\t\tint256 stakerIndex = getIndexOf(stakerAddr);\n\t\treturn getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxAssignedHighWater\")));\n\t}\n\n\t/// @notice Increase the AVAXAssignedHighWater\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction increaseAVAXAssignedHighWater(address stakerAddr, uint256 amount) public onlyRegisteredNetworkContract {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\taddUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxAssignedHighWater\")), amount);\n\t}\n\n\t/// @notice Reset the AVAXAssignedHighWater to what the current AVAXAssigned is for the staker\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction resetAVAXAssignedHighWater(address stakerAddr) public onlyRegisteredNetworkContract {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\tuint256 currAVAXAssigned = getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxAssigned\")));\n\t\tsetUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxAssignedHighWater\")), currAVAXAssigned);\n\t}\n\n\t/* MINIPOOL COUNT */\n\n\t/// @notice The number of minipools the given staker has\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getMinipoolCount(address stakerAddr) public view returns (uint256) {\n\t\tint256 stakerIndex = getIndexOf(stakerAddr);\n\t\treturn getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".minipoolCount\")));\n\t}\n\n\t/// @notice Increase the number of minipools the given staker has\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction increaseMinipoolCount(address stakerAddr) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\taddUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".minipoolCount\")), 1);\n\t}\n\n\t/// @notice Decrease the number of minipools the given staker has\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction decreaseMinipoolCount(address stakerAddr) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\tsubUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".minipoolCount\")), 1);\n\t}\n\n\t/* REWARDS START TIME */\n\n\t/// @notice The timestamp when the staker registered for GGP rewards\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getRewardsStartTime(address stakerAddr) public view returns (uint256) {\n\t\tint256 stakerIndex = getIndexOf(stakerAddr);\n\t\treturn getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".rewardsStartTime\")));\n\t}\n\n\t/// @notice Set the timestamp when the staker registered for GGP rewards\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\t// TODO cant use onlySpecificRegisteredContract(\"ClaimNodeOp\", msg.sender) since we also call from increaseMinipoolCount. Wat do?\n\tfunction setRewardsStartTime(address stakerAddr, uint256 time) public onlyRegisteredNetworkContract {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\tif (time > block.timestamp) {\n\t\t\trevert InvalidRewardsStartTime();\n\t\t}\n\n\t\tsetUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".rewardsStartTime\")), time);\n\t}\n\n\t/* GGP REWARDS */\n\n\t/// @notice The amount of GGP rewards the staker has earned and not claimed\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getGGPRewards(address stakerAddr) public view returns (uint256) {\n\t\tint256 stakerIndex = getIndexOf(stakerAddr);\n\t\treturn getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".ggpRewards\")));\n\t}\n\n\t/// @notice Increase the amount of GGP rewards the staker has earned and not claimed\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction increaseGGPRewards(address stakerAddr, uint256 amount) public onlySpecificRegisteredContract(\"ClaimNodeOp\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\taddUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".ggpRewards\")), amount);\n\t}\n\n\t/// @notice Decrease the amount of GGP rewards the staker has earned and not claimed\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction decreaseGGPRewards(address stakerAddr, uint256 amount) public onlySpecificRegisteredContract(\"ClaimNodeOp\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\tsubUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".ggpRewards\")), amount);\n\t}\n\n\t/* LAST REWARDS CYCLE PAID OUT */\n\n\t/// @notice The most recent reward cycle number that the staker has been paid out for\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getLastRewardsCycleCompleted(address stakerAddr) public view returns (uint256) {\n\t\tint256 stakerIndex = getIndexOf(stakerAddr);\n\t\treturn getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".lastRewardsCycleCompleted\")));\n\t}\n\n\t/// @notice Set the most recent reward cycle number that the staker has been paid out for\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\t/// @param cycleNumber The cycle that the staker was just rewarded for\n\tfunction setLastRewardsCycleCompleted(address stakerAddr, uint256 cycleNumber) public onlySpecificRegisteredContract(\"ClaimNodeOp\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\tsetUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".lastRewardsCycleCompleted\")), cycleNumber);\n\t}\n\n\t/// @notice Get a stakers's minimum GGP stake to collateralize their minipools, based on current GGP price\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\t/// @return Amount of GGP\n\tfunction getMinimumGGPStake(address stakerAddr) public view returns (uint256) {\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tOracle oracle = Oracle(getContractAddress(\"Oracle\"));\n\t\t(uint256 ggpPriceInAvax, ) = oracle.getGGPPriceInAVAX();\n\n\t\tuint256 avaxAssigned = getAVAXAssigned(stakerAddr);\n\t\tuint256 ggp100pct = avaxAssigned.divWadDown(ggpPriceInAvax);\n\t\treturn ggp100pct.mulWadDown(dao.getMinCollateralizationRatio());\n\t}\n\n\t/// @notice Returns collateralization ratio based on current GGP price\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\t/// @return A ratio where 0 = 0%, 1 ether = 100%\n\tfunction getCollateralizationRatio(address stakerAddr) public view returns (uint256) {\n\t\tuint256 avaxAssigned = getAVAXAssigned(stakerAddr);\n\t\tif (avaxAssigned == 0) {\n\t\t\t// Infinite collat ratio\n\t\t\treturn type(uint256).max;\n\t\t}\n\t\tOracle oracle = Oracle(getContractAddress(\"Oracle\"));\n\t\t(uint256 ggpPriceInAvax, ) = oracle.getGGPPriceInAVAX();\n\t\tuint256 ggpStakedInAvax = getGGPStake(stakerAddr).mulWadDown(ggpPriceInAvax);\n\t\treturn ggpStakedInAvax.divWadDown(avaxAssigned);\n\t}\n\n\t/// @notice Returns effective collateralization ratio which will be used to pay out rewards\n\t///         based on current GGP price and AVAX high water mark. A staker can earn GGP rewards\n\t///         on up to 150% collat ratio\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\t/// @return Ratio is between 0%-150% (0-1.5 ether)\n\tfunction getEffectiveRewardsRatio(address stakerAddr) public view returns (uint256) {\n\t\tuint256 avaxAssignedHighWater = getAVAXAssignedHighWater(stakerAddr);\n\t\tif (avaxAssignedHighWater == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (getCollateralizationRatio(stakerAddr) < TENTH) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tOracle oracle = Oracle(getContractAddress(\"Oracle\"));\n\t\t(uint256 ggpPriceInAvax, ) = oracle.getGGPPriceInAVAX();\n\t\tuint256 ggpStakedInAvax = getGGPStake(stakerAddr).mulWadDown(ggpPriceInAvax);\n\t\tuint256 ratio = ggpStakedInAvax.divWadDown(avaxAssignedHighWater);\n\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tuint256 maxRatio = dao.getMaxCollateralizationRatio();\n\n\t\treturn (ratio > maxRatio) ? maxRatio : ratio;\n\t}\n\n\t/// @notice GGP that will count towards rewards this cycle\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getEffectiveGGPStaked(address stakerAddr) external view returns (uint256) {\n\t\tOracle oracle = Oracle(getContractAddress(\"Oracle\"));\n\t\t(uint256 ggpPriceInAvax, ) = oracle.getGGPPriceInAVAX();\n\n\t\tuint256 avaxAssignedHighWater = getAVAXAssignedHighWater(stakerAddr);\n\t\tuint256 ratio = getEffectiveRewardsRatio(stakerAddr);\n\t\treturn avaxAssignedHighWater.mulWadDown(ratio).divWadDown(ggpPriceInAvax);\n\t}\n\n\t/// @notice Accept a GGP stake\n\t/// @param amount The amount of GGP being staked\n\tfunction stakeGGP(uint256 amount) external whenNotPaused {\n\t\t// Transfer GGP tokens from staker to this contract\n\t\tggp.safeTransferFrom(msg.sender, address(this), amount);\n\t\t_stakeGGP(msg.sender, amount);\n\t}\n\n\t/// @notice Convenience function to allow for restaking claimed GGP rewards\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\t/// @param amount The amount of GGP being staked\n\tfunction restakeGGP(address stakerAddr, uint256 amount) public onlySpecificRegisteredContract(\"ClaimNodeOp\", msg.sender) {\n\t\t// Transfer GGP tokens from the ClaimNodeOp contract to this contract\n\t\tggp.safeTransferFrom(msg.sender, address(this), amount);\n\t\t_stakeGGP(stakerAddr, amount);\n\t}\n\n\t/// @notice Stakes GGP in the protocol\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\t/// @param amount The amount of GGP being staked\n\tfunction _stakeGGP(address stakerAddr, uint256 amount) internal {\n\t\temit GGPStaked(stakerAddr, amount);\n\n\t\t// Deposit GGP tokens from this contract to vault\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\t\tggp.approve(address(vault), amount);\n\t\tvault.depositToken(\"Staking\", ggp, amount);\n\n\t\tint256 stakerIndex = getIndexOf(stakerAddr);\n\t\tif (stakerIndex == -1) {\n\t\t\t// create index for the new staker\n\t\t\tstakerIndex = int256(getUint(keccak256(\"staker.count\")));\n\t\t\taddUint(keccak256(\"staker.count\"), 1);\n\t\t\tsetUint(keccak256(abi.encodePacked(\"staker.index\", stakerAddr)), uint256(stakerIndex + 1));\n\t\t\tsetAddress(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".stakerAddr\")), stakerAddr);\n\t\t}\n\t\tincreaseGGPStake(stakerAddr, amount);\n\t}\n\n\t/// @notice Allows the staker to unstake their GGP if they are over the 150% collateralization ratio\n\t/// @param amount The amount of GGP being withdrawn\n\tfunction withdrawGGP(uint256 amount) external whenNotPaused {\n\t\tif (amount > getGGPStake(msg.sender)) {\n\t\t\trevert InsufficientBalance();\n\t\t}\n\n\t\temit GGPWithdrawn(msg.sender, amount);\n\n\t\tdecreaseGGPStake(msg.sender, amount);\n\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tif (getCollateralizationRatio(msg.sender) < dao.getMaxCollateralizationRatio()) {\n\t\t\trevert CannotWithdrawUnder150CollateralizationRatio();\n\t\t}\n\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\t\tvault.withdrawToken(msg.sender, ggp, amount);\n\t}\n\n\t/// @notice Minipool Manager will call this if a minipool ended and was not in good standing\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\t/// @param ggpAmt The amount of GGP being slashed\n\tfunction slashGGP(address stakerAddr, uint256 ggpAmt) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\t\tdecreaseGGPStake(stakerAddr, ggpAmt);\n\t\tvault.transferToken(\"ProtocolDAO\", ggp, ggpAmt);\n\t}\n\n\t/// @notice Verifying the staker exists in the protocol\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction requireValidStaker(address stakerAddr) public view returns (int256) {\n\t\tint256 index = getIndexOf(stakerAddr);\n\t\tif (index != -1) {\n\t\t\treturn index;\n\t\t} else {\n\t\t\trevert StakerNotFound();\n\t\t}\n\t}\n\n\t/// @notice Get index of the staker\n\t/// @return staker index or -1 if the value was not found\n\tfunction getIndexOf(address stakerAddr) public view returns (int256) {\n\t\treturn int256(getUint(keccak256(abi.encodePacked(\"staker.index\", stakerAddr)))) - 1;\n\t}\n\n\t/// @notice Gets the staker information using the staker's index\n\t/// @param stakerIndex Index of the staker\n\t/// @return staker struct containing the staker's properties\n\tfunction getStaker(int256 stakerIndex) public view returns (Staker memory staker) {\n\t\tstaker.ggpStaked = getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".ggpStaked\")));\n\t\tstaker.avaxAssigned = getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxAssigned\")));\n\t\tstaker.avaxStaked = getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxStaked\")));\n\t\tstaker.stakerAddr = getAddress(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".stakerAddr\")));\n\t\tstaker.minipoolCount = getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".minipoolCount\")));\n\t\tstaker.rewardsStartTime = getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".rewardsStartTime\")));\n\t\tstaker.ggpRewards = getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".ggpRewards\")));\n\t\tstaker.lastRewardsCycleCompleted = getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".lastRewardsCycleCompleted\")));\n\t}\n\n\t/// @notice Get stakers in the protocol (limit=0 means no pagination)\n\t/// @param offset The number the result should be offset by\n\t/// @param limit The limit to the amount of minipools that should be returned\n\t/// @return stakers in the protocol that adhear to the paramaters\n\tfunction getStakers(uint256 offset, uint256 limit) external view returns (Staker[] memory stakers) {\n\t\tuint256 totalStakers = getStakerCount();\n\t\tuint256 max = offset + limit;\n\t\tif (max > totalStakers || limit == 0) {\n\t\t\tmax = totalStakers;\n\t\t}\n\t\tstakers = new Staker[](max - offset);\n\t\tuint256 total = 0;\n\t\tfor (uint256 i = offset; i < max; i++) {\n\t\t\tStaker memory s = getStaker(int256(i));\n\t\t\tstakers[total] = s;\n\t\t\ttotal++;\n\t\t}\n\t\t// Dirty hack to cut unused elements off end of return value (from RP)\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tmstore(stakers, total)\n\t\t}\n\t}\n}"
    },
    {
      "filename": "contracts/contract/ClaimNodeOp.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport \"./Base.sol\";\nimport {MinipoolManager} from \"./MinipoolManager.sol\";\nimport {ProtocolDAO} from \"./ProtocolDAO.sol\";\nimport {RewardsPool} from \"./RewardsPool.sol\";\nimport {Staking} from \"./Staking.sol\";\nimport {Storage} from \"./Storage.sol\";\nimport {TokenGGP} from \"./tokens/TokenGGP.sol\";\nimport {Vault} from \"./Vault.sol\";\n\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\n\n/// @title Node Operators claiming GGP Rewards\ncontract ClaimNodeOp is Base {\n\tusing FixedPointMathLib for uint256;\n\n\terror InvalidAmount();\n\terror NoRewardsToClaim();\n\terror RewardsAlreadyDistributedToStaker(address);\n\terror RewardsCycleNotStarted();\n\n\tevent GGPRewardsClaimed(address indexed to, uint256 amount);\n\n\tERC20 public immutable ggp;\n\n\tconstructor(Storage storageAddress, ERC20 ggp_) Base(storageAddress) {\n\t\tversion = 1;\n\t\tggp = ggp_;\n\t}\n\n\t/// @notice Get the total rewards for the most recent cycle\n\tfunction getRewardsCycleTotal() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"NOPClaim.RewardsCycleTotal\"));\n\t}\n\n\t/// @dev Sets the total rewards for the most recent cycle\n\tfunction setRewardsCycleTotal(uint256 amount) public onlySpecificRegisteredContract(\"RewardsPool\", msg.sender) {\n\t\tsetUint(keccak256(\"NOPClaim.RewardsCycleTotal\"), amount);\n\t}\n\n\t/// @notice Determines if a staker is eligible for the upcoming rewards cycle\n\t/// @dev Eligiblity: time in protocol (secs) > RewardsEligibilityMinSeconds. Rialto will call this.\n\tfunction isEligible(address stakerAddr) external view returns (bool) {\n\t\tStaking staking = Staking(getContractAddress(\"Staking\"));\n\t\tuint256 rewardsStartTime = staking.getRewardsStartTime(stakerAddr);\n\t\tuint256 elapsedSecs = (block.timestamp - rewardsStartTime);\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\treturn (rewardsStartTime != 0 && elapsedSecs >= dao.getRewardsEligibilityMinSeconds());\n\t}\n\n\t/// @notice Set the share of rewards for a staker as a fraction of 1 ether\n\t/// @dev Rialto will call this\n\tfunction calculateAndDistributeRewards(address stakerAddr, uint256 totalEligibleGGPStaked) external onlyMultisig {\n\t\tStaking staking = Staking(getContractAddress(\"Staking\"));\n\t\tstaking.requireValidStaker(stakerAddr);\n\n\t\tRewardsPool rewardsPool = RewardsPool(getContractAddress(\"RewardsPool\"));\n\t\tif (rewardsPool.getRewardsCycleCount() == 0) {\n\t\t\trevert RewardsCycleNotStarted();\n\t\t}\n\n\t\tif (staking.getLastRewardsCycleCompleted(stakerAddr) == rewardsPool.getRewardsCycleCount()) {\n\t\t\trevert RewardsAlreadyDistributedToStaker(stakerAddr);\n\t\t}\n\t\tstaking.setLastRewardsCycleCompleted(stakerAddr, rewardsPool.getRewardsCycleCount());\n\t\tuint256 ggpEffectiveStaked = staking.getEffectiveGGPStaked(stakerAddr);\n\t\tuint256 percentage = ggpEffectiveStaked.divWadDown(totalEligibleGGPStaked);\n\t\tuint256 rewardsCycleTotal = getRewardsCycleTotal();\n\t\tuint256 rewardsAmt = percentage.mulWadDown(rewardsCycleTotal);\n\t\tif (rewardsAmt > rewardsCycleTotal) {\n\t\t\trevert InvalidAmount();\n\t\t}\n\n\t\tstaking.resetAVAXAssignedHighWater(stakerAddr);\n\t\tstaking.increaseGGPRewards(stakerAddr, rewardsAmt);\n\n\t\t// check if their rewards time should be reset\n\t\tuint256 minipoolCount = staking.getMinipoolCount(stakerAddr);\n\t\tif (minipoolCount == 0) {\n\t\t\tstaking.setRewardsStartTime(stakerAddr, 0);\n\t\t}\n\t}\n\n\t/// @notice Claim GGP and automatically restake the remaining unclaimed rewards\n\t/// @param claimAmt The amount of GGP the staker would like to withdraw from the protocol\n\tfunction claimAndRestake(uint256 claimAmt) external {\n\t\tStaking staking = Staking(getContractAddress(\"Staking\"));\n\t\tuint256 ggpRewards = staking.getGGPRewards(msg.sender);\n\t\tif (ggpRewards == 0) {\n\t\t\trevert NoRewardsToClaim();\n\t\t}\n\t\tif (claimAmt > ggpRewards) {\n\t\t\trevert InvalidAmount();\n\t\t}\n\n\t\tstaking.decreaseGGPRewards(msg.sender, ggpRewards);\n\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\t\tuint256 restakeAmt = ggpRewards - claimAmt;\n\t\tif (restakeAmt > 0) {\n\t\t\tvault.withdrawToken(address(this), ggp, restakeAmt);\n\t\t\tggp.approve(address(staking), restakeAmt);\n\t\t\tstaking.restakeGGP(msg.sender, restakeAmt);\n\t\t}\n\n\t\tif (claimAmt > 0) {\n\t\t\tvault.withdrawToken(msg.sender, ggp, claimAmt);\n\t\t}\n\n\t\temit GGPRewardsClaimed(msg.sender, claimAmt);\n\t}\n}"
    },
    {
      "filename": "contracts/contract/ClaimProtocolDAO.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport \"./Base.sol\";\nimport {Storage} from \"./Storage.sol\";\nimport {TokenGGP} from \"./tokens/TokenGGP.sol\";\nimport {Vault} from \"./Vault.sol\";\n\n/// @title Protocol DAO claiming GGP Rewards\ncontract ClaimProtocolDAO is Base {\n\terror InvalidAmount();\n\n\tevent GGPTokensSentByDAOProtocol(string invoiceID, address indexed from, address indexed to, uint256 amount);\n\n\tconstructor(Storage storageAddress) Base(storageAddress) {\n\t\tversion = 1;\n\t}\n\n\t/// @notice Spends the ProtocolDAO's GGP rewards\n\tfunction spend(\n\t\tstring memory invoiceID,\n\t\taddress recipientAddress,\n\t\tuint256 amount\n\t) external onlyGuardian {\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\t\tTokenGGP ggpToken = TokenGGP(getContractAddress(\"TokenGGP\"));\n\n\t\tif (amount == 0 || amount > vault.balanceOfToken(\"ClaimProtocolDAO\", ggpToken)) {\n\t\t\trevert InvalidAmount();\n\t\t}\n\n\t\tvault.withdrawToken(recipientAddress, ggpToken, amount);\n\n\t\temit GGPTokensSentByDAOProtocol(invoiceID, address(this), recipientAddress, amount);\n\t}\n}"
    }
  ]
}