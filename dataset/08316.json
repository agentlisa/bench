{
  "Title": "[G-12] Using bools for storage incurs overhead",
  "Content": "\n        // Booleans are more expensive than uint256 or any type that takes up a full\n        // word because each write operation emits an extra SLOAD to first read the\n        // slot's contents, replace the bits taken up by the boolean, and then write\n        // back. This is the compiler's defense against contract upgrades and\n        // pointer aliasing, and it cannot be disabled.\n\nSee [source](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27)<br>\nUse uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess (100 gas), and to avoid Gsset (20000 gas) when changing from ‘false’ to ‘true’, after having been ‘true’ in the past.\n\n**Instances affected include**<br>\nFile: HomeFiProxy.sol [line 30](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/HomeFiProxy.sol#L30)\n\n```solidity\n    mapping(address => bool) internal contractsActive;\n```\n\nFile: Disputes.sol [Line 144](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Disputes.sol#L144)\n\n```solidity\n        bool _ratify\n```\n\nFile: HomeFi.sol [Line 50](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/HomeFi.sol#L50)\n\n```solidity\n    bool public override addrSet;\n```\n\nFile: Project.sol [Line 68](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L68)\n\n```solidity\n    bool public override contractorConfirmed;\n```\n\nFile: Project.sol [Line 84](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L84)\n\n```solidity\n    mapping(address => mapping(bytes32 => bool)) public override approvedHashes;\n```\n\nFile: Project.sol [Line 412](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L412)\n\n```solidity\n        bool _unapproved = false;\n```\n\nFile: Project.sol  [Line 582](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L582)\n\n```solidity\n        bool _exceedLimit;\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-08-rigor-protocol-contest",
  "Code": [
    {
      "filename": "contracts/security/ReentrancyGuard.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}"
    },
    {
      "filename": "contracts/HomeFiProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {TransparentUpgradeableProxy} from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport {ProxyAdmin} from \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/**\n * @title HomeFiProxy Contract for HomeFi v2.5.0\n\n * @dev This contract provided functionality to update the core HomeFi contracts.\n */\ncontract HomeFiProxy is OwnableUpgradeable {\n    /*******************************************************************************\n     * -------------------------PUBLIC STORED PROPERTIES-------------------------- *\n     *******************************************************************************/\n\n    /// @notice Address of proxy admin\n    ProxyAdmin public proxyAdmin;\n\n    /// @notice bytes2 array of upgradable contracts initials\n    bytes2[] public allContractNames;\n\n    /*******************************************************************************\n     * ------------------------INTERNAL STORED PROPERTIES------------------------- *\n     *******************************************************************************/\n\n    /// @dev mapping that tell if a particular address is active(latest version of contract)\n    mapping(address => bool) internal contractsActive;\n\n    /// @dev mapping that maps contract initials with there implementation address\n    mapping(bytes2 => address payable) internal contractAddress;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    /// @dev check _address should not be zero address\n    modifier nonZero(address _address) {\n        require(_address != address(0), \"Proxy::0 address\");\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @notice Initialize all the homeFi contract in the correct sequential order and generate upgradable proxy for them.\n\n     * @dev Can only be called by HomeFiProxy owner.\n     * @dev modifier initializer\n     * @dev if more contract are added in homeFi, then their entry can be done here. \n\n     * @param _implementations the implementation address of homeFi smart contract in correct sequence.\n     */\n    function initiateHomeFi(address[] calldata _implementations)\n        external\n        initializer\n    {\n        // Initialize ownable\n        __Ownable_init();\n\n        // Create new proxy admin contract\n        proxyAdmin = new ProxyAdmin();\n\n        // Initial contract names\n        allContractNames.push(\"HF\"); // HomeFi\n        allContractNames.push(\"CN\"); // Community\n        allContractNames.push(\"DP\"); // Disputes\n        allContractNames.push(\"PF\"); // Project Factory\n        allContractNames.push(\"DA\"); // rDAI\n        allContractNames.push(\"US\"); // rUSDC\n        allContractNames.push(\"NT\"); // native token rETH - rXDAI\n\n        // Local instance of variable. For saving gas.\n        uint256 _length = allContractNames.length;\n\n        // Revert if _implementations length is wrong. Indicating wrong set of _implementations.\n        require(_length == _implementations.length, \"Proxy::Lengths !match\");\n\n        // Mark this contract as active\n        contractsActive[address(this)] = true;\n\n        // Generate proxy for all implementation\n        for (uint256 i = 0; i < _length; i++) {\n            _generateProxy(allContractNames[i], _implementations[i]);\n        }\n    }\n\n    /**\n     * @notice Adds a new contract type/implementation to HomeFi\n\n     * @dev modifier onlyOwner\n\n     * @param _contractName initial of contract to be added\n     * @param _contractAddress address of contract implementation to be added.\n     */\n    function addNewContract(bytes2 _contractName, address _contractAddress)\n        external\n        onlyOwner\n    {\n        // Revert if _contractName is already in use.\n        require(\n            contractAddress[_contractName] == address(0),\n            \"Proxy::Name !OK\"\n        );\n\n        // Add to allContractNames\n        allContractNames.push(_contractName);\n\n        // Generate proxy\n        _generateProxy(_contractName, _contractAddress);\n    }\n\n    /**\n     * @notice Upgrades a multiple contract implementations. Replaces old implementation with new.\n\n     * @dev modifier onlyOwner\n\n     * @param _contractNames bytes2 array of contract initials that needs to be upgraded\n     * @param _contractAddresses address array of contract implementation address that needs to be upgraded\n     */\n    function upgradeMultipleImplementations(\n        bytes2[] calldata _contractNames,\n        address[] calldata _contractAddresses\n    ) external onlyOwner {\n        // Local instance of variable. For saving gas.\n        uint256 _length = _contractNames.length;\n\n        // Revert if _contractNames and _contractAddresses length mismatch\n        require(_length == _contractAddresses.length, \"Proxy::Lengths !match\");\n\n        // Replace implementations\n        for (uint256 i = 0; i < _length; i++) {\n            _replaceImplementation(_contractNames[i], _contractAddresses[i]);\n        }\n    }\n\n    /**\n     * @notice Allows HomeFiProxy owner to change the owner of proxyAdmin contract.\n     * This can be useful when trying to deploy new version of HomeFiProxy\n\n     * @dev modifier onlyOwner\n     * @dev modifier nonZero with _newAdmin\n\n     * @param _newAdmin address of new proxyAdmin owner / new version of HomeFiProxy\n     */\n    function changeProxyAdminOwner(address _newAdmin)\n        external\n        onlyOwner\n        nonZero(_newAdmin)\n    {\n        // Transfer ownership to new admin.\n        proxyAdmin.transferOwnership(_newAdmin);\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @notice To check if we use the particular contract.\n     * @param _address The contract address to check if it is active or not.\n     * @return true if _address is active else false\n     */\n    function isActive(address _address) external view returns (bool) {\n        return contractsActive[_address];\n    }\n\n    /**\n     * @notice Gets latest contract address\n     * @param _contractName Contract name to fetch\n     * @return current implementation address corresponding to _contractName\n     */\n    function getLatestAddress(bytes2 _contractName)\n        external\n        view\n        returns (address)\n    {\n        return contractAddress[_contractName];\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev Replaces the implementations of the contract.\n     * @dev modifier nonZero with _contractAddress\n\n     * @param _contractName The name of the contract.\n\n     * @param _contractAddress The address of the contract to replace the implementations for.\n     */\n    function _replaceImplementation(\n        bytes2 _contractName,\n        address _contractAddress\n    ) internal nonZero(_contractAddress) {\n        // Upgrade proxy\n        proxyAdmin.upgrade(\n            TransparentUpgradeableProxy(contractAddress[_contractName]),\n            _contractAddress\n        );\n    }\n\n    /**\n     * @dev generates upgradable proxy\n     * @dev modifier nonZero with _contractAddress\n\n     * @param _contractName initial of the contract\n\n     * @param _contractAddress of the proxy\n     */\n    function _generateProxy(bytes2 _contractName, address _contractAddress)\n        internal\n        nonZero(_contractAddress)\n    {\n        // Deploys new TransparentUpgradeableProxy for implementation\n        TransparentUpgradeableProxy tempInstance = new TransparentUpgradeableProxy(\n                _contractAddress,\n                address(proxyAdmin),\n                bytes(\"\")\n            );\n\n        // Store details\n        contractAddress[_contractName] = payable(address(tempInstance));\n        contractsActive[address(tempInstance)] = true;\n    }\n}"
    },
    {
      "filename": "contracts/Disputes.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {IDisputes} from \"./interfaces/IDisputes.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ContextUpgradeable, ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/**\n * @title Disputes Contract for HomeFi v2.5.0\n\n * @dev Module for raising disputes for arbitration within HomeFi projects\n */\ncontract Disputes is\n    IDisputes,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    /*******************************************************************************\n     * -------------------------PUBLIC STORED PROPERTIES-------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IDisputes\n    IHomeFi public override homeFi;\n    /// @inheritdoc IDisputes\n    uint256 public override disputeCount; //starts from 0\n    /// @inheritdoc IDisputes\n    mapping(uint256 => Dispute) public override disputes;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    modifier nonZero(address _address) {\n        // Revert if _address zero address (0x00)\n        require(_address != address(0), \"Disputes::0 address\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        // Revert if sender is not HomeFi admin\n        // Only HomeFi admin can resolve dispute\n        require(homeFi.admin() == _msgSender(), \"Disputes::!Admin\");\n        _;\n    }\n\n    modifier onlyProject() {\n        // Revert if project not originated of HomeFi\n        require(homeFi.isProjectExist(_msgSender()), \"Disputes::!Project\");\n        _;\n    }\n\n    /**\n     * Affirm that a given dispute is currently resolvable\n     * @param _disputeID uint256 - the serial/id of the dispute\n     */\n    modifier resolvable(uint256 _disputeID) {\n        require(\n            _disputeID < disputeCount &&\n                disputes[_disputeID].status == Status.Active,\n            \"Disputes::!Resolvable\"\n        );\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IDisputes\n    function initialize(address _homeFi)\n        external\n        override\n        initializer\n        nonZero(_homeFi)\n    {\n        homeFi = IHomeFi(_homeFi);\n    }\n\n    /// @inheritdoc IDisputes\n    function raiseDispute(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n        onlyProject\n    {\n        // Recover signer from signature\n        address _signer = SignatureDecoder.recoverKey(\n            keccak256(_data),\n            _signature,\n            0\n        );\n\n        // Decode params from _data\n        (\n            address _project,\n            uint256 _taskID,\n            uint8 _actionType,\n            bytes memory _actionData,\n            bytes memory _reason\n        ) = abi.decode(_data, (address, uint256, uint8, bytes, bytes));\n\n        // Revert if _actionType is invalid\n        require(\n            _actionType > 0 && _actionType <= uint8(ActionType.TaskPay),\n            \"Disputes::!ActionType\"\n        );\n\n        // Store dispute details\n        Dispute storage _dispute = disputes[disputeCount];\n        _dispute.status = Status.Active;\n        _dispute.project = _project;\n        _dispute.taskID = _taskID;\n        _dispute.raisedBy = _signer;\n        _dispute.actionType = ActionType(_actionType);\n        _dispute.actionData = _actionData;\n\n        // Increment dispute counter and emit event\n        emit DisputeRaised(disputeCount++, _reason);\n    }\n\n    /// @inheritdoc IDisputes\n    function attachDocument(uint256 _disputeID, bytes calldata _attachment)\n        external\n        override\n        resolvable(_disputeID)\n    {\n        // Local instance of variable. For saving gas.\n        Dispute storage _dispute = disputes[_disputeID];\n\n        // Check if sender is related to dispute\n        assertMember(_dispute.project, _dispute.taskID, _msgSender());\n\n        // Emit _attachment in event. To save it in logs.\n        emit DisputeAttachmentAdded(_disputeID, _msgSender(), _attachment);\n    }\n\n    /// @inheritdoc IDisputes\n    function resolveDispute(\n        uint256 _disputeID,\n        bytes calldata _judgement,\n        bool _ratify\n    ) external override onlyAdmin nonReentrant resolvable(_disputeID) {\n        // If dispute is accepted\n        if (_ratify) {\n            // Complete dispute actions\n            resolveHandler(_disputeID);\n\n            // Mark dispute as accepted\n            disputes[_disputeID].status = Status.Accepted;\n        }\n        // If dispute is rejected\n        else {\n            // Mark dispute as rejected\n            disputes[_disputeID].status = Status.Rejected;\n        }\n\n        emit DisputeResolved(_disputeID, _ratify, _judgement);\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IDisputes\n    function assertMember(\n        address _project,\n        uint256 _taskID,\n        address _address\n    ) public view override {\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Get task subcontractor\n        (, address _sc, ) = _projectInstance.getTask(_taskID);\n\n        // Revert is signer is not builder, contractor or subcontractor.\n        bool _result = _projectInstance.builder() == _address ||\n            _projectInstance.contractor() == _address ||\n            _sc == _address;\n        require(_result, \"Disputes::!Member\");\n    }\n\n    /// @inheritdoc IDisputes\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, IDisputes)\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @notice Given an id, attempt to execute the action to enforce the arbitration\n\n     * @notice logic for decoding and enforcing outcome of arbitration judgement\n\n     * @param _disputeID uint256 - the dispute to attempt to\n     */\n    function resolveHandler(uint256 _disputeID) internal {\n        // Local instance of variable. For saving gas.\n        Dispute storage dispute = disputes[_disputeID];\n\n        // If action type is add task then execute add task\n        if (dispute.actionType == ActionType.TaskAdd) {\n            executeTaskAdd(dispute.project, dispute.actionData);\n        }\n        // If action type is task change then execute task change\n        else if (dispute.actionType == ActionType.TaskChange) {\n            executeTaskChange(dispute.project, dispute.actionData);\n        }\n        // Else execute task pay\n        else {\n            executeTaskPay(dispute.project, dispute.actionData);\n        }\n    }\n\n    /**\n     * @dev Arbitration enforcement of task change orders\n\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the task add transaction data stored when dispute was raised\n     * - _hash bytes[] - bytes IPFS hash of task details\n     * - _taskCosts uint256[] - an array of cost for each task index\n     * - _taskCount uint256 - current task count before adding these tasks. Can be fetched by taskCount.\n     *   For signature security.\n     * - _projectAddress address - the address of this contract. For signature security.\n     */\n    function executeTaskAdd(address _project, bytes memory _actionData)\n        internal\n    {\n        IProject(_project).addTasks(_actionData, bytes(\"\"));\n    }\n\n    /**\n     * @dev Arbitration enforcement of task change orders\n\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the task change order transaction data stored when dispute was raised\n     * - _taskID uint256 - index of the task\n     * - _newSC address - address of new subcontractor.\n     *   If do not want to replace subcontractor, then pass address of existing subcontractor.\n     * - _newCost uint256 - new cost for the task.\n     *   If do not want to change cost, then pass existing cost.\n     * - _project address - address of project\n     */\n    function executeTaskChange(address _project, bytes memory _actionData)\n        internal\n    {\n        IProject(_project).changeOrder(_actionData, bytes(\"\"));\n    }\n\n    /**\n     * @dev Arbitration enforcement of task payout\n\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the task payout transaction data stored when dispute was raised\n     * - _taskID uint256 - the index of task\n     * - _projectAddress address - the address of this contract. For signature security.\n     */\n    function executeTaskPay(address _project, bytes memory _actionData)\n        internal\n    {\n        IProject(_project).setComplete(_actionData, bytes(\"\"));\n    }\n}"
    },
    {
      "filename": "contracts/HomeFi.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProjectFactory} from \"./interfaces/IProjectFactory.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC721URIStorageUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\";\nimport {ContextUpgradeable, ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\n\n/**\n * @title HomeFi v2.5.0 HomeFi Contract.\n\n * @notice Main on-chain client.\n * Administrative controls and project deployment.\n \n * @dev\n * Adheres to -\n * IHomeFi: Allows this contract to be used by other HomeFi contracts.\n\n * @dev\n * Inherits from -\n * ReentrancyGuardUpgradeable: Contract module that helps prevent reentrant calls to a function.\n * ERC721URIStorageUpgradeable: ERC721 token with storage based token URI management.\n * ERC2771ContextUpgradeable: Context variant with ERC2771 support.\n */\ncontract HomeFi is\n    IHomeFi,\n    ReentrancyGuardUpgradeable,\n    ERC721URIStorageUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    /*******************************************************************************\n     * -------------------------PUBLIC STORED PROPERTIES-------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IHomeFi\n    address public override tokenCurrency1;\n    /// @inheritdoc IHomeFi\n    address public override tokenCurrency2;\n    /// @inheritdoc IHomeFi\n    address public override tokenCurrency3;\n    /// @inheritdoc IHomeFi\n    IProjectFactory public override projectFactoryInstance;\n    /// @inheritdoc IHomeFi\n    address public override disputesContract;\n    /// @inheritdoc IHomeFi\n    address public override communityContract;\n    /// @inheritdoc IHomeFi\n    bool public override addrSet;\n    /// @inheritdoc IHomeFi\n    address public override admin;\n    /// @inheritdoc IHomeFi\n    address public override treasury;\n    /// @inheritdoc IHomeFi\n    uint256 public override lenderFee;\n    /// @inheritdoc IHomeFi\n    uint256 public override projectCount;\n    /// @inheritdoc IHomeFi\n    address public override trustedForwarder;\n    /// @inheritdoc IHomeFi\n    mapping(uint256 => address) public override projects;\n    /// @inheritdoc IHomeFi\n    mapping(address => uint256) public override projectTokenId;\n    /// @inheritdoc IHomeFi\n    mapping(address => address) public override wrappedToken;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    modifier onlyAdmin() {\n        require(admin == _msgSender(), \"HomeFi::!Admin\");\n        _;\n    }\n\n    modifier nonZero(address _address) {\n        require(_address != address(0), \"HomeFi::0 address\");\n        _;\n    }\n\n    modifier noChange(address _oldAddress, address _newAddress) {\n        // Revert if new address is same as old\n        require(_oldAddress != _newAddress, \"HomeFi::!Change\");\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IHomeFi\n    function initialize(\n        address _treasury,\n        uint256 _lenderFee,\n        address _tokenCurrency1,\n        address _tokenCurrency2,\n        address _tokenCurrency3,\n        address _forwarder\n    )\n        external\n        override\n        initializer\n        nonZero(_treasury)\n        nonZero(_tokenCurrency1)\n        nonZero(_tokenCurrency2)\n        nonZero(_tokenCurrency3)\n    {\n        // Initialize ERC721 and ERC2771Context\n        __ERC721_init(\"HomeFiNFT\", \"hNFT\");\n        __ERC2771Context_init(_forwarder);\n\n        // Initialize variables\n        admin = _msgSender();\n        treasury = _treasury;\n        lenderFee = _lenderFee; // the percentage must be multiplied with 10\n        tokenCurrency1 = _tokenCurrency1;\n        tokenCurrency2 = _tokenCurrency2;\n        tokenCurrency3 = _tokenCurrency3;\n        trustedForwarder = _forwarder;\n    }\n\n    /// @inheritdoc IHomeFi\n    function setAddr(\n        address _projectFactory,\n        address _communityContract,\n        address _disputesContract,\n        address _hTokenCurrency1,\n        address _hTokenCurrency2,\n        address _hTokenCurrency3\n    )\n        external\n        override\n        onlyAdmin\n        nonZero(_projectFactory)\n        nonZero(_communityContract)\n        nonZero(_disputesContract)\n        nonZero(_hTokenCurrency1)\n        nonZero(_hTokenCurrency2)\n        nonZero(_hTokenCurrency3)\n    {\n        // Revert if addrSet is true\n        require(!addrSet, \"HomeFi::Set\");\n\n        // Initialize variables\n        projectFactoryInstance = IProjectFactory(_projectFactory);\n        communityContract = _communityContract;\n        disputesContract = _disputesContract;\n        wrappedToken[tokenCurrency1] = _hTokenCurrency1;\n        wrappedToken[tokenCurrency2] = _hTokenCurrency2;\n        wrappedToken[tokenCurrency3] = _hTokenCurrency3;\n        addrSet = true;\n\n        emit AddressSet();\n    }\n\n    /// @inheritdoc IHomeFi\n    function replaceAdmin(address _newAdmin)\n        external\n        override\n        onlyAdmin\n        nonZero(_newAdmin)\n        noChange(admin, _newAdmin)\n    {\n        // Replace admin\n        admin = _newAdmin;\n\n        emit AdminReplaced(_newAdmin);\n    }\n\n    /// @inheritdoc IHomeFi\n    function replaceTreasury(address _newTreasury)\n        external\n        override\n        onlyAdmin\n        nonZero(_newTreasury)\n        noChange(treasury, _newTreasury)\n    {\n        // Replace treasury\n        treasury = _newTreasury;\n\n        emit TreasuryReplaced(_newTreasury);\n    }\n\n    /// @inheritdoc IHomeFi\n    function replaceLenderFee(uint256 _newLenderFee)\n        external\n        override\n        onlyAdmin\n    {\n        // Revert if no change in lender fee\n        require(lenderFee != _newLenderFee, \"HomeFi::!Change\");\n\n        // Reset variables\n        lenderFee = _newLenderFee;\n\n        emit LenderFeeReplaced(_newLenderFee);\n    }\n\n    /// @inheritdoc IHomeFi\n    function setTrustedForwarder(address _newForwarder)\n        external\n        override\n        onlyAdmin\n        noChange(trustedForwarder, _newForwarder)\n    {\n        trustedForwarder = _newForwarder;\n    }\n\n    /// @inheritdoc IHomeFi\n    function createProject(bytes memory _hash, address _currency)\n        external\n        override\n        nonReentrant\n    {\n        // Revert if currency not supported by HomeFi\n        validCurrency(_currency);\n\n        address _sender = _msgSender();\n\n        // Create a new project Clone and mint a new NFT for it\n        address _project = projectFactoryInstance.createProject(\n            _currency,\n            _sender\n        );\n        mintNFT(_sender, string(_hash));\n\n        // Update project related mappings\n        projects[projectCount] = _project;\n        projectTokenId[_project] = projectCount;\n\n        emit ProjectAdded(projectCount, _project, _sender, _currency, _hash);\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IHomeFi\n    function isProjectExist(address _project)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return projectTokenId[_project] > 0;\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IHomeFi\n    function validCurrency(address _currency) public view override {\n        // _currency must be one of HomeFi supported currencies\n        require(\n            _currency == tokenCurrency1 ||\n                _currency == tokenCurrency2 ||\n                _currency == tokenCurrency3,\n            \"HomeFi::!Currency\"\n        );\n    }\n\n    /// @inheritdoc IHomeFi\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, IHomeFi)\n        returns (bool)\n    {\n        return trustedForwarder == _forwarder;\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n    /**\n     * @dev Makes an NFT for every project\n\n     * @param _to address - NFT owner. Initially it will be the project builder.\n     * @param _tokenURI string - IPFS hash of project details like name, description etc\n\n     * @return _tokenIds NFT Id of project\n     */\n    function mintNFT(address _to, string memory _tokenURI)\n        internal\n        returns (uint256)\n    {\n        // Project count starts from 1\n        projectCount += 1;\n\n        // Mints NFT and set token URI\n        _mint(_to, projectCount);\n        _setTokenURI(projectCount, _tokenURI);\n\n        emit NftCreated(projectCount, _to);\n        return projectCount;\n    }\n\n    /*******************************************************************************\n     * ------------------------------INTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n    /// @dev This is same as ERC2771ContextUpgradeable._msgSender()\n    function _msgSender()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        // We want to use the _msgSender() implementation of ERC2771ContextUpgradeable\n        return super._msgSender();\n    }\n\n    /// @dev This is same as ERC2771ContextUpgradeable._msgData()\n    function _msgData()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        // We want to use the _msgData() implementation of ERC2771ContextUpgradeable\n        return super._msgData();\n    }\n}"
    },
    {
      "filename": "contracts/Project.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {IDebtToken} from \"./interfaces/IDebtToken.sol\";\nimport {IDisputes} from \"./interfaces/IDisputes.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {Tasks, Task, TaskStatus} from \"./libraries/Tasks.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/**\n * @title Deployable Project Contract for HomeFi v2.5.0\n\n * @notice contains the primary logic around construction project management. \n * O"
    }
  ]
}