{
  "Title": "Missing Table Registration",
  "Content": "*This issue was independently identified and fixed by the Lattice team during the audit.*\n\n\nThe Core module [registers the tables it uses](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/modules/core/CoreModule.sol#L80), but it excludes the [`FunctionSignatures` table](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/codegen/tables/FunctionSignatures.sol#L84). This prevents the indexers from decoding the `FunctionSignatures` events. Consider registering this table as well.\n\n\n***Update:** Resolved in pull request [#1841](https://github.com/latticexyz/mud/pull/1841) at commit [f96d8b3](https://github.com/latticexyz/mud/pull/1841/commits/f96d8b3226fdb48f51ecb1d803529d38fc884535).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/world/src/modules/core/CoreModule.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { WorldContextProviderLib } from \"../../WorldContext.sol\";\nimport { ROOT_NAMESPACE, ROOT_NAMESPACE_ID, WORLD_NAMESPACE_ID } from \"../../constants.sol\";\nimport { Module } from \"../../Module.sol\";\n\nimport { IBaseWorld } from \"../../codegen/interfaces/IBaseWorld.sol\";\n\nimport { StoreCore } from \"@latticexyz/store/src/StoreCore.sol\";\nimport { ResourceIds } from \"@latticexyz/store/src/codegen/tables/ResourceIds.sol\";\nimport { ResourceId, WorldResourceIdLib, WorldResourceIdInstance } from \"../../WorldResourceId.sol\";\nimport { RESOURCE_SYSTEM } from \"../../worldResourceTypes.sol\";\n\nimport { NamespaceOwner } from \"../../codegen/tables/NamespaceOwner.sol\";\nimport { ResourceAccess } from \"../../codegen/tables/ResourceAccess.sol\";\nimport { InstalledModules } from \"../../codegen/tables/InstalledModules.sol\";\nimport { UserDelegationControl } from \"../../codegen/tables/UserDelegationControl.sol\";\nimport { NamespaceDelegationControl } from \"../../codegen/tables/NamespaceDelegationControl.sol\";\n\nimport { CoreSystem } from \"./CoreSystem.sol\";\nimport { CORE_MODULE_NAME, CORE_SYSTEM_ID } from \"./constants.sol\";\n\nimport { Systems } from \"../../codegen/tables/Systems.sol\";\nimport { FunctionSelectors } from \"../../codegen/tables/FunctionSelectors.sol\";\nimport { SystemHooks } from \"../../codegen/tables/SystemHooks.sol\";\nimport { SystemRegistry } from \"../../codegen/tables/SystemRegistry.sol\";\nimport { Balances } from \"../../codegen/tables/Balances.sol\";\n\nimport { AccessManagementSystem } from \"./implementations/AccessManagementSystem.sol\";\nimport { BalanceTransferSystem } from \"./implementations/BalanceTransferSystem.sol\";\nimport { BatchCallSystem } from \"./implementations/BatchCallSystem.sol\";\nimport { ModuleInstallationSystem } from \"./implementations/ModuleInstallationSystem.sol\";\nimport { StoreRegistrationSystem } from \"./implementations/StoreRegistrationSystem.sol\";\nimport { WorldRegistrationSystem } from \"./implementations/WorldRegistrationSystem.sol\";\n\n/**\n * @title Core Module\n * @notice Registers internal World tables, the CoreSystem, and its function selectors.\n * @dev This module only supports `installRoot` because it installs root tables, systems and function selectors.\n */\n\ncontract CoreModule is Module {\n  /**\n   * @dev Since the CoreSystem only exists once per World and writes to\n   * known tables, we can deploy it once and register it in multiple Worlds.\n   */\n  address immutable coreSystem = address(new CoreSystem());\n\n  /**\n   * @notice Get the name of the module.\n   * @return Module name as bytes16.\n   */\n  function getName() public pure returns (bytes16) {\n    return CORE_MODULE_NAME;\n  }\n\n  /**\n   * @notice Root installation of the module.\n   * @dev Registers core tables, systems, and function selectors in the World.\n   */\n  function installRoot(bytes memory) public override {\n    _registerCoreTables();\n    _registerCoreSystem();\n    _registerFunctionSelectors();\n  }\n\n  /**\n   * @notice Non-root installation of the module.\n   * @dev Installation is only supported at root level, so this function will always revert.\n   */\n  function install(bytes memory) public pure {\n    revert Module_NonRootInstallNotSupported();\n  }\n\n  /**\n   * @notice Register core tables in the World.\n   * @dev This internal function registers various tables and sets initial permissions.\n   */\n  function _registerCoreTables() internal {\n    StoreCore.registerCoreTables();\n    NamespaceOwner.register();\n    Balances.register();\n    InstalledModules.register();\n    UserDelegationControl.register();\n    NamespaceDelegationControl.register();\n    ResourceAccess.register();\n    Systems.register();\n    FunctionSelectors.register();\n    SystemHooks.register();\n    SystemRegistry.register();\n\n    ResourceIds._setExists(ROOT_NAMESPACE_ID, true);\n    NamespaceOwner._set(ROOT_NAMESPACE_ID, _msgSender());\n    ResourceAccess._set(ROOT_NAMESPACE_ID, _msgSender(), true);\n\n    ResourceIds._setExists(WORLD_NAMESPACE_ID, true);\n    NamespaceOwner._set(WORLD_NAMESPACE_ID, _msgSender());\n    ResourceAccess._set(WORLD_NAMESPACE_ID, _msgSender(), true);\n  }\n\n  /**\n   * @notice Register the CoreSystem in the World.\n   * @dev Uses the CoreSystem's `registerSystem` implementation to register itself on the World.\n   */\n  function _registerCoreSystem() internal {\n    WorldContextProviderLib.delegatecallWithContextOrRevert({\n      msgSender: _msgSender(),\n      msgValue: 0,\n      target: coreSystem,\n      callData: abi.encodeCall(WorldRegistrationSystem.registerSystem, (CORE_SYSTEM_ID, CoreSystem(coreSystem), true))\n    });\n  }\n\n  /**\n   * @notice Register function selectors for all CoreSystem functions in the World.\n   * @dev Iterates through known function signatures and registers them.\n   */\n  function _registerFunctionSelectors() internal {\n    string[19] memory functionSignatures = [\n      // --- AccessManagementSystem ---\n      \"grantAccess(bytes32,address)\",\n      \"revokeAccess(bytes32,address)\",\n      \"transferOwnership(bytes32,address)\",\n      // --- BalanceTransferSystem ---\n      \"transferBalanceToNamespace(bytes32,bytes32,uint256)\",\n      \"transferBalanceToAddress(bytes32,address,uint256)\",\n      // --- BatchCallSystem ---\n      \"batchCall((bytes32,bytes)[])\",\n      \"batchCallFrom((address,bytes32,bytes)[])\",\n      // --- ModuleInstallationSystem ---\n      \"installModule(address,bytes)\",\n      // --- StoreRegistrationSystem ---\n      \"registerTable(bytes32,bytes32,bytes32,bytes32,string[],string[])\",\n      \"registerStoreHook(bytes32,address,uint8)\",\n      \"unregisterStoreHook(bytes32,address)\",\n      // --- WorldRegistrationSystem ---\n      \"registerNamespace(bytes32)\",\n      \"registerSystemHook(bytes32,address,uint8)\",\n      \"unregisterSystemHook(bytes32,address)\",\n      \"registerSystem(bytes32,address,bool)\",\n      \"registerFunctionSelector(bytes32,string)\",\n      \"registerRootFunctionSelector(bytes32,string,bytes4)\",\n      \"registerDelegation(address,bytes32,bytes)\",\n      \"registerNamespaceDelegation(bytes32,bytes32,bytes)\"\n    ];\n\n    for (uint256 i = 0; i < functionSignatures.length; i++) {\n      // Use the CoreSystem's `registerRootFunctionSelector` to register the\n      // root function selectors in the World.\n      WorldContextProviderLib.delegatecallWithContextOrRevert({\n        msgSender: _msgSender(),\n        msgValue: 0,\n        target: coreSystem,\n        callData: abi.encodeCall(\n          WorldRegistrationSystem.registerRootFunctionSelector,\n          (CORE_SYSTEM_ID, functionSignatures[i], bytes4(keccak256(bytes(functionSignatures[i]))))\n        )\n      });\n    }\n  }\n}"
    }
  ]
}