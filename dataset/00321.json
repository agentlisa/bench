{
  "Title": "M-3: Theft of initial bonds from proposers who are using smart wallets",
  "Content": "# Issue M-3: Theft of initial bonds from proposers who are using smart wallets \n\nSource: https://github.com/sherlock-audit/2024-02-optimism-2024-judging/issues/194 \n\n## Found by \nGalloDaSballo, Trust\n## Summary\n\nProposal of output roots through the DisputeGameFactory from Smart Wallets is vulnerable to frontrunning attacks which will steal the initial bond of the proposer.\n\n## Vulnerability Detail\n\nA fault dispute game is built from the factory, which initializes the first claim in the array below:\n\n```solidity\nclaimData.push(\n    ClaimData({\n        parentIndex: type(uint32).max,\n        counteredBy: address(0),\n        claimant: tx.origin,\n        bond: uint128(msg.value),\n        claim: rootClaim(),\n        position: ROOT_POSITION,\n        clock: LibClock.wrap(Duration.wrap(0), Timestamp.wrap(uint64(block.timestamp)))\n    })\n);\n```\n\nThe  sender passes a `msg.value` which equals the required bond amount, and the registered `claimant` is `tx.origin`.  At the end of the game, if the claim is honest, the funds will be returned to the `claimant`.\n\nSmart Wallets are extremely popular ways of holding funds and are used by all types of entities for additional security properties and/or flexibility. A typical smart wallet will receive some `execute()` call with parameters, verify it's authenticity via signature / multiple signatures, and perform the requested external call. That is how the highly popular Gnosis Safe operates among many others. Smart Wallets are agnostic to whoever actually  called the `execute()` function, as long as the data is authenticated.\n\nThese properties as well as the use of `tx.origin` in the FaultDisputeGame make it easy to steal the bonds of honest proposals:\n- Scan the mempool for calls to [Gnosis](https://github.com/safe-global/safe-smart-account/blob/1cd7568769128717c1a6862d22fe34873d7c79c8/contracts/Safe.sol#L104) `execTransaction()`  or any other variants.\n- Copy the TX content and call it from the attacker's EOA.\n- The Smart Wallet will accept the call and send the `msg.value` to the DisputeGameFactory.\n- The `claimant` will now be the attacker.\n- Upon resolution of the root claim, the attacker will receive the initial bond.\n\n## Impact\n\nTheft of funds from an honest victim who did not interact with the system in any wrong way.\n\n## Code Snippet\n\n```solidity\nclaimData.push(\n    ClaimData({\n        parentIndex: type(uint32).max,\n        counteredBy: address(0),\n        claimant: tx.origin,\n        bond: uint128(msg.value),\n        claim: rootClaim(),\n        position: ROOT_POSITION,\n        clock: LibClock.wrap(Duration.wrap(0), Timestamp.wrap(uint64(block.timestamp)))\n    })\n);\n```\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe Factory needs to pass down the real msg.sender to the FaultDisputeGame. \n\n\n\n## Discussion\n\n**smartcontracts**\n\nThis report is not entirely correct. It is not possible to \"steal\" funds from a wallet. Instead, it is the case that the user creating the `FaultDisputeGame` would not receive their bonds at the end of the game. Although this behavior was intentional as the contracts are meant to be used by EOAs directly and not smart contract wallets, we believe this is a valid low-severity issue and we will fix it.\n\n**trust1995**\n\n> This report is not entirely correct. It is not possible to \"steal\" funds from a wallet. Instead, it is the case that the user creating the FaultDisputeGame would not receive their bonds at the end of the game.\n\nWhat you described is essentially stealing - an honest user's bond will be claimed by the attacker.\n\n> Although this behavior was intentional as the contracts are meant to be used by EOAs directly and not smart contract wallets, we believe this is a valid low-severity issue and we will fix it.\n- If the behavior is intentional, then why fix it?\n- Also, no mention anywhere of the assumption that disputers (which are permissionless) should be EOAs, therefore we can't view that as reducing severity or OOS in any capacity.\n\n**smartcontracts**\n\nI think the implied contract is relatively clear, the user who creates the game is the `tx.origin` and not the `msg.sender`. Smart contract wallets weren't an intended user of the contracts. Either way impact is relatively limited (smallest bond size is at the initialization level). I think it's a pretty clear footgun though and should be fixed to prevent issues down the line.\n\n**smartcontracts**\n\nSo actual stance here is that this is valid but low-likelihood and low-impact in practice. \n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/ethereum-optimism/optimism/pull/10149\n\n\n**nevillehuang**\n\nBased on scope details below, any issue with root cause of the issue stemming from FDG contract will be considered OOS of this contest if airgap and/or delayed WETH mechanism implemented for off-chain review of game results and bond distribution is not shown to be bypassed\n\nhttps://docs.google.com/document/d/1xjvPwAzD2Zxtx8-P6UE69TuoBwtZPbpwf5zBHAvBJBw/edit\n\n**trust1995**\n\n@nevillehuang The root cause is clearly in the factory contract using an unusafe tx.origin parameter, as demonstrated in the submission. The finding is in scope.\n\n**trust1995**\n\nEscalate\n\nThe issue is in scope, because:\n\n- The bug's origin is certainly not in the FDG's _initialize()_ function - without any changes to the factory there is NO actual way to determine who the correct claimant should be. The FDG does not have the neceesary context, and the root cause is lack of sending the msg.sender of the factory as a parameter. This is further evidenced by the fact the fix [changed ](packages/contracts-bedrock/src/dispute/DisputeGameFactory.sol) the Factory's call\n- The impact is clearly high\n- Based on the following ruling, the submission must be treated as in-scope: `Issues with a root cause in the non-game contracts are IN SCOPE`\n\n**sherlock-admin2**\n\n> Escalate\n> \n> The issue is in scope, because:\n> \n> - The bug's origin is certainly not in the FDG's _initialize()_ function - without any changes to the factory there is NO actual way to determine who the correct claimant should be. The FDG does not have the neceesary context, and the root cause is lack of sending the msg.sender of the factory as a parameter. This is further evidenced by the fact the fix [changed ](packages/contracts-bedrock/src/dispute/DisputeGameFactory.sol) the Factory's call\n> - The impact is clearly high\n> - Based on the following ruling, the submission must be treated as in-scope: `Issues with a root cause in the non-game contracts are IN SCOPE`\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\nAgree that this issue is valid, given the root cause can be seen as  stemming from the factory contract. Additionally, there is no mention whether only an EOA is allowed to interact with the contracts. Based on agreed upon scope and line drawn, I believe medium severity to be appropriate since no safety mechanisms (DelyayedWETH) is bypassed.\n\n**MightyFox3**\n\nFirstly, it's important to clarify that funds cannot be \"stolen\" from a wallet in the manner described. The scenario involves the user who initiates the FaultDisputeGame; they would not receive their bonds back at the conclusion of the game, which differs significantly from the notion of funds being stolen.\n\nRegarding the vulnerabilities outlined in the original report, it seems there are misconceptions about the ease of exploiting these issues. The steps provided suggest that an attacker can simply scan the mempool, copy transaction content, and execute it from their own externally owned account (EOA). However, this overlooks critical security measures inherent in the system:\n\n- The Gnosis smart contract requires signatures from its owners, Alice and Bob, to authorize any execution of the `execTransaction()` function. This means copying the transaction content and executing it from an attacker's EOA is not feasible unless there is a flaw in how signatures are validated, which is not typical for smart contract wallets, including the Gnosis Safe Wallet.\n\n- Furthermore, even if Alice and Bob authorize a transaction, the claim that funds are lost is incorrect. If Alice is the transaction originator and her EOA executes the transaction, she (tx.origin) retains the ability to claim the bond. Therefore, there is no actual loss of funds.\n\nGiven these clarifications, it would be more accurate to assess the severity of the issue as low, rather than medium.\n\n**trust1995**\n\n@MightyFox3 you seem to have completely missed the meat of the exploit, so allow me to re-iterate:\n\n\n\n> Firstly, it's important to clarify that funds cannot be \"stolen\" from a wallet in the manner described. The scenario involves the user who initiates the FaultDisputeGame; they would not receive their bonds back at the conclusion of the game, which differs significantly from the notion of funds being stolen.\n\nRespectfully, when an attacker can receive a bond deposited by a victim's account without proofing their claim was invalid, it is considered a theft of funds. \n\n> * The Gnosis smart contract requires signatures from its owners, Alice and Bob, to authorize any execution of the `execTransaction()` function. This means copying the transaction content and executing it from an attacker's EOA is not feasible unless there is a flaw in how signatures are validated, which is not typical for smart contract wallets, including the Gnosis Safe Wallet.\n\nOf course it requires signatures, this is the part of the original submission: `Copy the TX content and call it from the attacker's EOA.` The attacker requires a proposer who is using smart wallet, like the title says. That is not a side exploit or any actual blocking limitation, since we assume the functionality is a valid way of interaction (not otherwise noted).\n\n> Furthermore, even if Alice and Bob authorize a transaction, the claim that funds are lost is incorrect. If Alice is the transaction originator and her EOA executes the transaction, she (tx.origin) retains the ability to claim the bond. Therefore, there is no actual loss of funds.\n\nHonestly don't understand the argument - is this saying that if the exploit is botched (doesn't frontrun like it should), it fails? It is shown in the submission that a malicious frontrunner will be registered as the claimant, and receive the bond at the end of the dispute.\n\n\n**MightyFox3**\n\nThank you for clarifying the situation further.\n\nAlice and Bob, who own the smart contract wallet, need to agree and sign off on any transactions that initiate the claim. If Alice submits the transaction and there's no frontrunning interference, she should be the one to claim the bond.\n\nHowever, if Bob were to submit his own claim before Alice’s is processed—a practice known as frontrunning—he would then be eligible to claim the bond. This could be unfair to Alice, especially if Bob does this deliberately. But such a situation is quite rare since both parties need to agree to initiate the transaction.\n\nThis makes the potential problem less severe, as it relies heavily on one party acting against the agreed-upon terms.\n\n**54710adk341**\n\nYou can't just 'front-run' any given smart wallet.\n\n[Safe.sol#L141-L161](https://github.com/safe-global/safe-smart-account/blob/8340a4e6e898755aaca8b285f164c20e41891691/contracts/Safe.sol#L141-L161)\n```solidity\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkTransaction(\n                    // Transaction info\n                    to,\n                    value,\n                    data,\n                    operation,\n                    safeTxGas,\n                    // Payment info\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    // Signature info\n                    signatures,\n                    msg.sender\n                );\n            }\n        }\n```\nSmart wallets have guards in place, they check against the `msg.sender`. Front-running would make `execTransaction()` fail since the `msg.sender` would be different. \n\n**trust1995**\n\n> Thank you for clarifying the situation further.\n> \n> Alice and Bob, who own the smart contract wallet, need to agree and sign off on any transactions that initiate the claim. If Alice submits the transaction and there's no frontrunning interference, she should be the one to claim the bond.\n> \n> However, if Bob were to submit his own claim before Alice’s is processed—a practice known as frontrunning—he would then be eligible to claim the bond. This could be unfair to Alice, especially if Bob does this deliberately. But such a situation is quite rare since both parties need to agree to initiate the transaction.\n> \n> This makes the potential problem less severe, as it relies heavily on one party acting against the agreed-upon terms.\n\nNo, that's the point. Charlie, an **unprivileged attacker** who observes the TX Alice sent to the mempool, copies the contents and sends it from his EOA. They frontrun the origin TX and steal the bond. \n\n**trust1995**\n\n> You can't just 'front-run' any given smart wallet.\n> \n> [Safe.sol#L141-L161](https://github.com/safe-global/safe-smart-account/blob/8340a4e6e898755aaca8b285f164c20e41891691/contracts/Safe.sol#L141-L161)\n> \n> ```solidity\n>         {\n>             if (guard != address(0)) {\n>                 Guard(guard).checkTransaction(\n>                     // Transaction info\n>                     to,\n>                     value,\n>                     data,\n>                     operation,\n>                     safeTxGas,\n>                     // Payment info\n>                     baseGas,\n>                     gasPrice,\n>                     gasToken,\n>                     refundReceiver,\n>                     // Signature info\n>                     signatures,\n>                     msg.sender\n>                 );\n>             }\n>         }\n> ```\n> \n> Smart wallets have guards in place, they check against the `msg.sender`. Front-running would make `execTransaction()` fail since the `msg.sender` would be different.\n\nThat's a wildly incorrect statement. The design of smart wallets is exactly with account abstraction in mind - The TX contents, gas , calldata etc are all signed by the multisig and then _anyone_ can transmit the TX to the blockchain. A TX should be perfectly secure regardless of who is initiating the smart wallet execution call.\n\nThe contestant is referring to the optional guard feature, which can perform any type of filtering at the discretion of the multisig. The only two multisigs I've checked, the [Chainlink MS](https://etherscan.io/address/0x4a87ecE3eFffCb012fbE491AA028032e07B6F6cF) and the [Optimism MS](https://etherscan.io/address/0x5a0Aae59D09fccBdDb6C6CcEB07B7279367C3d2A#readProxyContract), don't use any guards. It is, broadly speaking, a mostly unused feature used to perform arbitrary custom validation, and has no relevance to the submission.\n\n**lemonmon1984**\n\nBut at the end, the optimism team can utilize DelayedWETH to address the situation. There is no airgap bypass, and based on the security measures such as DelayedWETH, the funds are secure.\n\n**bemic**\n\n_Signatures of Safe owners for a specific transaction are crafted off-chain and passed into the function as input parameters. Once there are enough signatures to pass the threshold, the Safe transaction will be executed. Who is the one who calls the Execute function? It does not matter._ \n\nThis is the known problem of Safe multisig wallet. There are Guards made specifically to avoid this situation, and they let only one of the owners call the actual execution. However, they are **not** set up by default.\nI see this as a known and real problem of Safe. But other protocols like optimism are not forced to be compatible (although they probably should).\n\n**Evert0x**\n\nThis issue is either invalid as it flags a design recommendation to mitigate an attack vector. From the perspective of the smart contract it's functioning as normal, it's just that the user didn't take the necessary measures to profit from this.\n\nOr it's valid and Medium as the loss requires specific conditions (smart wallet) and it's constrained as it only applies to the initial bond. \n\nWill revisit this issue\n\n**trust1995**\n\n> From the perspective of the smart contract it's functioning as normal, it's just that the user didn't take the necessary measures to profit from this.\n\nThe rationale above can be said about any smart contract exploit, from the perspective of the smart contract, everything is functioning as normal. It's not a design recommendation, because Optimism did not limit interaction with the contracts to only EOAs, and any usage without using a private mempool (extremely likely) is vulnerable.\n\n> Or it's valid and Medium as the loss requires specific conditions (smart wallet) \n\nAs a C4 Supreme Court judge, that's not the type of conditions that merit lowering a severity. Consider as a thought experiment, a bug that results in loss of funds, only if the first byte of an address is 0xFF. Would that condition reduce severity to Med? Absolutely not, because we realize that over time and considering enough users, it is extremely likely there will be affected users. It is incorrect to look at the single-victim level when the bug is affecting all potential victims.\n\n> it's constrained as it only applies to the initial bond.\n\nThis argument could also be used if the initial bond is $100000000. Would that make such billion dollar exploits Med? Just to show that saying it is constrained does not cap severities, what matters it the potential concrete impact.\nThere is no respectable judge on the planet that would rule impact of loss of 0.08 ETH = $240 as lower than high.\n\n\n\n**Evert0x**\n\n> The rationale above can be said about any smart contract exploit, from the perspective of the smart contract, everything is functioning as normal. It's not a design recommendation, because Optimism did not limit interaction with the contracts to only EOAs, and any usage without using a private mempool (extremely likely) is vulnerable.\n\nFrom the perspective of the protocol's mechanisms it doesn't matter if Alice or Bob executes this transaction. The functionality works as intended as the person executing the transaction will receive the bond. Of course this can't be said about every exploit.  \n\n\n\n**nevillehuang**\n\nBonds should belong to the person(s) creating the games that is signing the transaction to create a claim. However, given the permisionless nature of transaction execution for smart wallets as [seen here](https://github.com/safe-global/safe-smart-account/blob/5feb0d08f59cfbb44918be1ed5889d9bb634562a/contracts/Safe.sol#L108-L122), someone can fron-run and copy the transaction, bypass the transaction checks and act as the `tx.origin` of that initial proposal of the FDG, receiving that initial bond after resolution. I don't think it should be high severity given the DelayedWETH safety mechanism is not bypassed, so I believe medium severity is appropriate here.\n\n**darkbit0**\n\nHey @nevillehuang, Clearly the issue exists in the FaultDisputeGame [contract](https://github.com/sherlock-audit/2024-02-optimism-2024/blob/f216b0d3ad08c1a0ead557ea74691aaefd5fd489/optimism/packages/contracts-bedrock/src/dispute/FaultDisputeGame.sol#L559). `tx.origin` has been used in FaultDisputeGame which its issues were out of scope (unless it bypasses the air-gap). Just because one fix is involving changing the Factory's code doesn't mean the issue exists in out of FaultDisputeGame's code.\n\nAlso if any smart wallet allows attackers to front-run its txs,  then those smart wallets have vulnerability and the real root cause of this issue is in those smart wallet's code which weren't in the scope of this contest. Users who uses those smart wallets accepted their risk and they also have options to protect their txs and avoid front-runners (by using private mempools or using Guard feature of smart wallet or using smart wallet without front-run issue). There were a lot of similar situations in that past contests that 3rd party systems bugs could effect the protocol and there were fixes for those issues in in-scope Contracts (adding more checks or ...) but those issues were considered as OOS.\n\n**trust1995**\n\n@darkbit0 \nIt is considered very poor contest etiquette to repeat arguments already discussed. It is showing lack of respect for Watsons and judge's time, and in my opinion should even be punished.\n\n > Hey @nevillehuang, Clearly the issue exists in the FaultDisputeGame [contract](https://github.com/sherlock-audit/2024-02-optimism-2024/blob/f216b0d3ad08c1a0ead557ea74691aaefd5fd489/optimism/packages/contracts-bedrock/src/dispute/FaultDisputeGame.sol#L559). tx.origin has been used in FaultDisputeGame which its issues were out of scope (unless it bypasses the air-gap). Just because one fix is involving changing the Factory's code doesn't mean the issue exists in out of FaultDisputeGame's code.\n\nWas argued above, and neville's response was:\n> Agree that this issue is valid, given the root cause can be seen as stemming from the factory contract. Additionally, there is no mention whether only an EOA is allowed to interact with the contracts. Based on agreed upon scope and line drawn, I believe medium severity to be appropriate since no safety mechanisms (DelyayedWETH) is bypassed.\n\nThen:\n\n> Also if any smart wallet allows attackers to front-run its txs, then those smart wallets have vulnerability and the real root cause of this issue is in those smart wallet's code which weren't in the scope of this contest. Users who uses those smart wallets accepted their risk and they also have options to protect their txs and avoid front-runners (by using private mempools or using Guard feature of smart wallet or using smart wallet without front-run issue)\n\nThis was already explored in depth before your attempt to re-open the discussion.\n\n>> That's a wildly incorrect statement. The design of smart wallets is exactly with account abstraction in mind - The TX contents, gas , calldata etc are all signed by the multisig and then anyone can transmit the TX to the blockchain. A TX should be perfectly secure regardless of who is initiating the smart wallet execution call.\n\n> The contestant is referring to the optional guard feature, which can perform any type of filtering at the discretion of the multisig. The only two multisigs I've checked, the [Chainlink MS](https://etherscan.io/address/0x4a87ecE3eFffCb012fbE491AA028032e07B6F6cF) and the [Optimism MS](https://etherscan.io/address/0x5a0Aae59D09fccBdDb6C6CcEB07B7279367C3d2A#readProxyContract), don't use any guards. It is, broadly speaking, a mostly unused feature used to perform arbitrary custom validation, and has no relevance to the submission.\n\n\n**54710adk341**\n\n> I think the implied contract is relatively clear, the user who creates the game is the `tx.origin` and not the `msg.sender`. Smart contract wallets weren't an intended user of the contracts. Either way impact is relatively limited (smallest bond size is at the initialization level). I think it's a pretty clear footgun though and should be fixed to prevent issues down the line.\n\nThis sums it up pretty well, this is a clear footgun, hence this is a valid Low. User errors are not Medium under Sherlock rules.\n\n**Evert0x**\n\nThis comment reflects my current stance on this issue https://github.com/sherlock-audit/2024-02-optimism-2024-judging/issues/194#issuecomment-2094911840\n\n\n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [trust1995](https://github.com/sherlock-audit/2024-02-optimism-2024-judging/issues/194/#issuecomment-2075476704): accepted\n\n**MightyFox3**\n\nhttps://github.com/sherlock-audit/2024-02-optimism-2024-judging/issues/15 \n\n@Evert0x @nevillehuang \n\n**trust1995**\n\n> #15\n> \n> @Evert0x @nevillehuang\n\n???\nHas nothing to do with this submission.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/205",
  "Code": [
    {
      "filename": "contracts/Safe.sol",
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport {Guard} from \"./base/GuardManager.sol\";\nimport {ModuleManager} from \"./base/ModuleManager.sol\";\nimport {OwnerManager} from \"./base/OwnerManager.sol\";\nimport {FallbackManager} from \"./base/FallbackManager.sol\";\nimport {NativeCurrencyPaymentFallback} from \"./common/NativeCurrencyPaymentFallback.sol\";\nimport {Singleton} from \"./common/Singleton.sol\";\nimport {SignatureDecoder} from \"./common/SignatureDecoder.sol\";\nimport {SecuredTokenTransfer} from \"./common/SecuredTokenTransfer.sol\";\nimport {StorageAccessible} from \"./common/StorageAccessible.sol\";\nimport {Enum} from \"./libraries/Enum.sol\";\nimport {ISignatureValidator, ISignatureValidatorConstants} from \"./interfaces/ISignatureValidator.sol\";\nimport {SafeMath} from \"./external/SafeMath.sol\";\nimport {ISafe} from \"./interfaces/ISafe.sol\";\n\n/**\n * @title Safe - A multisignature wallet with support for confirmations using signed messages based on EIP-712.\n * @dev Most important concepts:\n *      - Threshold: Number of required confirmations for a Safe transaction.\n *      - Owners: List of addresses that control the Safe. They are the only ones that can add/remove owners, change the threshold and\n *        approve transactions. Managed in `OwnerManager`.\n *      - Transaction Hash: Hash of a transaction is calculated using the EIP-712 typed structured data hashing scheme.\n *      - Nonce: Each transaction should have a different nonce to prevent replay attacks.\n *      - Signature: A valid signature of an owner of the Safe for a transaction hash.\n *      - Guard: Guard is a contract that can execute pre- and post- transaction checks. Managed in `GuardManager`.\n *      - Modules: Modules are contracts that can be used to extend the write functionality of a Safe. Managed in `ModuleManager`.\n *      - Fallback: Fallback handler is a contract that can provide additional read-only functional for Safe. Managed in `FallbackManager`.\n *      Note: This version of the implementation contract doesn't emit events for the sake of gas efficiency and therefore requires a tracing node for indexing/\n *      For the events-based implementation see `SafeL2.sol`.\n * @author Stefan George - @Georgi87\n * @author Richard Meissner - @rmeissner\n */\ncontract Safe is\n    Singleton,\n    NativeCurrencyPaymentFallback,\n    ModuleManager,\n    OwnerManager,\n    SignatureDecoder,\n    SecuredTokenTransfer,\n    ISignatureValidatorConstants,\n    FallbackManager,\n    StorageAccessible,\n    ISafe\n{\n    using SafeMath for uint256;\n\n    string public constant override VERSION = \"1.4.1\";\n\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // keccak256(\n    //     \"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 private constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\n\n    uint256 public override nonce;\n    bytes32 private _deprecatedDomainSeparator;\n    // Mapping to keep track of all message hashes that have been approved by ALL REQUIRED owners\n    mapping(bytes32 => uint256) public override signedMessages;\n    // Mapping to keep track of all hashes (message or transaction) that have been approved by ANY owners\n    mapping(address => mapping(bytes32 => uint256)) public override approvedHashes;\n\n    // This constructor ensures that this contract can only be used as a singleton for Proxy contracts\n    constructor() {\n        /**\n         * By setting the threshold it is not possible to call setup anymore,\n         * so we create a Safe with 0 owners and threshold 1.\n         * This is an unusable Safe, perfect for the singleton\n         */\n        threshold = 1;\n    }\n\n    // @inheritdoc ISafe\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    ) external override {\n        // setupOwners checks if the Threshold is already set, therefore preventing that this method is called twice\n        setupOwners(_owners, _threshold);\n        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\n        // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\n        setupModules(to, data);\n\n        if (payment > 0) {\n            // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)\n            // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment\n            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\n        }\n        emit SafeSetup(msg.sender, _owners, _threshold, to, fallbackHandler);\n    }\n\n    // @inheritdoc ISafe\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) public payable virtual override returns (bool success) {\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            txHash = getTransactionHash( // Transaction info\n                to,\n                value,\n                data,\n                operation,\n                safeTxGas,\n                // Payment info\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                // Signature info\n                // We use the post-increment here, so the current nonce value is used and incremented afterwards.\n                nonce++\n            );\n            checkSignatures(txHash, signatures);\n        }\n        address guard = getGuard();\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkTransaction(\n                    // Transaction info\n                    to,\n                    value,\n                    data,\n                    operation,\n                    safeTxGas,\n                    // Payment info\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    // Signature info\n                    signatures,\n                    msg.sender\n                );\n            }\n        }\n\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        if (gasleft() < ((safeTxGas * 64) / 63).max(safeTxGas + 2500) + 500) revertWithError(\"GS010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            uint256 gasUsed = gasleft();\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than safeTxGas)\n            // We only subtract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than safeTxGas\n            success = execute(to, value, data, operation, gasPrice == 0 ? (gasleft() - 2500) : safeTxGas);\n            gasUsed = gasUsed.sub(gasleft());\n            // If no safeTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            if (!success && safeTxGas == 0 && gasPrice == 0) revertWithError(\"GS013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            if (gasPrice > 0) {\n                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\n            }\n            if (success) emit ExecutionSuccess(txHash, payment);\n            else emit ExecutionFailure(txHash, payment);\n        }\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkAfterExecution(txHash, success);\n            }\n        }\n    }\n\n    /**\n     * @notice Handles the payment for a Safe transaction.\n     * @param gasUsed Gas used by the Safe transaction.\n     * @param baseGas Gas costs that are independent of the transaction execution (e.g. base transaction fee, signature check, payment of the refund).\n     * @param gasPrice Gas price that should be used for the payment calculation.\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\n     * @return payment The amount of payment made in the specified token.\n     */\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver\n    ) private returns (uint256 payment) {\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For native tokens, we will only adjust the gas price to not be higher than the actually used gas price\n            payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool refundSuccess, ) = receiver.call{value: payment}(\"\");\n            if (!refundSuccess) revertWithError(\"GS011\");\n        } else {\n            payment = gasUsed.add(baseGas).mul(gasPrice);\n            if (!transferToken(gasToken, receiver, payment)) revertWithError(\"GS012\");\n        }\n    }\n\n    /**\n     * @notice Checks whether the contract signature is valid. Reverts otherwise.\n     * @dev This is extracted to a separate function for better compatibility with Certora's prover.\n     *      More info here: https://github.com/safe-global/safe-smart-account/pull/661\n     * @param owner Address of the owner used to sign the message\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param signatures Signature data that should be verified.\n     * @param offset Offset to the start of the contract signature in the signatures byte array\n     */\n    function checkContractSignature(address owner, bytes32 dataHash, bytes memory signatures, uint256 offset) internal view {\n        // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n        if (offset.add(32) > signatures.length) revertWithError(\"GS022\");\n\n        // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n        uint256 contractSignatureLen;\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            contractSignatureLen := mload(add(add(signatures, offset), 0x20))\n        }\n        /* solhint-enable no-inline-assembly */\n        if (offset.add(32).add(contractSignatureLen) > signatures.length) revertWithError(\"GS023\");\n\n        // Check signature\n        bytes memory contractSignature;\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n            contractSignature := add(add(signatures, offset), 0x20)\n        }\n        /* solhint-enable no-inline-assembly */\n\n        if (ISignatureValidator(owner).isValidSignature(dataHash, contractSignature) != EIP1271_MAGIC_VALUE) revertWithError(\"GS024\");\n    }\n\n    // @inheritdoc ISafe\n    function checkSignatures(bytes32 dataHash, bytes memory signatures) public view override {\n        checkSignatures(dataHash, \"\", signatures);\n    }\n\n    // @inheritdoc ISafe\n    function checkSignatures(bytes32 dataHash, bytes memory /* IGNORED */, bytes memory signatures) public view override {\n        // Load threshold to avoid multiple storage loads\n        uint256 _threshold = threshold;\n        // Check that a threshold is set\n        if (_threshold == 0) revertWithError(\"GS001\");\n        checkNSignatures(msg.sender, dataHash, signatures, _threshold);\n    }\n\n    // @inheritdoc ISafe\n    function checkNSignatures(\n        address executor,\n        bytes32 dataHash,\n        bytes memory signatures,\n        uint256 requiredSignatures\n    ) public view override {\n        // Check that the provided signature data is not too short\n        if (signatures.length < requiredSignatures.mul(65)) revertWithError(\"GS020\");\n        // There cannot be an owner with address 0.\n        address lastOwner = address(0);\n        address currentOwner;\n        uint256 v; // Implicit conversion from uint8 to uint256 will be done for v received from signatureSplit(...).\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n        for (i = 0; i < requiredSignatures; i++) {\n            (v, r, s) = signatureSplit(signatures, i);\n            if (v == 0) {\n                // If v is 0 then it is a contract signature\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n\n                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                if (uint256(s) < requiredSignatures.mul(65)) revertWithError(\"GS021\");\n\n                // The contract signature check is extracted to a separate function for better compatibility with formal verification\n                // A quote from the Certora team:\n                // \"The assembly code broke the pointer analysis, which switched the prover in failsafe mode, where it is (a) much slower and (b) computes different hashes than in the normal mode.\"\n                // More info here: https://github.com/safe-global/safe-smart-account/pull/661\n                checkContractSignature(currentOwner, dataHash, signatures, uint256(s));\n            } else if (v == 1) {\n                // If v is 1 then it is an approved hash\n                // When handling approved hashes the address of the approver is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n                // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction\n                if (executor != currentOwner && approvedHashes[currentOwner][dataHash] == 0) revertWithError(\"GS025\");\n            } else if (v > 30) {\n                // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n                currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), uint8(v - 4), r, s);\n            } else {\n                // Default is the ecrecover flow with the provided data hash\n                // Use ecrecover with the messageHash for EOA signatures\n                currentOwner = ecrecover(dataHash, uint8(v), r, s);\n            }\n            if (currentOwner <= lastOwner || owners[currentOwner] == address(0) || currentOwner == SENTINEL_OWNERS)\n                revertWithError(\"GS026\");\n            lastOwner = currentOwner;\n        }\n    }\n\n    // @inheritdoc ISafe\n    function approveHash(bytes32 hashToApprove) external override {\n        if (owners[msg.sender] == address(0)) revertWithError(\"GS030\");\n        approvedHashes[msg.sender][hashToApprove] = 1;\n        emit ApproveHash(hashToApprove, msg.sender);\n    }\n\n    // @inheritdoc ISafe\n    function domainSeparator() public view override returns (bytes32) {\n        uint256 chainId;\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            chainId := chainid()\n        }\n        /* solhint-enable no-inline-assembly */\n\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, chainId, this));\n    }\n\n    /**\n     * @notice Returns the pre-image of the transaction hash (see getTransactionHash).\n     * @param to Destination address.\n     * @param value Ether value.\n     * @param data Data payload.\n     * @param operation Operation type.\n     * @param safeTxGas Gas that should be used for the safe transaction.\n     * @param baseGas Gas costs for that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n     * @param gasPrice Maximum gas price that should be used for this transaction.\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n     * @param _nonce Transaction nonce.\n     * @return Transaction hash bytes.\n     */\n    function encodeTransactionData(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) private view returns (bytes memory) {\n        bytes32 safeTxHash = keccak256(\n            abi.encode(\n                SAFE_TX_TYPEHASH,\n                to,\n                value,\n                keccak256(data),\n                operation,\n                safeTxGas,\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                _nonce\n            )\n        );\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\n    }\n\n    // @inheritdoc ISafe\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) public view override returns (bytes32) {\n        return keccak256(encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce));\n    }\n}"
    },
    {
      "filename": "contracts/Safe.sol",
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport {Guard} from \"./base/GuardManager.sol\";\nimport {ModuleManager} from \"./base/ModuleManager.sol\";\nimport {OwnerManager} from \"./base/OwnerManager.sol\";\nimport {FallbackManager} from \"./base/FallbackManager.sol\";\nimport {NativeCurrencyPaymentFallback} from \"./common/NativeCurrencyPaymentFallback.sol\";\nimport {Singleton} from \"./common/Singleton.sol\";\nimport {SignatureDecoder} from \"./common/SignatureDecoder.sol\";\nimport {SecuredTokenTransfer} from \"./common/SecuredTokenTransfer.sol\";\nimport {StorageAccessible} from \"./common/StorageAccessible.sol\";\nimport {Enum} from \"./libraries/Enum.sol\";\nimport {ISignatureValidator, ISignatureValidatorConstants} from \"./interfaces/ISignatureValidator.sol\";\nimport {SafeMath} from \"./external/SafeMath.sol\";\nimport {ISafe} from \"./interfaces/ISafe.sol\";\n\n/**\n * @title Safe - A multisignature wallet with support for confirmations using signed messages based on EIP-712.\n * @dev Most important concepts:\n *      - Threshold: Number of required confirmations for a Safe transaction.\n *      - Owners: List of addresses that control the Safe. They are the only ones that can add/remove owners, change the threshold and\n *        approve transactions. Managed in `OwnerManager`.\n *      - Transaction Hash: Hash of a transaction is calculated using the EIP-712 typed structured data hashing scheme.\n *      - Nonce: Each transaction should have a different nonce to prevent replay attacks.\n *      - Signature: A valid signature of an owner of the Safe for a transaction hash.\n *      - Guard: Guard is a contract that can execute pre- and post- transaction checks. Managed in `GuardManager`.\n *      - Modules: Modules are contracts that can be used to extend the write functionality of a Safe. Managed in `ModuleManager`.\n *      - Fallback: Fallback handler is a contract that can provide additional read-only functional for Safe. Managed in `FallbackManager`.\n *      Note: This version of the implementation contract doesn't emit events for the sake of gas efficiency and therefore requires a tracing node for indexing/\n *      For the events-based implementation see `SafeL2.sol`.\n * @author Stefan George - @Georgi87\n * @author Richard Meissner - @rmeissner\n */\ncontract Safe is\n    Singleton,\n    NativeCurrencyPaymentFallback,\n    ModuleManager,\n    OwnerManager,\n    SignatureDecoder,\n    SecuredTokenTransfer,\n    ISignatureValidatorConstants,\n    FallbackManager,\n    StorageAccessible,\n    ISafe\n{\n    using SafeMath for uint256;\n\n    string public constant override VERSION = \"1.4.1\";\n\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // keccak256(\n    //     \"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 private constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\n\n    uint256 public override nonce;\n    bytes32 private _deprecatedDomainSeparator;\n    // Mapping to keep track of all message hashes that have been approved by ALL REQUIRED owners\n    mapping(bytes32 => uint256) public override signedMessages;\n    // Mapping to keep track of all hashes (message or transaction) that have been approved by ANY owners\n    mapping(address => mapping(bytes32 => uint256)) public override approvedHashes;\n\n    // This constructor ensures that this contract can only be used as a singleton for Proxy contracts\n    constructor() {\n        /**\n         * By setting the threshold it is not possible to call setup anymore,\n         * so we create a Safe with 0 owners and threshold 1.\n         * This is an unusable Safe, perfect for the singleton\n         */\n        threshold = 1;\n    }\n\n    /**\n     * @inheritdoc ISafe\n     */\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    ) external override {\n        // setupOwners checks if the Threshold is already set, therefore preventing that this method is called twice\n        setupOwners(_owners, _threshold);\n        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\n        // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\n        setupModules(to, data);\n\n        if (payment > 0) {\n            // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)\n            // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment\n            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\n        }\n        emit SafeSetup(msg.sender, _owners, _threshold, to, fallbackHandler);\n    }\n\n    /**\n     * @inheritdoc ISafe\n     */\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) public payable virtual override returns (bool success) {\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            txHash = getTransactionHash( // Transaction info\n                to,\n                value,\n                data,\n                operation,\n                safeTxGas,\n                // Payment info\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                // Signature info\n                // We use the post-increment here, so the current nonce value is used and incremented afterwards.\n                nonce++\n            );\n            checkSignatures(txHash, signatures);\n        }\n        address guard = getGuard();\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkTransaction(\n                    // Transaction info\n                    to,\n                    value,\n                    data,\n                    operation,\n                    safeTxGas,\n                    // Payment info\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    // Signature info\n                    signatures,\n                    msg.sender\n                );\n            }\n        }\n\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        if (gasleft() < ((safeTxGas * 64) / 63).max(safeTxGas + 2500) + 500) revertWithError(\"GS010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            uint256 gasUsed = gasleft();\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than safeTxGas)\n            // We only subtract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than safeTxGas\n            success = execute(to, value, data, operation, gasPrice == 0 ? (gasleft() - 2500) : safeTxGas);\n            gasUsed = gasUsed.sub(gasleft());\n            // If no safeTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            if (!success && safeTxGas == 0 && gasPrice == 0) revertWithError(\"GS013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            if (gasPrice > 0) {\n                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\n            }\n            if (success) emit ExecutionSuccess(txHash, payment);\n            else emit ExecutionFailure(txHash, payment);\n        }\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkAfterExecution(txHash, success);\n            }\n        }\n    }\n\n    /**\n     * @notice Handles the payment for a Safe transaction.\n     * @param gasUsed Gas used by the Safe transaction.\n     * @param baseGas Gas costs that are independent of the transaction execution (e.g. base transaction fee, signature check, payment of the refund).\n     * @param gasPrice Gas price that should be used for the payment calculation.\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\n     * @return payment The amount of payment made in the specified token.\n     */\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver\n    ) private returns (uint256 payment) {\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For native tokens, we will only adjust the gas price to not be higher than the actually used gas price\n            payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool refundSuccess, ) = receiver.call{value: payment}(\"\");\n            if (!refundSuccess) revertWithError(\"GS011\");\n        } else {\n            payment = gasUsed.add(baseGas).mul(gasPrice);\n            if (!transferToken(gasToken, receiver, payment)) revertWithError(\"GS012\");\n        }\n    }\n\n    /**\n     * @notice Checks whether the contract signature is valid. Reverts otherwise.\n     * @dev This is extracted to a separate function for better compatibility with Certora's prover.\n     *      More info here: https://github.com/safe-global/safe-smart-account/pull/661\n     * @param owner Address of the owner used to sign the message\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param signatures Signature data that should be verified.\n     * @param offset Offset to the start of the contract signature in the signatures byte array\n     */\n    function checkContractSignature(address owner, bytes32 dataHash, bytes memory signatures, uint256 offset) internal view {\n        // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n        if (offset.add(32) > signatures.length) revertWithError(\"GS022\");\n\n        // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n        uint256 contractSignatureLen;\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            contractSignatureLen := mload(add(add(signatures, offset), 0x20))\n        }\n        /* solhint-enable no-inline-assembly */\n        if (offset.add(32).add(contractSignatureLen) > signatures.length) revertWithError(\"GS023\");\n\n        // Check signature\n        bytes memory contractSignature;\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n            contractSignature := add(add(signatures, offset), 0x20)\n        }\n        /* solhint-enable no-inline-assembly */\n\n        if (ISignatureValidator(owner).isValidSignature(dataHash, contractSignature) != EIP1271_MAGIC_VALUE) revertWithError(\"GS024\");\n    }\n\n    /**\n     * @inheritdoc ISafe\n     */\n    function checkSignatures(bytes32 dataHash, bytes memory signatures) public view override {\n        // Load threshold to avoid multiple storage loads\n        uint256 _threshold = threshold;\n        // Check that a threshold is set\n        if (_threshold == 0) revertWithError(\"GS001\");\n        checkNSignatures(msg.sender, dataHash, signatures, _threshold);\n    }\n\n    /**\n     * @inheritdoc ISafe\n     */\n    function checkNSignatures(\n        address executor,\n        bytes32 dataHash,\n        bytes memory signatures,\n        uint256 requiredSignatures\n    ) public view override {\n        // Check that the provided signature data is not too short\n        if (signatures.length < requiredSignatures.mul(65)) revertWithError(\"GS020\");\n        // There cannot be an owner with address 0.\n        address lastOwner = address(0);\n        address currentOwner;\n        uint256 v; // Implicit conversion from uint8 to uint256 will be done for v received from signatureSplit(...).\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n        for (i = 0; i < requiredSignatures; i++) {\n            (v, r, s) = signatureSplit(signatures, i);\n            if (v == 0) {\n                // If v is 0 then it is a contract signature\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n\n                // Check that signature"
    }
  ]
}