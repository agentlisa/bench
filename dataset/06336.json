{
  "Title": "[M-01] LibHelpers.piecewiseLinear will revert when the value is less than the first element of the array",
  "Content": "\n<https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/transmuter/facets/Redeemer.sol#L156-L157> <br><https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/transmuter/libraries/LibSetters.sol#L230-L240> <br><https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/transmuter/libraries/LibHelpers.sol#L77-L80>\n\n`LibHelpers.piecewiseLinear` reverts when the value is less than the first element of the array. This method is used in Redeemer contract and if the collateral ratio is below the first element of xRedemptionCurve, the redepmtion will revert.\n\n### Proof of Concept\n\nIn `Redeemer._quoteRedemptionCurve`, a penalty factor is applied when the protocol is under-collateralized using `LibHelpers.piecewiseLinear`.\n\nRedeemer.sol#L156-L157\n\n```solidity\n        uint64[] memory xRedemptionCurveMem = ts.xRedemptionCurve;\n        penaltyFactor = uint64(LibHelpers.piecewiseLinear(collatRatio, xRedemptionCurveMem, yRedemptionCurveMem));\n```\n\n`xRedemptionCurveMem` is strictly increasing and upper bounded by `BASE_9`, and there's no more limitations.\n\nLibSetters.sol\n\n```solidity\n230        (action == ActionType.Redeem && (xFee[n - 1] > BASE_9 || yFee[n - 1] < 0 || yFee[n - 1] > int256(BASE_9)))\n           \n233        for (uint256 i = 0; i < n - 1; ++i) {\n234            if (\n           \n240                (action == ActionType.Redeem && (xFee[i] >= xFee[i + 1] || yFee[i] < 0 || yFee[i] > int256(BASE_9)))\n```\n\nSo `collatRatio` can be less than the first element of `xRedemptionCurveMem`. In that case, `LibHelpers.findLowerBound` will return 0 and `LibHelpers.piecewiseLinear` will revert on the following line.\n\nLibHelpers.sol#L77-L80\n\n```solidity\n    return\n        yArray[indexLowerBound] +\n        ((yArray[indexLowerBound + 1] - yArray[indexLowerBound]) * int64(x - xArray[indexLowerBound])) /\n        int64(xArray[indexLowerBound + 1] - xArray[indexLowerBound]);\n```\n\n`Redeemer._redeem` calls `_quoteRedemptionCurve`, so the redemption will be blocked in this case.\n\n### Recommended Mitigation Steps\n\nWe can add the following line to mitigate this issue.\n\n```solidity\n    if (indexLowerBound == 0 && x < xArray[0]) return yArray[0];\n```\n\n**[Picodes (Angle) confirmed and commented](https://github.com/code-423n4/2023-06-angle-findings/issues/40#issuecomment-1628608115):**\n > Indeed we are assuming throughout the test base that the first value is 0 but the check is missing in the code so there this could happen. It's kind of conditional to a misconfiguration though. Leaving it up to the judge.\n\n**[hansfriese (Judge) commented](https://github.com/code-423n4/2023-06-angle-findings/issues/40#issuecomment-1628647579):**\n > @Picodes - Medium is appropriate because it's likely to happen with the current configuration.\n\n**[Angle mitigated](https://github.com/code-423n4/2023-07-angle-mitigation/blob/main/README.md#mitigations-to-be-reviewed):**\n> PR: https://github.com/AngleProtocol/angle-transmuter/commit/5f7635cdab52b75416309d45f8cd253609c705ff<br>\n> Add a handler for this edge case.\n\n**Status:** Mitigation confirmed. Full details in reports from [Lambda](https://github.com/code-423n4/2023-07-angle-mitigation-findings/issues/9), [auditor0517](https://github.com/code-423n4/2023-07-angle-mitigation-findings/issues/25), and [Jeiwan](https://github.com/code-423n4/2023-07-angle-mitigation-findings/issues/16).\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-01-dev-test-repo",
  "Code": [
    {
      "filename": "contracts/transmuter/facets/Redeemer.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.19;\n\nimport { IERC20 } from \"oz/token/ERC20/IERC20.sol\";\nimport { SafeCast } from \"oz/utils/math/SafeCast.sol\";\nimport { SafeERC20 } from \"oz/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"oz/utils/math/Math.sol\";\n\nimport { IAgToken } from \"interfaces/IAgToken.sol\";\nimport { IRedeemer } from \"interfaces/IRedeemer.sol\";\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { LibHelpers } from \"../libraries/LibHelpers.sol\";\nimport { LibGetters } from \"../libraries/LibGetters.sol\";\nimport { LibManager } from \"../libraries/LibManager.sol\";\nimport { LibStorage as s } from \"../libraries/LibStorage.sol\";\nimport { LibWhitelist } from \"../libraries/LibWhitelist.sol\";\n\nimport \"../../utils/Constants.sol\";\nimport \"../../utils/Errors.sol\";\nimport \"../Storage.sol\";\n\n/// @title Redeemer\n/// @author Angle Labs, Inc.\ncontract Redeemer is IRedeemer {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n    using SafeCast for uint256;\n\n    event Redeemed(\n        uint256 amount,\n        address[] tokens,\n        uint256[] amounts,\n        address[] forfeitTokens,\n        address indexed from,\n        address indexed to\n    );\n    event NormalizerUpdated(uint256 newNormalizerValue);\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                   EXTERNAL ACTIONS                                                 \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRedeemer\n    /// @dev The `minAmountOuts` list must reflect or be longer than the amount of `tokens` returned\n    /// @dev In normal conditions, the amount of tokens outputted by this function should be the amount\n    /// of collateral assets supported by the system, following their order in the `collateralList`.\n    /// @dev If one collateral has its liquidity managed through strategies, then it's possible that this asset\n    /// has sub-collaterals with it. In this situation, these sub-collaterals may be sent during the redemption\n    /// process and the `minAmountOuts` will be bigger than the `collateralList` length. If there are 3 collateral\n    /// assets and the 2nd collateral asset in the list (at index 1) consists of 3 sub-collaterals, then the ordering\n    /// of the token list will be as follows:\n    /// `[collat 1, sub-collat 1 of collat 2, sub-collat 2 of collat 2, sub-collat 3 of collat 2, collat 3]`\n    /// @dev The list of tokens outputted (and hence the minimum length of the `minAmountOuts` list) can be obtained\n    /// by calling the `quoteRedemptionCurve` function\n    /// @dev Tokens requiring a whitelist must be forfeited if the redemption is to an address that is not in the\n    /// whitelist, otherwise this function reverts\n    /// @dev No approval is needed before calling this function\n    function redeem(\n        uint256 amount,\n        address receiver,\n        uint256 deadline,\n        uint256[] memory minAmountOuts\n    ) external returns (address[] memory tokens, uint256[] memory amounts) {\n        return _redeem(amount, receiver, deadline, minAmountOuts, new address[](0));\n    }\n\n    /// @inheritdoc IRedeemer\n    /// @dev Beware that if a token is given in the `forfeitTokens` list, the redemption will not try to send token\n    /// even if it has enough immediately available to send the amount\n    function redeemWithForfeit(\n        uint256 amount,\n        address receiver,\n        uint256 deadline,\n        uint256[] memory minAmountOuts,\n        address[] memory forfeitTokens\n    ) external returns (address[] memory tokens, uint256[] memory amounts) {\n        return _redeem(amount, receiver, deadline, minAmountOuts, forfeitTokens);\n    }\n\n    /// @inheritdoc IRedeemer\n    /// @dev This function may be called by trusted addresses: these could be for instance savings contract\n    /// minting stablecoins when they notice a profit\n    function updateNormalizer(uint256 amount, bool increase) external returns (uint256) {\n        if (!LibDiamond.isGovernor(msg.sender) && s.transmuterStorage().isTrusted[msg.sender] == 0) revert NotTrusted();\n        return _updateNormalizer(amount, increase);\n    }\n\n    /// @inheritdoc IRedeemer\n    function quoteRedemptionCurve(\n        uint256 amount\n    ) external view returns (address[] memory tokens, uint256[] memory amounts) {\n        (tokens, amounts, ) = _quoteRedemptionCurve(amount);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                   INTERNAL HELPERS                                                 \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Internal function of the `redeem` function in the `Redeemer` contract\n    function _redeem(\n        uint256 amount,\n        address to,\n        uint256 deadline,\n        uint256[] memory minAmountOuts,\n        address[] memory forfeitTokens\n    ) internal returns (address[] memory tokens, uint256[] memory amounts) {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        if (ts.isRedemptionLive == 0) revert Paused();\n        if (block.timestamp > deadline) revert TooLate();\n        uint256[] memory subCollateralsTracker;\n        (tokens, amounts, subCollateralsTracker) = _quoteRedemptionCurve(amount);\n        // Updating the normalizer enables to simultaneously and proportionally reduce the amount\n        // of stablecoins issued from each collateral without having to loop through each of them\n        _updateNormalizer(amount, false);\n\n        IAgToken(ts.agToken).burnSelf(amount, msg.sender);\n\n        address[] memory collateralListMem = ts.collateralList;\n        uint256 indexCollateral;\n        for (uint256 i; i < amounts.length; ++i) {\n            if (amounts[i] < minAmountOuts[i]) revert TooSmallAmountOut();\n            // If a token is in the `forfeitTokens` list, then it is not sent as part of the redemption process\n            if (amounts[i] > 0 && LibHelpers.checkList(tokens[i], forfeitTokens) < 0) {\n                Collateral storage collatInfo = ts.collaterals[collateralListMem[indexCollateral]];\n                if (collatInfo.onlyWhitelisted > 0 && !LibWhitelist.checkWhitelist(collatInfo.whitelistData, to))\n                    revert NotWhitelisted();\n                if (collatInfo.isManaged > 0)\n                    LibManager.release(tokens[i], to, amounts[i], collatInfo.managerData.config);\n                else IERC20(tokens[i]).safeTransfer(to, amounts[i]);\n            }\n            if (subCollateralsTracker[indexCollateral] - 1 <= i) ++indexCollateral;\n        }\n        emit Redeemed(amount, tokens, amounts, forfeitTokens, msg.sender, to);\n    }\n\n    /// @dev This function reverts if `stablecoinsIssued==0`, which is expected behavior as there is nothing to redeem\n    /// anyway in this case, or if the `amountBurnt` is greater than `stablecoinsIssued`\n    function _quoteRedemptionCurve(\n        uint256 amountBurnt\n    )\n        internal\n        view\n        returns (address[] memory tokens, uint256[] memory balances, uint256[] memory subCollateralsTracker)\n    {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        uint64 collatRatio;\n        uint256 stablecoinsIssued;\n        (collatRatio, stablecoinsIssued, tokens, balances, subCollateralsTracker) = LibGetters.getCollateralRatio();\n        if (amountBurnt > stablecoinsIssued) revert TooBigAmountIn();\n        int64[] memory yRedemptionCurveMem = ts.yRedemptionCurve;\n        uint64 penaltyFactor;\n        // If the protocol is under-collateralized, a penalty factor is applied to the returned amount of each asset\n        if (collatRatio < BASE_9) {\n            uint64[] memory xRedemptionCurveMem = ts.xRedemptionCurve;\n            penaltyFactor = uint64(LibHelpers.piecewiseLinear(collatRatio, xRedemptionCurveMem, yRedemptionCurveMem));\n        }\n\n        uint256 balancesLength = balances.length;\n        for (uint256 i; i < balancesLength; ++i) {\n            // The amount given for each token in reserves does not depend on the price of the tokens in reserve:\n            // it is a proportion of the balance for each token computed as the ratio between the stablecoins\n            // burnt relative to the amount of stablecoins issued.\n            // If the protocol is over-collateralized, the amount of each token given is inversely proportional\n            // to the collateral ratio.\n            balances[i] = collatRatio >= BASE_9\n                ? (amountBurnt * balances[i] * (uint64(yRedemptionCurveMem[yRedemptionCurveMem.length - 1]))) /\n                    (stablecoinsIssued * collatRatio)\n                : (amountBurnt * balances[i] * penaltyFactor) / (stablecoinsIssued * BASE_9);\n        }\n    }\n\n    /// @notice Updates the `normalizer` variable used to track stablecoins issued from each asset and globally\n    function _updateNormalizer(uint256 amount, bool increase) internal returns (uint256 newNormalizerValue) {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        uint256 _normalizer = ts.normalizer;\n        uint256 _normalizedStables = ts.normalizedStables;\n        // In case of an increase, the update formula used is the simplified version of the formula below:\n        /*\n            _normalizer * (BASE_27 + BASE_27 * amount / stablecoinsIssued) / BASE_27\n             = _normalizer + (_normalizer * BASE_27 * amount * (BASE_27 / (_normalizedStables * normalizer))) / BASE_27\n             = _normalizer + BASE_27 * amount / _normalizedStables\n        */\n        if (increase) {\n            newNormalizerValue = _normalizer + (amount * BASE_27) / _normalizedStables;\n        } else {\n            newNormalizerValue = _normalizer - (amount * BASE_27) / _normalizedStables;\n        }\n        // If the `normalizer` gets too small or too big, it must be renormalized to later avoid the propagation of\n        // rounding errors, as well as overflows. In this case, the function has to iterate through all the\n        // supported collateral assets\n        if (newNormalizerValue <= BASE_18 || newNormalizerValue >= BASE_36) {\n            address[] memory collateralListMem = ts.collateralList;\n            uint256 collateralListLength = collateralListMem.length;\n            // For each asset, we store the actual amount of stablecoins issued based on the `newNormalizerValue`\n            // (and not a normalized value)\n            // We ensure to preserve the invariant `sum(collateralNewNormalizedStables) = normalizedStables`\n            uint128 newNormalizedStables = 0;\n            for (uint256 i; i < collateralListLength; ++i) {\n                uint128 newCollateralNormalizedStable = ((uint256(\n                    ts.collaterals[collateralListMem[i]].normalizedStables\n                ) * newNormalizerValue) / BASE_27).toUint128();\n                newNormalizedStables += newCollateralNormalizedStable;\n                ts.collaterals[collateralListMem[i]].normalizedStables = uint216(newCollateralNormalizedStable);\n            }\n            ts.normalizedStables = newNormalizedStables;\n            newNormalizerValue = BASE_27;\n        }\n        ts.normalizer = newNormalizerValue.toUint128();\n        emit NormalizerUpdated(newNormalizerValue);\n    }\n}"
    },
    {
      "filename": "README.md",
      "content": "# Angle Protocol - Mitigation Review details\n\n- Total Prize Pool: $14,000 USDC\n- [Warden guidelines for C4 mitigation reviews](https://code4rena.notion.site/Guidelines-for-C4-mitigation-reviews-ed10fc5cfbf640bd8dcec66f38b343c4)\n- Submit findings [using the C4 form](https://code4rena.com/contests/2023-07-angle-protocol-mitigation-review/submit)\n- Starts July 17, 2023 20:00 UTC\n- Ends July 21, 2023 20:00 UTC \n\n## Important note\n\nEach warden must submit a mitigation review for:\n\n- Every High and Medium finding listed as in-scope below, and\n- one report each for the Gas and QA fixes.\n\nFor the Gas and QA mitigation reports:\n- Submit any new High or Medium issues introduced by the QA and GAS fixes as a newly-introduced High and Medium risk issue.\n\n**Incomplete mitigation reviews will not be eligible for awards.**\n\n## Findings being mitigated\n\nMitigations of all High and Medium issues will be considered in-scope and listed here.\n\n- [H-01: Possible reentrancy during redemption/swap](https://github.com/code-423n4/2023-06-angle-findings/issues/24)\n- [H-02: The first disputer might lose funds although his dispute is valid.](https://github.com/code-423n4/2023-06-angle-findings/issues/23)\n- [H-03: Poor detection of disputed trees allows claiming tokens from a disputed tre](https://github.com/code-423n4/2023-06-angle-findings/issues/10)\n- [M-01: LibHelpers.piecewiseLinear will revert when the value is less than the first element of the array](https://github.com/code-423n4/2023-06-angle-findings/issues/40)\n- [M-02: Unsafe cast in getCollateralRatio()](https://github.com/code-423n4/2023-06-angle-findings/issues/31)\n- [M-03: Read-only reentrancy is possible](https://github.com/code-423n4/2023-06-angle-findings/issues/30)\n- [M-04: estimatedAPR() might return the wrong APR.](https://github.com/code-423n4/2023-06-angle-findings/issues/28)\n- [M-06: Interest is not accrued before parameters are updated in SavingsVest](https://github.com/code-423n4/2023-06-angle-findings/issues/13)\n- [M-07: User may get less tokens than expected when collateral list order changes](https://github.com/code-423n4/2023-06-angle-findings/issues/8)\n\n## Overview of changes\n\nChanges related to High and Medium issues on Merkl can be found [here](https://github.com/AngleProtocol/merkl-contracts/compare/code-423n4-2023-06-angle...code-423n4-2023-06-angle-mitigation).\nChanges that we intend to make on Merkl prior to final deployment, so including QA and GAS can be found [here](https://github.com/AngleProtocol/merkl-contracts/compare/code-423n4-2023-06-angle...code-423n4-2023-06-angle-full-mitigation). Updated tests and scripts are on the `main` branch.\n\nChanges related to High and Medium issues on Transmuter can be found [here](https://github.com/AngleProtocol/angle-transmuter/compare/code-423n4-2023-06-angle...code-423n4-2023-06-angle-mitigation).\nChanges that we intend to make on Transmuter prior to final deployment, so including QA and GAS can be found can be found [here](https://github.com/AngleProtocol/angle-transmuter/compare/code-423n4-2023-06-angle...code-423n4-2023-06-angle-full-mitigation). Updated tests and scripts are on the `main` branch.\n\n## Mitigations to be reviewed\n\n### Individual PRs\n\n| URL                                                                                               | Mitigation of | Purpose                                             |\n| ------------------------------------------------------------------------------------------------- | ------------- | --------------------------------------------------- |\n| https://github.com/AngleProtocol/angle-transmuter/commit/864c1c47cb550f8e337244f0f70409a171a4e671 | H-01          | Adds a reentrancy guard to several functions        |\n| https://github.com/AngleProtocol/merkl-contracts/commit/7402ee6b84789391479c5876b27be23fd579f7b2  | H-02          | Applies the suggested fix                           |\n| https://github.com/AngleProtocol/merkl-contracts/commit/82d8c0ff37b4a9ad8277cac4aef85f3ca0ad5c7c  | H-03          | Applies the suggested fix                           |\n| https://github.com/AngleProtocol/angle-transmuter/commit/5f7635cdab52b75416309d45f8cd253609c705ff | M-01          | Add an handler for this edge case                   |\n| https://github.com/AngleProtocol/angle-transmuter/commit/6f2ffcb1e89e3bba05c9aa2133ef94347aa42c28 | M-02          | Adds safeCast                                       |\n| https://github.com/AngleProtocol/angle-transmuter/commit/864c1c47cb550f8e337244f0f70409a171a4e671 | M-03          | Adds a reentrancy guard to several functions        |\n| https://github.com/AngleProtocol/angle-transmuter/commit/337c65d005bbd8ed6dfa76929d2cae475066756a | M-04          | Applies the suggested fix                           |\n| https://github.com/AngleProtocol/angle-transmuter/commit/94c4e51ae3400a63532e85f04f4081152adc97db | M-06          | Calls `accrues` before updating sensible parameters |\n| https://github.com/AngleProtocol/angle-transmuter/commit/f8d0bf7c4009586f7022d5929359041db3990175 | M-07          | Applies the suggested fix                           |\n| https://github.com/AngleProtocol/merkl-contracts/commit/3c2fe3a956cdd29b632e8d7a20e1fc2ce5e8ac37  | QA & GAS      |                                                     |\n| https://github.com/AngleProtocol/angle-transmuter/commit/66bba3f5dba4ab6307c997e350dfadb13d2a2119 | QA & GAS      |                                                     |\n\n## Out of Scope\n\n- [M-05: uint128 changeAmount might overflow](https://github.com/code-423n4/2023-06-angle-findings/issues/16): we consider that there is no risk here as swaps will be reverting, and that the chances that this happen are infinitesimals"
    }
  ]
}