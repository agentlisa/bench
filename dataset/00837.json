{
  "Title": "M-4: Price calculation can be manipulated by intentionally reverting some of price feeds.",
  "Content": "# Issue M-4: Price calculation can be manipulated by intentionally reverting some of price feeds. \n\nSource: https://github.com/sherlock-audit/2023-11-olympus-judging/issues/127 \n\n## Found by \nKupiaSec\n## Summary\nPrice calculation module iterates through available price feeds for the requested asset, gather prices of non-revert price feeds and then apply strategy on available prices to calculate final asset price.\nBy abusing this functionality, an attacker can let some price feeds revert to get advantage from any manipulated price feed.\n\n## Vulnerability Detail\nHere we have some methods that attackers can abuse to intentionally revert price feeds.\n1. UniswapV3 price feed\n[UniswapV3Price.sol#L210-214](https://github.com/sherlock-audit/2023-11-olympus/blob/9c8df76dc9820b4c6605d2e1e6d87dcfa9e50070/bophades/src/modules/PRICE/submodules/feeds/UniswapV3Price.sol#L210-L214)\n```Solidity\n// Get the current price of the lookup token in terms of the quote token\n(, int24 currentTick, , , , , bool unlocked) = params.pool.slot0();\n\n// Check for re-entrancy\nif (unlocked == false) revert UniswapV3_PoolReentrancy(address(params.pool));\n```\nIn UniswapV3 price feed, it reverts if current state is re-entered.\nAn attacker can intentionally revert this price feed by calling it from UniswapV3's callback methods.\n\n2. Balancer price feed\n[BalancerPoolTokenPrice.sol#L388](https://github.com/sherlock-audit/2023-11-olympus/blob/9c8df76dc9820b4c6605d2e1e6d87dcfa9e50070/bophades/src/modules/PRICE/submodules/feeds/BalancerPoolTokenPrice.sol#L388)\n[BalancerPoolTokenPrice.sol#487](https://github.com/sherlock-audit/2023-11-olympus/blob/9c8df76dc9820b4c6605d2e1e6d87dcfa9e50070/bophades/src/modules/PRICE/submodules/feeds/BalancerPoolTokenPrice.sol#L487)\n[BalancerPoolTokenPrice.sol#599](https://github.com/sherlock-audit/2023-11-olympus/blob/9c8df76dc9820b4c6605d2e1e6d87dcfa9e50070/bophades/src/modules/PRICE/submodules/feeds/BalancerPoolTokenPrice.sol#L599)\n[BalancerPoolTokenPrice.sol#748](https://github.com/sherlock-audit/2023-11-olympus/blob/9c8df76dc9820b4c6605d2e1e6d87dcfa9e50070/bophades/src/modules/PRICE/submodules/feeds/BalancerPoolTokenPrice.sol#L748)\n```Solidity\n// Prevent re-entrancy attacks\nVaultReentrancyLib.ensureNotInVaultContext(balVault);\n```\nIn BalancerPool price feed, it reverts if current state is re-entered.\nAn attacker can intentionally revert this price feed by calling it in the middle of Balancer action.\n\n3. BunniToken price feed\n[BunniPirce.sol#L155-160](https://github.com/sherlock-audit/2023-11-olympus/blob/9c8df76dc9820b4c6605d2e1e6d87dcfa9e50070/bophades/src/modules/PRICE/submodules/feeds/BunniPrice.sol#L155-L160)\n```Solidity\n_validateReserves(\n    _getBunniKey(token),\n    lens,\n    params.twapMaxDeviationsBps,\n    params.twapObservationWindow\n);\n```\nIn BunniToken price feed, it validates reserves and reverts if it doesn't satisfy deviation.\nSince BunniToken uses UniswapV3, this can be intentionally reverted by calling it from UniswapV3's mint callback.\n\n---\nUsually for ERC20 token prices, above 3 price feeds are commonly used combined with Chainlink price feed, and optionally with `averageMovingPrice`.\nThere are another two points to consider here:\n1. When average moving price is used, it is appended at the end of the price array.\n[OlympusPrice.v2.sol#L160](https://github.com/sherlock-audit/2023-11-olympus/blob/9c8df76dc9820b4c6605d2e1e6d87dcfa9e50070/bophades/src/modules/PRICE/OlympusPrice.v2.sol#L160)\n```Solidity\nif (asset.useMovingAverage) prices[numFeeds] = asset.cumulativeObs / asset.numObservations;\n```\n2. In price calculation strategy, first non-zero price is used when there are 2 valid prices:\n`getMedianPriceIfDeviation` - [SimplePriceFeedStrategy.sol#L246](https://github.com/sherlock-audit/2023-11-olympus/blob/9c8df76dc9820b4c6605d2e1e6d87dcfa9e50070/bophades/src/modules/PRICE/submodules/strategies/SimplePriceFeedStrategy.sol#L246)\n`getMedianPrice` - [SimplePriceFeedStrategy.sol#L313](https://github.com/sherlock-audit/2023-11-olympus/blob/9c8df76dc9820b4c6605d2e1e6d87dcfa9e50070/bophades/src/modules/PRICE/submodules/strategies/SimplePriceFeedStrategy.sol#L313)\nFor `getAveragePrice` and `getAveragePriceIfDeviation`, it uses average price if it deviates.\n\n---\nBased on the information above, here are potential attack vectors that attackers would try:\n1. When Chainlink price feed is manipulated, an attacker can disable all three above price feeds intentionally to get advantage of the price manipulation.\n2. When Chainlink price feed is not used for an asset, an attacker can manipulate one of above 3 spot price feeds and disable other ones.\n\nWhen `averageMovingPrice` is used and average price strategy is applied, the manipulation effect becomes half:\n$\\frac{(P + \\Delta X) + (P)}{2} = P + \\frac{\\Delta X}{2}, P=Market Price, \\Delta X=Manipulated Amount$\n\n## Impact\nAttackers can disable some of price feeds as they want with ease, they can get advantage of one manipulated price feed.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-11-olympus/blob/9c8df76dc9820b4c6605d2e1e6d87dcfa9e50070/bophades/src/modules/PRICE/OlympusPrice.v2.sol#L132-L184\n\n## Tool used\nManual Review\n\n## Recommendation\nFor the cases above that price feeds being intentionally reverted, the price calculation itself also should revert without just ignoring it.\n\n\n\n## Discussion\n\n**nevillehuang**\n\nInvalid, if a user purposely revert price feeds, they are only affecting their own usage, not the usage of price feeds for other users transactions.\n\n**KupiaSecAdmin**\n\nEscalate\n\nHey @nevillehuang - Yes, exactly you are right. What an attacker can manipulate is a spot price using flashloans, so if an attacker purposely disable other price feeds but only leave manipulated price feed, there happens a vulnerability that an attacker can buy tokens at affected price.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> Hey @nevillehuang - Yes, exactly you are right. What an attacker can manipulate is a spot price using flashloans, so if an attacker purposely disable other price feeds but only leave manipulated price feed, there happens a vulnerability that an attacker can buy tokens at affected price.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\n@KupiaSecAdmin, All of your scenarios are invalid\n\n1. There is no point for somebody to reenter to explicity cause a revert for using the price feed himself\n2. Same reason as 1.\n3. There is no point for somebody to cause a deviation to explicity cause a revert for using the price feed himself\n4. A user cannot manipulate a chainlink price feed since there are no reserves\n\nThis is on top of the fact that price submodules are not intended to be called directly, but via the primary price module mentioned in this [comment here](https://github.com/sherlock-audit/2023-11-olympus-judging/issues/96#issuecomment-1878273812)\n\n**KupiaSecAdmin**\n\n@nevillehuang - For example, you can manipulate spot price of Uniswap. To make this work, you need to make other price feeds revert because if they are all enabled, average/median price strategy will be taken and manipulated spot price will not take effect.\n\n**nevillehuang**\n\n@KupiaSecAdmin you cannot make other feeds revert for other user, only yourself, and your submission certainly doesn't prove that it is possible. Besides, to manipulate spot price in uniswap, you will have to manipulate the reserves, which is a known issue in the contest and out of scope.\n\n**KupiaSecAdmin**\n\n@nevillehuang - I would like to add some notes and scenarios below that I think might be attack vectors.\n@0xJem - I would be happy to get some feedbacks from the protocol team regarding the issue.\n\n[Notes]\n1. (I believe) This price module will be used in other parts of Olympus protocol to determine fair price of OHM(and other ERC20 tokens) at any time by integrating multiple price feeds and applying a strategy(average or median) to different prices to carry out final fair price.\n2. The carried out final price will be used to buy/sell OHM tokens using other collaterals in other modules of Olympus protocol.\n\n[Scenario]\n1. Let's assume that an attacker can manipulate a spot price of one price feed, e.g. Uni2, Uni3, Bunni. It can not be guaranteed that all spot price feeds work correctly.\n2. As a result, we can assume that the attacker can manipulate OHM price of one price feed to $9(for example by manipulating Bunni).\n3. However, multiple price feeds are used to calculate fair OHM price, for example, 3 strategies can be used to determine fair OHM price: Chainlink, Uniswap3, Bunni. Thus assume Chainlink returns $11.1 and Uniswap3 returns $11.05 for OHM price.\n4. The price strategy takes median strategy, this means manipulating Bunni price feeds does not take effect on final OHM price determination because the median price of ($9, $11.05, $11.1) is $11.05 which could be accepted as fair OHM price.\n5. Now, the attacker can intentionally make Uniswap 3 price feed reverting using re-entrancy.\n6. When this happens, the only available price feeds are Chainlink and Bunny which are $9 and $11.1. Median price strategy is applied to these feeds thus returning $10 as OHM price, which is affected and this could result in attacker can buy more OHM tokens than expected.\n\n[Thoughts]\nPrice feeds can revert for any reason by accidents so it would actually make sense using try/catch to ignore reverted price feeds. However, price feeds being reverted because of re-entrancy check can not be considered as accidents because it's intentional and unusual behavior. So I think it's the right behavior to revert price calculation itself as a whole when any price feed is reverted by re-entrancy check.\n\n[Claims]\n@nevillehuang - You were mentioning that I can not make other feeds revert for other users but only for myself.\nYes, that's right. An attacker will let some price feeds revert only for himself(and only within a single transaction, they should work fine in other transactions), and it is to manipulate final fair price of tokens regardless of whatever strategy is taken.\n\n**nevillehuang**\n\n@KupiaSecAdmin Can you provide a coded PoC for your above scenario? I really don't see how step 5 can occur, given price feeds are utilized in separate transactions? How would one users price feed reverting affect another?\n\n> 5. Now, the attacker can intentionally make Uniswap 3 price feed reverting using re-entrancy.\n\n\n**KupiaSecAdmin**\n\n@nevillehuang @0xJem  - Here's a PoC that shows how price can be manipulated. You can put this test file in same test directory with `PRICE.v2.t.sol`.\nhttps://gist.github.com/KupiaSecAdmin/fc7ef6664b191ab2b758a22ab15bf404\n\nRunning test: `forge test --fork-url {{MAINNET_RPC}} --fork-block-number 19041673 --match-test testPriceManipulation -vv`\n\nResult:\n```bash\n[PASS] testPriceManipulation() (gas: 2299239)\nLogs:\n  Before: Chainklink/Olympus 6294108760000000000 6308514491323687440\n  After: Chainklink/Olympus 6294108760000000000 29508079057029841191\n\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 4.69s\n \nRan 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```\n\n[Scenario]\n1. It calculates UNI price using mainnet's forked data.\n2. It is assumed that Olympus uses UniV2 and UniV3 price feeds for calculating UNI price.\n3. The test manipulates UniV2 price and intentionally reverts UniV3 price feed, thus the final price is same as manipulated UniV2 price.\n\n[Focus]\n1. Even though test shows price manipulation is done via reserves, but reserve manipulation is not the only way of manipulating price, as Olympus integrates further more price feeds and based on protocols.\n2. The main point to show from the issue and PoC is that intentionally reverting some price feeds is dangerous because that can be a cause of price manipulation.\n\n**0xJem**\n\n@Oighty can you weigh in on the risk of a third-party deliberately triggering the re-entrancy lock in the UniV3 pool?\n\nTo me, this represents a misconfiguration of the asset price feeds. \n\nIf it was a single price feed (UniV3) only, it would be fine, as the price lookup would fail. \nIt's because there's a UniV2 pool in use that this *could* be susceptible to the price manipulation as you described. However, this feels unlikely because:\n- The depth of liquidity on the UNI / WETH UniV2 pool is $4.32m, which feels too low for a UniV3 pool (let alone UniV2!), and so we'd be unlikely to use it.\n- For an asset that does not have as much liquidity (e.g. we are following this approach for FXS), we track an internal MA and use that, which ensures that any manipulation is smoothed out.\n\nIf we were to have UNI defined as an asset, we would be more likely to do this:\n- UNI/ETH Chainlink feed\n- UNI/wETH UniV3 pool with TWAP\n\nGiven the difficulty of manipulation *both* sources, and the deep liquidity of the UniV3 pool ($31.65m), we'd be confident that it would be resilient enough.\n\n**nevillehuang**\n\n- UNI wasn't mentioned as an integrated token in the contest details, so wouldn't this be invalid?\n- Olympus also has many mitigations in place for TWAP manipulation\n\n**Czar102**\n\nI think this is a really nice finding if true, kudos for the thought process @KupiaSecAdmin!\n\nSince price manipulation itself is out of scope, but the expectation of using multiple price sources should make the price more difficult to manipulate, and because of the bug, the breakdown value falls drastically. Thus I believe it deserves to be a valid Medium.\n\nI'm not sure about the point above, @0xJem could you explain why would such setup be a misconfiguration? From my understanding, any setup using any of these 3 oracles and any other one will be susceptible to manipulation.\n\n**nevillehuang**\n\n@Czar102 Some questions:\n\n1. Is there anywhere it was indicated that the above uni pools would be used as price feeds? Given the watson made an assumption:\n\n> assumed that Olympus uses UniV2 and UniV3 price feeds for calculating UNI price.\n\n2. Isn't the additional data provided by the watson still related to manipulation of reserves and like you said out of scope? To me he still hasn't prove that there is any other cause other than manipulating reserves other than stating a possibility? Would be nice if he can prove this issues above scenario of 1 and 2 (reentrancy triggering affecting price feed of other users?)\n\n3. Dont Olympus use an internal MA to mitigate risk of reserve manipulation?\n\n**0xJem**\n\n> I'm not sure about the point above, @0xJem could you explain why would such setup be a misconfiguration? From my understanding, any setup using any of these 3 oracles and any other one will be susceptible to manipulation.\n\n- Given the risk of a single price feed reverting (causing the 2nd price feed to be used), we would not use a UniV2 (which doesn't have re-entrancy protection and is much more susceptible to manipulation) pool as the second feed.\n- Instead of this UniV3 + UniV3 combination, if we were to configure in PRICE for this asset, we would do a Chainlink feed (e.g. UNI-USD, no idea if it exists) and a UniV3 pool.\n\n**Czar102**\n\n@nevillehuang I believe the assumption you are mentioning in point 1 is just an example and the different price feeds could be anything, like Uni v3 + Uni v3 – one could manipulate one of these and make the other revert, for example.\n\nRegarding point 2, I don't think the crux here is the manipulation of reserves, they may be just off with respect to each other. The point is that the attacker can selectively decide which sources of information to use, impacting the final price reading. The point of using multiple feeds is to make the price more reliable, and they are being made less reliable if you can make the readings be rejected.\n\nRegarding point 3, I believe you could repetitively make the price pass sanity checks, making it exponentially diverge from the real price.\n\nRegarding @0xJem's points: I believe simply not using a Uni v2 pool doesn't mitigate this. Using any of the dexes mentioned above together with any feed will have this impact. So, a Chainlink feed + Uni v3 pool could be exploited in a way that the Uni v3 reading will revert and only Chainlink feed will be used, which may benefit the attacker in a certain way.\n\nHas the approach for creating these safe setups been shared with Watsons anywhere? Am I misunderstanding something? @0xJem @nevillehuang @KupiaSecAdmin \n\n**nevillehuang**\n\n@Czar102 \n\n- What is the cost of manipulating such price feeds, is it even profitable for the user?\n\n- The ORIGINAL issue certainly doesn't have [sufficient proof](https://docs.sherlock.xyz/audits/judging/judging#vi.-requirements) to prove that anything other than manipulation of reserves will cause price feed revert or show that it is viable/economically viable. Until the watson prove to me with a reasonable PoC that it is possible, I cannot verify validity, especially not with information from the original submission. If a judge has to do alot of additional research apart from what is provided in the issue, it certainly doesn’t help too.\n\n> 2. In case of non-obvious issues with complex vulnerabilities/attack paths, Watson must submit a valid POC for the issue to be considered valid and rewarded.\n\n- The watson is speculating on how protocol will configure and select different price feeds. Like @0xJem mentioned, this is protocol determined so the above mentioned possibilities are all possible assumptions. “Could be anything” is a weak argument and based off your previous statement [here](https://github.com/sherlock-audit/2023-11-convergence-judging/issues/122#issuecomment-1889571331) it doesn’t line up, given configurations of price feeds are not explicitly mentioned in docs\n\n\nTLDR, unless the watson or YOU provide sufficient proof (best with a PoC) that it is economically possible/profitable, I’m not convinced this is a valid issue since you are just simply stating possibility. Please only consider the original submission only and see if it has sufficient information in place during the time when Im judging this.\n\n**Hash01011122**\n\nIMO In my opinion, while the precise impact of the potential attack isn't crystal clear, the mentioned attack path, extending up to price manipulation, significantly expands the attack surface. This broader surface introduces multiple avenues for potential attacks that may not be immediately apparent. I find @nevillehuang's comment lacking in persuasiveness, on how this issue should be considered as invalid after watson submitted the PoC. With a clear attack impact, Watson's submission should be rated as High severity. Watson's failure to articulate how the identified issue could result in a loss of funds for the protocol is crucial. But the issue highlights numerous ways the core functionality of the contract could be exploited, making it a valid medium-severity concern. \n\n**nevillehuang**\n\n@Hash01011122, stating the possibility of an issue and proving it are two separate things. Can you look at the details provided in the issue and tell me with at least 80% confidence rate that it is valid without additional research by the judge to prove its validity when its not the case? \n\nFor example, the watson is simply stating \"user can cause reentrancy\" with a single one liner type comment without any code description/POC (there are multiple instances throughout the issue)? How am I suppose to verify that? I am a firm believer that burden of proof is on the watson not the judge, and I believe sherlock also enforces this stance.\n\nThe fact that Head of judging and sponsor has to come in and supplement the non-obvious finding of the watson certainly doesn't help too, and I believe this will be resolved in the future now that we have the `request poc` feature, but I believe as of contest date, the information provided in the ORIGINAL submission is insufficient to warrant its severity other than low/invalid.\n\n**Czar102**\n\nI understood the finding when I haven't read a half or it. I think the only thing that needs to be verified is that a revert in price reading will cause the price to be computed based on other sources.\n\nSelective manipulation of sources of information defeats the purpose of sourcing the data from many sources – instead of increasing security, the data will be pulled from potentially least safe sources.\n\nI think it warrants Medium severity.\n\n**nevillehuang**\n\n@Czar102 ok got it I put it on myself for not having the knowledge u possess to understand this issue. I will let you decide once you decide what @0xJem considers. Again understanding and proving to issue is two separate issues for debate.\n\n**Czar102**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [KupiaSecAdmin](https://github.com/sherlock-audit/2023-11-olympus-judging/issues/127/#issuecomment-1881721379): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/128",
  "Code": [
    {
      "filename": "bophades/src/modules/PRICE/submodules/feeds/UniswapV3Price.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n// Libraries\nimport {UniswapV3OracleHelper as OracleHelper} from \"libraries/UniswapV3/Oracle.sol\";\nimport {Deviation} from \"libraries/Deviation.sol\";\nimport {FullMath} from \"libraries/FullMath.sol\";\n\n// Uniswap V3\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {OracleLibrary} from \"@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol\";\n\n// Bophades\nimport \"modules/PRICE/PRICE.v2.sol\";\n\n/// @title      UniswapV3Price\n/// @author     0xJem\n/// @notice     Provides prices derived from the TWAP of a Uniswap V3 pool\ncontract UniswapV3Price is PriceSubmodule {\n    using FullMath for uint256;\n\n    // ========== CONSTANTS ========== //\n\n    /// @notice     The maximum number of decimals allowed for a token in order to prevent overflows\n    uint8 internal constant BASE_10_MAX_EXPONENT = 30;\n\n    /// @notice     The minimum length of the TWAP observation window in seconds\n    ///             From testing, a value under 19 seconds is rejected by `OracleLibrary.getQuoteAtTick()`\n    uint32 internal constant TWAP_MINIMUM_OBSERVATION_SECONDS = 19;\n\n    /// @notice                         The parameters for a Uniswap V3 pool\n    /// @param pool                     The address of the pool\n    /// @param observationWindowSeconds The length of the TWAP observation window in seconds\n    struct UniswapV3Params {\n        IUniswapV3Pool pool;\n        uint32 observationWindowSeconds;\n        uint16 maxDeviationBps;\n    }\n\n    /// @notice     The minimum tick that can be used in a pool, as defined by UniswapV3 libraries\n    int24 internal constant MIN_TICK = -887272;\n    /// @notice     The maximum tick that can be used in a pool, as defined by UniswapV3 libraries\n    int24 internal constant MAX_TICK = -MIN_TICK;\n    /// @notice     Represents a deviation of 100% from the TWAP\n    uint16 internal constant DEVIATION_BASE = 10_000;\n\n    // ========== ERRORS ========== //\n\n    /// @notice                 The decimals of the asset are out of bounds\n    /// @param asset_           The address of the asset\n    /// @param assetDecimals_   The number of decimals of the asset\n    /// @param maxDecimals_     The maximum number of decimals allowed\n    error UniswapV3_AssetDecimalsOutOfBounds(\n        address asset_,\n        uint8 assetDecimals_,\n        uint8 maxDecimals_\n    );\n\n    /// @notice                 The lookup token was not found in the pool\n    /// @param pool_            The address of the pool\n    /// @param asset_           The address of the asset\n    error UniswapV3_LookupTokenNotFound(address pool_, address asset_);\n\n    /// @notice                 The output decimals are out of bounds\n    /// @param outputDecimals_  The number of decimals of the output\n    /// @param maxDecimals_     The maximum number of decimals allowed\n    error UniswapV3_OutputDecimalsOutOfBounds(uint8 outputDecimals_, uint8 maxDecimals_);\n\n    /// @notice                 The pool specified in the parameters is invalid\n    /// @param paramsIndex_     The index of the parameter\n    /// @param pool_            The address of the pool\n    error UniswapV3_ParamsPoolInvalid(uint8 paramsIndex_, address pool_);\n\n    /// @notice                 The pool tokens are invalid\n    /// @param pool_            The address of the pool\n    /// @param tokenIndex_      The index of the token\n    /// @param token_           The address of the token\n    error UniswapV3_PoolTokensInvalid(address pool_, uint8 tokenIndex_, address token_);\n\n    /// @notice                 The pool is invalid\n    /// @dev                    This is triggered if the pool reverted when called,\n    ///                         and indicates that the feed address is not a UniswapV3 pool.\n    ///\n    /// @param pool_            The address of the pool\n    error UniswapV3_PoolTypeInvalid(address pool_);\n\n    /// @notice         Triggered if `pool_` is locked, which indicates re-entrancy\n    ///\n    /// @param pool_    The address of the affected Uniswap V3 pool\n    error UniswapV3_PoolReentrancy(address pool_);\n\n    /// @notice                   The calculated pool price deviates from the TWAP by more than the maximum deviation.\n    ///\n    /// @param pool_              The address of the pool\n    /// @param baseInQuoteTWAP_   The calculated TWAP price in terms of the quote token\n    /// @param baseInQuotePrice_  The calculated current price in terms of the quote token\n    error UniswapV3_PriceMismatch(\n        address pool_,\n        uint256 baseInQuoteTWAP_,\n        uint256 baseInQuotePrice_\n    );\n\n    // ========== STATE VARIABLES ========== //\n\n    // ========== CONSTRUCTOR ========== //\n\n    constructor(Module parent_) Submodule(parent_) {}\n\n    // ========== SUBMODULE FUNCTIONS =========== //\n\n    /// @inheritdoc      Submodule\n    function SUBKEYCODE() public pure override returns (SubKeycode) {\n        return toSubKeycode(\"PRICE.UNIV3\");\n    }\n\n    /// @inheritdoc      Submodule\n    function VERSION() public pure override returns (uint8 major, uint8 minor) {\n        major = 1;\n        minor = 0;\n    }\n\n    // ========== TOKEN PRICE FUNCTIONS ========== //\n\n    /// @notice                 Obtains the price of `lookupToken_` in USD, using the TWAP from the specified Uniswap V3 oracle.\n    /// @dev                    This function will revert if:\n    ///                         - The value of `params.observationWindowSeconds` is less than `TWAP_MINIMUM_OBSERVATION_SECONDS`\n    ///                         - Any token decimals or `outputDecimals_` are high enough to cause an overflow\n    ///                         - Any tokens in the pool are not set\n    ///                         - `lookupToken_` is not in the pool\n    ///                         - The calculated time-weighted tick is outside the bounds of int24\n    ///\n    ///                         NOTE: as a UniswapV3 pool can be manipulated using multi-block MEV, the TWAP values\n    ///                         can also be manipulated. Price feeds are a preferred source of price data. Use this function with caution.\n    ///                         See https://chainsecurity.com/oracle-manipulation-after-merge/\n    ///\n    /// @param lookupToken_     The token to determine the price of.\n    /// @param outputDecimals_  The number of decimals to return the price in\n    /// @param params_          Pool parameters of type `UniswapV3Params`\n    /// @return                 Price in the scale of `outputDecimals_`\n    function getTokenTWAP(\n        address lookupToken_,\n        uint8 outputDecimals_,\n        bytes calldata params_\n    ) external view returns (uint256) {\n        UniswapV3Params memory params = abi.decode(params_, (UniswapV3Params));\n        (\n            address quoteToken,\n            uint8 quoteTokenDecimals,\n            uint8 lookupTokenDecimals\n        ) = _checkPoolAndTokenParams(lookupToken_, outputDecimals_, params.pool);\n\n        uint256 baseInQuotePrice = OracleHelper.getTWAPRatio(\n            address(params.pool),\n            params.observationWindowSeconds,\n            lookupToken_,\n            quoteToken,\n            lookupTokenDecimals\n        );\n\n        // Get the price of {quoteToken} in USD\n        // Decimals: outputDecimals_\n        // PRICE will revert if the price cannot be determined or is 0.\n        (uint256 quoteInUsdPrice, ) = _PRICE().getPrice(quoteToken, PRICEv2.Variant.CURRENT);\n\n        // Calculate final price in USD\n        // Decimals: outputDecimals_\n        return baseInQuotePrice.mulDiv(quoteInUsdPrice, 10 ** quoteTokenDecimals);\n    }\n\n    /// @notice                  Obtains the price of `lookupToken_` in USD, using the current Slot0 price from the specified Uniswap V3 oracle.\n    /// @dev                     This function will revert if:\n    ///                          - The current price differs from the TWAP by more than `maxDeviationBps_`\n    ///                          - The value of `params.observationWindowSeconds` is less than `TWAP_MINIMUM_OBSERVATION_SECONDS`\n    ///                          - Any token decimals or `outputDecimals_` are high enough to cause an overflow\n    ///                          - Any tokens in the pool are not set\n    ///                          - `lookupToken_` is not in the pool\n    ///                          - The calculated time-weighted tick is outside the bounds of int24\n    ///\n    ///                          NOTE: as a UniswapV3 pool can be manipulated using multi-block MEV, the TWAP values\n    ///                          can also be manipulated. Price feeds are a preferred source of price data. Use this function with caution.\n    ///                          See https://chainsecurity.com/oracle-manipulation-after-merge/\n    ///\n    /// @param lookupToken_      The token to determine the price of.\n    /// @param outputDecimals_   The number of decimals to return the price in\n    /// @param params_           Pool parameters of type `UniswapV3Params`\n    /// @return                  Price in the scale of `outputDecimals_`\n    function getTokenPrice(\n        address lookupToken_,\n        uint8 outputDecimals_,\n        bytes calldata params_\n    ) external view returns (uint256) {\n        UniswapV3Params memory params = abi.decode(params_, (UniswapV3Params));\n        (\n            address quoteToken,\n            uint8 quoteTokenDecimals,\n            uint8 lookupTokenDecimals\n        ) = _checkPoolAndTokenParams(lookupToken_, outputDecimals_, params.pool);\n\n        // Get the TWAP price of the lookup token in terms of the quote token\n        uint256 baseInQuoteTWAP = OracleHelper.getTWAPRatio(\n            address(params.pool),\n            params.observationWindowSeconds,\n            lookupToken_,\n            quoteToken,\n            lookupTokenDecimals\n        );\n\n        // Get the current price of the lookup token in terms of the quote token\n        (, int24 currentTick, , , , , bool unlocked) = params.pool.slot0();\n\n        // Check for re-entrancy\n        if (unlocked == false) revert UniswapV3_PoolReentrancy(address(params.pool));\n\n        uint256 baseInQuotePrice = OracleLibrary.getQuoteAtTick(\n            currentTick,\n            uint128(10 ** lookupTokenDecimals),\n            lookupToken_,\n            quoteToken\n        );\n\n        // Check if the absolute deviation between the lookup and reserves price differs by more than reservesDeviationBps\n        // If so, the reserves may be manipulated\n        if (\n            // `isDeviatingWithBpsCheck()` will revert if `deviationBps` is invalid.\n            Deviation.isDeviatingWithBpsCheck(\n                baseInQuotePrice,\n                baseInQuoteTWAP,\n                params.maxDeviationBps,\n                DEVIATION_BASE\n            )\n        ) {\n            revert UniswapV3_PriceMismatch(address(params.pool), baseInQuoteTWAP, baseInQuotePrice);\n        }\n\n        // Get the price of {quoteToken} in USD\n        // Decimals: outputDecimals_\n        // PRICE will revert if the price cannot be determined or is 0.\n        (uint256 quoteInUsdPrice, ) = _PRICE().getPrice(quoteToken, PRICEv2.Variant.CURRENT);\n\n        // Calculate final price in USD\n        // Decimals: outputDecimals_\n        return baseInQuotePrice.mulDiv(quoteInUsdPrice, 10 ** quoteTokenDecimals);\n    }\n\n    // ========== INTERNAL FUNCTIONS ========== //\n\n    /// @notice  Performs checks to ensure that the pool, the tokens, and the decimals are valid.\n    /// @dev                    This function will revert if:\n    ///                         - Any token decimals or `outputDecimals_` are high enough to cause an overflow\n    ///                         - Any tokens in the pool are not set\n    ///                         - `lookupToken_` is not in the pool\n    ///\n    /// @param lookupToken_     The token to determine the price of\n    /// @param outputDecimals_  The decimals of `baseToken`\n    /// @param pool_            The Uniswap V3 pool to use\n    /// @return                 The `quoteToken`, its decimals, and the decimals of `lookupToken_`\n    function _checkPoolAndTokenParams(\n        address lookupToken_,\n        uint8 outputDecimals_,\n        IUniswapV3Pool pool_\n    ) internal view returns (address, uint8, uint8) {\n        if (address(pool_) == address(0)) revert UniswapV3_ParamsPoolInvalid(0, address(pool_));\n\n        try pool_.slot0() returns (uint160, int24, uint16, uint16, uint16, uint8, bool) {\n            // Do nothing\n        } catch (bytes memory) {\n            // Handle a non-UniswapV3 pool\n            revert UniswapV3_PoolTypeInvalid(address(pool_));\n        }\n\n        address quoteToken;\n        {\n            bool lookupTokenFound;\n            try pool_.token0() returns (address token) {\n                // Check if token is zero address, revert if so\n                if (token == address(0))\n                    revert UniswapV3_PoolTokensInvalid(address(pool_), 0, token);\n\n                // If token is the lookup token, set lookupTokenFound to true\n                // Otherwise, it should be the quote token\n                // If lookup token isn't found, quote token will be set twice,\n                // but this is fine since the function will revert anyway\n                if (token == lookupToken_) {\n                    lookupTokenFound = true;\n                } else {\n                    quoteToken = token;\n                }\n            } catch (bytes memory) {\n                // Handle a non-UniswapV3 pool\n                revert UniswapV3_PoolTypeInvalid(address(pool_));\n            }\n            try pool_.token1() returns (address token) {\n                // Check if token is zero address, revert if so\n                if (token == address(0))\n                    revert UniswapV3_PoolTokensInvalid(address(pool_), 1, token);\n\n                // If token is the lookup token, set lookupTokenFound to true\n                // Otherwise, it should be the quote token\n                // If lookup token isn't found, quote token will be set twice,\n                // but this is fine since the function will revert anyway\n                if (token == lookupToken_) {\n                    lookupTokenFound = true;\n                } else {\n                    quoteToken = token;\n                }\n            } catch (bytes memory) {\n                // Handle a non-UniswapV3 pool\n                revert UniswapV3_PoolTypeInvalid(address(pool_));\n            }\n\n            // If lookup token wasn't found, revert\n            if (!lookupTokenFound)\n                revert UniswapV3_LookupTokenNotFound(address(pool_), lookupToken_);\n        }\n\n        // Validate output decimals are not too high\n        if (outputDecimals_ > BASE_10_MAX_EXPONENT)\n            revert UniswapV3_OutputDecimalsOutOfBounds(outputDecimals_, BASE_10_MAX_EXPONENT);\n\n        uint8 quoteTokenDecimals = ERC20(quoteToken).decimals();\n        uint8 lookupTokenDecimals = ERC20(lookupToken_).decimals();\n\n        // Avoid overflows with decimal normalisation\n        if (quoteTokenDecimals > BASE_10_MAX_EXPONENT)\n            revert UniswapV3_AssetDecimalsOutOfBounds(\n                quoteToken,\n                quoteTokenDecimals,\n                BASE_10_MAX_EXPONENT\n            );\n\n        // lookupTokenDecimals must be less than 38 to avoid overflow when cast to uint128\n        // BASE_10_MAX_EXPONENT is less than 38, so this check is safe\n        if (lookupTokenDecimals > BASE_10_MAX_EXPONENT)\n            revert UniswapV3_AssetDecimalsOutOfBounds(\n                lookupToken_,\n                lookupTokenDecimals,\n                BASE_10_MAX_EXPONENT\n            );\n\n        return (quoteToken, quoteTokenDecimals, lookupTokenDecimals);\n    }\n}"
    },
    {
      "filename": "bophades/src/modules/PRICE/submodules/feeds/BalancerPoolTokenPrice.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport \"modules/PRICE/PRICE.v2.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {FullMath} from \"src/libraries/FullMath.sol\";\nimport {StableMath} from \"src/libraries/Balancer/math/StableMath.sol\";\nimport {IVault} from \"src/libraries/Balancer/interfaces/IVault.sol\";\nimport {IBasePool} from \"src/libraries/Balancer/interfaces/IBasePool.sol\";\nimport {IWeightedPool} from \"src/libraries/Balancer/interfaces/IWeightedPool.sol\";\nimport {IStablePool} from \"src/libraries/Balancer/interfaces/IStablePool.sol\";\nimport {VaultReentrancyLib} from \"src/libraries/Balancer/contracts/VaultReentrancyLib.sol\";\nimport {LogExpMath} from \"src/libraries/Balancer/math/LogExpMath.sol\";\nimport {FixedPoint} from \"src/libraries/Balancer/math/FixedPoint.sol\";\n\n/// @title      BalancerPoolTokenPrice\n/// @author     0xJem\n/// @notice     Provides prices related to Balancer pools\ncontract BalancerPoolTokenPrice is PriceSubmodule {\n    using FullMath for uint256;\n\n    /// @notice     Any token or pool with a decimal scale greater than this would result in an overflow\n    uint8 internal constant BASE_10_MAX_EXPONENT = 50;\n\n    /// @notice     Used when calculating the value of a token in a weighted pool\n    uint8 internal constant WEIGHTED_POOL_POW_DECIMALS = 18;\n\n    /// @notice             Parameters for a Balancer weighted pool\n    ///\n    /// @param pool         Address of the Balancer pool\n    struct BalancerWeightedPoolParams {\n        IWeightedPool pool;\n    }\n\n    /// @notice             Parameters for a Balancer stable pool\n    ///\n    /// @param pool         Address of the Balancer pool\n    struct BalancerStablePoolParams {\n        IStablePool pool;\n    }\n\n    /// @notice             Struct to cache data related to a Balancer weighted pool\n    /// @dev                This is not persisted between calls, and is only used to reduce the number of parameters\n    struct BalancerWeightedPoolCache {\n        address[] tokens;\n        uint256[] weights;\n        uint256[] balances;\n        uint8 decimals;\n        bytes32 poolId;\n    }\n\n    // ========== ERRORS ========== //\n\n    /// @notice             The number of decimals of the asset is greater than the maximum allowed\n    ///\n    /// @param asset_       The address of the asset\n    /// @param decimals_    The number of decimals of the asset\n    /// @param maxDecimals_ The maximum number of decimals allowed\n    error Balancer_AssetDecimalsOutOfBounds(address asset_, uint8 decimals_, uint8 maxDecimals_);\n\n    /// @notice             The provided token was not found in the Balancer pool\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    /// @param asset_       The address of the token\n    error Balancer_LookupTokenNotFound(bytes32 poolId_, address asset_);\n\n    /// @notice                 The desired number of output decimals is greater than the maximum allowed\n    ///\n    /// @param outputDecimals_  The desired number of output decimals\n    /// @param maxDecimals_     The maximum number of decimals allowed\n    error Balancer_OutputDecimalsOutOfBounds(uint8 outputDecimals_, uint8 maxDecimals_);\n\n    /// @notice                 The number of decimals of the pool is greater than the maximum allowed\n    ///\n    /// @param poolId_          The id of the Balancer pool\n    /// @param poolDecimals_    The number of decimals of the pool\n    /// @param maxDecimals_     The maximum number of decimals allowed\n    error Balancer_PoolDecimalsOutOfBounds(\n        bytes32 poolId_,\n        uint8 poolDecimals_,\n        uint8 maxDecimals_\n    );\n\n    /// @notice             The stable rate returned by the pool is invalid\n    /// @dev                This currently only occurs if the rate is 0\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    /// @param rate_        The stable rate returned by the pool\n    error Balancer_PoolStableRateInvalid(bytes32 poolId_, uint256 rate_);\n\n    /// @notice             The total supply returned by the pool is invalid\n    /// @dev                This currently only occurs if the total supply is 0\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    /// @param supply_      The total supply returned by the pool\n    error Balancer_PoolSupplyInvalid(bytes32 poolId_, uint256 supply_);\n\n    /// @notice             A token in the pool is invalid\n    /// @dev                This currently only occurs if the token address is 0\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    /// @param index_       The index of the token in the pool\n    /// @param token_       The address of the token\n    error Balancer_PoolTokenInvalid(bytes32 poolId_, uint256 index_, address token_);\n\n    /// @notice             The value of the Balancer pool is zero\n    /// @dev                This currently only occurs if the number of tokens is 0\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    error Balancer_PoolValueZero(bytes32 poolId_);\n\n    /// @notice             There is a mismatch between the number of tokens and weights\n    /// @dev                This is unlikely to occur, but is in place to be defensive\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    /// @param tokenCount_  The number of tokens in the Balancer pool\n    /// @param weightCount_ The number of weights in the Balancer pool\n    error Balancer_PoolTokenWeightMismatch(\n        bytes32 poolId_,\n        uint256 tokenCount_,\n        uint256 weightCount_\n    );\n\n    /// @notice                 There is a mismatch between the number of tokens and balances\n    /// @dev                    This is unlikely to occur, but is in place to be defensive\n    ///\n    /// @param poolId_          The id of the Balancer pool\n    /// @param tokenCount_      The number of tokens in the Balancer pool\n    /// @param balanceCount_    The number of balances in the Balancer pool\n    error Balancer_PoolTokenBalanceMismatch(\n        bytes32 poolId_,\n        uint256 tokenCount_,\n        uint256 balanceCount_\n    );\n\n    /// @notice                 There is a mismatch between the number of tokens, balances and weights\n    /// @dev                    This is unlikely to occur, but is in place to be defensive\n    ///\n    /// @param poolId_          The id of the Balancer pool\n    /// @param tokenCount_      The number of tokens in the Balancer pool\n    /// @param balanceCount_    The number of balances in the Balancer pool\n    /// @param weightCount_     The number of weights in the Balancer pool\n    error Balancer_PoolTokenBalanceWeightMismatch(\n        bytes32 poolId_,\n        uint256 tokenCount_,\n        uint256 balanceCount_,\n        uint256 weightCount_\n    );\n\n    /// @notice             The pool is not a stable pool\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    error Balancer_PoolTypeNotStable(bytes32 poolId_);\n\n    /// @notice             The pool is not a weighted pool\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    error Balancer_PoolTypeNotWeighted(bytes32 poolId_);\n\n    /// @notice             A weight in the pool is invalid\n    /// @dev                This currently only occurs if the weight is 0\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    /// @param index_       The index of the weight in the pool\n    /// @param weight_      The value of the weight\n    error Balancer_PoolWeightInvalid(bytes32 poolId_, uint256 index_, uint256 weight_);\n\n    /// @notice             The price of a corresponding token could not be found\n    /// @dev                This occurs if there are no asset definitions in PRICE\n    /// @dev                for the other tokens in the Balancer pool, and hence\n    /// @dev                the price of the lookup token cannot be determined\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    /// @param lookupToken_ The token to determine the price of\n    error Balancer_PriceNotFound(bytes32 poolId_, address lookupToken_);\n\n    // ========== STATE VARIABLES ========== //\n\n    /// @notice     Address of the Balancer vault\n    IVault public immutable balVault;\n\n    // ========== CONSTRUCTOR ========== //\n\n    constructor(Module parent_, IVault balVault_) Submodule(parent_) {\n        balVault = balVault_;\n    }\n\n    // ========== SUBMODULE FUNCTIONS =========== //\n\n    /// @inheritdoc Submodule\n    function SUBKEYCODE() public pure override returns (SubKeycode) {\n        return toSubKeycode(\"PRICE.BPT\");\n    }\n\n    /// @inheritdoc Submodule\n    function VERSION() public pure override returns (uint8 major, uint8 minor) {\n        major = 1;\n        minor = 0;\n    }\n\n    // ========== HELPER FUNCTIONS ========== //\n\n    /// @notice                     Converts `value_` from the ERC20 token's decimals to `outputDecimals_`\n    /// @dev                        This function will revert if:\n    /// @dev                        - Converting the token's decimals would result in an overflow.\n    ///\n    /// @param value_               Value in native ERC20 token decimals\n    /// @param token_               The address of the ERC20 token\n    /// @param outputDecimals_      The desired number of decimals\n    /// @return                     Number in the scale of `outputDecimals_`\n    function _convertERC20Decimals(\n        uint256 value_,\n        address token_,\n        uint8 outputDecimals_\n    ) internal view returns (uint256) {\n        uint8 tokenDecimals = ERC20(token_).decimals();\n        if (tokenDecimals > BASE_10_MAX_EXPONENT)\n            revert Balancer_AssetDecimalsOutOfBounds(token_, tokenDecimals, BASE_10_MAX_EXPONENT);\n\n        return value_.mulDiv(10 ** outputDecimals_, 10 ** tokenDecimals);\n    }\n\n    /// @notice                     Obtains the balance/weight ratio of the token at index `index_` in the pool\n    /// @dev                        This function will revert if:\n    /// @dev                        - Converting the pool's decimals would result in an overflow.\n    ///\n    /// @dev                        As this function is accessing the balances of the pool, ensure that VaultReentrancyLib\n    /// @dev                        is called in order to prevent re-entrancy attacks.\n    ///\n    /// @param cache                Cached data related to the Balancer weighted pool\n    /// @param index_               Index of the token in the Balancer pool\n    /// @param outputDecimals_      The desired number of decimals\n    /// @return                     Balance in the scale of `outputDecimals_`\n    function _getTokenBalanceWeighting(\n        BalancerWeightedPoolCache memory cache,\n        uint256 index_,\n        uint8 outputDecimals_\n    ) internal view returns (uint256) {\n        uint256 tokenBalance = _convertERC20Decimals(\n            cache.balances[index_],\n            cache.tokens[index_],\n            outputDecimals_\n        );\n\n        uint256 tokenWeight = cache.weights[index_].mulDiv(\n            10 ** outputDecimals_,\n            10 ** cache.decimals\n        );\n\n        return tokenBalance.mulDiv(10 ** outputDecimals_, tokenWeight);\n    }\n\n    /// @notice                     Calculates the value of a token in a Balancer weighted pool\n    /// @dev                        This function will revert if:\n    /// @dev                        - The provided token is address(0)\n    /// @dev                        - The provided weight is 0\n    ///\n    /// @param token_               Address of the token\n    /// @param weight_              Weight of the token in the Balancer pool\n    /// @param poolDecimals_        The number of decimals of the Balancer pool\n    /// @param outputDecimals_      The desired number of decimals\n    /// @param poolId_              id of the Balancer pool\n    /// @param index_               Index of the token in the Balancer pool\n    /// @return                     Value in the scale of `outputDecimals_`\n    function _getTokenValueInWeightedPool(\n        address token_,\n        uint256 weight_,\n        uint8 poolDecimals_,\n        uint8 outputDecimals_,\n        bytes32 poolId_,\n        uint256 index_\n    ) internal view returns (uint256) {\n        if (token_ == address(0)) revert Balancer_PoolTokenInvalid(poolId_, index_, token_);\n        if (weight_ == 0) revert Balancer_PoolWeightInvalid(poolId_, index_, weight_);\n\n        uint256 price; // Scale: `WEIGHTED_POOL_POW_DECIMALS`\n        {\n            /**\n             * PRICE will revert if there is an issue resolving the price, or if it is 0.\n             *\n             * As the value of the pool token is reliant on the price of every underlying token,\n             * the revert from PRICE is not caught.\n             */\n            (uint256 price_, ) = _PRICE().getPrice(token_, PRICEv2.Variant.CURRENT); // Scale: `outputDecimals_`\n\n            price = price_.mulDiv(10 ** WEIGHTED_POOL_POW_DECIMALS, 10 ** outputDecimals_);\n        }\n\n        // Scale: `WEIGHTED_POOL_POW_DECIMALS`\n        uint256 weight = weight_.mulDiv(10 ** WEIGHTED_POOL_POW_DECIMALS, 10 ** poolDecimals_);\n\n        // All inputs to pow need to be in the scale of WEIGHTED_POOL_POW_DECIMALS, so adjust for that\n        uint256 value = LogExpMath.pow(\n            price.mulDiv(10 ** WEIGHTED_POOL_POW_DECIMALS, weight),\n            weight\n        ); // Scale: `WEIGHTED_POOL_POW_DECIMALS`\n\n        // Adjust for `outputDecimals_`\n        return value.mulDiv(10 ** outputDecimals_, 10 ** WEIGHTED_POOL_POW_DECIMALS);\n    }\n\n    /// @notice                     Calculates the value of a Balancer weighted pool\n    /// @dev                        This function calculates the value of each token and returns the sum.\n    ///\n    /// @param tokens_              Array of tokens in the Balancer pool\n    /// @param weights_             Array of weights of the tokens in the Balancer pool\n    /// @param poolDecimals_        The number of decimals of the Balancer pool\n    /// @param outputDecimals_      The desired number of decimals\n    /// @return                     Value in the scale of `outputDecimals_`\n    function _getWeightedPoolRawValue(\n        address[] memory tokens_,\n        uint256[] memory weights_,\n        uint8 poolDecimals_,\n        uint8 outputDecimals_,\n        bytes32 poolId_\n    ) internal view returns (uint256) {\n        uint256 len = tokens_.length;\n\n        uint256 poolValue = 0; // Scale: `outputDecimals_`\n        for (uint256 i; i < len; ) {\n            uint256 currentValue = _getTokenValueInWeightedPool(\n                tokens_[i],\n                weights_[i],\n                poolDecimals_,\n                outputDecimals_,\n                poolId_,\n                i\n            );\n\n            if (poolValue == 0) {\n                poolValue = currentValue;\n            } else {\n                poolValue = poolValue.mulDiv(currentValue, 10 ** outputDecimals_);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return poolValue;\n    }\n\n    // ========== POOL TOKEN PRICE FUNCTIONS ========== //\n\n    /// @notice                 Determines the unit price of the pool token for the Balancer weighted pool specified in `params_`.\n    /// @dev                    To avoid price manipulation, this function calculated the pool token price in the manner recommended by\n    /// @dev                    Balancer at https://docs.balancer.fi/concepts/advanced/valuing-bpt/valuing-bpt.html#on-chain-price-evaluation :\n    /// @dev                    - Obtains the prices of all tokens in the pool from PRICE (usually using price feeds)\n    /// @dev                    - Applies a guard to protect against re-entrancy attacks on the Balancer pool\n    ///\n    /// @dev                    This function will revert if:\n    /// @dev                    - The scale of `outputDecimals_` or the pool's decimals is too high\n    /// @dev                    - The pool is mis-configured\n    /// @dev                    - If the pool is not a weighted pool\n    ///\n    /// @param outputDecimals_  The number of output decimals\n    /// @param params_          Balancer pool parameters of type `BalancerWeightedPoolParams`\n    /// @return                 Price in the scale of `outputDecimals_`\n    function getWeightedPoolTokenPrice(\n        address,\n        uint8 outputDecimals_,\n        bytes calldata params_\n    ) external view returns (uint256) {\n        // Prevent overflow\n        if (outputDecimals_ > BASE_10_MAX_EXPONENT)\n            revert Balancer_OutputDecimalsOutOfBounds(outputDecimals_, BASE_10_MAX_EXPONENT);\n\n        address[] memory tokens;\n        uint256[] memory weights;\n        uint256 poolMultiplier; // outputDecimals_\n        uint8 poolDecimals;\n        bytes32 poolId;\n        {\n            // Decode params\n            BalancerWeightedPoolParams memory params = abi.decode(\n                params_,\n                (BalancerWeightedPoolParams)\n            );\n            if (address(par"
    }
  ]
}