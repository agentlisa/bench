{
  "Title": "[L-02] Risks associated with forceful ETH transfers to unprepared contracts",
  "Content": "Forcing ETH transfers to contracts that are not designed to receive them, due to the absence of a `payable fallback` or `receive` function, can lead to permanently locked funds within these recipient contracts. This situation, facilitated by low-level operations like `selfdestruct`, presents a significant severity issue that undermines the predictability and safety of smart contract interactions in the Ethereum ecosystem. To mitigate such risks, it is recommended that sending contracts verify the recipient's ability to handle ETH in a standard manner and that developers design contracts with interoperability and safe ETH handling in mind, ensuring the broader reliability and trustworthiness of the ecosystem.\n\nhttps://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol#L158-L162\n\n```solidity\n        // Send the all remaining funds to the user accout.\n        delete _withdrawableETH[account];\n        if (withdrawable > 0) {\n            SafeTransferLib.forceSafeTransferETH(account, withdrawable, SafeTransferLib.GAS_STIPEND_NO_STORAGE_WRITES);\n        }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-coinbase",
  "Code": [
    {
      "filename": "src/MagicSpend/MagicSpend.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SignatureCheckerLib} from \"solady/utils/SignatureCheckerLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {UserOperation} from \"account-abstraction/interfaces/UserOperation.sol\";\nimport {IPaymaster} from \"account-abstraction/interfaces/IPaymaster.sol\";\nimport {IEntryPoint} from \"account-abstraction/interfaces/IEntryPoint.sol\";\n\n/// @title Magic Spend\n///\n/// @author Coinbase (https://github.com/coinbase/magic-spend)\n///\n/// @notice ERC4337 Paymaster implementation compatible with Entrypoint v0.6.\n///\n/// @dev See https://eips.ethereum.org/EIPS/eip-4337#extension-paymasters.\ncontract MagicSpend is Ownable, IPaymaster {\n    /// @notice Signed withdraw request allowing accounts to withdraw funds from this contract.\n    struct WithdrawRequest {\n        /// @dev The signature associated with this withdraw request.\n        bytes signature;\n        /// @dev The asset to withdraw. NOTE: Only ETH (associated with zero address) is supported for now.\n        address asset;\n        /// @dev The requested amount to withdraw.\n        uint256 amount;\n        /// @dev Unique nonce used to prevent replays.\n        uint256 nonce;\n        /// @dev The maximum expiry the withdraw request remains valid for.\n        uint48 expiry;\n    }\n\n    /// @notice Track the ETH available to be withdrawn per user.\n    mapping(address user => uint256 amount) internal _withdrawableETH;\n\n    /// @dev Mappings keeping track of already used nonces per user to prevent replays of withdraw requests.\n    mapping(uint256 nonce => mapping(address user => bool used)) internal _nonceUsed;\n\n    /// @notice Emitted after validating a withdraw request and funds are about to be withdrawn.\n    ///\n    /// @param account The account address.\n    /// @param asset   The asset withdrawn.\n    /// @param amount  The amount withdrawn.\n    /// @param nonce   The request nonce.\n    event MagicSpendWithdrawal(address indexed account, address indexed asset, uint256 amount, uint256 nonce);\n\n    /// @notice Thrown when the withdraw request signature is invalid.\n    ///\n    /// @dev The withdraw request signature MUST be:\n    ///         - an ECDSA signature following EIP-191 (version 0x45)\n    ///         - performed over the content specified in `getHash()`\n    ///         - signed by the current owner of this contract\n    error InvalidSignature();\n\n    /// @notice Thrown when trying to use a withdraw request after its expiry has been reched.\n    error Expired();\n\n    /// @notice Thrown when trying to replay a withdraw request with the same nonce.\n    ///\n    /// @param nonce The already used nonce.\n    error InvalidNonce(uint256 nonce);\n\n    /// @notice Thrown during validation in the context of ERC4337, when the withraw reques amount is insufficient\n    ///         to sponsor the transaction gas.\n    ///\n    /// @param requested The withdraw request amount.\n    /// @param maxCost   The max gas cost required by the Entrypoint.\n    error RequestLessThanGasMaxCost(uint256 requested, uint256 maxCost);\n\n    /// @notice Thrown when the withdraw request asset is not ETH (zero address).\n    ///\n    /// @param asset The requested asset.\n    error UnsupportedPaymasterAsset(address asset);\n\n    /// @notice Thrown during `UserOperation` validation when the current balance is insufficient to cover the\n    ///         requested amount (exluding the `maxGasCost` set by the Entrypoint).\n    ///\n    /// @param requestedAmount The requested amount excluding gas.\n    /// @param balance         The current contract balance.\n    error InsufficientBalance(uint256 requestedAmount, uint256 balance);\n\n    /// @notice Thrown when trying to withdraw funds but nothing is available.\n    error NoExcess();\n\n    /// @notice Thrown in when `postOp()` is called a second time with `PostOpMode.postOpReverted`.\n    ///\n    /// @dev This should only really occur if for unknown reasons the transfer of the withdrwable\n    ///      funds to the user account failed (i.e. this contract's ETH balance is insufficient or\n    ///      the user account refused the funds or ran out of gas on receive).\n    error UnexpectedPostOpRevertedMode();\n\n    /// @dev Requires that the caller is the EntryPoint.\n    modifier onlyEntryPoint() virtual {\n        if (msg.sender != entryPoint()) revert Unauthorized();\n        _;\n    }\n\n    /// @notice Deploy the contract and set its initial owner.\n    ///\n    /// @param _owner The initial owner of this contract.\n    constructor(address _owner) {\n        Ownable._initializeOwner(_owner);\n    }\n\n    /// @notice Receive function allowing ETH to be deposited in this contract.\n    receive() external payable {}\n\n    /// @inheritdoc IPaymaster\n    function validatePaymasterUserOp(UserOperation calldata userOp, bytes32, uint256 maxCost)\n        external\n        onlyEntryPoint\n        returns (bytes memory context, uint256 validationData)\n    {\n        WithdrawRequest memory withdrawRequest = abi.decode(userOp.paymasterAndData[20:], (WithdrawRequest));\n        uint256 withdrawAmount = withdrawRequest.amount;\n\n        if (withdrawAmount < maxCost) {\n            revert RequestLessThanGasMaxCost(withdrawAmount, maxCost);\n        }\n\n        if (withdrawRequest.asset != address(0)) {\n            revert UnsupportedPaymasterAsset(withdrawRequest.asset);\n        }\n\n        _validateRequest(userOp.sender, withdrawRequest);\n\n        bool sigFailed = !isValidWithdrawSignature(userOp.sender, withdrawRequest);\n        validationData = (sigFailed ? 1 : 0) | (uint256(withdrawRequest.expiry) << 160);\n\n        // Ensure at validation that the contract has enough balance to cover the requested funds.\n        // NOTE: This check is necessary to enforce that the contract will be able to transfer the remaining funds\n        //       when `postOp()` is called back after the `UserOperation` has been executed.\n        if (address(this).balance < withdrawAmount) {\n            revert InsufficientBalance(withdrawAmount, address(this).balance);\n        }\n\n        // NOTE: Do not include the gas part in withdrawable funds as it will be handled in `postOp()`.\n        _withdrawableETH[userOp.sender] += withdrawAmount - maxCost;\n        context = abi.encode(maxCost, userOp.sender);\n    }\n\n    /// @inheritdoc IPaymaster\n    function postOp(IPaymaster.PostOpMode mode, bytes calldata context, uint256 actualGasCost)\n        external\n        onlyEntryPoint\n    {\n        // `PostOpMode.postOpReverted` should be impossible.\n        // Only possible cause would be if this contract does not own enough ETH to transfer\n        // but this is checked at the validation step.\n        assert(mode != PostOpMode.postOpReverted);\n\n        (uint256 maxGasCost, address account) = abi.decode(context, (uint256, address));\n\n        // Compute the total remaining funds available for the user accout.\n        // NOTE: Take into account the user operation gas that was not consummed.\n        uint256 withdrawable = _withdrawableETH[account] + (maxGasCost - actualGasCost);\n\n        // Send the all remaining funds to the user accout.\n        delete _withdrawableETH[account];\n        if (withdrawable > 0) {\n            SafeTransferLib.forceSafeTransferETH(account, withdrawable, SafeTransferLib.GAS_STIPEND_NO_STORAGE_WRITES);\n        }\n    }\n\n    /// @notice Allows the sender to withdraw any available funds associated with him.\n    ///\n    /// @dev Can be called back during the `UserOperation` execution to sponsor funds for non-gas related\n    ///      use cases (e.g., swap or mint).\n    function withdrawGasExcess() external {\n        uint256 amount = _withdrawableETH[msg.sender];\n        // we could allow 0 value transfers, but prefer to be explicit\n        if (amount == 0) revert NoExcess();\n\n        delete _withdrawableETH[msg.sender];\n        _withdraw(address(0), msg.sender, amount);\n    }\n\n    /// @notice Allows caller to withdraw funds by calling with a valid `withdrawRequest`\n    ///\n    /// @param withdrawRequest The withdraw request.\n    function withdraw(WithdrawRequest memory withdrawRequest) external {\n        _validateRequest(msg.sender, withdrawRequest);\n\n        if (!isValidWithdrawSignature(msg.sender, withdrawRequest)) {\n            revert InvalidSignature();\n        }\n\n        if (block.timestamp > withdrawRequest.expiry) {\n            revert Expired();\n        }\n\n        // reserve funds for gas, will credit user with difference in post op\n        _withdraw(withdrawRequest.asset, msg.sender, withdrawRequest.amount);\n    }\n\n    /// @notice Withdraws funds from this contract.\n    ///\n    /// @dev Reverts if not called by the owner of the contract.\n    ///\n    /// @param asset The asset to withdraw.\n    /// @param to The beneficiary address.\n    /// @param amount The amount to withdraw.\n    function ownerWithdraw(address asset, address to, uint256 amount) external onlyOwner {\n        _withdraw(asset, to, amount);\n    }\n\n    /// @notice Deposits ETH from this contract funds into the EntryPoint.\n    ///\n    /// @dev Reverts if not called by the owner of the contract.\n    ///\n    /// @param amount The amount to deposit on the the Entrypoint.\n    function entryPointDeposit(uint256 amount) external payable onlyOwner {\n        SafeTransferLib.safeTransferETH(entryPoint(), amount);\n    }\n\n    /// @notice Withdraws ETH from the EntryPoint.\n    ///\n    /// @dev Reverts if not called by the owner of the contract.\n    ///\n    /// @param to     The beneficiary address.\n    /// @param amount The amount to withdraw from the Entrypoint.\n    function entryPointWithdraw(address payable to, uint256 amount) external onlyOwner {\n        IEntryPoint(entryPoint()).withdrawTo(to, amount);\n    }\n\n    /// @notice Adds stake to the EntryPoint.\n    ///\n    /// @dev Reverts if not called by the owner of the contract.\n    ///\n    /// @param amount              The amount to stake in the Entrypoint.\n    /// @param unstakeDelaySeconds The duration for which the stake cannot be withdrawn.\n    function entryPointAddStake(uint256 amount, uint32 unstakeDelaySeconds) external payable onlyOwner {\n        IEntryPoint(entryPoint()).addStake{value: amount}(unstakeDelaySeconds);\n    }\n\n    /// @notice Unlocks stake in the EntryPoint.\n    ///\n    /// @dev Reverts if not called by the owner of the contract.\n    function entryPointUnlockStake() external onlyOwner {\n        IEntryPoint(entryPoint()).unlockStake();\n    }\n\n    /// @notice Withdraws stake from the EntryPoint.\n    ///\n    /// @dev Reverts if not called by the owner of the contract.\n    ///\n    /// @param to The beneficiary address.\n    function entryPointWithdrawStake(address payable to) external onlyOwner {\n        IEntryPoint(entryPoint()).withdrawStake(to);\n    }\n\n    /// @notice Returns whether the `withdrawRequest` signature is valid for the given `account`.\n    ///\n    /// @dev Does not validate nonce or expiry.\n    ///\n    /// @param account         The account address.\n    /// @param withdrawRequest The withdraw request.\n    ///\n    /// @return `true` if the signature is valid, else `false`.\n    function isValidWithdrawSignature(address account, WithdrawRequest memory withdrawRequest)\n        public\n        view\n        returns (bool)\n    {\n        return SignatureCheckerLib.isValidSignatureNow(\n            owner(), getHash(account, withdrawRequest), withdrawRequest.signature\n        );\n    }\n\n    /// @notice Returns the hash to be signed for a given `account` and `withdrawRequest` pair.\n    ///\n    /// @dev Returns an EIP-191 compliant Ethereum Signed Message (version 0x45), see\n    ///      https://eips.ethereum.org/EIPS/eip-191.\n    ///\n    /// @param account         The account address.\n    /// @param withdrawRequest The withdraw request.\n    ///\n    /// @return The hash to be signed for the given `account` and `withdrawRequest`.\n    function getHash(address account, WithdrawRequest memory withdrawRequest) public view returns (bytes32) {\n        return SignatureCheckerLib.toEthSignedMessageHash(\n            abi.encode(\n                address(this),\n                account,\n                block.chainid,\n                withdrawRequest.asset,\n                withdrawRequest.amount,\n                withdrawRequest.nonce,\n                withdrawRequest.expiry\n            )\n        );\n    }\n\n    /// @notice Returns whether the `nonce` has been used by the given `account`.\n    ///\n    /// @param account The account address.\n    /// @param nonce   The nonce to check.\n    ///\n    /// @return `true` if the nonce has already been used by the account, else `false`.\n    function nonceUsed(address account, uint256 nonce) external view returns (bool) {\n        return _nonceUsed[nonce][account];\n    }\n\n    /// @notice Returns the canonical ERC-4337 EntryPoint v0.6 contract.\n    function entryPoint() public pure returns (address) {\n        return 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789;\n    }\n\n    /// @notice Validate the `withdrawRequest` against the given `account`.\n    ///\n    /// @dev Runs all non-signature validation checks.\n    /// @dev Reverts if the withdraw request nonce has already been used.\n    ///\n    /// @param account         The account address.\n    /// @param withdrawRequest The withdraw request to validate.\n    function _validateRequest(address account, WithdrawRequest memory withdrawRequest) internal {\n        if (_nonceUsed[withdrawRequest.nonce][account]) {\n            revert InvalidNonce(withdrawRequest.nonce);\n        }\n\n        _nonceUsed[withdrawRequest.nonce][account] = true;\n\n        // This is emitted ahead of fund transfer, but allows a consolidated code path\n        emit MagicSpendWithdrawal(account, withdrawRequest.asset, withdrawRequest.amount, withdrawRequest.nonce);\n    }\n\n    /// @notice Withdraws funds from this contract.\n    ///\n    /// @dev Callers MUST validate that the withdraw is legitimate before calling this method as\n    ///      no validation is performed here.\n    ///\n    /// @param asset  The asset to withdraw.\n    /// @param to     The beneficiary address.\n    /// @param amount The amount to withdraw.\n    function _withdraw(address asset, address to, uint256 amount) internal {\n        if (asset == address(0)) {\n            SafeTransferLib.safeTransferETH(to, amount);\n        } else {\n            SafeTransferLib.safeTransfer(asset, to, amount);\n        }\n    }\n}"
    }
  ]
}