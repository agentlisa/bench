{
  "Title": "[M-06] EthAssetManager and ThreePoolAssetManager don't control Meta tokens decimals",
  "Content": "_Submitted by hyh_\n\nBoth contracts treat meta assets as if they have fixed decimals of 18. Minting logic breaks when it's not the case. However, meta tokens decimals aren't controlled.\n\nIf actual meta assets have any other decimals, minting slippage control logic of both contracts will break up as `total` is calculated as a plain sum of token amounts.\n\nIn the higher token decimals case `minTotalAmount` will be magnitudes higher than actual amount Curve can provide and minting becomes unavailable.\n\nIn the lower token decimals case `minTotalAmount` will lack value and slippage control will be rendered void, which opens up a possibility of a fund loss from the excess slippage.\n\nSetting severity to medium as the contract can be used with various meta tokens (`_metaPoolAssetCache`  can be filled with any assets) and, whenever decimals differ from 18 `add_liquidity` uses, its logic be broken: the inability to mint violates the contract purpose, the lack of slippage control can lead to fund losses.\n\nI.e. this is system breaking impact conditional on a low probability assumption of different meta token decimals.\n\n### Proof of Concept\n\nMeta tokens decimals are de facto hard coded into the contract as plain amounts are used (L. 905):\n\n[ThreePoolAssetManager.sol#L896-L905](https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L896-L905)<br>\n\n```solidity\n    function _mintMetaPoolTokens(\n        uint256[NUM_META_COINS] calldata amounts\n    ) internal returns (uint256 minted) {\n        IERC20[NUM_META_COINS] memory tokens = _metaPoolAssetCache;\n\n        uint256 total = 0;\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\n            if (amounts[i] == 0) continue;\n\n            total += amounts[i];\n```\n\n[ThreePoolAssetManager.sol#L915-L919](https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L915-L919)<br>\n\n```solidity\n        uint256 expectedOutput    = total * CURVE_PRECISION / metaPool.get_virtual_price();\n        uint256 minimumMintAmount = expectedOutput * metaPoolSlippage / SLIPPAGE_PRECISION;\n\n        // Add the liquidity to the pool.\n        minted = metaPool.add_liquidity(amounts, minimumMintAmount);\n```\n\nThe same plain sum approach is used in EthAssetManager.\\_mintMetaPoolTokens:\n\n[EthAssetManager.sol#L566-L573](https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/EthAssetManager.sol#L566-L573)<br>\n\n```solidity\n        uint256 total = 0;\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\n            // Skip over approving WETH since we are directly swapping ETH.\n            if (i == uint256(MetaPoolAsset.ETH)) continue;\n\n            if (amounts[i] == 0) continue;\n\n            total += amounts[i];\n```\n\nWhen this decimals assumption doesn't hold, the slippage logic will not hold too: either the mint be blocked or slippage control disabled.\n\nNotice, that ThreePoolAssetManager.calculateRebalance do query alUSD decimals (which is inconsistent with the above as itâ€™s either fix and control on inception or do not fix and accommodate the logic):\n\n[ThreePoolAssetManager.sol#L338-L338](https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L338-L338)<br>\n\n```solidity\ndecimals     = SafeERC20.expectDecimals(address(alUSD));\n```\n\n### Recommended Mitigation Steps\n\nIf meta assets are always supposed to have fixed decimals of 18, consider controlling it at the construction time.\n\nI.e. the decimals can be controlled in constructors:\n\n[EthAssetManager.sol#L214-L219](https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/EthAssetManager.sol#L214-L219)<br>\n\n```solidity\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\n            _metaPoolAssetCache[i] = params.metaPool.coins(i);\n            if (_metaPoolAssetCache[i] == IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)) {\n                _metaPoolAssetCache[i] = weth;\n+           } else {\n+           \t// check the decimals\n\t\t\t\t}\n        }\n```\n\n[ThreePoolAssetManager.sol#L254-L256](https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L254-L256)<br>\n\n```solidity\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\n            _metaPoolAssetCache[i] = params.metaPool.coins(i);\n+           // check the decimals            \n        }\n```\n\nIn this case further decimals reading as it's done in calculateRebalance() is redundant.\n\nOtherwise (which is less recommended as fixed decimals assumption is viable and simplify the logic) the meta token decimals can be added to calculations similarly to stables:\n\n[ThreePoolAssetManager.sol#L779-L779](https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L779-L779)<br>\n\n```solidity\nnormalizedTotal += amounts[i] * 10**missingDecimals;\n```\n\n**[0xfoobar (Alchemix) confirmed](https://github.com/code-423n4/2022-05-alchemix-findings/issues/63#issuecomment-1141380260)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-05-alchemix-findings/issues/63#issuecomment-1153292871):**\n > Agree with issue and its severity. `minTotalAmount` is affected by a change in a token's decimals, leading to improper handling by the contract. \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-alchemix-contest",
  "Code": [
    {
      "filename": "contracts-full/ThreePoolAssetManager.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.13;\n\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\n\n\nimport {IllegalArgument, IllegalState, Unauthorized} from \"./base/Errors.sol\";\nimport {Multicall} from \"./base/Multicall.sol\";\nimport {Mutex} from \"./base/Mutex.sol\";\n\nimport {IERC20TokenReceiver} from \"./interfaces/IERC20TokenReceiver.sol\";\nimport {IConvexBooster} from \"./interfaces/external/convex/IConvexBooster.sol\";\nimport {IConvexRewards} from \"./interfaces/external/convex/IConvexRewards.sol\";\nimport {IConvexToken} from \"./interfaces/external/convex/IConvexToken.sol\";\n\nimport {\n    IStableMetaPool,\n    N_COINS as NUM_META_COINS\n} from \"./interfaces/external/curve/IStableMetaPool.sol\";\n\nimport {\n    IStableSwap3Pool,\n    N_COINS as NUM_STABLE_COINS\n} from \"./interfaces/external/curve/IStableSwap3Pool.sol\";\n\nimport {SafeERC20} from \"./libraries/SafeERC20.sol\";\n\n/// @notice A struct used to define initialization parameters. This is not included\n///         in the contract to prevent naming collisions.\nstruct InitializationParams {\n    address admin;\n    address operator;\n    address rewardReceiver;\n    address transmuterBuffer;\n    IERC20 curveToken;\n    IStableSwap3Pool threePool;\n    IStableMetaPool metaPool;\n    uint256 threePoolSlippage;\n    uint256 metaPoolSlippage;\n    IConvexToken convexToken;\n    IConvexBooster convexBooster;\n    IConvexRewards convexRewards;\n    uint256 convexPoolId;\n}\n\n/// @dev The amount of precision that slippage parameters have.\nuint256 constant SLIPPAGE_PRECISION = 1e4;\n\n/// @dev The amount of precision that curve pools use for price calculations.\nuint256 constant CURVE_PRECISION = 1e18;\n\n/// @notice Enumerations for 3pool assets.\n///\n/// @dev Do not change the order of these fields.\nenum ThreePoolAsset {\n    DAI, USDC, USDT\n}\n\n/// @notice Enumerations for meta pool assets.\n///\n/// @dev Do not change the order of these fields.\nenum MetaPoolAsset {\n    ALUSD, THREE_POOL\n}\n\n/// @title  ThreePoolAssetManager\n/// @author Alchemix Finance\ncontract ThreePoolAssetManager is Multicall, Mutex, IERC20TokenReceiver {\n    /// @notice Emitted when the admin is updated.\n    ///\n    /// @param admin The admin.\n    event AdminUpdated(address admin);\n\n    /// @notice Emitted when the pending admin is updated.\n    ///\n    /// @param pendingAdmin The pending admin.\n    event PendingAdminUpdated(address pendingAdmin);\n\n    /// @notice Emitted when the operator is updated.\n    ///\n    /// @param operator The operator.\n    event OperatorUpdated(address operator);\n\n    /// @notice Emitted when the reward receiver is updated.\n    ///\n    /// @param rewardReceiver The reward receiver.\n    event RewardReceiverUpdated(address rewardReceiver);\n\n    /// @notice Emitted when the transmuter buffer is updated.\n    ///\n    /// @param transmuterBuffer The transmuter buffer.\n    event TransmuterBufferUpdated(address transmuterBuffer);\n\n    /// @notice Emitted when the 3pool slippage is updated.\n    ///\n    /// @param threePoolSlippage The 3pool slippage.\n    event ThreePoolSlippageUpdated(uint256 threePoolSlippage);\n\n    /// @notice Emitted when the meta pool slippage is updated.\n    ///\n    /// @param metaPoolSlippage The meta pool slippage.\n    event MetaPoolSlippageUpdated(uint256 metaPoolSlippage);\n\n    /// @notice Emitted when 3pool tokens are minted.\n    ///\n    /// @param amounts               The amounts of each 3pool asset used to mint liquidity.\n    /// @param mintedThreePoolTokens The amount of 3pool tokens minted.\n    event MintThreePoolTokens(uint256[NUM_STABLE_COINS] amounts, uint256 mintedThreePoolTokens);\n\n    /// @notice Emitted when 3pool tokens are minted.\n    ///\n    /// @param asset                 The 3pool asset used to mint 3pool tokens.\n    /// @param amount                The amount of the asset used to mint 3pool tokens.\n    /// @param mintedThreePoolTokens The amount of 3pool tokens minted.\n    event MintThreePoolTokens(ThreePoolAsset asset, uint256 amount, uint256 mintedThreePoolTokens);\n\n    /// @notice Emitted when 3pool tokens are burned.\n    ///\n    /// @param asset     The 3pool asset that was received.\n    /// @param amount    The amount of 3pool tokens that were burned.\n    /// @param withdrawn The amount of the 3pool asset that was withdrawn.\n    event BurnThreePoolTokens(ThreePoolAsset asset, uint256 amount, uint256 withdrawn);\n\n    /// @notice Emitted when meta pool tokens are minted.\n    ///\n    /// @param amounts               The amounts of each meta pool asset used to mint liquidity.\n    /// @param mintedThreePoolTokens The amount of meta pool tokens minted.\n    event MintMetaPoolTokens(uint256[NUM_META_COINS] amounts, uint256 mintedThreePoolTokens);\n\n    /// @notice Emitted when meta tokens are minted.\n    ///\n    /// @param asset  The asset used to mint meta pool tokens.\n    /// @param amount The amount of the asset used to mint meta pool tokens.\n    /// @param minted The amount of meta pool tokens minted.\n    event MintMetaPoolTokens(MetaPoolAsset asset, uint256 amount, uint256 minted);\n\n    /// @notice Emitted when meta pool tokens are burned.\n    ///\n    /// @param asset     The meta pool asset that was received.\n    /// @param amount    The amount of meta pool tokens that were burned.\n    /// @param withdrawn The amount of the asset that was withdrawn.\n    event BurnMetaPoolTokens(MetaPoolAsset asset, uint256 amount, uint256 withdrawn);\n\n    /// @notice Emitted when meta pool tokens are deposited into convex.\n    ///\n    /// @param amount  The amount of meta pool tokens that were deposited.\n    /// @param success If the operation was successful.\n    event DepositMetaPoolTokens(uint256 amount, bool success);\n\n    /// @notice Emitted when meta pool tokens are withdrawn from convex.\n    ///\n    /// @param amount  The amount of meta pool tokens that were withdrawn.\n    /// @param success If the operation was successful.\n    event WithdrawMetaPoolTokens(uint256 amount, bool success);\n\n    /// @notice Emitted when convex rewards are claimed.\n    ///\n    /// @param success      If the operation was successful.\n    /// @param amountCurve  The amount of curve tokens sent to the reward recipient.\n    /// @param amountConvex The amount of convex tokens sent to the reward recipient.\n    event ClaimRewards(bool success, uint256 amountCurve, uint256 amountConvex);\n\n    /// @notice Emitted when 3pool assets are sent to the transmuter buffer.\n    ///\n    /// @param asset  The 3pool asset that was reclaimed.\n    /// @param amount The amount of the asset that was reclaimed.\n    event ReclaimThreePoolAsset(ThreePoolAsset asset, uint256 amount);\n\n    /// @notice The admin.\n    address public admin;\n\n    /// @notice The current pending admin.\n    address public pendingAdmin;\n\n    /// @notice The operator.\n    address public operator;\n\n    // @notice The reward receiver.\n    address public rewardReceiver;\n\n    /// @notice The transmuter buffer.\n    address public transmuterBuffer;\n\n    /// @notice The curve token.\n    IERC20 public immutable curveToken;\n\n    /// @notice The 3pool contract.\n    IStableSwap3Pool public immutable threePool;\n\n    /// @notice The meta pool contract.\n    IStableMetaPool public immutable metaPool;\n\n    /// @notice The amount of slippage that will be tolerated when depositing and withdrawing assets\n    ///         from the stable swap pool. In units of basis points.\n    uint256 public threePoolSlippage;\n\n    /// @notice The amount of slippage that will be tolerated when depositing and withdrawing assets\n    ///         from the meta pool. In units of basis points.\n    uint256 public metaPoolSlippage;\n\n    /// @notice The convex token.\n    IConvexToken public immutable convexToken;\n\n    /// @notice The convex booster contract.\n    IConvexBooster public immutable convexBooster;\n\n    /// @notice The convex rewards contract.\n    IConvexRewards public immutable convexRewards;\n\n    /// @notice The convex pool identifier.\n    uint256 public immutable convexPoolId;\n\n    /// @dev A cache of the tokens that the stable swap pool supports.\n    IERC20[NUM_STABLE_COINS] private _threePoolAssetCache;\n\n    /// @dev A cache of the tokens that the meta pool supports.\n    IERC20[NUM_META_COINS] private _metaPoolAssetCache;\n\n    /// @dev A modifier which reverts if the message sender is not the admin.\n    modifier onlyAdmin() {\n        if (msg.sender != admin) {\n            revert Unauthorized(\"Not admin\");\n        }\n        _;\n    }\n\n    /// @dev A modifier which reverts if the message sender is not the operator.\n    modifier onlyOperator() {\n        if (msg.sender != operator) {\n            revert Unauthorized(\"Not operator\");\n        }\n        _;\n    }\n\n    constructor(InitializationParams memory params) {\n        admin             = params.admin;\n        operator          = params.operator;\n        rewardReceiver    = params.rewardReceiver;\n        transmuterBuffer  = params.transmuterBuffer;\n        curveToken        = params.curveToken;\n        threePool         = params.threePool;\n        metaPool          = params.metaPool;\n        threePoolSlippage = params.threePoolSlippage;\n        metaPoolSlippage  = params.metaPoolSlippage;\n        convexToken       = params.convexToken;\n        convexBooster     = params.convexBooster;\n        convexRewards     = params.convexRewards;\n        convexPoolId      = params.convexPoolId;\n\n        for (uint256 i = 0; i < NUM_STABLE_COINS; i++) {\n            _threePoolAssetCache[i] = params.threePool.coins(i);\n        }\n\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\n            _metaPoolAssetCache[i] = params.metaPool.coins(i);\n        }\n\n        emit AdminUpdated(admin);\n        emit OperatorUpdated(operator);\n        emit RewardReceiverUpdated(rewardReceiver);\n        emit TransmuterBufferUpdated(transmuterBuffer);\n        emit ThreePoolSlippageUpdated(threePoolSlippage);\n        emit MetaPoolSlippageUpdated(metaPoolSlippage);\n    }\n\n    /// @notice Gets the amount of meta pool tokens that this contract has in reserves.\n    ///\n    /// @return The reserves.\n    function metaPoolReserves() external view returns (uint256) {\n        return metaPool.balanceOf(address(this));\n    }\n\n    /// @notice Gets the amount of a 3pool asset that this contract has in reserves.\n    ///\n    /// @param asset The 3pool asset.\n    ///\n    /// @return The reserves.\n    function threePoolAssetReserves(ThreePoolAsset asset) external view returns (uint256) {\n        IERC20 token = getTokenForThreePoolAsset(asset);\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Gets the amount of a meta pool asset that this contract has in reserves.\n    ///\n    /// @param asset The meta pool asset.\n    ///\n    /// @return The reserves.\n    function metaPoolAssetReserves(MetaPoolAsset asset) external view returns (uint256) {\n        IERC20 token = getTokenForMetaPoolAsset(asset);\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Gets the amount of a 3pool asset that one alUSD is worth.\n    ///\n    /// @param asset The 3pool asset.\n    ///\n    /// @return The amount of the underying.\n    function exchangeRate(ThreePoolAsset asset) public view returns (uint256) {\n        IERC20 alUSD = getTokenForMetaPoolAsset(MetaPoolAsset.ALUSD);\n\n        uint256[NUM_META_COINS] memory metaBalances = metaPool.get_balances();\n        uint256 amountThreePool = metaPool.get_dy(\n            int128(uint128(uint256(MetaPoolAsset.ALUSD))),\n            int128(uint128(uint256(MetaPoolAsset.THREE_POOL))),\n            10**SafeERC20.expectDecimals(address(alUSD)),\n            metaBalances\n        );\n\n        return threePool.calc_withdraw_one_coin(amountThreePool, int128(uint128(uint256(asset))));\n    }\n\n    /// @dev Struct used to declare local variables for the calculate rebalance function.\n    struct CalculateRebalanceLocalVars {\n        uint256 minimum;\n        uint256 maximum;\n        uint256 minimumDistance;\n        uint256 minimizedBalance;\n        uint256 startingBalance;\n    }\n\n    /// @notice Calculates how much alUSD or 3pool needs to be added or removed from the metapool\n    ///         to reach a target exchange rate for a specified 3pool asset.\n    ///\n    /// @param rebalanceAsset      The meta pool asset to use to rebalance the pool.\n    /// @param targetExchangeAsset The 3pool asset to balance the price relative to.\n    /// @param targetExchangeRate  The target exchange rate.\n    ///\n    /// @return delta The amount of alUSD or 3pool that needs to be added or removed from the pool.\n    /// @return add   If the alUSD or 3pool needs to be removed or added.\n    function calculateRebalance(\n        MetaPoolAsset rebalanceAsset,\n        ThreePoolAsset targetExchangeAsset,\n        uint256 targetExchangeRate\n    ) public view returns (uint256 delta, bool add) {\n        uint256 decimals;\n        {\n            IERC20 alUSD = getTokenForMetaPoolAsset(MetaPoolAsset.ALUSD);\n            decimals     = SafeERC20.expectDecimals(address(alUSD));\n        }\n\n        uint256[NUM_META_COINS] memory startingBalances = metaPool.get_balances();\n        uint256[NUM_META_COINS] memory currentBalances  = [startingBalances[0], startingBalances[1]];\n\n        CalculateRebalanceLocalVars memory v;\n        v.minimum          = 0;\n        v.maximum          = type(uint96).max;\n        v.minimumDistance  = type(uint256).max;\n        v.minimizedBalance = type(uint256).max;\n        v.startingBalance  = startingBalances[uint256(rebalanceAsset)];\n\n        uint256 previousBalance;\n\n        for (uint256 i = 0; i < 256; i++) {\n            uint256 examineBalance;\n            if ((examineBalance = (v.maximum + v.minimum) / 2) == previousBalance) break;\n\n            currentBalances[uint256(rebalanceAsset)] = examineBalance;\n\n            uint256 amountThreePool = metaPool.get_dy(\n                int128(uint128(uint256(MetaPoolAsset.ALUSD))),\n                int128(uint128(uint256(MetaPoolAsset.THREE_POOL))),\n                10**decimals,\n                currentBalances\n            );\n\n            uint256 exchangeRate = threePool.calc_withdraw_one_coin(\n                amountThreePool,\n                int128(uint128(uint256(targetExchangeAsset)))\n            );\n\n            uint256 distance = abs(exchangeRate, targetExchangeRate);\n\n            if (distance < v.minimumDistance) {\n                v.minimumDistance  = distance;\n                v.minimizedBalance = examineBalance;\n            } else if(distance == v.minimumDistance) {\n                uint256 examineDelta = abs(examineBalance, v.startingBalance);\n                uint256 currentDelta = abs(v.minimizedBalance, v.startingBalance);\n                v.minimizedBalance = currentDelta > examineDelta ? examineBalance : v.minimizedBalance;\n            }\n\n            if (exchangeRate > targetExchangeRate) {\n                if (rebalanceAsset == MetaPoolAsset.ALUSD) {\n                    v.minimum = examineBalance;\n                } else {\n                    v.maximum = examineBalance;\n                }\n            } else {\n                if (rebalanceAsset == MetaPoolAsset.ALUSD) {\n                    v.maximum = examineBalance;\n                } else {\n                    v.minimum = examineBalance;\n                }\n            }\n\n            previousBalance = examineBalance;\n        }\n\n        return v.minimizedBalance > v.startingBalance\n            ? (v.minimizedBalance - v.startingBalance, true)\n            : (v.startingBalance - v.minimizedBalance, false);\n    }\n\n    /// @notice Gets the amount of curve tokens and convex tokens that can be claimed.\n    ///\n    /// @return amountCurve  The amount of curve tokens available.\n    /// @return amountConvex The amount of convex tokens available.\n    function claimableRewards() public view returns (uint256 amountCurve, uint256 amountConvex) {\n        amountCurve  = convexRewards.earned(address(this));\n        amountConvex = _getEarnedConvex(amountCurve);\n    }\n\n    /// @notice Gets the ERC20 token associated with a 3pool asset.\n    ///\n    /// @param asset The asset to get the token for.\n    ///\n    /// @return The token.\n    function getTokenForThreePoolAsset(ThreePoolAsset asset) public view returns (IERC20) {\n        uint256 index = uint256(asset);\n        if (index >= NUM_STABLE_COINS) {\n            revert IllegalArgument(\"Asset index out of bounds\");\n        }\n        return _threePoolAssetCache[index];\n    }\n\n    /// @notice Gets the ERC20 token associated with a meta pool asset.\n    ///\n    /// @param asset The asset to get the token for.\n    ///\n    /// @return The token.\n    function getTokenForMetaPoolAsset(MetaPoolAsset asset) public view returns (IERC20) {\n        uint256 index = uint256(asset);\n        if (index >= NUM_META_COINS) {\n            revert IllegalArgument(\"Asset index out of bounds\");\n        }\n        return _metaPoolAssetCache[index];\n    }\n\n    /// @notice Begins the 2-step process of setting the administrator.\n    ///\n    /// The caller must be the admin. Setting the pending timelock to the zero address will stop\n    /// the process of setting a new timelock.\n    ///\n    /// @param value The value to set the pending timelock to.\n    function setPendingAdmin(address value) external onlyAdmin {\n        pendingAdmin = value;\n        emit PendingAdminUpdated(value);\n    }\n\n    /// @notice Completes the 2-step process of setting the administrator.\n    ///\n    /// The pending admin must be set and the caller must be the pending admin. After this function\n    /// is successfully executed, the admin will be set to the pending admin and the pending admin\n    /// will be reset.\n    function acceptAdmin() external {\n        if (pendingAdmin == address(0)) {\n            revert IllegalState(\"Pending admin unset\");\n        }\n\n        if (pendingAdmin != msg.sender) {\n            revert Unauthorized(\"Not pending admin\");\n        }\n\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n\n        emit AdminUpdated(admin);\n        emit PendingAdminUpdated(address(0));\n    }\n\n    /// @notice Sets the operator.\n    ///\n    /// The caller must be the admin.\n    ///\n    /// @param value The value to set the admin to.\n    function setOperator(address value) external onlyAdmin {\n        operator = value;\n        emit OperatorUpdated(value);\n    }\n\n    /// @notice Sets the reward receiver.\n    ///\n    /// @param value The value to set the reward receiver to.\n    function setRewardReceiver(address value) external onlyAdmin {\n        rewardReceiver = value;\n        emit RewardReceiverUpdated(value);\n    }\n\n    /// @notice Sets the transmuter buffer.\n    ///\n    /// @param value The value to set the transmuter buffer to.\n    function setTransmuterBuffer(address value) external onlyAdmin {\n        transmuterBuffer = value;\n        emit TransmuterBufferUpdated(value);\n    }\n\n    /// @notice Sets the slippage that will be tolerated when depositing and withdrawing 3pool\n    ///         assets. The slippage has a resolution of 6 decimals.\n    ///\n    /// The operator is allowed to set the slippage because it is a volatile parameter that may need\n    /// fine adjustment in a short time window.\n    ///\n    /// @param value The value to set the slippage to.\n    function setThreePoolSlippage(uint256 value) external onlyOperator {\n        if (value > SLIPPAGE_PRECISION) {\n            revert IllegalArgument(\"Slippage not in range\");\n        }\n        threePoolSlippage = value;\n        emit ThreePoolSlippageUpdated(value);\n    }\n\n    /// @notice Sets the slippage that will be tolerated when depositing and withdrawing meta pool\n    ///         assets. The slippage has a resolution of 6 decimals.\n    ///\n    /// The operator is allowed to set the slippage because it is a volatile parameter that may need\n    /// fine adjustment in a short time window.\n    ///\n    /// @param value The value to set the slippage to.\n    function setMetaPoolSlippage(uint256 value) external onlyOperator {\n        if (value > SLIPPAGE_PRECISION) {\n            revert IllegalArgument(\"Slippage not in range\");\n        }\n        metaPoolSlippage = value;\n        emit MetaPoolSlippageUpdated(value);\n    }\n\n    /// @notice Mints 3pool tokens with a combination of assets.\n    ///\n    /// @param amounts The amounts of the assets to deposit.\n    ///\n    /// @return minted The number of 3pool tokens minted.\n    function mintThreePoolTokens(\n        uint256[NUM_STABLE_COINS] calldata amounts\n    ) external lock onlyOperator returns (uint256 minted) {\n        return _mintThreePoolTokens(amounts);\n    }\n\n    /// @notice Mints 3pool tokens with an asset.\n    ///\n    /// @param asset  The asset to deposit into the 3pool.\n    /// @param amount The amount of the asset to deposit.\n    ///\n    /// @return minted The number of 3pool tokens minted.\n    function mintThreePoolTokens(\n        ThreePoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256 minted) {\n        return _mintThreePoolTokens(asset, amount);\n    }\n\n    /// @notice Burns 3pool tokens to withdraw an asset.\n    ///\n    /// @param asset  The asset to withdraw.\n    /// @param amount The amount of 3pool tokens to burn.\n    ///\n    /// @return withdrawn The amount of the asset withdrawn from the pool.\n    function burnThreePoolTokens(\n        ThreePoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256 withdrawn) {\n        return _burnThreePoolTokens(asset, amount);\n    }\n\n    /// @notice Mints meta pool tokens with a combination of assets.\n    ///\n    /// @param amounts The amounts of the assets to deposit.\n    ///\n    /// @return minted The number of meta pool tokens minted.\n    function mintMetaPoolTokens(\n        uint256[NUM_META_COINS] calldata amounts\n    ) external lock onlyOperator returns (uint256 minted) {\n        return _mintMetaPoolTokens(amounts);\n    }\n\n    /// @notice Mints meta pool tokens with an asset.\n    ///\n    /// @param asset  The asset to deposit into the meta pool.\n    /// @param amount The amount of the asset to deposit.\n    ///\n    /// @return minted The number of meta pool tokens minted.\n    function mintMetaPoolTokens(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256 minted) {\n        return _mintMetaPoolTokens(asset, amount);\n    }\n\n    /// @notice Burns meta pool tokens to withdraw an asset.\n    ///\n    /// @param asset  The asset to withdraw.\n    /// @param amount The amount of meta pool tokens to burn.\n    ///\n    /// @return withdrawn The amount of the asset withdrawn from the pool.\n    function burnMetaPoolTokens(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256 withdrawn) {\n        return _burnMetaPoolTokens(asset, amount);\n    }\n\n    /// @notice Deposits and stakes meta pool tokens into convex.\n    ///\n    /// @param amount The amount of meta pool tokens to deposit.\n    ///\n    /// @return success If the tokens were successfully deposited.\n    function depositMetaPoolTokens(\n        uint256 amount\n    ) external lock onlyOperator returns (bool success) {\n        return _depositMetaPoolTokens(amount);\n    }\n\n    /// @notice Withdraws and unwraps meta pool tokens from convex.\n    ///\n    /// @param amount The amount of meta pool tokens to withdraw.\n    ///\n    /// @return success If the tokens were successfully withdrawn.\n    function withdrawMetaPoolTokens(\n        uint256 amount\n    ) external lock onlyOperator returns (bool success) {\n        return _withdrawMetaPoolTokens(amount);\n    }\n\n    /// @notice Claims convex, curve, and auxiliary rewards.\n    ///\n    /// @return success If the claim was successful.\n    function claimRewards() external lock onlyOperator returns (bool success) {\n        success = convexRewards.getReward();\n\n        uint256 curveBalance  = curveToken.balanceOf(address(this));\n        uint256 convexBalance = convexToken.balanceOf(address(this));\n\n        SafeERC20.safeTransfer(address(curveToken), rewardReceiver, curveBalance);\n        SafeERC20.safeTransfer(address(convexToken), rewardReceiver, convexBalance);\n\n        emit ClaimRewards(success, curveBalance, convexBalance);\n    }\n\n    /// @notice Flushes three pool assets into convex by minting 3pool tokens from the assets,\n    ///         minting meta pool tokens using the 3pool tokens, and then depositing the meta pool\n    ///         tokens into convex.\n    ///\n    /// This function is provided for ease of use.\n    ///\n    /// @param amounts The amounts of the 3pool assets to flush.\n    ///\n    /// @return The amount of meta pool tokens deposited into convex.\n    function flush(\n        uint256[NUM_STABLE_COINS] calldata amounts\n    ) external lock onlyOperator returns (uint256) {\n        uint256 mintedThreePoolTokens = _mintThreePoolTokens(amounts);\n\n        uint256 mintedMetaPoolTokens = _mintMetaPoolTokens(\n            MetaPoolAsset.THREE_POOL,\n            mintedThreePoolTokens\n        );\n\n        if (!_depositMetaPoolTokens(mintedMetaPoolTokens)) {\n            revert IllegalState(\"Deposit into convex failed\");\n        }\n\n        return mintedMetaPoolTokens;\n    }\n\n    /// @notice Flushes a three pool asset into convex by minting 3pool tokens using the asset,\n    ///         minting meta pool tokens using the 3pool tokens, and then depositing the meta pool\n    ///         tokens into convex.\n    ///\n    /// This function is provided for ease of use.\n    ///\n    /// @param asset  The 3pool asset to flush.\n    /// @param amount The amount of the 3pool asset to flush.\n    ///\n    /// @return The amount of meta pool tokens deposited into convex.\n    function flush(\n        ThreePoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256) {\n        uint256 mintedThreePoolTokens = _mintThreePoolTokens(asset, amount);\n\n        uint256 mintedMetaPoolTokens = _mintMetaPoolTokens(\n            MetaPoolAsset.THREE_POOL,\n            mintedThreePoolTokens\n        );\n\n        if (!_depositMetaPoolTokens(mintedMetaPoolTokens)) {\n            revert IllegalState(\"Deposit into convex failed\");\n        }\n\n        return mintedMetaPoolTokens;\n    }\n\n    /// @notice Recalls a three pool asset into reserves by withdrawing meta pool tokens from\n    ///         convex, burning the meta pool tokens for 3pool tokens, and then burning the 3pool\n    ///         tokens for an asset.\n    ///\n    /// This function is provided for ease of use.\n    ///\n    /// @param asset  The 3pool asset to recall.\n    /// @param amount The amount of the meta pool tokens to withdraw from convex and burn.\n    ///\n    /// @return The amount of the 3pool asset recalled.\n    function recall(\n        ThreePoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256) {\n        if (!_withdrawMetaPoolTokens(amount)) {\n            revert IllegalState(\"Withdraw from convex failed\");\n        }\n        uint256 withdrawnThreePoolTokens = _burnMetaPoolTokens(MetaPoolAsset.THREE_POOL, amount);\n        return _burnThreePoolTokens(asset, withdrawnThreePoolTokens);\n    }\n\n    /// @notice Reclaims a three pool asset to the transmuter buffer.\n    ///\n    /// @param asset  The 3pool asset to reclaim.\n    /// @param amount The amount to reclaim.\n    function reclaimThreePoolAsset(ThreePoolAsset asset, uint256 amount) public lock onlyAdmin {\n        IERC20 token = getTokenForThreePoolAsset(asset);\n        SafeERC20.safeTransfer(address(token), transmuterBuffer, amount);\n\n        IERC20TokenReceiver(transmuterBuffer).onERC20Received(address(token), amount);\n\n        emit ReclaimThreePoolAsset(asset, amount);\n    }\n\n    /// @notice Sweeps a token out of the contract to the admin.\n    ///\n    /// @param token  The token to sweep.\n    /// @param amount The amount of the token to sweep.\n    function sweep(address token, uint256 amount) external lock onlyAdmin {\n        SafeERC20.safeTransfer(address(token), msg.sender, amount);\n    }\n\n    /// @inheritdoc IERC20TokenReceiver\n    ///\n    /// @dev This function is required in order to receive tokens from the conduit.\n    function onERC20Received(address token, uint256 value) external { /* noop */ }\n\n    /// @dev Gets the amount of convex that will be minted for an amount of curve tokens.\n    ///\n    /// @param amountCurve The amount of curve tokens.\n    ///\n    /// @return The amount of convex tokens.\n    function _getEarnedConvex(uint256 amountCurve) internal view returns (uint256) {\n        uint256 supply      = convexToken.totalSupply();\n        uint256 cliff       = supply / convexToken.reductionPerCliff();\n        uint256 totalCliffs = convexToken.totalCliffs();\n\n        if (cliff >= totalCliffs) return 0;\n\n        uint256 reduction = totalCliffs - cliff;\n        uint256 earned    = amountCurve * reduction / totalCliffs;\n\n        uint256 available = convexToken.maxSupply() - supply;\n        return earned > available ? available : earned;\n    }\n\n    /// @dev Mints 3pool tokens with a combination of assets.\n    ///\n    /// @param amounts The amounts of the assets to deposit.\n    ///\n    /// @return minted The number of 3pool tokens minted.\n    function _mintThreePoolTokens(\n        uint256[NUM_STABLE_COINS] calldata amounts\n    ) internal returns (uint256 minted) {\n        IERC20[NUM_STABLE_COINS] memory tokens = _threePoolAssetCache;\n\n        IERC20 threePoolToken = getTokenForMetaPoolAsset(MetaPoolAsset.THREE_POOL);\n\n        uint256 threePoolDecimals = SafeERC20.expectDecimals(address(threePoolToken));\n        uint256 normalizedTotal   = 0;\n\n        for (uint256 i = 0; i < NUM_STABLE_COINS; i++) {\n            if (amounts[i] == 0) continue;\n\n            uint256 tokenDecimals   = SafeERC20.expectDecimals(address(tokens[i]));\n            uint256 missingDecimals = threePoolDecimals - tokenDecimals;\n\n            normalizedTotal += amounts[i] * 10**missingDecimals;\n\n            // For assets like USDT, the approval must be first set to zero before updating it.\n            SafeERC20.safeApprove(address(tokens[i]), address(threePool), 0);\n            SafeERC20.safeApprove(address(tokens[i]), address(threePool), amounts[i]);\n        }\n\n        // Calculate what the normalized value of the tokens is.\n        uint256 expectedOutput = normalizedTotal * CURVE_PRECISION / threePool.get_virtual_price();\n\n        // Calculate the minimum amount of 3pool lp tokens that we are expecting out when\n        // adding liquidity for all of the assets. This value is based off the optimistic\n        // assumption that one of each token is approximately equal to one 3pool lp token.\n        uint256 minimumMintAmount = expectedOutput * threePoolSlippage / SLIPPAGE_PRECISION;\n\n        // Record the amount of 3pool lp tokens that we start with before adding liquidity\n        // so that we can determine how many we minted.\n        uint256 startingBalance = threePoolToken.balanceOf(address(this));\n\n        // Add the liquidity to the pool.\n        threePool.add_liquidity(amounts, minimumMintAmount);\n\n        // Calculate how many 3pool lp tokens were minted.\n        minted = threePoolToken.balanceOf(address(this)) - startingBalance;\n\n        emit MintThreePoolTokens(amounts, minted);\n    }\n\n    /// @dev Mints 3pool tokens with an asset.\n    ///\n    /// @param asset  The asset to deposit into the 3pool.\n    /// @param amount The amount of the asset to deposit.\n    ///\n    /// @return minted The number of 3pool tokens minted.\n    function _mintThreePoolTokens(\n        ThreePoolAsset asset,\n        uint256 amount\n    ) internal returns (uint256 minted) {\n        IERC20 token          = getTokenForThreePoolAsset(asset);\n        IERC20 threePoolToken = getTokenForMetaPoolAsset(MetaPoolAsset.THREE_POOL);\n\n        uint256 threePoolDecimals = SafeERC20.expectDecimals(address(threePoolToken));\n        uint256 missingDecimals   = threePoolDecimals - SafeERC20.expectDecimals(address(token));\n\n        uint256[NUM_STABLE_COINS] memory amounts;\n        amounts[uint256(asset)] = amount;\n\n        // Calculate the minimum amount of 3pool lp tokens that we are expecting out when\n        // adding single sided liquidity. This value is based off the optimistic assumption that\n        // one of each token is approximately equal to one 3pool lp token.\n        uint256 normalizedAmount  = amount * 10**missingDecimals;\n        uint256 expectedOutput    = normalizedAmount * CURVE_PRECISION / threePool.get_virtual_price();\n        uint256 minimumMintAmount = expectedOutput * threePoolSlippage / SLIPPAGE_PRECISION;\n\n        // Record the amount of 3pool lp tokens that we start with before adding liquidity\n        // so that we can determine how many we minted.\n        uint256 startingBalance = threePoolToken.balanceOf(address(this));\n\n        // For asset"
    }
  ]
}