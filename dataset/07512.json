{
  "Title": "[M-13] Ownership of EscherERC721.sol contracts can be changed, thus creator roles become useless",
  "Content": "\n<https://github.com/code-423n4/2022-12-escher/blob/main/src/Escher.sol#L11>\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/65420cb9c943c32eb7e8c9da60183a413d90067a/contracts/access/AccessControlUpgradeable.sol#L150>\n\n<https://github.com/code-423n4/2022-12-escher/blob/main/src/Escher721Factory.sol#L32>\n\n### Impact\n\n(\ncreator = has a CREATOR_ROLE in Escher.sol\n\nnon-creator = doesn't have a CREATOR_ROLE in Escher.sol\n)\n\nCurrently creating an ERC721 edition via the `Escher721Factory.sol` contract requires a user to have the `CREATOR_ROLE` in the main `Escher.sol` contract.\n\nThis requirement would mean that only users with the aforementioned role can be admins of editions. This requirement can be bypassed by having a 'malicious' creator create an edition for someone who doesn't have the  `CREATOR_ROLE` set by creating the edition and granting the `DEFAULT_ADMIN_ROLE` to the non-creator via AccessControl.sol's `grantRole()` function. This way the non-creator can revoke the original creator's roles in this edition and gain full ownership. Now this non-creator admin can create sales and operate as if he/she was a creator.\n\nThis defeats the point of having a role for creators and makes this function of the protocol not as described == faulty.\n\n### Proof of Concept\n\nA creator can benefit from his role by taking in payments for creating ERC721 editions for other people. This would make sense so that his risk can be covered.\n\n1.  A creator gets onboarded to Escher.\n2.  For some time he stays good but then people start offering payments for edition ownership\n3.  The more creators there are in Escher, the less of a chance to get caught. But then again, the more inclusive Escher gets, the more people will pay to get their own edition, which makes this pretty dangerous\n4.  This creator creates an edition with the payer's inputs and grants the payer the DEFAULT_ADMIN_ROLE\n5.  Payer revokes all of the creator's roles and becomes the new admin\n\nYou can edit the Escher721.t.sol file to look like this and then run the test normally, everything should go through without errors:\n\n    // SPDX-License-Identifier: MIT\n    pragma solidity ^0.8.17;\n\n    import \"forge-std/Test.sol\";\n    import {EscherTest} from \"./utils/EscherTest.sol\";\n\n    contract Escher721Test is EscherTest {\n        function setUp() public override {\n            super.setUp();\n        }\n        function test_grantRoles() public {\n            address _this = address(this);\n            // Malicious creator grants someone else the rights for this edition\n            edition.grantRole(bytes32(0x0), address(9));\n            vm.prank(address(9));\n            // Now this user can grant/revoke roles\n            edition.grantRole(edition.MINTER_ROLE(), address(9));\n            assertEq(edition.hasRole(bytes32(0x0), address(9)), true);\n            // clean out the partner\n            edition.revokeRole(bytes32(0x0), _this);\n            assertEq(edition.hasRole(bytes32(0x0), _this), false);\n        }\n    }\n\nThis kind of attack/abuse is currently hard to track. There is no centralized database of created editions and their admins at the time of creations (i.e. a mapping). This makes it hard to track down malicious creators who create editions for other people. Looping through the emitted events and comparing current admins to the emitted admins is a hassle especially if this protocol gains a lot of traction in the future which I assume is the end goal here.\n\n### Tools Used\n\nVS Code, Forge\n\n### Recommended Mitigation Steps\n\nIn `EscherERC721.sol` implementation contract, it is recommended to override the `grantRole()` function of `AccessControlUpgradeable.sol` with something like:\n\n    function grantRole(bytes32 role, address account) internal override {\n        revert(\"Admins can't be chagned\");\n    }\n\nThis will disable the granting of roles after initialization. The initialization function already has the required granting of roles done and they cannot be changed after this fix.\n\nOverall it would be recommended to store the created editions in a mapping for example to prevent problems like these.\n\n**[stevennevins (Escher) confirmed](https://github.com/code-423n4/2022-12-escher-findings/issues/521)** \n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-escher-contest",
  "Code": [
    {
      "filename": "src/Escher.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ERC1155} from \"openzeppelin/token/ERC1155/ERC1155.sol\";\nimport {AccessControl} from \"openzeppelin/access/AccessControl.sol\";\n\n/// @title Escher\n/// @notice Escher is a decentralized curated marketplace for editionized artworks\ncontract Escher is ERC1155, AccessControl {\n    /// @notice The role that grants the ability to mint editions\n    bytes32 public constant CREATOR_ROLE = keccak256(\"CREATOR_ROLE\");\n    /// @notice the role that grants the ability to onboard creators\n    bytes32 public constant CURATOR_ROLE = keccak256(\"CURATOR_ROLE\");\n\n    constructor() ERC1155(\"\") {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /// @notice Updates the metadata for Escher Solbound token\n    /// @param _newuri The new metadata URI\n    function setURI(string memory _newuri) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setURI(_newuri);\n    }\n\n    /// @notice Adds a new creator to Escher\n    /// @param _account The creator's account to onboard\n    function addCreator(address _account) public onlyRole(CURATOR_ROLE) {\n        _grantRole(CREATOR_ROLE, _account);\n    }\n\n    function supportsInterface(\n        bytes4 _interfaceId\n    ) public view override(ERC1155, AccessControl) returns (bool) {\n        return super.supportsInterface(_interfaceId);\n    }\n\n    /// @notice SoulBound\n    function safeTransferFrom(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public pure override {\n        revert(\"SoulBound\");\n    }\n\n    /// @notice SoulBound\n    function safeBatchTransferFrom(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public pure override {\n        revert(\"SoulBound\");\n    }\n\n    /// @notice Receive a role, get a token\n    function _grantRole(bytes32 _role, address _account) internal override {\n        require(balanceOf(_account, uint256(_role)) == 0, \"Already Creator\");\n        super._grantRole(_role, _account);\n        _mint(_account, uint256(_role), 1, \"0x0\");\n    }\n\n    /// @notice Lose a role, burn a token\n    function _revokeRole(bytes32 _role, address _account) internal override {\n        super._revokeRole(_role, _account);\n        _burn(_account, uint256(_role), balanceOf(_account, uint256(_role)));\n    }\n}"
    },
    {
      "filename": "contracts/access/AccessControlUpgradeable.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(account),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}"
    },
    {
      "filename": "src/Escher721Factory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {Escher} from \"./Escher.sol\";\nimport {Escher721} from \"./Escher721.sol\";\nimport {Clones} from \"openzeppelin/proxy/Clones.sol\";\nimport {ITokenUriDelegate} from \"./interfaces/ITokenUriDelegate.sol\";\n\ncontract Escher721Factory {\n    using Clones for address;\n\n    Escher public immutable escher;\n    address public immutable implementation;\n\n    event NewEscher721Contract(address indexed creator, address indexed clone, address indexed uri);\n\n    constructor(address _escher) {\n        escher = Escher(_escher);\n        implementation = address(new Escher721());\n        Escher721(implementation).initialize(address(this), address(0), \"Implementation\", \"IMPL\");\n    }\n\n    /// @notice create a new escher unique contract\n    /// @param _name the name of the contract\n    /// @param _symbol the symbol of the contract\n    /// @param _uri the uri delegate contract\n    function createContract(\n        string memory _name,\n        string memory _symbol,\n        address _uri\n    ) external returns (address escherClone) {\n        require(escher.hasRole(escher.CREATOR_ROLE(), msg.sender), \"NOT AUTHORIZED\");\n\n        escherClone = implementation.clone();\n        address uriClone = _uri.clone();\n\n        Escher721(escherClone).initialize(msg.sender, uriClone, _name, _symbol);\n        ITokenUriDelegate(uriClone).initialize(msg.sender);\n\n        emit NewEscher721Contract(msg.sender, escherClone, uriClone);\n    }\n}"
    }
  ]
}