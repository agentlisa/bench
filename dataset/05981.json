{
  "Title": "[M-10] The `ContinuousGDA` implementation is incorrect leading to liquidation auctions running at the wrong price",
  "Content": "\n<https://github.com/GenerationSoftware/pt-v5-cgda-liquidator/blob/7f95bcacd4a566c2becb98d55c1886cadbaa8897/src/libraries/ContinuousGDA.sol#L39-L41><br>\n<https://github.com/GenerationSoftware/pt-v5-cgda-liquidator/blob/7f95bcacd4a566c2becb98d55c1886cadbaa8897/src/libraries/ContinuousGDA.sol#L65><br>\n<https://github.com/GenerationSoftware/pt-v5-cgda-liquidator/blob/7f95bcacd4a566c2becb98d55c1886cadbaa8897/src/libraries/ContinuousGDA.sol#L86>\n\nThe `LiquidationPair` contract facilitates Periodic Continuous Gradual Dutch Auctions for yield. This uses the underlying `ContinuousGDA.sol` library in order to correctly price the auctions.\n\nHowever this library incorrectly implements the formula, using the emission rate in a few places where it should use the decay constant. Since the decay constant is usually less than the emission rate (as can also be seen from the test suite), this means that the `purchasePrice` calculation is lower than it should be, meaning that liquidations are over-incentivised.\n\n### Proof of Concept\n\nThis is difficult to demonstrate given the issue is basically just that the formula in <https://www.paradigm.xyz/2022/04/gda> has been wrongly implemented. However I'll point out a few issues in the code:\n\n      function purchasePrice(\n        SD59x18 _amount,\n        SD59x18 _emissionRate,\n        SD59x18 _k,\n        SD59x18 _decayConstant,\n        SD59x18 _timeSinceLastAuctionStart\n      ) internal pure returns (SD59x18) {\n        if (_amount.unwrap() == 0) {\n          return SD59x18.wrap(0);\n        }\n        SD59x18 topE = _decayConstant.mul(_amount).div(_emissionRate);\n        topE = topE.exp().sub(ONE);\n        SD59x18 bottomE = _decayConstant.mul(_timeSinceLastAuctionStart);\n        bottomE = bottomE.exp();\n        SD59x18 result;\n        if (_emissionRate.unwrap() > 1e18) {\n          result = _k.div(_emissionRate).mul(topE).div(bottomE);\n        } else {\n          result = _k.mul(topE.div(_emissionRate.mul(bottomE)));\n        }\n        return result;\n      }\n\nIn the `result` calculation you can see that `_k` is divided by `_emissionRate`. However, according to the proper formula, `_k` should be divided by `_decayConstant`.\n\nAnother issue occurs in `purchaseAmount` where `_k` is added to `lnParam` instead of ONE and `price` is multiplied by `_emissionRate` instead of `_decayConstant`:\n\n      function purchaseAmount(\n        SD59x18 _price,\n        SD59x18 _emissionRate,\n        SD59x18 _k,\n        SD59x18 _decayConstant,\n        SD59x18 _timeSinceLastAuctionStart\n      ) internal pure returns (SD59x18) {\n        if (_price.unwrap() == 0) {\n          return SD59x18.wrap(0);\n        }\n        SD59x18 exp = _decayConstant.mul(_timeSinceLastAuctionStart).exp();\n        SD59x18 lnParam = _k.add(_price.mul(_emissionRate).mul(exp)).div(_k);\n        SD59x18 numerator = _emissionRate.mul(lnParam.ln());\n        SD59x18 amount = numerator.div(_decayConstant);\n        return amount;\n      }\n\nI would suggest double checking the formula and the derivation of the complementary formulas to calculate amount/k. The correct implementation is show in the diff below.\n\n### Recommended Mitigation Steps\n\nThe implementation should be updated to correctly calculate the price for a continuous GDA. I have made the required fixes in the diff below:\n\n```\ndiff --git a/src/libraries/ContinuousGDA.sol b/src/libraries/ContinuousGDA.sol\nindex 721d626..7e2bb61 100644\n--- a/src/libraries/ContinuousGDA.sol\n+++ b/src/libraries/ContinuousGDA.sol\n@@ -36,9 +36,9 @@ library ContinuousGDA {\n     bottomE = bottomE.exp();\n     SD59x18 result;\n     if (_emissionRate.unwrap() > 1e18) {\n-      result = _k.div(_emissionRate).mul(topE).div(bottomE);\n+      result = _k.div(_decayConstant).mul(topE).div(bottomE);\n     } else {\n-      result = _k.mul(topE.div(_emissionRate.mul(bottomE)));\n+      result = _k.mul(topE.div(_decayConstant.mul(bottomE)));\n     }\n     return result;\n   }\n@@ -62,7 +62,7 @@ library ContinuousGDA {\n       return SD59x18.wrap(0);\n     }\n     SD59x18 exp = _decayConstant.mul(_timeSinceLastAuctionStart).exp();\n-    SD59x18 lnParam = _k.add(_price.mul(_emissionRate).mul(exp)).div(_k);\n+    SD59x18 lnParam = ONE.add(_price.mul(_decayConstant).mul(exp)).div(_k);\n     SD59x18 numerator = _emissionRate.mul(lnParam.ln());\n     SD59x18 amount = numerator.div(_decayConstant);\n     return amount;\n@@ -83,7 +83,7 @@ library ContinuousGDA {\n   ) internal pure returns (SD59x18) {\n     SD59x18 exponent = _decayConstant.mul(_targetFirstSaleTime);\n     SD59x18 eValue = exponent.exp();\n-    SD59x18 multiplier = _emissionRate.mul(_price);\n+    SD59x18 multiplier = _decayConstant.mul(_price);\n     SD59x18 denominator = (_decayConstant.mul(_purchaseAmount).div(_emissionRate)).exp().sub(ONE);\n     SD59x18 result = eValue.div(denominator);\n     return result.mul(multiplier);\n\n```\n\n### Assessed type\n\nMath\n\n**[RaymondFam (Lookout) commented](https://github.com/code-423n4/2023-08-pooltogether-findings/issues/24#issuecomment-1668806578):**\n > The formula in the doc is just one of many different price functions the protocol can work on. \n\n**[asselstine (PoolTogether) confirmed](https://github.com/code-423n4/2023-08-pooltogether-findings/issues/24#issuecomment-1671999963)**\n\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2023-08-pooltogether-findings/issues/24#issuecomment-1676632025):**\n > I agree that the pricing formula is up to the project to figure out and implement; it doesn't necessarily have to be the one Paradigm laid out in their blog post.\n> \n> Nevertheless, the sponsor confirmed the issue, so I will leave it as that.\n> \n> IMO the issue's severity can be raised to High, but I'd have liked to see further proof of price deviations to justify the higher severity. =\\)\n> \n> I suggest explicitly stating out what the intended pricing formula is, so that wardens can verify the implementation's correctness. Right now, it's guesswork.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-08-pooltogether",
  "Code": [
    {
      "filename": "src/libraries/ContinuousGDA.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport { SD59x18, convert, unwrap } from \"prb-math/SD59x18.sol\";\n\n/// @title ContinuousGDA\n/// @author G9 Software Inc.\n/// @notice Implements the Continous Gradual Dutch Auction formula\n/// See https://www.paradigm.xyz/2022/04/gda\n/// @dev Pricing formula adapted from https://github.com/FrankieIsLost/gradual-dutch-auction/blob/master/src/ContinuousGDA.sol\nlibrary ContinuousGDA {\n\n  /// @notice a helpful constant\n  SD59x18 internal constant ONE = SD59x18.wrap(1e18);\n\n  /// @notice Calculate purchase price for a given amount of tokens\n  /// @param _amount The amount of tokens to purchase\n  /// @param _emissionRate The emission rate of the CGDA\n  /// @param _k The initial price of the CGDA\n  /// @param _decayConstant The decay constant of the CGDA\n  /// @param _timeSinceLastAuctionStart The elapsed time since the last consumed timestamp\n  /// @return The purchase price for the given amount of tokens\n  function purchasePrice(\n    SD59x18 _amount,\n    SD59x18 _emissionRate,\n    SD59x18 _k,\n    SD59x18 _decayConstant,\n    SD59x18 _timeSinceLastAuctionStart\n  ) internal pure returns (SD59x18) {\n    if (_amount.unwrap() == 0) {\n      return SD59x18.wrap(0);\n    }\n    SD59x18 topE = _decayConstant.mul(_amount).div(_emissionRate);\n    topE = topE.exp().sub(ONE);\n    SD59x18 bottomE = _decayConstant.mul(_timeSinceLastAuctionStart);\n    bottomE = bottomE.exp();\n    SD59x18 result;\n    if (_emissionRate.unwrap() > 1e18) {\n      result = _k.div(_emissionRate).mul(topE).div(bottomE);\n    } else {\n      result = _k.mul(topE.div(_emissionRate.mul(bottomE)));\n    }\n    return result;\n  }\n\n  /// @notice Computes the amount of tokens that can be purchased for a given price\n  /// @dev Note that this formula has significant floating point differences to the above. Either one, not both, should be used.\n  /// @param _price The price willing to be paid\n  /// @param _emissionRate The emission rate of the CGDA\n  /// @param _k The initial price of the CGDA\n  /// @param _decayConstant The decay constant of the CGDA\n  /// @param _timeSinceLastAuctionStart The elapsed time since the last consumed timestamp\n  /// @return The number of tokens that can be purchased for the given price\n  function purchaseAmount(\n    SD59x18 _price,\n    SD59x18 _emissionRate,\n    SD59x18 _k,\n    SD59x18 _decayConstant,\n    SD59x18 _timeSinceLastAuctionStart\n  ) internal pure returns (SD59x18) {\n    if (_price.unwrap() == 0) {\n      return SD59x18.wrap(0);\n    }\n    SD59x18 exp = _decayConstant.mul(_timeSinceLastAuctionStart).exp();\n    SD59x18 lnParam = _k.add(_price.mul(_emissionRate).mul(exp)).div(_k);\n    SD59x18 numerator = _emissionRate.mul(lnParam.ln());\n    SD59x18 amount = numerator.div(_decayConstant);\n    return amount;\n  }\n\n  /// @notice Computes an initial price for the CGDA such that the purchase amount will cost the price at the given timestamp\n  /// @param _emissionRate The emission rate of the CGDA\n  /// @param _decayConstant The decay constant of the CGDA\n  /// @param _targetFirstSaleTime The timestamp at which the CGDA price for the given amount matches the given price\n  /// @param _purchaseAmount The amount of tokens to purchase\n  /// @param _price The price to be paid for the amount of tokens\n  function computeK(\n    SD59x18 _emissionRate,\n    SD59x18 _decayConstant,\n    SD59x18 _targetFirstSaleTime,\n    SD59x18 _purchaseAmount,\n    SD59x18 _price\n  ) internal pure returns (SD59x18) {\n    SD59x18 exponent = _decayConstant.mul(_targetFirstSaleTime);\n    SD59x18 eValue = exponent.exp();\n    SD59x18 multiplier = _emissionRate.mul(_price);\n    SD59x18 denominator = (_decayConstant.mul(_purchaseAmount).div(_emissionRate)).exp().sub(ONE);\n    SD59x18 result = eValue.div(denominator);\n    return result.mul(multiplier);\n  }\n}"
    },
    {
      "filename": "src/libraries/ContinuousGDA.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport { SD59x18, convert, unwrap } from \"prb-math/SD59x18.sol\";\n\n/// @title ContinuousGDA\n/// @author G9 Software Inc.\n/// @notice Implements the Continous Gradual Dutch Auction formula\n/// See https://www.paradigm.xyz/2022/04/gda\n/// @dev Pricing formula adapted from https://github.com/FrankieIsLost/gradual-dutch-auction/blob/master/src/ContinuousGDA.sol\nlibrary ContinuousGDA {\n\n  /// @notice a helpful constant\n  SD59x18 internal constant ONE = SD59x18.wrap(1e18);\n\n  /// @notice Calculate purchase price for a given amount of tokens\n  /// @param _amount The amount of tokens to purchase\n  /// @param _emissionRate The emission rate of the CGDA\n  /// @param _k The initial price of the CGDA\n  /// @param _decayConstant The decay constant of the CGDA\n  /// @param _timeSinceLastAuctionStart The elapsed time since the last consumed timestamp\n  /// @return The purchase price for the given amount of tokens\n  function purchasePrice(\n    SD59x18 _amount,\n    SD59x18 _emissionRate,\n    SD59x18 _k,\n    SD59x18 _decayConstant,\n    SD59x18 _timeSinceLastAuctionStart\n  ) internal pure returns (SD59x18) {\n    if (_amount.unwrap() == 0) {\n      return SD59x18.wrap(0);\n    }\n    SD59x18 topE = _decayConstant.mul(_amount).div(_emissionRate);\n    topE = topE.exp().sub(ONE);\n    SD59x18 bottomE = _decayConstant.mul(_timeSinceLastAuctionStart);\n    bottomE = bottomE.exp();\n    SD59x18 result;\n    if (_emissionRate.unwrap() > 1e18) {\n      result = _k.div(_emissionRate).mul(topE).div(bottomE);\n    } else {\n      result = _k.mul(topE.div(_emissionRate.mul(bottomE)));\n    }\n    return result;\n  }\n\n  /// @notice Computes the amount of tokens that can be purchased for a given price\n  /// @dev Note that this formula has significant floating point differences to the above. Either one, not both, should be used.\n  /// @param _price The price willing to be paid\n  /// @param _emissionRate The emission rate of the CGDA\n  /// @param _k The initial price of the CGDA\n  /// @param _decayConstant The decay constant of the CGDA\n  /// @param _timeSinceLastAuctionStart The elapsed time since the last consumed timestamp\n  /// @return The number of tokens that can be purchased for the given price\n  function purchaseAmount(\n    SD59x18 _price,\n    SD59x18 _emissionRate,\n    SD59x18 _k,\n    SD59x18 _decayConstant,\n    SD59x18 _timeSinceLastAuctionStart\n  ) internal pure returns (SD59x18) {\n    if (_price.unwrap() == 0) {\n      return SD59x18.wrap(0);\n    }\n    SD59x18 exp = _decayConstant.mul(_timeSinceLastAuctionStart).exp();\n    SD59x18 lnParam = _k.add(_price.mul(_emissionRate).mul(exp)).div(_k);\n    SD59x18 numerator = _emissionRate.mul(lnParam.ln());\n    SD59x18 amount = numerator.div(_decayConstant);\n    return amount;\n  }\n\n  /// @notice Computes an initial price for the CGDA such that the purchase amount will cost the price at the given timestamp\n  /// @param _emissionRate The emission rate of the CGDA\n  /// @param _decayConstant The decay constant of the CGDA\n  /// @param _targetFirstSaleTime The timestamp at which the CGDA price for the given amount matches the given price\n  /// @param _purchaseAmount The amount of tokens to purchase\n  /// @param _price The price to be paid for the amount of tokens\n  function computeK(\n    SD59x18 _emissionRate,\n    SD59x18 _decayConstant,\n    SD59x18 _targetFirstSaleTime,\n    SD59x18 _purchaseAmount,\n    SD59x18 _price\n  ) internal pure returns (SD59x18) {\n    SD59x18 exponent = _decayConstant.mul(_targetFirstSaleTime);\n    SD59x18 eValue = exponent.exp();\n    SD59x18 multiplier = _emissionRate.mul(_price);\n    SD59x18 denominator = (_decayConstant.mul(_purchaseAmount).div(_emissionRate)).exp().sub(ONE);\n    SD59x18 result = eValue.div(denominator);\n    return result.mul(multiplier);\n  }\n}"
    },
    {
      "filename": "src/libraries/ContinuousGDA.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport { SD59x18, convert, unwrap } from \"prb-math/SD59x18.sol\";\n\n/// @title ContinuousGDA\n/// @author G9 Software Inc.\n/// @notice Implements the Continous Gradual Dutch Auction formula\n/// See https://www.paradigm.xyz/2022/04/gda\n/// @dev Pricing formula adapted from https://github.com/FrankieIsLost/gradual-dutch-auction/blob/master/src/ContinuousGDA.sol\nlibrary ContinuousGDA {\n\n  /// @notice a helpful constant\n  SD59x18 internal constant ONE = SD59x18.wrap(1e18);\n\n  /// @notice Calculate purchase price for a given amount of tokens\n  /// @param _amount The amount of tokens to purchase\n  /// @param _emissionRate The emission rate of the CGDA\n  /// @param _k The initial price of the CGDA\n  /// @param _decayConstant The decay constant of the CGDA\n  /// @param _timeSinceLastAuctionStart The elapsed time since the last consumed timestamp\n  /// @return The purchase price for the given amount of tokens\n  function purchasePrice(\n    SD59x18 _amount,\n    SD59x18 _emissionRate,\n    SD59x18 _k,\n    SD59x18 _decayConstant,\n    SD59x18 _timeSinceLastAuctionStart\n  ) internal pure returns (SD59x18) {\n    if (_amount.unwrap() == 0) {\n      return SD59x18.wrap(0);\n    }\n    SD59x18 topE = _decayConstant.mul(_amount).div(_emissionRate);\n    topE = topE.exp().sub(ONE);\n    SD59x18 bottomE = _decayConstant.mul(_timeSinceLastAuctionStart);\n    bottomE = bottomE.exp();\n    SD59x18 result;\n    if (_emissionRate.unwrap() > 1e18) {\n      result = _k.div(_emissionRate).mul(topE).div(bottomE);\n    } else {\n      result = _k.mul(topE.div(_emissionRate.mul(bottomE)));\n    }\n    return result;\n  }\n\n  /// @notice Computes the amount of tokens that can be purchased for a given price\n  /// @dev Note that this formula has significant floating point differences to the above. Either one, not both, should be used.\n  /// @param _price The price willing to be paid\n  /// @param _emissionRate The emission rate of the CGDA\n  /// @param _k The initial price of the CGDA\n  /// @param _decayConstant The decay constant of the CGDA\n  /// @param _timeSinceLastAuctionStart The elapsed time since the last consumed timestamp\n  /// @return The number of tokens that can be purchased for the given price\n  function purchaseAmount(\n    SD59x18 _price,\n    SD59x18 _emissionRate,\n    SD59x18 _k,\n    SD59x18 _decayConstant,\n    SD59x18 _timeSinceLastAuctionStart\n  ) internal pure returns (SD59x18) {\n    if (_price.unwrap() == 0) {\n      return SD59x18.wrap(0);\n    }\n    SD59x18 exp = _decayConstant.mul(_timeSinceLastAuctionStart).exp();\n    SD59x18 lnParam = _k.add(_price.mul(_emissionRate).mul(exp)).div(_k);\n    SD59x18 numerator = _emissionRate.mul(lnParam.ln());\n    SD59x18 amount = numerator.div(_decayConstant);\n    return amount;\n  }\n\n  /// @notice Computes an initial price for the CGDA such that the purchase amount will cost the price at the given timestamp\n  /// @param _emissionRate The emission rate of the CGDA\n  /// @param _decayConstant The decay constant of the CGDA\n  /// @param _targetFirstSaleTime The timestamp at which the CGDA price for the given amount matches the given price\n  /// @param _purchaseAmount The amount of tokens to purchase\n  /// @param _price The price to be paid for the amount of tokens\n  function computeK(\n    SD59x18 _emissionRate,\n    SD59x18 _decayConstant,\n    SD59x18 _targetFirstSaleTime,\n    SD59x18 _purchaseAmount,\n    SD59x18 _price\n  ) internal pure returns (SD59x18) {\n    SD59x18 exponent = _decayConstant.mul(_targetFirstSaleTime);\n    SD59x18 eValue = exponent.exp();\n    SD59x18 multiplier = _emissionRate.mul(_price);\n    SD59x18 denominator = (_decayConstant.mul(_purchaseAmount).div(_emissionRate)).exp().sub(ONE);\n    SD59x18 result = eValue.div(denominator);\n    return result.mul(multiplier);\n  }\n}"
    }
  ]
}