{
  "Title": "[01] `ProfitManager::donateToTermSurplusBuffer()` does not check if the term is from the same market",
  "Content": "\nUsers can lose their `CREDIT` tokens by calling or `donateToTermSurplusBuffer` for a non-existing term and transferring their tokens to the wrong or eventually non-existing address.\n\n[ProfitManager.sol#L258-L264](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/governance/ProfitManager.sol#L258-L264)\n\n```solidity\n/// @notice donate to surplus buffer of a given term\nfunction donateToTermSurplusBuffer(address term, uint256 amount) external {\n    CreditToken(credit).transferFrom(msg.sender, address(this), amount);\n    uint256 newSurplusBuffer = termSurplusBuffer[term] + amount;\n    termSurplusBuffer[term] = newSurplusBuffer;\n    emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer);\n}\n```\n\nThey wonâ€™t be able to rescue their tokens unless contract/user with `GUILD_SURPLUS_BUFFER_WITHDRAW` role calls it for a user who has lost his tokens.\n\n[ProfitManager.sol#L277-L287](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/governance/ProfitManager.sol#L277-L287)\n\n```solidity\n/// @notice withdraw from surplus buffer\nfunction withdrawFromSurplusBuffer(address to, uint256 amount)\n    external\n    onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW)\n{\n    uint256 newSurplusBuffer = surplusBuffer - amount; // this would revert due to underflow if withdrawing > surplusBuffer\n    surplusBuffer = newSurplusBuffer;\n    CreditToken(credit).transfer(to, amount);\n    emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer);\n}\n```\n\n### Recommendation\n\nConsider adding check if term is actually a `LendingTerm` contract, modify `donateToTermSurplusBuffer`:\n\n```diff\n/// @notice donate to surplus buffer of a given term\nfunction donateToTermSurplusBuffer(address term, uint256 amount) external {\n+   require(LendingTerm(term).getReferences().creditToken == credit, \"ProfitManager: term from wrong market!\");     \n    CreditToken(credit).transferFrom(msg.sender, address(this), amount);\n    uint256 newSurplusBuffer = termSurplusBuffer[term] + amount;\n    termSurplusBuffer[term] = newSurplusBuffer;\n    emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer);\n}\n```\n\n*** \n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-12-ethereumcreditguild",
  "Code": [
    {
      "filename": "src/governance/ProfitManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {SimplePSM} from \"@src/loan/SimplePSM.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {CreditToken} from \"@src/tokens/CreditToken.sol\";\n\n/** \n@title ProfitManager\n@author eswak\n@notice This contract manages profits generated in the system and how it is distributed\n    between the various stakeholders.\n\n    This contract also manages a surplus buffer, which acts as first-loss capital in case of\n    bad debt. When bad debt is created beyond the surplus buffer, this contract decrements\n    the `creditMultiplier` value held in its storage, which has the effect of reducing the\n    value of CREDIT everywhere in the system.\n\n    When a loan generates profit (interests), the profit is traced back to users voting for\n    this lending term (gauge), which subsequently allows pro-rata distribution of profits to\n    GUILD holders that vote for the most productive gauges.\n\n    Seniority stack of the debt, in case of losses :\n    - per term surplus buffer (donated to global surplus buffer when loss is reported)\n    - global surplus buffer\n    - finally, credit holders (by updating down the creditMultiplier)\n*/\ncontract ProfitManager is CoreRef {\n    /// @notice reference to GUILD token.\n    address public guild;\n\n    /// @notice reference to CREDIT token.\n    address public credit;\n\n    /// @notice reference to CREDIT token PSM.\n    address public psm;\n\n    /// @notice profit index of a given gauge\n    mapping(address => uint256) public gaugeProfitIndex;\n\n    /// @notice profit index of a given user in a given gauge\n    mapping(address => mapping(address => uint256)) public userGaugeProfitIndex;\n\n    /// @dev internal structure used to optimize storage read, public functions use\n    /// uint256 numbers with 18 decimals.\n    struct ProfitSharingConfig {\n        uint32 surplusBufferSplit; // percentage, with 9 decimals (!) that go to surplus buffer\n        uint32 guildSplit; // percentage, with 9 decimals (!) that go to GUILD holders\n        uint32 otherSplit; // percentage, with 9 decimals (!) that go to other address if != address(0)\n        address otherRecipient; // address receiving `otherSplit`\n    }\n\n    /// @notice configuration of profit sharing.\n    /// `surplusBufferSplit`, `guildSplit`, and `otherSplit` are expressed as percentages with 9 decimals,\n    /// so a value of 1e9 would direct 100% of profits. The sum should be <= 1e9.\n    /// The rest (if the sum of `guildSplit` + `otherSplit` is < 1e9) is distributed to lenders of the\n    /// system, CREDIT holders, through the rebasing mechanism (`CreditToken.distribute()`).\n    /// If `otherRecipient` is set to address(0), `otherSplit` must equal 0.\n    /// The share of profit to `otherRecipient` is sent through a regular ERC20.transfer().\n    /// This structure is optimized for storage packing, all external interfaces reference\n    /// percentages encoded as uint256 with 18 decimals.\n    ProfitSharingConfig internal profitSharingConfig;\n\n    /// @notice amount of first-loss capital in the system.\n    /// This is a number of CREDIT token held on this contract that can be used to absorb losses in\n    /// cases where a loss is reported through `notifyPnL`. The surplus buffer is depleted first, and\n    /// if the loss is greater than the surplus buffer, the `creditMultiplier` is updated down.\n    uint256 public surplusBuffer;\n\n    /// @notice amount of first-loss capital for a given term.\n    /// This is a number of CREDIT token held on this contract that can be used to absorb losses in\n    /// cases where a loss is reported through `notifyPnL` in a given term.\n    /// When a loss is reported in a given term, its termSuplusBuffer is donated to the general\n    /// surplusBuffer before calculating the loss.\n    mapping(address => uint256) public termSurplusBuffer;\n\n    /// @notice multiplier for CREDIT value in the system.\n    /// e.g. a value of 0.7e18 would mean that CREDIT has been discounted by 30% so far in the system,\n    /// and that all lending terms will allow 1/0.7=1.42 times more CREDIT to be borrowed per collateral\n    /// tokens, and all active debts are also affected by this multiplier during the update (e.g. if an\n    /// address owed 1000 CREDIT in an active loan, they now owe 1428 CREDIT).\n    /// The CREDIT multiplier can only go down (CREDIT can only lose value over time, when bad debt\n    /// is created in the system). To make CREDIT a valuable asset to hold, profits generated by the system\n    /// shall be redistributed to holders through a savings rate or another mechanism.\n    uint256 public creditMultiplier = 1e18;\n\n    /// @notice minimum size of CREDIT loans.\n    /// this parameter is here to ensure that the gas costs of liquidation do not\n    /// outsize minimum overcollateralization (which could result in bad debt\n    /// on otherwise sound loans).\n    /// This value is adjusted up when the creditMultiplier goes down.\n    uint256 internal _minBorrow = 100e18;\n\n    /// @notice tolerance on new borrows regarding gauge weights.\n    /// For a total supply or 100 credit, and 2 gauges each at 50% weight,\n    /// the ideal borrow amount for each gauge is 50 credit. To facilitate\n    /// growth of the protocol, a tolerance is allowed compared to the ideal\n    /// gauge weights.\n    /// This tolerance is expressed as a percentage with 18 decimals.\n    /// A tolerance of 1e18 (100% - or 0% deviation compared to ideal weights)\n    /// can result in a deadlock situation where no new borrows are allowed.\n    uint256 public gaugeWeightTolerance = 1.2e18; // 120%\n\n    constructor(address _core) CoreRef(_core) {\n        emit MinBorrowUpdate(block.timestamp, 100e18);\n    }\n\n    /// @notice emitted when a profit or loss in a gauge is notified.\n    event GaugePnL(address indexed gauge, uint256 indexed when, int256 pnl);\n\n    /// @notice emitted when surplus buffer is updated.\n    event SurplusBufferUpdate(uint256 indexed when, uint256 newValue);\n\n    /// @notice emitted when surplus buffer of a given term is updated.\n    event TermSurplusBufferUpdate(\n        uint256 indexed when,\n        address indexed term,\n        uint256 newValue\n    );\n\n    /// @notice emitted when CREDIT multiplier is updated.\n    event CreditMultiplierUpdate(uint256 indexed when, uint256 newValue);\n\n    /// @notice emitted when GUILD profit sharing is updated.\n    event ProfitSharingConfigUpdate(\n        uint256 indexed when,\n        uint256 surplusBufferSplit,\n        uint256 creditSplit,\n        uint256 guildSplit,\n        uint256 otherSplit,\n        address otherRecipient\n    );\n\n    /// @notice emitted when a GUILD member claims their CREDIT rewards.\n    event ClaimRewards(\n        uint256 indexed when,\n        address indexed user,\n        address indexed gauge,\n        uint256 amount\n    );\n\n    /// @notice emitted when minBorrow is updated\n    event MinBorrowUpdate(uint256 indexed when, uint256 newValue);\n\n    /// @notice emitted when gaugeWeightTolerance is updated\n    event GaugeWeightToleranceUpdate(uint256 indexed when, uint256 newValue);\n\n    /// @notice get the minimum borrow amount\n    function minBorrow() external view returns (uint256) {\n        return (_minBorrow * 1e18) / creditMultiplier;\n    }\n\n    /// @notice initialize references to GUILD & CREDIT tokens.\n    function initializeReferences(\n        address _credit,\n        address _guild,\n        address _psm\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        assert(\n            credit == address(0) && guild == address(0) && psm == address(0)\n        );\n        credit = _credit;\n        guild = _guild;\n        psm = _psm;\n    }\n\n    /// @notice returns the sum of all borrowed CREDIT, not including unpaid interests\n    /// and creditMultiplier changes that could make debt amounts higher than the initial\n    /// borrowed CREDIT amounts.\n    function totalBorrowedCredit() external view returns (uint256) {\n        return\n            CreditToken(credit).targetTotalSupply() -\n            SimplePSM(psm).redeemableCredit();\n    }\n\n    /// @notice set the minimum borrow amount\n    function setMinBorrow(\n        uint256 newValue\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        _minBorrow = newValue;\n        emit MinBorrowUpdate(block.timestamp, newValue);\n    }\n\n    /// @notice set the gauge weight tolerance\n    function setGaugeWeightTolerance(\n        uint256 newValue\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        gaugeWeightTolerance = newValue;\n        emit GaugeWeightToleranceUpdate(block.timestamp, newValue);\n    }\n\n    /// @notice set the profit sharing config.\n    function setProfitSharingConfig(\n        uint256 surplusBufferSplit,\n        uint256 creditSplit,\n        uint256 guildSplit,\n        uint256 otherSplit,\n        address otherRecipient\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        if (otherRecipient == address(0)) {\n            require(otherSplit == 0, \"GuildToken: invalid config\");\n        } else {\n            require(otherSplit != 0, \"GuildToken: invalid config\");\n        }\n        require(\n            surplusBufferSplit + otherSplit + guildSplit + creditSplit == 1e18,\n            \"GuildToken: invalid config\"\n        );\n\n        profitSharingConfig = ProfitSharingConfig({\n            surplusBufferSplit: uint32(surplusBufferSplit / 1e9),\n            guildSplit: uint32(guildSplit / 1e9),\n            otherSplit: uint32(otherSplit / 1e9),\n            otherRecipient: otherRecipient\n        });\n\n        emit ProfitSharingConfigUpdate(\n            block.timestamp,\n            surplusBufferSplit,\n            creditSplit,\n            guildSplit,\n            otherSplit,\n            otherRecipient\n        );\n    }\n\n    /// @notice get the profit sharing config.\n    function getProfitSharingConfig()\n        external\n        view\n        returns (\n            uint256 surplusBufferSplit,\n            uint256 creditSplit,\n            uint256 guildSplit,\n            uint256 otherSplit,\n            address otherRecipient\n        )\n    {\n        surplusBufferSplit =\n            uint256(profitSharingConfig.surplusBufferSplit) *\n            1e9;\n        guildSplit = uint256(profitSharingConfig.guildSplit) * 1e9;\n        otherSplit = uint256(profitSharingConfig.otherSplit) * 1e9;\n        creditSplit = 1e18 - surplusBufferSplit - guildSplit - otherSplit;\n        otherRecipient = profitSharingConfig.otherRecipient;\n    }\n\n    /// @notice donate to surplus buffer\n    function donateToSurplusBuffer(uint256 amount) external {\n        CreditToken(credit).transferFrom(msg.sender, address(this), amount);\n        uint256 newSurplusBuffer = surplusBuffer + amount;\n        surplusBuffer = newSurplusBuffer;\n        emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer);\n    }\n\n    /// @notice donate to surplus buffer of a given term\n    function donateToTermSurplusBuffer(address term, uint256 amount) external {\n        CreditToken(credit).transferFrom(msg.sender, address(this), amount);\n        uint256 newSurplusBuffer = termSurplusBuffer[term] + amount;\n        termSurplusBuffer[term] = newSurplusBuffer;\n        emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer);\n    }\n\n    /// @notice withdraw from surplus buffer\n    function withdrawFromSurplusBuffer(\n        address to,\n        uint256 amount\n    ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) {\n        uint256 newSurplusBuffer = surplusBuffer - amount; // this would revert due to underflow if withdrawing > surplusBuffer\n        surplusBuffer = newSurplusBuffer;\n        CreditToken(credit).transfer(to, amount);\n        emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer);\n    }\n\n    /// @notice withdraw from surplus buffer of a given term\n    function withdrawFromTermSurplusBuffer(\n        address term,\n        address to,\n        uint256 amount\n    ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) {\n        uint256 newSurplusBuffer = termSurplusBuffer[term] - amount; // this would revert due to underflow if withdrawing > termSurplusBuffer\n        termSurplusBuffer[term] = newSurplusBuffer;\n        CreditToken(credit).transfer(to, amount);\n        emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer);\n    }\n\n    /// @notice notify profit and loss in a given gauge\n    /// if `amount` is > 0, the same number of CREDIT tokens are expected to be transferred to this contract\n    /// before `notifyPnL` is called.\n    function notifyPnL(\n        address gauge,\n        int256 amount\n    ) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) {\n        uint256 _surplusBuffer = surplusBuffer;\n        uint256 _termSurplusBuffer = termSurplusBuffer[gauge];\n        address _credit = credit;\n\n        // handling loss\n        if (amount < 0) {\n            uint256 loss = uint256(-amount);\n\n            // save gauge loss\n            GuildToken(guild).notifyGaugeLoss(gauge);\n\n            // deplete the term surplus buffer, if any, and\n            // donate its content to the general surplus buffer\n            if (_termSurplusBuffer != 0) {\n                termSurplusBuffer[gauge] = 0;\n                emit TermSurplusBufferUpdate(block.timestamp, gauge, 0);\n                _surplusBuffer += _termSurplusBuffer;\n            }\n\n            if (loss < _surplusBuffer) {\n                // deplete the surplus buffer\n                surplusBuffer = _surplusBuffer - loss;\n                emit SurplusBufferUpdate(\n                    block.timestamp,\n                    _surplusBuffer - loss\n                );\n                CreditToken(_credit).burn(loss);\n            } else {\n                // empty the surplus buffer\n                loss -= _surplusBuffer;\n                surplusBuffer = 0;\n                CreditToken(_credit).burn(_surplusBuffer);\n                emit SurplusBufferUpdate(block.timestamp, 0);\n\n                // update the CREDIT multiplier\n                uint256 creditTotalSupply = CreditToken(_credit).totalSupply();\n                uint256 newCreditMultiplier = (creditMultiplier *\n                    (creditTotalSupply - loss)) / creditTotalSupply;\n                creditMultiplier = newCreditMultiplier;\n                emit CreditMultiplierUpdate(\n                    block.timestamp,\n                    newCreditMultiplier\n                );\n            }\n        }\n        // handling profit\n        else if (amount > 0) {\n            ProfitSharingConfig\n                memory _profitSharingConfig = profitSharingConfig;\n\n            uint256 amountForSurplusBuffer = (uint256(amount) *\n                uint256(_profitSharingConfig.surplusBufferSplit)) / 1e9;\n\n            uint256 amountForGuild = (uint256(amount) *\n                uint256(_profitSharingConfig.guildSplit)) / 1e9;\n\n            uint256 amountForOther = (uint256(amount) *\n                uint256(_profitSharingConfig.otherSplit)) / 1e9;\n\n            uint256 amountForCredit = uint256(amount) -\n                amountForSurplusBuffer -\n                amountForGuild -\n                amountForOther;\n\n            // distribute to surplus buffer\n            if (amountForSurplusBuffer != 0) {\n                surplusBuffer = _surplusBuffer + amountForSurplusBuffer;\n                emit SurplusBufferUpdate(\n                    block.timestamp,\n                    _surplusBuffer + amountForSurplusBuffer\n                );\n            }\n\n            // distribute to other\n            if (amountForOther != 0) {\n                CreditToken(_credit).transfer(\n                    _profitSharingConfig.otherRecipient,\n                    amountForOther\n                );\n            }\n\n            // distribute to lenders\n            if (amountForCredit != 0) {\n                CreditToken(_credit).distribute(amountForCredit);\n            }\n\n            // distribute to the guild\n            if (amountForGuild != 0) {\n                // update the gauge profit index\n                // if the gauge has 0 weight, does not update the profit index, this is unnecessary\n                // because the profit index is used to reattribute profit to users voting for the gauge,\n                // and if the weigth is 0, there are no users voting for the gauge.\n                uint256 _gaugeWeight = uint256(\n                    GuildToken(guild).getGaugeWeight(gauge)\n                );\n                if (_gaugeWeight != 0) {\n                    uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];\n                    if (_gaugeProfitIndex == 0) {\n                        _gaugeProfitIndex = 1e18;\n                    }\n                    gaugeProfitIndex[gauge] =\n                        _gaugeProfitIndex +\n                        (amountForGuild * 1e18) /\n                        _gaugeWeight;\n                }\n            }\n        }\n\n        emit GaugePnL(gauge, block.timestamp, amount);\n    }\n\n    /// @notice claim a user's rewards for a given gauge.\n    /// @dev This should be called every time the user's weight changes in the gauge.\n    function claimGaugeRewards(\n        address user,\n        address gauge\n    ) public returns (uint256 creditEarned) {\n        uint256 _userGaugeWeight = uint256(\n            GuildToken(guild).getUserGaugeWeight(user, gauge)\n        );\n        if (_userGaugeWeight == 0) {\n            return 0;\n        }\n        uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];\n        uint256 _userGaugeProfitIndex = userGaugeProfitIndex[user][gauge];\n        if (_gaugeProfitIndex == 0) {\n            _gaugeProfitIndex = 1e18;\n        }\n        if (_userGaugeProfitIndex == 0) {\n            _userGaugeProfitIndex = 1e18;\n        }\n        uint256 deltaIndex = _gaugeProfitIndex - _userGaugeProfitIndex;\n        if (deltaIndex != 0) {\n            creditEarned = (_userGaugeWeight * deltaIndex) / 1e18;\n            userGaugeProfitIndex[user][gauge] = _gaugeProfitIndex;\n        }\n        if (creditEarned != 0) {\n            emit ClaimRewards(block.timestamp, user, gauge, creditEarned);\n            CreditToken(credit).transfer(user, creditEarned);\n        }\n    }\n\n    /// @notice claim a user's rewards across all their active gauges.\n    function claimRewards(\n        address user\n    ) external returns (uint256 creditEarned) {\n        address[] memory gauges = GuildToken(guild).userGauges(user);\n        for (uint256 i = 0; i < gauges.length; ) {\n            creditEarned += claimGaugeRewards(user, gauges[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice read & return pending undistributed rewards for a given user\n    function getPendingRewards(\n        address user\n    )\n        external\n        view\n        returns (\n            address[] memory gauges,\n            uint256[] memory creditEarned,\n            uint256 totalCreditEarned\n        )\n    {\n        address _guild = guild;\n        gauges = GuildToken(_guild).userGauges(user);\n        creditEarned = new uint256[](gauges.length);\n\n        for (uint256 i = 0; i < gauges.length; ) {\n            address gauge = gauges[i];\n            uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];\n            uint256 _userGaugeProfitIndex = userGaugeProfitIndex[user][gauge];\n\n            if (_gaugeProfitIndex == 0) {\n                _gaugeProfitIndex = 1e18;\n            }\n            if (_userGaugeProfitIndex == 0) {\n                _userGaugeProfitIndex = 1e18;\n            }\n            uint256 deltaIndex = _gaugeProfitIndex - _userGaugeProfitIndex;\n            if (deltaIndex != 0) {\n                uint256 _userGaugeWeight = uint256(\n                    GuildToken(_guild).getUserGaugeWeight(user, gauge)\n                );\n                creditEarned[i] = (_userGaugeWeight * deltaIndex) / 1e18;\n                totalCreditEarned += creditEarned[i];\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/governance/ProfitManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {SimplePSM} from \"@src/loan/SimplePSM.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {CreditToken} from \"@src/tokens/CreditToken.sol\";\n\n/** \n@title ProfitManager\n@author eswak\n@notice This contract manages profits generated in the system and how it is distributed\n    between the various stakeholders.\n\n    This contract also manages a surplus buffer, which acts as first-loss capital in case of\n    bad debt. When bad debt is created beyond the surplus buffer, this contract decrements\n    the `creditMultiplier` value held in its storage, which has the effect of reducing the\n    value of CREDIT everywhere in the system.\n\n    When a loan generates profit (interests), the profit is traced back to users voting for\n    this lending term (gauge), which subsequently allows pro-rata distribution of profits to\n    GUILD holders that vote for the most productive gauges.\n\n    Seniority stack of the debt, in case of losses :\n    - per term surplus buffer (donated to global surplus buffer when loss is reported)\n    - global surplus buffer\n    - finally, credit holders (by updating down the creditMultiplier)\n*/\ncontract ProfitManager is CoreRef {\n    /// @notice reference to GUILD token.\n    address public guild;\n\n    /// @notice reference to CREDIT token.\n    address public credit;\n\n    /// @notice reference to CREDIT token PSM.\n    address public psm;\n\n    /// @notice profit index of a given gauge\n    mapping(address => uint256) public gaugeProfitIndex;\n\n    /// @notice profit index of a given user in a given gauge\n    mapping(address => mapping(address => uint256)) public userGaugeProfitIndex;\n\n    /// @dev internal structure used to optimize storage read, public functions use\n    /// uint256 numbers with 18 decimals.\n    struct ProfitSharingConfig {\n        uint32 surplusBufferSplit; // percentage, with 9 decimals (!) that go to surplus buffer\n        uint32 guildSplit; // percentage, with 9 decimals (!) that go to GUILD holders\n        uint32 otherSplit; // percentage, with 9 decimals (!) that go to other address if != address(0)\n        address otherRecipient; // address receiving `otherSplit`\n    }\n\n    /// @notice configuration of profit sharing.\n    /// `surplusBufferSplit`, `guildSplit`, and `otherSplit` are expressed as percentages with 9 decimals,\n    /// so a value of 1e9 would direct 100% of profits. The sum should be <= 1e9.\n    /// The rest (if the sum of `guildSplit` + `otherSplit` is < 1e9) is distributed to lenders of the\n    /// system, CREDIT holders, through the rebasing mechanism (`CreditToken.distribute()`).\n    /// If `otherRecipient` is set to address(0), `otherSplit` must equal 0.\n    /// The share of profit to `otherRecipient` is sent through a regular ERC20.transfer().\n    /// This structure is optimized for storage packing, all external interfaces reference\n    /// percentages encoded as uint256 with 18 decimals.\n    ProfitSharingConfig internal profitSharingConfig;\n\n    /// @notice amount of first-loss capital in the system.\n    /// This is a number of CREDIT token held on this contract that can be used to absorb losses in\n    /// cases where a loss is reported through `notifyPnL`. The surplus buffer is depleted first, and\n    /// if the loss is greater than the surplus buffer, the `creditMultiplier` is updated down.\n    uint256 public surplusBuffer;\n\n    /// @notice amount of first-loss capital for a given term.\n    /// This is a number of CREDIT token held on this contract that can be used to absorb losses in\n    /// cases where a loss is reported through `notifyPnL` in a given term.\n    /// When a loss is reported in a given term, its termSuplusBuffer is donated to the general\n    /// surplusBuffer before calculating the loss.\n    mapping(address => uint256) public termSurplusBuffer;\n\n    /// @notice multiplier for CREDIT value in the system.\n    /// e.g. a value of 0.7e18 would mean that CREDIT has been discounted by 30% so far in the system,\n    /// and that all lending terms will allow 1/0.7=1.42 times more CREDIT to be borrowed per collateral\n    /// tokens, and all active debts are also affected by this multiplier during the update (e.g. if an\n    /// address owed 1000 CREDIT in an active loan, they now owe 1428 CREDIT).\n    /// The CREDIT multiplier can only go down (CREDIT can only lose value over time, when bad debt\n    /// is created in the system). To make CREDIT a valuable asset to hold, profits generated by the system\n    /// shall be redistributed to holders through a savings rate or another mechanism.\n    uint256 public creditMultiplier = 1e18;\n\n    /// @notice minimum size of CREDIT loans.\n    /// this parameter is here to ensure that the gas costs of liquidation do not\n    /// outsize minimum overcollateralization (which could result in bad debt\n    /// on otherwise sound loans).\n    /// This value is adjusted up when the creditMultiplier goes down.\n    uint256 internal _minBorrow = 100e18;\n\n    /// @notice tolerance on new borrows regarding gauge weights.\n    /// For a total supply or 100 credit, and 2 gauges each at 50% weight,\n    /// the ideal borrow amount for each gauge is 50 credit. To facilitate\n    /// growth of the protocol, a tolerance is allowed compared to the ideal\n    /// gauge weights.\n    /// This tolerance is expressed as a percentage with 18 decimals.\n    /// A tolerance of 1e18 (100% - or 0% deviation compared to ideal weights)\n    /// can result in a deadlock situation where no new borrows are allowed.\n    uint256 public gaugeWeightTolerance = 1.2e18; // 120%\n\n    constructor(address _core) CoreRef(_core) {\n        emit MinBorrowUpdate(block.timestamp, 100e18);\n    }\n\n    /// @notice emitted when a profit or loss in a gauge is notified.\n    event GaugePnL(address indexed gauge, uint256 indexed when, int256 pnl);\n\n    /// @notice emitted when surplus buffer is updated.\n    event SurplusBufferUpdate(uint256 indexed when, uint256 newValue);\n\n    /// @notice emitted when surplus buffer of a given term is updated.\n    event TermSurplusBufferUpdate(\n        uint256 indexed when,\n        address indexed term,\n        uint256 newValue\n    );\n\n    /// @notice emitted when CREDIT multiplier is updated.\n    event CreditMultiplierUpdate(uint256 indexed when, uint256 newValue);\n\n    /// @notice emitted when GUILD profit sharing is updated.\n    event ProfitSharingConfigUpdate(\n        uint256 indexed when,\n        uint256 surplusBufferSplit,\n        uint256 creditSplit,\n        uint256 guildSplit,\n        uint256 otherSplit,\n        address otherRecipient\n    );\n\n    /// @notice emitted when a GUILD member claims their CREDIT rewards.\n    event ClaimRewards(\n        uint256 indexed when,\n        address indexed user,\n        address indexed gauge,\n        uint256 amount\n    );\n\n    /// @notice emitted when minBorrow is updated\n    event MinBorrowUpdate(uint256 indexed when, uint256 newValue);\n\n    /// @notice emitted when gaugeWeightTolerance is updated\n    event GaugeWeightToleranceUpdate(uint256 indexed when, uint256 newValue);\n\n    /// @notice get the minimum borrow amount\n    function minBorrow() external view returns (uint256) {\n        return (_minBorrow * 1e18) / creditMultiplier;\n    }\n\n    /// @notice initialize references to GUILD & CREDIT tokens.\n    function initializeReferences(\n        address _credit,\n        address _guild,\n        address _psm\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        assert(\n            credit == address(0) && guild == address(0) && psm == address(0)\n        );\n        credit = _credit;\n        guild = _guild;\n        psm = _psm;\n    }\n\n    /// @notice returns the sum of all borrowed CREDIT, not including unpaid interests\n    /// and creditMultiplier changes that could make debt amounts higher than the initial\n    /// borrowed CREDIT amounts.\n    function totalBorrowedCredit() external view returns (uint256) {\n        return\n            CreditToken(credit).targetTotalSupply() -\n            SimplePSM(psm).redeemableCredit();\n    }\n\n    /// @notice set the minimum borrow amount\n    function setMinBorrow(\n        uint256 newValue\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        _minBorrow = newValue;\n        emit MinBorrowUpdate(block.timestamp, newValue);\n    }\n\n    /// @notice set the gauge weight tolerance\n    function setGaugeWeightTolerance(\n        uint256 newValue\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        gaugeWeightTolerance = newValue;\n        emit GaugeWeightToleranceUpdate(block.timestamp, newValue);\n    }\n\n    /// @notice set the profit sharing config.\n    function setProfitSharingConfig(\n        uint256 surplusBufferSplit,\n        uint256 creditSplit,\n        uint256 guildSplit,\n        uint256 otherSplit,\n        address otherRecipient\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        if (otherRecipient == address(0)) {\n            require(otherSplit == 0, \"GuildToken: invalid config\");\n        } else {\n            require(otherSplit != 0, \"GuildToken: invalid config\");\n        }\n        require(\n            surplusBufferSplit + otherSplit + guildSplit + creditSplit == 1e18,\n            \"GuildToken: invalid config\"\n        );\n\n        profitSharingConfig = ProfitSharingConfig({\n            surplusBufferSplit: uint32(surplusBufferSplit / 1e9),\n            guildSplit: uint32(guildSplit / 1e9),\n            otherSplit: uint32(otherSplit / 1e9),\n            otherRecipient: otherRecipient\n        });\n\n        emit ProfitSharingConfigUpdate(\n            block.timestamp,\n            surplusBufferSplit,\n            creditSplit,\n            guildSplit,\n            otherSplit,\n            otherRecipient\n        );\n    }\n\n    /// @notice get the profit sharing config.\n    function getProfitSharingConfig()\n        external\n        view\n        returns (\n            uint256 surplusBufferSplit,\n            uint256 creditSplit,\n            uint256 guildSplit,\n            uint256 otherSplit,\n            address otherRecipient\n        )\n    {\n        surplusBufferSplit =\n            uint256(profitSharingConfig.surplusBufferSplit) *\n            1e9;\n        guildSplit = uint256(profitSharingConfig.guildSplit) * 1e9;\n        otherSplit = uint256(profitSharingConfig.otherSplit) * 1e9;\n        creditSplit = 1e18 - surplusBufferSplit - guildSplit - otherSplit;\n        otherRecipient = profitSharingConfig.otherRecipient;\n    }\n\n    /// @notice donate to surplus buffer\n    function donateToSurplusBuffer(uint256 amount) external {\n        CreditToken(credit).transferFrom(msg.sender, address(this), amount);\n        uint256 newSurplusBuffer = surplusBuffer + amount;\n        surplusBuffer = newSurplusBuffer;\n        emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer);\n    }\n\n    /// @notice donate to surplus buffer of a given term\n    function donateToTermSurplusBuffer(address term, uint256 amount) external {\n        CreditToken(credit).transferFrom(msg.sender, address(this), amount);\n        uint256 newSurplusBuffer = termSurplusBuffer[term] + amount;\n        termSurplusBuffer[term] = newSurplusBuffer;\n        emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer);\n    }\n\n    /// @notice withdraw from surplus buffer\n    function withdrawFromSurplusBuffer(\n        address to,\n        uint256 amount\n    ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) {\n        uint256 newSurplusBuffer = surplusBuffer - amount; // this would revert due to underflow if withdrawing > surplusBuffer\n        surplusBuffer = newSurplusBuffer;\n        CreditToken(credit).transfer(to, amount);\n        emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer);\n    }\n\n    /// @notice withdraw from surplus buffer of a given term\n    function withdrawFromTermSurplusBuffer(\n        address term,\n        address to,\n        uint256 amount\n    ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) {\n        uint256 newSurplusBuffer = termSurplusBuffer[term] - amount; // this would revert due to underflow if withdrawing > termSurplusBuffer\n        termSurplusBuffer[term] = newSurplusBuffer;\n        CreditToken(credit).transfer(to, amount);\n        emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer);\n    }\n\n    /// @notice notify profit and loss in a given gauge\n    /// if `amount` is > 0, the same number of CREDIT tokens are expected to be transferred to this contract\n    /// before `notifyPnL` is called.\n    function notifyPnL(\n        address gauge,\n        int256 amount\n    ) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) {"
    }
  ]
}