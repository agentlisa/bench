{
  "Title": "[L-01] NatSpec comment on 255 owner limitation in `_addOwner()` being ambiguous",
  "Content": "The discrepancy between the NatSpec comment in the `_addOwner` function of the MultiOwnable contract and its actual implementation could lead to misunderstandings about the contract's owner limit. The comment suggests a limit of 255 owners:\n\nhttps://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol#L176\n\n```solidity\n    /// @notice Convenience function used to add the first 255 owners.\n```\nBut the code, utilizing `uint256` for indexing, does not enforce any such limit, allowing for a significantly larger number of owners. \n\nhttps://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol#L8-L9\n\n```solidity\n    /// @dev Tracks the index of the next owner to add.\n    uint256 nextOwnerIndex;\n```\nhttps://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol#L179-L181\n\n```solidity\n    function _addOwner(bytes memory owner) internal virtual {\n        _addOwnerAtIndex(owner, _getMultiOwnableStorage().nextOwnerIndex++);\n    }\n```\nThis issue, while not affecting the contract's functionality or security directly, could cause confusion among developers and users, leading to potential misalignments in expectations and implementations. Addressing this through clarification in the documentation or by introducing an explicit limit, if desired, is recommended to ensure clear and accurate communication of the contract's capabilities. \n\n```diff\n    function _addOwner(bytes memory owner) internal virtual {\n+        require(_getMultiOwnableStorage().nextOwnerIndex < 255, \"Owner limit reached\");\n        _addOwnerAtIndex(owner, _getMultiOwnableStorage().nextOwnerIndex++);\n    }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-coinbase",
  "Code": [
    {
      "filename": "src/SmartWallet/MultiOwnable.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Storage layout used by this contract.\n///\n/// @custom:storage-location erc7201:coinbase.storage.MultiOwnable\nstruct MultiOwnableStorage {\n    /// @dev Tracks the index of the next owner to add.\n    uint256 nextOwnerIndex;\n    /// @dev Mapping of indices to raw owner bytes, used to idenfitied owners by their\n    ///      uint256 id.\n    ///\n    ///      Some uses —-such as signature validation for secp256r1 public key owners—-\n    ///      requires the caller to assert which owner signed. To economize calldata,\n    ///      we allow an index to identify an owner, so that the full owner bytes do\n    ///      not need to be passed.\n    ///\n    ///      The underlying raw bytes can either be:\n    ///         - An abi encoded ethereum address\n    ///         - The abi encoded public key (x, y) coordinates when using passkey.\n    mapping(uint256 index => bytes owner) ownerAtIndex;\n    /// @dev Mapping of raw bytes accounts to booleans indicating whether or not the\n    ///      account is an owner of this contract.\n    mapping(bytes account => bool isOwner_) isOwner;\n}\n\n/// @title Multi Ownable\n///\n/// @notice Auth contract allowing multiple owners, each identified as bytes.\n///\n/// @author Coinbase (https://github.com/coinbase/smart-wallet)\ncontract MultiOwnable {\n    /// @dev Slot for the `MultiOwnableStorage` struct in storage.\n    ///      Computed from: keccak256(abi.encode(uint256(keccak256(\"coinbase.storage.MultiOwnable\")) - 1)) & ~bytes32(uint256(0xff))\n    ///      Follows ERC-7201 (see https://eips.ethereum.org/EIPS/eip-7201).\n    bytes32 private constant MUTLI_OWNABLE_STORAGE_LOCATION =\n        0x97e2c6aad4ce5d562ebfaa00db6b9e0fb66ea5d8162ed5b243f51a2e03086f00;\n\n    /// @notice Thrown when the sender is not an owner and is trying to call a privileged function.\n    error Unauthorized();\n\n    /// @notice Thrown when trying to add an already registered owner.\n    ///\n    /// @param owner The raw abi encoded owner bytes.\n    error AlreadyOwner(bytes owner);\n\n    /// @notice Thrown when trying to remove an owner from an index that is empty.\n    ///\n    /// @param index The targeted index for removal.\n    error NoOwnerAtIndex(uint256 index);\n\n    /// @notice Thrown when trying to intialize the contracts owners if a provided owner is neither\n    ///         64 bytes long (for passkey) nor a valid address.\n    ///\n    /// @param owner The invalid raw abi encoded owner bytes.\n    error InvalidOwnerBytesLength(bytes owner);\n\n    /// @notice Thrown when trying to intialize the contracts owners if a provided owner is 32 bytes\n    ///         long but does not fit in an `address` type (`uint160`).\n    ///\n    /// @param owner The invalid raw abi encoded owner bytes.\n    error InvalidEthereumAddressOwner(bytes owner);\n\n    /// @notice Emitted when a new owner is registered.\n    ///\n    /// @param index The owner index.\n    /// @param owner The raw abi encoded owner bytes.\n    event AddOwner(uint256 indexed index, bytes owner);\n\n    /// @notice Emitted when an owner is removed.\n    ///\n    /// @param index The owner index.\n    /// @param owner The raw abi encoded owner bytes.\n    event RemoveOwner(uint256 indexed index, bytes owner);\n\n    /// @notice Access control modifier ensuring the caller is an authorized owner\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n\n    /// @notice Convenience function to add a new owner address.\n    ///\n    /// @param owner The owner address.\n    function addOwnerAddress(address owner) public virtual onlyOwner {\n        _addOwner(abi.encode(owner));\n    }\n\n    /// @notice Convenience function to add a new owner passkey.\n    ///\n    /// @param x The owner public key x coordinate.\n    /// @param y The owner public key y coordinate.\n    function addOwnerPublicKey(bytes32 x, bytes32 y) public virtual onlyOwner {\n        _addOwner(abi.encode(x, y));\n    }\n\n    /// @notice Removes an owner from the given `index`.\n    ///\n    /// @dev Reverts if the owner is not registered at `index`.\n    ///\n    /// @param index The index to remove from.\n    function removeOwnerAtIndex(uint256 index) public virtual onlyOwner {\n        bytes memory owner = ownerAtIndex(index);\n        if (owner.length == 0) revert NoOwnerAtIndex(index);\n\n        delete _getMultiOwnableStorage().isOwner[owner];\n        delete _getMultiOwnableStorage().ownerAtIndex[index];\n\n        emit RemoveOwner(index, owner);\n    }\n\n    /// @notice Checks if the given `account` address is registered as owner.\n    ///\n    /// @param account The account address to check.\n    ///\n    /// @return `true` if the account is an owner, else `false`.\n    function isOwnerAddress(address account) public view virtual returns (bool) {\n        return _getMultiOwnableStorage().isOwner[abi.encode(account)];\n    }\n\n    /// @notice Checks if the given `account` public key is registered as owner.\n    ///\n    /// @param x The public key x coordinate.\n    /// @param y The public key y coordinate.\n    ///\n    /// @return `true` if the account is an owner, else `false`.\n    function isOwnerPublicKey(bytes32 x, bytes32 y) public view virtual returns (bool) {\n        return _getMultiOwnableStorage().isOwner[abi.encode(x, y)];\n    }\n\n    /// @notice Checks if the given `account` raw bytes is registered as owner.\n    ///\n    /// @param account The account to check identified by its address or passkey.\n    ///\n    /// @return `true` if the account is an owner, else `false`.\n    function isOwnerBytes(bytes memory account) public view virtual returns (bool) {\n        return _getMultiOwnableStorage().isOwner[account];\n    }\n\n    /// @notice Returns the owner bytes at the given `index`.\n    ///\n    /// @param index The index to lookup.\n    ///\n    /// @return The owner bytes (empty if no owner is registered at this `index`).\n    function ownerAtIndex(uint256 index) public view virtual returns (bytes memory) {\n        return _getMultiOwnableStorage().ownerAtIndex[index];\n    }\n\n    /// @notice Returns the next index that will be used to add a new owner.\n    ///\n    /// @return The next index that will be used to add a new owner.\n    function nextOwnerIndex() public view virtual returns (uint256) {\n        return _getMultiOwnableStorage().nextOwnerIndex;\n    }\n\n    /// @notice Initialize the owners of this contract.\n    ///\n    /// @dev Intended to be called when the smart account is first deployed.\n    /// @dev Reverts if a provided owner is neither 64 bytes long (for passkey) nor a valid address.\n    ///\n    /// @param owners The intiial list of owners to register.\n    function _initializeOwners(bytes[] memory owners) internal virtual {\n        for (uint256 i; i < owners.length; i++) {\n            if (owners[i].length != 32 && owners[i].length != 64) {\n                revert InvalidOwnerBytesLength(owners[i]);\n            }\n\n            if (owners[i].length == 32 && uint256(bytes32(owners[i])) > type(uint160).max) {\n                revert InvalidEthereumAddressOwner(owners[i]);\n            }\n\n            _addOwnerAtIndex(owners[i], _getMultiOwnableStorage().nextOwnerIndex++);\n        }\n    }\n\n    /// @notice Convenience function used to add the first 255 owners.\n    ///\n    /// @param owner The owner raw bytes to add.\n    function _addOwner(bytes memory owner) internal virtual {\n        _addOwnerAtIndex(owner, _getMultiOwnableStorage().nextOwnerIndex++);\n    }\n\n    /// @notice Adds an owner at the given `index`.\n    ///\n    /// @dev Reverts if `owner` is already registered as an owner.\n    ///\n    /// @param owner The owner raw bytes to register.\n    /// @param index The index to write to.\n    function _addOwnerAtIndex(bytes memory owner, uint256 index) internal virtual {\n        if (isOwnerBytes(owner)) revert AlreadyOwner(owner);\n\n        _getMultiOwnableStorage().isOwner[owner] = true;\n        _getMultiOwnableStorage().ownerAtIndex[index] = owner;\n\n        emit AddOwner(index, owner);\n    }\n\n    /// @notice Checks if the sender is an owner of this contract or the contract itself.\n    ///\n    /// @dev Revert if the sender is not an owner fo the contract itself.\n    function _checkOwner() internal view virtual {\n        if (isOwnerAddress(msg.sender) || (msg.sender == address(this))) {\n            return;\n        }\n\n        revert Unauthorized();\n    }\n\n    /// @notice Helper function to get a storage reference to the `MultiOwnableStorage` struct.\n    ///\n    /// @return $ A storage reference to the `MultiOwnableStorage` struct.\n    function _getMultiOwnableStorage() internal pure returns (MultiOwnableStorage storage $) {\n        assembly (\"memory-safe\") {\n            $.slot := MUTLI_OWNABLE_STORAGE_LOCATION\n        }\n    }\n}"
    },
    {
      "filename": "src/SmartWallet/MultiOwnable.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Storage layout used by this contract.\n///\n/// @custom:storage-location erc7201:coinbase.storage.MultiOwnable\nstruct MultiOwnableStorage {\n    /// @dev Tracks the index of the next owner to add.\n    uint256 nextOwnerIndex;\n    /// @dev Mapping of indices to raw owner bytes, used to idenfitied owners by their\n    ///      uint256 id.\n    ///\n    ///      Some uses —-such as signature validation for secp256r1 public key owners—-\n    ///      requires the caller to assert which owner signed. To economize calldata,\n    ///      we allow an index to identify an owner, so that the full owner bytes do\n    ///      not need to be passed.\n    ///\n    ///      The underlying raw bytes can either be:\n    ///         - An abi encoded ethereum address\n    ///         - The abi encoded public key (x, y) coordinates when using passkey.\n    mapping(uint256 index => bytes owner) ownerAtIndex;\n    /// @dev Mapping of raw bytes accounts to booleans indicating whether or not the\n    ///      account is an owner of this contract.\n    mapping(bytes account => bool isOwner_) isOwner;\n}\n\n/// @title Multi Ownable\n///\n/// @notice Auth contract allowing multiple owners, each identified as bytes.\n///\n/// @author Coinbase (https://github.com/coinbase/smart-wallet)\ncontract MultiOwnable {\n    /// @dev Slot for the `MultiOwnableStorage` struct in storage.\n    ///      Computed from: keccak256(abi.encode(uint256(keccak256(\"coinbase.storage.MultiOwnable\")) - 1)) & ~bytes32(uint256(0xff))\n    ///      Follows ERC-7201 (see https://eips.ethereum.org/EIPS/eip-7201).\n    bytes32 private constant MUTLI_OWNABLE_STORAGE_LOCATION =\n        0x97e2c6aad4ce5d562ebfaa00db6b9e0fb66ea5d8162ed5b243f51a2e03086f00;\n\n    /// @notice Thrown when the sender is not an owner and is trying to call a privileged function.\n    error Unauthorized();\n\n    /// @notice Thrown when trying to add an already registered owner.\n    ///\n    /// @param owner The raw abi encoded owner bytes.\n    error AlreadyOwner(bytes owner);\n\n    /// @notice Thrown when trying to remove an owner from an index that is empty.\n    ///\n    /// @param index The targeted index for removal.\n    error NoOwnerAtIndex(uint256 index);\n\n    /// @notice Thrown when trying to intialize the contracts owners if a provided owner is neither\n    ///         64 bytes long (for passkey) nor a valid address.\n    ///\n    /// @param owner The invalid raw abi encoded owner bytes.\n    error InvalidOwnerBytesLength(bytes owner);\n\n    /// @notice Thrown when trying to intialize the contracts owners if a provided owner is 32 bytes\n    ///         long but does not fit in an `address` type (`uint160`).\n    ///\n    /// @param owner The invalid raw abi encoded owner bytes.\n    error InvalidEthereumAddressOwner(bytes owner);\n\n    /// @notice Emitted when a new owner is registered.\n    ///\n    /// @param index The owner index.\n    /// @param owner The raw abi encoded owner bytes.\n    event AddOwner(uint256 indexed index, bytes owner);\n\n    /// @notice Emitted when an owner is removed.\n    ///\n    /// @param index The owner index.\n    /// @param owner The raw abi encoded owner bytes.\n    event RemoveOwner(uint256 indexed index, bytes owner);\n\n    /// @notice Access control modifier ensuring the caller is an authorized owner\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n\n    /// @notice Convenience function to add a new owner address.\n    ///\n    /// @param owner The owner address.\n    function addOwnerAddress(address owner) public virtual onlyOwner {\n        _addOwner(abi.encode(owner));\n    }\n\n    /// @notice Convenience function to add a new owner passkey.\n    ///\n    /// @param x The owner public key x coordinate.\n    /// @param y The owner public key y coordinate.\n    function addOwnerPublicKey(bytes32 x, bytes32 y) public virtual onlyOwner {\n        _addOwner(abi.encode(x, y));\n    }\n\n    /// @notice Removes an owner from the given `index`.\n    ///\n    /// @dev Reverts if the owner is not registered at `index`.\n    ///\n    /// @param index The index to remove from.\n    function removeOwnerAtIndex(uint256 index) public virtual onlyOwner {\n        bytes memory owner = ownerAtIndex(index);\n        if (owner.length == 0) revert NoOwnerAtIndex(index);\n\n        delete _getMultiOwnableStorage().isOwner[owner];\n        delete _getMultiOwnableStorage().ownerAtIndex[index];\n\n        emit RemoveOwner(index, owner);\n    }\n\n    /// @notice Checks if the given `account` address is registered as owner.\n    ///\n    /// @param account The account address to check.\n    ///\n    /// @return `true` if the account is an owner, else `false`.\n    function isOwnerAddress(address account) public view virtual returns (bool) {\n        return _getMultiOwnableStorage().isOwner[abi.encode(account)];\n    }\n\n    /// @notice Checks if the given `account` public key is registered as owner.\n    ///\n    /// @param x The public key x coordinate.\n    /// @param y The public key y coordinate.\n    ///\n    /// @return `true` if the account is an owner, else `false`.\n    function isOwnerPublicKey(bytes32 x, bytes32 y) public view virtual returns (bool) {\n        return _getMultiOwnableStorage().isOwner[abi.encode(x, y)];\n    }\n\n    /// @notice Checks if the given `account` raw bytes is registered as owner.\n    ///\n    /// @param account The account to check identified by its address or passkey.\n    ///\n    /// @return `true` if the account is an owner, else `false`.\n    function isOwnerBytes(bytes memory account) public view virtual returns (bool) {\n        return _getMultiOwnableStorage().isOwner[account];\n    }\n\n    /// @notice Returns the owner bytes at the given `index`.\n    ///\n    /// @param index The index to lookup.\n    ///\n    /// @return The owner bytes (empty if no owner is registered at this `index`).\n    function ownerAtIndex(uint256 index) public view virtual returns (bytes memory) {\n        return _getMultiOwnableStorage().ownerAtIndex[index];\n    }\n\n    /// @notice Returns the next index that will be used to add a new owner.\n    ///\n    /// @return The next index that will be used to add a new owner.\n    function nextOwnerIndex() public view virtual returns (uint256) {\n        return _getMultiOwnableStorage().nextOwnerIndex;\n    }\n\n    /// @notice Initialize the owners of this contract.\n    ///\n    /// @dev Intended to be called when the smart account is first deployed.\n    /// @dev Reverts if a provided owner is neither 64 bytes long (for passkey) nor a valid address.\n    ///\n    /// @param owners The intiial list of owners to register.\n    function _initializeOwners(bytes[] memory owners) internal virtual {\n        for (uint256 i; i < owners.length; i++) {\n            if (owners[i].length != 32 && owners[i].length != 64) {\n                revert InvalidOwnerBytesLength(owners[i]);\n            }\n\n            if (owners[i].length == 32 && uint256(bytes32(owners[i])) > type(uint160).max) {\n                revert InvalidEthereumAddressOwner(owners[i]);\n            }\n\n            _addOwnerAtIndex(owners[i], _getMultiOwnableStorage().nextOwnerIndex++);\n        }\n    }\n\n    /// @notice Convenience function used to add the first 255 owners.\n    ///\n    /// @param owner The owner raw bytes to add.\n    function _addOwner(bytes memory owner) internal virtual {\n        _addOwnerAtIndex(owner, _getMultiOwnableStorage().nextOwnerIndex++);\n    }\n\n    /// @notice Adds an owner at the given `index`.\n    ///\n    /// @dev Reverts if `owner` is already registered as an owner.\n    ///\n    /// @param owner The owner raw bytes to register.\n    /// @param index The index to write to.\n    function _addOwnerAtIndex(bytes memory owner, uint256 index) internal virtual {\n        if (isOwnerBytes(owner)) revert AlreadyOwner(owner);\n\n        _getMultiOwnableStorage().isOwner[owner] = true;\n        _getMultiOwnableStorage().ownerAtIndex[index] = owner;\n\n        emit AddOwner(index, owner);\n    }\n\n    /// @notice Checks if the sender is an owner of this contract or the contract itself.\n    ///\n    /// @dev Revert if the sender is not an owner fo the contract itself.\n    function _checkOwner() internal view virtual {\n        if (isOwnerAddress(msg.sender) || (msg.sender == address(this))) {\n            return;\n        }\n\n        revert Unauthorized();\n    }\n\n    /// @notice Helper function to get a storage reference to the `MultiOwnableStorage` struct.\n    ///\n    /// @return $ A storage reference to the `MultiOwnableStorage` struct.\n    function _getMultiOwnableStorage() internal pure returns (MultiOwnableStorage storage $) {\n        assembly (\"memory-safe\") {\n            $.slot := MUTLI_OWNABLE_STORAGE_LOCATION\n        }\n    }\n}"
    },
    {
      "filename": "src/SmartWallet/MultiOwnable.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Storage layout used by this contract.\n///\n/// @custom:storage-location erc7201:coinbase.storage.MultiOwnable\nstruct MultiOwnableStorage {\n    /// @dev Tracks the index of the next owner to add.\n    uint256 nextOwnerIndex;\n    /// @dev Mapping of indices to raw owner bytes, used to idenfitied owners by their\n    ///      uint256 id.\n    ///\n    ///      Some uses —-such as signature validation for secp256r1 public key owners—-\n    ///      requires the caller to assert which owner signed. To economize calldata,\n    ///      we allow an index to identify an owner, so that the full owner bytes do\n    ///      not need to be passed.\n    ///\n    ///      The underlying raw bytes can either be:\n    ///         - An abi encoded ethereum address\n    ///         - The abi encoded public key (x, y) coordinates when using passkey.\n    mapping(uint256 index => bytes owner) ownerAtIndex;\n    /// @dev Mapping of raw bytes accounts to booleans indicating whether or not the\n    ///      account is an owner of this contract.\n    mapping(bytes account => bool isOwner_) isOwner;\n}\n\n/// @title Multi Ownable\n///\n/// @notice Auth contract allowing multiple owners, each identified as bytes.\n///\n/// @author Coinbase (https://github.com/coinbase/smart-wallet)\ncontract MultiOwnable {\n    /// @dev Slot for the `MultiOwnableStorage` struct in storage.\n    ///      Computed from: keccak256(abi.encode(uint256(keccak256(\"coinbase.storage.MultiOwnable\")) - 1)) & ~bytes32(uint256(0xff))\n    ///      Follows ERC-7201 (see https://eips.ethereum.org/EIPS/eip-7201).\n    bytes32 private constant MUTLI_OWNABLE_STORAGE_LOCATION =\n        0x97e2c6aad4ce5d562ebfaa00db6b9e0fb66ea5d8162ed5b243f51a2e03086f00;\n\n    /// @notice Thrown when the sender is not an owner and is trying to call a privileged function.\n    error Unauthorized();\n\n    /// @notice Thrown when trying to add an already registered owner.\n    ///\n    /// @param owner The raw abi encoded owner bytes.\n    error AlreadyOwner(bytes owner);\n\n    /// @notice Thrown when trying to remove an owner from an index that is empty.\n    ///\n    /// @param index The targeted index for removal.\n    error NoOwnerAtIndex(uint256 index);\n\n    /// @notice Thrown when trying to intialize the contracts owners if a provided owner is neither\n    ///         64 bytes long (for passkey) nor a valid address.\n    ///\n    /// @param owner The invalid raw abi encoded owner bytes.\n    error InvalidOwnerBytesLength(bytes owner);\n\n    /// @notice Thrown when trying to intialize the contracts owners if a provided owner is 32 bytes\n    ///         long but does not fit in an `address` type (`uint160`).\n    ///\n    /// @param owner The invalid raw abi encoded owner bytes.\n    error InvalidEthereumAddressOwner(bytes owner);\n\n    /// @notice Emitted when a new owner is registered.\n    ///\n    /// @param index The owner index.\n    /// @param owner The raw abi encoded owner bytes.\n    event AddOwner(uint256 indexed index, bytes owner);\n\n    /// @notice Emitted when an owner is removed.\n    ///\n    /// @param index The owner index.\n    /// @param owner The raw abi encoded owner bytes.\n    event RemoveOwner(uint256 indexed index, bytes owner);\n\n    /// @notice Access control modifier ensuring the caller is an authorized owner\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n\n    /// @notice Convenience function to add a new owner address.\n    ///\n    /// @param owner The owner address.\n    function addOwnerAddress(address owner) public virtual onlyOwner {\n        _addOwner(abi.encode(owner));\n    }\n\n    /// @notice Convenience function to add a new owner passkey.\n    ///\n    /// @param x The owner public key x coordinate.\n    /// @param y The owner public key y coordinate.\n    function addOwnerPublicKey(bytes32 x, bytes32 y) public virtual onlyOwner {\n        _addOwner(abi.encode(x, y));\n    }\n\n    /// @notice Removes an owner from the given `index`.\n    ///\n    /// @dev Reverts if the owner is not registered at `index`.\n    ///\n    /// @param index The index to remove from.\n    function removeOwnerAtIndex(uint256 index) public virtual onlyOwner {\n        bytes memory owner = ownerAtIndex(index);\n        if (owner.length == 0) revert NoOwnerAtIndex(index);\n\n        delete _getMultiOwnableStorage().isOwner[owner];\n        delete _getMultiOwnableStorage().ownerAtIndex[index];\n\n        emit RemoveOwner(index, owner);\n    }\n\n    /// @notice Checks if the given `account` address is registered as owner.\n    ///\n    /// @param account The account address to check.\n    ///\n    /// @return `true` if the account is an owner, else `false`.\n    function isOwnerAddress(address account) public view virtual returns (bool) {\n        return _getMultiOwnableStorage().isOwner[abi.encode(account)];\n    }\n\n    /// @notice Checks if the given `account` public key is registered as owner.\n    ///\n    /// @param x The public key x coordinate.\n    /// @param y The public key y coordinate.\n    ///\n    /// @return `true` if the account is an owner, else `false`.\n    function isOwnerPublicKey(bytes32 x, bytes32 y) public view virtual returns (bool) {\n        return _getMultiOwnableStorage().isOwner[abi.encode(x, y)];\n    }\n\n    /// @notice Checks if the given `account` raw bytes is registered as owner.\n    ///\n    /// @param account The account to check identified by its address or passkey.\n    ///\n    /// @return `true` if the account is an owner, else `false`.\n    function isOwnerBytes(bytes memory account) public view virtual returns (bool) {\n        return _getMultiOwnableStorage().isOwner[account];\n    }\n\n    /// @notice Returns the owner bytes at the given `index`.\n    ///\n    /// @param index The index to lookup.\n    ///\n    /// @return The owner bytes (empty if no owner is registered at this `index`).\n    function ownerAtIndex(uint256 index) public view virtual returns (bytes memory) {\n        return _getMultiOwnableStorage().ownerAtIndex[index];\n    }\n\n    /// @notice Returns the next index that will be used to add a new owner.\n    ///\n    /// @return The next index that will be used to add a new owner.\n    function nextOwnerIndex() public view virtual returns (uint256) {\n        return _getMultiOwnableStorage().nextOwnerIndex;\n    }\n\n    /// @notice Initialize the owners of this contract.\n    ///\n    /// @dev Intended to be called when the smart account is first deployed.\n    /// @dev Reverts if a provided owner is neither 64 bytes long (for passkey) nor a valid address.\n    ///\n    /// @param owners The intiial list of owners to register.\n    function _initializeOwners(bytes[] memory owners) internal virtual {\n        for (uint256 i; i < owners.length; i++) {\n            if (owners[i].length != 32 && owners[i].length != 64) {\n                revert InvalidOwnerBytesLength(owners[i]);\n            }\n\n            if (owners[i].length == 32 && uint256(bytes32(owners[i])) > type(uint160).max) {\n                revert InvalidEthereumAddressOwner(owners[i]);\n            }\n\n            _addOwnerAtIndex(owners[i], _getMultiOwnableStorage().nextOwnerIndex++);\n        }\n    }\n\n    /// @notice Convenience function used to add the first 255 owners.\n    ///\n    /// @param owner The owner raw bytes to add.\n    function _addOwner(bytes memory owner) internal virtual {\n        _addOwnerAtIndex(owner, _getMultiOwnableStorage().nextOwnerIndex++);\n    }\n\n    /// @notice Adds an owner at the given `index`.\n    ///\n    /// @dev Reverts if `owner` is already registered as an owner.\n    ///\n    /// @param owner The owner raw bytes to register.\n    /// @param index The index to write to.\n    function _addOwnerAtIndex(bytes memory owner, uint256 index) internal virtual {\n        if (isOwnerBytes(owner)) revert AlreadyOwner(owner);\n\n        _getMultiOwnableStorage().isOwner[owner] = true;\n        _getMultiOwnableStorage().ownerAtIndex[index] = owner;\n\n        emit AddOwner(index, owner);\n    }\n\n    /// @notice Checks if the sender is an owner of this contract or the contract itself.\n    ///\n    /// @dev Revert if the sender is not an owner fo the contract itself.\n    function _checkOwner() internal view virtual {\n        if (isOwnerAddress(msg.sender) || (msg.sender == address(this))) {\n            return;\n        }\n\n        revert Unauthorized();\n    }\n\n    /// @notice Helper function to get a storage reference to the `MultiOwnableStorage` struct.\n    ///\n    /// @return $ A storage reference to the `MultiOwnableStorage` struct.\n    function _getMultiOwnableStorage() internal pure returns (MultiOwnableStorage storage $) {\n        assembly (\"memory-safe\") {\n            $.slot := MUTLI_OWNABLE_STORAGE_LOCATION\n        }\n    }\n}"
    }
  ]
}