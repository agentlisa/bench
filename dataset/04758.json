{
  "Title": "[N-03] Incorrect comment associated with `CoinbaseSmartWallet._validateSignature()`",
  "Content": "The comment below is inaccurate,\n\nhttps://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol#L301-L306\n\n```solidity\n        if (ownerBytes.length == 32) {\n            if (uint256(bytes32(ownerBytes)) > type(uint160).max) {\n                // technically should be impossible given owners can only be added with @audit\n                // addOwnerAddress and addOwnerPublicKey, but we leave incase of future changes. @audit\n                revert InvalidEthereumAddressOwner(ownerBytes);\n            }\n```\ngiven the fact that `addOwnerAddress()` and `addOwnerPublicKey()` both invoking `_addOwner()`,\n\nhttps://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol#L179-L181\n\n```solidity\n    function _addOwner(bytes memory owner) internal virtual {\n        _addOwnerAtIndex(owner, _getMultiOwnableStorage().nextOwnerIndex++);\n    }\n```\ndo not have checks as implemented in `_initializeOwners()`,\n\nhttps://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol#L168-L170\n\n```solidity\n            if (owners[i].length == 32 && uint256(bytes32(owners[i])) > type(uint160).max) {\n                revert InvalidEthereumAddressOwner(owners[i]);\n            }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-coinbase",
  "Code": [
    {
      "filename": "src/SmartWallet/CoinbaseSmartWallet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {Receiver} from \"solady/accounts/Receiver.sol\";\nimport {UUPSUpgradeable} from \"solady/utils/UUPSUpgradeable.sol\";\nimport {SignatureCheckerLib} from \"solady/utils/SignatureCheckerLib.sol\";\nimport {UserOperation, UserOperationLib} from \"account-abstraction/interfaces/UserOperation.sol\";\nimport {WebAuthn} from \"../WebAuthnSol/WebAuthn.sol\";\n\nimport {ERC1271} from \"./ERC1271.sol\";\nimport {MultiOwnable} from \"./MultiOwnable.sol\";\n\n/// @title Coinbase Smart Wallet\n///\n/// @notice ERC4337-compatible smart contract wallet, based on Solady ERC4337 account implementation\n///         with inspiration from Alchemy's LightAccount and Daimo's DaimoAccount.\n///\n/// @author Coinbase (https://github.com/coinbase/smart-wallet)\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/ERC4337.sol)\ncontract CoinbaseSmartWallet is MultiOwnable, UUPSUpgradeable, Receiver, ERC1271 {\n    /// @notice Wrapper struct, used during signature validation, tie a signature with its signer.\n    struct SignatureWrapper {\n        /// @dev The index indentifying owner (see MultiOwnable) who signed.\n        uint256 ownerIndex;\n        /// @dev An ABI encoded ECDSA signature (r, s, v) or WebAuthnAuth struct.\n        bytes signatureData;\n    }\n\n    /// @notice Wrapper struct, used in `executeBatch`, describing a raw call to execute.\n    struct Call {\n        /// @dev The target address to call.\n        address target;\n        /// @dev The value to associate with the call.\n        uint256 value;\n        /// @dev The raw call data.\n        bytes data;\n    }\n\n    /// @notice Reserved nonce key (upper 192 bits of `UserOperation.nonce`) for cross-chain replayable\n    ///         transactions.\n    ///\n    /// @dev Helps enforce sequential sequencing of replayable transactions.\n    uint256 public constant REPLAYABLE_NONCE_KEY = 8453;\n\n    /// @notice Thrown when trying to re-initialize an account.\n    error Initialized();\n\n    /// @notice Thrown when executing a `UserOperation` that requires the chain ID to be validated\n    ///         but this validation has been omitted.\n    ///\n    /// @dev Whitelisting of `UserOperation`s that are allowed to skip the chain ID validation is\n    ///      based on their call selectors (see `canSkipChainIdValidation()`).\n    ///\n    /// @param selector The user operation call selector that raised the error.\n    error SelectorNotAllowed(bytes4 selector);\n\n    /// @notice Thrown during a `UserOperation` validation when its key is invalid.\n    ///\n    /// @dev The `UserOperation` key validation is based on the `UserOperation` call selector.\n    ///\n    /// @param key The invalid `UserOperation` key.\n    error InvalidNonceKey(uint256 key);\n\n    /// @notice Reverts if the caller is not the EntryPoint.\n    modifier onlyEntryPoint() virtual {\n        if (msg.sender != entryPoint()) {\n            revert Unauthorized();\n        }\n\n        _;\n    }\n\n    /// @notice Reverts if the caller is neither the EntryPoint, the owner, nor the account itself.\n    modifier onlyEntryPointOrOwner() virtual {\n        if (msg.sender != entryPoint()) {\n            _checkOwner();\n        }\n\n        _;\n    }\n\n    /// @notice Sends to the EntryPoint (i.e. `msg.sender`) the missing funds for this transaction.\n    ///\n    /// @dev Subclass MAY override this modifier for better funds management (e.g. send to the\n    ///      EntryPoint more than the minimum required, so that in future transactions it will not\n    ///      be required to send again).\n    ///\n    /// @param missingAccountFunds The minimum value this modifier should send the EntryPoint which\n    ///                            MAY be zero, in case there is enough deposit, or the userOp has a\n    ///                            paymaster.\n    modifier payPrefund(uint256 missingAccountFunds) virtual {\n        _;\n\n        assembly (\"memory-safe\") {\n            if missingAccountFunds {\n                // Ignore failure (it's EntryPoint's job to verify, not the account's).\n                pop(call(gas(), caller(), missingAccountFunds, codesize(), 0x00, codesize(), 0x00))\n            }\n        }\n    }\n\n    constructor() {\n        // Implementation should not be initializable (does not affect proxies which use their own storage).\n        bytes[] memory owners = new bytes[](1);\n        owners[0] = abi.encode(address(0));\n        _initializeOwners(owners);\n    }\n\n    /// @notice Initializes the account with the the given owners.\n    ///\n    /// @dev Reverts if the account has already been initialized.\n    ///\n    /// @param owners The initial array of owners to initialize this account with.\n    function initialize(bytes[] calldata owners) public payable virtual {\n        if (nextOwnerIndex() != 0) {\n            revert Initialized();\n        }\n\n        _initializeOwners(owners);\n    }\n\n    /// @notice Custom implemenentation of the ERC-4337 `validateUserOp` method. The EntryPoint will\n    ///         make the call to the recipient only if this validation call returns successfully.\n    ///         See `IAccount.validateUserOp()`.\n    ///\n    /// @dev Signature failure should be reported by returning 1 (see: `_validateSignature()`). This\n    ///      allows making a \"simulation call\" without a valid signature. Other failures (e.g. nonce\n    ///      mismatch, or invalid signature format) should still revert to signal failure.\n    /// @dev Reverts if the `UserOperation` key is invalid.\n    /// @dev Reverts if the signature verification fails (except for the case mentionned earlier).\n    ///\n    /// @param userOp              The `UserOperation` to validate.\n    /// @param userOpHash          The `UserOperation` hash (including the chain ID).\n    /// @param missingAccountFunds The missing account funds that must be deposited on the Entrypoint.\n    ///\n    /// @return validationData The encoded `ValidationData` structure.\n    function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds)\n        public\n        payable\n        virtual\n        onlyEntryPoint\n        payPrefund(missingAccountFunds)\n        returns (uint256 validationData)\n    {\n        uint256 key = userOp.nonce >> 64;\n\n        // 0xbf6ba1fc = bytes4(keccak256(\"executeWithoutChainIdValidation(bytes)\"))\n        if (userOp.callData.length >= 4 && bytes4(userOp.callData[0:4]) == 0xbf6ba1fc) {\n            userOpHash = getUserOpHashWithoutChainId(userOp);\n            if (key != REPLAYABLE_NONCE_KEY) {\n                revert InvalidNonceKey(key);\n            }\n        } else {\n            if (key == REPLAYABLE_NONCE_KEY) {\n                revert InvalidNonceKey(key);\n            }\n        }\n\n        // Return 0 if the recovered address matches the owner.\n        if (_validateSignature(userOpHash, userOp.signature)) {\n            return 0;\n        }\n\n        // Else return 1, which is equivalent to:\n        // `(uint256(validAfter) << (160 + 48)) | (uint256(validUntil) << 160) | (success ? 0 : 1)`\n        // where `validUntil` is 0 (indefinite) and `validAfter` is 0.\n        return 1;\n    }\n\n    /// @notice Execute the given call from this account to this account (i.e., self call).\n    ///\n    /// @dev Can only be called by the Entrypoint.\n    /// @dev Reverts if the given call is not authorized to skip the chain ID validtion.\n    /// @dev `validateUserOp()` will recompute the `userOpHash` without the chain ID befor validatin\n    ///      it if the `UserOperation` aims at executing this function. This allows certain operations\n    ///      to be replayed for all accounts sharing the same address across chains. E.g. This may be\n    ///      useful for syncing owner changes.\n    ///\n    /// @param data The `UserOperation` raw call data of the  execute.\n    function executeWithoutChainIdValidation(bytes calldata data) public payable virtual onlyEntryPoint {\n        bytes4 selector = bytes4(data[0:4]);\n        if (!canSkipChainIdValidation(selector)) {\n            revert SelectorNotAllowed(selector);\n        }\n\n        _call(address(this), 0, data);\n    }\n\n    /// @notice Execute the given call from this account.\n    ///\n    /// @dev Can only be called by the Entrypoint or an owner of this account (including itself).\n    ///\n    /// @param target The target call address.\n    /// @param value  The call value to user.\n    /// @param data   The raw call data.\n    function execute(address target, uint256 value, bytes calldata data) public payable virtual onlyEntryPointOrOwner {\n        _call(target, value, data);\n    }\n\n    /// @notice Execute the given list of calls from this account.\n    ///\n    /// @dev Can only be called by the Entrypoint or an owner of this account (including itself).\n    ///\n    /// @param calls The list of `Call`s to execute.\n    function executeBatch(Call[] calldata calls) public payable virtual onlyEntryPointOrOwner {\n        for (uint256 i; i < calls.length;) {\n            _call(calls[i].target, calls[i].value, calls[i].data);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Returns the address of the EntryPoint v0.6.\n    ///\n    /// @return The address of the EntryPoint v0.6\n    function entryPoint() public view virtual returns (address) {\n        return 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789;\n    }\n\n    /// @notice Computes the hash of the `UserOperation` in the same way as EntryPoint v0.6, but\n    ///         leaves out the chain ID.\n    ///\n    /// @dev This allows accounts to sign a hash that can be used on many chains.\n    ///\n    /// @param userOp The `UserOperation` to compute the hash for.\n    ///\n    /// @return userOpHash The `UserOperation` hash, not including the chain ID.\n    function getUserOpHashWithoutChainId(UserOperation calldata userOp)\n        public\n        view\n        virtual\n        returns (bytes32 userOpHash)\n    {\n        return keccak256(abi.encode(UserOperationLib.hash(userOp), entryPoint()));\n    }\n\n    /// @notice Returns the implementation of the ERC1967 proxy.\n    ///\n    /// @return $ The address of implementation contract.\n    function implementation() public view returns (address $) {\n        assembly {\n            $ := sload(_ERC1967_IMPLEMENTATION_SLOT)\n        }\n    }\n\n    /// @notice Check if the given function selector is whitelisted to skip the chain ID validation.\n    ///\n    /// @param functionSelector The function selector to check.\n    ////\n    /// @return `true` is the function selector is whitelisted to skip the chain ID validation, else `false`.\n    function canSkipChainIdValidation(bytes4 functionSelector) public pure returns (bool) {\n        if (\n            functionSelector == MultiOwnable.addOwnerPublicKey.selector\n                || functionSelector == MultiOwnable.addOwnerAddress.selector\n                || functionSelector == MultiOwnable.removeOwnerAtIndex.selector\n                || functionSelector == UUPSUpgradeable.upgradeToAndCall.selector\n        ) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @notice Execute the given call from this account.\n    ///\n    /// @dev Reverts if the call reverted.\n    /// @dev Impl taken from https://github.com/alchemyplatform/light-account/blob/main/src/LightAccount.sol#L347\n    ///\n    /// @param target The target call address.\n    /// @param value  The call value to user.\n    /// @param data   The raw call data.\n    function _call(address target, uint256 value, bytes memory data) internal {\n        (bool success, bytes memory result) = target.call{value: value}(data);\n        if (!success) {\n            assembly (\"memory-safe\") {\n                revert(add(result, 32), mload(result))\n            }\n        }\n    }\n\n    /// @inheritdoc ERC1271\n    ///\n    /// @dev Used both for classic ERC-1271 signature AND `UserOperation` validations.\n    /// @dev Reverts if the signer (based on the `ownerIndex`) is not compatible with the signature.\n    /// @dev Reverts if the signature does not correspond to an ERC-1271 signature or to the abi\n    ///      encoded version of a `WebAuthnAuth` struct.\n    /// @dev Does NOT revert if the signature verification fails to allow making a \"simulation call\"\n    ///      without a valid signature.\n    ///\n    /// @param signature The abi encoded `SignatureWrapper` struct.\n    function _validateSignature(bytes32 message, bytes calldata signature)\n        internal\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        SignatureWrapper memory sigWrapper = abi.decode(signature, (SignatureWrapper));\n        bytes memory ownerBytes = ownerAtIndex(sigWrapper.ownerIndex);\n\n        if (ownerBytes.length == 32) {\n            if (uint256(bytes32(ownerBytes)) > type(uint160).max) {\n                // technically should be impossible given owners can only be added with\n                // addOwnerAddress and addOwnerPublicKey, but we leave incase of future changes.\n                revert InvalidEthereumAddressOwner(ownerBytes);\n            }\n\n            address owner;\n            assembly (\"memory-safe\") {\n                owner := mload(add(ownerBytes, 32))\n            }\n\n            return SignatureCheckerLib.isValidSignatureNow(owner, message, sigWrapper.signatureData);\n        }\n\n        if (ownerBytes.length == 64) {\n            (uint256 x, uint256 y) = abi.decode(ownerBytes, (uint256, uint256));\n\n            WebAuthn.WebAuthnAuth memory auth = abi.decode(sigWrapper.signatureData, (WebAuthn.WebAuthnAuth));\n\n            return WebAuthn.verify({challenge: abi.encode(message), requireUV: false, webAuthnAuth: auth, x: x, y: y});\n        }\n\n        revert InvalidOwnerBytesLength(ownerBytes);\n    }\n\n    /// @inheritdoc UUPSUpgradeable\n    ///\n    /// @dev Authorization logic is only based on the sender being an owner of this account.\n    function _authorizeUpgrade(address) internal view virtual override(UUPSUpgradeable) onlyOwner {}\n\n    /// @inheritdoc ERC1271\n    function _domainNameAndVersion() internal pure override(ERC1271) returns (string memory, string memory) {\n        return (\"Coinbase Smart Wallet\", \"1\");\n    }\n}"
    },
    {
      "filename": "src/SmartWallet/MultiOwnable.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Storage layout used by this contract.\n///\n/// @custom:storage-location erc7201:coinbase.storage.MultiOwnable\nstruct MultiOwnableStorage {\n    /// @dev Tracks the index of the next owner to add.\n    uint256 nextOwnerIndex;\n    /// @dev Mapping of indices to raw owner bytes, used to idenfitied owners by their\n    ///      uint256 id.\n    ///\n    ///      Some uses —-such as signature validation for secp256r1 public key owners—-\n    ///      requires the caller to assert which owner signed. To economize calldata,\n    ///      we allow an index to identify an owner, so that the full owner bytes do\n    ///      not need to be passed.\n    ///\n    ///      The underlying raw bytes can either be:\n    ///         - An abi encoded ethereum address\n    ///         - The abi encoded public key (x, y) coordinates when using passkey.\n    mapping(uint256 index => bytes owner) ownerAtIndex;\n    /// @dev Mapping of raw bytes accounts to booleans indicating whether or not the\n    ///      account is an owner of this contract.\n    mapping(bytes account => bool isOwner_) isOwner;\n}\n\n/// @title Multi Ownable\n///\n/// @notice Auth contract allowing multiple owners, each identified as bytes.\n///\n/// @author Coinbase (https://github.com/coinbase/smart-wallet)\ncontract MultiOwnable {\n    /// @dev Slot for the `MultiOwnableStorage` struct in storage.\n    ///      Computed from: keccak256(abi.encode(uint256(keccak256(\"coinbase.storage.MultiOwnable\")) - 1)) & ~bytes32(uint256(0xff))\n    ///      Follows ERC-7201 (see https://eips.ethereum.org/EIPS/eip-7201).\n    bytes32 private constant MUTLI_OWNABLE_STORAGE_LOCATION =\n        0x97e2c6aad4ce5d562ebfaa00db6b9e0fb66ea5d8162ed5b243f51a2e03086f00;\n\n    /// @notice Thrown when the sender is not an owner and is trying to call a privileged function.\n    error Unauthorized();\n\n    /// @notice Thrown when trying to add an already registered owner.\n    ///\n    /// @param owner The raw abi encoded owner bytes.\n    error AlreadyOwner(bytes owner);\n\n    /// @notice Thrown when trying to remove an owner from an index that is empty.\n    ///\n    /// @param index The targeted index for removal.\n    error NoOwnerAtIndex(uint256 index);\n\n    /// @notice Thrown when trying to intialize the contracts owners if a provided owner is neither\n    ///         64 bytes long (for passkey) nor a valid address.\n    ///\n    /// @param owner The invalid raw abi encoded owner bytes.\n    error InvalidOwnerBytesLength(bytes owner);\n\n    /// @notice Thrown when trying to intialize the contracts owners if a provided owner is 32 bytes\n    ///         long but does not fit in an `address` type (`uint160`).\n    ///\n    /// @param owner The invalid raw abi encoded owner bytes.\n    error InvalidEthereumAddressOwner(bytes owner);\n\n    /// @notice Emitted when a new owner is registered.\n    ///\n    /// @param index The owner index.\n    /// @param owner The raw abi encoded owner bytes.\n    event AddOwner(uint256 indexed index, bytes owner);\n\n    /// @notice Emitted when an owner is removed.\n    ///\n    /// @param index The owner index.\n    /// @param owner The raw abi encoded owner bytes.\n    event RemoveOwner(uint256 indexed index, bytes owner);\n\n    /// @notice Access control modifier ensuring the caller is an authorized owner\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n\n    /// @notice Convenience function to add a new owner address.\n    ///\n    /// @param owner The owner address.\n    function addOwnerAddress(address owner) public virtual onlyOwner {\n        _addOwner(abi.encode(owner));\n    }\n\n    /// @notice Convenience function to add a new owner passkey.\n    ///\n    /// @param x The owner public key x coordinate.\n    /// @param y The owner public key y coordinate.\n    function addOwnerPublicKey(bytes32 x, bytes32 y) public virtual onlyOwner {\n        _addOwner(abi.encode(x, y));\n    }\n\n    /// @notice Removes an owner from the given `index`.\n    ///\n    /// @dev Reverts if the owner is not registered at `index`.\n    ///\n    /// @param index The index to remove from.\n    function removeOwnerAtIndex(uint256 index) public virtual onlyOwner {\n        bytes memory owner = ownerAtIndex(index);\n        if (owner.length == 0) revert NoOwnerAtIndex(index);\n\n        delete _getMultiOwnableStorage().isOwner[owner];\n        delete _getMultiOwnableStorage().ownerAtIndex[index];\n\n        emit RemoveOwner(index, owner);\n    }\n\n    /// @notice Checks if the given `account` address is registered as owner.\n    ///\n    /// @param account The account address to check.\n    ///\n    /// @return `true` if the account is an owner, else `false`.\n    function isOwnerAddress(address account) public view virtual returns (bool) {\n        return _getMultiOwnableStorage().isOwner[abi.encode(account)];\n    }\n\n    /// @notice Checks if the given `account` public key is registered as owner.\n    ///\n    /// @param x The public key x coordinate.\n    /// @param y The public key y coordinate.\n    ///\n    /// @return `true` if the account is an owner, else `false`.\n    function isOwnerPublicKey(bytes32 x, bytes32 y) public view virtual returns (bool) {\n        return _getMultiOwnableStorage().isOwner[abi.encode(x, y)];\n    }\n\n    /// @notice Checks if the given `account` raw bytes is registered as owner.\n    ///\n    /// @param account The account to check identified by its address or passkey.\n    ///\n    /// @return `true` if the account is an owner, else `false`.\n    function isOwnerBytes(bytes memory account) public view virtual returns (bool) {\n        return _getMultiOwnableStorage().isOwner[account];\n    }\n\n    /// @notice Returns the owner bytes at the given `index`.\n    ///\n    /// @param index The index to lookup.\n    ///\n    /// @return The owner bytes (empty if no owner is registered at this `index`).\n    function ownerAtIndex(uint256 index) public view virtual returns (bytes memory) {\n        return _getMultiOwnableStorage().ownerAtIndex[index];\n    }\n\n    /// @notice Returns the next index that will be used to add a new owner.\n    ///\n    /// @return The next index that will be used to add a new owner.\n    function nextOwnerIndex() public view virtual returns (uint256) {\n        return _getMultiOwnableStorage().nextOwnerIndex;\n    }\n\n    /// @notice Initialize the owners of this contract.\n    ///\n    /// @dev Intended to be called when the smart account is first deployed.\n    /// @dev Reverts if a provided owner is neither 64 bytes long (for passkey) nor a valid address.\n    ///\n    /// @param owners The intiial list of owners to register.\n    function _initializeOwners(bytes[] memory owners) internal virtual {\n        for (uint256 i; i < owners.length; i++) {\n            if (owners[i].length != 32 && owners[i].length != 64) {\n                revert InvalidOwnerBytesLength(owners[i]);\n            }\n\n            if (owners[i].length == 32 && uint256(bytes32(owners[i])) > type(uint160).max) {\n                revert InvalidEthereumAddressOwner(owners[i]);\n            }\n\n            _addOwnerAtIndex(owners[i], _getMultiOwnableStorage().nextOwnerIndex++);\n        }\n    }\n\n    /// @notice Convenience function used to add the first 255 owners.\n    ///\n    /// @param owner The owner raw bytes to add.\n    function _addOwner(bytes memory owner) internal virtual {\n        _addOwnerAtIndex(owner, _getMultiOwnableStorage().nextOwnerIndex++);\n    }\n\n    /// @notice Adds an owner at the given `index`.\n    ///\n    /// @dev Reverts if `owner` is already registered as an owner.\n    ///\n    /// @param owner The owner raw bytes to register.\n    /// @param index The index to write to.\n    function _addOwnerAtIndex(bytes memory owner, uint256 index) internal virtual {\n        if (isOwnerBytes(owner)) revert AlreadyOwner(owner);\n\n        _getMultiOwnableStorage().isOwner[owner] = true;\n        _getMultiOwnableStorage().ownerAtIndex[index] = owner;\n\n        emit AddOwner(index, owner);\n    }\n\n    /// @notice Checks if the sender is an owner of this contract or the contract itself.\n    ///\n    /// @dev Revert if the sender is not an owner fo the contract itself.\n    function _checkOwner() internal view virtual {\n        if (isOwnerAddress(msg.sender) || (msg.sender == address(this))) {\n            return;\n        }\n\n        revert Unauthorized();\n    }\n\n    /// @notice Helper function to get a storage reference to the `MultiOwnableStorage` struct.\n    ///\n    /// @return $ A storage reference to the `MultiOwnableStorage` struct.\n    function _getMultiOwnableStorage() internal pure returns (MultiOwnableStorage storage $) {\n        assembly (\"memory-safe\") {\n            $.slot := MUTLI_OWNABLE_STORAGE_LOCATION\n        }\n    }\n}"
    },
    {
      "filename": "src/SmartWallet/MultiOwnable.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Storage layout used by this contract.\n///\n/// @custom:storage-location erc7201:coinbase.storage.MultiOwnable\nstruct MultiOwnableStorage {\n    /// @dev Tracks the index of the next owner to add.\n    uint256 nextOwnerIndex;\n    /// @dev Mapping of indices to raw owner bytes, used to idenfitied owners by their\n    ///      uint256 id.\n    ///\n    ///      Some uses —-such as signature validation for secp256r1 public key owners—-\n    ///      requires the caller to assert which owner signed. To economize calldata,\n    ///      we allow an index to identify an owner, so that the full owner bytes do\n    ///      not need to be passed.\n    ///\n    ///      The underlying raw bytes can either be:\n    ///         - An abi encoded ethereum address\n    ///         - The abi encoded public key (x, y) coordinates when using passkey.\n    mapping(uint256 index => bytes owner) ownerAtIndex;\n    /// @dev Mapping of raw bytes accounts to booleans indicating whether or not the\n    ///      account is an owner of this contract.\n    mapping(bytes account => bool isOwner_) isOwner;\n}\n\n/// @title Multi Ownable\n///\n/// @notice Auth contract allowing multiple owners, each identified as bytes.\n///\n/// @author Coinbase (https://github.com/coinbase/smart-wallet)\ncontract MultiOwnable {\n    /// @dev Slot for the `MultiOwnableStorage` struct in storage.\n    ///      Computed from: keccak256(abi.encode(uint256(keccak256(\"coinbase.storage.MultiOwnable\")) - 1)) & ~bytes32(uint256(0xff))\n    ///      Follows ERC-7201 (see https://eips.ethereum.org/EIPS/eip-7201).\n    bytes32 private constant MUTLI_OWNABLE_STORAGE_LOCATION =\n        0x97e2c6aad4ce5d562ebfaa00db6b9e0fb66ea5d8162ed5b243f51a2e03086f00;\n\n    /// @notice Thrown when the sender is not an owner and is trying to call a privileged function.\n    error Unauthorized();\n\n    /// @notice Thrown when trying to add an already registered owner.\n    ///\n    /// @param owner The raw abi encoded owner bytes.\n    error AlreadyOwner(bytes owner);\n\n    /// @notice Thrown when trying to remove an owner from an index that is empty.\n    ///\n    /// @param index The targeted index for removal.\n    error NoOwnerAtIndex(uint256 index);\n\n    /// @notice Thrown when trying to intialize the contracts owners if a provided owner is neither\n    ///         64 bytes long (for passkey) nor a valid address.\n    ///\n    /// @param owner The invalid raw abi encoded owner bytes.\n    error InvalidOwnerBytesLength(bytes owner);\n\n    /// @notice Thrown when trying to intialize the contracts owners if a provided owner is 32 bytes\n    ///         long but does not fit in an `address` type (`uint160`).\n    ///\n    /// @param owner The invalid raw abi encoded owner bytes.\n    error InvalidEthereumAddressOwner(bytes owner);\n\n    /// @notice Emitted when a new owner is registered.\n    ///\n    /// @param index The owner index.\n    /// @param owner The raw abi encoded owner bytes.\n    event AddOwner(uint256 indexed index, bytes owner);\n\n    /// @notice Emitted when an owner is removed.\n    ///\n    /// @param index The owner index.\n    /// @param owner The raw abi encoded owner bytes.\n    event RemoveOwner(uint256 indexed index, bytes owner);\n\n    /// @notice Access control modifier ensuring the caller is an authorized owner\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n\n    /// @notice Convenience function to add a new owner address.\n    ///\n    /// @param owner The owner address.\n    function addOwnerAddress(address owner) public virtual onlyOwner {\n        _addOwner(abi.encode(owner));\n    }\n\n    /// @notice Convenience function to add a new owner passkey.\n    ///\n    /// @param x The owner public key x coordinate.\n    /// @param y The owner public key y coordinate.\n    function addOwnerPublicKey(bytes32 x, bytes32 y) public virtual onlyOwner {\n        _addOwner(abi.encode(x, y));\n    }\n\n    /// @notice Removes an owner from the given `index`.\n    ///\n    /// @dev Reverts if the owner is not registered at `index`.\n    ///\n    /// @param index The index to remove from.\n    function removeOwnerAtIndex(uint256 index) public virtual onlyOwner {\n        bytes memory owner = ownerAtIndex(index);\n        if (owner.length == 0) revert NoOwnerAtIndex(index);\n\n        delete _getMultiOwnableStorage().isOwner[owner];\n        delete _getMultiOwnableStorage().ownerAtIndex[index];\n\n        emit RemoveOwner(index, owner);\n    }\n\n    /// @notice Checks if the given `account` address is registered as owner.\n    ///\n    /// @param account The account address to check.\n    ///\n    /// @return `true` if the account is an owner, else `false`.\n    function isOwnerAddress(address account) public view virtual returns (bool) {\n        return _getMultiOwnableStorage().isOwner[abi.encode(account)];\n    }\n\n    /// @notice Checks if the given `account` public key is registered as owner.\n    ///\n    /// @param x The public key x coordinate.\n    /// @param y The public key y coordinate.\n    ///\n    /// @return `true` if the account is an owner, else `false`.\n    function isOwnerPublicKey(bytes32 x, bytes32 y) public view virtual returns (bool) {\n        return _getMultiOwnableStorage().isOwner[abi.encode(x, y)];\n    }\n\n    /// @notice Checks if the given `account` raw bytes is registered as owner.\n    ///\n    /// @param account The account to check identified by its address or passkey.\n    ///\n    /// @return `true` if the account is an owner, else `false`.\n    function isOwnerBytes(bytes memory account) public view virtual returns (bool) {\n        return _getMultiOwnableStorage().isOwner[account];\n    }\n\n    /// @notice Returns the owner bytes at the given `index`.\n    ///\n    /// @param index The index to lookup.\n    ///\n    /// @return The owner bytes (empty if no owner is registered at this `index`).\n    function ownerAtIndex(uint256 index) public view virtual returns (bytes memory) {\n        return _getMultiOwnableStorage().ownerAtIndex[index];\n    }\n\n    /// @notice Returns the next index that will be used to add a new owner.\n    ///\n    /// @return The next index that will be used to add a new owner.\n    function nextOwnerIndex() public view virtual returns (uint256) {\n        return _getMultiOwnableStorage().nextOwnerIndex;\n    }\n\n    /// @notice Initialize the owners of this contract.\n    ///\n    /// @dev Intended to be called when the smart account is first deployed.\n    /// @dev Reverts if a provided owner is neither 64 bytes long (for passkey) nor a valid address.\n    ///\n    /// @param owners The intiial list of owners to register.\n    function _initializeOwners(bytes[] memory owners) internal virtual {\n        for (uint256 i; i < owners.length; i++) {\n            if (owners[i].length != 32 && owners[i].length != 64) {\n                revert InvalidOwnerBytesLength(owners[i]);\n            }\n\n            if (owners[i].length == 32 && uint256(bytes32(owners[i])) > type(uint160).max) {\n                revert InvalidEthereumAddressOwner(owners[i]);\n            }\n\n            _addOwnerAtIndex(owners[i], _getMultiOwnableStorage().nextOwnerIndex++);\n        }\n    }\n\n    /// @notice Convenience function used to add the first 255 owners.\n    ///\n    /// @param owner The owner raw bytes to add.\n    function _addOwner(bytes memory owner) internal virtual {\n        _addOwnerAtIndex(owner, _getMultiOwnableStorage().nextOwnerIndex++);\n    }\n\n    /// @notice Adds an owner at the given `index`.\n    ///\n    /// @dev Reverts if `owner` is already registered as an owner.\n    ///\n    /// @param owner The owner raw bytes to register.\n    /// @param index The index to write to.\n    function _addOwnerAtIndex(bytes memory owner, uint256 index) internal virtual {\n        if (isOwnerBytes(owner)) revert AlreadyOwner(owner);\n\n        _getMultiOwnableStorage().isOwner[owner] = true;\n        _getMultiOwnableStorage().ownerAtIndex[index] = owner;\n\n        emit AddOwner(index, owner);\n    }\n\n    /// @notice Checks if the sender is an owner of this contract or the contract itself.\n    ///\n    /// @dev Revert if the sender is not an owner fo the contract itself.\n    function _checkOwner() internal view virtual {\n        if (isOwnerAddress(msg.sender) || (msg.sender == address(this))) {\n            return;\n        }\n\n        revert Unauthorized();\n    }\n\n    /// @notice Helper function to get a storage reference to the `MultiOwnableStorage` struct.\n    ///\n    /// @return $ A storage reference to the `MultiOwnableStorage` struct.\n    function _getMultiOwnableStorage() internal pure returns (MultiOwnableStorage storage $) {\n        assembly (\"memory-safe\") {\n            $.slot := MUTLI_OWNABLE_STORAGE_LOCATION\n        }\n    }\n}"
    }
  ]
}