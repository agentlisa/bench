{
  "Title": "H-11: Sense PTs can never be redeemed",
  "Content": "# Issue H-11: Sense PTs can never be redeemed \n\nSource: https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/117 \n\n## Found by \nIllIllI, neumo, Ruhum, 0x52\n\n## Summary\n\nSense PTs can never be redeemed\n\n\n## Vulnerability Detail\n\nMost of the protocols that require the user of the `Converter` contract have code that approves the `Converter` for that protocol, but there is no such approval for Sense.\n\n\n## Impact\n\n_Permanent freezing of funds_\n\nUsers will be able to lend and mint using Sense, but when it's time for Illuminate to redeem the Sense PTs, the call will always revert, meaning the associated underlying will be locked in the contract, and users that try to redeem their Illuminate PTs will have lost principal.\n\nWhile the Illuminate project does have an emergency `withdraw()` function that would allow an admin to rescue the funds and manually distribute them, this would not be trustless and defeats the purpose of having a smart contract.\n\n\n## Code Snippet\nThe Sense flavor of `redeem()` requires the use of the `Converter`:\n```solidity\n// File: src/Redeemer.sol : Redeemer.redeem()   #1\n\n366            // Get the starting balance to verify the amount received afterwards\n367            uint256 starting = IERC20(u).balanceOf(address(this));\n368    \n369            // Get the divider from the adapter\n370            ISenseDivider divider = ISenseDivider(ISenseAdapter(a).divider());\n371    \n372            // Redeem the tokens from the Sense contract\n373            ISenseDivider(divider).redeem(a, s, amount);\n374    \n375            // Get the compounding token that is redeemed by Sense\n376            address compounding = ISenseAdapter(a).target();\n377    \n378            // Redeem the compounding token back to the underlying\n379 @>         IConverter(converter).convert(\n380                compounding,\n381                u,\n382                IERC20(compounding).balanceOf(address(this))\n383            );\n384    \n385            // Get the amount received\n386:           uint256 redeemed = IERC20(u).balanceOf(address(this)) - starting;\n```\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L366-L386\n\nBut there is no code that approves the `Converter` to be able to withdraw from the `Redeemer`. The only function available is required to have been called by the `MarketPlace`, and is thus not callable by the admin:\n```solidity\n// File: src/Redeemer.sol : Redeemer.approve()   #2\n\n203        function approve(address i) external authorized(marketPlace) {\n204            if (i != address(0)) {\n205 @>             Safe.approve(IERC20(i), address(converter), type(uint256).max);\n206            }\n207:       }\n```\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L203-L207\n\n\nRedemptions of Illuminate PTs for underlyings is based on shares of each Illuminate PT's `totalSupply()` of the _available_ underlying, not the expect underlying total:\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L422\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L464\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L517\n\n\nThere is a fork test that tests the converter functionalty, but is uses `vm.startPrank()` to [hack the approval](https://github.com/sherlock-audit/2022-10-illuminate/blob/main/test/fork/Redeemer.t.sol#L370-L372), which wouldn't be available in real life.\n\nAlso note that if the admin ever deploys and sets a new converter, that all other redemptions using the converter will break\n\n## Tool used\n\nManual Review\n\n## Recommendation\nAdd the sense yield token to the `Redeemer`'s `Converter` approval during market creation/setting of principal\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/12",
  "Code": [
    {
      "filename": "src/Redeemer.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/MarketPlace.sol';\n\nimport 'src/lib/Safe.sol';\nimport 'src/errors/Exception.sol';\n\nimport 'src/interfaces/IERC5095.sol';\nimport 'src/interfaces/IERC20.sol';\nimport 'src/interfaces/ITempus.sol';\nimport 'src/interfaces/ITempusPool.sol';\nimport 'src/interfaces/ITempusToken.sol';\nimport 'src/interfaces/IAPWine.sol';\nimport 'src/interfaces/IAPWineController.sol';\nimport 'src/interfaces/IAPWineFutureVault.sol';\nimport 'src/interfaces/IAPWineToken.sol';\nimport 'src/interfaces/IAPWineAMMPool.sol';\nimport 'src/interfaces/ISwivel.sol';\nimport 'src/interfaces/ISwivelToken.sol';\nimport 'src/interfaces/IElementToken.sol';\nimport 'src/interfaces/IYieldToken.sol';\nimport 'src/interfaces/INotional.sol';\nimport 'src/interfaces/IPendle.sol';\nimport 'src/interfaces/IPendleForge.sol';\nimport 'src/interfaces/IPendleToken.sol';\nimport 'src/interfaces/ISenseDivider.sol';\nimport 'src/interfaces/ISenseAdapter.sol';\nimport 'src/interfaces/IYield.sol';\nimport 'src/interfaces/IConverter.sol';\n\nimport 'forge-std/Test.sol';\n\n/// @title Redeemer\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The Redeemer contract is used to redeem the underlying lent capital of a loan.\n/// @notice Users may redeem their ERC-5095 tokens for the underlying asset represented by that token after maturity.\ncontract Redeemer {\n    /// @notice address that is allowed to set fees and contracts, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the MarketPlace contract, used to access the markets mapping\n    address public marketPlace;\n    /// @notice address that custodies principal tokens for all markets\n    address public lender;\n    /// @notice address that converts compounding tokens to their underlying\n    address public converter;\n\n    /// @notice third party contract needed to redeem Swivel PTs\n    address public immutable swivelAddr;\n    /// @notice third party contract needed to redeem Pendle PTs\n    address public immutable pendleAddr;\n    /// @notice third party contract needed to redeem Tempus PTs\n    address public immutable tempusAddr;\n\n    /// @notice this value determines the amount of fees paid on auto redemptions\n    uint256 public feenominator;\n    /// @notice represents a point in time where the feenominator may change\n    uint256 public feeChange;\n    /// @notice represents a minimum that the feenominator must exceed\n    uint256 public MIN_FEENOMINATOR = 500;\n\n    /// @notice mapping that indicates how much underlying has been redeemed by a market\n    mapping(address => mapping(uint256 => uint256)) public holdings;\n    /// @notice mapping that determines if a market's iPT can be redeemed\n    mapping(address => mapping(uint256 => bool)) public paused;\n\n    /// @notice emitted upon redemption of a loan\n    event Redeem(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 amount,\n        address sender\n    );\n    /// @notice emitted upon changing the admin\n    event SetAdmin(address indexed admin);\n    /// @notice emitted upon changing the converter\n    event SetConverter(address indexed converter);\n    /// @notice emitted upon setting the fee rate\n    event SetFee(uint256 indexed fee);\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    /// @notice reverts on all markets where the paused mapping returns true\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    modifier unpaused(address u, uint256 m) {\n        if (paused[u][m]) {\n            revert Exception(17, m, 0, u, address(0));\n        }\n        _;\n    }\n\n    /// @notice Initializes the Redeemer contract\n    /// @param l the lender contract\n    /// @param s the Swivel contract\n    /// @param p the Pendle contract\n    /// @param t the Tempus contract\n    constructor(\n        address l,\n        address s,\n        address p,\n        address t\n    ) {\n        admin = msg.sender;\n        lender = l;\n        swivelAddr = s;\n        pendleAddr = p;\n        tempusAddr = t;\n        feenominator = 4000;\n    }\n\n    /// @notice sets the admin address\n    /// @param a Address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        emit SetAdmin(a);\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set\n    function setMarketPlace(address m)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        if (marketPlace != address(0)) {\n            revert Exception(5, 0, 0, marketPlace, address(0));\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice sets the converter address\n    /// @param c address of the new converter\n    /// @return bool true if successful\n    function setConverter(address c) external authorized(admin) returns (bool) {\n        converter = c;\n        emit SetConverter(c);\n        return true;\n    }\n\n    /// @notice sets the address of the lender contract which contains the addresses of all the fixed rate markets\n    /// @param l the address of the lender contract\n    /// @return bool true if the address was set\n    function setLender(address l) external authorized(admin) returns (bool) {\n        if (lender != address(0)) {\n            revert Exception(8, 0, 0, address(lender), address(0));\n        }\n        lender = l;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param f the new value of the feenominator, fees are not collected when the feenominator is 0\n    /// @return bool true if successful\n    function setFee(uint256 f) external authorized(admin) returns (bool) {\n        uint256 feeTime = feeChange;\n        if (feeTime == 0) {\n            revert Exception(23, 0, 0, address(0), address(0));\n        } else if (feeTime < block.timestamp) {\n            revert Exception(\n                24,\n                block.timestamp,\n                feeTime,\n                address(0),\n                address(0)\n            );\n        } else if (f < MIN_FEENOMINATOR) {\n            revert Exception(25, 0, 0, address(0), address(0));\n        }\n        feenominator = f;\n        delete feeChange;\n        emit SetFee(f);\n        return true;\n    }\n\n    /// @notice allows admin to stop redemptions of Illuminate PTs for a given market\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param b true to pause, false to unpause\n    function pauseRedemptions(\n        address u,\n        uint256 m,\n        bool b\n    ) external authorized(admin) {\n        paused[u][m] = b;\n    }\n\n    /// @notice approves the converter to spend the compounding asset\n    /// @param i an interest bearing token that must be approved for conversion\n    function approve(address i) external authorized(marketPlace) {\n        if (i != address(0)) {\n            Safe.approve(IERC20(i), address(converter), type(uint256).max);\n        }\n    }\n\n    /// @notice redeem method for Swivel, Yield, Element, Pendle, APWine, Tempus and Notional protocols\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m\n    ) external returns (bool) {\n        // Get the principal token that is being redeemed by the user\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Get the maturity for the given principal token\n        uint256 maturity;\n        if (p == uint8(MarketPlace.Principals.Swivel)) {\n            maturity = ISwivelToken(principal).maturity();\n        } else if (p == uint8(MarketPlace.Principals.Yield)) {\n            maturity = IYieldToken(principal).maturity();\n        } else if (p == uint8(MarketPlace.Principals.Element)) {\n            maturity = IElementToken(principal).unlockTimestamp();\n        } else if (p == uint8(MarketPlace.Principals.Pendle)) {\n            maturity = IPendleToken(principal).expiry();\n        } else if (p == uint8(MarketPlace.Principals.Tempus)) {\n            maturity = ITempusPool(ITempusToken(principal).pool())\n                .maturityTime();\n        } else if (p == uint8(MarketPlace.Principals.Apwine)) {\n            // APWine's maturity is retrieved indirectly via the PT's\n            // futureVault and Controller\n            address futureVault = IAPWineToken(principal).futureVault();\n\n            address controller = IAPWineFutureVault(futureVault)\n                .getControllerAddress();\n\n            uint256 duration = IAPWineFutureVault(futureVault)\n                .PERIOD_DURATION();\n\n            maturity = IAPWineController(controller).getNextPeriodStart(\n                duration\n            );\n        } else if (p == uint8(MarketPlace.Principals.Notional)) {\n            maturity = INotional(principal).getMaturity();\n        } else {\n            revert Exception(6, p, 0, address(0), address(0));\n        }\n\n        // Verify that the token has matured\n        if (maturity > block.timestamp) {\n            revert Exception(7, maturity, 0, address(0), address(0));\n        }\n\n        // Cache the lender to save gas on sload\n        address cachedLender = lender;\n\n        // Get the amount to be redeemed\n        uint256 amount = IERC20(principal).balanceOf(cachedLender);\n\n        // Receive the principal token from the lender contract\n        Safe.transferFrom(\n            IERC20(principal),\n            cachedLender,\n            address(this),\n            amount\n        );\n\n        // Get the starting balance of the underlying held by the redeemer\n        uint256 starting = IERC20(u).balanceOf(address(this));\n\n        if (p == uint8(MarketPlace.Principals.Swivel)) {\n            // Redeems principal tokens from Swivel\n            if (!ISwivel(swivelAddr).redeemZcToken(u, maturity, amount)) {\n                revert Exception(15, 0, 0, address(0), address(0));\n            }\n        } else if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Redeems principal tokens from Yield\n            IYieldToken(principal).redeem(address(this), amount);\n        } else if (p == uint8(MarketPlace.Principals.Element)) {\n            // Redeems principal tokens from Element\n            IElementToken(principal).withdrawPrincipal(amount, address(this));\n        } else if (p == uint8(MarketPlace.Principals.Pendle)) {\n            // Get the forge contract for the principal token\n            address forge = IPendleToken(principal).forge();\n\n            // Get the forge ID of the principal token\n            bytes32 forgeId = IPendleForge(forge).forgeId();\n\n            // Redeem the tokens from the Pendle contract\n            IPendle(pendleAddr).redeemAfterExpiry(forgeId, u, maturity);\n\n            // Get the compounding asset for this market\n            address compounding = IPendleToken(principal)\n                .underlyingYieldToken();\n\n            // Redeem the compounding to token to the underlying\n            IConverter(converter).convert(\n                compounding,\n                u,\n                IERC20(compounding).balanceOf(address(this))\n            );\n        } else if (p == uint8(MarketPlace.Principals.Tempus)) {\n            // Retrieve the pool for the principal token\n            address pool = ITempusToken(principal).pool();\n\n            // Redeems principal tokens from Tempus\n            ITempus(tempusAddr).redeemToBacking(pool, amount, 0, address(this));\n        } else if (p == uint8(MarketPlace.Principals.Apwine)) {\n            apwineWithdraw(principal, u, amount);\n        } else if (p == uint8(MarketPlace.Principals.Notional)) {\n            // Redeems principal tokens from Notional\n            INotional(principal).redeem(\n                INotional(principal).maxRedeem(address(this)),\n                address(this),\n                address(this)\n            );\n        }\n\n        // Calculate how much underlying was redeemed\n        uint256 redeemed = IERC20(u).balanceOf(address(this)) - starting;\n\n        // Update the holding for this market\n        holdings[u][m] = holdings[u][m] + redeemed;\n\n        emit Redeem(p, u, m, redeemed, msg.sender);\n        return true;\n    }\n\n    /// @notice redeem method signature for Sense\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param s Sense's maturity is needed to extract the pt address\n    /// @param a Sense's adapter for this market\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 s,\n        address a\n    ) external returns (bool) {\n        // Check the principal is Sense\n        if (p != uint8(MarketPlace.Principals.Sense)) {\n            revert Exception(6, p, 0, address(0), address(0));\n        }\n\n        // Get Sense's principal token for this market\n        IERC20 token = IERC20(IMarketPlace(marketPlace).token(u, m, p));\n\n        // Cache the lender to save on SLOAD operations\n        address cachedLender = lender;\n\n        // Get the balance of tokens to be redeemed by the user\n        uint256 amount = token.balanceOf(cachedLender);\n\n        // Transfer the user's tokens to the redeem contract\n        Safe.transferFrom(token, cachedLender, address(this), amount);\n\n        // Get the starting balance to verify the amount received afterwards\n        uint256 starting = IERC20(u).balanceOf(address(this));\n\n        // Get the divider from the adapter\n        ISenseDivider divider = ISenseDivider(ISenseAdapter(a).divider());\n\n        // Redeem the tokens from the Sense contract\n        ISenseDivider(divider).redeem(a, s, amount);\n\n        // Get the compounding token that is redeemed by Sense\n        address compounding = ISenseAdapter(a).target();\n\n        // Redeem the compounding token back to the underlying\n        IConverter(converter).convert(\n            compounding,\n            u,\n            IERC20(compounding).balanceOf(address(this))\n        );\n\n        // Get the amount received\n        uint256 redeemed = IERC20(u).balanceOf(address(this)) - starting;\n\n        // Verify that underlying are received 1:1 - cannot trust the adapter\n        if (redeemed < amount) {\n            revert Exception(13, 0, 0, address(0), address(0));\n        }\n\n        // Update the holdings for this market\n        holdings[u][m] = holdings[u][m] + redeemed;\n\n        emit Redeem(p, u, m, redeemed, msg.sender);\n        return true;\n    }\n\n    /// @notice burns Illuminate principal tokens and sends underlying to user\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    function redeem(address u, uint256 m) external unpaused(u, m) {\n        // Get Illuminate's principal token for this market\n        IERC5095 token = IERC5095(\n            IMarketPlace(marketPlace).token(\n                u,\n                m,\n                uint8(MarketPlace.Principals.Illuminate)\n            )\n        );\n\n        // Verify the token has matured\n        if (block.timestamp < token.maturity()) {\n            revert Exception(7, block.timestamp, m, address(0), address(0));\n        }\n\n        // Get the amount of tokens to be redeemed from the sender\n        uint256 amount = token.balanceOf(msg.sender);\n\n        // Calculate how many tokens the user should receive\n        uint256 redeemed = (amount * holdings[u][m]) / token.totalSupply();\n\n        // Update holdings of underlying\n        holdings[u][m] = holdings[u][m] - redeemed;\n\n        // Burn the user's principal tokens\n        token.authBurn(msg.sender, amount);\n\n        // Transfer the original underlying token back to the user\n        Safe.transfer(IERC20(u), msg.sender, redeemed);\n\n        emit Redeem(0, u, m, redeemed, msg.sender);\n    }\n\n    /// @notice implements the redeem method for the contract to fulfill the ERC-5095 interface\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param f address from where the underlying asset will be burned\n    /// @param t address to where the underlying asset will be transferred\n    /// @param a amount of the Illuminate PT to be burned and redeemed\n    /// @return uint256 amount of the underlying asset that was burned\n    function authRedeem(\n        address u,\n        uint256 m,\n        address f,\n        address t,\n        uint256 a\n    )\n        external\n        authorized(IMarketPlace(marketPlace).token(u, m, 0))\n        returns (uint256)\n    {\n        // Get the principal token for the given market\n        IERC5095 pt = IERC5095(IMarketPlace(marketPlace).token(u, m, 0));\n\n        // Make sure the market has matured\n        uint256 maturity = pt.maturity();\n        if (block.timestamp < maturity) {\n            revert Exception(7, maturity, 0, address(0), address(0));\n        }\n\n        // Calculate the amount redeemed\n        uint256 redeemed = (a * holdings[u][m]) / pt.totalSupply();\n\n        // Update holdings of underlying\n        holdings[u][m] = holdings[u][m] - redeemed;\n\n        // Burn the user's principal tokens\n        pt.authBurn(f, a);\n\n        // Transfer the original underlying token back to the user\n        Safe.transfer(IERC20(u), t, redeemed);\n\n        emit Redeem(0, u, m, redeemed, msg.sender);\n        return a;\n    }\n\n    /// @notice implements a redeem method to enable third-party redemptions\n    /// @dev expects approvals from owners to redeemer\n    /// @param u address of the underlying asset\n    /// @param m maturity of the market\n    /// @param f address from where the principal token will be burned\n    /// @return uint256 amount of underlying yielded as a fee\n    function autoRedeem(\n        address u,\n        uint256 m,\n        address[] calldata f\n    ) external returns (uint256) {\n        // Get the principal token for the given market\n        IERC5095 pt = IERC5095(IMarketPlace(marketPlace).token(u, m, 0));\n\n        // Make sure the market has matured\n        uint256 maturity = pt.maturity();\n        if (block.timestamp < maturity) {\n            revert Exception(7, maturity, 0, address(0), address(0));\n        }\n\n        // Retrieve the underlying\n        IERC20 uToken = IERC20(u);\n\n        // Sum up the fees received by the caller\n        uint256 incentiveFee;\n\n        // Get the number of owners to loop through\n        uint256 length = f.length;\n\n        // Loop through the provided arrays and mature each individual position\n        for (uint256 i; i != length; ) {\n            // Fetch the allowance set by the holder of the principal tokens\n            uint256 allowance = uToken.allowance(f[i], address(this));\n\n            // Get the amount of tokens held by the owner\n            uint256 amount = pt.balanceOf(f[i]);\n\n            // Calculate how many tokens the user should receive\n            uint256 redeemed = (amount * holdings[u][m]) / pt.totalSupply();\n\n            // Calculate the fees to be received (currently .025%)\n            uint256 fee = redeemed / feenominator;\n\n            // Verify allowance\n            if (allowance < amount) {\n                revert Exception(20, allowance, amount, address(0), address(0));\n            }\n\n            // Burn the tokens from the user\n            pt.authBurn(f[i], amount);\n\n            // Update the holdings for this market\n            holdings[u][m] = holdings[u][m] - redeemed;\n\n            // Transfer the underlying to the user\n            Safe.transfer(uToken, f[i], redeemed - fee);\n\n            unchecked {\n                // Track the fees gained by the caller\n                incentiveFee += fee;\n\n                ++i;\n            }\n        }\n\n        // Transfer the fee to the caller\n        Safe.transfer(uToken, msg.sender, incentiveFee);\n\n        return incentiveFee;\n    }\n\n    /// @notice Execute the business logic for conducting an APWine redemption\n    function apwineWithdraw(\n        address p,\n        address u,\n        uint256 a\n    ) internal {\n        // Retrieve the vault which executes the redemption in APWine\n        address futureVault = IAPWineToken(p).futureVault();\n\n        // Retrieve the controller that will execute the withdrawal\n        address controller = IAPWineFutureVault(futureVault)\n            .getControllerAddress();\n\n        // Retrieve the next period index\n        uint256 index = IAPWineFutureVault(futureVault).getCurrentPeriodIndex();\n\n        // Get the FYT address for the current period\n        address fyt = IAPWineFutureVault(futureVault).getFYTofPeriod(index);\n\n        // Trigger claim to FYTs by executing transfer\n        // Safe.transferFrom(IERC20(fyt), address(lender), address(this), a);\n        ILender(lender).transferFYTs(fyt, a);\n\n        // Redeem the underlying token from APWine to Illuminate\n        IAPWineController(controller).withdraw(futureVault, a);\n\n        // Retrieve the interest bearing token\n        address ibt = IAPWineFutureVault(futureVault).getIBTAddress();\n\n        // Convert the interest bearing token to underlying\n        IConverter(converter).convert(\n            IAPWineFutureVault(futureVault).getIBTAddress(),\n            u,\n            IERC20(ibt).balanceOf(address(this))\n        );\n    }\n}"
    },
    {
      "filename": "src/Redeemer.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/MarketPlace.sol';\n\nimport 'src/lib/Safe.sol';\nimport 'src/errors/Exception.sol';\n\nimport 'src/interfaces/IERC5095.sol';\nimport 'src/interfaces/IERC20.sol';\nimport 'src/interfaces/ITempus.sol';\nimport 'src/interfaces/ITempusPool.sol';\nimport 'src/interfaces/ITempusToken.sol';\nimport 'src/interfaces/IAPWine.sol';\nimport 'src/interfaces/IAPWineController.sol';\nimport 'src/interfaces/IAPWineFutureVault.sol';\nimport 'src/interfaces/IAPWineToken.sol';\nimport 'src/interfaces/IAPWineAMMPool.sol';\nimport 'src/interfaces/ISwivel.sol';\nimport 'src/interfaces/ISwivelToken.sol';\nimport 'src/interfaces/IElementToken.sol';\nimport 'src/interfaces/IYieldToken.sol';\nimport 'src/interfaces/INotional.sol';\nimport 'src/interfaces/IPendle.sol';\nimport 'src/interfaces/IPendleForge.sol';\nimport 'src/interfaces/IPendleToken.sol';\nimport 'src/interfaces/ISenseDivider.sol';\nimport 'src/interfaces/ISenseAdapter.sol';\nimport 'src/interfaces/IYield.sol';\nimport 'src/interfaces/IConverter.sol';\n\nimport 'forge-std/Test.sol';\n\n/// @title Redeemer\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The Redeemer contract is used to redeem the underlying lent capital of a loan.\n/// @notice Users may redeem their ERC-5095 tokens for the underlying asset represented by that token after maturity.\ncontract Redeemer {\n    /// @notice address that is allowed to set fees and contracts, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the MarketPlace contract, used to access the markets mapping\n    address public marketPlace;\n    /// @notice address that custodies principal tokens for all markets\n    address public lender;\n    /// @notice address that converts compounding tokens to their underlying\n    address public converter;\n\n    /// @notice third party contract needed to redeem Swivel PTs\n    address public immutable swivelAddr;\n    /// @notice third party contract needed to redeem Pendle PTs\n    address public immutable pendleAddr;\n    /// @notice third party contract needed to redeem Tempus PTs\n    address public immutable tempusAddr;\n\n    /// @notice this value determines the amount of fees paid on auto redemptions\n    uint256 public feenominator;\n    /// @notice represents a point in time where the feenominator may change\n    uint256 public feeChange;\n    /// @notice represents a minimum that the feenominator must exceed\n    uint256 public MIN_FEENOMINATOR = 500;\n\n    /// @notice mapping that indicates how much underlying has been redeemed by a market\n    mapping(address => mapping(uint256 => uint256)) public holdings;\n    /// @notice mapping that determines if a market's iPT can be redeemed\n    mapping(address => mapping(uint256 => bool)) public paused;\n\n    /// @notice emitted upon redemption of a loan\n    event Redeem(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 amount,\n        address sender\n    );\n    /// @notice emitted upon changing the admin\n    event SetAdmin(address indexed admin);\n    /// @notice emitted upon changing the converter\n    event SetConverter(address indexed converter);\n    /// @notice emitted upon setting the fee rate\n    event SetFee(uint256 indexed fee);\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    /// @notice reverts on all markets where the paused mapping returns true\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    modifier unpaused(address u, uint256 m) {\n        if (paused[u][m]) {\n            revert Exception(17, m, 0, u, address(0));\n        }\n        _;\n    }\n\n    /// @notice Initializes the Redeemer contract\n    /// @param l the lender contract\n    /// @param s the Swivel contract\n    /// @param p the Pendle contract\n    /// @param t the Tempus contract\n    constructor(\n        address l,\n        address s,\n        address p,\n        address t\n    ) {\n        admin = msg.sender;\n        lender = l;\n        swivelAddr = s;\n        pendleAddr = p;\n        tempusAddr = t;\n        feenominator = 4000;\n    }\n\n    /// @notice sets the admin address\n    /// @param a Address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        emit SetAdmin(a);\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set\n    function setMarketPlace(address m)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        if (marketPlace != address(0)) {\n            revert Exception(5, 0, 0, marketPlace, address(0));\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice sets the converter address\n    /// @param c address of the new converter\n    /// @return bool true if successful\n    function setConverter(address c) external authorized(admin) returns (bool) {\n        converter = c;\n        emit SetConverter(c);\n        return true;\n    }\n\n    /// @notice sets the address of the lender contract which contains the addresses of all the fixed rate markets\n    /// @param l the address of the lender contract\n    /// @return bool true if the address was set\n    function setLender(address l) external authorized(admin) returns (bool) {\n        if (lender != address(0)) {\n            revert Exception(8, 0, 0, address(lender), address(0));\n        }\n        lender = l;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param f the new value of the feenominator, fees are not collected when the feenominator is 0\n    /// @return bool true if successful\n    function setFee(uint256 f) external authorized(admin) returns (bool) {\n        uint256 feeTime = feeChange;\n        if (feeTime == 0) {\n            revert Exception(23, 0, 0, address(0), address(0));\n        } else if (feeTime < block.timestamp) {\n            revert Exception(\n                24,\n                block.timestamp,\n                feeTime,\n                address(0),\n                address(0)\n            );\n        } else if (f < MIN_FEENOMINATOR) {\n            revert Exception(25, 0, 0, address(0), address(0));\n        }\n        feenominator = f;\n        delete feeChange;\n        emit SetFee(f);\n        return true;\n    }\n\n    /// @notice allows admin to stop redemptions of Illuminate PTs for a given market\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param b true to pause, false to unpause\n    function pauseRedemptions(\n        address u,\n        uint256 m,\n        bool b\n    ) external authorized(admin) {\n        paused[u][m] = b;\n    }\n\n    /// @notice approves the converter to spend the compounding asset\n    /// @param i an interest bearing token that must be approved for conversion\n    function approve(address i) external authorized(marketPlace) {\n        if (i != address(0)) {\n            Safe.approve(IERC20(i), address(converter), type(uint256).max);\n        }\n    }\n\n    /// @notice redeem method for Swivel, Yield, Element, Pendle, APWine, Tempus and Notional protocols\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m\n    ) external returns (bool) {\n        // Get the principal token that is being redeemed by the user\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Get the maturity for the given principal token\n        uint256 maturity;\n        if (p == uint8(MarketPlace.Principals.Swivel)) {\n            maturity = ISwivelToken(principal).maturity();\n        } else if (p == uint8(MarketPlace.Principals.Yield)) {\n            maturity = IYieldToken(principal).maturity();\n        } else if (p == uint8(MarketPlace.Principals.Element)) {\n            maturity = IElementToken(principal).unlockTimestamp();\n        } else if (p == uint8(MarketPlace.Principals.Pendle)) {\n            maturity = IPendleToken(principal).expiry();\n        } else if (p == uint8(MarketPlace.Principals.Tempus)) {\n            maturity = ITempusPool(ITempusToken(principal).pool())\n                .maturityTime();\n        } else if (p == uint8(MarketPlace.Principals.Apwine)) {\n            // APWine's maturity is retrieved indirectly via the PT's\n            // futureVault and Controller\n            address futureVault = IAPWineToken(principal).futureVault();\n\n            address controller = IAPWineFutureVault(futureVault)\n                .getControllerAddress();\n\n            uint256 duration = IAPWineFutureVault(futureVault)\n                .PERIOD_DURATION();\n\n            maturity = IAPWineController(controller).getNextPeriodStart(\n                duration\n            );\n        } else if (p == uint8(MarketPlace.Principals.Notional)) {\n            maturity = INotional(principal).getMaturity();\n        } else {\n            revert Exception(6, p, 0, address(0), address(0));\n        }\n\n        // Verify that the token has matured\n        if (maturity > block.timestamp) {\n            revert Exception(7, maturity, 0, address(0), address(0));\n        }\n\n        // Cache the lender to save gas on sload\n        address cachedLender = lender;\n\n        // Get the amount to be redeemed\n        uint256 amount = IERC20(principal).balanceOf(cachedLender);\n\n        // Receive the principal token from the lender contract\n        Safe.transferFrom(\n            IERC20(principal),\n            cachedLender,\n            address(this),\n            amount\n        );\n\n        // Get the starting balance of the underlying held by the redeemer\n        uint256 starting = IERC20(u).balanceOf(address(this));\n\n        if (p == uint8(MarketPlace.Principals.Swivel)) {\n            // Redeems principal tokens from Swivel\n            if (!ISwivel(swivelAddr).redeemZcToken(u, maturity, amount)) {\n                revert Exception(15, 0, 0, address(0), address(0));\n            }\n        } else if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Redeems principal tokens from Yield\n            IYieldToken(principal).redeem(address(this), amount);\n        } e"
    }
  ]
}