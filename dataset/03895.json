{
  "Title": "Using \"magic\" numbers",
  "Content": "##### Description\nThe use in the source code of some unknown where taken values impair its understanding:\n - At line https://github.com/sushiswap/bentobox/blob/c2e150b16b8764ebfe2e1e6e267ae14e10738065/contracts/ERC20.sol#L55 the value is `\\x19\\x01`.\n - At line https://github.com/sushiswap/bentobox/blob/c2e150b16b8764ebfe2e1e6e267ae14e10738065/contracts/ERC20.sol#L57 the value is `0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9`.\n - At line https://github.com/sushiswap/bentobox/blob/c2e150b16b8764ebfe2e1e6e267ae14e10738065/contracts/BentoBox.sol#L171 the value is `0x23b872dd`.\n - At line https://github.com/sushiswap/bentobox/blob/c2e150b16b8764ebfe2e1e6e267ae14e10738065/contracts/BentoBox.sol#L186 the value is `0xa9059cbb`.\n - At line https://github.com/sushiswap/bentobox/blob/c2e150b16b8764ebfe2e1e6e267ae14e10738065/contracts/LendingPair.sol#L586 the value is `0xa9059cbb`.\n - At lines 178, 389, 398, 503, 546 https://github.com/sushiswap/bentobox/blob/c2e150b16b8764ebfe2e1e6e267ae14e10738065/contracts/LendingPair.sol the value is `1e5`.\n - At lines 177, 195, 198, 203 https://github.com/sushiswap/bentobox/blob/c2e150b16b8764ebfe2e1e6e267ae14e10738065/contracts/LendingPair.sol the value is `1e18`.\n - At lines 86, 89 https://github.com/sushiswap/bentobox/blob/c2e150b16b8764ebfe2e1e6e267ae14e10738065/contracts/LendingPair.sol the value is `0x95d89b41`.\n - At lines 96, 99 https://github.com/sushiswap/bentobox/blob/c2e150b16b8764ebfe2e1e6e267ae14e10738065/contracts/LendingPair.sol the value is `0x06fdde03`.\n - At line https://github.com/sushiswap/bentobox/blob/c2e150b16b8764ebfe2e1e6e267ae14e10738065/contracts/LendingPair.sol#L106 the value is `0x313ce567`.\n - At line https://github.com/sushiswap/bentobox/blob/c2e150b16b8764ebfe2e1e6e267ae14e10738065/contracts/LendingPair.sol#L471 the value is `1e23`.\n\n##### Recommendation\nIt is recommended that you create constants with meaningful names to use numeric values.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/ERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\r\n// solhint-disable no-inline-assembly\r\n// solhint-disable not-rely-on-time\r\n\r\npragma solidity 0.6.12;\r\n\r\n// Data part taken out for building of contracts that receive delegate calls\r\ncontract ERC20Data {\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping (address => uint256)) public allowance;\r\n    mapping(address => uint256) public nonces;\r\n}\r\n\r\ncontract ERC20 is ERC20Data {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function transfer(address to, uint256 amount) public returns (bool success) {\r\n        require(balanceOf[msg.sender] >= amount, \"ERC20: balance too low\");\r\n        require(balanceOf[to] + amount >= balanceOf[to], \"ERC20: overflow detected\");\r\n        balanceOf[msg.sender] -= amount;\r\n        balanceOf[to] += amount;\r\n        emit Transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 amount) public returns (bool success) {\r\n        require(balanceOf[from] >= amount, \"ERC20: balance too low\");\r\n        require(allowance[from][msg.sender] >= amount, \"ERC20: allowance too low\");\r\n        require(balanceOf[to] + amount >= balanceOf[to], \"ERC20: overflow detected\");\r\n        balanceOf[from] -= amount;\r\n        allowance[from][msg.sender] -= amount;\r\n        balanceOf[to] += amount;\r\n        emit Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public returns (bool success) {\r\n        allowance[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() public view returns (bytes32){\r\n      uint256 chainId;\r\n      assembly {chainId := chainid()}\r\n      return keccak256(abi.encode(keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\"), chainId, address(this)));\r\n    }\r\n\r\n    function permit(address owner_, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\r\n        require(owner_ != address(0), \"ERC20: Owner cannot be 0\");\r\n        require(block.timestamp < deadline, \"ERC20: Expired\");\r\n        bytes32 digest = keccak256(abi.encodePacked(\r\n            \"\\x19\\x01\", DOMAIN_SEPARATOR(),\r\n            keccak256(abi.encode(\r\n                0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9,\r\n                owner_, spender, value, nonces[owner_]++, deadline\r\n            ))\r\n        ));\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(recoveredAddress == owner_, \"ERC20: Invalid Signature\");\r\n        allowance[owner_][spender] = value;\r\n        emit Approval(owner_, spender, value);\r\n    }\r\n}"
    },
    {
      "filename": "contracts/ERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\r\n// solhint-disable no-inline-assembly\r\n// solhint-disable not-rely-on-time\r\n\r\npragma solidity 0.6.12;\r\n\r\n// Data part taken out for building of contracts that receive delegate calls\r\ncontract ERC20Data {\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping (address => uint256)) public allowance;\r\n    mapping(address => uint256) public nonces;\r\n}\r\n\r\ncontract ERC20 is ERC20Data {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function transfer(address to, uint256 amount) public returns (bool success) {\r\n        require(balanceOf[msg.sender] >= amount, \"ERC20: balance too low\");\r\n        require(balanceOf[to] + amount >= balanceOf[to], \"ERC20: overflow detected\");\r\n        balanceOf[msg.sender] -= amount;\r\n        balanceOf[to] += amount;\r\n        emit Transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 amount) public returns (bool success) {\r\n        require(balanceOf[from] >= amount, \"ERC20: balance too low\");\r\n        require(allowance[from][msg.sender] >= amount, \"ERC20: allowance too low\");\r\n        require(balanceOf[to] + amount >= balanceOf[to], \"ERC20: overflow detected\");\r\n        balanceOf[from] -= amount;\r\n        allowance[from][msg.sender] -= amount;\r\n        balanceOf[to] += amount;\r\n        emit Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public returns (bool success) {\r\n        allowance[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() public view returns (bytes32){\r\n      uint256 chainId;\r\n      assembly {chainId := chainid()}\r\n      return keccak256(abi.encode(keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\"), chainId, address(this)));\r\n    }\r\n\r\n    function permit(address owner_, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\r\n        require(owner_ != address(0), \"ERC20: Owner cannot be 0\");\r\n        require(block.timestamp < deadline, \"ERC20: Expired\");\r\n        bytes32 digest = keccak256(abi.encodePacked(\r\n            \"\\x19\\x01\", DOMAIN_SEPARATOR(),\r\n            keccak256(abi.encode(\r\n                0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9,\r\n                owner_, spender, value, nonces[owner_]++, deadline\r\n            ))\r\n        ));\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(recoveredAddress == owner_, \"ERC20: Invalid Signature\");\r\n        allowance[owner_][spender] = value;\r\n        emit Approval(owner_, spender, value);\r\n    }\r\n}"
    },
    {
      "filename": "contracts/BentoBox.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\n// The BentoBox\r\n\r\n//  ▄▄▄▄· ▄▄▄ . ▐ ▄ ▄▄▄▄▄      ▄▄▄▄·       ▐▄• ▄ \r\n//  ▐█ ▀█▪▀▄.▀·•█▌▐█•██  ▪     ▐█ ▀█▪▪      █▌█▌▪\r\n//  ▐█▀▀█▄▐▀▀▪▄▐█▐▐▌ ▐█.▪ ▄█▀▄ ▐█▀▀█▄ ▄█▀▄  ·██· \r\n//  ██▄▪▐█▐█▄▄▌██▐█▌ ▐█▌·▐█▌.▐▌██▄▪▐█▐█▌.▐▌▪▐█·█▌\r\n//  ·▀▀▀▀  ▀▀▀ ▀▀ █▪ ▀▀▀  ▀█▄▀▪·▀▀▀▀  ▀█▄▀▪•▀▀ ▀▀\r\n\r\n// This contract stores funds, handles their transfers.\r\n\r\n// Copyright (c) 2020 BoringCrypto - All rights reserved\r\n// Twitter: @Boring_Crypto\r\n\r\n// WARNING!!! DO NOT USE!!! BEING AUDITED!!!\r\n\r\n// solhint-disable no-inline-assembly\r\n// solhint-disable avoid-low-level-calls\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\nimport \"./libraries/BoringMath.sol\";\r\nimport \"./interfaces/IERC20.sol\";\r\nimport \"./interfaces/IWETH.sol\";\r\nimport \"./interfaces/IMasterContract.sol\";\r\n\r\ncontract BentoBox {\r\n    using BoringMath for uint256;\r\n    using BoringMath128 for uint128;\r\n\r\n    event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);\r\n    event LogSetMasterContractApproval(address indexed masterContract, address indexed user, bool indexed approved);\r\n    event LogDeposit(IERC20 indexed token, address indexed from, address indexed to, uint256 amount);\r\n    event LogWithdraw(IERC20 indexed token, address indexed from, address indexed to, uint256 amount);\r\n    event LogTransfer(IERC20 indexed token, address indexed from, address indexed to, uint256 amount);\r\n\r\n    mapping(address => address) public masterContractOf; // Mapping from clone contracts to their masterContract\r\n    mapping(address => mapping(address => bool)) public masterContractApproved; // masterContract to user to approval state\r\n    mapping(IERC20 => mapping(address => uint256)) public balanceOf; // Balance per token per address/contract\r\n    mapping(IERC20 => uint256) public totalSupply;\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    IERC20 public immutable WETH;\r\n\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    constructor(IERC20 WETH_) public {\r\n        WETH = WETH_;\r\n    }\r\n\r\n    // Deploys a given master Contract as a clone.\r\n    function deploy(address masterContract, bytes calldata data) public {\r\n        bytes20 targetBytes = bytes20(masterContract); // Takes the first 20 bytes of the masterContract's address\r\n        address cloneAddress; // Address where the clone contract will reside.\r\n\r\n        // Creates clone, more info here: https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            cloneAddress := create(0, clone, 0x37)\r\n        }\r\n        masterContractOf[cloneAddress] = masterContract;\r\n\r\n        IMasterContract(cloneAddress).init(data);\r\n\r\n        emit LogDeploy(masterContract, data, cloneAddress);\r\n    }\r\n\r\n    // *** Public actions *** //\r\n    function setMasterContractApproval(address masterContract, bool approved) public {\r\n        require(masterContract != address(0), \"BentoBox: masterContract not set\"); // Important for security\r\n        masterContractApproved[masterContract][msg.sender] = approved;\r\n        emit LogSetMasterContractApproval(masterContract, msg.sender, approved);\r\n    }\r\n\r\n    modifier allowed(address from) {\r\n        require(msg.sender == from || masterContractApproved[masterContractOf[msg.sender]][from], \"BentoBox: Transfer not approved\");\r\n        _;\r\n    }\r\n\r\n    function deposit(IERC20 token, address from, uint256 amount) public payable { depositTo(token, from, msg.sender, amount); }\r\n    function depositTo(IERC20 token, address from, address to, uint256 amount) public payable allowed(from) {\r\n        _deposit(token, from, to, amount);\r\n    }\r\n\r\n    function depositWithPermit(IERC20 token, address from, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public payable \r\n    { \r\n        depositWithPermitTo(token, from, msg.sender, amount, deadline, v, r, s); \r\n    }\r\n    function depositWithPermitTo(\r\n        IERC20 token, address from, address to, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s\r\n    ) public payable allowed(from) {\r\n        token.permit(from, address(this), amount, deadline, v, r, s);\r\n        _deposit(token, from, to, amount);\r\n    }\r\n\r\n    function withdraw(IERC20 token, address to, uint256 amount) public { withdrawFrom(token, msg.sender, to, amount); }\r\n    function withdrawFrom(IERC20 token, address from, address to, uint256 amount) public allowed(from) {\r\n        _withdraw(token, from, to, amount);\r\n    }\r\n\r\n    // *** Approved contract actions *** //\r\n    // Clones of master contracts can transfer from any account that has approved them\r\n    function transfer(IERC20 token, address to, uint256 amount) public { transferFrom(token, msg.sender, to, amount); }\r\n    function transferFrom(IERC20 token, address from, address to, uint256 amount) public allowed(from) {\r\n        require(to != address(0), \"BentoBox: to not set\"); // To avoid a bad UI from burning funds\r\n        balanceOf[token][from] = balanceOf[token][from].sub(amount);\r\n        balanceOf[token][to] = balanceOf[token][to].add(amount);\r\n\r\n        emit LogTransfer(token, from, to, amount);\r\n    }\r\n\r\n    function transferMultiple(IERC20 token, address[] calldata tos, uint256[] calldata amounts) public\r\n    {\r\n        transferMultipleFrom(token, msg.sender, tos, amounts);\r\n    }\r\n    function transferMultipleFrom(IERC20 token, address from, address[] calldata tos, uint256[] calldata amounts) public allowed(from) {\r\n        require(tos[0] != address(0), \"BentoBox: to[0] not set\"); // To avoid a bad UI from burning funds\r\n        uint256 totalAmount;\r\n        for (uint256 i=0; i < tos.length; i++) {\r\n            address to = tos[i];\r\n            balanceOf[token][to] = balanceOf[token][to].add(amounts[i]);\r\n            totalAmount = totalAmount.add(amounts[i]);\r\n            emit LogTransfer(token, from, to, amounts[i]);\r\n        }\r\n        balanceOf[token][from] = balanceOf[token][from].sub(totalAmount);\r\n    }\r\n\r\n    function skim(IERC20 token) public returns (uint256 amount) { amount = skimTo(token, msg.sender); }\r\n    function skimTo(IERC20 token, address to) public returns (uint256 amount) {\r\n        require(to != address(0), \"BentoBox: to not set\"); // To avoid a bad UI from burning funds\r\n        amount = token.balanceOf(address(this)).sub(totalSupply[token]);\r\n        balanceOf[token][to] = balanceOf[token][to].add(amount);\r\n        totalSupply[token] = totalSupply[token].add(amount);\r\n        emit LogDeposit(token, address(this), to, amount);\r\n    }\r\n\r\n    function skimETH() public returns (uint256 amount) { amount = skimETHTo(msg.sender); }\r\n    function skimETHTo(address to) public returns (uint256 amount) {\r\n        IWETH(address(WETH)).deposit{value: address(this).balance}();\r\n        amount = skimTo(WETH, to);\r\n    }\r\n\r\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns(bool[] memory successes, bytes[] memory results) {\r\n        successes = new bool[](calls.length);\r\n        results = new bytes[](calls.length);\r\n        for (uint256 i = 0; i < calls.length; i++) {\r\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\r\n            require(success || !revertOnFail, \"BentoBox: Transaction failed\");\r\n            successes[i] = success;\r\n            results[i] = result;\r\n        }\r\n    }\r\n\r\n    // solhint-disable-next-line no-empty-blocks\r\n    receive() external payable {}\r\n\r\n    // *** Private functions *** //\r\n    function _deposit(IERC20 token, address from, address to, uint256 amount) private {\r\n        require(to != address(0), \"BentoBox: to not set\"); // To avoid a bad UI from burning funds\r\n        balanceOf[token][to] = balanceOf[token][to].add(amount);\r\n        uint256 supply = totalSupply[token];\r\n        totalSupply[token] = supply.add(amount);\r\n\r\n        if (address(token) == address(WETH)) {\r\n            IWETH(address(WETH)).deposit{value: amount}();\r\n        } else {\r\n            if (supply == 0) { // During the first deposit, we check that this token is 'real'\r\n                require(token.totalSupply() > 0, \"BentoBox: No tokens\");\r\n            }\r\n            (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x23b872dd, from, address(this), amount));\r\n            require(success && (data.length == 0 || abi.decode(data, (bool))), \"BentoBox: TransferFrom failed\");\r\n        }\r\n        emit LogDeposit(token, from, to, amount);\r\n    }\r\n\r\n    function _withdraw(IERC20 token, address from, address to, uint256 amount) private {\r\n        require(to != address(0), \"BentoBox: to not set\"); // To avoid a bad UI from burning funds\r\n        balanceOf[token][from] = balanceOf[token][from].sub(amount);\r\n        totalSupply[token] = totalSupply[token].sub(amount);\r\n        if (address(token) == address(WETH)) {\r\n            IWETH(address(WETH)).withdraw(amount);\r\n            (bool success,) = to.call{value: amount}(new bytes(0));\r\n            require(success, \"BentoBox: ETH transfer failed\");\r\n        } else {\r\n            (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, to, amount));\r\n            require(success && (data.length == 0 || abi.decode(data, (bool))), \"BentoBox: Transfer failed\");\r\n        }\r\n        emit LogWithdraw(token, from, to, amount);\r\n    }\r\n}"
    },
    {
      "filename": "contracts/BentoBox.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\n// The BentoBox\r\n\r\n//  ▄▄▄▄· ▄▄▄ . ▐ ▄ ▄▄▄▄▄      ▄▄▄▄·       ▐▄• ▄ \r\n//  ▐█ ▀█▪▀▄.▀·•█▌▐█•██  ▪     ▐█ ▀█▪▪      █▌█▌▪\r\n//  ▐█▀▀█▄▐▀▀▪▄▐█▐▐▌ ▐█.▪ ▄█▀▄ ▐█▀▀█▄ ▄█▀▄  ·██· \r\n//  ██▄▪▐█▐█▄▄▌██▐█▌ ▐█▌·▐█▌.▐▌██▄▪▐█▐█▌.▐▌▪▐█·█▌\r\n//  ·▀▀▀▀  ▀▀▀ ▀▀ █▪ ▀▀▀  ▀█▄▀▪·▀▀▀▀  ▀█▄▀▪•▀▀ ▀▀\r\n\r\n// This contract stores funds, handles their transfers.\r\n\r\n// Copyright (c) 2020 BoringCrypto - All rights reserved\r\n// Twitter: @Boring_Crypto\r\n\r\n// WARNING!!! DO NOT USE!!! BEING AUDITED!!!\r\n\r\n// solhint-disable no-inline-assembly\r\n// solhint-disable avoid-low-level-calls\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\nimport \"./libraries/BoringMath.sol\";\r\nimport \"./interfaces/IERC20.sol\";\r\nimport \"./interfaces/IWETH.sol\";\r\nimport \"./interfaces/IMasterContract.sol\";\r\n\r\ncontract BentoBox {\r\n    using BoringMath for uint256;\r\n    using BoringMath128 for uint128;\r\n\r\n    event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);\r\n    event LogSetMasterContractApproval(address indexed masterContract, address indexed user, bool indexed approved);\r\n    event LogDeposit(IERC20 indexed token, address indexed from, address indexed to, uint256 amount);\r\n    event LogWithdraw(IERC20 indexed token, address indexed from, address indexed to, uint256 amount);\r\n    event LogTransfer(IERC20 indexed token, address indexed from, address indexed to, uint256 amount);\r\n\r\n    mapping(address => address) public masterContractOf; // Mapping from clone contracts to their masterContract\r\n    mapping(address => mapping(address => bool)) public masterContractApproved; // masterContract to user to approval state\r\n    mapping(IERC20 => mapping(address => uint256)) public balanceOf; // Balance per token per address/contract\r\n    mapping(IERC20 => uint256) public totalSupply;\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    IERC20 public immutable WETH;\r\n\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    constructor(IERC20 WETH_) public {\r\n        WETH = WETH_;\r\n    }\r\n\r\n    // Deploys a given master Contract as a clone.\r\n    function deploy(address masterContract, bytes calldata data) public {\r\n        bytes20 targetBytes = bytes20(masterContract); // Takes the first 20 bytes of the masterContract's address\r\n        address cloneAddress; // Address where the clone contract will reside.\r\n\r\n        // Creates clone, more info here: https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            cloneAddress := create(0, clone, 0x37)\r\n        }\r\n        masterContractOf[cloneAddress] = masterContract;\r\n\r\n        IMasterContract(cloneAddress).init(data);\r\n\r\n        emit LogDeploy(masterContract, data, cloneAddress);\r\n    }\r\n\r\n    // *** Public actions *** //\r\n    function setMasterContractApproval(address masterContract, bool approved) public {\r\n        require(masterContract != address(0), \"BentoBox: masterContract not set\"); // Important for security\r\n        masterContractApproved[masterContract][msg.sender] = approved;\r\n        emit LogSetMasterContractApproval(masterContract, msg.sender, approved);\r\n    }\r\n\r\n    modifier allowed(address from) {\r\n        require(msg.sender == from || masterContractApproved[masterContractOf[msg.sender]][from], \"BentoBox: Transfer not approved\");\r\n        _;\r\n    }\r\n\r\n    function deposit(IERC20 token, address from, uint256 amount) public payable { depositTo(token, from, msg.sender, amount); }\r\n    function depositTo(IERC20 token, address from, address to, uint256 amount) public payable allowed(from) {\r\n        _deposit(token, from, to, amount);\r\n    }\r\n\r\n    function depositWithPermit(IERC20 token, address from, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public payable \r\n    { \r\n        depositWithPermitTo(token, from, msg.sender, amount, deadline, v, r, s); \r\n    }\r\n    function depositWithPermitTo(\r\n        IERC20 token, address from, address to, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s\r\n    ) public payable allowed(from) {\r\n        token.permit(from, address(this), amount, deadline, v, r, s);\r\n        _deposit(token, from, to, amount);\r\n    }\r\n\r\n    function withdraw(IERC20 token, address to, uint256 amount) public { withdrawFrom(token, msg.sender, to, amount); }\r\n    function withdrawFrom(IERC20 token, address from, address to, uint256 amount) public allowed(from) {\r\n        _withdraw(token, from, to, amount);\r\n    }\r\n\r\n    // *** Approved contract actions *** //\r\n    // Clones of master contracts can transfer from any account that has approved them\r\n    function transfer(IERC20 token, address to, uint256 amount) public { transferFrom(token, msg.sender, to, amount); }\r\n    function transferFrom(IERC20 token, address from, address to, uint256 amount) public allowed(from) {\r\n        require(to != address(0), \"BentoBox: to not set\"); // To avoid a bad UI from burning funds\r\n        balanceOf[token][from] = balanceOf[token][from].sub(amount);\r\n        balanceOf[token][to] = balanceOf[token][to].add(amount);\r\n\r\n        emit LogTransfer(token, from, to, amount);\r\n    }\r\n\r\n    function transferMultiple(IERC20 token, address[] calldata tos, uint256[] calldata amounts) public\r\n    {\r\n        transferMultipleFrom(token, msg.sender, tos, amounts);\r\n    }\r\n    function transferMultipleFrom(IERC20 token, address from, address[] calldata tos, uint256[] calldata amounts) public allowed(from) {\r\n        require(tos[0] != address(0), \"BentoBox: to[0] not set\"); // To avoid a bad UI from burning funds\r\n        uint256 totalAmount;\r\n        for (uint256 i=0; i < tos.length; i++) {\r\n            address to = tos[i];\r\n            balanceOf[token][to] = balanceOf[token][to].add(amounts[i]);\r\n            totalAmount = totalAmount.add(amounts[i]);\r\n            emit LogTransfer(token, from, to, amounts[i]);\r\n        }\r\n        balanceOf[token][from] = balanceOf[token][from].sub(totalAmount);\r\n    }\r\n\r\n    function skim(IERC20 token) public returns (uint256 amount) { amount = skimTo(token, msg.sender); }\r\n    function skimTo(IERC20 token, address to) public returns (uint256 amount) {\r\n        require(to != address(0), \"BentoBox: to not set\"); // To avoid a bad UI from burning funds\r\n        amount = token.balanceOf(address(this)).sub(totalSupply[token]);\r\n        balanceOf[token][to] = balanceOf[token][to].add(amount);\r\n        totalSupply[token] = totalSupply[token].add(amount);\r\n        emit LogDeposit(token, address(this), to, amount);\r\n    }\r\n\r\n    function skimETH() public returns (uint256 amount) { amount = skimETHTo(msg.sender); }\r\n    function skimETHTo(address to) public returns (uint256 amount) {\r\n        IWETH(address(WETH)).deposit{value: address(this).balance}();\r\n        amount = skimTo(WETH, to);\r\n    }\r\n\r\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns(bool[] memory successes, bytes[] memory results) {\r\n        successes = new bool[](calls.length);\r\n        results = new bytes[](calls.length);\r\n        for (uint256 i = 0; i < calls.length; i++) {\r\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\r\n            require(success || !revertOnFail, \"BentoBox: Transaction failed\");\r\n            successes[i] = success;\r\n            results[i] = result;\r\n        }\r\n    }\r\n\r\n    // solhint-disable-next-line no-empty-blocks\r\n    receive() external payable {}\r\n\r\n    // *** Private functions *** //\r\n    function _deposit(IERC20 token, address from, address to, uint256 amount) private {\r\n        require(to != address(0), \"BentoBox: to not set\"); // To avoid a bad UI from burning funds\r\n        balanceOf[token][to] = balanceOf[token][to].add(amount);\r\n        uint256 supply = totalSupply[token];\r\n        totalSupply[token] = supply.add(amount);\r\n\r\n        if (address(token) == address(WETH)) {\r\n            IWETH(address(WETH)).deposit{value: amount}();\r\n        } else {\r\n            if (supply == 0) { // During the first deposit, we check that this token is 'real'\r\n                require(token.totalSupply() > 0, \"BentoBox: No tokens\");\r\n            }\r\n            (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x23b872dd, from, address(this), amount));\r\n            require(success && (data.length == 0 || abi.decode(data, (bool))), \"BentoBox: TransferFrom failed\");\r\n        }\r\n        emit LogDeposit(token, from, to, amount);\r\n    }\r\n\r\n    function _withdraw(IERC20 token, address from, address to, uint256 amount) private {\r\n        require(to != address(0), \"BentoBox: to not set\"); // To avoid a bad UI from burning funds\r\n        balanceOf[token][from] = balanceOf[token][from].sub(amount);\r\n        totalSupply[token] = totalSupply[token].sub(amount);\r\n        if (address(token) == address(WETH)) {\r\n            IWETH(address(WETH)).withdraw(amount);\r\n            (bool success,) = to.call{value: amount}(new bytes(0));\r\n            require(success, \"BentoBox: ETH transfer failed\");\r\n        } else {\r\n            (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, to, amount));\r\n            require(success && (data.length == 0 || abi.decode(data, (bool))), \"BentoBox: Transfer failed\");\r\n        }\r\n        emit LogWithdraw(token, from, to, amount);\r\n    }\r\n}"
    },
    {
      "filename": "contracts/LendingPair.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\n// Medium Risk LendingPair\r\n\r\n// ▄▄▌  ▄▄▄ . ▐ ▄ ·▄▄▄▄  ▪   ▐ ▄  ▄▄ •  ▄▄▄· ▄▄▄· ▪  ▄▄▄\r\n// ██•  ▀▄.▀·•█▌▐███▪ ██ ██ •█▌▐█▐█ ▀ ▪▐█ ▄█▐█ ▀█ ██ ▀▄ █·\r\n// ██▪  ▐▀▀▪▄▐█▐▐▌▐█· ▐█▌▐█·▐█▐▐▌▄█ ▀█▄ ██▀·▄█▀▀█ ▐█·▐▀▀▄\r\n// ▐█▌▐▌▐█▄▄▌██▐█▌██. ██ ▐█▌██▐█▌▐█▄▪▐█▐█▪·•▐█ ▪▐▌▐█▌▐█•█▌\r\n// .▀▀▀  ▀▀▀ ▀▀ █▪▀▀▀▀▀• ▀▀▀▀▀ █▪·▀▀▀▀ .▀    ▀  ▀ ▀▀▀.▀  ▀\r\n\r\n// Copyright (c) 2020 BoringCrypto - All rights reserved\r\n// Twitter: @Boring_Crypto\r\n\r\n// Special thanks to:\r\n// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations\r\n\r\n// WARNING!!! DO NOT USE!!! BEING AUDITED!!!\r\n\r\n// solhint-disable avoid-low-level-calls\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./libraries/BoringMath.sol\";\r\nimport \"./interfaces/IOracle.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./ERC20.sol\";\r\nimport \"./interfaces/IMasterContract.sol\";\r\nimport \"./interfaces/ISwapper.sol\";\r\nimport \"./interfaces/IWETH.sol\";\r\n\r\n// TODO: check all reentrancy paths\r\n// TODO: what to do when the entire pool is underwater?\r\n// TODO: check that all actions on a users funds can only be initiated by that user as msg.sender\r\n\r\ncontract LendingPair is ERC20, Ownable, IMasterContract {\r\n    using BoringMath for uint256;\r\n    using BoringMath128 for uint128;\r\n\r\n    // MasterContract variables\r\n    IBentoBox public immutable bentoBox;\r\n    LendingPair public immutable masterContract;\r\n    address public feeTo;\r\n    address public dev;\r\n    mapping(ISwapper => bool) public swappers;\r\n\r\n    // Per clone variables\r\n    // Clone settings\r\n    IERC20 public collateral;\r\n    IERC20 public asset;\r\n    IOracle public oracle;\r\n    bytes public oracleData;\r\n\r\n    // User balances\r\n    mapping(address => uint256) public userCollateralAmount;\r\n    // userAssetFraction is called balanceOf for ERC20 compatibility\r\n    mapping(address => uint256) public userBorrowFraction;\r\n\r\n    struct TokenTotals {\r\n        uint128 amount;\r\n        uint128 fraction;\r\n    }\r\n\r\n    // Total amounts\r\n    uint256 public totalCollateralAmount;\r\n    TokenTotals public totalAsset; // The total assets belonging to the suppliers (including any borrowed amounts).\r\n    TokenTotals public totalBorrow; // Total units of asset borrowed\r\n\r\n    // totalSupply for ERC20 compatibility\r\n    function totalSupply() public view returns(uint256) {\r\n        return totalAsset.fraction;\r\n    }\r\n\r\n    // Exchange and interest rate tracking\r\n    uint256 public exchangeRate;\r\n\r\n    struct AccrueInfo {\r\n        uint64 interestPerBlock;\r\n        uint64 lastBlockAccrued;\r\n        uint128 feesPendingAmount;\r\n    }\r\n    AccrueInfo public accrueInfo;\r\n\r\n    // ERC20 'variables'\r\n    function symbol() public view returns(string memory) {\r\n        (bool success, bytes memory data) = address(asset).staticcall(abi.encodeWithSelector(0x95d89b41));\r\n        string memory assetSymbol = success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\r\n\r\n        (success, data) = address(collateral).staticcall(abi.encodeWithSelector(0x95d89b41));\r\n        string memory collateralSymbol = success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\r\n\r\n        return string(abi.encodePacked(\"bm\", collateralSymbol, \">\", assetSymbol, \"-\", oracle.symbol(oracleData)));\r\n    }\r\n\r\n    function name() public view returns(string memory) {\r\n        (bool success, bytes memory data) = address(asset).staticcall(abi.encodeWithSelector(0x06fdde03));\r\n        string memory assetName = success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\r\n\r\n        (success, data) = address(collateral).staticcall(abi.encodeWithSelector(0x06fdde03));\r\n        string memory collateralName = success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\r\n\r\n        return string(abi.encodePacked(\"Bento Med Risk \", collateralName, \">\", assetName, \"-\", oracle.symbol(oracleData)));\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        (bool success, bytes memory data) = address(asset).staticcall(abi.encodeWithSelector(0x313ce567));\r\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\r\n    }\r\n\r\n    event LogExchangeRate(uint256 rate);\r\n    event LogAccrue(uint256 accruedAmount, uint256 feeAmount, uint256 rate, uint256 utilization);\r\n    event LogAddCollateral(address indexed user, uint256 amount);\r\n    event LogAddAsset(address indexed user, uint256 amount, uint256 fraction);\r\n    event LogAddBorrow(address indexed user, uint256 amount, uint256 fraction);\r\n    event LogRemoveCollateral(address indexed user, uint256 amount);\r\n    event LogRemoveAsset(address indexed user, uint256 amount, uint256 fraction);\r\n    event LogRemoveBorrow(address indexed user, uint256 amount, uint256 fraction);\r\n    event LogFeeTo(address indexed newFeeTo);\r\n    event LogDev(address indexed newDev);\r\n    event LogWithdrawFees();\r\n\r\n    constructor(IBentoBox bentoBox_) public {\r\n        bentoBox = bentoBox_;\r\n        masterContract = LendingPair(this);\r\n        dev = msg.sender;\r\n        feeTo = msg.sender;\r\n        emit LogDev(msg.sender);\r\n        emit LogFeeTo(msg.sender);\r\n    }\r\n\r\n    // Settings for the Medium Risk LendingPair\r\n    uint256 public constant CLOSED_COLLATERIZATION_RATE = 75000; // 75%\r\n    uint256 public constant OPEN_COLLATERIZATION_RATE = 77000; // 77%\r\n    uint256 public constant MINIMUM_TARGET_UTILIZATION = 7e17; // 70%\r\n    uint256 public constant MAXIMUM_TARGET_UTILIZATION = 8e17; // 80%\r\n\r\n    uint256 public constant STARTING_INTEREST_PER_BLOCK = 4566210045; // approx 1% APR\r\n    uint256 public constant MINIMUM_INTEREST_PER_BLOCK = 1141552511; // approx 0.25% APR\r\n    uint256 public constant MAXIMUM_INTEREST_PER_BLOCK = 4566210045000;  // approx 1000% APR\r\n    uint256 public constant INTEREST_ELASTICITY = 2000e36; // Half or double in 2000 blocks (approx 8 hours)\r\n\r\n    uint256 public constant LIQUIDATION_MULTIPLIER = 112000; // add 12%\r\n\r\n    // Fees\r\n    uint256 public constant PROTOCOL_FEE = 10000; // 10%\r\n    uint256 public constant DEV_FEE = 10000; // 10% of the PROTOCOL_FEE = 1%\r\n    uint256 public constant BORROW_OPENING_FEE = 50; // 0.05%\r\n\r\n    // Serves as the constructor, as clones can't have a regular constructor\r\n    function init(bytes calldata data) public override {\r\n        require(address(collateral) == address(0), \"LendingPair: already initialized\");\r\n        (collateral, asset, oracle, oracleData) = abi.decode(data, (IERC20, IERC20, IOracle, bytes));\r\n\r\n        accrueInfo.interestPerBlock = uint64(STARTING_INTEREST_PER_BLOCK);  // 1% APR, with 1e18 being 100%\r\n        updateExchangeRate();\r\n    }\r\n\r\n    function getInitData(IERC20 collateral_, IERC20 asset_, IOracle oracle_, bytes calldata oracleData_) public pure returns(bytes memory data) {\r\n        return abi.encode(collateral_, asset_, oracle_, oracleData_);\r\n    }\r\n\r\n    // Accrues the interest on the borrowed tokens and handles the accumulation of fees\r\n    function accrue() public {\r\n        AccrueInfo memory info = accrueInfo;\r\n        // Number of blocks since accrue was called\r\n        uint256 blocks = block.number - info.lastBlockAccrued;\r\n        if (blocks == 0) {return;}\r\n        info.lastBlockAccrued = uint64(block.number);\r\n\r\n        uint256 extraAmount;\r\n        uint256 feeAmount;\r\n\r\n        TokenTotals memory _totalBorrow = totalBorrow;\r\n        TokenTotals memory _totalAsset = totalAsset;\r\n        if (_totalBorrow.amount > 0) {\r\n            // Accrue interest\r\n            extraAmount = uint256(_totalBorrow.amount).mul(info.interestPerBlock).mul(blocks) / 1e18;\r\n            feeAmount = ext"
    }
  ]
}