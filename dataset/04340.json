{
  "Title": "[M03] WarpSync contract may return erroneous finalization reward",
  "Content": "The public [`getFinalizationReward` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol#L67) of the `WarpSync` contract is intended to retrieve the finalization reward of a given market. Internally, it calls the [`getRepReward` private function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol#L75) passing the end time of the market’s dispute window as an argument.\n\n\nIf `getFinalizationReward` is called when the market’s dispute window is not yet over (i.e., when `block.timestamp` is lower than `_market.getDisputeWindow().getEndTime()`), then the [unsafe arithmetic operation in line 77](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol#L77) will inevitably underflow. As a result, the returned amount of REP representing the finalization reward will be erroneous.\n\n\nNote that this issue does not introduce a security risk on its own. The only time the `getFinalizationReward` function is used internally by Augur is [at the `recordMarketFinalized` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol#L62), when the market’s dispute window should already be over. At this point, no underflows should occur when calculating the reward. Additionally, the `getCreationReward` function is not affected by the unsafe arithmetic operation mentioned in the previous paragraph, as any known Augur universe is expected to have a lower creation time than the current `block.timestamp`.\n\n\nYet, to prevent unexpected behaviors when querying the `getFinalizationReward` function from off-chain clients (or other functions in future changes to the code base), consider reverting the transaction when an underflow occurs. Alternatively, depending on Augur’s use cases for this getter function, consider returning zero as the REP reward when the given market’s dispute window is not yet over.\n\n\n**Update**: *Fixed in [PR #5564](https://github.com/AugurProject/augur/pull/5564/files). The `WarpSync` contract now uses `SafeMathUint256` in all calculations.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/augur-core/source/contracts/WarpSync.sol",
      "content": "pragma solidity 0.5.10;\n\nimport 'ROOT/IWarpSync.sol';\nimport 'ROOT/reporting/IUniverse.sol';\nimport 'ROOT/reporting/IMarket.sol';\nimport 'ROOT/reporting/IV2ReputationToken.sol';\nimport 'ROOT/external/IAffiliateValidator.sol';\nimport 'ROOT/libraries/Initializable.sol';\n\n\ncontract WarpSync is IWarpSync, Initializable {\n\n    struct Data {\n        uint256 warpSyncHash;\n        uint256 timestamp;\n    }\n\n    IAugur public augur;\n    mapping(address => address) public markets;\n    mapping(address => Data) public data;\n\n    uint256 private constant MARKET_LENGTH = 1 days;\n    uint256 private constant MAX_NUM_TICKS = 2 ** 256 - 2;\n    int256[] private PRICES = [0, 1 ether];\n    string private constant EXTRA_INFO = '{\"description\":\"What will the next Augur Warp Sync hash be?\",\"longDescription\":\"What will the Augur SDK warp sync hash be for the latest block time before or equal to the end date of this market?\"}';\n\n    function initialize(IAugur _augur) public beforeInitialized returns (bool) {\n        endInitialization();\n        augur = _augur;\n        return true;\n    }\n\n    function doInitialReport(IUniverse _universe, uint256[] memory _payoutNumerators, string memory _description, uint256 _additionalStake) public returns (bool) {\n        IMarket _market = IMarket(markets[address(_universe)]);\n        _market.doInitialReport(_payoutNumerators, _description, _additionalStake);\n        _market.getInitialReporter().transferOwnership(msg.sender);\n    }\n\n    function initializeUniverse(IUniverse _universe) public {\n        require(augur.isKnownUniverse(_universe));\n        require(markets[address(_universe)] == address(0));\n        awardRep(_universe, getCreationReward(_universe));\n        createMarket(_universe);\n    }\n\n    function notifyMarketFinalized() public {\n        IMarket _market = IMarket(msg.sender);\n        IUniverse _universe = _market.getUniverse();\n\n        if (markets[address(_universe)] != address(_market)) {\n            return;\n        }\n\n        recordMarketFinalized(_market, _universe);\n\n        if (!_universe.isForking()) {\n            createMarket(_universe);\n        }\n    }\n\n    function recordMarketFinalized(IMarket _market, IUniverse _universe) private {\n        awardRep(_universe, getFinalizationReward(_market));\n        data[address(_universe)].warpSyncHash = _market.getWinningPayoutNumerator(2);\n        data[address(_universe)].timestamp = _market.getEndTime();\n    }\n\n    function getFinalizationReward(IMarket _market) public view returns (uint256) {\n        return getRepReward(_market.getDisputeWindow().getEndTime());\n    }\n\n    function getCreationReward(IUniverse _universe) public view returns (uint256) {\n        return getRepReward(_universe.creationTime());\n    }\n\n    function getRepReward(uint256 _theoreticalTime) private view returns (uint256) {\n        uint256 _currentTime = augur.getTimestamp();\n        uint256 _timeSinceTheoreticalCreationInSeconds = _currentTime - _theoreticalTime;\n        return (_timeSinceTheoreticalCreationInSeconds ** 3) * 1000;\n    }\n\n    function awardRep(IUniverse _universe, uint256 _amount) private returns (bool) {\n        IV2ReputationToken _reputationToken = _universe.getReputationToken();\n        // Whoever was responsible for this tx occuring gets REP.\n        // solium-disable-next-line security/no-tx-origin\n        _reputationToken.mintForWarpSync(_amount, tx.origin);\n        return true;\n    }\n\n    function createMarket(IUniverse _universe) private {\n        IV2ReputationToken _reputationToken = _universe.getReputationToken();\n        uint256 _repBond = _universe.getOrCacheMarketRepBond();\n        _reputationToken.mintForWarpSync(_repBond, address(this));\n        uint256 _endTime = augur.getTimestamp() + MARKET_LENGTH;\n        IMarket _market = _universe.createScalarMarket(_endTime, 0, IAffiliateValidator(0), 0, address(this), PRICES, MAX_NUM_TICKS, EXTRA_INFO);\n        markets[address(_universe)] = address(_market);\n    }\n}"
    },
    {
      "filename": "packages/augur-core/source/contracts/WarpSync.sol",
      "content": "pragma solidity 0.5.10;\n\nimport 'ROOT/IWarpSync.sol';\nimport 'ROOT/reporting/IUniverse.sol';\nimport 'ROOT/reporting/IMarket.sol';\nimport 'ROOT/reporting/IV2ReputationToken.sol';\nimport 'ROOT/external/IAffiliateValidator.sol';\nimport 'ROOT/libraries/Initializable.sol';\n\n\ncontract WarpSync is IWarpSync, Initializable {\n\n    struct Data {\n        uint256 warpSyncHash;\n        uint256 timestamp;\n    }\n\n    IAugur public augur;\n    mapping(address => address) public markets;\n    mapping(address => Data) public data;\n\n    uint256 private constant MARKET_LENGTH = 1 days;\n    uint256 private constant MAX_NUM_TICKS = 2 ** 256 - 2;\n    int256[] private PRICES = [0, 1 ether];\n    string private constant EXTRA_INFO = '{\"description\":\"What will the next Augur Warp Sync hash be?\",\"longDescription\":\"What will the Augur SDK warp sync hash be for the latest block time before or equal to the end date of this market?\"}';\n\n    function initialize(IAugur _augur) public beforeInitialized returns (bool) {\n        endInitialization();\n        augur = _augur;\n        return true;\n    }\n\n    function doInitialReport(IUniverse _universe, uint256[] memory _payoutNumerators, string memory _description, uint256 _additionalStake) public returns (bool) {\n        IMarket _market = IMarket(markets[address(_universe)]);\n        _market.doInitialReport(_payoutNumerators, _description, _additionalStake);\n        _market.getInitialReporter().transferOwnership(msg.sender);\n    }\n\n    function initializeUniverse(IUniverse _universe) public {\n        require(augur.isKnownUniverse(_universe));\n        require(markets[address(_universe)] == address(0));\n        awardRep(_universe, getCreationReward(_universe));\n        createMarket(_universe);\n    }\n\n    function notifyMarketFinalized() public {\n        IMarket _market = IMarket(msg.sender);\n        IUniverse _universe = _market.getUniverse();\n\n        if (markets[address(_universe)] != address(_market)) {\n            return;\n        }\n\n        recordMarketFinalized(_market, _universe);\n\n        if (!_universe.isForking()) {\n            createMarket(_universe);\n        }\n    }\n\n    function recordMarketFinalized(IMarket _market, IUniverse _universe) private {\n        awardRep(_universe, getFinalizationReward(_market));\n        data[address(_universe)].warpSyncHash = _market.getWinningPayoutNumerator(2);\n        data[address(_universe)].timestamp = _market.getEndTime();\n    }\n\n    function getFinalizationReward(IMarket _market) public view returns (uint256) {\n        return getRepReward(_market.getDisputeWindow().getEndTime());\n    }\n\n    function getCreationReward(IUniverse _universe) public view returns (uint256) {\n        return getRepReward(_universe.creationTime());\n    }\n\n    function getRepReward(uint256 _theoreticalTime) private view returns (uint256) {\n        uint256 _currentTime = augur.getTimestamp();\n        uint256 _timeSinceTheoreticalCreationInSeconds = _currentTime - _theoreticalTime;\n        return (_timeSinceTheoreticalCreationInSeconds ** 3) * 1000;\n    }\n\n    function awardRep(IUniverse _universe, uint256 _amount) private returns (bool) {\n        IV2ReputationToken _reputationToken = _universe.getReputationToken();\n        // Whoever was responsible for this tx occuring gets REP.\n        // solium-disable-next-line security/no-tx-origin\n        _reputationToken.mintForWarpSync(_amount, tx.origin);\n        return true;\n    }\n\n    function createMarket(IUniverse _universe) private {\n        IV2ReputationToken _reputationToken = _universe.getReputationToken();\n        uint256 _repBond = _universe.getOrCacheMarketRepBond();\n        _reputationToken.mintForWarpSync(_repBond, address(this));\n        uint256 _endTime = augur.getTimestamp() + MARKET_LENGTH;\n        IMarket _market = _universe.createScalarMarket(_endTime, 0, IAffiliateValidator(0), 0, address(this), PRICES, MAX_NUM_TICKS, EXTRA_INFO);\n        markets[address(_universe)] = address(_market);\n    }\n}"
    },
    {
      "filename": "packages/augur-core/source/contracts/WarpSync.sol",
      "content": "pragma solidity 0.5.10;\n\nimport 'ROOT/IWarpSync.sol';\nimport 'ROOT/reporting/IUniverse.sol';\nimport 'ROOT/reporting/IMarket.sol';\nimport 'ROOT/reporting/IV2ReputationToken.sol';\nimport 'ROOT/external/IAffiliateValidator.sol';\nimport 'ROOT/libraries/Initializable.sol';\n\n\ncontract WarpSync is IWarpSync, Initializable {\n\n    struct Data {\n        uint256 warpSyncHash;\n        uint256 timestamp;\n    }\n\n    IAugur public augur;\n    mapping(address => address) public markets;\n    mapping(address => Data) public data;\n\n    uint256 private constant MARKET_LENGTH = 1 days;\n    uint256 private constant MAX_NUM_TICKS = 2 ** 256 - 2;\n    int256[] private PRICES = [0, 1 ether];\n    string private constant EXTRA_INFO = '{\"description\":\"What will the next Augur Warp Sync hash be?\",\"longDescription\":\"What will the Augur SDK warp sync hash be for the latest block time before or equal to the end date of this market?\"}';\n\n    function initialize(IAugur _augur) public beforeInitialized returns (bool) {\n        endInitialization();\n        augur = _augur;\n        return true;\n    }\n\n    function doInitialReport(IUniverse _universe, uint256[] memory _payoutNumerators, string memory _description, uint256 _additionalStake) public returns (bool) {\n        IMarket _market = IMarket(markets[address(_universe)]);\n        _market.doInitialReport(_payoutNumerators, _description, _additionalStake);\n        _market.getInitialReporter().transferOwnership(msg.sender);\n    }\n\n    function initializeUniverse(IUniverse _universe) public {\n        require(augur.isKnownUniverse(_universe));\n        require(markets[address(_universe)] == address(0));\n        awardRep(_universe, getCreationReward(_universe));\n        createMarket(_universe);\n    }\n\n    function notifyMarketFinalized() public {\n        IMarket _market = IMarket(msg.sender);\n        IUniverse _universe = _market.getUniverse();\n\n        if (markets[address(_universe)] != address(_market)) {\n            return;\n        }\n\n        recordMarketFinalized(_market, _universe);\n\n        if (!_universe.isForking()) {\n            createMarket(_universe);\n        }\n    }\n\n    function recordMarketFinalized(IMarket _market, IUniverse _universe) private {\n        awardRep(_universe, getFinalizationReward(_market));\n        data[address(_universe)].warpSyncHash = _market.getWinningPayoutNumerator(2);\n        data[address(_universe)].timestamp = _market.getEndTime();\n    }\n\n    function getFinalizationReward(IMarket _market) public view returns (uint256) {\n        return getRepReward(_market.getDisputeWindow().getEndTime());\n    }\n\n    function getCreationReward(IUniverse _universe) public view returns (uint256) {\n        return getRepReward(_universe.creationTime());\n    }\n\n    function getRepReward(uint256 _theoreticalTime) private view returns (uint256) {\n        uint256 _currentTime = augur.getTimestamp();\n        uint256 _timeSinceTheoreticalCreationInSeconds = _currentTime - _theoreticalTime;\n        return (_timeSinceTheoreticalCreationInSeconds ** 3) * 1000;\n    }\n\n    function awardRep(IUniverse _universe, uint256 _amount) private returns (bool) {\n        IV2ReputationToken _reputationToken = _universe.getReputationToken();\n        // Whoever was responsible for this tx occuring gets REP.\n        // solium-disable-next-line security/no-tx-origin\n        _reputationToken.mintForWarpSync(_amount, tx.origin);\n        return true;\n    }\n\n    function createMarket(IUniverse _universe) private {\n        IV2ReputationToken _reputationToken = _universe.getReputationToken();\n        uint256 _repBond = _universe.getOrCacheMarketRepBond();\n        _reputationToken.mintForWarpSync(_repBond, address(this));\n        uint256 _endTime = augur.getTimestamp() + MARKET_LENGTH;\n        IMarket _market = _universe.createScalarMarket(_endTime, 0, IAffiliateValidator(0), 0, address(this), PRICES, MAX_NUM_TICKS, EXTRA_INFO);\n        markets[address(_universe)] = address(_market);\n    }\n}"
    }
  ]
}