{
  "Title": "[N-03] Large multiples of ten should use scientific notation (e.g. `1e6`) rather than decimal literals (e.g. `1000000`), for readability",
  "Content": "\n*There are 2 instances of this issue:*\n```solidity\nFile: protocol/contracts/utils/CvxMintAmount.sol   #1\n\n10:       uint256 private constant _CLIFF_SIZE = 100000 * 1e18; //new cliff every 100,000 tokens\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/CvxMintAmount.sol#L10\n\n```solidity\nFile: protocol/contracts/utils/CvxMintAmount.sol   #2\n\n12:       uint256 private constant _MAX_SUPPLY = 100000000 * 1e18; //100 mil max supply\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/CvxMintAmount.sol#L12\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-backd",
  "Code": [
    {
      "filename": "protocol/contracts/utils/CvxMintAmount.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../libraries/UncheckedMath.sol\";\n\nabstract contract CvxMintAmount {\n    using UncheckedMath for uint256;\n\n    uint256 private constant _CLIFF_SIZE = 100000 * 1e18; //new cliff every 100,000 tokens\n    uint256 private constant _CLIFF_COUNT = 1000; // 1,000 cliffs\n    uint256 private constant _MAX_SUPPLY = 100000000 * 1e18; //100 mil max supply\n    IERC20 private constant _CVX_TOKEN =\n        IERC20(address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B)); // CVX Token\n\n    function getCvxMintAmount(uint256 crvEarned) public view returns (uint256) {\n        //first get total supply\n        uint256 cvxTotalSupply = _CVX_TOKEN.totalSupply();\n\n        //get current cliff\n        uint256 currentCliff = cvxTotalSupply / _CLIFF_SIZE;\n\n        //if current cliff is under the max\n        if (currentCliff >= _CLIFF_COUNT) return 0;\n\n        //get remaining cliffs\n        uint256 remaining = _CLIFF_COUNT.uncheckedSub(currentCliff);\n\n        //multiply ratio of remaining cliffs to total cliffs against amount CRV received\n        uint256 cvxEarned = (crvEarned * remaining) / _CLIFF_COUNT;\n\n        //double check we have not gone over the max supply\n        uint256 amountTillMax = _MAX_SUPPLY - cvxTotalSupply;\n        if (cvxEarned > amountTillMax) cvxEarned = amountTillMax;\n        return cvxEarned;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/utils/CvxMintAmount.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../libraries/UncheckedMath.sol\";\n\nabstract contract CvxMintAmount {\n    using UncheckedMath for uint256;\n\n    uint256 private constant _CLIFF_SIZE = 100000 * 1e18; //new cliff every 100,000 tokens\n    uint256 private constant _CLIFF_COUNT = 1000; // 1,000 cliffs\n    uint256 private constant _MAX_SUPPLY = 100000000 * 1e18; //100 mil max supply\n    IERC20 private constant _CVX_TOKEN =\n        IERC20(address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B)); // CVX Token\n\n    function getCvxMintAmount(uint256 crvEarned) public view returns (uint256) {\n        //first get total supply\n        uint256 cvxTotalSupply = _CVX_TOKEN.totalSupply();\n\n        //get current cliff\n        uint256 currentCliff = cvxTotalSupply / _CLIFF_SIZE;\n\n        //if current cliff is under the max\n        if (currentCliff >= _CLIFF_COUNT) return 0;\n\n        //get remaining cliffs\n        uint256 remaining = _CLIFF_COUNT.uncheckedSub(currentCliff);\n\n        //multiply ratio of remaining cliffs to total cliffs against amount CRV received\n        uint256 cvxEarned = (crvEarned * remaining) / _CLIFF_COUNT;\n\n        //double check we have not gone over the max supply\n        uint256 amountTillMax = _MAX_SUPPLY - cvxTotalSupply;\n        if (cvxEarned > amountTillMax) cvxEarned = amountTillMax;\n        return cvxEarned;\n    }\n}"
    }
  ]
}