{
  "Title": "[15] Orders with moving price and `endTime = type(uint).max` can never be fulfilled",
  "Content": "\nIt is quite realistic that many users will use `type(uint).max` as `infinity` when setting the `endTime` of their orders so that it stays open indefinitely. However the math `(startAmount * remaining) + (endAmount * elapsed) + extraCeiling` in https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/AmountDeriver.sol#L57 will almost always revert in that case since `remaining` will be very large and this block of code is checked Solidity.\n\n### Proof of Concept\n**Context:** [Seaport.sol](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/Seaport.sol)\n\nUse the new test below and run `forge test -m testAdvancedPartialMaxEndTime -vvvv`:\n\n```solidity\nfunction testAdvancedPartialMaxEndTime() public {\n\tFuzzInputs memory inputs = FuzzInputs(\n\t\t0,\n\t\taddress(0),\n\t\tbytes32(0),\n\t\t0,\n\t\t0,\n\t\t[uint120(10), 20, 30],\n\t\tfalse,\n\t\t1,\n\t\t1\n\t);\n\n\t_testAdvancedPartialMaxEndTime(\n\t\tContext(consideration, inputs, 10, 10)\n\t);\n}\n\nfunction _testAdvancedPartialMaxEndTime(\n\tContext memory context\n) internal resetTokenBalancesBetweenRuns {\n\tbytes32 conduitKey = context.args.useConduit\n\t\t? conduitKeyOne\n\t\t: bytes32(0);\n\n\tuint startAmount = 10;\n\tuint endAmount = 20;\n\n\ttest1155_1.mint(\n\t\talice,\n\t\tcontext.args.tokenId,\n\t\tendAmount\n\t);\n\n\t_configureOfferItem(\n\t\tItemType.ERC1155,\n\t\tcontext.args.tokenId,\n\t\tstartAmount,\n\t\tendAmount\n\t);\n\t_configureEthConsiderationItem(\n\t\talice,\n\t\t10\n\t);\n\n\tOrderParameters memory orderParameters = OrderParameters(\n\t\taddress(alice),\n\t\tcontext.args.zone,\n\t\tofferItems,\n\t\tconsiderationItems,\n\t\tOrderType.PARTIAL_OPEN,\n\t\tblock.timestamp, // startTime\n\t\ttype(uint).max, // endTime\n\t\tcontext.args.zoneHash,\n\t\tcontext.args.salt,\n\t\tconduitKey,\n\t\tconsiderationItems.length\n\t);\n\n\tOrderComponents memory orderComponents = getOrderComponents(\n\t\torderParameters,\n\t\tcontext.consideration.getNonce(alice)\n\t);\n\n\tbytes32 orderHash = context.consideration.getOrderHash(orderComponents);\n\n\tbytes memory signature = signOrder(\n\t\tcontext.consideration,\n\t\talicePk,\n\t\torderHash\n\t);\n\n\tdelete offerItems;\n\tdelete considerationItems;\n\n\tAdvancedOrder memory advancedOrder = AdvancedOrder(\n\t\torderParameters,\n\t\t1,\n\t\t1,\n\t\tsignature,\n\t\t\"\"\n\t);\n\n\tcontext.consideration.fulfillAdvancedOrder{\n\t\tvalue: 10\n\t}(advancedOrder, new CriteriaResolver[](0), bytes32(0));\n\t(, , uint256 totalFilled, uint256 totalSize) = context\n\t\t.consideration\n\t\t.getOrderStatus(orderHash);\n}\n```\n\n### Recommended Mitigation Steps\n\nNeed to find a way to compute the linear interpolation without overflows.\nFor `(a + b) / 2`, the trick is `a / 2 + b / 2 + (a & b & 1)`:\nhttps://devblogs.microsoft.com/oldnewthing/20220207-00/?p=106223\n\nNeed to find a similar trick for `(x * a + y * b) / (x + y)`.\n\nWorst case it can also be a front end fix.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-opensea-seaport",
  "Code": [
    {
      "filename": "contracts/lib/AmountDeriver.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n// prettier-ignore\nimport {\n    AmountDerivationErrors\n} from \"../interfaces/AmountDerivationErrors.sol\";\n\n/**\n * @title AmountDeriver\n * @author 0age\n * @notice AmountDeriver contains pure functions related to deriving item\n *         amounts based on partial fill quantity and on linear extrapolation\n *         based on current time when the start amount and end amount differ.\n */\ncontract AmountDeriver is AmountDerivationErrors {\n    /**\n     * @dev Internal pure function to derive the current amount of a given item\n     *      based on the current price, the starting price, and the ending\n     *      price. If the start and end prices differ, the current price will be\n     *      extrapolated on a linear basis.\n     *\n     * @param startAmount The starting amount of the item.\n     * @param endAmount   The ending amount of the item.\n     * @param elapsed     The time elapsed since the order's start time.\n     * @param remaining   The time left until the order's end time.\n     * @param duration    The total duration of the order.\n     * @param roundUp     A boolean indicating whether the resultant amount\n     *                    should be rounded up or down.\n     *\n     * @return The current amount.\n     */\n    function _locateCurrentAmount(\n        uint256 startAmount,\n        uint256 endAmount,\n        uint256 elapsed,\n        uint256 remaining,\n        uint256 duration,\n        bool roundUp\n    ) internal pure returns (uint256) {\n        // Only modify end amount if it doesn't already equal start amount.\n        if (startAmount != endAmount) {\n            // Leave extra amount to add for rounding at zero (i.e. round down).\n            uint256 extraCeiling = 0;\n\n            // If rounding up, set rounding factor to one less than denominator.\n            if (roundUp) {\n                // Skip underflow check: duration cannot be zero.\n                unchecked {\n                    extraCeiling = duration - 1;\n                }\n            }\n\n            // Aggregate new amounts weighted by time with rounding factor\n            // prettier-ignore\n            uint256 totalBeforeDivision = (\n                (startAmount * remaining) + (endAmount * elapsed) + extraCeiling\n            );\n\n            // Division performed with no zero check as duration cannot be zero.\n            uint256 newAmount;\n            assembly {\n                newAmount := div(totalBeforeDivision, duration)\n            }\n\n            // Return the current amount (expressed as endAmount internally).\n            return newAmount;\n        }\n\n        // Return the original amount (now expressed as endAmount internally).\n        return endAmount;\n    }\n\n    /**\n     * @dev Internal pure function to return a fraction of a given value and to\n     *      ensure the resultant value does not have any fractional component.\n     *      Note that this function assumes that zero will never be supplied as\n     *      the denominator parameter; invalid / undefined behavior will result\n     *      should a denominator of zero be provided.\n     *\n     * @param numerator   A value indicating the portion of the order that\n     *                    should be filled.\n     * @param denominator A value indicating the total size of the order. Note\n     *                    that this value cannot be equal to zero.\n     * @param value       The value for which to compute the fraction.\n     *\n     * @return newValue The value after applying the fraction.\n     */\n    function _getFraction(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 value\n    ) internal pure returns (uint256 newValue) {\n        // Return value early in cases where the fraction resolves to 1.\n        if (numerator == denominator) {\n            return value;\n        }\n\n        // Ensure fraction can be applied to the value with no remainder. Note\n        // that the denominator cannot be zero.\n        bool exact;\n        assembly {\n            // Ensure new value contains no remainder via mulmod operator.\n            // Credit to @hrkrshnn + @axic for proposing this optimal solution.\n            exact := iszero(mulmod(value, numerator, denominator))\n        }\n\n        // Ensure that division gave a final result with no remainder.\n        if (!exact) {\n            revert InexactFraction();\n        }\n\n        // Multiply the numerator by the value and ensure no overflow occurs.\n        uint256 valueTimesNumerator = value * numerator;\n\n        // Divide and check for remainder. Note that denominator cannot be zero.\n        assembly {\n            // Perform division without zero check.\n            newValue := div(valueTimesNumerator, denominator)\n        }\n    }\n\n    /**\n     * @dev Internal pure function to apply a fraction to a consideration\n     * or offer item.\n     *\n     * @param startAmount     The starting amount of the item.\n     * @param endAmount       The ending amount of the item.\n     * @param numerator       A value indicating the portion of the order that\n     *                        should be filled.\n     * @param denominator     A value indicating the total size of the order.\n     * @param elapsed         The time elapsed since the order's start time.\n     * @param remaining       The time left until the order's end time.\n     * @param duration        The total duration of the order.\n     *\n     * @return amount The received item to transfer with the final amount.\n     */\n    function _applyFraction(\n        uint256 startAmount,\n        uint256 endAmount,\n        uint256 numerator,\n        uint256 denominator,\n        uint256 elapsed,\n        uint256 remaining,\n        uint256 duration,\n        bool roundUp\n    ) internal pure returns (uint256 amount) {\n        // If start amount equals end amount, apply fraction to end amount.\n        if (startAmount == endAmount) {\n            // Apply fraction to end amount.\n            amount = _getFraction(numerator, denominator, endAmount);\n        } else {\n            // Otherwise, apply fraction to both and extrapolate final amount.\n            amount = _locateCurrentAmount(\n                _getFraction(numerator, denominator, startAmount),\n                _getFraction(numerator, denominator, endAmount),\n                elapsed,\n                remaining,\n                duration,\n                roundUp\n            );\n        }\n    }\n}"
    }
  ]
}