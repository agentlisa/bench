{
  "Title": "[M-18] Users cannot stop loss in AutoRange and AutoExit",
  "Content": "\n<https://github.com/code-423n4/2024-03-revert-lend/blob/main/src/automators/Automator.sol#L151-L153>\n\n<https://github.com/code-423n4/2024-03-revert-lend/blob/main/src/automators/AutoExit.sol#L162-L169>\n\n<https://github.com/code-423n4/2024-03-revert-lend/blob/main/src/transformers/AutoRange.sol#L157-L164>\n\n### Impact\n\n- Users cannot stop loss in AutoRange and AutoExit, resulting in huge loss.\n- Users cannot withdraw their tokens and cut loss even when they choose no swap option.\n\n### Proof of Concept\n\nContract `AutoRange` and `AutoExit` both inherits contract `Automator` and uses its function `_validateSwap`:\n\n```solidity\nfunction _validateSwap(\n        bool swap0For1,\n        uint256 amountIn,\n        IUniswapV3Pool pool,\n        uint32 twapPeriod,\n        uint16 maxTickDifference,\n        uint64 maxPriceDifferenceX64\n    ) internal view returns (uint256 amountOutMin, int24 currentTick, uint160 sqrtPriceX96, uint256 priceX96) {\n        // get current price and tick\n        (sqrtPriceX96, currentTick,,,,,) = pool.slot0();\n\n        // check if current tick not too far from TWAP\n        if (!_hasMaxTWAPTickDifference(pool, twapPeriod, currentTick, maxTickDifference)) {\n            revert TWAPCheckFailed();\n        }\n....\n\n function _hasMaxTWAPTickDifference(IUniswapV3Pool pool, uint32 twapPeriod, int24 currentTick, uint16 maxDifference)\n        internal\n        view\n        returns (bool)\n    {\n        (int24 twapTick, bool twapOk) = _getTWAPTick(pool, twapPeriod);\n        if (twapOk) {\n            return twapTick - currentTick >= -int16(maxDifference) && twapTick - currentTick <= int16(maxDifference);\n        } else {\n            return false;\n        }\n    }\n\n...\n\n\nfunction _getTWAPTick(IUniswapV3Pool pool, uint32 twapPeriod) internal view returns (int24, bool) {\n        uint32[] memory secondsAgos = new uint32[](2);\n        secondsAgos[0] = 0; // from (before)\n        secondsAgos[1] = twapPeriod; // from (before)\n\n        // pool observe may fail when there is not enough history available\n        try pool.observe(secondsAgos) returns (int56[] memory tickCumulatives, uint160[] memory) {\n            return (int24((tickCumulatives[0] - tickCumulatives[1]) / int56(uint56(twapPeriod))), true);\n        } catch {\n            return (0, false);\n        }\n    }\n```\n\nThe function will revert if the difference between current tick and twap tick `>` `maxTickDifference`. Currently, `maxTickDifference` must `<= 200` as you can see in function `setTWAPConfig`:\n\n```solidity\nfunction setTWAPConfig(uint16 _maxTWAPTickDifference, uint32 _TWAPSeconds) public onlyOwner {\n        if (_TWAPSeconds < MIN_TWAP_SECONDS) {\n            revert InvalidConfig();\n        }\n        if (_maxTWAPTickDifference > MAX_TWAP_TICK_DIFFERENCE) {\n            revert InvalidConfig();\n        }\n        emit TWAPConfigChanged(_TWAPSeconds, _maxTWAPTickDifference);\n        TWAPSeconds = _TWAPSeconds;\n        maxTWAPTickDifference = _maxTWAPTickDifference;\n    }\n```\n\n`MAX_TWAP_TICK_DIFFERENCE` = 200.\n\nIf for example, `maxTWAPTickDifference` = 100, then the function will revert if price difference `= 1.0001 * 100 = 1%`. This will prevent users of `AutoExit` and `AutoRange` from stopping their loss in case the market drops `>` 1%.\n\nLets take an example:\n\n- Alice chooses `AutoRange` transformer.\n- Then `AutoRange.execute` is called with `amountIn` = 0, according to the comment in `AutoRange.ExecuteParams` struct, then if `amountIn` = 0, it means no swap:\n\n```solidity\nstruct ExecuteParams {\n        uint256 tokenId;\n        bool swap0To1;\n        uint256 amountIn; // if this is set to 0 no swap happens\n        bytes swapData;\n        uint128 liquidity; // liquidity the calculations are based on\n        uint256 amountRemoveMin0; // min amount to be removed from liquidity\n        uint256 amountRemoveMin1; // min amount to be removed from liquidity\n        uint256 deadline; // for uniswap operations - operator promises fair value\n        uint64 rewardX64; // which reward will be used for protocol, can be max configured amount (considering onlyFees)\n    }\n```\n\n- In case of no swap, Alice just wants to withdraw her tokens and cut loss.\n- However, after `AutoRange` has called `_decreaseFullLiquidityAndCollect` to withdraw tokens for Alice, `AutoRange` still call `_validateSwap` to check (although `amountIn` is set to `0` - meaning no swap):\n\n```solidity\n        (state.amount0, state.amount1, state.feeAmount0, state.feeAmount1) = _decreaseFullLiquidityAndCollect(\n            params.tokenId, state.liquidity, params.amountRemoveMin0, params.amountRemoveMin1, params.deadline\n        );\n\n        ...\n        // check oracle for swap\n        (state.amountOutMin, state.currentTick,,) = _validateSwap(\n            params.swap0To1,\n            params.amountIn,\n            state.pool,\n            TWAPSeconds,\n            maxTWAPTickDifference,\n            params.swap0To1 ? config.token0SlippageX64 : config.token1SlippageX64\n        );\n```\n\n- If (`currentTick` - `twapTick`) `> 100` (meaning 1% price difference), then the transaction will revert and the operator failed to stop Alice's loss.\n- Alice has to wait when the condition (`currentTick` - `twapTick`) `< 100` to cut loss, by then it's too late.\n\nThe same thing happens in `AutoExit`, users cannot withdraw their tokens in case the prices change `>` 1%.\n\nBelow is a POC for the above example, save this test case to file `test/integration/automators/AutoRange.t.sol` and run it using command:\n`forge test --match-path test/integration/automators/AutoRange.t.sol --match-test testNoSwapRevert -vvvv`.\n\n```solidity\nfunction testNoSwapRevert() public {\n        bool onlyFees = false;\n        SwapTestState memory state;\n\n\n        // Config AutoRange\n        vm.startPrank(TEST_NFT_2_ACCOUNT);\n        NPM.setApprovalForAll(address(autoRange), true);\n        autoRange.configToken(\n            TEST_NFT_2,\n            address(0),\n            AutoRange.PositionConfig(\n                0, 0, 0, 60, uint64(Q64 / 100), uint64(Q64 / 100), onlyFees, onlyFees ? MAX_FEE_REWARD : MAX_REWARD\n            )\n        );\n\n        (,,,,,,, state.liquidity,,,,) = NPM.positions(TEST_NFT_2);\n        vm.stopPrank();\n\n        //\n        (, int24 currentTick,,,,,) = IUniswapV3Pool(0xC2e9F25Be6257c210d7Adf0D4Cd6E3E881ba25f8).slot0();\n        console.logInt(currentTick);\n\n        // mock twap data\n        // _maxTWAPTickDifference is currently set as 100\n        // twapPeriod is 60,\n        // currenttick = -73244\n        // so the mock twap price  = (-6912871013261 - -6912866037401) / 60 = -82931\n        int56[] memory tickCumulative = new int56[](2);\n        tickCumulative[0] = -6912871013261;\n        tickCumulative[1] = -6912866037401;\n\n        uint32[] memory secondsAgos = new uint32[](2);\n        secondsAgos[0] = 0;\n        secondsAgos[1] = 60;\n        uint160[] memory secondsPerLiquidityCumulativeX128s = new uint160[](2);\n\n        vm.mockCall(\n            0xC2e9F25Be6257c210d7Adf0D4Cd6E3E881ba25f8,(abi.encodeWithSelector(0x883bdbfd,secondsAgos)),\n            abi.encode(tickCumulative,secondsPerLiquidityCumulativeX128s)\n        );\n\n        //Operator run\n        vm.prank(OPERATOR_ACCOUNT);\n        vm.expectRevert();\n        autoRange.execute(\n            AutoRange.ExecuteParams(\n                TEST_NFT_2, false, 0, \"\", state.liquidity, 0, 0, block.timestamp, onlyFees ? MAX_FEE_REWARD : MAX_REWARD\n            )\n        );\n    }\n```\n\nIn the test case, I creates a `mockCall` to uniswap v3 `observe` function to simulate a market drop.\n\n### Recommended Mitigation Steps\n\nI recommend skipping the swap operation if `_hasMaxTWAPTickDifference` returns `false` instead of reverting.\n\n### Assessed type\n\nInvalid Validation\n\n**[EV_om (lookout) commented](https://github.com/code-423n4/2024-03-revert-lend-findings/issues/202#issuecomment-2017824490):**\n > Users have no control over the timing of Automator calls, operators do. If a user wants to quickly exit a position, they can repay.\n> \n> This is an in-built protection mechanism.\n\n**[ktg (warden) commented](https://github.com/code-423n4/2024-03-revert-lend-findings/issues/202#issuecomment-2033383100):**\n > @EV_om, `AutoExit` will be called by a bot, users uses a bot to avoid manually exiting their UniswapV3 positions so I think the point `If a user wants to quickly exit a position, they can repay.` is not related. \n> \n> What I meant in this issue is that even if `amountIn` is set to `0` (which means no swap), the code still call `_validateSwap ` and revert if the price fluctuation is too high. Therefore, if `execute` is called with `amountIn = 0` (which clearly indicates no swap, just withdraw and exit) and the price fluctuation is too high, it will revert. In another word, the code check the condition and revert in situations where users/callers clearly want to neglect that condition.\n> \n> About `This is an in-built protection mechanism.`, I think this is indeed a built-in protection mechanism, but that mechanism is only for cases where swap is needed. In this issue, this mechanism is still activated even when users don't want it and result in their losses.\n\n**[EV_om (lookout) commented](https://github.com/code-423n4/2024-03-revert-lend-findings/issues/202#issuecomment-2033738713):**\n > You're right, repayment of positions is unrelated, my bad. What I should have said was \"If a user wants to quickly exit a position, they can do so manually.\" As for the no swap case, there is no loss being prevented as the position owner will remain exposed to the same price action.\n> \n> Nevertheless, the unnecessary call to `_validateSwap()` and resulting reverting behavior is a good observation. The judge may want to consider this as QA despite the overinflated severity and invalid assumptions of the original submission.\n\n**[ktg (warden) commented](https://github.com/code-423n4/2024-03-revert-lend-findings/issues/202#issuecomment-2033929536):**\n > @EV_om , @ronnyx2017 - I think the statement `If a user wants to quickly exit a position, they can do so manually.` is also unrelated here because the role of `AutoExit` is to help users automatically exit a position. You can't expect users to look at market data and exit manually all the time; that's why `AutoExit/AutoRange` exists.\n> \n> The loss here is that `AutoExit` cannot help users to automatically exit a position because it reverts on a condition that clearly needed to be omitted due to `amountIn =0` (no swap). \n> \n> I think we all agree that the call to `_validateSwap()` is unnecessary here but I disagree that it's just a QA because it can cost huge loss due to users (through `AutoExit` or `AutoRange`) unable to exit or re arrange their position. \n> \n> If users choose to set `amountIn` (or `swapAmount`) `= 0`, then what they want is \"I don't want to swap, just exit/autorange my position\", but then `AutoExit`/`AutoRange` fails to do this.\n\n**[ronnyx2017 (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-03-revert-lend-findings/issues/202#issuecomment-2036442091):**\n > Good catch! Unnecessary `_validateSwap` here has genuinely compromised certain functionalities of the protocol. Medium is justified, in my opinion. Looking forward to the sponsor's perspective, @kalinbas.\n\n**[kalinbas (Revert) confirmed and commented](https://github.com/code-423n4/2024-03-revert-lend-findings/issues/202#issuecomment-2037841620):**\n > `_validateSwap()` is not necessary only if there is no swap, we are going to remove if in that case.\n\n**[Revert mitigated](https://github.com/code-423n4/2024-04-revert-mitigation?tab=readme-ov-file#scope):**\n> Fixed [here](https://github.com/revert-finance/lend/pull/12).\n\n**Status:** Mitigation Confirmed. Full details in reports from [b0g0](https://github.com/code-423n4/2024-04-revert-mitigation-findings/issues/50), [thank_you](https://github.com/code-423n4/2024-04-revert-mitigation-findings/issues/93) and [ktg](https://github.com/code-423n4/2024-04-revert-mitigation-findings/issues/35).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-revert-lend",
  "Code": [
    {
      "filename": "src/automators/Automator.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"v3-core/interfaces/IUniswapV3Factory.sol\";\nimport \"v3-core/interfaces/IUniswapV3Pool.sol\";\nimport \"v3-core/libraries/TickMath.sol\";\nimport \"v3-core/libraries/FullMath.sol\";\n\nimport \"v3-periphery/interfaces/INonfungiblePositionManager.sol\";\n\nimport \"../../lib/IWETH9.sol\";\nimport \"../utils/Swapper.sol\";\nimport \"../interfaces/IVault.sol\";\n\nabstract contract Automator is Swapper, Ownable {\n    uint256 internal constant Q64 = 2 ** 64;\n    uint256 internal constant Q96 = 2 ** 96;\n\n    uint32 public constant MIN_TWAP_SECONDS = 60; // 1 minute\n    uint32 public constant MAX_TWAP_TICK_DIFFERENCE = 200; // 2%\n\n    // admin events\n    event OperatorChanged(address newOperator, bool active);\n    event VaultChanged(address newVault, bool active);\n\n    event WithdrawerChanged(address newWithdrawer);\n    event TWAPConfigChanged(uint32 TWAPSeconds, uint16 maxTWAPTickDifference);\n\n    // configurable by owner\n    mapping(address => bool) public operators;\n    mapping(address => bool) public vaults;\n\n    address public withdrawer;\n    uint32 public TWAPSeconds;\n    uint16 public maxTWAPTickDifference;\n\n    constructor(\n        INonfungiblePositionManager npm,\n        address _operator,\n        address _withdrawer,\n        uint32 _TWAPSeconds,\n        uint16 _maxTWAPTickDifference,\n        address _zeroxRouter,\n        address _universalRouter\n    ) Swapper(npm, _zeroxRouter, _universalRouter) {\n        setOperator(_operator, true);\n        setWithdrawer(_withdrawer);\n        setTWAPConfig(_maxTWAPTickDifference, _TWAPSeconds);\n    }\n\n    /**\n     * @notice Owner controlled function to set withdrawer address\n     * @param _withdrawer withdrawer\n     */\n    function setWithdrawer(address _withdrawer) public onlyOwner {\n        emit WithdrawerChanged(_withdrawer);\n        withdrawer = _withdrawer;\n    }\n\n    /**\n     * @notice Owner controlled function to activate/deactivate operator address\n     * @param _operator operator\n     * @param _active active or not\n     */\n    function setOperator(address _operator, bool _active) public onlyOwner {\n        emit OperatorChanged(_operator, _active);\n        operators[_operator] = _active;\n    }\n\n    /**\n     * @notice Owner controlled function to activate/deactivate vault address\n     * @param _vault vault\n     * @param _active active or not\n     */\n    function setVault(address _vault, bool _active) public onlyOwner {\n        emit VaultChanged(_vault, _active);\n        vaults[_vault] = _active;\n    }\n\n    /**\n     * @notice Owner controlled function to increase TWAPSeconds / decrease maxTWAPTickDifference\n     */\n    function setTWAPConfig(uint16 _maxTWAPTickDifference, uint32 _TWAPSeconds) public onlyOwner {\n        if (_TWAPSeconds < MIN_TWAP_SECONDS) {\n            revert InvalidConfig();\n        }\n        if (_maxTWAPTickDifference > MAX_TWAP_TICK_DIFFERENCE) {\n            revert InvalidConfig();\n        }\n        emit TWAPConfigChanged(_TWAPSeconds, _maxTWAPTickDifference);\n        TWAPSeconds = _TWAPSeconds;\n        maxTWAPTickDifference = _maxTWAPTickDifference;\n    }\n\n    /**\n     * @notice Withdraws token balance (accumulated protocol fee)\n     * @param tokens Addresses of tokens to withdraw\n     * @param to Address to send to\n     */\n    function withdrawBalances(address[] calldata tokens, address to) external virtual {\n        if (msg.sender != withdrawer) {\n            revert Unauthorized();\n        }\n\n        uint256 i;\n        uint256 count = tokens.length;\n        for (; i < count; ++i) {\n            uint256 balance = IERC20(tokens[i]).balanceOf(address(this));\n            if (balance > 0) {\n                _transferToken(to, IERC20(tokens[i]), balance, true);\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraws ETH balance\n     * @param to Address to send to\n     */\n    function withdrawETH(address to) external {\n        if (msg.sender != withdrawer) {\n            revert Unauthorized();\n        }\n\n        uint256 balance = address(this).balance;\n        if (balance > 0) {\n            (bool sent,) = to.call{value: balance}(\"\");\n            if (!sent) {\n                revert EtherSendFailed();\n            }\n        }\n    }\n\n    // validate if swap can be done with specified oracle parameters - if not possible reverts\n    // if possible returns minAmountOut\n    function _validateSwap(\n        bool swap0For1,\n        uint256 amountIn,\n        IUniswapV3Pool pool,\n        uint32 twapPeriod,\n        uint16 maxTickDifference,\n        uint64 maxPriceDifferenceX64\n    ) internal view returns (uint256 amountOutMin, int24 currentTick, uint160 sqrtPriceX96, uint256 priceX96) {\n        // get current price and tick\n        (sqrtPriceX96, currentTick,,,,,) = pool.slot0();\n\n        // check if current tick not too far from TWAP\n        if (!_hasMaxTWAPTickDifference(pool, twapPeriod, currentTick, maxTickDifference)) {\n            revert TWAPCheckFailed();\n        }\n\n        // calculate min output price price and percentage\n        priceX96 = FullMath.mulDiv(sqrtPriceX96, sqrtPriceX96, Q96);\n        if (swap0For1) {\n            amountOutMin = FullMath.mulDiv(amountIn * (Q64 - maxPriceDifferenceX64), priceX96, Q96 * Q64);\n        } else {\n            amountOutMin = FullMath.mulDiv(amountIn * (Q64 - maxPriceDifferenceX64), Q96, priceX96 * Q64);\n        }\n    }\n\n    // Checks if there was not more tick difference\n    // returns false if not enough data available or tick difference >= maxDifference\n    function _hasMaxTWAPTickDifference(IUniswapV3Pool pool, uint32 twapPeriod, int24 currentTick, uint16 maxDifference)\n        internal\n        view\n        returns (bool)\n    {\n        (int24 twapTick, bool twapOk) = _getTWAPTick(pool, twapPeriod);\n        if (twapOk) {\n            return twapTick - currentTick >= -int16(maxDifference) && twapTick - currentTick <= int16(maxDifference);\n        } else {\n            return false;\n        }\n    }\n\n    // gets twap tick from pool history if enough history available\n    function _getTWAPTick(IUniswapV3Pool pool, uint32 twapPeriod) internal view returns (int24, bool) {\n        uint32[] memory secondsAgos = new uint32[](2);\n        secondsAgos[0] = 0; // from (before)\n        secondsAgos[1] = twapPeriod; // from (before)\n\n        // pool observe may fail when there is not enough history available\n        try pool.observe(secondsAgos) returns (int56[] memory tickCumulatives, uint160[] memory) {\n            return (int24((tickCumulatives[0] - tickCumulatives[1]) / int56(uint56(twapPeriod))), true);\n        } catch {\n            return (0, false);\n        }\n    }\n\n    function _decreaseFullLiquidityAndCollect(\n        uint256 tokenId,\n        uint128 liquidity,\n        uint256 amountRemoveMin0,\n        uint256 amountRemoveMin1,\n        uint256 deadline\n    ) internal returns (uint256 amount0, uint256 amount1, uint256 feeAmount0, uint256 feeAmount1) {\n        if (liquidity > 0) {\n            // store in temporarely \"misnamed\" variables - see comment below\n            (feeAmount0, feeAmount1) = nonfungiblePositionManager.decreaseLiquidity(\n                INonfungiblePositionManager.DecreaseLiquidityParams(\n                    tokenId, liquidity, amountRemoveMin0, amountRemoveMin1, deadline\n                )\n            );\n        }\n        (amount0, amount1) = nonfungiblePositionManager.collect(\n            INonfungiblePositionManager.CollectParams(tokenId, address(this), type(uint128).max, type(uint128).max)\n        );\n\n        // fee amount is what was collected additionally to liquidity amount\n        feeAmount0 = amount0 - feeAmount0;\n        feeAmount1 = amount1 - feeAmount1;\n    }\n\n    // transfers token (or unwraps WETH and sends ETH)\n    function _transferToken(address to, IERC20 token, uint256 amount, bool unwrap) internal {\n        if (address(weth) == address(token) && unwrap) {\n            weth.withdraw(amount);\n            (bool sent,) = to.call{value: amount}(\"\");\n            if (!sent) {\n                revert EtherSendFailed();\n            }\n        } else {\n            SafeERC20.safeTransfer(token, to, amount);\n        }\n    }\n\n    function _validateOwner(uint256 tokenId, address vault) internal returns (address owner) {\n        // msg.sender must not be a vault\n        if (vaults[msg.sender]) {\n            revert Unauthorized();\n        }\n\n        if (vault != address(0)) {\n            if (!vaults[vault]) {\n                revert Unauthorized();\n            }\n            owner = IVault(vault).ownerOf(tokenId);\n        } else {\n            owner = nonfungiblePositionManager.ownerOf(tokenId);\n        }\n\n        if (owner != msg.sender) {\n            revert Unauthorized();\n        }\n    }\n\n    // needed for WETH unwrapping\n    receive() external payable {\n        if (msg.sender != address(weth)) {\n            revert NotWETH();\n        }\n    }\n}"
    },
    {
      "filename": "src/automators/AutoExit.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./Automator.sol\";\n\n/// @title AutoExit\n/// @notice Lets a v3 position to be automatically removed (limit order) or swapped to the opposite token (stop loss order) when it reaches a certain tick.\n/// A revert controlled bot (operator) is responsable for the execution of optimized swaps (using external swap router)\n/// Positions need to be approved (approve or setApprovalForAll) for the contract and configured with configToken method\ncontract AutoExit is Automator {\n    event Executed(\n        uint256 indexed tokenId,\n        address account,\n        bool isSwap,\n        uint256 amountReturned0,\n        uint256 amountReturned1,\n        address token0,\n        address token1\n    );\n    event PositionConfigured(\n        uint256 indexed tokenId,\n        bool isActive,\n        bool token0Swap,\n        bool token1Swap,\n        int24 token0TriggerTick,\n        int24 token1TriggerTick,\n        uint64 token0SlippageX64,\n        uint64 token1SlippageX64,\n        bool onlyFees,\n        uint64 maxRewardX64\n    );\n\n    constructor(\n        INonfungiblePositionManager _npm,\n        address _operator,\n        address _withdrawer,\n        uint32 _TWAPSeconds,\n        uint16 _maxTWAPTickDifference,\n        address _zeroxRouter,\n        address _universalRouter\n    ) Automator(_npm, _operator, _withdrawer, _TWAPSeconds, _maxTWAPTickDifference, _zeroxRouter, _universalRouter) {}\n\n    // define how stoploss / limit should be handled\n    struct PositionConfig {\n        bool isActive; // if position is active\n        // should swap token to other token when triggered\n        bool token0Swap;\n        bool token1Swap;\n        // when should action be triggered (when this tick is reached - allow execute)\n        int24 token0TriggerTick; // when tick is below this one\n        int24 token1TriggerTick; // when tick is equal or above this one\n        // max price difference from current pool price for swap / Q64\n        uint64 token0SlippageX64; // when token 0 is swapped to token 1\n        uint64 token1SlippageX64; // when token 1 is swapped to token 0\n        bool onlyFees; // if only fees maybe used for protocol reward\n        uint64 maxRewardX64; // max allowed reward percentage of fees or full position\n    }\n\n    // configured tokens\n    mapping(uint256 => PositionConfig) public positionConfigs;\n\n    /// @notice params for execute()\n    struct ExecuteParams {\n        uint256 tokenId; // tokenid to process\n        bytes swapData; // if its a swap order - must include swap data\n        uint128 liquidity; // liquidity the calculations are based on\n        uint256 amountRemoveMin0; // min amount to be removed from liquidity\n        uint256 amountRemoveMin1; // min amount to be removed from liquidity\n        uint256 deadline; // for uniswap operations - operator promises fair value\n        uint64 rewardX64; // which reward will be used for protocol, can be max configured amount (considering onlyFees)\n    }\n\n    struct ExecuteState {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint128 liquidity;\n        uint256 amount0;\n        uint256 amount1;\n        uint256 feeAmount0;\n        uint256 feeAmount1;\n        uint256 amountOutMin;\n        uint256 amountInDelta;\n        uint256 amountOutDelta;\n        IUniswapV3Pool pool;\n        uint256 swapAmount;\n        int24 tick;\n        bool isSwap;\n        bool isAbove;\n        address owner;\n    }\n\n    /**\n     * @notice Handle token (must be in correct state)\n     * Can only be called only from configured operator account\n     * Swap needs to be done with max price difference from current pool price - otherwise reverts\n     */\n    function execute(ExecuteParams calldata params) external {\n        if (!operators[msg.sender]) {\n            revert Unauthorized();\n        }\n\n        ExecuteState memory state;\n        PositionConfig memory config = positionConfigs[params.tokenId];\n\n        if (!config.isActive) {\n            revert NotConfigured();\n        }\n\n        if (\n            config.onlyFees && params.rewardX64 > config.maxRewardX64\n                || !config.onlyFees && params.rewardX64 > config.maxRewardX64\n        ) {\n            revert ExceedsMaxReward();\n        }\n\n        // get position info\n        (,, state.token0, state.token1, state.fee, state.tickLower, state.tickUpper, state.liquidity,,,,) =\n            nonfungiblePositionManager.positions(params.tokenId);\n\n        // so can be executed only once\n        if (state.liquidity == 0) {\n            revert NoLiquidity();\n        }\n        if (state.liquidity != params.liquidity) {\n            revert LiquidityChanged();\n        }\n\n        state.pool = _getPool(state.token0, state.token1, state.fee);\n        (, state.tick,,,,,) = state.pool.slot0();\n\n        // not triggered\n        if (config.token0TriggerTick <= state.tick && state.tick < config.token1TriggerTick) {\n            revert NotReady();\n        }\n\n        state.isAbove = state.tick >= config.token1TriggerTick;\n        state.isSwap = !state.isAbove && config.token0Swap || state.isAbove && config.token1Swap;\n\n        // decrease full liquidity for given position - and return fees as well\n        (state.amount0, state.amount1, state.feeAmount0, state.feeAmount1) = _decreaseFullLiquidityAndCollect(\n            params.tokenId, state.liquidity, params.amountRemoveMin0, params.amountRemoveMin1, params.deadline\n        );\n\n        // swap to other token\n        if (state.isSwap) {\n            if (params.swapData.length == 0) {\n                revert MissingSwapData();\n            }\n\n            // reward is taken before swap - if from fees only\n            if (config.onlyFees) {\n                state.amount0 -= state.feeAmount0 * params.rewardX64 / Q64;\n                state.amount1 -= state.feeAmount1 * params.rewardX64 / Q64;\n            }\n\n            state.swapAmount = state.isAbove ? state.amount1 : state.amount0;\n\n            // checks if price in valid oracle range and calculates amountOutMin\n            (state.amountOutMin,,,) = _validateSwap(\n                !state.isAbove,\n                state.swapAmount,\n                state.pool,\n                TWAPSeconds,\n                maxTWAPTickDifference,\n                state.isAbove ? config.token1SlippageX64 : config.token0SlippageX64\n            );\n\n            (state.amountInDelta, state.amountOutDelta) = _routerSwap(\n                Swapper.RouterSwapParams(\n                    state.isAbove ? IERC20(state.token1) : IERC20(state.token0),\n                    state.isAbove ? IERC20(state.token0) : IERC20(state.token1),\n                    state.swapAmount,\n                    state.amountOutMin,\n                    params.swapData\n                )\n            );\n\n            state.amount0 = state.isAbove ? state.amount0 + state.amountOutDelta : state.amount0 - state.amountInDelta;\n            state.amount1 = state.isAbove ? state.amount1 - state.amountInDelta : state.amount1 + state.amountOutDelta;\n\n            // when swap and !onlyFees - protocol reward is removed only from target token (to incentivize optimal swap done by operator)\n            if (!config.onlyFees) {\n                if (state.isAbove) {\n                    state.amount0 -= state.amount0 * params.rewardX64 / Q64;\n                } else {\n                    state.amount1 -= state.amount1 * params.rewardX64 / Q64;\n                }\n            }\n        } else {\n            // reward is taken as configured\n            state.amount0 -= (config.onlyFees ? state.feeAmount0 : state.amount0) * params.rewardX64 / Q64;\n            state.amount1 -= (config.onlyFees ? state.feeAmount1 : state.amount1) * params.rewardX64 / Q64;\n        }\n\n        state.owner = nonfungiblePositionManager.ownerOf(params.tokenId);\n        if (state.amount0 > 0) {\n            _transferToken(state.owner, IERC20(state.token0), state.amount0, true);\n        }\n        if (state.amount1 > 0) {\n            _transferToken(state.owner, IERC20(state.token1), state.amount1, true);\n        }\n\n        // delete config for position\n        delete positionConfigs[params.tokenId];\n        emit PositionConfigured(params.tokenId, false, false, false, 0, 0, 0, 0, false, 0);\n\n        // log event\n        emit Executed(\n            params.tokenId, msg.sender, state.isSwap, state.amount0, state.amount1, state.token0, state.token1\n        );\n    }\n\n    // function to configure a token to be used with this runner\n    // it needs to have approvals set for this contract beforehand\n    function configToken(uint256 tokenId, PositionConfig calldata config) external {\n        address owner = nonfungiblePositionManager.ownerOf(tokenId);\n        if (owner != msg.sender) {\n            revert Unauthorized();\n        }\n\n        if (config.isActive) {\n            if (config.token0TriggerTick >= config.token1TriggerTick) {\n                revert InvalidConfig();\n            }\n        }\n\n        positionConfigs[tokenId] = config;\n\n        emit PositionConfigured(\n            tokenId,\n            config.isActive,\n            config.token0Swap,\n            config.token1Swap,\n            config.token0TriggerTick,\n            config.token1TriggerTick,\n            config.token0SlippageX64,\n            config.token1SlippageX64,\n            config.onlyFees,\n            config.maxRewardX64\n        );\n    }\n}"
    },
    {
      "filename": "src/transformers/AutoRange.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../automators/Automator.sol\";\n\n/// @title AutoRange\n/// @notice Allows operator of AutoRange contract (Revert controlled bot) to change range for configured positions\n/// Positions need to be approved (setApprovalForAll) for the contract and configured with configToken method\n/// When executed a new position is created and automatically configured the same way as the original position\n/// When position is inside Vault - transform is called\ncontract AutoRange is Automator {\n    event RangeChanged(uint256 indexed oldTokenId, uint256 indexed newTokenId);\n    event PositionConfigured(\n        uint256 indexed tokenId,\n        int32 lowerTickLimit,\n        int32 upperTickLimit,\n        int32 lowerTickDelta,\n        int32 upperTickDelta,\n        uint64 token0SlippageX64,\n        uint64 token1SlippageX64,\n        bool onlyFees,\n        uint64 maxRewardX64\n    );\n\n    constructor(\n        INonfungiblePositionManager _npm,\n        address _operator,\n        address _withdrawer,\n        uint32 _TWAPSeconds,\n        uint16 _maxTWAPTickDifference,\n        address _zeroxRouter,\n        address _universalRouter\n    ) Automator(_npm, _operator, _withdrawer, _TWAPSeconds, _maxTWAPTickDifference, _zeroxRouter, _universalRouter) {}\n\n    // defines when and how a position can be changed by operator\n    // when a position is adjusted config for the position is cleared and copied to the newly created position\n    struct PositionConfig {\n        // needs more than int24 because it can be [-type(uint24).max,type(uint24).max]\n        int32 lowerTickLimit; // if negative also in-range positions may be adjusted / if 0 out of range positions may be adjusted\n        int32 upperTickLimit; // if negative also in-range positions may be adjusted / if 0 out of range positions may be adjusted\n        int32 lowerTickDelta; // this amount is added to current tick (floored to tickspacing) to define lowerTick of new position\n        int32 upperTickDelta; // this amount is added to current tick (floored to tickspacing) to define upperTick of new position\n        uint64 token0SlippageX64; // max price difference from current pool price for swap / Q64 for token0\n        uint64 token1SlippageX64; // max price difference from current pool price for swap / Q64 for token1\n        bool onlyFees; // if only fees maybe used for protocol reward\n        uint64 maxRewardX64; // max allowed reward percentage of fees or full position\n    }\n\n    // configured tokens\n    mapping(uint256 => PositionConfig) public positionConfigs;\n\n    /// @notice params for execute()\n    struct ExecuteParams {\n        uint256 tokenId;\n        bool swap0To1;\n        uint256 amountIn; // if this is set to 0 no swap happens\n        bytes swapData;\n        uint128 liquidity; // liquidity the calculations are based on\n        uint256 amountRemoveMin0; // min amount to be removed from liquidity\n        uint256 amountRemoveMin1; // min amount to be removed from liquidity\n        uint256 deadline; // for uniswap operations - operator promises fair value\n        uint64 rewardX64; // which reward will be used for protocol, can be max configured amount (considering onlyFees)\n    }\n\n    struct ExecuteState {\n        address owner;\n        address realOwner;\n        IUniswapV3Pool pool;\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        int24 currentTick;\n        uint256 amount0;\n        uint256 amount1;\n        uint256 feeAmount0;\n        uint256 feeAmount1;\n        uint256 maxAddAmount0;\n        uint256 maxAddAmount1;\n        uint256 amountAdded0;\n        uint256 amountAdded1;\n        uint128 liquidity;\n        uint256 protocolReward0;\n        uint256 protocolReward1;\n        uint256 amountOutMin;\n        uint256 amountInDelta;\n        uint256 amountOutDelta;\n        uint256 newTokenId;\n    }\n\n    /**\n     * @notice Adjust token (which is in a Vault) - via transform method\n     * Can only be called from configured operator account - vault must be configured as well\n     * Swap needs to be done with max price difference from current pool price - otherwise reverts\n     */\n    function executeWithVault(ExecuteParams calldata params, address vault) external {\n        if (!operators[msg.sender] || !vaults[vault]) {\n            revert Unauthorized();\n        }\n        IVault(vault).transform(\n            params.tokenId, address(this), abi.encodeWithSelector(AutoRange.execute.selector, params)\n        );\n    }\n\n    /**\n     * @notice Adjust token directly (must be in correct state)\n     * Can only be called only from configured operator account, or vault via transform\n     * Swap needs to be done with max price difference from current pool price - otherwise reverts\n     */\n    function execute(ExecuteParams calldata params) external {\n        if (!operators[msg.sender] && !vaults[msg.sender]) {\n            revert Unauthorized();\n        }\n        ExecuteState memory state;\n        PositionConfig memory config = positionConfigs[params.tokenId];\n\n        if (config.lowerTickDelta == config.upperTickDelta) {\n            revert NotConfigured();\n        }\n\n        if (\n            config.onlyFees && params.rewardX64 > config.maxRewardX64\n                || !config.onlyFees && params.rewardX64 > config.maxRewardX64\n        ) {\n            revert ExceedsMaxReward();\n        }\n\n        // get position info\n        (,, state.token0, state.token1, state.fee, state.tickLower, state.tickUpper, state.liquidity,,,,) =\n            nonfungiblePositionManager.positions(params.tokenId);\n\n        if (state.liquidity != params.liquidity) {\n            revert LiquidityChanged();\n        }\n\n        (state.amount0, state.amount1, state.feeAmount0, state.feeAmount1) = _decreaseFullLiquidityAndCollect(\n            params.tokenId, state.liquidity, params.amountRemoveMin0, params.amountRemoveMin1, params.deadline\n        );\n\n        // if only fees reward is removed before adding\n        if (config.onlyFees) {\n            state.protocolReward0 = state.feeAmount0 * params.rewardX64 / Q64;\n            state.protocolReward1 = state.feeAmount1 * params.rewardX64 / Q64;\n            state.amount0 -= state.protocolReward0;\n            state.amount1 -= state.protocolReward1;\n        }\n\n        if (params.swap0To1 && params.amountIn > state.amount0 || !params.swap0To1 && params.amountIn > state.amount1) {\n            revert SwapAmountTooLarge();\n        }\n\n        // get pool info\n        state.pool = _getPool(state.token0, state.token1, state.fee);\n\n        // check oracle for swap\n        (state.amountOutMin, state.currentTick,,) = _validateSwap(\n            params.swap0To1,\n            params.amountIn,\n            state.pool,\n            TWAPSeconds,\n            maxTWAPTickDifference,\n            params.swap0To1 ? config.token0SlippageX64 : config.token1SlippageX64\n        );\n\n        if (\n            state.currentTick < state.tickLower - config.lowerTickLimit\n                || state.currentTick >= state.tickUpper + config.upperTickLimit\n        ) {\n            int24 tickSpacing = _getTickSpacing(state.fee);\n            int24 baseTick = state.currentTick - (((state.currentTick % tickSpacing) + tickSpacing) % tickSpacing);\n\n            // check if new range same as old range\n            if (\n                baseTick + config.lowerTickDelta == state.tickLower\n                    && baseTick + config.upperTickDelta == state.tickUpper\n            ) {\n                revert SameRange();\n            }\n\n            (state.amountInDelta, state.amountOutDelta) = _routerSwap(\n                Swapper.RouterSwapParams(\n                    params.swap0To1 ? IERC20(state.token0) : IERC20(state.token1),\n                    params.swap0To1 ? IERC20(state.token1) : IERC20(state.token0),\n                    params.amountIn,\n                    state.amountOutMin,\n                    params.swapData\n                )\n            );\n\n            state.amount0 = params.swap0To1 ? state.amount0 - state.amountInDelta : state.amount0 + state.amountOutDelta;\n            state.amount1 = params.swap0To1 ? state.amount1 + state.amountOutDelta : state.amount1 - state.amountInDelta;\n\n            // max amount to add - removing max potential fees (if config.onlyFees - the have been removed already)\n            state.maxAddAmount0 = config.onlyFees ? state.amount0 : state.amount0 * Q64 / (params.rewardX64 + Q64);\n            state.maxAddAmount1 = config.onlyFees ? state.amount1 : state.amount1 * Q64 / (params.rewardX64 + Q64);\n\n            INonfungiblePositionManager.MintParams memory mintParams = INonfungiblePositionManager.MintParams(\n                address(state.token0),\n                address(state.token1),\n                state.fee,\n                SafeCast.toInt24(baseTick + config.lowerTickDelta), // reverts if out of valid range\n                SafeCast.toInt24(baseTick + config.upperTickDelta), // reverts if out of valid range\n                state.maxAddAmount0,\n                state.maxAddAmount1,\n                0,\n                0,\n                address(this), // is sent to real recipient aftwards\n                params.deadline\n            );\n\n            // approve npm\n            SafeERC20.safeApprove(IERC20(state.token0), address(nonfungiblePositionManager), state.maxAddAmount0);\n            SafeERC20.safeApprove(IERC20(state.token1), address(nonfungiblePositionManager), state.maxAddAmount1);\n\n            // mint is done to address(this) first - its not a safemint\n            (state.newTokenId,, state.amountAdded0, state.amountAdded1) = nonfungiblePositionManager.mint(mintParams);\n\n            // remove remaining approval\n            SafeERC20.safeApprove(IERC20(state.token0), address(nonfungiblePositionManager), 0);\n            SafeERC20.safeApprove(IERC20(state.token1), address(nonfungiblePositionManager), 0);\n\n            state.owner = nonfungiblePositionManager.ownerOf(params.tokenId);\n\n            // get the real owner - if owner is vault - for sending leftover tokens\n            state.realOwner = state.owner;\n            if (vaults[state.owner]) {\n                state.realOwner = IVault(state.owner).ownerOf(params.tokenId);\n            }\n\n            // send the new nft to the owner / vault\n            nonfungiblePositionManager.safeTransferFrom(address(this), state.owner, state.newTokenId);\n\n            // protocol reward is calculated based on added amount (to incentivize optimal swap done by operator)\n            if (!config.onlyFees) {\n                state.protocolReward0 = state.amountAdded0 * params.rewardX64 / Q64;\n                state.protocolReward1 = state.amountAdded1 * params.rewardX64 / Q64;\n                state.amount0 -= state.protocolReward0;\n                state.amount1 -= state.protocolReward1;\n            }\n\n            // send leftover to real owner\n            if (state.amount0 - state.amountAdded0 > 0) {\n                _transferToken(state.realOwner, IERC20(state.token0), state.amount0 - state.amountAdded0, true);\n            }\n            if (state.amount1 - state.amountAdded1 > 0) {\n                _transferToken(state.realOwner, IERC20(state.token1), state.amount1 - state.amountAdded1, true);\n            }\n\n            // copy token config for new token\n            positionConfigs[state.newTokenId] = config;\n            emit PositionConfigured(\n                state.newTokenId,\n                config.lowerTickLimit,\n                config.upperTickLimit,\n                config.lowerTickDelta,\n                config.upperTickDelta,\n                config.token0SlippageX64,\n                config.token1SlippageX64,\n                config.onlyFees,\n                config.maxRewardX64\n            );\n\n            // delete config for old position\n            delete positionConfigs[params.tokenId];\n            emit PositionConfigured(params.tokenId, 0, 0, 0, 0, 0, 0, false, 0);\n\n            emit RangeChanged(params.tokenId, state.newTokenId);\n        } else {\n            revert NotReady();\n        }\n    }\n\n    // function to configure a token to be used with this runner\n    // it needs to have approvals set for this contract beforehand\n    function configToken(uint256 tokenId, address vault, PositionConfig calldata config) external {\n        _validateOwner(tokenId, vault);\n\n        // lower tick must be always below or equal to upper tick - if they are equal - range adjustment is deactivated\n        if (config.lowerTickDelta > config.upperTickDelta) {\n            revert InvalidConfig();\n        }\n\n        positionConfigs[tokenId] = config;\n\n        emit PositionConfigured(\n            tokenId,\n            config.lowerTickLimit,\n            config.upperTickLimit,\n            config.lowerTickDelta,\n            config.upperTickDelta,\n            config.token0SlippageX64,\n            config.token1SlippageX64,\n            config.onlyFees,\n            config.maxRewardX64\n        );\n    }\n\n    // get tick spacing for fee tier (cached when possible)\n    function _getTickSpacing(uint24 fee) internal view returns (int24) {\n        if (fee == 10000) {\n            return 200;\n        } else if (fee == 3000) {\n            return 60;\n        } else if (fee == 500) {\n            return 10;\n        } else {\n            int24 spacing = IUniswapV3Factory(factory).feeAmountTickSpacing(fee);\n            if (spacing <= 0) {\n                revert NotSupportedFeeTier();\n            }\n            return spacing;\n        }\n    }\n}"
    }
  ]
}