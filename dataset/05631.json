{
  "Title": "[M-04] Module transactions will always fail because incompatible with Safe 1.5.0",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/SafeModerator.sol#L80-L86><br>\n<https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/SafeModeratorOverridable.sol#L86-L92>\n\n### Impact\n\nGnosisSafe has concept of module. Trusted modules of GnosisSafe contract can execute arbitrary transactions without signatures once enabled. That's the main purpose of protocol: to allow the execution of some defined action (like swap on DEX) without signatures via registering such an action in Policy commitment. Then, execute this action via Executor or Main Account without need of delegatee's signatures, and also allow one to register SubAccounts and manage them via Main Account.\n\nTherefore, ExecutorPlugin and Main Account are enabled as modules. The main problem is that all transactions executed via module will fail, meaning SubAccount is just another GnosisSafe without additional utility. When assessing the severity, I took into consideration protocol specific: protocol is about adding new functionality.\n\n> Users also have access to SafeSub-accounts that reduce their risk from the protocol by isolating their interactions.\n\nBut core functionality of protocol regarding ExecutorPlugin and SubAccounts doesn't work. Due to this reasoning I submit it as High, despite there is no financial loss.\n\n### Proof of Concept\n\nLet's take a look on how tx from module is executed:\n\nFirst, `guard.checkModuleTransaction()` is called, which returns `bytes32 guardHash`, and then transaction is executed:\n\n<https://github.com/safe-global/safe-contracts/blob/810fad9a074837e1247ca24ac9e7f77a5dffce19/contracts/base/ModuleManager.sol#L82-L104>\n\n```solidity\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public virtual returns (bool success) {\n        // Only whitelisted modules are allowed.\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"GS104\");\n        // Execute transaction without further confirmations.\n        address guard = getGuard();\n\n        bytes32 guardHash;\n        if (guard != address(0)) {\n@>          guardHash = Guard(guard).checkModuleTransaction(to, value, data, operation, msg.sender);\n        }\n        success = execute(to, value, data, operation, type(uint256).max);\n\n        if (guard != address(0)) {\n            Guard(guard).checkAfterExecution(guardHash, success);\n        }\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\n        else emit ExecutionFromModuleFailure(msg.sender);\n    }\n```\n\nIn context of Brahma, Guard contract is SafeModerator or SafeModeratorOverridable. They implement the incorrect interface IGuard, so the function `checkModuleTransaction()` returns nothing.\n\n<https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/interfaces/external/IGnosisSafe.sol#L110-L116>\n\n```solidity\n    function checkModuleTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        address module\n    ) external;\n```\n\nHere is PoC in Remix to ensure that function reverts when trying to decode output while the function doesn't return anything:\n\n```solidity\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface WithoutReturn {\n      function checkModuleTransaction() external;\n}\n\ninterface WithReturn {\n      function checkModuleTransaction() external returns(bytes32);\n}\n\ncontract Test {\n\n  function test() external returns(bytes32) {\n\n    address calledContract = address(new ContractWithoutReturn());\n\n    // Reverts on decoding\n    bytes32 result = WithReturn(calledContract).checkModuleTransaction();\n    return result;\n  }\n}\n\ncontract ContractWithoutReturn is WithoutReturn {\n\n  function checkModuleTransaction() external {}\n\n}\n```\n\nAs a result, the function `GnosisSafe.execTransactionFromModule()` will always revert.\n\n### Tools Used\n\nRemix\n\n### Recommended Mitigation Steps\n\nUpdate interface IGuard:\n\n```diff\n    function checkModuleTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        address module\n-   ) external;\n+   ) external returns(bytes32);\n```\n\n### Note:\n\nThe protocol is meant to use 1.5.0; the feature with `callback to guard in module transactions` was introduced in 1.5.0 recently. I also advise to add tests for different safe Versions; [now only 1.3.0 is used in tests](https://github.com/code-423n4/2023-10-brahma/blob/a6424230052fc47c4215200c19a8eef9b07dfccc/contracts/script/utils/ConstantSetup.s.sol#L20)\n\nThe sponsor said they took interface from [this PR](https://github.com/safe-global/safe-contracts/pull/571) because GnosisSafe 1.5.0. is still in development. In further discussion, [they noted mistake in the interface](https://github.com/safe-global/safe-contracts/pull/571#discussion_r1261472211).\n\n### Assessed type\n\nError\n\n**[0xad1onchain (Brahma) commented](https://github.com/code-423n4/2023-10-brahma-findings/issues/16#issuecomment-1773413233):**\n > Protocol is clearly marked to use safe `1.3.0` and has been mentioned in codebase natspac, tests and clarified multiple times on discord chat.\n\n**[0xad1onchain (Brahma) confirmed and commented](https://github.com/code-423n4/2023-10-brahma-findings/issues/16#issuecomment-1779473806):**\n > Valid, thanks for informing us about this issue. Safe `1.5.0` is still a PR and their specifications keep changing. We will remove support for it until it's released.\n\n**[0xsomeone (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-10-brahma-findings/issues/16#issuecomment-1783086712):**\n > The Sponsor initially maintained that Gnosis Safe v1.5.0 is of no concern, however, the documentation of the `SafeModerator::checkModuleTransaction` / `SafeModeratorOverridable::checkModuleTransaction` clearly states that it has been introduced to facilitate support for v1.5.0.\n> \n> However, as the Sponsor has clearly specified, version 1.5.0 of Gnosis Safe is actively undergoing changes meaning that the `interface` (although highly unlikely) is subject to change; rendering no course of action as *correct* except for simply marking that `1.5.0` is not supported until proper support for it has been introduced.\n> \n> I think the confusion arises from the fact that the various modules of Brahma (i.e. `SafeModerator`) are meant to be compatible with more versions than the one actually in use by the `SubAccount` systems etc., given that they represent Gnosis Safe modules that can be attached to any instance, further evidenced by the ability to register any wallet in the `WalletRegistry`.\n> \n> As the main version the system supports is `1.3.0`, which is fully compatible with the present code, I am inclined to judge this exhibit as a \"Medium\" rather than a \"High\". To note, the `bytes32` return value was introduced in Gnosis Safe versions `1.4.0` and up, meaning that the exhibit is applicable to a version that has been released and not only to unreleased versions. In general, the bug will manifest when the module is introduced **outside the scope of the repository** to a Gnosis Safe with a version of `1.4.0>=`.\n> \n> The Sponsor should either:\n> - Incorporate the return function signature change in their system to support Gnosis Safes `1.4.0>=` and potentially `1.5.0`.\n> - Mark versions `1.4.0` and `1.4.1` **in addition to `1.5.0`** as not supported by the system.\n\n**[0xad1onchain (Brahma) commented](https://github.com/code-423n4/2023-10-brahma-findings/issues/16#issuecomment-1817756811):**\n> Fixed, removed support for safe wallet `v1.5.0`.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-brahma",
  "Code": [
    {
      "filename": "contracts/src/core/SafeModerator.sol",
      "content": "/// SPDX-License-Identifier: BUSL-1.1\n\n/// Copyright (C) 2023 Brahma.fi\n\npragma solidity 0.8.19;\n\nimport {IGuard, Enum} from \"interfaces/external/IGnosisSafe.sol\";\nimport {AddressProviderService} from \"src/core/AddressProviderService.sol\";\nimport {TransactionValidator} from \"src/core/TransactionValidator.sol\";\n\n/**\n * @title SafeModerator\n * @author Brahma.fi\n * @notice A guard that validates transactions and allows only policy abiding txns, on Brahma console account\n */\ncontract SafeModerator is AddressProviderService, IGuard {\n    constructor(address _addressProvider) AddressProviderService(_addressProvider) {}\n\n    /**\n     * @notice Inherited from IGuard, function is called before executing a Safe transaction during execTransaction\n     * @param to target address\n     * @param value txn value\n     * @param data txn callData\n     * @param operation type of operation\n     * @param safeTxGas gas that should be used for safe txn\n     * @param baseGas gas cost independent of txn cost\n     * @param gasPrice gas price in current block\n     * @param gasToken address of token used for gas\n     * @param refundReceiver address of receiver of gas payment\n     * @param signatures user signatures appended with validation signature\n     * @param msgSender address of msg.sender of original txn\n     */\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        address msgSender\n    ) external view override {\n        TransactionValidator(AddressProviderService._getAuthorizedAddress(_TRANSACTION_VALIDATOR_HASH))\n            .validatePreTransaction(\n            TransactionValidator.SafeTransactionParams({\n                from: msg.sender,\n                to: to,\n                value: value,\n                data: data,\n                operation: operation,\n                safeTxGas: safeTxGas,\n                baseGas: baseGas,\n                gasPrice: gasPrice,\n                gasToken: gasToken,\n                refundReceiver: refundReceiver,\n                signatures: signatures,\n                msgSender: msgSender\n            })\n        );\n    }\n\n    /**\n     * @notice Inherited from IGuard, function is called after executing a Safe transaction during execTransaction\n     * @param txHash tx hash, computed from transaction\n     * @param success boolean indicating success\n     */\n    function checkAfterExecution(bytes32 txHash, bool success) external view override {\n        TransactionValidator(AddressProviderService._getAuthorizedAddress(_TRANSACTION_VALIDATOR_HASH))\n            .validatePostTransaction(txHash, success, msg.sender);\n    }\n\n    /**\n     * @notice Inherited from IGuard, function is called after executing a Safe transaction during execTransactionViaModule\n     * @dev No op-check. Provides compatibility with Safe 1.5 guard over module\n     */\n    /* solhint-disable no-empty-blocks */\n    function checkModuleTransaction(\n        address, /* to */\n        uint256, /* value */\n        bytes memory, /* data */\n        Enum.Operation, /* operation */\n        address /* module */\n    ) external override {}\n    /* solhint-enable no-empty-blocks */\n}"
    },
    {
      "filename": "contracts/src/core/SafeModeratorOverridable.sol",
      "content": "/// SPDX-License-Identifier: BUSL-1.1\n\n/// Copyright (C) 2023 Brahma.fi\n\npragma solidity 0.8.19;\n\nimport {IGuard, Enum} from \"interfaces/external/IGnosisSafe.sol\";\nimport {AddressProviderService} from \"src/core/AddressProviderService.sol\";\nimport {TransactionValidator} from \"src/core/TransactionValidator.sol\";\n\n/**\n * @title SafeModeratorOverridable\n * @author Brahma.fi\n * @notice A guard that validates transactions and allows only policy abiding txns, on Brhma console account and can be overriden by removal of guard\n */\ncontract SafeModeratorOverridable is AddressProviderService, IGuard {\n    /**\n     * @dev Token interface change used to bypass foundry coverage issue\n     * Refer https://github.com/foundry-rs/foundry/issues/5729\n     */\n    uint8 public constant DIFFER_SAFE_MOD = 0;\n\n    constructor(address _addressProvider) AddressProviderService(_addressProvider) {}\n\n    /**\n     * @notice Inherited from IGuard, function is called before executing a Safe transaction during execTransaction\n     * @param to target address\n     * @param value txn value\n     * @param data txn callData\n     * @param operation type of operation\n     * @param safeTxGas gas that should be used for safe txn\n     * @param baseGas gas cost independent of txn cost\n     * @param gasPrice gas price in current block\n     * @param gasToken address of token used for gas\n     * @param refundReceiver address of receiver of gas payment\n     * @param signatures user signatures appended with validation signature\n     * @param msgSender address of msg.sender of original txn\n     */\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        address msgSender\n    ) external view override {\n        TransactionValidator(AddressProviderService._getAuthorizedAddress(_TRANSACTION_VALIDATOR_HASH))\n            .validatePreTransactionOverridable(\n            TransactionValidator.SafeTransactionParams({\n                from: msg.sender,\n                to: to,\n                value: value,\n                data: data,\n                operation: operation,\n                safeTxGas: safeTxGas,\n                baseGas: baseGas,\n                gasPrice: gasPrice,\n                gasToken: gasToken,\n                refundReceiver: refundReceiver,\n                signatures: signatures,\n                msgSender: msgSender\n            })\n        );\n    }\n\n    /**\n     * @notice Inherited from IGuard, function is called after executing a Safe transaction during execTransaction\n     * @param txHash tx hash, computed from transaction\n     * @param success boolean indicating success/failure of above transaction\n     */\n    function checkAfterExecution(bytes32 txHash, bool success) external view override {\n        TransactionValidator(AddressProviderService._getAuthorizedAddress(_TRANSACTION_VALIDATOR_HASH))\n            .validatePostTransactionOverridable(txHash, success, msg.sender);\n    }\n\n    /**\n     * @notice Inherited from IGuard, function is called after executing a Safe transaction during execTransactionViaModule\n     * @dev No op-check. Provides compatibility with Safe 1.5 guard over module\n     */\n    /* solhint-disable no-empty-blocks */\n    function checkModuleTransaction(\n        address, /* to */\n        uint256, /* value */\n        bytes memory, /* data */\n        Enum.Operation, /* operation */\n        address /* module */\n    ) external override {}\n    /* solhint-enable no-empty-blocks */\n}"
    },
    {
      "filename": "contracts/base/ModuleManager.sol",
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport {Enum} from \"../common/Enum.sol\";\nimport {SelfAuthorized} from \"../common/SelfAuthorized.sol\";\nimport {Executor} from \"./Executor.sol\";\nimport {GuardManager, Guard} from \"./GuardManager.sol\";\n\n/**\n * @title Module Manager - A contract managing Safe modules\n * @notice Modules are extensions with unlimited access to a Safe that can be added to a Safe by its owners.\n           ⚠️ WARNING: Modules are a security risk since they can execute arbitrary transactions, \n           so only trusted and audited modules should be added to a Safe. A malicious module can\n           completely takeover a Safe.\n * @author Stefan George - @Georgi87\n * @author Richard Meissner - @rmeissner\n */\nabstract contract ModuleManager is SelfAuthorized, Executor, GuardManager {\n    event EnabledModule(address indexed module);\n    event DisabledModule(address indexed module);\n    event ExecutionFromModuleSuccess(address indexed module);\n    event ExecutionFromModuleFailure(address indexed module);\n\n    address internal constant SENTINEL_MODULES = address(0x1);\n\n    mapping(address => address) internal modules;\n\n    /**\n     * @notice Setup function sets the initial storage of the contract.\n     *         Optionally executes a delegate call to another contract to setup the modules.\n     * @param to Optional destination address of call to execute.\n     * @param data Optional data of call to execute.\n     */\n    function setupModules(address to, bytes memory data) internal {\n        require(modules[SENTINEL_MODULES] == address(0), \"GS100\");\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n        if (to != address(0)) {\n            require(isContract(to), \"GS002\");\n            // Setup has to complete successfully or transaction fails.\n            require(execute(to, 0, data, Enum.Operation.DelegateCall, type(uint256).max), \"GS000\");\n        }\n    }\n\n    /**\n     * @notice Enables the module `module` for the Safe.\n     * @dev This can only be done via a Safe transaction.\n     * @param module Module to be whitelisted.\n     */\n    function enableModule(address module) public authorized {\n        // Module address cannot be null or sentinel.\n        require(module != address(0) && module != SENTINEL_MODULES, \"GS101\");\n        // Module cannot be added twice.\n        require(modules[module] == address(0), \"GS102\");\n        modules[module] = modules[SENTINEL_MODULES];\n        modules[SENTINEL_MODULES] = module;\n        emit EnabledModule(module);\n    }\n\n    /**\n     * @notice Disables the module `module` for the Safe.\n     * @dev This can only be done via a Safe transaction.\n     * @param prevModule Previous module in the modules linked list.\n     * @param module Module to be removed.\n     */\n    function disableModule(address prevModule, address module) public authorized {\n        // Validate module address and check that it corresponds to module index.\n        require(module != address(0) && module != SENTINEL_MODULES, \"GS101\");\n        require(modules[prevModule] == module, \"GS103\");\n        modules[prevModule] = modules[module];\n        modules[module] = address(0);\n        emit DisabledModule(module);\n    }\n\n    /**\n     * @notice Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token)\n     * @dev Function is virtual to allow overriding for L2 singleton to emit an event for indexing.\n     * @param to Destination address of module transaction.\n     * @param value Ether value of module transaction.\n     * @param data Data payload of module transaction.\n     * @param operation Operation type of module transaction.\n     * @return success Boolean flag indicating if the call succeeded.\n     */\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public virtual returns (bool success) {\n        // Only whitelisted modules are allowed.\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"GS104\");\n        // Execute transaction without further confirmations.\n        address guard = getGuard();\n\n        bytes32 guardHash;\n        if (guard != address(0)) {\n            guardHash = Guard(guard).checkModuleTransaction(to, value, data, operation, msg.sender);\n        }\n        success = execute(to, value, data, operation, type(uint256).max);\n\n        if (guard != address(0)) {\n            Guard(guard).checkAfterExecution(guardHash, success);\n        }\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\n        else emit ExecutionFromModuleFailure(msg.sender);\n    }\n\n    /**\n     * @notice Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token) and return data\n     * @param to Destination address of module transaction.\n     * @param value Ether value of module transaction.\n     * @param data Data payload of module transaction.\n     * @param operation Operation type of module transaction.\n     * @return success Boolean flag indicating if the call succeeded.\n     * @return returnData Data returned by the call.\n     */\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public returns (bool success, bytes memory returnData) {\n        success = execTransactionFromModule(to, value, data, operation);\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Load free memory location\n            let ptr := mload(0x40)\n            // We allocate memory for the return data by setting the free memory location to\n            // current free memory location + data size + 32 bytes for data size value\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\n            // Store the size\n            mstore(ptr, returndatasize())\n            // Store the data\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\n            // Point the return data to the correct memory location\n            returnData := ptr\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n\n    /**\n     * @notice Returns if an module is enabled\n     * @return True if the module is enabled\n     */\n    function isModuleEnabled(address module) public view returns (bool) {\n        return SENTINEL_MODULES != module && modules[module] != address(0);\n    }\n\n    /**\n     * @notice Returns an array of modules.\n     *         If all entries fit into a single page, the next pointer will be 0x1.\n     *         If another page is present, next will be the last element of the returned array.\n     * @param start Start of the page. Has to be a module or start pointer (0x1 address)\n     * @param pageSize Maximum number of modules that should be returned. Has to be > 0\n     * @return array Array of modules.\n     * @return next Start of the next page.\n     */\n    function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory array, address next) {\n        require(start == SENTINEL_MODULES || isModuleEnabled(start), \"GS105\");\n        require(pageSize > 0, \"GS106\");\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 moduleCount = 0;\n        next = modules[start];\n        while (next != address(0) && next != SENTINEL_MODULES && moduleCount < pageSize) {\n            array[moduleCount] = next;\n            next = modules[next];\n            moduleCount++;\n        }\n\n        /**\n          Because of the argument validation, we can assume that the loop will always iterate over the valid module list values\n          and the `next` variable will either be an enabled module or a sentinel address (signalling the end). \n          \n          If we haven't reached the end inside the loop, we need to set the next pointer to the last element of the modules array\n          because the `next` variable (which is a module by itself) acting as a pointer to the start of the next page is neither \n          included to the current page, nor will it be included in the next one if you pass it as a start.\n        */\n        if (next != SENTINEL_MODULES) {\n            next = array[moduleCount - 1];\n        }\n        // Set correct size of returned array\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(array, moduleCount)\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n\n    /**\n     * @notice Returns true if `account` is a contract.\n     * @dev This function will return false if invoked during the constructor of a contract,\n     *      as the code is not actually created until after the constructor finishes.\n     * @param account The address being queried\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        /* solhint-enable no-inline-assembly */\n        return size > 0;\n    }\n}"
    },
    {
      "filename": "contracts/interfaces/external/IGnosisSafe.sol",
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.19;\n\n/// @title Enum - Collection of enums\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Enum {\n    enum Operation {\n        Call,\n        DelegateCall\n    }\n}\n\ninterface IGnosisSafe {\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModule(address to, uint256 value, bytes calldata data, Enum.Operation operation)\n        external\n        returns (bool success);\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModuleReturnData(address to, uint256 value, bytes memory data, Enum.Operation operation)\n        external\n        returns (bool success, bytes memory returnData);\n    function getStorageAt(uint256 offset, uint256 length) external view returns (bytes memory);\n    function isOwner(address owner) external view returns (bool);\n    function nonce() external view returns (uint256);\n    function getThreshold() external view returns (uint256);\n    function isModuleEnabled(address module) external view returns (bool);\n    function enableModule(address module) external;\n    function disableModule(address prevModule, address module) external;\n    function removeOwner(address prevOwner, address owner, uint256 _threshold) external;\n    function swapOwner(address prevOwner, address oldOwner, address newOwner) external;\n    function getOwners() external view returns (address[] memory);\n    function approveHash(bytes32 hashToApprove) external;\n    function signedMessages(bytes32 _dataHash) external returns (uint256 _signatures);\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) external payable returns (bool);\n\n    function setup(\n        address[] memory _owners,\n        uint256 _threshold,\n        address to,\n        bytes memory data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address paymentReceiver\n    ) external;\n\n    function addOwnerWithThreshold(address owner, uint256 _threshold) external;\n    function domainSeparator() external view returns (bytes32);\n    function setFallbackHandler(address _fallbackHandler) external;\n    function setGuard(address guard) external;\n    function encodeTransactionData(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) external view returns (bytes memory);\n}\n\ninterface IGuard {\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        address msgSender\n    ) external;\n\n    function checkAfterExecution(bytes32 txHash, bool success) external;\n\n    /**\n     * @notice Function called before execution of transaction via safe module\n     * @param to The address of the recipient\n     * @param value The value of the transaction\n     * @param data The data of the transaction\n     * @param operation The operation type\n     * @param module The module that triggered the transaction\n     */\n    function checkModuleTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        address module\n    ) external;\n}"
    },
    {
      "filename": "contracts/script/utils/ConstantSetup.s.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.19;\n\ncontract ConstantSetup {\n    // Safe 1.3.0 Addresses\n    address public singleton;\n    address public proxyDeployer;\n    address public fallbackHandler;\n    address public gnosisMultisend;\n\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    constructor() {\n        setUpConstants();\n    }\n\n    function setUpConstants() public {\n        // Ethereum Mainnet\n        if (block.chainid == 1) {\n            singleton = 0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552;\n            proxyDeployer = 0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2;\n            fallbackHandler = 0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4;\n            gnosisMultisend = 0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761;\n        }\n        // Ethereum Goerli Testnet\n        if (block.chainid == 5) {\n            singleton = 0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552;\n            proxyDeployer = 0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2;\n            fallbackHandler = 0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4;\n            gnosisMultisend = 0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761;\n        }\n        // Optimism Mainnet\n        if (block.chainid == 10) {\n            /// @notice UNOFFICIAL DEPLOYMENT (to get same address across all chains)\n            singleton = 0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552;\n            proxyDeployer = 0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2;\n            fallbackHandler = 0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4;\n            gnosisMultisend = 0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761;\n            // singleton = 0x69f4D1788e39c87893C980c06EdF4b7f686e2938;\n            // proxyDeployer = 0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC;\n            // fallbackHandler = 0x017062a1dE2FE6b99BE3d9d37841FeD19F573804;\n            // gnosisMultisend = 0x998739BFdAAdde7C933B942a68053933098f9EDa;\n        }\n        // Binance Smart Chain Mainnet\n        if (block.chainid == 56) {\n            singleton = 0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552;\n            proxyDeployer = 0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2;\n            fallbackHandler = 0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4;\n            gnosisMultisend = 0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761;\n        }\n        // Polygon Mainnet\n        if (block.chainid == 137) {\n            singleton = 0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552;\n            proxyDeployer = 0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2;\n            fallbackHandler = 0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4;\n            gnosisMultisend = 0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761;\n        }\n        // Fantom Opera\n        if (block.chainid == 250) {\n            singleton = 0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552;\n            proxyDeployer = 0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2;\n            fallbackHandler = 0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4;\n            gnosisMultisend = 0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761;\n        }\n        // Polygon zkEVM\n        if (block.chainid == 1101) {\n            singleton = 0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552;\n            proxyDeployer = 0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2;\n            fallbackHandler = 0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4;\n            gnosisMultisend = 0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761;\n        }\n        // Base Mainnet\n        if (block.chainid == 8453) {\n            /// @notice UNOFFICIAL DEPLOYMENT (to get same address across all chains)\n            singleton = 0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552;\n            proxyDeployer = 0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2;\n            fallbackHandler = 0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4;\n            gnosisMultisend = 0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761;\n            // singleton = 0x69f4D1788e39c87893C980c06EdF4b7f686e2938;\n            // proxyDeployer = 0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC;\n            // fallbackHandler = 0x017062a1dE2FE6b99BE3d9d37841FeD19F573804;\n            // gnosisMultisend = 0x998739BFdAAdde7C933B942a68053933098f9EDa;\n        }\n        // Arbitrum One\n        if (block.chainid == 42161) {\n            singleton = 0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552;\n            proxyDeployer = 0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2;\n            fallbackHandler = 0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4;\n            gnosisMultisend = 0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761;\n        }\n        // Avalanche C Chain\n        if (block.chainid == 43114) {\n            /// @notice UNOFFICIAL DEPLOYMENT (to get same address across all chains)\n            singleton = 0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552;\n            proxyDeployer = 0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2;\n            fallbackHandler = 0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4;\n            gnosisMultisend = 0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761;\n            // singleton = 0x69f4D1788e39c87893C980c06EdF4b7f686e2938;\n            // proxyDeployer = 0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC;\n            // fallbackHandler = 0x017062a1dE2FE6b99BE3d9d37841FeD19F573804;\n            // gnosisMultisend = 0x998739BFdAAdde7C933B942a68053933098f9EDa;\n        }\n    }\n}"
    }
  ]
}