{
  "Title": "[G‑13] Add unchecked `{}` for subtractions where the operands cannot underflow because of a previous `require()` or `if-statement`",
  "Content": "\n`require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`.\n\n```solidity\nFile:   src/governance/GovernorBravoDelegateMaia.sol\n532    require(b <= a, \"subtraction underflow\");\n        return a - b;\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/governance/GovernorBravoDelegateMaia.sol#L532-L533\n\n```solidity\nFile:   src/hermes/minters/BaseV2Minter.sol\n140   HERMES(underlying).mint(address(this), _required - _balanceOf);\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/hermes/minters/BaseV2Minter.sol#L140\n\n```solidity\nFile:   src/talos/base/TalosBaseStrategy.sol\n166   if (amount0 < amount0Desired) {\n            uint256 refund0 = amount0Desired - amount0;\n            address(_token0).safeTransfer(msg.sender, refund0);\n        }\n\n171    if (amount1 < amount1Desired) {\n            uint256 refund1 = amount1Desired - amount1;\n            address(_token1).safeTransfer(msg.sender, refund1);\n        }\n226    if (amount0 < amount0Desired) {\n            uint256 refund0 = amount0Desired - amount0;\n            address(_token0).safeTransfer(msg.sender, refund0);\n        }\n\n231   if (amount1 < amount1Desired) {\n            uint256 refund1 = amount1Desired - amount1;\n            address(_token1).safeTransfer(msg.sender, refund1);\n        }  \n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L166-L174\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/governance/GovernorBravoDelegateMaia.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./GovernorBravoInterfaces.sol\";\n\n/// @title Governor Bravo Constants Contract\ncontract GovernorBravoConstants {\n    /// @notice The name of this contract\n    string public constant name = \"vMaia Governor Bravo\";\n\n    /// @notice The minimum setable proposal threshold\n    uint256 public constant MIN_PROPOSAL_THRESHOLD = 0.005 ether; // 0.5% of GovToken\n\n    /// @notice The maximum setable proposal threshold\n    uint256 public constant MAX_PROPOSAL_THRESHOLD = 0.05 ether; // 5% of GovToken\n\n    /// @notice The minimum setable voting period\n    uint256 public constant MIN_VOTING_PERIOD = 80640; // About 2 weeks\n\n    /// @notice The max setable voting period\n    uint256 public constant MAX_VOTING_PERIOD = 161280; // About 4 weeks\n\n    /// @notice The min setable voting delay\n    uint256 public constant MIN_VOTING_DELAY = 40320; // About 1 weeks\n\n    /// @notice The max setable voting delay\n    uint256 public constant MAX_VOTING_DELAY = 80640; // About 2 weeks\n\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    uint256 public constant quorumVotes = 0.35 ether; // 35% of GovToken\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint256 public constant proposalMaxOperations = 10; // 10 actions\n\n    /// @notice The divisor value used in percentage calculations\n    uint256 public constant DIVISIONER = 1 ether;\n}\n\n/// @title Governor Bravo Delegate Contract\ncontract GovernorBravoDelegate is GovernorBravoDelegateStorageV2, GovernorBravoEvents, GovernorBravoConstants {\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,uint8 support)\");\n\n    /**\n     * @notice Used to initialize the contract during delegator constructor\n     * @param timelock_ The address of the Timelock\n     * @param govToken_ The address of the GOV token\n     * @param votingPeriod_ The initial voting period\n     * @param votingDelay_ The initial voting delay\n     * @param proposalThreshold_ The initial proposal threshold\n     */\n    function initialize(\n        address timelock_,\n        address govToken_,\n        uint256 votingPeriod_,\n        uint256 votingDelay_,\n        uint256 proposalThreshold_\n    ) public virtual {\n        require(address(timelock) == address(0), \"GovernorBravo::initialize: can only initialize once\");\n        require(msg.sender == admin, \"GovernorBravo::initialize: admin only\");\n        require(timelock_ != address(0), \"GovernorBravo::initialize: invalid timelock address\");\n        require(govToken_ != address(0), \"GovernorBravo::initialize: invalid govToken address\");\n        require(\n            votingPeriod_ >= MIN_VOTING_PERIOD && votingPeriod_ <= MAX_VOTING_PERIOD,\n            \"GovernorBravo::initialize: invalid voting period\"\n        );\n        require(\n            votingDelay_ >= MIN_VOTING_DELAY && votingDelay_ <= MAX_VOTING_DELAY,\n            \"GovernorBravo::initialize: invalid voting delay\"\n        );\n        require(\n            proposalThreshold_ >= MIN_PROPOSAL_THRESHOLD && proposalThreshold_ <= MAX_PROPOSAL_THRESHOLD,\n            \"GovernorBravo::initialize: invalid proposal threshold\"\n        );\n\n        timelock = TimelockInterface(timelock_);\n        govToken = GovTokenInterface(govToken_);\n        votingPeriod = votingPeriod_;\n        votingDelay = votingDelay_;\n        proposalThreshold = proposalThreshold_;\n    }\n\n    function getProposalThresholdAmount() public view returns (uint256) {\n        return govToken.totalSupply() * proposalThreshold / DIVISIONER;\n    }\n\n    function getQuorumVotesAmount() public view returns (uint256) {\n        return govToken.totalSupply() * quorumVotes / DIVISIONER;\n    }\n\n    /**\n     * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\n     * @param targets Target addresses for proposal calls\n     * @param values Eth values for proposal calls\n     * @param signatures Function signatures for proposal calls\n     * @param calldatas Calldatas for proposal calls\n     * @param description String description of the proposal\n     * @return Proposal id of new proposal\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public returns (uint256) {\n        // Reject proposals before initiating as Governor\n        require(initialProposalId != 0, \"GovernorBravo::propose: Governor Bravo not active\");\n        // Allow addresses above proposal threshold and whitelisted addresses to propose\n        require(\n            govToken.getPriorVotes(msg.sender, sub256(block.number, 1)) > getProposalThresholdAmount()\n                || isWhitelisted(msg.sender),\n            \"GovernorBravo::propose: proposer votes below proposal threshold\"\n        );\n        require(\n            targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length,\n            \"GovernorBravo::propose: proposal function information arity mismatch\"\n        );\n        require(targets.length != 0, \"GovernorBravo::propose: must provide actions\");\n        require(targets.length <= proposalMaxOperations, \"GovernorBravo::propose: too many actions\");\n\n        uint256 latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n            require(\n                proposersLatestProposalState != ProposalState.Active,\n                \"GovernorBravo::propose: one live proposal per proposer, found an already active proposal\"\n            );\n            require(\n                proposersLatestProposalState != ProposalState.Pending,\n                \"GovernorBravo::propose: one live proposal per proposer, found an already pending proposal\"\n            );\n        }\n\n        uint256 startBlock = add256(block.number, votingDelay);\n        uint256 endBlock = add256(startBlock, votingPeriod);\n\n        proposalCount++;\n        uint256 newProposalID = proposalCount;\n        Proposal storage newProposal = proposals[newProposalID];\n        // This should never happen but add a check in case.\n        require(newProposal.id == 0, \"GovernorBravo::propose: ProposalID collsion\");\n        newProposal.id = newProposalID;\n        newProposal.proposer = msg.sender;\n        newProposal.eta = 0;\n        newProposal.targets = targets;\n        newProposal.values = values;\n        newProposal.signatures = signatures;\n        newProposal.calldatas = calldatas;\n        newProposal.startBlock = startBlock;\n        newProposal.endBlock = endBlock;\n        newProposal.forVotes = 0;\n        newProposal.againstVotes = 0;\n        newProposal.abstainVotes = 0;\n        newProposal.canceled = false;\n        newProposal.executed = false;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(\n            newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description\n        );\n        return newProposal.id;\n    }\n\n    /**\n     * @notice Queues a proposal of state succeeded\n     * @param proposalId The id of the proposal to queue\n     */\n    function queue(uint256 proposalId) external {\n        require(\n            state(proposalId) == ProposalState.Succeeded,\n            \"GovernorBravo::queue: proposal can only be queued if it is succeeded\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        uint256 eta = add256(block.timestamp, timelock.delay());\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            queueOrRevertInternal(\n                proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta\n            );\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\n    function queueOrRevertInternal(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        require(\n            !timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\n            \"GovernorBravo::queueOrRevertInternal: identical proposal action already queued at eta\"\n        );\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    /**\n     * @notice Executes a queued proposal if eta has passed\n     * @param proposalId The id of the proposal to execute\n     */\n    function execute(uint256 proposalId) external payable {\n        require(\n            state(proposalId) == ProposalState.Queued,\n            \"GovernorBravo::execute: proposal can only be executed if it is queued\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction{value: proposal.values[i]}(\n                proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\n     * @param proposalId The id of the proposal to cancel\n     */\n    function cancel(uint256 proposalId) external {\n        require(state(proposalId) != ProposalState.Executed, \"GovernorBravo::cancel: cannot cancel executed proposal\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        // Proposer can cancel\n        // admin is Emergency DAO and can cancel any proposal\n        if (msg.sender != proposal.proposer && msg.sender != admin) {\n            // Whitelisted proposers can't be canceled for falling below proposal threshold\n            if (isWhitelisted(proposal.proposer)) {\n                require(\n                    (govToken.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < getProposalThresholdAmount())\n                        && msg.sender == whitelistGuardian,\n                    \"GovernorBravo::cancel: whitelisted proposer\"\n                );\n            } else {\n                require(\n                    (govToken.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < getProposalThresholdAmount()),\n                    \"GovernorBravo::cancel: proposer above threshold\"\n                );\n            }\n        }\n\n        proposal.canceled = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta\n            );\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /**\n     * @notice Gets actions of a proposal\n     * @param proposalId the id of the proposal\n     * @return targets of the proposal actions\n     * @return values of the proposal actions\n     * @return signatures of the proposal actions\n     * @return calldatas of the proposal actions\n     */\n    function getActions(uint256 proposalId)\n        external\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    /**\n     * @notice Gets the receipt for a voter on a given proposal\n     * @param proposalId the id of proposal\n     * @param voter The address of the voter\n     * @return The voting receipt\n     */\n    function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory) {\n        return proposals[proposalId].receipts[voter];\n    }\n\n    /**\n     * @notice Gets the state of a proposal\n     * @param proposalId The id of the proposal\n     * @return Proposal state\n     */\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(\n            proposalCount >= proposalId && proposalId > initialProposalId, \"GovernorBravo::state: invalid proposal id\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < getQuorumVotesAmount()) {\n            return ProposalState.Defeated;\n        } else if (proposal.eta == 0) {\n            return ProposalState.Succeeded;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /**\n     * @notice Cast a vote for a proposal\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     */\n    function castVote(uint256 proposalId, uint8 support) external {\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), \"\");\n    }\n\n    /**\n     * @notice Cast a vote for a proposal with a reason\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @param reason The reason given for the vote by the voter\n     */\n    function castVoteWithReason(uint256 proposalId, uint8 support, string calldata reason) external {\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), reason);\n    }\n\n    /**\n     * @notice Cast a vote for a proposal by signature\n     * @dev External function that accepts EIP-712 signatures for voting on proposals.\n     */\n    function castVoteBySig(uint256 proposalId, uint8 support, uint8 v, bytes32 r, bytes32 s) external {\n        bytes32 domainSeparator =\n            keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainIdInternal(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"GovernorBravo::castVoteBySig: invalid signature\");\n        emit VoteCast(signatory, proposalId, support, castVoteInternal(signatory, proposalId, support), \"\");\n    }\n\n    /**\n     * @notice Internal function that caries out voting logic\n     * @param voter The voter that is casting their vote\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @return The number of votes cast\n     */\n    function castVoteInternal(address voter, uint256 proposalId, uint8 support) internal returns (uint96) {\n        require(state(proposalId) == ProposalState.Active, \"GovernorBravo::castVoteInternal: voting is closed\");\n        require(support <= 2, \"GovernorBravo::castVoteInternal: invalid vote type\");\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        require(receipt.hasVoted == false, \"GovernorBravo::castVoteInternal: voter already voted\");\n        uint96 votes = govToken.getPriorVotes(voter, proposal.startBlock);\n\n        if (support == 0) {\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\n        } else if (support == 1) {\n            proposal.forVotes = add256(proposal.forVotes, votes);\n        } else if (support == 2) {\n            proposal.abstainVotes = add256(proposal.abstainVotes, votes);\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        return votes;\n    }\n\n    /**\n     * @notice View function which returns if an account is whitelisted\n     * @param account Account to check white list status of\n     * @return If the account is whitelisted\n     */\n    function isWhitelisted(address account) public view returns (bool) {\n        return (whitelistAccountExpirations[account] > block.timestamp);\n    }\n\n    /**\n     * @notice Admin function for setting the voting delay\n     * @param newVotingDelay new voting delay, in blocks\n     */\n    function _setVotingDelay(uint256 newVotingDelay) external {\n        require(msg.sender == admin, \"GovernorBravo::_setVotingDelay: admin only\");\n        require(\n            newVotingDelay >= MIN_VOTING_DELAY && newVotingDelay <= MAX_VOTING_DELAY,\n            \"GovernorBravo::_setVotingDelay: invalid voting delay\"\n        );\n        uint256 oldVotingDelay = votingDelay;\n        votingDelay = newVotingDelay;\n\n        emit VotingDelaySet(oldVotingDelay, votingDelay);\n    }\n\n    /**\n     * @notice Admin function for setting the voting period\n     * @param newVotingPeriod new voting period, in blocks\n     */\n    function _setVotingPeriod(uint256 newVotingPeriod) external {\n        require(msg.sender == admin, \"GovernorBravo::_setVotingPeriod: admin only\");\n        require(\n            newVotingPeriod >= MIN_VOTING_PERIOD && newVotingPeriod <= MAX_VOTING_PERIOD,\n            \"GovernorBravo::_setVotingPeriod: invalid voting period\"\n        );\n        uint256 oldVotingPeriod = votingPeriod;\n        votingPeriod = newVotingPeriod;\n\n        emit VotingPeriodSet(oldVotingPeriod, votingPeriod);\n    }\n\n    /**\n     * @notice Admin function for setting the proposal threshold\n     * @dev newProposalThreshold must be greater than the hardcoded min\n     * @param newProposalThreshold new proposal threshold\n     */\n    function _setProposalThreshold(uint256 newProposalThreshold) external {\n        require(msg.sender == admin, \"GovernorBravo::_setProposalThreshold: admin only\");\n        require(\n            newProposalThreshold >= MIN_PROPOSAL_THRESHOLD && newProposalThreshold <= MAX_PROPOSAL_THRESHOLD,\n            \"GovernorBravo::_setProposalThreshold: invalid proposal threshold\"\n        );\n        uint256 oldProposalThreshold = proposalThreshold;\n        proposalThreshold = newProposalThreshold;\n\n        emit ProposalThresholdSet(oldProposalThreshold, proposalThreshold);\n    }\n\n    /**\n     * @notice Admin function for setting the whitelist expiration as a timestamp for an account. Whitelist status allows accounts to propose without meeting threshold\n     * @param account Account address to set whitelist expiration for\n     * @param expiration Expiration for account whitelist status as timestamp (if now < expiration, whitelisted)\n     */\n    function _setWhitelistAccountExpiration(address account, uint256 expiration) external {\n        require(\n            msg.sender == admin || msg.sender == whitelistGuardian,\n            \"GovernorBravo::_setWhitelistAccountExpiration: admin only\"\n        );\n        whitelistAccountExpirations[account] = expiration;\n\n        emit WhitelistAccountExpirationSet(account, expiration);\n    }\n\n    /**\n     * @notice Admin function for setting the whitelistGuardian. WhitelistGuardian can cancel proposals from whitelisted addresses\n     * @param account Account to set whitelistGuardian to (0x0 to remove whitelistGuardian)\n     */\n    function _setWhitelistGuardian(address account) external {\n        require(msg.sender == admin, \"GovernorBravo::_setWhitelistGuardian: admin only\");\n        address oldGuardian = whitelistGuardian;\n        whitelistGuardian = account;\n\n        emit WhitelistGuardianSet(oldGuardian, whitelistGuardian);\n    }\n\n    /**\n     * @notice Initiate the GovernorBravo contract\n     * @dev Admin only. Sets initial proposal id which initiates the contract, ensuring a continuous proposal id count\n     * @param governorAlpha The address for the Governor to continue the proposal id count from\n     */\n    function _initiate(address governorAlpha) external {\n        require(msg.sender == admin, \"GovernorBravo::_initiate: admin only\");\n        require(initialProposalId == 0, \"GovernorBravo::_initiate: can only initiate once\");\n        proposalCount = GovernorAlpha(governorAlpha).proposalCount();\n        initialProposalId = proposalCount;\n        timelock.acceptAdmin();\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     */\n    function _setPendingAdmin(address newPendingAdmin) external {\n        // Check caller = admin\n        require(msg.sender == admin, \"GovernorBravo:_setPendingAdmin: admin only\");\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     */\n    function _acceptAdmin() external {\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n        require(\n            msg.sender == pendingAdmin && msg.sender != address(0), \"GovernorBravo:_acceptAdmin: pending admin only\"\n        );\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n    }\n\n    function add256(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }\n\n    function sub256(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"subtraction underflow\");\n        return a - b;\n    }\n\n    function getChainIdInternal() internal view returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}"
    },
    {
      "filename": "src/hermes/minters/BaseV2Minter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC4626} from \"@ERC4626/ERC4626.sol\";\n\nimport {HERMES} from \"@hermes/tokens/HERMES.sol\";\n\nimport {FlywheelGaugeRewards} from \"@rewards/rewards/FlywheelGaugeRewards.sol\";\n\nimport {IBaseV2Minter} from \"../interfaces/IBaseV2Minter.sol\";\n\n/// @title Base V2 Minter - Mints HERMES tokens for the B(3,3) system\ncontract BaseV2Minter is Ownable, IBaseV2Minter {\n    using SafeTransferLib for address;\n\n    /*//////////////////////////////////////////////////////////////\n                         MINTER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev allows minting once per week (reset every Thursday 00:00 UTC)\n    uint256 internal constant week = 86400 * 7;\n    /// @dev 2% per week target emission\n    uint256 internal constant base = 1000;\n\n    uint256 internal constant max_tail_emission = 100;\n    uint256 internal constant max_dao_share = 300;\n\n    /// @inheritdoc IBaseV2Minter\n    address public immutable override underlying;\n    /// @inheritdoc IBaseV2Minter\n    ERC4626 public immutable override vault;\n\n    /// @inheritdoc IBaseV2Minter\n    FlywheelGaugeRewards public override flywheelGaugeRewards;\n    /// @inheritdoc IBaseV2Minter\n    address public override dao;\n\n    /// @inheritdoc IBaseV2Minter\n    uint256 public override daoShare = 100;\n    uint256 public override tailEmission = 20;\n    /// @inheritdoc IBaseV2Minter\n\n    /// @inheritdoc IBaseV2Minter\n    uint256 public override weekly;\n    /// @inheritdoc IBaseV2Minter\n    uint256 public override activePeriod;\n\n    address internal initializer;\n\n    constructor(\n        address _vault, // the B(3,3) system that will be locked into\n        address _dao,\n        address _owner\n    ) {\n        _initializeOwner(_owner);\n        initializer = msg.sender;\n        dao = _dao;\n        underlying = address(ERC4626(_vault).asset());\n        vault = ERC4626(_vault);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         FALLBACK LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    fallback() external {\n        updatePeriod();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2Minter\n    function initialize(FlywheelGaugeRewards _flywheelGaugeRewards) external {\n        if (initializer != msg.sender) revert NotInitializer();\n        flywheelGaugeRewards = _flywheelGaugeRewards;\n        initializer = address(0);\n        activePeriod = (block.timestamp / week) * week;\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function setDao(address _dao) external onlyOwner {\n        /// @dev DAO can be set to address(0) to disable DAO rewards.\n        dao = _dao;\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function setDaoShare(uint256 _daoShare) external onlyOwner {\n        if (_daoShare > max_dao_share) revert DaoShareTooHigh();\n        daoShare = _daoShare;\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function setTailEmission(uint256 _tail_emission) external onlyOwner {\n        if (_tail_emission > max_tail_emission) revert TailEmissionTooHigh();\n        tailEmission = _tail_emission;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         EMISSION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2Minter\n    function circulatingSupply() public view returns (uint256) {\n        return HERMES(underlying).totalSupply() - vault.totalAssets();\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function weeklyEmission() public view returns (uint256) {\n        return (circulatingSupply() * tailEmission) / base;\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function calculateGrowth(uint256 _minted) public view returns (uint256) {\n        return (vault.totalAssets() * _minted) / HERMES(underlying).totalSupply();\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function updatePeriod() public returns (uint256) {\n        uint256 _period = activePeriod;\n        // only trigger if new week\n        if (block.timestamp >= _period + week && initializer == address(0)) {\n            _period = (block.timestamp / week) * week;\n            activePeriod = _period;\n            uint256 newWeeklyEmission = weeklyEmission();\n            weekly += newWeeklyEmission;\n            uint256 _circulatingSupply = circulatingSupply();\n\n            uint256 _growth = calculateGrowth(newWeeklyEmission);\n            uint256 _required = _growth + newWeeklyEmission;\n            /// @dev share of newWeeklyEmission emissions sent to DAO.\n            uint256 share = (_required * daoShare) / base;\n            _required += share;\n            uint256 _balanceOf = underlying.balanceOf(address(this));\n            if (_balanceOf < _required) {\n                HERMES(underlying).mint(address(this), _required - _balanceOf);\n            }\n\n            underlying.safeTransfer(address(vault), _growth);\n\n            if (dao != address(0)) underlying.safeTransfer(dao, share);\n\n            emit Mint(msg.sender, newWeeklyEmission, _circulatingSupply, _growth, share);\n\n            /// @dev queue rewards for the cycle, anyone can call if fails\n            ///      queueRewardsForCycle will call this function but won't enter\n            ///      here because activePeriod was updated\n            try flywheelGaugeRewards.queueRewardsForCycle() {} catch {}\n        }\n        return _period;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         REWARDS STREAM LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2Minter\n    function getRewards() external returns (uint256 totalQueuedForCycle) {\n        if (address(flywheelGaugeRewards) != msg.sender) revert NotFlywheelGaugeRewards();\n        totalQueuedForCycle = weekly;\n        weekly = 0;\n        underlying.safeTransfer(msg.sender, totalQueuedForCycle);\n    }\n}"
    },
    {
      "filename": "src/talos/base/TalosBaseStrategy.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Logic inspired by Popsicle Finance Contracts (PopsicleV3Optimizer/contracts/popsicle-v3-optimizer/PopsicleV3Optimizer.sol)\npragma solidity >=0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {INonfungiblePositionManager} from \"@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol\";\n\nimport {PoolVariables} from \"../libraries/PoolVariables.sol\";\n\nimport {ITalosBaseStrategy} from \"../interfaces/ITalosBaseStrategy.sol\";\nimport {ITalosOptimizer} from \"../interfaces/ITalosOptimizer.sol\";\n\n/// @title Tokenized Vault implementation for Uniswap V3 Non Fungible Positions.\nabstract contract TalosBaseStrategy is Ownable, ERC20, ReentrancyGuard, ITalosBaseStrategy {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n    using FixedPointMathLib for uint128;\n    using SafeCastLib for uint256;\n    using SafeCastLib for uint128;\n    using PoolVariables for IUniswapV3Pool;\n\n    /*//////////////////////////////////////////////////////////////\n                        TALOS BASE STRATEGY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    uint256 public override tokenId;\n    /// @inheritdoc ITalosBaseStrategy\n    uint128 public override liquidity;\n\n    /// @inheritdoc ITalosBaseStrategy\n    uint256 public protocolFees0;\n    /// @inheritdoc ITalosBaseStrategy\n    uint256 public protocolFees1;\n\n    /// @notice Current tick lower of Optimizer pool position\n    /// @inheritdoc ITalosBaseStrategy\n    int24 public override tickLower;\n    /// @notice Current tick higher of Optimizer pool position\n    /// @inheritdoc ITalosBaseStrategy\n    int24 public override tickUpper;\n\n    /// @inheritdoc ITalosBaseStrategy\n    bool public initialized;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    ERC20 public immutable override token0;\n    /// @inheritdoc ITalosBaseStrategy\n    ERC20 public immutable override token1;\n    /// @inheritdoc ITalosBaseStrategy\n    int24 public immutable override tickSpacing;\n    /// @inheritdoc ITalosBaseStrategy\n    uint24 public immutable override poolFee;\n    /// @inheritdoc ITalosBaseStrategy\n    IUniswapV3Pool public immutable override pool;\n    /// @inheritdoc ITalosBaseStrategy\n    ITalosOptimizer public immutable override optimizer;\n    /// @inheritdoc ITalosBaseStrategy\n    address public immutable strategyManager;\n    /// @inheritdoc ITalosBaseStrategy\n    INonfungiblePositionManager public immutable override nonfungiblePositionManager;\n\n    uint24 internal constant MULTIPLIER = 1e6;\n\n    constructor(\n        IUniswapV3Poo"
    }
  ]
}