{
  "Title": "[G-02] Use prefix not postfix in loops",
  "Content": "<h2 id=\"g-02-use-prefix-not-postfix-in-loops\" style=\"position:relative;\"><a href=\"#g-02-use-prefix-not-postfix-in-loops\" aria-label=\"g 02 use prefix not postfix in loops permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[G-02] Use prefix not postfix in loops</h2>\n<p>Using a prefix increment (++i) instead of a postfix increment (i++) saves gas for each loop cycle and so can have a big gas impact when the loop executes on a large number of elements.</p>\n<p>There are several examples of this:<br>\n<a href=\"https://github.com/fei-protocol/ERC4626/blob/643cd044fac34bcbf64e1c3790a5126fec0dbec1/src/external/Multicall.sol#L14\">Multicall.sol#L14</a><br>\n<a href=\"https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L189\">FlywheelGaugeRewards.sol#L189</a><br>\n<a href=\"https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L346\">ERC20MultiVotes.sol#L346</a><br>\n<a href=\"https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L137\">ERC20Gauges.sol#L137</a><br>\n<a href=\"https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L187\">ERC20Gauges.sol#L187</a><br>\n<a href=\"https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L314\">ERC20Gauges.sol#L314</a><br>\n<a href=\"https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L391\">ERC20Gauges.sol#L391</a><br>\n<a href=\"https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L576\">ERC20Gauges.sol#L576</a><br>\n<a href=\"https://github.com/fei-protocol/xTRIBE/blob/989e47d176facbb0c38bc1e1ca58672f179159e1/src/xTRIBE.sol#L99\">xTRIBE.sol#L99</a><br></p>\n<h3 id=\"recommended-mitigation-steps-8\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-8\" aria-label=\"recommended mitigation steps 8 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>Use prefix not postfix to increment in a loop.</p>\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-04-xtribe-contest",
  "Code": [
    {
      "filename": "src/external/Multicall.sol",
      "content": "// forked from https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/Multicall.sol\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.6;\n\nimport './interfaces/IMulticall.sol';\n\n/// @title Multicall\n/// @notice Enables calling multiple methods in a single call to the contract\nabstract contract Multicall is IMulticall {\n    /// @inheritdoc IMulticall\n    function multicall(bytes[] calldata data) public payable override returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n            if (!success) {\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n                if (result.length < 68) revert();\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            results[i] = result;\n        }\n    }\n}"
    },
    {
      "filename": "src/rewards/FlywheelGaugeRewards.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {SafeCastLib} from \"solmate/utils/SafeCastLib.sol\";\n\nimport \"./BaseFlywheelRewards.sol\";\n\nimport {ERC20Gauges} from \"../token/ERC20Gauges.sol\";\n\n/// @notice a contract which streams reward tokens to the FlywheelRewards module\ninterface IRewardsStream {\n    /// @notice read and transfer reward token chunk to FlywheelRewards module\n    function getRewards() external returns (uint256);\n}\n\n/** \n @title Flywheel Gauge Reward Stream\n @notice Distributes rewards from a stream based on gauge weights\n\n The contract assumes an arbitrary stream of rewards `S` of rewardToken. It chunks the rewards into cycles of length `l`.\n\n The allocation function for each cycle A(g, S) proportions the stream to each gauge such that SUM(A(g, S)) over all gauges <= S. \n NOTE it should be approximately S, but may be less due to truncation.\n\n Rewards are accumulated every time a new rewards cycle begins, and all prior rewards are cached in the previous cycle.\n When the Flywheel Core requests accrued rewards for a specific gauge:\n 1. All prior rewards before this cycle are distributed\n 2. Rewards for the current cycle are distributed proportionally to the remaining time in the cycle. \n    If `e` is the cycle end, `t` is the min of e and current timestamp, and `p` is the prior updated time:\n    For `A` accrued rewards over the cycle, distribute `min(A * (t-p)/(e-p), A)`.\n*/\ncontract FlywheelGaugeRewards is Auth, BaseFlywheelRewards {\n    using SafeTransferLib for ERC20;\n    using SafeCastLib for uint256;\n\n    /// @notice thrown when trying to queue a new cycle during an old one.\n    error CycleError();\n\n    /// @notice thrown when trying to queue with 0 gauges\n    error EmptyGaugesError();\n\n    /// @notice emitted when a cycle has completely queued and started\n    event CycleStart(uint32 indexed cycleStart, uint256 rewardAmount);\n\n    /// @notice emitted when a single gauge is queued. May be emitted before the cycle starts if the queue is done via pagination.\n    event QueueRewards(address indexed gauge, uint32 indexed cycleStart, uint256 rewardAmount);\n\n    /// @notice the start of the current cycle\n    uint32 public gaugeCycle;\n\n    /// @notice the length of a rewards cycle\n    uint32 public immutable gaugeCycleLength;\n\n    /// @notice the start of the next cycle being partially queued\n    uint32 internal nextCycle;\n\n    // rewards that made it into a partial queue but didn't get completed\n    uint112 internal nextCycleQueuedRewards;\n\n    // the offset during pagination of the queue\n    uint32 internal paginationOffset;\n\n    /// @notice rewards queued from prior and current cycles\n    struct QueuedRewards {\n        uint112 priorCycleRewards;\n        uint112 cycleRewards;\n        uint32 storedCycle;\n    }\n\n    /// @notice mapping from gauges to queued rewards\n    mapping(ERC20 => QueuedRewards) public gaugeQueuedRewards;\n\n    /// @notice the gauge token for determining gauge allocations of the rewards stream\n    ERC20Gauges public immutable gaugeToken;\n\n    /// @notice contract to pull reward tokens from\n    IRewardsStream public rewardsStream;\n\n    constructor(\n        FlywheelCore _flywheel,\n        address _owner,\n        Authority _authority,\n        ERC20Gauges _gaugeToken,\n        IRewardsStream _rewardsStream\n    ) BaseFlywheelRewards(_flywheel) Auth(_owner, _authority) {\n        gaugeCycleLength = _gaugeToken.gaugeCycleLength();\n\n        // seed initial gaugeCycle\n        gaugeCycle = (block.timestamp.safeCastTo32() / gaugeCycleLength) * gaugeCycleLength;\n\n        gaugeToken = _gaugeToken;\n\n        rewardsStream = _rewardsStream;\n    }\n\n    /**\n        @notice Iterates over all live gauges and queues up the rewards for the cycle\n        @return totalQueuedForCycle the max amount of rewards to be distributed over the cycle\n    */\n    function queueRewardsForCycle() external requiresAuth returns (uint256 totalQueuedForCycle) {\n        // next cycle is always the next even divisor of the cycle length above current block timestamp.\n        uint32 currentCycle = (block.timestamp.safeCastTo32() / gaugeCycleLength) * gaugeCycleLength;\n        uint32 lastCycle = gaugeCycle;\n\n        // ensure new cycle has begun\n        if (currentCycle <= lastCycle) revert CycleError();\n\n        gaugeCycle = currentCycle;\n\n        // queue the rewards stream and sanity check the tokens were received\n        uint256 balanceBefore = rewardToken.balanceOf(address(this));\n        totalQueuedForCycle = rewardsStream.getRewards();\n        require(rewardToken.balanceOf(address(this)) - balanceBefore >= totalQueuedForCycle);\n\n        // include uncompleted cycle\n        totalQueuedForCycle += nextCycleQueuedRewards;\n\n        // iterate over all gauges and update the rewards allocations\n        address[] memory gauges = gaugeToken.gauges();\n\n        _queueRewards(gauges, currentCycle, lastCycle, totalQueuedForCycle);\n\n        nextCycleQueuedRewards = 0;\n        paginationOffset = 0;\n\n        emit CycleStart(currentCycle, totalQueuedForCycle);\n    }\n\n    /**\n        @notice Iterates over all live gauges and queues up the rewards for the cycle\n    */\n    function queueRewardsForCyclePaginated(uint256 numRewards) external requiresAuth {\n        // next cycle is always the next even divisor of the cycle length above current block timestamp.\n        uint32 currentCycle = (block.timestamp.safeCastTo32() / gaugeCycleLength) * gaugeCycleLength;\n        uint32 lastCycle = gaugeCycle;\n\n        // ensure new cycle has begun\n        if (currentCycle <= lastCycle) revert CycleError();\n\n        if (currentCycle > nextCycle) {\n            nextCycle = currentCycle;\n            paginationOffset = 0;\n        }\n\n        uint32 offset = paginationOffset;\n\n        // important to only calculate the reward amount once to prevent each page from having a different reward amount\n        if (offset == 0) {\n            // queue the rewards stream and sanity check the tokens were received\n            uint256 balanceBefore = rewardToken.balanceOf(address(this));\n            uint256 newRewards = rewardsStream.getRewards();\n            require(rewardToken.balanceOf(address(this)) - balanceBefore >= newRewards);\n            require(newRewards <= type(uint112).max); // safe cast\n            nextCycleQueuedRewards += uint112(newRewards); // in case a previous incomplete cycle had rewards, add on\n        }\n\n        uint112 queued = nextCycleQueuedRewards;\n\n        uint256 remaining = gaugeToken.numGauges() - offset;\n\n        // Important to do non-strict inequality to include the case where the numRewards is just enough to complete the cycle\n        if (remaining <= numRewards) {\n            numRewards = remaining;\n            gaugeCycle = currentCycle;\n            nextCycleQueuedRewards = 0;\n            paginationOffset = 0;\n            emit CycleStart(currentCycle, queued);\n        } else {\n            paginationOffset = offset + numRewards.safeCastTo32();\n        }\n\n        // iterate over all gauges and update the rewards allocations\n        address[] memory gauges = gaugeToken.gauges(offset, numRewards);\n\n        _queueRewards(gauges, currentCycle, lastCycle, queued);\n    }\n\n    function _queueRewards(\n        address[] memory gauges,\n        uint32 currentCycle,\n        uint32 lastCycle,\n        uint256 totalQueuedForCycle\n    ) internal {\n        uint256 size = gauges.length;\n\n        if (size == 0) revert EmptyGaugesError();\n\n        for (uint256 i = 0; i < size; i++) {\n            ERC20 gauge = ERC20(gauges[i]);\n\n            QueuedRewards memory queuedRewards = gaugeQueuedRewards[gauge];\n\n            // Cycle queue already started\n            require(queuedRewards.storedCycle < currentCycle);\n            assert(queuedRewards.storedCycle == 0 || queuedRewards.storedCycle >= lastCycle);\n\n            uint112 completedRewards = queuedRewards.storedCycle == lastCycle ? queuedRewards.cycleRewards : 0;\n            uint256 nextRewards = gaugeToken.calculateGaugeAllocation(address(gauge), totalQueuedForCycle);\n            require(nextRewards <= type(uint112).max); // safe cast\n\n            gaugeQueuedRewards[gauge] = QueuedRewards({\n                priorCycleRewards: queuedRewards.priorCycleRewards + completedRewards,\n                cycleRewards: uint112(nextRewards),\n                storedCycle: currentCycle\n            });\n\n            emit QueueRewards(address(gauge), currentCycle, nextRewards);\n        }\n    }\n\n    /**\n     @notice calculate and transfer accrued rewards to flywheel core\n     @param gauge the gauge to accrue rewards for\n     @param lastUpdatedTimestamp the last updated time for gauge\n     @return accruedRewards the amount of reward tokens accrued.\n    */\n    function getAccruedRewards(ERC20 gauge, uint32 lastUpdatedTimestamp)\n        external\n        override\n        onlyFlywheel\n        returns (uint256 accruedRewards)\n    {\n        QueuedRewards memory queuedRewards = gaugeQueuedRewards[gauge];\n\n        uint32 cycle = gaugeCycle;\n        bool incompleteCycle = queuedRewards.storedCycle > cycle;\n\n        // no rewards\n        if (queuedRewards.priorCycleRewards == 0 && (queuedRewards.cycleRewards == 0 || incompleteCycle)) {\n            return 0;\n        }\n\n        // if stored cycle != 0 it must be >= the last queued cycle\n        assert(queuedRewards.storedCycle >= cycle);\n\n        uint32 cycleEnd = cycle + gaugeCycleLength;\n\n        // always accrue prior rewards\n        accruedRewards = queuedRewards.priorCycleRewards;\n        uint112 cycleRewardsNext = queuedRewards.cycleRewards;\n\n        if (incompleteCycle) {\n            // If current cycle queue incomplete, do nothing to current cycle rewards or accrued\n        } else if (block.timestamp >= cycleEnd) {\n            // If cycle ended, accrue all rewards\n            accruedRewards += cycleRewardsNext;\n            cycleRewardsNext = 0;\n        } else {\n            uint32 beginning = lastUpdatedTimestamp > cycle ? lastUpdatedTimestamp : cycle;\n\n            // otherwise, return proportion of remaining rewards in cycle\n            uint32 elapsed = block.timestamp.safeCastTo32() - beginning;\n            uint32 remaining = cycleEnd - beginning;\n\n            // Casted up to avoid intermediate overflow\n            // cannot end in an overflow of uint112 because elapsed <= remaining and cycleRewards <= uint112.max\n            uint256 currentAccrued = (uint256(queuedRewards.cycleRewards) * elapsed) / remaining;\n\n            // add proportion of current cycle to accrued rewards\n            accruedRewards += currentAccrued;\n            cycleRewardsNext -= uint112(currentAccrued);\n        }\n\n        gaugeQueuedRewards[gauge] = QueuedRewards({\n            priorCycleRewards: 0,\n            cycleRewards: cycleRewardsNext,\n            storedCycle: queuedRewards.storedCycle\n        });\n    }\n\n    /// @notice set the rewards stream contract\n    function setRewardsStream(IRewardsStream newRewardsStream) external requiresAuth {\n        rewardsStream = newRewardsStream;\n    }\n}"
    },
    {
      "filename": "src/token/ERC20MultiVotes.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Voting logic inspired by OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Votes.sol)\n\npragma solidity ^0.8.0;\n\nimport \"solmate/auth/Auth.sol\";\nimport \"solmate/tokens/ERC20.sol\";\nimport \"solmate/utils/SafeCastLib.sol\";\nimport \"../../lib/EnumerableSet.sol\";\nimport \"../interfaces/Errors.sol\";\n\n/**\n @title ERC20 Multi-Delegation Voting contract\n @notice an ERC20 extension which allows delegations to multiple delegatees up to a user's balance on a given block.\n */\nabstract contract ERC20MultiVotes is ERC20, Auth {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeCastLib for *;\n\n    /*///////////////////////////////////////////////////////////////\n                        VOTE CALCULATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice thrown when trying to read from an invalid block.\n    error BlockError();\n\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    /// @notice votes checkpoint list per user.\n    mapping(address => Checkpoint[]) private _checkpoints;\n\n    /// @notice Get the `pos`-th checkpoint for `account`.\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /// @notice Get number of checkpoints for `account`.\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return _checkpoints[account].length.safeCastTo32();\n    }\n\n    /**\n     * @notice Gets the amount of unallocated votes for `account`.\n     * @param account the address to get free votes of.\n     * @return the amount of unallocated votes.\n     */\n    function freeVotes(address account) public view virtual returns (uint256) {\n        return balanceOf[account] - userDelegatedVotes[account];\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`.\n     * @param account the address to get votes of.\n     * @return the amount of votes.\n     */\n    function getVotes(address account) public view virtual returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n    /**\n     * @notice Retrieve the number of votes for `account` at the end of `blockNumber`.\n     * @param account the address to get votes of.\n     * @param blockNumber the block to calculate votes for.\n     * @return the amount of votes.\n     */\n    function getPastVotes(address account, uint256 blockNumber) public view virtual returns (uint256) {\n        if (blockNumber >= block.number) revert BlockError();\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n\n    /// @dev Lookup a value in a list of (sorted) checkpoints.\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice emitted when updating the maximum amount of delegates per user\n    event MaxDelegatesUpdate(uint256 oldMaxDelegates, uint256 newMaxDelegates);\n\n    /// @notice emitted when updating the canContractExceedMaxDelegates flag for an account\n    event CanContractExceedMaxDelegatesUpdate(address indexed account, bool canContractExceedMaxDelegates);\n\n    /// @notice the maximum amount of delegates for a user at a given time\n    uint256 public maxDelegates;\n\n    /// @notice an approve list for contracts to go above the max delegate limit.\n    mapping(address => bool) public canContractExceedMaxDelegates;\n\n    /// @notice set the new max delegates per user. Requires auth by `authority`.\n    function setMaxDelegates(uint256 newMax) external requiresAuth {\n        uint256 oldMax = maxDelegates;\n        maxDelegates = newMax;\n\n        emit MaxDelegatesUpdate(oldMax, newMax);\n    }\n\n    /// @notice set the canContractExceedMaxDelegates flag for an account.\n    function setContractExceedMaxDelegates(address account, bool canExceedMax) external requiresAuth {\n        if (canExceedMax && account.code.length == 0) revert Errors.NonContractError(); // can only approve contracts\n\n        canContractExceedMaxDelegates[account] = canExceedMax;\n\n        emit CanContractExceedMaxDelegatesUpdate(account, canExceedMax);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        DELEGATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Emitted when a `delegator` delegates `amount` votes to `delegate`.\n    event Delegation(address indexed delegator, address indexed delegate, uint256 amount);\n\n    /// @dev Emitted when a `delegator` undelegates `amount` votes from `delegate`.\n    event Undelegation(address indexed delegator, address indexed delegate, uint256 amount);\n\n    /// @dev Emitted when a token transfer or delegate change results in changes to an account's voting power.\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /// @notice An event thats emitted when an account changes its delegate\n    /// @dev this is used for backward compatibility with OZ interfaces for ERC20Votes and ERC20VotesComp.\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @dev thrown when attempting to delegate more votes than an address has free, or exceeding the max delegates\n    error DelegationError();\n\n    /// @notice mapping from a delegator and delegatee to the delegated amount.\n    mapping(address => mapping(address => uint256)) private _delegatesVotesCount;\n\n    /// @notice mapping from a delegator to the total number of delegated votes.\n    mapping(address => uint256) public userDelegatedVotes;\n\n    /// @notice list of delegates per user.\n    mapping(address => EnumerableSet.AddressSet) private _delegates;\n\n    /**\n     * @notice Get the amount of votes currently delegated by `delegator` to `delegatee`.\n     * @param delegator the account which is delegating votes to `delegatee`.\n     * @param delegatee the account receiving votes from `delegator`.\n     * @return the total amount of votes delegated to `delegatee` by `delegator`\n     */\n    function delegatesVotesCount(address delegator, address delegatee) public view virtual returns (uint256) {\n        return _delegatesVotesCount[delegator][delegatee];\n    }\n\n    /**\n     * @notice Get the list of delegates from `delegator`.\n     * @param delegator the account which is delegating votes to delegates.\n     * @return the list of delegated accounts.\n     */\n    function delegates(address delegator) public view returns (address[] memory) {\n        return _delegates[delegator].values();\n    }\n\n    /**\n     * @notice Get the number of delegates from `delegator`.\n     * @param delegator the account which is delegating votes to delegates.\n     * @return the number of delegated accounts.\n     */\n    function delegateCount(address delegator) public view returns (uint256) {\n        return _delegates[delegator].length();\n    }\n\n    /**\n     * @notice Delegate `amount` votes from the sender to `delegatee`.\n     * @param delegatee the receivier of votes.\n     * @param amount the amount of votes received.\n     * @dev requires \"freeVotes(msg.sender) > amount\" and will not exceed max delegates\n     */\n    function incrementDelegation(address delegatee, uint256 amount) public virtual {\n        _incrementDelegation(msg.sender, delegatee, amount);\n    }\n\n    /**\n     * @notice Undelegate `amount` votes from the sender from `delegatee`.\n     * @param delegatee the receivier of undelegation.\n     * @param amount the amount of votes taken away.\n     */\n    function undelegate(address delegatee, uint256 amount) public virtual {\n        _undelegate(msg.sender, delegatee, amount);\n    }\n\n    /**\n     * @notice Delegate all votes `newDelegatee`. First undelegates from an existing delegate. If `newDelegatee` is zero, only undelegates.\n     * @param newDelegatee the receiver of votes.\n     * @dev undefined for `delegateCount(msg.sender) > 1`\n     * NOTE This is meant for backward compatibility with the `ERC20Votes` and `ERC20VotesComp` interfaces from OpenZeppelin.\n     */\n    function delegate(address newDelegatee) external virtual {\n        _delegate(msg.sender, newDelegatee);\n    }\n\n    function _delegate(address delegator, address newDelegatee) internal virtual {\n        uint256 count = delegateCount(delegator);\n\n        // undefined behavior for delegateCount > 1\n        if (count > 1) revert DelegationError();\n\n        address oldDelegatee;\n        // if already delegated, undelegate first\n        if (count == 1) {\n            oldDelegatee = _delegates[delegator].at(0);\n            _undelegate(delegator, oldDelegatee, _delegatesVotesCount[delegator][oldDelegatee]);\n        }\n\n        // redelegate only if newDelegatee is not empty\n        if (newDelegatee != address(0)) {\n            _incrementDelegation(delegator, newDelegatee, freeVotes(delegator));\n        }\n        emit DelegateChanged(delegator, oldDelegatee, newDelegatee);\n    }\n\n    function _incrementDelegation(\n        address delegator,\n        address delegatee,\n        uint256 amount\n    ) internal virtual {\n        // Require freeVotes exceed the delegation size\n        uint256 free = freeVotes(delegator);\n        if (delegatee == address(0) || free < amount) revert DelegationError();\n\n        bool newDelegate = _delegates[delegator].add(delegatee); // idempotent add\n        if (newDelegate && delegateCount(delegator) > maxDelegates && !canContractExceedMaxDelegates[delegator]) {\n            // if new delegate and exceeds max and not approved to exceed, revert\n            revert DelegationError();\n        }\n\n        _delegatesVotesCount[delegator][delegatee] += amount;\n        userDelegatedVotes[delegator] += amount;\n\n        emit Delegation(delegator, delegatee, amount);\n        _writeCheckpoint(delegatee, _add, amount);\n    }\n\n    function _undelegate(\n        address delegator,\n        address delegatee,\n        uint256 amount\n    ) internal virtual {\n        uint256 newDelegates = _delegatesVotesCount[delegator][delegatee] - amount;\n\n        if (newDelegates == 0) {\n            require(_delegates[delegator].remove(delegatee));\n        }\n\n        _delegatesVotesCount[delegator][delegatee] = newDelegates;\n        userDelegatedVotes[delegator] -= amount;\n\n        emit Undelegation(delegator, delegatee, amount);\n        _writeCheckpoint(delegatee, _subtract, amount);\n    }\n\n    function _writeCheckpoint(\n        address delegatee,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private {\n        Checkpoint[] storage ckpts = _checkpoints[delegatee];\n\n        uint256 pos = ckpts.length;\n        uint256 oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        uint256 newWeight = op(oldWeight, delta);\n\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = newWeight.safeCastTo224();\n        } else {\n            ckpts.push(Checkpoint({fromBlock: block.number.safeCastTo32(), votes: newWeight.safeCastTo224()}));\n        }\n        emit DelegateVotesChanged(delegatee, oldWeight, newWeight);\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// NOTE: any \"removal\" of tokens from a user requires freeVotes(user) < amount.\n    /// _decrementVotesUntilFree is called as a greedy algorithm to free up votes.\n    /// It may be more gas efficient to free weight before burning or transferring tokens.\n\n    function _burn(address from, uint256 amount) internal virtual override {\n        _decrementVotesUntilFree(from, amount);\n        super._burn(from, amount);\n    }\n\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        _decrementVotesUntilFree(msg.sender, amount);\n        return super.transfer(to, amount);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _decrementVotesUntilFree(from, amount);\n        return super.transferFrom(from, to, amount);\n    }\n\n    /// a greedy algorithm for freeing votes before a token burn/transfer\n    /// frees up entire delegates, so likely will free more than `votes`\n    function _decrementVotesUntilFree(address user, uint256 votes) internal {\n        uint256 userFreeVotes = freeVotes(user);\n\n        // early return if already free\n        if (userFreeVotes >= votes) return;\n\n        // cache total for batch updates\n        uint256 totalFreed;\n\n        // Loop through all delegates\n        address[] memory delegateList = _delegates[user].values();\n\n        // Free delegates until through entire list or under votes amount\n        uint256 size = delegateList.length;\n        for (uint256 i = 0; i < size && (userFreeVotes + totalFreed) < votes; i++) {\n            address delegatee = delegateList[i];\n            uint256 delegateVotes = _delegatesVotesCount[user][delegatee];\n            if (delegateVotes != 0) {\n                totalFreed += delegateVotes;\n\n                require(_delegates[user].remove(delegatee)); // Remove from set. Should never fail.\n\n                _delegatesVotesCount[user][delegatee] = 0;\n\n                _writeCheckpoint(delegatee, _subtract, delegateVotes);\n                emit Undelegation(user, delegatee, delegateVotes);\n            }\n        }\n\n        userDelegatedVotes[user] -= totalFreed;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             EIP-712 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        require(block.timestamp <= expiry, \"ERC20MultiVotes: signature expired\");\n        address signer = ecrecover(\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry))\n                )\n            ),\n            v,\n            r,\n            s\n        );\n        require(nonce == nonces[signer]++, \"ERC20MultiVotes: invalid nonce\");\n        require(signer != address(0));\n        _delegate(signer, delegatee);\n    }\n}"
    },
    {
      "filename": "src/token/ERC20Gauges.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"solmate/auth/Auth.sol\";\nimport \"solmate/tokens/ERC20.sol\";\nimport \"solmate/utils/SafeCastLib.sol\";\nimport \"../../lib/EnumerableSet.sol\";\nimport \"../interfaces/Errors.sol\";\n\n/** \n @title  An ERC20 with an embedded \"Gauge\" style vote with liquid weights\n @author Tribe DAO\n @notice This contract is meant to be used to support gauge style votes with weights associated with resource allocation.\n         Holders can allocate weight in any proportion to supported gauges.\n         A \"gauge\" is represented by an address which would receive the resources periodically or continuously.\n\n         For example, gauges can be used to direct token emissions, similar to Curve or Tokemak.\n         Alternatively, gauges can be used to direct another quantity such as relative access to a line of credit.\n\n         The contract's Authority <https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol> manages the gauge set and cap.\n         \"Live\" gauges are in the set.  \n         Users can only add weight to live gauges but can remove weight from live or deprecated gauges.\n         Gauges can be deprecated and reinstated, and will maintain any non-removed weight from before.\n\n @dev    SECURITY NOTES: `maxGauges` is a critical variable to protect against gas DOS attacks upon token transfer. \n         This must be low enough to allow complicated transactions to fit in a block.\n \n         Weight state is preserved on the gauge and user level even when a gauge is removed, in case it is re-added. \n         This maintains state efficiently, and global accounting is managed only on the `_totalWeight`\n*/\nabstract contract ERC20Gauges is ERC20, Auth {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeCastLib for *;\n\n    constructor(uint32 _gaugeCycleLength, uint32 _incrementFreezeWindow) {\n        if (_incrementFreezeWindow >= _gaugeCycleLength) revert IncrementFreezeError();\n        gaugeCycleLength = _gaugeCycleLength;\n        incrementFreezeWindow = _incrementFreezeWindow;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        GAUGE STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice the length of a gauge cycle\n    uint32 public immutable gaugeCycleLength;\n\n    /// @notice the period at the end of a cycle where votes cannot increment\n    uint32 public immutable incrementFreezeWindow;\n\n    struct Weight {\n        uint112 storedWeight;\n        uint112 currentWeight;\n        uint32 currentCycle;\n    }\n\n    /// @notice a mapping from users to gauges to a user's allocated weight to that gauge\n    mapping(address => mapping(address => uint112)) public getUserGaugeWeight;\n\n    /// @notice a mapping from a user to their total allocated weight across all gauges\n    /// @dev NOTE this may contain weights for deprecated gauges\n    mapping(address => uint112) public getUserWeight;\n\n    /// @notice a mapping from a gauge to the total weight allocated to it\n    /// @dev NOTE this may contain weights for deprecated gauges\n    mapping(address => Weight) internal _getGaugeWeight;\n\n    /// @notice the total global allocated weight ONLY of live gauges\n    Weight internal _totalWeight;\n\n    mapping(address => EnumerableSet.AddressSet) internal _userGauges;\n\n    EnumerableSet.AddressSet internal _gauges;\n\n    // Store deprecated gauges in case a user needs to free dead weight\n    EnumerableSet.AddressSet internal _deprecatedGauges;\n\n    /*///////////////////////////////////////////////////////////////\n                              VIEW HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice return the end of the current cycle. This is the next unix timestamp which evenly divides `gaugeCycleLength`\n    function getGaugeCycleEnd() public view returns (uint32) {\n        return _getGaugeCycleEnd();\n    }\n\n    /// @notice see `getGaugeCycleEnd()`\n    function _getGaugeCycleEnd() internal view returns (uint32) {\n        uint32 nowPlusOneCycle = block.timestamp.safeCastTo32() + gaugeCycleLength;\n        unchecked {\n            return (nowPlusOneCycle / gaugeCycleLength) * gaugeCycleLength; // cannot divide by zero and always <= nowPlusOneCycle so no overflow\n        }\n    }\n\n    /// @notice returns the current weight of a given gauge\n    function getGaugeWeight(address gauge) public view returns (uint112) {\n        return _getGaugeWeight[gauge].currentWeight;\n    }\n\n    /// @notice returns the stored weight of a given gauge. This is the snapshotted weight as-of the end of the last cycle.\n    function getStoredGaugeWeight(address gauge) public view returns (uint112) {\n        if (_deprecatedGauges.contains(gauge)) return 0;\n        return _getStoredWeight(_getGaugeWeight[gauge]"
    }
  ]
}