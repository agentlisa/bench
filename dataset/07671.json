{
  "Title": "[H-13] Possible reentrancy and fund theft in withdrawDETH() of GiantSavETHVaultPool because there is no whitelist check for user provided Vaults and there is no reentrancy defense",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L62-L102\n\n\n# Vulnerability details\n\n## Impact\nFunction `withdrawDETH()` in `GiantSavETHVaultPool` allows a user to burn their giant LP in exchange for dETH that is ready to withdraw from a set of savETH vaults. This function make external calls to user provided addresses without checking those addresses and send increased dETH balance of contract during the call to user. user can provide malicious addresses to contract and then took the execution flow during the transaction and increase dETH balance of contract by other calls and make contract to transfer them to him.\n\n## Proof of Concept\nThis is `withdrawDETH()` in `GiantSavETHVaultPool`  code:\n```\n    /// @notice Allow a user to burn their giant LP in exchange for dETH that is ready to withdraw from a set of savETH vaults\n    /// @param _savETHVaults List of savETH vaults being interacted with\n    /// @param _lpTokens List of savETH vault LP being burnt from the giant pool in exchange for dETH\n    /// @param _amounts Amounts of giant LP the user owns which is burnt 1:1 with savETH vault LP and in turn that will give a share of dETH\n    function withdrawDETH(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _savETHVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n\n        // Firstly capture current dETH balance and see how much has been deposited after the loop\n        uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));\n        for (uint256 i; i < numOfVaults; ++i) {\n            SavETHVault vault = SavETHVault(_savETHVaults[i]);\n\n            // Simultaneously check the status of LP tokens held by the vault and the giant LP balance of the user\n            for (uint256 j; j < _lpTokens[i].length; ++j) {\n                LPToken token = _lpTokens[i][j];\n                uint256 amount = _amounts[i][j];\n\n                // Check the user has enough giant LP to burn and that the pool has enough savETH vault LP\n                _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);\n\n                require(vault.isDETHReadyForWithdrawal(address(token)), \"dETH is not ready for withdrawal\");\n\n                // Giant LP is burned 1:1 with LPs from sub-networks\n                require(lpTokenETH.balanceOf(msg.sender) >= amount, \"User does not own enough LP\");\n\n                // Burn giant LP from user before sending them dETH\n                lpTokenETH.burn(msg.sender, amount);\n\n                emit LPBurnedForDETH(address(token), msg.sender, amount);\n            }\n\n            // Ask\n            vault.burnLPTokens(_lpTokens[i], _amounts[i]);\n        }\n\n        // Calculate how much dETH has been received from burning\n        dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this)) - dETHReceivedFromAllSavETHVaults;\n\n        // Send giant LP holder dETH owed\n        getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);\n    }\n```\nAs you can see first contract save the dETH balance of contract by this line: `uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));` and then it loops through user provided vaults addresses and call those vaults to withdraw dETH and in the end it calculates `dETHReceivedFromAllSavETHVaults` and transfer those dETH to user: ` getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);`. attacker can perform these steps:\n1- create a malicious contract `AttackerVault` which is copy of `SavETHVault` with modifiction.\n2- call `withdrawDETH()` with Vault list `[ValidVault1, ValidVault2, AttackerVault, ValidVaul3]`.\n3- contract would save the dETH balance of itself and then loops through Vaults to validate and burn LPTokens.\n4- contract would reach Vault `AttackerVault` and call attacker controlled address.\n5- attacker contract call other functions to increase dETH balance of contract (if it's not possible to increase dETH balance of contract by other way so there is no need to save contract initial balance of dETH before the loop and dETH balance of contract would be zero always)\n6- `withdrawDETH()` would finish the loop and transfer all the increase dETH balance to attacker which includes extra amounts.\n\nbecause contract don't check the provided addresses and calls them and there is no reentrancy defense mechanism there is possibility of reentrancy attack which can cause fund lose.\n\n## Tools Used\nVIM\n\n## Recommended Mitigation Steps\ncheck the provided addresses and also have some reentrancy defence mechanisim.",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
  "Code": [
    {
      "filename": "contracts/liquid-staking/GiantSavETHVaultPool.sol",
      "content": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { SavETHVault } from \"./SavETHVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\n\n/// @notice A giant pool that can provide protected deposit liquidity to any liquid staking network\ncontract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {\n\n    /// @notice Emitted when giant LP is burnt to receive dETH\n    event LPBurnedForDETH(address indexed savETHVaultLPToken, address indexed sender, uint256 amount);\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(0), \"GiantETHLP\", \"gETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Given the liquidity of the giant pool, stake ETH to receive protected deposits from many liquid staking networks (LSDNs)\n    /// @dev Take ETH from the contract balance in order to send money to the individual vaults\n    /// @param _savETHVaults List of savETH vaults that belong to individual liquid staking derivative networks\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeys For every savETH vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _stakeAmounts For every savETH vault, the amount of ETH each BLS key will receive in funding\n    function batchDepositETHForStaking(\n        address[] calldata _savETHVaults,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeys,\n        uint256[][] calldata _stakeAmounts\n    ) public {\n        uint256 numOfSavETHVaults = _savETHVaults.length;\n        require(numOfSavETHVaults > 0, \"Empty arrays\");\n        require(numOfSavETHVaults == _ETHTransactionAmounts.length, \"Inconsistent array lengths\");\n        require(numOfSavETHVaults == _blsPublicKeys.length, \"Inconsistent array lengths\");\n        require(numOfSavETHVaults == _stakeAmounts.length, \"Inconsistent array lengths\");\n\n        // For every vault specified, supply ETH for at least 1 BLS public key of a LSDN validator\n        for (uint256 i; i < numOfSavETHVaults; ++i) {\n            uint256 transactionAmount = _ETHTransactionAmounts[i];\n\n            // As ETH is being deployed to a savETH pool vault, it is no longer idle\n            idleETH -= transactionAmount;\n\n            SavETHVault savETHPool = SavETHVault(_savETHVaults[i]);\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            // Deposit ETH for staking of BLS key\n            savETHPool.batchDepositETHForStaking{ value: transactionAmount }(\n                _blsPublicKeys[i],\n                _stakeAmounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a user to burn their giant LP in exchange for dETH that is ready to withdraw from a set of savETH vaults\n    /// @param _savETHVaults List of savETH vaults being interacted with\n    /// @param _lpTokens List of savETH vault LP being burnt from the giant pool in exchange for dETH\n    /// @param _amounts Amounts of giant LP the user owns which is burnt 1:1 with savETH vault LP and in turn that will give a share of dETH\n    function withdrawDETH(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _savETHVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n\n        // Firstly capture current dETH balance and see how much has been deposited after the loop\n        uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));\n        for (uint256 i; i < numOfVaults; ++i) {\n            SavETHVault vault = SavETHVault(_savETHVaults[i]);\n\n            // Simultaneously check the status of LP tokens held by the vault and the giant LP balance of the user\n            for (uint256 j; j < _lpTokens[i].length; ++j) {\n                LPToken token = _lpTokens[i][j];\n                uint256 amount = _amounts[i][j];\n\n                // Check the user has enough giant LP to burn and that the pool has enough savETH vault LP\n                _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);\n\n                require(vault.isDETHReadyForWithdrawal(address(token)), \"dETH is not ready for withdrawal\");\n\n                // Giant LP is burned 1:1 with LPs from sub-networks\n                require(lpTokenETH.balanceOf(msg.sender) >= amount, \"User does not own enough LP\");\n\n                // Burn giant LP from user before sending them dETH\n                lpTokenETH.burn(msg.sender, amount);\n\n                emit LPBurnedForDETH(address(token), msg.sender, amount);\n            }\n\n            // Ask\n            vault.burnLPTokens(_lpTokens[i], _amounts[i]);\n        }\n\n        // Calculate how much dETH has been received from burning\n        dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this)) - dETHReceivedFromAllSavETHVaults;\n\n        // Send giant LP holder dETH owed\n        getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _savETHVaults List of savETH vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _savETHVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            SavETHVault(_savETHVaults[i]).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a savETH vault can be brought back into the giant pool\n    /// @param _savETHVaults List of savETH vaults where ETH is staked\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a savETH vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _savETHVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            SavETHVault vault = SavETHVault(_savETHVaults[i]);\n            for (uint256 j; j < _lpTokens[i].length; ++j) {\n                require(\n                    vault.isDETHReadyForWithdrawal(address(_lpTokens[i][j])) == false,\n                    \"ETH is either staked or derivatives minted\"\n                );\n            }\n\n            vault.burnLPTokens(_lpTokens[i], _amounts[i]);\n        }\n    }\n}"
    }
  ]
}