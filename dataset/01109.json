{
  "Title": "M-1: DoS of lenders and gas griefing by packing tokenIdToBorrowingKeys arrays",
  "Content": "# Issue M-1: DoS of lenders and gas griefing by packing tokenIdToBorrowingKeys arrays \n\nSource: https://github.com/sherlock-audit/2023-10-real-wagmi-judging/issues/15 \n\n## Found by \n0xDetermination\nIn `LiquidityBorrowingManager`, `tokenIdToBorrowingKeys` arrays can be packed to gas grief and cause DoS of specific loans for an arbitrary period of time.\n## Vulnerability Detail\n`LiquidityBorrowingManager.borrow()` calls the function `_addKeysAndLoansInfo()`, which adds user keys to the `tokenIdToBorrowingKeys` array of the borrowed-from LP position:\n```solidity\n    function _addKeysAndLoansInfo(\n        bool update,\n        bytes32 borrowingKey,\n        LoanInfo[] memory sourceLoans\n    ) private {\n        // Get the storage reference to the loans array for the borrowing key\n        LoanInfo[] storage loans = loansInfo[borrowingKey];\n        // Iterate through the sourceLoans array\n        for (uint256 i; i < sourceLoans.length; ) {\n            // Get the current loan from the sourceLoans array\n            LoanInfo memory loan = sourceLoans[i];\n            // Get the storage reference to the tokenIdLoansKeys array for the loan's token ID\n            bytes32[] storage tokenIdLoansKeys = tokenIdToBorrowingKeys[loan.tokenId];\n            // Conditionally add or push the borrowing key to the tokenIdLoansKeys array based on the 'update' flag\n            update\n                ? tokenIdLoansKeys.addKeyIfNotExists(borrowingKey)\n                : tokenIdLoansKeys.push(borrowingKey);\n    ...\n```\nA user key is calculated in the `Keys` library like so:\n```solidity\n    function computeBorrowingKey(\n        address borrower,\n        address saleToken,\n        address holdToken\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(borrower, saleToken, holdToken));\n    }\n```\nSo every time a new user borrows some amount from a LP token, a new `borrowKey` is added to the `tokenIdToBorrowingKeys[LP_Token_ID]` array. The problem is that this array is iterated through by calling iterating methods (`addKeyIfNotExists()` or `removeKey()`) in the `Keys` library when updating a borrow (as seen in the first code block). Furthermore, emergency repays call `removeKey()` in `_calculateEmergencyLoanClosure()`, non-emergency repays call `removeKey()` in `_removeKeysAndClearStorage()`, and `takeOverDebt()` calls `removeKey()` in `_removeKeysAndClearStorage()`. The result is that all exit/repay/liquidation methods must iterate through the array. Both of the iterating methods in the `Keys` library access storage to compare array values to the key passed as argument, so every key in the array before the argument key will increase the gas cost of the transaction by (more than) a cold `SLOAD`, which costs 2100 gas (https://eips.ethereum.org/EIPS/eip-2929). Library methods below:\n```solidity\n    function addKeyIfNotExists(bytes32[] storage self, bytes32 key) internal {\n        uint256 length = self.length;\n        for (uint256 i; i < length; ) {\n            if (self.unsafeAccess(i).value == key) {\n                return;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        self.push(key);\n    }\n\n    function removeKey(bytes32[] storage self, bytes32 key) internal {\n        uint256 length = self.length;\n        for (uint256 i; i < length; ) {\n            if (self.unsafeAccess(i).value == key) {\n                self.unsafeAccess(i).value = self.unsafeAccess(length - 1).value;\n                self.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n```\nLet's give an example to see the potential impact and cost of the attack:\n1. An LP provider authorizes the contract to give loans from their large position. Let's say USDC/WETH pool.\n2. The attacker sees this and takes out minimum borrows of USDC using different addresses to pack the position's `tokenIdToBorrowingKeys` array. In `Constants.sol`, `MINIMUM_BORROWED_AMOUNT = 100000` so the minimum borrow is $0.1 dollars since USDC has 6 decimal places. Add this to the estimated gas cost of the borrow transaction, let's say $3.9 dollars. The cost to add one key to the array is approx. $4. The max block gas limit on ethereum mainnet is `30,000,000`,  so divide that by 2000 gas, the approximate gas increase for one key added to the array. The result is 15,000, therefore the attacker can spend 60000 dollars to make any new borrows from the LP position unable to be repaid, transferred, or liquidated. Any new borrow will be stuck in the contract.\n3. The attacker now takes out a high leverage borrow on the LP position, for example $20,000 in collateral for a $1,000,000 borrow. The attacker's total expenditure is now $80,000, and the $1,000,000 from the LP is now locked in the contract for an arbitrary period of time.\n4. The attacker calls `increaseCollateralBalance()` on all of the spam positions. Default daily rate is .1% (max 1%), so over a year the attacker must pay 36.5% of each spam borrow amount to avoid liquidation and shortening of the array. If the gas cost of increasing collateral is $0.5 dollars, and the attacker spends another $0.5 dollars to increase collateral for each spam borrow, then the attacker can spend $1 on each spam borrow and keep them safe from liquidation for over 10 years for a cost of $15,000 dollars. The total attack expenditure is now $95,000. The protocol cannot easily increase the rate to hurt the attacker, because that would increase the rate for all users in the USDC/WETH market. Furthermore, the cost of the attack will not increase that much even if the daily rate is increased to the max of 1%. The attacker does not need to increase the collateral balance of the $1,000,000 borrow since repaying that borrow is DoSed. \n6. The result is that $1,000,000 of the loaner's liquidity is locked in the contract for over 10 years for an attack cost of $95,000.\n## Impact\nArray packing causes users to spend more gas on loans of the affected LP token. User transactions may out-of-gas revert due to increased gas costs. An attacker can lock liquidity from LPs in the contract for arbitrary periods of time for asymmetric cost favoring the attacker. The LP will earn very little fees over the period of the DoS.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-10-real-wagmi/blob/main/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L100-L101\nhttps://github.com/sherlock-audit/2023-10-real-wagmi/blob/main/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L790-L826\nhttps://github.com/sherlock-audit/2023-10-real-wagmi/blob/main/wagmi-leverage/contracts/libraries/Keys.sol\n## Tool used\nManual Review\n## Recommendation\n`tokenIdToBorrowingKeys` tracks borrowing keys and is used in view functions to return info (getLenderCreditsCount() and getLenderCreditsInfo()). This functionality is easier to implement with arrays, but it can be done with mappings to reduce gas costs and prevent gas griefing and DoS attacks. For example the protocol can emit the borrows for all LP tokens and keep track of them offchain, and pass borrow IDs in an array to a view function to look them up in the mapping. Alternatively, OpenZeppelin's EnumerableSet library could be used to replace the array and keep track of all the borrows on-chain.\n\n\n\n## Discussion\n\n**fann95**\n\nFixed: https://github.com/RealWagmi/wagmi-leverage/commit/cb4d91fdc632b1a4496932ec4546c7f4fa78e842\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/118",
  "Code": [
    {
      "filename": "wagmi-leverage/contracts/LiquidityBorrowingManager.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./abstract/LiquidityManager.sol\";\nimport \"./abstract/OwnerSettings.sol\";\nimport \"./abstract/DailyRateAndCollateral.sol\";\nimport \"./libraries/ErrLib.sol\";\n\n/**\n * @title LiquidityBorrowingManager\n * @dev This contract manages the borrowing liquidity functionality for WAGMI Leverage protocol.\n * It inherits from LiquidityManager, OwnerSettings, DailyRateAndCollateral, and ReentrancyGuard contracts.\n */\ncontract LiquidityBorrowingManager is\n    LiquidityManager,\n    OwnerSettings,\n    DailyRateAndCollateral,\n    ReentrancyGuard\n{\n    using { Keys.removeKey, Keys.addKeyIfNotExists } for bytes32[];\n    using { ErrLib.revertError } for bool;\n\n    /// @title BorrowParams\n    /// @notice This struct represents the parameters required for borrowing.\n    struct BorrowParams {\n        /// @notice The pool fee level for the internal swap\n        uint24 internalSwapPoolfee;\n        /// @notice The address of the token that will be sold to obtain the loan currency\n        address saleToken;\n        /// @notice The address of the token that will be held\n        address holdToken;\n        /// @notice The minimum amount of holdToken that must be obtained\n        uint256 minHoldTokenOut;\n        /// @notice The maximum amount of collateral that can be provided for the loan\n        uint256 maxCollateral;\n        /// @notice The SwapParams struct representing the external swap parameters\n        SwapParams externalSwap;\n        /// @notice An array of LoanInfo structs representing multiple loans\n        LoanInfo[] loans;\n    }\n    /// @title BorrowingInfo\n    /// @notice This struct represents the borrowing information for a borrower.\n    struct BorrowingInfo {\n        address borrower;\n        address saleToken;\n        address holdToken;\n        /// @notice The amount of fees owed by the creditor\n        uint256 feesOwed;\n        /// @notice The amount borrowed by the borrower\n        uint256 borrowedAmount;\n        /// @notice The amount of liquidation bonus\n        uint256 liquidationBonus;\n        /// @notice The accumulated loan rate per share\n        uint256 accLoanRatePerSeconds;\n        /// @notice The daily rate collateral balance multiplied by COLLATERAL_BALANCE_PRECISION\n        uint256 dailyRateCollateralBalance;\n    }\n    /// @notice This struct used for caching variables inside a function 'borrow'\n    struct BorrowCache {\n        uint256 dailyRateCollateral;\n        uint256 accLoanRatePerSeconds;\n        uint256 borrowedAmount;\n        uint256 holdTokenBalance;\n    }\n    /// @notice Struct representing the extended borrowing information.\n    struct BorrowingInfoExt {\n        /// @notice The main borrowing information.\n        BorrowingInfo info;\n        /// @notice An array of LoanInfo structs representing multiple loans\n        LoanInfo[] loans;\n        /// @notice The balance of the collateral.\n        int256 collateralBalance;\n        /// @notice The estimated lifetime of the loan.\n        uint256 estimatedLifeTime;\n        /// borrowing Key\n        bytes32 key;\n    }\n\n    /// @title RepayParams\n    /// @notice This struct represents the parameters required for repaying a loan.\n    struct RepayParams {\n        /// @notice The activation of the emergency liquidity restoration mode (available only to the lender)\n        bool isEmergency;\n        /// @notice The pool fee level for the internal swap\n        uint24 internalSwapPoolfee;\n        /// @notice The external swap parameters for the repayment transaction\n        SwapParams externalSwap;\n        /// @notice The unique borrowing key associated with the loan\n        bytes32 borrowingKey;\n        /// @notice The slippage allowance for the swap in basis points (1/10th of a percent)\n        uint256 swapSlippageBP1000;\n    }\n    /// borrowingKey=>LoanInfo\n    mapping(bytes32 => LoanInfo[]) public loansInfo;\n    /// borrowingKey=>BorrowingInfo\n    mapping(bytes32 => BorrowingInfo) public borrowingsInfo;\n    /// borrower => BorrowingKeys[]\n    mapping(address => bytes32[]) public userBorrowingKeys;\n    /// NonfungiblePositionManager tokenId => BorrowingKeys[]\n    mapping(uint256 => bytes32[]) public tokenIdToBorrowingKeys;\n\n    ///  token => FeesAmt\n    mapping(address => uint256) private platformsFeesInfo;\n\n    /// Indicates that a borrower has made a new loan\n    event Borrow(\n        address borrower,\n        bytes32 borrowingKey,\n        uint256 borrowedAmount,\n        uint256 borrowingCollateral,\n        uint256 liquidationBonus,\n        uint256 dailyRatePrepayment\n    );\n    /// Indicates that a borrower has repaid their loan, optionally with the help of a liquidator\n    event Repay(address borrower, address liquidator, bytes32 borrowingKey);\n    /// Indicates that a loan has been closed due to an emergency situation\n    event EmergencyLoanClosure(address borrower, address lender, bytes32 borrowingKey);\n    /// Indicates that the protocol has collected fee tokens\n    event CollectProtocol(address recipient, address[] tokens, uint256[] amounts);\n    /// Indicates that the daily interest rate for holding token(for specific pair) has been updated\n    event UpdateHoldTokenDailyRate(address saleToken, address holdToken, uint256 value);\n    /// Indicates that a borrower has increased their collateral balance for a loan\n    event IncreaseCollateralBalance(address borrower, bytes32 borrowingKey, uint256 collateralAmt);\n    /// Indicates that a new borrower has taken over the debt from an old borrower\n    event TakeOverDebt(\n        address oldBorrower,\n        address newBorrower,\n        bytes32 oldBorrowingKey,\n        bytes32 newBorrowingKey\n    );\n\n    error TooLittleReceivedError(uint256 minOut, uint256 out);\n\n    /// @dev Modifier to check if the current block timestamp is before or equal to the deadline.\n    modifier checkDeadline(uint256 deadline) {\n        (_blockTimestamp() > deadline).revertError(ErrLib.ErrorCode.TOO_OLD_TRANSACTION);\n        _;\n    }\n\n    function _blockTimestamp() internal view returns (uint256) {\n        return block.timestamp;\n    }\n\n    constructor(\n        address _underlyingPositionManagerAddress,\n        address _underlyingQuoterV2,\n        address _underlyingV3Factory,\n        bytes32 _underlyingV3PoolInitCodeHash\n    )\n        LiquidityManager(\n            _underlyingPositionManagerAddress,\n            _underlyingQuoterV2,\n            _underlyingV3Factory,\n            _underlyingV3PoolInitCodeHash\n        )\n    {}\n\n    /**\n     * @dev Adds or removes a swap call params to the whitelist.\n     * @param swapTarget The address of the target contract for the swap call.\n     * @param funcSelector The function selector of the swap call.\n     * @param isAllowed A boolean indicating whether the swap call is allowed or not.\n     */\n    function setSwapCallToWhitelist(\n        address swapTarget,\n        bytes4 funcSelector,\n        bool isAllowed\n    ) external onlyOwner {\n        (swapTarget == VAULT_ADDRESS ||\n            swapTarget == address(this) ||\n            swapTarget == address(underlyingPositionManager) ||\n            funcSelector == IERC20.transferFrom.selector).revertError(ErrLib.ErrorCode.FORBIDDEN);\n        whitelistedCall[swapTarget][funcSelector] = isAllowed;\n    }\n\n    /**\n     * @notice This function allows the owner to collect protocol fees for multiple tokens\n     * and transfer them to a specified recipient.\n     * @dev Only the contract owner can call this function.\n     * @param recipient The address of the recipient who will receive the collected fees.\n     * @param tokens An array of addresses representing the tokens for which fees will be collected.\n     */\n    function collectProtocol(address recipient, address[] calldata tokens) external onlyOwner {\n        uint256[] memory amounts = new uint256[](tokens.length);\n        for (uint256 i; i < tokens.length; ) {\n            address token = tokens[i];\n            uint256 amount = platformsFeesInfo[token] / Constants.COLLATERAL_BALANCE_PRECISION;\n            if (amount > 0) {\n                platformsFeesInfo[token] = 0;\n                amounts[i] = amount;\n                Vault(VAULT_ADDRESS).transferToken(token, recipient, amount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit CollectProtocol(recipient, tokens, amounts);\n    }\n\n    /**\n     * @notice This function is used to update the daily rate for holding token for specific pair.\n     * @dev Only the daily rate operator can call this function.\n     * @param saleToken The address of the sale token.\n     * @param holdToken The address of the hold token.\n     * @param value The new value of the daily rate for the hold token will be calculated based\n     * on the volatility of the pair and the popularity of loans in it\n     * @dev The value must be within the range of MIN_DAILY_RATE and MAX_DAILY_RATE.\n     */\n    function updateHoldTokenDailyRate(\n        address saleToken,\n        address holdToken,\n        uint256 value\n    ) external {\n        (msg.sender != dailyRateOperator).revertError(ErrLib.ErrorCode.INVALID_CALLER);\n        if (value > Constants.MAX_DAILY_RATE || value < Constants.MIN_DAILY_RATE) {\n            revert InvalidSettingsValue(value);\n        }\n        // If the value is within the acceptable range, the function updates the currentDailyRate property\n        // of the holdTokenRateInfo structure associated with the token pair.\n        (, TokenInfo storage holdTokenRateInfo) = _updateTokenRateInfo(saleToken, holdToken);\n        holdTokenRateInfo.currentDailyRate = value;\n        emit UpdateHoldTokenDailyRate(saleToken, holdToken, value);\n    }\n\n    /**\n     * @notice This function is used to check the daily rate collateral for a specific borrowing.\n     * @param borrowingKey The key of the borrowing.\n     * @return balance The balance of the daily rate collateral.\n     * @return estimatedLifeTime The estimated lifetime of the collateral in seconds.\n     */\n    function checkDailyRateCollateral(\n        bytes32 borrowingKey\n    ) external view returns (int256 balance, uint256 estimatedLifeTime) {\n        (, balance, estimatedLifeTime) = _getDebtInfo(borrowingKey);\n        balance /= int256(Constants.COLLATERAL_BALANCE_PRECISION);\n    }\n\n    /**\n     * @notice Get information about loans associated with a borrowing key\n     * @dev This function retrieves an array of loan information for a given borrowing key.\n     * The loans are stored in the loansInfo mapping, which is a mapping of borrowing keys to LoanInfo arrays.\n     * @param borrowingKey The unique key associated with the borrowing\n     * @return loans An array containing LoanInfo structs representing the loans associated with the borrowing key\n     */\n    function getLoansInfo(bytes32 borrowingKey) external view returns (LoanInfo[] memory loans) {\n        loans = loansInfo[borrowingKey];\n    }\n\n    /**\n     * @notice Retrieves the borrowing information for a specific NonfungiblePositionManager tokenId.\n     * @param tokenId The unique identifier of the PositionManager token.\n     * @return extinfo An array of BorrowingInfoExt structs representing the borrowing information.\n     */\n    function getLenderCreditsInfo(\n        uint256 tokenId\n    ) external view returns (BorrowingInfoExt[] memory extinfo) {\n        bytes32[] memory borrowingKeys = tokenIdToBorrowingKeys[tokenId];\n        extinfo = _getDebtsInfo(borrowingKeys);\n    }\n\n    /**\n     * @notice Retrieves the debts information for a specific borrower.\n     * @param borrower The address of the borrower.\n     * @return extinfo An array of BorrowingInfoExt structs representing the borrowing information.\n     */\n    function getBorrowerDebtsInfo(\n        address borrower\n    ) external view returns (BorrowingInfoExt[] memory extinfo) {\n        bytes32[] memory borrowingKeys = userBorrowingKeys[borrower];\n        extinfo = _getDebtsInfo(borrowingKeys);\n    }\n\n    /**\n     * @dev Returns the number of loans associated with a given NonfungiblePositionManager tokenId.\n     * @param tokenId The ID of the token.\n     * @return count The total number of loans associated with the tokenId.\n     */\n    function getLenderCreditsCount(uint256 tokenId) external view returns (uint256 count) {\n        bytes32[] memory borrowingKeys = tokenIdToBorrowingKeys[tokenId];\n        count = borrowingKeys.length;\n    }\n\n    /**\n     * @dev Returns the number of borrowings for a given borrower.\n     * @param borrower The address of the borrower.\n     * @return count The total number of borrowings for the borrower.\n     */\n    function getBorrowerDebtsCount(address borrower) external view returns (uint256 count) {\n        bytes32[] memory borrowingKeys = userBorrowingKeys[borrower];\n        count = borrowingKeys.length;\n    }\n\n    /**\n     * @dev Returns the current daily rate for holding token.\n     * @param saleToken The address of the token being sold.\n     * @param holdToken The address of the token being held.\n     * @return currentDailyRate The current daily rate .\n     */\n    function getHoldTokenDailyRateInfo(\n        address saleToken,\n        address holdToken\n    ) external view returns (uint256 currentDailyRate, TokenInfo memory holdTokenRateInfo) {\n        (currentDailyRate, holdTokenRateInfo) = _getHoldTokenRateInfo(saleToken, holdToken);\n    }\n\n    /**\n     * @dev Returns the fees information for multiple tokens in an array.\n     * @param tokens An array of token addresses for which the fees are to be retrieved.\n     * @return fees An array containing the fees for each token.\n     */\n    function getPlatformsFeesInfo(\n        address[] calldata tokens\n    ) external view returns (uint256[] memory fees) {\n        fees = new uint256[](tokens.length);\n        for (uint256 i; i < tokens.length; ) {\n            address token = tokens[i];\n            uint256 amount = platformsFeesInfo[token] / Constants.COLLATERAL_BALANCE_PRECISION;\n            fees[i] = amount;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Calculates the collateral amount required for a lifetime in seconds.\n     *\n     * @param borrowingKey The unique identifier of the borrowing.\n     * @param lifetimeInSeconds The duration of the borrowing in seconds.\n     * @return collateralAmt The calculated collateral amount that is needed.\n     */\n    function calculateCollateralAmtForLifetime(\n        bytes32 borrowingKey,\n        uint256 lifetimeInSeconds\n    ) external view returns (uint256 collateralAmt) {\n        // Retrieve the BorrowingInfo struct associated with the borrowing key\n        BorrowingInfo memory borrowing = borrowingsInfo[borrowingKey];\n        // Check if the borrowed position is existing\n        if (borrowing.borrowedAmount > 0) {\n            // Get the current daily rate for the hold token\n            (uint256 currentDailyRate, ) = _getHoldTokenRateInfo(\n                borrowing.saleToken,\n                borrowing.holdToken\n            );\n            // Calculate the collateral amount per second\n            uint256 everySecond = (\n                FullMath.mulDivRoundingUp(\n                    borrowing.borrowedAmount,\n                    currentDailyRate * Constants.COLLATERAL_BALANCE_PRECISION,\n                    1 days * Constants.BP\n                )\n            );\n            // Calculate the total collateral amount for the borrowing lifetime\n            collateralAmt = FullMath.mulDivRoundingUp(\n                everySecond,\n                lifetimeInSeconds,\n                Constants.COLLATERAL_BALANCE_PRECISION\n            );\n            // Ensure that the collateral amount is at least 1\n            if (collateralAmt == 0) collateralAmt = 1;\n        }\n    }\n\n    /**\n     * @notice This function is used to increase the daily rate collateral for a specific borrowing.\n     * @param borrowingKey The unique identifier of the borrowing.\n     * @param collateralAmt The amount of collateral to be added.\n     */\n    function increaseCollateralBalance(bytes32 borrowingKey, uint256 collateralAmt) external {\n        BorrowingInfo storage borrowing = borrowingsInfo[borrowingKey];\n        // Ensure that the borrowed position exists and the borrower is the message sender\n        (borrowing.borrowedAmount == 0 || borrowing.borrower != address(msg.sender)).revertError(\n            ErrLib.ErrorCode.INVALID_BORROWING_KEY\n        );\n        // Increase the daily rate collateral balance by the specified collateral amount\n        borrowing.dailyRateCollateralBalance +=\n            collateralAmt *\n            Constants.COLLATERAL_BALANCE_PRECISION;\n        _pay(borrowing.holdToken, msg.sender, VAULT_ADDRESS, collateralAmt);\n        emit IncreaseCollateralBalance(msg.sender, borrowingKey, collateralAmt);\n    }\n\n    /**\n     * @notice Take over debt by transferring ownership of a borrowing to the current caller\n     * @dev This function allows the current caller to take over a debt from another borrower.\n     * The function validates the borrowingKey and checks if the collateral balance is negative.\n     * If the conditions are met, the function transfers ownership of the borrowing to the current caller,\n     * updates the daily rate collateral balance, and pays the collateral amount to the vault.\n     * Emits a `TakeOverDebt` event.\n     * @param borrowingKey The unique key associated with the borrowing to be taken over\n     * @param collateralAmt The amount of collateral to be provided by the new borrower\n     */\n    function takeOverDebt(bytes32 borrowingKey, uint256 collateralAmt) external {\n        BorrowingInfo memory oldBorrowing = borrowingsInfo[borrowingKey];\n        // Ensure that the borrowed position exists\n        (oldBorrowing.borrowedAmount == 0).revertError(ErrLib.ErrorCode.INVALID_BORROWING_KEY);\n\n        uint256 accLoanRatePerSeconds;\n        uint256 minPayment;\n        {\n            // Update token rate info and retrieve the accumulated loan rate per second for holdToken\n            (, TokenInfo storage holdTokenRateInfo) = _updateTokenRateInfo(\n                oldBorrowing.saleToken,\n                oldBorrowing.holdToken\n            );\n            accLoanRatePerSeconds = holdTokenRateInfo.accLoanRatePerSeconds;\n            // Calculate the collateral balance and current fees for the oldBorrowing\n            (int256 collateralBalance, uint256 currentFees) = _calculateCollateralBalance(\n                oldBorrowing.borrowedAmount,\n                oldBorrowing.accLoanRatePerSeconds,\n                oldBorrowing.dailyRateCollateralBalance,\n                accLoanRatePerSeconds\n            );\n            // Ensure that the collateral balance is greater than or equal to 0\n            (collateralBalance >= 0).revertError(ErrLib.ErrorCode.FORBIDDEN);\n            // Pick up platform fees from the oldBorrowing's holdToken and add them to the feesOwed\n            currentFees = _pickUpPlatformFees(oldBorrowing.holdToken, currentFees);\n            oldBorrowing.feesOwed += currentFees;\n            // Calculate the minimum payment required based on the collateral balance\n            minPayment = (uint256(-collateralBalance) / Constants.COLLATERAL_BALANCE_PRECISION) + 1;\n            (collateralAmt <= minPayment).revertError(\n                ErrLib.ErrorCode.COLLATERAL_AMOUNT_IS_NOT_ENOUGH\n            );\n        }\n        // Retrieve the old loans associated with the borrowing key and remove them from storage\n        LoanInfo[] memory oldLoans = loansInfo[borrowingKey];\n        _removeKeysAndClearStorage(oldBorrowing.borrower, borrowingKey, oldLoans);\n        // Initialize a new borrowing using the same saleToken, holdToken\n        (\n            uint256 feesDebt,\n            bytes32 newBorrowingKey,\n            BorrowingInfo storage newBorrowing\n        ) = _initOrUpdateBorrowing(\n                oldBorrowing.saleToken,\n                oldBorrowing.holdToken,\n                accLoanRatePerSeconds\n            );\n        // Add the new borrowing key and old loans to the newBorrowing\n        _addKeysAndLoansInfo(newBorrowing.borrowedAmount > 0, borrowingKey, oldLoans);\n        // Increase the borrowed amount, liquidation bonus, and fees owed of the newBorrowing based on the oldBorrowing\n        newBorrowing.borrowedAmount += oldBorrowing.borrowedAmount;\n        newBorrowing.liquidationBonus += oldBorrowing.liquidationBonus;\n        newBorrowing.feesOwed += oldBorrowing.feesOwed;\n        // oldBorrowing.dailyRateCollateralBalance is 0\n        newBorrowing.dailyRateCollateralBalance +=\n            (collateralAmt - minPayment) *\n            Constants.COLLATERAL_BALANCE_PRECISION;\n        //newBorrowing.accLoanRatePerSeconds = oldBorrowing.accLoanRatePerSeconds;\n        _pay(oldBorrowing.holdToken, msg.sender, VAULT_ADDRESS, collateralAmt + feesDebt);\n        emit TakeOverDebt(oldBorrowing.borrower, msg.sender, borrowingKey, newBorrowingKey);\n    }\n\n    /**\n     * @notice Borrow function allows a user to borrow tokens by providing collateral and taking out loans.\n     * The trader opens a long position by borrowing the liquidity of Uniswap V3 and extracting it into a pair of tokens,\n     * one of which will be swapped into a desired(holdToken).The tokens will be kept in storage until the position is closed.\n     * The margin is calculated on the basis that liquidity must be restored with any price movement.\n     * The time the position is held is paid by the trader.\n     * @dev Emits a Borrow event upon successful borrowing.\n     * @param params The BorrowParams struct containing the necessary parameters for borrowing.\n     * @param deadline The deadline timestamp after which the transaction is considered invalid.\n     */\n    function borrow(\n        BorrowParams calldata params,\n        uint256 deadline\n    ) external nonReentrant checkDeadline(deadline) {\n        // Precalculating borrowing details and storing them in cache\n        BorrowCache memory cache = _precalculateBorrowing(params);\n        // Initializing borrowing variables and obtaining borrowing key\n        (\n            uint256 feesDebt,\n            bytes32 borrowingKey,\n            BorrowingInfo storage borrowing\n        ) = _initOrUpdateBorrowing(params.saleToken, params.holdToken, cache.accLoanRatePerSeconds);\n        // Adding borrowing key and loans information to storage\n        _addKeysAndLoansInfo(borrowing.borrowedAmount > 0, borrowingKey, params.loans);\n        // Calculating liquidation bonus based on hold token, borrowed amount, and number of used loans\n        uint256 liquidationBonus = getLiquidationBonus(\n            params.holdToken,\n            cache.borrowedAmount,\n            params.loans.length\n        );\n        // Updating borrowing details\n        borrowing.borrowedAmount += cache.borrowedAmount;\n        borrowing.liquidationBonus += liquidationBonus;\n        borrowing.dailyRateCollateralBalance +=\n            cache.dailyRateCollateral *\n            Constants.COLLATERAL_BALANCE_PRECISION;\n        // Checking if borrowing collateral exceeds the maximum allowed collateral\n        uint256 borrowingCollateral = cache.borrowedAmount - cache.holdTokenBalance;\n        (borrowingCollateral > params.maxCollateral).revertError(\n            ErrLib.ErrorCode.TOO_BIG_COLLATERAL\n        );\n\n        // Transfer the required tokens to the VAULT_ADDRESS for collateral and holdTokenBalance\n        _pay(\n            params.holdToken,\n            msg.sender,\n            VAULT_ADDRESS,\n            borrowingCollateral + liquidationBonus + cache.dailyRateCollateral + feesDebt\n        );\n        // Transferring holdTokenBalance to VAULT_ADDRESS\n        _pay(params.holdToken, address(this), VAULT_ADDRESS, cache.holdTokenBalance);\n        // Emit the Borrow event with the borrower, borrowing key, and borrowed amount\n        emit Borrow(\n            msg.sender,\n            borrowingKey,\n            cache.borrowedAmount,\n            borrowingCollateral,\n            liquidationBonus,\n            cache.dailyRateCollateral\n        );\n    }\n\n    /**\n     * @notice This function is used to repay a loan.\n     * The position is closed either by the trader or by the liquidator if the trader has not paid for holding the position\n     * and the moment of liquidation has arrived.The positions borrowed from liquidation providers are restored from the held\n     * token and the remainder is sent to the caller.In the event of liquidation, the liquidity provider\n     * whose liquidity is present in the traderâ€™s position can use the emergency mode and withdraw their liquidity.In this case,\n     * he will receive hold tokens and liquidity will not be restored in the uniswap pool.\n     * @param params The repayment parameters including\n     *  activation of the emergency liquidity restoration mode (available only to the lender)\n     *  internal swap pool fee,\n     *  external swap parameters,\n     *  borrowing key,\n     *  swap slippage allowance.\n     * @param deadline The deadline by which the repayment must be made.\n     */\n    function repay(\n        RepayParams calldata params,\n        uint256 deadline\n    ) external nonReentrant checkDeadline(deadline) {\n        BorrowingInfo memory borrowing = borrowingsInfo[params.borrowingKey];\n        // Check if the borrowing key is valid\n        (borrowing.borrowedAmount == 0).revertError(ErrLib.ErrorCode.INVALID_BORROWING_KEY);\n\n        bool zeroForSaleToken = borrowing.saleToken < borrowing.holdToken;\n        uint256 liquidationBonus = borrowing.liquidationBonus;\n        int256 collateralBalance;\n        // Update token rate information and get holdTokenRateInfo storage reference\n        (, TokenInfo storage holdTokenRateInfo) = _updateTokenRateInfo(\n            borrowing.saleToken,\n            borrowing.holdToken\n        );\n        {\n            // Calculate collateral balance and validate caller\n            uint256 accLoanRatePerSeconds = holdTokenRateInfo.accLoanRatePerSeconds;\n            uint256 currentFees;\n            (collateralBalance, currentFees) = _calculateCollateralBalance(\n                borrowing.borrowedAmount,\n                borrowing.accLoanRatePerSeconds,\n                borrowing.dailyRateCollateralBalance,\n                accLoanRatePerSeconds\n            );\n\n            (msg.sender != borrowing.borrower && collateralBalance >= 0).revertError(\n                ErrLib.ErrorCode.INVALID_CALLER\n            );\n\n            // Calculate liquidation bonus and adjust fees owed\n\n            if (\n                collateralBalance > 0 &&\n                (currentFees + borrowing.feesOwed) / Constants.COLLATERAL_BALANCE_PRECISION >\n                Constants.MINIMUM_AMOUNT\n            ) {\n                liquidationBonus +=\n                    uint256(collateralBalance) /\n                    Constants.COLLATERAL_BALANCE_PRECISION;\n            } else {\n                currentFees = borrowing.dailyRateCollateralBalance;\n            }\n\n            // Calculate platform fees and adjust fees owed\n            borrowing.feesOwed += _pickUpPlatformFees(borrowing.holdToken, currentFees);\n        }\n        // Check if it's an emergency repayment\n        if (params.isEmergency) {\n            (collateralBalance >= 0).revertError(ErrLib.ErrorCode.FORBIDDEN);\n            (\n                uint256 removedAmt,\n                uint256 feesAmt,\n                bool completeRepayment\n            ) = _calculateEmergencyLoanClosure(\n                    zeroForSaleToken,\n                    params.borrowingKey,\n                    borrowing.feesOwed,\n                    borrowing.borrowedAmount\n                );\n            (removedAmt == 0).revertError(ErrLib.ErrorCode.LIQUIDITY_IS_ZERO);\n            // prevent overspent\n            // Subtract the removed amount and fees from borrowedAmount and feesOwed\n            borrowing.borrowedAmount -= removedAmt;\n            borrowing.feesOwed -= feesAmt;\n            feesAmt /= Constants.COLLATERAL_BALANCE_PRECISION;\n            // Deduct the removed amount from totalBorrowed\n            holdTokenRateInfo.totalBorrowed -= removedAmt;\n            // If loansInfoLength is 0, remove the borrowing key from storage and get the liquidation bonus\n            if (completeRepayment) {\n                LoanInfo[] memory empty;\n                _removeKeysAndClearStorage(borrowing.borrower, params.borrowingKey, empty);\n                feesAmt += liquidationBonus;\n            } else {\n                BorrowingInfo storage borrowingStorage = borrowingsInfo[params.borrowingKey];\n                borrowingStorage.dailyRateCollateralBalance = 0;\n                borrowingStorage.feesOwed = borrowing.feesOwed;\n                borrowingStorage.borrowedAmount = borrowing.borrowedAmount;\n                // Calculate the updated accLoanRatePerSeconds\n                borrowingStorage.accLoanRatePerSeconds =\n                    holdTokenRateInfo.accLoanRatePerSeconds -\n                    FullMath.mulDiv(\n                        uint256(-collateralBalance),\n                        Constants.BP,\n                        borrowing.borrowedAmount // new amount\n                    );\n            }\n            // Transfer removedAmt + feesAmt to msg.sender and emit EmergencyLoanClosure event\n            Vault(VAULT_ADDRESS).transferToken(\n                borrowing.holdToken,\n                msg.sender,\n                removedAmt + feesAmt\n            );\n            emit EmergencyLoanClosure(borrowing.borrower, msg.sender, params.borrowingKey);\n        } else {\n            // Deduct borrowedAmount from totalBorrowed\n            holdTokenRateInfo.totalBorrowed -= borrowing.borrowedAmount;\n\n            // Transfer the borrowed amount and liquidation bonus from the VAULT to this contract\n            Vault(VAULT_ADDRESS).transferToken(\n                borrowing.holdToken,\n                address(this),\n                borrowing.borrowedAmount + liquidationBonus\n            );\n            // Restore liquidity using the borrowed amount and pay a daily rate fee\n            LoanInfo[] memory loans = loansInfo[params.borrowingKey];\n            _maxApproveIfNecessary(\n                borrowing.holdToken,\n                address(underlyingPositionManager),\n                type(uint128).max\n            );\n            _maxApproveIfNecessary(\n                borrowing.saleToken,\n                address(underlyingPositionManager),\n                type(uint128).max\n            );\n\n            _restoreLiquidity(\n                RestoreLiquidityParams({\n                    zeroForSaleToken: zeroForSaleToken,\n                    fee: params.internalSwapPoolfee,\n                    slippageBP1000: params.swapSlippageBP1000,\n                    totalfeesOwed: borrowing.feesOwed,\n                    totalBorrowedAmount: borrowing.borrowedAmount\n                }),\n                params.externalSwap,\n                loans\n            );\n            // Get the remaining balance of saleToken and holdToken\n            (uint256 saleTokenBalance, uint256 holdTokenBalance) = _getPairBalance(\n                borrowing.saleToken,\n                borrowing.holdToken\n            );\n            // Remove borrowing key from related data structures\n            _removeKeysAndClearStorage(borrowing.borrower, params.borrowingKey, loans);\n            // Pay a profit to a msg.sender\n            _pay(borrowing.holdToken, address(this), msg.sender, holdTokenBalance);\n            _pay(borrowing.saleToken, address(this), msg.sender, saleTokenBalance);\n\n            emit Repay(borrowing.borrower, msg.sender, params.borrowingKey);\n        }\n    }\n\n    /**\n     * @dev Calculates the liquidation bonus for a given token, borrowed amount, and times factor.\n     * @param token The address of the token.\n     * @param borrowedAmount The amount of tokens borrowed.\n     * @param times The times factor to apply to the liquidation bonus calculation.\n     * @return liquidationBonus The calculated liquidation bonus.\n     */\n    function getLiquidationBonus(\n        address token,\n        uint256 borrowedAmount,\n        uint256 times\n    ) public view returns (uint256 liquidationBonus) {\n        // Retrieve liquidation bonus for the given token\n        Liquidation memory liq = liquidationBonusForToken[token];\n\n        if (liq.bonusBP == 0) {\n            // If there is no specific bonus for the token\n            // Use default bonus\n            liq.minBonusAmount = Constants.MINIMUM_AMOUNT;\n            liq.bonusBP = dafaultLiquidationBonusBP;\n        }\n        liquidationBonus = (borrowedAmount * liq.bonusBP) / Constants.BP;\n\n        if (liquidationBonus < liq.minBonusAmount) {\n            liquidationBonus = liq.minBonusAmount;\n        }\n        l"
    }
  ]
}