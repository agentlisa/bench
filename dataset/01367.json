{
  "Title": "The deposit function is not following CEI pattern",
  "Content": "**Severity:** Low\n\n**Description:** The protocol implemented a function `deposit()` to allow users to deposit.\n```solidity\nDepositVault.sol\n37:     function deposit(uint256 amount, address tokenAddress) public payable {\n38:         require(amount > 0 || msg.value > 0, \"Deposit amount must be greater than 0\");\n39:         if(msg.value > 0) {\n40:             require(tokenAddress == address(0), \"Token address must be 0x0 for ETH deposits\");\n41:             uint256 depositIndex = deposits.length;\n42:             deposits.push(Deposit(payable(msg.sender), msg.value, tokenAddress));\n43:             emit DepositMade(msg.sender, depositIndex, msg.value, tokenAddress);\n44:         } else {\n45:             require(tokenAddress != address(0), \"Token address must not be 0x0 for token deposits\");\n46:             IERC20 token = IERC20(tokenAddress);\n47:             token.safeTransferFrom(msg.sender, address(this), amount);//@audit-issue against CEI pattern\n48:             uint256 depositIndex = deposits.length;\n49:             deposits.push(Deposit(payable(msg.sender), amount, tokenAddress));\n50:             emit DepositMade(msg.sender, depositIndex, amount, tokenAddress);\n51:\n52:         }\n53:     }\n```\nLooking at the line L47, we can see that the token transfer happens before updating the accounting state of the protocol against the CEI pattern.\nBecause the protocol intends to support all ERC20 tokens, the tokens with hooks (e.g. ERC777) can be exploited for reentrancy.\nAlthough we can not verify an exploit that causes explicit loss due to this, it is still highly recommended to follow CEI pattern to prevent possible reentrancy attack.\n\n**Recommended Mitigation:** Handle token transfers after updating the `deposits` state.\n\n**Protocol:**\nFixed in commit [7726ae7](https://github.com/HyperGood/woosh-contracts/commit/7726ae72118cfdf91ceb9129e36662f69f4d42de).\n\n**Cyfrin:** We note that the protocol still does not follow CEI pattern in the final commit [b21d23e](https://github.com/HyperGood/woosh-contracts/commit/b21d23e661b0f25f0e757dc00ee90e4464730b1b).\nBut we also acknowledge that the fix in [405fa78](https://github.com/HyperGood/woosh-contracts/commit/405fa78a2c0cf8b8ab8943484cb95b5c8807cbfb) to support non-standard ERC20 tokens makes it impossible to follow CEI pattern.\nFor the current implementation, we verified that there is no reentrancy attack vector due to this issue. If the protocol intends any upgrades in the future related to the `deposits` state, we recommend using [OpenZeppelin's ReentrancyGuard](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/8a0b7bed82d6b8053872c3fd40703efd58f5699d/contracts/security/ReentrancyGuard.sol#L22) to prevent possible reentrancy attack.\nPlease note that the lack of CEI pattern will still be problematic in the sense of [Read-only reentrancy](https://officercia.mirror.xyz/DBzFiDuxmDOTQEbfXhvLdK0DXVpKu1Nkurk0Cqk3QKc) if the states `deposits` are going to be utilized for any other purposes.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/security/ReentrancyGuard.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}"
    }
  ]
}