{
  "Title": "[M03] Unregistered parties",
  "Content": "The `Registry` contract [tracks the parties](https://github.com/UMAprotocol/protocol/blob/e6eaa48124ae3f209fb117cf05eb18292cf26d21/core/contracts/oracle/implementation/Registry.sol#L49) associated with each registered financial contract. It provides mechanisms for financial contracts to [initialize](https://github.com/UMAprotocol/protocol/blob/e6eaa48124ae3f209fb117cf05eb18292cf26d21/core/contracts/oracle/implementation/Registry.sol#L80), [add](https://github.com/UMAprotocol/protocol/blob/e6eaa48124ae3f209fb117cf05eb18292cf26d21/core/contracts/oracle/implementation/Registry.sol#L112), [remove](https://github.com/UMAprotocol/protocol/blob/e6eaa48124ae3f209fb117cf05eb18292cf26d21/core/contracts/oracle/implementation/Registry.sol#L133) and [query](https://github.com/UMAprotocol/protocol/blob/e6eaa48124ae3f209fb117cf05eb18292cf26d21/core/contracts/oracle/implementation/Registry.sol#L206) the party members.\n\n\nHowever, the [`ExpiringMultiParty` contract](https://github.com/UMAprotocol/protocol/blob/e6eaa48124ae3f209fb117cf05eb18292cf26d21/core/contracts/financial-templates/implementation/ExpiringMultiParty.sol) does not inform the registry when its parties change. In fact, the `ExpiringMultiPartyCreator` [sets the initial party member](https://github.com/UMAprotocol/protocol/blob/e6eaa48124ae3f209fb117cf05eb18292cf26d21/core/contracts/financial-templates/implementation/ExpiringMultiPartyCreator.sol#L113-L116) to the address that triggers the deployment, whether or not that address is a party to the financial contract.\n\n\nConsider updating the `Registry` contract whenever the `ExpiringMultiParty` contractâ€™s participants change.\n\n\n**Update:** *Fixed in [PR#1353](https://github.com/UMAprotocol/protocol/pull/1353). The participants are no longer tracked in the `Registry` contract. Note that the party-related functions still exist in the `Registry`, but they do not apply to `ExpiringMultiParty` contracts.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "core/contracts/oracle/implementation/Registry.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../common/implementation/MultiRole.sol\";\nimport \"../interfaces/RegistryInterface.sol\";\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\n/**\n * @title Registry for financial contracts and approved financial contract creators.\n * @dev Maintains a whitelist of financial contract creators that are allowed\n * to register new financial contracts and stores party members of a financial contract.\n */\ncontract Registry is RegistryInterface, MultiRole {\n    using SafeMath for uint;\n\n    /****************************************\n     *    INTERNAL VARIABLES AND STORAGE    *\n     ****************************************/\n\n    enum Roles {\n        Owner, // The owner manages the set of ContractCreators.\n        ContractCreator // Can register financial contracts.\n    }\n\n    // This enum is required because a WasValid state is required to ensure that financial contracts cannot be re-registered.\n    enum Validity { Invalid, Valid }\n\n    // Local information about a contract.\n    struct FinancialContract {\n        Validity valid;\n        uint128 index;\n    }\n\n    struct Party {\n        address[] contracts; // Each financial contract address is stored in this array.\n        // The index of each financial contract is mapped to it's address for constant time look up and deletion.\n        mapping(address => uint) contractIndex;\n    }\n\n    // Array of all contracts that are approved to use the UMA Oracle.\n    address[] public registeredContracts;\n\n    // Map of financial contract contracts to the associated FinancialContract struct.\n    mapping(address => FinancialContract) public contractMap;\n\n    // Map each party member to their associated FinancialContract struct.\n    mapping(address => Party) private partyMap;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event NewContractRegistered(address indexed contractAddress, address indexed creator, address[] parties);\n    event PartyAdded(address indexed contractAddress, address indexed party);\n    event PartyRemoved(address indexed contractAddress, address indexed party);\n\n    /**\n     * @notice Construct the Registry contract.\n     */\n    constructor() public {\n        _createExclusiveRole(uint(Roles.Owner), uint(Roles.Owner), msg.sender);\n        // Start with no contract creators registered.\n        _createSharedRole(uint(Roles.ContractCreator), uint(Roles.Owner), new address[](0));\n    }\n\n    /****************************************\n     *        REGISTRATION FUNCTIONS        *\n     ****************************************/\n\n    /**\n     * @notice Registers a new financial contract.\n     * @dev Only authorized contract creators can call this method.\n     * @param parties an array of addresses who become parties in the contract.\n     * @param contractAddress defines the address of the deployed finan.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function registerContract(address[] calldata parties, address contractAddress)\n        external\n        override\n        onlyRoleHolder(uint(Roles.ContractCreator))\n    {\n        FinancialContract storage financialContract = contractMap[contractAddress];\n        require(contractMap[contractAddress].valid == Validity.Invalid, \"Can only register once\");\n\n        // Store contract address as a registered contract.\n        registeredContracts.push(contractAddress);\n\n        // No length check necessary because we should never hit (2^127 - 1) contracts.\n        financialContract.index = uint128(registeredContracts.length.sub(1));\n\n        // For all parties in the array add them to the contract's parties.\n        financialContract.valid = Validity.Valid;\n        for (uint i = 0; i < parties.length; i = i.add(1)) {\n            partyMap[parties[i]].contracts.push(contractAddress);\n            uint newLength = partyMap[parties[i]].contracts.length;\n            partyMap[parties[i]].contractIndex[contractAddress] = newLength - 1;\n        }\n\n        emit NewContractRegistered(contractAddress, msg.sender, parties);\n    }\n\n    /**\n     * @notice Adds a party member to the calling contract.\n     * @dev msg.sender will be used to determine the contract that this party is added to.\n     * @param party new party for the calling contract.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function addPartyToContract(address party) external override {\n        address contractAddress = msg.sender;\n\n        require(contractMap[contractAddress].valid == Validity.Valid, \"Can only add to valid contract\");\n        require(!isPartyMemberOfContract(party, contractAddress), \"Can only register a party once\");\n\n        // Push the contract address and store the index.\n        uint contractIndex = partyMap[party].contracts.length;\n        partyMap[party].contracts.push(contractAddress);\n        partyMap[party].contractIndex[contractAddress] = contractIndex;\n\n        emit PartyAdded(contractAddress, party);\n    }\n\n    /**\n     * @notice Removes a party member to the calling contract.\n     * @dev msg.sender will be used to determine the contract that this party is removed from.\n     * @param partyAddress address to be removed from the calling contract.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function removePartyFromContract(address partyAddress) external override {\n        address contractAddress = msg.sender;\n        Party storage party = partyMap[partyAddress];\n        uint256 numberOfContracts = party.contracts.length;\n\n        require(numberOfContracts != 0, \"Can't remove if party has no contracts\");\n        require(contractMap[contractAddress].valid == Validity.Valid, \"Remove only from valid contract\");\n        require(isPartyMemberOfContract(partyAddress, contractAddress), \"Can only remove an existing party\");\n\n        // Index of the current location of the contract to remove.\n        uint deleteIndex = party.contractIndex[contractAddress];\n\n        // Store the last contract's address to update the lookup map.\n        address lastContractAddress = party.contracts[numberOfContracts - 1];\n\n        // Swap the contract to be removed with the last contract.\n        party.contracts[deleteIndex] = lastContractAddress;\n\n        // Update the lookup index with the new location.\n        party.contractIndex[lastContractAddress] = deleteIndex;\n\n        // Pop the last contract from the array and update the lookup map.\n        party.contracts.pop();\n        delete party.contractIndex[contractAddress];\n\n        emit PartyRemoved(contractAddress, partyAddress);\n    }\n\n    /****************************************\n     *         REGISTRY STATE GETTERS       *\n     ****************************************/\n\n    /**\n     * @notice Returns whether the contract has been registered with the registry.\n     * @dev If it is registered, it is an authorized participant in the UMA system.\n     * @param contractAddress address of the financial contract.\n     * @return bool indicates whether the contract is registered.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function isContractRegistered(address contractAddress) external override view returns (bool) {\n        return contractMap[contractAddress].valid == Validity.Valid;\n    }\n\n    /**\n     * @notice Returns a list of all contracts that are associated with a particular party.\n     * @param party address of the party.\n     * @return an array of the contracts the party is registered to.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function getRegisteredContracts(address party) external override view returns (address[] memory) {\n        return partyMap[party].contracts;\n    }\n\n    /**\n     * @notice Returns all registered contracts.\n     * @return all registered contract addresses within the system.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function getAllRegisteredContracts() external override view returns (address[] memory) {\n        return registeredContracts;\n    }\n\n    /**\n     * @notice checks if an address is a party of a contract.\n     * @param party party to check.\n     * @param contractAddress address to check against the party.\n     * @return bool indicating if the address is a party of the contract.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function isPartyMemberOfContract(address party, address contractAddress) public override view returns (bool) {\n        uint index = partyMap[party].contractIndex[contractAddress];\n        return partyMap[party].contracts.length > index && partyMap[party].contracts[index] == contractAddress;\n    }\n}"
    }
  ]
}