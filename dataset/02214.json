{
  "Title": "H-2: Anyone can execute certain functions that use cross chain messages and potentially cancel them with potential loss of funds.",
  "Content": "# Issue H-2: Anyone can execute certain functions that use cross chain messages and potentially cancel them with potential loss of funds. \n\nSource: https://github.com/sherlock-audit/2023-01-derby-judging/issues/390 \n\n## Found by \nJeiwan, c7e7eff, rvierdiiev\n\nc7e7eff\nHigh\n\n## Summary\nCertain functions that route messages cross chain on the `Game` and `MainVault` contract are unprotected (anyone can call them under the required state of the vaults). The way the cross chain messaging is implemented in the XProvider makes use of Connext's `xcall()` and sets the `msg.sender` as the `delegate` and `msg.value` as `relayerFee`.\nThere are two possible attack vectors with this:\n- Either an attacker can call the function and set the msg.value to low so it won't be relayed until someone bumps the fee (Connext allows anyone to bump the fee). This however means special action must be taken to bump the fee in such a case.\n- Or the attacker can call the function  (which irreversibly changes the state of the contract) and as the delegate of the `xcall` cancel the message. This functionality is however not yet active on Connext, but the moment it is the attacker will be able to change the state of the contract on the origin chain and make the cross chain message not execute on the destination chain leaving the contracts on the two chains out of synch with possible loss of funds as a result.\n\n## Vulnerability Detail\nThe `XProvider` contract's `xsend()`  function sets the `msg.sender` as the delegate and `msg.value` as `relayerFee`\n```solidity\n    uint256 relayerFee = _relayerFee != 0 ? _relayerFee : msg.value;\n    IConnext(connext).xcall{value: relayerFee}(\n      _destinationDomain, // _destination: Domain ID of the destination chain\n      target, // _to: address of the target contract\n      address(0), // _asset: use address zero for 0-value transfers\n      msg.sender, // _delegate: address that can revert or forceLocal on destination\n      0, // _amount: 0 because no funds are being transferred\n      0, // _slippage: can be anything between 0-10000 because no funds are being transferred\n      _callData // _callData: the encoded calldata to send\n    );\n  }\n```\n\n`xTransfer()` using `msg.sender` as delegate:\n```solidity\n    IConnext(connext).xcall{value: (msg.value - _relayerFee)}(\n      _destinationDomain, // _destination: Domain ID of the destination chain\n      _recipient, // _to: address receiving the funds on the destination\n      _token, // _asset: address of the token contract\n      msg.sender, // _delegate: address that can revert or forceLocal on destination\n      _amount, // _amount: amount of tokens to transfer\n      _slippage, // _slippage: the maximum amount of slippage the user will accept in BPS (e.g. 30 = 0.3%)\n      bytes(\"\") // _callData: empty bytes because we're only sending funds\n    );\n  }\n```\n\nConnext [documentation](https://docs.connext.network/developers/reference/SDK/sdk-base#parameters-9) explaining:\n```solidity\nparams.delegate | (optional) Address allowed to cancel an xcall on destination.\n```\nConnext [documentation](https://docs.connext.network/developers/guides/handling-failures#high-slippage) seems to indicate this functionality isn't active yet though it isn't clear whether that applies to the cancel  itself or only the bridging back the funds to the origin chain.\n\n## Impact\nAn attacker can call certain functions which leave the relying contracts on different chains in an unsynched state, with possible loss of funds as a result (mainly on `XChainControleler`'s `sendFundsToVault()` when actual funds are transferred.\n\n## Code Snippet\n`MainVault`'s `pushTotalUnderlyingToController() `has no access control and calls `pushTotalUnderlying()` on the `xProvider`\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/MainVault.sol#L249\n\n`xProvider`'s `pushTotalUnderlying()` calling `xsend()`\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L243\n\n`MainVault`'s `sendRewardsToGame()` has no access control and calls `pushRewardsToGame()` on the `xProvider`\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/MainVault.sol#L365\n\n`xProvider`'s `pushRewardsToGame()` calling `xsend()`\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L443\n\n`XProvider` setting `msg.sender` as `delegate` and `msg.value` as relayer fee:\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L115-L124\n\n`XChainController`'s unprotected `sendFundsToVault()`\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XChainController.sol#L409-L414\n\n`XProvider`'s `xTransfer()` setting `msg.sender` as `delegate`:\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L152-L161\n\nAlso on the  `Game` contract, the unprotected `psuhAllocationsToController()` function:\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Game.sol#L424\n\nand the `pushAllocationsToVaults()`\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Game.sol#L465\n\n## Tool used\nManual Review\n\n## Recommendation\nProvide access control limits to the functions sending message across Connext so only the Guardian can call these functions with the correct msg.value and do not use msg.sender as a delegate but rather a configurable address like the Guardian.\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/13",
  "Code": [
    {
      "filename": "derby-yield-optimiser/contracts/MainVault.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"./Vault.sol\";\n\nimport \"./Interfaces/IXProvider.sol\";\n\ncontract MainVault is Vault, VaultToken {\n  using SafeERC20 for IERC20;\n\n  struct UserInfo {\n    // amount in vaultCurrency the vault owes to the user\n    uint256 withdrawalAllowance;\n    // rebalancing period the withdrawal request is made\n    uint256 withdrawalRequestPeriod;\n    // amount in vaultCurrency the vault owes to the user\n    uint256 rewardAllowance;\n    // rebalancing period the reward request is made\n    uint256 rewardRequestPeriod;\n  }\n\n  address public derbyToken;\n  address public game;\n  address public xProvider;\n\n  bool public vaultOff;\n  // True when rewards should be swapped to derby tokens\n  bool public swapRewards;\n\n  // total amount of withdrawal requests for the vault to pull extra during a cross-chain rebalance, will be upped when a user makes a withdrawalRequest\n  // during a cross-chain rebalance the vault will pull extra funds by the amount of totalWithdrawalRequests and the totalWithdrawalRequests will turn into actual reservedFunds\n  uint256 internal totalWithdrawalRequests;\n  uint256 public exchangeRate;\n  uint32 public homeChain;\n  uint256 public amountToSendXChain;\n  uint256 public governanceFee; // Basis points\n  uint256 public maxDivergenceWithdraws;\n\n  string internal allowanceError = \"!Allowance\";\n\n  // (userAddress => userInfo struct)\n  mapping(address => UserInfo) internal userInfo;\n\n  // training\n  bool private training;\n  uint256 private maxTrainingDeposit;\n  mapping(address => bool) private whitelist;\n\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals,\n    uint256 _vaultNumber,\n    address _dao,\n    address _game,\n    address _controller,\n    address _vaultCurrency,\n    uint256 _uScale\n  )\n    VaultToken(_name, _symbol, _decimals)\n    Vault(_vaultNumber, _dao, _controller, _vaultCurrency, _uScale)\n  {\n    exchangeRate = _uScale;\n    game = _game;\n    governanceFee = 0;\n    maxDivergenceWithdraws = 1_000_000;\n  }\n\n  modifier onlyXProvider() {\n    require(msg.sender == xProvider, \"only xProvider\");\n    _;\n  }\n\n  modifier onlyWhenVaultIsOn() {\n    require(state == State.Idle, \"Rebalancing\");\n    require(!vaultOff, \"Vault is off\");\n    _;\n  }\n\n  modifier onlyWhenIdle() {\n    require(state == State.Idle, \"Rebalancing\");\n    _;\n  }\n\n  modifier onlyGame() {\n    require(msg.sender == game, \"only game\");\n    _;\n  }\n\n  event PushTotalUnderlying(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    uint256 _underlying,\n    uint256 _totalSupply,\n    uint256 _withdrawalRequests\n  );\n  event RebalanceXChain(uint256 _vaultNumber, uint256 _amount, address _asset);\n  event PushedRewardsToGame(uint256 _vaultNumber, uint32 _chain, int256[] _rewards);\n\n  /// @notice Deposit in Vault\n  /// @dev Deposit VaultCurrency to Vault and mint LP tokens\n  /// @param _amount Amount to deposit\n  /// @param _receiver Receiving adress for the tokens\n  /// @return shares Tokens received by buyer\n  function deposit(\n    uint256 _amount,\n    address _receiver\n  ) external nonReentrant onlyWhenVaultIsOn returns (uint256 shares) {\n    if (training) {\n      require(whitelist[msg.sender]);\n      uint256 balanceSender = (balanceOf(msg.sender) * exchangeRate) / (10 ** decimals());\n      require(_amount + balanceSender <= maxTrainingDeposit);\n    }\n\n    uint256 balanceBefore = getVaultBalance() - reservedFunds;\n    vaultCurrency.safeTransferFrom(msg.sender, address(this), _amount);\n    uint256 balanceAfter = getVaultBalance() - reservedFunds;\n\n    uint256 amount = balanceAfter - balanceBefore;\n    shares = (amount * (10 ** decimals())) / exchangeRate;\n\n    _mint(_receiver, shares);\n  }\n\n  /// @notice Withdraw from Vault\n  /// @dev Withdraw VaultCurrency from Vault and burn LP tokens\n  /// @param _amount Amount to withdraw in LP tokens\n  /// @param _receiver Receiving adress for the vaultcurrency\n  /// @return value Amount received by seller in vaultCurrency\n  function withdraw(\n    uint256 _amount,\n    address _receiver,\n    address _owner\n  ) external nonReentrant onlyWhenVaultIsOn returns (uint256 value) {\n    value = (_amount * exchangeRate) / (10 ** decimals());\n\n    require(value > 0, \"!value\");\n\n    require(getVaultBalance() - reservedFunds >= value, \"!funds\");\n\n    _burn(msg.sender, _amount);\n    transferFunds(_receiver, value);\n  }\n\n  /// @notice Withdrawal request for when the vault doesnt have enough funds available\n  /// @dev Will give the user allowance for his funds and pulls the extra funds at the next rebalance\n  /// @param _amount Amount to withdraw in LP token\n  function withdrawalRequest(\n    uint256 _amount\n  ) external nonReentrant onlyWhenVaultIsOn returns (uint256 value) {\n    UserInfo storage user = userInfo[msg.sender];\n    require(user.withdrawalRequestPeriod == 0, \"Already a request\");\n\n    value = (_amount * exchangeRate) / (10 ** decimals());\n\n    _burn(msg.sender, _amount);\n\n    user.withdrawalAllowance = value;\n    user.withdrawalRequestPeriod = rebalancingPeriod;\n    totalWithdrawalRequests += value;\n  }\n\n  /// @notice Withdraw the allowance the user requested on the last rebalancing period\n  /// @dev Will send the user funds and reset the allowance\n  function withdrawAllowance() external nonReentrant onlyWhenIdle returns (uint256 value) {\n    UserInfo storage user = userInfo[msg.sender];\n    require(user.withdrawalAllowance > 0, allowanceError);\n    require(rebalancingPeriod > user.withdrawalRequestPeriod, \"Funds not arrived\");\n\n    value = user.withdrawalAllowance;\n    value = checkForBalance(value);\n\n    reservedFunds -= value;\n    delete user.withdrawalAllowance;\n    delete user.withdrawalRequestPeriod;\n\n    transferFunds(msg.sender, value);\n  }\n\n  /// @notice Substract governance fee from value\n  /// @param _receiver Receiving adress for the vaultcurrency\n  /// @param _value Amount received by seller in vaultCurrency\n  function transferFunds(address _receiver, uint256 _value) internal {\n    uint256 govFee = (_value * governanceFee) / 10_000;\n\n    vaultCurrency.safeTransfer(getDao(), govFee);\n    vaultCurrency.safeTransfer(_receiver, _value - govFee);\n  }\n\n  /// @notice Function for the game to set a withdrawalRequest for the rewards of the game user\n  /// @param _value Amount to set a request in vaultCurrency\n  /// @param _user Address of the user\n  function redeemRewardsGame(\n    uint256 _value,\n    address _user\n  ) external onlyGame nonReentrant onlyWhenVaultIsOn {\n    UserInfo storage user = userInfo[_user];\n    require(user.rewardAllowance == 0, allowanceError);\n\n    user.rewardAllowance = _value;\n    user.rewardRequestPeriod = rebalancingPeriod;\n    totalWithdrawalRequests += _value;\n  }\n\n  /// @notice Withdraw the reward allowance set by the game with redeemRewardsGame\n  /// @dev Will swap vaultCurrency to Derby tokens, send the user funds and reset the allowance\n  function withdrawRewards() external nonReentrant onlyWhenIdle returns (uint256 value) {\n    UserInfo storage user = userInfo[msg.sender];\n    require(user.rewardAllowance > 0, allowanceError);\n    require(rebalancingPeriod > user.rewardRequestPeriod, \"!Funds\");\n\n    value = user.rewardAllowance;\n    value = checkForBalance(value);\n\n    reservedFunds -= value;\n    delete user.rewardAllowance;\n    delete user.rewardRequestPeriod;\n\n    if (swapRewards) {\n      uint256 tokensReceived = Swap.swapTokensMulti(\n        Swap.SwapInOut(value, address(vaultCurrency), derbyToken),\n        controller.getUniswapParams(),\n        true\n      );\n      IERC20(derbyToken).safeTransfer(msg.sender, tokensReceived);\n    } else {\n      vaultCurrency.safeTransfer(msg.sender, value);\n    }\n  }\n\n  /// @notice Sometimes when swapping stable coins the vault will get a fraction of a coin less then expected\n  /// @notice This is to make sure the vault doesnt get stuck\n  /// @notice Value will be set to the vaultBalance\n  /// @notice When divergence is greater then maxDivergenceWithdraws it will revert\n  /// @param _value Value the user wants to withdraw\n  /// @return value Value - divergence\n  function checkForBalance(uint256 _value) internal view returns (uint256) {\n    if (_value > getVaultBalance()) {\n      uint256 oldValue = _value;\n      _value = getVaultBalance();\n      require(oldValue - _value <= maxDivergenceWithdraws, \"Max divergence\");\n    }\n    return _value;\n  }\n\n  /// @notice Step 2 trigger; Vaults push totalUnderlying, totalSupply and totalWithdrawalRequests to xChainController\n  /// @notice Pushes totalUnderlying, totalSupply and totalWithdrawalRequests of the vault for this chainId to xController\n  function pushTotalUnderlyingToController() external payable onlyWhenIdle {\n    require(rebalanceNeeded(), \"!rebalance needed\");\n\n    setTotalUnderlying();\n    uint256 underlying = savedTotalUnderlying + getVaultBalance() - reservedFunds;\n\n    IXProvider(xProvider).pushTotalUnderlying{value: msg.value}(\n      vaultNumber,\n      homeChain,\n      underlying,\n      totalSupply(),\n      totalWithdrawalRequests\n    );\n\n    state = State.PushedUnderlying;\n    lastTimeStamp = block.timestamp;\n\n    emit PushTotalUnderlying(\n      vaultNumber,\n      homeChain,\n      underlying,\n      totalSupply(),\n      totalWithdrawalRequests\n    );\n  }\n\n  /// @notice See setXChainAllocationInt below\n  function setXChainAllocation(\n    uint256 _amountToSend,\n    uint256 _exchangeRate,\n    bool _receivingFunds\n  ) external onlyXProvider {\n    require(state == State.PushedUnderlying, stateError);\n    setXChainAllocationInt(_amountToSend, _exchangeRate, _receivingFunds);\n  }\n\n  /// @notice Step 3 end; xChainController pushes exchangeRate and amount the vaults have to send back to all vaults\n  /// @notice Will set the amount to send back to the xController by the xController\n  /// @dev Sets the amount and state so the dao can trigger the rebalanceXChain function\n  /// @dev When amount == 0 the vault doesnt need to send anything and will wait for funds from the xController\n  /// @param _amountToSend amount to send in vaultCurrency\n  function setXChainAllocationInt(\n    uint256 _amountToSend,\n    uint256 _exchangeRate,\n    bool _receivingFunds\n  ) internal {\n    amountToSendXChain = _amountToSend;\n    exchangeRate = _exchangeRate;\n\n    if (_amountToSend == 0 && !_receivingFunds) settleReservedFunds();\n    else if (_amountToSend == 0 && _receivingFunds) state = State.WaitingForFunds;\n    else state = State.SendingFundsXChain;\n  }\n\n  /// @notice Step 4 trigger; Push funds from vaults to xChainController\n  /// @notice Send vaultcurrency to the xController for xChain rebalance\n  /// @param _slippage Slippage tollerance for xChain swap, in BPS (i.e. 30 = 0.3%)\n  /// @param _relayerFee The fee offered to the relayers\n  function rebalanceXChain(uint256 _slippage, uint256 _relayerFee) external payable {\n    require(state == State.SendingFundsXChain, stateError);\n\n    if (amountToSendXChain > getVaultBalance()) pullFunds(amountToSendXChain);\n    if (amountToSendXChain > getVaultBalance()) amountToSendXChain = getVaultBalance();\n\n    vaultCurrency.safeIncreaseAllowance(xProvider, amountToSendXChain);\n    IXProvider(xProvider).xTransferToController{value: msg.value}(\n      vaultNumber,\n      amountToSendXChain,\n      address(vaultCurrency),\n      _slippage,\n      _relayerFee\n    );\n\n    emit RebalanceXChain(vaultNumber, amountToSendXChain, address(vaultCurrency));\n\n    amountToSendXChain = 0;\n    settleReservedFunds();\n  }\n\n  /// @notice Step 5 end; Push funds from xChainController to vaults\n  /// @notice Receiving feedback from xController when funds are received, so the vault can rebalance\n  function receiveFunds() external onlyXProvider {\n    if (state != State.WaitingForFunds) return;\n    settleReservedFunds();\n  }\n\n  /// @notice Helper to settle reserved funds when funds arrived and up to the next State\n  function settleReservedFunds() internal {\n    reservedFunds += totalWithdrawalRequests;\n    totalWithdrawalRequests = 0;\n    state = State.RebalanceVault;\n  }\n\n  /// @notice See receiveProtocolAllocations below\n  function receiveProtocolAllocations(int256[] memory _deltas) external onlyXProvider {\n    receiveProtocolAllocationsInt(_deltas);\n  }\n\n  /// @notice Step 6 end; Game pushes deltaAllocations to vaults\n  /// @notice Receives protocol allocation array from the game and settles the allocations\n  /// @param _deltas Array with delta allocations where the index matches the protocolId\n  function receiveProtocolAllocationsInt(int256[] memory _deltas) internal {\n    for (uint i = 0; i < _deltas.length; i++) {\n      int256 allocation = _deltas[i];\n      if (allocation == 0) continue;\n      setDeltaAllocationsInt(i, allocation);\n    }\n\n    deltaAllocationsReceived = true;\n  }\n\n  /// @notice Step 8 trigger; Vaults push rewardsPerLockedToken to game\n  function sendRewardsToGame() external payable {\n    require(state == State.SendRewardsPerToken, stateError);\n\n    int256[] memory rewards = rewardsToArray();\n    IXProvider(xProvider).pushRewardsToGame{value: msg.value}(vaultNumber, homeChain, rewards);\n\n    state = State.Idle;\n\n    emit PushedRewardsToGame(vaultNumber, homeChain, rewards);\n  }\n\n  /// @notice Receive feedback for the vault if the vault is set to on or off\n  /// @param _state bool for chainId on or off\n  function toggleVaultOnOff(bool _state) external onlyXProvider {\n    vaultOff = _state;\n  }\n\n  /// @notice Returns the amount in vaultCurrency the user is able to withdraw\n  function getWithdrawalAllowance() external view returns (uint256) {\n    return userInfo[msg.sender].withdrawalAllowance;\n  }\n\n  /// @notice Returns the rewards the user is able to withdraw\n  function getRewardAllowance() external view returns (uint256) {\n    return userInfo[msg.sender].rewardAllowance;\n  }\n\n  /*\n  Only Dao functions\n  */\n\n  /// @notice Setter for xProvider address\n  /// @param _xProvider new address of xProvider on this chain\n  function setHomeXProvider(address _xProvider) external onlyDao {\n    xProvider = _xProvider;\n  }\n\n  /// @notice Setter for derby token address\n  /// @param _token New address of the derby token\n  function setDaoToken(address _token) external onlyDao {\n    derbyToken = _token;\n  }\n\n  /// @notice Setter for new game address\n  /// @param _game New address of the game\n  function setGame(address _game) external onlyDao {\n    game = _game;\n  }\n\n  /// @notice Setter for swapping rewards to derby tokens\n  /// @param _state True when rewards should be swapped to derby tokens\n  function setSwapRewards(bool _state) external onlyDao {\n    swapRewards = _state;\n  }\n\n  /// @notice Setter for maximum divergence a user can get during a withdraw\n  /// @param _maxDivergence New maximum divergence in vaultCurrency\n  function setMaxDivergence(uint256 _maxDivergence) external onlyDao {\n    maxDivergenceWithdraws = _maxDivergence;\n  }\n\n  /*\n  Only Guardian functions\n  */\n\n  /// @notice Step 3: Guardian function\n  function setXChainAllocationGuard(\n    uint256 _amountToSend,\n    uint256 _exchangeRate,\n    bool _receivingFunds\n  ) external onlyGuardian {\n    setXChainAllocationInt(_amountToSend, _exchangeRate, _receivingFunds);\n  }\n\n  /// @notice Step 5: Guardian function\n  function receiveFundsGuard() external onlyGuardian {\n    settleReservedFunds();\n  }\n\n  /// @notice Step 6: Guardian function\n  function receiveProtocolAllocationsGuard(int256[] memory _deltas) external onlyGuardian {\n    receiveProtocolAllocationsInt(_deltas);\n  }\n\n  /// @notice Guardian function to set state when vault gets stuck for whatever reason\n  function setVaultStateGuard(State _state) external onlyGuardian {\n    state = _state;\n  }\n\n  /// @notice Setter for new homeChain Id\n  function setHomeChain(uint32 _homeChain) external onlyGuardian {\n    homeChain = _homeChain;\n  }\n\n  /// @notice Setter for governance fee\n  /// @param _fee Fee in basis points\n  function setGovernanceFee(uint16 _fee) external onlyGuardian {\n    governanceFee = _fee;\n  }\n\n  /// @notice Setter to control the training state in de deposit function\n  function setTraining(bool _state) external onlyGuardian {\n    training = _state;\n  }\n\n  /// @notice Setter for maximum amount to be able to deposit in training state\n  function setTrainingDeposit(uint256 _maxDeposit) external onlyGuardian {\n    maxTrainingDeposit = _maxDeposit;\n  }\n\n  /// @notice Setter to add an address to the whitelist\n  function addToWhitelist(address _address) external onlyGuardian {\n    whitelist[_address] = true;\n  }\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/XProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IVault.sol\";\nimport \"./Interfaces/IXChainController.sol\";\nimport \"./Interfaces/IGame.sol\";\nimport \"./Interfaces/ExternalInterfaces/IConnext.sol\";\nimport \"./Interfaces/ExternalInterfaces/IXReceiver.sol\";\n\ncontract XProvider is IXReceiver {\n  using SafeERC20 for IERC20;\n\n  address public immutable connext;\n\n  address private dao;\n  address private guardian;\n  address public xController;\n  address public xControllerProvider;\n  address public game;\n\n  uint32 public homeChain;\n  uint32 public xControllerChain;\n  uint32 public gameChain;\n\n  // (domainID => contract address) mapping domainIDs to trusted remote xProvider on that specific domain\n  mapping(uint32 => address) public trustedRemoteConnext;\n  // (vaultAddress => bool): used for whitelisting vaults\n  mapping(address => bool) public vaultWhitelist;\n  // (vaultNumber => vaultAddress): used for guardian when xCall fails\n  mapping(uint256 => address) public vaults;\n\n  event SetTrustedRemote(uint32 _srcChainId, bytes _srcAddress);\n  event SetTrustedRemoteConnext(uint32 _srcChainId, address _srcAddress);\n\n  modifier onlyDao() {\n    require(msg.sender == dao, \"xProvider: only DAO\");\n    _;\n  }\n\n  modifier onlyGuardian() {\n    require(msg.sender == guardian, \"only Guardian\");\n    _;\n  }\n\n  modifier onlyController() {\n    require(msg.sender == xController, \"xProvider: only Controller\");\n    _;\n  }\n\n  modifier onlyVaults() {\n    require(vaultWhitelist[msg.sender], \"xProvider: only vault\");\n    _;\n  }\n\n  modifier onlyGame() {\n    require(msg.sender == game, \"xProvider: only Game\");\n    _;\n  }\n\n  /// @notice Solution for the low-level call in xReceive that is seen as an external call\n  modifier onlySelf() {\n    require(msg.sender == address(this), \"xProvider: only Self\");\n    _;\n  }\n\n  modifier onlySelfOrVault() {\n    require(\n      msg.sender == address(this) || vaultWhitelist[msg.sender],\n      \"xProvider: only Self or Vault\"\n    );\n    _;\n  }\n\n  /** @notice A modifier for authenticated calls.\n   * This is an important security consideration. If the target contract\n   * function should be authenticated, it must check three things:\n   *    1) The originating call comes from the expected origin domain.\n   *    2) The originating call comes from the expected source contract.\n   *    3) The call to this contract comes from Connext.\n   */\n  modifier onlySource(address _originSender, uint32 _origin) {\n    require(_originSender == trustedRemoteConnext[_origin] && msg.sender == connext, \"Not trusted\");\n    _;\n  }\n\n  constructor(\n    address _connext,\n    address _dao,\n    address _guardian,\n    address _game,\n    address _xController,\n    uint32 _homeChain\n  ) {\n    connext = _connext;\n    dao = _dao;\n    guardian = _guardian;\n    game = _game;\n    xController = _xController;\n    homeChain = _homeChain;\n  }\n\n  /// @notice Function to send function selectors crossChain\n  /// @param _destinationDomain chain Id of destination chain\n  /// @param _callData Function selector to call on receiving chain with params\n  /// @param _relayerFee The fee offered to the relayers, if 0 use the complete msg.value\n  function xSend(uint32 _destinationDomain, bytes memory _callData, uint256 _relayerFee) internal {\n    address target = trustedRemoteConnext[_destinationDomain];\n    require(target != address(0), \"XProvider: destination chain not trusted\");\n    uint256 relayerFee = _relayerFee != 0 ? _relayerFee : msg.value;\n\n    IConnext(connext).xcall{value: relayerFee}(\n      _destinationDomain, // _destination: Domain ID of the destination chain\n      target, // _to: address of the target contract\n      address(0), // _asset: use address zero for 0-value transfers\n      msg.sender, // _delegate: address that can revert or forceLocal on destination\n      0, // _amount: 0 because no funds are being transferred\n      0, // _slippage: can be anything between 0-10000 because no funds are being transferred\n      _callData // _callData: the encoded calldata to send\n    );\n  }\n\n  /// @notice Transfers funds from one chain to another.\n  /// @param _token Address of the token on this domain.\n  /// @param _amount The amount to transfer.\n  /// @param _recipient The destination address (e.g. a wallet).\n  /// @param _destinationDomain The destination domain ID.\n  /// @param _slippage Slippage tollerance for xChain swap, in BPS (i.e. 30 = 0.3%)\n  /// @param _relayerFee The fee offered to the relayers for confirmation message, msg.value - _relayerFee is what goes to the routers\n  function xTransfer(\n    address _token,\n    uint256 _amount,\n    address _recipient,\n    uint32 _destinationDomain,\n    uint256 _slippage,\n    uint256 _relayerFee\n  ) internal {\n    require(\n      IERC20(_token).allowance(msg.sender, address(this)) >= _amount,\n      \"User must approve amount\"\n    );\n\n    // User sends funds to this contract\n    IERC20(_token).transferFrom(msg.sender, address(this), _amount);\n\n    // This contract approves transfer to Connext\n    IERC20(_token).approve(address(connext), _amount);\n\n    IConnext(connext).xcall{value: (msg.value - _relayerFee)}(\n      _destinationDomain, // _destination: Domain ID of the destination chain\n      _recipient, // _to: address receiving the funds on the destination\n      _token, // _asset: address of the token contract\n      msg.sender, // _delegate: address that can revert or forceLocal on destination\n      _amount, // _amount: amount of tokens to transfer\n      _slippage, // _slippage: the maximum amount of slippage the user will accept in BPS (e.g. 30 = 0.3%)\n      bytes(\"\") // _callData: empty bytes because we're only sending funds\n    );\n  }\n\n  /// @notice function implemented from IXReceive from connext, standard way to receive messages with connext.\n  /// @param _transferId not used here because only relevant in case of a value transfer. Still in the signature to comply with IXReceive.\n  /// @param _amount not used here because only relevant in case of a value transfer. Still in the signature to comply with IXReceive.\n  /// @param _asset not used here because only relevant in case of a value transfer. Still in the signature to comply with IXReceive.\n  /// @param _originSender sender contract.\n  /// @param _origin sender domain id.\n  /// @param _callData calldata, contains function signature which has to be called in this contract as well as the values, hashed and encoded.\n  function xReceive(\n    bytes32 _transferId,\n    uint256 _amount,\n    address _asset,\n    address _originSender,\n    uint32 _origin,\n    bytes memory _callData\n  ) external onlySource(_originSender, _origin) returns (bytes memory) {\n    (bool success, ) = address(this).call(_callData);\n    require(success, \"xReceive: No success\");\n  }\n\n  /// @notice Step 1 push; Game pushes totalDeltaAllocations to xChainController\n  /// @notice Pushes the delta allocations from the game to the xChainController\n  /// @param _vaultNumber number of the vault\n  /// @param _deltas Array with delta Allocations for all chainIds\n  function pushAllocations(\n    uint256 _vaultNumber,\n    int256[] memory _deltas\n  ) external payable onlyGame {\n    if (homeChain == xControllerChain) {\n      return IXChainController(xController).receiveAllocationsFromGame(_vaultNumber, _deltas);\n    }\n    bytes4 selector = bytes4(keccak256(\"receiveAllocations(uint256,int256[])\"));\n    bytes memory callData = abi.encodeWithSelector(selector, _vaultNumber, _deltas);\n\n    xSend(xControllerChain, callData, 0);\n  }\n\n  /// @notice Step 1 receive; Game pushes totalDeltaAllocations to xChainController\n  /// @notice Receives the delta allocations from the game and routes to xChainController\n  /// @param _vaultNumber number of the vault\n  /// @param _deltas Array with delta Allocations for all chainIds\n  function receiveAllocations(uint256 _vaultNumber, int256[] memory _deltas) external onlySelf {\n    return IXChainController(xController).receiveAllocationsFromGame(_vaultNumber, _deltas);\n  }\n\n  /// @notice Step 2 push; Vaults push totalUnderlying, totalSupply and totalWithdrawalRequests to xChainController\n  /// @notice Pushes cross chain requests for the totalUnderlying for a vaultNumber on a chainId\n  /// @param _vaultNumber Number of the vault\n  /// @param _chainId Number of chain used\n  /// @param _underlying TotalUnderling plus vault balance in vaultcurrency e.g USDC\n  /// @param _totalSupply Supply of the LP token of the vault on given chainId\n  /// @param _withdrawalRequests Total amount of withdrawal requests from the vault in LP Tokens\n  function pushTotalUnderlying(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    uint256 _underlying,\n    uint256 _totalSupply,\n    uint256 _withdrawalRequests\n  ) external payable onlyVaults {\n    if (_chainId == xControllerChain) {\n      return\n        IXChainController(xController).setTotalUnderlying(\n          _vaultNumber,\n          _chainId,\n          _underlying,\n          _totalSupply,\n          _withdrawalRequests\n        );\n    } else {\n      bytes4 selector = bytes4(\n        keccak256(\"receiveTotalUnderlying(uint256,uint32,uint256,uint256,uint256)\")\n      );\n      bytes memory callData = abi.encodeWithSelector(\n        selector,\n        _vaultNumber,\n        _chainId,\n        _underlying,\n        _totalSupply,\n        _withdrawalRequests\n      );\n\n      xSend(xControllerChain, callData, 0);\n    }\n  }\n\n  /// @notice Step 2 receive; Vaults push totalUnderlying, totalSupply and totalWithdrawalRequests to xChainController\n  /// @notice Receive and set totalUnderlyings from the vaults for every chainId\n  /// @param _vaultNumber Number of the vault\n  /// @param _chainId Number of chain used\n  /// @param _underlying TotalUnderling plus vault balance in vaultcurrency e.g USDC\n  /// @param _totalSupply Supply of the LP token of the vault on given chainId\n  /// @param _withdrawalRequests Total amount of withdrawal requests from the vault in LP Tokens\n  function receiveTotalUnderlying(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    uint256 _underlying,\n    uint256 _totalSupply,\n    uint256 _withdrawalRequests\n  ) external onlySelf {\n    return\n      IXChainController(xController).setTotalUnderlying(\n        _vaultNumber,\n        _chainId,\n        _underlying,\n        _totalSupply,\n        _withdrawalRequests\n      );\n  }\n\n  /// @notice Step 3 push; xChainController pushes exchangeRate and amount the vaults have to send back to all vaults\n  /// @param _vault Address of the Derby Vault on given chainId\n  /// @param _chainId Number of chain used\n  /// @param _amountToSendBack Amount the vault has to send back\n  /// @param _exchangeRate New exchangerate for vaults\n  function pushSetXChainAllocation(\n    address _vault,\n    uint32 _chainId,\n    uint256 _amountToSendBack,\n    uint256 _exchangeRate,\n    bool _receivingFunds\n  ) external payable onlyController {\n    if (_chainId == homeChain) {\n      return IVault(_vault).setXChainAllocation(_amountToSendBack, _exchangeRate, _receivingFunds);\n    } else {\n      bytes4 selector = bytes4(\n        keccak256(\"receiveSetXChainAllocation(address,uint256,uint256,bool)\")\n      );\n      bytes memory callData = abi.encodeWithSelector(\n        selector,\n        _vault,\n        _amountToSendBack,\n        _exchangeRate,\n        _receivingFunds\n      );\n\n      xSend(_chainId, callData, 0);\n    }\n  }\n\n  /// @notice Step 3 receive; xChainController pushes exchangeRate and amount the vaults have to send back to all vaults\n  /// @param _vault Address of the Derby Vault on given chainId\n  /// @param _amountToSendBack Amount the vault has to send back\n  /// @param _exchangeRate New exchangerate for vaults\n  function receiveSetXChainAllocation(\n    address _vault,\n    uint256 _amountToSendBack,\n    uint256 _exchangeRate,\n    bool _receivingFunds\n  ) external onlySelf {\n    return IVault(_vault).setXChainAllocation(_amountToSendBack, _exchangeRate, _receivingFunds);\n  }\n\n  /// @notice Step 4 push; Push funds from vaults to xChainController\n  /// @notice Transfers funds from vault to xController for crosschain rebalance\n  /// @param _vaultNumber Address of the Derby Vault on given chainId\n  /// @param _amount Number of the vault\n  /// @param _asset Address of the token to send e.g USDC\n  /// @param _slippage Slippage tollerance for xChain swap, in BPS (i.e. 30 = 0.3%)\n  /// @param _relayerFee The fee offered to the relayers\n  function xTransferToController(\n    uint256 _vaultNumber,\n    uint256 _amount,\n    address _asset,\n    uint256 _slippage,\n    uint256 _relayerFee\n  ) external payable onlyVaults {\n    if (homeChain == xControllerChain) {\n      IERC20(_asset).transferFrom(msg.sender, xController, _amount);\n      IXChainController(xController).upFundsReceived(_vaultNumber);\n    } else {\n      xTransfer(_asset, _amount, xController, xControllerChain, _slippage, _relayerFee);\n      pushFeedbackToXController(_vaultNumber, _relayerFee);\n    }\n  }\n\n  /// @notice Step 4 push; Push funds from vaults to xChainController\n  /// @notice Push crosschain feedback to xController to know when the vaultNumber has sent funds\n  /// @param _vaultNumber Number of the vault\n  /// @param _relayerFee The fee offered to the relayers\n  function pushFeedbackToXController(uint256 _vaultNumber, uint256 _relayerFee) internal {\n    bytes4 selector = bytes4(keccak256(\"receiveFeedbackToXController(uint256)\"));\n    bytes memory callData = abi.encodeWithSelector(selector, _vaultNumber);\n\n    xSend(xControllerChain, callData, _relayerFee);\n  }\n\n  /// @notice Step 4 receive; Push funds from vaults to xChainController\n  /// @notice Receive crosschain feedback to xController to know when the vaultNumber has sent funds\n  /// @param _vaultNumber Number of the vault\n  function receiveFeedbackToXController(uint256 _vaultNumber) external onlySelf {\n    return IXChainController(xController).upFundsReceived(_vaultNumber);\n  }\n\n  /// @notice Step 5 push; Push funds from xChainController to vaults\n  /// @notice Transfers funds from xController to vault for crosschain rebalance\n  /// @param _chainId Number of chainId\n  /// @param _amount Amount to send to vault in vaultcurrency\n  /// @param _asset Addres of underlying e.g USDC\n  /// @param _slippage Slippage tollerance for xChain swap, in BPS (i.e. 30 = 0.3%)\n  /// @param _relayerFee The fee offered to the relayers\n  function xTransferToVaults(\n    address _vault,\n    uint32 _chainId,\n    uint256 _amount,\n    address _asset,\n    uint256 _slippage,\n    uint256 _relayerFee\n  ) external payable onlyController {\n    if (_chainId == homeChain) {\n      IVault(_vault).receiveFunds();\n      IERC20(_asset).transferFrom(msg.sender, _vault, _amount);\n    } else {\n      pushFeedbackToVault(_chainId, _vault, _relayerFee);\n      xTransfer(_asset, _amount, _vault, _chainId, _slippage, _relayerFee);\n    }\n  }\n\n  /// @notice Step 5 push; Push funds from xChainController to vaults\n  /// @notice Push feedback message so the vault knows it has received funds and is ready to rebalance\n  /// @param _chainId Number of chainId\n  /// @param _vault Address of the vault on given chainId\n  /// @param _relayerFee The fee offered to the relayers\n  function pushFeedbackToVault(uint32 _chainId, address _vault, uint256 _relayerFee) internal {\n    bytes4 selector = bytes4(keccak256(\"receiveFeedbackToVault(address)\"));\n    bytes memory callData = abi.encodeWithSelector(selector, _vault);\n\n    xSend(_chainId, callData, _relayerFee);\n  }\n\n  /// @notice Step 5 receive; Push funds from xChainController to vaults\n  /// @notice Receive feedback message so the vault knows it has received funds and is ready to rebalance\n  /// @param _vault Address of the vault on given chainId\n  function receiveFeedbackToVault(address _vault) external onlySelfOrVault {\n    return IVault(_vault).receiveFunds();\n  }\n\n  /// @notice Step 6 push; Game pushes deltaAllocations to vaults\n  /// @notice Push protocol allocation array from the game to all vaults/chains\n  /// @param _vault Address of the vault on given chainId\n  /// @param _deltas Array with delta allocations where the index matches the"
    }
  ]
}