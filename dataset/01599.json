{
  "Title": "M-7: Malicious user can grief withdrawing users via VUSD reentrancy",
  "Content": "# Issue M-7: Malicious user can grief withdrawing users via VUSD reentrancy \n\nSource: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/153 \n\n## Found by \n0x3e84fa45, 0x52\n## Summary\n\nVUSD#processWithdraw makes a call to withdrawal.usr to send the withdrawn gas token. processWithdrawals is the only nonreentrant function allowing a user to create a smart contract that uses it's receive function to deposit then immediately withdraw to indefinitely lengthen the withdrawal queue and waste large amounts of caller gas.\n\n## Vulnerability Detail\n\n[VUSD.sol#L69-L77](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/VUSD.sol#L69-L77)\n\n        while (i < withdrawals.length && (i - start) < maxWithdrawalProcesses) {\n            Withdrawal memory withdrawal = withdrawals[i];\n            if (reserve < withdrawal.amount) {\n                break;\n            }\n\n            (bool success, bytes memory data) = withdrawal.usr.call{value: withdrawal.amount}(\"\");\n            if (success) {\n                reserve -= withdrawal.amount;\n\nTo send the withdrawn gas token to the user VUSD#processWithdrawals utilizes a call with no data. When received by a contract this will trigger it's receive function. This can be abused to continually grief users who withdraw with no recurring cost to the attacker. To exploit this the attacker would withdraw VUSD to a malicious contract. This contract would deposit the received gas token then immediately withdraw it. This would lengthen the queue. Since the queue is first-in first-out a user would be forced to process all the malicious withdrawals before being able to process their own. While processing them they would inevitably reset the grief for the next user.\n\nNOTE: I am submitting this as a separate issue apart from my other two similar issues. I believe it should be a separate issue because even though the outcome is similar the root cause is entirely different. Those are directly related to the incorrect call parameters while the root cause of this issue is that both mintWithReserve and withdraw/withdrawTo lack the reentrant modifier allowing this malicious reentrancy.\n\n## Impact\n\nMalicious user can maliciously reenter VUSD to grief users via unnecessary gas wastage \n\n## Code Snippet\n\n[VUSD.sol#L45-L48](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/VUSD.sol#L45-L48)\n\n[VUSD.sol#L50-L52](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/VUSD.sol#L50-L52)\n\n[VUSD.sol#L58-L60](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/VUSD.sol#L58-L60)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd the nonreentrant modifer to mintWithReserve withdraw and withdrawTo\n\n\n\n## Discussion\n\n**asquare08**\n\nWill add the `nonreentrant` modifer to `mintWithReserve` withdraw and `withdrawTo`\n\n**ctf-sec**\n\n>To exploit this the attacker would withdraw VUSD to a malicious contract. This contract would deposit the received gas token then immediately withdraw it. \n\nI put this issue and #160 together because these two issue highlight different ways of wasting gas, but they also focus on how to waste gas in external call.\n\nRecommend checking #160 as well.\n\nand I leave the #158 as a separate issue because the root cause is the returned call data is emitted in the contract code itself\n\n**asquare08**\n\nyes noted. #160 has slightly different cause but same effect. So the solution for all these related issues is\n* don't save data in variable #158 \n* cap the gas limit of .call #160\n* [this](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/153#issuecomment-1640346418)\n\n\n**IAm0x52**\n\nEscalate\n\nAs the sponsor has pointed out, this is a different issue from the dupes. While the outcome of wasting gas is similar, the root cause is completely different. The root cause for this is reentrancy across functions, while the root cause of issues marked as dupes is that there is no gas limit. I suggest that this issue be separated and the dupes groped together as separate issues.\n\nEdit:\nMissed #195. That and this should be considered a separate issue\n\n**sherlock-admin2**\n\n > Escalate\n> \n> As the sponsor has pointed out, this is a different issue from the dupes. While the outcome of wasting gas is similar, the root cause is completely different. The root cause for this is reentrancy across functions, while the root cause of issues marked as dupes is that there is no gas limit. I suggest that this issue be separated and the dupes groped together as separate issues.\n> \n> Edit:\n> Missed #195. That and this should be considered a separate issue\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nSee escalation https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/116\n\nThere are a lot of ways to consume all gas in external call (reentrancy to expand the queue size, gas token, for loop, swap, etc....), cannot count each of them as duplicates \n\nI think grouping all these issue about wasting gas in external call to one issue make sense, root cause is gas limit not capped.\n\n**0xArcturus**\n\n Agreed with escalation, \nas also mentioned in [#195](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/195), the root cause of this is the lack of reentrancy guard and the `withdrawals.length` changing during execution. This attack can bloat the queue by reentering with a single withdraw call, while the dupes are focused on consuming gas in a single call.\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nAgree with the escalation that this should be a separate issue along with #195 \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [IAm0x52](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/153/#issuecomment-1643577079): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/72",
  "Code": [
    {
      "filename": "hubble-protocol/contracts/VUSD.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { ERC20PresetMinterPauserUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\";\nimport { IVUSD } from './Interfaces.sol';\n\n/**\n * @title VUSD is a wrapper over USDC (also the gas token). VUSD it the 0th collateral in the system and also the only coin accepted by the insurance fund.\n * @notice In Hubble Exchange docs/contracts etc, VUSD is interchangeably referred to as hUSD\n*/\ncontract VUSD is ERC20PresetMinterPauserUpgradeable, ReentrancyGuard, IVUSD {\n\n    uint8 private constant PRECISION = 6;\n    uint256 private constant SCALING_FACTOR = 1e12;\n\n    struct Withdrawal {\n        address usr;\n        uint amount;\n    }\n    Withdrawal[] public withdrawals;\n\n    /// @dev withdrawals will start processing at withdrawals[start]\n    uint public start;\n\n    /// @dev Constrained by block gas limit\n    uint public maxWithdrawalProcesses;\n\n    uint256[50] private __gap;\n\n    function initialize(string memory name, string memory symbol) public override virtual {\n        super.initialize(name, symbol); // has initializer modifier\n        _revokeRole(MINTER_ROLE, _msgSender()); // __ERC20PresetMinterPauser_init_unchained grants this but is not required\n        maxWithdrawalProcesses = 100;\n    }\n\n    /**\n    * @notice mint hUSD by depositing hubble gas token\n    * @dev keeping the function name same as v1 for compatibility\n    * @param to address to mint for\n    * @param amount amount to mint - precision 1e6\n    * msg.value has to be exactly 1e12 times `amount`\n    */\n    function mintWithReserve(address to, uint amount) external override payable whenNotPaused {\n        require(msg.value == amount * SCALING_FACTOR, \"vUSD: Insufficient amount transferred\");\n        _mint(to, amount);\n    }\n\n    function withdraw(uint amount) external override whenNotPaused {\n        _withdrawTo(_msgSender(), amount);\n    }\n\n    /**\n    * @notice Burn vusd from msg.sender and Q the withdrawal to `to`\n    * @dev no need to add onlyMarginAccountHelper modifier as vusd is burned from caller and sent to specified address\n    */\n    function withdrawTo(address to, uint amount) external override whenNotPaused {\n        _withdrawTo(to, amount);\n    }\n\n    /**\n     * @notice Process withdrawals in the queue. Sends gas token to the user.\n    */\n    function processWithdrawals() external override whenNotPaused nonReentrant {\n        uint reserve = address(this).balance;\n        require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this time: Not enough balance');\n        uint i = start;\n        while (i < withdrawals.length && (i - start) < maxWithdrawalProcesses) {\n            Withdrawal memory withdrawal = withdrawals[i];\n            if (reserve < withdrawal.amount) {\n                break;\n            }\n\n            (bool success, bytes memory data) = withdrawal.usr.call{value: withdrawal.amount}(\"\");\n            if (success) {\n                reserve -= withdrawal.amount;\n            } else {\n                emit WithdrawalFailed(withdrawal.usr, withdrawal.amount, data);\n            }\n            i += 1;\n        }\n        // re-entracy not possible, hence can update `start` at the end\n        start = i;\n    }\n\n    function withdrawalQueue() external view returns(Withdrawal[] memory queue) {\n        uint l = _min(withdrawals.length-start, maxWithdrawalProcesses);\n        queue = new Withdrawal[](l);\n\n        for (uint i = 0; i < l; i++) {\n            queue[i] = withdrawals[start+i];\n        }\n    }\n\n    function withdrawalQLength() external view returns (uint) {\n        return withdrawals.length;\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return PRECISION;\n    }\n\n    function setMaxWithdrawalProcesses(uint _maxWithdrawalProcesses) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have admin role\");\n        maxWithdrawalProcesses = _maxWithdrawalProcesses;\n    }\n\n    function _withdrawTo(address to, uint amount) internal {\n        require(amount >= 5 * (10 ** PRECISION), \"min withdraw is 5 vusd\");\n        burn(amount); // burn vusd from msg.sender\n        withdrawals.push(Withdrawal(to, amount * SCALING_FACTOR));\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}"
    },
    {
      "filename": "hubble-protocol/contracts/VUSD.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { ERC20PresetMinterPauserUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\";\nimport { IVUSD } from './Interfaces.sol';\n\n/**\n * @title VUSD is a wrapper over USDC (also the gas token). VUSD it the 0th collateral in the system and also the only coin accepted by the insurance fund.\n * @notice In Hubble Exchange docs/contracts etc, VUSD is interchangeably referred to as hUSD\n*/\ncontract VUSD is ERC20PresetMinterPauserUpgradeable, ReentrancyGuard, IVUSD {\n\n    uint8 private constant PRECISION = 6;\n    uint256 private constant SCALING_FACTOR = 1e12;\n\n    struct Withdrawal {\n        address usr;\n        uint amount;\n    }\n    Withdrawal[] public withdrawals;\n\n    /// @dev withdrawals will start processing at withdrawals[start]\n    uint public start;\n\n    /// @dev Constrained by block gas limit\n    uint public maxWithdrawalProcesses;\n\n    uint256[50] private __gap;\n\n    function initialize(string memory name, string memory symbol) public override virtual {\n        super.initialize(name, symbol); // has initializer modifier\n        _revokeRole(MINTER_ROLE, _msgSender()); // __ERC20PresetMinterPauser_init_unchained grants this but is not required\n        maxWithdrawalProcesses = 100;\n    }\n\n    /**\n    * @notice mint hUSD by depositing hubble gas token\n    * @dev keeping the function name same as v1 for compatibility\n    * @param to address to mint for\n    * @param amount amount to mint - precision 1e6\n    * msg.value has to be exactly 1e12 times `amount`\n    */\n    function mintWithReserve(address to, uint amount) external override payable whenNotPaused {\n        require(msg.value == amount * SCALING_FACTOR, \"vUSD: Insufficient amount transferred\");\n        _mint(to, amount);\n    }\n\n    function withdraw(uint amount) external override whenNotPaused {\n        _withdrawTo(_msgSender(), amount);\n    }\n\n    /**\n    * @notice Burn vusd from msg.sender and Q the withdrawal to `to`\n    * @dev no need to add onlyMarginAccountHelper modifier as vusd is burned from caller and sent to specified address\n    */\n    function withdrawTo(address to, uint amount) external override whenNotPaused {\n        _withdrawTo(to, amount);\n    }\n\n    /**\n     * @notice Process withdrawals in the queue. Sends gas token to the user.\n    */\n    function processWithdrawals() external override whenNotPaused nonReentrant {\n        uint reserve = address(this).balance;\n        require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this time: Not enough balance');\n        uint i = start;\n        while (i < withdrawals.length && (i - start) < maxWithdrawalProcesses) {\n            Withdrawal memory withdrawal = withdrawals[i];\n            if (reserve < withdrawal.amount) {\n                break;\n            }\n\n            (bool success, bytes memory data) = withdrawal.usr.call{value: withdrawal.amount}(\"\");\n            if (success) {\n                reserve -= withdrawal.amount;\n            } else {\n                emit WithdrawalFailed(withdrawal.usr, withdrawal.amount, data);\n            }\n            i += 1;\n        }\n        // re-entracy not possible, hence can update `start` at the end\n        start = i;\n    }\n\n    function withdrawalQueue() external view returns(Withdrawal[] memory queue) {\n        uint l = _min(withdrawals.length-start, maxWithdrawalProcesses);\n        queue = new Withdrawal[](l);\n\n        for (uint i = 0; i < l; i++) {\n            queue[i] = withdrawals[start+i];\n        }\n    }\n\n    function withdrawalQLength() external view returns (uint) {\n        return withdrawals.length;\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return PRECISION;\n    }\n\n    function setMaxWithdrawalProcesses(uint _maxWithdrawalProcesses) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have admin role\");\n        maxWithdrawalProcesses = _maxWithdrawalProcesses;\n    }\n\n    function _withdrawTo(address to, uint amount) internal {\n        require(amount >= 5 * (10 ** PRECISION), \"min withdraw is 5 vusd\");\n        burn(amount); // burn vusd from msg.sender\n        withdrawals.push(Withdrawal(to, amount * SCALING_FACTOR));\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}"
    },
    {
      "filename": "hubble-protocol/contracts/VUSD.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { ERC20PresetMinterPauserUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\";\nimport { IVUSD } from './Interfaces.sol';\n\n/**\n * @title VUSD is a wrapper over USDC (also the gas token). VUSD it the 0th collateral in the system and also the only coin accepted by the insurance fund.\n * @notice In Hubble Exchange docs/contracts etc, VUSD is interchangeably referred to as hUSD\n*/\ncontract VUSD is ERC20PresetMinterPauserUpgradeable, ReentrancyGuard, IVUSD {\n\n    uint8 private constant PRECISION = 6;\n    uint256 private constant SCALING_FACTOR = 1e12;\n\n    struct Withdrawal {\n        address usr;\n        uint amount;\n    }\n    Withdrawal[] public withdrawals;\n\n    /// @dev withdrawals will start processing at withdrawals[start]\n    uint public start;\n\n    /// @dev Constrained by block gas limit\n    uint public maxWithdrawalProcesses;\n\n    uint256[50] private __gap;\n\n    function initialize(string memory name, string memory symbol) public override virtual {\n        super.initialize(name, symbol); // has initializer modifier\n        _revokeRole(MINTER_ROLE, _msgSender()); // __ERC20PresetMinterPauser_init_unchained grants this but is not required\n        maxWithdrawalProcesses = 100;\n    }\n\n    /**\n    * @notice mint hUSD by depositing hubble gas token\n    * @dev keeping the function name same as v1 for compatibility\n    * @param to address to mint for\n    * @param amount amount to mint - precision 1e6\n    * msg.value has to be exactly 1e12 times `amount`\n    */\n    function mintWithReserve(address to, uint amount) external override payable whenNotPaused {\n        require(msg.value == amount * SCALING_FACTOR, \"vUSD: Insufficient amount transferred\");\n        _mint(to, amount);\n    }\n\n    function withdraw(uint amount) external override whenNotPaused {\n        _withdrawTo(_msgSender(), amount);\n    }\n\n    /**\n    * @notice Burn vusd from msg.sender and Q the withdrawal to `to`\n    * @dev no need to add onlyMarginAccountHelper modifier as vusd is burned from caller and sent to specified address\n    */\n    function withdrawTo(address to, uint amount) external override whenNotPaused {\n        _withdrawTo(to, amount);\n    }\n\n    /**\n     * @notice Process withdrawals in the queue. Sends gas token to the user.\n    */\n    function processWithdrawals() external override whenNotPaused nonReentrant {\n        uint reserve = address(this).balance;\n        require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this time: Not enough balance');\n        uint i = start;\n        while (i < withdrawals.length && (i - start) < maxWithdrawalProcesses) {\n            Withdrawal memory withdrawal = withdrawals[i];\n            if (reserve < withdrawal.amount) {\n                break;\n            }\n\n            (bool success, bytes memory data) = withdrawal.usr.call{value: withdrawal.amount}(\"\");\n            if (success) {\n                reserve -= withdrawal.amount;\n            } else {\n                emit WithdrawalFailed(withdrawal.usr, withdrawal.amount, data);\n            }\n            i += 1;\n        }\n        // re-entracy not possible, hence can update `start` at the end\n        start = i;\n    }\n\n    function withdrawalQueue() external view returns(Withdrawal[] memory queue) {\n        uint l = _min(withdrawals.length-start, maxWithdrawalProcesses);\n        queue = new Withdrawal[](l);\n\n        for (uint i = 0; i < l; i++) {\n            queue[i] = withdrawals[start+i];\n        }\n    }\n\n    function withdrawalQLength() external view returns (uint) {\n        return withdrawals.length;\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return PRECISION;\n    }\n\n    function setMaxWithdrawalProcesses(uint _maxWithdrawalProcesses) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have admin role\");\n        maxWithdrawalProcesses = _maxWithdrawalProcesses;\n    }\n\n    function _withdrawTo(address to, uint amount) internal {\n        require(amount >= 5 * (10 ** PRECISION), \"min withdraw is 5 vusd\");\n        burn(amount); // burn vusd from msg.sender\n        withdrawals.push(Withdrawal(to, amount * SCALING_FACTOR));\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}"
    },
    {
      "filename": "hubble-protocol/contracts/VUSD.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { ERC20PresetMinterPauserUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\";\nimport { IVUSD } from './Interfaces.sol';\n\n/**\n * @title VUSD is a wrapper over USDC (also the gas token). VUSD it the 0th collateral in the system and also the only coin accepted by the insurance fund.\n * @notice In Hubble Exchange docs/contracts etc, VUSD is interchangeably referred to as hUSD\n*/\ncontract VUSD is ERC20PresetMinterPauserUpgradeable, ReentrancyGuard, IVUSD {\n\n    uint8 private constant PRECISION = 6;\n    uint256 private constant SCALING_FACTOR = 1e12;\n\n    struct Withdrawal {\n        address usr;\n        uint amount;\n    }\n    Withdrawal[] public withdrawals;\n\n    /// @dev withdrawals will start processing at withdrawals[start]\n    uint public start;\n\n    /// @dev Constrained by block gas limit\n    uint public maxWithdrawalProcesses;\n\n    uint256[50] private __gap;\n\n    function initialize(string memory name, string memory symbol) public override virtual {\n        super.initialize(name, symbol); // has initializer modifier\n        _revokeRole(MINTER_ROLE, _msgSender()); // __ERC20PresetMinterPauser_init_unchained grants this but is not required\n        maxWithdrawalProcesses = 100;\n    }\n\n    /**\n    * @notice mint hUSD by depositing hubble gas token\n    * @dev keeping the function name same as v1 for compatibility\n    * @param to address to mint for\n    * @param amount amount to mint - precision 1e6\n    * msg.value has to be exactly 1e12 times `amount`\n    */\n    function mintWithReserve(address to, uint amount) external override payable whenNotPaused {\n        require(msg.value == amount * SCALING_FACTOR, \"vUSD: Insufficient amount transferred\");\n        _mint(to, amount);\n    }\n\n    function withdraw(uint amount) external override whenNotPaused {\n        _withdrawTo(_msgSender(), amount);\n    }\n\n    /**\n    * @notice Burn vusd from msg.sender and Q the withdrawal to `to`\n    * @dev no need to add onlyMarginAccountHelper modifier as vusd is burned from caller and sent to specified address\n    */\n    function withdrawTo(address to, uint amount) external override whenNotPaused {\n        _withdrawTo(to, amount);\n    }\n\n    /**\n     * @notice Process withdrawals in the queue. Sends gas token to the user.\n    */\n    function processWithdrawals() external override whenNotPaused nonReentrant {\n        uint reserve = address(this).balance;\n        require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this time: Not enough balance');\n        uint i = start;\n        while (i < withdrawals.length && (i - start) < maxWithdrawalProcesses) {\n            Withdrawal memory withdrawal = withdrawals[i];\n            if (reserve < withdrawal.amount) {\n                break;\n            }\n\n            (bool success, bytes memory data) = withdrawal.usr.call{value: withdrawal.amount}(\"\");\n            if (success) {\n                reserve -= withdrawal.amount;\n            } else {\n                emit WithdrawalFailed(withdrawal.usr, withdrawal.amount, data);\n            }\n            i += 1;\n        }\n        // re-entracy not possible, hence can update `start` at the end\n        start = i;\n    }\n\n    function withdrawalQueue() external view returns(Withdrawal[] memory queue) {\n        uint l = _min(withdrawals.length-start, maxWithdrawalProcesses);\n        queue = new Withdrawal[](l);\n\n        for (uint i = 0; i < l; i++) {\n            queue[i] = withdrawals[start+i];\n        }\n    }\n\n    function withdrawalQLength() external view returns (uint) {\n        return withdrawals.length;\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return PRECISION;\n    }\n\n    function setMaxWithdrawalProcesses(uint _maxWithdrawalProcesses) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have admin role\");\n        maxWithdrawalProcesses = _maxWithdrawalProcesses;\n    }\n\n    function _withdrawTo(address to, uint amount) internal {\n        require(amount >= 5 * (10 ** PRECISION), \"min withdraw is 5 vusd\");\n        burn(amount); // burn vusd from msg.sender\n        withdrawals.push(Withdrawal(to, amount * SCALING_FACTOR));\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}"
    }
  ]
}