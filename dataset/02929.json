{
  "Title": "M-3: The supply of NFT for each tokenID in ERC1155NFTProduct cannot be modified after the first minting",
  "Content": "# Issue M-3: The supply of NFT for each tokenID in ERC1155NFTProduct cannot be modified after the first minting \n\nSource: https://github.com/sherlock-audit/2022-10-nftport-judging/issues/95 \n\n## Found by \nGimelSec, cccz\n\n## Summary\nThe supply of NFT for each tokenID in ERC1155NFTProduct cannot be modified after the first minting\n## Vulnerability Detail\nWhen minting NFT in the ERC1155NFTProduct contract, it will check whether the tokenID already exists, that is, as long as tokenSupply[tokenId] > 0, the ERC1155 NFT of this tokenId will not be able to be minted again.\nThis will lead to\n1. The supply of NFT for each tokenID is determined after the first mint\n2. Unable to mint ERC1155 NFT with the same tokenId for different users\n\nThis will greatly limit the application scenarios of ERC1155NFTProduct\n## Impact\n\n1. The supply of NFT for each tokenID is determined after the first mint\n2. Unable to mint ERC1155 NFT with the same tokenId for different users\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/ERC1155NFTProduct.sol#L279-L286\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/ERC1155NFTProduct.sol#L259-L265\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/ERC1155NFTProduct.sol#L388-L390\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider removing the _exists check when minting ERC1155 NFT in the ERC1155NFTProduct contract\n\n## Discussion\n\n**hyperspacebunny**\n\nWe've decided to not change the behaviour at this point and revisit it once we have requests from users. It's currently working as designed.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/14",
  "Code": [
    {
      "filename": "evm-minting-master/contracts/templates/ERC1155NFTProduct.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport {IERC2981} from \"@openzeppelin/contracts/token/common/ERC2981.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"../lib/GranularRoles.sol\";\nimport \"../lib/Base64.sol\";\nimport \"../lib/Config.sol\";\nimport \"../lib/ITemplate.sol\";\n\n/*\n * ERC-1155 proxy contract, meaning it does not make use of a constructor,\n * but rather uses `initialize` with `initializer` modifier, see {Initializable}\n *\n * Minting and other write transactions only supported for accounts with relevant access rights.\n */\ncontract ERC1155NFTProduct is ERC1155Upgradeable, GranularRoles, ITemplate {\n    /*******************************\n     * Extensions, structs, events *\n     *******************************/\n\n    using Strings for uint256;\n\n    /*\n     * Event emitted to show opensea that metadata of a token is frozen,\n     * see https://docs.opensea.io/docs/metadata-standards\n     */\n    event PermanentURI(string _value, uint256 indexed _id);\n    // Event emitted to show that all tokens have their metadata frozen\n    event PermanentURIGlobal();\n\n    /*************\n     * Constants *\n     *************/\n\n    // Template name\n    string public constant NAME = \"ERC1155NFTProduct\";\n    // Template version\n    uint256 public constant VERSION = 1_00_00;\n\n    // Basis for calculating royalties.\n    // This has to be 10k for royaltiesBps to be in basis points.\n    uint16 public constant ROYALTIES_BASIS = 10000;\n    // Default URI for tokens, each minted token will have a token URI, so default URI is empty\n    string public constant DEFAULT_URI = \"\";\n\n    /********************\n     * Public variables *\n     ********************/\n\n    // If true then tokens metadata can be updated\n    bool public metadataUpdatable;\n    // If true then tokens can be burned by their owners\n    bool public tokensBurnable;\n    // If true then tokens can be transferred by having the correct access rights {GranularRoles-TRANSFER_ROLE}\n    // if the token is owned by {GranularRoles-_owner} address\n    bool public tokensTransferable;\n\n    // Token name\n    string public name;\n    // Token symbol\n    string public symbol;\n    // Token IDs are returned as `baseURI` + `tokenURI`\n    string public baseURI;\n\n    // Address where royalties will be transferred to\n    address public royaltiesAddress;\n    // Secondary market royalties in basis points (100 bps = 1%). Royalties use ERC2981 standard and support\n    // OpenSea standard.\n    uint256 public royaltiesBasisPoints;\n\n    // Mapping of individually frozen tokens\n    mapping(uint256 => bool) public freezeTokenUris;\n    // Mapping of token ID to supply\n    mapping(uint256 => uint256) public tokenSupply;\n\n    /***************************\n     * Contract initialization *\n     ***************************/\n\n    constructor() initializer {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    // Can only be called once, used because constructors cannot be used for proxy contracts\n    function initialize(\n        Config.Deployment memory deploymentConfig,\n        Config.Runtime memory runtimeConfig,\n        RolesAddresses[] memory rolesAddresses\n    ) public initializer {\n        __ERC1155_init(DEFAULT_URI);\n\n        royaltiesAddress = runtimeConfig.royaltiesAddress;\n        royaltiesBasisPoints = runtimeConfig.royaltiesBps;\n\n        metadataUpdatable = runtimeConfig.metadataUpdatable;\n        tokensBurnable = deploymentConfig.tokensBurnable;\n        tokensTransferable = runtimeConfig.tokensTransferable;\n\n        name = deploymentConfig.name;\n        symbol = deploymentConfig.symbol;\n        baseURI = runtimeConfig.baseURI;\n\n        _initRoles(deploymentConfig.owner, rolesAddresses);\n    }\n\n    /*******************\n     * Write functions *\n     *******************/\n\n    // Allows to set a default URI for tokens, which is only returned if token URI does not exist for given token ID\n    function setURI(string memory _newURI)\n        public\n        onlyRole(UPDATE_CONTRACT_ROLE)\n    {\n        _setURI(_newURI);\n    }\n\n    /*\n     * Allows to update token URI for given `_tokenId` and freeze it.\n     * For the transaction to succeed either `_newUri` or `_isFreezeTokenUri` as true must be specified, or both.\n     * The `_newURI` cannot be the same as the current URI for the token.\n     *\n     * Token ID must exist, `metadataUpdatable` must be true and token URI for given token cannot be frozen.\n     * Only callable by accounts with `UPDATE_TOKEN_ROLE` or `ADMIN_ROLE`.\n     */\n    function updateTokenUri(\n        uint256 _tokenId,\n        string memory _newUri,\n        bool _isFreezeTokenUri\n    ) public onlyRole(UPDATE_TOKEN_ROLE) {\n        require(_exists(_tokenId), \"Token does not exist\");\n        require(metadataUpdatable, \"Metadata is frozen\");\n        require(freezeTokenUris[_tokenId] != true, \"Token is frozen\");\n        require(\n            _isFreezeTokenUri || (bytes(_newUri).length != 0),\n            \"Either _newUri or _isFreezeTokenUri=true required\"\n        );\n\n        if (bytes(_newUri).length != 0) {\n            require(\n                keccak256(bytes(_tokenURIs[_tokenId])) !=\n                    keccak256(bytes(string(abi.encodePacked(_newUri)))),\n                \"New token URI is same as updated\"\n            );\n            _tokenURIs[_tokenId] = _newUri;\n            emit URI(_newUri, _tokenId);\n        }\n        if (_isFreezeTokenUri) {\n            freezeTokenUris[_tokenId] = true;\n            emit PermanentURI(_tokenURIs[_tokenId], _tokenId);\n        }\n    }\n\n    /*\n     * Allows to burn given `value` amount of tokens with `id`.\n     * `tokensBurnable` must be true in order for the transaction to succeed and\n     * at least `value` amount of tokens must exist.\n     * Only callable by accounts with `BURN_ROLE` or `ADMIN_ROLE`.\n     */\n    function burn(uint256 id, uint256 value) public onlyRole(BURN_ROLE) {\n        require(tokensBurnable, \"Burns are disabled\");\n\n        _burn(_owner, id, value);\n        tokenSupply[id] -= value;\n    }\n\n    /*\n     * Same functionality as `burn` but for a batch of tokens.\n     * Input `ids` and `values` must be in direct correlation,\n     * an index in both lists referring to the same token.\n     */\n    function burnBatch(uint256[] memory ids, uint256[] memory values)\n        public\n        onlyRole(BURN_ROLE)\n    {\n        require(tokensBurnable, \"Burns are disabled\");\n        _burnBatch(_owner, ids, values);\n        for (uint256 i = 0; i < ids.length; i++) {\n            tokenSupply[ids[i]] -= values[i];\n        }\n    }\n\n    /*\n     * Allows to transfer given `value` amount of tokens with `id`.\n     * `tokensTransferable` must be true and the tokens to be transferred must be owned by the `_owner`,\n     * at least `value` amount of tokens must exist.\n     * Only callable by accounts with `TRANSFER_ROLE` or `ADMIN_ROLE`.\n     */\n    function transferByOwner(\n        address to,\n        uint256 id,\n        uint256 amount\n    ) public onlyRole(TRANSFER_ROLE) {\n        require(tokensTransferable, \"Transfers are disabled\");\n        _safeTransferFrom(_owner, to, id, amount, \"\");\n    }\n\n    /*\n     * Same functionality as `transferByOwner` but for a batch of tokens.\n     * Input `ids` and `values` must be in direct correlation,\n     * an index in both lists referring to the same token.\n     */\n    function transferByOwnerBatch(\n        address[] memory to,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) public onlyRole(TRANSFER_ROLE) {\n        require(tokensTransferable, \"Transfers are disabled\");\n        for (uint256 i = 0; i < ids.length; i++) {\n            _safeTransferFrom(_owner, to[i], ids[i], amounts[i], \"\");\n        }\n    }\n\n    /*\n     * Allows to update contract configuration and revoke NFTPort's access to the contract.\n     * `baseURI` can only be updated if  `metadataUpdatable` is true.\n     * Tokens can only be made to not be transferable or updatable, not vice-versa.\n     * Only callable by accounts with `UPDATE_CONTRACT_ROLE` or `ADMIN_ROLE`.\n     */\n    function update(\n        Config.Runtime calldata newConfig,\n        RolesAddresses[] memory rolesAddresses,\n        bool isRevokeNFTPortPermissions\n    ) public onlyRole(UPDATE_CONTRACT_ROLE) {\n        // If metadata is frozen, baseURI cannot be updated\n        require(\n            metadataUpdatable ||\n                (keccak256(abi.encodePacked(newConfig.baseURI)) ==\n                    keccak256(abi.encodePacked(baseURI))),\n            \"Metadata is frozen\"\n        );\n\n        baseURI = newConfig.baseURI;\n        royaltiesAddress = newConfig.royaltiesAddress;\n        royaltiesBasisPoints = newConfig.royaltiesBps;\n\n        if (!newConfig.tokensTransferable) {\n            tokensTransferable = false;\n        }\n        if (!newConfig.metadataUpdatable && metadataUpdatable) {\n            metadataUpdatable = false;\n            emit PermanentURIGlobal();\n        }\n\n        _updateRoles(rolesAddresses);\n\n        if (isRevokeNFTPortPermissions) {\n            revokeNFTPortPermissions();\n        }\n    }\n\n    /*\n     * Allows to mint tokens by the contract `_owner`.\n     * Only callable by accounts with `MINT_ROLE` or `ADMIN_ROLE`.\n     */\n    function mintByOwner(\n        address account,\n        uint256 id,\n        uint256 amount,\n        string memory tokenUri\n    ) public onlyRole(MINT_ROLE) {\n        require(!_exists(id), \"NFT: token already minted\");\n        if (bytes(tokenUri).length > 0) {\n            _tokenURIs[id] = tokenUri;\n            emit URI(tokenUri, id);\n        }\n        _mint(account, id, amount, \"\");\n        tokenSupply[id] += amount;\n    }\n\n    /*\n     * Same functionality as `mintByOwner` but for a batch of tokens.\n     * Input `ids` and `values` must be in direct correlation,\n     * an index in both lists referring to the same token.\n     */\n    function mintByOwnerBatch(\n        address[] memory to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        string[] memory uris\n    ) public onlyRole(MINT_ROLE) {\n        for (uint256 i = 0; i < ids.length; i++) {\n            require(!_exists(ids[i]), \"One of tokens is already minted\");\n            require(\n                to[i] == address(to[i]),\n                \"NFT: one of addresses is invalid\"\n            );\n            require(amounts[i] > 0, \"NFT: all amounts must be > 0\");\n            tokenSupply[ids[i]] += amounts[i];\n            if (bytes(uris[i]).length > 0) {\n                _tokenURIs[ids[i]] = uris[i];\n                emit URI(uris[i], ids[i]);\n            }\n            _mint(to[i], ids[i], amounts[i], \"\");\n        }\n    }\n\n    /******************\n     * View functions *\n     ******************/\n\n    // Returns total supply for the given token ID\n    function totalSupply(uint256 _id) public view returns (uint256) {\n        return tokenSupply[_id];\n    }\n\n    /*\n     * Returns token URI for the given token ID.\n     * If token URI is not empty and base URI is not empty then returns base URI + token URI,\n     * if base URI is empty and token URI is not empty then returns just token URI.\n     * If the token URI for the given token ID is empty then returns the default token URI.\n     */\n    function uri(uint256 _id) public view override returns (string memory) {\n        if (bytes(_tokenURIs[_id]).length > 0) {\n            if (bytes(baseURI).length > 0) {\n                return string(abi.encodePacked(baseURI, _tokenURIs[_id]));\n            } else {\n                return _tokenURIs[_id];\n            }\n        } else {\n            return super.uri(_id);\n        }\n    }\n\n    // @dev ERC2981 token royalty info\n    function royaltyInfo(uint256, uint256 salePrice)\n        external\n        view\n        returns (address, uint256)\n    {\n        return (\n            royaltiesAddress,\n            (royaltiesBasisPoints * salePrice) / ROYALTIES_BASIS\n        );\n    }\n\n    /**\n    * @dev OpenSea contract metadata, returns a base64 encoded JSON string containing royalties basis points\n    * and royalties address\n    */\n    function contractURI() external view returns (string memory) {\n        string memory json = Base64.encode(\n            bytes(\n                string(\n                    abi.encodePacked(\n                        // solium-disable-next-line quotes\n                        '{\"seller_fee_basis_points\": ', // solhint-disable-line\n                        royaltiesBasisPoints.toString(),\n                        // solium-disable-next-line quotes\n                        ', \"fee_recipient\": \"', // solhint-disable-line\n                        uint256(uint160(royaltiesAddress)).toHexString(20),\n                        // solium-disable-next-line quotes\n                        '\"}' // solhint-disable-line\n                    )\n                )\n            )\n        );\n\n        string memory output = string(\n            abi.encodePacked(\"data:application/json;base64,\", json)\n        );\n\n        return output;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC1155Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return\n            ERC1155Upgradeable.supportsInterface(interfaceId) ||\n            interfaceId == type(IERC2981).interfaceId;\n    }\n\n    /*************\n     * Internals *\n     *************/\n\n    // Mapping of token ID to URI\n    mapping(uint256 => string) private _tokenURIs;\n\n    // Used for checking if token with given ID exists\n    function _exists(uint256 _tokenId) internal view virtual returns (bool) {\n        return tokenSupply[_tokenId] > 0;\n    }\n}"
    },
    {
      "filename": "evm-minting-master/contracts/templates/ERC1155NFTProduct.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport {IERC2981} from \"@openzeppelin/contracts/token/common/ERC2981.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"../lib/GranularRoles.sol\";\nimport \"../lib/Base64.sol\";\nimport \"../lib/Config.sol\";\nimport \"../lib/ITemplate.sol\";\n\n/*\n * ERC-1155 proxy contract, meaning it does not make use of a constructor,\n * but rather uses `initialize` with `initializer` modifier, see {Initializable}\n *\n * Minting and other write transactions only supported for accounts with relevant access rights.\n */\ncontract ERC1155NFTProduct is ERC1155Upgradeable, GranularRoles, ITemplate {\n    /*******************************\n     * Extensions, structs, events *\n     *******************************/\n\n    using Strings for uint256;\n\n    /*\n     * Event emitted to show opensea that metadata of a token is frozen,\n     * see https://docs.opensea.io/docs/metadata-standards\n     */\n    event PermanentURI(string _value, uint256 indexed _id);\n    // Event emitted to show that all tokens have their metadata frozen\n    event PermanentURIGlobal();\n\n    /*************\n     * Constants *\n     *************/\n\n    // Template name\n    string public constant NAME = \"ERC1155NFTProduct\";\n    // Template version\n    uint256 public constant VERSION = 1_00_00;\n\n    // Basis for calculating royalties.\n    // This has to be 10k for royaltiesBps to be in basis points.\n    uint16 public constant ROYALTIES_BASIS = 10000;\n    // Default URI for tokens, each minted token will have a token URI, so default URI is empty\n    string public constant DEFAULT_URI = \"\";\n\n    /********************\n     * Public variables *\n     ********************/\n\n    // If true then tokens metadata can be updated\n    bool public metadataUpdatable;\n    // If true then tokens can be burned by their owners\n    bool public tokensBurnable;\n    // If true then tokens can be transferred by having the correct access rights {GranularRoles-TRANSFER_ROLE}\n    // if the token is owned by {GranularRoles-_owner} address\n    bool public tokensTransferable;\n\n    // Token name\n    string public name;\n    // Token symbol\n    string public symbol;\n    // Token IDs are returned as `baseURI` + `tokenURI`\n    string public baseURI;\n\n    // Address where royalties will be transferred to\n    address public royaltiesAddress;\n    // Secondary market royalties in basis points (100 bps = 1%). Royalties use ERC2981 standard and support\n    // OpenSea standard.\n    uint256 public royaltiesBasisPoints;\n\n    // Mapping of individually frozen tokens\n    mapping(uint256 => bool) public freezeTokenUris;\n    // Mapping of token ID to supply\n    mapping(uint256 => uint256) public tokenSupply;\n\n    /***************************\n     * Contract initialization *\n     ***************************/\n\n    constructor() initializer {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    // Can only be called once, used because constructors cannot be used for proxy contracts\n    function initialize(\n        Config.Deployment memory deploymentConfig,\n        Config.Runtime memory runtimeConfig,\n        RolesAddresses[] memory rolesAddresses\n    ) public initializer {\n        __ERC1155_init(DEFAULT_URI);\n\n        royaltiesAddress = runtimeConfig.royaltiesAddress;\n        royaltiesBasisPoints = runtimeConfig.royaltiesBps;\n\n        metadataUpdatable = runtimeConfig.metadataUpdatable;\n        tokensBurnable = deploymentConfig.tokensBurnable;\n        tokensTransferable = runtimeConfig.tokensTransferable;\n\n        name = deploymentConfig.name;\n        symbol = deploymentConfig.symbol;\n        baseURI = runtimeConfig.baseURI;\n\n        _initRoles(deploymentConfig.owner, rolesAddresses);\n    }\n\n    /*******************\n     * Write functions *\n     *******************/\n\n    // Allows to set a default URI for tokens, which is only returned if token URI does not exist for given token ID\n    function setURI(string memory _newURI)\n        public\n        onlyRole(UPDATE_CONTRACT_ROLE)\n    {\n        _setURI(_newURI);\n    }\n\n    /*\n     * Allows to update token URI for given `_tokenId` and freeze it.\n     * For the transaction to succeed either `_newUri` or `_isFreezeTokenUri` as true must be specified, or both.\n     * The `_newURI` cannot be the same as the current URI for the token.\n     *\n     * Token ID must exist, `metadataUpdatable` must be true and token URI for given token cannot be frozen.\n     * Only callable by accounts with `UPDATE_TOKEN_ROLE` or `ADMIN_ROLE`.\n     */\n    function updateTokenUri(\n        uint256 _tokenId,\n        string memory _newUri,\n        bool _isFreezeTokenUri\n    ) public onlyRole(UPDATE_TOKEN_ROLE) {\n        require(_exists(_tokenId), \"Token does not exist\");\n        require(metadataUpdatable, \"Metadata is frozen\");\n        require(freezeTokenUris[_tokenId] != true, \"Token is frozen\");\n        require(\n            _isFreezeTokenUri || (bytes(_newUri).length != 0),\n            \"Either _newUri or _isFreezeTokenUri=true required\"\n        );\n\n        if (bytes(_newUri).length != 0) {\n            require(\n                keccak256(bytes(_tokenURIs[_tokenId])) !=\n                    keccak256(bytes(string(abi.encodePacked(_newUri)))),\n                \"New token URI is same as updated\"\n            );\n            _tokenURIs[_tokenId] = _newUri;\n            emit URI(_newUri, _tokenId);\n        }\n        if (_isFreezeTokenUri) {\n            freezeTokenUris[_tokenId] = true;\n            emit PermanentURI(_tokenURIs[_tokenId], _tokenId);\n        }\n    }\n\n    /*\n     * Allows to burn given `value` amount of tokens with `id`.\n     * `tokensBurnable` must be true in order for the transaction to succeed and\n     * at least `value` amount of tokens must exist.\n     * Only callable by accounts with `BURN_ROLE` or `ADMIN_ROLE`.\n     */\n    function burn(uint256 id, uint256 value) public onlyRole(BURN_ROLE) {\n        require(tokensBurnable, \"Burns are disabled\");\n\n        _burn(_owner, id, value);\n        tokenSupply[id] -= value;\n    }\n\n    /*\n     * Same functionality as `burn` but for a batch of tokens.\n     * Input `ids` and `values` must be in direct correlation,\n     * an index in both lists referring to the same token.\n     */\n    function burnBatch(uint256[] memory ids, uint256[] memory values)\n        public\n        onlyRole(BURN_ROLE)\n    {\n        require(tokensBurnable, \"Burns are disabled\");\n        _burnBatch(_owner, ids, values);\n        for (uint256 i = 0; i < ids.length; i++) {\n            tokenSupply[ids[i]] -= values[i];\n        }\n    }\n\n    /*\n     * Allows to transfer given `value` amount of tokens with `id`.\n     * `tokensTransferable` must be true and the tokens to be transferred must be owned by the `_owner`,\n     * at least `value` amount of tokens must exist.\n     * Only callable by accounts with `TRANSFER_ROLE` or `ADMIN_ROLE`.\n     */\n    function transferByOwner(\n        address to,\n        uint256 id,\n        uint256 amount\n    ) public onlyRole(TRANSFER_ROLE) {\n        require(tokensTransferable, \"Transfers are disabled\");\n        _safeTransferFrom(_owner, to, id, amount, \"\");\n    }\n\n    /*\n     * Same functionality as `transferByOwner` but for a batch of tokens.\n     * Input `ids` and `values` must be in direct correlation,\n     * an index in both lists referring to the same token.\n     */\n    function transferByOwnerBatch(\n        address[] memory to,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) public onlyRole(TRANSFER_ROLE) {\n        require(tokensTransferable, \"Transfers are disabled\");\n        for (uint256 i = 0; i < ids.length; i++) {\n            _safeTransferFrom(_owner, to[i], ids[i], amounts[i], \"\");\n        }\n    }\n\n    /*\n     * Allows to update contract configuration and revoke NFTPort's access to the contract.\n     * `baseURI` can only be updated if  `metadataUpdatable` is true.\n     * Tokens can only be made to not be transferable or updatable, not vice-versa.\n     * Only callable by accounts with `UPDATE_CONTRACT_ROLE` or `ADMIN_ROLE`.\n     */\n    function update(\n        Config.Runtime calldata newConfig,\n        RolesAddresses[] memory rolesAddresses,\n        bool isRevokeNFTPortPermissions\n    ) public onlyRole(UPDATE_CONTRACT_ROLE) {\n        // If metadata is frozen, baseURI cannot be updated\n        require(\n            metadataUpdatable ||\n                (keccak256(abi.encodePacked(newConfig.baseURI)) ==\n                    keccak256(abi.encodePacked(baseURI))),\n            \"Metadata is frozen\"\n        );\n\n        baseURI = newConfig.baseURI;\n        royaltiesAddress = newConfig.royaltiesAddress;\n        royaltiesBasisPoints = newConfig.royaltiesBps;\n\n        if (!newConfig.tokensTransferable) {\n            tokensTransferable = false;\n        }\n        if (!newConfig.metadataUpdatable && metadataUpdatable) {\n            metadataUpdatable = false;\n            emit PermanentURIGlobal();\n        }\n\n        _updateRoles(rolesAddresses);\n\n        if (isRevokeNFTPortPermissions) {\n            revokeNFTPortPermissions();\n        }\n    }\n\n    /*\n     * Allows to mint tokens by the contract `_owner`.\n     * Only callable by accounts with `MINT_ROLE` or `ADMIN_ROLE`.\n     */\n    function mintByOwner(\n        address account,\n        uint256 id,\n        uint256 amount,\n        string memory tokenUri\n    ) public onlyRole(MINT_ROLE) {\n        require(!_exists(id), \"NFT: token already minted\");\n        if (bytes(tokenUri).length > 0) {\n            _tokenURIs[id] = tokenUri;\n            emit URI(tokenUri, id);\n        }\n        _mint(account, id, amount, \"\");\n        tokenSupply[id] += amount;\n    }\n\n    /*\n     * Same functionality as `mintByOwner` but for a batch of tokens.\n     * Input `ids` and `values` must be in direct correlation,\n     * an index in both lists referring to the same token.\n     */\n    function mintByOwnerBatch(\n        address[] memory to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        string[] memory uris\n    ) public onlyRole(MINT_ROLE) {\n        for (uint256 i = 0; i < ids.length; i++) {\n            require(!_exists(ids[i]), \"One of tokens is already minted\");\n            require(\n                to[i] == address(to[i]),\n                \"NFT: one of addresses is invalid\"\n            );\n            require(amounts[i] > 0, \"NFT: all amounts must be > 0\");\n            tokenSupply[ids[i]] += amounts[i];\n            if (bytes(uris[i]).length > 0) {\n                _tokenURIs[ids[i]] = uris[i];\n                emit URI(uris[i], ids[i]);\n            }\n            _mint(to[i], ids[i], amounts[i], \"\");\n        }\n    }\n\n    /******************\n     * View functions *\n     ******************/\n\n    // Returns total supply for the given token ID\n    function totalSupply(uint256 _id) public view returns (uint256) {\n        return tokenSupply[_id];\n    }\n\n    /*\n     * Returns token URI for the given token ID.\n     * If token URI is not empty and base URI is not empty then returns base URI + token URI,\n     * if base URI is empty and token URI is not empty then returns just token URI.\n     * If the token URI for the given token ID is empty then returns the default token URI.\n     */\n    function uri(uint256 _id) public view override returns (string memory) {\n        if (bytes(_tokenURIs[_id]).length > 0) {\n            if (bytes(baseURI).length > 0) {\n                return string(abi.encodePacked(baseURI, _tokenURIs[_id]));\n            } else {\n                return _tokenURIs[_id];\n            }\n        } else {\n            return super.uri(_id);\n        }\n    }\n\n    // @dev ERC2981 token royalty info\n    function royaltyInfo(uint256, uint256 salePrice)\n        external\n        view\n        returns (address, uint256)\n    {\n        return (\n            royaltiesAddress,\n            (royaltiesBasisPoints * salePrice) / ROYALTIES_BASIS\n        );\n    }\n\n    /**\n    * @dev OpenSea contract metadata, returns a base64 encoded JSON string containing royalties basis points\n    * and royalties address\n    */\n    function contractURI() external view returns (string memory) {\n        string memory json = Base64.encode(\n            bytes(\n                string(\n                    abi.encodePacked(\n                        // solium-disable-next-line quotes\n                        '{\"seller_fee_basis_points\": ', // solhint-disable-line\n                        royaltiesBasisPoints.toString(),\n                        // solium-disable-next-line quotes\n                        ', \"fee_recipient\": \"', // solhint-disable-line\n                        uint256(uint160(royaltiesAddress)).toHexString(20),\n                        // solium-disable-next-line quotes\n                        '\"}' // solhint-disable-line\n                    )\n                )\n            )\n        );\n\n        string memory output = string(\n            abi.encodePacked(\"data:application/json;base64,\", json)\n        );\n\n        return output;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC1155Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return\n            ERC1155Upgradeable.supportsInterface(interfaceId) ||\n            interfaceId == type(IERC2981).interfaceId;\n    }\n\n    /*************\n     * Internals *\n     *************/\n\n    // Mapping of token ID to URI\n    mapping(uint256 => string) private _tokenURIs;\n\n    // Used for checking if token with given ID exists\n    function _exists(uint256 _tokenId) internal view virtual returns (bool) {\n        return tokenSupply[_tokenId] > 0;\n    }\n}"
    },
    {
      "filename": "evm-minting-master/contracts/templates/ERC1155NFTProduct.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport {IERC2981} from \"@openzeppelin/contracts/token/common/ERC2981.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"../lib/GranularRoles.sol\";\nimport \"../lib/Base64.sol\";\nimport \"../lib/Config.sol\";\nimport \"../lib/ITemplate.sol\";\n\n/*\n * ERC-1155 proxy contract, meaning it does not make use of a constructor,\n * but rather uses `initialize` with `initializer` modifier, see {Initializable}\n *\n * Minting and other write transactions only supported for accounts with relevant access rights.\n */\ncontract ERC1155NFTProduct is ERC1155Upgradeable, GranularRoles, ITemplate {\n    /*******************************\n     * Extensions, structs, events *\n     *******************************/\n\n    using Strings for uint256;\n\n    /*\n     * Event emitted to show opensea that metadata of a token is frozen,\n     * see https://docs.opensea.io/docs/metadata-standards\n     */\n    event PermanentURI(string _value, uint256 indexed _id);\n    // Event emitted to show that all tokens have their metadata frozen\n    event PermanentURIGlobal();\n\n    /*************\n     * Constants *\n     *************/\n\n    // Template name\n    string public constant NAME = \"ERC1155NFTProduct\";\n    // Template version\n    uint256 public constant VERSION = 1_00_00;\n\n    // Basis for calculating royalties.\n    // This has to be 10k for royaltiesBps to be in basis points.\n    uint16 public constant ROYALTIES_BASIS = 10000;\n    // Default URI for tokens, each minted token will have a token URI, so default URI is empty\n    string public constant DEFAULT_URI = \"\";\n\n    /********************\n     * Public variables *\n     ********************/\n\n    // If true then tokens metadata can be updated\n    bool public metadataUpdatable;\n    // If true then tokens can be burned by their owners\n    bool public tokensBurnable;\n    // If true then tokens can be transferred by having the correct access rights {GranularRoles-TRANSFER_ROLE}\n    // if the token is owned by {GranularRoles-_owner} address\n    bool public tokensTransferable;\n\n    // Token name\n    string public name;\n    // Token symbol\n    string public symbol;\n    // Token IDs are returned as `baseURI` + `tokenURI`\n    string public baseURI;\n\n    // Address where royalties will be transferred to\n    address public royaltiesAddress;\n    // Secondary market royalties in basis points (100 bps = 1%). Royalties use ERC2981 standard and support\n    // OpenSea standard.\n    uint256 public royaltiesBasisPoints;\n\n    // Mapping of individually frozen tokens\n    mapping(uint256 => bool) public freezeTokenUris;\n    // Mapping of token ID to supply\n    mapping(uint256 => uint256) public tokenSupply;\n\n    /***************************\n     * Contract initialization *\n     ***************************/\n\n    constructor() initializer {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    // Can only be called once, used because constructors cannot be used for proxy contracts\n    function initialize(\n        Config.Deployment memory deploymentConfig,\n        Config.Runtime memory runtimeConfig,\n        RolesAddresses[] memory rolesAddresses\n    ) public initializer {\n        __ERC1155_init(DEFAULT_URI);\n\n        royaltiesAddress = runtimeConfig.royaltiesAddress;\n        royaltiesBasisPoints = runtimeConfig.royaltiesBps;\n\n        metadataUpdatable = runtimeConfig.metadataUpdatable;\n        tokensBurnable = deploymentConfig.tokensBurnable;\n        tokensTransferable = runtimeConfig.tokensTransferable;\n\n        name = deploymentConfig.name;\n        symbol = deploymentConfig.symbol;\n        baseURI = runtimeConfig.baseURI;\n\n        _initRoles(deploymentConfig.owner, rolesAddresses);\n    }\n\n    /*******************\n     * Write functions *\n     *******************/\n\n    // Allows to set a default URI for tokens, which is only returned if token URI does not exist for given token ID\n    function setURI(string memory _newURI)\n        public\n        onlyRole(UPDATE_CONTRACT_ROLE)\n    {\n        _setURI(_newURI);\n    }\n\n    /*\n     * Allows to update token URI for given `_tokenId` and freeze it.\n     * For the transaction to succeed either `_newUri` or `_isFreezeTokenUri` as true must be specified, or both.\n     * The `_newURI` cannot be the same as the current URI for the token.\n     *\n     * Token ID must exist, `metadataUpdatable` must be true and token URI for given token cannot be frozen.\n     * Only callable by accounts with `UPDATE_TOKEN_ROLE` or `ADMIN_ROLE`.\n     */\n    function updateTokenUri(\n        uint256 _tokenId,\n        string memory _newUri,\n        bool _isFreezeTokenUri\n    ) public onlyRole(UPDATE_TOKEN_ROLE) {\n        require(_exists(_tokenId), \"Token does not exist\");\n        require(metadataUpdatable, \"Metadata is frozen\");\n        require(freezeTokenUris[_tokenId] != true, \"Token is frozen\");\n        require(\n            _isFreezeTokenUri || (bytes(_newUri).length != 0),\n            \"Either _newUri or _isFreezeTokenUri=true required\"\n        );\n\n        if (bytes(_newUri).length != 0) {\n            require(\n                keccak256(bytes(_tokenURIs[_tokenId])) !=\n                    keccak256(bytes(string(abi.enc"
    }
  ]
}