{
  "Title": "[M-18] Fees from delisted pool still in reward handler will become stuck after delisting",
  "Content": "_Submitted by 0x52_\n\nUnclaimed fees from pool will be stuck.\n\n### Proof of Concept\n\nWhen delisting a pool the pool's reference is removed from address provider:\n\n<https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L63>\n\nBurning fees calls a dynamic list of all pools which no longer contains the delisted pool:\n\n<https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L39>\n\nSince the list no longer contains the pool those fees will not be processed and will remain stuck in the contract\n\n### Recommended Mitigation Steps\n\nCall burnFees() before delisting a pool.\n\n**[danhper (Backd) confirmed](https://github.com/code-423n4/2022-05-backd-findings/issues/135)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-05-backd-findings/issues/135#issuecomment-1163376879):**\n > The warden has shown how, by removing a pool before calling `burnFees`, the removed pool will not receive the portion of fees that it should.\n> \n> Because this finding related to loss of yield, I believe Medium Severity to be appropriate.\n\n\n\n***\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-backd-tokenomics-contest",
  "Code": [
    {
      "filename": "protocol/contracts/Controller.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"../interfaces/actions/IAction.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IStakerVault.sol\";\nimport \"../interfaces/pool/ILiquidityPool.sol\";\nimport \"../interfaces/tokenomics/IInflationManager.sol\";\n\nimport \"../libraries/AddressProviderHelpers.sol\";\nimport \"../libraries/UncheckedMath.sol\";\n\nimport \"./utils/Preparable.sol\";\nimport \"./access/Authorization.sol\";\n\ncontract Controller is IController, Authorization, Preparable {\n    using UncheckedMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    IAddressProvider public immutable override addressProvider;\n\n    IInflationManager public inflationManager;\n\n    bytes32 internal constant _KEEPER_REQUIRED_STAKED_BKD = \"KEEPER_REQUIRED_STAKED_BKD\";\n\n    constructor(IAddressProvider _addressProvider)\n        Authorization(_addressProvider.getRoleManager())\n    {\n        addressProvider = _addressProvider;\n    }\n\n    function setInflationManager(address _inflationManager) external onlyGovernance {\n        require(address(inflationManager) == address(0), Error.ADDRESS_ALREADY_SET);\n        require(_inflationManager != address(0), Error.INVALID_ARGUMENT);\n        inflationManager = IInflationManager(_inflationManager);\n    }\n\n    function addStakerVault(address stakerVault)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.POOL_FACTORY)\n        returns (bool)\n    {\n        if (!addressProvider.addStakerVault(stakerVault)) {\n            return false;\n        }\n        if (address(inflationManager) != address(0)) {\n            address lpGauge = IStakerVault(stakerVault).getLpGauge();\n            if (lpGauge != address(0)) {\n                inflationManager.whitelistGauge(lpGauge);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Delists pool.\n     * @param pool Address of pool to delist.\n     * @return `true` if successful.\n     */\n    function removePool(address pool) external override onlyGovernance returns (bool) {\n        if (!addressProvider.removePool(pool)) {\n            return false;\n        }\n        address lpToken = ILiquidityPool(pool).getLpToken();\n\n        if (address(inflationManager) != address(0)) {\n            (bool exists, address stakerVault) = addressProvider.tryGetStakerVault(lpToken);\n            if (exists) {\n                inflationManager.removeStakerVaultFromInflation(stakerVault, lpToken);\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Prepares the minimum amount of staked BKD required by a keeper\n     */\n    function prepareKeeperRequiredStakedBKD(uint256 amount) external override onlyGovernance {\n        require(addressProvider.getBKDLocker() != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        _prepare(_KEEPER_REQUIRED_STAKED_BKD, amount);\n    }\n\n    /**\n     * @notice Resets the minimum amount of staked BKD required by a keeper\n     */\n    function resetKeeperRequiredStakedBKD() external override onlyGovernance {\n        _resetUInt256Config(_KEEPER_REQUIRED_STAKED_BKD);\n    }\n\n    /**\n     * @notice Sets the minimum amount of staked BKD required by a keeper to the prepared value\n     */\n    function executeKeeperRequiredStakedBKD() external override {\n        _executeUInt256(_KEEPER_REQUIRED_STAKED_BKD);\n    }\n\n    /**\n     * @notice Returns true if the given keeper has enough staked BKD to execute actions\n     */\n    function canKeeperExecuteAction(address keeper) external view override returns (bool) {\n        uint256 requiredBKD = getKeeperRequiredStakedBKD();\n        return\n            requiredBKD == 0 ||\n            IERC20(addressProvider.getBKDLocker()).balanceOf(keeper) >= requiredBKD;\n    }\n\n    /**\n     * @return Returns the minimum amount of staked BKD required by a keeper\n     */\n    function getKeeperRequiredStakedBKD() public view override returns (uint256) {\n        return currentUInts256[_KEEPER_REQUIRED_STAKED_BKD];\n    }\n\n    /**\n     * @return the total amount of ETH require by `payer` to cover the fees for\n     * positions registered in all actions\n     */\n    function getTotalEthRequiredForGas(address payer) external view override returns (uint256) {\n        // solhint-disable-previous-line ordering\n        uint256 totalEthRequired;\n        address[] memory actions = addressProvider.allActions();\n        uint256 numActions = actions.length;\n        for (uint256 i; i < numActions; i = i.uncheckedInc()) {\n            totalEthRequired += IAction(actions[i]).getEthRequiredForGas(payer);\n        }\n        return totalEthRequired;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/RewardHandler.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/IFeeBurner.sol\";\nimport \"../interfaces/IBkdLocker.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/IRewardHandler.sol\";\nimport \"./utils/Preparable.sol\";\nimport \"./access/Authorization.sol\";\nimport \"../libraries/AddressProviderHelpers.sol\";\nimport \"../libraries/UncheckedMath.sol\";\n\ncontract RewardHandler is IRewardHandler, Preparable, Authorization {\n    using UncheckedMath for uint256;\n    using SafeERC20 for IERC20;\n    using AddressProviderHelpers for IAddressProvider;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = IAddressProvider(controller.addressProvider());\n    }\n\n    receive() external payable {}\n\n    /**\n     * @notice Burns all accumulated fees and pays these out to the BKD locker.\n     */\n    function burnFees() external override {\n        IBkdLocker bkdLocker = IBkdLocker(addressProvider.getBKDLocker());\n        IFeeBurner feeBurner = addressProvider.getFeeBurner();\n        address targetLpToken = bkdLocker.rewardToken();\n        address[] memory pools = addressProvider.allPools();\n        uint256 ethBalance = address(this).balance;\n        address[] memory tokens = new address[](pools.length);\n        for (uint256 i; i < pools.length; i = i.uncheckedInc()) {\n            ILiquidityPool pool = ILiquidityPool(pools[i]);\n            address underlying = pool.getUnderlying();\n            if (underlying != address(0)) {\n                _approve(underlying, address(feeBurner));\n            }\n            tokens[i] = underlying;\n        }\n        feeBurner.burnToTarget{value: ethBalance}(tokens, targetLpToken);\n        uint256 burnedAmount = IERC20(targetLpToken).balanceOf(address(this));\n        IERC20(targetLpToken).safeApprove(address(bkdLocker), burnedAmount);\n        bkdLocker.depositFees(burnedAmount);\n        emit Burned(targetLpToken, burnedAmount);\n    }\n\n    /**\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     */\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) > 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n}"
    }
  ]
}