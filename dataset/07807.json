{
  "Title": "[M-07] Oracleâ€™s two-day feature can be gamed",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L124\n\n\n# Vulnerability details\n\n## Impact\nThe two-day feature of the oracle can be gamed where you only have to manipulate the oracle for ~2 blocks.\n\n## Proof of Concept\nThe oracle computes the day using:\n```sol\nuint day = block.timestamp / 1 days;\n```\n\nSince we're working with `uint` values here, the following is true:\n$1728799 / 86400 = 1$\n$172800 / 86400 = 2$\n\nMeaning, if you manipulate the oracle at the last block of day $X$, e.g. 23:59:50, and at the first block of day $X + 1$, e.g. 00:00:02, you bypass the two-day feature of the oracle. You only have to manipulate the oracle for two blocks.\n\nThis is quite hard to pull off. I'm also not sure whether there were any instances of Chainlink oracle manipulation before. But, since you designed this feature to prevent small timeframe oracle manipulation I think it's valid to point this out.\n\n## Tools Used\nnone\n\n## Recommended Mitigation Steps\nIf you increase it to a three-day interval you can fix this issue. Then, the oracle has to be manipulated for at least 24 hours.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-10-inverse-finance-contest",
  "Code": [
    {
      "filename": "src/Oracle.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ninterface IChainlinkFeed {\n    function decimals() external view returns (uint8);\n    function latestAnswer() external view returns (uint);\n}\n\n/**\n@title Oracle\n@notice Oracle used by markets. Can use both fixed price feeds and Chainlink-style feeds for prices.\nThe Pessimistic Oracle introduces collateral factor into the pricing formula. It ensures that any given oracle price is dampened to prevent borrowers from borrowing more than the lowest recorded value of their collateral over the past 2 days.\nThis has the advantage of making price manipulation attacks more difficult, as an attacker needs to log artificially high lows.\nIt has the disadvantage of reducing borrow power of borrowers to a 2-day minimum value of their collateral, where the value must have been seen by the oracle.\n*/\ncontract Oracle {\n\n    struct FeedData {\n        IChainlinkFeed feed;\n        uint8 tokenDecimals;\n    }\n\n    address public operator;\n    address public pendingOperator;\n    mapping (address => FeedData) public feeds;\n    mapping (address => uint) public fixedPrices;\n    mapping (address => mapping(uint => uint)) public dailyLows; // token => day => price\n\n    constructor(\n        address _operator\n    ) {\n        operator = _operator;\n    }\n\n    modifier onlyOperator {\n        require(msg.sender == operator, \"ONLY OPERATOR\");\n        _;\n    }\n    \n    /**\n    @notice Sets the pending operator of the oracle. Only callable by operator.\n    @param newOperator_ The address of the pending operator.\n    */\n    function setPendingOperator(address newOperator_) public onlyOperator { pendingOperator = newOperator_; }\n\n    /**\n    @notice Sets the price feed of a specific token address.\n    @dev Even though the price feeds implement the chainlink interface, it's possible to use other price oracle.\n    @param token Address of the ERC20 token to set a feed for\n    @param feed The chainlink feed of the ERC20 token.\n    @param tokenDecimals uint8 representing the decimal precision of the token\n    */\n    function setFeed(address token, IChainlinkFeed feed, uint8 tokenDecimals) public onlyOperator { feeds[token] = FeedData(feed, tokenDecimals); }\n\n    /**\n    @notice Sets a fixed price for a token\n    @dev Be careful when setting this. Assuming a fixed price where one doesn't exist can have disastrous consequences.\n    @param token The address of the fixed price token\n    @param price The fixed price of the token. Remember to account for decimal precision when setting this.\n    */\n    function setFixedPrice(address token, uint price) public onlyOperator { fixedPrices[token] = price; }\n\n    /**\n    @notice Claims the operator role. Only successfully callable by the pending operator.\n    */\n    function claimOperator() public {\n        require(msg.sender == pendingOperator, \"ONLY PENDING OPERATOR\");\n        operator = pendingOperator;\n        pendingOperator = address(0);\n        emit ChangeOperator(operator);\n    }\n\n    /**\n    @notice Gets the price of a specific token in DOLA\n    @param token The address of the token to get price of\n    @return The price of the token in DOLA, adjusted for token and feed decimals\n    */\n    function viewPrice(address token, uint collateralFactorBps) external view returns (uint) {\n        if(fixedPrices[token] > 0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price > 0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 - feedDecimals - tokenDecimals;\n            uint normalizedPrice = price * (10 ** decimals);\n            uint day = block.timestamp / 1 days;\n            // get today's low\n            uint todaysLow = dailyLows[token][day];\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day - 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n\n    /**\n    @notice Gets the price of a specific token in DOLA while also saving the price if it is the day's lowest.\n    @param token The address of the token to get price of\n    @return The price of the token in DOLA, adjusted for token and feed decimals\n    */\n    function getPrice(address token, uint collateralFactorBps) external returns (uint) {\n        if(fixedPrices[token] > 0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price > 0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 - feedDecimals - tokenDecimals;\n            uint normalizedPrice = price * (10 ** decimals);\n            // potentially store price as today's low\n            uint day = block.timestamp / 1 days;\n            uint todaysLow = dailyLows[token][day];\n            if(todaysLow == 0 || normalizedPrice < todaysLow) {\n                dailyLows[token][day] = normalizedPrice;\n                todaysLow = normalizedPrice;\n                emit RecordDailyLow(token, normalizedPrice);\n            }\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day - 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n\n    event ChangeOperator(address indexed newOperator);\n    event RecordDailyLow(address indexed token, uint price);\n\n}"
    }
  ]
}