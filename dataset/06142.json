{
  "Title": "[L-10] Avoid minting handles that have a `tokenId` of 0 in `mintHandle()`",
  "Content": "\nWhen a handle is minted, its `tokenId` is computed as the `keccak256` hash of the handle name:\n\n[LensHandles.sol#L182-L184](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/namespaces/LensHandles.sol#L182-L184)\n\n```solidity\n    function getTokenId(string memory localName) public pure returns (uint256) {\n        return uint256(keccak256(bytes(localName)));\n    }\n```\n\nHowever, `_mintHandle()` does not ensure that the `tokenId` minted is not 0:\n\n[LensHandles.sol#L194-L200](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/namespaces/LensHandles.sol#L194-L200)\n\n```solidity\n    function _mintHandle(address to, string calldata localName) internal returns (uint256) {\n        uint256 tokenId = getTokenId(localName);\n        _mint(to, tokenId);\n        _localNames[tokenId] = localName;\n        emit HandlesEvents.HandleMinted(localName, NAMESPACE, tokenId, to, block.timestamp);\n        return tokenId;\n    }\n```\n\nThis makes it theoretically possible to mint a handle with a `tokenId` of 0, which is problematic as `tokenId == 0` is treated as a default value in the protocol. For example, `getDefaultHandle()` in `TokenHandleRegistry` returns profile ID as 0 when the handle `tokenId` is 0:\n\n[TokenHandleRegistry.sol#L100-L102](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/namespaces/TokenHandleRegistry.sol#L100-L102)\n\n```solidity\n        if (resolvedTokenId == 0 || !ILensHub(LENS_HUB).exists(resolvedTokenId)) {\n            return 0;\n        }\n```\n\n### Recommendation\n\nIn `_mintHandle()`, consider checking that `tokenId` is non-zero to protect against the extremely unlikely event where a `localName` results in `tokenId = 0`:\n\n[LensHandles.sol#L194-L200](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/namespaces/LensHandles.sol#L194-L200)\n\n```diff\n    function _mintHandle(address to, string calldata localName) internal returns (uint256) {\n        uint256 tokenId = getTokenId(localName);\n+       if (tokenId == 0) revert InvalidHandle();\n        _mint(to, tokenId);\n        _localNames[tokenId] = localName;\n        emit HandlesEvents.HandleMinted(localName, NAMESPACE, tokenId, to, block.timestamp);\n        return tokenId;\n    }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-lens",
  "Code": [
    {
      "filename": "contracts/namespaces/LensHandles.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport {ImmutableOwnable} from 'contracts/misc/ImmutableOwnable.sol';\nimport {ILensHandles} from 'contracts/interfaces/ILensHandles.sol';\nimport {HandlesEvents} from 'contracts/namespaces/constants/Events.sol';\nimport {HandlesErrors} from 'contracts/namespaces/constants/Errors.sol';\nimport {HandleTokenURILib} from 'contracts/libraries/token-uris/HandleTokenURILib.sol';\nimport {ILensHub} from 'contracts/interfaces/ILensHub.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * A handle is defined as a local name inside a namespace context. A handle is represented as the local name with its\n * namespace applied as a suffix, using the dot symbol as separator.\n *\n *      handle = ${localName}.${namespace}\n *\n * Handle and local name can be used interchangeably once you are in a context of a namespace, as it became redundant.\n *\n *      handle === ${localName} ; inside some namespace.\n */\ncontract LensHandles is ERC721, ImmutableOwnable, ILensHandles {\n    using Address for address;\n\n    uint256 internal constant MAX_HANDLE_LENGTH = 31;\n    string internal constant NAMESPACE = 'lens';\n    uint256 internal immutable NAMESPACE_LENGTH = bytes(NAMESPACE).length;\n    uint256 internal constant SEPARATOR_LENGTH = 1; // bytes('.').length;\n    bytes32 internal constant NAMESPACE_HASH = keccak256(bytes(NAMESPACE));\n    uint256 internal immutable TOKEN_GUARDIAN_COOLDOWN;\n\n    mapping(address => uint256) internal _tokenGuardianDisablingTimestamp;\n\n    mapping(uint256 tokenId => string localName) internal _localNames;\n\n    modifier onlyOwnerOrWhitelistedProfileCreator() {\n        if (\n            msg.sender != OWNER && !ILensHub(LENS_HUB).isProfileCreatorWhitelisted(msg.sender)\n        ) {\n            revert HandlesErrors.NotOwnerNorWhitelisted();\n        }\n        _;\n    }\n\n    modifier onlyEOA() {\n        if (msg.sender.isContract()) {\n            revert HandlesErrors.NotEOA();\n        }\n        _;\n    }\n\n    modifier onlyHub() {\n        if (msg.sender != LENS_HUB) {\n            revert HandlesErrors.NotHub();\n        }\n        _;\n    }\n\n    constructor(\n        address owner,\n        address lensHub,\n        uint256 tokenGuardianCooldown\n    ) ERC721('', '') ImmutableOwnable(owner, lensHub) {\n        TOKEN_GUARDIAN_COOLDOWN = tokenGuardianCooldown;\n    }\n\n    function name() public pure override returns (string memory) {\n        return string.concat(symbol(), ' Handles');\n    }\n\n    function symbol() public pure override returns (string memory) {\n        return string.concat('.', NAMESPACE);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        _requireMinted(tokenId);\n        return HandleTokenURILib.getTokenURI(tokenId, _localNames[tokenId]);\n    }\n\n    /// @inheritdoc ILensHandles\n    function mintHandle(address to, string calldata localName)\n        external\n        onlyOwnerOrWhitelistedProfileCreator\n        returns (uint256)\n    {\n        _validateLocalName(localName);\n        return _mintHandle(to, localName);\n    }\n\n    function migrateHandle(address to, string calldata localName) external onlyHub returns (uint256) {\n        _validateLocalNameMigration(localName);\n        return _mintHandle(to, localName);\n    }\n\n    function burn(uint256 tokenId) external {\n        if (msg.sender != ownerOf(tokenId)) {\n            revert HandlesErrors.NotOwner();\n        }\n        _burn(tokenId);\n        delete _localNames[tokenId];\n    }\n\n    /// ************************************\n    /// ****  TOKEN GUARDIAN FUNCTIONS  ****\n    /// ************************************\n\n    function DANGER__disableTokenGuardian() external onlyEOA {\n        if (_tokenGuardianDisablingTimestamp[msg.sender] != 0) {\n            revert HandlesErrors.DisablingAlreadyTriggered();\n        }\n        _tokenGuardianDisablingTimestamp[msg.sender] = block.timestamp + TOKEN_GUARDIAN_COOLDOWN;\n        emit HandlesEvents.TokenGuardianStateChanged({\n            wallet: msg.sender,\n            enabled: false,\n            tokenGuardianDisablingTimestamp: block.timestamp + TOKEN_GUARDIAN_COOLDOWN,\n            timestamp: block.timestamp\n        });\n    }\n\n    function enableTokenGuardian() external onlyEOA {\n        if (_tokenGuardianDisablingTimestamp[msg.sender] == 0) {\n            revert HandlesErrors.AlreadyEnabled();\n        }\n        _tokenGuardianDisablingTimestamp[msg.sender] = 0;\n        emit HandlesEvents.TokenGuardianStateChanged({\n            wallet: msg.sender,\n            enabled: true,\n            tokenGuardianDisablingTimestamp: 0,\n            timestamp: block.timestamp\n        });\n    }\n\n    function approve(address to, uint256 tokenId) public override(IERC721, ERC721) {\n        // We allow removing approvals even if the wallet has the token guardian enabled\n        if (to != address(0) && _hasTokenGuardianEnabled(msg.sender)) {\n            revert HandlesErrors.GuardianEnabled();\n        }\n        super.approve(to, tokenId);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public override(IERC721, ERC721) {\n        // We allow removing approvals even if the wallet has the token guardian enabled\n        if (approved && _hasTokenGuardianEnabled(msg.sender)) {\n            revert HandlesErrors.GuardianEnabled();\n        }\n        super.setApprovalForAll(operator, approved);\n    }\n\n    function exists(uint256 tokenId) external view returns (bool) {\n        return _exists(tokenId);\n    }\n\n    function getNamespace() external pure returns (string memory) {\n        return NAMESPACE;\n    }\n\n    function getNamespaceHash() external pure returns (bytes32) {\n        return NAMESPACE_HASH;\n    }\n\n    // TODO: Should we revert if it doesn't exist?\n    function getLocalName(uint256 tokenId) public view returns (string memory) {\n        string memory localName = _localNames[tokenId];\n        if (bytes(localName).length == 0) {\n            revert HandlesErrors.DoesNotExist();\n        }\n        return _localNames[tokenId];\n    }\n\n    // TODO: Should we revert if it doesn't exist?\n    function getHandle(uint256 tokenId) public view returns (string memory) {\n        string memory localName = getLocalName(tokenId);\n        return string.concat(localName, '.', NAMESPACE);\n    }\n\n    function getTokenId(string memory localName) public pure returns (uint256) {\n        return uint256(keccak256(bytes(localName)));\n    }\n\n    function getTokenGuardianDisablingTimestamp(address wallet) external view returns (uint256) {\n        return _tokenGuardianDisablingTimestamp[wallet];\n    }\n\n    //////////////////////////////////////\n    ///        INTERNAL FUNCTIONS      ///\n    //////////////////////////////////////\n\n    function _mintHandle(address to, string calldata localName) internal returns (uint256) {\n        uint256 tokenId = getTokenId(localName);\n        _mint(to, tokenId);\n        _localNames[tokenId] = localName;\n        emit HandlesEvents.HandleMinted(localName, NAMESPACE, tokenId, to, block.timestamp);\n        return tokenId;\n    }\n\n    function _validateLocalNameMigration(string memory localName) internal view {\n        bytes memory localNameAsBytes = bytes(localName);\n        uint256 localNameLength = localNameAsBytes.length;\n\n        if (localNameLength == 0 || localNameLength + SEPARATOR_LENGTH + NAMESPACE_LENGTH > MAX_HANDLE_LENGTH) {\n            revert HandlesErrors.HandleLengthInvalid();\n        }\n\n        bytes1 firstByte = localNameAsBytes[0];\n        if (firstByte == '-' || firstByte == '_') {\n            revert HandlesErrors.HandleFirstCharInvalid();\n        }\n\n        uint256 i;\n        while (i < localNameLength) {\n            if (!_isAlphaNumeric(localNameAsBytes[i]) && localNameAsBytes[i] != '-' && localNameAsBytes[i] != '_') {\n                revert HandlesErrors.HandleContainsInvalidCharacters();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _validateLocalName(string memory localName) internal view {\n        bytes memory localNameAsBytes = bytes(localName);\n        uint256 localNameLength = localNameAsBytes.length;\n\n        if (localNameLength == 0 || localNameLength + SEPARATOR_LENGTH + NAMESPACE_LENGTH > MAX_HANDLE_LENGTH) {\n            revert HandlesErrors.HandleLengthInvalid();\n        }\n\n        if (localNameAsBytes[0] == '_') {\n            revert HandlesErrors.HandleFirstCharInvalid();\n        }\n\n        uint256 i;\n        while (i < localNameLength) {\n            if (!_isAlphaNumeric(localNameAsBytes[i]) && localNameAsBytes[i] != '_') {\n                revert HandlesErrors.HandleContainsInvalidCharacters();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _isAlphaNumeric(bytes1 char) internal pure returns (bool) {\n        return (char >= '0' && char <= '9') || (char >= 'a' && char <= 'z');\n    }\n\n    function _hasTokenGuardianEnabled(address wallet) internal view returns (bool) {\n        return\n            !wallet.isContract() &&\n            (_tokenGuardianDisablingTimestamp[wallet] == 0 ||\n                block.timestamp < _tokenGuardianDisablingTimestamp[wallet]);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 /* firstTokenId */,\n        uint256 batchSize\n    ) internal override {\n        if (from != address(0) && _hasTokenGuardianEnabled(from)) {\n            // Cannot transfer handle if the guardian is enabled, except at minting time.\n            revert HandlesErrors.GuardianEnabled();\n        }\n\n        super._beforeTokenTransfer(from, to, 0, batchSize);\n    }\n}"
    },
    {
      "filename": "contracts/namespaces/LensHandles.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport {ImmutableOwnable} from 'contracts/misc/ImmutableOwnable.sol';\nimport {ILensHandles} from 'contracts/interfaces/ILensHandles.sol';\nimport {HandlesEvents} from 'contracts/namespaces/constants/Events.sol';\nimport {HandlesErrors} from 'contracts/namespaces/constants/Errors.sol';\nimport {HandleTokenURILib} from 'contracts/libraries/token-uris/HandleTokenURILib.sol';\nimport {ILensHub} from 'contracts/interfaces/ILensHub.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * A handle is defined as a local name inside a namespace context. A handle is represented as the local name with its\n * namespace applied as a suffix, using the dot symbol as separator.\n *\n *      handle = ${localName}.${namespace}\n *\n * Handle and local name can be used interchangeably once you are in a context of a namespace, as it became redundant.\n *\n *      handle === ${localName} ; inside some namespace.\n */\ncontract LensHandles is ERC721, ImmutableOwnable, ILensHandles {\n    using Address for address;\n\n    uint256 internal constant MAX_HANDLE_LENGTH = 31;\n    string internal constant NAMESPACE = 'lens';\n    uint256 internal immutable NAMESPACE_LENGTH = bytes(NAMESPACE).length;\n    uint256 internal constant SEPARATOR_LENGTH = 1; // bytes('.').length;\n    bytes32 internal constant NAMESPACE_HASH = keccak256(bytes(NAMESPACE));\n    uint256 internal immutable TOKEN_GUARDIAN_COOLDOWN;\n\n    mapping(address => uint256) internal _tokenGuardianDisablingTimestamp;\n\n    mapping(uint256 tokenId => string localName) internal _localNames;\n\n    modifier onlyOwnerOrWhitelistedProfileCreator() {\n        if (\n            msg.sender != OWNER && !ILensHub(LENS_HUB).isProfileCreatorWhitelisted(msg.sender)\n        ) {\n            revert HandlesErrors.NotOwnerNorWhitelisted();\n        }\n        _;\n    }\n\n    modifier onlyEOA() {\n        if (msg.sender.isContract()) {\n            revert HandlesErrors.NotEOA();\n        }\n        _;\n    }\n\n    modifier onlyHub() {\n        if (msg.sender != LENS_HUB) {\n            revert HandlesErrors.NotHub();\n        }\n        _;\n    }\n\n    constructor(\n        address owner,\n        address lensHub,\n        uint256 tokenGuardianCooldown\n    ) ERC721('', '') ImmutableOwnable(owner, lensHub) {\n        TOKEN_GUARDIAN_COOLDOWN = tokenGuardianCooldown;\n    }\n\n    function name() public pure override returns (string memory) {\n        return string.concat(symbol(), ' Handles');\n    }\n\n    function symbol() public pure override returns (string memory) {\n        return string.concat('.', NAMESPACE);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        _requireMinted(tokenId);\n        return HandleTokenURILib.getTokenURI(tokenId, _localNames[tokenId]);\n    }\n\n    /// @inheritdoc ILensHandles\n    function mintHandle(address to, string calldata localName)\n        external\n        onlyOwnerOrWhitelistedProfileCreator\n        returns (uint256)\n    {\n        _validateLocalName(localName);\n        return _mintHandle(to, localName);\n    }\n\n    function migrateHandle(address to, string calldata localName) external onlyHub returns (uint256) {\n        _validateLocalNameMigration(localName);\n        return _mintHandle(to, localName);\n    }\n\n    function burn(uint256 tokenId) external {\n        if (msg.sender != ownerOf(tokenId)) {\n            revert HandlesErrors.NotOwner();\n        }\n        _burn(tokenId);\n        delete _localNames[tokenId];\n    }\n\n    /// ************************************\n    /// ****  TOKEN GUARDIAN FUNCTIONS  ****\n    /// ************************************\n\n    function DANGER__disableTokenGuardian() external onlyEOA {\n        if (_tokenGuardianDisablingTimestamp[msg.sender] != 0) {\n            revert HandlesErrors.DisablingAlreadyTriggered();\n        }\n        _tokenGuardianDisablingTimestamp[msg.sender] = block.timestamp + TOKEN_GUARDIAN_COOLDOWN;\n        emit HandlesEvents.TokenGuardianStateChanged({\n            wallet: msg.sender,\n            enabled: false,\n            tokenGuardianDisablingTimestamp: block.timestamp + TOKEN_GUARDIAN_COOLDOWN,\n            timestamp: block.timestamp\n        });\n    }\n\n    function enableTokenGuardian() external onlyEOA {\n        if (_tokenGuardianDisablingTimestamp[msg.sender] == 0) {\n            revert HandlesErrors.AlreadyEnabled();\n        }\n        _tokenGuardianDisablingTimestamp[msg.sender] = 0;\n        emit HandlesEvents.TokenGuardianStateChanged({\n            wallet: msg.sender,\n            enabled: true,\n            tokenGuardianDisablingTimestamp: 0,\n            timestamp: block.timestamp\n        });\n    }\n\n    function approve(address to, uint256 tokenId) public override(IERC721, ERC721) {\n        // We allow removing approvals even if the wallet has the token guardian enabled\n        if (to != address(0) && _hasTokenGuardianEnabled(msg.sender)) {\n            revert HandlesErrors.GuardianEnabled();\n        }\n        super.approve(to, tokenId);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public override(IERC721, ERC721) {\n        // We allow removing approvals even if the wallet has the token guardian enabled\n        if (approved && _hasTokenGuardianEnabled(msg.sender)) {\n            revert HandlesErrors.GuardianEnabled();\n        }\n        super.setApprovalForAll(operator, approved);\n    }\n\n    function exists(uint256 tokenId) external view returns (bool) {\n        return _exists(tokenId);\n    }\n\n    function getNamespace() external pure returns (string memory) {\n        return NAMESPACE;\n    }\n\n    function getNamespaceHash() external pure returns (bytes32) {\n        return NAMESPACE_HASH;\n    }\n\n    // TODO: Should we revert if it doesn't exist?\n    function getLocalName(uint256 tokenId) public view returns (string memory) {\n        string memory localName = _localNames[tokenId];\n        if (bytes(localName).length == 0) {\n            revert HandlesErrors.DoesNotExist();\n        }\n        return _localNames[tokenId];\n    }\n\n    // TODO: Should we revert if it doesn't exist?\n    function getHandle(uint256 tokenId) public view returns (string memory) {\n        string memory localName = getLocalName(tokenId);\n        return string.concat(localName, '.', NAMESPACE);\n    }\n\n    function getTokenId(string memory localName) public pure returns (uint256) {\n        return uint256(keccak256(bytes(localName)));\n    }\n\n    function getTokenGuardianDisablingTimestamp(address wallet) external view returns (uint256) {\n        return _tokenGuardianDisablingTimestamp[wallet];\n    }\n\n    //////////////////////////////////////\n    ///        INTERNAL FUNCTIONS      ///\n    //////////////////////////////////////\n\n    function _mintHandle(address to, string calldata localName) internal returns (uint256) {\n        uint256 tokenId = getTokenId(localName);\n        _mint(to, tokenId);\n        _localNames[tokenId] = localName;\n        emit HandlesEvents.HandleMinted(localName, NAMESPACE, tokenId, to, block.timestamp);\n        return tokenId;\n    }\n\n    function _validateLocalNameMigration(string memory localName) internal view {\n        bytes memory localNameAsBytes = bytes(localName);\n        uint256 localNameLength = localNameAsBytes.length;\n\n        if (localNameLength == 0 || localNameLength + SEPARATOR_LENGTH + NAMESPACE_LENGTH > MAX_HANDLE_LENGTH) {\n            revert HandlesErrors.HandleLengthInvalid();\n        }\n\n        bytes1 firstByte = localNameAsBytes[0];\n        if (firstByte == '-' || firstByte == '_') {\n            revert HandlesErrors.HandleFirstCharInvalid();\n        }\n\n        uint256 i;\n        while (i < localNameLength) {\n            if (!_isAlphaNumeric(localNameAsBytes[i]) && localNameAsBytes[i] != '-' && localNameAsBytes[i] != '_') {\n                revert HandlesErrors.HandleContainsInvalidCharacters();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _validateLocalName(string memory localName) internal view {\n        bytes memory localNameAsBytes = bytes(localName);\n        uint256 localNameLength = localNameAsBytes.length;\n\n        if (localNameLength == 0 || localNameLength + SEPARATOR_LENGTH + NAMESPACE_LENGTH > MAX_HANDLE_LENGTH) {\n            revert HandlesErrors.HandleLengthInvalid();\n        }\n\n        if (localNameAsBytes[0] == '_') {\n            revert HandlesErrors.HandleFirstCharInvalid();\n        }\n\n        uint256 i;\n        while (i < localNameLength) {\n            if (!_isAlphaNumeric(localNameAsBytes[i]) && localNameAsBytes[i] != '_') {\n                revert HandlesErrors.HandleContainsInvalidCharacters();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _isAlphaNumeric(bytes1 char) internal pure returns (bool) {\n        return (char >= '0' && char <= '9') || (char >= 'a' && char <= 'z');\n    }\n\n    function _hasTokenGuardianEnabled(address wallet) internal view returns (bool) {\n        return\n            !wallet.isContract() &&\n            (_tokenGuardianDisablingTimestamp[wallet] == 0 ||\n                block.timestamp < _tokenGuardianDisablingTimestamp[wallet]);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 /* firstTokenId */,\n        uint256 batchSize\n    ) internal override {\n        if (from != address(0) && _hasTokenGuardianEnabled(from)) {\n            // Cannot transfer handle if the guardian is enabled, except at minting time.\n            revert HandlesErrors.GuardianEnabled();\n        }\n\n        super._beforeTokenTransfer(from, to, 0, batchSize);\n    }\n}"
    },
    {
      "filename": "contracts/namespaces/TokenHandleRegistry.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {ITokenHandleRegistry} from 'contracts/interfaces/ITokenHandleRegistry.sol';\nimport {RegistryTypes} from 'contracts/namespaces/constants/Types.sol';\nimport {RegistryErrors} from 'contracts/namespaces/constants/Errors.sol';\nimport {RegistryEvents} from 'contracts/namespaces/constants/Events.sol';\nimport {ILensHub} from 'contracts/interfaces/ILensHub.sol';\nimport {ILensHandles} from 'contracts/interfaces/ILensHandles.sol';\n\n/**\n * @title TokenHandleRegistry\n * @author Lens Protocol\n * @notice This contract is used to link a token with a handle.\n * @custom:upgradeable Transparent upgradeable proxy without initializer.\n */\ncontract TokenHandleRegistry is ITokenHandleRegistry {\n    // First version of TokenHandleRegistry only works with Lens Profiles and .lens namespace.\n    address immutable LENS_HUB;\n    address immutable LENS_HANDLES;\n\n    // Using _handleHash(Handle) and _tokenHash(Token) as keys given that structs cannot be used as them.\n    mapping(bytes32 handle => RegistryTypes.Token token) handleToToken;\n    mapping(bytes32 token => RegistryTypes.Handle handle) tokenToHandle;\n\n    modifier onlyHandleOwner(uint256 handleId, address transactionExecutor) {\n        if (IERC721(LENS_HANDLES).ownerOf(handleId) != transactionExecutor) {\n            revert RegistryErrors.NotHandleOwner();\n        }\n        _;\n    }\n\n    modifier onlyTokenOwner(uint256 tokenId, address transactionExecutor) {\n        if (IERC721(LENS_HUB).ownerOf(tokenId) != transactionExecutor) {\n            revert RegistryErrors.NotTokenOwner();\n        }\n        _;\n    }\n\n    constructor(address lensHub, address lensHandles) {\n        LENS_HUB = lensHub;\n        LENS_HANDLES = lensHandles;\n    }\n\n    // Lens V1 to Lens V2 migration function\n    // WARNING: It is able to link the Token and Handle even if they're not in the same wallet.\n    //          But it is designed to be only called from LensHub migration function, which assures that they are.\n    function migrationLink(uint256 handleId, uint256 tokenId) external {\n        if (msg.sender != LENS_HUB) {\n            revert RegistryErrors.OnlyLensHub();\n        }\n        _link(\n            RegistryTypes.Handle({collection: LENS_HANDLES, id: handleId}),\n            RegistryTypes.Token({collection: LENS_HUB, id: tokenId})\n        );\n    }\n\n    /// @inheritdoc ITokenHandleRegistry\n    function link(\n        uint256 handleId,\n        uint256 tokenId\n    ) external onlyTokenOwner(tokenId, msg.sender) onlyHandleOwner(handleId, msg.sender) {\n        _link(\n            RegistryTypes.Handle({collection: LENS_HANDLES, id: handleId}),\n            RegistryTypes.Token({collection: LENS_HUB, id: tokenId})\n        );\n    }\n\n    /// @inheritdoc ITokenHandleRegistry\n    function unlink(uint256 handleId, uint256 tokenId) external {\n        // We revert here only in the case if both tokens exists and the caller is not the owner of any of them\n        if (\n            ILensHandles(LENS_HANDLES).exists(handleId) &&\n            ILensHandles(LENS_HANDLES).ownerOf(handleId) != msg.sender &&\n            ILensHub(LENS_HUB).exists(tokenId) &&\n            ILensHub(LENS_HUB).ownerOf(tokenId) != msg.sender\n        ) {\n            revert RegistryErrors.NotHandleNorTokenOwner();\n        }\n\n        RegistryTypes.Handle memory handle = RegistryTypes.Handle({collection: LENS_HANDLES, id: handleId});\n        RegistryTypes.Token memory tokenPointedByHandle = handleToToken[_handleHash(handle)];\n\n        // We check if the tokens are (were) linked for the case if some of them doesn't exist\n        if (tokenPointedByHandle.id != tokenId) {\n            revert RegistryErrors.NotLinked();\n        }\n        _unlink(handle, tokenPointedByHandle);\n    }\n\n    /// @inheritdoc ITokenHandleRegistry\n    function resolve(uint256 handleId) external view returns (uint256) {\n        if (!ILensHandles(LENS_HANDLES).exists(handleId)) {\n            revert RegistryErrors.DoesNotExist();\n        }\n        uint256 resolvedTokenId = _resolveHandleToToken(RegistryTypes.Handle({collection: LENS_HANDLES, id: handleId}))\n            .id;\n        if (resolvedTokenId == 0 || !ILensHub(LENS_HUB).exists(resolvedTokenId)) {\n            return 0;\n        }\n        return resolvedTokenId;\n    }\n\n    /// @inheritdoc ITokenHandleRegistry\n    function getDefaultHandle(uint256 tokenId) external view returns (uint256) {\n        if (!ILensHub(LENS_HUB).exists(tokenId)) {\n            revert RegistryErrors.DoesNotExist();\n        }\n        uint256 defaultHandleId = _resolveTokenToHandle(RegistryTypes.Token({collection: LENS_HUB, id: tokenId})).id;\n        if (defaultHandleId == 0 || !ILensHandles(LENS_HANDLES).exists(defaultHandleId)) {\n            return 0;\n        }\n        return defaultHandleId;\n    }\n\n    //////////////////////////////////////\n    ///        INTERNAL FUNCTIONS      ///\n    //////////////////////////////////////\n\n    function _resolveHandleToToken(\n        RegistryTypes.Handle memory handle\n    ) internal view returns (RegistryTypes.Token storage) {\n        return handleToToken[_handleHash(handle)];\n    }\n\n    function _resolveTokenToHandle(\n        RegistryTypes.Token memory token\n    ) internal view returns (RegistryTypes.Handle storage) {\n        return tokenToHandle[_tokenHash(token)];\n    }\n\n    function _link(RegistryTypes.Handle memory handle, RegistryTypes.Token memory token) internal {\n        _deleteTokenToHandleLinkageIfAny(handle);\n        handleToToken[_handleHash(handle)] = token;\n\n        _deleteHandleToTokenLinkageIfAny(token);\n        tokenToHandle[_tokenHash(token)] = handle;\n\n        emit RegistryEvents.HandleLinked(handle, token, block.timestamp);\n    }\n\n    function _deleteTokenToHandleLinkageIfAny(RegistryTypes.Handle memory handle) internal {\n        RegistryTypes.Token memory tokenPointedByHandle = handleToToken[_handleHash(handle)];\n        if (tokenPointedByHandle.collection != address(0) || tokenPointedByHandle.id != 0) {\n            delete tokenToHandle[_tokenHash(tokenPointedByHandle)];\n            emit RegistryEvents.HandleUnlinked(handle, tokenPointedByHandle, block.timestamp);\n        }\n    }\n\n    function _deleteHandleToTokenLinkageIfAny(RegistryTypes.Token memory token) internal {\n        RegistryTypes.Handle memory handlePointedByToken = tokenToHandle[_tokenHash(token)];\n        if (handlePointedByToken.collection != address(0) || handlePointedByToken.id != 0) {\n            delete handleToToken[_handleHash(handlePointedByToken)];\n            emit RegistryEvents.HandleUnlinked(handlePointedByToken, token, block.timestamp);\n        }\n    }\n\n    function _unlink(RegistryTypes.Handle memory handle, RegistryTypes.Token memory token) internal {\n        delete handleToToken[_handleHash(handle)];\n        // tokenToHandle is removed too, as the first version linkage is one-to-one.\n        delete tokenToHandle[_tokenHash(token)];\n        emit RegistryEvents.HandleUnlinked(handle, token, block.timestamp);\n    }\n\n    function _handleHash(RegistryTypes.Handle memory handle) internal pure returns (bytes32) {\n        return keccak256(abi.encode(handle.collection, handle.id));\n    }\n\n    function _tokenHash(RegistryTypes.Token memory token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(token.collection, token.id));\n    }\n}"
    },
    {
      "filename": "contracts/namespaces/LensHandles.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport {ImmutableOwnable} from 'contracts/misc/ImmutableOwnable.sol';\nimport {ILensHandles} from 'contracts/interfaces/ILensHandles.sol';\nimport {HandlesEvents} from 'contracts/namespaces/constants/Events.sol';\nimport {HandlesErrors} from 'contracts/namespaces/constants/Errors.sol';\nimport {HandleTokenURILib} from 'contracts/libraries/token-uris/HandleTokenURILib.sol';\nimport {ILensHub} from 'contracts/interfaces/ILensHub.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * A handle is defined as a local name inside a namespace context. A handle is represented as the local name with its\n * namespace applied as a suffix, using the dot symbol as separator.\n *\n *      handle = ${localName}.${namespace}\n *\n * Handle and local name can be used interchangeably once you are in a context of a namespace, as it became redundant.\n *\n *      handle === ${localName} ; inside some namespace.\n */\ncontract LensHandles is ERC721, ImmutableOwnable, ILensHandles {\n    using Address for address;\n\n    uint256 internal constant MAX_HANDLE_LENGTH = 31;\n    string internal constant NAMESPACE = 'lens';\n    uint256 internal immutable NAMESPACE_LENGTH = bytes(NAMESPACE).length;\n    uint256 internal constant SEPARATOR_LENGTH = 1; // bytes('.').length;\n    bytes32 internal constant NAMESPACE_HASH = keccak256(bytes(NAMESPACE));\n    uint256 internal immutable TOKEN_GUARDIAN_COOLDOWN;\n\n    mapping(address => uint256) internal _tokenGuardianDisablingTimestamp;\n\n    mapping(uint256 tokenId => string localName) internal _localNames;\n\n    modifier onlyOwnerOrWhitelistedProfileCreator() {\n        if (\n            msg.sender != OWNER && !ILensHub(LENS_HUB).isProfileCreatorWhitelisted(msg.sender)\n        ) {\n            revert HandlesErrors.NotOwnerNorWhitelisted();\n        }\n        _;\n    }\n\n    modifier onlyEOA() {\n        if (msg.sender.isContract()) {\n            revert HandlesErrors.NotEOA();\n        }\n        _;\n    }\n\n    modifier onlyHub() {\n        if (msg.sender != LENS_HUB) {\n            revert HandlesErrors.NotHub();\n        }\n        _;\n    }\n\n    constructor(\n        address owner,\n        address lensHub,\n        uint256 tokenGuardianCooldown\n    ) ERC721('', '') ImmutableOwnable(owner, lensHub) {\n        TOKEN_GUARDIAN_COOLDOWN = tokenGuardianCooldown;\n    }\n\n    function name() public pure override returns (string memory) {\n        return string.concat(symbol(), ' Handles');\n    }\n\n    function symbol() public pure override returns (string memory) {\n        return string.concat('.', NAMESPACE);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        _requireMinted(tokenId);\n        return HandleTokenURILib.getTokenURI(tokenId, _localNames[tokenId]);\n    }\n\n    /// @inheritdoc ILensHandles\n    function mintHandle(address to, string calldata localName)\n        external\n        onlyOwnerOrWhitelistedProfileCreator\n        returns (uint256)\n    {\n        _validateLocalName(localName);\n        return _mintHandle(to, localName);\n    }\n\n    function migrateHandle(address to, string calldata localName) external onlyHub returns (uint256) {\n        _validateLocalNameMigration(localName);\n        return _mintHandle(to, localName);\n    }\n\n    function burn(uint256 tokenId) external {\n        if (msg.sender != ownerOf(tokenId)) {\n            revert HandlesErrors.NotOwner();\n        }\n        _burn(tokenId);\n        delete _localNames[tokenId];\n    }\n\n    /// ************************************\n    /// ****  TOKEN GUARDIAN FUNCTIONS  ****\n    /// ************************************\n\n    function DANGER__disableTokenGuardian() external onlyEOA {\n        if (_tokenGuardianDisablingTimestamp[msg.sender] != 0) {\n            revert HandlesErrors.DisablingAlreadyTriggered();\n        }\n        _tokenGuardianDisablingTimestamp[msg.sender] = block.timestamp + TOKEN_GUARDIAN_COOLDOWN;\n        emit HandlesEvents.TokenGuardianStateChanged({\n            wallet: msg.sender,\n            enabled: false,\n            tokenGuardianDisablingTimestamp: block.timestamp + TOKEN_GUARDIAN_COOLDOWN,\n            timestamp: block.timestamp\n        });\n    }\n\n    function enableTokenGuardian() external onlyEOA {\n        if (_tokenGuardianDisablingTimestamp[msg.sender] == 0) {\n            revert HandlesErrors.AlreadyEnabled();\n        }\n        _tokenGuardianDisablingTimestamp[msg.sender] = 0;\n        emit HandlesEvents.TokenGuardianStateChanged({\n            wallet: msg.sender,\n            enabled: true,\n            tokenGuardianDisablingTimestamp: 0,\n            timestamp: block.timestamp\n        });\n    }\n\n    function approve(address to, uint256 tokenId) public override(IERC721, ERC721) {\n        // We allow removing approvals even if the wallet has the token guardian enabled\n        if (to != address(0) && _hasTokenGuardianEnabled(msg.sender)) {\n            revert HandlesErrors.GuardianEnabled();\n        }\n        super.approve(to, tokenId);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public override(IERC721, ERC721) {\n        // We allow removing approvals even if the wallet has the token guardian enabled\n        if (approved && _hasTokenGuardianEnabled(msg.sender)) {\n            revert HandlesErrors.GuardianEnab"
    }
  ]
}