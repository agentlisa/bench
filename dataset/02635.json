{
  "Title": "H-8: Anyone can withdraw user's Velo Deposit NFT after approval is given to depositor",
  "Content": "# Issue H-8: Anyone can withdraw user's Velo Deposit NFT after approval is given to depositor \n\nSource: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/47 \n\n## Found by \nclems4ever, bin2chen, ak1, neumo, CodingNameKiki, HollaDieWaldfee, rotcivegaf, Jeiwan, 0x52, HonorLt\n\n## Summary\n\n`Depositor#withdrawFromGauge` is a public function that can be called by anyone which transfers token to `msg.sender`. `withdrawFromGauge` burns the NFT to be withdrawn, which means that `Depositor` must either be approved or be in possession of the NFT. Since it doesn't transfer the NFT to the contract before burning the user must either send the NFT to the `Depositor` or `approve` the `Depositor` in a separate transaction. After the NFT is either transferred or approved, a malicious user could withdraw the NFT for themselves.\n\n## Vulnerability Detail\n\n    function withdrawFromGauge(uint256 _NFTId, address[] memory _tokens)  public  {\n        uint256 amount = depositReceipt.pooledTokens(_NFTId);\n        depositReceipt.burn(_NFTId);\n        gauge.getReward(address(this), _tokens);\n        gauge.withdraw(amount);\n        //AMMToken adheres to ERC20 spec meaning it reverts on failure, no need to check return\n        //slither-disable-next-line unchecked-transfer\n        AMMToken.transfer(msg.sender, amount);\n    }\n\n`Depositor#withdrawFromGauge` allows anyone to call it, burning the NFT and sending `msg.sender` the withdrawn tokens.\n\n    function burn(uint256 _NFTId) external onlyMinter{\n        require(_isApprovedOrOwner(msg.sender, _NFTId), \"ERC721: caller is not token owner or approved\");\n        delete pooledTokens[_NFTId];\n        delete relatedDepositor[_NFTId];\n        _burn(_NFTId);\n    }\n\n`Depositor` calls `DepositReceipt_Base#burn`, which means that it must be either the owner or approved for the NFT. Since \n`Depositor#withdrawFromGauge` doesn't transfer the NFT from the user, this must happen in a separate transaction. Between the user approval/transfer and them calling `Depositor#withdrawFromGauge` a malicious user could call `Depositor#withdrawFromGauge` first to withdraw the NFT and steal the users funds. This would be very easy to automate with a bot.\n\nExample:\n`User A` deposits 100 underlying into their `Depositor` and is given `Token A` which represents their deposit. After some time they want to redeem `Token A` so they `Approve` their `Depositor` for `Token A`. `User B` sees the approval and quickly calls `Depositor#withdrawFromGauge` to withdraw `Token A`. `User B` is sent the 100 tokens and `Token A` is burned from `User A`.\n\n## Impact\n\nUsers attempting to withdraw can have their funds stolen\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/Depositor.sol#L119-L127\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nOnly allow owner of NFT to withdraw it:\n\n        function withdrawFromGauge(uint256 _NFTId, address[] memory _tokens)  public  {\n    +       require(depositReceipt.ownerOf(_NFTId) == msg.sender);\n            uint256 amount = depositReceipt.pooledTokens(_NFTId);\n            depositReceipt.burn(_NFTId);\n            gauge.getReward(address(this), _tokens);\n            gauge.withdraw(amount);\n            //AMMToken adheres to ERC20 spec meaning it reverts on failure, no need to check return\n            //slither-disable-next-line unchecked-transfer\n            AMMToken.transfer(msg.sender, amount);\n        }\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor Confirmed, will fix\n\n**kree-dotcom**\n\nFixed https://github.com/kree-dotcom/Velo-Deposit-Tokens/commit/23ff5653b555b11c9f4dead7ff5a72d50eac5788\n\nHere we have added a check on line 81 and 122 as suggested. There is also minor refactoring which is needed due to the fact if we are doing a partial withdrawal then after calling `depositReceipt.split()` the owner of the newly acquired depositReceipt is the Depositor not the original msg.sender. Therefore we moved the withdrawal logic to an internal function that both `withdrawFromGauge()` and `partialWithdrawFromGauge()` both access after ownership checks. \n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/22",
  "Code": [
    {
      "filename": "contracts/Velo-Deposit-Tokens/contracts/Depositor.sol",
      "content": "pragma solidity =0.8.9;\n\nimport \"./DepositReceipt_USDC.sol\";\nimport \"./Interfaces/IGauge.sol\";\nimport \"./Interfaces/IRouter.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\n//Depositer takes pooled tokens from the user and deposits them on their behalf \n// into the Gauge. It then mints them the  ERC20 deposit receipt to use elsewhere\n// the initial Depositer can claim rewards from the Guage via the Depositer at any time\ncontract Depositor is Ownable {\n\n    using SafeERC20 for IERC20; \n\n    DepositReceipt_USDC public immutable depositReceipt;\n    IERC20 public immutable AMMToken;\n    IGauge public immutable gauge;\n    \n    \n    /**\n    *    @notice Used to deposit pooledTokens to the Gauge and mint a new DepositReceipt\n    *    @param _depositReceipt address of the related depositReceipt so we can mint and burn new DepositReceipt NFTs\n    *    @param _AMMToken the associate pooledToken we transfer to the Gauge on behalf of the user.\n    *    @param _gauge the related gauge for this pooledToken, where we deposit/withdraw pooledTokens and claim rewards from.\n    *    \n    **/\n    constructor(\n                address _depositReceipt,\n                address _AMMToken, \n                address _gauge\n                ){\n\n        AMMToken = IERC20(_AMMToken);\n        gauge = IGauge(_gauge);\n        depositReceipt = DepositReceipt_USDC(_depositReceipt);\n    }\n\n    //function required to receive ERC721s to this contract\n    function onERC721Received(\n        address operator,\n        address from,\n        uint tokenId,\n        bytes calldata data\n    ) external returns (bytes4){\n        return(IERC721Receiver.onERC721Received.selector);\n    }\n\n\n    /**\n    *    @notice Used to deposit pooledTokens to the Gauge and mint a new DepositReceipt\n    *    @param _amount amount of pooledTokens to deposit.\n    *    @return NFTId the Id relating to the newly minte DepositReceipt\n    *    \n    **/\n    function depositToGauge(uint256 _amount) onlyOwner() external returns(uint256){\n         //AMMToken adheres to ERC20 spec meaning it reverts on failure, no need to check return\n        //slither-disable-next-line unchecked-transfer\n        AMMToken.transferFrom(msg.sender, address(this), _amount);\n\n        AMMToken.safeIncreaseAllowance(address(gauge), _amount);\n        //we are not attaching a veNFT to the deposit so the 2nd arg is always 0.\n        gauge.deposit(_amount, 0);\n        uint256 NFTId = depositReceipt.safeMint(_amount);\n        //safeMint sends the minted DepositReceipt to Depositor so now we forward it to the user.\n        depositReceipt.safeTransferFrom(address(this), msg.sender, NFTId);\n        return(NFTId);\n    }\n\n    /**\n    *    @notice used to withdraw percentageSplit of specified DepositReceipt worth of pooledTokens.\n    *    @param _NFTId the ID sof the DepositReceipt you wish to reclaim some of the pooledTokens of.\n    *    @param _percentageSplit the percentage of the pooled tokens to be withdrawn , 100% is 1e18.\n    *    @param _tokens  array of reward tokens the user wishes to claim at the same time, can be empty.\n    *    \n    **/\n    function partialWithdrawFromGauge(uint256 _NFTId, uint256 _percentageSplit, address[] memory _tokens) public {\n        uint256 newNFTId = depositReceipt.split(_NFTId, _percentageSplit);\n        //then call withdrawFromGauge on portion removing.\n        withdrawFromGauge(newNFTId, _tokens);\n    }  \n\n    /**\n    *    @notice Wrapper around partialWithdrawFromGauge and withdrawFromGauge to improve user experience.\n    *    @param _NFTIds the ID sof the DepositReceipts you wish to burn and reclaim the pooledTokens relating to\n    *    @param _usingPartial Set to true if you wish to withdraw only part of one DepositReceipt\n    *    @param _partialNFTId the DepositReceipt Id of which you only wish to withdraw less than 100% of its pooled tokens\n    *    @param _percentageSplit if a partial withdrawal is being used, the percentage of the pooled tokens to be withdrawn , 100% is 1e18.\n    *    @param _tokens  array of reward tokens the user wishes to claim at the same time, can be empty.\n    *    \n    **/\n    function multiWithdrawFromGauge(\n        uint256[] memory _NFTIds, \n        bool _usingPartial,\n        uint256 _partialNFTId, \n        uint256 _percentageSplit, \n        address[] memory _tokens\n        ) external {\n\n        //here we use external calls in a loop, if gas is excessive withdrawFromGauge and partialWithdrawFromGauge can be called directly preventing DOS.\n        uint256 length = _NFTIds.length;\n        for (uint256 i = 0; i < length; i++ ){\n            withdrawFromGauge(_NFTIds[i], _tokens);\n        }\n        if(_usingPartial){\n            partialWithdrawFromGauge(_partialNFTId, _percentageSplit, _tokens);\n        }\n        \n    }\n\n    /**\n    *    @notice burns the NFT related to the ID and withdraws the owed pooledtokens from Gauge and sends to user.  \n    *    @param _NFTId the ID of the DepositReceipt you wish to burn and reclaim the pooledTokens relating to\n    *    @param _tokens  array of reward tokens the user wishes to claim at the same time, can be empty.\n    *    \n    **/\n    function withdrawFromGauge(uint256 _NFTId, address[] memory _tokens)  public  {\n        uint256 amount = depositReceipt.pooledTokens(_NFTId);\n        depositReceipt.burn(_NFTId);\n        gauge.getReward(address(this), _tokens);\n        gauge.withdraw(amount);\n        //AMMToken adheres to ERC20 spec meaning it reverts on failure, no need to check return\n        //slither-disable-next-line unchecked-transfer\n        AMMToken.transfer(msg.sender, amount);\n    }\n\n    /**\n    *    @notice Function to claim accrued rewards from gauge and send to Depositor owner who must be the caller.\n    *    @notice because we call the gauge then transfer to the user there should never be reward tokens leftover in Depositor\n    *            but if there are you can call again as gauge will succeed even if it has nothing to send the Depositor\n    *    @param _tokens  array of reward tokens the user wishes to claim. \n    *    \n    **/\n    function claimRewards( address[] memory _tokens) onlyOwner() external {\n        require(_tokens.length > 0, \"Empty tokens array\");\n        gauge.getReward(address(this), _tokens);\n        \n        uint256 length =  _tokens.length;\n        for (uint i = 0; i < length; i++) {\n            uint256 balance = IERC20(_tokens[i]).balanceOf(address(this));\n            // using SafeERC20 in case reward token returns false on failure\n            IERC20(_tokens[i]).safeTransfer(msg.sender, balance);\n        }\n\n    }\n\n    /**\n    *    @notice Function to check the quantity of _token rewards awaiting being claimed by claimRewards()\n    *    @param _token  reward tokens the user wishes to check the pending balance of in the gauge.\n    *    \n    **/\n    function viewPendingRewards(address _token) external view returns(uint256){\n        //passthrough to Gauge\n        return gauge.earned(_token, address(this)); \n    }\n    \n}"
    }
  ]
}