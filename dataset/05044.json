{
  "Title": "[M-01] Missing unwrap configuration when withdrawing cross-chain in the `depositYBLendSGLLockXchainTOLP()` function of `MagnetarAssetXChainModule` results in being unable to lock and participate on the destination chain",
  "Content": "\nThe `depositYBLendSGLLockXchainTOLP()` function attempts to lend into Singularity, then withdraws the Singularity tokens cross-chain to lock and participate on the destination chain. The Singularity tokens are wrapped as TOFT tokens to facilitate cross-chain transfer.\n\n```solidity\nuint256 fraction =\n    _depositYBLendSGL(data.depositData, data.singularity, IYieldBox(yieldBox), data.user, data.lendAmount);\n\n// wrap SGL receipt into tReceipt\n// ! User should approve `address(this)` for `IERC20(data.singularity)` !\nuint256 toftAmount = _wrapSglReceipt(IYieldBox(yieldBox), data.singularity, data.user, fraction, data.assetId);\n```\n\nThis function calls `_withdrawToChain()` with the `unwrap` parameter set to false, indicating that TOFT-wrapped Singularity tokens will not be unwrapped upon receipt on the destination chain.\n\n```solidity\n_withdrawToChain(\n    MagnetarWithdrawData({\n        yieldBox: yieldBox,\n        assetId: data.assetId,\n        unwrap: false,\n        lzSendParams: data.lockAndParticipateSendParams.lzParams,\n        sendGas: data.lockAndParticipateSendParams.lzSendGas,\n        composeGas: data.lockAndParticipateSendParams.lzComposeGas,\n        sendVal: data.lockAndParticipateSendParams.lzSendVal,\n        composeVal: data.lockAndParticipateSendParams.lzComposeVal,\n        composeMsg: data.lockAndParticipateSendParams.lzParams.sendParam.composeMsg,\n        composeMsgType: data.lockAndParticipateSendParams.lzComposeMsgType,\n        withdraw: true\n    })\n);\n```\n\nHowever, the [`TapiocaOptionLiquidityProvision.lock()`](https://github.com/Tapioca-DAO/tap-token/blob/20a83b1d2d5577653610a6c3879dff9df4968345/contracts/options/TapiocaOptionLiquidityProvision.sol#L187) function attempts to acquire YieldBox's shares of the original Singularity tokens. Therefore, upon receiving wrapped Singularity tokens on the destination chain, it should unwrap these tokens to facilitate the execution of subsequent actions.\n\n### Impact\n\n`depositYBLendSGLLockXchainTOLP()` will fail to execute the locking process after receiving wrapped Singularity tokens cross-chain.\n\n### Recommended Mitigation Steps\n\n`depositYBLendSGLLockXchainTOLP()` should call `_withdrawToChain()` with `unwrap` set to true.\n\n### Assessed type\n\nContext\n\n**[cryptotechmaker (Tapioca) confirmed and commented](https://github.com/code-423n4/2024-02-tapioca-findings/issues/180#issuecomment-2031959346):**\n > Fixed [here](https://github.com/Tapioca-DAO/tapioca-periph/pull/204).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-tapioca",
  "Code": [
    {
      "filename": "contracts/options/TapiocaOptionLiquidityProvision.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {BaseBoringBatchable} from \"@boringcrypto/boring-solidity/contracts/BoringBatchable.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC721Permit} from \"tapioca-periph/utils/ERC721Permit.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {IPearlmit, PearlmitHandler} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {IYieldBox} from \"tap-token/interfaces/IYieldBox.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nstruct LockPosition {\n    uint128 sglAssetID; // Singularity market YieldBox asset ID\n    uint128 ybShares; // amount of YieldBox shares locked.\n    uint128 lockTime; // time when the tokens were locked\n    uint128 lockDuration; // duration of the lock\n}\n\nstruct SingularityPool {\n    uint256 sglAssetID; // Singularity market YieldBox asset ID\n    uint256 totalDeposited; // total amount of YieldBox shares deposited, used for pool share calculation\n    uint256 poolWeight; // Pool weight to calculate emission\n    bool rescue; // If true, the pool will be used to rescue funds in case of emergency\n}\n\ncontract TapiocaOptionLiquidityProvision is\n    Ownable,\n    PearlmitHandler,\n    ERC721,\n    ERC721Permit,\n    IERC1155Receiver,\n    BaseBoringBatchable,\n    Pausable,\n    ReentrancyGuard\n{\n    uint256 public tokenCounter; // Counter for token IDs\n    mapping(uint256 => LockPosition) public lockPositions; // TokenID => LockPosition\n\n    IYieldBox public immutable yieldBox;\n\n    // Singularity market address => SingularityPool (YieldBox Asset ID is 0 if not active)\n    mapping(IERC20 => SingularityPool) public activeSingularities;\n    mapping(uint256 => IERC20) public sglAssetIDToAddress; // Singularity market YieldBox asset ID => Singularity market address\n    uint256[] public singularities; // Array of active singularity asset IDs\n\n    uint256 public rescueCooldown = 2 days; // Cooldown before a singularity pool can be put in rescue mode\n    mapping(uint256 sglId => uint256 rescueTime) public sglRescueRequest; // Time when the pool was put in rescue mode\n\n    uint256 public totalSingularityPoolWeights; // Total weight of all active singularity pools\n    uint256 public immutable EPOCH_DURATION; // 7 days = 604800\n    uint256 public constant MAX_LOCK_DURATION = 100 * 365 days; // 100 years\n\n    error NotRegistered();\n    error InvalidSingularity();\n    error DurationTooShort();\n    error DurationTooLong();\n    error SharesNotValid();\n    error SingularityInRescueMode();\n    error SingularityNotActive();\n    error PositionExpired();\n    error LockNotExpired();\n    error AlreadyActive();\n    error AssetIdNotValid();\n    error DuplicateAssetId();\n    error AlreadyRegistered();\n    error NotAuthorized();\n    error NotInRescueMode();\n    error NotActive();\n    error RescueCooldownNotReached();\n    error TransferFailed();\n\n    constructor(address _yieldBox, uint256 _epochDuration, IPearlmit _pearlmit, address _owner)\n        ERC721(\"TapiocaOptionLiquidityProvision\", \"tOLP\")\n        ERC721Permit(\"TapiocaOptionLiquidityProvision\")\n        PearlmitHandler(_pearlmit)\n    {\n        yieldBox = IYieldBox(_yieldBox);\n        EPOCH_DURATION = _epochDuration;\n        _transferOwnership(_owner);\n    }\n\n    // ==========\n    //   EVENTS\n    // ==========\n    event Mint(address indexed to, uint128 indexed sglAssetID, uint256 tokenId);\n    event Burn(address indexed to, uint128 indexed sglAssetID, uint256 tokenId);\n    event UpdateTotalSingularityPoolWeights(uint256 totalSingularityPoolWeights);\n    event SetSGLPoolWeight(address indexed sgl, uint256 poolWeight);\n    event RequestSglPoolRescue(uint256 sglAssetId, uint256 timestamp);\n    event ActivateSGLPoolRescue(address sgl);\n    event RegisterSingularity(address sgl, uint256 assetID);\n    event UnregisterSingularity(address sgl, uint256 assetID);\n\n    // ===============\n    //    MODIFIERS\n    // ===============\n    modifier updateTotalSGLPoolWeights() {\n        _;\n        totalSingularityPoolWeights = _computeSGLPoolWeights();\n        emit UpdateTotalSingularityPoolWeights(totalSingularityPoolWeights);\n    }\n\n    // =========\n    //    READ\n    // =========\n    /// @notice Returns the lock position of a given tOLP NFT and if it's active\n    /// @param _tokenId tOLP NFT ID\n    function getLock(uint256 _tokenId) external view returns (LockPosition memory) {\n        return lockPositions[_tokenId];\n    }\n\n    /// @notice Returns the active singularity YieldBox ID markets\n    /// @return singularities Array of YieldBox asset IDs\n    function getSingularities() external view returns (uint256[] memory) {\n        return singularities;\n    }\n\n    /// @notice Returns the active singularity pool data, excluding the ones in rescue\n    /// @return pools Array of SingularityPool\n    function getSingularityPools() external view returns (SingularityPool[] memory) {\n        uint256[] memory _singularities = singularities;\n        uint256 len = _singularities.length;\n\n        SingularityPool[] memory pools = new SingularityPool[](len);\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                SingularityPool memory sgl = activeSingularities[sglAssetIDToAddress[_singularities[i]]];\n                // If the pool is in rescue, don't return it\n                if (sgl.rescue) {\n                    continue;\n                }\n                pools[i] = sgl;\n            }\n        }\n        return pools;\n    }\n\n    /// @notice Returns the total amount of locked YieldBox shares for a given singularity market\n    /// @return shares Amount of YieldBox shares locked\n    /// @return amount Amount of YieldBox shares locked converted in amount\n    function getTotalPoolDeposited(uint256 _sglAssetId) external view returns (uint256 shares, uint256 amount) {\n        shares = activeSingularities[sglAssetIDToAddress[_sglAssetId]].totalDeposited;\n        amount = yieldBox.toAmount(_sglAssetId, shares, false);\n    }\n\n    /// @notice Return an approval or ownership status of a given address for a given tOLP NFT\n    /// @param _spender Address to check\n    /// @param _tokenId tOLP NFT ID\n    function isApprovedOrOwner(address _spender, uint256 _tokenId) external view returns (bool) {\n        return _isApprovedOrOwner(_spender, _tokenId);\n    }\n\n    /// @notice Returns super approve check or if the spender is approved for the tOLP NFT on Pearlmit\n    function _isApprovedOrOwner(address _spender, uint256 _tokenId) internal view override returns (bool) {\n        return super._isApprovedOrOwner(_spender, _tokenId)\n            || isERC721Approved(_ownerOf(_tokenId), _spender, address(this), _tokenId);\n    }\n\n    // ==========\n    //    WRITE\n    // ==========\n\n    /// @notice Locks YieldBox shares for a given duration\n    /// @param _to Address to mint the tOLP NFT to\n    /// @param _singularity Singularity market address\n    /// @param _lockDuration Duration of the lock\n    /// @param _ybShares Amount of YieldBox shares to lock\n    /// @return tokenId The ID of the minted NFT\n    function lock(address _to, IERC20 _singularity, uint128 _lockDuration, uint128 _ybShares)\n        external\n        nonReentrant\n        returns (uint256 tokenId)\n    {\n        if (_lockDuration < EPOCH_DURATION) revert DurationTooShort();\n        if (_lockDuration > MAX_LOCK_DURATION) revert DurationTooLong();\n\n        if (_ybShares == 0) revert SharesNotValid();\n\n        SingularityPool memory sgl = activeSingularities[_singularity];\n        if (sgl.rescue) revert SingularityInRescueMode();\n\n        uint256 sglAssetID = sgl.sglAssetID;\n        if (sglAssetID == 0) revert SingularityNotActive();\n\n        // Transfer the Singularity position to this contract\n        // yieldBox.transfer(msg.sender, address(this), sglAssetID, _ybShares);\n        {\n            bool isErr =\n                pearlmit.transferFromERC1155(msg.sender, address(this), address(yieldBox), sglAssetID, _ybShares);\n            if (isErr) {\n                revert TransferFailed();\n            }\n        }\n        activeSingularities[_singularity].totalDeposited += _ybShares;\n\n        // Create the lock position\n        tokenId = ++tokenCounter;\n        LockPosition storage lockPosition = lockPositions[tokenId];\n        lockPosition.lockTime = uint128(block.timestamp);\n        lockPosition.sglAssetID = uint128(sglAssetID);\n        lockPosition.lockDuration = _lockDuration;\n        lockPosition.ybShares = _ybShares;\n\n        // Mint the tOLP NFT position\n        _safeMint(_to, tokenId);\n\n        emit Mint(_to, uint128(sglAssetID), tokenId);\n    }\n\n    /// @notice Unlocks tOLP tokens\n    /// @param _tokenId ID of the position to unlock\n    /// @param _singularity Singularity market address\n    /// @param _to Address to send the tokens to\n    function unlock(uint256 _tokenId, IERC20 _singularity, address _to) external {\n        if (!_exists(_tokenId)) revert PositionExpired();\n\n        LockPosition memory lockPosition = lockPositions[_tokenId];\n        SingularityPool memory sgl = activeSingularities[_singularity];\n\n        // If the singularity is in rescue, the lock can be unlocked at any time\n        if (!sgl.rescue) {\n            // If not, the lock must be expired\n            if (block.timestamp < lockPosition.lockTime + lockPosition.lockDuration) revert LockNotExpired();\n        }\n        if (sgl.sglAssetID != lockPosition.sglAssetID) {\n            revert InvalidSingularity();\n        }\n\n        if (!_isApprovedOrOwner(msg.sender, _tokenId)) revert NotAuthorized();\n\n        _burn(_tokenId);\n        delete lockPositions[_tokenId];\n\n        // Transfer the YieldBox position back to the owner\n        yieldBox.transfer(address(this), _to, lockPosition.sglAssetID, lockPosition.ybShares);\n        activeSingularities[_singularity].totalDeposited -= lockPosition.ybShares;\n\n        emit Burn(_to, lockPosition.sglAssetID, _tokenId);\n    }\n\n    // =========\n    //   OWNER\n    // =========\n\n    /// @notice Sets the pool weight of a given singularity market\n    /// @param singularity Singularity market address\n    /// @param weight Weight of the pool\n    function setSGLPoolWeight(IERC20 singularity, uint256 weight) external onlyOwner updateTotalSGLPoolWeights {\n        if (activeSingularities[singularity].sglAssetID == 0) {\n            revert NotRegistered();\n        }\n        activeSingularities[singularity].poolWeight = weight;\n\n        emit SetSGLPoolWeight(address(singularity), weight);\n    }\n\n    function setRescueCooldown(uint256 _rescueCooldown) external onlyOwner {\n        rescueCooldown = _rescueCooldown;\n    }\n\n    /**\n     * @notice Requests a singularity market to be put in rescue mode. Needs to be activated later on in `activateSGLPoolRescue()`\n     * @param _sglAssetID YieldBox asset ID of the singularity market\n     */\n    function requestSglPoolRescue(uint256 _sglAssetID) external onlyOwner {\n        if (_sglAssetID == 0) revert NotRegistered();\n        if (sglRescueRequest[_sglAssetID] != 0) revert AlreadyActive();\n\n        sglRescueRequest[_sglAssetID] = block.timestamp;\n\n        emit RequestSglPoolRescue(_sglAssetID, block.timestamp);\n    }\n\n    /// @notice Sets the rescue status of a given singularity market\n    /// @param singularity Singularity market address\n    function activateSGLPoolRescue(IERC20 singularity) external onlyOwner updateTotalSGLPoolWeights {\n        SingularityPool memory sgl = activeSingularities[singularity];\n\n        if (sgl.sglAssetID == 0) revert NotRegistered();\n        if (sgl.rescue) revert AlreadyActive();\n        if (sglRescueRequest[sgl.sglAssetID] == 0) revert NotActive();\n        if (block.timestamp < sglRescueRequest[sgl.sglAssetID] + rescueCooldown) revert RescueCooldownNotReached();\n\n        activeSingularities[singularity].rescue = true;\n\n        emit ActivateSGLPoolRescue(address(singularity));\n    }\n\n    /// @notice Registers a new singularity market\n    /// @param singularity Singularity market address\n    /// @param assetID YieldBox asset ID of the singularity market\n    /// @param weight Weight of the pool\n    function registerSingularity(IERC20 singularity, uint256 assetID, uint256 weight)\n        external\n        onlyOwner\n        updateTotalSGLPoolWeights\n    {\n        if (assetID == 0) revert AssetIdNotValid();\n        if (sglAssetIDToAddress[assetID] != IERC20(address(0))) {\n            revert DuplicateAssetId();\n        }\n        if (activeSingularities[singularity].sglAssetID != 0) {\n            revert AlreadyRegistered();\n        }\n\n        activeSingularities[singularity].sglAssetID = assetID;\n        activeSingularities[singularity].poolWeight = weight > 0 ? weight : 1;\n        sglAssetIDToAddress[assetID] = singularity;\n        singularities.push(assetID);\n\n        emit RegisterSingularity(address(singularity), assetID);\n    }\n\n    /// @notice Un-registers a singularity market\n    /// @param singularity Singularity market address\n    function unregisterSingularity(IERC20 singularity) external onlyOwner updateTotalSGLPoolWeights {\n        uint256 sglAssetID = activeSingularities[singularity].sglAssetID;\n        if (sglAssetID == 0) revert NotRegistered();\n        if (!activeSingularities[singularity].rescue) revert NotInRescueMode();\n\n        unchecked {\n            uint256[] memory _singularities = singularities;\n            uint256 sglLength = _singularities.length;\n            uint256 sglLastIndex = sglLength - 1;\n\n            for (uint256 i; i < sglLength; i++) {\n                if (_singularities[i] == sglAssetID) {\n                    // If in the middle, copy last element on deleted element, then pop\n                    delete activeSingularities[singularity];\n                    delete sglAssetIDToAddress[sglAssetID];\n\n                    if (i != sglLastIndex) {\n                        singularities[i] = _singularities[sglLastIndex];\n                    }\n                    singularities.pop();\n                    emit UnregisterSingularity(address(singularity), sglAssetID);\n                    break;\n                }\n            }\n        }\n\n        emit UnregisterSingularity(address(singularity), sglAssetID);\n    }\n\n    /**\n     * @notice Un/Pauses this contract.\n     */\n    function setPause(bool _pauseState) external onlyOwner {\n        if (_pauseState) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    // =========\n    //  INTERNAL\n    // =========\n\n    /// @notice Compute the total pool weight of all active singularity markets, excluding the ones in rescue\n    /// @return total Total weight of all active singularity markets\n    function _computeSGLPoolWeights() internal view returns (uint256) {\n        uint256 total;\n        uint256 len = singularities.length;\n        for (uint256 i; i < len; i++) {\n            SingularityPool memory sgl = activeSingularities[sglAssetIDToAddress[singularities[i]]];\n            if (!sgl.rescue) {\n                total += sgl.poolWeight;\n            }\n        }\n\n        return total;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function onERC1155Received(address operator, address from, uint256 id, uint256 value, bytes calldata data)\n        external\n        returns (bytes4)\n    {\n        // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n        return 0xf23a6e61;\n    }\n\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4) {\n        return bytes4(0);\n    }\n}"
    }
  ]
}