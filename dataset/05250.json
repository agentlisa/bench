{
  "Title": "[M-19] No proposal time limit traps sponsors of unpopular proposals",
  "Content": "\n<https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/dao/Proposals.sol#L396-L397> \n\n<https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/dao/DAO.sol#L281-L281>\n\nA staker is restricted to sponsoring a single proposal at any given time. This proposal remains active until a predetermined duration has elapsed, and it has received the sufficient number of votes to reach a quorum, after which it can be finalized.\n\nHowever, if a staker sponsors a proposal that fails to attract the necessary quorum of votes, it remains indefinitely in an active state. This situation effectively locks the staker in a position where they cannot propose any new initiatives, as they are stuck with an unresolved proposal.\n\nThere is no mechanism for sponsors to withdraw or cancel their proposals. So when a proposal is unable to achieve quorum, the sponsor is left in a predicament where they are unable to further participate in the governance through the initiation of new proposals.\n\nFurthermore, there is a noticeable lack of motivation for stakers to vote against proposals that are not on track to meet the quorum. As these proposals cannot pass without achieving the required quorum, resulting in a situation where voting against such proposals does not offer any tangible benefit.\n\n### Proof of Concept\n\nSteps:\n\n1.  Staker creates a valid proposal\n2.  Sufficient time passes\n3.  Insufficient votes are received to reach quorum\n4.  Staker has an active proposal they cannot close (preventing create a new proposal)\n\n**A staker can have only one active proposal**\n\nWithin `Proposals` stakers are identified as `users` and when creating a proposal there is a check [Proposals::\\_possiblyCreateProposal()](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/dao/Proposals.sol#L98)\n\n```solidity\n\t\t\t// Make sure that the user doesn't already have an active proposal\n\t\t\trequire( ! _userHasActiveProposal[msg.sender], \"Users can only have one active proposal at a time\" );\n```\n\nWith the state being pushed later in [Proposals::\\_possiblyCreateProposal()](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/dao/Proposals.sol#L113-L115)\n\n```solidity\n\t\t// Remember that the user made a proposal\n\t\t_userHasActiveProposal[msg.sender] = true;\n\t\t_usersThatProposedBallots[ballotID] = msg.sender;\n```\n\n**A proposal can only be finalized after sufficient time has passed**\n\nThe check to ensure the minimum time has passed in [Proposals::canFinalizeBallot()](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/dao/Proposals.sol#L39-L393)\n\n```solidity\n        // Check that the minimum duration has passed\n        if (block.timestamp < ballot.ballotMinimumEndTime )\n            return false;\n```\n\n**A proposal can only be finalized after quorum is reached**\n\nThe check to ensure quorum is reached in [Proposals::canFinalizeBallot()](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/dao/Proposals.sol#L395-L397)\n\n```solidity\n        // Check that the required quorum has been reached\n        if ( totalVotesCastForBallot(ballotID) < requiredQuorumForBallotType( ballot.ballotType ))\n            return false;\n```\n\n<details>\n<summary>Test Case</summary>\nUser sponsors a proposal that fails to reach quorum cannot be finalized and with no other way to close will have an active proposal, preventing further proposals.\n\nAdd the test case to [Proposals.t.sol](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/dao/tests/Proposals.t.sol#L1717)\n\n```solidity\n    function test_quorum_needed_to_finalize_ballot() external {\n        uint256 ballotID = 1;\n        uint256 stakeAmount = 250000 ether;\n\n        // Fund Alice, Bob and Charlie with equal SALT\n        vm.startPrank( DEPLOYER );\n        salt.transfer( alice, stakeAmount );\n        salt.transfer( bob, stakeAmount );\n        salt.transfer( charlie, stakeAmount );\n        vm.stopPrank();\n\n        // Alice, Bob and Charlie all stake their equal amounts of SALT\n        _stakeSalt(alice, stakeAmount);\n        _stakeSalt(bob, stakeAmount);\n        _stakeSalt(charlie, stakeAmount);\n\n        // Alice proposes a ballot\n        vm.prank(alice);\n        proposals.proposeCountryInclusion(\"US\", \"proposed ballot\");\n\n        // Alice votes YES\n        vm.prank(alice);\n        proposals.castVote( ballotID, Vote.YES );\n\n        // Now, we allow some time to pass in order to finalize the ballot\n        vm.warp(block.timestamp + daoConfig.ballotMinimumDuration());\n\n        // The ballot cannot be finalized as quorum is not reached\n        assertFalse(proposals.canFinalizeBallot(ballotID), \"Ballot cannot be finalized\");\n        assertGt(proposals.requiredQuorumForBallotType(BallotType.INCLUDE_COUNTRY),stakeAmount, \"Quorum exceeds stakeAmount\" );\n        assertTrue( proposals.userHasActiveProposal(alice), \"Alice has an active proposal\");\n    }\n\n    function _stakeSalt(address wallet, uint256 amount ) private {\n        vm.startPrank( wallet );\n        salt.approve(address(staking), amount);\n        staking.stakeSALT(amount);\n        vm.stopPrank();\n    }\n```\n\n</details>\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nAllow the proposals to be closed (equivalent to finalized as `NO` or `NO_CHANGE`), which would allow the sponsor to afterward make a different proposal.\n\n*(This feature would also generally allow removing dead proposals)*\n\nAdd a time field to `Ballot` in [IProposals](https://github.com/code-423n4/2024-01-salty/blob/main/src/dao/interfaces/IProposals.sol):\n\n```diff\n\n\t// The earliest timestamp at which a ballot can end. Can be open longer if the quorum has not yet been reached for instance.\n\tuint256 ballotMinimumEndTime;\n\n+\t// The earliest timestamp at which a ballot can be closed without quorum being reached.\n+\tuint256 ballotCloseTime;\n\t}\n```\n\nPopulate the `ballotCloseTime` in [Proposal::\\_possiblyCreateProposal](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/dao/Proposals.sol#L101-L111), using a constant in this example, it could always another DAO configuration option:\n\n```diff\n\t\t// Make sure that a proposal of the same name is not already open for the ballot\n\t\trequire( openBallotsByName[ballotName] == 0, \"Cannot create a proposal similar to a ballot that is still open\" );\n\t\trequire( openBallotsByName[ string.concat(ballotName, \"_confirm\")] == 0, \"Cannot create a proposal for a ballot with a secondary confirmation\" );\n\n\t\tuint256 ballotMinimumEndTime = block.timestamp + daoConfig.ballotMinimumDuration();\n+       uint256 ballotCloseTime = ballotMinimumEndTime + 1 weeks;\t\t\n\n\t\t// Add the new Ballot to storage\n\t\tballotID = nextBallotID++;\n+\t\tballots[ballotID] = Ballot( ballotID, true, ballotType, ballotName, address1, number1, string1, string2, ballotMinimumEndTime );\n+\t\tballots[ballotID] = Ballot( ballotID, true, ballotType, ballotName, address1, number1, string1, string2, ballotMinimumEndTime, ballotCloseTime );\n\t\topenBallotsByName[ballotName] = ballotID;\n\t\t_allOpenBallots.add( ballotID );\t\t\n```\n\nAdd a function to return whether a proposal can be closed to [Proposal](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/dao/Proposals.sol#L441):\n\n```diff\n+\tfunction canCloseBallot( uint256 ballotID ) external view returns (bool)\n+\t\t{\n+        Ballot memory ballot = ballots[ballotID];\n+        if ( ! ballot.ballotIsLive )\n+        \treturn false;\n+\n+        // Check that the minimum duration has passed\n+        if (block.timestamp < ballot.ballotCloseTime )\n+            return false;\n+\n+        return true;\n+\t    }\n```\n\nAdd a function to close a ballot without any side effect to [DAO](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/dao/DAO.sol#L381)\n\n```diff\n+   function closeBallot( uint256 ballotID ) external nonReentrant\n+       {\n+       // Checks that ballot is live and closeTime has passed\n+\t\trequire( proposals.canCloseBallot(ballotID), \"The ballot is not yet able to be closed\" ); \n+\n+       // No mutation from the propsal\n+\t\t_finalizeApprovalBallot(ballotID);\n+       }\n```\n\n**[othernet-global (Salty.IO) confirmed and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/362#issuecomment-1950433590):**\n > There is now a default 30 day period after which ballots can be removed by any user.\n> \n> https://github.com/othernet-global/salty-io/commit/758349850a994c305a0ab9a151d00e738a5a45a0\n\n**Status:** Mitigated with an Error. Full details in report from [0xpiken](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/82), and also included in the [Mitigation Review](#mitigation-review) section below.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/dao/Proposals.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-contracts/contracts/utils/Strings.sol\";\nimport \"../pools/interfaces/IPoolsConfig.sol\";\nimport \"../staking/interfaces/IStaking.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"./interfaces/IDAOConfig.sol\";\nimport \"./interfaces/IProposals.sol\";\nimport \"./interfaces/IDAO.sol\";\nimport \"../pools/PoolUtils.sol\";\n\n\n// Allows SALT stakers to propose and vote on various types of ballots such as parameter changes, token whitelisting/unwhitelisting, sending tokens, calling contracts, and updating website URLs.\n// Ensures ballot uniqueness, tracks and validates user voting power, enforces quorums, and provides a mechanism for users to alter votes.\n\ncontract Proposals is IProposals, ReentrancyGuard\n    {\n    event ProposalCreated(uint256 indexed ballotID, BallotType ballotType, string ballotName);\n    event BallotFinalized(uint256 indexed ballotID);\n    event VoteCast(address indexed voter, uint256 indexed ballotID, Vote vote, uint256 votingPower);\n\n\tusing SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    IStaking immutable public staking;\n    IExchangeConfig immutable public exchangeConfig;\n    IPoolsConfig immutable public poolsConfig;\n    IDAOConfig immutable public daoConfig;\n    ISalt immutable public salt;\n\n\t// Mapping from ballotName to a currently open ballotID (zero if none).\n\t// Used to check for existing ballots by name so as to not allow duplicate ballots to be created.\n\tmapping(string=>uint256) public openBallotsByName;\n\n\t// Maps ballotID to the corresponding Ballot\n\tmapping(uint256=>Ballot) public ballots;\n\tuint256 public nextBallotID = 1;\n\n\t// All of the ballotIDs that are currently open for voting\n\tEnumerableSet.UintSet private _allOpenBallots;\n\n\t// The ballotIDs of the tokens currently being proposed for whitelisting\n\tEnumerableSet.UintSet private _openBallotsForTokenWhitelisting;\n\n\t// The number of votes cast for a given ballot by Vote type\n\tmapping(uint256=>mapping(Vote=>uint256)) private _votesCastForBallot;\n\n\t// The last vote cast by a user for a given ballot.\n\t// Allows users to change their vote - so that the previous vote can be undone before casting the new vote.\n\tmapping(uint256=>mapping(address=>UserVote)) private _lastUserVoteForBallot;\n\n\t// Which users currently have active proposals\n\t// Useful for checking that users are only able to create one active proposal at a time (to discourage spam proposals).\n\tmapping(address=>bool) private _userHasActiveProposal;\n\n\t// Which users proposed which ballots.\n\t// Useful when a ballot is finalized - so that the user that proposed it can have their _usersWithActiveProposals status cleared\n\tmapping(uint256=>address) private _usersThatProposedBallots;\n\n\t// The time at which the first proposal can be made (45 days after deployment).\n\t// This is to allow some time for users to start staking - as some percent of stake is required to propose ballots and if the total amount staked.\n\tuint256 immutable firstPossibleProposalTimestamp = block.timestamp + 45 days;\n\n\n    constructor( IStaking _staking, IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IDAOConfig _daoConfig )\n\t\t{\n\t\tstaking = _staking;\n\t\texchangeConfig = _exchangeConfig;\n\t\tpoolsConfig = _poolsConfig;\n\t\tdaoConfig = _daoConfig;\n\n\t\tsalt = exchangeConfig.salt();\n        }\n\n\n\tfunction _possiblyCreateProposal( string memory ballotName, BallotType ballotType, address address1, uint256 number1, string memory string1, string memory string2 ) internal returns (uint256 ballotID)\n\t\t{\n\t\trequire( block.timestamp >= firstPossibleProposalTimestamp, \"Cannot propose ballots within the first 45 days of deployment\" );\n\n\t\t// The DAO can create confirmation proposals which won't have the below requirements\n\t\tif ( msg.sender != address(exchangeConfig.dao() ) )\n\t\t\t{\n\t\t\t// Make sure that the sender has the minimum amount of xSALT required to make the proposal\n\t\t\tuint256 totalStaked = staking.totalShares(PoolUtils.STAKED_SALT);\n\t\t\tuint256 requiredXSalt = ( totalStaked * daoConfig.requiredProposalPercentStakeTimes1000() ) / ( 100 * 1000 );\n\n\t\t\trequire( requiredXSalt > 0, \"requiredXSalt cannot be zero\" );\n\n\t\t\tuint256 userXSalt = staking.userShareForPool( msg.sender, PoolUtils.STAKED_SALT );\n\t\t\trequire( userXSalt >= requiredXSalt, \"Sender does not have enough xSALT to make the proposal\" );\n\n\t\t\t// Make sure that the user doesn't already have an active proposal\n\t\t\trequire( ! _userHasActiveProposal[msg.sender], \"Users can only have one active proposal at a time\" );\n\t\t\t}\n\n\t\t// Make sure that a proposal of the same name is not already open for the ballot\n\t\trequire( openBallotsByName[ballotName] == 0, \"Cannot create a proposal similar to a ballot that is still open\" );\n\t\trequire( openBallotsByName[ string.concat(ballotName, \"_confirm\")] == 0, \"Cannot create a proposal for a ballot with a secondary confirmation\" );\n\n\t\tuint256 ballotMinimumEndTime = block.timestamp + daoConfig.ballotMinimumDuration();\n\n\t\t// Add the new Ballot to storage\n\t\tballotID = nextBallotID++;\n\t\tballots[ballotID] = Ballot( ballotID, true, ballotType, ballotName, address1, number1, string1, string2, ballotMinimumEndTime );\n\t\topenBallotsByName[ballotName] = ballotID;\n\t\t_allOpenBallots.add( ballotID );\n\n\t\t// Remember that the user made a proposal\n\t\t_userHasActiveProposal[msg.sender] = true;\n\t\t_usersThatProposedBallots[ballotID] = msg.sender;\n\n\t\temit ProposalCreated(ballotID, ballotType, ballotName);\n\t\t}\n\n\n\t// Create a confirmation proposal from the DAO\n\tfunction createConfirmationProposal( string calldata ballotName, BallotType ballotType, address address1, string calldata string1, string calldata description ) external returns (uint256 ballotID)\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.dao()), \"Only the DAO can create a confirmation proposal\" );\n\n\t\treturn _possiblyCreateProposal( ballotName, ballotType, address1, 0, string1, description );\n\t\t}\n\n\n\tfunction markBallotAsFinalized( uint256 ballotID ) external nonReentrant\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.dao()), \"Only the DAO can mark a ballot as finalized\" );\n\n\t\tBallot storage ballot = ballots[ballotID];\n\n\t\t// Remove finalized whitelist token ballots from the list of open whitelisting proposals\n\t\tif ( ballot.ballotType == BallotType.WHITELIST_TOKEN )\n\t\t\t_openBallotsForTokenWhitelisting.remove( ballotID );\n\n\t\t// Remove from the list of all open ballots\n\t\t_allOpenBallots.remove( ballotID );\n\n\t\tballot.ballotIsLive = false;\n\n\t\t// Indicate that the user who posted the proposal no longer has an active proposal\n\t\taddress userThatPostedBallot = _usersThatProposedBallots[ballotID];\n\t\t_userHasActiveProposal[userThatPostedBallot] = false;\n\n\t\tdelete openBallotsByName[ballot.ballotName];\n\n\t\temit BallotFinalized(ballotID);\n\t\t}\n\n\n\tfunction proposeParameterBallot( uint256 parameterType, string calldata description ) external nonReentrant returns (uint256 ballotID)\n\t\t{\n\t\tstring memory ballotName = string.concat(\"parameter:\", Strings.toString(parameterType) );\n\t\treturn _possiblyCreateProposal( ballotName, BallotType.PARAMETER, address(0), parameterType, \"\", description );\n\t\t}\n\n\n\tfunction proposeTokenWhitelisting( IERC20 token, string calldata tokenIconURL, string calldata description ) external nonReentrant returns (uint256 _ballotID)\n\t\t{\n\t\trequire( address(token) != address(0), \"token cannot be address(0)\" );\n\t\trequire( token.totalSupply() < type(uint112).max, \"Token supply cannot exceed uint112.max\" ); // 5 quadrillion max supply with 18 decimals of precision\n\n\t\trequire( _openBallotsForTokenWhitelisting.length() < daoConfig.maxPendingTokensForWhitelisting(), \"The maximum number of token whitelisting proposals are already pending\" );\n\t\trequire( poolsConfig.numberOfWhitelistedPools() < poolsConfig.maximumWhitelistedPools(), \"Maximum number of whitelisted pools already reached\" );\n\t\trequire( ! poolsConfig.tokenHasBeenWhitelisted(token, exchangeConfig.wbtc(), exchangeConfig.weth()), \"The token has already been whitelisted\" );\n\n\t\tstring memory ballotName = string.concat(\"whitelist:\", Strings.toHexString(address(token)) );\n\n\t\tuint256 ballotID = _possiblyCreateProposal( ballotName, BallotType.WHITELIST_TOKEN, address(token), 0, tokenIconURL, description );\n\t\t_openBallotsForTokenWhitelisting.add( ballotID );\n\n\t\treturn ballotID;\n\t\t}\n\n\n\tfunction proposeTokenUnwhitelisting( IERC20 token, string calldata tokenIconURL, string calldata description ) external nonReentrant returns (uint256 ballotID)\n\t\t{\n\t\trequire( poolsConfig.tokenHasBeenWhitelisted(token, exchangeConfig.wbtc(), exchangeConfig.weth()), \"Can only unwhitelist a whitelisted token\" );\n\t\trequire( address(token) != address(exchangeConfig.wbtc()), \"Cannot unwhitelist WBTC\" );\n\t\trequire( address(token) != address(exchangeConfig.weth()), \"Cannot unwhitelist WETH\" );\n\t\trequire( address(token) != address(exchangeConfig.dai()), \"Cannot unwhitelist DAI\" );\n\t\trequire( address(token) != address(exchangeConfig.usds()), \"Cannot unwhitelist USDS\" );\n\t\trequire( address(token) != address(exchangeConfig.salt()), \"Cannot unwhitelist SALT\" );\n\n\t\tstring memory ballotName = string.concat(\"unwhitelist:\", Strings.toHexString(address(token)) );\n\t\treturn _possiblyCreateProposal( ballotName, BallotType.UNWHITELIST_TOKEN, address(token), 0, tokenIconURL, description );\n\t\t}\n\n\n\t// Proposes sending a specified amount of SALT to a wallet or contract.\n\t// Only one sendSALT Ballot can be open at a time and the sending limit is 5% of the current SALT balance of the DAO.\n\tfunction proposeSendSALT( address wallet, uint256 amount, string calldata description ) external nonReentrant returns (uint256 ballotID)\n\t\t{\n\t\trequire( wallet != address(0), \"Cannot send SALT to address(0)\" );\n\n\t\t// Limit to 5% of current balance\n\t\tuint256 balance = exchangeConfig.salt().balanceOf( address(exchangeConfig.dao()) );\n\t\tuint256 maxSendable = balance * 5 / 100;\n\t\trequire( amount <= maxSendable, \"Cannot send more than 5% of the DAO SALT balance\" );\n\n\t\t// This ballotName is not unique for the receiving wallet and enforces the restriction of one sendSALT ballot at a time.\n\t\t// If more receivers are necessary at once, a splitter can be used.\n\t\tstring memory ballotName = \"sendSALT\";\n\t\treturn _possiblyCreateProposal( ballotName, BallotType.SEND_SALT, wallet, amount, \"\", description );\n\t\t}\n\n\n\t// Proposes calling the callFromDAO(uint256) function on an arbitrary contract.\n\tfunction proposeCallContract( address contractAddress, uint256 number, string calldata description ) external nonReentrant returns (uint256 ballotID)\n\t\t{\n\t\trequire( contractAddress != address(0), \"Contract address cannot be address(0)\" );\n\n\t\tstring memory ballotName = string.concat(\"callContract:\", Strings.toHexString(address(contractAddress)) );\n\t\treturn _possiblyCreateProposal( ballotName, BallotType.CALL_CONTRACT, contractAddress, number, description, \"\" );\n\t\t}\n\n\n\tfunction proposeCountryInclusion( string calldata country, string calldata description ) external nonReentrant returns (uint256 ballotID)\n\t\t{\n\t\trequire( bytes(country).length == 2, \"Country must be an ISO 3166 Alpha-2 Code\" );\n\n\t\tstring memory ballotName = string.concat(\"include:\", country );\n\t\treturn _possiblyCreateProposal( ballotName, BallotType.INCLUDE_COUNTRY, address(0), 0, country, description );\n\t\t}\n\n\n\tfunction proposeCountryExclusion( string calldata country, string calldata description ) external nonReentrant returns (uint256 ballotID)\n\t\t{\n\t\trequire( bytes(country).length == 2, \"Country must be an ISO 3166 Alpha-2 Code\" );\n\n\t\tstring memory ballotName = string.concat(\"exclude:\", country );\n\t\treturn _possiblyCreateProposal( ballotName, BallotType.EXCLUDE_COUNTRY, address(0), 0, country, description );\n\t\t}\n\n\n\tfunction proposeSetContractAddress( string calldata contractName, address newAddress, string calldata description ) external nonReentrant returns (uint256 ballotID)\n\t\t{\n\t\trequire( newAddress != address(0), \"Proposed address cannot be address(0)\" );\n\n\t\tstring memory ballotName = string.concat(\"setContract:\", contractName );\n\t\treturn _possiblyCreateProposal( ballotName, BallotType.SET_CONTRACT, newAddress, 0, \"\", description );\n\t\t}\n\n\n\tfunction proposeWebsiteUpdate( string calldata newWebsiteURL, string calldata description ) external nonReentrant returns (uint256 ballotID)\n\t\t{\n\t\trequire( keccak256(abi.encodePacked(newWebsiteURL)) != keccak256(abi.encodePacked(\"\")), \"newWebsiteURL cannot be empty\" );\n\n\t\tstring memory ballotName = string.concat(\"setURL:\", newWebsiteURL );\n\t\treturn _possiblyCreateProposal( ballotName, BallotType.SET_WEBSITE_URL, address(0), 0, newWebsiteURL, description );\n\t\t}\n\n\n\t// Cast a vote on an open ballot\n\tfunction castVote( uint256 ballotID, Vote vote ) external nonReentrant\n\t\t{\n\t\tBallot memory ballot = ballots[ballotID];\n\n\t\t// Require that the ballot is actually live\n\t\trequire( ballot.ballotIsLive, \"The specified ballot is not open for voting\" );\n\n\t\t// Make sure that the vote type is valid for the given ballot\n\t\tif ( ballot.ballotType == BallotType.PARAMETER )\n\t\t\trequire( (vote == Vote.INCREASE) || (vote == Vote.DECREASE) || (vote == Vote.NO_CHANGE), \"Invalid VoteType for Parameter Ballot\" );\n\t\telse // If a Ballot is not a Parameter Ballot, it is an Approval ballot\n\t\t\trequire( (vote == Vote.YES) || (vote == Vote.NO), \"Invalid VoteType for Approval Ballot\" );\n\n\t\t// Make sure that the user has voting power before proceeding.\n\t\t// Voting power is equal to their userShare of STAKED_SALT.\n\t\t// If the user changes their stake after voting they will have to recast their vote.\n\n\t\tuint256 userVotingPower = staking.userShareForPool( msg.sender, PoolUtils.STAKED_SALT );\n\t\trequire( userVotingPower > 0, \"Staked SALT required to vote\" );\n\n\t\t// Remove any previous votes made by the user on the ballot\n\t\tUserVote memory lastVote = _lastUserVoteForBallot[ballotID][msg.sender];\n\n\t\t// Undo the last vote?\n\t\tif ( lastVote.votingPower > 0 )\n\t\t\t_votesCastForBallot[ballotID][lastVote.vote] -= lastVote.votingPower;\n\n\t\t// Update the votes cast for the ballot with the user's current voting power\n\t\t_votesCastForBallot[ballotID][vote] += userVotingPower;\n\n\t\t// Remember how the user voted in case they change their vote later\n\t\t_lastUserVoteForBallot[ballotID][msg.sender] = UserVote( vote, userVotingPower );\n\n\t\temit VoteCast(msg.sender, ballotID, vote, userVotingPower);\n\t\t}\n\n\n\t// === VIEWS ===\n\tfunction ballotForID( uint256 ballotID ) external view returns (Ballot memory)\n\t\t{\n\t\treturn ballots[ballotID];\n\t\t}\n\n\n\tfunction lastUserVoteForBallot( uint256 ballotID, address user ) external view returns (UserVote memory)\n\t\t{\n\t\treturn _lastUserVoteForBallot[ballotID][user];\n\t\t}\n\n\n\tfunction votesCastForBallot( uint256 ballotID, Vote vote ) external view returns (uint256)\n\t\t{\n\t\treturn _votesCastForBallot[ballotID][vote];\n\t\t}\n\n\n\t// The required quorum is normally a default 10% of the amount of SALT staked.\n\t// There is though a minimum of 0.50% of SALT.totalSupply (in the case that the amount of staked SALT is low - at launch for instance).\n\tfunction requiredQuorumForBallotType( BallotType ballotType ) public view returns (uint256 requiredQuorum)\n\t\t{\n\t\t// The quorum will be specified as a percentage of the total amount of SALT staked\n\t\tuint256 totalStaked = staking.totalShares( PoolUtils.STAKED_SALT );\n\t\trequire( totalStaked != 0, \"SALT staked cannot be zero to determine quorum\" );\n\n\t\tif ( ballotType == BallotType.PARAMETER )\n\t\t\trequiredQuorum = ( 1 * totalStaked * daoConfig.baseBallotQuorumPercentTimes1000()) / ( 100 * 1000 );\n\t\telse if ( ( ballotType == BallotType.WHITELIST_TOKEN ) || ( ballotType == BallotType.UNWHITELIST_TOKEN ) )\n\t\t\trequiredQuorum = ( 2 * totalStaked * daoConfig.baseBallotQuorumPercentTimes1000()) / ( 100 * 1000 );\n\t\telse\n\t\t\t// All other ballot types require 3x multiple of the baseQuorum\n\t\t\trequiredQuorum = ( 3 * totalStaked * daoConfig.baseBallotQuorumPercentTimes1000()) / ( 100 * 1000 );\n\n\t\t// Make sure that the requiredQuorum is at least 0.50% of the total SALT supply.\n\t\t// Circulating supply after the first 45 days of emissions will be about 3 million - so this would require about 16% of the circulating\n\t\t// SALT to be staked and voting to pass a proposal (including whitelisting) 45 days after deployment..\n\t\tuint256 totalSupply = ERC20(address(exchangeConfig.salt())).totalSupply();\n\t\tuint256 minimumQuorum = totalSupply * 5 / 1000;\n\n\t\tif ( requiredQuorum < minimumQuorum )\n\t\t\trequiredQuorum = minimumQuorum;\n\t\t}\n\n\n\tfunction totalVotesCastForBallot( uint256 ballotID ) public view returns (uint256)\n\t\t{\n\t\tmapping(Vote=>uint256) storage votes = _votesCastForBallot[ballotID];\n\n\t\tBallot memory ballot = ballots[ballotID];\n\t\tif ( ballot.ballotType == BallotType.PARAMETER )\n\t\t\treturn votes[Vote.INCREASE] + votes[Vote.DECREASE] + votes[Vote.NO_CHANGE];\n\t\telse\n\t\t\treturn votes[Vote.YES] + votes[Vote.NO];\n\t\t}\n\n\n\t// Assumes that the quorum has been checked elsewhere\n\tfunction ballotIsApproved( uint256 ballotID ) external view returns (bool)\n\t\t{\n\t\tmapping(Vote=>uint256) storage votes = _votesCastForBallot[ballotID];\n\n\t\treturn votes[Vote.YES] > votes[Vote.NO];\n\t\t}\n\n\n\t// Assumes that the quorum has been checked elsewhere\n\tfunction winningParameterVote( uint256 ballotID ) external view returns (Vote)\n\t\t{\n\t\tmapping(Vote=>uint256) storage votes = _votesCastForBallot[ballotID];\n\n\t\tuint256 increaseTotal = votes[Vote.INCREASE];\n\t\tuint256 decreaseTotal = votes[Vote.DECREASE];\n\t\tuint256 noChangeTotal = votes[Vote.NO_CHANGE];\n\n\t\tif ( increaseTotal > decreaseTotal )\n\t\tif ( increaseTotal > noChangeTotal )\n\t\t\treturn Vote.INCREASE;\n\n\t\tif ( decreaseTotal > increaseTotal )\n\t\tif ( decreaseTotal > noChangeTotal )\n\t\t\treturn Vote.DECREASE;\n\n\t\treturn Vote.NO_CHANGE;\n\t\t}\n\n\n\t// Checks that ballot is live, and minimumEndTime and quorum have both been reached.\n\tfunction canFinalizeBallot( uint256 ballotID ) external view returns (bool)\n\t\t{\n        Ballot memory ballot = ballots[ballotID];\n        if ( ! ballot.ballotIsLive )\n        \treturn false;\n\n        // Check that the minimum duration has passed\n        if (block.timestamp < ballot.ballotMinimumEndTime )\n            return false;\n\n        // Check that the required quorum has been reached\n        if ( totalVotesCastForBallot(ballotID) < requiredQuorumForBallotType( ballot.ballotType ))\n            return false;\n\n        return true;\n\t    }\n\n\n\tfunction openBallots() external view returns (uint256[] memory)\n\t\t{\n\t\treturn _allOpenBallots.values();\n\t\t}\n\n\n\tfunction openBallotsForTokenWhitelisting() external view returns (uint256[] memory)\n\t\t{\n\t\treturn _openBallotsForTokenWhitelisting.values();\n\t\t}\n\n\n\t// Returns the ballotID of the whitelisting ballot that currently has the most yes votes\n\t// Requires that the quorum has been reached and that the number of yes votes is greater than the number no votes\n\tfunction tokenWhitelistingBallotWithTheMostVotes() external view returns (uint256)\n\t\t{\n\t\tuint256 quorum = requiredQuorumForBallotType( BallotType.WHITELIST_TOKEN);\n\n\t\tuint256 bestID = 0;\n\t\tuint256 mostYes = 0;\n\t\tfor( uint256 i = 0; i < _openBallotsForTokenWhitelisting.length(); i++ )\n\t\t\t{\n\t\t\tuint256 ballotID = _openBallotsForTokenWhitelisting.at(i);\n\t\t\tuint256 yesTotal = _votesCastForBallot[ballotID][Vote.YES];\n\t\t\tuint256 noTotal = _votesCastForBallot[ballotID][Vote.NO];\n\n\t\t\tif ( (yesTotal + noTotal) >= quorum ) // Make sure that quorum has been reached\n\t\t\tif ( yesTotal > noTotal )  // Make sure the token vote is favorable\n\t\t\tif ( yesTotal > mostYes )  // Make sure these are the most yes votes seen\n\t\t\t\t{\n\t\t\t\tbestID = ballotID;\n\t\t\t\tmostYes = yesTotal;\n\t\t\t\t}\n\t\t\t}\n\n\t\treturn bestID;\n\t\t}\n\n\n\tfunction userHasActiveProposal( address user ) external view returns (bool)\n\t\t{\n\t\treturn _userHasActiveProposal[user];\n\t\t}\n\t}"
    },
    {
      "filename": "src/dao/DAO.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"../price_feed/interfaces/IPriceAggregator.sol\";\nimport \"../rewards/interfaces/IRewardsEmitter.sol\";\nimport \"../rewards/interfaces/IRewardsConfig.sol\";\nimport \"../stable/interfaces/IStableConfig.sol\";\nimport \"../stable/interfaces/ILiquidizer.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"../staking/interfaces/IStaking.sol\";\nimport \"../interfaces/IAccessManager.sol\";\nimport \"./interfaces/ICalledContract.sol\";\nimport \"./interfaces/IProposals.sol\";\nimport \"./interfaces/IDAO.sol\";\nimport \"../pools/PoolUtils.sol\";\nimport \"./Parameters.sol\";\nimport \"../Upkeep.sol\";\n\n\n// Allows users to propose and vote on various governance actions such as changing parameters, whitelisting/unwhitelisting tokens, sending tokens, calling other contracts, and updating the website.\n// It handles proposing ballots, tracking votes, enforcing voting requirements, and executing approved proposals.\ncontract DAO is IDAO, Parameters, ReentrancyGuard\n    {\n\tevent BallotFinalized(uint256 indexed ballotID, Vote winningVote);\n    event SetContract(string indexed ballotName, address indexed contractAddress);\n    event SetWebsiteURL(string newURL);\n    event WhitelistToken(IERC20 indexed token);\n    event UnwhitelistToken(IERC20 indexed token);\n    event GeoExclusionUpdated(string country, bool excluded, uint256 geoVersion);\n    event ArbitrageProfitsWithdrawn(address indexed upkeepContract, IERC20 indexed weth, uint256 withdrawnAmount);\n    event SaltSent(address indexed to, uint256 amount);\n    event ContractCalled(address indexed contractAddress, uint256 indexed intArg);\n    event TeamRewardsTransferred(uint256 teamAmount);\n\n    event POLFormed(IERC20 indexed tokenA, IERC20 indexed tokenB, uint256 amountA, uint256 amountB);\n    event POLProcessed(uint256 claimedSALT);\n    event POLWithdrawn(IERC20 indexed tokenA, IERC20 indexed tokenB, uint256 withdrawnA, uint256 withdrawnB);\n\n\tusing SafeERC20 for ISalt;\n\tusing SafeERC20 for IERC20;\n\tusing SafeERC20 for IUSDS;\n\n\tIPools immutable public pools;\n\tIProposals immutable public proposals;\n\tIExchangeConfig immutable public exchangeConfig;\n\tIPoolsConfig immutable public poolsConfig;\n\tIStakingConfig immutable public stakingConfig;\n\tIRewardsConfig immutable public rewardsConfig;\n\tIStableConfig immutable public stableConfig;\n\tIDAOConfig immutable public daoConfig;\n\tIPriceAggregator immutable public priceAggregator;\n\tIRewardsEmitter immutable public liquidityRewardsEmitter;\n\tICollateralAndLiquidity immutable public collateralAndLiquidity;\n\tILiquidizer immutable public liquidizer;\n\n\tISalt immutable public salt;\n    IUSDS immutable public usds;\n\tIERC20 immutable public dai;\n\n\n\t// The default IPFS URL for the website content (can be changed with a setWebsiteURL proposal)\n\tstring public websiteURL;\n\n\t// Countries that have been excluded from access to the DEX (used by AccessManager.sol)\n\t// Keys as ISO 3166 Alpha-2 Codes\n\tmapping(string=>bool) public excludedCountries;\n\n\n    constructor( IPools _pools, IProposals _proposals, IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IStakingConfig _stakingConfig, IRewardsConfig _rewardsConfig, IStableConfig _stableConfig, IDAOConfig _daoConfig, IPriceAggregator _priceAggregator, IRewardsEmitter _liquidityRewardsEmitter, ICollateralAndLiquidity _collateralAndLiquidity )\n\t\t{\n\t\tpools = _pools;\n\t\tproposals = _proposals;\n\t\texchangeConfig = _exchangeConfig;\n\t\tpoolsConfig = _poolsConfig;\n\t\tstakingConfig = _stakingConfig;\n\t\trewardsConfig = _rewardsConfig;\n\t\tstableConfig = _stableConfig;\n\t\tdaoConfig = _daoConfig;\n\t\tpriceAggregator = _priceAggregator;\n        liquidityRewardsEmitter = _liquidityRewardsEmitter;\n        collateralAndLiquidity = _collateralAndLiquidity;\n \t\tliquidizer = collateralAndLiquidity.liquidizer();\n\n        usds = exchangeConfig.usds();\n        salt = exchangeConfig.salt();\n        dai = exchangeConfig.dai();\n\n\t\t// Gas saving approves for eventually forming Protocol Owned Liquidity\n\t\tsalt.approve(address(collateralAndLiquidity), type(uint256).max);\n\t\tusds.approve(address(collateralAndLiquidity), type(uint256).max);\n\t\tdai.approve(address(collateralAndLiquidity), type(uint256).max);\n\n\t\t// Excluded by default: United States, Canada, United Kingdom, China, India, Pakistan, Russia, Afghanistan, Cuba, Iran, North Korea, Syria, Venezuela\n\t\t// Note that the DAO can remove any of these exclusions - or open up access completely to the exchange as it sees fit.\n\t\texcludedCountries[\"US\"] = true;\n\t\texcludedCountries[\"CA\"] = true;\n\t\texcludedCountries[\"GB\"] = true;\n\t\texcludedCountries[\"CN\"] = true;\n\t\texcludedCountries[\"IN\"] = true;\n\t\texcludedCountries[\"PK\"] = true;\n\t\texcludedCountries[\"RU\"] = true;\n\t\texcludedCountries[\"AF\"] = true;\n\t\texcludedCountries[\"CU\"] = true;\n\t\texcludedCountries[\"IR\"] = true;\n\t\texcludedCountries[\"KP\"] = true;\n\t\texcludedCountries[\"SY\"] = true;\n\t\texcludedCountries[\"VE\"] = true;\n        }\n\n\n\t// Finalize the vote for a parameter ballot (increase, decrease or no_change) for a given parameter\n\tfunction _finalizeParameterBallot( uint256 ballotID ) internal\n\t\t{\n\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\n\t\tVote winningVote = proposals.winningParameterVote(ballotID);\n\n\t\tif ( winningVote == Vote.INCREASE )\n\t\t\t_executeParameterChange( ParameterTypes(ballot.number1), true, poolsConfig, stakingConfig, rewardsConfig, stableConfig, daoConfig, priceAggregator );\n\t\telse if ( winningVote == Vote.DECREASE )\n\t\t\t_executeParameterChange( ParameterTypes(ballot.number1), false, poolsConfig, stakingConfig, rewardsConfig, stableConfig, daoConfig, priceAggregator );\n\n\t\t// Finalize the ballot even if NO_CHANGE won\n\t\tproposals.markBallotAsFinalized(ballotID);\n\n\t\temit BallotFinalized(ballotID, winningVote);\n\t\t}\n\n\n\tfunction _executeSetContract( Ballot memory ballot ) internal\n\t\t{\n\t\tbytes32 nameHash = keccak256(bytes( ballot.ballotName ) );\n\n\t\tif ( nameHash == keccak256(bytes( \"setContract:priceFeed1_confirm\" )) )\n\t\t\tpriceAggregator.setPriceFeed( 1, IPriceFeed(ballot.address1) );\n\t\telse if ( nameHash == keccak256(bytes( \"setContract:priceFeed2_confirm\" )) )\n\t\t\tpriceAggregator.setPriceFeed( 2, IPriceFeed(ballot.address1) );\n\t\telse if ( nameHash == keccak256(bytes( \"setContract:priceFeed3_confirm\" )) )\n\t\t\tpriceAggregator.setPriceFeed( 3, IPriceFeed(ballot.address1) );\n\t\telse if ( nameHash == keccak256(bytes( \"setContract:accessManager_confirm\" )) )\n\t\t\texchangeConfig.setAccessManager( IAccessManager(ballot.address1) );\n\n\t\temit SetContract(ballot.ballotName, ballot.address1);\n\t\t}\n\n\n\tfunction _executeSetWebsiteURL( Ballot memory ballot ) internal\n\t\t{\n\t\twebsiteURL = ballot.string1;\n\t\temit SetWebsiteURL(ballot.string1);\n\t\t}\n\n\n\tfunction _executeApproval( Ballot memory ballot ) internal\n\t\t{\n\t\tif ( ballot.ballotType == BallotType.UNWHITELIST_TOKEN )\n\t\t\t{\n\t\t\t// All tokens are paired with both WBTC and WETH so unwhitelist those pools\n\t\t\tpoolsConfig.unwhitelistPool( pools, IERC20(ballot.address1), exchangeConfig.wbtc() );\n\t\t\tpoolsConfig.unwhitelistPool( pools, IERC20(ballot.address1), exchangeConfig.weth() );\n\n\t\t\temit UnwhitelistToken(IERC20(ballot.address1));\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.SEND_SALT )\n\t\t\t{\n\t\t\t// Make sure the contract has the SALT balance before trying to send it.\n\t\t\t// This should not happen but is here just in case - to prevent approved proposals from reverting on finalization.\n\t\t\tif ( exchangeConfig.salt().balanceOf(address(this)) >= ballot.number1 )\n\t\t\t\t{\n\t\t\t\tIERC20(exchangeConfig.salt()).safeTransfer( ballot.address1, ballot.number1 );\n\n\t\t\t\temit SaltSent(ballot.address1, ballot.number1);\n\t\t\t\t}\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.CALL_CONTRACT )\n\t\t\t{\n\t\t\tICalledContract(ballot.address1).callFromDAO( ballot.number1 );\n\n\t\t\temit ContractCalled(ballot.address1, ballot.number1);\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.INCLUDE_COUNTRY )\n\t\t\t{\n\t\t\texcludedCountries[ ballot.string1 ] = false;\n\n\t\t\temit GeoExclusionUpdated(ballot.string1, false, exchangeConfig.accessManager().geoVersion());\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.EXCLUDE_COUNTRY )\n\t\t\t{\n\t\t\texcludedCountries[ ballot.string1 ] = true;\n\n\t\t\t// If the AccessManager doesn't implement excludedCountriesUpdated, this will revert and countries will not be able to be excluded until the AccessManager is working properly.\n\t\t\texchangeConfig.accessManager().excludedCountriesUpdated();\n\n\t\t\temit GeoExclusionUpdated(ballot.string1, true, exchangeConfig.accessManager().geoVersion());\n\t\t\t}\n\n\t\t// Once an initial setContract proposal passes, it automatically starts a second confirmation ballot (to prevent last minute approvals)\n\t\telse if ( ballot.ballotType == BallotType.SET_CONTRACT )\n\t\t\tproposals.createConfirmationProposal( string.concat(ballot.ballotName, \"_confirm\"), BallotType.CONFIRM_SET_CONTRACT, ballot.address1, \"\", ballot.description );\n\n\t\t// Once an initial setWebsiteURL proposal passes, it automatically starts a second confirmation ballot (to prevent last minute approvals)\n\t\telse if ( ballot.ballotType == BallotType.SET_WEBSITE_URL )\n\t\t\tproposals.createConfirmationProposal( string.concat(ballot.ballotName, \"_confirm\"), BallotType.CONFIRM_SET_WEBSITE_URL, address(0), ballot.string1, ballot.description );\n\n\t\telse if ( ballot.ballotType == BallotType.CONFIRM_SET_CONTRACT )\n\t\t\t_executeSetContract( ballot );\n\n\t\telse if ( ballot.ballotType == BallotType.CONFIRM_SET_WEBSITE_URL )\n\t\t\t_executeSetWebsiteURL( ballot );\n\t\t}\n\n\n\t// Finalize the vote for an approval ballot (yes or no) for a given proposal\n\tfunction _finalizeApprovalBallot( uint256 ballotID ) internal\n\t\t{\n\t\tif ( proposals.ballotIsApproved(ballotID ) )\n\t\t\t{\n\t\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\t\t\t_executeApproval( ballot );\n\t\t\t}\n\n\t\tproposals.markBallotAsFinalized(ballotID);\n\t\t}\n\n\n\t// Finalize and execute a token whitelisting ballot.\n\t// If the proposal is currently the whitelisting proposal with the most yes votes then the token can be whitelisted.\n\t// Only the top voted whitelisting proposal can be finalized - as whitelisting requires bootstrapping rewards to be sent from the DAO.\n\t// If NO > YES than the proposal is removed immediately (quorum would already have been determined - in canFinalizeBallot as called from finalizeBallot).\n\tfunction _finalizeTokenWhitelisting( uint256 ballotID ) internal\n\t\t{\n\t\tif ( proposals.ballotIsApproved(ballotID ) )\n\t\t\t{\n\t\t\t// The ballot is approved. Any reversions below will allow the ballot to be attemped to be finalized later - as the ballot won't be finalized on reversion.\n\t\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\n\t\t\tuint256 bootstrappingRewards = daoConfig.bootstrappingRewards();\n\n\t\t\t// Make sure that the DAO contract holds the required amount of SALT for bootstrappingRewards.\n\t\t\t// Twice the bootstrapping rewards are needed (for both the token/WBTC and token/WETH pools)\n\t\t\tuint256 saltBalance = exchangeConfig.salt().balanceOf( address(this) );\n\t\t\trequire( saltBalance >= bootstrappingRewards * 2, \"Whitelisting is not currently possible due to insufficient bootstrapping rewards\" );\n\n\t\t\t// Fail to whitelist for now if this isn't the whitelisting proposal with the most votes - can try again later.\n\t\t\tuint256 bestWhitelistingBallotID = proposals.tokenWhitelistingBallotWithTheMostVotes();\n\t\t\trequire( bestWhitelistingBallotID == ballotID, \"Only the token whitelisting ballot with the most votes can be finalized\" );\n\n\t\t\t// All tokens are paired with both WBTC and WETH, so whitelist both pairings\n\t\t\tpoolsConfig.whitelistPool( pools,  IERC20(ballot.address1), exchangeConfig.wbtc() );\n\t\t\tpoolsConfig.whitelistPool( pools,  IERC20(ballot.address1), exchangeConfig.weth() );\n\n\t\t\tbytes32 pool1 = PoolUtils._poolID( IERC20(ballot.address1), exchangeConfig.wbtc() );\n\t\t\tbytes32 pool2 = PoolUtils._poolID( IERC20(ballot.address1), exchangeConfig.weth() );\n\n\t\t\t// Send the initial bootstrappingRewards to promote initial liquidity on these two newly whitelisted pools\n\t\t\tAddedReward[] memory addedRewards = new AddedReward[](2);\n\t\t\taddedRewards[0] = AddedReward( pool1, bootstrappingRewards );\n\t\t\taddedRewards[1] = AddedReward( pool2, bootstrappingRewards );\n\n\t\t\texchangeConfig.salt().approve( address(liquidityRewardsEmitter), bootstrappingRewards * 2 );\n\t\t\tliquidityRewardsEmitter.addSALTRewards( addedRewards );\n\n\t\t\temit WhitelistToken(IERC20(ballot.address1));\n\t\t\t}\n\n\t\t// Mark the ballot as finalized (which will also remove it from the list of open token whitelisting proposals)\n\t\tproposals.markBallotAsFinalized(ballotID);\n\t\t}\n\n\n\t// Finalize the vote on a specific ballot.\n\t// Can be called by anyone, but only actually finalizes the ballot if it can be finalized.\n\tfunction finalizeBallot( uint256 ballotID ) external nonReentrant\n\t\t{"
    }
  ]
}