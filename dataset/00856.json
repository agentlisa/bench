{
  "Title": "H-1: when reservedUntilTokenId > 100 first funder loss 1% NFT",
  "Content": "# Issue H-1: when reservedUntilTokenId > 100 first funder loss 1% NFT \n\nSource: https://github.com/sherlock-audit/2023-09-nounsbuilder-judging/issues/42 \n\n## Found by \n0x52, 0xReiAyanami, 0xbepresent, 0xcrunch, 0xmystery, 0xpep7, Aamirusmani1552, Ch\\_301, Falconhoof, HHK, Jiamin, Juntao, KingNFT, Kow, Krace, KupiaSec, Nyx, SilentDefendersOfDeFi, SovaSlava, almurhasan, ast3ros, bin2chen, cawfree, chaduke, circlelooper, coffiasd, dany.armstrong90, deepkin, dimulski, ge6a, ggg\\_ttt\\_hhh, giraffe, gqrp, pontifex, qpzm, rvierdiiev, saian, unforgiven, whoismxuse, xAriextz, ydlee, zraxx\n## Summary\nThe incorrect use of `baseTokenId = reservedUntilTokenId` may result in the first `tokenRecipient[]` being invalid, thus preventing the founder from obtaining this portion of the NFT.\n\n## Vulnerability Detail\n\nThe current protocol adds a parameter `reservedUntilTokenId` for reserving `Token`.\nThis parameter will be used as the starting `baseTokenId` during initialization.\n\n```solidity\n    function _addFounders(IManager.FounderParams[] calldata _founders, uint256 reservedUntilTokenId) internal {\n...\n\n                // Used to store the base token id the founder will recieve\n@>              uint256 baseTokenId = reservedUntilTokenId;\n\n                // For each token to vest:\n                for (uint256 j; j < founderPct; ++j) {\n                    // Get the available token id\n                    baseTokenId = _getNextTokenId(baseTokenId);\n\n                    // Store the founder as the recipient\n                    tokenRecipient[baseTokenId] = newFounder;\n\n                    emit MintScheduled(baseTokenId, founderId, newFounder);\n\n                    // Update the base token id\n                    baseTokenId = (baseTokenId + schedule) % 100;\n                }\n            }\n..\n\n    function _getNextTokenId(uint256 _tokenId) internal view returns (uint256) {\n        unchecked {\n@>          while (tokenRecipient[_tokenId].wallet != address(0)) {\n                _tokenId = (++_tokenId) % 100;\n            }\n\n            return _tokenId;\n        }\n    }\n```\n\nBecause `baseTokenId = reservedUntilTokenId` is used, if `reservedUntilTokenId>100`, for example, reservedUntilTokenId=200, the first `_getNextTokenId(200)` will return `baseTokenId=200 ,  tokenRecipient[200]=newFounder`.\n\nExample:\nreservedUntilTokenId = 200\nfounder[0].founderPct = 10\n\nIn this way, the `tokenRecipient[]` of `founder` will become\ntokenRecipient[200].wallet = founder   ( first will call _getNextTokenId(200) return 200)\ntokenRecipient[10].wallet = founder      ( second will call _getNextTokenId((200 + 10) %100 = 10) )\ntokenRecipient[20].wallet = founder\n...\ntokenRecipient[90].wallet = founder\n\n\nHowever, this `tokenRecipient[200]` will never be used, because in `_isForFounder()`, it will be modulo, so only `baseTokenId < 100` is valid. In this way, the first founder can actually only `9%` of NFT.\n\n```solidity\n    function _isForFounder(uint256 _tokenId) private returns (bool) {\n        // Get the base token id\n@>      uint256 baseTokenId = _tokenId % 100;\n\n        // If there is no scheduled recipient:\n        if (tokenRecipient[baseTokenId].wallet == address(0)) {\n            return false;\n\n            // Else if the founder is still vesting:\n        } else if (block.timestamp < tokenRecipient[baseTokenId].vestExpiry) {\n            // Mint the token to the founder\n@>          _mint(tokenRecipient[baseTokenId].wallet, _tokenId);\n\n            return true;\n\n            // Else the founder has finished vesting:\n        } else {\n            // Remove them from future lookups\n            delete tokenRecipient[baseTokenId];\n\n            return false;\n        }\n    }\n```\n\n## POC\n\nThe following test demonstrates that `tokenRecipient[200]` is for founder.\n\n1. need change tokenRecipient to public , so can assertEq\n```diff\ncontract TokenStorageV1 is TokenTypesV1 {\n    /// @notice The token settings\n    Settings internal settings;\n\n    /// @notice The vesting details of a founder\n    /// @dev Founder id => Founder\n    mapping(uint256 => Founder) internal founder;\n\n    /// @notice The recipient of a token\n    /// @dev ERC-721 token id => Founder\n-   mapping(uint256 => Founder) internal tokenRecipient;\n+   mapping(uint256 => Founder) public tokenRecipient;\n}\n```\n\n2. add to `token.t.sol`\n```solidity\n    function test_lossFirst(address _minter, uint256 _reservedUntilTokenId, uint256 _tokenId) public {\n        deployAltMock(200);\n        (address wallet ,,)= token.tokenRecipient(200);\n        assertEq(wallet,founder);\n    }\n```\n\n```console\n$ forge test -vvv --match-test test_lossFirst\n\nRunning 1 test for test/Token.t.sol:TokenTest\n[PASS] test_lossFirst(address,uint256,uint256) (runs: 256, Î¼: 3221578, ~: 3221578)\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 355.45ms\nRan 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)\n\n```\n\n## Impact\n\nwhen reservedUntilTokenId > 100 first funder loss 1% NFT\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-09-nounsbuilder/blob/main/nouns-protocol/src/token/Token.sol#L161\n\n## Tool used\n\nManual Review\n\n## Recommendation\n1. A better is that the baseTokenId always starts from 0.\n```diff\n    function _addFounders(IManager.FounderParams[] calldata _founders, uint256 reservedUntilTokenId) internal {\n...\n\n                // Used to store the base token id the founder will recieve\n-               uint256 baseTokenId = reservedUntilTokenId;\n+               uint256 baseTokenId =0;\n```\nor\n\n2. use `uint256 baseTokenId = reservedUntilTokenId  % 100;`\n```diff\n    function _addFounders(IManager.FounderParams[] calldata _founders, uint256 reservedUntilTokenId) internal {\n...\n\n                // Used to store the base token id the founder will recieve\n-               uint256 baseTokenId = reservedUntilTokenId;\n+               uint256 baseTokenId = reservedUntilTokenId  % 100;\n```\n\n\n\n## Discussion\n\n**neokry**\n\nThis is valid and is the core issue behind #247 as well. baseTokenId should start at 0 in `addFounders`\n\n**nevillehuang**\n\nI initially separated the 4 findings below, but I agree, #177, #247 and #67 are only possible because of the following lines of code [here](https://github.com/sherlock-audit/2023-09-nounsbuilder/blob/main/nouns-protocol/src/token/Token.sol#L161), wherein `_addFounder()`, `baseTokenId` is incorrectly initialized to `reservedUntilTokenId ` in `addFounders()`, which is the root cause of the issue, and once fixed, all the issues will be fixed too. There are 4 impacts mentioned by watsons. \n\n```solidity\nuint256 baseTokenId = reservedUntilTokenId;\n```\n\n1. Previous founders that are meant to be deleted are retained causing them to continue receiving minted NFTs --> High severity, since it is a definite loss of funds\n\n2. #247: Any `reserveTokenId` greater than 100 will cause a 1% loss of NFT for founder --> High severity, since it is a definite loss of funds for founder as long as `reservedUntilTokenId ` is set greater than 100, which is not unlikely\n\n3. #177: This is essentially only an issue as `baseTokenId` is incorrectly set as `reservedUntilTokenId` but will cause a definite loss of founders NFT if performed, so keeping as duplicate\n\n4. #67: This is closely related to the above finding (177), where a new update to `reservedUntilTokenId` via `setReservedUntilTokenId` can cause over/underallocation NFTs so keeping as duplicate\n\n\nHowever, in the context of the audit period, I could also see why watsons separated these issues, so happy to hear from watsons during escalation period revolving deduplication of these issues.\n\n**neokry**\n\nFixed here: https://github.com/ourzora/nouns-protocol/pull/122\n\n**nevillehuang**\n\nHi @neokry would be helpful if you could highlight to watsons here why you think the following primary issues should be duplicated under this issue:\n\n#67\n#177\n#247 \n\nFrom my understanding it stems from the `_addFounders()` function used in both the `initialize()` and `updateFounders()` function, in particular the following line [here](https://github.com/sherlock-audit/2023-09-nounsbuilder/blob/main/nouns-protocol/src/token/Token.sol#L161), \n```solidity\nuint256 baseTokenId = reservedUntilTokenId;\n```\n\nBut it would be extremely helpful if you could provide a more detailed explanation in each finding, and show how the fix to #42 also fixes the rest of the findings.\n\nTo all watsons, this is my initial deduplication [here](https://discord.com/channels/812037309376495636/1176899915411099719/1184507360765546556), feel free to also provide me the flow state of the functions to prove that they do not have the same root cause.\n\n**nevillehuang**\n\nHi watsons, \nThe core of issue #42 is that `baseTokenId` should not start with `reservedUntilTokenId ` within `addFounders()`\n\n#67 and its duplicates\nI believe this issue and its duplicates are invalid as there is a misunderstanding of how founders token amount are assigned based on this [comment here](https://github.com/sherlock-audit/2023-09-nounsbuilder-judging/issues/67#issuecomment-1856255695)\n\nBoth #177 and #247 and its duplicates\nThis issue hinges on the same root cause that `baseTokenId` is initialized as `reservedUntilTokenId `. However, the key difference here is that `updateFounders()` is also affected, which is a completely different function. However, I still think that this should be duplicated with #42, based on [sherlock duplication rules](https://docs.sherlock.xyz/audits/judging/judging#ix.-duplication-rules), more specifically, see point 1.1 and 2. The only point where they cannot be considered duplicates is when the fixes are different. \n\nUnless a watson can prove to me that the fix implemented [here](https://github.com/ourzora/nouns-protocol/pull/122/commits/5f12ca4a21aaae6ca1289e5517d3545a27325366) by the sponsor is insufficient, I am inclined to keep all of them as duplicates except the above mentioned #67 and its duplicates.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/111",
  "Code": [
    {
      "filename": "nouns-protocol/src/token/Token.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { UUPS } from \"../lib/proxy/UUPS.sol\";\nimport { ReentrancyGuard } from \"../lib/utils/ReentrancyGuard.sol\";\nimport { ERC721Votes } from \"../lib/token/ERC721Votes.sol\";\nimport { ERC721 } from \"../lib/token/ERC721.sol\";\nimport { Ownable } from \"../lib/utils/Ownable.sol\";\nimport { TokenStorageV1 } from \"./storage/TokenStorageV1.sol\";\nimport { TokenStorageV2 } from \"./storage/TokenStorageV2.sol\";\nimport { TokenStorageV3 } from \"./storage/TokenStorageV3.sol\";\nimport { IBaseMetadata } from \"./metadata/interfaces/IBaseMetadata.sol\";\nimport { IManager } from \"../manager/IManager.sol\";\nimport { IAuction } from \"../auction/IAuction.sol\";\nimport { IToken } from \"./IToken.sol\";\nimport { VersionedContract } from \"../VersionedContract.sol\";\n\n/// @title Token\n/// @author Rohan Kulkarni & Neokry\n/// @custom:repo github.com/ourzora/nouns-protocol\n/// @notice A DAO's ERC-721 governance token\ncontract Token is IToken, VersionedContract, UUPS, Ownable, ReentrancyGuard, ERC721Votes, TokenStorageV1, TokenStorageV2, TokenStorageV3 {\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                          MODIFIERS                       ///\n    ///                                                          ///\n\n    /// @notice Reverts if caller is not an authorized minter\n    modifier onlyMinter() {\n        if (!minter[msg.sender]) {\n            revert ONLY_AUCTION_OR_MINTER();\n        }\n\n        _;\n    }\n\n    /// @notice Reverts if caller is not an authorized minter\n    modifier onlyAuctionOrMinter() {\n        if (msg.sender != settings.auction && !minter[msg.sender]) {\n            revert ONLY_AUCTION_OR_MINTER();\n        }\n\n        _;\n    }\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IManager(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's ERC-721 token\n    /// @param _founders The founding members to receive vesting allocations\n    /// @param _initStrings The encoded token and metadata initialization strings\n    /// @param _reservedUntilTokenId The tokenId that a DAO's auctions will start at\n    /// @param _metadataRenderer The token's metadata renderer\n    /// @param _auction The token's auction house\n    /// @param _initialOwner The initial owner of the token\n    function initialize(\n        IManager.FounderParams[] calldata _founders,\n        bytes calldata _initStrings,\n        uint256 _reservedUntilTokenId,\n        address _metadataRenderer,\n        address _auction,\n        address _initialOwner\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) {\n            revert ONLY_MANAGER();\n        }\n\n        // Initialize the reentrancy guard\n        __ReentrancyGuard_init();\n\n        // Setup ownable\n        __Ownable_init(_initialOwner);\n\n        // Store the founders and compute their allocations\n        _addFounders(_founders, _reservedUntilTokenId);\n\n        // Decode the token name and symbol\n        (string memory _name, string memory _symbol, , , , ) = abi.decode(_initStrings, (string, string, string, string, string, string));\n\n        // Initialize the ERC-721 token\n        __ERC721_init(_name, _symbol);\n\n        // Store the metadata renderer and auction house\n        settings.metadataRenderer = IBaseMetadata(_metadataRenderer);\n        settings.auction = _auction;\n        reservedUntilTokenId = _reservedUntilTokenId;\n    }\n\n    /// @notice Called by the auction upon the first unpause / token mint to transfer ownership from founder to treasury\n    /// @dev Only callable by the auction contract\n    function onFirstAuctionStarted() external override {\n        if (msg.sender != settings.auction) {\n            revert ONLY_AUCTION();\n        }\n\n        // Force transfer ownership to the treasury\n        _transferOwnership(IAuction(settings.auction).treasury());\n    }\n\n    /// @notice Called upon initialization to add founders and compute their vesting allocations\n    /// @dev We do this by reserving an mapping of [0-100] token indices, such that if a new token mint ID % 100 is reserved, it's sent to the appropriate founder.\n    /// @param _founders The list of DAO founders\n    function _addFounders(IManager.FounderParams[] calldata _founders, uint256 reservedUntilTokenId) internal {\n        // Used to store the total percent ownership among the founders\n        uint256 totalOwnership;\n\n        uint8 numFoundersAdded = 0;\n\n        unchecked {\n            // For each founder:\n            for (uint256 i; i < _founders.length; ++i) {\n                // Cache the percent ownership\n                uint256 founderPct = _founders[i].ownershipPct;\n\n                // Continue if no ownership is specified\n                if (founderPct == 0) {\n                    continue;\n                }\n\n                // Update the total ownership and ensure it's valid\n                totalOwnership += founderPct;\n\n                // Check that founders own less than 100% of tokens\n                if (totalOwnership > 99) {\n                    revert INVALID_FOUNDER_OWNERSHIP();\n                }\n\n                // Compute the founder's id\n                uint256 founderId = numFoundersAdded++;\n\n                // Get the pointer to store the founder\n                Founder storage newFounder = founder[founderId];\n\n                // Store the founder's vesting details\n                newFounder.wallet = _founders[i].wallet;\n                newFounder.vestExpiry = uint32(_founders[i].vestExpiry);\n                // Total ownership cannot be above 100 so this fits safely in uint8\n                newFounder.ownershipPct = uint8(founderPct);\n\n                // Compute the vesting schedule\n                uint256 schedule = 100 / founderPct;\n\n                // Used to store the base token id the founder will recieve\n                uint256 baseTokenId = reservedUntilTokenId;\n\n                // For each token to vest:\n                for (uint256 j; j < founderPct; ++j) {\n                    // Get the available token id\n                    baseTokenId = _getNextTokenId(baseTokenId);\n\n                    // Store the founder as the recipient\n                    tokenRecipient[baseTokenId] = newFounder;\n\n                    emit MintScheduled(baseTokenId, founderId, newFounder);\n\n                    // Update the base token id\n                    baseTokenId = (baseTokenId + schedule) % 100;\n                }\n            }\n\n            // Store the founders' details\n            settings.totalOwnership = uint8(totalOwnership);\n            settings.numFounders = numFoundersAdded;\n        }\n    }\n\n    /// @dev Finds the next available base token id for a founder\n    /// @param _tokenId The ERC-721 token id\n    function _getNextTokenId(uint256 _tokenId) internal view returns (uint256) {\n        unchecked {\n            while (tokenRecipient[_tokenId].wallet != address(0)) {\n                _tokenId = (++_tokenId) % 100;\n            }\n\n            return _tokenId;\n        }\n    }\n\n    ///                                                          ///\n    ///                             MINT                         ///\n    ///                                                          ///\n\n    /// @notice Mints tokens to the caller and handles founder vesting\n    function mint() external nonReentrant onlyAuctionOrMinter returns (uint256 tokenId) {\n        tokenId = _mintWithVesting(msg.sender);\n    }\n\n    /// @notice Mints tokens to the recipient and handles founder vesting\n    function mintTo(address recipient) external nonReentrant onlyAuctionOrMinter returns (uint256 tokenId) {\n        tokenId = _mintWithVesting(recipient);\n    }\n\n    /// @notice Mints tokens from the reserve to the recipient\n    function mintFromReserveTo(address recipient, uint256 tokenId) external nonReentrant onlyMinter {\n        // Token must be reserved\n        if (tokenId >= reservedUntilTokenId) revert TOKEN_NOT_RESERVED();\n\n        // Mint the token without vesting (reserved tokens do not count towards founders vesting)\n        _mint(recipient, tokenId);\n    }\n\n    /// @notice Mints the specified amount of tokens to the recipient and handles founder vesting\n    function mintBatchTo(uint256 amount, address recipient) external nonReentrant onlyAuctionOrMinter returns (uint256[] memory tokenIds) {\n        tokenIds = new uint256[](amount);\n        for (uint256 i = 0; i < amount; ) {\n            tokenIds[i] = _mintWithVesting(recipient);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _mintWithVesting(address recipient) internal returns (uint256 tokenId) {\n        // Cannot realistically overflow\n        unchecked {\n            do {\n                // Get the next token to mint\n                tokenId = reservedUntilTokenId + settings.mintCount++;\n\n                // Lookup whether the token is for a founder, and mint accordingly if so\n            } while (_isForFounder(tokenId));\n        }\n\n        // Mint the next available token to the recipient for bidding\n        _mint(recipient, tokenId);\n    }\n\n    /// @dev Overrides _mint to include attribute generation\n    /// @param _to The token recipient\n    /// @param _tokenId The ERC-721 token id\n    function _mint(address _to, uint256 _tokenId) internal override {\n        // Mint the token\n        super._mint(_to, _tokenId);\n\n        // Increment the total supply\n        unchecked {\n            ++settings.totalSupply;\n        }\n\n        // Generate the token attributes\n        if (!settings.metadataRenderer.onMinted(_tokenId)) revert NO_METADATA_GENERATED();\n    }\n\n    /// @dev Checks if a given token is for a founder and mints accordingly\n    /// @param _tokenId The ERC-721 token id\n    function _isForFounder(uint256 _tokenId) private returns (bool) {\n        // Get the base token id\n        uint256 baseTokenId = _tokenId % 100;\n\n        // If there is no scheduled recipient:\n        if (tokenRecipient[baseTokenId].wallet == address(0)) {\n            return false;\n\n            // Else if the founder is still vesting:\n        } else if (block.timestamp < tokenRecipient[baseTokenId].vestExpiry) {\n            // Mint the token to the founder\n            _mint(tokenRecipient[baseTokenId].wallet, _tokenId);\n\n            return true;\n\n            // Else the founder has finished vesting:\n        } else {\n            // Remove them from future lookups\n            delete tokenRecipient[baseTokenId];\n\n            return false;\n        }\n    }\n\n    ///                                                          ///\n    ///                             BURN                         ///\n    ///                                                          ///\n\n    /// @notice Burns a token owned by the caller\n    /// @param _tokenId The ERC-721 token id\n    function burn(uint256 _tokenId) external onlyAuctionOrMinter {\n        // Ensure the caller owns the token\n        if (ownerOf(_tokenId) != msg.sender) {\n            revert ONLY_TOKEN_OWNER();\n        }\n\n        _burn(_tokenId);\n    }\n\n    function _burn(uint256 _tokenId) internal override {\n        // Call the parent burn function\n        super._burn(_tokenId);\n\n        // Reduce the total supply\n        unchecked {\n            --settings.totalSupply;\n        }\n    }\n\n    ///                                                          ///\n    ///                           METADATA                       ///\n    ///                                                          ///\n\n    /// @notice The URI for a token\n    /// @param _tokenId The ERC-721 token id\n    function tokenURI(uint256 _tokenId) public view override(IToken, ERC721) returns (string memory) {\n        return settings.metadataRenderer.tokenURI(_tokenId);\n    }\n\n    /// @notice The URI for the contract\n    function contractURI() public view override(IToken, ERC721) returns (string memory) {\n        return settings.metadataRenderer.contractURI();\n    }\n\n    ///                                                          ///\n    ///                           FOUNDERS                       ///\n    ///                                                          ///\n\n    /// @notice The number of founders\n    function totalFounders() external view returns (uint256) {\n        return settings.numFounders;\n    }\n\n    /// @notice The founders total percent ownership\n    function totalFounderOwnership() external view returns (uint256) {\n        return settings.totalOwnership;\n    }\n\n    /// @notice The vesting details of a founder\n    /// @param _founderId The founder id\n    function getFounder(uint256 _founderId) external view returns (Founder memory) {\n        return founder[_founderId];\n    }\n\n    /// @notice The vesting details of all founders\n    function getFounders() external view returns (Founder[] memory) {\n        // Cache the number of founders\n        uint256 numFounders = settings.numFounders;\n\n        // Get a temporary array to hold all founders\n        Founder[] memory founders = new Founder[](numFounders);\n\n        // Cannot realistically overflow\n        unchecked {\n            // Add each founder to the array\n            for (uint256 i; i < numFounders; ++i) {\n                founders[i] = founder[i];\n            }\n        }\n\n        return founders;\n    }\n\n    /// @notice The founder scheduled to receive the given token id\n    /// NOTE: If a founder is returned, there's no guarantee they'll receive the token as vesting expiration is not considered\n    /// @param _tokenId The ERC-721 token id\n    function getScheduledRecipient(uint256 _tokenId) external view returns (Founder memory) {\n        return tokenRecipient[_tokenId % 100];\n    }\n\n    /// @notice Update the list of allocation owners\n    /// @param newFounders the full list of founders\n    function updateFounders(IManager.FounderParams[] calldata newFounders) external onlyOwner {\n        // Cache the number of founders\n        uint256 numFounders = settings.numFounders;\n\n        // Get a temporary array to hold all founders\n        Founder[] memory cachedFounders = new Founder[](numFounders);\n\n        // Cannot realistically overflow\n        unchecked {\n            // Add each founder to the array\n            for (uint256 i; i < numFounders; ++i) {\n                cachedFounders[i] = founder[i];\n            }\n        }\n\n        // Keep a mapping of all the reserved token IDs we're set to clear.\n        bool[] memory clearedTokenIds = new bool[](100);\n\n        unchecked {\n            // for each existing founder:\n            for (uint256 i; i < cachedFounders.length; ++i) {\n                // copy the founder into memory\n                Founder memory cachedFounder = cachedFounders[i];\n\n                // Delete the founder from the stored mapping\n                delete founder[i];\n\n                // Some DAOs were initialized with 0 percentage ownership.\n                // This skips them to avoid a division by zero error.\n                if (cachedFounder.ownershipPct == 0) {\n                    continue;\n                }\n\n                // using the ownership percentage, get reserved token percentages\n                uint256 schedule = 100 / cachedFounder.ownershipPct;\n\n                // Used to reverse engineer the indices the founder has reserved tokens in.\n                uint256 baseTokenId;\n\n                for (uint256 j; j < cachedFounder.ownershipPct; ++j) {\n                    // Get the next index that hasn't already been cleared\n                    while (clearedTokenIds[baseTokenId] != false) {\n                        baseTokenId = (++baseTokenId) % 100;\n                    }\n\n                    delete tokenRecipient[baseTokenId];\n                    clearedTokenIds[baseTokenId] = true;\n\n                    emit MintUnscheduled(baseTokenId, i, cachedFounder);\n\n                    // Update the base token id\n                    baseTokenId = (baseTokenId + schedule) % 100;\n                }\n            }\n        }\n\n        // Clear values from storage before adding new founders\n        settings.numFounders = 0;\n        settings.totalOwnership = 0;\n        emit FounderAllocationsCleared(newFounders);\n\n        _addFounders(newFounders, reservedUntilTokenId);\n    }\n\n    ///                                                          ///\n    ///                           SETTINGS                       ///\n    ///                                                          ///\n\n    /// @notice The total supply of tokens\n    function totalSupply() external view returns (uint256) {\n        return settings.totalSupply;\n    }\n\n    /// @notice The address of the auction house\n    function auction() external view returns (address) {\n        return settings.auction;\n    }\n\n    /// @notice The address of the metadata renderer\n    function metadataRenderer() external view returns (address) {\n        return address(settings.metadataRenderer);\n    }\n\n    /// @notice The contract owner\n    function owner() public view override(IToken, Ownable) returns (address) {\n        return super.owner();\n    }\n\n    /// @notice Update minters\n    /// @param _minters Array of structs containing address status as a minter\n    function updateMinters(MinterParams[] calldata _minters) external onlyOwner {\n        // Update each minter\n        for (uint256 i; i < _minters.length; ++i) {\n            // Skip if the minter is already set to the correct value\n            if (minter[_minters[i].minter] == _minters[i].allowed) continue;\n\n            emit MinterUpdated(_minters[i].minter, _minters[i].allowed);\n\n            // Update the minter\n            minter[_minters[i].minter] = _minters[i].allowed;\n        }\n    }\n\n    /// @notice Check if an address is a minter\n    /// @param _minter Address to check\n    function isMinter(address _minter) external view returns (bool) {\n        return minter[_minter];\n    }\n\n    /// @notice Set the tokenId that the reserve will end at\n    /// @param newReservedUntilTokenId The tokenId that the reserve will end at\n    function setReservedUntilTokenId(uint256 newReservedUntilTokenId) external onlyOwner {\n        // Cannot change the reserve after any non reserved tokens have been minted\n        // Added to prevent making any tokens inaccessible\n        if (settings.mintCount > 0) {\n            revert CANNOT_CHANGE_RESERVE();\n        }\n\n        // Cannot decrease the reserve if any tokens have been minted\n        // Added to prevent collisions with tokens being auctioned / vested\n        if (settings.totalSupply > 0 && reservedUntilTokenId > newReservedUntilTokenId) {\n            revert CANNOT_DECREASE_RESERVE();\n        }\n\n        // Set the new reserve\n        reservedUntilTokenId = newReservedUntilTokenId;\n\n        emit ReservedUntilTokenIDUpdated(newReservedUntilTokenId);\n    }\n\n    /// @notice Set a new metadata renderer\n    /// @param newRenderer new renderer address to use\n    function setMetadataRenderer(IBaseMetadata newRenderer) external {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) {\n            revert ONLY_MANAGER();\n        }\n\n        settings.metadataRenderer = newRenderer;\n    }\n\n    ///                                                          ///\n    ///                         TOKEN UPGRADE                    ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override {\n        // Ensure the caller is the shared owner of the token and metadata renderer\n        if (msg.sender != owner()) revert ONLY_OWNER();\n\n        // Ensure the implementation is valid\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}"
    },
    {
      "filename": "nouns-protocol/src/token/Token.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { UUPS } from \"../lib/proxy/UUPS.sol\";\nimport { ReentrancyGuard } from \"../lib/utils/ReentrancyGuard.sol\";\nimport { ERC721Votes } from \"../lib/token/ERC721Votes.sol\";\nimport { ERC721 } from \"../lib/token/ERC721.sol\";\nimport { Ownable } from \"../lib/utils/Ownable.sol\";\nimport { TokenStorageV1 } from \"./storage/TokenStorageV1.sol\";\nimport { TokenStorageV2 } from \"./storage/TokenStorageV2.sol\";\nimport { TokenStorageV3 } from \"./storage/TokenStorageV3.sol\";\nimport { IBaseMetadata } from \"./metadata/interfaces/IBaseMetadata.sol\";\nimport { IManager } from \"../manager/IManager.sol\";\nimport { IAuction } from \"../auction/IAuction.sol\";\nimport { IToken } from \"./IToken.sol\";\nimport { VersionedContract } from \"../VersionedContract.sol\";\n\n/// @title Token\n/// @author Rohan Kulkarni & Neokry\n/// @custom:repo github.com/ourzora/nouns-protocol\n/// @notice A DAO's ERC-721 governance token\ncontract Token is IToken, VersionedContract, UUPS, Ownable, ReentrancyGuard, ERC721Votes, TokenStorageV1, TokenStorageV2, TokenStorageV3 {\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                          MODIFIERS                       ///\n    ///                                                          ///\n\n    /// @notice Reverts if caller is not an authorized minter\n    modifier onlyMinter() {\n        if (!minter[msg.sender]) {\n            revert ONLY_AUCTION_OR_MINTER();\n        }\n\n        _;\n    }\n\n    /// @notice Reverts if caller is not an authorized minter\n    modifier onlyAuctionOrMinter() {\n        if (msg.sender != settings.auction && !minter[msg.sender]) {\n            revert ONLY_AUCTION_OR_MINTER();\n        }\n\n        _;\n    }\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IManager(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's ERC-721 token\n    /// @param _founders The founding members to receive vesting allocations\n    /// @param _initStrings The encoded token and metadata initialization strings\n    /// @param _reservedUntilTokenId The tokenId that a DAO's auctions will start at\n    /// @param _metadataRenderer The token's metadata renderer\n    /// @param _auction The token's auction house\n    /// @param _initialOwner The initial owner of the token\n    function initialize(\n        IManager.FounderParams[] calldata _founders,\n        bytes calldata _initStrings,\n        uint256 _reservedUntilTokenId,\n        address _metadataRenderer,\n        address _auction,\n        address _initialOwner\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) {\n            revert ONLY_MANAGER();\n        }\n\n        // Initialize the reentrancy guard\n        __ReentrancyGuard_init();\n\n        // Setup ownable\n        __Ownable_init(_initialOwner);\n\n        // Store the founders and compute their allocations\n        _addFounders(_founders, _reservedUntilTokenId);\n\n        // Decode the token name and symbol\n        (string memory _name, string memory _symbol, , , , ) = abi.decode(_initStrings, (string, string, string, string, string, string));\n\n        // Initialize the ERC-721 token\n        __ERC721_init(_name, _symbol);\n\n        // Store the metadata renderer and auction house\n        settings.metadataRenderer = IBaseMetadata(_metadataRenderer);\n        settings.auction = _auction;\n        reservedUntilTokenId = _reservedUntilTokenId;\n    }\n\n    /// @notice Called by the auction upon the first unpause / token mint to transfer ownership from founder to treasury\n    /// @dev Only callable by the auction contract\n    function onFirstAuctionStarted() external override {\n        if (msg.sender != settings.auction) {\n            revert ONLY_AUCTION();\n        }\n\n        // Force transfer ownership to the treasury\n        _transferOwnership(IAuction(settings.auction).treasury());\n    }\n\n    /// @notice Called upon initialization to add founders and compute their vesting allocations\n    /// @dev We do this by reserving an mapping of [0-100] token indices, such that if a new token mint ID % 100 is reserved, it's sent to the appropriate founder.\n    /// @param _founders The list of DAO founders\n    function _addFounders(IManager.FounderParams[] calldata _founders, uint256 reservedUntilTokenId) internal {\n        // Used to store the total percent ownership among the founders\n        uint256 totalOwnership;\n\n        uint8 numFoundersAdded = 0;\n\n        unchecked {\n            // For each founder:\n            for (uint256 i; i < _founders.length; ++i) {\n                // Cache the percent ownership\n                uint256 founderPct = _founders[i].ownershipPct;\n\n                // Continue if no ownership is specified\n                if (founderPct == 0) {\n                    continue;\n                }\n\n                // Update the total ownership and ensure it's valid\n                totalOwnership += founderPct;\n\n                // Check that founders own less than 100% of tokens\n                if (totalOwnership > 99) {\n                    revert INVALID_FOUNDER_OWNERSHIP();\n                }\n\n                // Compute the founder's id\n                uint256 founderId = numFoundersAdded++;\n\n                // Get the pointer to store the founder\n                Founder storage newFounder = founder[founderId];\n\n                // Store the founder's vesting details\n                newFounder.wallet = _founders[i].wallet;\n                newFounder.vestExpiry = uint32(_founders[i].vestExpiry);\n                // Total ownership cannot be above 100 so this fits safely in uint8\n                newFounder.ownershipPct = uint8(founderPct);\n\n                // Compute the vesting schedule\n                uint256 schedule = 100 / founderPct;\n\n                // Used to store the base token id the founder will recieve\n                uint256 baseTokenId = reservedUntilTokenId;\n\n                // For each token to vest:\n                for (uint256 j; j < founderPct; ++j) {\n                    // Get the available token id\n                    baseTokenId = _getNextTokenId(baseTokenId);\n\n                    // Store the founder as the recipient\n                    tokenRecipient[baseTokenId] = newFounder;\n\n                    emit MintScheduled(baseTokenId, founderId, newFounder);\n\n                    // Update the base token id\n                    baseTokenId = (baseTokenId + schedule) % 100;\n                }\n            }\n\n            // Store the founders' details\n            settings.totalOwnership = uint8(totalOwnership);\n            settings.numFounders = numFoundersAdded;\n        }\n    }\n\n    /// @dev Finds the next available base token id for a founder\n    /// @param _tokenId The ERC-721 token id\n    function _getNextTokenId(uint256 _tokenId) internal view returns (uint256) {\n        unchecked {\n            while (tokenRecipient[_tokenId].wallet != address(0)) {\n                _tokenId = (++_tokenId) % 100;\n            }\n\n            return _tokenId;\n        }\n    }\n\n    ///                                                          ///\n    ///                             MINT                         ///\n    ///                                                          ///\n\n    /// @notice Mints tokens to the caller and handles founder vesting\n    function mint() external nonReentrant onlyAuctionOrMinter returns (uint256 tokenId) {\n        tokenId = _mintWithVesting(msg.sender);\n    }\n\n    /// @notice Mints tokens to the recipient and handles founder vesting\n    function mintTo(address recipient) external nonReentrant onlyAuctionOrMinter returns (uint256 tokenId) {\n        tokenId = _mintWithVesting(recipient);\n    }\n\n    /// @notice Mints tokens from the reserve to the recipient\n    function mintFromReserveTo(address recipient, uint256 tokenId) external nonReentrant onlyMinter {\n        // Token must be reserved\n        if (tokenId >= reservedUntilTokenId) revert TOKEN_NOT_RESERVED();\n\n        // Mint the token without vesting (reserved tokens do not count towards founders vesting)\n        _mint(recipient, tokenId);\n    }\n\n    /// @notice Mints the specified amount of tokens to the recipient and handles founder vesting\n    function mintBatchTo(uint256 amount, address recipient) external nonReentrant onlyAuctionOrMinter returns (uint256[] memory tokenIds) {\n        tokenIds = new uint256[](amount);\n        for (uint256 i = 0; i < amount; ) {\n            tokenIds[i] = _mintWithVesting(recipient);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _mintWithVesting(address recipient) internal returns (uint256 tokenId) {\n        // Cannot realistically overflow\n        unchecked {\n            do {\n                // Get the next token to mint\n                tokenId = reservedUntilTokenId + settings.mintCount++;\n\n                // Lookup whether the token is for a founder, and mint accordingly if so\n            } while (_isForFounder(tokenId));\n        }\n\n        // Mint the next available token to the recipient for bidding\n        _mint(recipient, tokenId);\n    }\n\n    /// @dev Overrides _mint to include attribute generation\n    /// @param _to The token recipient\n    /// @param _tokenId The ERC-721 token id\n    function _mint(address _to, uint256 _tokenId) internal override {\n        // Mint the token\n        super._mint(_to, _tokenId);\n\n        // Increment the total supply\n        unchecked {\n            ++settings.totalSupply;\n        }\n\n        // Generate the token attributes\n        if (!settings.metadataRenderer.onMinted(_tokenId)) revert NO_METADATA_GENERATED();\n    }\n\n    /// @dev Checks if a given token is for a founder and mints accordingly\n    /// @param _tokenId The ERC-721 token id\n    function _isForFounder(uint256 _tokenId) private returns (bool) {\n        // Get the base token id\n        uint256 baseTokenId = _tokenId % 100;\n\n        // If there is no scheduled recipient:\n        if (tokenRecipient[baseTokenId].wallet == address(0)) {\n            return false;\n\n            // Else if the founder is still vesting:\n        } else if (block.timestamp < tokenRecipient[baseTokenId].vestExpiry) {\n            // Mint the token to the founder\n            _mint(tokenRecipient[baseTokenId].wallet, _tokenId);\n\n            return true;\n\n            // Else the founder has finished vesting:\n        } else {\n            // Remove them from future lookups\n            delete tokenRecipient[baseTokenId];\n\n            return false;\n        }\n    }\n\n    ///                                                          ///\n    ///                             BURN                         ///\n    ///                                                          ///\n\n    /// @notice Burns a token owned by the caller\n    /// @param _tokenId The ERC-721 token id\n    function burn(uint256 _tokenId) external onlyAuctionOrMinter {\n        // Ensure the caller owns the token\n        if (ownerOf(_tokenId) != msg.sender) {\n            revert ONLY_TOKEN_OWNER();\n        }\n\n        _burn(_tokenId);\n    }\n\n    function _burn(uint256 _tokenId) int"
    }
  ]
}