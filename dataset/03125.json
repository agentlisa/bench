{
  "Title": "Implicit casting",
  "Content": "Throughout the codebase, an instance of implicit casting between types has been detected.\n\n\nIn the [`FortaStakingUtils` library](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStakingUtils.sol#L4), in lines [10](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStakingUtils.sol#L10) and [18](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStakingUtils.sol#L18), the `subjectType` `uint8` parameter is being used in a bitwise `OR` operation against a `uint256` result.\n\n\nWhenever a different type of variable is needed, consider either checking and casting the variable into the desired type or using OpenZeppelin’s [`SafeCast` library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.4.2/contracts/utils/math/SafeCast.sol) which provides overflow checking when casting from one type of number to another.\n\n\n***Update:** Fixed on [commit `2ff21729d1daeb06d830b8a239dcb8d9fd7b9dfd` in pull request 59](https://github.com/forta-protocol/forta-token/pull/59/commits/2ff21729d1daeb06d830b8a239dcb8d9fd7b9dfd).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/components/staking/FortaStakingUtils.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary FortaStakingUtils {\n    /**\n     * Encode \"active\" and subjectType in subject by hashing them together, shifting left 9 bits,\n     * setting bit 9 (to mark as active) and masking subjectType in\n     */\n    function subjectToActive(uint8 subjectType, uint256 subject) internal pure returns (uint256) {\n        return (uint256(keccak256(abi.encodePacked(subjectType, subject))) << 9 | uint16(256)) | subjectType;\n    }\n\n    /**\n     * Encode \"inactive\" and subjectType in subjectby hashing them together, shifting left 9 bits,\n     * letting bit 9 unset (to mark as inactive) and masking subjectType in\n     */\n    function subjectToInactive(uint8 subjectType, uint256 subject) internal pure returns (uint256) {\n        return (uint256(keccak256(abi.encodePacked(subjectType, subject))) << 9) | subjectType;\n    }\n\n    /**\n     * Unsets bit 9 of an activeSharesId to mark as inactive\n     */\n    function activeToInactive(uint256 activeSharesId) internal pure returns (uint256) {\n        return activeSharesId & (~uint256(1 << 8));\n    }\n\n    /**\n     * Sets bit 9 of an inactiveSharesId to mark as inactive\n     */\n    function inactiveToActive(uint256 inactiveSharesId) internal pure returns (uint256) {\n        return inactiveSharesId | (1 << 8);\n    }\n\n\n    function isActive(uint256 sharesId) internal pure returns(bool) {\n        return sharesId & (1 << 8) == 256;\n    }\n\n    function subjectTypeOfShares(uint256 sharesId) internal pure returns(uint8) {\n        return uint8(sharesId);\n    }\n}"
    }
  ]
}