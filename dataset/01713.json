{
  "Title": "Read-only reentrancy",
  "Content": "**Description:** The current implementation is vulnerable to read-only reentrancy, especially in [Wells::removeLiquidity](https://github.com/BeanstalkFarms/Wells/blob/e5441fc78f0fd4b77a898812d0fd22cb43a0af55/src/Well.sol#L440).\nThe implementation does not strictly follow the [Checks-Effects-Interactions (CEI) pattern](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html) as it is setting the new reserve values after sending out the tokens. This is not an immediate risk to the protocol itself due to the `nonReentrant` modifier, but this is still vulnerable to [read-only reentrancy](https://chainsecurity.com/curve-lp-oracle-manipulation-post-mortem/).\n\nMalicious attackers and unsuspecting ecosystem participants can deploy Wells with ERC-777 tokens (which have a callback that can take control) and exploit this vulnerability. This will lead to critical vulnerabilities given that the Wells are to be extended with price functions as defined by pumps - third-party protocols that integrate these on-chain oracles will be at risk.\n\nPumps are updated before token transfers; however, reserves are only set after. Therefore, pump functions will likely be incorrect on a re-entrant read-only call if `IWell(well).getReserves()` is called but reserves have not been correctly updated. The implementation of `GeoEmaAndCumSmaPump` appears not to be vulnerable, but given that each pump can choose its approach for recording a well's reserves over time, this remains a possible attack vector.\n\n**Impact:** Although this is not an immediate risk to the protocol itself, read-only re-entrancy can lead to critical issues, so we evaluate the severity as HIGH.\n\n**Proof of Concept:** We wrote a test case to show the existing read-only reentrancy.\n\n```solidity\n// MockCallbackRecipient.sol\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {console} from \"forge-std/Test.sol\";\n\ncontract MockCallbackRecipient {\n    fallback() external payable {\n        console.log(\"here\");\n        (bool success, bytes memory result) = msg.sender.call(abi.encodeWithSignature(\"getReserves()\"));\n        if (success) {\n            uint256[] memory reserves = abi.decode(result, (uint256[]));\n            console.log(\"read-only-reentrancy beforeTokenTransfer reserves[0]: %s\", reserves[0]);\n            console.log(\"read-only-reentrancy beforeTokenTransfer reserves[1]: %s\", reserves[1]);\n        }\n    }\n}\n\n// NOTE: Put in Exploit.t.sol\nfunction test_exploitReadOnlyReentrancyRemoveLiquidityCallbackToken() public {\n    IERC20 callbackToken = IERC20(new MockCallbackToken(\"CallbackToken\", \"CBTKN\", 18));\n    MockToken(address(callbackToken)).mint(user, 1000e18);\n    IERC20[] memory _tokens = new IERC20[](2);\n    _tokens[0] = callbackToken;\n    _tokens[1] = tokens[1];\n\n    vm.stopPrank();\n    Well well2 = Well(auger.bore(\"Well2\", \"WELL2\", _tokens, wellFunction, pumps));\n    approveMaxTokens(user, address(well2));\n\n    uint[] memory amounts = new uint[](2);\n    amounts[0] = 100 * 1e18;\n    amounts[1] = 100 * 1e18;\n\n    changePrank(user);\n    callbackToken.approve(address(well2), type(uint).max);\n    uint256 lpAmountOut = well2.addLiquidity(amounts, 0, user);\n\n    well2.removeLiquidity(lpAmountOut, amounts, user);\n}\n```\n\nThe output is shown below.\n\n```\nforge test -vv --match-test test_exploitReadOnlyReentrancyRemoveLiquidityCallbackToken\n\n[PASS] test_exploitReadOnlyReentrancyRemoveLiquidityCallbackToken() (gas: 5290876)\nLogs:\n  read-only-reentrancy beforeTokenTransfer reserves[0]: 0\n  read-only-reentrancy beforeTokenTransfer reserves[1]: 0\n  read-only-reentrancy afterTokenTransfer reserves[0]: 0\n  read-only-reentrancy afterTokenTransfer reserves[1]: 0\n  read-only-reentrancy beforeTokenTransfer reserves[0]: 100000000000000000000\n  read-only-reentrancy beforeTokenTransfer reserves[1]: 100000000000000000000\n  read-only-reentrancy afterTokenTransfer reserves[0]: 100000000000000000000\n  read-only-reentrancy afterTokenTransfer reserves[1]: 100000000000000000000\n\nTest result: ok. 1 passed; 0 failed; finished in 3.66ms\n```\n\n**Recommended Mitigation:** Implement the CEI pattern in relevant functions by updating reserves before making external calls. For example, the function `Well::removeLiquidity` can be modified shown below.\n\n```solidity\nfunction removeLiquidity(\n    uint lpAmountIn,\n    uint[] calldata minTokenAmountsOut,\n    address recipient\n) external nonReentrant returns (uint[] memory tokenAmountsOut) {\n    IERC20[] memory _tokens = tokens();\n    uint[] memory reserves = _updatePumps(_tokens.length);\n    uint lpTokenSupply = totalSupply();\n\n    tokenAmountsOut = new uint[](_tokens.length);\n    _burn(msg.sender, lpAmountIn);\n\n    _setReserves(reserves); // @audit CEI pattern\n\n    for (uint i; i < _tokens.length; ++i) {\n        tokenAmountsOut[i] = (lpAmountIn * reserves[i]) / lpTokenSupply;\n        require(\n            tokenAmountsOut[i] >= minTokenAmountsOut[i],\n            \"Well: slippage\"\n        );\n        _tokens[i].safeTransfer(recipient, tokenAmountsOut[i]);\n        reserves[i] = reserves[i] - tokenAmountsOut[i];\n    }\n\n    emit RemoveLiquidity(lpAmountIn, tokenAmountsOut);\n}\n```\n\n**Beanstalk:** Added a check to the `getReserves()` function that reverts if the Reentrancy guard has been entered. This prevents anyone from calling `getReserves()` while executing a function in the Well. Fixed in commit [fcbf04a](https://github.com/BeanstalkFarms/Basin/pull/85/commits/fcbf04a99b00807891fb2a9791ba18ed425479ab).\n\n**Cyfrin:** Acknowledged.\n\n\\clearpage",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "src/Well.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {ReentrancyGuardUpgradeable} from \"ozu/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC20Upgradeable, ERC20PermitUpgradeable} from \"ozu/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport {IERC20, SafeERC20} from \"oz/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeCast} from \"oz/utils/math/SafeCast.sol\";\nimport {IWell, Call} from \"src/interfaces/IWell.sol\";\nimport {IPump} from \"src/interfaces/pumps/IPump.sol\";\nimport {IWellFunction} from \"src/interfaces/IWellFunction.sol\";\nimport {LibBytes} from \"src/libraries/LibBytes.sol\";\nimport {ClonePlus} from \"src/utils/ClonePlus.sol\";\n\n/**\n * @title Well\n * @author Publius, Silo Chad, Brean\n * @dev A Well is a constant function AMM allowing the provisioning of liquidity\n * into a single pooled on-chain liquidity position.\n */\ncontract Well is ERC20PermitUpgradeable, IWell, ReentrancyGuardUpgradeable, ClonePlus {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint;\n\n    bytes32 constant RESERVES_STORAGE_SLOT = keccak256(\"reserves.storage.slot\");\n\n    function init(string memory name, string memory symbol) public initializer {\n        __ERC20Permit_init(name);\n        __ERC20_init(name, symbol);\n    }\n\n    //////////////////// WELL DEFINITION ////////////////////\n\n    /// This Well uses a dynamic immutable storage layout. Immutable storage is\n    /// used for gas-efficient reads during Well operation. The Well must be\n    /// created by cloning with a pre-encoded byte string containing immutable\n    /// data.\n    ///\n    /// Let n = number of tokens\n    ///     m = length of well function data (bytes)\n    ///\n    /// TYPE        NAME                       LOCATION (CONSTANT)\n    /// ==============================================================\n    /// address     aquifer()                  0        (LOC_AQUIFER_ADDR)\n    /// uint256     numberOfTokens()           20       (LOC_TOKENS_COUNT)\n    /// address     wellFunctionAddress()      52       (LOC_WELL_FUNCTION_ADDR)\n    /// uint256     wellFunctionDataLength()   72       (LOC_WELL_FUNCTION_DATA_LENGTH)\n    /// uint256     numberOfPumps()            104      (LOC_PUMPS_COUNT)\n    /// --------------------------------------------------------------\n    /// address     token0                     136      (LOC_VARIABLE)\n    /// ...\n    /// address     tokenN                     136 + (n-1) * 32\n    /// --------------------------------------------------------------\n    /// byte        wellFunctionData0          136 + n * 32\n    /// ...\n    /// byte        wellFunctionDataM          136 + n * 32 + m\n    /// --------------------------------------------------------------\n    /// address     pump1Address               136 + n * 32 + m\n    /// uint256     pump1DataLength            136 + n * 32 + m + 20\n    /// byte        pump1Data                  136 + n * 32 + m + 52\n    /// ...\n    /// ==============================================================\n\n    uint constant LOC_AQUIFER_ADDR = 0;\n    uint constant LOC_TOKENS_COUNT = LOC_AQUIFER_ADDR + 20;\n    uint constant LOC_WELL_FUNCTION_ADDR = LOC_TOKENS_COUNT + 32;\n    uint constant LOC_WELL_FUNCTION_DATA_LENGTH = LOC_WELL_FUNCTION_ADDR + 20;\n    uint constant LOC_PUMPS_COUNT = LOC_WELL_FUNCTION_DATA_LENGTH + 32;\n    uint constant LOC_VARIABLE = LOC_PUMPS_COUNT + 32;\n\n    function tokens() public pure returns (IERC20[] memory ts) {\n        ts = _getArgIERC20Array(LOC_VARIABLE, numberOfTokens());\n    }\n\n    function wellFunction() public pure returns (Call memory _wellFunction) {\n        _wellFunction.target = wellFunctionAddress();\n        uint dataLoc = LOC_VARIABLE + numberOfTokens() * 32;\n        _wellFunction.data = _getArgBytes(dataLoc, wellFunctionDataLength());\n    }\n\n    function pumps() public pure returns (Call[] memory _pumps) {\n        if (numberOfPumps() == 0) return _pumps;\n\n        _pumps = new Call[](numberOfPumps());\n        uint dataLoc = LOC_VARIABLE + numberOfTokens() * 32 + wellFunctionDataLength();\n\n        uint pumpDataLength;\n        for (uint i = 0; i < _pumps.length; i++) {\n            _pumps[i].target = _getArgAddress(dataLoc);\n            dataLoc += 20;\n            pumpDataLength = _getArgUint256(dataLoc);\n            dataLoc += 32;\n            _pumps[i].data = _getArgBytes(dataLoc, pumpDataLength);\n            dataLoc += pumpDataLength;\n        }\n    }\n\n    /**\n     * @dev {wellData} is unused in this implementation.\n     */\n    function wellData() public pure returns (bytes memory) {}\n\n    function aquifer() public pure override returns (address) {\n        return _getArgAddress(LOC_AQUIFER_ADDR);\n    }\n\n    function well()\n        external\n        pure\n        returns (\n            IERC20[] memory _tokens,\n            Call memory _wellFunction,\n            Call[] memory _pumps,\n            bytes memory _wellData,\n            address _aquifer\n        )\n    {\n        _tokens = tokens();\n        _wellFunction = wellFunction();\n        _pumps = pumps();\n        _aquifer = aquifer();\n    }\n\n    //////////////////// WELL DEFINITION: HELPERS ////////////////////\n\n    /**\n     * @notice Returns the number of tokens that are tradable in this Well.\n     * @dev Length of the `tokens()` array.\n     */\n    function numberOfTokens() public pure returns (uint) {\n        return _getArgUint256(LOC_TOKENS_COUNT);\n    }\n\n    /**\n     * @notice Returns the address of the Well Function.\n     */\n    function wellFunctionAddress() public pure returns (address) {\n        return _getArgAddress(LOC_WELL_FUNCTION_ADDR);\n    }\n\n    /**\n     * @notice Returns the length of the configurable `data` parameter passed during calls to the Well Function.\n     */\n    function wellFunctionDataLength() public pure returns (uint) {\n        return _getArgUint256(LOC_WELL_FUNCTION_DATA_LENGTH);\n    }\n\n    /**\n     * @notice Returns the number of Pumps which this Well was initialized with.\n     */\n    function numberOfPumps() public pure returns (uint) {\n        return _getArgUint256(LOC_PUMPS_COUNT);\n    }\n\n    /**\n     * @notice Returns address & data used to call the first Pump.\n     * @dev Provided as an optimization in the case where {numberOfPumps} returns 1.\n     */\n    function firstPump() public pure returns (Call memory _pump) {\n        uint dataLoc = LOC_VARIABLE + numberOfTokens() * 32 + wellFunctionDataLength();\n        _pump.target = _getArgAddress(dataLoc);\n        uint pumpDataLength = _getArgUint256(dataLoc + 20);\n        _pump.data = _getArgBytes(dataLoc + 52, pumpDataLength);\n    }\n\n    //////////////////// SWAP: FROM ////////////////////\n\n    /**\n     * @dev MUST revert if a fee on transfer token is used. The requisite check\n     * is performed in {_setReserves}.\n     */\n    function swapFrom(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint amountIn,\n        uint minAmountOut,\n        address recipient,\n        uint deadline\n    ) external nonReentrant expire(deadline) returns (uint amountOut) {\n        fromToken.safeTransferFrom(msg.sender, address(this), amountIn);\n        amountOut = _swapFrom(fromToken, toToken, amountIn, minAmountOut, recipient);\n    }\n\n    /**\n     * @dev Note that `amountOut` is the amount *transferred* by the Well; if a fee\n     * is charged on transfers of `toToken`, the amount received by `recipient`\n     * will be less than `amountOut`.\n     */\n    function swapFromFeeOnTransfer(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint amountIn,\n        uint minAmountOut,\n        address recipient,\n        uint deadline\n    ) external nonReentrant expire(deadline) returns (uint amountOut) {\n        amountIn = _safeTransferFromFeeOnTransfer(fromToken, msg.sender, amountIn);\n        amountOut = _swapFrom(fromToken, toToken, amountIn, minAmountOut, recipient);\n    }\n\n    function _swapFrom(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint amountIn,\n        uint minAmountOut,\n        address recipient\n    ) internal returns (uint amountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _updatePumps(_tokens.length);\n        (uint i, uint j) = _getIJ(_tokens, fromToken, toToken);\n\n        reserves[i] += amountIn;\n        uint reserveJBefore = reserves[j];\n        reserves[j] = _calcReserve(wellFunction(), reserves, j, totalSupply());\n\n        // Note: The rounding approach of the Well function determines whether\n        // slippage from imprecision goes to the Well or to the User.\n        amountOut = reserveJBefore - reserves[j];\n        if (amountOut < minAmountOut) {\n            revert SlippageOut(amountOut, minAmountOut);\n        }\n\n        toToken.safeTransfer(recipient, amountOut);\n        emit Swap(fromToken, toToken, amountIn, amountOut, recipient);\n        _setReserves(_tokens, reserves);\n    }\n\n    /**\n     * @dev Assumes both tokens incur no fee on transfer.\n     */\n    function getSwapOut(IERC20 fromToken, IERC20 toToken, uint amountIn) external view returns (uint amountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _getReserves(_tokens.length);\n        (uint i, uint j) = _getIJ(_tokens, fromToken, toToken);\n\n        reserves[i] += amountIn;\n\n        // underflow is desired; Well Function SHOULD NOT increase reserves of both `i` and `j`\n        amountOut = reserves[j] - _calcReserve(wellFunction(), reserves, j, totalSupply());\n    }\n\n    //////////////////// SWAP: TO ////////////////////\n\n    /**\n     * @dev {swapTo} does not support fee on transfer tokens, and no corresponding\n     * \"swapToFeeOnTransfer\" function is provided as this would require either:\n     * (a) inclusion of the fee as a parameter with verification; or\n     * (b) iterative transfers which attempts to back-calculate the fee.\n     */\n    function swapTo(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint maxAmountIn,\n        uint amountOut,\n        address recipient,\n        uint deadline\n    ) external nonReentrant expire(deadline) returns (uint amountIn) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _updatePumps(_tokens.length);\n        (uint i, uint j) = _getIJ(_tokens, fromToken, toToken);\n\n        reserves[j] -= amountOut;\n        uint reserveIBefore = reserves[i];\n        reserves[i] = _calcReserve(wellFunction(), reserves, i, totalSupply());\n\n        // Note: The rounding approach of the Well function determines whether\n        // slippage from imprecision goes to the Well or to the User.\n        amountIn = reserves[i] - reserveIBefore;\n\n        if (amountIn > maxAmountIn) {\n            revert SlippageIn(amountIn, maxAmountIn);\n        }\n\n        _swapTo(fromToken, toToken, amountIn, amountOut, recipient);\n        _setReserves(_tokens, reserves);\n    }\n\n    /**\n     * @dev Executes token transfers and emits Swap event. Used by {swapTo} to\n     * avoid stack too deep errors.\n     */\n    function _swapTo(IERC20 fromToken, IERC20 toToken, uint amountIn, uint amountOut, address recipient) internal {\n        fromToken.safeTransferFrom(msg.sender, address(this), amountIn);\n        toToken.safeTransfer(recipient, amountOut);\n        emit Swap(fromToken, toToken, amountIn, amountOut, recipient);\n    }\n\n    /**\n     * @dev Assumes both tokens incur no fee on transfer.\n     */\n    function getSwapIn(IERC20 fromToken, IERC20 toToken, uint amountOut) external view returns (uint amountIn) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _getReserves(_tokens.length);\n        (uint i, uint j) = _getIJ(_tokens, fromToken, toToken);\n\n        reserves[j] -= amountOut;\n\n        amountIn = _calcReserve(wellFunction(), reserves, i, totalSupply()) - reserves[i];\n    }\n\n    //////////////////// SHIFT ////////////////////\n\n    /**\n     * @dev When using Wells for a multi-step swap, gas costs can be reduced by\n     * \"shifting\" tokens from one Well to another rather than returning them to\n     * a router (like Pipeline).\n     *\n     * Example multi-hop swap: WETH -> DAI -> USDC\n     *\n     * 1. Using a router without {shift}:\n     *  WETH.transfer(sender=0xUSER, recipient=0xROUTER)                     [1]\n     *  Call the router, which performs:\n     *      Well1.swapFrom(fromToken=WETH, toToken=DAI, recipient=0xROUTER)\n     *          WETH.transfer(sender=0xROUTER, recipient=Well1)              [2]\n     *          DAI.transfer(sender=Well1, recipient=0xROUTER)               [3]\n     *      Well2.swapFrom(fromToken=DAI, toToken=USDC, recipient=0xROUTER)\n     *          DAI.transfer(sender=0xROUTER, recipient=Well2)               [4]\n     *          USDC.transfer(sender=Well2, recipient=0xROUTER)              [5]\n     *  USDC.transfer(sender=0xROUTER, recipient=0xUSER)                     [6]\n     *\n     *  Note: this could be optimized by configuring the router to deliver\n     *  tokens from the last swap directly to the user.\n     *\n     * 2. Using a router with {shift}:\n     *  WETH.transfer(sender=0xUSER, recipient=Well1)                        [1]\n     *  Call the router, which performs:\n     *      Well1.shift(tokenOut=DAI, recipient=Well2)\n     *          DAI.transfer(sender=Well1, recipient=Well2)                  [2]\n     *      Well2.shift(tokenOut=USDC, recipient=0xUSER)\n     *          USDC.transfer(sender=Well2, recipient=0xUSER)                [3]\n     */\n    function shift(\n        IERC20 tokenOut,\n        uint minAmountOut,\n        address recipient\n    ) external nonReentrant returns (uint amountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = new uint[](_tokens.length);\n\n        // Use the balances of the pool instead of the stored reserves.\n        // If there is a change in token balances relative to the currently\n        // stored reserves, the extra tokens can be shifted into `tokenOut`.\n        for (uint i; i < _tokens.length; ++i) {\n            reserves[i] = _tokens[i].balanceOf(address(this));\n        }\n        uint j = _getJ(_tokens, tokenOut);\n        amountOut = reserves[j] - _calcReserve(wellFunction(), reserves, j, totalSupply());\n\n        if (amountOut >= minAmountOut) {\n            tokenOut.safeTransfer(recipient, amountOut);\n            reserves[j] -= amountOut;\n            _setReserves(_tokens, reserves);\n            emit Shift(reserves, tokenOut, amountOut, recipient);\n        } else {\n            revert SlippageOut(amountOut, minAmountOut);\n        }\n    }\n\n    function getShiftOut(IERC20 tokenOut) external view returns (uint amountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = new uint[](_tokens.length);\n        for (uint i; i < _tokens.length; ++i) {\n            reserves[i] = _tokens[i].balanceOf(address(this));\n        }\n\n        uint j = _getJ(_tokens, tokenOut);\n        amountOut = reserves[j] - _calcReserve(wellFunction(), reserves, j, totalSupply());\n    }\n\n    //////////////////// ADD LIQUIDITY ////////////////////\n\n    function addLiquidity(\n        uint[] memory tokenAmountsIn,\n        uint minLpAmountOut,\n        address recipient,\n        uint deadline\n    ) external nonReentrant expire(deadline) returns (uint lpAmountOut) {\n        lpAmountOut = _addLiquidity(tokenAmountsIn, minLpAmountOut, recipient, false);\n    }\n\n    function addLiquidityFeeOnTransfer(\n        uint[] memory tokenAmountsIn,\n        uint minLpAmountOut,\n        address recipient,\n        uint deadline\n    ) external nonReentrant expire(deadline) returns (uint lpAmountOut) {\n        lpAmountOut = _addLiquidity(tokenAmountsIn, minLpAmountOut, recipient, true);\n    }\n\n    /**\n     * @dev Gas optimization: {IWell.AddLiquidity} is emitted even if `lpAmountOut` is 0.\n     */\n    function _addLiquidity(\n        uint[] memory tokenAmountsIn,\n        uint minLpAmountOut,\n        address recipient,\n        bool feeOnTransfer\n    ) internal returns (uint lpAmountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _updatePumps(_tokens.length);\n\n        if (feeOnTransfer) {\n            for (uint i; i < _tokens.length; ++i) {\n                if (tokenAmountsIn[i] == 0) continue;\n                tokenAmountsIn[i] = _safeTransferFromFeeOnTransfer(_tokens[i], msg.sender, tokenAmountsIn[i]);\n                reserves[i] = reserves[i] + tokenAmountsIn[i];\n            }\n        } else {\n            for (uint i; i < _tokens.length; ++i) {\n                if (tokenAmountsIn[i] == 0) continue;\n                _tokens[i].safeTransferFrom(msg.sender, address(this), tokenAmountsIn[i]);\n                reserves[i] = reserves[i] + tokenAmountsIn[i];\n            }\n        }\n\n        lpAmountOut = _calcLpTokenSupply(wellFunction(), reserves) - totalSupply();\n        if (lpAmountOut < minLpAmountOut) {\n            revert SlippageOut(lpAmountOut, minLpAmountOut);\n        }\n\n        _mint(recipient, lpAmountOut);\n        _setReserves(_tokens, reserves);\n        emit AddLiquidity(tokenAmountsIn, lpAmountOut, recipient);\n    }\n\n    /**\n     * @dev Assumes that no tokens involved incur a fee on transfer.\n     */\n    function getAddLiquidityOut(uint[] memory tokenAmountsIn) external view returns (uint lpAmountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _getReserves(_tokens.length);\n        for (uint i; i < _tokens.length; ++i) {\n            reserves[i] = reserves[i] + tokenAmountsIn[i];\n        }\n        lpAmountOut = _calcLpTokenSupply(wellFunction(), reserves) - totalSupply();\n    }\n\n    //////////////////// REMOVE LIQUIDITY: BALANCED ////////////////////\n\n    function removeLiquidity(\n        uint lpAmountIn,\n        uint[] calldata minTokenAmountsOut,\n        address recipient,\n        uint deadline\n    ) external nonReentrant expire(deadline) returns (uint[] memory tokenAmountsOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _updatePumps(_tokens.length);\n        uint lpTokenSupply = totalSupply();\n\n        tokenAmountsOut = new uint[](_tokens.length);\n        _burn(msg.sender, lpAmountIn);\n        for (uint i; i < _tokens.length; ++i) {\n            tokenAmountsOut[i] = (lpAmountIn * reserves[i]) / lpTokenSupply;\n            if (tokenAmountsOut[i] < minTokenAmountsOut[i]) {\n                revert SlippageOut(tokenAmountsOut[i], minTokenAmountsOut[i]);\n            }\n            _tokens[i].safeTransfer(recipient, tokenAmountsOut[i]);\n            reserves[i] = reserves[i] - tokenAmountsOut[i];\n        }\n\n        _setReserves(_tokens, reserves);\n        emit RemoveLiquidity(lpAmountIn, tokenAmountsOut, recipient);\n    }\n\n    function getRemoveLiquidityOut(uint lpAmountIn) external view returns (uint[] memory tokenAmountsOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _getReserves(_tokens.length);\n        uint lpTokenSupply = totalSupply();\n\n        tokenAmountsOut = new uint[](_tokens.length);\n        for (uint i; i < _tokens.length; ++i) {\n            tokenAmountsOut[i] = (lpAmountIn * reserves[i]) / lpTokenSupply;\n        }\n    }\n\n    //////////////////// REMOVE LIQUIDITY: ONE TOKEN ////////////////////\n\n    function removeLiquidityOneToken(\n        uint lpAmountIn,\n        IERC20 tokenOut,\n        uint minTokenAmountOut,\n        address recipient,\n        uint deadline\n    ) external nonReentrant expire(deadline) returns (uint tokenAmountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _updatePumps(_tokens.length);\n        uint j = _getJ(_tokens, tokenOut);\n\n        tokenAmountOut = _getRemoveLiquidityOneTokenOut(lpAmountIn, j, reserves);\n        if (tokenAmountOut < minTokenAmountOut) {\n            revert SlippageOut(tokenAmountOut, minTokenAmountOut);\n        }\n\n        _burn(msg.sender, lpAmountIn);\n        tokenOut.safeTransfer(recipient, tokenAmountOut);\n\n        reserves[j] = reserves[j] - tokenAmountOut;\n        _setReserves(_tokens, reserves);\n        emit RemoveLiquidityOneToken(lpAmountIn, tokenOut, tokenAmountOut, recipient);\n    }\n\n    function getRemoveLiquidityOneTokenOut(\n        uint lpAmountIn,\n        IERC20 tokenOut\n    ) external view returns (uint tokenAmountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _getReserves(_tokens.length);\n        uint j = _getJ(_tokens, tokenOut);\n        tokenAmountOut = _getRemoveLiquidityOneTokenOut(lpAmountIn, j, reserves);\n    }\n\n    /**\n     * @dev Shared logic for removing a single token from liquidity.\n     * Calculates change in reserve `j` given a change in LP token supply.\n     *\n     * Note: `lpAmountIn` is the amount of LP the user is burning in exchange\n     * for some amount of token `j`.\n     */\n    function _getRemoveLiquidityOneTokenOut(\n        uint lpAmountIn,\n        uint j,\n        uint[] memory reserves\n    ) private view returns (uint tokenAmountOut) {\n        uint newLpTokenSupply = totalSupply() - lpAmountIn;\n        uint newReserveJ = _calcReserve(wellFunction(), reserves, j, newLpTokenSupply);\n        tokenAmountOut = reserves[j] - newReserveJ;\n    }\n\n    //////////// REMOVE LIQUIDITY: IMBALANCED ////////////\n\n    function removeLiquidityImbalanced(\n        uint maxLpAmountIn,\n        uint[] calldata tokenAmountsOut,\n        address recipient,\n        uint deadline\n    ) external nonReentrant expire(deadline) returns (uint lpAmountIn) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _updatePumps(_tokens.length);\n\n        for (uint i; i < _tokens.length; ++i) {\n            _tokens[i].safeTransfer(recipient, tokenAmountsOut[i]);\n            reserves[i] = reserves[i] - tokenAmountsOut[i];\n        }\n\n        lpAmountIn = totalSupply() - _calcLpTokenSupply(wellFunction(), reserves);\n        if (lpAmountIn > maxLpAmountIn) {\n            revert SlippageIn(lpAmountIn, maxLpAmountIn);\n        }\n        _burn(msg.sender, lpAmountIn);\n\n        _setReserves(_tokens, reserves);\n        emit RemoveLiquidity(lpAmountIn, tokenAmountsOut, recipient);\n    }\n\n    function getRemoveLiquidityImbalancedIn(uint[] calldata tokenAmountsOut) external view returns (uint lpAmountIn) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _getReserves(_tokens.length);\n        for (uint i; i < _tokens.length; ++i) {\n            reserves[i] = reserves[i] - tokenAmountsOut[i];\n        }\n        lpAmountIn = totalSupply() - _calcLpTokenSupply(wellFunction(), reserves);\n    }\n\n    //////////////////// RESERVES ////////////////////\n\n    /**\n     * @dev Sync the reserves of the Well with its current balance of underlying tokens.\n     */\n    function sync() external nonReentrant {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = new uint[](_tokens.length);\n        for (uint i; i < _tokens.length; ++i) {\n            reserves[i] = _tokens[i].balanceOf(address(this));\n        }\n        _setReserves(_tokens, reserves);\n        emit Sync(reserves);\n    }\n\n    /**\n     * @dev Transfer excess tokens held by the Well to `recipient`.\n     */\n    function skim(address recipient) external nonReentrant returns (uint[] memory skimAmounts) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _getReserves(_tokens.length);\n        skimAmounts = new uint[](_tokens.length);\n        for (uint i; i < _tokens.length; ++i) {\n            skimAmounts[i] = _tokens[i].balanceOf(address(this)) - reserves[i];\n            if (skimAmounts[i] > 0) {\n                _tokens[i].safeTransfer(recipient, skimAmounts[i]);\n            }\n        }\n    }\n\n    function getReserves() external view returns (uint[] memory reserves) {\n        reserves = _getReserves(numberOfTokens());\n    }\n\n    /**\n     * @dev Gets the Well's token reserves by reading from byte storage.\n     */\n    function _getReserves(uint _numberOfTokens) internal view returns (uint[] memory reserves) {\n        reserves = LibBytes.readUint128(RESERVES_STORAGE_SLOT, _numberOfTokens);\n    }\n\n    /**\n     * @dev Checks that the balance of each ERC-20 token is >= the reserves and\n     * sets the Well's reserves of each token by writing to byte storage.\n     */\n    function _setReserves(IERC20[] memory _tokens, uint[] memory reserves) internal {\n        for (uint i; i < reserves.length; ++i) {\n            if (reserves[i] > _tokens[i].balanceOf(address(this))) revert InvalidReserves();\n        }\n        LibBytes.storeUint128(RESERVES_STORAGE_SLOT, reserves);\n    }\n\n    //////////////////// INTERNAL: UPDATE PUMPS ////////////////////\n\n    /**\n     * @dev Fetches the current token reserves of the Well and updates the Pumps.\n     * Typically called before an operation that modifies the Well's reserves.\n     */\n    function _updatePumps(uint _numberOfTokens) internal returns (uint[] memory reserves) {\n        reserves = _getReserves(_numberOfTokens);\n\n        if (numberOfPumps() == 0) {\n            return reserves;\n        }\n\n        // gas optimization: avoid looping if there is only one pump\n        if (numberOfPumps() == 1) {\n            Call memory _pump = firstPump();\n            IPump(_pump.target).update(reserves, _pump.data);\n        } else {\n            Call[] memory _pumps = pumps();\n            for (uint i; i < _pumps.length; ++i) {\n                IPump(_pumps[i].target).update(reserves, _pumps[i].data);\n            }\n        }\n    }\n\n    //////////////////// INTERNAL: WELL FUNCTION INTERACTION ////////////////////\n\n    /**\n     * @dev Calculates the LP token supply given a list of `reserves` using the\n     * provided `_wellFunction`. Wraps {IWellFunction.calcLpTokenSupply}.\n     *\n     * The Well function is passed as a parameter to minimize gas in instances\n     * where it is called multiple times in one transaction.\n     */\n    function _calcLpTokenSupply(\n        Call memory _wellFunction,\n        uint[] memory reserves\n    ) internal view returns (uint lpTokenSupply) {\n        lpTokenSupply = IWellFunction(_wellFunction.target).calcLpTokenSupply(reserves, _wellFunction.data);\n    }\n\n    /**\n     * @dev Calculates the `j`th reserve given a list of `reserves` and `lpTokenSupply`\n     * using the provided `_wellFunction`. Wraps {IWellFunction.calcReserve}.\n     *\n     * The Well function is passed as a parameter to minimize gas in instances\n     * where it is called multiple times in one transaction.\n     */\n    function _calcReserve(\n        Call memory _wellFunction,\n        uint[] memory reserves,\n        uint j,\n        uint lpTokenSupply\n    ) internal view returns (uint reserve) {\n        reserve = IWellFunction(_wellFunction.target).calcReserve(reserves, j, lpTokenSupply, _wellFunction.data);\n    }\n\n    //////////////////// INTERNAL: WELL TOKEN INDEXING ////////////////////\n\n    /**\n     * @dev Returns the indices of `iToken` and `jToken` in `_tokens`.\n     * Reverts if either token is not in `_tokens`.\n     */\n    function _getIJ(IERC20[] memory _tokens, IERC20 iToken, IERC20 jToken) internal pure returns (uint i, uint j) {\n        bool foundI = false;\n        bool foundJ = false;\n\n        for (uint k; k < _tokens.length; ++k) {\n            if (iToken == _tokens[k]) {\n                i = k;\n                foundI = true;\n            } else if (jToken == _tokens[k]) {\n                j = k;\n                foundJ = true;\n            }\n        }\n\n        if (!foundI) revert InvalidTokens();\n        if (!foundJ) revert InvalidTokens();\n    }\n\n    /**\n     * @dev Returns the index of `jToken` in `_tokens`. Reverts if `jToken` is\n     * not in `_tokens`.\n     *\n     * If `_tokens` contains multiple instances of `jToken`, this will return\n     * the first one. A {Well} with duplicate tokens has been misconfigured.\n     */\n    function _getJ(IERC20[] memory _tokens, IERC20 jToken) internal pure returns (uint j) {\n        for (j; j < _tokens.length; ++j) {\n            if (jToken == _tokens[j]) {\n                return j;\n            }\n        }\n        revert InvalidTokens();\n    }\n\n    //////////////////// INTERNAL: TRANSFER HELPERS ////////////////////\n\n    /**\n     * @dev Calculates the change in token balance of the Well across a transfer.\n     * Used when a fee might be incurred during safeTransferFrom.\n     */\n    function _safeTransferFromFeeOnTransfer(\n        IERC20 token,\n        address from,\n        uint amount\n    ) internal returns (uint amountTransferred) {\n        uint balanceBefore = token.balanceOf(address(this));\n        token.safeTransferFrom(from, address(this), amount);\n        amountTransferred = token.balanceOf(address(this)) - balanceBefore;\n    }\n\n    //////////////////// INTERNAL: EXPIRY ////////////////////\n\n    /**\n     * @dev Reverts if the deadline has passed.\n     */\n    modifier expire(uint deadline) {\n        if (block.timestamp > deadline) {\n            revert Expired();\n        }\n        _;\n    }\n}"
    }
  ]
}