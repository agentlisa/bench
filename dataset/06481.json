{
  "Title": "[M-33] `unstakeAndWithdraw` inside `BoostAggregator` could lose `pendingRewards` in certain cases",
  "Content": "\nWhen `BoosAggregator`'s `unstakeAndWithdraw` is triggered, it will try to unstake the uniswap NFT position token from the staker and get the pending rewards. If conditions are met, it will update the strategy and protocol rewards accounting, claim the rewards for strategy and finally, withdraw the NFT position tokens from the staker. However, if `pendingRewards` is lower than `DIVISIONER`, the accounting will not happen and can cause reward loss.\n\n### Proof of Concept\n\nInside `unstakeAndWithdraw`, if `pendingRewards` is lower than `DIVISIONER`, the accounting update for `protocolRewards` and claim rewards for strategy will not happen:\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/boost-aggregator/BoostAggregator.sol#L109-L136>\n\n```solidity\n    function unstakeAndWithdraw(uint256 tokenId) external {\n        address user = tokenIdToUser[tokenId];\n        if (user != msg.sender) revert NotTokenIdOwner();\n\n        // unstake NFT from Uniswap V3 Staker\n        uniswapV3Staker.unstakeToken(tokenId);\n\n        uint256 pendingRewards = uniswapV3Staker.tokenIdRewards(tokenId) - tokenIdRewards[tokenId];\n\n        if (pendingRewards > DIVISIONER) {\n            uint256 newProtocolRewards = (pendingRewards * protocolFee) / DIVISIONER;\n            /// @dev protocol rewards stay in stake contract\n            protocolRewards += newProtocolRewards;\n            pendingRewards -= newProtocolRewards;\n\n            address rewardsDepot = userToRewardsDepot[user];\n            if (rewardsDepot != address(0)) {\n                // claim rewards to user's rewardsDepot\n                uniswapV3Staker.claimReward(rewardsDepot, pendingRewards);\n            } else {\n                // claim rewards to user\n                uniswapV3Staker.claimReward(user, pendingRewards);\n            }\n        }\n\n        // withdraw rewards from Uniswap V3 Staker\n        uniswapV3Staker.withdrawToken(tokenId, user, \"\");\n    }\n```\n\nHowever, when the token is staked again via `BoosAggregator` by sending the NFT position back, the `tokenIdRewards` rewards are updated, so the previous unaccounted rewards will be lost:\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/boost-aggregator/BoostAggregator.sol#L79-L93>\n\n```solidity\n    function onERC721Received(address, address from, uint256 tokenId, bytes calldata)\n        external\n        override\n        onlyWhitelisted(from)\n        returns (bytes4)\n    {\n        // update tokenIdRewards prior to staking\n        tokenIdRewards[tokenId] = uniswapV3Staker.tokenIdRewards(tokenId);\n        // map tokenId to user\n        tokenIdToUser[tokenId] = from;\n        // stake NFT to Uniswap V3 Staker\n        nonfungiblePositionManager.safeTransferFrom(address(this), address(uniswapV3Staker), tokenId);\n\n        return this.onERC721Received.selector;\n    }\n```\n\n### Recommended Mitigation Steps\n\nTwo things can be done here, either just claim rewards to strategy without taking the protocol fee, or take the amount fully for the protocol.\n\n### Assessed type\n\nError\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/287#issuecomment-1709218882):**\n > Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/tree/287).\n\n**[0xBugsy (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/287#issuecomment-1719576951)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/talos/boost-aggregator/BoostAggregator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {INonfungiblePositionManager} from \"@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol\";\n\nimport {bHermesBoost} from \"@hermes/tokens/bHermesBoost.sol\";\nimport {UniswapV3Staker} from \"@v3-staker/UniswapV3Staker.sol\";\n\nimport {IBoostAggregator} from \"../interfaces/IBoostAggregator.sol\";\n\n/// @title Boost Aggregator for Uniswap V3 NFTs\ncontract BoostAggregator is Ownable, IBoostAggregator {\n    using SafeTransferLib for address;\n\n    /*//////////////////////////////////////////////////////////////\n                        BOOST AGGREGATOR STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBoostAggregator\n    INonfungiblePositionManager public immutable nonfungiblePositionManager;\n\n    /// @inheritdoc IBoostAggregator\n    UniswapV3Staker public immutable uniswapV3Staker;\n\n    /// @inheritdoc IBoostAggregator\n    bHermesBoost public immutable hermesGaugeBoost;\n\n    /// @inheritdoc IBoostAggregator\n    ERC20 public immutable hermes;\n\n    /// @inheritdoc IBoostAggregator\n    mapping(address => address) public userToRewardsDepot;\n\n    /// @inheritdoc IBoostAggregator\n    mapping(uint256 => address) public tokenIdToUser;\n\n    /// @inheritdoc IBoostAggregator\n    mapping(uint256 => uint256) public tokenIdRewards;\n\n    /// @inheritdoc IBoostAggregator\n    mapping(address => bool) public whitelistedAddresses;\n\n    /// @inheritdoc IBoostAggregator\n    uint256 public protocolRewards;\n\n    /// @inheritdoc IBoostAggregator\n    uint256 public protocolFee = 2000; // 20%\n    // divisioner for protocol fee\n    uint256 private constant DIVISIONER = 10000;\n\n    /**\n     * @notice Creates a new BoostAggregator\n     * @param _uniswapV3Staker The UniswapV3Staker contract\n     * @param _hermes The hermes token contract\n     * @param _owner The owner of this contract\n     */\n    constructor(UniswapV3Staker _uniswapV3Staker, ERC20 _hermes, address _owner) {\n        _initializeOwner(_owner);\n        uniswapV3Staker = _uniswapV3Staker;\n        hermesGaugeBoost = uniswapV3Staker.hermesGaugeBoost();\n        nonfungiblePositionManager = uniswapV3Staker.nonfungiblePositionManager();\n        hermes = _hermes;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL HOOKS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721Receiver\n    /// @dev msg.sender not validated to be nonfungiblePositionManager in order to allow\n    ///      whitelisted addresses to retrieve NFTs incorrectly sent to this contract\n    function onERC721Received(address, address from, uint256 tokenId, bytes calldata)\n        external\n        override\n        onlyWhitelisted(from)\n        returns (bytes4)\n    {\n        // update tokenIdRewards prior to staking\n        tokenIdRewards[tokenId] = uniswapV3Staker.tokenIdRewards(tokenId);\n        // map tokenId to user\n        tokenIdToUser[tokenId] = from;\n        // stake NFT to Uniswap V3 Staker\n        nonfungiblePositionManager.safeTransferFrom(address(this), address(uniswapV3Staker), tokenId);\n\n        return this.onERC721Received.selector;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        REWARD DEPOTS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBoostAggregator\n    function setOwnRewardsDepot(address rewardsDepot) external {\n        userToRewardsDepot[msg.sender] = rewardsDepot;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            UNSTAKE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBoostAggregator\n    function unstakeAndWithdraw(uint256 tokenId) external {\n        address user = tokenIdToUser[tokenId];\n        if (user != msg.sender) revert NotTokenIdOwner();\n\n        // unstake NFT from Uniswap V3 Staker\n        uniswapV3Staker.unstakeToken(tokenId);\n\n        uint256 pendingRewards = uniswapV3Staker.tokenIdRewards(tokenId) - tokenIdRewards[tokenId];\n\n        if (pendingRewards > DIVISIONER) {\n            uint256 newProtocolRewards = (pendingRewards * protocolFee) / DIVISIONER;\n            /// @dev protocol rewards stay in stake contract\n            protocolRewards += newProtocolRewards;\n            pendingRewards -= newProtocolRewards;\n\n            address rewardsDepot = userToRewardsDepot[user];\n            if (rewardsDepot != address(0)) {\n                // claim rewards to user's rewardsDepot\n                uniswapV3Staker.claimReward(rewardsDepot, pendingRewards);\n            } else {\n                // claim rewards to user\n                uniswapV3Staker.claimReward(user, pendingRewards);\n            }\n        }\n\n        // withdraw rewards from Uniswap V3 Staker\n        uniswapV3Staker.withdrawToken(tokenId, user, \"\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBoostAggregator\n    function addWhitelistedAddress(address user) external onlyOwner {\n        whitelistedAddresses[user] = true;\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function removeWhitelistedAddress(address user) external onlyOwner {\n        delete whitelistedAddresses[user];\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function setProtocolFee(uint256 _protocolFee) external onlyOwner {\n        if (_protocolFee > DIVISIONER) revert FeeTooHigh();\n        protocolFee = _protocolFee;\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function withdrawProtocolFees(address to) external onlyOwner {\n        uniswapV3Staker.claimReward(to, protocolRewards);\n        delete protocolRewards;\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function withdrawAllGaugeBoost(address to) external onlyOwner {\n        /// @dev May run out of gas.\n        hermesGaugeBoost.decrementAllGaugesAllBoost();\n        address(hermesGaugeBoost).safeTransfer(to, hermesGaugeBoost.balanceOf(address(this)));\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function withdrawGaugeBoost(address to, uint256 amount) external onlyOwner {\n        /// @dev May run out of gas.\n        hermesGaugeBoost.decrementAllGaugesBoost(amount);\n        hermesGaugeBoost.updateUserBoost(address(this));\n        address(hermesGaugeBoost).safeTransfer(to, amount);\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function decrementGaugesBoostIndexed(uint256 boost, uint256 offset, uint256 num) external onlyOwner {\n        hermesGaugeBoost.decrementGaugesBoostIndexed(boost, offset, num);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Only whitelisted addresses\n    /// @param from The address who the NFT is being transferred from\n    modifier onlyWhitelisted(address from) {\n        if (!whitelistedAddresses[from]) revert Unauthorized();\n        _;\n    }\n}"
    },
    {
      "filename": "src/talos/boost-aggregator/BoostAggregator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {INonfungiblePositionManager} from \"@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol\";\n\nimport {bHermesBoost} from \"@hermes/tokens/bHermesBoost.sol\";\nimport {UniswapV3Staker} from \"@v3-staker/UniswapV3Staker.sol\";\n\nimport {IBoostAggregator} from \"../interfaces/IBoostAggregator.sol\";\n\n/// @title Boost Aggregator for Uniswap V3 NFTs\ncontract BoostAggregator is Ownable, IBoostAggregator {\n    using SafeTransferLib for address;\n\n    /*//////////////////////////////////////////////////////////////\n                        BOOST AGGREGATOR STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBoostAggregator\n    INonfungiblePositionManager public immutable nonfungiblePositionManager;\n\n    /// @inheritdoc IBoostAggregator\n    UniswapV3Staker public immutable uniswapV3Staker;\n\n    /// @inheritdoc IBoostAggregator\n    bHermesBoost public immutable hermesGaugeBoost;\n\n    /// @inheritdoc IBoostAggregator\n    ERC20 public immutable hermes;\n\n    /// @inheritdoc IBoostAggregator\n    mapping(address => address) public userToRewardsDepot;\n\n    /// @inheritdoc IBoostAggregator\n    mapping(uint256 => address) public tokenIdToUser;\n\n    /// @inheritdoc IBoostAggregator\n    mapping(uint256 => uint256) public tokenIdRewards;\n\n    /// @inheritdoc IBoostAggregator\n    mapping(address => bool) public whitelistedAddresses;\n\n    /// @inheritdoc IBoostAggregator\n    uint256 public protocolRewards;\n\n    /// @inheritdoc IBoostAggregator\n    uint256 public protocolFee = 2000; // 20%\n    // divisioner for protocol fee\n    uint256 private constant DIVISIONER = 10000;\n\n    /**\n     * @notice Creates a new BoostAggregator\n     * @param _uniswapV3Staker The UniswapV3Staker contract\n     * @param _hermes The hermes token contract\n     * @param _owner The owner of this contract\n     */\n    constructor(UniswapV3Staker _uniswapV3Staker, ERC20 _hermes, address _owner) {\n        _initializeOwner(_owner);\n        uniswapV3Staker = _uniswapV3Staker;\n        hermesGaugeBoost = uniswapV3Staker.hermesGaugeBoost();\n        nonfungiblePositionManager = uniswapV3Staker.nonfungiblePositionManager();\n        hermes = _hermes;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL HOOKS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721Receiver\n    /// @dev msg.sender not validated to be nonfungiblePositionManager in order to allow\n    ///      whitelisted addresses to retrieve NFTs incorrectly sent to this contract\n    function onERC721Received(address, address from, uint256 tokenId, bytes calldata)\n        external\n        override\n        onlyWhitelisted(from)\n        returns (bytes4)\n    {\n        // update tokenIdRewards prior to staking\n        tokenIdRewards[tokenId] = uniswapV3Staker.tokenIdRewards(tokenId);\n        // map tokenId to user\n        tokenIdToUser[tokenId] = from;\n        // stake NFT to Uniswap V3 Staker\n        nonfungiblePositionManager.safeTransferFrom(address(this), address(uniswapV3Staker), tokenId);\n\n        return this.onERC721Received.selector;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        REWARD DEPOTS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBoostAggregator\n    function setOwnRewardsDepot(address rewardsDepot) external {\n        userToRewardsDepot[msg.sender] = rewardsDepot;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            UNSTAKE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBoostAggregator\n    function unstakeAndWithdraw(uint256 tokenId) external {\n        address user = tokenIdToUser[tokenId];\n        if (user != msg.sender) revert NotTokenIdOwner();\n\n        // unstake NFT from Uniswap V3 Staker\n        uniswapV3Staker.unstakeToken(tokenId);\n\n        uint256 pendingRewards = uniswapV3Staker.tokenIdRewards(tokenId) - tokenIdRewards[tokenId];\n\n        if (pendingRewards > DIVISIONER) {\n            uint256 newProtocolRewards = (pendingRewards * protocolFee) / DIVISIONER;\n            /// @dev protocol rewards stay in stake contract\n            protocolRewards += newProtocolRewards;\n            pendingRewards -= newProtocolRewards;\n\n            address rewardsDepot = userToRewardsDepot[user];\n            if (rewardsDepot != address(0)) {\n                // claim rewards to user's rewardsDepot\n                uniswapV3Staker.claimReward(rewardsDepot, pendingRewards);\n            } else {\n                // claim rewards to user\n                uniswapV3Staker.claimReward(user, pendingRewards);\n            }\n        }\n\n        // withdraw rewards from Uniswap V3 Staker\n        uniswapV3Staker.withdrawToken(tokenId, user, \"\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBoostAggregator\n    function addWhitelistedAddress(address user) external onlyOwner {\n        whitelistedAddresses[user] = true;\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function removeWhitelistedAddress(address user) external onlyOwner {\n        delete whitelistedAddresses[user];\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function setProtocolFee(uint256 _protocolFee) external onlyOwner {\n        if (_protocolFee > DIVISIONER) revert FeeTooHigh();\n        protocolFee = _protocolFee;\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function withdrawProtocolFees(address to) external onlyOwner {\n        uniswapV3Staker.claimReward(to, protocolRewards);\n        delete protocolRewards;\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function withdrawAllGaugeBoost(address to) external onlyOwner {\n        /// @dev May run out of gas.\n        hermesGaugeBoost.decrementAllGaugesAllBoost();\n        address(hermesGaugeBoost).safeTransfer(to, hermesGaugeBoost.balanceOf(address(this)));\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function withdrawGaugeBoost(address to, uint256 amount) external onlyOwner {\n        /// @dev May run out of gas.\n        hermesGaugeBoost.decrementAllGaugesBoost(amount);\n        hermesGaugeBoost.updateUserBoost(address(this));\n        address(hermesGaugeBoost).safeTransfer(to, amount);\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function decrementGaugesBoostIndexed(uint256 boost, uint256 offset, uint256 num) external onlyOwner {\n        hermesGaugeBoost.decrementGaugesBoostIndexed(boost, offset, num);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Only whitelisted addresses\n    /// @param from The address who the NFT is being transferred from\n    modifier onlyWhitelisted(address from) {\n        if (!whitelistedAddresses[from]) revert Unauthorized();\n        _;\n    }\n}"
    }
  ]
}