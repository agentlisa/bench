{
  "Title": "User will lose collateral in the exact case `cRatio == minimumCR`",
  "Content": "# User will lose collateral in the exact case `cRatio == minimumCR`\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallPrimaryFacet.sol#L213\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallPrimaryFacet.sol#L213</a>\n\n\n## Summary\nAccording to documentation\n>When CR >= minimumCR, the shorter will get back some of their collateral, with 1 CR worth of collateral being burned to cover the position's debt. When CR < minimumCR, the shorter doesn't get anything back, and the remaining collateral goes to the TAPP. If the CR < 1, then the TAPP is getting less collateral back in paying off the under-collateralized debt.\n\nHowever code is different, it will not repay collateral back if CR == minimumCR.\n\n## Vulnerability Details\n`m.loseCollateral` should be true when CR is strictly lower than minimumCR:\n\nhttps://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallPrimaryFacet.sol#L213\n\nThis variable then used to determine whether to repay collateral to user:\n\nhttps://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallPrimaryFacet.sol#L306-L310\n\nhttps://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallPrimaryFacet.sol#L323-L336\n\n\n## Impact\nUser will lose collateral payout in case `CR == minimumCR`\n\n## Tools Used\nManual Review\n\n## Recommendations\n```solidity\n-       m.loseCollateral = m.cRatio <= m.minimumCR;\n+       m.loseCollateral = m.cRatio < m.minimumCR;\n```",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/facets/MarginCallPrimaryFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U96, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {STypes, MTypes, SR, OF} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract MarginCallPrimaryFacet is Modifiers {\n    using LibShortRecord for STypes.ShortRecord;\n    using U256 for uint256;\n    using U96 for uint96;\n    using U88 for uint88;\n    using U80 for uint80;\n\n    address private immutable cusd;\n\n    constructor(address _cusd) {\n        cusd = _cusd;\n    }\n\n    /**\n     * @notice Flags short under primaryLiquidationCR to be eligible for liquidation after time has passed\n     * @dev Used to flag for primary liquidation method\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter getting liquidated\n     * @param id id of short getting liquidated\n     * @param flaggerHint Hint ID for gas-optimized update of short flagger\n     *\n     */\n    function flagShort(address asset, address shorter, uint8 id, uint16 flaggerHint)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, shorter, id)\n    {\n        if (msg.sender == shorter) revert Errors.CannotFlagSelf();\n        STypes.ShortRecord storage short = s.shortRecords[asset][shorter][id];\n        short.updateErcDebt(asset);\n\n        if (\n            short.getCollateralRatioSpotPrice(LibOracle.getSavedOrSpotOraclePrice(asset))\n                >= LibAsset.primaryLiquidationCR(asset)\n        ) {\n            revert Errors.SufficientCollateral();\n        }\n\n        uint256 adjustedTimestamp = LibOrders.getOffsetTimeHours();\n\n        // check if already flagged\n        if (short.flaggerId != 0) {\n            uint256 timeDiff = adjustedTimestamp - short.updatedAt;\n            uint256 resetLiquidationTime = LibAsset.resetLiquidationTime(asset);\n\n            if (timeDiff <= resetLiquidationTime) {\n                revert Errors.MarginCallAlreadyFlagged();\n            }\n        }\n\n        short.setFlagger(cusd, flaggerHint);\n        emit Events.FlagShort(asset, shorter, id, msg.sender, adjustedTimestamp);\n    }\n\n    /**\n     * @notice Liquidates short by forcing shorter to place bid on market\n     * @dev Primary liquidation method. Requires flag\n     * @dev Shorter will bear the cost of forcedBid on market\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter getting liquidated\n     * @param id Id of short getting liquidated\n     * @param shortHintArray Array of hintId for the id to start matching against shorts since you can't match a short < oracle price\n     *\n     * @return gasFee Estimated cost of gas for the forcedBid\n     * @return ethFilled Amount of eth filled in forcedBid\n     */\n    function liquidate(\n        address asset,\n        address shorter,\n        uint8 id,\n        uint16[] memory shortHintArray\n    )\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, shorter, id)\n        returns (uint88, uint88)\n    {\n        if (msg.sender == shorter) revert Errors.CannotLiquidateSelf();\n\n        //@dev marginCall requires more up-to-date oraclePrice (15 min vs createLimitBid's 1 hour)\n        LibOrders.updateOracleAndStartingShortViaTimeBidOnly(\n            asset, OF.FifteenMinutes, shortHintArray\n        );\n\n        MTypes.MarginCallPrimary memory m = _setMarginCallStruct(asset, shorter, id);\n\n        if (m.cRatio >= LibAsset.primaryLiquidationCR(m.asset)) {\n            revert Errors.SufficientCollateral();\n        }\n\n        // revert if no asks, or price too high\n        _checklowestSell(m);\n\n        // check if within margin call time window\n        if (!_canLiquidate(m)) {\n            STypes.ShortRecord storage shortRecord = s.shortRecords[asset][shorter][id];\n            shortRecord.resetFlag();\n            return (0, 0);\n        }\n\n        _performForcedBid(m, shortHintArray);\n\n        _marginFeeHandler(m);\n\n        _fullorPartialLiquidation(m);\n        emit Events.Liquidate(asset, shorter, id, msg.sender, m.ercDebtMatched);\n\n        return (m.gasFee, m.ethFilled);\n    }\n\n    //PRIVATE FUNCTIONS\n\n    // Reverts if no eligible sells, or if lowest sell price is too high\n    // @dev startingShortId is updated via updateOracleAndStartingShortViaTimeBidOnly() prior to call\n    function _checklowestSell(MTypes.MarginCallPrimary memory m) private view {\n        uint16 lowestAskKey = s.asks[m.asset][Constants.HEAD].nextId;\n        uint16 startingShortId = s.asset[m.asset].startingShortId;\n        uint256 bufferPrice = m.oraclePrice.mul(m.forcedBidPriceBuffer);\n        if (\n            // Checks for no eligible asks\n            (\n                lowestAskKey == Constants.TAIL\n                    || s.asks[m.asset][lowestAskKey].price > bufferPrice\n            )\n            // Checks for no eligible shorts\n            && (\n                startingShortId == Constants.HEAD // means no short >= oracleprice\n                    || s.shorts[m.asset][startingShortId].price > bufferPrice\n            )\n        ) {\n            revert Errors.NoSells();\n        }\n    }\n\n    /**\n     * @notice Sets the memory struct m with initial data\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter getting liquidated\n     * @param id Id of short getting liquidated\n     *\n     * @return m Memory struct used throughout MarginCallPrimaryFacet.sol\n     */\n\n    function _setMarginCallStruct(address asset, address shorter, uint8 id)\n        private\n        returns (MTypes.MarginCallPrimary memory)\n    {\n        LibShortRecord.updateErcDebt(asset, shorter, id);\n        {\n            MTypes.MarginCallPrimary memory m;\n            m.asset = asset;\n            m.short = s.shortRecords[asset][shorter][id];\n            m.vault = s.asset[asset].vault;\n            m.shorter = shorter;\n            m.minimumCR = LibAsset.minimumCR(asset);\n            m.oraclePrice = LibOracle.getPrice(asset);\n            m.cRatio = m.short.getCollateralRatio(asset);\n            m.forcedBidPriceBuffer = LibAsset.forcedBidPriceBuffer(asset);\n            m.callerFeePct = LibAsset.callerFeePct(m.asset);\n            m.tappFeePct = LibAsset.tappFeePct(m.asset);\n            m.ethDebt = m.short.ercDebt.mul(m.oraclePrice).mul(m.forcedBidPriceBuffer).mul(\n                1 ether + m.tappFeePct + m.callerFeePct\n            ); // ethDebt accounts for forcedBidPriceBuffer and potential fees\n            return m;\n        }\n    }\n\n    /**\n     * @notice Handles the set up and execution of making a forcedBid\n     * @dev Shorter will bear the cost of forcedBid on market\n     * @dev Depending on shorter's cRatio, the TAPP can attempt to fund bid\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     * @param shortHintArray Array of hintId for the id to start matching against shorts since you can't match a short < oracle price\n     *\n     */\n\n    function _performForcedBid(\n        MTypes.MarginCallPrimary memory m,\n        uint16[] memory shortHintArray\n    ) private {\n        uint256 startGas = gasleft();\n        uint88 ercAmountLeft;\n\n        //@dev Provide higher price to better ensure it can fully fill the margin call\n        uint80 _bidPrice = m.oraclePrice.mulU80(m.forcedBidPriceBuffer);\n\n        // Shorter loses leftover collateral to TAPP when unable to maintain CR above the minimum\n        m.loseCollateral = m.cRatio <= m.minimumCR;\n\n        //@dev Increase ethEscrowed by shorter's full collateral for forced bid\n        s.vaultUser[m.vault][address(this)].ethEscrowed += m.short.collateral;\n\n        // Check ability of TAPP plus short collateral to pay back ethDebt\n        if (s.vaultUser[m.vault][address(this)].ethEscrowed < m.ethDebt) {\n            uint96 ercDebtPrev = m.short.ercDebt;\n            if (s.asset[m.asset].ercDebt <= ercDebtPrev) {\n                // Occurs when only one shortRecord in the asset (market)\n                revert Errors.CannotSocializeDebt();\n            }\n            m.loseCollateral = true;\n            // @dev Max ethDebt can only be the ethEscrowed in the TAPP\n            m.ethDebt = s.vaultUser[m.vault][address(this)].ethEscrowed;\n            // Reduce ercDebt proportional to ethDebt\n            m.short.ercDebt = uint88(\n                m.ethDebt.div(_bidPrice.mul(1 ether + m.callerFeePct + m.tappFeePct))\n            ); // @dev(safe-cast)\n            uint96 ercDebtSocialized = ercDebtPrev - m.short.ercDebt;\n            // Update ercDebtRate to socialize loss (increase debt) to other shorts\n            s.asset[m.asset].ercDebtRate +=\n                ercDebtSocialized.divU64(s.asset[m.asset].ercDebt - ercDebtPrev);\n        }\n\n        // @dev MarginCall contract will be the caller. Virtual accounting done later for shorter or TAPP\n        (m.ethFilled, ercAmountLeft) = IDiamond(payable(address(this))).createForcedBid(\n            address(this), m.asset, _bidPrice, m.short.ercDebt, shortHintArray\n        );\n\n        m.ercDebtMatched = m.short.ercDebt - ercAmountLeft;\n\n        //@dev virtually burning the repurchased debt\n        s.assetUser[m.asset][address(this)].ercEscrowed -= m.ercDebtMatched;\n        s.asset[m.asset].ercDebt -= m.ercDebtMatched;\n\n        uint256 gasUsed = startGas - gasleft();\n        //@dev manually setting basefee to 1,000,000 in foundry.toml;\n        //@dev By basing gasFee off of baseFee instead of priority, adversaries are prevent from draining the TAPP\n        m.gasFee = uint88(gasUsed * block.basefee); // @dev(safe-cast)\n    }\n\n    /**\n     * @notice Handles the distribution of marginFee\n     * @dev MarginFee is taken into consideration when determining black swan\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     *\n     */\n    function _marginFeeHandler(MTypes.MarginCallPrimary memory m) private {\n        STypes.VaultUser storage VaultUser = s.vaultUser[m.vault][msg.sender];\n        STypes.VaultUser storage TAPP = s.vaultUser[m.vault][address(this)];\n        // distribute fees to TAPP and caller\n        uint88 tappFee = m.ethFilled.mulU88(m.tappFeePct);\n        uint88 callerFee = m.ethFilled.mulU88(m.callerFeePct) + m.gasFee;\n\n        m.totalFee += tappFee + callerFee;\n        //@dev TAPP already received the gasFee for being the forcedBid caller. tappFee nets out.\n        if (TAPP.ethEscrowed >= callerFee) {\n            TAPP.ethEscrowed -= callerFee;\n            VaultUser.ethEscrowed += callerFee;\n        } else {\n            // Give caller (portion of?) tappFee instead of gasFee\n            VaultUser.ethEscrowed += callerFee - m.gasFee + tappFee;\n            m.totalFee -= m.gasFee;\n            TAPP.ethEscrowed -= m.totalFee;\n        }\n    }\n\n    function min88(uint256 a, uint88 b) private pure returns (uint88) {\n        if (a > type(uint88).max) revert Errors.InvalidAmount();\n        return a < b ? uint88(a) : b;\n    }\n\n    /**\n     * @notice Handles accounting in event of full or partial liquidations\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     *\n     */\n    function _fullorPartialLiquidation(MTypes.MarginCallPrimary memory m) private {\n        uint88 decreaseCol = min88(m.totalFee + m.ethFilled, m.short.collateral);\n\n        if (m.short.ercDebt == m.ercDebtMatched) {\n            // Full liquidation\n            LibShortRecord.disburseCollateral(\n                m.asset,\n                m.shorter,\n                m.short.collateral,\n                m.short.zethYieldRate,\n                m.short.updatedAt\n            );\n            LibShortRecord.deleteShortRecord(m.asset, m.shorter, m.short.id);\n            if (!m.loseCollateral) {\n                m.short.collateral -= decreaseCol;\n                s.vaultUser[m.vault][m.shorter].ethEscrowed += m.short.collateral;\n                s.vaultUser[m.vault][address(this)].ethEscrowed -= m.short.collateral;\n            }\n        } else {\n            // Partial liquidation\n            m.short.ercDebt -= m.ercDebtMatched;\n            m.short.collateral -= decreaseCol;\n            s.shortRecords[m.asset][m.shorter][m.short.id] = m.short;\n\n            s.vaultUser[m.vault][address(this)].ethEscrowed -= m.short.collateral;\n            LibShortRecord.disburseCollateral(\n                m.asset, m.shorter, decreaseCol, m.short.zethYieldRate, m.short.updatedAt\n            );\n\n            // TAPP absorbs leftover short, unless it already owns the short\n            if (m.loseCollateral && m.shorter != address(this)) {\n                // Delete partially liquidated short\n                LibShortRecord.deleteShortRecord(m.asset, m.shorter, m.short.id);\n                // Absorb leftovers into TAPP short\n                LibShortRecord.fillShortRecord(\n                    m.asset,\n                    address(this),\n                    Constants.SHORT_STARTING_ID,\n                    SR.FullyFilled,\n                    m.short.collateral,\n                    m.short.ercDebt,\n                    s.asset[m.asset].ercDebtRate,\n                    m.short.zethYieldRate\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Helper that evaluates if a short is eligible for liquidation (i.e. flagged and within appropriate time frame)\n     * @dev Shorter has 10 hours after initial flag to bring cRatio up above maintainence margin...\n     * @dev ...After that, the flagger has 2 hours to liquidate the shorter. If short is not liquidated by shorter within that time, ANYBODY can then liquidate...\n     * @dev ...After 16 total hours have passed and the short has not been liquidated, the flag gets reset and the flagging process begins anew\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     *\n     */\n    // check if within margin call time window\n    function _canLiquidate(MTypes.MarginCallPrimary memory m)\n        private\n        view\n        returns (bool)\n    {\n        //@dev if cRatio is below the minimumCR, allow liquidation regardless of flagging\n        if (m.cRatio < m.minimumCR) return true;\n\n        //@dev Only check if flagger is empty, not updatedAt\n        if (m.short.flaggerId == 0) {\n            revert Errors.ShortNotFlagged();\n        }\n\n        /*\n         * Timeline: \n         * \n         * updatedAt (~0 hrs)\n         * ..\n         * [Errors.MarginCallIneligibleWindow]\n         * ..\n         * firstLiquidationTime (~10hrs, +10 hrs)\n         * ..\n         * [return msg.sender == short.flagger]\n         * ..\n         * secondLiquidationTime (~12hrs, +2 hrs)\n         * ..\n         * [return true (msg.sender is anyone)]\n         * ..\n         * resetLiquidationTime (~16hrs, +4 hrs)\n         * ..\n         * [return false (reset flag)]\n        */\n\n        uint256 timeDiff = LibOrders.getOffsetTimeHours() - m.short.updatedAt;\n        uint256 resetLiquidationTime = LibAsset.resetLiquidationTime(m.asset);\n\n        if (timeDiff >= resetLiquidationTime) {\n            return false;\n        } else {\n            uint256 secondLiquidationTime = LibAsset.secondLiquidationTime(m.asset);\n            bool isBetweenFirstAndSecondLiquidationTime = timeDiff\n                > LibAsset.firstLiquidationTime(m.asset) && timeDiff <= secondLiquidationTime\n                && s.flagMapping[m.short.flaggerId] == msg.sender;\n            bool isBetweenSecondAndResetLiquidationTime =\n                timeDiff > secondLiquidationTime && timeDiff <= resetLiquidationTime;\n            if (\n                !(\n                    (isBetweenFirstAndSecondLiquidationTime)\n                        || (isBetweenSecondAndResetLiquidationTime)\n                )\n            ) {\n                revert Errors.MarginCallIneligibleWindow();\n            }\n\n            return true;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/facets/MarginCallPrimaryFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U96, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {STypes, MTypes, SR, OF} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract MarginCallPrimaryFacet is Modifiers {\n    using LibShortRecord for STypes.ShortRecord;\n    using U256 for uint256;\n    using U96 for uint96;\n    using U88 for uint88;\n    using U80 for uint80;\n\n    address private immutable cusd;\n\n    constructor(address _cusd) {\n        cusd = _cusd;\n    }\n\n    /**\n     * @notice Flags short under primaryLiquidationCR to be eligible for liquidation after time has passed\n     * @dev Used to flag for primary liquidation method\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter getting liquidated\n     * @param id id of short getting liquidated\n     * @param flaggerHint Hint ID for gas-optimized update of short flagger\n     *\n     */\n    function flagShort(address asset, address shorter, uint8 id, uint16 flaggerHint)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, shorter, id)\n    {\n        if (msg.sender == shorter) revert Errors.CannotFlagSelf();\n        STypes.ShortRecord storage short = s.shortRecords[asset][shorter][id];\n        short.updateErcDebt(asset);\n\n        if (\n            short.getCollateralRatioSpotPrice(LibOracle.getSavedOrSpotOraclePrice(asset))\n                >= LibAsset.primaryLiquidationCR(asset)\n        ) {\n            revert Errors.SufficientCollateral();\n        }\n\n        uint256 adjustedTimestamp = LibOrders.getOffsetTimeHours();\n\n        // check if already flagged\n        if (short.flaggerId != 0) {\n            uint256 timeDiff = adjustedTimestamp - short.updatedAt;\n            uint256 resetLiquidationTime = LibAsset.resetLiquidationTime(asset);\n\n            if (timeDiff <= resetLiquidationTime) {\n                revert Errors.MarginCallAlreadyFlagged();\n            }\n        }\n\n        short.setFlagger(cusd, flaggerHint);\n        emit Events.FlagShort(asset, shorter, id, msg.sender, adjustedTimestamp);\n    }\n\n    /**\n     * @notice Liquidates short by forcing shorter to place bid on market\n     * @dev Primary liquidation method. Requires flag\n     * @dev Shorter will bear the cost of forcedBid on market\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter getting liquidated\n     * @param id Id of short getting liquidated\n     * @param shortHintArray Array of hintId for the id to start matching against shorts since you can't match a short < oracle price\n     *\n     * @return gasFee Estimated cost of gas for the forcedBid\n     * @return ethFilled Amount of eth filled in forcedBid\n     */\n    function liquidate(\n        address asset,\n        address shorter,\n        uint8 id,\n        uint16[] memory shortHintArray\n    )\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, shorter, id)\n        returns (uint88, uint88)\n    {\n        if (msg.sender == shorter) revert Errors.CannotLiquidateSelf();\n\n        //@dev marginCall requires more up-to-date oraclePrice (15 min vs createLimitBid's 1 hour)\n        LibOrders.updateOracleAndStartingShortViaTimeBidOnly(\n            asset, OF.FifteenMinutes, shortHintArray\n        );\n\n        MTypes.MarginCallPrimary memory m = _setMarginCallStruct(asset, shorter, id);\n\n        if (m.cRatio >= LibAsset.primaryLiquidationCR(m.asset)) {\n            revert Errors.SufficientCollateral();\n        }\n\n        // revert if no asks, or price too high\n        _checklowestSell(m);\n\n        // check if within margin call time window\n        if (!_canLiquidate(m)) {\n            STypes.ShortRecord storage shortRecord = s.shortRecords[asset][shorter][id];\n            shortRecord.resetFlag();\n            return (0, 0);\n        }\n\n        _performForcedBid(m, shortHintArray);\n\n        _marginFeeHandler(m);\n\n        _fullorPartialLiquidation(m);\n        emit Events.Liquidate(asset, shorter, id, msg.sender, m.ercDebtMatched);\n\n        return (m.gasFee, m.ethFilled);\n    }\n\n    //PRIVATE FUNCTIONS\n\n    // Reverts if no eligible sells, or if lowest sell price is too high\n    // @dev startingShortId is updated via updateOracleAndStartingShortViaTimeBidOnly() prior to call\n    function _checklowestSell(MTypes.MarginCallPrimary memory m) private view {\n        uint16 lowestAskKey = s.asks[m.asset][Constants.HEAD].nextId;\n        uint16 startingShortId = s.asset[m.asset].startingShortId;\n        uint256 bufferPrice = m.oraclePrice.mul(m.forcedBidPriceBuffer);\n        if (\n            // Checks for no eligible asks\n            (\n                lowestAskKey == Constants.TAIL\n                    || s.asks[m.asset][lowestAskKey].price > bufferPrice\n            )\n            // Checks for no eligible shorts\n            && (\n                startingShortId == Constants.HEAD // means no short >= oracleprice\n                    || s.shorts[m.asset][startingShortId].price > bufferPrice\n            )\n        ) {\n            revert Errors.NoSells();\n        }\n    }\n\n    /**\n     * @notice Sets the memory struct m with initial data\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter getting liquidated\n     * @param id Id of short getting liquidated\n     *\n     * @return m Memory struct used throughout MarginCallPrimaryFacet.sol\n     */\n\n    function _setMarginCallStruct(address asset, address shorter, uint8 id)\n        private\n        returns (MTypes.MarginCallPrimary memory)\n    {\n        LibShortRecord.updateErcDebt(asset, shorter, id);\n        {\n            MTypes.MarginCallPrimary memory m;\n            m.asset = asset;\n            m.short = s.shortRecords[asset][shorter][id];\n            m.vault = s.asset[asset].vault;\n            m.shorter = shorter;\n            m.minimumCR = LibAsset.minimumCR(asset);\n            m.oraclePrice = LibOracle.getPrice(asset);\n            m.cRatio = m.short.getCollateralRatio(asset);\n            m.forcedBidPriceBuffer = LibAsset.forcedBidPriceBuffer(asset);\n            m.callerFeePct = LibAsset.callerFeePct(m.asset);\n            m.tappFeePct = LibAsset.tappFeePct(m.asset);\n            m.ethDebt = m.short.ercDebt.mul(m.oraclePrice).mul(m.forcedBidPriceBuffer).mul(\n                1 ether + m.tappFeePct + m.callerFeePct\n            ); // ethDebt accounts for forcedBidPriceBuffer and potential fees\n            return m;\n        }\n    }\n\n    /**\n     * @notice Handles the set up and execution of making a forcedBid\n     * @dev Shorter will bear the cost of forcedBid on market\n     * @dev Depending on shorter's cRatio, the TAPP can attempt to fund bid\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     * @param shortHintArray Array of hintId for the id to start matching against shorts since you can't match a short < oracle price\n     *\n     */\n\n    function _performForcedBid(\n        MTypes.MarginCallPrimary memory m,\n        uint16[] memory shortHintArray\n    ) private {\n        uint256 startGas = gasleft();\n        uint88 ercAmountLeft;\n\n        //@dev Provide higher price to better ensure it can fully fill the margin call\n        uint80 _bidPrice = m.oraclePrice.mulU80(m.forcedBidPriceBuffer);\n\n        // Shorter loses leftover collateral to TAPP when unable to maintain CR above the minimum\n        m.loseCollateral = m.cRatio <= m.minimumCR;\n\n        //@dev Increase ethEscrowed by shorter's full collateral for forced bid\n        s.vaultUser[m.vault][address(this)].ethEscrowed += m.short.collateral;\n\n        // Check ability of TAPP plus short collateral to pay back ethDebt\n        if (s.vaultUser[m.vault][address(this)].ethEscrowed < m.ethDebt) {\n            uint96 ercDebtPrev = m.short.ercDebt;\n            if (s.asset[m.asset].ercDebt <= ercDebtPrev) {\n                // Occurs when only one shortRecord in the asset (market)\n                revert Errors.CannotSocializeDebt();\n            }\n            m.loseCollateral = true;\n            // @dev Max ethDebt can only be the ethEscrowed in the TAPP\n            m.ethDebt = s.vaultUser[m.vault][address(this)].ethEscrowed;\n            // Reduce ercDebt proportional to ethDebt\n            m.short.ercDebt = uint88(\n                m.ethDebt.div(_bidPrice.mul(1 ether + m.callerFeePct + m.tappFeePct))\n            ); // @dev(safe-cast)\n            uint96 ercDebtSocialized = ercDebtPrev - m.short.ercDebt;\n            // Update ercDebtRate to socialize loss (increase debt) to other shorts\n            s.asset[m.asset].ercDebtRate +=\n                ercDebtSocialized.divU64(s.asset[m.asset].ercDebt - ercDebtPrev);\n        }\n\n        // @dev MarginCall contract will be the caller. Virtual accounting done later for shorter or TAPP\n        (m.ethFilled, ercAmountLeft) = IDiamond(payable(address(this))).createForcedBid(\n            address(this), m.asset, _bidPrice, m.short.ercDebt, shortHintArray\n        );\n\n        m.ercDebtMatched = m.short.ercDebt - ercAmountLeft;\n\n        //@dev virtually burning the repurchased debt\n        s.assetUser[m.asset][address(this)].ercEscrowed -= m.ercDebtMatched;\n        s.asset[m.asset].ercDebt -= m.ercDebtMatched;\n\n        uint256 gasUsed = startGas - gasleft();\n        //@dev manually setting basefee to 1,000,000 in foundry.toml;\n        //@dev By basing gasFee off of baseFee instead of priority, adversaries are prevent from draining the TAPP\n        m.gasFee = uint88(gasUsed * block.basefee); // @dev(safe-cast)\n    }\n\n    /**\n     * @notice Handles the distribution of marginFee\n     * @dev MarginFee is taken into consideration when determining black swan\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     *\n     */\n    function _marginFeeHandler(MTypes.MarginCallPrimary memory m) private {\n        STypes.VaultUser storage VaultUser = s.vaultUser[m.vault][msg.sender];\n        STypes.VaultUser storage TAPP = s.vaultUser[m.vault][address(this)];\n        // distribute fees to TAPP and caller\n        uint88 tappFee = m.ethFilled.mulU88(m.tappFeePct);\n        uint88 callerFee = m.ethFilled.mulU88(m.callerFeePct) + m.gasFee;\n\n        m.totalFee += tappFee + callerFee;\n        //@dev TAPP already received the gasFee for being the forcedBid caller. tappFee nets out.\n        if (TAPP.ethEscrowed >= callerFee) {\n            TAPP.ethEscrowed -= callerFee;\n            VaultUser.ethEscrowed += callerFee;\n        } else {\n            // Give caller (portion of?) tappFee instead of gasFee\n            VaultUser.ethEscrowed += callerFee - m.gasFee + tappFee;\n            m.totalFee -= m.gasFee;\n            TAPP.ethEscrowed -= m.totalFee;\n        }\n    }\n\n    function min88(uint256 a, uint88 b) private pure returns (uint88) {\n        if (a > type(uint88).max) revert Errors.InvalidAmount();\n        return a < b ? uint88(a) : b;\n    }\n\n    /**\n     * @notice Handles accounting in event of full or partial liquidations\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     *\n     */\n    function _fullorPartialLiquidation(MTypes.MarginCallPrimary memory m) private {\n        uint88 decreaseCol = min88(m.totalFee + m.ethFilled, m.short.collateral);\n\n        if (m.short.ercDebt == m.ercDebtMatched) {\n            // Full liquidation\n            LibShortRecord.disburseCollateral(\n                m.asset,\n                m.shorter,\n                m.short.collateral,\n                m.short.zethYieldRate,\n                m.short.updatedAt\n            );\n            LibShortRecord.deleteShortRecord(m.asset, m.shorter, m.short.id);\n            if (!m.loseCollateral) {\n                m.short.collateral -= decreaseCol;\n                s.vaultUser[m.vault][m.shorter].ethEscrowed += m.short.collateral;\n                s.vaultUser[m.vault][address(this)].ethEscrowed -= m.short.collateral;\n            }\n        } else {\n            // Partial liquidation\n            m.short.ercDebt -= m.ercDebtMatched;\n            m.short.collateral -= decreaseCol;\n            s.shortRecords[m.asset][m.shorter][m.short.id] = m.short;\n\n            s.vaultUser[m.vault][address(this)].ethEscrowed -= m.short.collateral;\n            LibShortRecord.disburseCollateral(\n                m.asset, m.shorter, decreaseCol, m.short.zethYieldRate, m.short.updatedAt\n            );\n\n            // TAPP absorbs leftover short, unless it already owns the short\n            if (m.loseCollateral && m.shorter != address(this)) {\n                // Delete partially liquidated short\n                LibShortRecord.deleteShortRecord(m.asset, m.shorter, m.short.id);\n                // Absorb leftovers into TAPP short\n                LibShortRecord.fillShortRecord(\n                    m.asset,\n                    address(this),\n                    Constants.SHORT_STARTING_ID,\n                    SR.FullyFilled,\n                    m.short.collateral,\n                    m.short.ercDebt,\n                    s.asset[m.asset].ercDebtRate,\n                    m.short.zethYieldRate\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Helper that evaluates if a short is eligible for liquidation (i.e. flagged and within appropriate time frame)\n     * @dev Shorter has 10 hours after initial flag to bring cRatio up above maintainence margin...\n     * @dev ...After that, the flagger has 2 hours to liquidate the shorter. If short is not liquidated by shorter within that time, ANYBODY can then liquidate...\n     * @dev ...After 16 total hours have passed and the short has not been liquidated, the flag gets reset and the flagging process begins anew\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     *\n     */\n    // check if within margin call time window\n    function _canLiquidate(MTypes.MarginCallPrimary memory m)\n        private\n        view\n        returns (bool)\n    {\n        //@dev if cRatio is below the minimumCR, allow liquidation regardless of flagging\n        if (m.cRatio < m.minimumCR) return true;\n\n        //@dev Only check if flagger is empty, not updatedAt\n        if (m.short.flaggerId == 0) {\n            revert Errors.ShortNotFlagged();\n        }\n\n        /*\n         * Timeline: \n         * \n         * updatedAt (~0 hrs)\n         * ..\n         * [Errors.MarginCallIneligibleWindow]\n         * ..\n         * firstLiquidationTime (~10hrs, +10 hrs)\n         * ..\n         * [return msg.sender == short.flagger]\n         * ..\n         * secondLiquidationTime (~12hrs, +2 hrs)\n         * ..\n         * [return true (msg.sender is anyone)]\n         * ..\n         * resetLiquidationTime (~16hrs, +4 hrs)\n         * ..\n         * [return false (reset flag)]\n        */\n\n        uint256 timeDiff = LibOrders.getOffsetTimeHours() - m.short.updatedAt;\n        uint256 resetLiquidationTime = LibAsset.resetLiquidationTime(m.asset);\n\n        if (timeDiff >= resetLiquidationTime) {\n            return false;\n        } else {\n            uint256 secondLiquidationTime = LibAsset.secondLiquidationTime(m.asset);\n            bool isBetweenFirstAndSecondLiquidationTime = timeDiff\n                > LibAsset.firstLiquidationTime(m.asset) && timeDiff <= secondLiquidationTime\n                && s.flagMapping[m.short.flaggerId] == msg.sender;\n            bool isBetweenSecondAndResetLiquidationTime =\n                timeDiff > secondLiquidationTime && timeDiff <= resetLiquidationTime;\n            if (\n                !(\n                    (isBetweenFirstAndSecondLiquidationTime)\n                        || (isBetweenSecondAndResetLiquidationTime)\n                )\n            ) {\n                revert Errors.MarginCallIneligibleWindow();\n            }\n\n            return true;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/facets/MarginCall",
      "content": ""
    }
  ]
}