{
  "Title": "M-4: Attackers can create positions that have no incentive to be liquidated",
  "Content": "# Issue M-4: Attackers can create positions that have no incentive to be liquidated \n\nSource: https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/115 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nIllIllI\n## Summary\n\nThere is no incentive to liquidate tiny positions, which may lead to insolvency\n\n\n## Vulnerability Detail\n\nA well-funded attacker (e.g. a competing exchange) can create millions of positions where each position's total open notional (and thus the liquidation fee given when closing the position) is smaller than the gas cost required to liquidate it if there's a loss.\n\n\n## Impact\n\nLots of small losses are equivalent to one large loss, which will lead to bad debt that the exchange will have to cover in order to allow others to withdraw from the PnL pool\n\n\n## Code Snippet\n\nThere is [no](https://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/config/Config.sol) minimum position size, and the liquidation incentive is based on the total open notional (average cost to open):\n```solidity\n// File: src/clearingHouse/LibLiquidation.sol : LibLiquidation.getPenalty()   #1\n\n73        /// @notice penalty = liquidatedPositionNotionalDelta * liquidationPenaltyRatio, shared by liquidator and protocol\n74        /// liquidationFeeToLiquidator = penalty * liquidation fee ratio. the rest to the protocol\n75        function getPenalty(\n76            MaintenanceMarginProfile memory self,\n77            uint256 liquidatedPositionSizeDelta\n78        ) internal view returns (uint256, uint256) {\n79            // reduced percentage = toBeLiquidated / oldSize\n80            // liquidatedPositionNotionalDelta = oldOpenNotional * percentage = oldOpenNotional * toBeLiquidated / oldSize\n81            // penalty = liquidatedPositionNotionalDelta * liquidationPenaltyRatio\n82            uint256 openNotionalAbs = self.openNotional.abs();\n83 @>         uint256 liquidatedNotionalMulWad = openNotionalAbs * liquidatedPositionSizeDelta;\n84            uint256 penalty = liquidatedNotionalMulWad.mulWad(self.liquidationPenaltyRatio) / self.positionSize.abs();\n85            uint256 liquidationFeeToLiquidator = penalty.mulWad(self.liquidationFeeRatio);\n86            uint256 liquidationFeeToProtocol = penalty - liquidationFeeToLiquidator;\n87            return (liquidationFeeToLiquidator, liquidationFeeToProtocol);\n88:       }\n```\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/clearingHouse/LibLiquidation.sol#L73-L88\n\nFurthermore, even if somehow gas costs were free, the `mulWad()` used to calculate the penalty/fee rounds _down_ the total penalty as well as the portion that the liquidator gets, so one-wei open notionals will have a penalty payment of zero to the liquidator\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nHave a minimum total open notional for positions, to ensure there's a large enough fee to overcome liquidation gas costs. Also round up the fee\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**santipu_** commented:\n> Low - Gas fees on L2s are cheap, now more with Dencun update. An hypothetical attacker should use trillions of different addresses without gaining any profit doing it.\n\n**takarez** commented:\n>  POC of such attacked would have helped.\n\n\n\n**santipu03**\n\nEscalate\n\nI believe this issue should be LOW because of the impracticality of the attack. \n\nThe Perpetual protocol will be deployed on Optimism/Blast, where the gas costs are tiny, now even more with the Dencun update. To execute such an attack, one would need an insane amount of different addresses to even have a possibility of causing some bad debt, we're probably talking about billions of different addresses. \n\n**sherlock-admin2**\n\n> Escalate\n> \n> I believe this issue should be LOW because of the impracticality of the attack. \n> \n> The Perpetual protocol will be deployed on Optimism/Blast, where the gas costs are tiny, now even more with the Dencun update. To execute such an attack, one would need an insane amount of different addresses to even have a possibility of causing some bad debt, we're probably talking about billions of different addresses. \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\n@IllIllI000 Could you present a numerical scenario where this attack is practical?\n\n**IllIllI000**\n\nEscalate\n\nI believe this issue (#115) should have at least as high a severity as #112.\n\nTo address the above escalation on feasibility:\nIf you look at transactions relating to the [pyth oracle](https://optimistic.etherscan.io/address/0xff1a0f4744e8582DF1aE09D5611b887B6a12925C#internaltx), they're mostly related to synthetix transactions (synthetix is a perpetual futures DEX, just like perpetual), and most of executions that are similar to what a perpetual liquidation would be, are for ~$0.40-$0.60, (e.g. [this one](https://optimistic.etherscan.io/tx/0x95c85b339a8a16d4cb3b44b0585c8efe3f5cd6826763c9e07000dc42889f8d0e)). If you look through the tests, the expected liquidation penalty is 2.5%, and the penalty is split 50-50 with the protocol, so in order to hit this scenario, you'd be able to submit an order for $0.50 / 0.025 / 0.5 = $40.00 and not have to fear being liquidated, because the fee the liquidator would get would be less than the gas cost to liquidate. $40 is small enough that this scenario will likely happen organically, when traders open high-leverage trades against small account values, as is often done on DEXes. Alternatively, a determined attacker can create 1000 such transactions to reach a position size of $40k, with a cost of only $500 in transaction fees, plus whatever the current margin requirements are.\n\nWhy #115 should be at least as high as #112:\nBoth issues describe scenarios in which a trader can create positions where there is higher risk than the normal risk parameters would allow them to, without having to worry about being liquidated. In both cases, the risk is that bad debt will be created before the position is liquidated. Both issues can be somewhat mitigated by the admin changing the risk parameters (either the margin requirements for #112, or the liquidation penalty for #115), and in both cases the admin can specifically manually target specific positions by sandwiching them with changes to the parameter and doing the liquidation in between the sandwich, in order to avoid the parameters affecting other users. Both issues can be used together by the same attacker to increase the risk of the position over what is possible with only one, but fixing one does not fix the other. Both would require off-chain monitoring to apply the sandwich workarounds, whenever the issue pops up, but I believe #115 would occur _more_ frequently, since it can happen by accident.\n\nI submitted #115 as Med since the admin could decide to override the normal parameters, as is described above, and #112 has the same workaround, so they should have the same severity. If one is a High, the other is too.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> I believe this issue (#115) should have at least as high a severity as #112.\n> \n> To address the above escalation on feasibility:\n> If you look at transactions relating to the [pyth oracle](https://optimistic.etherscan.io/address/0xff1a0f4744e8582DF1aE09D5611b887B6a12925C#internaltx), they're mostly related to synthetix transactions (synthetix is a perpetual futures DEX, just like perpetual), and most of executions that are similar to what a perpetual liquidation would be, are for ~$0.40-$0.60, (e.g. [this one](https://optimistic.etherscan.io/tx/0x95c85b339a8a16d4cb3b44b0585c8efe3f5cd6826763c9e07000dc42889f8d0e)). If you look through the tests, the expected liquidation penalty is 2.5%, and the penalty is split 50-50 with the protocol, so in order to hit this scenario, you'd be able to submit an order for $0.50 / 0.025 / 0.5 = $40.00 and not have to fear being liquidated, because the fee the liquidator would get would be less than the gas cost to liquidate. $40 is small enough that this scenario will likely happen organically, when traders open high-leverage trades against small account values, as is often done on DEXes. Alternatively, a determined attacker can create 1000 such transactions to reach a position size of $40k, with a cost of only $500 in transaction fees, plus whatever the current margin requirements are.\n> \n> Why #115 should be at least as high as #112:\n> Both issues describe scenarios in which a trader can create positions where there is higher risk than the normal risk parameters would allow them to, without having to worry about being liquidated. In both cases, the risk is that bad debt will be created before the position is liquidated. Both issues can be somewhat mitigated by the admin changing the risk parameters (either the margin requirements for #112, or the liquidation penalty for #115), and in both cases the admin can specifically manually target specific positions by sandwiching them with changes to the parameter and doing the liquidation in between the sandwich, in order to avoid the parameters affecting other users. Both issues can be used together by the same attacker to increase the risk of the position over what is possible with only one, but fixing one does not fix the other. Both would require off-chain monitoring to apply the sandwich workarounds, whenever the issue pops up, but I believe #115 would occur _more_ frequently, since it can happen by accident.\n> \n> I submitted #115 as Med since the admin could decide to override the normal parameters, as is described above, and #112 has the same workaround, so they should have the same severity. If one is a High, the other is too.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\n@paco0x The following impact presented seems extremely concerning, however, given admin has workaround to mitigate the issue, I believe both this issue and #112 should remain as medium severity issues.\n\n> Alternatively, a determined attacker can create 1000 such transactions to reach a position size of $40k, with a cost of only $500 in transaction fees, plus whatever the current margin requirements are.\n\n**paco0x**\n\n> @paco0x The following impact presented seems extremely concerning, however, given admin has workaround to mitigate the issue, I believe both this issue and #112 should remain as medium severity issues.\n> \n> > Alternatively, a determined attacker can create 1000 such transactions to reach a position size of $40k, with a cost of only $500 in transaction fees, plus whatever the current margin requirements are.\n\nThanks for the reminder, we're aware of this issue and have already implemented a minimum requirement for opening positions in our latest code.\n\nI'm not sure the severity level for this issue under Sherlock's rules. Personally, I think it isn't an incentive for attackers for these behaviors. But anyway, we already fixed it and will let you guys decide the severity level of it.\n\n**detectiveking123**\n\nIssue is invalid. You also see the same thing with Aave; a bunch of small bad debt positions that no one cares to liquidate. It's highly unrealistic for this to ever happen because of how unprofitable it is for the attacker. \n\n**WangSecurity**\n\nI believe medium severity issue as appropriate here based on the comment [here](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/115#issuecomment-2052727976) by the Lead Judge. Moreover, as I understand it can be used by regular users to create many small positions instead of one big and not fear liquidation. Taking in the fact that there is a workaround by admins to mitigate the issue, planning to reject the escalation and leave the issue as it is.\n\n**Evert0x**\n\nResult:\nMedium \nUnique\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [santipu03](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/115/#issuecomment-2037981049): rejected\n- [IllIllI000](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/115/#issuecomment-2041111535): rejected\n\n**IllIllI000**\n\nThe sponsor acknowledges that $10 is less than the [example](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/115#issuecomment-2041111535) of $40, so the risk is still present. The minimum amount will also depend on the minimum percentage use for the fee split between the liquidator and the protocol. The sponsor also acknowledges that allowlisted makers may be able to exploit this issue. The sponsor plans to start out running their own liquidators, and may change the value in a future upgrade.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/219",
  "Code": [
    {
      "filename": "perp-contract-v3/src/clearingHouse/LibLiquidation.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\nimport { WAD } from \"../common/LibConstant.sol\";\n\n/// @param accountValue based on price\nstruct MaintenanceMarginProfile {\n    uint256 price;\n    int256 positionSize;\n    int256 openNotional;\n    int256 accountValue;\n    int256 maintenanceMarginRequirement;\n    uint256 liquidationPenaltyRatio;\n    uint256 liquidationFeeRatio;\n}\n\nstruct LiquidationResult {\n    int256 liquidatedPositionSizeDelta;\n    int256 liquidatedPositionNotionalDelta;\n    uint256 penalty;\n    uint256 feeToLiquidator;\n    uint256 feeToProtocol;\n}\n\n// 100 USD in WAD\nuint256 constant _MIN_PARTIAL_LIQUIDATE_POSITION_VALUE = 100 * WAD;\n\nlibrary LibLiquidation {\n    using SafeCast for uint256;\n    using FixedPointMathLib for uint256;\n    using FixedPointMathLib for int256;\n    using LibLiquidation for MaintenanceMarginProfile;\n\n    function getLiquidationResult(\n        MaintenanceMarginProfile memory self,\n        uint256 sizeRequestedFromLiquidator\n    ) internal view returns (LiquidationResult memory) {\n        uint256 liquidatedPositionSizeDeltaAbs = self.getLiquidatedPositionSizeDelta(sizeRequestedFromLiquidator);\n        if (liquidatedPositionSizeDeltaAbs == 0) {\n            return\n                LiquidationResult({\n                    liquidatedPositionSizeDelta: 0,\n                    liquidatedPositionNotionalDelta: 0,\n                    penalty: 0,\n                    feeToLiquidator: 0,\n                    feeToProtocol: 0\n                });\n        }\n        uint256 liquidatedPositionNotionalDeltaAbs = self.getLiquidatedNotionalDelta(liquidatedPositionSizeDeltaAbs);\n        (uint256 feeToLiquidator, uint256 liquidationFeeToProtocol) = self.getPenalty(liquidatedPositionSizeDeltaAbs);\n\n        // if liquidated position was long, liquidation order is short\n        bool isLiquidatedPositionLong = self.positionSize > 0;\n        int256 liquidatedPositionSizeDelta = isLiquidatedPositionLong\n            ? -liquidatedPositionSizeDeltaAbs.toInt256()\n            : liquidatedPositionSizeDeltaAbs.toInt256();\n        int256 liquidatedPositionNotionalDelta = isLiquidatedPositionLong\n            ? liquidatedPositionNotionalDeltaAbs.toInt256()\n            : -liquidatedPositionNotionalDeltaAbs.toInt256();\n\n        return\n            LiquidationResult({\n                liquidatedPositionSizeDelta: liquidatedPositionSizeDelta,\n                liquidatedPositionNotionalDelta: liquidatedPositionNotionalDelta,\n                penalty: feeToLiquidator + liquidationFeeToProtocol,\n                feeToLiquidator: feeToLiquidator,\n                feeToProtocol: liquidationFeeToProtocol\n            });\n    }\n\n    /// @notice penalty = liquidatedPositionNotionalDelta * liquidationPenaltyRatio, shared by liquidator and protocol\n    /// liquidationFeeToLiquidator = penalty * liquidation fee ratio. the rest to the protocol\n    function getPenalty(\n        MaintenanceMarginProfile memory self,\n        uint256 liquidatedPositionSizeDelta\n    ) internal view returns (uint256, uint256) {\n        // reduced percentage = toBeLiquidated / oldSize\n        // liquidatedPositionNotionalDelta = oldOpenNotional * percentage = oldOpenNotional * toBeLiquidated / oldSize\n        // penalty = liquidatedPositionNotionalDelta * liquidationPenaltyRatio\n        uint256 openNotionalAbs = self.openNotional.abs();\n        uint256 liquidatedNotionalMulWad = openNotionalAbs * liquidatedPositionSizeDelta;\n        uint256 penalty = liquidatedNotionalMulWad.mulWad(self.liquidationPenaltyRatio) / self.positionSize.abs();\n        uint256 liquidationFeeToLiquidator = penalty.mulWad(self.liquidationFeeRatio);\n        uint256 liquidationFeeToProtocol = penalty - liquidationFeeToLiquidator;\n        return (liquidationFeeToLiquidator, liquidationFeeToProtocol);\n    }\n\n    /// @notice liquidatable if accountValue < openNotionalAbs * mmRatio\n    function getLiquidatablePositionSize(MaintenanceMarginProfile memory self) internal view returns (int256) {\n        // No liquidatable position\n        if (\n            self.accountValue >= self.maintenanceMarginRequirement ||\n            self.positionSize == 0 ||\n            self.maintenanceMarginRequirement == 0\n        ) {\n            return 0;\n        }\n\n        // Liquidate the entire position if its value is small enough\n        // to prevent tiny positions left in the system\n        uint256 positionValueAbs = self.positionSize.abs().mulWad(self.price);\n        if (positionValueAbs <= _MIN_PARTIAL_LIQUIDATE_POSITION_VALUE) {\n            return self.positionSize;\n        }\n\n        // Liquidator can only take over half of position if margin ratio is â‰¥ half of mmRatio.\n        // If margin ratio < half of mmRatio, liquidator can take over the entire position.\n        if (self.accountValue < self.maintenanceMarginRequirement / 2) {\n            return self.positionSize;\n        }\n        return self.positionSize / 2;\n    }\n\n    /// @dev min(given position size, liquidatable position size)\n    function getLiquidatedPositionSizeDelta(\n        MaintenanceMarginProfile memory self,\n        uint256 sizeRequestedFromLiquidator\n    ) internal view returns (uint256) {\n        // if liquidator request to liquidate more than liquidatable size, liquidate all liquidatable size\n        uint256 liquidatableSizeAbs = self.getLiquidatablePositionSize().abs();\n        if (sizeRequestedFromLiquidator >= liquidatableSizeAbs) {\n            return liquidatableSizeAbs;\n        }\n\n        // if liquidatable size is larger than what liquidator requested, liquidate what liquidator requested\n        return sizeRequestedFromLiquidator;\n    }\n\n    /// @dev Open notional has negative signage vs position size delta\n    function getLiquidatedNotionalDelta(\n        MaintenanceMarginProfile memory self,\n        uint256 liquidatedPositionSizeDeltaAbs\n    ) internal pure returns (uint256) {\n        return liquidatedPositionSizeDeltaAbs.mulWad(self.price);\n    }\n}"
    }
  ]
}