{
  "Title": "Early Initiation of Grace Period Prevents Creator's Ability to Withdraw Funds via Clawback",
  "Content": "# Early Initiation of Grace Period Prevents Creator's Ability to Withdraw Funds via Clawback\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-05-Sablier/blob/43d7e752a68bba2a1d73d3d6466c3059079ed0c6/v2-periphery/src/abstracts/SablierV2MerkleLockup.sol#L109\">https://github.com/Cyfrin/2024-05-Sablier/blob/43d7e752a68bba2a1d73d3d6466c3059079ed0c6/v2-periphery/src/abstracts/SablierV2MerkleLockup.sol#L109</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-05-Sablier/blob/43d7e752a68bba2a1d73d3d6466c3059079ed0c6/v2-periphery/src/abstracts/SablierV2MerkleLockup.sol#L150\">https://github.com/Cyfrin/2024-05-Sablier/blob/43d7e752a68bba2a1d73d3d6466c3059079ed0c6/v2-periphery/src/abstracts/SablierV2MerkleLockup.sol#L150</a>\n\n\n## Summary\nThis issue arises when a campaign creator chooses to deploy the campaign first and fund it later. If a malicious recipient funds the Merkle Lockup contract immediately after deployment and triggers the `claim()` function, the grace period starts prematurely by setting the `_firstClaimTime` to the current `block.timestamp`. Consequently, the creator risks missing the window to call the `clawback` function. In the scenario where the creator funds the campaign after the grace period ends and then realizes there's a malicious value in the merkle tree, they won't be able to call the `clawback` function, leaving the funds exposed to risk if a malicious Merkle tree is detected.\n\n## Vulnerability Details\nAfter the creator deploys a campaign, a grace period begins after the first claim. This is done by setting `_firstClaimTime` to `uint40(block.timestamp)`[Link to code](https://github.com/Cyfrin/2024-05-Sablier/blob/43d7e752a68bba2a1d73d3d6466c3059079ed0c6/v2-periphery/src/abstracts/SablierV2MerkleLockup.sol#L150).\n\nDuring the grace period, which lasts for 7 days, the creator can withdraw the funds by calling `clawback()` in case of a malicious Merkle tree:\n> In case of a malicious Merkle tree, clawback can be called to withdraw funds from the deployed MerkleLockup contracts until the grace period ends\n\nAlso according to [the protocols documentations](https://docs.sablier.com/concepts/protocol/airstreams#how-it-works) creators are able to deploy the campaign and fund it later:\n> Additionally, you don't have to immediately fund the Airstream contract. You can just create the contract and at a later date fund it with the airdropped tokens.\n\nThe problem arises when a creator deploys a campaign and plans to fund it later. A malicious recipient can exploit this by funding the Merkle lockup contract right after deployment and calling `claim()`, which will prematurely start the grace period by setting `_firstClaimTime` to the current `block.timestamp`. This premature initiation of the grace period disrupts the intended sequence.\nIf the creator funds the campaign after the grace period ends and realizes there's a malicious value in the Merkle tree, they won't be able to call the `clawback` function, leaving the funds exposed to risk if a malicious Merkle tree is detected.\n\n### Example Scenario\n- Alice (the creator) deploys a campaign but plans to fund it later.\n- Bob (a malicious recipient) funds the campaign right after deployment and calls `claim()` with his actual parameters (index, recipient, amount, and merkleProof).\n- Bob's claim will start the grace period.\n- A few days later (let's say 8 days), Alice funds the campaign but then realizes there's a malicious value in the Merkle tree, so she attempts to withdraw the funds by calling `clawback()`. However, her transaction reverts because the grace period has ended.\n\n### Coded PoC\nTo test the scenario please make a file named `Ninja.t.sol` in this path: `/v2-periphery/test/integration/merkle-lockup/` and paste the following test code in it:\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.22;\n\nimport { ISablierV2MerkleLT } from \"src/interfaces/ISablierV2MerkleLT.sol\";\nimport { Errors } from \"src/libraries/Errors.sol\";\nimport { Integration_Test } from \"../Integration.t.sol\";\n\ncontract Ninja is Integration_Test {\n    function setUp() public virtual override {\n        Integration_Test.setUp();\n        deal({ token: address(dai), to: users.recipient1, give: defaults.CLAIM_AMOUNT() });\n    }\n\n    function test_clawbackFailedAfterEarlyClaim() external {\n        // Admin creates the campaign (Deploying the merkleLT)\n        merkleLT = createMerkleLT();\n\n        // merkleLT isn't funded yet\n        assert(dai.balanceOf(address(merkleLT)) == 0);\n\n        // Bob immediately funds the Merkle Lockup equal to his claim amount and then calls the claim()\n        // Grace period starts from now\n        vm.startPrank(users.recipient1);\n        dai.transfer(address(merkleLT), defaults.CLAIM_AMOUNT());\n        claimLT();\n        vm.stopPrank();\n\n        // 8 days later the Admin funds the merkleLT to airdrop the tokens\n        vm.warp({ newTimestamp: block.timestamp + 10 days });\n        vm.prank(users.admin);\n        deal({ token: address(dai), to: address(merkleLT), give: defaults.AGGREGATE_AMOUNT() });\n\n        // Admin realizes the merkle tree is incorrect/malicious and calls the clawback() to retrieve the funds\n        // but the transaction reverts because the grace period has ended\n        uint128 clawbackAmount = uint128(dai.balanceOf(address(merkleLT)));\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                Errors.SablierV2MerkleLockup_ClawbackNotAllowed.selector,\n                block.timestamp,\n                defaults.EXPIRATION(),\n                defaults.FIRST_CLAIM_TIME()\n            )\n        );\n        vm.prank(users.admin);\n        merkleLT.clawback({ to: users.admin, amount: clawbackAmount });\n    }\n\n    ////////////////////////////////////////////////////////////////\n    ////////////////////  INTERNAL FUNCTIONS  //////////////////////\n    ////////////////////////////////////////////////////////////////\n\n    function createMerkleLT() internal returns (ISablierV2MerkleLT) {\n        return createMerkleLT(users.admin, defaults.EXPIRATION());\n    }\n\n    function createMerkleLT(address admin, uint40 expiration) internal returns (ISablierV2MerkleLT) {\n        // Increment the CREATE nonce for factory contract.\n        ++merkleLockupFactoryNonce;\n\n        return merkleLockupFactory.createMerkleLT({\n            baseParams: defaults.baseParams(admin, dai, expiration, defaults.MERKLE_ROOT()),\n            lockupTranched: lockupTranched,\n            tranchesWithPercentages: defaults.tranchesWithPercentages(),\n            aggregateAmount: defaults.AGGREGATE_AMOUNT(),\n            recipientCount: defaults.RECIPIENT_COUNT()\n        });\n    }\n\n    function claimLT() internal returns (uint256) {\n        return merkleLT.claim({\n            index: defaults.INDEX1(),\n            recipient: users.recipient1,\n            amount: defaults.CLAIM_AMOUNT(),\n            merkleProof: defaults.index1Proof()\n        });\n    }\n}\n```\nRun the test:\n```\nforge test --match-test test_clawbackFailedAfterEarlyClaim\n```\n## Impact\nThe premature initiation of the grace period allows malicious users to exploit the system, leaving creators unable to withdraw funds during the intended window. Consequently, if a malicious Merkle tree is detected after the grace period, the creator loses the ability to claw back funds, leaving them exposed to potential losses.\n\n## Tools Used\nVSCode\nFoundry\n\n## Recommendations\nOne possible solution is to define a funding function to fund the campaign and a modifier to check whether the campaign is funded by the admin or not. In this case, if anyone other than the admin directly funds the campaign, they would simply lose their money because `isFunded` would not be true.\n\nSablierV2MerkleLockup.sol\n```diff\ndiff --git a/SablierV2MerkleLockup.sol.orig b/SablierV2MerkleLockup.sol\nindex cd5c178..de04894 100644\n--- a/SablierV2MerkleLockup.sol.orig\n+++ b/SablierV2MerkleLockup.sol\n@@ -42,6 +42,8 @@ abstract contract SablierV2MerkleLockup is\n     /// @inheritdoc ISablierV2MerkleLockup\n     bool public immutable override TRANSFERABLE;\n \n+    bool public isFunded;\n+\n     /// @inheritdoc ISablierV2MerkleLockup\n     string public ipfsCID;\n \n@@ -103,6 +105,18 @@ abstract contract SablierV2MerkleLockup is\n                          USER-FACING NON-CONSTANT FUNCTIONS\n     //////////////////////////////////////////////////////////////////////////*/\n \n+    modifier onlyFunded() {\n+        if (!isFunded) {\n+            revert(\"The campaign is not funded yet\");\n+        }\n+        _;\n+    }\n+\n+    function fund(uint256 amount) external onlyAdmin {\n+        ASSET.safeTransferFrom(msg.sender, address(this), amount);\n+        if (!isFunded) isFunded = true;\n+    }\n+\n     /// @inheritdoc ISablierV2MerkleLockup\n     function clawback(address to, uint128 amount) external override onlyAdmin {\n         // Check: current timestamp is over the grace period and the campaign has not expired.\n```\n\nSablierV2MerkleLT.sol\n```diff\ndiff --git a/SablierV2MerkleLT.sol.orig b/SablierV2MerkleLT.sol\nindex 7d091f5..ae28403 100644\n--- a/SablierV2MerkleLT.sol.orig\n+++ b/SablierV2MerkleLT.sol\n@@ -79,6 +79,7 @@ contract SablierV2MerkleLT is\n     )\n         external\n         override\n+        onlyFunded\n         returns (uint256 streamId)\n     {\n         // Generate the Merkle tree leaf by hashing the corresponding parameters. Hashing twice prevents second\n```",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clvb9njmy00012dqjyaavpl44",
  "Code": [
    {
      "filename": "v2-periphery/src/abstracts/SablierV2MerkleLockup.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.22;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport { BitMaps } from \"@openzeppelin/contracts/utils/structs/BitMaps.sol\";\nimport { Adminable } from \"@sablier/v2-core/src/abstracts/Adminable.sol\";\n\nimport { ISablierV2MerkleLockup } from \"../interfaces/ISablierV2MerkleLockup.sol\";\nimport { MerkleLockup } from \"../types/DataTypes.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\n\n/// @title SablierV2MerkleLockup\n/// @notice See the documentation in {ISablierV2MerkleLockup}.\nabstract contract SablierV2MerkleLockup is\n    ISablierV2MerkleLockup, // 2 inherited component\n    Adminable // 1 inherited component\n{\n    using BitMaps for BitMaps.BitMap;\n    using SafeERC20 for IERC20;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                  STATE VARIABLES\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    IERC20 public immutable override ASSET;\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    bool public immutable override CANCELABLE;\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    uint40 public immutable override EXPIRATION;\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    bytes32 public immutable override MERKLE_ROOT;\n\n    /// @dev The name of the campaign stored as bytes32.\n    bytes32 internal immutable NAME;\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    bool public immutable override TRANSFERABLE;\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    string public ipfsCID;\n\n    /// @dev Packed booleans that record the history of claims.\n    BitMaps.BitMap internal _claimedBitMap;\n\n    /// @dev The timestamp when the first claim is made.\n    uint40 internal _firstClaimTime;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Constructs the contract by initializing the immutable state variables.\n    constructor(MerkleLockup.ConstructorParams memory params) {\n        // Check: the campaign name is not greater than 32 bytes\n        if (bytes(params.name).length > 32) {\n            revert Errors.SablierV2MerkleLockup_CampaignNameTooLong({\n                nameLength: bytes(params.name).length,\n                maxLength: 32\n            });\n        }\n\n        admin = params.initialAdmin;\n        ASSET = params.asset;\n        CANCELABLE = params.cancelable;\n        EXPIRATION = params.expiration;\n        ipfsCID = params.ipfsCID;\n        MERKLE_ROOT = params.merkleRoot;\n        NAME = bytes32(abi.encodePacked(params.name));\n        TRANSFERABLE = params.transferable;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                           USER-FACING CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    function getFirstClaimTime() external view override returns (uint40) {\n        return _firstClaimTime;\n    }\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    function hasClaimed(uint256 index) public view override returns (bool) {\n        return _claimedBitMap.get(index);\n    }\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    function hasExpired() public view override returns (bool) {\n        return EXPIRATION > 0 && EXPIRATION <= block.timestamp;\n    }\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    function name() external view override returns (string memory) {\n        return string(abi.encodePacked(NAME));\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                         USER-FACING NON-CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    function clawback(address to, uint128 amount) external override onlyAdmin {\n        // Check: current timestamp is over the grace period and the campaign has not expired.\n        if (_hasGracePeriodPassed() && !hasExpired()) {\n            revert Errors.SablierV2MerkleLockup_ClawbackNotAllowed({\n                blockTimestamp: block.timestamp,\n                expiration: EXPIRATION,\n                firstClaimTime: _firstClaimTime\n            });\n        }\n\n        // Effect: transfer the tokens to the provided address.\n        ASSET.safeTransfer(to, amount);\n\n        // Log the clawback.\n        emit Clawback(admin, to, amount);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                            INTERNAL CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Validates the parameters of the `claim` function, which is implemented by child contracts.\n    function _checkClaim(uint256 index, bytes32 leaf, bytes32[] calldata merkleProof) internal {\n        // Check: the campaign has not expired.\n        if (hasExpired()) {\n            revert Errors.SablierV2MerkleLockup_CampaignExpired({\n                blockTimestamp: block.timestamp,\n                expiration: EXPIRATION\n            });\n        }\n\n        // Check: the index has not been claimed.\n        if (_claimedBitMap.get(index)) {\n            revert Errors.SablierV2MerkleLockup_StreamClaimed(index);\n        }\n\n        // Check: the input claim is included in the Merkle tree.\n        if (!MerkleProof.verify(merkleProof, MERKLE_ROOT, leaf)) {\n            revert Errors.SablierV2MerkleLockup_InvalidProof();\n        }\n\n        // Effect: set the `_firstClaimTime` if its zero.\n        if (_firstClaimTime == 0) {\n            _firstClaimTime = uint40(block.timestamp);\n        }\n    }\n\n    /// @notice Returns a flag indicating whether the grace period has passed.\n    /// @dev The grace period is 7 days after the first claim.\n    function _hasGracePeriodPassed() internal view returns (bool) {\n        return _firstClaimTime > 0 && block.timestamp > _firstClaimTime + 7 days;\n    }\n}"
    },
    {
      "filename": "v2-periphery/src/abstracts/SablierV2MerkleLockup.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.22;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport { BitMaps } from \"@openzeppelin/contracts/utils/structs/BitMaps.sol\";\nimport { Adminable } from \"@sablier/v2-core/src/abstracts/Adminable.sol\";\n\nimport { ISablierV2MerkleLockup } from \"../interfaces/ISablierV2MerkleLockup.sol\";\nimport { MerkleLockup } from \"../types/DataTypes.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\n\n/// @title SablierV2MerkleLockup\n/// @notice See the documentation in {ISablierV2MerkleLockup}.\nabstract contract SablierV2MerkleLockup is\n    ISablierV2MerkleLockup, // 2 inherited component\n    Adminable // 1 inherited component\n{\n    using BitMaps for BitMaps.BitMap;\n    using SafeERC20 for IERC20;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                  STATE VARIABLES\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    IERC20 public immutable override ASSET;\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    bool public immutable override CANCELABLE;\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    uint40 public immutable override EXPIRATION;\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    bytes32 public immutable override MERKLE_ROOT;\n\n    /// @dev The name of the campaign stored as bytes32.\n    bytes32 internal immutable NAME;\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    bool public immutable override TRANSFERABLE;\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    string public ipfsCID;\n\n    /// @dev Packed booleans that record the history of claims.\n    BitMaps.BitMap internal _claimedBitMap;\n\n    /// @dev The timestamp when the first claim is made.\n    uint40 internal _firstClaimTime;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Constructs the contract by initializing the immutable state variables.\n    constructor(MerkleLockup.ConstructorParams memory params) {\n        // Check: the campaign name is not greater than 32 bytes\n        if (bytes(params.name).length > 32) {\n            revert Errors.SablierV2MerkleLockup_CampaignNameTooLong({\n                nameLength: bytes(params.name).length,\n                maxLength: 32\n            });\n        }\n\n        admin = params.initialAdmin;\n        ASSET = params.asset;\n        CANCELABLE = params.cancelable;\n        EXPIRATION = params.expiration;\n        ipfsCID = params.ipfsCID;\n        MERKLE_ROOT = params.merkleRoot;\n        NAME = bytes32(abi.encodePacked(params.name));\n        TRANSFERABLE = params.transferable;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                           USER-FACING CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    function getFirstClaimTime() external view override returns (uint40) {\n        return _firstClaimTime;\n    }\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    function hasClaimed(uint256 index) public view override returns (bool) {\n        return _claimedBitMap.get(index);\n    }\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    function hasExpired() public view override returns (bool) {\n        return EXPIRATION > 0 && EXPIRATION <= block.timestamp;\n    }\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    function name() external view override returns (string memory) {\n        return string(abi.encodePacked(NAME));\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                         USER-FACING NON-CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    function clawback(address to, uint128 amount) external override onlyAdmin {\n        // Check: current timestamp is over the grace period and the campaign has not expired.\n        if (_hasGracePeriodPassed() && !hasExpired()) {\n            revert Errors.SablierV2MerkleLockup_ClawbackNotAllowed({\n                blockTimestamp: block.timestamp,\n                expiration: EXPIRATION,\n                firstClaimTime: _firstClaimTime\n            });\n        }\n\n        // Effect: transfer the tokens to the provided address.\n        ASSET.safeTransfer(to, amount);\n\n        // Log the clawback.\n        emit Clawback(admin, to, amount);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                            INTERNAL CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Validates the parameters of the `claim` function, which is implemented by child contracts.\n    function _checkClaim(uint256 index, bytes32 leaf, bytes32[] calldata merkleProof) internal {\n        // Check: the campaign has not expired.\n        if (hasExpired()) {\n            revert Errors.SablierV2MerkleLockup_CampaignExpired({\n                blockTimestamp: block.timestamp,\n                expiration: EXPIRATION\n            });\n        }\n\n        // Check: the index has not been claimed.\n        if (_claimedBitMap.get(index)) {\n            revert Errors.SablierV2MerkleLockup_StreamClaimed(index);\n        }\n\n        // Check: the input claim is included in the Merkle tree.\n        if (!MerkleProof.verify(merkleProof, MERKLE_ROOT, leaf)) {\n            revert Errors.SablierV2MerkleLockup_InvalidProof();\n        }\n\n        // Effect: set the `_firstClaimTime` if its zero.\n        if (_firstClaimTime == 0) {\n            _firstClaimTime = uint40(block.timestamp);\n        }\n    }\n\n    /// @notice Returns a flag indicating whether the grace period has passed.\n    /// @dev The grace period is 7 days after the first claim.\n    function _hasGracePeriodPassed() internal view returns (bool) {\n        return _firstClaimTime > 0 && block.timestamp > _firstClaimTime + 7 days;\n    }\n}"
    },
    {
      "filename": "v2-periphery/src/abstracts/SablierV2MerkleLockup.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.22;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport { BitMaps } from \"@openzeppelin/contracts/utils/structs/BitMaps.sol\";\nimport { Adminable } from \"@sablier/v2-core/src/abstracts/Adminable.sol\";\n\nimport { ISablierV2MerkleLockup } from \"../interfaces/ISablierV2MerkleLockup.sol\";\nimport { MerkleLockup } from \"../types/DataTypes.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\n\n/// @title SablierV2MerkleLockup\n/// @notice See the documentation in {ISablierV2MerkleLockup}.\nabstract contract SablierV2MerkleLockup is\n    ISablierV2MerkleLockup, // 2 inherited component\n    Adminable // 1 inherited component\n{\n    using BitMaps for BitMaps.BitMap;\n    using SafeERC20 for IERC20;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                  STATE VARIABLES\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    IERC20 public immutable override ASSET;\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    bool public immutable override CANCELABLE;\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    uint40 public immutable override EXPIRATION;\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    bytes32 public immutable override MERKLE_ROOT;\n\n    /// @dev The name of the campaign stored as bytes32.\n    bytes32 internal immutable NAME;\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    bool public immutable override TRANSFERABLE;\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    string public ipfsCID;\n\n    /// @dev Packed booleans that record the history of claims.\n    BitMaps.BitMap internal _claimedBitMap;\n\n    /// @dev The timestamp when the first claim is made.\n    uint40 internal _firstClaimTime;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Constructs the contract by initializing the immutable state variables.\n    constructor(MerkleLockup.ConstructorParams memory params) {\n        // Check: the campaign name is not greater than 32 bytes\n        if (bytes(params.name).length > 32) {\n            revert Errors.SablierV2MerkleLockup_CampaignNameTooLong({\n                nameLength: bytes(params.name).length,\n                maxLength: 32\n            });\n        }\n\n        admin = params.initialAdmin;\n        ASSET = params.asset;\n        CANCELABLE = params.cancelable;\n        EXPIRATION = params.expiration;\n        ipfsCID = params.ipfsCID;\n        MERKLE_ROOT = params.merkleRoot;\n        NAME = bytes32(abi.encodePacked(params.name));\n        TRANSFERABLE = params.transferable;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                           USER-FACING CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    function getFirstClaimTime() external view override returns (uint40) {\n        return _firstClaimTime;\n    }\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    function hasClaimed(uint256 index) public view override returns (bool) {\n        return _claimedBitMap.get(index);\n    }\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    function hasExpired() public view override returns (bool) {\n        return EXPIRATION > 0 && EXPIRATION <= block.timestamp;\n    }\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    function name() external view override returns (string memory) {\n        return string(abi.encodePacked(NAME));\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                         USER-FACING NON-CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2MerkleLockup\n    function clawback(address to, uint128 amount) external override onlyAdmin {\n        // Check: current timestamp is over the grace period and the campaign has not expired.\n        if (_hasGracePeriodPassed() && !hasExpired()) {\n            revert Errors.SablierV2MerkleLockup_ClawbackNotAllowed({\n                blockTimestamp: block.timestamp,\n                expiration: EXPIRATION,\n                firstClaimTime: _firstClaimTime\n            });\n        }\n\n        // Effect: transfer the tokens to the provided address.\n        ASSET.safeTransfer(to, amount);\n\n        // Log the clawback.\n        emit Clawback(admin, to, amount);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                            INTERNAL CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Validates the parameters of the `claim` function, which is implemented by child contracts.\n    function _checkClaim(uint256 index, bytes32 leaf, bytes32[] calldata merkleProof) internal {\n        // Check: the campaign has not expired.\n        if (hasExpired()) {\n            revert Errors.SablierV2MerkleLockup_CampaignExpired({\n                blockTimestamp: block.timestamp,\n                expiration: EXPIRATION\n            });\n        }\n\n        // Check: the index has not been claimed.\n        if (_claimedBitMap.get(index)) {\n            revert Errors.SablierV2MerkleLockup_StreamClaimed(index);\n        }\n\n        // Check: the input claim is included in the Merkle tree.\n        if (!MerkleProof.verify(merkleProof, MERKLE_ROOT, leaf)) {\n            revert Errors.SablierV2MerkleLockup_InvalidProof();\n        }\n\n        // Effect: set the `_firstClaimTime` if its zero.\n        if (_firstClaimTime == 0) {\n            _firstClaimTime = uint40(block.timestamp);\n        }\n    }\n\n    /// @notice Returns a flag indicating whether the grace period has passed.\n    /// @dev The grace period is 7 days after the first claim.\n    function _hasGracePeriodPassed() internal view returns (bool) {\n        return _firstClaimTime > 0 && block.timestamp > _firstClaimTime + 7 days;\n    }\n}"
    }
  ]
}