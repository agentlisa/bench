{
  "Title": "[N-01] `getRequestDetails()` should include the tokenid",
  "Content": "\nIn [VRFNFTRandomDraw.sol#getRequestDetails()](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDraw.sol#L58-L70) should include `currentChosenTokenId` ([at](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/interfaces/IVRFNFTRandomDraw.sol#L63)) and ease integrations with other tools.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-12-forgeries",
  "Code": [
    {
      "filename": "src/VRFNFTRandomDraw.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport {OwnableUpgradeable} from \"./ownable/OwnableUpgradeable.sol\";\nimport {IERC721EnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\";\n\nimport {VRFConsumerBaseV2} from \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\nimport {VRFCoordinatorV2, VRFCoordinatorV2Interface} from \"@chainlink/contracts/src/v0.8/VRFCoordinatorV2.sol\";\n\nimport {IVRFNFTRandomDraw} from \"./interfaces/IVRFNFTRandomDraw.sol\";\nimport {Version} from \"./utils/Version.sol\";\n\n/// @notice VRFNFTRandom Draw with NFT Tickets\n/// @author @isiain\ncontract VRFNFTRandomDraw is\n    IVRFNFTRandomDraw,\n    VRFConsumerBaseV2,\n    OwnableUpgradeable,\n    Version(1)\n{\n    /// @notice Our callback is just setting a few variables, 200k should be more than enough gas.\n    uint32 immutable callbackGasLimit = 200_000;\n    /// @notice Chainlink request confirmations, left at the default\n    uint16 immutable minimumRequestConfirmations = 3;\n    /// @notice Number of words requested in a drawing\n    uint16 immutable wordsRequested = 1;\n\n    /// @dev 60 seconds in a min, 60 mins in an hour\n    uint256 immutable HOUR_IN_SECONDS = 60 * 60;\n    /// @dev 24 hours in a day 7 days in a week\n    uint256 immutable WEEK_IN_SECONDS = (3600 * 24 * 7);\n    // @dev about 30 days in a month\n    uint256 immutable MONTH_IN_SECONDS = (3600 * 24 * 7) * 30;\n\n\n    /// @notice Reference to chain-specific coordinator contract\n    VRFCoordinatorV2Interface immutable coordinator;\n\n    /// @notice Settings used for the contract.\n    IVRFNFTRandomDraw.Settings public settings;\n\n    /// @notice Details about the current request to chainlink\n    IVRFNFTRandomDraw.CurrentRequest public request;\n\n    /// @dev Save the coordinator to the contract\n    /// @param _coordinator Address for VRF Coordinator V2 Interface\n    constructor(VRFCoordinatorV2Interface _coordinator)\n        VRFConsumerBaseV2(address(_coordinator))\n        initializer\n    {\n        coordinator = _coordinator;\n    }\n\n    /// @notice Getter for request details, does not include picked tokenID\n    /// @return currentChainlinkRequestId Current Chainlink Request ID\n    /// @return hasChosenRandomNumber If the random number for the drawing has been chosen\n    /// @return drawTimelock block.timestamp when a redraw can be issued\n    function getRequestDetails()\n        external\n        view\n        returns (\n            uint256 currentChainlinkRequestId,\n            bool hasChosenRandomNumber,\n            uint256 drawTimelock\n        )\n    {\n        currentChainlinkRequestId = request.currentChainlinkRequestId;\n        hasChosenRandomNumber = request.hasChosenRandomNumber;\n        drawTimelock = request.drawTimelock;\n    }\n\n    /// @notice Initialize the contract with settings and an admin\n    /// @param admin initial admin user\n    /// @param _settings initial settings for draw\n    function initialize(address admin, Settings memory _settings)\n        public\n        initializer\n    {\n        // Set new settings\n        settings = _settings;\n\n        // Check values in memory:\n        if (_settings.drawBufferTime < HOUR_IN_SECONDS) {\n            revert REDRAW_TIMELOCK_NEEDS_TO_BE_MORE_THAN_AN_HOUR();\n        }\n        if (_settings.drawBufferTime > MONTH_IN_SECONDS) {\n            revert REDRAW_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_MONTH();\n        }\n\n        if (_settings.recoverTimelock < block.timestamp + WEEK_IN_SECONDS) {\n            revert RECOVER_TIMELOCK_NEEDS_TO_BE_AT_LEAST_A_WEEK();\n        }\n        if (\n            _settings.recoverTimelock >\n            block.timestamp + (MONTH_IN_SECONDS * 12)\n        ) {\n            revert RECOVER_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_YEAR();\n        }\n\n        // If NFT contract address is not a contract\n        if (_settings.token.code.length == 0) {\n            revert TOKEN_NEEDS_TO_BE_A_CONTRACT(_settings.token);\n        }\n\n        // If drawing token is not a contract\n        if (_settings.drawingToken.code.length == 0) {\n            revert TOKEN_NEEDS_TO_BE_A_CONTRACT(_settings.drawingToken);\n        }\n\n        // Validate token range: end needs to be greater than start\n        // and the size of the range needs to be at least 2 (end is exclusive)\n        if (\n            _settings.drawingTokenEndId < _settings.drawingTokenStartId ||\n            _settings.drawingTokenEndId - _settings.drawingTokenStartId < 2\n        ) {\n            revert DRAWING_TOKEN_RANGE_INVALID();\n        }\n\n        // Setup owner as admin\n        __Ownable_init(admin);\n\n        // Emit initialized event for indexing\n        emit InitializedDraw(msg.sender, settings);\n\n        // Get owner of raffled tokenId and ensure the current owner is the admin\n        try\n            IERC721EnumerableUpgradeable(_settings.token).ownerOf(\n                _settings.tokenId\n            )\n        returns (address nftOwner) {\n            // Check if address is the admin address\n            if (nftOwner != admin) {\n                revert DOES_NOT_OWN_NFT();\n            }\n        } catch {\n            revert TOKEN_BEING_OFFERED_NEEDS_TO_EXIST();\n        }\n    }\n\n    /// @notice Internal function to request entropy\n    function _requestRoll() internal {\n        // Chainlink request cannot be currently in flight.\n        // Request is cleared in re-roll if conditions are correct.\n        if (request.currentChainlinkRequestId != 0) {\n            revert REQUEST_IN_FLIGHT();\n        }\n\n        // If the number has been drawn and\n        if (\n            request.hasChosenRandomNumber &&\n            // Draw timelock not yet used\n            request.drawTimelock != 0 &&\n            request.drawTimelock > block.timestamp\n        ) {\n            revert STILL_IN_WAITING_PERIOD_BEFORE_REDRAWING();\n        }\n\n        // Setup re-draw timelock\n        request.drawTimelock = block.timestamp + settings.drawBufferTime;\n\n        // Request first random round\n        request.currentChainlinkRequestId = coordinator.requestRandomWords({\n            keyHash: settings.keyHash,\n            subId: settings.subscriptionId,\n            minimumRequestConfirmations: minimumRequestConfirmations,\n            callbackGasLimit: callbackGasLimit,\n            numWords: wordsRequested\n        });\n    }\n\n    /// @notice Call this to start the raffle drawing\n    /// @return chainlink request id\n    function startDraw() external onlyOwner returns (uint256) {\n        // Only can be called on first drawing\n        if (request.currentChainlinkRequestId != 0) {\n            revert REQUEST_IN_FLIGHT();\n        }\n\n        // Emit setup draw user event\n        emit SetupDraw(msg.sender, settings);\n\n        // Request initial roll\n        _requestRoll();\n\n        // Attempt to transfer token into this address\n        try\n            IERC721EnumerableUpgradeable(settings.token).transferFrom(\n                msg.sender,\n                address(this),\n                settings.tokenId\n            )\n        {} catch {\n            revert TOKEN_NEEDS_TO_BE_APPROVED_TO_CONTRACT();\n        }\n\n        // Return the current chainlink request id\n        return request.currentChainlinkRequestId;\n    }\n\n    /// @notice Call this to re-draw the raffle\n    /// @return chainlink request ID\n    /// @dev Only callable by the owner\n    function redraw() external onlyOwner returns (uint256) {\n        if (request.drawTimelock >= block.timestamp) {\n            revert TOO_SOON_TO_REDRAW();\n        }\n\n        // Reset request\n        delete request;\n\n        // Re-roll\n        _requestRoll();\n\n        // Owner of token to raffle needs to be this contract\n        if (\n            IERC721EnumerableUpgradeable(settings.token).ownerOf(\n                settings.tokenId\n            ) != address(this)\n        ) {\n            revert DOES_NOT_OWN_NFT();\n        }\n\n        // Return current chainlink request ID\n        return request.currentChainlinkRequestId;\n    }\n\n    /// @notice Function called by chainlink to resolve random words\n    /// @param _requestId ID of request sent to chainlink VRF\n    /// @param _randomWords List of uint256 words of random entropy\n    function fulfillRandomWords(\n        uint256 _requestId,\n        uint256[] memory _randomWords\n    ) internal override {\n        // Validate request ID\n        if (_requestId != request.currentChainlinkRequestId) {\n            revert REQUEST_DOES_NOT_MATCH_CURRENT_ID();\n        }\n\n        // Validate number of words returned\n        // Words requested is an immutable set to 1\n        if (_randomWords.length != wordsRequested) {\n            revert WRONG_LENGTH_FOR_RANDOM_WORDS();\n        }\n\n        // Set request details\n        request.hasChosenRandomNumber = true;\n\n        // Get total token range\n        uint256 tokenRange = settings.drawingTokenEndId -\n            settings.drawingTokenStartId;\n\n        // Store a number from it here (reduce number here to reduce gas usage)\n        // We know there will only be 1 word sent at this point.\n        request.currentChosenTokenId =\n            (_randomWords[0] % tokenRange) +\n            settings.drawingTokenStartId;\n\n        // Emit completed event.\n        emit DiceRollComplete(msg.sender, request);\n    }\n\n    /// @notice Function to determine if the user has won in the current drawing\n    /// @param user address for the user to check if they have won in the current drawing\n    function hasUserWon(address user) public view returns (bool) {\n        if (!request.hasChosenRandomNumber) {\n            revert NEEDS_TO_HAVE_CHOSEN_A_NUMBER();\n        }\n\n        return\n            user ==\n            IERC721EnumerableUpgradeable(settings.drawingToken).ownerOf(\n                request.currentChosenTokenId\n            );\n    }\n\n    /// @notice Function for the winner to call to retrieve their NFT\n    function winnerClaimNFT() external {\n        // Assume (potential) winner calls this fn, cache.\n        address user = msg.sender;\n\n        // Check if this user has indeed won.\n        if (!hasUserWon(user)) {\n            revert USER_HAS_NOT_WON();\n        }\n\n        // Emit a celebratory event\n        emit WinnerSentNFT(\n            user,\n            address(settings.token),\n            settings.tokenId,\n            settings\n        );\n\n        // Transfer token to the winter.\n        IERC721EnumerableUpgradeable(settings.token).transferFrom(\n            address(this),\n            msg.sender,\n            settings.tokenId\n        );\n    }\n\n    /// @notice Optional last resort admin reclaim nft function\n    /// @dev Only callable by the owner\n    function lastResortTimelockOwnerClaimNFT() external onlyOwner {\n        // If recoverTimelock is not setup, or if not yet occurred\n        if (settings.recoverTimelock > block.timestamp) {\n            // Stop the withdraw\n            revert RECOVERY_IS_NOT_YET_POSSIBLE();\n        }\n\n        // Send event for indexing that the owner reclaimed the NFT\n        emit OwnerReclaimedNFT(owner());\n\n        // Transfer token to the admin/owner.\n        IERC721EnumerableUpgradeable(settings.token).transferFrom(\n            address(this),\n            owner(),\n            settings.tokenId\n        );\n    }\n}"
    }
  ]
}