{
  "Title": "No null checks for input addresses",
  "Content": "##### Description\nSome code lacks a check for null address:\nadmin: https://github.com/ibdotxyz/compound-protocol/blob/8cd45803b48552e344e22be280c9e1c03ec8644a/contracts/PriceOracle/PriceOracleProxyIB.sol#L157\n\n##### Recommendation\nWe recommend adding null checks.\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/PriceOracle/PriceOracleProxyIB.sol",
      "content": "pragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"./Denominations.sol\";\nimport \"./PriceOracle.sol\";\nimport \"./interfaces/BandReference.sol\";\nimport \"./interfaces/FeedRegistryInterface.sol\";\nimport \"../CErc20.sol\";\nimport \"../CToken.sol\";\nimport \"../Exponential.sol\";\nimport \"../EIP20Interface.sol\";\n\ncontract PriceOracleProxyIB is PriceOracle, Exponential, Denominations {\n    /// @notice Admin address\n    address public admin;\n\n    /// @notice Guardian address\n    address public guardian;\n\n    struct AggregatorInfo {\n        /// @notice The base\n        address base;\n        /// @notice The quote denomination\n        address quote;\n        /// @notice It's being used or not.\n        bool isUsed;\n    }\n\n    struct ReferenceInfo {\n        /// @notice The symbol used in reference\n        string symbol;\n        /// @notice It's being used or not.\n        bool isUsed;\n    }\n\n    /// @notice Chainlink Aggregators\n    mapping(address => AggregatorInfo) public aggregators;\n\n    /// @notice Band Reference\n    mapping(address => ReferenceInfo) public references;\n\n    /// @notice The ChainLink registry address\n    FeedRegistryInterface public reg;\n\n    /// @notice The BAND reference address\n    StdReferenceInterface public ref;\n\n    /// @notice Quote symbol we used for BAND reference contract\n    string public constant QUOTE_SYMBOL = \"USD\";\n\n    /**\n     * @param admin_ The address of admin to set aggregators\n     * @param registry_ The address of ChainLink registry\n     * @param reference_ The address of Band reference\n     */\n    constructor(\n        address admin_,\n        address registry_,\n        address reference_\n    ) public {\n        admin = admin_;\n        reg = FeedRegistryInterface(registry_);\n        ref = StdReferenceInterface(reference_);\n    }\n\n    /**\n     * @notice Get the underlying price of a listed cToken asset\n     * @param cToken The cToken to get the underlying price of\n     * @return The underlying asset price mantissa (scaled by 1e18)\n     */\n    function getUnderlyingPrice(CToken cToken) public view returns (uint256) {\n        address underlying = CErc20(address(cToken)).underlying();\n\n        // Get price from ChainLink.\n        AggregatorInfo storage aggregatorInfo = aggregators[underlying];\n        if (aggregatorInfo.isUsed) {\n            uint256 price = getPriceFromChainlink(aggregatorInfo.base, aggregatorInfo.quote);\n            if (aggregatorInfo.quote == Denominations.ETH) {\n                // Convert the price to USD based if it's ETH based.\n                uint256 ethUsdPrice = getPriceFromChainlink(Denominations.ETH, Denominations.USD);\n                price = mul_(price, Exp({mantissa: ethUsdPrice}));\n            }\n            return getNormalizedPrice(price, underlying);\n        }\n\n        // Get price from Band.\n        ReferenceInfo storage referenceInfo = references[underlying];\n        if (referenceInfo.isUsed) {\n            uint256 price = getPriceFromBAND(referenceInfo.symbol);\n            return getNormalizedPrice(price, underlying);\n        }\n\n        revert(\"no price\");\n    }\n\n    /*** Internal fucntions ***/\n\n    /**\n     * @notice Get price from ChainLink\n     * @param base The base token that ChainLink aggregator gets the price of\n     * @param quote The quote token, currenlty support ETH and USD\n     * @return The price, scaled by 1e18\n     */\n    function getPriceFromChainlink(address base, address quote) internal view returns (uint256) {\n        (, int256 price, , , ) = reg.latestRoundData(base, quote);\n        require(price > 0, \"invalid price\");\n\n        // Extend the decimals to 1e18.\n        return mul_(uint256(price), 10**(18 - uint256(reg.decimals(base, quote))));\n    }\n\n    /**\n     * @notice Get price from BAND protocol.\n     * @param symbol The symbol that used to get price of\n     * @return The price, scaled by 1e18\n     */\n    function getPriceFromBAND(string memory symbol) internal view returns (uint256) {\n        StdReferenceInterface.ReferenceData memory data = ref.getReferenceData(symbol, QUOTE_SYMBOL);\n        require(data.rate > 0, \"invalid price\");\n\n        // Price from BAND is always 1e18 base.\n        return data.rate;\n    }\n\n    /**\n     * @notice Normalize the price according to the token decimals.\n     * @param price The original price\n     * @param tokenAddress The token address\n     * @return The normalized price.\n     */\n    function getNormalizedPrice(uint256 price, address tokenAddress) internal view returns (uint256) {\n        uint256 underlyingDecimals = EIP20Interface(tokenAddress).decimals();\n        return mul_(price, 10**(18 - underlyingDecimals));\n    }\n\n    /*** Admin or guardian functions ***/\n\n    event AggregatorUpdated(address tokenAddress, address base, address quote, bool isUsed);\n    event ReferenceUpdated(address tokenAddress, string symbol, bool isUsed);\n    event SetGuardian(address guardian);\n    event SetAdmin(address admin);\n\n    /**\n     * @notice Set guardian for price oracle proxy\n     * @param _guardian The new guardian\n     */\n    function _setGuardian(address _guardian) external {\n        require(msg.sender == admin, \"only the admin may set new guardian\");\n        guardian = _guardian;\n        emit SetGuardian(guardian);\n    }\n\n    /**\n     * @notice Set admin for price oracle proxy\n     * @param _admin The new admin\n     */\n    function _setAdmin(address _admin) external {\n        require(msg.sender == admin, \"only the admin may set new admin\");\n        admin = _admin;\n        emit SetAdmin(admin);\n    }\n\n    /**\n     * @notice Set ChainLink aggregators for multiple tokens\n     * @param tokenAddresses The list of underlying tokens\n     * @param bases The list of ChainLink aggregator bases\n     * @param quotes The list of ChainLink aggregator quotes, currently support 'ETH' and 'USD'\n     */\n    function _setAggregators(\n        address[] calldata tokenAddresses,\n        address[] calldata bases,\n        address[] calldata quotes\n    ) external {\n        require(msg.sender == admin, \"only the admin may set the aggregators\");\n        require(tokenAddresses.length == bases.length && tokenAddresses.length == quotes.length, \"mismatched data\");\n        for (uint256 i = 0; i < tokenAddresses.length; i++) {\n            bool isUsed;\n            if (bases[i] != address(0)) {\n                require(quotes[i] == Denominations.ETH || quotes[i] == Denominations.USD, \"unsupported denomination\");\n                isUsed = true;\n\n                // Make sure the aggregator works.\n                address aggregator = reg.getFeed(bases[i], quotes[i]);\n                require(reg.isFeedEnabled(aggregator), \"aggregator not enabled\");\n\n                (, int256 price, , , ) = reg.latestRoundData(bases[i], quotes[i]);\n                require(price > 0, \"invalid price\");\n            }\n            aggregators[tokenAddresses[i]] = AggregatorInfo({base: bases[i], quote: quotes[i], isUsed: isUsed});\n            emit AggregatorUpdated(tokenAddresses[i], bases[i], quotes[i], isUsed);\n        }\n    }\n\n    /**\n     * @notice Disable ChainLink aggregator\n     * @param tokenAddress The underlying token\n     */\n    function _disableAggregator(address tokenAddress) external {\n        require(msg.sender == admin || msg.sender == guardian, \"only the admin or guardian may disable the aggregator\");\n\n        AggregatorInfo storage aggregatorInfo = aggregators[tokenAddress];\n        require(aggregatorInfo.isUsed, \"aggregator not used\");\n\n        aggregatorInfo.isUsed = false;\n        emit AggregatorUpdated(tokenAddress, aggregatorInfo.base, aggregatorInfo.quote, aggregatorInfo.isUsed);\n    }\n\n    /**\n     * @notice Enable ChainLink aggregator\n     * @param tokenAddress The underlying token\n     */\n    function _enableAggregator(address tokenAddress) external {\n        require(msg.sender == admin || msg.sender == guardian, \"only the admin or guardian may enable the aggregator\");\n\n        AggregatorInfo storage aggregatorInfo = aggregators[tokenAddress];\n        require(!aggregatorInfo.isUsed, \"aggregator is already used\");\n\n        // Make sure the aggregator works.\n        address aggregator = reg.getFeed(aggregatorInfo.base, aggregatorInfo.quote);\n        require(reg.isFeedEnabled(aggregator), \"aggregator not enabled\");\n\n        (, int256 price, , , ) = reg.latestRoundData(aggregatorInfo.base, aggregatorInfo.quote);\n        require(price > 0, \"invalid price\");\n\n        aggregatorInfo.isUsed = true;\n        emit AggregatorUpdated(tokenAddress, aggregatorInfo.base, aggregatorInfo.quote, aggregatorInfo.isUsed);\n    }\n\n    /**\n     * @notice Set Band references for multiple tokens\n     * @param tokenAddresses The list of underlying tokens\n     * @param symbols The list of symbols used by Band reference\n     */\n    function _setReferences(address[] calldata tokenAddresses, string[] calldata symbols) external {\n        require(msg.sender == admin, \"only the admin may set the references\");\n        require(tokenAddresses.length == symbols.length, \"mismatched data\");\n        for (uint256 i = 0; i < tokenAddresses.length; i++) {\n            bool isUsed;\n            if (bytes(symbols[i]).length != 0) {\n                isUsed = true;\n\n                // Make sure we could get the price.\n                StdReferenceInterface.ReferenceData memory data = ref.getReferenceData(symbols[i], QUOTE_SYMBOL);\n                require(data.rate > 0, \"invalid price\");\n            }\n\n            references[tokenAddresses[i]] = ReferenceInfo({symbol: symbols[i], isUsed: isUsed});\n            emit ReferenceUpdated(tokenAddresses[i], symbols[i], isUsed);\n        }\n    }\n\n    /**\n     * @notice Disable Band reference\n     * @param tokenAddress The underlying token\n     */\n    function _disableReference(address tokenAddress) external {\n        require(msg.sender == admin || msg.sender == guardian, \"only the admin or guardian may disable the reference\");\n\n        ReferenceInfo storage referenceInfo = references[tokenAddress];\n        require(referenceInfo.isUsed, \"reference not used\");\n\n        referenceInfo.isUsed = false;\n        emit ReferenceUpdated(tokenAddress, referenceInfo.symbol, referenceInfo.isUsed);\n    }\n\n    /**\n     * @notice Enable Band reference\n     * @param tokenAddress The underlying token\n     */\n    function _enableReference(address tokenAddress) external {\n        require(msg.sender == admin || msg.sender == guardian, \"only the admin or guardian may enable the reference\");\n\n        ReferenceInfo storage referenceInfo = references[tokenAddress];\n        require(!referenceInfo.isUsed, \"reference is already used\");\n\n        // Make sure we could get the price.\n        StdReferenceInterface.ReferenceData memory data = ref.getReferenceData(referenceInfo.symbol, QUOTE_SYMBOL);\n        require(data.rate > 0, \"invalid price\");\n\n        referenceInfo.isUsed = true;\n        emit ReferenceUpdated(tokenAddress, referenceInfo.symbol, referenceInfo.isUsed);\n    }\n}"
    }
  ]
}