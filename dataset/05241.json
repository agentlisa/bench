{
  "Title": "[M-07] Impossible to change managed wallets with `proposeWallets` after first rejection",
  "Content": "\n<https://github.com/code-423n4/2024-01-salty/blob/main/src/ManagedWallet.sol#L67-L69> \n\n<https://github.com/code-423n4/2024-01-salty/blob/main/src/ManagedWallet.sol#L48-L49>\n\nThe `receive` function in `ManagedWallet` fails to reset the `proposedMainWallet` address to the zero address (`address(0)`) when the confirmation wallet rejects the wallet change:\n\n```solidity\nreceive() external payable {\n    require(msg.sender == confirmationWallet, \"Invalid sender\");\n\n    // Confirm if .05 or more ether is sent and otherwise reject.\n    // Done this way in case custodial wallets are used as the confirmationWallet - which sometimes won't allow for smart contract calls.\n    if (msg.value >= .05 ether)\n        activeTimelock = block.timestamp + TIMELOCK_DURATION; // establish the timelock\n    else activeTimelock = type(uint256).max; // effectively never\n    //@audit doesn't reset proposedMainWallet to address(0)\n}\n```\n\nThis omission renders it impossible to submit new proposals for changing wallets in the future. After the confirmation wallet rejects for the first time, the `proposedMainWallet` remains different from `address(0)`, causing the `proposeWallets` function to revert due to the check on the `proposedMainWallet` address:\n\n```solidity\nfunction proposeWallets(\n    address _proposedMainWallet,\n    address _proposedConfirmationWallet\n) external {\n    ...\n\n    //@audit revert if proposedMainWallet != address(0)\n    // Make sure we're not overwriting a previous proposal (as only the confirmationWallet can reject proposals)\n    require(\n        proposedMainWallet == address(0),\n        \"Cannot overwrite non-zero proposed mainWallet.\"\n    );\n\n    proposedMainWallet = _proposedMainWallet;\n    proposedConfirmationWallet = _proposedConfirmationWallet;\n\n    emit WalletProposal(proposedMainWallet, proposedConfirmationWallet);\n}\n```\n\n### Impact\n\nAfter the first rejection of wallet changes, the `proposeWallets` function will consistently revert, making it impossible to change the main and confirmation wallets indefinitely.\n\n### Proof of Concept\n\nThe scenario for this issue to occurs is straightforward :\n\n*   `mainWallet` make a request to `proposeWallets` to change the main and confirmation wallets which sets `proposedMainWallet != address(0)`.\n\n*   `confirmationWallet` doesn't like the change so he calls `receive` function with insufficient amount of ETH to refuse the change. After `receive` call, `activeTimelock` is set to `uint256.max` but `proposedMainWallet` is still different from `address(0)`.\n\n*   `mainWallet` tries to call `proposeWallets` again by it will always revert because `proposedMainWallet != address(0)`.\n\n*   Both main and confirmation wallets can never be changed again.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation\n\nIn the `receive` function, reset the `proposedMainWallet` variable to `address(0)` after the confirmation process has been rejected (similar to the reset done in `changeWallets()`).\n\n```solidity\nif (msg.value >= .05 ether)\n    activeTimelock = block.timestamp + TIMELOCK_DURATION; // establish the timelock\nelse {\n    //@audit Reset\n    activeTimelock = type(uint256).max;\n    proposedMainWallet = address(0);\n    proposedConfirmationWallet = address(0);\n}\n```\n\n**[othernet-global (Salty.IO) confirmed and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/838#issuecomment-1947935073):**\n > ManagedWallet has been removed.\n> \n> https://github.com/othernet-global/salty-io/commit/5766592880737a5e682bb694a3a79e12926d48a5\n\n**[Picodes (Judge) decreased severity to Medium](https://github.com/code-423n4/2024-01-salty-findings/issues/838#issuecomment-1950275953)**\n\n**Status:** Mitigation confirmed. Full details in reports from [t0x1c](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/11), [0xpiken](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/73), and [zzebra83].\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/ManagedWallet.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"./interfaces/IManagedWallet.sol\";\n\n\n// A smart contract which provides two wallet addresses (a main and confirmation wallet) which can be changed using the following mechanism:\n// 1. Main wallet can propose a new main wallet and confirmation wallet.\n// 2. Confirmation wallet confirms or rejects.\n// 3. There is a timelock of 30 days before the proposed mainWallet can confirm the change.\n\ncontract ManagedWallet is IManagedWallet\n    {\n    event WalletProposal(address proposedMainWallet, address proposedConfirmationWallet);\n    event WalletChange(address mainWallet, address confirmationWallet);\n\n    uint256 constant public TIMELOCK_DURATION = 30 days;\n\n    // The active main and confirmation wallets\n    address public mainWallet;\n    address public confirmationWallet;\n\n\t// Proposed wallets\n    address public proposedMainWallet;\n    address public proposedConfirmationWallet;\n\n\t// Active timelock\n    uint256 public activeTimelock;\n\n\n\tconstructor( address _mainWallet, address _confirmationWallet)\n\t\t{\n\t\tmainWallet = _mainWallet;\n\t\tconfirmationWallet = _confirmationWallet;\n\n\t\t// Write a value so subsequent writes take less gas\n\t\tactiveTimelock = type(uint256).max;\n        }\n\n\n\t// Make a request to change the main and confirmation wallets.\n\tfunction proposeWallets( address _proposedMainWallet, address _proposedConfirmationWallet ) external\n\t\t{\n\t\trequire( msg.sender == mainWallet, \"Only the current mainWallet can propose changes\" );\n\t\trequire( _proposedMainWallet != address(0), \"_proposedMainWallet cannot be the zero address\" );\n\t\trequire( _proposedConfirmationWallet != address(0), \"_proposedConfirmationWallet cannot be the zero address\" );\n\n\t\t// Make sure we're not overwriting a previous proposal (as only the confirmationWallet can reject proposals)\n\t\trequire( proposedMainWallet == address(0), \"Cannot overwrite non-zero proposed mainWallet.\" );\n\n\t\tproposedMainWallet = _proposedMainWallet;\n\t\tproposedConfirmationWallet = _proposedConfirmationWallet;\n\n\t\temit WalletProposal(proposedMainWallet, proposedConfirmationWallet);\n\t\t}\n\n\n\t// The confirmation wallet confirms or rejects wallet proposals by sending a specific amount of ETH to this contract\n    receive() external payable\n    \t{\n    \trequire( msg.sender == confirmationWallet, \"Invalid sender\" );\n\n\t\t// Confirm if .05 or more ether is sent and otherwise reject.\n\t\t// Done this way in case custodial wallets are used as the confirmationWallet - which sometimes won't allow for smart contract calls.\n    \tif ( msg.value >= .05 ether )\n    \t\tactiveTimelock = block.timestamp + TIMELOCK_DURATION; // establish the timelock\n    \telse\n\t\t\tactiveTimelock = type(uint256).max; // effectively never\n        }\n\n\n\t// Confirm the wallet proposals - assuming that the active timelock has already expired.\n\tfunction changeWallets() external\n\t\t{\n\t\t// proposedMainWallet calls the function - to make sure it is a valid address.\n\t\trequire( msg.sender == proposedMainWallet, \"Invalid sender\" );\n\t\trequire( block.timestamp >= activeTimelock, \"Timelock not yet completed\" );\n\n\t\t// Set the wallets\n\t\tmainWallet = proposedMainWallet;\n\t\tconfirmationWallet = proposedConfirmationWallet;\n\n\t\temit WalletChange(mainWallet, confirmationWallet);\n\n\t\t// Reset\n\t\tactiveTimelock = type(uint256).max;\n\t\tproposedMainWallet = address(0);\n\t\tproposedConfirmationWallet = address(0);\n\t\t}\n\t}"
    },
    {
      "filename": "src/ManagedWallet.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"./interfaces/IManagedWallet.sol\";\n\n\n// A smart contract which provides two wallet addresses (a main and confirmation wallet) which can be changed using the following mechanism:\n// 1. Main wallet can propose a new main wallet and confirmation wallet.\n// 2. Confirmation wallet confirms or rejects.\n// 3. There is a timelock of 30 days before the proposed mainWallet can confirm the change.\n\ncontract ManagedWallet is IManagedWallet\n    {\n    event WalletProposal(address proposedMainWallet, address proposedConfirmationWallet);\n    event WalletChange(address mainWallet, address confirmationWallet);\n\n    uint256 constant public TIMELOCK_DURATION = 30 days;\n\n    // The active main and confirmation wallets\n    address public mainWallet;\n    address public confirmationWallet;\n\n\t// Proposed wallets\n    address public proposedMainWallet;\n    address public proposedConfirmationWallet;\n\n\t// Active timelock\n    uint256 public activeTimelock;\n\n\n\tconstructor( address _mainWallet, address _confirmationWallet)\n\t\t{\n\t\tmainWallet = _mainWallet;\n\t\tconfirmationWallet = _confirmationWallet;\n\n\t\t// Write a value so subsequent writes take less gas\n\t\tactiveTimelock = type(uint256).max;\n        }\n\n\n\t// Make a request to change the main and confirmation wallets.\n\tfunction proposeWallets( address _proposedMainWallet, address _proposedConfirmationWallet ) external\n\t\t{\n\t\trequire( msg.sender == mainWallet, \"Only the current mainWallet can propose changes\" );\n\t\trequire( _proposedMainWallet != address(0), \"_proposedMainWallet cannot be the zero address\" );\n\t\trequire( _proposedConfirmationWallet != address(0), \"_proposedConfirmationWallet cannot be the zero address\" );\n\n\t\t// Make sure we're not overwriting a previous proposal (as only the confirmationWallet can reject proposals)\n\t\trequire( proposedMainWallet == address(0), \"Cannot overwrite non-zero proposed mainWallet.\" );\n\n\t\tproposedMainWallet = _proposedMainWallet;\n\t\tproposedConfirmationWallet = _proposedConfirmationWallet;\n\n\t\temit WalletProposal(proposedMainWallet, proposedConfirmationWallet);\n\t\t}\n\n\n\t// The confirmation wallet confirms or rejects wallet proposals by sending a specific amount of ETH to this contract\n    receive() external payable\n    \t{\n    \trequire( msg.sender == confirmationWallet, \"Invalid sender\" );\n\n\t\t// Confirm if .05 or more ether is sent and otherwise reject.\n\t\t// Done this way in case custodial wallets are used as the confirmationWallet - which sometimes won't allow for smart contract calls.\n    \tif ( msg.value >= .05 ether )\n    \t\tactiveTimelock = block.timestamp + TIMELOCK_DURATION; // establish the timelock\n    \telse\n\t\t\tactiveTimelock = type(uint256).max; // effectively never\n        }\n\n\n\t// Confirm the wallet proposals - assuming that the active timelock has already expired.\n\tfunction changeWallets() external\n\t\t{\n\t\t// proposedMainWallet calls the function - to make sure it is a valid address.\n\t\trequire( msg.sender == proposedMainWallet, \"Invalid sender\" );\n\t\trequire( block.timestamp >= activeTimelock, \"Timelock not yet completed\" );\n\n\t\t// Set the wallets\n\t\tmainWallet = proposedMainWallet;\n\t\tconfirmationWallet = proposedConfirmationWallet;\n\n\t\temit WalletChange(mainWallet, confirmationWallet);\n\n\t\t// Reset\n\t\tactiveTimelock = type(uint256).max;\n\t\tproposedMainWallet = address(0);\n\t\tproposedConfirmationWallet = address(0);\n\t\t}\n\t}"
    }
  ]
}