{
  "Title": "Small amounts can be withdrawn without penalties from TockenLocker",
  "Content": "##### Description\n- https://github.com/prisma-fi/prisma-contracts/blob/c0122d27677cd4e1aaee7f1e21f807ccadf46ac8/contracts/dao/TokenLocker.sol#L806\n\nThere's a rounding error in the penalty calculation:\n```\nuint256 penaltyOnAmount = (lockAmount * weeksToUnlock) / MAX_LOCK_WEEKS;\n```\n\nThe penalty becomes zero if `lockAmount * weeksToUnlock < MAX_LOCK_WEEKS`. For example, if `lockToTokenRatio=1e18`, then 1e18 PRISM is locked for 51 weeks (or alternatively, 51e18 PRISMA is locked for 1 week) can be withdrawn without penalties.\n\nOne example of an attack that allows you to withdraw 23% of the tokens from the `AllocationVesting` contract:\n- We send a small amount of tokens using `allocation_vesting.transferPoints` to any of the addresses (https://github.com/prisma-fi/pris`ma-contracts/blob/c0122d27677cd4e1aaee7f1e21f807ccadf46ac8/contracts/dao/AllocationVesting.sol#L83)\n- Lock these tokens `allocation_vesting.lockFutureClaims` releasing 23% of future transfers (https://github.com/prisma-fi/prisma-contracts/blob/c0122d27677cd4e1aaee7f1e21f807ccadf46ac8/contracts/dao/AllocationVesting.sol#L116)\n- Call `locker.withdrawWithPenalty` in a loop (https://github.com/prisma-fi/prisma-contracts/blob/c0122d27677cd4e1aaee7f1e21f807ccadf46ac8/contracts/dao/TokenLocker.sol#L769). In this case, the commission is not taken\n- Get PRISMA tokens without blocking for 12 weeks\n\nPoC has been sent to the customer.\n\n##### Recommendation\n\nWe recommended that you improve the precision of the penalty calculation or prohibit the early withdrawal of small amounts.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/dao/TokenLocker.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"../dependencies/SystemStart.sol\";\nimport \"../interfaces/IPrismaCore.sol\";\nimport \"../interfaces/IIncentiveVoting.sol\";\nimport \"../interfaces/IPrismaToken.sol\";\n\n/**\n    @title Prisma Token Locker\n    @notice PRISMA tokens can be locked in this contract to receive \"lock weight\",\n            which is used within `AdminVoting` and `IncentiveVoting` to vote on\n            core protocol operations.\n */\ncontract TokenLocker is SystemStart {\n    // The maximum number of weeks that tokens may be locked for. Also determines the maximum\n    // number of active locks that a single account may open. Weight is calculated as:\n    // `[balance] * [weeks to unlock]`. Weights are stored as `uint40` and balances as `uint32`,\n    // so the max lock weeks cannot be greater than 256 or the system could break due to overflow.\n    uint256 public constant MAX_LOCK_WEEKS = 52;\n\n    // Multiplier applied during token deposits and withdrawals. A balance within this\n    // contract corresponds to a deposit of `balance * lockToTokenRatio` tokens. Balances\n    // in this contract are stored as `uint32`, so the invariant:\n    //\n    // `lockToken.totalSupply() <= type(uint32).max * lockToTokenRatio`\n    //\n    // cannot be violated or the system could break due to overflow.\n    uint256 public immutable lockToTokenRatio;\n\n    IPrismaToken public immutable lockToken;\n    IIncentiveVoting public immutable incentiveVoter;\n    IPrismaCore public immutable prismaCore;\n\n    struct AccountData {\n        // Currently locked balance. Each week the lock weight decays by this amount.\n        uint32 locked;\n        // Currently unlocked balance (from expired locks, can be withdrawn)\n        uint32 unlocked;\n        // Currently \"frozen\" balance. A frozen balance is equivalent to a `MAX_LOCK_WEEKS` lock,\n        // where the lock weight does not decay weekly. An account may have a locked balance or a\n        // frozen balance, never both at the same time.\n        uint32 frozen;\n        // Current week within `accountWeeklyUnlocks`. Lock durations decay as this value increases.\n        uint16 week;\n        // Array of bitfields, where each bit represents 1 week. A bit is set to true when the\n        // account has a non-zero token balance unlocking in that week, and so a non-zero value\n        // at the same index in `accountWeeklyUnlocks`. We use this bitarray to reduce gas costs\n        // when iterating over the weekly unlocks.\n        uint256[256] updateWeeks;\n    }\n\n    // structs used in function inputs\n    struct LockData {\n        uint256 amount;\n        uint256 weeksToUnlock;\n    }\n    struct ExtendLockData {\n        uint256 amount;\n        uint256 currentWeeks;\n        uint256 newWeeks;\n    }\n\n    // Rate at which the total lock weight decreases each week. The total decay rate may not\n    // be equal to the total number of locked tokens, as it does not include frozen accounts.\n    uint32 public totalDecayRate;\n    // Current week within `totalWeeklyWeights` and `totalWeeklyUnlocks`. When up-to-date\n    // this value is always equal to `getWeek()`\n    uint16 public totalUpdatedWeek;\n\n    // week -> total lock weight\n    uint40[65535] totalWeeklyWeights;\n    // week -> tokens to unlock in this week\n    uint32[65535] totalWeeklyUnlocks;\n\n    // account -> week -> lock weight\n    mapping(address => uint40[65535]) accountWeeklyWeights;\n\n    // account -> week -> token balance unlocking this week\n    mapping(address => uint32[65535]) accountWeeklyUnlocks;\n\n    // account -> primary account data structure\n    mapping(address => AccountData) accountLockData;\n\n    event LockCreated(address indexed account, uint256 amount, uint256 _weeks);\n    event LockExtended(address indexed account, uint256 amount, uint256 _weeks, uint256 newWeeks);\n    event LocksCreated(address indexed account, LockData[] newLocks);\n    event LocksExtended(address indexed account, ExtendLockData[] locks);\n    event LocksFrozen(address indexed account, uint256 amount);\n    event LocksUnfrozen(address indexed account, uint256 amount);\n    event LocksWithdrawn(address indexed account, uint256 withdrawn, uint256 penalty);\n\n    constructor(\n        address _prismaCore,\n        IPrismaToken _token,\n        IIncentiveVoting _voter,\n        uint256 _lockToTokenRatio\n    ) SystemStart(_prismaCore) {\n        lockToken = _token;\n        incentiveVoter = _voter;\n        prismaCore = IPrismaCore(_prismaCore);\n\n        lockToTokenRatio = _lockToTokenRatio;\n    }\n\n    modifier notFrozen(address account) {\n        require(accountLockData[account].frozen == 0, \"Lock is frozen\");\n        _;\n    }\n\n    /**\n        @notice Get the balances currently held in this contract for an account\n        @return locked balance which is currently locked or frozen\n        @return unlocked expired lock balance which may be withdrawn\n     */\n    function getAccountBalances(address account) external view returns (uint256 locked, uint256 unlocked) {\n        AccountData storage accountData = accountLockData[account];\n        uint256 frozen = accountData.frozen;\n        unlocked = accountData.unlocked;\n        if (frozen > 0) {\n            return (frozen, unlocked);\n        }\n\n        locked = accountData.locked;\n        if (locked > 0) {\n            uint32[65535] storage weeklyUnlocks = accountWeeklyUnlocks[account];\n            uint256 accountWeek = accountData.week;\n            uint256 systemWeek = getWeek();\n\n            uint256 bitfield = accountData.updateWeeks[accountWeek / 256] >> (accountWeek % 256);\n\n            while (accountWeek < systemWeek) {\n                accountWeek++;\n                if (accountWeek % 256 == 0) {\n                    bitfield = accountData.updateWeeks[accountWeek / 256];\n                } else {\n                    bitfield = bitfield >> 1;\n                }\n                if (bitfield & uint256(1) == 1) {\n                    uint256 u = weeklyUnlocks[accountWeek];\n                    locked -= u;\n                    unlocked += u;\n                    if (locked == 0) break;\n                }\n            }\n        }\n        return (locked, unlocked);\n    }\n\n    /**\n        @notice Get the current lock weight for an account\n     */\n    function getAccountWeight(address account) external view returns (uint256) {\n        return getAccountWeightAt(account, getWeek());\n    }\n\n    /**\n        @notice Get the lock weight for an account in a given week\n     */\n    function getAccountWeightAt(address account, uint256 week) public view returns (uint256) {\n        if (week > getWeek()) return 0;\n        uint32[65535] storage weeklyUnlocks = accountWeeklyUnlocks[account];\n        uint40[65535] storage weeklyWeights = accountWeeklyWeights[account];\n        AccountData storage accountData = accountLockData[account];\n\n        uint256 accountWeek = accountData.week;\n        if (accountWeek >= week) return weeklyWeights[week];\n\n        uint256 locked = accountData.locked;\n        uint256 weight = weeklyWeights[accountWeek];\n        if (locked == 0 || accountData.frozen > 0) {\n            return weight;\n        }\n\n        uint256 systemWeek = getWeek();\n        if (accountWeek >= systemWeek) {\n            return weight;\n        }\n\n        uint256 bitfield = accountData.updateWeeks[accountWeek / 256] >> (accountWeek % 256);\n        while (accountWeek < week) {\n            accountWeek++;\n            weight -= locked;\n            if (accountWeek % 256 == 0) {\n                bitfield = accountData.updateWeeks[accountWeek / 256];\n            } else {\n                bitfield = bitfield >> 1;\n            }\n            if (bitfield & uint256(1) == 1) {\n                uint256 amount = weeklyUnlocks[accountWeek];\n                locked -= amount;\n                if (locked == 0) break;\n            }\n        }\n        return weight;\n    }\n\n    /**\n        @notice Get data on an accounts's active token locks and frozen balance\n        @param account Address to query data for\n        @return lockData dynamic array of [weeks until expiration, balance of lock]\n        @return frozenAmount total frozen balance\n     */\n    function getAccountActiveLocks(\n        address account,\n        uint256 minWeeks\n    ) external view returns (LockData[] memory lockData, uint256 frozenAmount) {\n        AccountData storage accountData = accountLockData[account];\n        frozenAmount = accountData.frozen;\n        if (frozenAmount == 0) {\n            if (minWeeks == 0) minWeeks = 1;\n            uint32[65535] storage unlocks = accountWeeklyUnlocks[account];\n\n            uint256 systemWeek = getWeek();\n            uint256 currentWeek = systemWeek + minWeeks;\n            uint256 maxLockWeek = systemWeek + MAX_LOCK_WEEKS;\n\n            uint256[] memory unlockWeeks = new uint256[](MAX_LOCK_WEEKS);\n            uint256 bitfield = accountData.updateWeeks[currentWeek / 256] >> (currentWeek % 256);\n\n            uint256 length;\n            while (currentWeek <= maxLockWeek) {\n                if (bitfield & uint256(1) == 1) {\n                    unlockWeeks[length] = currentWeek;\n                    length++;\n                }\n                currentWeek++;\n                if (currentWeek % 256 == 0) {\n                    bitfield = accountData.updateWeeks[currentWeek / 256];\n                } else {\n                    bitfield = bitfield >> 1;\n                }\n            }\n\n            lockData = new LockData[](length);\n            uint256 x = length;\n            // increment i, decrement x so LockData is ordered from longest to shortest duration\n            for (uint256 i = 0; x != 0; i++) {\n                x--;\n                uint256 idx = unlockWeeks[x];\n                lockData[i] = LockData({ weeksToUnlock: idx - systemWeek, amount: unlocks[idx] });\n            }\n        }\n        return (lockData, frozenAmount);\n    }\n\n    /**\n        @notice Get withdrawal and penalty amounts when withdrawing locked tokens\n        @param account Account that will withdraw locked tokens\n        @param amountToWithdraw Desired amount of tokens with withdraw\n        @return amountWithdrawn Actual amount withdrawn. If `amountToWithdraw` exceeds the\n                                max possible withdrawal, this return value is be the max\n                                amount available after paying the penalty.\n        @return penaltyAmountPaid The amount paid in penalty to perform this withdrawal\n     */\n    function getWithdrawWithPenaltyAmounts(\n        address account,\n        uint256 amountToWithdraw\n    ) external view returns (uint256 amountWithdrawn, uint256 penaltyAmountPaid) {\n        AccountData storage accountData = accountLockData[account];\n        uint32[65535] storage unlocks = accountWeeklyUnlocks[account];\n\n        // first we apply the unlocked balance without penalty\n        uint256 unlocked = accountData.unlocked;\n        if (unlocked >= amountToWithdraw) {\n            return (amountToWithdraw, 0);\n        }\n        uint256 remaining = amountToWithdraw - unlocked;\n        uint256 penaltyTotal;\n\n        uint256 accountWeek = accountData.week;\n        uint256 systemWeek = getWeek();\n        uint256 offset = systemWeek - accountWeek;\n        uint256 bitfield = accountData.updateWeeks[accountWeek / 256];\n\n        // `weeksToUnlock < MAX_LOCK_WEEKS` stops iteration prior to the final week\n        for (uint256 weeksToUnlock = 1; weeksToUnlock < MAX_LOCK_WEEKS; weeksToUnlock++) {\n            accountWeek++;\n\n            if (accountWeek % 256 == 0) {\n                bitfield = accountData.updateWeeks[accountWeek / 256];\n            }\n\n            if ((bitfield >> (accountWeek % 256)) & uint256(1) == 1) {\n                uint32 lockAmount = unlocks[accountWeek];\n\n                uint256 penaltyOnAmount = 0;\n                if (accountWeek > systemWeek) {\n                    // only apply the penalty if the lock has not expired\n                    penaltyOnAmount = (lockAmount * (weeksToUnlock - offset)) / MAX_LOCK_WEEKS;\n                }\n\n                if (lockAmount - penaltyOnAmount > remaining) {\n                    // after penalty, locked amount exceeds remaining required balance\n                    // we can complete the withdrawal using only a portion of this lock\n                    penaltyOnAmount =\n                        (remaining * MAX_LOCK_WEEKS) /\n                        (MAX_LOCK_WEEKS - (weeksToUnlock - offset)) -\n                        remaining;\n                    penaltyTotal += penaltyOnAmount;\n                    remaining = 0;\n                } else {\n                    // after penalty, locked amount does not exceed remaining required balance\n                    // the entire lock must be used in the withdrawal\n                    penaltyTotal += penaltyOnAmount;\n                    remaining -= lockAmount - penaltyOnAmount;\n                }\n\n                if (remaining == 0) {\n                    break;\n                }\n            }\n        }\n        amountToWithdraw -= remaining;\n        return (amountToWithdraw, penaltyTotal);\n    }\n\n    /**\n        @notice Get the current total lock weight\n     */\n    function getTotalWeight() external view returns (uint256) {\n        return getTotalWeightAt(getWeek());\n    }\n\n    /**\n        @notice Get the total lock weight for a given week\n     */\n    function getTotalWeightAt(uint256 week) public view returns (uint256) {\n        uint256 systemWeek = getWeek();\n        if (week > systemWeek) return 0;\n\n        uint32 updatedWeek = totalUpdatedWeek;\n        if (week <= updatedWeek) return totalWeeklyWeights[week];\n\n        uint32 rate = totalDecayRate;\n        uint40 weight = totalWeeklyWeights[updatedWeek];\n        if (rate == 0 || updatedWeek >= systemWeek) {\n            return weight;\n        }\n\n        while (updatedWeek < systemWeek) {\n            updatedWeek++;\n            weight -= rate;\n            rate -= totalWeeklyUnlocks[updatedWeek];\n        }\n        return weight;\n    }\n\n    /**\n        @notice Get the current lock weight for an account\n        @dev Also updates local storage values for this account. Using\n             this function over it's `view` counterpart is preferred for\n             contract -> contract interactions.\n     */\n    function getAccountWeightWrite(address account) external returns (uint256) {\n        return _weeklyWeightWrite(account);\n    }\n\n    /**\n        @notice Get the current total lock weight\n        @dev Also updates local storage values for total weights. Using\n             this function over it's `view` counterpart is preferred for\n             contract -> contract interactions.\n     */\n    function getTotalWeightWrite() public returns (uint256) {\n        uint256 week = getWeek();\n        uint32 rate = totalDecayRate;\n        uint32 updatedWeek = totalUpdatedWeek;\n        uint40 weight = totalWeeklyWeights[updatedWeek];\n\n        if (weight == 0) {\n            totalUpdatedWeek = uint16(week);\n            return 0;\n        }\n\n        while (updatedWeek < week) {\n            updatedWeek++;\n            weight -= rate;\n            totalWeeklyWeights[updatedWeek] = weight;\n            rate -= totalWeeklyUnlocks[updatedWeek];\n        }\n\n        totalDecayRate = rate;\n        totalUpdatedWeek = uint16(week);\n\n        return weight;\n    }\n\n    /**\n        @notice Deposit tokens into the contract to create a new lock.\n        @dev A lock is created for a given number of weeks. Minimum 1, maximum `MAX_LOCK_WEEKS`.\n             An account can have multiple locks active at the same time. The account's \"lock weight\"\n             is calculated as the sum of [number of tokens] * [weeks until unlock] for all active\n             locks. At the start of each new week, each lock's weeks until unlock is reduced by 1.\n             Locks that reach 0 weeks no longer receive any weight, and tokens may be withdrawn by\n             calling `withdrawExpiredLocks`.\n        @param _account Address to create a new lock for (does not have to be the caller)\n        @param _amount Amount of tokens to lock. This balance transfered from the caller.\n        @param _weeks The number of weeks for the lock\n     */\n    function lock(address _account, uint256 _amount, uint256 _weeks) external returns (bool) {\n        require(_weeks > 0, \"Min 1 week\");\n        require(_amount > 0, \"Amount must be nonzero\");\n        _lock(_account, _amount, _weeks);\n        lockToken.transferToLocker(msg.sender, _amount * lockToTokenRatio);\n\n        return true;\n    }\n\n    function _lock(address _account, uint256 _amount, uint256 _weeks) internal {\n        require(_weeks <= MAX_LOCK_WEEKS, \"Exceeds MAX_LOCK_WEEKS\");\n        AccountData storage accountData = accountLockData[_account];\n\n        uint256 accountWeight = _weeklyWeightWrite(_account);\n        uint256 totalWeight = getTotalWeightWrite();\n        uint256 systemWeek = getWeek();\n        uint256 frozen = accountData.frozen;\n        if (frozen > 0) {\n            accountData.frozen = uint32(frozen + _amount);\n            _weeks = MAX_LOCK_WEEKS;\n        } else {\n            accountData.locked = uint32(accountData.locked + _amount);\n            totalDecayRate = uint32(totalDecayRate + _amount);\n\n            uint32[65535] storage unlocks = accountWeeklyUnlocks[_account];\n            uint256 unlockWeek = systemWeek + _weeks;\n            uint256 previous = unlocks[unlockWeek];\n\n            // modify weekly unlocks and unlock bitfield\n            unlocks[unlockWeek] = uint32(previous + _amount);\n            totalWeeklyUnlocks[unlockWeek] += uint32(_amount);\n            if (previous == 0) {\n                uint256 idx = unlockWeek / 256;\n                uint256 bitfield = accountData.updateWeeks[idx] | (uint256(1) << (unlockWeek % 256));\n                accountData.updateWeeks[idx] = bitfield;\n            }\n        }\n\n        // update and adjust account weight and decay rate\n        accountWeeklyWeights[_account][systemWeek] = uint40(accountWeight + _amount * _weeks);\n        // update and modify total weight\n        totalWeeklyWeights[systemWeek] = uint40(totalWeight + _amount * _weeks);\n        emit LockCreated(_account, _amount, _weeks);\n    }\n\n    /**\n        @notice Extend the length of an existing lock.\n        @param _amount Amount of tokens to extend the lock for. When the value given equals\n                       the total size of the existing lock, the entire lock is moved.\n                       If the amount is less, then the lock is effectively split into\n                       two locks, with a portion of the balance extended to the new length\n                       and the remaining balance at the old length.\n        @param _weeks The number of weeks for the lock that is being extended.\n        @param _newWeeks The number of weeks to extend the lock until.\n     */\n    function extendLock(\n        uint256 _amount,\n        uint256 _weeks,\n        uint256 _newWeeks\n    ) external notFrozen(msg.sender) returns (bool) {\n        require(_weeks > 0, \"Min 1 week\");\n        require(_newWeeks <= MAX_LOCK_WEEKS, \"Exceeds MAX_LOCK_WEEKS\");\n        require(_weeks < _newWeeks, \"newWeeks must be greater than weeks\");\n        require(_amount > 0, \"Amount must be nonzero\");\n\n        AccountData storage accountData = accountLockData[msg.sender];\n        uint256 systemWeek = getWeek();\n        uint256 increase = (_newWeeks - _weeks) * _amount;\n        uint32[65535] storage unlocks = accountWeeklyUnlocks[msg.sender];\n\n        // update and adjust account weight\n        // current decay rate is unaffected when extending\n        uint256 weight = _weeklyWeightWrite(msg.sender);\n        accountWeeklyWeights[msg.sender][systemWeek] = uint40(weight + increase);\n\n        // reduce account weekly unlock for previous week and modify bitfield\n        uint256 changedWeek = systemWeek + _weeks;\n        uint256 previous = unlocks[changedWeek];\n        unlocks[changedWeek] = uint32(previous - _amount);\n        totalWeeklyUnlocks[changedWeek] -= uint32(_amount);\n        if (previous == _amount) {\n            uint256 idx = changedWeek / 256;\n            uint256 bitfield = accountData.updateWeeks[idx] & ~(uint256(1) << (changedWeek % 256));\n            accountData.updateWeeks[idx] = bitfield;\n        }\n\n        // increase account weekly unlock for new week and modify bitfield\n        changedWeek = systemWeek + _newWeeks;\n        previous = unlocks[changedWeek];\n        unlocks[changedWeek] = uint32(previous + _amount);\n        totalWeeklyUnlocks[changedWeek] += uint32(_amount);\n        if (previous == 0) {\n            uint256 idx = changedWeek / 256;\n            uint256 bitfield = accountData.updateWeeks[idx] | (uint256(1) << (changedWeek % 256));\n            accountData.updateWeeks[idx] = bitfield;\n        }\n\n        // update and modify total weight\n        totalWeeklyWeights[systemWeek] = uint40(getTotalWeightWrite() + increase);\n        emit LockExtended(msg.sender, _amount, _weeks, _newWeeks);\n\n        return true;\n    }\n\n    /**\n        @notice Deposit tokens into the contract to create multiple new locks.\n        @param _account Address to create new locks for (does not have to be the caller)\n        @param newLocks Array of [(amount, weeks), ...] where amount is the amount of\n                        tokens to lock, and weeks is the number of weeks for the lock.\n                        All tokens to be locked are transferred from the caller.\n     */\n    function lockMany(address _account, LockData[] calldata newLocks) external notFrozen(_account) returns (bool) {\n        AccountData storage accountData = accountLockData[_account];\n        uint32[65535] storage unlocks = accountWeeklyUnlocks[_account];\n\n        // update account weight\n        uint256 accountWeight = _weeklyWeightWrite(_account);\n        uint256 systemWeek = getWeek();\n\n        // copy maybe-updated bitfield entries to memory\n        uint256[2] memory bitfield = [\n            accountData.updateWeeks[systemWeek / 256],\n            accountData.updateWeeks[(systemWeek / 256) + 1]\n        ];\n\n        uint256 increasedAmount;\n        uint256 increasedWeight;\n\n        // iterate new locks and store intermediate values in memory where possible\n        uint256 length = newLocks.length;\n        for (uint256 i = 0; i < length; i++) {\n            uint256 amount = newLocks[i].amount;\n            uint256 week = newLocks[i].weeksToUnlock;\n            require(amount > 0, \"Amount must be nonzero\");\n            require(week > 0, \"Min 1 week\");\n            require(week <= MAX_LOCK_WEEKS, \"Exceeds MAX_LOCK_WEEKS\");\n            increasedAmount += amount;\n            increasedWeight += amount * week;\n\n            uint256 unlockWeek = systemWeek + week;\n            uint256 previous = unlocks[unlockWeek];\n            unlocks[unlockWeek] = uint32(previous + amount);\n            totalWeeklyUnlocks[unlockWeek] += uint32(amount);\n\n            if (previous == 0) {\n                uint256 idx = (unlockWeek / 256) - (systemWeek / 256);\n                bitfield[idx] = bitfield[idx] | (uint256(1) << (unlockWeek % 256));\n            }\n        }\n\n        // write updated bitfield to storage\n        accountData.updateWeeks[systemWeek / 256] = bitfield[0];\n        accountData.updateWeeks[(systemWeek / 256) + 1] = bitfield[1];\n\n        lockToken.transferToLocker(msg.sender, increasedAmount * lockToTokenRatio);\n\n        // update account and total weight / decay storage values\n        accountWeeklyWeights[_account][systemWeek] = uint40(accountWeight + increasedWeight);\n        totalWeeklyWeights[systemWeek] = uint40(getTotalWeightWrite() + increasedWeight);\n\n        accountData.locked = uint32(accountData.locked + increasedAmount);\n        totalDecayRate = uint32(totalDecayRate + increasedAmount);\n        emit LocksCreated(_account, newLocks);\n\n        return true;\n    }\n\n    /**\n        @notice Extend the length of multiple existing locks.\n        @param newExtendLocks Array of [(amount, weeks, newWeeks), ...] where amount is the amount\n                              of tokens to extend the lock for, weeks is the current number of weeks\n                              for the lock that is being extended, and newWeeks is the number of weeks\n                              to extend the lock until.\n     */\n    function extendMany(ExtendLockData[] calldata newExtendLocks) external notFrozen(msg.sender) returns (bool) {\n        AccountData storage accountData = accountLockData[msg.sender];\n        uint32[65535] storage unlocks = accountWeeklyUnlocks[msg.sender];\n\n        // update account weight\n        uint256 accountWeight = _weeklyWeightWrite(msg.sender);\n        uint256 systemWeek = getWeek();\n\n        // copy maybe-updated bitfield entries to memory\n        uint256[2] memory bitfield = [\n            accountData.updateWeeks[systemWeek / 256],\n            accountData.updateWeeks[(systemWeek / 256) + 1]\n        ];\n        uint256 increasedWeight;\n\n        // iterate extended locks and store intermediate values in memory where possible\n        uint256 length = newExtendLocks.length;\n        for (uint256 i = 0; i < length; i++) {\n            uint256 amount = newExtendLocks[i].amount;\n            uint256 oldWeeks = newExtendLocks[i].currentWeeks;\n            uint256 newWeeks = newExtendLocks[i].newWeeks;\n\n            require(oldWeeks > 0, \"Min 1 week\");\n            require(newWeeks <= MAX_LOCK_WEEKS, \"Exceeds MAX_LOCK_WEEKS\");\n            require(oldWeeks < newWeeks, \"newWeeks must be greater than weeks\");\n            require(amount > 0, \"Amount must be nonzero\");\n\n            increasedWeight += (newWeeks - oldWeeks) * amount;\n\n            // reduce account weekly unlock for previous week and modify bitfield\n            oldWeeks += systemWeek;\n            uint256 previous = unlocks[oldWeeks];\n            unlocks[oldWeeks] = uint32(previous - amount);\n            totalWeeklyUnlocks[oldWeeks] -= uint32(amount);\n            if (previous == amount) {\n                uint256 idx = (oldWeeks / 256) - (systemWeek / 256);\n                bitfield[idx] = bitfield[idx] & ~(uint256(1) << (oldWeeks % 256));\n            }\n\n            // increase account weekly unlock for new week and modify bitfield\n            newWeeks += systemWeek;\n            previous = unlocks[newWeeks];\n            unlocks[newWeeks] = uint32(previous + amount);\n            totalWeeklyUnlocks[newWeeks] += uint32(amount);\n            if (previous == 0) {\n                uint256 idx = (newWeeks / 256) - (systemWeek / 256);\n                bitfield[idx] = bitfield[idx] | (uint256(1) << (newWeeks % 256));\n            }\n        }\n\n        // write updated bitfield to storage\n        accountData.updateWeeks[systemWeek / 256] = bitfield[0];\n        accountData.updateWeeks[(systemWeek / 256) + 1] = bitfield[1];\n\n        accountWeeklyWeights[msg.sender][systemWeek] = uint40(accountWeight + increasedWeight);\n        totalWeeklyWeights[systemWeek] = uint40(getTotalWeightWrite() + increasedWeight);\n        emit LocksExtended(msg.sender, newExtendLocks);\n\n        return true;\n    }\n\n    /**\n        @notice Freeze all locks for the caller\n        @dev When an account's locks are frozen, the weeks-to-unlock does not decay.\n             All other functionality remains the same; the account can continue to lock,\n             extend locks, and withdraw tokens. Freezing greatly reduces gas costs for\n             actions such as emissions voting.\n     */\n    function freeze() external notFrozen(msg.sender) {\n        AccountData storage accountData = accountLockData[msg.sender];\n        uint32[65535] storage unlocks = accountWeeklyUnlocks[msg.sender];\n\n        uint256 accountWeight = _weeklyWeightWrite(msg.sender);\n        uint256 totalWeight = getTotalWeightWrite();\n\n        // remove account locked balance from the total decay rate\n        uint256 locked = accountData.locked;\n        require(locked > 0, \"No locked balance\");\n        totalDecayRate = uint32(totalDecayRate - locked);\n        accountData.frozen = uint32(locked);\n        accountData.locked = 0;\n\n        uint256 systemWeek = getWeek();\n        accountWeeklyWeights[msg.sender][systemWeek] = uint40(locked * MAX_LOCK_WEEKS);\n        totalWeeklyWeights[systemWeek] = uint40(totalWeight - accountWeight + locked * MAX_LOCK_WEEKS);\n\n        // use bitfield to iterate acount unlocks and subtract them from the total unlocks\n        uint256 bitfield = accountData.updateWeeks[systemWeek / 256] >> (systemWeek % 256);\n        while (locked > 0) {\n            systemWeek++;\n            if (systemWeek % 256 == 0) {\n                bitfield = accountData.updateWeeks[systemWeek / 256];\n                accountData.updateWeeks[(systemWeek / 256) - 1] = 0;\n            } else {\n                bitfield = bitfield >> 1;\n            }\n            if (bitfield & uint256(1) == 1) {\n                uint32 amount = unlocks[systemWeek];\n                unlocks[systemWeek] = 0;\n                totalWeeklyUnlocks[systemWeek] -= amount;\n                locked -= amount;\n            }\n        }\n        accountData.updateWeeks[systemWeek / 256] = 0;\n        emit LocksFrozen(msg.sender, locked);\n    }\n\n    /**\n        @notice Unfreeze all locks for the caller\n        @dev When an account's locks are unfrozen, the weeks-to-unlock decay normally.\n             This is the default locking behaviour for each account. Unfreezing locks\n             also updates the frozen status within `IncentiveVoter` - otherwise it could be\n             possible for accounts to have a larger registered vote weight than their actual\n             lock weight.\n        @param keepIncentivesVote If true, existing incentive votes are preserved when updating\n                                  the frozen status within `IncentiveVoter`. Voting with unfrozen\n                                  weight uses significantly more gas than voting with frozen weight.\n                                  If the caller has many active locks and/or many votes, it will be\n                                  much cheaper to set this value to false.\n\n     */\n    function unfreeze(bool keepIncentivesVote) external {\n        AccountData storage accountData = accountLockData[msg.sender];\n        uint32[65535] storage unlocks = accountWeeklyUnlocks[msg.sender];\n        uint256 frozen = accountData.frozen;\n        require(frozen > 0, \"Locks already unfrozen\");\n\n        // unfreeze the caller's registered vote weights\n        incentiveVoter.unfreeze(msg.sender, keepIncentivesVote);\n\n        // update account weights and get the current account week\n        _weeklyWeightWrite(msg.sender);\n        getTotalWeightWrite();\n\n        // add account decay to the total decay rate\n        totalDecayRate = uint32(totalDecayRate + frozen);\n        accountData.locked = uint32(frozen);\n        accountData.frozen = 0;\n\n        uint256 systemWeek = getWeek();\n\n        uint256 unlockWeek = systemWeek + MAX_LOCK_WEEKS;\n\n        // modify weekly unlocks and unlock bitfield\n        unlocks[unlockWeek] = uint32(frozen);\n        totalWeeklyUnlocks[unlockWeek] += uint32(frozen);\n        uint256 idx = unlockWeek / 256;\n        uint256 bitfield = accountData.updateWeeks[idx] | (uint256(1) << (unlockWeek % 256));\n        accountData.updateWeeks[idx] = bitfield;\n        emit LocksUnfrozen(msg.sender, frozen);\n    }\n\n    /**\n        @notice Withdraw tokens from locks that have expired\n        @param _weeks Optional number of weeks for the re-locking.\n                      If 0 the full amount is transferred back to the user.\n\n     */\n    function withdrawExpiredLocks(uint256 _weeks) external returns (bool) {\n        _weeklyWeightWrite(msg.sender);\n        getTotalWeightWrite();\n\n        AccountData storage accountData = accountLockData[msg.sender];\n        uint256 unlocked = accountData.unlocked;\n        require(unlocked > 0, \"No unlocked tokens\");\n        accountData.unlocked = 0;\n        if (_weeks > 0) {\n            _lock(msg.sender, unlocked, _weeks);\n        } else {\n            lockToken.transfer(msg.sender, unlocked * lockToTokenRatio);\n            emit LocksWithdrawn(msg.sender, unlocked, 0);\n        }\n        return true;\n    }\n\n    /**\n        @notice Pay a penalty to withdraw locked tokens\n        @dev Withdrawals are processed starting with the lock that will expire soonest.\n             The penalty starts at 100% and decays linearly based on the number of weeks\n             remaining until the tokens unlock. The exact calculation used is:\n\n             [total amount] * [weeks to unlock] / MAX_LOCK_WEEKS = [penalty amount]\n\n        @param amountToWithdraw The amount of tokens to withdraw from active locks. This\n                                is the same number of tokens that will be received; the\n                                penalty amount is taken on t"
    }
  ]
}