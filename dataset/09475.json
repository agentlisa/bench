{
  "Title": "[M-05] Stale price used when `citadelPriceFlag` is cleared",
  "Content": "_Submitted by IllIllI_\n\nDuring the [video](https://drive.google.com/file/d/1hCzQrgZEsbd0t2mtuaXm7Cp3YS-ZIlw3/view?usp=sharing) it was explained that the policy operations team was meant to be a nimble group that could change protocol values considered to be safe. Further, it was explained that since pricing comes from an oracle, and there would have to be unusual coordination between the two to affect outcomes, the group was given the ability to clear the pricing flag to get things moving again once the price was determined to be valid\n\n### Impact\n\nIf an oracle price falls out of the valid min/max range, the `citadelPriceFlag` is set to true, but the out-of-bounds value is not stored. If the policy operations team calls `clearCitadelPriceFlag()`, the stale price from before the flag will be used. Not only is it an issue because of stale prices, but this means the policy op team now has a way to affect pricing not under the control of the oracle (i.e. no unusual coordination required to affect an outcome). Incorrect pricing leads to incorrect asset valuations, and loss of funds.\n\n### Proof of Concept\n\nThe flag is set but the price is not stored\nFile: src/Funding.sol (lines [427-437](https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/Funding.sol#L427-L437))\n\n```solidity\n        if (\n            _citadelPriceInAsset < minCitadelPriceInAsset ||\n            _citadelPriceInAsset > maxCitadelPriceInAsset\n        ) {\n            citadelPriceFlag = true;\n            emit CitadelPriceFlag(\n                _citadelPriceInAsset,\n                minCitadelPriceInAsset,\n                maxCitadelPriceInAsset\n            );\n        } else {\n```\n\n### Tools Used\n\nCode inspection\n\n### Recommended Mitigation Steps\n\nAlways set the `citadelPriceInAsset`\n\n**[shuklaayush (BadgerDAO) confirmed and commented](https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/176#issuecomment-1124328765):**\n > Makes sense. It's best to update the price even when it's flagged\n\n**[jack-the-pug (judge) commented](https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/176#issuecomment-1146741831):**\n > This is a very good catch! `citadelPriceInAsset` is not updated when `citadelPriceFlag` is set, therefore clearing the flag will not approve the out of range price but continues with a stale price before the out of range price.\n\n\n\n***\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-04-badger-citadel-contest",
  "Code": [
    {
      "filename": "src/Funding.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./interfaces/badger/IVault.sol\";\nimport \"./interfaces/erc20/IERC20.sol\";\nimport \"./lib/GlobalAccessControlManaged.sol\";\nimport \"./lib/SafeERC20.sol\";\nimport \"./interfaces/citadel/IMedianOracle.sol\";\n\n/**\n * @notice Sells a token at a predetermined price to whitelisted buyers.\n * TODO: Better revert strings\n */\ncontract Funding is GlobalAccessControlManaged, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n\n    // Roles used from GAC\n    bytes32 public constant CONTRACT_GOVERNANCE_ROLE =\n        keccak256(\"CONTRACT_GOVERNANCE_ROLE\");\n    bytes32 public constant POLICY_OPERATIONS_ROLE =\n        keccak256(\"POLICY_OPERATIONS_ROLE\");\n    bytes32 public constant TREASURY_OPERATIONS_ROLE = keccak256(\"TREASURY_OPERATIONS_ROLE\");\n    bytes32 public constant TREASURY_VAULT_ROLE =\n        keccak256(\"TREASURY_VAULT_ROLE\");\n    bytes32 public constant KEEPER_ROLE = keccak256(\"KEEPER_ROLE\");\n\n    uint256 public constant MAX_BPS = 10000;\n\n    IERC20 public citadel; /// token to distribute (in vested xCitadel form)\n    IVault public xCitadel; /// wrapped citadel form that is actually distributed\n    IERC20 public asset; /// token to take in WBTC / bibbtc LP / CVX / bveCVX\n\n    uint256 public citadelPriceInAsset; /// asset per citadel price eg. 1 WBTC (8 decimals) = 40,000 CTDL ==> price = 10^8 / 40,000\n    uint256 public minCitadelPriceInAsset; /// Lower bound on expected citadel price in asset terms. Used as circuit breaker oracle.\n    uint256 public maxCitadelPriceInAsset; /// Upper bound on expected citadel price in asset terms. Used as circuit breaker oracle.\n    bool public citadelPriceFlag; /// Flag citadel price for review by guardian if it exceeds min and max bounds;\n\n    uint256 public assetDecimalsNormalizationValue;\n\n    address public citadelPriceInAssetOracle;\n    address public saleRecipient;\n\n    struct FundingParams {\n        uint256 discount;\n        uint256 minDiscount;\n        uint256 maxDiscount;\n        address discountManager;\n        uint256 assetCumulativeFunded; /// persistent sum of asset amount in over lifetime of contract.\n        uint256 assetCap; /// Max asset token that can be taken in by the contract (defines the cap for citadel sold)\n    }\n\n    FundingParams public funding;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    // TODO: we should conform to some interface here\n    event Deposit(\n        address indexed buyer,\n        uint256 assetIn,\n        uint256 citadelOutValue\n    );\n\n    event CitadelPriceInAssetUpdated(uint256 citadelPrice);\n\n    event CitadelPriceBoundsSet(uint256 minPrice, uint256 maxPrice);\n    event CitadelPriceFlag(uint256 price, uint256 minPrice, uint256 maxPrice);\n\n    event SaleRecipientUpdated(address indexed recipient);\n    event AssetCapUpdated(uint256 assetCap);\n\n    event Sweep(address indexed token, uint256 amount);\n    event ClaimToTreasury(address indexed token, uint256 amount);\n\n    modifier onlyCitadelPriceInAssetOracle() {\n        require(\n            msg.sender == citadelPriceInAssetOracle,\n            \"onlyCitadelPriceInAssetOracle\"\n        );\n        _;\n    }\n\n    event DiscountLimitsSet(uint256 minDiscount, uint256 maxDiscount);\n    event DiscountSet(uint256 discount);\n    event DiscountManagerSet(address discountManager);\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    /**\n     * @notice Initializer.\n     * @param _gac Global access control\n     * @param _citadel The token this contract will return in a trade\n     * @param _asset The token this contract will receive in a trade\n     * @param _xCitadel Staked citadel, citadel will be granted to funders in this form\n     * @param _saleRecipient The address receiving the proceeds of the sale - will be citadel multisig\n     * @param _assetCap The max asset that the contract can take\n     */\n    function initialize(\n        address _gac,\n        address _citadel,\n        address _asset,\n        address _xCitadel,\n        address _saleRecipient,\n        address _citadelPriceInAssetOracle,\n        uint256 _assetCap\n    ) external initializer {\n        require(\n            _saleRecipient != address(0),\n            \"Funding: 0 sale\"\n        );\n        require(\n            _citadelPriceInAssetOracle != address(0),\n            \"Funding: 0 oracle\"\n        );\n\n        __GlobalAccessControlManaged_init(_gac);\n        __ReentrancyGuard_init();\n\n        citadel = IERC20(_citadel);\n        xCitadel = IVault(_xCitadel);\n        asset = IERC20(_asset);\n        saleRecipient = _saleRecipient;\n\n        citadelPriceInAssetOracle = _citadelPriceInAssetOracle;\n\n        funding = FundingParams(0, 0, 0, address(0), 0, _assetCap);\n\n        assetDecimalsNormalizationValue = 10**asset.decimals();\n\n        // No circuit breaker on price by default\n        minCitadelPriceInAsset = 0;\n        maxCitadelPriceInAsset = type(uint256).max;\n\n        // Allow to deposit in vault\n        // Done last for reEntrancy concerns\n        IERC20(_citadel).safeApprove(address(_xCitadel), type(uint256).max);\n    }\n\n    modifier onlyWhenPriceNotFlagged() {\n        require(\n            citadelPriceFlag == false,\n            \"Funding: citadel price from oracle flagged and pending review\"\n        );\n        _;\n    }\n\n    /// ==========================\n    /// ===== Public actions =====\n    /// ==========================\n\n    /**\n     * @notice Exchange `_assetAmountIn` of `asset` for `citadel`\n     * @param _assetAmountIn Amount of `asset` to give\n     * @param _minCitadelOut ID of DAO to vote for\n     * @return citadelAmount_ Amount of `xCitadel` bought\n     */\n    function deposit(uint256 _assetAmountIn, uint256 _minCitadelOut)\n        external\n        onlyWhenPriceNotFlagged\n        gacPausable\n        nonReentrant\n        returns (uint256 citadelAmount_)\n    {\n        require(_assetAmountIn > 0, \"_assetAmountIn must not be 0\");\n        require(\n            funding.assetCumulativeFunded + _assetAmountIn <= funding.assetCap,\n            \"asset funding cap exceeded\"\n        );\n        funding.assetCumulativeFunded = funding.assetCumulativeFunded + _assetAmountIn;\n        // Take in asset from user\n        citadelAmount_ = getAmountOut(_assetAmountIn);\n        require(citadelAmount_ >= _minCitadelOut, \"minCitadelOut\");\n\n        asset.safeTransferFrom(msg.sender, saleRecipient, _assetAmountIn);\n        \n        // Deposit xCitadel and send to user\n        // TODO: Check gas costs. How does this relate to market buying if you do want to deposit to xCTDL?\n        xCitadel.depositFor(msg.sender, citadelAmount_);\n\n        emit Deposit(\n            msg.sender,\n            _assetAmountIn,\n            citadelAmount_\n        );\n    }\n\n    /// =======================\n    /// ===== Public view =====\n    /// =======================\n\n    /**\n     * @notice Get the amount received when exchanging `asset`\n     * @param _assetAmountIn Amount of `asset` to exchange\n     * @return citadelAmount_ Amount of `citadel` received\n     */\n    function getAmountOut(uint256 _assetAmountIn)\n        public\n        view\n        returns (uint256 citadelAmount_)\n    {\n        uint256 citadelAmountWithoutDiscount = _assetAmountIn * citadelPriceInAsset;\n\n        if (funding.discount > 0) {\n            citadelAmount_ =\n                (citadelAmountWithoutDiscount * MAX_BPS) /\n                (MAX_BPS - funding.discount);\n        }\n\n        citadelAmount_ = citadelAmount_ / assetDecimalsNormalizationValue;\n    }\n\n    /**\n     * @notice Get the amount received when exchanging `asset`, in terms of xCitadel at current price per share\n     * @param _assetAmountIn Amount of `asset` to exchange\n     * @return xCitadelAmount_ Amount of `xCitadel` received at current price per share\n     */\n    function getStakedCitadelAmountOut(uint256 _assetAmountIn) public view returns (uint256 xCitadelAmount_) {\n        uint citadelAmount = getAmountOut(_assetAmountIn);\n        xCitadelAmount_ = citadelAmount * 10**citadel.decimals() / xCitadel.getPricePerFullShare();\n    }\n\n    /**\n     * @notice Check how much `asset` can still be taken in, based on cap and cumulative amount funded\n     * @return limitLeft_ Amount of `asset` that can still be exchanged for citadel\n     */\n    function getRemainingFundable() external view returns (uint256 limitLeft_) {\n        uint256 assetCumulativeFunded = funding.assetCumulativeFunded;\n        uint256 assetCap = funding.assetCap;\n        if (assetCumulativeFunded < assetCap) {\n            limitLeft_ = assetCap - assetCumulativeFunded;\n        }\n    }\n\n    /**\n     * @notice Get all funding params\n     * @return funding all funding params\n     */\n    function getFundingParams() external view returns (FundingParams memory) {\n        return funding;\n    }\n\n    /**\n     * @notice Convenience function to get current discount rate\n     * @return discount current discount rate\n     */\n    function getDiscount() external view returns (uint256) {\n        return funding.discount;\n    }\n\n    /// ==============================\n    /// ===== Policy Ops actions =====\n    /// ==============================\n\n    /**\n     * @notice Set discount manually, within the constraints of min and max discount values\n     * @dev managed by policy operations for rapid response to market conditions\n     * @param _discount active discount (in bps)\n     */\n    function setDiscount(uint256 _discount)\n        external\n        gacPausable\n        onlyRoleOrAddress(POLICY_OPERATIONS_ROLE, funding.discountManager)\n    {\n        require(_discount >= funding.minDiscount, \"discount < minDiscount\");\n        require(_discount <= funding.maxDiscount, \"discount > maxDiscount\");\n\n        funding.discount = _discount;\n\n        emit DiscountSet(_discount);\n    }\n\n    function clearCitadelPriceFlag()\n        external\n        gacPausable\n        onlyRole(POLICY_OPERATIONS_ROLE)\n    {\n        citadelPriceFlag = false;\n    }\n\n    /**\n     * @notice Modify the max asset amount that this contract can take. Managed by policy governance.\n     * @dev This is cumulative asset cap, so must take into account the asset amount already funded.\n     * @param _assetCap New max cumulatiive amountIn\n     */\n    function setAssetCap(uint256 _assetCap)\n        external\n        gacPausable\n        onlyRole(POLICY_OPERATIONS_ROLE)\n    {\n        require(\n            _assetCap > funding.assetCumulativeFunded,\n            \"cannot decrease cap below global sum of assets in\"\n        );\n        funding.assetCap = _assetCap;\n        emit AssetCapUpdated(_assetCap);\n    }\n\n    /// ================================\n    /// ===== Treasury Ops actions =====\n    /// ================================\n\n    /**\n     * @notice Transfers out any tokens accidentally sent to the contract. Can only be called by owner\n     * @dev The contract transfers all `asset` directly to `saleRecipient` during a sale so it's safe\n     *      to sweep `asset`. For `citadel`, the function only sweeps the extra amount\n     *      (current contract balance - amount left to be claimed)\n     * @param _token The token to sweep\n     */\n    function sweep(address _token)\n        external\n        gacPausable\n        nonReentrant\n        onlyRole(TREASURY_OPERATIONS_ROLE)\n    {\n        uint256 amount = IERC20(_token).balanceOf(address(this));\n        require(amount > 0, \"nothing to sweep\");\n        require(\n            _token != address(asset),\n            \"cannot sweep funding asset, use claimAssetToTreasury()\"\n        );\n\n        emit Sweep(_token, amount);\n        IERC20(_token).safeTransfer(saleRecipient, amount);\n    }\n\n    /// @notice Claim accumulated asset token to treasury\n    /// @dev We let assets accumulate and batch transfer to treasury (rather than transfer atomically on each deposi)t for user gas savings\n    function claimAssetToTreasury()\n        external\n        gacPausable\n        onlyRole(TREASURY_OPERATIONS_ROLE)\n    {\n        uint256 amount = asset.balanceOf(address(this));\n        require(amount > 0, \"nothing to claim\");\n        asset.safeTransfer(saleRecipient, amount);\n\n        emit ClaimToTreasury(address(asset), amount);\n    }\n\n    /// ==============================\n    /// ===== Governance actions =====\n    /// ==============================\n\n    /**\n     * @notice Set minimum and maximum discount\n     * @dev managed by contract governance to place constraints around the parameter for policy operations to play within\n     * @param _minDiscount minimum discount (in bps)\n     * @param _maxDiscount maximum discount (in bps)\n     */\n    function setDiscountLimits(uint256 _minDiscount, uint256 _maxDiscount)\n        external\n        gacPausable\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(_maxDiscount < MAX_BPS , \"maxDiscount >= MAX_BPS\");\n        funding.minDiscount = _minDiscount;\n        funding.maxDiscount = _maxDiscount;\n\n        emit DiscountLimitsSet(_minDiscount, _maxDiscount);\n    }\n\n    /**\n     * @notice Set a discount manager address\n     * @dev This is intended to be used for an automated discount manager contract to supplement or replace manual calls\n     * @param _discountManager discount manager address\n     */\n    function setDiscountManager(address _discountManager)\n        external\n        gacPausable\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        funding.discountManager = _discountManager;\n\n        emit DiscountManagerSet(_discountManager);\n    }\n\n    function setSaleRecipient(address _saleRecipient)\n        external\n        gacPausable\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(\n            _saleRecipient != address(0),\n            \"Funding: sale recipient should not be zero\"\n        );\n\n        saleRecipient = _saleRecipient;\n        emit SaleRecipientUpdated(_saleRecipient);\n    }\n\n    function setCitadelAssetPriceBounds(uint256 _minPrice, uint256 _maxPrice)\n        external\n        gacPausable\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        minCitadelPriceInAsset = _minPrice;\n        maxCitadelPriceInAsset = _maxPrice;\n\n        emit CitadelPriceBoundsSet(_minPrice, _maxPrice);\n    }\n\n    /// ==========================\n    /// ===== Oracle actions =====\n    /// ==========================\n\n    /// @notice Update citadel price in asset terms from oracle source\n    /// @dev Note that the oracle mechanics are abstracted to the oracle address\n    function updateCitadelPriceInAsset()\n        external\n        gacPausable\n        onlyRole(KEEPER_ROLE)\n    {   \n        uint _citadelPriceInAsset;\n        bool _valid;\n\n        (_citadelPriceInAsset, _valid) = IMedianOracle(citadelPriceInAssetOracle).getData();\n\n        require(_citadelPriceInAsset > 0, \"citadel price must not be zero\");\n        require(_valid, \"oracle data must be valid\");\n\n        if (\n            _citadelPriceInAsset < minCitadelPriceInAsset ||\n            _citadelPriceInAsset > maxCitadelPriceInAsset\n        ) {\n            citadelPriceFlag = true;\n            emit CitadelPriceFlag(\n                _citadelPriceInAsset,\n                minCitadelPriceInAsset,\n                maxCitadelPriceInAsset\n            );\n        } else {\n            citadelPriceInAsset = _citadelPriceInAsset;\n            emit CitadelPriceInAssetUpdated(_citadelPriceInAsset);\n        }\n    }\n\n\n    /// @dev OUT OF AUDIT SCOPE: This is a test function that will be removed in final code\n    /// @notice Update citadel price in asset terms from oracle source\n    /// @dev Note that the oracle mechanics are abstracted to the oracle address\n    function updateCitadelPriceInAsset(uint256 _citadelPriceInAsset)\n        external\n        gacPausable\n        onlyCitadelPriceInAssetOracle\n    {\n        require(_citadelPriceInAsset > 0, \"citadel price must not be zero\");\n\n        if (\n            _citadelPriceInAsset < minCitadelPriceInAsset ||\n            _citadelPriceInAsset > maxCitadelPriceInAsset\n        ) {\n            citadelPriceFlag = true;\n            emit CitadelPriceFlag(\n                _citadelPriceInAsset,\n                minCitadelPriceInAsset,\n                maxCitadelPriceInAsset\n            );\n        } else {\n            citadelPriceInAsset = _citadelPriceInAsset;\n            emit CitadelPriceInAssetUpdated(_citadelPriceInAsset);\n        }\n    }\n}"
    }
  ]
}