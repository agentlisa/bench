{
  "Title": "[M-10] New gALCX token denomination can be depressed by the first depositor",
  "Content": "_Submitted by hyh, also found by 0xsomeone_\n\nAn attacker can become the first depositor for a recently created gALCX contract, providing a tiny amount of ALCX tokens by calling `stake(1)` (raw values here, `1` is `1 wei`, `1e18` is `1 ALCX`). Then the attacker can directly transfer, for example, `10^6 * 1e18 - 1` of ALCX to the gALCX contract and run bumpExchangeRate(), effectively setting the cost of `1` gALCX to be `10^6 * 1e18` of ALCX. The attacker will still own 100% of the gALCX's ALCX pool being the only depositor.\n\nAll subsequent depositors will have their ALCX token investments rounded to `10^6 * 1e18`, due to the lack of precision which initial tiny deposit caused, with the remainder divided between all current depositors, i.e. the subsequent depositors lose value to the attacker.\n\nFor example, if the second depositor brings in `1.9*10^6 * 1e18` of ALCX, only `1` of new vault to be issued as `1.9*10^6 * 1e18` divided by `10^6 * 1e18` will yield just `1`, which means that `2.9*10^6 * 1e18` total ALCX pool will be divided 50/50 between the second depositor and the attacker, as each will have `1 wei` of the total `2 wei` of vault tokens, i.e. the depositor lost and the attacker gained `0.45 * 10^6 * 1e18` of ALCX tokens.\n\nAs there are no penalties to exit with gALCX.unstake(), the attacker can remain staked for an arbitrary time, gathering the share of all new deposits' remainder amounts.\n\nPlacing severity to be medium as this is principal funds loss scenario for many users (most of depositors), easily executable, but only new gALCX contract instances are vulnerable.\n\n### Proof of Concept\n\ngAmount of gALCX to be minted is determined as a quotient of `amount` provided and `exchangeRate`:\n\n[gALCX.sol#L93-L94](https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-hardhat/gALCX.sol#L93-L94)<br>\n\n```solidity\n        uint gAmount = amount * exchangeRatePrecision / exchangeRate;\n        _mint(msg.sender, gAmount);\n```\n\n[gALCX.sol#L15](https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/gALCX.sol#L15)<br>\n\n```solidity\nuint public constant exchangeRatePrecision = 1e18;\n```\n\n`exchangeRate` accumulates balance increments relative to total gALCX supply:\n\n[gALCX.sol#L69-L76](https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/gALCX.sol#L69-L76)<br>\n\n```solidity\n    function bumpExchangeRate() public {\n        // Claim from pool\n        pools.claim(poolId);\n        // Bump exchange rate\n        uint balance = alcx.balanceOf(address(this));\n\n        if (balance > 0) {\n            exchangeRate += (balance * exchangeRatePrecision) / totalSupply;\n```\n\nWhen gALCX contract is new, the very first stake -> bumpExchangeRate() yields nothing as the balance is empty, i.e. `exchangeRate` is still `1e18` and `gAmount == amount`:\n\n[gALCX.sol#L85-L93](https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/gALCX.sol#L85-L93)<br>\n\n```solidity\n    function stake(uint amount) external {\n        // Get current exchange rate between ALCX and gALCX\n        bumpExchangeRate();\n        // Then receive new deposits\n        bool success = alcx.transferFrom(msg.sender, address(this), amount);\n        require(success, \"Transfer failed\");\n        pools.deposit(poolId, amount);\n        // gAmount always <= amount\n        uint gAmount = amount * exchangeRatePrecision / exchangeRate;\n```\n\nThis way, as there is no minimum amount or special treatment for the first deposit, the very first `gAmount` can be made `1 wei` with `stake(1)` call.\n\nThen, a combination of direct ALCX transfer and bumpExchangeRate() will make `exchangeRate` equal to the total amount provided by the attacker, say `10^6 * 1e18 * 1e18`, as totalSupply is `1 wei`.\n\nWhen a second depositor enters, the amount of gALCX to be minted is calculated as `amount * exchangeRatePrecision / exchangeRate`, which is `amount / (10^6 * 1e18)`, which will trunk the `amount` to the nearest divisor of `10^6 * 1e18`, effectively dividing the remainder between the depositor and the attacker.\n\nFor example, if the second depositor brings in `1.9*10^6` ALCX, only `1` (`1 wei`) of gALCX to be issued as `1.9*10^6 * 1e18 * 1e18 / (10^6 * 1e18 * 1e18)` = `1`.\n\nAs the attacker and depositor both have `1` of gALCX, each owns `(2.9 / 2)*10^6 * 1e18 = 1.45*10^6 * 1e18`, so the attacker effectively stole `0.45*10^6 * 1e18` from the depositor.\n\nAny deposit lower than total attacker's stake, `10^6 * 1e18`, will be fully stolen from the depositor as `0` gALCX tokens will be issued in this case.\n\n### References\n\nThe issue is similar to the `TOB-YEARN-003` one of the Trail of Bits audit of Yearn Finance:\n\n<https://github.com/yearn/yearn-security/tree/master/audits/20210719_ToB_yearn_vaultsv2>\n\n### Recommended Mitigation Steps\n\nA minimum for deposit value can drastically reduce the economic viability of the attack. I.e. stake() can require each amount to surpass the threshold, and then an attacker would have to provide too big direct investment to capture any meaningful share of the subsequent deposits.\n\nAn alternative is to require only the first depositor to freeze big enough initial amount of liquidity. This approach has been used long enough by various projects, for example in Uniswap V2:\n\n[Uniswap/UniswapV2Pair.sol#L119-L121](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L121)<br>\n\n**[0xfoobar (Alchemix) acknowledged, disagreed with severity and commented](https://github.com/code-423n4/2022-05-alchemix-findings/issues/135#issuecomment-1140704865):**\n\n> Not a risk with current >400 tokenholders, but good to incorporated into future designs.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-05-alchemix-findings/issues/135#issuecomment-1146370503):**\n > I think from the perspective of the contest, it is fair to assume that contracts are somewhat fresh. I'd be inclined to keep this as medium because it outlines a viable attack path that should be made public.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-alchemix-contest",
  "Code": [
    {
      "filename": "contracts-hardhat/gALCX.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.11;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\n\nimport {IALCXSource} from \"./interfaces/IALCXSource.sol\";\n\n/// @title A wrapper for single-sided ALCX staking\ncontract gALCX is ERC20 {\n\n    IERC20 public alcx = IERC20(0xdBdb4d16EdA451D0503b854CF79D55697F90c8DF);\n    IALCXSource public pools = IALCXSource(0xAB8e74017a8Cc7c15FFcCd726603790d26d7DeCa);\n    uint public poolId = 1;\n    uint public constant exchangeRatePrecision = 1e18;\n    uint public exchangeRate = exchangeRatePrecision;\n    address public owner;\n\n    event ExchangeRateChange(uint _exchangeRate);\n    event Stake(address _from, uint _gAmount, uint _amount);\n    event Unstake(address _from, uint _gAmount, uint _amount);\n\n    /// @param _name The token name\n    /// @param _symbol The token symbol\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol, 18) {\n        owner = msg.sender;\n        reApprove();\n    }\n\n    // OWNERSHIP\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    /// @notice Transfer contract ownership\n    /// @param _owner The new owner address\n    function transferOwnership(address _owner) external onlyOwner {\n        owner = _owner;\n    }\n\n    /// @notice Set a new staking pool address and migrate funds there\n    /// @param _pools The new pool address\n    /// @param _poolId The new pool id\n    function migrateSource(address _pools, uint _poolId) external onlyOwner {\n        // Withdraw ALCX\n        bumpExchangeRate();\n\n        uint poolBalance = pools.getStakeTotalDeposited(address(this), poolId);\n        pools.withdraw(poolId, poolBalance);\n        // Update staking pool address and id\n        pools = IALCXSource(_pools);\n        poolId = _poolId;\n        // Deposit ALCX\n        uint balance = alcx.balanceOf(address(this));\n        reApprove();\n        pools.deposit(poolId, balance);\n    }\n\n    /// @notice Approve the staking pool to move funds in this address, can be called by anyone\n    function reApprove() public {\n        bool success = alcx.approve(address(pools), type(uint).max);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Claim and autocompound rewards\n    function bumpExchangeRate() public {\n        // Claim from pool\n        pools.claim(poolId);\n        // Bump exchange rate\n        uint balance = alcx.balanceOf(address(this));\n\n        if (balance > 0) {\n            exchangeRate += (balance * exchangeRatePrecision) / totalSupply;\n            emit ExchangeRateChange(exchangeRate);\n            // Restake\n            pools.deposit(poolId, balance);\n        }\n    }\n\n    /// @notice Deposit new funds into the staking pool\n    /// @param amount The amount of ALCX to deposit\n    function stake(uint amount) external {\n        // Get current exchange rate between ALCX and gALCX\n        bumpExchangeRate();\n        // Then receive new deposits\n        bool success = alcx.transferFrom(msg.sender, address(this), amount);\n        require(success, \"Transfer failed\");\n        pools.deposit(poolId, amount);\n        // gAmount always <= amount\n        uint gAmount = amount * exchangeRatePrecision / exchangeRate;\n        _mint(msg.sender, gAmount);\n        emit Stake(msg.sender, gAmount, amount);\n    }\n\n    /// @notice Withdraw funds from the staking pool\n    /// @param gAmount the amount of gALCX to withdraw\n    function unstake(uint gAmount) external {\n        bumpExchangeRate();\n        uint amount = gAmount * exchangeRate / exchangeRatePrecision;\n        _burn(msg.sender, gAmount);\n        // Withdraw ALCX and send to user\n        pools.withdraw(poolId, amount);\n        bool success = alcx.transfer(msg.sender, amount); // Should return true or revert, but doesn't hurt\n        require(success, \"Transfer failed\"); \n        emit Unstake(msg.sender, gAmount, amount);\n    }\n}"
    },
    {
      "filename": "contracts-full/gALCX.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.11;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\n\nimport {IALCXSource} from \"./interfaces/IALCXSource.sol\";\n\n/// @title A wrapper for single-sided ALCX staking\ncontract gALCX is ERC20 {\n\n    IERC20 public alcx = IERC20(0xdBdb4d16EdA451D0503b854CF79D55697F90c8DF);\n    IALCXSource public pools = IALCXSource(0xAB8e74017a8Cc7c15FFcCd726603790d26d7DeCa);\n    uint public poolId = 1;\n    uint public constant exchangeRatePrecision = 1e18;\n    uint public exchangeRate = exchangeRatePrecision;\n    address public owner;\n\n    event ExchangeRateChange(uint _exchangeRate);\n    event Stake(address _from, uint _gAmount, uint _amount);\n    event Unstake(address _from, uint _gAmount, uint _amount);\n\n    /// @param _name The token name\n    /// @param _symbol The token symbol\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol, 18) {\n        owner = msg.sender;\n        reApprove();\n    }\n\n    // OWNERSHIP\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    /// @notice Transfer contract ownership\n    /// @param _owner The new owner address\n    function transferOwnership(address _owner) external onlyOwner {\n        owner = _owner;\n    }\n\n    /// @notice Set a new staking pool address and migrate funds there\n    /// @param _pools The new pool address\n    /// @param _poolId The new pool id\n    function migrateSource(address _pools, uint _poolId) external onlyOwner {\n        // Withdraw ALCX\n        bumpExchangeRate();\n\n        uint poolBalance = pools.getStakeTotalDeposited(address(this), poolId);\n        pools.withdraw(poolId, poolBalance);\n        // Update staking pool address and id\n        pools = IALCXSource(_pools);\n        poolId = _poolId;\n        // Deposit ALCX\n        uint balance = alcx.balanceOf(address(this));\n        reApprove();\n        pools.deposit(poolId, balance);\n    }\n\n    /// @notice Approve the staking pool to move funds in this address, can be called by anyone\n    function reApprove() public {\n        bool success = alcx.approve(address(pools), type(uint).max);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Claim and autocompound rewards\n    function bumpExchangeRate() public {\n        // Claim from pool\n        pools.claim(poolId);\n        // Bump exchange rate\n        uint balance = alcx.balanceOf(address(this));\n\n        if (balance > 0) {\n            exchangeRate += (balance * exchangeRatePrecision) / totalSupply;\n            emit ExchangeRateChange(exchangeRate);\n            // Restake\n            pools.deposit(poolId, balance);\n        }\n    }\n\n    /// @notice Deposit new funds into the staking pool\n    /// @param amount The amount of ALCX to deposit\n    function stake(uint amount) external {\n        // Get current exchange rate between ALCX and gALCX\n        bumpExchangeRate();\n        // Then receive new deposits\n        bool success = alcx.transferFrom(msg.sender, address(this), amount);\n        require(success, \"Transfer failed\");\n        pools.deposit(poolId, amount);\n        // gAmount always <= amount\n        uint gAmount = amount * exchangeRatePrecision / exchangeRate;\n        _mint(msg.sender, gAmount);\n        emit Stake(msg.sender, gAmount, amount);\n    }\n\n    /// @notice Withdraw funds from the staking pool\n    /// @param gAmount the amount of gALCX to withdraw\n    function unstake(uint gAmount) external {\n        bumpExchangeRate();\n        uint amount = gAmount * exchangeRate / exchangeRatePrecision;\n        _burn(msg.sender, gAmount);\n        // Withdraw ALCX and send to user\n        pools.withdraw(poolId, amount);\n        bool success = alcx.transfer(msg.sender, amount); // Should return true or revert, but doesn't hurt\n        require(success, \"Transfer failed\"); \n        emit Unstake(msg.sender, gAmount, amount);\n    }\n}"
    },
    {
      "filename": "contracts-full/gALCX.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.11;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\n\nimport {IALCXSource} from \"./interfaces/IALCXSource.sol\";\n\n/// @title A wrapper for single-sided ALCX staking\ncontract gALCX is ERC20 {\n\n    IERC20 public alcx = IERC20(0xdBdb4d16EdA451D0503b854CF79D55697F90c8DF);\n    IALCXSource public pools = IALCXSource(0xAB8e74017a8Cc7c15FFcCd726603790d26d7DeCa);\n    uint public poolId = 1;\n    uint public constant exchangeRatePrecision = 1e18;\n    uint public exchangeRate = exchangeRatePrecision;\n    address public owner;\n\n    event ExchangeRateChange(uint _exchangeRate);\n    event Stake(address _from, uint _gAmount, uint _amount);\n    event Unstake(address _from, uint _gAmount, uint _amount);\n\n    /// @param _name The token name\n    /// @param _symbol The token symbol\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol, 18) {\n        owner = msg.sender;\n        reApprove();\n    }\n\n    // OWNERSHIP\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    /// @notice Transfer contract ownership\n    /// @param _owner The new owner address\n    function transferOwnership(address _owner) external onlyOwner {\n        owner = _owner;\n    }\n\n    /// @notice Set a new staking pool address and migrate funds there\n    /// @param _pools The new pool address\n    /// @param _poolId The new pool id\n    function migrateSource(address _pools, uint _poolId) external onlyOwner {\n        // Withdraw ALCX\n        bumpExchangeRate();\n\n        uint poolBalance = pools.getStakeTotalDeposited(address(this), poolId);\n        pools.withdraw(poolId, poolBalance);\n        // Update staking pool address and id\n        pools = IALCXSource(_pools);\n        poolId = _poolId;\n        // Deposit ALCX\n        uint balance = alcx.balanceOf(address(this));\n        reApprove();\n        pools.deposit(poolId, balance);\n    }\n\n    /// @notice Approve the staking pool to move funds in this address, can be called by anyone\n    function reApprove() public {\n        bool success = alcx.approve(address(pools), type(uint).max);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Claim and autocompound rewards\n    function bumpExchangeRate() public {\n        // Claim from pool\n        pools.claim(poolId);\n        // Bump exchange rate\n        uint balance = alcx.balanceOf(address(this));\n\n        if (balance > 0) {\n            exchangeRate += (balance * exchangeRatePrecision) / totalSupply;\n            emit ExchangeRateChange(exchangeRate);\n            // Restake\n            pools.deposit(poolId, balance);\n        }\n    }\n\n    /// @notice Deposit new funds into the staking pool\n    /// @param amount The amount of ALCX to deposit\n    function stake(uint amount) external {\n        // Get current exchange rate between ALCX and gALCX\n        bumpExchangeRate();\n        // Then receive new deposits\n        bool success = alcx.transferFrom(msg.sender, address(this), amount);\n        require(success, \"Transfer failed\");\n        pools.deposit(poolId, amount);\n        // gAmount always <= amount\n        uint gAmount = amount * exchangeRatePrecision / exchangeRate;\n        _mint(msg.sender, gAmount);\n        emit Stake(msg.sender, gAmount, amount);\n    }\n\n    /// @notice Withdraw funds from the staking pool\n    /// @param gAmount the amount of gALCX to withdraw\n    function unstake(uint gAmount) external {\n        bumpExchangeRate();\n        uint amount = gAmount * exchangeRate / exchangeRatePrecision;\n        _burn(msg.sender, gAmount);\n        // Withdraw ALCX and send to user\n        pools.withdraw(poolId, amount);\n        bool success = alcx.transfer(msg.sender, amount); // Should return true or revert, but doesn't hurt\n        require(success, \"Transfer failed\"); \n        emit Unstake(msg.sender, gAmount, amount);\n    }\n}"
    },
    {
      "filename": "contracts-full/gALCX.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.11;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\n\nimport {IALCXSource} from \"./interfaces/IALCXSource.sol\";\n\n/// @title A wrapper for single-sided ALCX staking\ncontract gALCX is ERC20 {\n\n    IERC20 public alcx = IERC20(0xdBdb4d16EdA451D0503b854CF79D55697F90c8DF);\n    IALCXSource public pools = IALCXSource(0xAB8e74017a8Cc7c15FFcCd726603790d26d7DeCa);\n    uint public poolId = 1;\n    uint public constant exchangeRatePrecision = 1e18;\n    uint public exchangeRate = exchangeRatePrecision;\n    address public owner;\n\n    event ExchangeRateChange(uint _exchangeRate);\n    event Stake(address _from, uint _gAmount, uint _amount);\n    event Unstake(address _from, uint _gAmount, uint _amount);\n\n    /// @param _name The token name\n    /// @param _symbol The token symbol\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol, 18) {\n        owner = msg.sender;\n        reApprove();\n    }\n\n    // OWNERSHIP\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    /// @notice Transfer contract ownership\n    /// @param _owner The new owner address\n    function transferOwnership(address _owner) external onlyOwner {\n        owner = _owner;\n    }\n\n    /// @notice Set a new staking pool address and migrate funds there\n    /// @param _pools The new pool address\n    /// @param _poolId The new pool id\n    function migrateSource(address _pools, uint _poolId) external onlyOwner {\n        // Withdraw ALCX\n        bumpExchangeRate();\n\n        uint poolBalance = pools.getStakeTotalDeposited(address(this), poolId);\n        pools.withdraw(poolId, poolBalance);\n        // Update staking pool address and id\n        pools = IALCXSource(_pools);\n        poolId = _poolId;\n        // Deposit ALCX\n        uint balance = alcx.balanceOf(address(this));\n        reApprove();\n        pools.deposit(poolId, balance);\n    }\n\n    /// @notice Approve the staking pool to move funds in this address, can be called by anyone\n    function reApprove() public {\n        bool success = alcx.approve(address(pools), type(uint).max);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Claim and autocompound rewards\n    function bumpExchangeRate() public {\n        // Claim from pool\n        pools.claim(poolId);\n        // Bump exchange rate\n        uint balance = alcx.balanceOf(address(this));\n\n        if (balance > 0) {\n            exchangeRate += (balance * exchangeRatePrecision) / totalSupply;\n            emit ExchangeRateChange(exchangeRate);\n            // Restake\n            pools.deposit(poolId, balance);\n        }\n    }\n\n    /// @notice Deposit new funds into the staking pool\n    /// @param amount The amount of ALCX to deposit\n    function stake(uint amount) external {\n        // Get current exchange rate between ALCX and gALCX\n        bumpExchangeRate();\n        // Then receive new deposits\n        bool success = alcx.transferFrom(msg.sender, address(this), amount);\n        require(success, \"Transfer failed\");\n        pools.deposit(poolId, amount);\n        // gAmount always <= amount\n        uint gAmount = amount * exchangeRatePrecision / exchangeRate;\n        _mint(msg.sender, gAmount);\n        emit Stake(msg.sender, gAmount, amount);\n    }\n\n    /// @notice Withdraw funds from the staking pool\n    /// @param gAmount the amount of gALCX to withdraw\n    function unstake(uint gAmount) external {\n        bumpExchangeRate();\n        uint amount = gAmount * exchangeRate / exchangeRatePrecision;\n        _burn(msg.sender, gAmount);\n        // Withdraw ALCX and send to user\n        pools.withdraw(poolId, amount);\n        bool success = alcx.transfer(msg.sender, amount); // Should return true or revert, but doesn't hurt\n        require(success, \"Transfer failed\"); \n        emit Unstake(msg.sender, gAmount, amount);\n    }\n}"
    },
    {
      "filename": "contracts/UniswapV2Pair.sol",
      "content": "pragma solidity =0.5.16;\n\nimport './interfaces/IUniswapV2Pair.sol';\nimport './UniswapV2ERC20.sol';\nimport './libraries/Math.sol';\nimport './libraries/UQ112x112.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IUniswapV2Factory.sol';\nimport './interfaces/IUniswapV2Callee.sol';\n\ncontract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 {\n    using SafeMath  for uint;\n    using UQ112x112 for uint224;\n\n    uint public constant MINIMUM_LIQUIDITY = 10**3;\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n\n    address public factory;\n    address public token0;\n    address public token1;\n\n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves\n    uint112 private reserve1;           // uses single storage slot, accessible via getReserves\n    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    uint public price0CumulativeLast;\n    uint public price1CumulativeLast;\n    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\n\n    uint private unlocked = 1;\n    modifier lock() {\n        require(unlocked == 1, 'UniswapV2: LOCKED');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');\n    }\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    constructor() public {\n        factory = msg.sender;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1) external {\n        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\n        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            // * never overflows, and + overflow is desired\n            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n        }\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\n        address feeTo = IUniswapV2Factory(factory).feeTo();\n        feeOn = feeTo != address(0);\n        uint _kLast = kLast; // gas savings\n        if (feeOn) {\n            if (_kLast != 0) {\n                uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));\n                uint rootKLast = Math.sqrt(_kLast);\n                if (rootK > rootKLast) {\n                    uint numerator = totalSupply.mul(rootK.sub(rootKLast));\n                    uint denominator = rootK.mul(5).add(rootKLast);\n                    uint liquidity = numerator / denominator;\n                    if (liquidity > 0) _mint(feeTo, liquidity);\n                }\n            }\n        } else if (_kLast != 0) {\n            kLast = 0;\n        }\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address to) external lock returns (uint liquidity) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        uint balance0 = IERC20(token0).balanceOf(address(this));\n        uint balance1 = IERC20(token1).balanceOf(address(this));\n        uint amount0 = balance0.sub(_reserve0);\n        uint amount1 = balance1.sub(_reserve1);\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n           _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n        }\n        require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(address to) external lock returns (uint amount0, uint amount1) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        address _token0 = token0;                                // gas savings\n        address _token1 = token1;                                // gas savings\n        uint balance0 = IERC20(_token0).balanceOf(address(this));\n        uint balance1 = IERC20(_token1).balanceOf(address(this));\n        uint liquidity = balanceOf[address(this)];\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {\n        require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');\n\n        uint balance0;\n        uint balance1;\n        { // scope for _token{0,1}, avoids stack too deep errors\n        address _token0 = token0;\n        address _token1 = token1;\n        require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n        if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');\n        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\n        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\n        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');\n        }\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    // force balances to match reserves\n    function skim(address to) external lock {\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\n    }\n\n    // force reserves to match balances\n    function sync() external lock {\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\n    }\n}"
    }
  ]
}