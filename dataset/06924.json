{
  "Title": "[M-02] User transactions can call system contracts directly",
  "Content": "\nUser transaction can call system contracts directly, which shouldn't be allowed to not invoke potentially dangerous operations.\n\n### Proof of Concept\n\nThe [DefaultAccount.executeTransaction](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/DefaultAccount.sol#L117) executes a user transaction after it was validated. The function calls [\\_execute](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/DefaultAccount.sol#L140) under the hood. The `_execute` function makes two different calls depending on the destination address of a transaction:\n\n1.  if the `ContractDeployer` is called, it'll [pass the call to the contract](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/DefaultAccount.sol#L149) via the system call (`ContractDeployer` is a system contract and can be executed only via system calls);\n2.  if any other contract is called, it'll [execute the call via `EfficientCall.rawCall`](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/DefaultAccount.sol#L151).\n\n`EfficientCall.rawCall` in its turn also makes two different calls:\n\n1.  If `msg.value` of the transaction is 0, it'll [make a regular call](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/libraries/EfficientCall.sol#L131).\n2.  If there's some ETH sent with the transaction (i.e. `msg.value` is positive), it'll [pass the call to the `MsgValueSimulator` contract](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/libraries/EfficientCall.sol#L144). `MsgValueSimulator` is a system contract, thus the `isSystem` flag will be set in the far call ABI (notice the `true` in the [last argument of `_loadFarCallABIIntoActivePtr`](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/libraries/EfficientCall.sol#L134)). However, it'll also [set the forward mask](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/libraries/EfficientCall.sol#L141) to 1 (the value of [MSG\\_VALUE\\_SIMULATOR\\_IS\\_SYSTEM\\_BIT](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/Constants.sol#L71)). `MsgValueSimulator` will [extract the mask and will set the `isSystemCall` flag to true](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/MsgValueSimulator.sol#L27)–it'll then pass the `isSystemCall` flag to the [subsequent call](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/MsgValueSimulator.sol#L62), making the call a system one.\n\nTo sum it up, if a transaction calls a contract that's not `ContractDeployer` and sends ETH, the call will be a system one, which will let it call the system contracts. However, users shouldn't be allowed to call system contracts directly to not invoke potentially dangerous operations. As per the documentation:\n\n> Some of the system contracts can act on behalf of the user or have a very important impact on the behavior of the account. That's why we wanted to make it clear that users can not invoke potentially dangerous operations by doing a simple EVM-like call. Whenever a user wants to invoke some of the operations which we considered dangerous, they must explicitly provide isSystem flag with them.\n\nHowever, since most system contracts are harmless, there's no direct high severity impact on the system, thus I think the issue is a medium severity.\n\n### Recommended Mitigation Steps\n\nIn the `EfficientCall.rawCall` function, consider setting the forward mask to 0. The behaviour of the function is similar to that of the `msgValueSimulatorMimicCall` function from the bootloader:\n\n1.  since the `MsgValueSimulator` contract is called, the `isSystemCall` flag should be set [only for this call](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/bootloader/bootloader.yul#L1737);\n2.  the `isSystemCall` flag should be forwarded by `MsgValueSimulator` [only if the destination contract is `ContractDeployer`](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/bootloader/bootloader.yul#L1730).\n\nIt looks that the second part of the `EfficientCall.rawCall` function was copied from the `SystemContractsCaller.systemCall` function, which is intended to call system contracts and which sets the forward mask to 1 when calling `MsgValueSimulator`. However, `rawCall` shouldn't forward the `isSystemCall` flag.\n\n**[miladpiri (zkSync) confirmed and commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/146#issuecomment-1484957932):**\n > It is an issue, though realisticially most of the methods are non-payable.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/146#issuecomment-1497380450):**\n > The Warden has shown a way to bypass the security checks that would prevent a end user to be able to call system contracts.\n> \n> In lack of a loss of deposits, I agree with Medium Severity.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-03-zksync",
  "Code": [
    {
      "filename": "contracts/DefaultAccount.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IAccount.sol\";\nimport \"./libraries/TransactionHelper.sol\";\nimport \"./libraries/SystemContractHelper.sol\";\nimport \"./libraries/EfficientCall.sol\";\nimport {BOOTLOADER_FORMAL_ADDRESS, NONCE_HOLDER_SYSTEM_CONTRACT, DEPLOYER_SYSTEM_CONTRACT, INonceHolder} from \"./Constants.sol\";\n\n/**\n * @author Matter Labs\n * @notice The default implementation of account.\n * @dev The bytecode of the contract is set by default for all addresses for which no other bytecodes are deployed.\n * @notice If the caller is not a bootloader always returns empty data on call, just like EOA does.\n * @notice If it is delegate called always returns empty data, just like EOA does.\n */\ncontract DefaultAccount is IAccount {\n    using TransactionHelper for *;\n\n    /**\n     * @dev Simulate the behavior of the EOA if the caller is not the bootloader.\n     * Essentially, for all non-bootloader callers halt the execution with empty return data.\n     * If all functions will use this modifier AND the contract will implement an empty payable fallback()\n     * then the contract will be indistinguishable from the EOA when called.\n     */\n    modifier ignoreNonBootloader() {\n        if (msg.sender != BOOTLOADER_FORMAL_ADDRESS) {\n            // If function was called outside of the bootloader, behave like an EOA.\n            assembly {\n                return(0, 0)\n            }\n        }\n        // Continue execution if called from the bootloader.\n        _;\n    }\n\n    /**\n     * @dev Simulate the behavior of the EOA if it is called via `delegatecall`.\n     * Thus, the default account on a delegate call behaves the same as EOA on Ethereum.\n     * If all functions will use this modifier AND the contract will implement an empty payable fallback()\n     * then the contract will be indistinguishable from the EOA when called.\n     */\n    modifier ignoreInDelegateCall() {\n        address codeAddress = SystemContractHelper.getCodeAddress();\n        if (codeAddress != address(this)) {\n            // If the function was delegate called, behave like an EOA.\n            assembly {\n                return(0, 0)\n            }\n        }\n\n        // Continue execution if not delegate called.\n        _;\n    }\n\n    /// @notice Validates the transaction & increments nonce.\n    /// @dev The transaction is considered accepted by the account if\n    /// the call to this function by the bootloader does not revert\n    /// and the nonce has been set as used.\n    /// @param _suggestedSignedHash The suggested hash of the transaction to be signed by the user.\n    /// This is the hash that is signed by the EOA by default.\n    /// @param _transaction The transaction structure itself.\n    /// @dev Besides the params above, it also accepts unused first paramter \"_txHash\", which\n    /// is the unique (canonical) hash of the transaction.\n    function validateTransaction(\n        bytes32, // _txHash\n        bytes32 _suggestedSignedHash,\n        Transaction calldata _transaction\n    ) external payable override ignoreNonBootloader ignoreInDelegateCall returns (bytes4 magic) {\n        magic = _validateTransaction(_suggestedSignedHash, _transaction);\n    }\n\n    /// @notice Inner method for validating transaction and increasing the nonce\n    /// @param _suggestedSignedHash The hash of the transaction signed by the EOA\n    /// @param _transaction The transaction.\n    function _validateTransaction(\n        bytes32 _suggestedSignedHash,\n        Transaction calldata _transaction\n    ) internal returns (bytes4 magic) {\n        // Note, that nonce holder can only be called with \"isSystem\" flag.\n        SystemContractsCaller.systemCallWithPropagatedRevert(\n            uint32(gasleft()),\n            address(NONCE_HOLDER_SYSTEM_CONTRACT),\n            0,\n            abi.encodeCall(INonceHolder.incrementMinNonceIfEquals, (_transaction.nonce))\n        );\n\n        // Even though for the transaction types present in the system right now,\n        // we always provide the suggested signed hash, this should not be\n        // always expected. In case the bootloader has no clue what the default hash\n        // is, the bytes32(0) will be supplied.\n        bytes32 txHash = _suggestedSignedHash != bytes32(0) ? _suggestedSignedHash : _transaction.encodeHash();\n\n        if (_transaction.to == uint256(uint160(address(DEPLOYER_SYSTEM_CONTRACT)))) {\n            require(_transaction.data.length >= 4, \"Invalid call to ContractDeployer\");\n        }\n\n        // The fact there is are enough balance for the account\n        // should be checked explicitly to prevent user paying for fee for a\n        // transaction that wouldn't be included on Ethereum.\n        uint256 totalRequiredBalance = _transaction.totalRequiredBalance();\n        require(totalRequiredBalance <= address(this).balance, \"Not enough balance for fee + value\");\n\n        if (_isValidSignature(txHash, _transaction.signature)) {\n            magic = ACCOUNT_VALIDATION_SUCCESS_MAGIC;\n        } else {\n            magic = bytes4(0);\n        }\n    }\n\n    /// @notice Method called by the bootloader to execute the transaction.\n    /// @param _transaction The transaction to execute.\n    /// @dev It also accepts unused _txHash and _suggestedSignedHash parameters:\n    /// the unique (canonical) hash of the transaction and the suggested signed\n    /// hash of the transaction.\n    function executeTransaction(\n        bytes32, // _txHash\n        bytes32, // _suggestedSignedHash\n        Transaction calldata _transaction\n    ) external payable override ignoreNonBootloader ignoreInDelegateCall {\n        _execute(_transaction);\n    }\n\n    /// @notice Method that should be used to initiate a transaction from this account\n    /// by an external call. This is not mandatory but should be implemented so that\n    /// it is always possible to execute transactions from L1 for this account.\n    /// @dev This method is basically validate + execute.\n    /// @param _transaction The transaction to execute.\n    function executeTransactionFromOutside(\n        Transaction calldata _transaction\n    ) external payable override ignoreNonBootloader ignoreInDelegateCall {\n        // The account recalculate the hash on its own\n        _validateTransaction(bytes32(0), _transaction);\n        _execute(_transaction);\n    }\n\n    /// @notice Inner method for executing a transaction.\n    /// @param _transaction The transaction to execute.\n    function _execute(Transaction calldata _transaction) internal {\n        address to = address(uint160(_transaction.to));\n        uint128 value = Utils.safeCastToU128(_transaction.value);\n        bytes calldata data = _transaction.data;\n        uint32 gas = Utils.safeCastToU32(gasleft());\n\n        if (to == address(DEPLOYER_SYSTEM_CONTRACT)) {\n            // Note, that the deployer contract can only be called\n            // with a \"systemCall\" flag.\n            SystemContractsCaller.systemCallWithPropagatedRevert(gas, to, value, data);\n        } else {\n            bool success = EfficientCall.rawCall(gas, to, value, data);\n            if (!success) {\n                EfficientCall.propagateRevert();\n            }\n        }\n    }\n\n    /// @notice Validation that the ECDSA signature of the transaction is correct.\n    /// @param _hash The hash of the transaction to be signed.\n    /// @param _signature The signature of the transaction.\n    /// @return EIP1271_SUCCESS_RETURN_VALUE if the signaure is correct. It reverts otherwise.\n    function _isValidSignature(bytes32 _hash, bytes memory _signature) internal view returns (bool) {\n        require(_signature.length == 65, \"Signature length is incorrect\");\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        // Signature loading code\n        // we jump 32 (0x20) as the first slot of bytes contains the length\n        // we jump 65 (0x41) per signature\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\n        assembly {\n            r := mload(add(_signature, 0x20))\n            s := mload(add(_signature, 0x40))\n            v := and(mload(add(_signature, 0x41)), 0xff)\n        }\n        require(v == 27 || v == 28, \"v is neither 27 nor 28\");\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Invalid s\");\n\n        address recoveredAddress = ecrecover(_hash, v, r, s);\n\n        return recoveredAddress == address(this) && recoveredAddress != address(0);\n    }\n\n    /// @notice Method for paying the bootloader for the transaction.\n    /// @param _transaction The transaction for which the fee is paid.\n    /// @dev It also accepts unused _txHash and _suggestedSignedHash parameters:\n    /// the unique (canonical) hash of the transaction and the suggested signed\n    /// hash of the transaction.\n    function payForTransaction(\n        bytes32, // _txHash\n        bytes32, // _suggestedSignedHash\n        Transaction calldata _transaction\n    ) external payable ignoreNonBootloader ignoreInDelegateCall {\n        bool success = _transaction.payToTheBootloader();\n        require(success, \"Failed to pay the fee to the operator\");\n    }\n\n    /// @notice Method, where the user should prepare for the transaction to be\n    /// paid for by a paymaster.\n    /// @dev Here, the account should set the allowance for the smart contracts\n    /// @param _transaction The transaction.\n    /// @dev It also accepts unused _txHash and _suggestedSignedHash parameters:\n    /// the unique (canonical) hash of the transaction and the suggested signed\n    /// hash of the transaction.\n    function prepareForPaymaster(\n        bytes32, // _txHash\n        bytes32, // _suggestedSignedHash\n        Transaction calldata _transaction\n    ) external payable ignoreNonBootloader ignoreInDelegateCall {\n        _transaction.processPaymasterInput();\n    }\n\n    fallback() external {\n        // fallback of default account shouldn't be called by bootloader under no circumstances\n        assert(msg.sender != BOOTLOADER_FORMAL_ADDRESS);\n\n        // If the contract is called directly, behave like an EOA\n    }\n\n    receive() external payable {\n        // If the contract is called directly, behave like an EOA\n    }\n}"
    },
    {
      "filename": "contracts/DefaultAccount.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IAccount.sol\";\nimport \"./libraries/TransactionHelper.sol\";\nimport \"./libraries/SystemContractHelper.sol\";\nimport \"./libraries/EfficientCall.sol\";\nimport {BOOTLOADER_FORMAL_ADDRESS, NONCE_HOLDER_SYSTEM_CONTRACT, DEPLOYER_SYSTEM_CONTRACT, INonceHolder} from \"./Constants.sol\";\n\n/**\n * @author Matter Labs\n * @notice The default implementation of account.\n * @dev The bytecode of the contract is set by default for all addresses for which no other bytecodes are deployed.\n * @notice If the caller is not a bootloader always returns empty data on call, just like EOA does.\n * @notice If it is delegate called always returns empty data, just like EOA does.\n */\ncontract DefaultAccount is IAccount {\n    using TransactionHelper for *;\n\n    /**\n     * @dev Simulate the behavior of the EOA if the caller is not the bootloader.\n     * Essentially, for all non-bootloader callers halt the execution with empty return data.\n     * If all functions will use this modifier AND the contract will implement an empty payable fallback()\n     * then the contract will be indistinguishable from the EOA when called.\n     */\n    modifier ignoreNonBootloader() {\n        if (msg.sender != BOOTLOADER_FORMAL_ADDRESS) {\n            // If function was called outside of the bootloader, behave like an EOA.\n            assembly {\n                return(0, 0)\n            }\n        }\n        // Continue execution if called from the bootloader.\n        _;\n    }\n\n    /**\n     * @dev Simulate the behavior of the EOA if it is called via `delegatecall`.\n     * Thus, the default account on a delegate call behaves the same as EOA on Ethereum.\n     * If all functions will use this modifier AND the contract will implement an empty payable fallback()\n     * then the contract will be indistinguishable from the EOA when called.\n     */\n    modifier ignoreInDelegateCall() {\n        address codeAddress = SystemContractHelper.getCodeAddress();\n        if (codeAddress != address(this)) {\n            // If the function was delegate called, behave like an EOA.\n            assembly {\n                return(0, 0)\n            }\n        }\n\n        // Continue execution if not delegate called.\n        _;\n    }\n\n    /// @notice Validates the transaction & increments nonce.\n    /// @dev The transaction is considered accepted by the account if\n    /// the call to this function by the bootloader does not revert\n    /// and the nonce has been set as used.\n    /// @param _suggestedSignedHash The suggested hash of the transaction to be signed by the user.\n    /// This is the hash that is signed by the EOA by default.\n    /// @param _transaction The transaction structure itself.\n    /// @dev Besides the params above, it also accepts unused first paramter \"_txHash\", which\n    /// is the unique (canonical) hash of the transaction.\n    function validateTransaction(\n        bytes32, // _txHash\n        bytes32 _suggestedSignedHash,\n        Transaction calldata _transaction\n    ) external payable override ignoreNonBootloader ignoreInDelegateCall returns (bytes4 magic) {\n        magic = _validateTransaction(_suggestedSignedHash, _transaction);\n    }\n\n    /// @notice Inner method for validating transaction and increasing the nonce\n    /// @param _suggestedSignedHash The hash of the transaction signed by the EOA\n    /// @param _transaction The transaction.\n    function _validateTransaction(\n        bytes32 _suggestedSignedHash,\n        Transaction calldata _transaction\n    ) internal returns (bytes4 magic) {\n        // Note, that nonce holder can only be called with \"isSystem\" flag.\n        SystemContractsCaller.systemCallWithPropagatedRevert(\n            uint32(gasleft()),\n            address(NONCE_HOLDER_SYSTEM_CONTRACT),\n            0,\n            abi.encodeCall(INonceHolder.incrementMinNonceIfEquals, (_transaction.nonce))\n        );\n\n        // Even though for the transaction types present in the system right now,\n        // we always provide the suggested signed hash, this should not be\n        // always expected. In case the bootloader has no clue what the default hash\n        // is, the bytes32(0) will be supplied.\n        bytes32 txHash = _suggestedSignedHash != bytes32(0) ? _suggestedSignedHash : _transaction.encodeHash();\n\n        if (_transaction.to == uint256(uint160(address(DEPLOYER_SYSTEM_CONTRACT)))) {\n            require(_transaction.data.length >= 4, \"Invalid call to ContractDeployer\");\n        }\n\n        // The fact there is are enough balance for the account\n        // should be checked explicitly to prevent user paying for fee for a\n        // transaction that wouldn't be included on Ethereum.\n        uint256 totalRequiredBalance = _transaction.totalRequiredBalance();\n        require(totalRequiredBalance <= address(this).balance, \"Not enough balance for fee + value\");\n\n        if (_isValidSignature(txHash, _transaction.signature)) {\n            magic = ACCOUNT_VALIDATION_SUCCESS_MAGIC;\n        } else {\n            magic = bytes4(0);\n        }\n    }\n\n    /// @notice Method called by the bootloader to execute the transaction.\n    /// @param _transaction The transaction to execute.\n    /// @dev It also accepts unused _txHash and _suggestedSignedHash parameters:\n    /// the unique (canonical) hash of the transaction and the suggested signed\n    /// hash of the transaction.\n    function executeTransaction(\n        bytes32, // _txHash\n        bytes32, // _suggestedSignedHash\n        Transaction calldata _transaction\n    ) external payable override ignoreNonBootloader ignoreInDelegateCall {\n        _execute(_transaction);\n    }\n\n    /// @notice Method that should be used to initiate a transaction from this account\n    /// by an external call. This is not mandatory but should be implemented so that\n    /// it is always possible to execute transactions from L1 for this account.\n    /// @dev This method is basically validate + execute.\n    /// @param _transaction The transaction to execute.\n    function executeTransactionFromOutside(\n        Transaction calldata _transaction\n    ) external payable override ignoreNonBootloader ignoreInDelegateCall {\n        // The account recalculate the hash on its own\n        _validateTransaction(bytes32(0), _transaction);\n        _execute(_transaction);\n    }\n\n    /// @notice Inner method for executing a transaction.\n    /// @param _transaction The transaction to execute.\n    function _execute(Transaction calldata _transaction) internal {\n        address to = address(uint160(_transaction.to));\n        uint128 value = Utils.safeCastToU128(_transaction.value);\n        bytes calldata data = _transaction.data;\n        uint32 gas = Utils.safeCastToU32(gasleft());\n\n        if (to == address(DEPLOYER_SYSTEM_CONTRACT)) {\n            // Note, that the deployer contract can only be called\n            // with a \"systemCall\" flag.\n            SystemContractsCaller.systemCallWithPropagatedRevert(gas, to, value, data);\n        } else {\n            bool success = EfficientCall.rawCall(gas, to, value, data);\n            if (!success) {\n                EfficientCall.propagateRevert();\n            }\n        }\n    }\n\n    /// @notice Validation that the ECDSA signature of the transaction is correct.\n    /// @param _hash The hash of the transaction to be signed.\n    /// @param _signature The signature of the transaction.\n    /// @return EIP1271_SUCCESS_RETURN_VALUE if the signaure is correct. It reverts otherwise.\n    function _isValidSignature(bytes32 _hash, bytes memory _signature) internal view returns (bool) {\n        require(_signature.length == 65, \"Signature length is incorrect\");\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        // Signature loading code\n        // we jump 32 (0x20) as the first slot of bytes contains the length\n        // we jump 65 (0x41) per signature\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\n        assembly {\n            r := mload(add(_signature, 0x20))\n            s := mload(add(_signature, 0x40))\n            v := and(mload(add(_signature, 0x41)), 0xff)\n        }\n        require(v == 27 || v == 28, \"v is neither 27 nor 28\");\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Invalid s\");\n\n        address recoveredAddress = ecrecover(_hash, v, r, s);\n\n        return recoveredAddress == address(this) && recoveredAddress != address(0);\n    }\n\n    /// @notice Method for paying the bootloader for the transaction.\n    /// @param _transaction The transaction for which the fee is paid.\n    /// @dev It also accepts unused _txHash and _suggestedSignedHash parameters:\n    /// the unique (canonical) hash of the transaction and the suggested signed\n    /// hash of the transaction.\n    function payForTransaction(\n        bytes32, // _txHash\n        bytes32, // _suggestedSignedHash\n        Transaction calldata _transaction\n    ) external payable ignoreNonBootloader ignoreInDelegateCall {\n        bool success = _transaction.payToTheBootloader();\n        require(success, \"Failed to pay the fee to the operator\");\n    }\n\n    /// @notice Method, where the user should prepare for the transaction to be\n    /// paid for by a paymaster.\n    /// @dev Here, the account should set the allowance for the smart contracts\n    /// @param _transaction The transaction.\n    /// @dev It also accepts unused _txHash and _suggestedSignedHash parameters:\n    /// the unique (canonical) hash of the transaction and the suggested signed\n    /// hash of the transaction.\n    function prepareForPaymaster(\n        bytes32, // _txHash\n        bytes32, // _suggestedSignedHash\n        Transaction calldata _transaction\n    ) external payable ignoreNonBootloader ignoreInDelegateCall {\n        _transaction.processPaymasterInput();\n    }\n\n    fallback() external {\n        // fallback of default account shouldn't be called by bootloader under no circumstances\n        assert(msg.sender != BOOTLOADER_FORMAL_ADDRESS);\n\n        // If the contract is called directly, behave like an EOA\n    }\n\n    receive() external payable {\n        // If the contract is called directly, behave like an EOA\n    }\n}"
    },
    {
      "filename": "contracts/DefaultAccount.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IAccount.sol\";\nimport \"./libraries/TransactionHelper.sol\";\nimport \"./libraries/SystemContractHelper.sol\";\nimport \"./libraries/EfficientCall.sol\";\nimport {BOOTLOADER_FORMAL_ADDRESS, NONCE_HOLDER_SYSTEM_CONTRACT, DEPLOYER_SYSTEM_CONTRACT, INonceHolder} from \"./Constants.sol\";\n\n/**\n * @author Matter Labs\n * @notice The default implementation of account.\n * @dev The bytecode of the contract is set by default for all addresses for which no other bytecodes are deployed.\n * @notice If the caller is not a bootloader always returns empty data on call, just like EOA does.\n * @notice If it is delegate called always returns empty data, just like EOA does.\n */\ncontract DefaultAccount is IAccount {\n    using TransactionHelper for *;\n\n    /**\n     * @dev Simulate the behavior of the EOA if the caller is not the bootloader.\n     * Essentially, for all non-bootloader callers halt the execution with empty return data.\n     * If all functions will use this modifier AND the contract will implement an empty payable fallback()\n     * then the contract will be indistinguishable from the EOA when called.\n     */\n    modifier ignoreNonBootloader() {\n        if (msg.sender != BOOTLOADER_FORMAL_ADDRESS) {\n            // If function was called outside of the bootloader, behave like an EOA.\n            assembly {\n                return(0, 0)\n            }\n        }\n        // Continue execution if called from the bootloader.\n        _;\n    }\n\n    /**\n     * @dev Simulate the behavior of the EOA if it is called via `delegatecall`.\n     * Thus, the default account on a delegate call behaves the same as EOA on Ethereum.\n     * If all functions will use this modifier AND the contract will implement an empty payable fallback()\n     * then the contract will be indistinguishable from the EOA when called.\n     */\n    modifier ignoreInDelegateCall() {\n        address codeAddress = SystemContractHelper.getCodeAddress();\n        if (codeAddress != address(this)) {\n            // If the function was delegate called, behave like an EOA.\n            assembly {\n                return(0, 0)\n            }\n        }\n\n        // Continue execution if not delegate called.\n        _;\n    }\n\n    /// @notice Validates the transaction & increments nonce.\n    /// @dev The transaction is considered accepted by the account if\n    /// the call to this function by the bootloader does not revert\n    /// and the nonce has been set as used.\n    /// @param _suggestedSignedHash The suggested hash of the transaction to be signed by the user.\n    /// This is the hash that is signed by the EOA by default.\n    /// @param _transaction The transaction structure itself.\n    /// @dev Besides the params above, it also accepts unused first paramter \"_txHash\", which\n    /// is the unique (canonical) hash of the transaction.\n    function validateTransaction(\n        bytes32, // _txHash\n        bytes32 _suggestedSignedHash,\n        Transaction calldata _transaction\n    ) external payable override ignoreNonBootloader ignoreInDelegateCall returns (bytes4 magic) {\n        magic = _validateTransaction(_suggestedSignedHash, _transaction);\n    }\n\n    /// @notice Inner method for validating transaction and increasing the nonce\n    /// @param _suggestedSignedHash The hash of the transaction signed by the EOA\n    /// @param _transaction The transaction.\n    function _validateTransaction(\n        bytes32 _suggestedSignedHash,\n        Transaction calldata _transaction\n    ) internal returns (bytes4 magic) {\n        // Note, that nonce holder can only be called with \"isSystem\" flag.\n        SystemContractsCaller.systemCallWithPropagatedRevert(\n            uint32(gasleft()),\n            address(NONCE_HOLDER_SYSTEM_CONTRACT),\n            0,\n            abi.encodeCall(INonceHolder.incrementMinNonceIfEquals, (_transaction.nonce))\n        );\n\n        // Even though for the transaction types present in the system right now,\n        // we always provide the suggested signed hash, this should not be\n        // always expected. In case the bootloader has no clue what the default hash\n        // is, the bytes32(0) will be supplied.\n        bytes32 txHash = _suggestedSignedHash != bytes32(0) ? _suggestedSignedHash : _transaction.encodeHash();\n\n        if (_transaction.to == uint256(uint160(address(DEPLOYER_SYSTEM_CONTRACT)))) {\n            require(_transaction.data.length >= 4, \"Invalid call to ContractDeployer\");\n        }\n\n        // The fact there is are enough balance for the account\n        // should be checked explicitly to prevent user paying for fee for a\n        // transaction that wouldn't be included on Ethereum.\n        uint256 totalRequiredBalance = _transaction.totalRequiredBalance();\n        require(totalRequiredBalance <= address(this).balance, \"Not enough balance for fee + value\");\n\n        if (_isValidSignature(txHash, _transaction.signature)) {\n            magic = ACCOUNT_VALIDATION_SUCCESS_MAGIC;\n        } else {\n            magic = bytes4(0);\n        }\n    }\n\n    /// @notice Method called by the bootloader to execute the transaction.\n    /// @param _transaction The transaction to execute.\n    /// @dev It also accepts unused _txHash and _suggestedSignedHash parameters:\n    /// the unique (canonical) hash of the transaction and the suggested signed\n    /// hash of the transaction.\n    function executeTransaction(\n        bytes32, // _txHash\n        bytes32, // _suggestedSignedHash\n        Transaction calldata _transaction\n    ) external payable override ignoreNonBootloader ignoreInDelegateCall {\n        _execute(_transaction);\n    }\n\n    /// @notice Method that should be used to initiate a transaction from this account\n    /// by an external call. This is not mandatory but should be implemented so that\n    /// it is always possible to execute transactions from L1 for this account.\n    /// @dev This method is basically validate + execute.\n    /// @param _transaction The transaction to execute.\n    function executeTransactionFromOutside(\n        Transaction calldata _transaction\n    ) external payable override ignoreNonBootloader ignoreInDelegateCall {\n        // The account recalculate the hash on its own\n        _validateTransaction(bytes32(0), _transaction);\n        _execute(_transaction);\n    }\n\n    /// @notice Inner method for executing a transaction.\n    /// @param _transaction The transaction to execute.\n    function _execute(Transaction calldata _transaction) internal {\n        address to = address(uint160(_transaction.to));\n        uint128 value = Utils.safeCastToU128(_transaction.value);\n        bytes calldata data = _transaction.data;\n        uint32 gas = Utils.safeCastToU32(gasleft());\n\n        if (to == address(DEPLOYER_SYSTEM_CONTRACT)) {\n            // Note, that the deployer contract can only be called\n            // with a \"systemCall\" flag.\n            SystemContractsCaller.systemCallWithPropagatedRevert(gas, to, value, data);\n        } else {\n            bool success = EfficientCall.rawCall(gas, to, value, data);\n            if (!success) {\n                EfficientCall.propagateRevert();\n            }\n        }\n    }\n\n    /// @notice Validation that the ECDSA signature of the transaction is correct.\n    /// @param _hash The hash of the transaction to be signed.\n    /// @param _signature The signature of the transaction.\n    /// @return EIP1271_SUCCESS_RETURN_VALUE if the signaure is correct. It reverts otherwise.\n    function _isValidSignature(bytes32 _hash, bytes memory _signature) internal view returns (bool) {\n        require(_signature.length == 65, \"Signature length is incorrect\");\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        // Signature loading code\n        // we jump 32 (0x20) as the first slot of bytes contains the length\n        // we jump 65 (0x41) per signature\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\n        assembly {\n            r := mload(add(_signature, 0x20))\n            s := mload(add(_signature, 0x40))\n            v := and(mload(add(_signature, 0x41)), 0xff)\n        }\n        require(v == 27 || v == 28, \"v is neither 27 nor 28\");\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Invalid s\");\n\n        address recoveredAddress = ecrecover(_hash, v, r, s);\n\n        return recoveredAddress == address(this) && recoveredAddress != address(0);\n    }\n\n    /// @notice Method for paying the bootloader for the transaction.\n    /// @param _transaction The transaction for which the fee is paid.\n    /// @dev It also accepts unused _txHash and _suggestedSignedHash parameters:\n    /// the unique (canonical) hash of the transaction and the suggested signed\n    /// hash of the transaction.\n    function payForTransaction(\n        bytes32, // _txHash\n        bytes32, // _suggestedSignedHash\n        Transaction calldata _transaction\n    ) external payable ignoreNonBootloader ignoreInDelegateCall {\n        bool success = _transaction.payToTheBootloader();\n        require(success, \"Failed to pay the fee to the operator\");\n    }\n\n    /// @notice Method, where the user should prepare for the transaction to be\n    /// paid for by a paymaster.\n    /// @dev Here, the account should set the allowance for the smart contracts\n    /// @param _transaction The transaction.\n    /// @dev It also accepts unused _txHash and _suggestedSignedHash parameters:\n    /// the unique (canonical) hash of the transaction and the suggested signed\n    /// hash of the transaction.\n    function prepareForPaymaster(\n        bytes32, // _txHash\n        bytes32, // _suggestedS"
    }
  ]
}