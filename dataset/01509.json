{
  "Title": "Missing docstrings",
  "Content": "The following instances of missing docstrings were identified:\n\n\n* Lines [11](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/Land/erc721/ERC721BaseTokenV2.sol#L11) and [32](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/Land/erc721/ERC721BaseTokenV2.sol#L32-L35) in `ERC721BaseTokenV2.sol`\n* [Line 6](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/Land/erc721/LandBaseTokenV3.sol#L6) in `LandBaseTokenV3.sol`\n* [Line 9](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/LandV3.sol#L9) in `LandV3.sol`\n* Lines [4](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L4), [5](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L5), [7](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L7), [9](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L9), [11](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L11), [13](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L13), [19](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L19), [25](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L25), [31](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L31), [37](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L37), [41](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L41), [43](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L43), [45](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L45), [47](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L47), [49](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L49), [51](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L51), [53](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L53), [55](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L55), [57](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L57), [59](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L59), [61](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L61), [63](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L63), and [65](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L65) in `IOperatorFilterRegistry.sol`\n* [Line 6](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/contracts_common/BaseWithStorage/MetaTransactionReceiverV2.sol#L6) in `MetaTransactionReceiverV2.sol`\n* [Line 5](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/contracts_common/BaseWithStorage/SuperOperatorsV2.sol#L5) in `SuperOperatorsV2`.sol\n* Lines [12](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/contracts_common/Interfaces/ERC721MandatoryTokenReceiver.sol#L7-L12) and [19](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/contracts_common/Interfaces/ERC721MandatoryTokenReceiver.sol#L14-L19) in `ERC721MandatoryTokenReceiver.sol`\n* Lines [11](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/contracts_common/Interfaces/ERC721TokenReceiver.sol#L11) and [17](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/contracts_common/Interfaces/ERC721TokenReceiver.sol#L12-L17) in `ERC721TokenReceiver.sol`\n* [Line 3](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/contracts_common/Libraries/AddressUtils.sol#L3) in `AddressUtils.sol`\n* Lines [4](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L4), [5](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L5), [7](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L7), [9](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L9), [11](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L11), [13](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L13), [19](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L19), [25](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L25), [31](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L31), [37](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L37), [39](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L39), [41](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L41), [43](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L43), [45](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L45), [47](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L47), [49](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L49), [51](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L51), [53](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L53), [55](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L55), [57](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L57), [59](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L59), [61](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L61), [63](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L63), and [65](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol#L65) in `IOperatorFilterRegistry.sol`\n* Lines [16](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/BaseWithStorage/ERC2771Handler.sol#L16) and [20](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/BaseWithStorage/ERC2771Handler.sol#L20) in `ERC2771Handler.sol`\n* [Line 13](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/BaseWithStorage/ERC721BaseTokenV2.sol#L13) in `ERC721BaseTokenV2.sol`\n* [Line 7](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/BaseWithStorage/WithAdminV2.sol#L7) in `WithAdminV2.sol`\n* [Line 8](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/BaseWithStorage/WithSuperOperatorsV2.sol#L8) in `WithSuperOperatorsV2.sol`\n* [Line 6](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/fx-portal/FxBaseChildTunnelUpgradeable.sol#L6) in `FxBaseChildTunnelUpgradeable.sol`\n* [Line 10](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/fx-portal/FxBaseRootTunnelUpgradeable.sol#L10) in `FxBaseRootTunnelUpgradeable.sol`\n* Lines [12](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/interfaces/IERC721MandatoryTokenReceiver.sol#L7-L12) and [19](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/interfaces/IERC721MandatoryTokenReceiver.sol#L14-L19) in `IERC721MandatoryTokenReceiver.sol`\n* Lines [4](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/interfaces/ILandToken.sol#L4), [5](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/interfaces/ILandToken.sol#L5), [14](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/interfaces/ILandToken.sol#L14), and [23](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/interfaces/ILandToken.sol#L23) in `ILandToken.sol`\n* Lines [6](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/interfaces/ILandTokenV2.sol#L6), [7](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/interfaces/ILandTokenV2.sol#L7), [13](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/interfaces/ILandTokenV2.sol#L9-L13), [21](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/interfaces/ILandTokenV2.sol#L15-L21), and [29](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/interfaces/ILandTokenV2.sol#L23-L29) in `ILandTokenV2.sol`\n* Lines [6](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/interfaces/IPolygonLand.sol#L6), [13](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/interfaces/IPolygonLand.sol#L7-L13), and [19](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/interfaces/IPolygonLand.sol#L15-L19) in `IPolygonLand.sol`\n* Lines [4](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/interfaces/IPolygonLandTunnel.sol#L4) and [11](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/interfaces/IPolygonLandTunnel.sol#L5-L11) in `IPolygonLandTunnel.sol`\n* Lines [6](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/interfaces/IPolygonLandWithSetApproval.sol#L6) and [7](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/interfaces/IPolygonLandWithSetApproval.sol#L7) in `IPolygonLandWithSetApproval.sol`\n* Lines [10](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/child/land/PolygonLandBaseTokenV2.sol#L10), and [195](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/child/land/PolygonLandBaseTokenV2.sol#L190-L195) in `PolygonLandBaseTokenV2.sol`\n* [Line 13](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/child/land/PolygonLandTunnelV2.sol#L13) in `PolygonLandTunnelV2.sol`\n* Lines [14](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/child/land/PolygonLandV2.sol#L14), [30](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/root/land/LandTunnelV2.sol#L25-L30), and [77](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/root/land/LandTunnelV2.sol#L71-L77) in `LandTunnelV2.sol`\n* Lines [122](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/child/land/PolygonLandTunnelMigration.sol#L122) and [131](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/child/land/PolygonLandTunnelMigration.sol#L131) of `PolygonLandTunnelMigration.sol`\n* Lines [6](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/interfaces/IPolygonLandV2.sol#L6), [7](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/interfaces/IPolygonLandV2.sol#L7), and [15](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/interfaces/IPolygonLandV2.sol#L15) of `IPolygonLandV2.sol`\n* [Line 38](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/root/land/LandTunnelMigration.sol#L38-L43) of `LandTunnelMigration.sol`\n\n\nAdditionally, there are cases that require further completion:\n\n\n* The return from the [`supportsInterface` function](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/root/land/LandTunnelV2.sol#L67) in the `LandTunnelV2` contract is undocumented.\n* The return from the [`supportsInterface` function](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/child/land/PolygonLandTunnelV2.sol#L171) in the `PolygonLandTunnelV2` contract is undocumented.\n* The `_childToken` argument to the [`initialize` function](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/child/land/PolygonLandTunnelV2.sol#L71-L78) in the `PolygonLandTunnelV2` contract is undocumented.\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec).\n\n\n***Update:** Resolved in [pull request #907](https://github.com/thesandboxgame/sandbox-smart-contracts/pull/907) at commit [9ddf8c9](https://github.com/thesandboxgame/sandbox-smart-contracts/pull/907/commits/9ddf8c991294157474aa741ea7f14b69c7b9e06e).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/solc_0.5/Land/erc721/ERC721BaseTokenV2.sol",
      "content": "/* solhint-disable func-order, code-complexity */\npragma solidity 0.5.9;\n\nimport \"../../contracts_common/Libraries/AddressUtils.sol\";\nimport \"../../contracts_common/Interfaces/ERC721TokenReceiver.sol\";\nimport \"../../contracts_common/Interfaces/ERC721Events.sol\";\nimport \"../../contracts_common/BaseWithStorage/SuperOperatorsV2.sol\";\nimport \"../../contracts_common/BaseWithStorage/MetaTransactionReceiverV2.sol\";\nimport \"../../contracts_common/Interfaces/ERC721MandatoryTokenReceiver.sol\";\n\ncontract ERC721BaseTokenV2 is ERC721Events, SuperOperatorsV2, MetaTransactionReceiverV2 {\n    using AddressUtils for address;\n\n    bytes4 internal constant _ERC721_RECEIVED = 0x150b7a02;\n    bytes4 internal constant _ERC721_BATCH_RECEIVED = 0x4b808c46;\n\n    bytes4 internal constant ERC165ID = 0x01ffc9a7;\n    bytes4 internal constant ERC721_MANDATORY_RECEIVER = 0x5e8bf644;\n\n    mapping (address => uint256) public _numNFTPerAddress;\n    mapping (uint256 => uint256) public _owners;\n    mapping (address => mapping(address => bool)) public _operatorsForAll;\n    mapping (uint256 => address) public _operators;\n\n    bool internal _initialized;\n\n    modifier initializer() {\n        require(!_initialized, \"ERC721BaseToken: Contract already initialized\");\n        _;\n    }\n\n    function initialize (\n        address metaTransactionContract,\n        address admin\n    ) public initializer {\n        _admin = admin;\n        _setMetaTransactionProcessor(metaTransactionContract, true);\n        _initialized = true;\n    }\n\n    function _transferFrom(address from, address to, uint256 id) internal {\n        _numNFTPerAddress[from]--;\n        _numNFTPerAddress[to]++;\n        _owners[id] = uint256(to);\n        emit Transfer(from, to, id);\n    }\n\n    /**\n     * @notice Return the number of Land owned by an address\n     * @param owner The address to look for\n     * @return The number of Land token owned by the address\n     */\n    function balanceOf(address owner) external view returns (uint256) {\n        require(owner != address(0), \"owner is zero address\");\n        return _numNFTPerAddress[owner];\n    }\n\n\n    function _ownerOf(uint256 id) internal view returns (address) {\n        return address(_owners[id]);\n    }\n\n    function _ownerAndOperatorEnabledOf(uint256 id) internal view returns (address owner, bool operatorEnabled) {\n        uint256 data = _owners[id];\n        owner = address(data);\n        operatorEnabled = (data / 2**255) == 1;\n    }\n\n    /**\n     * @notice Return the owner of a Land\n     * @param id The id of the Land\n     * @return The address of the owner\n     */\n    function ownerOf(uint256 id) external view returns (address owner) {\n        owner = _ownerOf(id);\n        require(owner != address(0), \"token does not exist\");\n    }\n\n    function _approveFor(address owner, address operator, uint256 id) internal {\n        if(operator == address(0)) {\n            _owners[id] = uint256(owner); // no need to resset the operator, it will be overriden next time\n        } else {\n            _owners[id] = uint256(owner) + 2**255;\n            _operators[id] = operator;\n        }\n        emit Approval(owner, operator, id);\n    }\n\n    /**\n     * @notice Approve an operator to spend tokens on the sender behalf\n     * @param sender The address giving the approval\n     * @param operator The address receiving the approval\n     * @param id The id of the token\n     */\n    function approveFor(\n        address sender,\n        address operator,\n        uint256 id\n    ) external {\n        address owner = _ownerOf(id);\n        require(sender != address(0), \"sender is zero address\");\n        require(\n            msg.sender == sender ||\n            _metaTransactionContracts[msg.sender] ||\n            _operatorsForAll[sender][msg.sender] ||\n            _superOperators[msg.sender],\n            \"not authorized to approve\"\n        );\n        require(owner == sender, \"owner != sender\");\n        _approveFor(owner, operator, id);\n    }\n\n    /**\n     * @notice Approve an operator to spend tokens on the sender behalf\n     * @param operator The address receiving the approval\n     * @param id The id of the token\n     */\n    function approve(address operator, uint256 id) external {\n        address owner = _ownerOf(id);\n        require(owner != address(0), \"token does not exist\");\n        require(\n            owner == msg.sender ||\n            _operatorsForAll[owner][msg.sender] ||\n            _superOperators[msg.sender],\n            \"not authorized to approve\"\n        );\n        _approveFor(owner, operator, id);\n    }\n\n    /**\n     * @notice Get the approved operator for a specific token\n     * @param id The id of the token\n     * @return The address of the operator\n     */\n    function getApproved(uint256 id) external view returns (address) {\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(owner != address(0), \"token does not exist\");\n        if (operatorEnabled) {\n            return _operators[id];\n        } else {\n            return address(0);\n        }\n    }\n\n    function _checkTransfer(address from, address to, uint256 id) internal view returns (bool isMetaTx) {\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(owner != address(0), \"token does not exist\");\n        require(owner == from, \"not owner in _checkTransfer\");\n        require(to != address(0), \"can't send to zero address\");\n        isMetaTx = msg.sender != from && _metaTransactionContracts[msg.sender];\n        if (msg.sender != from && !isMetaTx) {\n            require(\n                _operatorsForAll[from][msg.sender] ||\n                (operatorEnabled && _operators[id] == msg.sender) ||\n                _superOperators[msg.sender],\n                \"not approved to transfer\"\n            );\n        }\n    }\n\n    function _checkInterfaceWith10000Gas(address _contract, bytes4 interfaceId)\n        internal\n        view\n        returns (bool)\n    {\n        bool success;\n        bool result;\n        bytes memory call_data = abi.encodeWithSelector(\n            ERC165ID,\n            interfaceId\n        );\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let call_ptr := add(0x20, call_data)\n            let call_size := mload(call_data)\n            let output := mload(0x40) // Find empty storage location using \"free memory pointer\"\n            mstore(output, 0x0)\n            success := staticcall(\n                10000,\n                _contract,\n                call_ptr,\n                call_size,\n                output,\n                0x20\n            ) // 32 bytes\n            result := mload(output)\n        }\n        // (10000 / 63) \"not enough for supportsInterface(...)\" // consume all gas, so caller can potentially know that there was not enough gas\n        assert(gasleft() > 158);\n        return success && result;\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n    */\n    function transferFrom(address from, address to, uint256 id) external {\n        bool metaTx = _checkTransfer(from, to, id);\n        _transferFrom(from, to, id);\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            require(\n                _checkOnERC721Received(metaTx ? from : msg.sender, from, to, id, \"\"),\n                \"erc721 transfer rejected by to\"\n            );\n        }\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     * @param data Additional data\n     */\n    function safeTransferFrom(address from, address to, uint256 id, bytes memory data) public {\n        bool metaTx = _checkTransfer(from, to, id);\n        _transferFrom(from, to, id);\n        if (to.isContract()) {\n            require(\n                _checkOnERC721Received(metaTx ? from : msg.sender, from, to, id, data),\n                \"ERC721: transfer rejected by to\"\n            );\n        }\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\n     * @param from The send of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     */\n    function safeTransferFrom(address from, address to, uint256 id) external {\n        safeTransferFrom(from, to, id, \"\");\n    }\n\n    /**\n     * @notice Transfer many tokens between 2 addresses\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param ids The ids of the tokens\n     * @param data additional data\n    */\n    function batchTransferFrom(address from, address to, uint256[] calldata ids, bytes calldata data) external {\n        _batchTransferFrom(from, to, ids, data, false);\n    }\n\n    function _batchTransferFrom(address from, address to, uint256[] memory ids, bytes memory data, bool safe) internal {\n        bool metaTx = msg.sender != from && _metaTransactionContracts[msg.sender];\n        bool authorized = msg.sender == from ||\n            metaTx ||\n            _operatorsForAll[from][msg.sender] ||\n            _superOperators[msg.sender];\n\n        require(from != address(0), \"from is zero address\");\n        require(to != address(0), \"can't send to zero address\");\n\n        uint256 numTokens = ids.length;\n        for(uint256 i = 0; i < numTokens; i ++) {\n            uint256 id = ids[i];\n            (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n            require(owner == from, \"not owner in batchTransferFrom\");\n            require(authorized || (operatorEnabled && _operators[id] == msg.sender), \"not authorized\");\n            _owners[id] = uint256(to);\n            emit Transfer(from, to, id);\n        }\n        if (from != to) {\n            _numNFTPerAddress[from] -= numTokens;\n            _numNFTPerAddress[to] += numTokens;\n        }\n\n        if (to.isContract()) {\n            if (_checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n                require(\n                    _checkOnERC721BatchReceived(metaTx ? from : msg.sender, from, to, ids, data),\n                    \"erc721 batch transfer rejected by to\"\n                );\n            } else if (safe) {\n                for (uint256 i = 0; i < numTokens; i ++) {\n                    require(\n                        _checkOnERC721Received(metaTx ? from : msg.sender, from, to, ids[i], \"\"),\n                        \"erc721 transfer rejected by to\"\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Transfer many tokens between 2 addresses ensuring the receiving contract has a receiver method\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param ids The ids of the tokens\n     * @param data additional data\n    */\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, bytes calldata data) external {\n        _batchTransferFrom(from, to, ids, data, true);\n    }\n\n    /**\n     * @notice Check if the contract supports an interface\n     * 0x01ffc9a7 is ERC-165\n     * 0x80ac58cd is ERC-721\n     * @param id The id of the interface\n     * @return True if the interface is supported\n     */\n    function supportsInterface(bytes4 id) external pure returns (bool) {\n        return id == 0x01ffc9a7 || id == 0x80ac58cd;\n    }\n\n    /**\n     * @notice Set the approval for an operator to manage all the tokens of the sender\n     * @param sender The address giving the approval\n     * @param operator The address receiving the approval\n     * @param approved The determination of the approval\n     */\n    function setApprovalForAllFor(\n        address sender,\n        address operator,\n        bool approved\n    ) external {\n        require(sender != address(0), \"Invalid sender address\");\n        require(\n            msg.sender == sender ||\n            _metaTransactionContracts[msg.sender] ||\n            _superOperators[msg.sender],\n            \"not authorized to approve for all\"\n        );\n\n        _setApprovalForAll(sender, operator, approved);\n    }\n\n    /**\n     * @notice Set the approval for an operator to manage all the tokens of the sender\n     * @param operator The address receiving the approval\n     * @param approved The determination of the approval\n     */\n    function setApprovalForAll(address operator, bool approved) external {\n        _setApprovalForAll(msg.sender, operator, approved);\n    }\n\n\n    function _setApprovalForAll(\n        address sender,\n        address operator,\n        bool approved\n    ) internal {\n        require(\n            !_superOperators[operator],\n            \"super operator can't have their approvalForAll changed\"\n        );\n        _operatorsForAll[sender][operator] = approved;\n\n        emit ApprovalForAll(sender, operator, approved);\n    }\n\n    /**\n     * @notice Check if the sender approved the operator\n     * @param owner The address of the owner\n     * @param operator The address of the operator\n     * @return The status of the approval\n     */\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool isOperator)\n    {\n        return _operatorsForAll[owner][operator] || _superOperators[operator];\n    }\n\n    function _burn(address from, address owner, uint256 id) internal {\n        require(from == owner, \"not owner\");\n        _owners[id] = 2**160; // cannot mint it again\n        _numNFTPerAddress[from]--;\n        emit Transfer(from, address(0), id);\n    }\n\n    /// @notice Burns token `id`.\n    /// @param id token which will be burnt.\n    function burn(uint256 id) external {\n        _burn(msg.sender, _ownerOf(id), id);\n    }\n\n    /// @notice Burn token`id` from `from`.\n    /// @param from address whose token is to be burnt.\n    /// @param id token which will be burnt.\n    function burnFrom(address from, uint256 id) external {\n        require(from != address(0), \"Invalid sender address\");\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(\n            msg.sender == from ||\n            _metaTransactionContracts[msg.sender] ||\n            (operatorEnabled && _operators[id] == msg.sender) ||\n            _operatorsForAll[from][msg.sender] ||\n            _superOperators[msg.sender],\n            \"not authorized to burn\"\n        );\n        _burn(from, owner, id);\n    }\n\n    function _checkOnERC721Received(address operator, address from, address to, uint256 tokenId, bytes memory _data)\n        internal returns (bool)\n    {\n        bytes4 retval = ERC721TokenReceiver(to).onERC721Received(operator, from, tokenId, _data);\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    function _checkOnERC721BatchReceived(address operator, address from, address to, uint256[] memory ids, bytes memory _data)\n        internal returns (bool)\n    {\n        bytes4 retval = ERC721MandatoryTokenReceiver(to).onERC721BatchReceived(operator, from, ids, _data);\n        return (retval == _ERC721_BATCH_RECEIVED);\n    }\n\n    // Empty storage space in contracts for future enhancements\n    // ref: https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/issues/13)\n    uint256[49] private __gap;\n}"
    },
    {
      "filename": "src/solc_0.5/Land/erc721/LandBaseTokenV3.sol",
      "content": "/* solhint-disable func-order, code-complexity */\npragma solidity 0.5.9;\n\nimport \"./ERC721BaseTokenV2.sol\";\n\ncontract LandBaseTokenV3 is ERC721BaseTokenV2 {\n    // Our grid is 408 x 408 lands\n    uint256 internal constant GRID_SIZE = 408;\n\n    uint256 internal constant LAYER = 0xFF00000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_1x1 = 0x0000000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_3x3 = 0x0100000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_6x6 = 0x0200000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_12x12 = 0x0300000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_24x24 = 0x0400000000000000000000000000000000000000000000000000000000000000;\n\n    mapping(address => bool) internal _minters;\n    event Minter(address superOperator, bool enabled);\n\n    struct Land {\n        uint256 x;\n        uint256 y;\n        uint256 size;\n    }\n\n    /**\n     * @notice Mint a new quad (aligned to a quad tree with size 1, 3, 6, 12 or 24 only)\n     * @param to The recipient of the new quad\n     * @param size The size of the new quad\n     * @param x The top left x coordinate of the new quad\n     * @param y The top left y coordinate of the new quad\n     * @param data extra data to pass to the transfer\n     */\n    function mintQuad(\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes calldata data\n    ) external {\n        require(to != address(0), \"to is zero address\");\n        require(isMinter(msg.sender), \"Only a minter can mint\");\n        require(x % size == 0 && y % size == 0, \"Invalid coordinates\");\n        require(x <= GRID_SIZE - size && y <= GRID_SIZE - size, \"Out of bounds\");\n\n        (uint256 layer, , ) = _getQuadLayer(size);\n        uint256 quadId = _getQuadId(layer, x, y);\n\n        _checkOwner(size, x, y, 24);\n        for (uint256 i = 0; i < size * size; i++) {\n            uint256 _id = _idInPath(i, size, x, y);\n            require(_owners[_id] == 0, \"Already minted\");\n            emit Transfer(address(0), to, _id);\n        }\n\n        _owners[quadId] = uint256(to);\n        _numNFTPerAddress[to] += size * size;\n\n        _checkBatchReceiverAcceptQuad(msg.sender, address(0), to, size, x, y, data);\n    }\n\n    /**\n     * @notice Checks if a parent quad has child quads already minted.\n     *  Then mints the rest child quads and transfers the parent quad.\n     *  Should only be called by the tunnel.\n     * @param to The recipient of the new quad\n     * @param size The size of the new quad\n     * @param x The top left x coordinate of the new quad\n     * @param y The top left y coordinate of the new quad\n     * @param data extra data to pass to the transfer\n     */\n    function mintAndTransferQuad(\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes calldata data\n    ) external {\n        require(to != address(0), \"to is zero address\");\n        require(isMinter(msg.sender), \"Only a minter can mint\");\n        \n        if (exists(size, x, y) == true) {\n            _transferQuad(msg.sender, to, size, x, y);\n            _numNFTPerAddress[msg.sender] -= size * size;\n            _numNFTPerAddress[to] += size * size;\n            _checkBatchReceiverAcceptQuad(msg.sender, msg.sender, to, size, x, y, data);\n        } else {\n            _mintAndTransferQuad(to, size, x, y, data);\n        }\n    }\n\n    /// @notice transfer one quad (aligned to a quad tree with size 3, 6, 12 or 24 only)\n    /// @param from current owner of the quad\n    /// @param to destination\n    /// @param size size of the quad\n    /// @param x The top left x coordinate of the quad\n    /// @param y The top left y coordinate of the quad\n    /// @param data additional data\n    function transferQuad(\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes calldata data\n    ) external {\n        require(from != address(0), \"from is zero address\");\n        require(to != address(0), \"can't send to zero address\");\n        bool metaTx = msg.sender != from && _metaTransactionContracts[msg.sender];\n        if (msg.sender != from && !metaTx) {\n            require(\n                _operatorsForAll[from][msg.sender] || _superOperators[msg.sender],\n                \"not authorized to transferQuad\"\n            );\n        }\n        _transferQuad(from, to, size, x, y);\n        _numNFTPerAddress[from] -= size * size;\n        _numNFTPerAddress[to] += size * size;\n\n        _checkBatchReceiverAcceptQuad(metaTx ? from : msg.sender, from, to, size, x, y, data);\n    }\n\n    /// @notice transfer multiple quad (aligned to a quad tree with size 3, 6, 12 or 24 only)\n    /// @param from current owner of the quad\n    /// @param to destination\n    /// @param sizes list of sizes for each quad\n    /// @param xs list of top left x coordinates for each quad\n    /// @param ys list of top left y coordinates for each quad\n    /// @param data additional data\n    function batchTransferQuad(\n        address from,\n        address to,\n        uint256[] calldata sizes,\n        uint256[] calldata xs,\n        uint256[] calldata ys,\n        bytes calldata data\n    ) external {\n        require(from != address(0), \"from is zero address\");\n        require(to != address(0), \"can't send to zero address\");\n        require(sizes.length == xs.length && xs.length == ys.length, \"invalid data\");\n        bool metaTx = msg.sender != from && _metaTransactionContracts[msg.sender];\n        if (msg.sender != from && !metaTx) {\n            require(\n                _operatorsForAll[from][msg.sender] || _superOperators[msg.sender],\n                \"not authorized to transferMultiQuads\"\n            );\n        }\n        uint256 numTokensTransfered = 0;\n        for (uint256 i = 0; i < sizes.length; i++) {\n            uint256 size = sizes[i];\n            _transferQuad(from, to, size, xs[i], ys[i]);\n            numTokensTransfered += size * size;\n        }\n        _numNFTPerAddress[from] -= numTokensTransfered;\n        _numNFTPerAddress[to] += numTokensTransfered;\n\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            uint256[] memory ids = new uint256[](numTokensTransfered);\n            uint256 counter = 0;\n            for (uint256 j = 0; j < sizes.length; j++) {\n                uint256 size = sizes[j];\n                for (uint256 i = 0; i < size * size; i++) {\n                    ids[counter] = _idInPath(i, size, xs[j], ys[j]);\n                    counter++;\n                }\n            }\n            require(\n                _checkOnERC721BatchReceived(metaTx ? from : msg.sender, from, to, ids, data),\n                \"erc721 batch transfer rejected by to\"\n            );\n        }\n    }\n\n    /// @notice Enable or disable the ability of `minter` to mint tokens\n    /// @param minter address that will be given/removed minter right.\n    /// @param enabled set whether the minter is enabled or disabled.\n    function setMinter(address minter, bool enabled) external onlyAdmin {\n        require(minter != address(0), \"address 0 is not allowed as minter\");\n        require(enabled != _minters[minter], \"the status should be different than the current one\");\n        _minters[minter] = enabled;\n        emit Minter(minter, enabled);\n    }\n\n    /// @notice total width of the map\n    /// @return width\n    function width() external pure returns (uint256) {\n        return GRID_SIZE;\n    }\n\n    /// @notice total height of the map\n    /// @return height\n    function height() external pure returns (uint256) {\n        return GRID_SIZE;\n    }\n\n    /// @notice x coordinate of Land token\n    /// @param id tokenId\n    /// @return the x coordinates\n    function getX(uint256 id) external pure returns (uint256) {\n        return _getX(id);\n    }\n\n    /// @notice y coordinate of Land token\n    /// @param id tokenId\n    /// @return the y coordinates\n    function getY(uint256 id) external pure returns (uint256) {\n        return _getY(id);\n    }\n\n    /// @notice check whether address `who` is given minter rights.\n    /// @param who The address to query.\n    /// @return whether the address has minter rights.\n    function isMinter(address who) public view returns (bool) {\n        return _minters[who];\n    }\n\n    /// @notice checks if Land has been minted or not\n    /// @param size size of the\n    /// @param x x coordinate of the quad\n    /// @param y y coordinate of the quad\n    /// @return bool for if Land has been minted or not\n    function exists(\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) public view returns (bool) {\n        require(x % size == 0 && y % size == 0, \"Invalid coordinates\");\n        require(x <= GRID_SIZE - size && y <= GRID_SIZE - size, \"Out of bounds\");\n        return _ownerOfQuad(size, x, y) != address(0);\n    }\n\n    function _mintAndTransferQuad(\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) internal {\n        (uint256 layer, , ) = _getQuadLayer(size);\n        uint256 quadId = _getQuadId(layer, x, y);\n\n        // Length of array is equal to number of 3x3 child quad a 24x24 quad can have\n        Land[] memory quadMinted = new Land[](64);\n        uint256 index;\n        uint256 landMinted;\n\n        if (size > 3) {\n            (index, landMinted) = _checkAndClearOwner(\n                Land({x: x, y: y, size: size}),\n                quadMinted,\n                landMinted,\n                index,\n                size / 2\n            );\n        }\n\n        {\n            for (uint256 i = 0; i < size * size; i++) {\n                uint256 _id = _idInPath(i, size, x, y);\n                bool isAlreadyMinted = _isQuadMinted(quadMinted, Land({x: _getX(_id), y: _getY(_id), size: 1}), index);\n                if (isAlreadyMinted) {\n                    emit Transfer(msg.sender, to, _id);\n                } else {\n                    if (_owners[_id] == uint256(msg.sender)) {\n                        landMinted += 1;\n                        emit Transfer(msg.sender, to, _id);\n                    } else {\n                        require(_owners[_id] == 0, \"Already minted\");\n\n                        emit Transfer(address(0), to, _id);\n                    }\n                }\n            }\n        }\n\n        _checkBatchReceiverAcceptQuadAndClearOwner(quadMinted, index, landMinted, to, size, x, y, data);\n\n        _owners[quadId] = uint256(to);\n        _numNFTPerAddress[to] += size * size;\n        _numNFTPerAddress[msg.sender] -= landMinted;\n    }\n\n    function _checkBatchReceiverAcceptQuad(\n        address operator,\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) internal {\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            uint256[] memory ids = new uint256[](size * size);\n            for (uint256 i = 0; i < size * size; i++) {\n                ids[i] = _idInPath(i, size, x, y);\n            }\n            require(_checkOnERC721BatchReceived(operator, from, to, ids, data), \"erc721 batch transfer rejected by to\");\n        }\n    }\n\n    function _checkBatchReceiverAcceptQuadAndClearOwner(\n        Land[] memory quadMinted,\n        uint256 index,\n        uint256 landMinted,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) internal {\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            uint256[] memory idsToTransfer = new uint256[](landMinted);\n            uint256 transferIndex;\n            uint256[] memory idsToMint = new uint256[]((size * size) - landMinted);\n            uint256 mintIndex;\n\n            for (uint256 i = 0; i < size * size; i++) {\n                uint256 id = _idInPath(i, size, x, y);\n\n                if (_isQuadMinted(quadMinted, Land({x: _getX(id), y: _getY(id), size: 1}), index)) {\n                    idsToTransfer[transferIndex] = id;\n                    transferIndex++;\n                } else if (_owners[id] == uint256(msg.sender)) {\n                    _owners[id] = 0;\n                    idsToTransfer[transferIndex] = id;\n                    transferIndex++;\n                } else {\n                    idsToMint[mintIndex] = id;\n                    mintIndex++;\n                }\n            }\n            require(\n                _checkOnERC721BatchReceived(msg.sender, address(0), to, idsToMint, data),\n                \"erc721 batch transfer rejected by to\"\n            );\n            require(\n                _checkOnERC721BatchReceived(msg.sender, msg.sender, to, idsToTransfer, data),\n                \"erc721 batch transfer rejected by to\"\n            );\n        } else {\n            for (uint256 i = 0; i < size * size; i++) {\n                uint256 id = _idInPath(i, size, x, y);\n                if (_owners[id] == uint256(msg.sender)) _owners[id] = 0;\n            }\n        }\n    }\n\n    function _transferQuad(\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) internal {\n        if (size == 1) {\n            uint256 id1x1 = _getQuadId(LAYER_1x1, x, y);\n            address owner = _ownerOf(id1x1);\n            require(owner != address(0), \"token does not exist\");\n            require(owner == from, \"not owner in _transferQuad\");\n            _owners[id1x1] = uint256(to);\n        } else {\n            _regroup(from, to, size, x, y);\n        }\n        for (uint256 i = 0; i < size * size; i++) {\n            emit Transfer(from, to, _idInPath(i, size, x, y));\n        }\n    }\n\n    function _checkOwner(\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        uint256 quadCompareSize\n    ) internal view {\n        (uint256 layer, , ) = _getQuadLayer(quadCompareSize);\n\n        if (size <= quadCompareSize) {\n            // when the size of the quad is smaller than the quadCompareSize(size to be compared with),\n            // then it is checked if the bigger quad which encapsulates the quad to be minted\n            // of with size equals the quadCompareSize has been minted or not\n            require(\n                _owners[\n                    _getQuadId(layer, (x / quadCompareSize) * quadCompareSize, (y / quadCompareSize) * quadCompareSize)\n                ] == 0,\n                \"Already minted\"\n            );\n        } else {\n            // when the size is smaller than the quadCompare size the owner of all the smaller quads with size\n            // quadCompare size in the quad to be minted are checked if they are minted or not\n            uint256 toX = x + size;\n            uint256 toY = y + size;\n            for (uint256 xi = x; xi < toX; xi += quadCompareSize) {\n                for (uint256 yi = y; yi < toY; yi += quadCompareSize) {\n                    require(_owners[_getQuadId(layer, xi, yi)] == 0, \"Already minted\");\n                }\n            }\n        }\n\n        quadCompareSize = quadCompareSize / 2;\n        if (quadCompareSize >= 3) _checkOwner(size, x, y, quadCompareSize);\n    }\n\n    function _checkAndClear(address from, uint256 id) internal returns (bool) {\n        uint256 owner = _owners[id];\n        if (owner != 0) {\n            require(address(owner) == from, \"not owner\");\n            _owners[id] = 0;\n            return true;\n        }\n        return false;\n    }\n\n    function _regroup(\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) internal {\n        require(x % size == 0 && y % size == 0, \"Invalid coordinates\");\n        require(x <= GRID_SIZE - size && y <= GRID_SIZE - size, \"Out of bounds\");\n        if (size == 3 || size == 6 || size == 12 || size == 24) {\n            _regroupQuad(from, to, Land({x: x, y: y, size: size}), true, size / 2);\n        } else {\n            require(false, \"Invalid size\");\n        }\n    }\n\n    function _checkAndClearOwner(\n        Land memory land,\n        Land[] memory quadMinted,\n        uint256 landMinted,\n        uint256 index,\n        uint256 quadCompareSize\n    ) internal returns (uint256, uint256) {\n        (uint256 layer, , ) = _getQuadLayer(quadCompareSize);\n        uint256 toX = land.x + land.size;\n        uint256 toY = land.y + land.size;\n\n        for (uint256 xi = land.x; xi < toX; xi += quadCompareSize) {\n            for (uint256 yi = land.y; yi < toY; yi += quadCompareSize) {\n                bool isQuadChecked = _isQuadMinted(quadMinted, Land({x: xi, y: yi, size: quadCompareSize}), index);\n                if (!isQuadChecked) {\n                    uint256 id = _getQuadId(layer, xi, yi);\n                    address owner = address(uint160(_owners[id]));\n\n                    if (owner == msg.sender) {\n                        quadMinted[index] = Land({x: xi, y: yi, size: quadCompareSize});\n                        index++;\n                        landMinted += quadCompareSize * quadCompareSize;\n                        _owners[id] = 0;\n                    } else {\n                        require(owner == address(0), \"Already minted\");\n                    }"
    }
  ]
}