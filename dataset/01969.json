{
  "Title": "H-10: Balance check for swapToken in ShortLongSpell#_deposit is incorrect and will result in nonfunctional contract",
  "Content": "# Issue H-10: Balance check for swapToken in ShortLongSpell#_deposit is incorrect and will result in nonfunctional contract \n\nSource: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/133 \n\n## Found by \n0x52, Ch\\_301, sinarette\n## Summary\n\nThe balance checks on ShortLongSpell#_withdraw are incorrect and will make contract basically nonfunctional \n\n## Vulnerability Detail\n\nswapToken is always vault.uToken. borrowToken is always required to be vault.uToken which means that swapToken == borrowToken. This means that the token borrowed is always required to be swapped. \n\n[ShortLongSpell.sol#L83-L89](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L83-L89)\n\n        uint256 strTokenAmt = _doBorrow(param.borrowToken, param.borrowAmount);\n\n        // 3. Swap borrowed token to strategy token\n        IERC20Upgradeable swapToken = ISoftVault(strategy.vault).uToken();\n        // swapData.fromAmount = strTokenAmt;\n        PSwapLib.megaSwap(augustusSwapper, tokenTransferProxy, swapData);\n        strTokenAmt = swapToken.balanceOf(address(this)) - strTokenAmt; <- @audit-issue will always revert on swap\n\nBecause swapToken == borrowToken if there is ever a swap then the swapToken balance will decrease. This causes L89 to always revert when a swap happens, making the contract completely non-functional\n\n## Impact\n\nShortLongSpell is nonfunctional\n\n## Code Snippet\n\n[ShortLongSpell.sol#L160-L202](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L160-L202)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRemove check\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/69",
  "Code": [
    {
      "filename": "blueberry-core/contracts/spell/ShortLongSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"./BasicSpell.sol\";\n\nimport \"../interfaces/ISoftVault.sol\";\nimport \"../interfaces/IWERC20.sol\";\nimport \"../libraries/Paraswap/PSwapLib.sol\";\n\n/**\n * @title Short/Long Spell\n * @author BlueberryProtocol\n * @notice Short/Long Spell is the factory contract that\n * defines how Blueberry Protocol interacts for leveraging\n * an asset either long or short\n */\ncontract ShortLongSpell is BasicSpell {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @dev WERC20\n    IWERC20 public wrapper;\n\n    /// @dev paraswap AugustusSwapper address\n    address public augustusSwapper;\n\n    /// @dev paraswap TokenTransferProxy address\n    address public tokenTransferProxy;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address augustusSwapper_,\n        address tokenTransferProxy_\n    ) external initializer {\n        if (augustusSwapper_ == address(0)) revert Errors.ZERO_ADDRESS();\n        if (tokenTransferProxy_ == address(0)) revert Errors.ZERO_ADDRESS();\n\n        augustusSwapper = augustusSwapper_;\n        tokenTransferProxy = tokenTransferProxy_;\n        wrapper = IWERC20(werc20_);\n\n        __BasicSpell_init(bank_, werc20_, weth_);\n    }\n\n    /**\n     * @notice Internal function to swap token using paraswap assets\n     * @dev Deposit isolated underlying to Blueberry Money Market,\n     *      Borrow tokens from Blueberry Money Market,\n     *      Swap borrowed token to another token\n     *      Then deposit swapped token to softvault,\n     *\n     */\n    function _deposit(\n        OpenPosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    ) internal {\n        Strategy memory strategy = strategies[param.strategyId];\n\n        // 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        // 2. Borrow specific amounts\n        uint256 strTokenAmt = _doBorrow(param.borrowToken, param.borrowAmount);\n\n        // 3. Swap borrowed token to strategy token\n        IERC20Upgradeable swapToken = ISoftVault(strategy.vault).uToken();\n        // swapData.fromAmount = strTokenAmt;\n        PSwapLib.megaSwap(augustusSwapper, tokenTransferProxy, swapData);\n        strTokenAmt = swapToken.balanceOf(address(this)) - strTokenAmt;\n        if (strTokenAmt < swapData.expectedAmount)\n            revert Errors.SWAP_FAILED(address(swapToken));\n\n        // 4. Deposit to SoftVault directly\n        _ensureApprove(\n            address(swapToken),\n            address(strategy.vault),\n            strTokenAmt\n        );\n        ISoftVault(strategy.vault).deposit(strTokenAmt);\n\n        // 5. Validate MAX LTV\n        _validateMaxLTV(param.strategyId);\n\n        // 6. Validate Max Pos Size\n        _validateMaxPosSize(param.strategyId);\n    }\n\n    /**\n     * @notice External function to deposit assets\n     */\n    function openPosition(\n        OpenPosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n        if (\n            address(ISoftVault(strategy.vault).uToken()) != param.borrowToken ||\n            swapData.fromToken != param.borrowToken\n        ) revert Errors.INCORRECT_LP(param.borrowToken);\n\n        // 1-3 Swap to strategy underlying token, deposit to softvault\n        _deposit(param, swapData);\n\n        // 4. Put collateral -\n        {\n            IBank.Position memory pos = bank.getCurrentPositionInfo();\n            address posCollToken = pos.collToken;\n            uint256 collSize = pos.collateralSize;\n            address burnToken = address(ISoftVault(strategy.vault).uToken());\n            if (collSize > 0) {\n                if (posCollToken != address(wrapper))\n                    revert Errors.INCORRECT_COLTOKEN(posCollToken);\n                bank.takeCollateral(collSize);\n                wrapper.burn(burnToken, collSize);\n                _doRefund(burnToken);\n            }\n        }\n\n        // 5. Put collateral - strategy token\n        address vault = strategies[param.strategyId].vault;\n        _doPutCollateral(\n            vault,\n            IERC20Upgradeable(ISoftVault(vault).uToken()).balanceOf(\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @notice Internal function to withdraw assets from SoftVault\n     * @dev Withdraw assets from Soft Vault,\n     *      Swap withdrawn assets to debt token,\n     *      Withdraw isolated collaterals from Blueberry Money Market,\n     *      Repay Debt and refund rest to user\n     */\n    function _withdraw(\n        ClosePosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    ) internal {\n        if (param.sellSlippage > bank.config().maxSlippageOfClose())\n            revert Errors.RATIO_TOO_HIGH(param.sellSlippage);\n\n        Strategy memory strategy = strategies[param.strategyId];\n        ISoftVault vault = ISoftVault(strategy.vault);\n        uint256 positionId = bank.POSITION_ID();\n\n        // 1. Calculate actual amount to remove\n        uint256 amountPosRemove = param.amountPosRemove;\n        if (amountPosRemove == type(uint256).max) {\n            amountPosRemove = vault.balanceOf(address(this));\n        }\n\n        // 2. Withdraw from softvault\n        vault.withdraw(amountPosRemove);\n\n        // 3. Swap strategy token to isolated collateral token\n        {\n            PSwapLib.megaSwap(augustusSwapper, tokenTransferProxy, swapData);\n        }\n\n        // 4. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        // 5. Repay\n        {\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(positionId);\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        _validateMaxLTV(param.strategyId);\n\n        // 6. Refund\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n    }\n\n    /**\n     * @notice External function to withdraw assets\n     */\n    function closePosition(\n        ClosePosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n\n        if (address(ISoftVault(strategy.vault).uToken()) != swapData.fromToken)\n            revert Errors.INCORRECT_LP(swapData.fromToken);\n\n        address vault = strategies[param.strategyId].vault;\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        address posCollToken = pos.collToken;\n        uint256 collId = pos.collId;\n        if (IWERC20(posCollToken).getUnderlyingToken(collId) != vault)\n            revert Errors.INCORRECT_UNDERLYING(vault);\n        if (posCollToken != address(werc20))\n            revert Errors.INCORRECT_COLTOKEN(posCollToken);\n\n        // 1. Take out collateral\n        bank.takeCollateral(param.amountPosRemove);\n        werc20.burn(\n            address(ISoftVault(strategy.vault).uToken()),\n            param.amountPosRemove\n        );\n\n        // 2-7. Remove liquidity\n        _withdraw(param, swapData);\n    }\n\n    /**\n     * @notice Add strategy to the spell\n     * @param swapToken Address of token for given strategy\n     * @param maxPosSize, USD price of maximum position size for given strategy, based 1e18\n     */\n    function addStrategy(\n        address swapToken,\n        uint256 maxPosSize\n    ) external onlyOwner {\n        _addStrategy(swapToken, maxPosSize);\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/spell/ShortLongSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"./BasicSpell.sol\";\n\nimport \"../interfaces/ISoftVault.sol\";\nimport \"../interfaces/IWERC20.sol\";\nimport \"../libraries/Paraswap/PSwapLib.sol\";\n\n/**\n * @title Short/Long Spell\n * @author BlueberryProtocol\n * @notice Short/Long Spell is the factory contract that\n * defines how Blueberry Protocol interacts for leveraging\n * an asset either long or short\n */\ncontract ShortLongSpell is BasicSpell {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @dev WERC20\n    IWERC20 public wrapper;\n\n    /// @dev paraswap AugustusSwapper address\n    address public augustusSwapper;\n\n    /// @dev paraswap TokenTransferProxy address\n    address public tokenTransferProxy;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address augustusSwapper_,\n        address tokenTransferProxy_\n    ) external initializer {\n        if (augustusSwapper_ == address(0)) revert Errors.ZERO_ADDRESS();\n        if (tokenTransferProxy_ == address(0)) revert Errors.ZERO_ADDRESS();\n\n        augustusSwapper = augustusSwapper_;\n        tokenTransferProxy = tokenTransferProxy_;\n        wrapper = IWERC20(werc20_);\n\n        __BasicSpell_init(bank_, werc20_, weth_);\n    }\n\n    /**\n     * @notice Internal function to swap token using paraswap assets\n     * @dev Deposit isolated underlying to Blueberry Money Market,\n     *      Borrow tokens from Blueberry Money Market,\n     *      Swap borrowed token to another token\n     *      Then deposit swapped token to softvault,\n     *\n     */\n    function _deposit(\n        OpenPosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    ) internal {\n        Strategy memory strategy = strategies[param.strategyId];\n\n        // 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        // 2. Borrow specific amounts\n        uint256 strTokenAmt = _doBorrow(param.borrowToken, param.borrowAmount);\n\n        // 3. Swap borrowed token to strategy token\n        IERC20Upgradeable swapToken = ISoftVault(strategy.vault).uToken();\n        // swapData.fromAmount = strTokenAmt;\n        PSwapLib.megaSwap(augustusSwapper, tokenTransferProxy, swapData);\n        strTokenAmt = swapToken.balanceOf(address(this)) - strTokenAmt;\n        if (strTokenAmt < swapData.expectedAmount)\n            revert Errors.SWAP_FAILED(address(swapToken));\n\n        // 4. Deposit to SoftVault directly\n        _ensureApprove(\n            address(swapToken),\n            address(strategy.vault),\n            strTokenAmt\n        );\n        ISoftVault(strategy.vault).deposit(strTokenAmt);\n\n        // 5. Validate MAX LTV\n        _validateMaxLTV(param.strategyId);\n\n        // 6. Validate Max Pos Size\n        _validateMaxPosSize(param.strategyId);\n    }\n\n    /**\n     * @notice External function to deposit assets\n     */\n    function openPosition(\n        OpenPosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n        if (\n            address(ISoftVault(strategy.vault).uToken()) != param.borrowToken ||\n            swapData.fromToken != param.borrowToken\n        ) revert Errors.INCORRECT_LP(param.borrowToken);\n\n        // 1-3 Swap to strategy underlying token, deposit to softvault\n        _deposit(param, swapData);\n\n        // 4. Put collateral -\n        {\n            IBank.Position memory pos = bank.getCurrentPositionInfo();\n            address posCollToken = pos.collToken;\n            uint256 collSize = pos.collateralSize;\n            address burnToken = address(ISoftVault(strategy.vault).uToken());\n            if (collSize > 0) {\n                if (posCollToken != address(wrapper))\n                    revert Errors.INCORRECT_COLTOKEN(posCollToken);\n                bank.takeCollateral(collSize);\n                wrapper.burn(burnToken, collSize);\n                _doRefund(burnToken);\n            }\n        }\n\n        // 5. Put collateral - strategy token\n        address vault = strategies[param.strategyId].vault;\n        _doPutCollateral(\n            vault,\n            IERC20Upgradeable(ISoftVault(vault).uToken()).balanceOf(\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @notice Internal function to withdraw assets from SoftVault\n     * @dev Withdraw assets from Soft Vault,\n     *      Swap withdrawn assets to debt token,\n     *      Withdraw isolated collaterals from Blueberry Money Market,\n     *      Repay Debt and refund rest to user\n     */\n    function _withdraw(\n        ClosePosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    ) internal {\n        if (param.sellSlippage > bank.config().maxSlippageOfClose())\n            revert Errors.RATIO_TOO_HIGH(param.sellSlippage);\n\n        Strategy memory strategy = strategies[param.strategyId];\n        ISoftVault vault = ISoftVault(strategy.vault);\n        uint256 positionId = bank.POSITION_ID();\n\n        // 1. Calculate actual amount to remove\n        uint256 amountPosRemove = param.amountPosRemove;\n        if (amountPosRemove == type(uint256).max) {\n            amountPosRemove = vault.balanceOf(address(this));\n        }\n\n        // 2. Withdraw from softvault\n        vault.withdraw(amountPosRemove);\n\n        // 3. Swap strategy token to isolated collateral token\n        {\n            PSwapLib.megaSwap(augustusSwapper, tokenTransferProxy, swapData);\n        }\n\n        // 4. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        // 5. Repay\n        {\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(positionId);\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        _validateMaxLTV(param.strategyId);\n\n        // 6. Refund\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n    }\n\n    /**\n     * @notice External function to withdraw assets\n     */\n    function closePosition(\n        ClosePosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n\n        if (address(ISoftVault(strategy.vault).uToken()) != swapData.fromToken)\n            revert Errors.INCORRECT_LP(swapData.fromToken);\n\n        address vault = strategies[param.strategyId].vault;\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        address posCollToken = pos.collToken;\n        uint256 collId = pos.collId;\n        if (IWERC20(posCollToken).getUnderlyingToken(collId) != vault)\n            revert Errors.INCORRECT_UNDERLYING(vault);\n        if (posCollToken != address(werc20))\n            revert Errors.INCORRECT_COLTOKEN(posCollToken);\n\n        // 1. Take out collateral\n        bank.takeCollateral(param.amountPosRemove);\n        werc20.burn(\n            address(ISoftVault(strategy.vault).uToken()),\n            param.amountPosRemove\n        );\n\n        // 2-7. Remove liquidity\n        _withdraw(param, swapData);\n    }\n\n    /**\n     * @notice Add strategy to the spell\n     * @param swapToken Address of token for given strategy\n     * @param maxPosSize, USD price of maximum position size for given strategy, based 1e18\n     */\n    function addStrategy(\n        address swapToken,\n        uint256 maxPosSize\n    ) external onlyOwner {\n        _addStrategy(swapToken, maxPosSize);\n    }\n}"
    }
  ]
}