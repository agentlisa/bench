{
  "Title": "[M-02] `ASDRouter` didn't call `ASDUSDC.approve()` to to grant permission for `crocSwapAddress` to spend their `ASDUSDC`",
  "Content": "\nThe function 'ASDRouter#lzCompose()' never succeeds. The receiver can only receive `ASDUSDC` token when the call of 'ASDRouter#lzCompose()' is done.\n\n### Proof of Concept\n\n'ASDRouter#lzCompose()' is used to deposit wrapped USDC token for ASD token:\n\n1. Once wrapped USDC is received, it will be deposited for `ASDUSDC` by calling [`ASDUSDC.deposit()`](https://github.com/code-423n4/2024-03-canto/blob/main/contracts/asd/asdRouter.sol#L87).\n2. Next `ASDUSDC` will swapped to `NOTE` by calling [`_swapOFTForNote()`](https://github.com/code-423n4/2024-03-canto/blob/main/contracts/asd/asdRouter.sol#L90).\n3. In the last, all `NOTE` will be deposited into ASD vault for ASD token by calling [`_depositNoteToASDVault()`](https://github.com/code-423n4/2024-03-canto/blob/main/contracts/asd/asdRouter.sol#L100).\n\nHowever, in the second step, `ASDUSDC.approve()` was not invoked to authorize `crocSwapAddress` to spend their `ASDUSDC`. Consequently, `crocSwapAddress#swap()` cannot successfully swap `ASDUSDC` for `NOTE`. `_swapOFTForNote()` will fail and all `ASDUSDC` will be refunded to the designated receiver.\n\nTo demonstrate the aforementioned issue, the POC is divided into two parts:\n\n1. The allowance that `crocSwapAddress` is allowed to spend from `ASDRouter` is `0`. Modify [`asdRouter.sol`](https://github.com/code-423n4/2024-03-canto/blob/main/contracts/asd/asdRouter.sol) as below:\n\n```diff\n...\nimport {ASDUSDC} from \"./asdUSDC.sol\";\n+import {console} from \"hardhat/console.sol\";\n...\n    function _swapOFTForNote(address _oftAddress, uint _amount, uint _minAmountNote) internal returns (uint, bool) {\n         ...\n+        console.log(\"balance:\", ASDUSDC(asdUSDC).balanceOf(address(this)));\n+        console.log(\"allowance:\", ASDUSDC(asdUSDC).allowance(address(this), crocSwapAddress));\n        // swap is good to make, use call just in case revert occurs\n        (bool successSwap, bytes memory data) = crocSwapAddress.call(abi.encodeWithSelector(ICrocSwapDex.swap.selector, baseToken, quoteToken, ambientPoolIdx, !isNoteBase, !isNoteBase, amountConverted, 0, 0, uintMinAmount, 0));\n...\n```\n\nRun `npx hardhat test`. From the log we can see that the allowance is `0`, while the `ASDUSDC` balance of `ASDRouter` is not:\n\n```\n      ASDRouter\n        ✔ lzCompose: invalid payload\n        ✔ lzCompose: invalid payload with gas\n        ✔ lzCompose: not whitelisted\n        ✔ lzCompose: not whitelisted with gas\n        ✔ lzCompose: bad swap\n        ✔ lzCompose: bad swap with gas\n    balance: 100000000000000000000\n    allowance: 0\n        ✔ lzCompose: insufficient send fee\n    balance: 100000000000000000000\n    allowance: 0\n        ✔ lzCompose: insufficient send fee with gas\n    balance: 100000000000000000000\n    allowance: 0\n        ✔ lzCompose: successful deposit and send on canto\n\n      ASDUSDC\n        ✔ should set whitelist for correct contract addresses\n        ✔ should deposit whitelisted usdc versions for asdUSDC\n        ✔ should withdraw whitelisted usdc versions for asdUSDC\n        ✔ should recover USDC tokens sent to the contract\n```\n\n2. [`crocSwapAddress#swap()`](https://github.com/code-423n4/2024-03-canto/blob/main/contracts/asd/asdRouter.sol#L247) wouldn't work if the caller didn't approve `crocSwapAddress` to spend their token. Add fork configuration into [`hardhat.config.js`](https://github.com/code-423n4/2024-03-canto/blob/main/hardhat.config.js):\n\n```diff\n...\n    networks: {\n+       hardhat: {\n+           forking: {\n+             url: \"https://canto-rpc.ansybl.io/\",\n+             blockNumber: 8977374,\n+           },\n+           chainId: 7700,\n+       },\n...\n```\n\nCreate `test/DEX.js`:\n\n```solidity\nconst { expect } = require(\"chai\");\nconst { ethers } = require(\"hardhat\");\nconst hre = require(\"hardhat\");\n\ndescribe(\"Dex\", function () {\n    const dexAddress = \"0x9290C893ce949FE13EF3355660d07dE0FB793618\";\n    const usdcAddress = \"0x80b5a32E4F032B2a058b4F29EC95EEfEEB87aDcd\";\n    const cNoteAddress = \"0xEe602429Ef7eCe0a13e4FfE8dBC16e101049504C\";\n    const usdcWhaleAddress = \"0xfAc5EBD2b1b830806189FCcD0255DC9B174decbc\";\n    let dex;\n    let usdc;\n    let cNote;\n    this.beforeEach(async () => {\n        dex  = await hre.ethers.getContractAt(\"ICrocSwapDex\", dexAddress);\n        usdc = await hre.ethers.getContractAt(\"IERC20\", usdcAddress);\n        cNote = await hre.ethers.getContractAt(\"CErc20Interface\", cNoteAddress);\n    });\n\n    it(\"User can only call DEX.swap() for cNote after call USDC.approve(dex)\", async () => {\n        await hre.network.provider.request({\n            method: \"hardhat_impersonateAccount\",\n            params: [usdcWhaleAddress],\n        });\n        whale = await ethers.getSigner(usdcWhaleAddress);\n        let usdcBalanceBeforeSwap = await usdc.balanceOf(usdcWhaleAddress);\n        await usdc.connect(whale).approve(dexAddress, 0);\n        expect(await usdc.allowance(usdcWhaleAddress,dexAddress)).to.be.equal(0);\n        //@audit-info swap failed due to zero allowance\n        expect(dex.connect(whale).swap(\n            usdcAddress,\n            cNoteAddress,\n            36000,\n            true,\n            true,\n            2000000,\n            0, \n            0,\n            0, \n            0 \n        )).to.be.reverted;\n        //@audit-info user set the allowance for dex to 2000000\n        await usdc.connect(whale).approve(dexAddress, 2000000);\n        expect(await usdc.allowance(usdcWhaleAddress,dexAddress)).to.be.equal(2000000);\n        swapTx = await dex.connect(whale).swap(\n            usdcAddress, \n            cNoteAddress,\n            36000,\n            true,\n            true, \n            2000000,\n            0,\n            ethers.parseEther(\"10000000000\"),\n            0,\n            0\n        );\n        await swapTx.wait();\n        let usdcBalanceAfterSwap = await usdc.balanceOf(usdcWhaleAddress);\n        let usedUSDC = usdcBalanceBeforeSwap - usdcBalanceAfterSwap;\n        //@audit-info swap succeeded and 2000000 of USDC was tranferred from user\n        expect(usedUSDC).to.be.equal(2000000);\n    });\n});\n```\n\nOpen one terminal to run `npx hardhat node`, then open another terminal to run `npx hardhat test`. It's obvious that `dex.swap()` will fail if `usdc.approve()` is not called first.\n\n### Recommended Mitigation Steps\n\nSet `allowance` to the maximum value from the beginning:\n\n```diff\n    constructor(address _noteAddress, uint32 _cantoLzEID, address _crocSwapAddress, address _crocImpactAddress, address _asdUSDCAddress) {\n        noteAddress = _noteAddress;\n        cantoLzEID = _cantoLzEID;\n        crocSwapAddress = _crocSwapAddress;\n        crocImpactAddress = _crocImpactAddress;\n        asdUSDC = _asdUSDCAddress;\n+       ASDUSDC(asdUSDC).approve(crocSwapAddress, type(uint).max);\n    }\n```\n\n### Assessed type\n\nContext\n\n**[dsudit01 (Canto) confirmed and commented](https://github.com/code-423n4/2024-03-canto-findings/issues/7#issuecomment-2040485103):**\n > PR [here](https://github.com/Plex-Engineer/ASD-V2/pull/2).\n\n**[SpicyMeatball (warden) commented](https://github.com/code-423n4/2024-03-canto-findings/issues/7#issuecomment-2041107857):**\n > @3docSec - the sole purpose of the router contract is to exchange `USDC` to `asD` and send it to the source chain. The bug described in this report disrupts this functionality making the router unusable. Therefore, I believe a high severity is more appropriate.\n\n**[3docSec (judge) commented](https://github.com/code-423n4/2024-03-canto-findings/issues/7#issuecomment-2041122060):**\n > A quick refresher on our [severity categorization](https://docs.code4rena.com/awarding/judging-criteria/severity-categorization):\n> \n> > 2 — Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> > \n> > 3 — High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n> \n> Should help clarify how this finding is a well-deserved Medium.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-canto",
  "Code": [
    {
      "filename": "contracts/asd/asdRouter.sol",
      "content": "pragma solidity ^0.8.22;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IOAppComposer} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppComposer.sol\";\nimport {OFTComposeMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTComposeMsgCodec.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ASDOFT} from \"./asdOFT.sol\";\nimport {IOFT, SendParam, MessagingFee} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {OptionsBuilder} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/libs/OptionsBuilder.sol\";\nimport {ICrocSwapDex, ICrocImpact} from \"../ambient/CrocInterfaces.sol\";\nimport {ASDUSDC} from \"./asdUSDC.sol\";\n\n/**\n * @title ASDRouter\n */\n\ncontract ASDRouter is IOAppComposer, Ownable {\n    // ambient params\n    address public crocSwapAddress;\n    address public crocImpactAddress;\n    uint public constant ambientPoolIdx = 36000;\n    // canto chain params\n    address public noteAddress;\n    uint32 public cantoLzEID;\n    // asdUSDC contract for swapping to $NOTE\n    address public asdUSDC;\n\n    struct OftComposeMessage {\n        uint32 _dstLzEid;\n        address _dstReceiver;\n        address _dstAsdAddress;\n        address _cantoAsdAddress;\n        uint256 _minAmountASD;\n        address _cantoRefundAddress;\n        uint256 _feeForSend;\n    }\n\n    event LZReceived(bytes32 indexed _guid, address _from, bytes _message, address _executor, bytes _extraData, uint _value);\n\n    event TokenRefund(bytes32 indexed _guid, address _tokenAddress, address _refundAddress, uint _amount, uint _nativeAmount, string _reason);\n\n    event ASDSent(bytes32 indexed _guid, address _to, address _asdAddress, uint _amount, uint32 _dstEid, bool _lzSend);\n\n    constructor(address _noteAddress, uint32 _cantoLzEID, address _crocSwapAddress, address _crocImpactAddress, address _asdUSDCAddress) {\n        noteAddress = _noteAddress;\n        cantoLzEID = _cantoLzEID;\n        crocSwapAddress = _crocSwapAddress;\n        crocImpactAddress = _crocImpactAddress;\n        asdUSDC = _asdUSDCAddress;\n    }\n\n    /**\n     * @notice Called by the LZ executor after sending OFT tokens to this contract.\n     * @param _from The address of the OFT on this chain.\n     * @param _guid The GUID of the message.\n     * @param _message The message payload from the executor formatted as an OFT composed message.\n     * @param _executor The address of the executor.\n     * @param _extraData Additional data supplied by the executor.\n     * @dev Cannot revert anywhere, must send the tokens to the intended receiver if something fails (token's will be lost otherwise)\n     */\n    function lzCompose(address _from, bytes32 _guid, bytes calldata _message, address _executor, bytes calldata _extraData) external payable {\n        /* log event */\n        emit LZReceived(_guid, _from, _message, _executor, _extraData, msg.value);\n\n        /* decode OFT composed message */\n        (, , uint256 amountLD, bytes32 composeFrom, bytes memory composeMsg) = _decodeOFTComposeMsg(_message);\n\n        /* decode composed message payload */\n\n        // check the composed message for proper formatting\n        if (composeMsg.length != 224) {\n            // return tokens to the address that sent them (composeFrom)\n            _refundToken(_guid, _from, OFTComposeMsgCodec.bytes32ToAddress(composeFrom), amountLD, msg.value, \"Invalid composeMsg length\");\n            return;\n        }\n        OftComposeMessage memory payload = abi.decode(composeMsg, (OftComposeMessage));\n\n        /* check if the OFT stable coin is whitelisted */\n        if (!ASDUSDC(asdUSDC).whitelistedUSDCVersions(_from)) {\n            // return tokens to the refund address on canto\n            _refundToken(_guid, _from, payload._cantoRefundAddress, amountLD, msg.value, \"not whitelisted\");\n            return;\n        }\n\n        /* deposit oft to receive asdUSDC for swapping */\n        IERC20(_from).approve(asdUSDC, amountLD);\n        uint amountUSDC = ASDUSDC(asdUSDC).deposit(_from, amountLD);\n\n        /* swap tokens for $NOTE (check minAmount for slippage) */\n        (uint amountNote, bool successfulSwap) = _swapOFTForNote(asdUSDC, amountUSDC, payload._minAmountASD);\n\n        // check if the swap was successful\n        if (!successfulSwap) {\n            // return tokens to the refund address on canto\n            _refundToken(_guid, asdUSDC, payload._cantoRefundAddress, amountUSDC, msg.value, \"swap failed\");\n            return;\n        }\n\n        /* deposit $NOTE to the correct asd vault to receive ASD tokens */\n        (bool successfulDeposit, string memory reason) = _depositNoteToASDVault(payload._cantoAsdAddress, amountNote);\n\n        // check if deposit was successful\n        if (!successfulDeposit) {\n            // return $NOTE to the refund address on canto since OFT was swapped already\n            _refundToken(_guid, noteAddress, payload._cantoRefundAddress, amountNote, msg.value, reason);\n            return;\n        }\n\n        /* transfer the ASD tokens to the destination receiver */\n        _sendASD(_guid, payload, amountNote);\n    }\n\n    /**\n     *\n     * @param _message The message payload from the executor formatted as an OFT composed message.\n     * @return _nonce The nonce value.\n     * @return _srcEid The source endpoint ID.\n     * @return _amountLD The amount in local decimals.\n     * @return _composeFrom The composeFrom value (msg.sender on from chain).\n     * @return _composeMsg The composed message.\n     */\n    function _decodeOFTComposeMsg(bytes calldata _message) internal pure returns (uint64 _nonce, uint32 _srcEid, uint256 _amountLD, bytes32 _composeFrom, bytes memory _composeMsg) {\n        _nonce = OFTComposeMsgCodec.nonce(_message);\n        _srcEid = OFTComposeMsgCodec.srcEid(_message);\n        _amountLD = OFTComposeMsgCodec.amountLD(_message);\n        _composeFrom = OFTComposeMsgCodec.composeFrom(_message);\n        _composeMsg = OFTComposeMsgCodec.composeMsg(_message);\n    }\n\n    /**\n     * @param _guid the GUID of the message from layer zero.\n     * @param _payload the payload of the message.\n     * @param _amount  the amount of ASD tokens to send.\n     */\n    function _sendASD(bytes32 _guid, OftComposeMessage memory _payload, uint _amount) internal {\n        /* transfer the ASD tokens to the destination receiver */\n        if (_payload._dstLzEid == cantoLzEID) {\n            // just transfer the ASD tokens to the destination receiver\n            emit ASDSent(_guid, _payload._dstReceiver, _payload._cantoAsdAddress, _amount, _payload._dstLzEid, false);\n            ASDOFT(_payload._cantoAsdAddress).transfer(_payload._dstReceiver, _amount);\n        } else {\n            // use Layer Zero oapp to send ASD tokens to the destination receiver on the destination chain\n\n            // make sure msg.value is enough to cover the fee or this transaction will revert\n            if (msg.value < _payload._feeForSend) {\n                // refund ASD tokens on canto\n                _refundToken(_guid, _payload._cantoAsdAddress, _payload._cantoRefundAddress, _amount, msg.value, \"insufficient msg.value for send fee\");\n                return;\n            }\n\n            // create send params for the Layer Zero oapp\n            bytes memory sendOptions = OptionsBuilder.addExecutorLzReceiveOption(OptionsBuilder.newOptions(), 200000, 0);\n            SendParam memory sendParams = SendParam({dstEid: _payload._dstLzEid, to: OFTComposeMsgCodec.addressToBytes32(_payload._dstReceiver), amountLD: _amount, minAmountLD: _amount, extraOptions: sendOptions, composeMsg: \"0x\", oftCmd: \"0x\"});\n            MessagingFee memory fee = MessagingFee({nativeFee: _payload._feeForSend, lzTokenFee: 0});\n\n            // send tokens\n            (bool successfulSend, bytes memory data) = payable(_payload._cantoAsdAddress).call{value: _payload._feeForSend}(abi.encodeWithSelector(IOFT.send.selector, sendParams, fee, _payload._cantoRefundAddress));\n\n            // check if the send was successful\n            if (!successfulSend) {\n                // refund ASD tokens on canto\n                _refundToken(_guid, _payload._cantoAsdAddress, _payload._cantoRefundAddress, _amount, msg.value, string(data));\n                return;\n            }\n            emit ASDSent(_guid, _payload._dstReceiver, _payload._cantoAsdAddress, _amount, _payload._dstLzEid, true);\n        }\n    }\n\n    /**\n     * @notice refunds tokens when lzCompose fails\n     * @param _guid The GUID of the message from layer zero.\n     * @param _tokenAddress address of token\n     * @param _refundAddress address to refund to on canto\n     * @param _amount amount to send\n     * @param _nativeAmount amount to send in native token\n     */\n    function _refundToken(bytes32 _guid, address _tokenAddress, address _refundAddress, uint _amount, uint _nativeAmount, string memory _reason) internal {\n        // emit event\n        emit TokenRefund(_guid, _tokenAddress, _refundAddress, _amount, _nativeAmount, _reason);\n        // transfer tokens to refund address\n        IERC20(_tokenAddress).transfer(_refundAddress, _amount);\n        // transfer native tokens to refund address and check that this value is less than or equal to msg.value\n        if (_nativeAmount > 0 && _nativeAmount <= msg.value) {\n            payable(_refundAddress).transfer(_nativeAmount);\n        }\n    }\n\n    /**\n     * @notice deposits $NOTE to the correct asd vault to receive ASD tokens\n     * @param _asdVault The address of the ASD vault to deposit to\n     * @param _amountNote The amount of $NOTE to deposit\n     */\n    function _depositNoteToASDVault(address _asdVault, uint _amountNote) internal returns (bool, string memory) {\n        // approve asd vault to spend $NOTE\n        IERC20(noteAddress).approve(_asdVault, _amountNote);\n        // deposit $NOTE to asd vault (use call, so this doesn't revert)\n        (bool success, bytes memory errReason) = _asdVault.call(abi.encodeWithSelector(ASDOFT.mint.selector, _amountNote));\n        return (success, string(errReason));\n    }\n\n    /**\n     * @notice swaps an OFT stable coin for $NOTE\n     * @dev only callable by the owner\n     * @param _oftAddress The address of the OFT stable coin contract\n     * @param _amount The amount of OFT stable coin to swap\n     * @param _minAmountNote The minimum amount of $NOTE to receive\n     * @return amount The amount of $NOTE received or error code\n     */\n    function _swapOFTForNote(address _oftAddress, uint _amount, uint _minAmountNote) internal returns (uint, bool) {\n        // sort tokens\n        address baseToken;\n        address quoteToken;\n        if (_oftAddress < noteAddress) {\n            baseToken = _oftAddress;\n            quoteToken = noteAddress;\n        } else {\n            baseToken = noteAddress;\n            quoteToken = _oftAddress;\n        }\n        // check if pool exists\n        if (ambientPoolFor(baseToken, quoteToken, ambientPoolIdx) == 0) {\n            // nothing swapped, swapped failed\n            return (0, false);\n        }\n\n        // convert amount to uint128\n        uint128 amountConverted = uint128(_amount);\n        // query impact to make sure user will receive at least _minAmountNote\n        bool isNoteBase = baseToken == noteAddress;\n        (int128 baseFlow, int128 quoteFlow, ) = ICrocImpact(crocImpactAddress).calcImpact(baseToken, quoteToken, ambientPoolIdx, !isNoteBase, !isNoteBase, amountConverted, 0, 0);\n\n        // check if amount note received is greater than or equal to _minAmountNote\n\n        int minAmountInt = int(_minAmountNote); // stack too deep fix\n        // flow is negative if it left the pool, so multiply by -1\n        if (isNoteBase && -baseFlow < minAmountInt) {\n            // nothing swapped, swapped failed\n            return (0, false);\n        } else if (!isNoteBase && -quoteFlow < minAmountInt) {\n            // nothing swapped, swapped failed\n            return (0, false);\n        }\n        // convert minAmount to uint for stack too deep fix\n        uint128 uintMinAmount = uint128(_minAmountNote);\n\n        // swap is good to make, use call just in case revert occurs\n        (bool successSwap, bytes memory data) = crocSwapAddress.call(abi.encodeWithSelector(ICrocSwapDex.swap.selector, baseToken, quoteToken, ambientPoolIdx, !isNoteBase, !isNoteBase, amountConverted, 0, 0, uintMinAmount, 0));\n        if (!successSwap) {\n            // nothing swapped, swapped failed\n            return (0, false);\n        }\n        // return amount of note received\n        (int128 baseUsed, int128 quoteUsed) = abi.decode(data, (int128, int128));\n        return (uint128(-1 * (isNoteBase ? baseUsed : quoteUsed)), true);\n    }\n\n    function ambientPoolFor(address _baseToken, address _quoteToken, uint256 _poolIdx) internal view returns (uint256) {\n        bytes32 poolKey = keccak256(abi.encode(_baseToken, _quoteToken, _poolIdx));\n        uint POOL_PARAM_SLOT = 65545;\n        bytes32 slot = keccak256(abi.encode(poolKey, POOL_PARAM_SLOT));\n        return ICrocSwapDex(crocSwapAddress).readSlot(uint256(slot));\n    }\n}"
    },
    {
      "filename": "contracts/asd/asdRouter.sol",
      "content": "pragma solidity ^0.8.22;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IOAppComposer} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppComposer.sol\";\nimport {OFTComposeMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTComposeMsgCodec.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ASDOFT} from \"./asdOFT.sol\";\nimport {IOFT, SendParam, MessagingFee} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {OptionsBuilder} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/libs/OptionsBuilder.sol\";\nimport {ICrocSwapDex, ICrocImpact} from \"../ambient/CrocInterfaces.sol\";\nimport {ASDUSDC} from \"./asdUSDC.sol\";\n\n/**\n * @title ASDRouter\n */\n\ncontract ASDRouter is IOAppComposer, Ownable {\n    // ambient params\n    address public crocSwapAddress;\n    address public crocImpactAddress;\n    uint public constant ambientPoolIdx = 36000;\n    // canto chain params\n    address public noteAddress;\n    uint32 public cantoLzEID;\n    // asdUSDC contract for swapping to $NOTE\n    address public asdUSDC;\n\n    struct OftComposeMessage {\n        uint32 _dstLzEid;\n        address _dstReceiver;\n        address _dstAsdAddress;\n        address _cantoAsdAddress;\n        uint256 _minAmountASD;\n        address _cantoRefundAddress;\n        uint256 _feeForSend;\n    }\n\n    event LZReceived(bytes32 indexed _guid, address _from, bytes _message, address _executor, bytes _extraData, uint _value);\n\n    event TokenRefund(bytes32 indexed _guid, address _tokenAddress, address _refundAddress, uint _amount, uint _nativeAmount, string _reason);\n\n    event ASDSent(bytes32 indexed _guid, address _to, address _asdAddress, uint _amount, uint32 _dstEid, bool _lzSend);\n\n    constructor(address _noteAddress, uint32 _cantoLzEID, address _crocSwapAddress, address _crocImpactAddress, address _asdUSDCAddress) {\n        noteAddress = _noteAddress;\n        cantoLzEID = _cantoLzEID;\n        crocSwapAddress = _crocSwapAddress;\n        crocImpactAddress = _crocImpactAddress;\n        asdUSDC = _asdUSDCAddress;\n    }\n\n    /**\n     * @notice Called by the LZ executor after sending OFT tokens to this contract.\n     * @param _from The address of the OFT on this chain.\n     * @param _guid The GUID of the message.\n     * @param _message The message payload from the executor formatted as an OFT composed message.\n     * @param _executor The address of the executor.\n     * @param _extraData Additional data supplied by the executor.\n     * @dev Cannot revert anywhere, must send the tokens to the intended receiver if something fails (token's will be lost otherwise)\n     */\n    function lzCompose(address _from, bytes32 _guid, bytes calldata _message, address _executor, bytes calldata _extraData) external payable {\n        /* log event */\n        emit LZReceived(_guid, _from, _message, _executor, _extraData, msg.value);\n\n        /* decode OFT composed message */\n        (, , uint256 amountLD, bytes32 composeFrom, bytes memory composeMsg) = _decodeOFTComposeMsg(_message);\n\n        /* decode composed message payload */\n\n        // check the composed message for proper formatting\n        if (composeMsg.length != 224) {\n            // return tokens to the address that sent them (composeFrom)\n            _refundToken(_guid, _from, OFTComposeMsgCodec.bytes32ToAddress(composeFrom), amountLD, msg.value, \"Invalid composeMsg length\");\n            return;\n        }\n        OftComposeMessage memory payload = abi.decode(composeMsg, (OftComposeMessage));\n\n        /* check if the OFT stable coin is whitelisted */\n        if (!ASDUSDC(asdUSDC).whitelistedUSDCVersions(_from)) {\n            // return tokens to the refund address on canto\n            _refundToken(_guid, _from, payload._cantoRefundAddress, amountLD, msg.value, \"not whitelisted\");\n            return;\n        }\n\n        /* deposit oft to receive asdUSDC for swapping */\n        IERC20(_from).approve(asdUSDC, amountLD);\n        uint amountUSDC = ASDUSDC(asdUSDC).deposit(_from, amountLD);\n\n        /* swap tokens for $NOTE (check minAmount for slippage) */\n        (uint amountNote, bool successfulSwap) = _swapOFTForNote(asdUSDC, amountUSDC, payload._minAmountASD);\n\n        // check if the swap was successful\n        if (!successfulSwap) {\n            // return tokens to the refund address on canto\n            _refundToken(_guid, asdUSDC, payload._cantoRefundAddress, amountUSDC, msg.value, \"swap failed\");\n            return;\n        }\n\n        /* deposit $NOTE to the correct asd vault to receive ASD tokens */\n        (bool successfulDeposit, string memory reason) = _depositNoteToASDVault(payload._cantoAsdAddress, amountNote);\n\n        // check if deposit was successful\n        if (!successfulDeposit) {\n            // return $NOTE to the refund address on canto since OFT was swapped already\n            _refundToken(_guid, noteAddress, payload._cantoRefundAddress, amountNote, msg.value, reason);\n            return;\n        }\n\n        /* transfer the ASD tokens to the destination receiver */\n        _sendASD(_guid, payload, amountNote);\n    }\n\n    /**\n     *\n     * @param _message The message payload from the executor formatted as an OFT composed message.\n     * @return _nonce The nonce value.\n     * @return _srcEid The source endpoint ID.\n     * @return _amountLD The amount in local decimals.\n     * @return _composeFrom The composeFrom value (msg.sender on from chain).\n     * @return _composeMsg The composed message.\n     */\n    function _decodeOFTComposeMsg(bytes calldata _message) internal pure returns (uint64 _nonce, uint32 _srcEid, uint256 _amountLD, bytes32 _composeFrom, bytes memory _composeMsg) {\n        _nonce = OFTComposeMsgCodec.nonce(_message);\n        _srcEid = OFTComposeMsgCodec.srcEid(_message);\n        _amountLD = OFTComposeMsgCodec.amountLD(_message);\n        _composeFrom = OFTComposeMsgCodec.composeFrom(_message);\n        _composeMsg = OFTComposeMsgCodec.composeMsg(_message);\n    }\n\n    /**\n     * @param _guid the GUID of the message from layer zero.\n     * @param _payload the payload of the message.\n     * @param _amount  the amount of ASD tokens to send.\n     */\n    function _sendASD(bytes32 _guid, OftComposeMessage memory _payload, uint _amount) internal {\n        /* transfer the ASD tokens to the destination receiver */\n        if (_payload._dstLzEid == cantoLzEID) {\n            // just transfer the ASD tokens to the destination receiver\n            emit ASDSent(_guid, _payload._dstReceiver, _payload._cantoAsdAddress, _amount, _payload._dstLzEid, false);\n            ASDOFT(_payload._cantoAsdAddress).transfer(_payload._dstReceiver, _amount);\n        } else {\n            // use Layer Zero oapp to send ASD tokens to the destination receiver on the destination chain\n\n            // make sure msg.value is enough to cover the fee or this transaction will revert\n            if (msg.value < _payload._feeForSend) {\n                // refund ASD tokens on canto\n                _refundToken(_guid, _payload._cantoAsdAddress, _payload._cantoRefundAddress, _amount, msg.value, \"insufficient msg.value for send fee\");\n                return;\n            }\n\n            // create send params for the Layer Zero oapp\n            bytes memory sendOptions = OptionsBuilder.addExecutorLzReceiveOption(OptionsBuilder.newOptions(), 200000, 0);\n            SendParam memory sendParams = SendParam({dstEid: _payload._dstLzEid, to: OFTComposeMsgCodec.addressToBytes32(_payload._dstReceiver), amountLD: _amount, minAmountLD: _amount, extraOptions: sendOptions, composeMsg: \"0x\", oftCmd: \"0x\"});\n            MessagingFee memory fee = MessagingFee({nativeFee: _payload._feeForSend, lzTokenFee: 0});\n\n            // send tokens\n            (bool successfulSend, bytes memory data) = payable(_payload._cantoAsdAddress).call{value: _payload._feeForSend}(abi.encodeWithSelector(IOFT.send.selector, sendParams, fee, _payload._cantoRefundAddress));\n\n            // check if the send was successful\n            if (!successfulSend) {\n                // refund ASD tokens on canto\n                _refundToken(_guid, _payload._cantoAsdAddress, _payload._cantoRefundAddress, _amount, msg.value, string(data));\n                return;\n            }\n            emit ASDSent(_guid, _payload._dstReceiver, _payload._cantoAsdAddress, _amount, _payload._dstLzEid, true);\n        }\n    }\n\n    /**\n     * @notice refunds tokens when lzCompose fails\n     * @param _guid The GUID of the message from layer zero.\n     * @param _tokenAddress address of token\n     * @param _refundAddress address to refund to on canto\n     * @param _amount amount to send\n     * @param _nativeAmount amount to send in native token\n     */\n    function _refundToken(bytes32 _guid, address _tokenAddress, address _refundAddress, uint _amount, uint _nativeAmount, string memory _reason) internal {\n        // emit event\n        emit TokenRefund(_guid, _tokenAddress, _refundAddress, _amount, _nativeAmount, _reason);\n        // transfer tokens to refund address\n        IERC20(_tokenAddress).transfer(_refundAddress, _amount);\n        // transfer native tokens to refund address and check that this value is less than or equal to msg.value\n        if (_nativeAmount > 0 && _nativeAmount <= msg.value) {\n            payable(_refundAddress).transfer(_nativeAmount);\n        }\n    }\n\n    /**\n     * @notice deposits $NOTE to the correct asd vault to receive ASD tokens\n     * @param _asdVault The address of the ASD vault to deposit to\n     * @param _amountNote The amount of $NOTE to deposit\n     */\n    function _depositNoteToASDVault(address _asdVault, uint _amountNote) internal returns (bool, string memory) {\n        // approve asd vault to spend $NOTE\n        IERC20(noteAddress).approve(_asdVault, _amountNote);\n        // deposit $NOTE to asd vault (use call, so this doesn't revert)\n        (bool success, bytes memory errReason) = _asdVault.call(abi.encodeWithSelector(ASDOFT.mint.selector, _amountNote));\n        return (success, string(errReason));\n    }\n\n    /**\n     * @notice swaps an OFT stable coin for $NOTE\n     * @dev only callable by the owner\n     * @param _oftAddress The address of the OFT stable coin contract\n     * @param _amount The amount of OFT stable coin to swap\n     * @param _minAmountNote The minimum amount of $NOTE to receive\n     * @return amount The amount of $NOTE received or error code\n     */\n    function _swapOFTForNote(address _oftAddress, uint _amount, uint _minAmountNote) internal returns (uint, bool) {\n        // sort tokens\n        address baseToken;\n        address quoteToken;\n        if (_oftAddress < noteAddress) {\n            baseToken = _oftAddress;\n            quoteToken = noteAddress;\n        } else {\n            baseToken = noteAddress;\n            quoteToken = _oftAddress;\n        }\n        // check if pool exists\n        if (ambientPoolFor(baseToken, quoteToken, ambientPoolIdx) == 0) {\n            // nothing swapped, swapped failed\n            return (0, false);\n        }\n\n        // convert amount to uint128\n        uint128 amountConverted = uint128(_amount);\n        // query impact to make sure user will receive at least _minAmountNote\n        bool isNoteBase = baseToken == noteAddress;\n        (int128 baseFlow, int128 quoteFlow, ) = ICrocImpact(crocImpactAddress).calcImpact(baseToken, quoteToken, ambientPoolIdx, !isNoteBase, !isNoteBase, amountConverted, 0, 0);\n\n        // check if amount note received is greater than or equal to _minAmountNote\n\n        int minAmountInt = int(_minAmountNote); // stack too deep fix\n        // flow is negative if it left the pool, so multiply by -1\n        if (isNoteBase && -baseFlow < minAmountInt) {\n            // nothing swapped, swapped failed\n            return (0, false);\n        } else if (!isNoteBase && -quoteFlow < minAmountInt) {\n            // nothing swapped, swapped failed\n            return (0, false);\n        }\n        // convert minAmount to uint for stack too deep fix\n        uint128 uintMinAmount = uint128(_minAmountNote);\n\n        // swap is good to make, use call just in case revert occurs\n        (bool successSwap, bytes memory data) = crocSwapAddress.call(abi.encodeWithSelector(ICrocSwapDex.swap.selector, baseToken, quoteToken, ambientPoolIdx, !isNoteBase, !isNoteBase, amountConverted, 0, 0, uintMinAmount, 0));\n        if (!successSwap) {\n            // nothing swapped, swapped failed\n            return (0, false);\n        }\n        // return amount of note received\n        (int128 baseUsed, int128 quoteUsed) = abi.decode(data, (int128, int128));\n        return (uint128(-1 * (isNoteBase ? baseUsed : quoteUsed)), true);\n    }\n\n    function ambientPoolFor(address _baseToken, address _quoteToken, uint256 _poolIdx) internal view returns (uint256) {\n        bytes32 poolKey = keccak256(abi.encode(_baseToken, _quoteToken, _poolIdx));\n        uint POOL_PARAM_SLOT = 65545;\n        bytes32 slot = keccak256(abi.encode(poolKey, POOL_PARAM_SLOT));\n        return ICrocSwapDex(crocSwapAddress).readSlot(uint256(slot));\n    }\n}"
    },
    {
      "filename": "contracts/asd/asdRouter.sol",
      "content": "pragma solidity ^0.8.22;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IOAppComposer} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppComposer.sol\";\nimport {OFTComposeMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTComposeMsgCodec.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ASDOFT} from \"./asdOFT.sol\";\nimport {IOFT, SendParam, MessagingFee} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {OptionsBuilder} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/libs/OptionsBuilder.sol\";\nimport {ICrocSwapDex, ICrocImpact} from \"../ambient/CrocInterfaces.sol\";\nimport {ASDUSDC} from \"./asdUSDC.sol\";\n\n/**\n * @title ASDRouter\n */\n\ncontract ASDRouter is IOAppComposer, Ownable {\n    // ambient params\n    address public crocSwapAddress;\n    address public crocImpactAddress;\n    uint public constant ambientPoolIdx = 36000;\n    // canto chain params\n    address public noteAddress;\n    uint32 public cantoLzEID;\n    // asdUSDC contract for swapping to $NOTE\n    address public asdUSDC;\n\n    struct OftComposeMessage {\n        uint32 _dstLzEid;\n        address _dstReceiver;\n        address _dstAsdAddress;\n        address _cantoAsdAddress;\n        uint256 _minAmountASD;\n        address _cantoRefundAddress;\n        uint256 _feeForSend;\n    }\n\n    event LZReceived(bytes32 indexed _guid, address _from, bytes _message, address _executor, bytes _extraData, uint _value);\n\n    event TokenRefund(bytes32 indexed _guid, address _tokenAddress, address _refundAddress, uint _amount, uint _nativeAmount, string _reason);\n\n    event ASDSent(bytes32 indexed _guid, address _to, address _asdAddress, uint _amount, uint32 _dstEid, bool _lzSend);\n\n    constructor(address _noteAddress, uint32 _cantoLzEID, address _crocSwapAddress, address _crocImpactAddress, address _asdUSDCAddress) {\n        noteAddress = _noteAddress;\n        cantoLzEID = _cantoLzEID;\n        crocSwapAddress = _crocSwapAddress;\n        crocImpactAddress = _crocImpactAddress;\n        asdUSDC = _asdUSDCAddress;\n    }\n\n    /**\n     * @notice Called by the LZ executor after sending OFT tokens to this contract.\n     * @param _from The address of the OFT on this chain.\n     * @param _guid The GUID of the message.\n     * @param _message The message payload from the executor formatted as an OFT composed message.\n     * @param _executor The address of the executor.\n     * @param _extraData Additional data supplied by the executor.\n     * @dev Cannot revert anywhere, must send the tokens to the intended receiver if something fails (token's will be lost otherwise)\n     */\n    function lzCompose(address _from, bytes32 _guid, bytes calldata _message, address _executor, bytes calldata _extraData) external payable {\n        /* log event */\n        emit LZReceived(_guid, _from, _message, _executor, _extraData, msg.value);\n\n        /* decode OFT composed message */\n        (, , uint256 amountLD, bytes32 composeFrom, bytes memory composeMsg) = _decodeOFTComposeMsg(_message);\n\n        /* decode composed message payload */\n\n        // check the composed message for proper formatting\n        if (composeMsg.length != 224) {\n            // return tokens to the address that sent them (composeFrom)\n            _refundToken(_guid, _from, OFTComposeMsgCodec.bytes32ToAddress(composeFrom), amountLD, msg.value, \"Invalid composeMsg length\");\n            return;\n        }\n        OftComposeMessage memory payload = abi.decode(composeMsg, (OftComposeMessage));\n\n        /* check if the OFT stable coin is whitelisted */\n        if (!ASDUSDC(asdUSDC).whitelistedUSDCVersions(_from)) {\n            // return tokens to the refund address on canto\n            _refundToken(_guid, _from, payload._cantoRefundAddress, amountLD, msg.value, \"not whitelisted\");\n            return;\n        }\n\n        /* deposit oft to receive asdUSDC for swapping */\n        IERC20(_from).approve(asdUSDC, amountLD);\n        uint amountUSDC = ASDUSDC(asdUSDC).deposit(_from, amountLD);\n\n        /* swap tokens for $NOTE (check minAmount for slippage) */\n        (uint amountNote, bool successfulSwap) = _swapOFTForNote(asdUSDC, amountUSDC, payload._minAmountASD);\n\n        // check if the swap was successful\n        if (!successfulSwap) {\n            // return tokens to the refund address on canto\n            _refundToken(_guid, asdUSDC, payload._cantoRefundAddress, amountUSDC, msg.value, \"swap failed\");\n            return;\n        }\n\n        /* deposit $NOTE to the correct asd vault to receive ASD tokens */\n        (bool successfulDeposit, string memory reason) = _depositNoteToASDVault(payload._cantoAsdAddress, amountNote);\n\n        // check if deposit was successful\n        if (!successfulDeposit) {\n            // return $NOTE to the refund address on canto since OFT was swapped already\n            _refundToken(_guid, noteAddress, payload._cantoRefundAddress, amountNote, msg.value, reason);\n            return;\n        }\n\n        /* transfer the ASD tokens to the destination receiver */\n        _sendASD(_guid, payload, amountNote);\n    }\n\n    /**\n     *\n     * @param _message The message payload from the executor formatted as an OFT composed message.\n     * @return _nonce The nonce value.\n     * @return _srcEid The source endpoint ID.\n     * @return _amountLD The amount in local decimals.\n     * @return _composeFrom The composeFrom value (msg.sender on from chain).\n     * @return _composeMsg The composed message.\n     */\n    function _decodeOFTComposeMsg(bytes calldata _message) internal pure returns (uint64 _nonce, uint32 _srcEid, uint256 _amountLD, bytes32 _composeFrom, bytes memory _composeMsg) {\n        _nonce = OFTComposeMsgCodec.nonce(_message);\n        _srcEid = OFTComposeMsgCodec.srcEid(_message);\n        _amountLD = OFTComposeMsgCodec.amountLD(_message);\n        _composeFrom = OFTComposeMsgCodec.composeFrom(_message);\n        _composeMsg = OFTComposeMsgCodec.composeMsg(_message);\n    }\n\n    /**\n     * @param _guid the GUID of the message from layer zero.\n     * @param _payload the payload of the message.\n     * @param _amount  the amount of ASD tokens to send.\n     */\n    function _sendASD(bytes32 _guid, OftComposeMessage memory _payload, uint _amount) internal {\n        /* transfer the ASD tokens to the destination receiver */\n        if (_payload._dstLzEid == cantoLzEID) {\n            // just transfer the ASD tokens to the destination receiver\n            emit ASDSent(_guid, _payload._dstReceiver, _payload._cantoAsdAddress, _amount,"
    }
  ]
}