{
  "Title": "Potential `safeApprove` blocking",
  "Content": "##### Description\nAt several places, e.g. https://github.com/bondappetit/bondappetit-protocol/blob/355180f0aca0b29d60d808f761052956b7a3a159/contracts/Investment.sol#L182 contract perform `safeApprove` before uniswap's function call, however in case if uniswap doesn't use full provided allowance that can lead to blocking next `safeApprove` call because `safeApprove` requires zero allowance.\n\nAnother lines with same issue:\n- https://github.com/bondappetit/bondappetit-protocol/blob/355180f0aca0b29d60d808f761052956b7a3a159/contracts/Market.sol#L248\n- https://github.com/bondappetit/bondappetit-protocol/blob/355180f0aca0b29d60d808f761052956b7a3a159/contracts/profit/Buyback.sol#L125\n- https://github.com/bondappetit/bondappetit-protocol/blob/355180f0aca0b29d60d808f761052956b7a3a159/contracts/profit/ProfitSplitter.sol#L195\n- https://github.com/bondappetit/bondappetit-protocol/blob/355180f0aca0b29d60d808f761052956b7a3a159/contracts/profit/ProfitSplitter.sol#L204\n- https://github.com/bondappetit/bondappetit-protocol/blob/355180f0aca0b29d60d808f761052956b7a3a159/contracts/profit/UniswapMarketMaker.sol#L116\n- https://github.com/bondappetit/bondappetit-protocol/blob/355180f0aca0b29d60d808f761052956b7a3a159/contracts/profit/UniswapMarketMaker.sol#L124\n- https://github.com/bondappetit/bondappetit-protocol/blob/355180f0aca0b29d60d808f761052956b7a3a159/contracts/profit/UniswapMarketMaker.sol#L125\n- https://github.com/bondappetit/bondappetit-protocol/blob/355180f0aca0b29d60d808f761052956b7a3a159/contracts/profit/UniswapMarketMaker.sol#L151\n- https://github.com/bondappetit/bondappetit-protocol/blob/355180f0aca0b29d60d808f761052956b7a3a159/contracts/profit/UniswapMarketMaker.sol#L152\n- https://github.com/bondappetit/bondappetit-protocol/blob/355180f0aca0b29d60d808f761052956b7a3a159/contracts/profit/UniswapMarketMaker.sol#L181\n\n##### Recommendation\nWe recommend to always reset allowance to zero by calling `safeApprove` with `0` amount.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Investment.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./utils/OwnablePausable.sol\";\nimport \"./uniswap/IUniswapV2Router02.sol\";\nimport \"./GovernanceToken.sol\";\n\ncontract Investment is OwnablePausable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    ///@notice Address of cumulative token\n    ERC20 public cumulative;\n\n    ///@notice Address of governance token\n    GovernanceToken public governanceToken;\n\n    ///@notice Date of locking governance token\n    uint256 public governanceTokenLockDate;\n\n    uint8 internal constant GOVERNANCE_TOKEN_PRICE_DECIMALS = 6;\n\n    ///@notice Price governance token\n    uint256 public governanceTokenPrice = 1000000;\n\n    ///@dev Address of UniswapV2Router\n    IUniswapV2Router02 internal uniswapRouter;\n\n    ///@notice Investment tokens list\n    mapping(address => bool) public investmentTokens;\n\n    /// @notice An event thats emitted when an uniswap router contract address changed.\n    event UniswapRouterChanged(address newUniswapRouter);\n\n    /// @notice An event thats emitted when an invest token allowed.\n    event InvestTokenAllowed(address token);\n\n    /// @notice An event thats emitted when an invest token denied.\n    event InvestTokenDenied(address token);\n\n    /// @notice An event thats emitted when an governance token price changed.\n    event GovernanceTokenPriceChanged(uint256 newPrice);\n\n    /// @notice An event thats emitted when an invested token.\n    event Invested(address investor, address token, uint256 amount, uint256 reward);\n\n    /// @notice An event thats emitted when an withdrawal token.\n    event Withdrawal(address recipient, address token, uint256 amount);\n\n    /**\n     * @param _cumulative Address of cumulative token\n     * @param _governanceToken Address of governance token\n     * @param _uniswapRouter Address of UniswapV2Router\n     */\n    constructor(\n        address _cumulative,\n        address _governanceToken,\n        uint256 _governanceTokenLockDate,\n        address _uniswapRouter\n    ) public {\n        cumulative = ERC20(_cumulative);\n        governanceToken = GovernanceToken(_governanceToken);\n        governanceTokenLockDate = _governanceTokenLockDate;\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n    }\n\n    /**\n     * @notice Changed uniswap router contract address.\n     * @param _uniswapRouter Address new uniswap router contract.\n     */\n    function changeUniswapRouter(address _uniswapRouter) external onlyOwner {\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        emit UniswapRouterChanged(_uniswapRouter);\n    }\n\n    /**\n     * @notice Add token to investable tokens white list\n     * @param token Allowable token\n     */\n    function allowToken(address token) external onlyOwner {\n        investmentTokens[token] = true;\n        emit InvestTokenAllowed(token);\n    }\n\n    /**\n     * @notice Remove token from investable tokens white list\n     * @param token Denied token\n     */\n    function denyToken(address token) external onlyOwner {\n        investmentTokens[token] = false;\n        emit InvestTokenDenied(token);\n    }\n\n    /**\n     * @notice Update governance token price\n     * @param newPrice New price of governance token of USD (6 decimal)\n     */\n    function changeGovernanceTokenPrice(uint256 newPrice) external onlyOwner {\n        require(newPrice > 0, \"Investment::changeGovernanceTokenPrice: invalid new governance token price\");\n\n        governanceTokenPrice = newPrice;\n        emit GovernanceTokenPriceChanged(newPrice);\n    }\n\n    /**\n     * @param token Invested token\n     * @return Pools for each consecutive pair of addresses must exist and have liquidity\n     */\n    function _path(address token) internal view returns (address[] memory) {\n        address weth = uniswapRouter.WETH();\n        if (weth == token) {\n            address[] memory path = new address[](2);\n            path[0] = token;\n            path[1] = address(cumulative);\n            return path;\n        }\n\n        address[] memory path = new address[](3);\n        path[0] = token;\n        path[1] = weth;\n        path[2] = address(cumulative);\n        return path;\n    }\n\n    /**\n     * @param token Invested token\n     * @param amount Invested amount\n     * @return Amount cumulative token after swap\n     */\n    function _amountOut(address token, uint256 amount) internal view returns (uint256) {\n        uint256[] memory amountsOut = uniswapRouter.getAmountsOut(amount, _path(token));\n        require(amountsOut.length != 0, \"Investment::_amountOut: invalid amounts out length\");\n\n        return amountsOut[amountsOut.length - 1];\n    }\n\n    /**\n     * @param amount Cumulative amount invested\n     * @return Amount governance token after swap\n     */\n    function _governanceTokenPrice(uint256 amount) internal view returns (uint256) {\n        uint256 decimals = cumulative.decimals();\n\n        return amount.mul(10**(18 - decimals + GOVERNANCE_TOKEN_PRICE_DECIMALS)).div(governanceTokenPrice);\n    }\n\n    /**\n     * @param token Invested token\n     * @param amount Invested amount\n     * @return Amount governance token after swap\n     */\n    function price(address token, uint256 amount) external view returns (uint256) {\n        require(investmentTokens[token], \"Investment::price: invalid investable token\");\n\n        uint256 amountOut = amount;\n        if (token != address(cumulative)) {\n            amountOut = _amountOut(token, amount);\n        }\n\n        return _governanceTokenPrice(amountOut);\n    }\n\n    /**\n     * @notice Invest tokens to protocol\n     * @param token Invested token\n     * @param amount Invested amount\n     */\n    function invest(address token, uint256 amount) external whenNotPaused returns (bool) {\n        require(investmentTokens[token], \"Investment::invest: invalid investable token\");\n        uint256 reward = _governanceTokenPrice(amount);\n\n        ERC20(token).safeTransferFrom(_msgSender(), address(this), amount);\n\n        if (token != address(cumulative)) {\n            uint256 amountOut = _amountOut(token, amount);\n            require(amountOut != 0, \"Investment::invest: liquidity pool is empty\");\n            reward = _governanceTokenPrice(amountOut);\n\n            ERC20(token).safeApprove(address(uniswapRouter), amount);\n            uniswapRouter.swapExactTokensForTokens(amount, amountOut, _path(token), address(this), block.timestamp);\n        }\n\n        governanceToken.transferLock(_msgSender(), reward, governanceTokenLockDate);\n\n        emit Invested(_msgSender(), token, amount, reward);\n        return true;\n    }\n\n    /**\n     * @notice Invest ETH to protocol\n     */\n    function investETH() external payable whenNotPaused returns (bool) {\n        address token = uniswapRouter.WETH();\n        require(investmentTokens[token], \"Investment::investETH: invalid investable token\");\n        uint256 reward = _governanceTokenPrice(msg.value);\n\n        if (token != address(cumulative)) {\n            uint256 amountOut = _amountOut(token, msg.value);\n            require(amountOut != 0, \"Investment::invest: liquidity pool is empty\");\n            reward = _governanceTokenPrice(amountOut);\n\n            uniswapRouter.swapExactETHForTokens{value: msg.value}(amountOut, _path(token), address(this), block.timestamp);\n        }\n\n        governanceToken.transferLock(_msgSender(), reward, governanceTokenLockDate);\n\n        emit Invested(_msgSender(), token, msg.value, reward);\n        return true;\n    }\n\n    /**\n     * @notice Withdraw invested token to address\n     * @param recipient Recipient of tokens\n     */\n    function withdraw(address recipient) external onlyOwner {\n        require(recipient != address(0), \"Investment::withdraw: cannot transfer to the zero address\");\n\n        uint256 balance = cumulative.balanceOf(address(this));\n        cumulative.safeTransfer(recipient, balance);\n\n        emit Withdrawal(recipient, address(cumulative), balance);\n    }\n}"
    },
    {
      "filename": "contracts/Market.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./utils/OwnablePausable.sol\";\nimport \"./uniswap/IUniswapV2Router02.sol\";\nimport \"./uniswap/IUniswapAnchoredView.sol\";\n\ncontract Market is OwnablePausable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    uint256 public constant PRICE_DECIMALS = 6;\n\n    uint256 public constant REWARD_DECIMALS = 12;\n\n    /// @notice Address of cumulative token.\n    ERC20 public cumulative;\n\n    /// @notice Address of product token contract.\n    ERC20 public productToken;\n\n    /// @notice Address of reward token contract.\n    ERC20 public rewardToken;\n\n    /// @dev Address of UniswapV2Router.\n    IUniswapV2Router02 public uniswapRouter;\n\n    /// @dev Address of IUniswapAnchoredView.\n    IUniswapAnchoredView public priceOracle;\n\n    /// @dev Allowed tokens symbols list.\n    mapping(address => string) internal allowedTokens;\n\n    /// @notice An event thats emitted when an price oracle contract address changed.\n    event PriceOracleChanged(address newPriceOracle);\n\n    /// @notice An event thats emitted when an uniswap router contract address changed.\n    event UniswapRouterChanged(address newUniswapRouter);\n\n    /// @notice An event thats emitted when an cumulative token changed.\n    event CumulativeChanged(address newToken);\n\n    /// @notice An event thats emitted when an token allowed.\n    event TokenAllowed(address token, string symbol);\n\n    /// @notice An event thats emitted when an token denied.\n    event TokenDenied(address token);\n\n    /// @notice An event thats emitted when an account buyed token.\n    event Buy(address customer, address token, uint256 amount, uint256 buy, uint256 reward);\n\n    /// @notice An event thats emitted when an cumulative token withdrawal.\n    event Withdrawal(address recipient, address token, uint256 amount);\n\n    /**\n     * @param _cumulative Address of cumulative token.\n     * @param _productToken Address of product token.\n     * @param _rewardToken Address of reward token.\n     * @param _uniswapRouter Address of Uniswap router contract.\n     * @param _priceOracle Address of Price oracle contract.\n     */\n    constructor(\n        address _cumulative,\n        address _productToken,\n        address _rewardToken,\n        address _uniswapRouter,\n        address _priceOracle\n    ) public {\n        cumulative = ERC20(_cumulative);\n        productToken = ERC20(_productToken);\n        rewardToken = ERC20(_rewardToken);\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        priceOracle = IUniswapAnchoredView(_priceOracle);\n    }\n\n    /**\n     * @notice Changed uniswap router contract address.\n     * @param _uniswapRouter Address new uniswap router contract.\n     */\n    function changeUniswapRouter(address _uniswapRouter) external onlyOwner {\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        emit UniswapRouterChanged(_uniswapRouter);\n    }\n\n    /**\n     * @notice Changed price oracle contract address.\n     * @param _priceOracle Address new price oracle contract.\n     */\n    function changePriceOracle(address _priceOracle) external onlyOwner {\n        priceOracle = IUniswapAnchoredView(_priceOracle);\n        emit PriceOracleChanged(_priceOracle);\n    }\n\n    /**\n     * @notice Changed cumulative token address.\n     * @param newToken Address new cumulative token.\n     * @param recipient Address of recipient for withdraw current cumulative balance.\n     */\n    function changeCumulativeToken(address newToken, address recipient) external onlyOwner {\n        withdraw(recipient);\n        cumulative = ERC20(newToken);\n        emit CumulativeChanged(newToken);\n    }\n\n    /**\n     * @notice Add token to tokens white list.\n     * @param token Allowable token.\n     * @param symbol Symbol target token of price oracle contract.\n     */\n    function allowToken(address token, string calldata symbol) external onlyOwner {\n        allowedTokens[token] = symbol;\n        emit TokenAllowed(token, symbol);\n    }\n\n    /**\n     * @notice Remove token from tokens white list.\n     * @param token Denied token.\n     */\n    function denyToken(address token) external onlyOwner {\n        allowedTokens[token] = \"\";\n        emit TokenDenied(token);\n    }\n\n    /**\n     * @param token Target token.\n     * @return Is target token allowed.\n     */\n    function isAllowedToken(address token) public view returns (bool) {\n        return bytes(allowedTokens[token]).length != 0;\n    }\n\n    /**\n     * @dev Transfer token to recipient.\n     * @param from Address of transfered token contract.\n     * @param recipient Address of recipient.\n     * @param amount Amount of transfered token.\n     */\n    function transfer(\n        ERC20 from,\n        address recipient,\n        uint256 amount\n    ) internal {\n        require(recipient != address(0), \"Market::transfer: cannot transfer to the zero address\");\n\n        uint256 currentBalance = from.balanceOf(address(this));\n        require(amount <= currentBalance, \"Market::transfer: not enough tokens\");\n\n        from.safeTransfer(recipient, amount);\n    }\n\n    /**\n     * @notice Transfer product token to recipient.\n     * @param recipient Address of recipient.\n     * @param amount Amount of transfered token.\n     */\n    function transferProductToken(address recipient, uint256 amount) external onlyOwner {\n        transfer(productToken, recipient, amount);\n    }\n\n    /**\n     * @notice Transfer reward token to recipient.\n     * @param recipient Address of recipient.\n     * @param amount Amount of transfered token.\n     */\n    function transferRewardToken(address recipient, uint256 amount) external onlyOwner {\n        transfer(rewardToken, recipient, amount);\n    }\n\n    /**\n     * @notice Get token price.\n     * @param currency Currency token.\n     * @param payment Amount of payment.\n     * @return product Amount of product token.\n     * @return reward Amount of reward token.\n     */\n    function price(address currency, uint256 payment) public view returns (uint256 product, uint256 reward) {\n        require(isAllowedToken(currency), \"Market::price: currency not allowed\");\n\n        uint256 tokenDecimals = ERC20(currency).decimals();\n        uint256 productDecimals = productToken.decimals();\n        uint256 tokenPrice = priceOracle.price(allowedTokens[currency]);\n        uint256 cumulativePrice = priceOracle.price(cumulative.symbol());\n\n        product = payment.mul(10**productDecimals.sub(tokenDecimals));\n        if (address(productToken) != currency) {\n            product = tokenPrice.mul(10**PRICE_DECIMALS).div(cumulativePrice).mul(payment).div(10**PRICE_DECIMALS).mul(10**productDecimals.sub(tokenDecimals));\n        }\n\n        uint256 productTokenBalance = productToken.balanceOf(address(this));\n        if (productTokenBalance > 0) {\n            uint256 rewardTokenBalance = rewardToken.balanceOf(address(this));\n            reward = product.mul(10**REWARD_DECIMALS).div(productTokenBalance).mul(rewardTokenBalance).div(10**REWARD_DECIMALS);\n        }\n    }\n\n    /**\n     * @param currency Currency token.\n     * @return Pools for each consecutive pair of addresses must exist and have liquidity\n     */\n    function _path(address currency) internal view returns (address[] memory) {\n        address weth = uniswapRouter.WETH();\n        if (weth == currency) {\n            address[] memory path = new address[](2);\n            path[0] = currency;\n            path[1] = address(cumulative);\n            return path;\n        }\n\n        address[] memory path = new address[](3);\n        path[0] = currency;\n        path[1] = weth;\n        path[2] = address(cumulative);\n        return path;\n    }\n\n    /**\n     * @param currency Currency token.\n     * @param payment Amount of payment.\n     * @return Amount cumulative token after swap.\n     */\n    function _amountOut(address currency, uint256 payment) internal view returns (uint256) {\n        uint256[] memory amountsOut = uniswapRouter.getAmountsOut(payment, _path(currency));\n        require(amountsOut.length != 0, \"Market::_amountOut: invalid amounts out length\");\n\n        return amountsOut[amountsOut.length - 1];\n    }\n\n    /**\n     * @notice Buy token with ERC20.\n     * @param currency Currency token.\n     * @param payment Amount of payment.\n     * @return True if success.\n     */\n    function buy(address currency, uint256 payment) external whenNotPaused returns (bool) {\n        (uint256 product, uint256 reward) = price(currency, payment);\n        uint256 productTokenBalance = productToken.balanceOf(address(this));\n        require(productTokenBalance > 0 && product <= productTokenBalance, \"Market::buy: exceeds balance\");\n\n        ERC20(currency).safeTransferFrom(_msgSender(), address(this), payment);\n\n        if (currency != address(cumulative)) {\n            uint256 amountOut = _amountOut(currency, payment);\n            require(amountOut != 0, \"Market::buy: liquidity pool is empty\");\n\n            ERC20(currency).safeApprove(address(uniswapRouter), payment);\n            uniswapRouter.swapExactTokensForTokens(payment, amountOut, _path(currency), address(this), block.timestamp);\n        }\n\n        productToken.safeTransfer(_msgSender(), product);\n        if (reward > 0) {\n            rewardToken.safeTransfer(_msgSender(), reward);\n        }\n        emit Buy(_msgSender(), currency, payment, product, reward);\n\n        return true;\n    }\n\n    /**\n     * @notice Buy token with ETH.\n     * @return True if success.\n     */\n    function buyFromETH() external payable whenNotPaused returns (bool) {\n        address currency = uniswapRouter.WETH();\n        uint256 payment = msg.value;\n\n        (uint256 product, uint256 reward) = price(currency, payment);\n        uint256 productTokenBalance = productToken.balanceOf(address(this));\n        require(product <= productTokenBalance, \"Market::buyFromETH: balance is empty\");\n\n        if (currency != address(cumulative)) {\n            uint256 amountOut = _amountOut(currency, payment);\n            require(amountOut != 0, \"Market::buyFromETH: liquidity pool is empty\");\n\n            uniswapRouter.swapExactETHForTokens{value: payment}(amountOut, _path(currency), address(this), block.timestamp);\n        }\n\n        productToken.safeTransfer(_msgSender(), product);\n        if (reward > 0) {\n            rewardToken.safeTransfer(_msgSender(), reward);\n        }\n        emit Buy(_msgSender(), currency, payment, product, reward);\n\n        return true;\n    }\n\n    /**\n     * @notice Withdraw cumulative token to address.\n     * @param recipient Recipient of token.\n     */\n    function withdraw(address recipient) public onlyOwner {\n        require(recipient != address(0), \"Market::withdraw: cannot transfer to the zero address\");\n\n        uint256 balance = cumulative.balanceOf(address(this));\n        cumulative.safeTransfer(recipient, balance);\n\n        emit Withdrawal(recipient, address(cumulative), balance);\n    }\n}"
    },
    {
      "filename": "contracts/profit/Buyback.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../utils/OwnablePausable.sol\";\nimport \"../uniswap/IUniswapV2Router02.sol\";\n\ncontract Buyback is OwnablePausable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    /// @notice Incoming token.\n    ERC20 public incoming;\n\n    /// @notice Outcoming token.\n    ERC20 public outcoming;\n\n    /// @notice Recipient address.\n    address public recipient;\n\n    /// @notice Uniswap router contract address.\n    IUniswapV2Router02 public uniswapRouter;\n\n    /// @notice An event thats emitted when an incoming token transferred to recipient.\n    event Transfer(address recipient, uint256 amount);\n\n    /// @notice An event thats emitted when an recipient address changed.\n    event RecipientChanged(address newRecipient);\n\n    /// @notice An event thats emitted when an incoming token changed.\n    event IncomingChanged(address newIncoming);\n\n    /// @notice An event thats emitted when an uniswap router contract address changed.\n    event UniswapRouterChanged(address newUniswapRouter);\n\n    /// @notice An event thats emitted when an buyback successed.\n    event BuybackSuccessed(uint256 incoming, uint256 outcoming);\n\n    /**\n     * @param _incoming Address of incoming token.\n     * @param _outcoming Address of outcoming token.\n     * @param _recipient Address of recipient outcoming token.\n     * @param _uniswapRouter Address of Uniswap router contract.\n     */\n    constructor(\n        address _incoming,\n        address _outcoming,\n        address _recipient,\n        address _uniswapRouter\n    ) public {\n        incoming = ERC20(_incoming);\n        outcoming = ERC20(_outcoming);\n        recipient = _recipient;\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n    }\n\n    /**\n     * @notice Change recipient address.\n     * @param _recipient New recipient address.\n     */\n    function changeRecipient(address _recipient) external onlyOwner {\n        recipient = _recipient;\n        emit RecipientChanged(recipient);\n    }\n\n    /**\n     * @notice Changed uniswap router contract address.\n     * @param _uniswapRouter Address new uniswap router contract.\n     */\n    function changeUniswapRouter(address _uniswapRouter) external onlyOwner {\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        emit UniswapRouterChanged(_uniswapRouter);\n    }\n\n    /**\n     * @notice Transfer incoming token to recipient.\n     * @param _recipient Address of recipient.\n     * @param amount Amount of transferred token.\n     */\n    function transfer(address _recipient, uint256 amount) public onlyOwner {\n        require(_recipient != address(0), \"Buyback::transfer: cannot transfer to the zero address\");\n\n        incoming.safeTransfer(_recipient, amount);\n        emit Transfer(_recipient, amount);\n    }\n\n    /**\n     * @notice Change incoming token address.\n     * @param _incoming New incoming token address.\n     * @param _recipient Address of recipient.\n     */\n    function changeIncoming(address _incoming, address _recipient) external onlyOwner {\n        require(address(incoming) != _incoming, \"Buyback::changeIncoming: duplicate incoming token address\");\n\n        uint256 balance = incoming.balanceOf(address(this));\n        if (balance > 0) {\n            transfer(_recipient, balance);\n        }\n        incoming = ERC20(_incoming);\n        emit IncomingChanged(_incoming);\n    }\n\n    /**\n     * @notice Make buyback attempt.\n     * @param amount Amount of tokens to buyback.\n     */\n    function buy(uint256 amount) external whenNotPaused {\n        if (amount > 0) {\n            incoming.safeTransferFrom(_msgSender(), address(this), amount);\n        }\n\n        address[] memory path = new address[](2);\n        path[0] = address(incoming);\n        path[1] = address(outcoming);\n\n        uint256 amountIn = incoming.balanceOf(address(this));\n        require(amountIn > 0, \"Buyback::buy: incoming token balance is empty\");\n        uint256[] memory amountsOut = uniswapRouter.getAmountsOut(amountIn, path);\n        require(amountsOut.length != 0, \"Buyback::buy: invalid amounts out length\");\n        uint256 amountOut = amountsOut[amountsOut.length - 1];\n        require(amountOut > 0, \"Buyback::buy: liquidity pool is empty\");\n\n        incoming.safeApprove(address(uniswapRouter), amountIn);\n        uniswapRouter.swapExactTokensForTokens(amountIn, amountOut, path, recipient, block.timestamp);\n        emit BuybackSuccessed(amountIn, amountOut);\n    }\n}"
    },
    {
      "filename": "contracts/profit/ProfitSplitter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"../utils/OwnablePausable.sol\";\nimport \"../uniswap/IUniswapV2Router02.sol\";\n\ncontract ProfitSplitter is OwnablePausable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 public constant SHARE_ACCURACY = 6;\n\n    uint256 public constant SHARE_DIGITS = 2;\n\n    /// @notice Incoming token.\n    ERC20 public incoming;\n\n    /// @notice Budget contract address.\n    address payable public budget;\n\n    /// @notice Target budget ETH balance.\n    uint256 public budgetBalance;\n\n    /// @notice Recipients share.\n    mapping(address => uint256) public shares;\n\n    /// @dev Recipients addresses index.\n    EnumerableSet.AddressSet private recipientsIndex;\n\n    /// @notice Uniswap router contract address.\n    IUniswapV2Router02 public uniswapRouter;\n\n    /// @notice An event thats emitted when an incoming token transferred to recipient.\n    event Transfer(address recipient, uint256 amount);\n\n    /// @notice An event thats emitted when an budget contract address and target balance changed.\n    event BudgetChanged(address newBudget, uint256 newBalance);\n\n    /// @notice An event thats emitted when an incoming token changed.\n    event IncomingChanged(address newIncoming);\n\n    /// @notice An event thats emitted when an uniswap router contract address changed.\n    event UniswapRouterChanged(address newUniswapRouter);\n\n    /// @notice An event thats emitted when an recipient added.\n    event RecipientAdded(address recipient, uint256 share);\n\n    /// @notice An event thats emitted when an recipient removed.\n    event RecipientRemoved(address recipient);\n\n    /// @notice An event thats emitted when an profit payed to budget.\n    event PayToBudget(address recipient, uint256 amount);\n\n    /// @notice An event thats emitted when an profit payed to recipient.\n    event PayToRecipient(address recipient, uint256 amount);\n\n    receive() external payable {}\n\n    /**\n     * @param _incoming Address of incoming token.\n     * @param _uniswapRouter Address of Uniswap router contract.\n     */\n    constructor(address _incoming, address _uniswapRouter) public {\n        incoming = ERC20(_incoming);\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n    }\n\n    /**\n     * @notice Changed uniswap router contract address.\n     * @param _uniswapRouter Address new uniswap router contract.\n     */\n    function changeUniswapRouter(address _uniswapRouter) external onlyOwner {\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        emit UniswapRouterChanged(_uniswapRouter);\n    }\n\n    /**\n     * @notice Changed budget contract address and target balance.\n     * @param _budget Address of budget contract.\n     * @param _budgetBalance Target budget balance.\n     */\n    function changeBudget(address payable _budget, uint256 _budgetBalance) external onlyOwner {\n        budget = _budget;\n        budgetBalance = _budgetBalance;\n        emit BudgetChanged(budget, budgetBalance);\n    }\n\n    /**\n     * @notice Transfer incoming token to recipient.\n     * @param _recipient Address of recipient.\n     * @param amount Amount of transferred token.\n     */\n    function transfer(address _recipient, uint256 amount) public onlyOwner {\n        require(_recipient != address(0), \"ProfitSplitter::transfer: cannot transfer to the zero address\");\n\n        incoming.safeTransfer(_recipient, amount);\n        emit Transfer(_recipient, amount);\n    }\n\n    /**\n     * @notice Change incoming token address.\n     * @param _incoming New incoming token address.\n     * @param _recipient Address of recipient.\n     */\n    function changeIncoming(address _incoming, address _recipient) external onlyOwner {\n        require(address(incoming) != _incoming, \"ProfitSplitter::changeIncoming: duplicate incoming token address\");\n\n        uint256 balance = incoming.balanceOf(address(this));\n        if (balance > 0) {\n            transfer(_recipient, balance);\n        }\n        incoming = ERC20(_incoming);\n        emit IncomingChanged(_incoming);\n    }\n\n    /**\n     * @dev Current share value.\n     * @return result Current share value.\n     */\n    function _currentShare() internal view returns (uint256 result) {\n        for (uint256 i = 0; i < recipientsIndex.length(); i++) {\n            result = result.add(shares[recipientsIndex.at(i)]);\n        }\n    }\n\n    /**\n     * @notice Add recipient.\n     * @param recipient Address of recipient contract.\n     * @param share Target share.\n     */\n    function addRecipient(address recipient, uint256 share) external onlyOwner {\n        require(!recipientsIndex.contains(recipient), \"ProfitSplitter::addRecipient: recipient already added\");\n        require(_currentShare().add(share) <= 100, \"ProfitSplitter::addRecipient: invalid share\");\n\n        recipientsIndex.add(recipient);\n        shares[recipient] = share;\n        emit RecipientAdded(recipient, share);\n    }\n\n    /**\n     * @notice Remove recipient.\n     * @param recipient Address of recipient contract.\n     */\n    function removeRecipient(address recipient) external onlyOwner {\n        require(recipientsIndex.contains(recipient), \"ProfitSplitter::removeRecipient: recipient already removed\");\n\n        recipientsIndex.remove(recipient);\n        shares[recipient] = 0;\n        emit RecipientRemoved(recipient);\n    }\n\n    /**\n     * @notice Get addresses of recipients.\n     * @return Current recipients list.\n     */\n    function getRecipients() public view returns (address[] memory) {\n        address[] memory result = new address[](recipientsIndex.length());\n\n        for (uint256 i = 0; i < recipientsIndex.length(); i++) {\n            result[i] = recipientsIndex.at(i);\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Pay ETH to budget contract.\n     */\n    function _payToBudget() internal returns (bool) {\n        uint256 splitterIncomingBalance = incoming.balanceOf(address(this));\n        if (splitterIncomingBalance == 0) return false;\n\n        uint256 currentBudgetBalance = budget.balance;\n        if (currentBudgetBalance >= budgetBalance) return false;\n\n        uint256 amount = budgetBalance.sub(currentBudgetBalance);\n        uint256 splitterEthBalance = address(this).balance;\n        if (splitterEthBalance < amount) {\n            uint256 amountOut = amount.sub(splitterEthBalance);\n\n            address[] memory path = new address[](2);\n            path[0] = address(incoming);\n            path[1] = uniswapRouter.WETH();\n\n            uint256[] memory amountsIn = uniswapRouter.getAmountsIn(amountOut, path);\n            require(amountsIn.length == 2, \"ProfitSplitter::_payToBudget: invalid amounts in length\");\n            require(amountsIn[0] > 0, \"ProfitSplitter::_payToBudget: liquidity pool is empty\");\n            if (amountsIn[0] <= splitterIncomingBalance) {\n                incoming.safeApprove(address(uniswapRouter), amountsIn[0]);\n                uniswapRouter.swapTokensForExactETH(amountOut, amountsIn[0], path, address(this), block.timestamp);\n            } else {\n                uint256[] memory amountsOut = uniswapRouter.getAmountsOut(splitterIncomingBalance, path);\n                require(amountsOut.length == 2, \"ProfitSplitter::_payToBudget: invalid amounts out length\");\n                require(amountsOut[1] > 0, \"ProfitSplitter::_payToBudget: amounts out liquidity pool is empty\");\n\n                amount = amountsOut[1];\n\n                incoming.safeApprove(address(uniswapRouter), splitterIncomingBalance);\n                uniswapRouter.swapExactTokensForETH(splitterIncomingBalance, amountsOut[1], path, address(this), block.timestamp);\n            }\n        }\n\n        budget.transfer(amount);\n        emit PayToBudget(budget, amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Pay incoming token to all recipients.\n     */\n    function _payToRecipients() internal returns (bool) {\n        uint256 splitterIncomingBalance = incoming.balanceOf(address(this));\n        if (splitterIncomingBalance == 0) return false;\n\n        for (uint256 i = 0; i < recipientsIndex.length(); i++) {\n            address recipient = recipientsIndex.at(i);\n            uint256 share = shares[recipient];\n\n            uint256 amount = splitterIncomingBalance.mul(10**SHARE_ACCURACY).mul(share).div(10**SHARE_ACCURACY.add(SHARE_DIGITS));\n            incoming.safeTransfer(recipient, amount);\n\n            emit PayToRecipient(recipient, amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Split all incoming token balance to recipients and budget contract.\n     * @param amount Approved amount incoming token."
    }
  ]
}