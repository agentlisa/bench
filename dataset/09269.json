{
  "Title": "[L-04] Prefer ",
  "Content": "<h2 id=\"l-04-prefer-safetransfer-and-safetransferfrom-for-erc20-token-transfers\" style=\"position:relative;\"><a href=\"#l-04-prefer-safetransfer-and-safetransferfrom-for-erc20-token-transfers\" aria-label=\"l 04 prefer safetransfer and safetransferfrom for erc20 token transfers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-04] Prefer <code>safeTransfer</code> and <code>safeTransferFrom</code> for ERC20 token transfers</h2>\n<p>Consider using OpenZeppelinâ€™s <a href=\"https://docs.openzeppelin.com/contracts/2.x/api/token/erc20#SafeERC20\"><code>SafeERC20</code></a> library to handle edge cases in ERC20 token transfers. This prevents accidentally forgetting to check the return value, like the example in <a href=\"https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleVesting.sol#L169-L174\"><code>MerkleVesting#withdraw</code></a>.</p>\n<p>Potential changes:</p>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L144\"><code>PermissionlessBasicPoolFactory.sol#L144</code></a></li>\n<li><a href=\"https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L198\"><code>PermissionlessBasicPoolFactory.sol#L198</code></a></li>\n<li><a href=\"https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L230\"><code>PermissionlessBasicPoolFactory.sol#L230</code></a></li>\n<li><a href=\"https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleVesting.sol#L89\"><code>MerkleVesting.sol#L89</code></a></li>\n<li><a href=\"https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleResistor.sol#L121\"><code>MerkleResistor.sol#L121</code></a></li>\n<li><a href=\"https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleResistor.sol#L204\"><code>MerkleResistor.sol#L204</code></a></li>\n<li><a href=\"https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleDropFactory.sol#L77\"><code>MerkleDropFactory.sol#L77</code></a></li>\n<li><a href=\"https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleDropFactory.sol#L107\"><code>MerkleDropFactory.sol#L107</code></a></li>\n</ul>\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-05-factorydao-contest",
  "Code": [
    {
      "filename": "contracts/MerkleVesting.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"./MerkleLib.sol\";\n\n/// @title A factory pattern for merkle-vesting, that is, a time release schedule for tokens, using merkle proofs to scale\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\n/// @notice This contract is permissionless and public facing. Any fees must be included in the data of the merkle tree.\n/// @dev The contract cannot introspect into the contents of the merkle tree, except when provided a merkle proof\ncontract MerkleVesting {\n    using MerkleLib for bytes32;\n\n    // the number of vesting schedules in this contract\n    uint public numTrees = 0;\n    \n    // this represents a single vesting schedule for a specific address\n    struct Tranche {\n        uint totalCoins;  // total number of coins released to an address after vesting is completed\n        uint currentCoins; // how many coins are left unclaimed by this address, vested or unvested\n        uint startTime; // when the vesting schedule is set to start, possibly in the past\n        uint endTime;  // when the vesting schedule will have released all coins\n        uint coinsPerSecond; // an intermediate value cached to reduce gas costs, how many coins released every second\n        uint lastWithdrawalTime; // the last time a withdrawal occurred, used to compute unvested coins\n        uint lockPeriodEndTime; // the first time at which coins may be withdrawn\n    }\n\n    // this represents a set of vesting schedules all in the same token\n    struct MerkleTree {\n        bytes32 rootHash;  // merkleroot of tree whose leaves are (address,uint,uint,uint,uint) representing vesting schedules\n        bytes32 ipfsHash; // ipfs hash of entire dataset, used to reconstruct merkle proofs if our servers go down\n        address tokenAddress; // token that the vesting schedules will be denominated in\n        uint tokenBalance; // current amount of tokens deposited to this tree, used to make sure trees don't share tokens\n    }\n\n    // initialized[recipient][treeIndex] = wasItInitialized?\n    mapping (address => mapping (uint => bool)) public initialized;\n\n    // array-like sequential map for all the vesting schedules\n    mapping (uint => MerkleTree) public merkleTrees;\n\n    // tranches[recipient][treeIndex] = initializedVestingSchedule\n    mapping (address => mapping (uint => Tranche)) public tranches;\n\n    // every time there's a withdrawal\n    event WithdrawalOccurred(uint indexed treeIndex, address indexed destination, uint numTokens, uint tokensLeft);\n\n    // every time a tree is added\n    event MerkleRootAdded(uint indexed treeIndex, address indexed tokenAddress, bytes32 newRoot, bytes32 ipfsHash);\n\n    // every time a tree is topped up\n    event TokensDeposited(uint indexed treeIndex, address indexed tokenAddress, uint amount);\n\n    /// @notice Add a new merkle tree to the contract, creating a new merkle-vesting-schedule\n    /// @dev Anyone may call this function, therefore we must make sure trees cannot affect each other\n    /// @dev Root hash should be built from (destination, totalCoins, startTime, endTime, lockPeriodEndTime)\n    /// @param newRoot root hash of merkle tree representing vesting schedules\n    /// @param ipfsHash the ipfs hash of the entire dataset, used for redundance so that creator can ensure merkleproof are always computable\n    /// @param tokenAddress the address of the token contract that is being distributed\n    /// @param tokenBalance the amount of tokens user wishes to use to fund the airdrop, note trees can be under/overfunded\n    function addMerkleRoot(bytes32 newRoot, bytes32 ipfsHash, address tokenAddress, uint tokenBalance) public {\n        // prefix operator ++ increments then evaluates\n        merkleTrees[++numTrees] = MerkleTree(\n            newRoot,\n            ipfsHash,\n            tokenAddress,\n            0    // no funds have been allocated to the tree yet\n        );\n        // fund the tree now\n        depositTokens(numTrees, tokenBalance);\n        emit MerkleRootAdded(numTrees, tokenAddress, newRoot, ipfsHash);\n    }\n\n    /// @notice Add funds to an existing merkle-vesting-schedule\n    /// @dev Anyone may call this function, the only risk here is that the token contract is malicious, rendering the tree malicious\n    /// @dev If the tree is over-funded, excess funds are lost. No clear way to get around this without zk-proofs\n    /// @param treeIndex index into array-like map of merkleTrees\n    /// @param value the amount of tokens user wishes to use to fund the airdrop, note trees can be underfunded\n    function depositTokens(uint treeIndex, uint value) public {\n        // storage since we are editing\n        MerkleTree storage merkleTree = merkleTrees[treeIndex];\n\n        // bookkeeping to make sure trees don't share tokens\n        merkleTree.tokenBalance += value;\n\n        // transfer tokens, if this is a malicious token, then this whole tree is malicious\n        // but it does not effect the other trees\n        require(IERC20(merkleTree.tokenAddress).transferFrom(msg.sender, address(this), value), \"ERC20 transfer failed\");\n        emit TokensDeposited(treeIndex, merkleTree.tokenAddress, value);\n    }\n\n    /// @notice Called once per recipient of a vesting schedule to initialize the vesting schedule\n    /// @dev Anyone may call this function, the only risk here is that the token contract is malicious, rendering the tree malicious\n    /// @dev If the tree is over-funded, excess funds are lost. No clear way to get around this without zk-proofs of global tree stats\n    /// @dev The contract has no knowledge of the vesting schedules until this function is called\n    /// @param treeIndex index into array-like map of merkleTrees\n    /// @param destination address that will receive tokens\n    /// @param totalCoins amount of tokens to be released after vesting completes\n    /// @param startTime time that vesting schedule starts, can be past or future\n    /// @param endTime time vesting schedule completes, can be past or future\n    /// @param lockPeriodEndTime time that coins become unlocked, can be after endTime\n    /// @param proof array of hashes linking leaf hash of (destination, totalCoins, startTime, endTime, lockPeriodEndTime) to root\n    function initialize(uint treeIndex, address destination, uint totalCoins, uint startTime, uint endTime, uint lockPeriodEndTime, bytes32[] memory proof) external {\n        // must not initialize multiple times\n        require(!initialized[destination][treeIndex], \"Already initialized\");\n        // leaf hash is digest of vesting schedule parameters and destination\n        // NOTE: use abi.encode, not abi.encodePacked to avoid possible (but unlikely) collision\n        bytes32 leaf = keccak256(abi.encode(destination, totalCoins, startTime, endTime, lockPeriodEndTime));\n        // memory because we read only\n        MerkleTree memory tree = merkleTrees[treeIndex];\n        // call to MerkleLib to check if the submitted data is correct\n        require(tree.rootHash.verifyProof(leaf, proof), \"The proof could not be verified.\");\n        // set initialized, preventing double initialization\n        initialized[destination][treeIndex] = true;\n        // precompute how many coins are released per second\n        uint coinsPerSecond = totalCoins / (endTime - startTime);\n        // create the tranche struct and assign it\n        tranches[destination][treeIndex] = Tranche(\n            totalCoins,  // total coins to be released\n            totalCoins,  // currentCoins starts as totalCoins\n            startTime,\n            endTime,\n            coinsPerSecond,\n            startTime,    // lastWithdrawal starts as startTime\n            lockPeriodEndTime\n        );\n        // if we've passed the lock time go ahead and perform a withdrawal now\n        if (lockPeriodEndTime < block.timestamp) {\n            withdraw(treeIndex, destination);\n        }\n    }\n\n    /// @notice Claim funds as a recipient in the merkle-drop\n    /// @dev Anyone may call this function for anyone else, funds go to destination regardless, it's just a question of\n    /// @dev who provides the proof and pays the gas, msg.sender is not used in this function\n    /// @param treeIndex index into array-like map of merkleTrees, which tree should we apply the proof to?\n    /// @param destination recipient of tokens\n    function withdraw(uint treeIndex, address destination) public {\n        // cannot withdraw from an uninitialized vesting schedule\n        require(initialized[destination][treeIndex], \"You must initialize your account first.\");\n        // storage because we will modify it\n        Tranche storage tranche = tranches[destination][treeIndex];\n        // no withdrawals before lock time ends\n        require(block.timestamp > tranche.lockPeriodEndTime, 'Must wait until after lock period');\n        // revert if there's nothing left\n        require(tranche.currentCoins >  0, 'No coins left to withdraw');\n\n        // declaration for branched assignment\n        uint currentWithdrawal = 0;\n\n        // if after vesting period ends, give them the remaining coins\n        if (block.timestamp >= tranche.endTime) {\n            currentWithdrawal = tranche.currentCoins;\n        } else {\n            // compute allowed withdrawal\n            currentWithdrawal = (block.timestamp - tranche.lastWithdrawalTime) * tranche.coinsPerSecond;\n        }\n\n        // decrease allocation of coins\n        tranche.currentCoins -= currentWithdrawal;\n        // this makes sure coins don't get double withdrawn\n        tranche.lastWithdrawalTime = block.timestamp;\n\n        // update the tree balance so trees can't take each other's tokens\n        MerkleTree storage tree = merkleTrees[treeIndex];\n        tree.tokenBalance -= currentWithdrawal;\n\n        // Transfer the tokens, if the token contract is malicious, this will make the whole tree malicious\n        // but this does not allow re-entrance due to struct updates and it does not effect other trees.\n        // It is also consistent with the ethereum general security model:\n        // other contracts do what they want, it's our job to protect our contract\n        IERC20(tree.tokenAddress).transfer(destination, currentWithdrawal);\n        emit WithdrawalOccurred(treeIndex, destination, currentWithdrawal, tranche.currentCoins);\n    }\n\n}"
    },
    {
      "filename": "contracts/PermissionlessBasicPoolFactory.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.12;\n\nimport \"../interfaces/IERC20.sol\";\n\n/// @title A factory pattern for basic staking, put tokens in, get more tokens (potentially multiple types) out\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\n/// @notice This contract is permissionless and public facing. Anyone can create a pool, and fees are taken out of rewards\n/// @dev Maximum possible pool obligations are computed at pool-creation-time and taken from creator at that time\n/// @dev Any unclaimed rewards are claimable after the pool has ended, pool funds are accounted for separately\ncontract PermissionlessBasicPoolFactory {\n\n    // this represents a single deposit into a staking pool, used to withdraw as well\n    struct Receipt {\n        uint id;   // primary key\n        uint amountDepositedWei;  // amount of tokens originally deposited\n        uint timeDeposited;  // the time the deposit was made\n        uint timeWithdrawn;  // the time the deposit was withdrawn, or 0 if not withdrawn yet\n        address owner;  // the owner of the deposit\n    }\n\n    // this represents a single staking pool with >= 1 reward tokens\n    struct Pool {\n        uint id; // primary key\n        uint[] rewardsWeiPerSecondPerToken; // array of reward rates, this number gets multiplied by time and tokens (not wei) to determine rewards\n        uint[] rewardsWeiClaimed;  // bookkeeping of how many rewards have been paid out for each token\n        uint[] rewardFunding;  // bookkeeping of how many rewards have been supplied for each token\n        uint maximumDepositWei;  // the size of the pool, maximum sum of all deposits\n        uint totalDepositsWei;  // current sum of all deposits\n        uint numReceipts;  // number of receipts issued\n        uint startTime;  // the time that the pool begins\n        uint endTime;    // time that the pool ends\n        uint taxPerCapita;  // portion of rewards that go to the contract creator\n        address depositToken;  // token that user deposits (stakes)\n        address excessBeneficiary;  // address that is able to reclaim unused rewards\n        address[] rewardTokens;  // array of token contract addresses that stakers will receive as rewards\n        mapping (uint => Receipt) receipts;  // mapping of receipt ids to receipt structs\n    }\n\n    // simple struct for UI to display relevant data\n    struct Metadata {\n        bytes32 name;\n        bytes32 ipfsHash;\n    }\n\n    // the number of staking pools ever created\n    uint public numPools;\n\n    // the beneficiary of taxes\n    address public globalBeneficiary;\n\n    // this is the settable tax imposed on new pools, fixed at pool creation time\n    uint public globalTaxPerCapita;\n\n    // pools[poolId] = poolStruct\n    mapping (uint => Pool) public pools;\n    // metadatas[poolId] = metadataStruct\n    mapping (uint => Metadata) public metadatas;\n    // taxes[poolId] = taxesCollected[rewardIndex]\n    mapping (uint => uint[]) public taxes;\n\n    // every time a deposit happens\n    event DepositOccurred(uint indexed poolId, uint indexed receiptId, address indexed owner);\n    // every time a withdrawal happens\n    event WithdrawalOccurred(uint indexed poolId, uint indexed receiptId, address indexed owner);\n    // every time excess rewards are withdrawn\n    event ExcessRewardsWithdrawn(uint indexed poolId);\n    // every time a pool is added\n    event PoolAdded(uint indexed poolId, bytes32 indexed name, address indexed depositToken);\n\n    /// @notice Whoever deploys the contract decides who receives how much fees\n    /// @param _globalBeneficiary the address that receives the fees and can also set the fees\n    /// @param _globalTaxPerCapita the amount of the rewards that goes to the globalBeneficiary * 1000 (perCapita)\n    constructor(address _globalBeneficiary, uint _globalTaxPerCapita) {\n        globalBeneficiary = _globalBeneficiary;\n        globalTaxPerCapita = _globalTaxPerCapita;\n    }\n\n    /// @notice Create a pool and fund it\n    /// @dev Anyone may call this function, but they must fund it, having called approve on all contracts beforehand\n    /// @dev Any malicious token contracts included here will make the pool malicious, but not effect other pools\n    /// @param startTime time at which pool starts, if in past, it is set to block.timestamp \"now\"\n    /// @param maxDeposit the maximum amount of tokens that can be deposited in this pool\n    /// @param rewardsWeiPerSecondPerToken the amount of tokens given out per second per token (not wei) deposited\n    /// @param programLengthDays the amount of days the pool will be open, this with the start time determines the end time\n    /// @param depositTokenAddress the token that users will put into the pool to receive rewards\n    /// @param excessBeneficiary the recipient of any unclaimed funds in the pool\n    /// @param rewardTokenAddresses the list of token contracts that will be given out as rewards for staking\n    /// @param ipfsHash a hash of any metadata about the pool, may be incorporated into interfaces\n    /// @param name name of pool, to be used by interfaces\n    function addPool (\n        uint startTime,\n        uint maxDeposit,\n        uint[] memory rewardsWeiPerSecondPerToken,\n        uint programLengthDays,\n        address depositTokenAddress,\n        address excessBeneficiary,\n        address[] memory rewardTokenAddresses,\n        bytes32 ipfsHash,\n        bytes32 name\n    ) external {\n        Pool storage pool = pools[++numPools];\n        pool.id = numPools;\n        pool.rewardsWeiPerSecondPerToken = rewardsWeiPerSecondPerToken;\n        pool.startTime = startTime > block.timestamp ? startTime : block.timestamp;\n        pool.endTime = pool.startTime + (programLengthDays * 1 days);\n        pool.depositToken = depositTokenAddress;\n        pool.excessBeneficiary = excessBeneficiary;\n        pool.taxPerCapita = globalTaxPerCapita;\n\n        require(rewardsWeiPerSecondPerToken.length == rewardTokenAddresses.length, 'Rewards and reward token arrays must be same length');\n\n        // fill out the arrays with zeros\n        for (uint i = 0; i < rewardTokenAddresses.length; i++) {\n            pool.rewardTokens.push(rewardTokenAddresses[i]);\n            pool.rewardsWeiClaimed.push(0);\n            pool.rewardFunding.push(0);\n            taxes[numPools].push(0);\n        }\n        pool.maximumDepositWei = maxDeposit;\n\n        // this must be after pool initialization above\n        fundPool(pool.id);\n\n        {\n            Metadata storage metadata = metadatas[numPools];\n            metadata.ipfsHash = ipfsHash;\n            metadata.name = name;\n        }\n        emit PoolAdded(pool.id, name, depositTokenAddress);\n    }\n\n    /// @notice Add funds to a pool\n    /// @dev This function is internal because pools cannot be underfunded, liabilities are known at pool-creation-time\n    /// @param poolId index of pool that is being funded\n    function fundPool(uint poolId) internal {\n        Pool storage pool = pools[poolId];\n        bool success = true;\n        uint amount;\n        for (uint i = 0; i < pool.rewardFunding.length; i++) {\n            amount = getMaximumRewards(poolId, i);\n            // transfer the tokens from pool-creator to this contract\n            success = success && IERC20(pool.rewardTokens[i]).transferFrom(msg.sender, address(this), amount);\n            // bookkeeping to make sure pools don't share tokens\n            pool.rewardFunding[i] += amount;\n        }\n        require(success, 'Token deposits failed');\n    }\n\n    /// @notice Compute the rewards that would be received if the receipt was cashed out now\n    /// @dev This function does not inspect whether the receipt has already been cashed out\n    /// @param poolId which pool are we talking about?\n    /// @param receiptId the id of the receipt that we are querying\n    /// @return rewardsLocal array of rewards, one entry for each reward token\n    function getRewards(uint poolId, uint receiptId) public view returns (uint[] memory) {\n        Pool storage pool = pools[poolId];\n        Receipt memory receipt = pool.receipts[receiptId];\n        require(pool.id == poolId, 'Uninitialized pool');\n        require(receipt.id == receiptId, 'Uninitialized receipt');\n        uint nowish = block.timestamp;\n        if (nowish > pool.endTime) {\n            nowish = pool.endTime;\n        }\n\n        uint secondsDiff = nowish - receipt.timeDeposited;\n        uint[] memory rewardsLocal = new uint[](pool.rewardsWeiPerSecondPerToken.length);\n        for (uint i = 0; i < pool.rewardsWeiPerSecondPerToken.length; i++) {\n            rewardsLocal[i] = (secondsDiff * pool.rewardsWeiPerSecondPerToken[i] * receipt.amountDepositedWei) / 1e18;\n        }\n\n        return rewardsLocal;\n    }\n\n    /// @notice Add funds to a pool\n    /// @dev Anyone may call this function, it simply puts tokens in the pool and returns a receipt\n    /// @dev If deposit amount causes pool to overflow, amount is decreased so pool is full\n    /// @param poolId which pool are we talking about?\n    /// @param amount amount of tokens to deposit\n    function deposit(uint poolId, uint amount) external {\n        Pool storage pool = pools[poolId];\n        require(pool.id == poolId, 'Uninitialized pool');\n        require(block.timestamp > pool.startTime, 'Cannot deposit before pool start');\n        require(block.timestamp < pool.endTime, 'Cannot deposit after pool ends');\n        require(pool.totalDepositsWei < pool.maximumDepositWei, 'Maximum deposit already reached');\n        if (pool.totalDepositsWei + amount > pool.maximumDepositWei) {\n            amount = pool.maximumDepositWei - pool.totalDepositsWei;\n        }\n        pool.totalDepositsWei += amount;\n        pool.numReceipts++;\n\n        Receipt storage receipt = pool.receipts[pool.numReceipts];\n        receipt.id = pool.numReceipts;\n        receipt.amountDepositedWei = amount;\n        receipt.timeDeposited = block.timestamp;\n        receipt.owner = msg.sender;\n\n        bool success = IERC20(pool.depositToken).transferFrom(msg.sender, address(this), amount);\n        require(success, 'Token transfer failed');\n\n        emit DepositOccurred(poolId, pool.numReceipts, msg.sender);\n    }\n\n    /// @notice Withdraw funds from pool\n    /// @dev Only receipt owner may call this function\n    /// @dev If any of the reward tokens are malicious, this function may break\n    /// @param poolId which pool are we talking about?\n    /// @param receiptId which receipt is being cashed in\n    function withdraw(uint poolId, uint receiptId) external {\n        Pool storage pool = pools[poolId];\n        require(pool.id == poolId, 'Uninitialized pool');\n        Receipt storage receipt = pool.receipts[receiptId];\n        require(receipt.id == receiptId, 'Can only withdraw real receipts');\n        require(receipt.owner == msg.sender || block.timestamp > pool.endTime, 'Can only withdraw your own deposit');\n        require(receipt.timeWithdrawn == 0, 'Can only withdraw once per receipt');\n\n        // close re-entry gate\n        receipt.timeWithdrawn = block.timestamp;\n\n        uint[] memory rewards = getRewards(poolId, receiptId);\n        pool.totalDepositsWei -= receipt.amountDepositedWei;\n        bool success = true;\n\n        for (uint i = 0; i < rewards.length; i++) {\n            pool.rewardsWeiClaimed[i] += rewards[i];\n            pool.rewardFunding[i] -= rewards[i];\n            uint tax = (pool.taxPerCapita * rewards[i]) / 1000;\n            uint transferAmount = rewards[i] - tax;\n            taxes[poolId][i] += tax;\n            success = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);\n        }\n\n        success = success && IERC20(pool.depositToken).transfer(receipt.owner, receipt.amountDepositedWei);\n        require(success, 'Token transfer failed');\n\n        emit WithdrawalOccurred(poolId, receiptId, receipt.owner);\n    }\n\n    /// @notice Withdraw any unused rewards from the pool, after it has ended\n    /// @dev Anyone can call this, as the excess beneficiary is set at pool-creation-time\n    /// @param poolId which pool are we talking about?\n    function withdrawExcessRewards(uint poolId) external {\n        Pool storage pool = pools[poolId];\n        require(pool.id == poolId, 'Uninitialized pool');\n        require(pool.totalDepositsWei == 0, 'Cannot withdraw until all deposits are withdrawn');\n        require(block.timestamp > pool.endTime, 'Contract must reach maturity');\n\n        bool success = true;\n        for (uint i = 0; i < pool.rewardTokens.length; i++) {\n            uint rewards = pool.rewardFunding[i];\n            pool.rewardFunding[i] = 0;\n            success = success && IERC20(pool.rewardTokens[i]).transfer(pool.excessBeneficiary, rewards);\n        }\n        require(success, 'Token transfer failed');\n        emit ExcessRewardsWithdrawn(poolId);\n    }\n\n    /// @notice Withdraw taxes from pool\n    /// @dev Anyone may call this, it just moves the taxes from this contract to the globalBeneficiary\n    /// @param poolId which pool are we talking about?\n    function withdrawTaxes(uint poolId) external {\n        Pool storage pool = pools[poolId];\n        require(pool.id == poolId, 'Uninitialized pool');\n\n        bool success = true;\n        for (uint i = 0; i < pool.rewardTokens.length; i++) {\n            uint tax = taxes[poolId][i];\n            taxes[poolId][i] = 0;\n            success = success && IERC20(pool.rewardTokens[i]).transfer(globalBeneficiary, tax);\n        }\n        require(success, 'Token transfer failed');\n    }\n\n    /// @notice Compute maximum rewards that could be given out by a given pool\n    /// @dev This is primarily used by fundPool to compute how many tokens to take from the pool-creator\n    /// @param poolId which pool are we talking about?\n    /// @param rewardIndex index into the rewards array, to avoid passing arrays around\n    /// @return maximumRewardAmount the theoretical maximum that will be paid from this reward token, if pool fills instantly\n    function getMaximumRewards(uint poolId, uint rewardIndex) public view returns (uint) {\n        Pool storage pool = pools[poolId];\n        // rewardsPerSecondPerToken * tokens * seconds\n        return pool.rewardsWeiPerSecondPerToken[rewardIndex] * pool.maximumDepositWei * (pool.endTime - pool.startTime) / 1e18;\n    }\n\n    /// @notice Get reward data about a pool\n    /// @dev This gets all the reward-relevant fields from the struct\n    /// @param poolId which pool are we talking about?\n    /// @return rewardsWeiPerSecondPerToken reward slope array\n    /// @return rewardsWeiClaimed rewards already claimed array\n    /// @return rewardTokens array of reward token contract addresses\n    /// @return rewardFunding array of amounts of reward tokens already dispensed\n    function getRewardData(uint poolId) external view returns (uint[] memory, uint[] memory, address[] memory, uint[] memory) {\n        Pool storage pool = pools[poolId];\n        return (pool.rewardsWeiPerSecondPerToken, pool.rewardsWeiClaimed, pool.rewardTokens, pool.rewardFunding);\n    }\n\n    /// @notice Get data about a specific receipt\n    /// @dev This gets all the fields from a receipt\n    /// @param poolId which pool are we talking about?\n    /// @param receiptId which receipt are we talking about?\n    /// @return amountDepositedWei original deposit amount\n    /// @return timeDeposited the time of original deposit\n    /// @return timeWithdrawn time when receipt was cashed in, if ever\n    /// @return owner the beneficiary of the receipt, who deposited the tokens originally?\n    function getReceipt(uint poolId, uint receiptId) external view returns (uint, uint, uint, address) {\n        Pool storage pool = pools[poolId];\n        Receipt storage receipt = pool.receipts[receiptId];\n        return (receipt.amountDepositedWei, receipt.timeDeposited, receipt.timeWithdrawn, receipt.owner);\n    }\n\n    /// @notice Change the fee factor\n    /// @dev This can only be called by the global beneficiary\n    /// @param newTaxPerCapita the new fee\n    function setGlobalTax(uint newTaxPerCapita) external {\n        require(msg.sender == globalBeneficiary, 'Only globalBeneficiary can set tax');\n        require(newTaxPerCapita < 1000, 'Tax too high');\n        globalTaxPerCapita = newTaxPerCapita;\n    }\n}"
    },
    {
      "filename": "contracts/PermissionlessBasicPoolFactory.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.12;\n\nimport \"../interfaces/IERC20.sol\";\n\n/// @title A factory pattern for basic staking, put tokens in, get more tokens (potentially multiple types) out\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\n/// @notice This contract is permissionless and public facing. Anyone can create a pool, and fees are taken out of rewards\n/// @dev Maximum possible pool obligations are computed at pool-creation-time and taken from creator at that time\n/// @dev Any unclaimed rewards are claimable after the pool has ended, pool funds are accounted for separately\ncontract PermissionlessBasicPoolFactory {\n\n    // this represents a single deposit into a staking pool, used to withdraw as well\n    struct Receipt {\n        uint id;   // primary key\n        uint amountDepositedWei;  // amount of tokens originally deposited\n        uint timeDeposited;  // the time the deposit was made\n        uint timeWithdrawn;  // the time the deposit was withdrawn, or 0 if not withdrawn yet\n        address owner;  // the owner of the deposit\n    }\n\n    // this represents a single staking pool with >= 1 reward tokens\n    struct Pool {\n        uint id; // primary key\n        uint[] rewardsWeiPerSecondPerToken; // array of reward rates, this number gets multiplied by time and tokens (not wei) to determine rewards\n        uint[] rewardsWeiClaimed;  // bookkeeping of how many rewards have been paid out for each token\n        uint[] rewardFunding;  // bookkeeping of how many rewards have been supplied for each token\n        uint maximumDepositWei;  // the size of the pool, maximum sum of all deposits\n        uint totalDepositsWei;  // current sum of all deposits\n        uint numReceipts;  // number of receipts issued\n        uint startTime;  // the time that the pool begins\n        uint endTime;    // time that the pool ends\n        uint taxPerCapita;  // portion of rewards that go to the contract creator\n        address depositToken;  // token that user deposits (stakes)\n        address excessBeneficiary;  // address that is able to reclaim unused rewards\n        address[] rewardTokens;  // array of token contract addresses that stakers will receive as rewards\n        mapping (uint => Receipt) receipts;  // mapping of receipt ids to receipt structs\n    }\n\n    // simple struct for UI to display relevant data\n    struct Metadata {\n        bytes32 name;\n        bytes32 ipfsHash;\n    }\n\n    // the number of staking pools ever created\n    uint public numPools;\n\n    // the beneficiary of taxes\n    address public globalBeneficiary;\n\n    // this is the settable tax imposed on new pools, fixed at pool creation time\n    uint public globalTaxPerCapita;\n\n    // pools[poolId] = poolStruct\n    mapping (uint => Pool) public pools;\n    // metadatas[poolId] = metadataStruct\n    mapping (uint => Metadata) public metadatas;\n    // taxes[poolId] = taxesCollected[rewardIndex]\n    mapping (uint => uint[]) public taxes;\n\n    // every time a deposit happens\n    event DepositOccurred(uint indexed poolId, uint indexed receiptId, address indexed owner);\n    // every time a withdrawal happens\n    event WithdrawalOccurred(uint indexed poolId, uint indexed receiptId, address indexed owner);\n    // every time excess rewards are withdrawn\n    event ExcessRewardsWithdrawn(uint indexed poolId);\n    // every time a pool is added\n    event PoolAdded(uint indexed poolId, bytes32 indexed name, address indexed depositToken);\n\n    /// @notice Whoever deploys the contract decides who receives how much fees\n    /// @param _globalBeneficiary the address that receives the fees and can also set the fees\n    /// @param _globalTaxPerCapita the amount of the rewards that goes to the globalBeneficiary * 1000 (perCapita)\n    constructor(address _globalBeneficiary, uint _globalTaxPerCapita) {\n        globalBeneficiary = _globalBeneficiary;\n        globalTaxPerCapita = _globalTaxPerCapita;\n    }\n\n    /// @notice Create a pool and fund it\n    /// @dev Anyone may call this function, but they must fund it, having called approve on all contracts beforehand\n    /// @dev Any malicious token contracts included here will make the pool malicious, but not effect other pools\n    /// @param startTime time at which pool starts, if in past, it is set to block.timestamp \"now\"\n    /// @param maxDeposit the maximum amount of tokens that can be deposited in this pool\n    /// @param rewardsWeiPerSecondPerToken the amount of tokens given out per second per token (not wei) deposited\n    /// @param programLengthDays the amount of days the pool will be open, this with the start time determines the end time\n    /// @param depositTokenAddress the token that users will put into the pool to receive rewards\n    /// @param excessBeneficiary the recipient of any unclaimed funds in the pool\n    /// @param rewardTokenAddresses the list of token contracts that will be given out as rewards for staking\n    /// @param ipfsHash a hash of any metadata about the pool, may be incorporated into interfaces\n    /// @param name name of pool, to be used by interfaces\n    function addPool (\n        uint startTime,\n        uint maxDeposit,\n        uint[] memory rewardsWeiPerSecondPerToken,\n        uint programLengthDays,\n        address depositTokenAddress,\n        address excessBeneficiary,\n        address[] memory rewardTokenAddresses,\n        bytes32 ipfsHash,\n        bytes32 name\n    ) external {\n        Pool storage pool = pools[++numPools];\n        pool.id = numPools;\n        pool.rewardsWeiPerSecondPerToken = rewardsWeiPerSecondPerToken;\n        pool.startTime = startTime > block.timestamp ? startTime : block.timestamp;\n        pool.endTime = pool.startTime + (programLengthDays * 1 days);\n        pool.depositToken = depositTokenAddress;\n        pool.excessBeneficiary = excessBeneficiary;\n        pool.taxPerCapita = globalTaxPerCapita;\n\n        require(rewardsWeiPerSecondPerToken.length == rewardTokenAddresses.length, 'Rewards and reward token arrays must be same length'"
    }
  ]
}