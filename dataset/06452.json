{
  "Title": "[H-28] Removing a `BribeFlywheel` from a Gauge does not remove the reward asset from the rewards depo, making it impossible to add a new Flywheel with the same reward token",
  "Content": "\nRemoving a bribe Flywheel (`FlywheelCore`) from a Gauge (via `BaseV2Gauge::removeBribeFlywheel`) does not remove the reward asset (call `MultiRewardsDepot::removeAsset`) from the rewards depo (`BaseV2Gauge::multiRewardsDepot`), making it impossible to add a new Flywheel (by calling `BaseV2Gauge::addBribeFlywheel`) with the same reward token (because `MultiRewardsDepot::addAsset` reverts as the assets already exist).\n\nThe impact is limiting protocol functionality in unwanted ways, possibly impacting gains in the long run. Example: due to incentives lost by not having a specific token bribe reward.\n\n### Proof of Concept\n\nObservation: a `BribeFlywheel` is a `FlywheelCore` with a `FlywheelBribeRewards` set as the `FlywheelRewards`, typically created using the `BribesFactory::createBribeFlywheel`.\n\n### Scenario and execution flow\n\n- A project decides to add an initial  `BribeFlywheel` to the recently deployed `UniswapV3Gauge` contract.\n- This is done by calling [`UniswapV3GaugeFactory::BaseV2GaugeFactory::addBribeToGauge`](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/BaseV2GaugeFactory.sol#L144-L148).\n  - The execution further goes to `BaseV2Gauge::addGaugetoFlywheel` where [the bribe flywheel reward token is added](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/BaseV2Gauge.sol#L135) to the multi reward depo.\n- A project decides, for whatever reason (a bug in the contract, an exploit, a decommission, a more profitable wheel that would use the same rewards token), that they want to replace the old flywheel with a new one.\n- Removing this is done via calling [`UniswapV3GaugeFactory::BaseV2GaugeFactory::removeBribeFromGauge`](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/BaseV2GaugeFactory.sol#L151-L154).\n  - The execution further goes to `BaseV2Gauge::removeBribeFlywheel`, where the flywheel is removed but the reward token asset [is not removed from the multi reward depo](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/BaseV2Gauge.sol#L144-L152). There is no call to [`MultiRewardsDepot::removeAsset`](https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/depots/MultiRewardsDepot.sol#L57-L65):\n\n```Solidity\n    function removeBribeFlywheel(FlywheelCore bribeFlywheel) external onlyOwner {\n        /// @dev Can only remove active flywheels\n        if (!isActive[bribeFlywheel]) revert FlywheelNotActive();\n\n        /// @dev This is permanent; can't be re-added\n        delete isActive[bribeFlywheel];\n\n        emit RemoveBribeFlywheel(bribeFlywheel);\n    }\n```\n\n- After removal, when trying to add a new flywheel with the same rewards token, the execution fails with `ErrorAddingAsset` since the [`addAsset`](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/BaseV2Gauge.sol#L135) call reverts since [the rewards token was not removed](https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/depots/MultiRewardsDepot.sol#L48) with the previous call to `BaseV2Gauge::removeBribeFlywheel`.\n\n### Recommended Mitigation Steps\n\nwhen `BaseV2Gauge::removeBribeFlywheel` is called for a particular flywheel, also remove its corresponding reward depo token.\n\nExample implementation:\n\n```diff\ndiff --git a/src/gauges/BaseV2Gauge.sol b/src/gauges/BaseV2Gauge.sol\nindex c2793a7..8ea6c1e 100644\n--- a/src/gauges/BaseV2Gauge.sol\n+++ b/src/gauges/BaseV2Gauge.sol\n@@ -148,6 +148,9 @@ abstract contract BaseV2Gauge is Ownable, IBaseV2Gauge {\n         /// @dev This is permanent; can't be re-added\n         delete isActive[bribeFlywheel];\n \n+        address flyWheelRewards = address(bribeFlywheel.flywheelRewards());        \n+        multiRewardsDepot.removeAsset(flyWheelRewards);\n+\n         emit RemoveBribeFlywheel(bribeFlywheel);\n     }\n```\n\n**[Trust (judge) increased the severity to High](https://github.com/code-423n4/2023-05-maia-findings/issues/214#issuecomment-1631216394)**\n\n**[0xLightt (Maia) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-05-maia-findings/issues/214#issuecomment-1632701449):**\n > This happens due to not being able to remove strategies from `FlyWheelCore` and the immutability in bribes. In accruing bribes for gauges, there is only one general FlyWheel per token, so removing it from the `RewardsDepot` would actually brick all rewards of the FlyWheel's token.\n> \n> The goal with removing the flywheel from the gauge is to stop forcing the user to call `accrue` and update the `rewardIndex` for that flywheel to save gas or remove an unwanted token. After removing this forced accrual, users can increase their voting balance, accrue and then decrease the voting balance without accruing again. So the balances to accrue rewards can't be trusted and would lead to issues if we tried to reuse the same FlyWheel for the same strategy. One solution would be to add the option to remove the strategy from the flywheel, but could lead to un-accrued rewards being bricked. \n> \n> If there is a need to migrate the bribe system, there needs to be a migration of the gauge system as well. This is intended so that users can opt in into the migration, in turn, protecting them.\n> \n> I believe the best solution would be to leave it up to the user to choose the bribes they want to accrue. By default, all users could have all bribes set as `optOut` for all strategies and `FlywheelBooster` would always return 0 when querying `boostedBalanceOf` and wouldn't take the user's balance into account in `boostedTotalSupply`. If the user decides to `optIn` into a bribe for strategy (we would mimic a minting scenario), they would accrue with 0 balance, having their current balance added to the the strategy's `boostedTotalSupply` and `boostedBalanceOf`, which would return the allocated `gaugeWeight` instead of 0. The opposite is when a user tries to `optOut` after being `optIn`. There should be the option to give up rewards, actually bricking in them, but it would be useful in case there is an issue with the token; for example, reverts when transferring from the `rewardsDepot`. The gauge would force the user to accrue rewards for all `optIn` bribes when changing it's balance.\n> This way, we can completely remove governance around bribes, but would still keep the immutability of the bribes system intact.\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/214#issuecomment-1709935233):**\n > Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/tree/address-214).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/gauges/factories/BaseV2GaugeFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {bHermesBoost} from \"@hermes/tokens/bHermesBoost.sol\";\nimport {BaseV2Gauge} from \"@gauges/BaseV2Gauge.sol\";\n\nimport {BribesFactory} from \"./BribesFactory.sol\";\nimport {BaseV2GaugeManager} from \"./BaseV2GaugeManager.sol\";\n\nimport {IBaseV2GaugeFactory} from \"../interfaces/IBaseV2GaugeFactory.sol\";\n\n/// @title Base V2 Gauge Factory\nabstract contract BaseV2GaugeFactory is Ownable, IBaseV2GaugeFactory {\n    /*///////////////////////////////////////////////////////////////\n                            FACTORY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    BaseV2GaugeManager public immutable override gaugeManager;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    bHermesBoost public immutable override bHermesBoostToken;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    BribesFactory public immutable override bribesFactory;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    BaseV2Gauge[] public override gauges;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    mapping(BaseV2Gauge => uint256) public override gaugeIds;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    mapping(BaseV2Gauge => bool) public override activeGauges;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    mapping(address => BaseV2Gauge) public override strategyGauges;\n\n    /**\n     * @notice Creates a new gauge factory\n     * @param _gaugeManager The gauge manager to use\n     * @param _bHermesBoost The bHermes boost token to use\n     * @param _bribesFactory The bribes factory to use\n     * @param _owner The owner of the factory\n     */\n    constructor(\n        BaseV2GaugeManager _gaugeManager,\n        bHermesBoost _bHermesBoost,\n        BribesFactory _bribesFactory,\n        address _owner\n    ) {\n        _initializeOwner(_owner);\n        bribesFactory = _bribesFactory;\n        bHermesBoostToken = _bHermesBoost;\n        gaugeManager = _gaugeManager;\n    }\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function getGauges() external view returns (BaseV2Gauge[] memory) {\n        return gauges;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         EPOCH LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function newEpoch() external {\n        BaseV2Gauge[] storage _gauges = gauges;\n\n        uint256 length = _gauges.length;\n        for (uint256 i = 0; i < length;) {\n            if (activeGauges[_gauges[i]]) _gauges[i].newEpoch();\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function newEpoch(uint256 start, uint256 end) external {\n        BaseV2Gauge[] storage _gauges = gauges;\n\n        uint256 length = _gauges.length;\n        if (end > length) end = length;\n\n        for (uint256 i = start; i < end;) {\n            if (activeGauges[_gauges[i]]) _gauges[i].newEpoch();\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         GAUGE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Creates a new gauge for the given strategy\n    /// @param strategy The strategy address to create a gauge for\n    /// @param data The information to pass to create a new gauge.\n    function createGauge(address strategy, bytes memory data) external onlyOwner {\n        if (address(strategyGauges[strategy]) != address(0)) revert GaugeAlreadyExists();\n\n        BaseV2Gauge gauge = newGauge(strategy, data);\n        strategyGauges[strategy] = gauge;\n\n        uint256 id = gauges.length;\n        gauges.push(gauge);\n        gaugeIds[gauge] = id;\n        activeGauges[gauge] = true;\n\n        gaugeManager.addGauge(address(gauge));\n\n        afterCreateGauge(strategy, data);\n    }\n\n    function afterCreateGauge(address strategy, bytes memory data) internal virtual;\n\n    function newGauge(address strategy, bytes memory data) internal virtual returns (BaseV2Gauge gauge);\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function removeGauge(BaseV2Gauge gauge) external onlyOwner {\n        if (!activeGauges[gauge] || gauges[gaugeIds[gauge]] != gauge) revert InvalidGauge();\n        delete gauges[gaugeIds[gauge]];\n        delete gaugeIds[gauge];\n        delete activeGauges[gauge];\n        delete strategyGauges[gauge.strategy()];\n        gaugeManager.removeGauge(address(gauge));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           BRIBE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function addBribeToGauge(BaseV2Gauge gauge, address bribeToken) external onlyOwnerOrBribesFactoryOwner {\n        if (!activeGauges[gauge]) revert InvalidGauge();\n        gauge.addBribeFlywheel(bribesFactory.flywheelTokens(bribeToken));\n        bribesFactory.addGaugetoFlywheel(address(gauge), bribeToken);\n    }\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function removeBribeFromGauge(BaseV2Gauge gauge, address bribeToken) external onlyOwnerOrBribesFactoryOwner {\n        if (!activeGauges[gauge]) revert InvalidGauge();\n        gauge.removeBribeFlywheel(bribesFactory.flywheelTokens(bribeToken));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    modifier onlyOwnerOrBribesFactoryOwner() {\n        if (msg.sender != bribesFactory.owner() && msg.sender != owner()) {\n            revert NotOwnerOrBribesFactoryOwner();\n        }\n        _;\n    }\n}"
    },
    {
      "filename": "src/gauges/BaseV2Gauge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {bHermesBoost} from \"@hermes/tokens/bHermesBoost.sol\";\n\nimport {MultiRewardsDepot} from \"@rewards/depots/MultiRewardsDepot.sol\";\nimport {FlywheelBribeRewards} from \"@rewards/rewards/FlywheelBribeRewards.sol\";\nimport {FlywheelCore} from \"@rewards/FlywheelCoreStrategy.sol\";\nimport {FlywheelGaugeRewards} from \"@rewards/rewards/FlywheelGaugeRewards.sol\";\n\nimport {BaseV2GaugeFactory} from \"./factories/BaseV2GaugeFactory.sol\";\n\nimport {IBaseV2Gauge} from \"./interfaces/IBaseV2Gauge.sol\";\n\n/// @title Base V2 Gauge - Base contract for handling liquidity provider incentives and voter's bribes.\nabstract contract BaseV2Gauge is Ownable, IBaseV2Gauge {\n    /*///////////////////////////////////////////////////////////////\n                            GAUGE STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2Gauge\n    address public immutable override rewardToken;\n\n    /// @notice token to boost gauge rewards\n    bHermesBoost public immutable hermesGaugeBoost;\n\n    /// @inheritdoc IBaseV2Gauge\n    FlywheelGaugeRewards public immutable override flywheelGaugeRewards;\n\n    /// @inheritdoc IBaseV2Gauge\n    mapping(FlywheelCore => bool) public override isActive;\n\n    /// @inheritdoc IBaseV2Gauge\n    mapping(FlywheelCore => bool) public override added;\n\n    /// @inheritdoc IBaseV2Gauge\n    address public override strategy;\n\n    /// @inheritdoc IBaseV2Gauge\n    MultiRewardsDepot public override multiRewardsDepot;\n\n    /// @inheritdoc IBaseV2Gauge\n    uint256 public override epoch;\n\n    /// @notice Bribes flywheels array to accrue bribes from.\n    FlywheelCore[] private bribeFlywheels;\n\n    /// @notice 1 week in seconds.\n    uint256 internal constant WEEK = 1 weeks;\n\n    /**\n     * @notice Constructs the BaseV2Gauge contract.\n     * @param _flywheelGaugeRewards The FlywheelGaugeRewards contract.\n     * @param _strategy The strategy address.\n     * @param _owner The owner address.\n     */\n    constructor(FlywheelGaugeRewards _flywheelGaugeRewards, address _strategy, address _owner) {\n        _initializeOwner(_owner);\n        flywheelGaugeRewards = _flywheelGaugeRewards;\n        rewardToken = _flywheelGaugeRewards.rewardToken();\n        hermesGaugeBoost = BaseV2GaugeFactory(msg.sender).bHermesBoostToken();\n        strategy = _strategy;\n\n        epoch = (block.timestamp / WEEK) * WEEK;\n\n        multiRewardsDepot = new MultiRewardsDepot(address(this));\n    }\n\n    /// @inheritdoc IBaseV2Gauge\n    function getBribeFlywheels() external view returns (FlywheelCore[] memory) {\n        return bribeFlywheels;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        GAUGE ACTIONS    \n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2Gauge\n    function newEpoch() external {\n        uint256 _newEpoch = (block.timestamp / WEEK) * WEEK;\n\n        if (epoch < _newEpoch) {\n            epoch = _newEpoch;\n\n            uint256 accruedRewards = flywheelGaugeRewards.getAccruedRewards();\n\n            distribute(accruedRewards);\n\n            emit Distribute(accruedRewards, _newEpoch);\n        }\n    }\n\n    /// @notice Distributes weekly emissions to the strategy.\n    function distribute(uint256 amount) internal virtual;\n\n    /// @inheritdoc IBaseV2Gauge\n    function attachUser(address user) external onlyStrategy {\n        hermesGaugeBoost.attach(user);\n    }\n\n    /// @inheritdoc IBaseV2Gauge\n    function detachUser(address user) external onlyStrategy {\n        hermesGaugeBoost.detach(user);\n    }\n\n    /// @inheritdoc IBaseV2Gauge\n    function accrueBribes(address user) external {\n        FlywheelCore[] storage _bribeFlywheels = bribeFlywheels;\n        uint256 length = _bribeFlywheels.length;\n        for (uint256 i = 0; i < length;) {\n            if (isActive[_bribeFlywheels[i]]) _bribeFlywheels[i].accrue(ERC20(address(this)), user);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            ADMIN ACTIONS    \n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2Gauge\n    function addBribeFlywheel(FlywheelCore bribeFlywheel) external onlyOwner {\n        /// @dev Can't add existing flywheel (active or not)\n        if (added[bribeFlywheel]) revert FlywheelAlreadyAdded();\n\n        address flyWheelRewards = address(bribeFlywheel.flywheelRewards());\n        FlywheelBribeRewards(flyWheelRewards).setRewardsDepot(multiRewardsDepot);\n\n        multiRewardsDepot.addAsset(flyWheelRewards, bribeFlywheel.rewardToken());\n        bribeFlywheels.push(bribeFlywheel);\n        isActive[bribeFlywheel] = true;\n        added[bribeFlywheel] = true;\n\n        emit AddedBribeFlywheel(bribeFlywheel);\n    }\n\n    /// @inheritdoc IBaseV2Gauge\n    function removeBribeFlywheel(FlywheelCore bribeFlywheel) external onlyOwner {\n        /// @dev Can only remove active flywheels\n        if (!isActive[bribeFlywheel]) revert FlywheelNotActive();\n\n        /// @dev This is permanent; can't be re-added\n        delete isActive[bribeFlywheel];\n\n        emit RemoveBribeFlywheel(bribeFlywheel);\n    }\n\n    /// @notice Only the strategy can attach and detach users.\n    modifier onlyStrategy() virtual {\n        if (msg.sender != strategy) revert StrategyError();\n        _;\n    }\n}"
    },
    {
      "filename": "src/gauges/factories/BaseV2GaugeFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {bHermesBoost} from \"@hermes/tokens/bHermesBoost.sol\";\nimport {BaseV2Gauge} from \"@gauges/BaseV2Gauge.sol\";\n\nimport {BribesFactory} from \"./BribesFactory.sol\";\nimport {BaseV2GaugeManager} from \"./BaseV2GaugeManager.sol\";\n\nimport {IBaseV2GaugeFactory} from \"../interfaces/IBaseV2GaugeFactory.sol\";\n\n/// @title Base V2 Gauge Factory\nabstract contract BaseV2GaugeFactory is Ownable, IBaseV2GaugeFactory {\n    /*///////////////////////////////////////////////////////////////\n                            FACTORY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    BaseV2GaugeManager public immutable override gaugeManager;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    bHermesBoost public immutable override bHermesBoostToken;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    BribesFactory public immutable override bribesFactory;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    BaseV2Gauge[] public override gauges;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    mapping(BaseV2Gauge => uint256) public override gaugeIds;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    mapping(BaseV2Gauge => bool) public override activeGauges;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    mapping(address => BaseV2Gauge) public override strategyGauges;\n\n    /**\n     * @notice Creates a new gauge factory\n     * @param _gaugeManager The gauge manager to use\n     * @param _bHermesBoost The bHermes boost token to use\n     * @param _bribesFactory The bribes factory to use\n     * @param _owner The owner of the factory\n     */\n    constructor(\n        BaseV2GaugeManager _gaugeManager,\n        bHermesBoost _bHermesBoost,\n        BribesFactory _bribesFactory,\n        address _owner\n    ) {\n        _initializeOwner(_owner);\n        bribesFactory = _bribesFactory;\n        bHermesBoostToken = _bHermesBoost;\n        gaugeManager = _gaugeManager;\n    }\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function getGauges() external view returns (BaseV2Gauge[] memory) {\n        return gauges;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         EPOCH LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function newEpoch() external {\n        BaseV2Gauge[] storage _gauges = gauges;\n\n        uint256 length = _gauges.length;\n        for (uint256 i = 0; i < length;) {\n            if (activeGauges[_gauges[i]]) _gauges[i].newEpoch();\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function newEpoch(uint256 start, uint256 end) external {\n        BaseV2Gauge[] storage _gauges = gauges;\n\n        uint256 length = _gauges.length;\n        if (end > length) end = length;\n\n        for (uint256 i = start; i < end;) {\n            if (activeGauges[_gauges[i]]) _gauges[i].newEpoch();\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         GAUGE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Creates a new gauge for the given strategy\n    /// @param strategy The strategy address to create a gauge for\n    /// @param data The information to pass to create a new gauge.\n    function createGauge(address strategy, bytes memory data) external onlyOwner {\n        if (address(strategyGauges[strategy]) != address(0)) revert GaugeAlreadyExists();\n\n        BaseV2Gauge gauge = newGauge(strategy, data);\n        strategyGauges[strategy] = gauge;\n\n        uint256 id = gauges.length;\n        gauges.push(gauge);\n        gaugeIds[gauge] = id;\n        activeGauges[gauge] = true;\n\n        gaugeManager.addGauge(address(gauge));\n\n        afterCreateGauge(strategy, data);\n    }\n\n    function afterCreateGauge(address strategy, bytes memory data) internal virtual;\n\n    function newGauge(address strategy, bytes memory data) internal virtual returns (BaseV2Gauge gauge);\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function removeGauge(BaseV2Gauge gauge) external onlyOwner {\n        if (!activeGauges[gauge] || gauges[gaugeIds[gauge]] != gauge) revert InvalidGauge();\n        delete gauges[gaugeIds[gauge]];\n        delete gaugeIds[gauge];\n        delete activeGauges[gauge];\n        delete strategyGauges[gauge.strategy()];\n        gaugeManager.removeGauge(address(gauge));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           BRIBE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function addBribeToGauge(BaseV2Gauge gauge, address bribeToken) external onlyOwnerOrBribesFactoryOwner {\n        if (!activeGauges[gauge]) revert InvalidGauge();\n        gauge.addBribeFlywheel(bribesFactory.flywheelTokens(bribeToken));\n        bribesFactory.addGaugetoFlywheel(address(gauge), bribeToken);\n    }\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function removeBribeFromGauge(BaseV2Gauge gauge, address bribeToken) external onlyOwnerOrBribesFactoryOwner {\n        if (!activeGauges[gauge]) revert InvalidGauge();\n        gauge.removeBribeFlywheel(bribesFactory.flywheelTokens(bribeToken));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    modifier onlyOwnerOrBribesFactoryOwner() {\n        if (msg.sender != bribesFactory.owner() && msg.sender != owner()) {\n            revert NotOwnerOrBribesFactoryOwner();\n        }\n        _;\n    }\n}"
    },
    {
      "filename": "src/gauges/BaseV2Gauge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {bHermesBoost} from \"@hermes/tokens/bHermesBoost.sol\";\n\nimport {MultiRewardsDepot} from \"@rewards/depots/MultiRewardsDepot.sol\";\nimport {FlywheelBribeRewards} from \"@rewards/rewards/FlywheelBribeRewards.sol\";\nimport {FlywheelCore} from \"@rewards/FlywheelCoreStrategy.sol\";\nimport {FlywheelGaugeRewards} from \"@rewards/rewards/FlywheelGaugeRewards.sol\";\n\nimport {BaseV2GaugeFactory} from \"./factories/BaseV2GaugeFactory.sol\";\n\nimport {IBaseV2Gauge} from \"./interfaces/IBaseV2Gauge.sol\";\n\n/// @title Base V2 Gauge - Base contract for handling liquidity provider incentives and voter's bribes.\nabstract contract BaseV2Gauge is Ownable, IBaseV2Gauge {\n    /*///////////////////////////////////////////////////////////////\n                            GAUGE STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2Gauge\n    address public immutable override rewardToken;\n\n    /// @notice token to boost gauge rewards\n    bHermesBoost public immutable hermesGaugeBoost;\n\n    /// @inheritdoc IBaseV2Gauge\n    FlywheelGaugeRewards public immutable override flywheelGaugeRewards;\n\n    /// @inheritdoc IBaseV2Gauge\n    mapping(FlywheelCore => bool) public override isActive;\n\n    /// @inheritdoc IBaseV2Gauge\n    mapping(FlywheelCore => bool) public override added;\n\n    /// @inheritdoc IBaseV2Gauge\n    address public override strategy;\n\n    /// @inheritdoc IBaseV2Gauge\n    MultiRewardsDepot public override multiRewardsDepot;\n\n    /// @inheritdoc IBaseV2Gauge\n    uint256 public override epoch;\n\n    /// @notice Bribes flywheels array to accrue bribes from.\n    FlywheelCore[] private bribeFlywheels;\n\n    /// @notice 1 week in seconds.\n    uint256 internal constant WEEK = 1 weeks;\n\n    /**\n     * @notice Constructs the BaseV2Gauge contract.\n     * @param _flywheelGaugeRewards The FlywheelGaugeRewards contract.\n     * @param _strategy The strategy address.\n     * @param _owner The owner address.\n     */\n    constructor(FlywheelGaugeRewards _flywheelGaugeRewards, address _strategy, address _owner) {\n        _initializeOwner(_owner);\n        flywheelGaugeRewards = _flywheelGaugeRewards;\n        rewardToken = _flywheelGaugeRewards.rewardToken();\n        hermesGaugeBoost = BaseV2GaugeFactory(msg.sender).bHermesBoostToken();\n        strategy = _strategy;\n\n        epoch = (block.timestamp / WEEK) * WEEK;\n\n        multiRewardsDepot = new MultiRewardsDepot(address(this));\n    }\n\n    /// @inheritdoc IBaseV2Gauge\n    function getBribeFlywheels() external view returns (FlywheelCore[] memory) {\n        return bribeFlywheels;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        GAUGE ACTIONS    \n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2Gauge\n    function newEpoch() external {\n        uint256 _newEpoch = (block.timestamp / WEEK) * WEEK;\n\n        if (epoch < _newEpoch) {\n            epoch = _newEpoch;\n\n            uint256 accruedRewards = flywheelGaugeRewards.getAccruedRewards();\n\n            distribute(accruedRewards);\n\n            emit Distribute(accruedRewards, _newEpoch);\n        }\n    }\n\n    /// @notice Distributes weekly emissions to the strategy.\n    function distribute(uint256 amount) internal virtual;\n\n    /// @inheritdoc IBaseV2Gauge\n    function attachUser(address user) external onlyStrategy {\n        hermesGaugeBoost.attach(user);\n    }\n\n    /// @inheritdoc IBaseV2Gauge\n    function detachUser(address user) external onlyStrategy {\n        hermesGaugeBoost.detach(user);\n    }\n\n    /// @inheritdoc IBaseV2Gauge\n    function accrueBribes(address user) external {\n        FlywheelCore[] storage _bribeFlywheels = bribeFlywheels;\n        uint256 length = _bribeFlywheels.length;\n        for (uint256 i = 0; i < length;) {\n            if (isActive[_bribeFlywheels[i]]) _bribeFlywheels[i].accrue(ERC20(address(this)), user);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            ADMIN ACTIONS    \n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2Gauge\n    function addBribeFlywheel(FlywheelCore bribeFlywheel) external onlyOwner {\n        /// @dev Can't add existing flywheel (active or not)\n        if (added[bribeFlywheel]) revert FlywheelAlreadyAdded();\n\n        address flyWheelRewards = address(bribeFlywheel.flywheelRewards());\n        FlywheelBribeRewards(flyWheelRewards).setRewardsDepot(multiRewardsDepot);\n\n        multiRewardsDepot.addAsset(flyWheelRewards, bribeFlywheel.rewardToken());\n        bribeFlywheels.push(bribeFlywheel);\n        isActive[bribeFlywheel] = true;\n        added[bribeFlywheel] = true;\n\n        emit AddedBribeFlywheel(bribeFlywheel);\n    }\n\n    /// @inheritdoc IBaseV2Gauge\n    function removeBribeFlywheel(FlywheelCore bribeFlywheel) external onlyOwner {\n        /// @dev Can only remove active flywheels\n        if (!isActive[bribeFlywheel]) revert FlywheelNotActive();\n\n        /// @dev This is permanent; can't be re-added\n        delete isActive[bribeFlywheel];\n\n        emit RemoveBribeFlywheel(bribeFlywheel);\n    }\n\n    /// @notice Only the strategy can attach and detach users.\n    modifier onlyStrategy() virtual {\n        if (msg.sender != strategy) revert StrategyError();\n        _;\n    }\n}"
    },
    {
      "filename": "src/gauges/BaseV2Gauge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {bHermesBoost} from \"@hermes/tokens/bHermesBoost.sol\";\n\nimport {MultiRewardsDepot} from \"@rewards/depots/MultiRewardsDepot.sol\";\nimport {FlywheelBribeRewards} from \"@rewards/rewards/FlywheelBribeRewards.sol\";\nimport {FlywheelCore} from \"@rewards/FlywheelCoreStrategy.sol\";\nimport {FlywheelGaugeRewards} from \"@rewards/rewards/FlywheelGaugeRewards.sol\";\n\nimport {BaseV2GaugeFactory} from \"./factories/BaseV2GaugeFactory.sol\";\n\nimport {IBaseV2Gauge} from \"./interfaces/IBaseV2Gauge.sol\";\n\n/// @title Base V2 Gauge - Base contract for handling liquidity provider incentives and voter's bribes.\nabstract contract BaseV2Gauge is Ownable, IBaseV2Gauge {\n    /*///////////////////////////////////////////////////////////////\n                            GAUGE STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2Gauge\n    address public immutable override rewardToken;\n\n    /// @notice token to boost gauge rewards\n    bHermesBoost public immutable hermesGaugeBoost;\n\n    /// @inheritdoc IBaseV2Gauge\n    FlywheelGaugeRewards public immutable override flywheelGaugeRewards;\n\n    /// @inheritdoc IBaseV2Gauge\n    mapping(FlywheelCore => bool) public override isActive;\n\n    /// @inheritdoc IBaseV2Gauge\n    mapping(FlywheelCore => bool) public override added;\n\n    /// @inheritdoc IBaseV2Gauge\n    address public override strategy;\n\n    /// @inheritdoc IBaseV2Gauge\n    MultiRewardsDepot public override multiRewardsDepot;\n\n    /// @inheritdoc IBaseV2Gauge\n    uint256 public override epoch;\n\n    /// @notice Bribes flywheels array to accrue bribes from.\n    FlywheelCore[] private bribeFlywheels;\n\n    /// @notice 1 week in seconds.\n    uint256 internal constant WEEK = 1 weeks;\n\n    /**\n     * @notice Constructs the BaseV2Gauge contract.\n     * @param _flywheelGaugeRewards The FlywheelGaugeRewards contract.\n     * @param _strategy The strategy address.\n     * @param _owner The owner address.\n     */\n    constructor(FlywheelGaugeRewards _flywheelGaugeRewards, address _strategy, address _owner) {\n        _initializeOwner(_owner);\n        flywheelGaugeRewards = _flywheelGaugeRewards;\n        rewardToken = _flywheelGaugeRewards.rewardToken();\n        hermesGaugeBoost = BaseV2GaugeFactory(msg.sender).bHermesBoostToken();\n        strategy = _strategy;\n\n        epoch = (block.timestamp / WEEK) * WEEK;\n\n        multiRewardsDepot = new MultiRewardsDepot(address(this));\n    }\n\n    /// @inheritdoc IBaseV2Gauge\n    function getBribeFlywheels() external view returns (FlywheelCore[] memory) {\n        return bribeFlywheels;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        GAUGE ACTIONS    \n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2Gauge\n    function newEpoch() external {\n        uint256 _newEpoch = (block.timestamp / WEEK) * WEEK;\n\n        if (epoch < _newEpoch) {\n            epoch = _newEpoch;\n\n            uint256 accruedRewards = flywheelGaugeRewards.getAccruedRewards();\n\n            distribute(accruedRewards);\n\n            emit Distribute(accruedRewards, _newEpoch);\n        }\n    }\n\n    /// @notice Distributes weekly emissions to the strategy.\n    function distribute(uint256 amount) internal virtual;\n\n    /// @inheritdoc IBaseV2Gauge\n    function attachUser(address user) external onlyStrategy {\n        hermesGaugeBoost.attach(user);\n    }\n\n    /// @inheritdoc IBaseV2Gauge\n    function detachUser(address user) external onlyStrategy {\n        hermesGaugeBoost.detach(user);\n    }\n\n    /// @inheritdoc IBaseV2Gauge\n    function accrueBribes(address user) external {\n        FlywheelCore[] storage _bribeFlywheels = bribeFlywheels;\n        uint256 length = _bribeFlywheels.length;\n        for (uint256 i = 0; i < length;) {\n            if (isActive[_bribeFlywheels[i]]) _bribeFlywheels[i].accrue(ERC20(address(this)), user);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            ADMIN ACTIONS    \n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2Gauge\n    function addBribeFlywheel(FlywheelCore bribeFlywheel) external onlyOwner {\n        /// @dev Can't add existing flywheel (active or not)\n        if (added[bribeFlywheel]) revert FlywheelAlreadyAdded();\n\n        address flyWheelRewards = address(bribeFlywheel.flywheelRewards());\n        FlywheelBribeRewards(flyWheelRewards).setRewardsDepot(multiRewardsDepot);\n\n        multiRewardsDepot.addAsset(flyWheelRewards, bribeFlywheel.rewardToken());\n        bribeFlywheels.push(bribeFlywheel);\n        isActive[bribeFlywheel] = true;\n        added[bribeFlywheel] = true;\n\n        emit AddedBribeFlywheel(bribeFlywheel);\n    }\n\n    /// @inheritdoc IBaseV2Gauge\n    function removeBribeFlywheel(FlywheelCore bribeFlywheel) external onlyOwner {\n        /// @dev Can only remove active flywheels\n        if (!isActive[bribeFlywheel]) revert FlywheelNotActive();\n\n        /// @dev This is permanent; can't be re-added\n        delete isActive[bribeFlywheel];\n\n        emit RemoveBribeFlywheel(bribeFlywheel);\n    }\n\n    /// @notice Only the strategy can attach and detach users.\n    modifier onlyStrategy() virtual {\n        if (msg.sender != strategy) revert StrategyError();\n        _;\n    }\n}"
    }
  ]
}