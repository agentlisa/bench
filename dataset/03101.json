{
  "Title": "Lack of documentation",
  "Content": "Throughout the codebase, we found several instances where documentation was lacking. This hinders reviewers’ understanding of the code’s intention, which is fundamental to correctly assess not only security but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned, and the events emitted. For instance:\n\n\n* The functions and variables in the [`OgvStaking` contract](https://github.com/OriginProtocol/ousd-governance/blob/2b9761606d4ac4062b69367ebbad88220cea45ce/contracts/OgvStaking.sol) lack documentation.\n* The functions and some variables in the [`RewardsSource` contract](https://github.com/OriginProtocol/ousd-governance/blob/2b9761606d4ac4062b69367ebbad88220cea45ce/contracts/RewardsSource.sol) lack documentation.\n* The [`setInflation` function](https://github.com/OriginProtocol/ousd-governance/blob/2b9761606d4ac4062b69367ebbad88220cea45ce/contracts/RewardsSource.sol#L95) should explicitly state:\n\t+ The start time of the first slope may lie in the future, which allows an implicit configuration of a zero slope before the first start time.\n\t+ The end time of the end slope will always be set to infinity (`type(uint64).max`), which implies that unless `Slope.ratePerDay` is set to zero in the last slope a potentially unbounded number of OGV tokens could be minted.\n* In the [`OgvStaking` contract](https://github.com/OriginProtocol/ousd-governance/blob/2b9761606d4ac4062b69367ebbad88220cea45ce/contracts/OgvStaking.sol), when a user stakes `OGV` tokens before the `epoch` time is reached, the tokens are locked for the specified [duration after epoch](https://github.com/OriginProtocol/ousd-governance/blob/2b9761606d4ac4062b69367ebbad88220cea45ce/contracts/OgvStaking.sol#L156-L157). Hence, the [tokens are locked](https://github.com/OriginProtocol/ousd-governance/blob/2b9761606d4ac4062b69367ebbad88220cea45ce/contracts/OgvStaking.sol#L98) for longer than expected. Users might be unaware of this behavior, so consider documenting it explicitly.\n\n\nConsider thoroughly documenting the aforementioned code using the [NatSpec format](https://docs.soliditylang.org/en/v0.8.13/natspec-format.html) to increase the understandability of the codebase.\n\n\n**Update**: *Fixed in pull request [#102](https://github.com/OriginProtocol/ousd-governance/pull/102).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/RewardsSource.sol",
      "content": "pragma solidity 0.8.10;\nimport {ERC20Votes} from \"OpenZeppelin/openzeppelin-contracts@4.6.0/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport {ERC20Permit} from \"OpenZeppelin/openzeppelin-contracts@4.6.0/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport {ERC20} from \"OpenZeppelin/openzeppelin-contracts@4.6.0/contracts/token/ERC20/ERC20.sol\";\nimport {PRBMathUD60x18} from \"paulrberg/prb-math@2.5.0/contracts/PRBMathUD60x18.sol\";\nimport {Governable} from \"./Governable.sol\";\n\ninterface Mintable {\n    function mint(address to, uint256 amount) external;\n}\n\ncontract RewardsSource is Governable {\n    ERC20 public immutable ogv;\n    address public rewardsTarget; // Contract that receives rewards\n    uint256 public lastRewardTime; // Start of the time to calculate rewards over\n    uint256 private currentSlopeIndex = 0; // Allows us to start with the correct slope\n\n    struct Slope {\n        uint64 start; // uint64 = billions and billions of years\n        uint64 end; // Internal use only. By duplicating the start of the next slope, we can save a slot read\n        uint128 ratePerDay;\n    }\n    Slope[] public inflationSlopes;\n\n    uint256 constant MAX_KNEES = 48;\n    uint256 constant MAX_INFLATION_PER_DAY = (5 * 1e6 * 1e18);\n\n    constructor(address ogv_) {\n        require(ogv_ != address(0), \"Rewards: OGV must be set\");\n        ogv = ERC20(ogv_);\n        lastRewardTime = block.timestamp; // No possible rewards from before contract deployed\n    }\n\n    function collectRewards() external returns (uint256) {\n        require(msg.sender == rewardsTarget, \"Rewards: Not rewardsTarget\");\n        if (block.timestamp <= lastRewardTime) {\n            return 0;\n        }\n        (uint256 rewards, uint256 _nextSlopeIndex) = _calcRewards();\n        if (_nextSlopeIndex != 0) {\n            currentSlopeIndex = _nextSlopeIndex;\n        }\n        lastRewardTime = block.timestamp;\n        Mintable(address(ogv)).mint(rewardsTarget, rewards);\n        return rewards;\n    }\n\n    function previewRewards() external view returns (uint256) {\n        (uint256 rewards, ) = _calcRewards();\n        return rewards;\n    }\n\n    function _calcRewards() internal view returns (uint256, uint256) {\n        uint256 last = lastRewardTime;\n        if (last >= block.timestamp) {\n            return (0, currentSlopeIndex);\n        }\n        if (inflationSlopes.length == 0) {\n            return (0, 0); // Save a slot read by returning a zero constant\n        } \n        uint256 total = 0;\n        uint256 nextSlopeIndex = 0; // Zero means no change\n        uint256 _currentSlopeIndex = currentSlopeIndex;\n        uint256 i;\n        for (i = _currentSlopeIndex; i < inflationSlopes.length; i++) {\n            Slope memory slope = inflationSlopes[i];\n            uint256 slopeStart = slope.start;\n            uint256 slopeEnd = slope.end;\n            uint256 rangeStart = last;\n            uint256 rangeEnd = block.timestamp;\n            if (rangeStart > slopeEnd) {\n                continue; // no duration possible in this slope\n            } \n            if (rangeEnd < slopeStart) {\n                continue; // no duration possible in this slope\n            } \n            if (rangeStart < slopeStart) {\n                rangeStart = slopeStart; // trim to slope edge\n            } \n            if (rangeEnd > slopeEnd) {\n                rangeEnd = slopeEnd; // trim to slope edge\n            } \n            uint256 duration = rangeEnd - rangeStart;\n            total += (duration * slope.ratePerDay) / 1 days;\n            if (i > _currentSlopeIndex && duration > 0) {\n                nextSlopeIndex = i; // We have moved into a new slope\n            }\n            if (slopeEnd < rangeEnd) {\n                break; // No future slope could match\n            } \n        }\n        return (total, nextSlopeIndex);\n    }\n\n    function setInflation(Slope[] memory slopes) external onlyGovernor {\n        // slope ends intentionally are overwritten\n        require(slopes.length <= MAX_KNEES, \"Rewards: Too many slopes\");\n        delete inflationSlopes; // Delete all before rebuilding\n        currentSlopeIndex = 0; // Reset\n        uint256 minSlopeStart = 0;\n        if (slopes.length == 0) {\n            return;\n        }\n        slopes[slopes.length - 1].end = type(uint64).max;\n        for (uint256 i = 0; i < slopes.length; i++) {\n            require(\n                slopes[i].ratePerDay <= MAX_INFLATION_PER_DAY,\n                \"Rewards: RatePerDay too high\"\n            );\n            require(\n                slopes[i].start > minSlopeStart,\n                \"Rewards: Start times must increase\"\n            );\n            if (i < slopes.length - 1) {\n                slopes[i].end = slopes[i + 1].start;\n            }\n            inflationSlopes.push(slopes[i]);\n            minSlopeStart = slopes[i].start;\n        }\n    }\n\n    function setRewardsTarget(address rewardsTarget_) external onlyGovernor {\n        rewardsTarget = rewardsTarget_; // Okay to be zero, just disables collecting rewards\n    }\n}"
    }
  ]
}