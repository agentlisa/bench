{
  "Title": "Miscellaneous informational findings regarding Curve-related contracts/libraries",
  "Content": "It is understood that a significant portion of logic related to Curve contracts has been copied from existing implementations, written in Vyper, and ported to Solidity for the purpose of use both within Beanstalk and as an on-chain reference for wider Beanstalk ecosystem contracts. The most pressing issue identified here pertains to the use of unchecked arithmetic. Unlike the Solidity compiler version 0.7.6 utilized by the Beanstalk contracts, the Vyper compiler, utilized by Curve contracts, handles integer overflow checks by default and will revert if one is detected. In other contracts where this functionality is desired, Beanstalk uses the OpenZeppelin SafeMath library; however, this is not the case at all in [`LibCurve`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Curve/LibCurve.sol#L13), [`CurvePrice`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/ecosystem/price/CurvePrice.sol#L17) and [`BeanstalkPrice`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/ecosystem/price/BeanstalkPrice.sol#L7). While we have been unable to identify any specific vulnerabilities (due to the time-constrained nature of this engagement) that may arise as a result, it is recommended to implement these contracts as closely to the existing Vyper implementations as possible, using SafeMath functions rather than unchecked arithmetic operators. `LibBeanMetaCurve` does import the SafeMath library but still contains some [instances](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Curve/LibBeanMetaCurve.sol#L40) of [unchecked arithmetic](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Curve/LibBeanMetaCurve.sol#L58) – if this is intentional, then it should at least be commented as explaining why it is safe to do so; otherwise, the recommendation applies here also.\n\nThe following additional informational findings were identified:\n* `CurvePrice::getCurveDeltaB` and `LibBeanMetaCurve::getDeltaBWithD` both contain [unsafe](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/ecosystem/price/CurvePrice.sol#L56) [casts](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Curve/LibBeanMetaCurve.sol#L59) from `uint256` to `int256`. While it is unlikely that these will ever cause an issue since the number of beans at peg and the corresponding equilibrium pool BEAN balance are both highly unlikely to exceed the max `int256` value, it is recommended that this be resolved along with the recommendation regarding the use of unchecked arithmetic.\n* [Multiplication by one](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Curve/LibCurve.sol#L43) is unnecessary and redundant when calculating the price based on normalized reserves and rates, given that it adds no additional precision and that of the BEAN rate is already sufficient at 30 decimals.\n* The [implementation referenced](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Curve/LibCurve.sol#L88) in `LibCurve::getD` uses `255` as the upper bound for the number of Newton-Raphson approximation iterations rather than `256`, as is the case [here](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Curve/LibCurve.sol#L98). In reality, the approximation should converge long before nearing either of these values, so any additional gas usage is unlikely.\n* In the event `LibCurve::getD` fails to converge, this function [will revert](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Curve/LibCurve.sol#L110); therefore, the unreachable line of code which [returns zero](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Curve/LibCurve.sol#L111) does not appear to be necessary.\n* The NatSpec of `LibCurve::getXP` contains a small [mistake](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Curve/LibCurve.sol#L151):\n```diff\n    /**\n     * @dev Return the `xp` array for two tokens. Adjusts `balances[0]` by `padding`\n     * and `balances[1]` by `rate / PRECISION`.\n     *\n-    * This is provided as a gas optimization when `rates[0] * PRECISION` has been\n+    * This is provided as a gas optimization when `rates[0] / PRECISION` has been\n     * pre-computed.\n     */\n```\n* The `xp1` variable in [`LibCurveConvert::beansToPeg`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Convert/LibCurveConvert.sol#L24-L35) should be renamed `xp0` to be semantically correct.\n* `CurveFacet::is3Pool` should be formatted with the same indentation as other functions – consider running a formatting tool such as `forge fmt`.\n* The existing [`token`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/CurveFacet.sol#L244) declaration within `CurveFacet::removeLiquidityImbalance` can be reused when entering the conditional 3Pool/Tri-Crypto block rather than also declaring [`lpToken`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/CurveFacet.sol#L244) which will be assigned the same value.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/libraries/Curve/LibCurve.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/**\n * @title LibCurve\n * @author Publius\n * @notice Low-level Curve swap math for a 2-token StableSwap pool.\n */\nlibrary LibCurve {\n    using SafeMath for uint256;\n\n    uint256 private constant A_PRECISION = 100;\n    uint256 private constant N_COINS = 2;\n    uint256 private constant PRECISION = 1e18;\n    uint256 private constant i = 0;\n    uint256 private constant j = 1;\n\n    /**\n     * @dev Find the change in token `j` given a change in token `i`.\n     */\n    function getPrice(\n        uint256[2] memory xp,\n        uint256 a,\n        uint256 D,\n        uint256 padding\n    ) internal pure returns (uint256) {\n        uint256 x = xp[i] + padding;\n        uint256 y = getY(x, xp, a, D);\n        uint256 dy = xp[j] - y - 1;\n        return dy;\n    }\n\n    function getPrice(\n        uint256[2] memory xp,\n        uint256[2] memory rates,\n        uint256 a,\n        uint256 D\n    ) internal pure returns (uint256) {\n        uint256 x = xp[i] + ((1 * rates[i]) / PRECISION);\n        uint256 y = getY(x, xp, a, D);\n        uint256 dy = xp[j] - y - 1;\n        return dy / 1e6;\n    }\n\n    function getY(\n        uint256 x,\n        uint256[2] memory xp,\n        uint256 a,\n        uint256 D\n    ) internal pure returns (uint256 y) {\n        // Solution is taken from pool contract: 0xc9C32cd16Bf7eFB85Ff14e0c8603cc90F6F2eE49\n        uint256 S_ = 0;\n        uint256 _x = 0;\n        uint256 y_prev = 0;\n        uint256 c = D;\n        uint256 Ann = a * N_COINS;\n\n        for (uint256 _i; _i < N_COINS; ++_i) {\n            if (_i == i) _x = x;\n            else if (_i != j) _x = xp[_i];\n            else continue;\n            S_ += _x;\n            c = (c * D) / (_x * N_COINS);\n        }\n\n        c = (c * D * A_PRECISION) / (Ann * N_COINS);\n        uint256 b = S_ + (D * A_PRECISION) / Ann; // - D\n        y = D;\n\n        for (uint256 _i; _i < 255; ++_i) {\n            y_prev = y;\n            y = (y * y + c) / (2 * y + b - D);\n            if (y > y_prev && y - y_prev <= 1) return y;\n            else if (y_prev - y <= 1) return y;\n        }\n        require(false, \"Price: Convergence false\");\n    }\n\n    function getD(uint256[2] memory xp, uint256 a)\n        internal\n        pure\n        returns (uint256 D)\n    {\n        // Solution is taken from pool contract: 0xc9C32cd16Bf7eFB85Ff14e0c8603cc90F6F2eE49\n        uint256 S;\n        uint256 Dprev;\n        for (uint256 _i; _i < xp.length; ++_i) {\n            S += xp[_i];\n        }\n        if (S == 0) return 0;\n\n        D = S;\n        uint256 Ann = a * N_COINS;\n        for (uint256 _i; _i < 256; ++_i) {\n            uint256 D_P = D;\n            for (uint256 _j; _j < xp.length; ++_j) {\n                D_P = (D_P * D) / (xp[_j] * N_COINS);\n            }\n            Dprev = D;\n            D =\n                (((Ann * S) / A_PRECISION + D_P * N_COINS) * D) /\n                (((Ann - A_PRECISION) * D) / A_PRECISION + (N_COINS + 1) * D_P);\n            if (D > Dprev && D - Dprev <= 1) return D;\n            else if (Dprev - D <= 1) return D;\n        }\n        require(false, \"Price: Convergence false\");\n        return 0;\n    }\n\n    function getYD(\n        uint256 a,\n        uint256 i_,\n        uint256[2] memory xp,\n        uint256 D\n    ) internal pure returns (uint256 y) {\n        // Solution is taken from pool contract: 0xc9C32cd16Bf7eFB85Ff14e0c8603cc90F6F2eE49\n        uint256 S_ = 0;\n        uint256 _x = 0;\n        uint256 y_prev = 0;\n        uint256 c = D;\n        uint256 Ann = a * N_COINS;\n\n        for (uint256 _i; _i < N_COINS; ++_i) {\n            if (_i != i_) _x = xp[_i];\n            else continue;\n            S_ += _x;\n            c = (c * D) / (_x * N_COINS);\n        }\n\n        c = (c * D * A_PRECISION) / (Ann * N_COINS);\n        uint256 b = S_ + (D * A_PRECISION) / Ann; // - D\n        y = D;\n\n        for (uint256 _i; _i < 255; ++_i) {\n            y_prev = y;\n            y = (y * y + c) / (2 * y + b - D);\n            if (y > y_prev && y - y_prev <= 1) return y;\n            else if (y_prev - y <= 1) return y;\n        }\n        require(false, \"Price: Convergence false\");\n    }\n\n    /**\n     * @dev Return the `xp` array for two tokens. Adjusts `balances[0]` by `padding`\n     * and `balances[1]` by `rate / PRECISION`.\n     * \n     * This is provided as a gas optimization when `rates[0] * PRECISION` has been\n     * pre-computed.\n     */\n    function getXP(\n        uint256[2] memory balances,\n        uint256 padding,\n        uint256 rate\n    ) internal pure returns (uint256[2] memory xp) {\n        xp[0] = balances[0].mul(padding);\n        xp[1] = balances[1].mul(rate).div(PRECISION);\n    }\n\n    /**\n     * @dev Return the `xp` array for two tokens. Adjusts `balances[0]` by `rates[0]`\n     * and `balances[1]` by `rates[1] / PRECISION`.\n     */\n    function getXP(\n        uint256[2] memory balances,\n        uint256[2] memory rates\n    ) internal pure returns (uint256[2] memory xp) {\n        xp[0] = balances[0].mul(rates[0]).div(PRECISION);\n        xp[1] = balances[1].mul(rates[1]).div(PRECISION);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/ecosystem/price/CurvePrice.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {P} from \"./P.sol\";\nimport \"contracts/libraries/Curve/LibMetaCurve.sol\";\nimport \"contracts/libraries/Curve/LibCurve.sol\";\n\ninterface IERC20D {\n    function decimals() external view returns (uint8);\n}\n\ninterface IBDV {\n    function bdv(address token, uint256 amount) external view returns (uint256);\n}\n\ncontract CurvePrice {\n\n    using SafeMath for uint256;\n\n    //-------------------------------------------------------------------------------------------------------------------\n    // Mainnet\n    address private constant POOL = 0xc9C32cd16Bf7eFB85Ff14e0c8603cc90F6F2eE49;\n    address private constant CRV3_POOL = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;\n    address private constant BEANSTALK = 0xC1E088fC1323b20BCBee9bd1B9fC9546db5624C5;\n    //-------------------------------------------------------------------------------------------------------------------\n\n    uint256 private constant A_PRECISION = 100; \n    uint256 private constant N_COINS  = 2;\n    uint256 private constant RATE_MULTIPLIER = 10 ** 30;\n    uint256 private constant PRECISION = 1e18;\n    uint256 private constant i = 0;\n    uint256 private constant j = 1;\n    address[2] private tokens = [0xBEA0000029AD1c77D3d5D23Ba2D8893dB9d1Efab, 0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490];\n\n    function getCurve() public view returns (P.Pool memory pool) {\n        pool.pool = POOL;\n        pool.tokens = tokens;\n        uint256[2] memory balances = ICurvePool(POOL).get_balances();\n        pool.balances = balances;\n        uint256[2] memory rates = getRates();\n        uint256[2] memory xp = LibCurve.getXP(balances, rates);\n        uint256 a = ICurvePool(POOL).A_precise();\n        uint256 D = getD(xp, a);\n\n        pool.price = LibCurve.getPrice(xp, rates, a, D);\n        rates[0] = rates[0].mul(pool.price).div(1e6);\n        pool.liquidity = getCurveUSDValue(balances, rates);\n        pool.deltaB = getCurveDeltaB(balances[0], D);\n        pool.lpUsd = pool.liquidity * 1e18 / ICurvePool(POOL).totalSupply();\n        pool.lpBdv = IBDV(BEANSTALK).bdv(POOL, 1e18);\n    }\n\n    function getCurveDeltaB(uint256 balance, uint256 D) private pure returns (int deltaB) {\n        uint256 pegBeans = D / 2 / 1e12;\n        deltaB = int256(pegBeans) - int256(balance);\n    }\n\n    function getCurveUSDValue(uint256[2] memory balances, uint256[2] memory rates) private pure returns (uint) {\n        uint256[2] memory value = LibCurve.getXP(balances, rates);\n        return (value[0] + value[1]) / 1e12;\n    }\n\n    function getD(uint256[2] memory xp, uint256 a) private pure returns (uint D) {\n        \n        /*  \n        * D invariant calculation in non-overflowing integer operations\n        * iteratively\n        *\n        * A * sum(x_i) * n**n + D = A * D * n**n + D**(n+1) / (n**n * prod(x_i))\n        *\n        * Converging solution:\n        * D[j+1] = (A * n**n * sum(x_i) - D[j]**(n+1) / (n**n prod(x_i))) / (A * n**n - 1)\n        */\n        uint256 S;\n        uint256 Dprev;\n        for (uint _i = 0; _i < xp.length; _i++) {\n            S += xp[_i];\n        }\n        if (S == 0) return 0;\n\n        D = S;\n        uint256 Ann = a * N_COINS;\n        for (uint _i = 0; _i < 256; _i++) {\n            uint256 D_P = D;\n            for (uint _j = 0; _j < xp.length; _j++) {\n                D_P = D_P * D / (xp[_j] * N_COINS);  // If division by 0, this will be borked: only withdrawal will work. And that is good\n            }\n            Dprev = D;\n            D = (Ann * S / A_PRECISION + D_P * N_COINS) * D / ((Ann - A_PRECISION) * D / A_PRECISION + (N_COINS + 1) * D_P);\n            // Equality with the precision of 1\n            if (D > Dprev && D - Dprev <= 1) return D;\n            else if (Dprev - D <= 1) return D;\n        }\n        // convergence typically occurs in 4 rounds or less, this should be unreachable!\n        // if it does happen the pool is borked and LPs can withdraw via `remove_liquidity`\n        require(false, \"Price: Convergence false\");\n    }\n\n    function getRates() private view returns (uint256[2] memory rates) {\n        uint8 decimals = IERC20D(tokens[0]).decimals();\n        return [10**(36-decimals), I3Curve(CRV3_POOL).get_virtual_price()];\n    }\n}"
    },
    {
      "filename": "protocol/contracts/libraries/Curve/LibCurve.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/**\n * @title LibCurve\n * @author Publius\n * @notice Low-level Curve swap math for a 2-token StableSwap pool.\n */\nlibrary LibCurve {\n    using SafeMath for uint256;\n\n    uint256 private constant A_PRECISION = 100;\n    uint256 private constant N_COINS = 2;\n    uint256 private constant PRECISION = 1e18;\n    uint256 private constant i = 0;\n    uint256 private constant j = 1;\n\n    /**\n     * @dev Find the change in token `j` given a change in token `i`.\n     */\n    function getPrice(\n        uint256[2] memory xp,\n        uint256 a,\n        uint256 D,\n        uint256 padding\n    ) internal pure returns (uint256) {\n        uint256 x = xp[i] + padding;\n        uint256 y = getY(x, xp, a, D);\n        uint256 dy = xp[j] - y - 1;\n        return dy;\n    }\n\n    function getPrice(\n        uint256[2] memory xp,\n        uint256[2] memory rates,\n        uint256 a,\n        uint256 D\n    ) internal pure returns (uint256) {\n        uint256 x = xp[i] + ((1 * rates[i]) / PRECISION);\n        uint256 y = getY(x, xp, a, D);\n        uint256 dy = xp[j] - y - 1;\n        return dy / 1e6;\n    }\n\n    function getY(\n        uint256 x,\n        uint256[2] memory xp,\n        uint256 a,\n        uint256 D\n    ) internal pure returns (uint256 y) {\n        // Solution is taken from pool contract: 0xc9C32cd16Bf7eFB85Ff14e0c8603cc90F6F2eE49\n        uint256 S_ = 0;\n        uint256 _x = 0;\n        uint256 y_prev = 0;\n        uint256 c = D;\n        uint256 Ann = a * N_COINS;\n\n        for (uint256 _i; _i < N_COINS; ++_i) {\n            if (_i == i) _x = x;\n            else if (_i != j) _x = xp[_i];\n            else continue;\n            S_ += _x;\n            c = (c * D) / (_x * N_COINS);\n        }\n\n        c = (c * D * A_PRECISION) / (Ann * N_COINS);\n        uint256 b = S_ + (D * A_PRECISION) / Ann; // - D\n        y = D;\n\n        for (uint256 _i; _i < 255; ++_i) {\n            y_prev = y;\n            y = (y * y + c) / (2 * y + b - D);\n            if (y > y_prev && y - y_prev <= 1) return y;\n            else if (y_prev - y <= 1) return y;\n        }\n        require(false, \"Price: Convergence false\");\n    }\n\n    function getD(uint256[2] memory xp, uint256 a)\n        internal\n        pure\n        returns (uint256 D)\n    {\n        // Solution is taken from pool contract: 0xc9C32cd16Bf7eFB85Ff14e0c8603cc90F6F2eE49\n        uint256 S;\n        uint256 Dprev;\n        for (uint256 _i; _i < xp.length; ++_i) {\n            S += xp[_i];\n        }\n        if (S == 0) return 0;\n\n        D = S;\n        uint256 Ann = a * N_COINS;\n        for (uint256 _i; _i < 256; ++_i) {\n            uint256 D_P = D;\n            for (uint256 _j; _j < xp.length; ++_j) {\n                D_P = (D_P * D) / (xp[_j] * N_COINS);\n            }\n            Dprev = D;\n            D =\n                (((Ann * S) / A_PRECISION + D_P * N_COINS) * D) /\n                (((Ann - A_PRECISION) * D) / A_PRECISION + (N_COINS + 1) * D_P);\n            if (D > Dprev && D - Dprev <= 1) return D;\n            else if (Dprev - D <= 1) return D;\n        }\n        require(false, \"Price: Convergence false\");\n        return 0;\n    }\n\n    function getYD(\n        uint256 a,\n        uint256 i_,\n        uint256[2] memory xp,\n        uint256 D\n    ) internal pure returns (uint256 y) {\n        // Solution is taken from pool contract: 0xc9C32cd16Bf7eFB85Ff14e0c8603cc90F6F2eE49\n        uint256 S_ = 0;\n        uint256 _x = 0;\n        uint256 y_prev = 0;\n        uint256 c = D;\n        uint256 Ann = a * N_COINS;\n\n        for (uint256 _i; _i < N_COINS; ++_i) {\n            if (_i != i_) _x = xp[_i];\n            else continue;\n            S_ += _x;\n            c = (c * D) / (_x * N_COINS);\n        }\n\n        c = (c * D * A_PRECISION) / (Ann * N_COINS);\n        uint256 b = S_ + (D * A_PRECISION) / Ann; // - D\n        y = D;\n\n        for (uint256 _i; _i < 255; ++_i) {\n            y_prev = y;\n            y = (y * y + c) / (2 * y + b - D);\n            if (y > y_prev && y - y_prev <= 1) return y;\n            else if (y_prev - y <= 1) return y;\n        }\n        require(false, \"Price: Convergence false\");\n    }\n\n    /**\n     * @dev Return the `xp` array for two tokens. Adjusts `balances[0]` by `padding`\n     * and `balances[1]` by `rate / PRECISION`.\n     * \n     * This is provided as a gas optimization when `rates[0] * PRECISION` has been\n     * pre-computed.\n     */\n    function getXP(\n        uint256[2] memory balances,\n        uint256 padding,\n        uint256 rate\n    ) internal pure returns (uint256[2] memory xp) {\n        xp[0] = balances[0].mul(padding);\n        xp[1] = balances[1].mul(rate).div(PRECISION);\n    }\n\n    /**\n     * @dev Return the `xp` array for two tokens. Adjusts `balances[0]` by `rates[0]`\n     * and `balances[1]` by `rates[1] / PRECISION`.\n     */\n    function getXP(\n        uint256[2] memory balances,\n        uint256[2] memory rates\n    ) internal pure returns (uint256[2] memory xp) {\n        xp[0] = balances[0].mul(rates[0]).div(PRECISION);\n        xp[1] = balances[1].mul(rates[1]).div(PRECISION);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/libraries/Curve/LibCurve.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/**\n * @title LibCurve\n * @author Publius\n * @notice Low-level Curve swap math for a 2-token StableSwap pool.\n */\nlibrary LibCurve {\n    using SafeMath for uint256;\n\n    uint256 private constant A_PRECISION = 100;\n    uint256 private constant N_COINS = 2;\n    uint256 private constant PRECISION = 1e18;\n    uint256 private constant i = 0;\n    uint256 private constant j = 1;\n\n    /**\n     * @dev Find the change in token `j` given a change in token `i`.\n     */\n    function getPrice(\n        uint256[2] memory xp,\n        uint256 a,\n        uint256 D,\n        uint256 padding\n    ) internal pure returns (uint256) {\n        uint256 x = xp[i] + padding;\n        uint256 y = getY(x, xp, a, D);\n        uint256 dy = xp[j] - y - 1;\n        return dy;\n    }\n\n    function getPrice(\n        uint256[2] memory xp,\n        uint256[2] memory rates,\n        uint256 a,\n        uint256 D\n    ) internal pure returns (uint256) {\n        uint256 x = xp[i] + ((1 * rates[i]) / PRECISION);\n        uint256 y = getY(x, xp, a, D);\n        uint256 dy = xp[j] - y - 1;\n        return dy / 1e6;\n    }\n\n    function getY(\n        uint256 x,\n        uint256[2] memory xp,\n        uint256 a,\n        uint256 D\n    ) internal pure returns (uint256 y) {\n        // Solution is taken from pool contract: 0xc9C32cd16Bf7eFB85Ff14e0c8603cc90F6F2eE49\n        uint256 S_ = 0;\n        uint256 _x = 0;\n        uint256 y_prev = 0;\n        uint256 c = D;\n        uint256 Ann = a * N_COINS;\n\n        for (uint256 _i; _i < N_COINS; ++_i) {\n            if (_i == i) _x = x;\n            else if (_i != j) _x = xp[_i];\n            else continue;\n            S_ += _x;\n            c = (c * D) / (_x * N_COINS);\n        }\n\n        c = (c * D * A_PRECISION) / (Ann * N_COINS);\n        uint256 b = S_ + (D * A_PRECISION) / Ann; // - D\n        y = D;\n\n        for (uint256 _i; _i < 255; ++_i) {\n            y_prev = y;\n            y = (y * y + c) / (2 * y + b - D);\n            if (y > y_prev && y - y_prev <= 1) return y;\n            else if (y_prev - y <= 1) return y;\n        }\n        require(false, \"Price: Convergence false\");\n    }\n\n    function getD(uint256[2] memory xp, uint256 a)\n        internal\n        pure\n        returns (uint256 D)\n    {\n        // Solution is taken from pool contract: 0xc9C32cd16Bf7eFB85Ff14e0c8603cc90F6F2eE49\n        uint256 S;\n        uint256 Dprev;\n        for (uint256 _i; _i < xp.length; ++_i) {\n            S += xp[_i];\n        }\n        if (S == 0) return 0;\n\n        D = S;\n        uint256 Ann = a * N_COINS;\n        for (uint256 _i; _i < 256; ++_i) {\n            uint256 D_P = D;\n            for (uint256 _j; _j < xp.length; ++_j) {\n                D_P = (D_P * D) / (xp[_j] * N_COINS);\n            }\n            Dprev = D;\n            D =\n                (((Ann * S) / A_PRECISION + D_P * N_COINS) * D) /\n                (((Ann - A_PRECISION) * D) / A_PRECISION + (N_COINS + 1) * D_P);\n            if (D > Dprev && D - Dprev <= 1) return D;\n            else if (Dprev - D <= 1) return D;\n        }\n        require(false, \"Price: Convergence false\");\n        return 0;\n    }\n\n    function getYD(\n        uint256 a,\n        uint256 i_,\n        uint256[2] memory xp,\n        uint256 D\n    ) internal pure returns (uint256 y) {\n        // Solution is taken from pool contract: 0xc9C32cd16Bf7eFB85Ff14e0c8603cc90F6F2eE49\n        uint256 S_ = 0;\n        uint256 _x = 0;\n        uint256 y_prev = 0;\n        uint256 c = D;\n        uint256 Ann = a * N_COINS;\n\n        for (uint256 _i; _i < N_COINS; ++_i) {\n            if (_i != i_) _x = xp[_i];\n            else continue;\n            S_ += _x;\n            c = (c * D) / (_x * N_COINS);\n        }\n\n        c = (c * D * A_PRECISION) / (Ann * N_COINS);\n        uint256 b = S_ + (D * A_PRECISION) / Ann; // - D\n        y = D;\n\n        for (uint256 _i; _i < 255; ++_i) {\n            y_prev = y;\n            y = (y * y + c) / (2 * y + b - D);\n            if (y > y_prev && y - y_prev <= 1) return y;\n            else if (y_prev - y <= 1) return y;\n        }\n        require(false, \"Price: Convergence false\");\n    }\n\n    /**\n     * @dev Return the `xp` array for two tokens. Adjusts `balances[0]` by `padding`\n     * and `balances[1]` by `rate / PRECISION`.\n     * \n     * This is provided as a gas optimization when `rates[0] * PRECISION` has been\n     * pre-computed.\n     */\n    function getXP(\n        uint256[2] memory balances,\n        uint256 padding,\n        uint256 rate\n    ) internal pure returns (uint256[2] memory xp) {\n        xp[0] = balances[0].mul(padding);\n        xp[1] = balances[1].mul(rate).div(PRECISION);\n    }\n\n    /**\n     * @dev Return the `xp` array for two tokens. Adjusts `balances[0]` by `rates[0]`\n     * and `balances[1]` by `rates[1] / PRECISION`.\n     */\n    function getXP(\n        uint256[2] memory balances,\n        uint256[2] memory rates\n    ) internal pure returns (uint256[2] memory xp) {\n        xp[0] = balances[0].mul(rates[0]).div(PRECISION);\n        xp[1] = balances[1].mul(rates[1]).div(PRECISION);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/libraries/Curve/LibCurve.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/**\n * @title LibCurve\n * @author Publius\n * @notice Low-level Curve swap math for a 2-token StableSwap pool.\n */\nlibrary LibCurve {\n    using SafeMath for uint256;\n\n    uint256 private constant A_PRECISION = 100;\n    uint256 private constant N_COINS = 2;\n    uint256 private constant PRECISION = 1e18;\n    uint256 private constant i = 0;\n    uint256 private constant j = 1;\n\n    /**\n     * @dev Find the change in token `j` given a change in token `i`.\n     */\n    function getPrice(\n        uint256[2] memory xp,\n        uint256 a,\n        uint256 D,\n        uint256 padding\n    ) internal pure returns (uint256) {\n        uint256 x = xp[i] + padding;\n        uint256 y = getY(x, xp, a, D);\n        uint256 dy = xp[j] - y - 1;\n        return dy;\n    }\n\n    function getPrice(\n        uint256[2] memory xp,\n        uint256[2] memory rates,\n        uint256 a,\n        uint256 D\n    ) internal pure returns (uint256) {\n        uint256 x = xp[i] + ((1 * rates[i]) / PRECISION);\n        uint256 y = getY(x, xp, a, D);\n        uint256 dy = xp[j] - y - 1;\n        return dy / 1e6;\n    }\n\n    function getY(\n        uint256 x,\n        uint256[2] memory xp,\n        uint256 a,\n        uint256 D\n    ) internal pure returns (uint256 y) {\n        // Solution is taken from pool contract: 0xc9C32cd16Bf7eFB85Ff14e0c8603cc90F6F2eE49\n        uint256 S_ = 0;\n        uint256 _x = 0;\n        uint256 y_prev = 0;\n        uint256 c = D;\n        uint256 Ann = a * N_COINS;\n\n        for (uint256 _i; _i < N_COINS; ++_i) {\n            if (_i == i) _x = x;\n            else if (_i != j) _x = xp[_i];\n            else continue;\n            S_ += _x;\n            c = (c * D) / (_x * N_COINS);\n        }\n\n        c = (c * D * A_PRECISION) / (Ann * N_COINS);\n        uint256 b = S_ + (D * A_PRECISION) / Ann; // - D\n        y = D;\n\n        for (uint256 _i; _i < 255; ++_i) {\n            y_prev = y;\n            y = (y * y + c) / (2 * y + b - D);\n            if (y > y_prev && y - y_prev <= 1) return y;\n            else if (y_prev - y <= 1) return y;\n        }\n        require(false, \"Price: Convergence false\");\n    }\n\n    function getD(uint256[2] memory xp, uint256 a)\n        internal\n        pure\n        returns (uint256 D)\n    {\n        // Solution is taken from pool contract: 0xc9C32cd16Bf7eFB85Ff14e0c8603cc90F6F2eE49\n        uint256 S;\n        uint256 Dprev;\n        for (uint256 _i; _i < xp.length; ++_i) {\n            S += xp[_i];\n        }\n        if (S == 0) return 0;\n\n        D = S;\n        uint256 Ann = a * N_COINS;\n        for (uint256 _i; _i < 256; ++_i) {\n            uint256 D_P = D;\n            for (uint256 _j; _j < xp.length; ++_j) {\n                D_P = (D_P * D) / (xp[_j] * N_COINS);\n            }\n            Dprev = D;\n            D =\n                (((Ann * S) / A_PRECISION + D_P * N_COINS) * D) /\n                (((Ann - A_PRECISION) * D) / A_PRECISION + (N_COINS + 1) * D_P);\n            if (D > Dprev && D - Dprev <= 1) return D;\n            else if (Dprev - D <= 1) return D;\n        }\n        require(false, \"Price: Convergence false\");\n        return 0;\n    }\n\n    function getYD(\n        uint256 a,\n        uint256 i_,\n        uint256[2] memory xp,\n        uint256 D\n    ) internal pure returns (uint256 y) {\n        // Solution is taken from pool contract: 0xc9C32cd16Bf7eFB85Ff14e0c8603cc90F6F2eE49\n        uint256 S_ = 0;\n        uint256 _x = 0;\n        uint256 y_prev = 0;\n        uint256 c = D;\n        uint256 Ann = a * N_COINS;\n\n        for (uint256 _i; _i < N_COINS; ++_i) {\n            if (_i != i_) _x = xp[_i];\n            else continue;\n            S_ += _x;\n            c = (c * D) / (_x * N_COINS);\n        }\n\n        c = (c * D * A_PRECISION) / (Ann * N_COINS);\n        uint256 b = S_ + (D * A_PRECISION) / Ann; // - D\n        y = D;\n\n        for (uint256 _i; _i < 255; ++_i) {\n            y_prev = y;\n            y = (y * y + c) / (2 * y + b - D);\n            if (y > y_prev && y - y_prev <= 1) return y;\n            else if (y_prev - y <= 1) return y;\n        }\n        require(false, \"Price: Convergence false\");\n    }\n\n    /**\n     * @dev Return the `xp` array for two tokens. Adjusts `balances[0]` by `padding`\n     * and `balances[1]` by `rate / PRECISION`.\n     * \n     * This is provided as a gas optimization when `rates[0] * PRECISION` has been\n     * pre-computed.\n     */\n    function getXP(\n        uint256[2] memory balances,\n        uint256 padding,\n        uint256 rate\n    ) internal pure returns (uint256[2] memory xp) {\n        xp[0] = balances[0].mul(padding);\n        xp[1] = balances[1].mul(rate).div(PRECISION);\n    }\n\n    /**\n     * @dev Return the `xp` array for two tokens. Adjusts `balances[0]` by `rates[0]`\n     * and `balances[1]` by `rates[1] / PRECISION`.\n     */\n    function getXP(\n        uint256[2] memory balances,\n        uint256[2] memory rates\n    ) internal pure returns (uint256[2] memory xp) {\n        xp[0] = balances[0].mul(rates[0]).div(PRECISION);\n        xp[1] = balances[1].mul(rates[1]).div(PRECISION);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/libraries/Curve/LibCurve.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/**\n * @title LibCurve\n * @author Publius\n * @notice Low-level Curve swap math for a 2-token StableSwap pool.\n */\nlibrary LibCurve {\n    using SafeMath for uint256;\n\n    uint256 private constant A_PRECISION = 100;\n    uint256 private constant N_COINS = 2;\n    uint256 private constant PRECISION = 1e18;\n    uint256 private constant i = 0;\n    uint256 private constant j = 1;\n\n    /**\n     * @dev Find the change in token `j` given a change in token `i`.\n     */\n    function getPrice(\n        uint256[2] memory xp,\n        uint256 a,\n        uint256 D,\n        uint256 padding\n    ) internal pure returns (uint256) {\n        uint256 x = xp[i] + padding;\n        uint256 y = getY(x, xp, a, D);\n        uint256 dy = xp[j] - y - 1;\n        return dy;\n    }\n\n    function getPrice(\n        uint256[2] memory xp,\n        uint256[2] memory rates,\n        uint256 a,\n        uint256 D\n    ) internal pure returns (uint256) {\n        uint256 x = xp[i] + ((1 * rates[i]) / PRECISION);\n        uint256 y = getY(x, xp, a, D);\n        uint256 dy = xp[j] - y - 1;\n        return dy / 1e6;\n    }\n\n    function getY(\n        uint256 x,\n        uint256[2] memory xp,\n        uint256 a,\n        uint256 D\n    ) internal pure returns (uint256 y) {\n        // Solution is taken from pool contract: 0xc9C32cd16Bf7eFB85Ff14e0c8603cc90F6F2eE49\n        uint256 S_ = 0;\n        uint256 _x = 0;\n        uint256 y_prev = 0;\n        uint256 c = D;\n        uint256 Ann = a * N_COINS;\n\n        for (uint256 _i; _i < N_COINS; ++_i) {\n            if (_i == i) _x = x;\n            else if (_i != j) _x = xp[_i];\n            else continue;\n            S_ += _x;\n            c = (c * D) / (_x * N_COINS);\n        }\n\n        c = (c * D * A_PRECISION) / (Ann * N_COINS);\n        uint256 b = S_ + (D * A_PRECISION) / Ann; // - D\n        y = D;\n\n        for (uint256 _i; _i < 255; ++_i) {\n            y_prev = y;\n            y = (y * y + c) / (2 * y + b - D);\n            if (y > y_prev && y - y_prev <= 1) return y;\n            else if (y_prev - y <= 1) return y;\n        }\n        require(false, \"Price: Convergence false\");\n    }\n\n    function getD(uint256[2] memory xp, uint256 a)\n        internal\n        pure\n        returns (uint256 D)\n    {\n        // Solution is taken from pool contract: 0xc9C32cd16Bf7eFB85Ff14e0c8603cc90F6F2eE49\n        uint256 S;\n        uint256 Dprev;\n        for (uint256 _i; _i < xp.length; ++_i) {\n            S += xp[_i];\n        }\n        if (S == 0) return 0;\n\n        D = S;\n        uint256 Ann = a * N_COINS;\n        for (uint256 _i; _i < 256; ++_i) {\n            uint256 D_P = D;\n            for (uint256 _j; _j < xp.length; ++_j) {\n                D_P = (D_P * D) / (xp[_j] * N_COINS);\n            }\n            Dprev = D;\n            D =\n                (((Ann * S) / A_PRECISION + D_P * N_COINS) * D) /\n                (((Ann - A_PRECISION) * D) / A_PRECISION + (N_COINS + 1) * D_P);\n            if (D > Dprev && D - Dprev <= 1) return D;\n            else if (Dprev - D <= 1) return D;\n        }\n        require(false, \"Price: Convergence false\");\n        return 0;\n    }\n\n    function getYD(\n        uint256 a,\n        uint256 i_,\n        uint256[2] memory xp,\n        uint256 D\n    ) internal pure returns (uint256 y) {\n        // Solution is taken from pool contract: 0xc9C32cd16Bf7eFB85Ff14e0c8603cc90F6F2eE49\n        uint256 S_ = 0;\n        uint256 _x = 0;\n        uint256 y_prev = 0;\n        uint256 c = D;\n        uint256 Ann = a * N_COINS;\n\n        for (uint256 _i; _i < N_COINS; ++_i) {\n            if (_i != i_) _x = xp[_i];\n            else continue;\n            S_ += _x;\n            c = (c * D) / (_x * N_COINS);\n        }\n\n        c = (c * D * A_PRECISION) / (Ann * N_COINS);\n        uint256 b = S_ + (D * A_PRECISION) / Ann; // - D\n        y = D;\n\n        for (uint256 _i; _i < 255; ++_i) {\n            y_prev = y;\n            y = (y * y + c) / (2 * y + b - D);\n            if (y > y_prev && y - y_prev <= 1) return y;\n            else if (y_prev - y <= 1) return y;\n        }\n        require(false, \"Price: Convergence false\");\n    }\n\n    /**\n     * @dev Return the `xp` array for two tokens. Adjusts `balances[0]` by `padding`\n     * and `balances[1]` by `rate / PRECISION`.\n     * \n     * This is provided as a gas optimization when `rates[0] * PRECISION` has been\n     * pre-computed.\n     */\n    function getXP(\n        uint256[2] memory balances,\n        uint256 padding,\n        uint256 rate\n    ) internal pure returns (uint256[2] memory xp) {\n        xp[0] = balances[0].mul(padding);\n        xp[1] = balances[1].mul(rate).div(PRECISION);\n    }\n\n    /**\n     * @dev Return the `xp` array for two tokens. Adjusts `balances[0]` by `rates[0]`\n     * and `balances[1]` by `rates[1] / PRECISION`.\n     */\n    function getXP(\n        uint256[2] memory balances,\n        uint256[2] memory rates\n    ) internal pure returns (uint256[2] memory xp) {\n        xp[0] = balances[0].mul(rates[0]).div(PRECISION);\n        xp[1] = balances[1].mul(rates[1]).div(PRECISION);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/libraries/Convert/LibCurveConvert.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {ICurvePool} from \"contracts/interfaces/ICurve.sol\";\nimport {LibAppStorage, AppStorage} from \"../LibAppStorage.sol\";\nimport {LibConvertData} from \"./LibConvertData.sol\";\nimport {LibMetaCurveConvert} from \"./LibMetaCurveConvert.sol\";\nimport {C} from \"contracts/C.sol\";\n\n/**\n * @title Curve Convert Library\n * @notice Contains Functions to convert from/to Curve LP tokens to/from Beans\n * in the direction of the Peg.\n **/\nlibrary LibCurveConvert {\n    using SafeMath for uint256;\n    using LibConvertData for bytes;\n\n    //////////////////// GETTERS ////////////////////\n\n    /**\n     * @notice Calculate the number of BEAN needed to be added as liquidity to return `pool` back to peg.\n     * @dev\n     *   Assumes that BEAN is the first token in the pool.\n     *   Returns 0 if returns peg.\n     */\n    function beansToPeg(address pool) internal view returns (uint256 beans) {\n        uint256[2] memory balances = ICurvePool(pool).get_balances();\n        uint256 xp1 = _getBeansAtPeg(pool, balances);\n        if (xp1 <= balances[0]) return 0;\n        beans = xp1.sub(balances[0]);\n    }\n\n    /**\n     * @notice Calculate the amount of liquidity needed to be removed as Beans to return `pool` back to peg.\n     * @dev Returns 0 if above peg.\n     */\n    function lpToPeg(address pool) internal view returns (uint256 lp) {\n        uint256[2] memory balances = ICurvePool(pool).get_balances();\n        uint256 xp1 = _getBeansAtPeg(pool, balances);\n        if (balances[0] <= xp1) return 0;\n        return LibMetaCurveConvert.lpToPeg(balances, xp1);\n    }\n\n    /**\n     * @param pool The address of the Curve pool where `amountIn` will be withdrawn\n     * @param amountIn The amount of the LP token of `pool` to remove as BEAN\n     * @return beans The amount of BEAN received for removing `amountIn` LP tokens.\n     * @dev Assumes that i=0 corresponds to BEAN.\n     */\n    function getBeanAmountOut(address pool, uint256 amountIn) internal view returns(uint256 beans) {\n        beans = ICurvePool(pool).calc_withdraw_one_coin(amountIn, 0); // i=0 -> BEAN\n    }\n\n    /**\n     * @param pool The address of the Curve pool where `amountIn` will be deposited\n     * @param amount"
    }
  ]
}