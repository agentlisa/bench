{
  "Title": "[M-04] Potential Near-Zero Scenarios for `purchasePrice` in the Continuous Gradual Dutch Auction",
  "Content": "\n<https://github.com/GenerationSoftware/pt-v5-cgda-liquidator/blob/7f95bcacd4a566c2becb98d55c1886cadbaa8897/src/LiquidationPair.sol#L211-L226><br>\n<https://github.com/GenerationSoftware/pt-v5-cgda-liquidator/blob/7f95bcacd4a566c2becb98d55c1886cadbaa8897/src/LiquidationPair.sol#L294-L319><br>\n<https://github.com/GenerationSoftware/pt-v5-cgda-liquidator/blob/7f95bcacd4a566c2becb98d55c1886cadbaa8897/src/libraries/ContinuousGDA.sol#L16-L44>\n\nThe Continuous Gradual Dutch Auction (CGDA) model has potential scenarios where the `purchasePrice` for an amount of tokens could approach near-zero values. This is influenced mainly by two factors: `_emissionRate` and `_timeSinceLastAuctionStart`. If either one or both of these factors (`_emissionRate` specifically more likely) are significantly large, the `purchasePrice` could drastically drop.\n\nThis condition could cause undesired economic effects in the auction process. Under this context, participants may acquire tokens (amount of Vault shares) at an extremely low price (very low POOL amount indeed), which could lead to significant chance of winnings.\n\n### Proof of Concept\n\nHere is the purchasePrice function within the ContinuousGDA library, which computes the purchase price of tokens based on various parameters.\n\n<https://github.com/GenerationSoftware/pt-v5-cgda-liquidator/blob/7f95bcacd4a566c2becb98d55c1886cadbaa8897/src/libraries/ContinuousGDA.sol#L23-L44>\n\n```solidity\n  function purchasePrice(\n    SD59x18 _amount,\n    SD59x18 _emissionRate,\n    SD59x18 _k,\n    SD59x18 _decayConstant,\n    SD59x18 _timeSinceLastAuctionStart\n  ) internal pure returns (SD59x18) {\n    if (_amount.unwrap() == 0) {\n      return SD59x18.wrap(0);\n    }\n    SD59x18 topE = _decayConstant.mul(_amount).div(_emissionRate);\n    topE = topE.exp().sub(ONE);\n    SD59x18 bottomE = _decayConstant.mul(_timeSinceLastAuctionStart);\n    bottomE = bottomE.exp();\n    SD59x18 result;\n    if (_emissionRate.unwrap() > 1e18) {\n      result = _k.div(_emissionRate).mul(topE).div(bottomE);\n    } else {\n      result = _k.mul(topE.div(_emissionRate.mul(bottomE)));\n    }\n    return result;\n  }\n```\n\nOne possible scenarios where `purchasePrice` could approach near-zero values is:<br>\n\\_k = 1e18 (the initial price of the CGDA)<br>\n\\_decayConstant = 0.00001 (a very small decay constant)<br>\n\\_amount = 1e18 (the amount of tokens to purchase which has reportedly become a rare commodity)<br>\n\\_emissionRate = 1e20 (a significantly large, but more practical emission rate)<br>\n\\_timeSinceLastAuctionStart = 3600 (equivalent to 1 hour)\n\nThe small `_decayConstant`, along with the relatively short `_timeSinceLastAuctionStart`, results in `bottomE` being close to 1. `_emissionRate` is significantly larger than `_amount`, making `topE` also close to 1. As a result, this combination of factors drives the `purchasePrice` towards near-zero values.\n\nPlease note that this is only one of many possible scenarios where the purchase price could approach near-zero values. Other combinations of parameter tweaks could potentially also lead to similar or more likely outcomes.\n\n### Recommended Mitigation Steps\n\n1.  Introduce checks in the `_computeExactAmountIn` function to ensure that `_emissionRate` doesn't exceed a certain practical limit.\n2.  Introduce checks in function `swapExactAmountOut` that the scaled ratio of `_amountInForPeriod` to `_amountOutForPeriod` should not fall below a certain threshold.\n\n### Assessed type\n\nContext\n\n**[asselstine (PoolTogether) confirmed and commented](https://github.com/code-423n4/2023-08-pooltogether-findings/issues/122#issuecomment-1673814935):**\n > I'd like to see a more concrete example, as some of these parameters have been chosen arbitrarily. What is the asset:prize exchange rate? What should the value of \\_k be after being tuned correctly with computeK? This boundary condition feels a little contrived.\n> \n> Regardless of the details, I think it's good that it points out the possibility of a zero-value swap.\n> \n> We should assert that `swapAmountIn > 0` in the `swapExactAmountOut` function.\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2023-08-pooltogether-findings/issues/122#issuecomment-1676992619):**\n > This issue is affected by [`#24`](https://github.com/code-423n4/2023-08-pooltogether-findings/issues/24): the near-zero condition presented no longer holds true when the formula has been modified.\n> \n> Nevertheless, looking at this issue in isolation, the argument is valid: near-zero / zero price scenarios should be blocked. \n\n**[asselstine (PoolTogether) commented](https://github.com/code-423n4/2023-08-pooltogether-findings/issues/122#issuecomment-1684443889):**\n > Fixed in [this commit](https://github.com/GenerationSoftware/pt-v5-cgda-liquidator/commit/7e29f33ac78dae2204394d44bb76e83af39056b6).\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-08-pooltogether",
  "Code": [
    {
      "filename": "src/LiquidationPair.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport { ILiquidationSource } from \"pt-v5-liquidator-interfaces/ILiquidationSource.sol\";\nimport { ILiquidationPair } from \"pt-v5-liquidator-interfaces/ILiquidationPair.sol\";\nimport { SD59x18, uEXP_MAX_INPUT, wrap, convert, unwrap } from \"prb-math/SD59x18.sol\";\n\nimport { ContinuousGDA } from \"./libraries/ContinuousGDA.sol\";\n\nerror AmountInZero();\nerror AmountOutZero();\nerror TargetFirstSaleTimeLtPeriodLength(uint passedTargetSaleTime, uint periodLength);\nerror SwapExceedsAvailable(uint256 amountOut, uint256 available);\nerror SwapExceedsMax(uint256 amountInMax, uint256 amountIn);\nerror DecayConstantTooLarge(SD59x18 maxDecayConstant, SD59x18 decayConstant);\nerror PurchasePriceIsZero(uint256 amountOut);\n\n/***\n * @title LiquidationPair\n * @author G9 Software Inc.\n * @notice Auctions one token for another in a periodic continuous gradual dutch auction. Auctions occur over a limit period so that the price can be adjusted.\n * @dev This contract is designed to be used with the LiquidationRouter contract.\n */\ncontract LiquidationPair is ILiquidationPair {\n\n  /* ============ Variables ============ */\n\n  /// @notice The liquidation source that the pair is using.  The source executes the actual token swap, while the pair handles the pricing.\n  ILiquidationSource public immutable source;\n\n  /// @notice The token that is used to pay for auctions\n  address public immutable tokenIn;\n\n  /// @notice The token that is being auctioned.\n  address public immutable tokenOut;\n\n  /// @notice The rate at which the price decays\n  SD59x18 public immutable decayConstant;\n\n  /// @notice The duration of each auction.\n  uint256 public immutable periodLength;\n\n  /// @notice Sets the beginning timestamp for the first period.\n  /// @dev Ensure that the periodOffset is in the past.\n  uint256 public immutable periodOffset;\n\n  /// @notice The time within an auction at which the price of available tokens matches the previous non-zero exchange rate.\n  uint32 public immutable targetFirstSaleTime;\n\n  /// @notice Require a minimum number of tokens before an auction is triggered.\n  /// @dev This is important, because the gas cost ultimately determines the efficiency of the swap.\n  /// If gas cost to auction is 10 cents and the auction is for 11 cents, then the auction price will be driven to zero to make up for the difference.\n  /// If gas cost is 10 cents and we're seeking an efficiency of at least 90%, then the minimum auction amount should be $1 worth of tokens.\n  uint256 public immutable minimumAuctionAmount;\n\n  /// @notice The last non-zero total tokens in for an auction. This is used to configure the target price for the next auction.\n  uint112 _lastNonZeroAmountIn;\n\n  /// @notice The last non-zero total tokens out for an auction.  This is used to configure the target price for the next auction.\n  uint112 _lastNonZeroAmountOut;\n\n  /// @notice The total tokens in for the current auction.\n  uint96 _amountInForPeriod;\n\n  /// @notice The total tokens out for the current auction.\n  uint96 _amountOutForPeriod;\n\n  /// @notice The current auction period. Note that this number can wrap.\n  uint16 _period;\n\n  /// @notice The timestamp at which emissions have been consumed to for the current auction\n  uint48 _lastAuctionTime;\n\n  /// @notice The rate of token emissions for the current auction\n  SD59x18 _emissionRate;\n\n  /// @notice The initial price for the current auction\n  SD59x18 _initialPrice;\n\n  /* ============ Constructor ============ */\n\n  /// @notice Construct a new pair\n  /// @param _source The liquidation source to use for the pair\n  /// @param _tokenIn The token that is used to pay for auctions\n  /// @param _tokenOut The token that is being auctioned\n  /// @param _periodLength The duration of each auction.\n  /// @param _periodOffset Sets the beginning timestamp for the first period\n  /// @param _targetFirstSaleTime The time within an auction at which the price of available tokens matches the previous non-zero exchange rate\n  /// @param _decayConstant The rate at which the price decays\n  /// @param _initialAmountIn The initial amount of tokens in for the first auction (used for the initial exchange rate)\n  /// @param _initialAmountOut The initial amount of tokens out for the first auction (used for the initial exchange rate)\n  /// @param _minimumAuctionAmount Require a minimum number of tokens before an auction is triggered.\n  constructor(\n    ILiquidationSource _source,\n    address _tokenIn,\n    address _tokenOut,\n    uint32 _periodLength,\n    uint32 _periodOffset,\n    uint32 _targetFirstSaleTime,\n    SD59x18 _decayConstant,\n    uint112 _initialAmountIn,\n    uint112 _initialAmountOut,\n    uint256 _minimumAuctionAmount\n  ) {\n    source = _source;\n    tokenIn = _tokenIn;\n    tokenOut = _tokenOut;\n    decayConstant = _decayConstant;\n    periodLength = _periodLength;\n    periodOffset = _periodOffset;\n    targetFirstSaleTime = _targetFirstSaleTime;\n\n    SD59x18 period59 = convert(int256(uint256(_periodLength)));\n    if (_decayConstant.mul(period59).unwrap() > uEXP_MAX_INPUT) {\n      revert DecayConstantTooLarge(wrap(uEXP_MAX_INPUT).div(period59), _decayConstant);\n    }\n\n    if (targetFirstSaleTime >= periodLength) {\n      revert TargetFirstSaleTimeLtPeriodLength(targetFirstSaleTime, periodLength);\n    }\n\n    if (_initialAmountIn == 0) {\n      revert AmountInZero();\n    }\n\n    if (_initialAmountOut == 0) {\n      revert AmountOutZero();\n    }\n\n    _lastNonZeroAmountIn = _initialAmountIn;\n    _lastNonZeroAmountOut = _initialAmountOut;\n    minimumAuctionAmount = _minimumAuctionAmount;\n\n    _updateAuction(0);\n  }\n\n  /* ============ External Read Methods ============ */\n\n  /// @inheritdoc ILiquidationPair\n  function target() external returns (address) {\n    return source.targetOf(tokenIn);\n  }\n\n  /// @inheritdoc ILiquidationPair\n  function maxAmountOut() external returns (uint256) {\n    _checkUpdateAuction();\n    return _maxAmountOut();\n  }\n\n  /// @notice Returns the maximum amount of tokens in\n  /// @return The max number of tokens in\n  function maxAmountIn() external returns (uint256) {\n    _checkUpdateAuction();\n    return _computeExactAmountIn(_maxAmountOut());\n  }\n\n  /// @inheritdoc ILiquidationPair\n  function computeExactAmountIn(uint256 _amountOut) external returns (uint256) {\n    _checkUpdateAuction();\n    return _computeExactAmountIn(_amountOut);\n  }\n\n  /// @inheritdoc ILiquidationPair\n  function estimateAmountOut(uint256 __amountIn) external returns (uint256) {\n    _checkUpdateAuction();\n    return uint(convert(ContinuousGDA.purchaseAmount(\n      convert(int(__amountIn)),\n      _emissionRate,\n      _initialPrice,\n      decayConstant,\n      _getElapsedTime()\n    )));\n  }\n\n  /// @notice Returns the total input tokens for the current auction.\n  /// @return Total tokens in\n  function amountInForPeriod() external returns (uint96) {\n    _checkUpdateAuction();\n    return _amountInForPeriod;\n  }\n\n  /// @notice Returns the total output tokens for the current auction.\n  /// @return Total tokens out\n  function amountOutForPeriod() external returns (uint96) {\n    _checkUpdateAuction();\n    return _amountOutForPeriod;\n  }\n\n  /// @notice Returns the timestamp to which emissions have been consumed.\n  /// @return The timestamp to which emissions have been consumed.\n  function lastAuctionTime() external returns (uint48) {\n    _checkUpdateAuction();\n    return _lastAuctionTime;\n  }\n\n  /// @notice Returns the emission rate in tokens per second for current auction\n  /// @return The emission rate\n  function emissionRate() external returns (SD59x18) {\n    _checkUpdateAuction();\n    return _emissionRate;\n  }\n\n  /// @notice Returns the initial price for the current auction\n  /// @return The initial price\n  function initialPrice() external returns (SD59x18) {\n    _checkUpdateAuction();\n    return _initialPrice;\n  }\n\n  /// @inheritdoc ILiquidationPair\n  function swapExactAmountOut(\n    address _account,\n    uint256 _amountOut,\n    uint256 _amountInMax\n  ) external returns (uint256) {\n    _checkUpdateAuction();\n    uint swapAmountIn = _computeExactAmountIn(_amountOut);\n    if (swapAmountIn > _amountInMax) {\n      revert SwapExceedsMax(_amountInMax, swapAmountIn);\n    }\n    _amountInForPeriod += uint96(swapAmountIn);\n    _amountOutForPeriod += uint96(_amountOut);\n    _lastAuctionTime += uint48(uint256(convert(convert(int256(_amountOut)).div(_emissionRate))));\n    source.liquidate(_account, tokenIn, swapAmountIn, tokenOut, _amountOut);\n    return swapAmountIn;\n  }\n\n  /// @notice Computes the elapsed time within the auction\n  function getElapsedTime() external returns (uint256) {\n    _checkUpdateAuction();\n    return uint256(convert(_getElapsedTime()));\n  }\n\n  /// @notice Returns the current auction start time\n  /// @return The start timestamp\n  function getPeriodStart() external returns (uint256) {\n    _checkUpdateAuction();\n    return _getPeriodStart(_computePeriod());\n  }\n\n  /// @notice Returns the current auction end time\n  /// @return The end timestamp\n  function getPeriodEnd() external returns (uint256) {\n    _checkUpdateAuction();\n    return _getPeriodEnd(_computePeriod());\n  }\n\n  /// @notice Returns the last non-zero auction total input tokens\n  /// @return Total input tokens\n  function lastNonZeroAmountIn() external returns (uint112) {\n    _checkUpdateAuction();\n    return _lastNonZeroAmountIn;\n  }\n\n  /// @notice Returns the last non-zero auction total output tokens\n  /// @return Total output tokens\n  function lastNonZeroAmountOut() external returns (uint112) {\n    _checkUpdateAuction();\n    return _lastNonZeroAmountOut;\n  }\n\n  /* ============ Internal Functions ============ */\n\n  /// @notice Computes the maximum amount of output tokens that can be purchased\n  /// @return Maximum amount of output tokens\n  function _maxAmountOut() internal returns (uint256) {\n    uint emissions = uint(convert(_emissionRate.mul(_getElapsedTime())));\n    uint liquidatable = source.liquidatableBalanceOf(tokenOut);\n    return emissions > liquidatable ? liquidatable : emissions;\n  }\n\n  /// @notice Computes the current emission rate given the available source balance of the output token\n  /// @return The current emission rate\n  function _computeEmissionRate() internal returns (SD59x18) {\n    uint256 amount = source.liquidatableBalanceOf(tokenOut);\n    // console2.log(\"_computeEmissionRate amount\", amount);\n    if (amount < minimumAuctionAmount) {\n      // do not release funds if the minimum is not met\n      amount = 0;\n      // console2.log(\"AMOUNT IS ZERO\");\n    }\n    return convert(int256(amount)).div(convert(int32(int(periodLength))));\n  }\n\n  /// @notice Computes the elapsed time within the current auction\n  /// @return The elapsed time\n  function _getElapsedTime() internal view returns (SD59x18) {\n    if (block.timestamp < _lastAuctionTime) {\n      return wrap(0);\n    }\n    return convert(int256(block.timestamp)).sub(convert(int256(uint256(_lastAuctionTime))));\n  }\n\n  /// @notice Computes the exact amount of input tokens required to purchase the given amount of output tokens\n  /// @param _amountOut The number of output tokens desired\n  /// @return The number of input tokens needed\n  function _computeExactAmountIn(uint256 _amountOut) internal returns (uint256) {\n    if (_amountOut == 0) {\n      return 0;\n    }\n    uint256 maxOut = _maxAmountOut();\n    if (_amountOut > maxOut) {\n      revert SwapExceedsAvailable(_amountOut, maxOut);\n    }\n    SD59x18 elapsed = _getElapsedTime();\n    uint purchasePrice = uint256(convert(ContinuousGDA.purchasePrice(\n        convert(int(_amountOut)),\n        _emissionRate,\n        _initialPrice,\n        decayConstant,\n        elapsed\n      ).ceil()));\n\n    if (purchasePrice == 0) {\n      revert PurchasePriceIsZero(_amountOut);\n    }\n\n    return purchasePrice;\n  }\n\n  /// @notice Checks to see if a new auction has started, and updates the state if so\n  function _checkUpdateAuction() internal {\n    uint256 currentPeriod = _computePeriod();\n    if (currentPeriod != _period) {\n      _updateAuction(currentPeriod);\n    }\n  }\n\n  /// @notice Updates the current auction to the given period\n  /// @param __period The period that the auction should be updated to\n  function _updateAuction(uint256 __period) internal {\n    if (_amountInForPeriod > 0 && _amountOutForPeriod > 0) {\n      // if we sold something, then update the previous non-zero amount\n      _lastNonZeroAmountIn = _amountInForPeriod;\n      _lastNonZeroAmountOut = _amountOutForPeriod;\n    }\n    _amountInForPeriod = 0;\n    _amountOutForPeriod = 0;\n    _lastAuctionTime = uint48(periodOffset + periodLength * __period);\n    _period = uint16(__period);\n    SD59x18 emissionRate_ = _computeEmissionRate();\n    _emissionRate = emissionRate_;\n    if (_emissionRate.unwrap() != 0) {\n      // compute k\n      SD59x18 timeSinceLastAuctionStart = convert(int(uint(targetFirstSaleTime)));\n      SD59x18 purchaseAmount = timeSinceLastAuctionStart.mul(emissionRate_);\n      SD59x18 exchangeRateAmountInToAmountOut = convert(int(uint(_lastNonZeroAmountIn))).div(convert(int(uint(_lastNonZeroAmountOut))));\n      SD59x18 price = exchangeRateAmountInToAmountOut.mul(purchaseAmount);\n      _initialPrice = ContinuousGDA.computeK(\n        emissionRate_,\n        decayConstant,\n        timeSinceLastAuctionStart,\n        purchaseAmount,\n        price\n      );\n    } else {\n      _initialPrice = wrap(0);\n    }\n  }\n\n  /// @notice Computes the start time of the given auction period\n  /// @param __period The auction period, in terms of number of periods since periodOffset\n  /// @return The start timestamp of the given period\n  function _getPeriodStart(uint256 __period) internal view returns (uint256) {\n    return periodOffset + __period * periodLength;\n  }\n\n  /// @notice Computes the end time of the given auction period\n  /// @param __period The auction period, in terms of number of periods since periodOffset\n  /// @return The end timestamp of the given period\n  function _getPeriodEnd(uint256 __period) internal view returns (uint256) {\n    return _getPeriodStart(__period) + periodLength;\n  }\n\n  /// @notice Computes the current auction period\n  /// @return the current period\n  function _computePeriod() internal view returns (uint256) {\n    uint256 _timestamp = block.timestamp;\n    if (_timestamp < periodOffset) {\n      return 0;\n    }\n    return (_timestamp - periodOffset) / periodLength;\n  }\n}"
    },
    {
      "filename": "src/LiquidationPair.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport { ILiquidationSource } from \"pt-v5-liquidator-interfaces/ILiquidationSource.sol\";\nimport { ILiquidationPair } from \"pt-v5-liquidator-interfaces/ILiquidationPair.sol\";\nimport { SD59x18, uEXP_MAX_INPUT, wrap, convert, unwrap } from \"prb-math/SD59x18.sol\";\n\nimport { ContinuousGDA } from \"./libraries/ContinuousGDA.sol\";\n\nerror AmountInZero();\nerror AmountOutZero();\nerror TargetFirstSaleTimeLtPeriodLength(uint passedTargetSaleTime, uint periodLength);\nerror SwapExceedsAvailable(uint256 amountOut, uint256 available);\nerror SwapExceedsMax(uint256 amountInMax, uint256 amountIn);\nerror DecayConstantTooLarge(SD59x18 maxDecayConstant, SD59x18 decayConstant);\nerror PurchasePriceIsZero(uint256 amountOut);\n\n/***\n * @title LiquidationPair\n * @author G9 Software Inc.\n * @notice Auctions one token for another in a periodic continuous gradual dutch auction. Auctions occur over a limit period so that the price can be adjusted.\n * @dev This contract is designed to be used with the LiquidationRouter contract.\n */\ncontract LiquidationPair is ILiquidationPair {\n\n  /* ============ Variables ============ */\n\n  /// @notice The liquidation source that the pair is using.  The source executes the actual token swap, while the pair handles the pricing.\n  ILiquidationSource public immutable source;\n\n  /// @notice The token that is used to pay for auctions\n  address public immutable tokenIn;\n\n  /// @notice The token that is being auctioned.\n  address public immutable tokenOut;\n\n  /// @notice The rate at which the price decays\n  SD59x18 public immutable decayConstant;\n\n  /// @notice The duration of each auction.\n  uint256 public immutable periodLength;\n\n  /// @notice Sets the beginning timestamp for the first period.\n  /// @dev Ensure that the periodOffset is in the past.\n  uint256 public immutable periodOffset;\n\n  /// @notice The time within an auction at which the price of available tokens matches the previous non-zero exchange rate.\n  uint32 public immutable targetFirstSaleTime;\n\n  /// @notice Require a minimum number of tokens before an auction is triggered.\n  /// @dev This is important, because the gas cost ultimately determines the efficiency of the swap.\n  /// If gas cost to auction is 10 cents and the auction is for 11 cents, then the auction price will be driven to zero to make up for the difference.\n  /// If gas cost is 10 cents and we're seeking an efficiency of at least 90%, then the minimum auction amount should be $1 worth of tokens.\n  uint256 public immutable minimumAuctionAmount;\n\n  /// @notice The last non-zero total tokens in for an auction. This is used to configure the target price for the next auction.\n  uint112 _lastNonZeroAmountIn;\n\n  /// @notice The last non-zero total tokens out for an auction.  This is used to configure the target price for the next auction.\n  uint112 _lastNonZeroAmountOut;\n\n  /// @notice The total tokens in for the current auction.\n  uint96 _amountInForPeriod;\n\n  /// @notice The total tokens out for the current auction.\n  uint96 _amountOutForPeriod;\n\n  /// @notice The current auction period. Note that this number can wrap.\n  uint16 _period;\n\n  /// @notice The timestamp at which emissions have been consumed to for the current auction\n  uint48 _lastAuctionTime;\n\n  /// @notice The rate of token emissions for the current auction\n  SD59x18 _emissionRate;\n\n  /// @notice The initial price for the current auction\n  SD59x18 _initialPrice;\n\n  /* ============ Constructor ============ */\n\n  /// @notice Construct a new pair\n  /// @param _source The liquidation source to use for the pair\n  /// @param _tokenIn The token that is used to pay for auctions\n  /// @param _tokenOut The token that is being auctioned\n  /// @param _periodLength The duration of each auction.\n  /// @param _periodOffset Sets the beginning timestamp for the first period\n  /// @param _targetFirstSaleTime The time within an auction at which the price of available tokens matches the previous non-zero exchange rate\n  /// @param _decayConstant The rate at which the price decays\n  /// @param _initialAmountIn The initial amount of tokens in for the first auction (used for the initial exchange rate)\n  /// @param _initialAmountOut The initial amount of tokens out for the first auction (used for the initial exchange rate)\n  /// @param _minimumAuctionAmount Require a minimum number of tokens before an auction is triggered.\n  constructor(\n    ILiquidationSource _source,\n    address _tokenIn,\n    address _tokenOut,\n    uint32 _periodLength,\n    uint32 _periodOffset,\n    uint32 _targetFirstSaleTime,\n    SD59x18 _decayConstant,\n    uint112 _initialAmountIn,\n    uint112 _initialAmountOut,\n    uint256 _minimumAuctionAmount\n  ) {\n    source = _source;\n    tokenIn = _tokenIn;\n    tokenOut = _tokenOut;\n    decayConstant = _decayConstant;\n    periodLength = _periodLength;\n    periodOffset = _periodOffset;\n    targetFirstSaleTime = _targetFirstSaleTime;\n\n    SD59x18 period59 = convert(int256(uint256(_periodLength)));\n    if (_decayConstant.mul(period59).unwrap() > uEXP_MAX_INPUT) {\n      revert DecayConstantTooLarge(wrap(uEXP_MAX_INPUT).div(period59), _decayConstant);\n    }\n\n    if (targetFirstSaleTime >= periodLength) {\n      revert TargetFirstSaleTimeLtPeriodLength(targetFirstSaleTime, periodLength);\n    }\n\n    if (_initialAmountIn == 0) {\n      revert AmountInZero();\n    }\n\n    if (_initialAmountOut == 0) {\n      revert AmountOutZero();\n    }\n\n    _lastNonZeroAmountIn = _initialAmountIn;\n    _lastNonZeroAmountOut = _initialAmountOut;\n    minimumAuctionAmount = _minimumAuctionAmount;\n\n    _updateAuction(0);\n  }\n\n  /* ============ External Read Methods ============ */\n\n  /// @inheritdoc ILiquidationPair\n  function target() external returns (address) {\n    return source.targetOf(tokenIn);\n  }\n\n  /// @inheritdoc ILiquidationPair\n  function maxAmountOut() external returns (uint256) {\n    _checkUpdateAuction();\n    return _maxAmountOut();\n  }\n\n  /// @notice Returns the maximum amount of tokens in\n  /// @return The max number of tokens in\n  function maxAmountIn() external returns (uint256) {\n    _checkUpdateAuction();\n    return _computeExactAmountIn(_maxAmountOut());\n  }\n\n  /// @inheritdoc ILiquidationPair\n  function computeExactAmountIn(uint256 _amountOut) external returns (uint256) {\n    _checkUpdateAuction();\n    return _computeExactAmountIn(_amountOut);\n  }\n\n  /// @inheritdoc ILiquidationPair\n  function estimateAmountOut(uint256 __amountIn) external returns (uint256) {\n    _checkUpdateAuction();\n    return uint(convert(ContinuousGDA.purchaseAmount(\n      convert(int(__amountIn)),\n      _emissionRate,\n      _initialPrice,\n      decayConstant,\n      _getElapsedTime()\n    )));\n  }\n\n  /// @notice Returns the total input tokens for the current auction.\n  /// @return Total tokens in\n  function amountInForPeriod() external returns (uint96) {\n    _checkUpdateAuction();\n    return _amountInForPeriod;\n  }\n\n  /// @notice Returns the total output tokens for the current auction.\n  /// @return Total tokens out\n  function amountOutForPeriod() external returns (uint96) {\n    _checkUpdateAuction();\n    return _amountOutForPeriod;\n  }\n\n  /// @notice Returns the timestamp to which emissions have been consumed.\n  /// @return The timestamp to which emissions have been consumed.\n  function lastAuctionTime() external returns (uint48) {\n    _checkUpdateAuction();\n    return _lastAuctionTime;\n  }\n\n  /// @notice Returns the emission rate in tokens per second for current auction\n  /// @return The emission rate\n  function emissionRate() external returns (SD59x18) {\n    _checkUpdateAuction();\n    return _emissionRate;\n  }\n\n  /// @notice Returns the initial price for the current auction\n  /// @return The initial price\n  function initialPrice() external returns (SD59x18) {\n    _checkUpdateAuction();\n    return _initialPrice;\n  }\n\n  /// @inheritdoc ILiquidationPair\n  function swapExactAmountOut(\n    address _account,\n    uint256 _amountOut,\n    uint256 _amountInMax\n  ) external returns (uint256) {\n    _checkUpdateAuction();\n    uint swapAmountIn = _computeExactAmountIn(_amountOut);\n    if (swapAmountIn > _amountInMax) {\n      revert SwapExceedsMax(_amountInMax, swapAmountIn);\n    }\n    _amountInForPeriod += uint96(swapAmountIn);\n    _amountOutForPeriod += uint96(_amountOut);\n    _lastAuctionTime += uint48(uint256(convert(convert(int256(_amountOut)).div(_emissionRate))));\n    source.liquidate(_account, tokenIn, swapAmountIn, tokenOut, _amountOut);\n    return swapAmountIn;\n  }\n\n  /// @notice Computes the elapsed time within the auction\n  function getElapsedTime() external returns (uint256) {\n    _checkUpdateAuction();\n    return uint256(convert(_getElapsedTime()));\n  }\n\n  /// @notice Returns the current auction start time\n  /// @return The start timestamp\n  function getPeriodStart() external returns (uint256) {\n    _checkUpdateAuction();\n    return _getPeriodStart(_computePeriod());\n  }\n\n  /// @notice Returns the current auction end time\n  /// @return The end timestamp\n  function getPeriodEnd() external returns (uint256) {\n    _checkUpdateAuction();\n    return _getPeriodEnd(_computePeriod());\n  }\n\n  /// @notice Returns the last non-zero auction total input tokens\n  /// @return Total input tokens\n  function lastNonZeroAmountIn() external returns (uint112) {\n    _checkUpdateAuction();\n    return _lastNonZeroAmountIn;\n  }\n\n  /// @notice Returns the last non-zero auction total output tokens\n  /// @return Total output tokens\n  function lastNonZeroAmountOut() external returns (uint112) {\n    _checkUpdateAuction();\n    return _lastNonZeroAmountOut;\n  }\n\n  /* ============ Internal Functions ============ */\n\n  /// @notice Computes the maximum amount of output tokens that can be purchased\n  /// @return Maximum amount of output tokens\n  function _maxAmountOut() internal returns (uint256) {\n    uint emissions = uint(convert(_emissionRate.mul(_getElapsedTime())));\n    uint liquidatable = source.liquidatableBalanceOf(tokenOut);\n    return emissions > liquidatable ? liquidatable : emissions;\n  }\n\n  /// @notice Computes the current emission rate given the available source balance of the output token\n  /// @return The current emission rate\n  function _computeEmissionRate() internal returns (SD59x18) {\n    uint256 amount = source.liquidatableBalanceOf(tokenOut);\n    // console2.log(\"_computeEmissionRate amount\", amount);\n    if (amount < minimumAuctionAmount) {\n      // do not release funds if the minimum is not met\n      amount = 0;\n      // console2.log(\"AMOUNT IS ZERO\");\n    }\n    return convert(int256(amount)).div(convert(int32(int(periodLength))));\n  }\n\n  /// @notice Computes the elapsed time within the current auction\n  /// @return The elapsed time\n  function _getElapsedTime() internal view returns (SD59x18) {\n    if (block.timestamp < _lastAuctionTime) {\n      return wrap(0);\n    }\n    return convert(int256(block.timestamp)).sub(convert(int256(uint256(_lastAuctionTime))));\n  }\n\n  /// @notice Computes the exact amount of input tokens required to purchase the given amount of output tokens\n  /// @param _amountOut The number of output tokens desired\n  /// @return The number of input tokens needed\n  function _computeExactAmountIn(uint256 _amountOut) internal returns (uint256) {\n    if (_amountOut == 0) {\n      return 0;\n    }\n    uint256 maxOut = _maxAmountOut();\n    if (_amountOut > maxOut) {\n      revert SwapExceedsAvailable(_amountOut, maxOut);\n    }\n    SD59x18 elapsed = _getElapsedTime();\n    uint purchasePrice = uint256(convert(ContinuousGDA.purchasePrice(\n        convert(int(_amountOut)),\n        _emissionRate,\n        _initialPrice,\n        decayConstant,\n        elapsed\n      ).ceil()));\n\n    if (purchasePrice == 0) {\n      revert PurchasePriceIsZero(_amountOut);\n    }\n\n    return purchasePrice;\n  }\n\n  /// @notice Checks to see if a new auction has started, and updates the state if so\n  function _checkUpdateAuction() internal {\n    uint256 currentPeriod = _computePeriod();\n    if (currentPeriod != _period) {\n      _updateAuction(currentPeriod);\n    }\n  }\n\n  /// @notice Updates the current auction to the given period\n  /// @param __period The period that the auction should be updated to\n  function _updateAuction(uint256 __period) internal {\n    if (_amountInForPeriod > 0 && _amountOutForPeriod > 0) {\n      // if we sold something, then update the previous non-zero amount\n      _lastNonZeroAmountIn = _amountInForPeriod;\n      _lastNonZeroAmountOut = _amountOutForPeriod;\n    }\n    _amountInForPeriod = 0;\n    _amountOutForPeriod = 0;\n    _lastAuctionTime = uint48(periodOffset + periodLength * __period);\n    _period = uint16(__period);\n    SD59x18 emissionRate_ = _computeEmissionRate();\n    _emissionRate = emissionRate_;\n    if (_emissionRate.unwrap() != 0) {\n      // compute k\n      SD59x18 timeSinceLastAuctionStart = convert(int(uint(targetFirstSaleTime)));\n      SD59x18 purchaseAmount = timeSinceLastAuctionStart.mul(emissionRate_);\n      SD59x18 exchangeRateAmountInToAmountOut = convert(int(uint(_lastNonZeroAmountIn))).div(convert(int(uint(_lastNonZeroAmountOut))));\n      SD59x18 price = exchangeRateAmountInToAmountOut.mul(purchaseAmount);\n      _initialPrice = ContinuousGDA.computeK(\n        emissionRate_,\n        decayConstant,\n        timeSinceLastAuctionStart,\n        purchaseAmount,\n        price\n      );\n    } else {\n      _initialPrice = wrap(0);\n    }\n  }\n\n  /// @notice Computes the start time of the given auction period\n  /// @param __period The auction period, in terms of number of periods since periodOffset\n  /// @return The start timestamp of the given period\n  function _getPeriodStart(uint256 __period) internal view returns (uint256) {\n    return periodOffset + __period * periodLength;\n  }\n\n  /// @notice Computes the end time of the given auction period\n  /// @param __period The auction period, in terms of number of periods since periodOffset\n  /// @return The end timestamp of the given period\n  function _getPeriodEnd(uint256 __period) internal view returns (uint256) {\n    return _getPeriodStart(__period) + periodLength;\n  }\n\n  /// @notice Computes the current auction period\n  /// @return the current period\n  function _computePeriod() internal view returns (uint256) {\n    uint256 _timestamp = block.timestamp;\n    if (_timestamp < periodOffset) {\n      return 0;\n    }\n    return (_timestamp - periodOffset) / periodLength;\n  }\n}"
    },
    {
      "filename": "src/libraries/ContinuousGDA.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport { SD59x18, convert, unwrap } from \"prb-math/SD59x18.sol\";\n\n/// @title ContinuousGDA\n/// @author G9 Software Inc.\n/// @notice Implements the Continous Gradual Dutch Auction formula\n/// See https://www.paradigm.xyz/2022/04/gda\n/// @dev Pricing formula adapted from https://github.com/FrankieIsLost/gradual-dutch-auction/blob/master/src/ContinuousGDA.sol\nlibrary ContinuousGDA {\n\n  /// @notice a helpful constant\n  SD59x18 internal constant ONE = SD59x18.wrap(1e18);\n\n  /// @notice Calculate purchase price for a given amount of tokens\n  /// @param _amount The amount of tokens to purchase\n  /// @param _emissionRate The emission rate of the CGDA\n  /// @param _k The initial price of the CGDA\n  /// @param _decayConstant The decay constant of the CGDA\n  /// @param _timeSinceLastAuctionStart The elapsed time since the last consumed timestamp\n  /// @return The purchase price for the given amount of tokens\n  function purchasePrice(\n    SD59x18 _amount,\n    SD59x18 _emissionRate,\n    SD59x18 _k,\n    SD59x18 _decayConstant,\n    SD59x18 _timeSinceLastAuctionStart\n  ) internal pure returns (SD59x18) {\n    if (_amount.unwrap() == 0) {\n      return SD59x18.wrap(0);\n    }\n    SD59x18 topE = _decayConstant.mul(_amount).div(_emissionRate);\n    topE = topE.exp().sub(ONE);\n    SD59x18 bottomE = _decayConstant.mul(_timeSinceLastAuctionStart);\n    bottomE = bottomE.exp();\n    SD59x18 result;\n    if (_emissionRate.unwrap() > 1e18) {\n      result = _k.div(_emissionRate).mul(topE).div(bottomE);\n    } else {\n      result = _k.mul(topE.div(_emissionRate.mul(bottomE)));\n    }\n    return result;\n  }\n\n  /// @notice Computes the amount of tokens that can be purchased for a given price\n  /// @dev Note that this formula has significant floating point differences to the above. Either one, not both, should be used.\n  /// @param _price The price willing to be paid\n  /// @param _emissionRate The emission rate of the CGDA\n  /// @param _k The initial price of the CGDA\n  /// @param _decayConstant The decay constant of the CGDA\n  /// @param _timeSinceLastAuctionStart The elapsed time since the last consumed timestamp\n  /// @return The number of tokens that can be purchased for the given price\n  function purchaseAmount(\n    SD59x18 _price,\n    SD59x18 _emissionRate,\n    SD59x18 _k,\n    SD59x18 _decayConstant,\n    SD59x18 _timeSinceLastAuctionStart\n  ) internal pure returns (SD59x18) {\n    if (_price.unwrap() == 0) {\n      return SD59x18.wrap(0);\n    }\n    SD59x18 exp = _decayConstant.mul(_timeSinceLastAuctionStart).exp();\n    SD59x18 lnParam = _k.add(_price.mul(_emissionRate).mul(exp)).div(_k);\n    SD59x18 numerator = _emissionRate.mul(lnParam.ln());\n    SD59x18 amount = numerator.div(_decayConstant);\n    return amount;\n  }\n\n  /// @notice Computes an initial price for the CGDA such that the purchase amount will cost the price at the given timestamp\n  /// @param _emissionRate The emission rate of the CGDA\n  /// @param _decayConstant The decay constant of the CGDA\n  /// @param _targetFirstSaleTime The timestamp at which the CGDA price for the given amount matches the given price\n  /// @param _purchaseAmount The amount of tokens to purchase\n  /// @param _price The price to be paid for the amount of tokens\n  function computeK(\n    SD59x18 _emissionRate,\n    SD59x18 _decayConstant,\n    SD59x18 _targetFirstSaleTime,\n    SD59x18 _purchaseAmount,\n    SD59x18 _price\n  ) internal pure returns (SD59x18) {\n    SD59x18 exponent = _decayConstant.mul(_targetFirstSaleTime);\n    SD59x18 eValue = exponent.exp();\n    SD59x18 multiplier = _emissionRate.mul(_price);\n    SD59x18 denominator = (_decayConstant.mul(_purchaseAmount).div(_emissionRate)).exp().sub(ONE);\n    SD59x18 result = eValue.div(denominator);\n    return result.mul(multiplier);\n  }\n}"
    },
    {
      "filename": "src/libraries/ContinuousGDA.sol",
      "content": "// SPDX-License-Identifier: GPL-"
    }
  ]
}