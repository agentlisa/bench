{
  "Title": "H-1: The implied value of a public vault can be impaired, liquidity providers can lose funds",
  "Content": "# Issue H-1: The implied value of a public vault can be impaired, liquidity providers can lose funds \n\nSource: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/272 \n\n## Found by \nJeiwan\n\n## Summary\nThe implied value of a public vault can be impaired, liquidity providers can lose funds\n## Vulnerability Detail\nBorrowers can partially repay their liens, which is handled by the `_payment` function ([LienToken.sol#L594](https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L594)).\nWhen repaying a part of a lien, `lien.amount` is updated to include currently accrued debt ([LienToken.sol#L605-L617](https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L605-L617)):\n```solidity\nLien storage lien = lienData[lienId];\nlien.amount = _getOwed(lien); // @audit current debt, including accrued interest; saved to storage!\n```\nNotice that `lien.amount` is updated in storage, and `lien.last` wasn't updated.\n\nThen, lien's slope is subtracted from vault's slope accumulator to be re-calculated after the repayment ([LienToken.sol#L620-L630](https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L620-L630)):\n```solidity\nif (isPublicVault) {\n  // @audit calculates and subtracts lien's slope from vault's slope\n  IPublicVault(lienOwner).beforePayment(lienId, paymentAmount);\n}\nif (lien.amount > paymentAmount) {\n  lien.amount -= paymentAmount;\n  // @audit lien.last is updated only after payment amount subtraction\n  lien.last = block.timestamp.safeCastTo32();\n  // slope does not need to be updated if paying off the rest, since we neutralize slope in beforePayment()\n  if (isPublicVault) {\n    // @audit re-calculates and re-applies lien's slope after the repayment\n    IPublicVault(lienOwner).afterPayment(lienId);\n  }\n}\n```\n\nIn the `beforePayment` function, `LIEN_TOKEN().calculateSlope(lienId)` is called to calculate lien's current slope ([PublicVault.sol#L433-L442](https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L433-L442)):\n```solidity\nfunction beforePayment(uint256 lienId, uint256 amount) public onlyLienToken {\n  _handleStrategistInterestReward(lienId, amount);\n  uint256 lienSlope = LIEN_TOKEN().calculateSlope(lienId);\n  if (lienSlope > slope) {\n    slope = 0;\n  } else {\n    slope -= lienSlope;\n  }\n  last = block.timestamp;\n}\n```\n\nThe `calculateSlope` function reads a lien from storage and calls `_getOwed` again ([LienToken.sol#L440-L445](https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L440-L445)):\n```solidity\nfunction calculateSlope(uint256 lienId) public view returns (uint256) {\n  // @audit lien.amount includes interest accrued so far\n  Lien memory lien = lienData[lienId];\n  uint256 end = (lien.start + lien.duration);\n  uint256 owedAtEnd = _getOwed(lien, end);\n  // @audit lien.last wasn't updated in `_payment`, it's an older timestamp\n  return (owedAtEnd - lien.amount).mulDivDown(1, end - lien.last);\n}\n```\n\nThis is where double counting of accrued interest happens. Recall that lien's amount already includes the interest that was accrued by this moment (in the `_payment` function). Now, interest is calculated again and *is applied to the amount that already includes (a portion) it* ([LienToken.sol#L544-L550](https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L544-L550)):\n```solidity\nfunction _getOwed(Lien memory lien, uint256 timestamp)\n  internal\n  view\n  returns (uint256)\n{\n  // @audit lien.amount already includes interest accrued so far\n  return lien.amount + _getInterest(lien, timestamp);\n}\n```\n\n[LienToken.sol#L177-L196](https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L177-L196):\n```solidity\nfunction _getInterest(Lien memory lien, uint256 timestamp)\n  internal\n  view\n  returns (uint256)\n{\n  if (!lien.active) {\n    return uint256(0);\n  }\n  uint256 delta_t;\n  if (block.timestamp >= lien.start + lien.duration) {\n    delta_t = uint256(lien.start + lien.duration - lien.last);\n  } else {\n    // @audit lien.last wasn't updated in `_payment`, so the `delta_t` is bigger here\n    delta_t = uint256(timestamp.safeCastTo32() - lien.last);\n  }\n  return\n    // @audit rate applied to a longer delta_t and multiplied by a bigger amount than expected\n    delta_t.mulDivDown(lien.rate, 1).mulDivDown(\n      lien.amount,\n      INTEREST_DENOMINATOR\n    );\n}\n```\n## Impact\nDouble counting of interest will result in a wrong lien slope, which will affect the vault's slope accumulator.  This will result in an invalid implied value of a vault ([PublicVault.sol#L406-L413](https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L406-L413)):\n1. If miscalculated lien slope is bigger than expected, vault's slope will be smaller than expected (due to the subtraction in `beforePayment`), and vault's implied value will also be smaller. Liquidity providers will lose money because they won't be able to redeem the whole liquidity (vault's implied value, `totalAssets`, is used in the conversion of LP shares, [ERC4626-Cloned.sol#L392-L412](https://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/ERC4626-Cloned.sol#L392-L412))\n1. If miscalculated lien slope is smaller than expected, vault's slope will be higher, and vaults implied value will also be higher. However, it won't be backed by actual liquidity, thus the liquidity providers that exit earlier will get a bigger share of the underlying assets. The last liquidity provider won't be able to get their entire share.\n\n## Code Snippet\nSee Vulnerability Detail\n## Tool used\nManual Review\n## Recommendation\nIn the `_payment` function, consider updating `lien.amount` after the `beforePayment` call:\n```diff\n--- a/src/LienToken.sol\n+++ b/src/LienToken.sol\n@@ -614,12 +614,13 @@ contract LienToken is ERC721, ILienToken, Auth, TransferAgent {\n       type(IPublicVault).interfaceId\n     );\n\n-    lien.amount = _getOwed(lien);\n-\n     address payee = getPayee(lienId);\n     if (isPublicVault) {\n       IPublicVault(lienOwner).beforePayment(lienId, paymentAmount);\n     }\n+\n+    lien.amount = _getOwed(lien);\n+\n     if (lien.amount > paymentAmount) {\n       lien.amount -= paymentAmount;\n       lien.last = block.timestamp.safeCastTo32();\n```\nIn this case, lien's slope calculation won't be affected in the `beforePayment` call and the correct slope will be removed from the slope accumulator.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/8",
  "Code": [
    {
      "filename": "src/LienToken.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n/**\n *       __  ___       __\n *  /\\  /__'  |   /\\  |__) |  /\\\n * /~~\\ .__/  |  /~~\\ |  \\ | /~~\\\n *\n * Copyright (c) Astaria Labs, Inc\n */\n\npragma solidity ^0.8.17;\n\npragma experimental ABIEncoderV2;\n\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {ERC721} from \"gpl/ERC721.sol\";\nimport {IAuctionHouse} from \"gpl/interfaces/IAuctionHouse.sol\";\nimport {IERC721, IERC165} from \"gpl/interfaces/IERC721.sol\";\nimport {ITransferProxy} from \"gpl/interfaces/ITransferProxy.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\nimport {Base64} from \"./libraries/Base64.sol\";\nimport {CollateralLookup} from \"./libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"./interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"./interfaces/ICollateralToken.sol\";\nimport {ILienBase, ILienToken} from \"./interfaces/ILienToken.sol\";\n\nimport {IPublicVault} from \"./PublicVault.sol\";\nimport {VaultImplementation} from \"./VaultImplementation.sol\";\n\ncontract TransferAgent {\n  address public immutable WETH;\n  ITransferProxy public immutable TRANSFER_PROXY;\n\n  constructor(ITransferProxy _TRANSFER_PROXY, address _WETH) {\n    TRANSFER_PROXY = _TRANSFER_PROXY;\n    WETH = _WETH;\n  }\n}\n\n/**\n * @title LienToken\n * @author androolloyd\n * @notice This contract handles the creation, payments, buyouts, and liquidations of tokenized NFT-collateralized debt (liens). Vaults which originate loans against supported collateral are issued a LienToken representing the right to loan repayments and auctioned funds on liquidation.\n */\ncontract LienToken is ERC721, ILienToken, Auth, TransferAgent {\n  using FixedPointMathLib for uint256;\n  using CollateralLookup for address;\n  using SafeCastLib for uint256;\n\n  IAuctionHouse public AUCTION_HOUSE;\n  IAstariaRouter public ASTARIA_ROUTER;\n  ICollateralToken public COLLATERAL_TOKEN;\n\n  uint256 INTEREST_DENOMINATOR = 1e18; //wad per second\n\n  uint256 constant MAX_LIENS = uint256(5);\n\n  mapping(uint256 => Lien) public lienData;\n  mapping(uint256 => uint256[]) public liens;\n\n  /**\n   * @dev Setup transfer authority and initialize the buyoutNumerator and buyoutDenominator for the lien buyout premium.\n   * @param _AUTHORITY The authority manager.\n   * @param _TRANSFER_PROXY The TransferProxy for balance transfers.\n   * @param _WETH The WETH address to use for transfers.\n   */\n  constructor(\n    Authority _AUTHORITY,\n    ITransferProxy _TRANSFER_PROXY,\n    address _WETH\n  )\n    Auth(address(msg.sender), _AUTHORITY)\n    TransferAgent(_TRANSFER_PROXY, _WETH)\n    ERC721(\"Astaria Lien Token\", \"ALT\")\n  {}\n\n  /**\n   * @notice Sets addresses for the AuctionHouse, CollateralToken, and AstariaRouter contracts to use.\n   * @param what The identifier for what is being filed.\n   * @param data The encoded address data to be decoded and filed.\n   */\n  function file(bytes32 what, bytes calldata data) external requiresAuth {\n    if (what == \"setAuctionHouse\") {\n      address addr = abi.decode(data, (address));\n      AUCTION_HOUSE = IAuctionHouse(addr);\n    } else if (what == \"setCollateralToken\") {\n      address addr = abi.decode(data, (address));\n      COLLATERAL_TOKEN = ICollateralToken(addr);\n    } else if (what == \"setAstariaRouter\") {\n      address addr = abi.decode(data, (address));\n      ASTARIA_ROUTER = IAstariaRouter(addr);\n    } else {\n      revert UnsupportedFile();\n    }\n    emit File(what, data);\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC721, IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(ILienToken).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @notice Purchase a LienToken for its buyout price.\n   * @param params The LienActionBuyout data specifying the lien position, receiver address, and underlying CollateralToken information of the lien.\n   */\n\n  function buyoutLien(ILienToken.LienActionBuyout calldata params) external {\n    (bool valid, IAstariaRouter.LienDetails memory ld) = ASTARIA_ROUTER\n      .validateCommitment(params.incoming);\n\n    if (!valid) {\n      revert InvalidTerms();\n    }\n\n    uint256 collateralId = params.incoming.tokenContract.computeId(\n      params.incoming.tokenId\n    );\n    (uint256 owed, uint256 buyout) = getBuyout(collateralId, params.position);\n    uint256 lienId = liens[collateralId][params.position];\n\n    //the borrower shouldn't incur more debt from the buyout than they already owe\n    if (ld.maxAmount < owed) {\n      revert InvalidBuyoutDetails(ld.maxAmount, owed);\n    }\n    if (!ASTARIA_ROUTER.isValidRefinance(lienData[lienId], ld)) {\n      revert InvalidRefinance();\n    }\n\n    TRANSFER_PROXY.tokenTransferFrom(\n      WETH,\n      address(msg.sender),\n      getPayee(lienId),\n      uint256(buyout)\n    );\n\n    lienData[lienId].last = block.timestamp.safeCastTo32();\n    lienData[lienId].start = block.timestamp.safeCastTo32();\n    lienData[lienId].rate = ld.rate.safeCastTo240();\n    lienData[lienId].duration = ld.duration.safeCastTo32();\n\n    _transfer(ownerOf(lienId), address(params.receiver), lienId);\n  }\n\n  /**\n   * @notice Public view function that computes the interest for a LienToken since its last payment.\n   * @param collateralId The ID of the underlying CollateralToken\n   * @param position The position of the lien to calculate interest for.\n   */\n  function getInterest(uint256 collateralId, uint256 position)\n    public\n    view\n    returns (uint256)\n  {\n    uint256 lien = liens[collateralId][position];\n    return _getInterest(lienData[lien], block.timestamp);\n  }\n\n  /**\n   * @dev Computes the interest accrued for a lien since its last payment.\n   * @param lien The Lien for the loan to calculate interest for.\n   * @param timestamp The timestamp at which to compute interest for.\n   */\n  function _getInterest(Lien memory lien, uint256 timestamp)\n    internal\n    view\n    returns (uint256)\n  {\n    if (!lien.active) {\n      return uint256(0);\n    }\n    uint256 delta_t;\n    if (block.timestamp >= lien.start + lien.duration) {\n      delta_t = uint256(lien.start + lien.duration - lien.last);\n    } else {\n      delta_t = uint256(timestamp.safeCastTo32() - lien.last);\n    }\n    return\n      delta_t.mulDivDown(lien.rate, 1).mulDivDown(\n        lien.amount,\n        INTEREST_DENOMINATOR\n      );\n  }\n\n  /**\n   * @notice Stops accruing interest for all liens against a single CollateralToken.\n   * @param collateralId The ID for the  CollateralToken of the NFT used as collateral for the liens.\n   */\n  function stopLiens(uint256 collateralId)\n    external\n    requiresAuth\n    returns (uint256 reserve, uint256[] memory lienIds)\n  {\n    reserve = 0;\n    lienIds = liens[collateralId];\n    for (uint256 i = 0; i < lienIds.length; ++i) {\n      Lien storage lien = lienData[lienIds[i]];\n      unchecked {\n        lien.amount = _getOwed(lien);\n        reserve += lien.amount;\n      }\n      lien.active = false;\n    }\n  }\n\n  /**\n   * @dev See {IERC721Metadata-tokenURI}.\n   */\n  function tokenURI(uint256 tokenId)\n    public\n    pure\n    override\n    returns (string memory)\n  {\n    return \"\";\n  }\n\n  /**\n   * @notice Creates a new lien against a CollateralToken.\n   * @param params LienActionEncumber data containing CollateralToken information and lien parameters (rate, duration, and amount, rate, and debt caps).\n   */\n  function createLien(ILienBase.LienActionEncumber memory params)\n    external\n    requiresAuth\n    returns (uint256 lienId)\n  {\n    // require that the auction is not under way\n\n    uint256 collateralId = params.tokenContract.computeId(params.tokenId);\n\n    if (AUCTION_HOUSE.auctionExists(collateralId)) {\n      revert InvalidCollateralState(InvalidStates.AUCTION);\n    }\n\n    (address tokenContract, ) = COLLATERAL_TOKEN.getUnderlying(collateralId);\n    if (tokenContract == address(0)) {\n      revert InvalidCollateralState(InvalidStates.NO_DEPOSIT);\n    }\n\n    uint256 totalDebt = getTotalDebtForCollateralToken(collateralId);\n    uint256 impliedRate = getImpliedRate(collateralId);\n\n    uint256 potentialDebt = totalDebt *\n      (impliedRate + 1) *\n      params.terms.duration;\n\n    if (potentialDebt > params.terms.maxPotentialDebt) {\n      revert InvalidCollateralState(InvalidStates.DEBT_LIMIT);\n    }\n\n    lienId = uint256(\n      keccak256(\n        abi.encodePacked(\n          abi.encode(\n            bytes32(collateralId),\n            params.vault,\n            WETH,\n            params.terms.maxAmount,\n            params.terms.rate,\n            params.terms.duration,\n            params.terms.maxPotentialDebt\n          ),\n          params.strategyRoot\n        )\n      )\n    );\n\n    //0 - 4 are valid\n    require(\n      uint256(liens[collateralId].length) < MAX_LIENS,\n      \"too many liens active\"\n    );\n\n    uint8 newPosition = uint8(liens[collateralId].length);\n\n    _mint(VaultImplementation(params.vault).recipient(), lienId);\n    lienData[lienId] = Lien({\n      collateralId: collateralId,\n      position: newPosition,\n      amount: params.amount,\n      active: true,\n      rate: params.terms.rate.safeCastTo240(),\n      last: block.timestamp.safeCastTo32(),\n      start: block.timestamp.safeCastTo32(),\n      duration: params.terms.duration.safeCastTo32(),\n      payee: address(0)\n    });\n\n    liens[collateralId].push(lienId);\n    emit NewLien(lienId, lienData[lienId]);\n  }\n\n  /**\n   * @notice Removes all liens for a given CollateralToken.\n   * @param collateralId The ID for the underlying CollateralToken.\n   * @param remainingLiens The IDs for the unpaid liens\n   */\n  function removeLiens(uint256 collateralId, uint256[] memory remainingLiens)\n    external\n    requiresAuth\n  {\n    for (uint256 i = 0; i < remainingLiens.length; i++) {\n      delete lienData[remainingLiens[i]];\n      _burn(remainingLiens[i]);\n    }\n    delete liens[collateralId];\n    emit RemovedLiens(collateralId);\n  }\n\n  /**\n   * @notice Retrieves all liens taken out against the underlying NFT of a CollateralToken.\n   * @param collateralId The ID for the underlying CollateralToken.\n   * @return The IDs of the liens against the CollateralToken.\n   */\n  function getLiens(uint256 collateralId)\n    public\n    view\n    returns (uint256[] memory)\n  {\n    return liens[collateralId];\n  }\n\n  /**\n   * @notice Retrieves a specific Lien by its ID.\n   * @param lienId The ID of the requested Lien.\n   * @return lien The Lien for the lienId.\n   */\n  function getLien(uint256 lienId) public view returns (Lien memory lien) {\n    lien = lienData[lienId];\n    lien.amount = _getOwed(lien);\n    lien.last = block.timestamp.safeCastTo32();\n  }\n\n  /**\n   * @notice Retrives a specific Lien from the ID of the CollateralToken for the underlying NFT and the lien position.\n   * @param collateralId The ID for the underlying CollateralToken.\n   * @param position The requested lien position.\n   *  @ return lien The Lien for the lienId.\n   */\n  function getLien(uint256 collateralId, uint256 position)\n    public\n    view\n    returns (Lien memory)\n  {\n    uint256 lienId = liens[collateralId][position];\n    return getLien(lienId);\n  }\n\n  /**\n   * @notice Computes and returns the buyout amount for a Lien.\n   * @param collateralId The ID for the underlying CollateralToken.\n   * @param position The position of the Lien to compute the buyout amount for.\n   * @return The outstanding debt for the lien and the buyout amount for the Lien.\n   */\n  function getBuyout(uint256 collateralId, uint256 position)\n    public\n    view\n    returns (uint256, uint256)\n  {\n    Lien memory lien = getLien(collateralId, position);\n\n    uint256 remainingInterest = _getRemainingInterest(lien, true);\n    uint256 buyoutTotal = lien.amount +\n      ASTARIA_ROUTER.getBuyoutFee(remainingInterest);\n\n    return (lien.amount, buyoutTotal);\n  }\n\n  /**\n   * @notice Make a payment for the debt against a CollateralToken.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @param paymentAmount The amount to pay against the debt.\n   */\n  function makePayment(uint256 collateralId, uint256 paymentAmount) public {\n    _makePayment(collateralId, paymentAmount);\n  }\n\n  /**\n   * @notice Make a payment for the debt against a CollateralToken for a specific lien.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @param paymentAmount The amount to pay against the debt.\n   * @param position The lien position to make a payment to.\n   */\n  function makePayment(\n    uint256 collateralId,\n    uint256 paymentAmount,\n    uint8 position\n  ) external {\n    _payment(collateralId, position, paymentAmount, address(msg.sender));\n  }\n\n  /**\n   * @notice Have a specified paymer make a payment for the debt against a CollateralToken.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @param totalCapitalAvailable The amount to pay against the debts\n   */\n  function _makePayment(uint256 collateralId, uint256 totalCapitalAvailable)\n    internal\n  {\n    uint256[] memory openLiens = liens[collateralId];\n    uint256 paymentAmount = totalCapitalAvailable;\n    for (uint256 i = 0; i < openLiens.length; ++i) {\n      uint256 capitalSpent = _payment(\n        collateralId,\n        uint8(i),\n        paymentAmount,\n        address(msg.sender)\n      );\n      paymentAmount -= capitalSpent;\n    }\n  }\n\n  function makePayment(\n    uint256 collateralId,\n    uint256 paymentAmount,\n    uint8 position,\n    address payer\n  ) public requiresAuth {\n    _payment(collateralId, position, paymentAmount, payer);\n  }\n\n  /**\n   * @notice Computes the rate for a specified lien.\n   * @param lienId The ID for the lien.\n   * @return The rate for the specified lien, in WETH per second.\n   */\n  function calculateSlope(uint256 lienId) public view returns (uint256) {\n    Lien memory lien = lienData[lienId];\n    uint256 end = (lien.start + lien.duration);\n    uint256 owedAtEnd = _getOwed(lien, end);\n    return (owedAtEnd - lien.amount).mulDivDown(1, end - lien.last);\n  }\n\n  /**\n   * @notice Computes the change in rate for a lien if a specific payment amount was made.\n   * @param lienId The ID for the lien.\n   * @param paymentAmount The hypothetical payment amount that would be made to the lien.\n   * @return slope The difference between the current lien rate and the lien rate if the payment was made.\n   */\n  function changeInSlope(uint256 lienId, uint256 paymentAmount)\n    public\n    view\n    returns (uint256 slope)\n  {\n    Lien memory lien = lienData[lienId];\n    uint256 oldSlope = calculateSlope(lienId);\n    uint256 newAmount = (lien.amount - paymentAmount);\n\n    // slope = (rate*time*amount - amount) / time -> amount(rate*time - 1) / time\n    uint256 newSlope = newAmount.mulDivDown(\n      (uint256(lien.rate).mulDivDown(lien.duration, 1) - 1),\n      lien.duration\n    );\n\n    slope = oldSlope - newSlope;\n  }\n\n  /**\n   * @notice Computes the total amount owed on all liens against a CollateralToken.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @return totalDebt The aggregate debt for all loans against the collateral.\n   */\n  function getTotalDebtForCollateralToken(uint256 collateralId)\n    public\n    view\n    returns (uint256 totalDebt)\n  {\n    uint256[] memory openLiens = getLiens(collateralId);\n    totalDebt = 0;\n    for (uint256 i = 0; i < openLiens.length; ++i) {\n      totalDebt += _getOwed(lienData[openLiens[i]]);\n    }\n  }\n\n  /**\n   * @notice Computes the total amount owed on all liens against a CollateralToken at a specified timestamp.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @param timestamp The timestamp to use to calculate owed debt.\n   * @return totalDebt The aggregate debt for all loans against the specified collateral at the specified timestamp.\n   */\n  function getTotalDebtForCollateralToken(\n    uint256 collateralId,\n    uint256 timestamp\n  ) public view returns (uint256 totalDebt) {\n    uint256[] memory openLiens = getLiens(collateralId);\n    totalDebt = 0;\n\n    for (uint256 i = 0; i < openLiens.length; ++i) {\n      totalDebt += _getOwed(lienData[openLiens[i]], timestamp);\n    }\n  }\n\n  /**\n   * @notice Computes the combined rate of all liens against a CollateralToken\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @return impliedRate The aggregate rate for all loans against the specified collateral.\n   */\n  function getImpliedRate(uint256 collateralId)\n    public\n    view\n    returns (uint256 impliedRate)\n  {\n    uint256 totalDebt = getTotalDebtForCollateralToken(collateralId);\n    uint256[] memory openLiens = getLiens(collateralId);\n    impliedRate = 0;\n    for (uint256 i = 0; i < openLiens.length; ++i) {\n      Lien memory lien = lienData[openLiens[i]];\n\n      impliedRate += lien.rate * lien.amount;\n    }\n\n    if (totalDebt > uint256(0)) {\n      impliedRate = impliedRate.mulDivDown(1, totalDebt);\n    }\n  }\n\n  /**\n   * @dev Computes the debt owed to a Lien.\n   * @param lien The specified Lien.\n   * @return The amount owed to the specified Lien.\n   */\n  function _getOwed(Lien memory lien) internal view returns (uint256) {\n    return _getOwed(lien, block.timestamp);\n  }\n\n  /**\n   * @dev Computes the debt owed to a Lien at a specified timestamp.\n   * @param lien The specified Lien.\n   * @return The amount owed to the Lien at the specified timestamp.\n   */\n  function _getOwed(Lien memory lien, uint256 timestamp)\n    internal\n    view\n    returns (uint256)\n  {\n    return lien.amount + _getInterest(lien, timestamp);\n  }\n\n  /**\n   * @dev Computes the interest still owed to a Lien.\n   * @param lien The specified Lien.\n   * @param buyout compute with a ceiling based on the buyout interest window\n   * @return The WETH still owed in interest to the Lien.\n   */\n  function _getRemainingInterest(Lien memory lien, bool buyout)\n    internal\n    view\n    returns (uint256)\n  {\n    uint256 end = lien.start + lien.duration;\n    if (buyout) {\n      uint32 getBuyoutInterestWindow = ASTARIA_ROUTER.getBuyoutInterestWindow();\n      if (\n        lien.start + lien.duration >= block.timestamp + getBuyoutInterestWindow\n      ) {\n        end = block.timestamp + getBuyoutInterestWindow;\n      }\n    }\n\n    uint256 delta_t = end - block.timestamp;\n\n    return\n      delta_t.mulDivDown(lien.rate, 1).mulDivDown(\n        lien.amount,\n        INTEREST_DENOMINATOR\n      );\n  }\n\n  function getInterest(uint256 lienId) public view returns (uint256) {\n    return _getInterest(lienData[lienId], block.timestamp);\n  }\n\n  /**\n   * @dev Make a payment from a payer to a specific lien against a CollateralToken.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @param position The position of the lien to make a payment to.\n   * @param paymentAmount The amount to pay against the debt.\n   * @param payer The address to make the payment.\n   * @return The paymentAmount for the payment.\n   */\n  function _payment(\n    uint256 collateralId,\n    uint8 position,\n    uint256 paymentAmount,\n    address payer\n  ) internal returns (uint256) {\n    if (paymentAmount == uint256(0)) {\n      return uint256(0);\n    }\n\n    uint256 lienId = liens[collateralId][position];\n    Lien storage lien = lienData[lienId];\n    uint256 end = (lien.start + lien.duration);\n    require(\n      block.timestamp < end || address(msg.sender) == address(AUCTION_HOUSE),\n      \"cannot pay off an expired lien\"\n    );\n\n    address lienOwner = ownerOf(lienId);\n    bool isPublicVault = IPublicVault(lienOwner).supportsInterface(\n      type(IPublicVault).interfaceId\n    );\n\n    lien.amount = _getOwed(lien);\n\n    address payee = getPayee(lienId);\n    if (isPublicVault) {\n      IPublicVault(lienOwner).beforePayment(lienId, paymentAmount);\n    }\n    if (lien.amount > paymentAmount) {\n      lien.amount -= paymentAmount;\n      lien.last = block.timestamp.safeCastTo32();\n      // slope does not need to be updated if paying off the rest, since we neutralize slope in beforePayment()\n      if (isPublicVault) {\n        IPublicVault(lienOwner).afterPayment(lienId);\n      }\n    } else {\n      if (isPublicVault && !AUCTION_HOUSE.auctionExists(collateralId)) {\n        // since the openLiens count is only positive when there are liens that haven't been paid off\n        // that should be liquidated, this lien should not be counted anymore\n        IPublicVault(lienOwner).decreaseEpochLienCount(\n          IPublicVault(lienOwner).getLienEpoch(end)\n        );\n      }\n      //delete liens\n      _deleteLienPosition(collateralId, position);\n      delete lienData[lienId]; //full delete\n\n      _burn(lienId);\n    }\n\n    TRANSFER_PROXY.tokenTransferFrom(WETH, payer, payee, paymentAmount);\n\n    emit Payment(lienId, paymentAmount);\n    return paymentAmount;\n  }\n\n  function _deleteLienPosition(uint256 collateralId, uint256 position) public {\n    uint256[] storage stack = liens[collateralId];\n    require(position < stack.length, \"index out of bounds\");\n\n    emit RemoveLien(\n      stack[position],\n      lienData[stack[position]].collateralId,\n      lienData[stack[position]].position\n    );\n    for (uint256 i = position; i < stack.length - 1; i++) {\n      stack[i] = stack[i + 1];\n    }\n    stack.pop();\n  }\n\n  /**\n   * @notice Retrieve the payee (address that receives payments and auction funds) for a specified Lien.\n   * @param lienId The ID of the Lien.\n   * @return The address of the payee for the Lien.\n   */\n  function getPayee(uint256 lienId) public view returns (address) {\n    return\n      lienData[lienId].payee != address(0)\n        ? lienData[lienId].payee\n        : ownerOf(lienId);\n  }\n\n  /**\n   * @notice Change the payee for a specified Lien.\n   * @param lienId The ID of the Lien.\n   * @param newPayee The new Lien payee.\n   */\n  function setPayee(uint256 lienId, address newPayee) public {\n    if (AUCTION_HOUSE.auctionExists(lienData[lienId].collateralId)) {\n      revert InvalidCollateralState(InvalidStates.AUCTION);\n    }\n    require(\n      !AUCTION_HOUSE.auctionExists(lienData[lienId].collateralId),\n      \"collateralId is being liquidated, cannot change payee from LiquidationAccountant\"\n    );\n    require(\n      msg.sender == ownerOf(lienId) || msg.sender == address(ASTARIA_ROUTER),\n      \"invalid owner\"\n    );\n\n    lienData[lienId].payee = newPayee;\n    emit PayeeChanged(lienId, newPayee);\n  }\n}"
    },
    {
      "filename": "src/LienToken.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n/**\n *       __  ___       __\n *  /\\  /__'  |   /\\  |__) |  /\\\n * /~~\\ .__/  |  /~~\\ |  \\ | /~~\\\n *\n * Copyright (c) Astaria Labs, Inc\n */\n\npragma solidity ^0.8.17;\n\npragma experimental ABIEncoderV2;\n\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {ERC721} from \"gpl/ERC721.sol\";\nimport {IAuctionHouse} from \"gpl/interfaces/IAuctionHouse.sol\";\nimport {IERC721, IERC165} from \"gpl/interfaces/IERC721.sol\";\nimport {ITransferProxy} from \"gpl/interfaces/ITransferProxy.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\nimport {Base64} from \"./libraries/Base64.sol\";\nimport {CollateralLookup} from \"./libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"./interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"./interfaces/ICollateralToken.sol\";\nimport {ILienBase, ILienToken} from \"./interfaces/ILienToken.sol\";\n\nimport {IPublicVault} from \"./PublicVault.sol\";\nimport {VaultImplementation} from \"./VaultImplementation.sol\";\n\ncontract TransferAgent {\n  address public immutable WETH;\n  ITransferProxy public immutable TRANSFER_PROXY;\n\n  constructor(ITransferProxy _TRANSFER_PROXY, address _WETH) {\n    TRANSFER_PROXY = _TRANSFER_PROXY;\n    WETH = _WETH;\n  }\n}\n\n/**\n * @title LienToken\n * @author androolloyd\n * @notice This contract handles the creation, payments, buyouts, and liquidations of tokenized NFT-collateralized debt (liens). Vaults which originate loans against supported collateral are issued a LienToken representing the right to loan repayments and auctioned funds on liquidation.\n */\ncontract LienToken is ERC721, ILienToken, Auth, TransferAgent {\n  using FixedPointMathLib for uint256;\n  using CollateralLookup for address;\n  using SafeCastLib for uint256;\n\n  IAuctionHouse public AUCTION_HOUSE;\n  IAstariaRouter public ASTARIA_ROUTER;\n  ICollateralToken public COLLATERAL_TOKEN;\n\n  uint256 INTEREST_DENOMINATOR = 1e18; //wad per second\n\n  uint256 constant MAX_LIENS = uint256(5);\n\n  mapping(uint256 => Lien) public lienData;\n  mapping(uint256 => uint256[]) public liens;\n\n  /**\n   * @dev Setup transfer authority and initialize the buyoutNumerator and buyoutDenominator for the lien buyout premium.\n   * @param _AUTHORITY The authority manager.\n   * @param _TRANSFER_PROXY The TransferProxy for balance transfers.\n   * @param _WETH The WETH address to use for transfers.\n   */\n  constructor(\n    Authority _AUTHORITY,\n    ITransferProxy _TRANSFER_PROXY,\n    address _WETH\n  )\n    Auth(address(msg.sender), _AUTHORITY)\n    TransferAgent(_TRANSFER_PROXY, _WETH)\n    ERC721(\"Astaria Lien Token\", \"ALT\")\n  {}\n\n  /**\n   * @notice Sets addresses for the AuctionHouse, CollateralToken, and AstariaRouter contracts to use.\n   * @param what The identifier for what is being filed.\n   * @param data The encoded address data to be decoded and filed.\n   */\n  function file(bytes32 what, bytes calldata data) external requiresAuth {\n    if (what == \"setAuctionHouse\") {\n      address addr = abi.decode(data, (address));\n      AUCTION_HOUSE = IAuctionHouse(addr);\n    } else if (what == \"setCollateralToken\") {\n      address addr = abi.decode(data, (address));\n      COLLATERAL_TOKEN = ICollateralToken(addr);\n    } else if (what == \"setAstariaRouter\") {\n      address addr = abi.decode(data, (address));\n      ASTARIA_ROUTER = IAstariaRouter(addr);\n    } else {\n      revert UnsupportedFile();\n    }\n    emit File(what, data);\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC721, IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(ILienToken).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @notice Purchase a LienToken for its buyout price.\n   * @param params The LienActionBuyout data specifying the lien position, receiver address, and underlying CollateralToken information of the lien.\n   */\n\n  function buyoutLien(ILienToken.LienActionBuyout calldata params) external {\n    (bool valid, IAstariaRouter.LienDetails memory ld) = ASTARIA_ROUTER\n      .validateCommitment(params.incoming);\n\n    if (!valid) {\n      revert InvalidTerms();\n    }\n\n    uint256 collateralId = params.incoming.tokenContract.computeId(\n      params.incoming.tokenId\n    );\n    (uint256 owed, uint256 buyout) = getBuyout(collateralId, params.position);\n    uint256 lienId = liens[collateralId][params.position];\n\n    //the borrower shouldn't incur more debt from the buyout than they already owe\n    if (ld.maxAmount < owed) {\n      revert InvalidBuyoutDetails(ld.maxAmount, owed);\n    }\n    if (!ASTARIA_ROUTER.isValidRefinance(lienData[lienId], ld)) {\n      revert InvalidRefinance();\n    }\n\n    TRANSFER_PROXY.tokenTransferFrom(\n      WETH,\n      address(msg.sender),\n      getPayee(lienId),\n      uint256(buyout)\n    );\n\n    lienData[lienId].last = block.timestamp.safeCastTo32();\n    lienData[lienId].start = block.timestamp.safeCastTo32();\n    lienData[lienId].rate = ld.rate.safeCastTo240();\n    lienData[lienId].duration = ld.duration.safeCastTo32();\n\n    _transfer(ownerOf(lienId), address(params.receiver), lienId);\n  }\n\n  /**\n   * @notice Public view function that computes the interest for a LienToken since its last payment.\n   * @param collateralId The ID of the underlying CollateralToken\n   * @param position The position of the lien to calculate interest for.\n   */\n  function getInterest(uint256 collateralId, uint256 position)\n    public\n    view\n    returns (uint256)\n  {\n    uint256 lien = liens[collateralId][position];\n    return _getInterest(lienData[lien], block.timestamp);\n  }\n\n  /**\n   * @dev Computes the interest accrued for a lien since its last payment.\n   * @param lien The Lien for the loan to calculate interest for.\n   * @param timestamp The timestamp at which to compute interest for.\n   */\n  function _getInterest(Lien memory lien, uint256 timestamp)\n    internal\n    view\n    returns (uint256)\n  {\n    if (!lien.active) {\n      return uint256(0);\n    }\n    uint256 delta_t;\n    if (block.timestamp >= lien.start + lien.duration) {\n      delta_t = uint256(lien.start + lien.duration - lien.last);\n    } else {\n      delta_t = uint256(timestamp.safeCastTo32() - lien.last);\n    }\n    return\n      delta_t.mulDivDown(lien.rate, 1).mulDivDown(\n        lien.amount,\n        INTEREST_DENOMINATOR\n      );\n  }\n\n  /**\n   * @notice Stops accruing interest for all liens against a single CollateralToken.\n   * @param collateralId The ID for the  CollateralToken of the NFT used as collateral for the liens.\n   */\n  function stopLiens(uint256 collateralId)\n    external\n    requiresAuth\n    returns (uint256 reserve, uint256[] memory lienIds)\n  {\n    reserve = 0;\n    lienIds = liens[collateralId];\n    for (uint256 i = 0; i < lienIds.length; ++i) {\n      Lien storage lien = lienData[lienIds[i]];\n      unchecked {\n        lien.amount = _getOwed(lien);\n        reserve += lien.amount;\n      }\n      lien.active = false;\n    }\n  }\n\n  /**\n   * @dev See {IERC721Metadata-tokenURI}.\n   */\n  function tokenURI(uint256 tokenId)\n    public\n    pure\n    override\n    returns (string memory)\n  {\n    return \"\";\n  }\n\n  /**\n   * @notice Creates a new lien against a CollateralToken.\n   * @param params LienActionEncumber data containing CollateralToken information and lien parameters (rate, duration, and amount, rate, and debt caps).\n   */\n  function createLien(ILienBase.LienActionEncumber memory params)\n    external\n    requiresAuth\n    returns (uint256 lienId)\n  {\n    // require that the auction is not under way\n\n    uint256 collateralId = params.tokenContract.computeId(params.tokenId);\n\n    if (AUCTION_HOUSE.auctionExists(collateralId)) {\n      revert InvalidCollateralState(InvalidStates.AUCTION);\n    }\n\n    (address tokenContract, ) = COLLATERAL_TOKEN.getUnderlying(collateralId);\n    if (tokenContract == address(0)) {\n      revert InvalidCollateralState(InvalidStates.NO_DEPOSIT);\n    }\n\n    uint256 totalDebt = getTotalDebtForCollateralToken(collateralId);\n    uint256 impliedRate = getImpliedRate(collateralId);\n\n    uint256 potentialDebt = totalDebt *\n      (impliedRate + 1) *\n      params.terms.duration;\n\n    if (potentialDebt > params.terms.maxPotentialDebt) {\n      revert InvalidCollateralState(InvalidStates.DEBT_LIMIT);\n    }\n\n    lienId = uint256(\n      keccak256(\n        abi.encodePacked(\n          abi.encode(\n            bytes32(collateralId),\n            params.vault,\n            WETH,\n            params.terms.maxAmount,\n            params.terms.rate,\n            params.terms.duration,\n            params.terms.maxPotentialDebt\n          ),\n          params.strategyRoot\n        )\n      )\n    );\n\n    //0 - 4 are valid\n    require(\n      uint256(liens[collateralId].length) < MAX_LIENS,\n      \"too many liens active\"\n    );\n\n    uint8 newPosition = uint8(liens[collateralId].length);\n\n    _mint(VaultImplementation(params.vault).recipient(), lienId);\n    lienData[lienId] = Lien({\n      collateralId: collateralId,\n      position: newPosition,\n      amount: params.amount,\n      active: true,\n      rate: params.terms.rate.safeCastTo240(),\n      last: block.timestamp.safeCastTo32(),\n      start: block.timestamp.safeCastTo32(),\n      duration: params.terms.duration.safeCastTo32(),\n      payee: address(0)\n    });\n\n    liens[collateralId].push(lienId);\n    emit NewLien(lienId, lienData[lienId]);\n  }\n\n  /**\n   * @notice Removes all liens for a given CollateralToken.\n   * @param collateralId The ID for the underlying CollateralToken.\n   * @param remainingLiens The IDs for the unpaid liens\n   */\n  function removeLiens(uint256 collateralId, uint256[] memory remainingLiens)\n    external\n    requiresAuth\n  {\n    for (uint256 i = 0; i < remainingLiens.length; i++) {\n      delete lienData[remainingLiens[i]];\n      _burn(remainingLiens[i]);\n    }\n    delete liens[collateralId];\n    emit RemovedLiens(collateralId);\n  }\n\n  /**\n   * @notice Retrieves all liens taken out against the underlying NFT of a CollateralToken.\n   * @param collateralId The ID for the underlying CollateralToken.\n   * @return The IDs of the liens against the CollateralToken.\n   */\n  function getLiens(uint256 collateralId)\n    public\n    view\n    returns (uint256[] memory)\n  {\n    return liens[collateralId];\n  }\n\n  /**\n   * @notice Retrieves a specific Lien by its ID.\n   * @param lienId The ID of the requested Lien."
    }
  ]
}