{
  "Title": "[L-04] sendSignal() calls can be spammed by attacker to relayer",
  "Content": "\n[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/signal/SignalService.sol#L63)\n\nSince the function is external, an attacker can continuously spam signals to the offchain relayer which is always listening to signals. This would be more cost efficient on Taiko where fees are cheap.\n\nThe signals could also be used to mess with the relayer service i.e. by sending a the same signal early by frontrunning a user's bytes32 signal _parameter.\n```solidity\nFile: SignalService.sol\n68:     function sendSignal(bytes32 _signal) external returns (bytes32) {\n69:         return _sendSignal(msg.sender, _signal, _signal);\n70:     }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-taiko",
  "Code": [
    {
      "filename": "packages/protocol/contracts/signal/SignalService.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../common/EssentialContract.sol\";\nimport \"../libs/LibTrieProof.sol\";\nimport \"./ISignalService.sol\";\nimport \"./LibSignals.sol\";\n\n/// @title SignalService\n/// @notice See the documentation in {ISignalService} for more details.\n/// @dev Labeled in AddressResolver as \"signal_service\".\n/// @custom:security-contact security@taiko.xyz\ncontract SignalService is EssentialContract, ISignalService {\n    /// @notice Mapping to store the top blockId.\n    /// @dev Slot 1.\n    mapping(uint64 chainId => mapping(bytes32 kind => uint64 blockId)) public topBlockId;\n\n    /// @notice Mapping to store the authorized addresses.\n    /// @dev Slot 2.\n    mapping(address addr => bool authorized) public isAuthorized;\n\n    uint256[48] private __gap;\n\n    error SS_EMPTY_PROOF();\n    error SS_INVALID_SENDER();\n    error SS_INVALID_LAST_HOP_CHAINID();\n    error SS_INVALID_MID_HOP_CHAINID();\n    error SS_INVALID_STATE();\n    error SS_INVALID_VALUE();\n    error SS_SIGNAL_NOT_FOUND();\n    error SS_UNAUTHORIZED();\n    error SS_UNSUPPORTED();\n\n    modifier validSender(address _app) {\n        if (_app == address(0)) revert SS_INVALID_SENDER();\n        _;\n    }\n\n    modifier nonZeroValue(bytes32 _input) {\n        if (_input == 0) revert SS_INVALID_VALUE();\n        _;\n    }\n\n    /// @notice Initializes the contract.\n    /// @param _owner The owner of this contract. msg.sender will be used if this value is zero.\n    /// @param _addressManager The address of the {AddressManager} contract.\n    function init(address _owner, address _addressManager) external initializer {\n        __Essential_init(_owner, _addressManager);\n    }\n\n    /// @dev Authorize or deauthorize an address for calling syncChainData.\n    /// @dev Note that addr is supposed to be TaikoL1 and TaikoL1 contracts deployed locally.\n    /// @param _addr The address to be authorized or deauthorized.\n    /// @param _authorize True if authorize, false otherwise.\n    function authorize(address _addr, bool _authorize) external onlyOwner {\n        if (isAuthorized[_addr] == _authorize) revert SS_INVALID_STATE();\n        isAuthorized[_addr] = _authorize;\n        emit Authorized(_addr, _authorize);\n    }\n\n    /// @inheritdoc ISignalService\n    function sendSignal(bytes32 _signal) external returns (bytes32) {\n        return _sendSignal(msg.sender, _signal, _signal);\n    }\n\n    /// @inheritdoc ISignalService\n    function syncChainData(\n        uint64 _chainId,\n        bytes32 _kind,\n        uint64 _blockId,\n        bytes32 _chainData\n    )\n        external\n        returns (bytes32)\n    {\n        if (!isAuthorized[msg.sender]) revert SS_UNAUTHORIZED();\n        return _syncChainData(_chainId, _kind, _blockId, _chainData);\n    }\n\n    /// @inheritdoc ISignalService\n    /// @dev This function may revert.\n    function proveSignalReceived(\n        uint64 _chainId,\n        address _app,\n        bytes32 _signal,\n        bytes calldata _proof\n    )\n        public\n        virtual\n        validSender(_app)\n        nonZeroValue(_signal)\n    {\n        HopProof[] memory hopProofs = abi.decode(_proof, (HopProof[]));\n        if (hopProofs.length == 0) revert SS_EMPTY_PROOF();\n\n        uint64 chainId = _chainId;\n        address app = _app;\n        bytes32 signal = _signal;\n        bytes32 value = _signal;\n        address signalService = resolve(chainId, \"signal_service\", false);\n\n        HopProof memory hop;\n        for (uint256 i; i < hopProofs.length; ++i) {\n            hop = hopProofs[i];\n\n            bytes32 signalRoot = _verifyHopProof(chainId, app, signal, value, hop, signalService);\n            bool isLastHop = i == hopProofs.length - 1;\n\n            if (isLastHop) {\n                if (hop.chainId != block.chainid) revert SS_INVALID_LAST_HOP_CHAINID();\n                signalService = address(this);\n            } else {\n                if (hop.chainId == 0 || hop.chainId == block.chainid) {\n                    revert SS_INVALID_MID_HOP_CHAINID();\n                }\n                signalService = resolve(hop.chainId, \"signal_service\", false);\n            }\n\n            bool isFullProof = hop.accountProof.length > 0;\n\n            _cacheChainData(hop, chainId, hop.blockId, signalRoot, isFullProof, isLastHop);\n\n            bytes32 kind = isFullProof ? LibSignals.STATE_ROOT : LibSignals.SIGNAL_ROOT;\n            signal = signalForChainData(chainId, kind, hop.blockId);\n            value = hop.rootHash;\n            chainId = hop.chainId;\n            app = signalService;\n        }\n\n        if (value == 0 || value != _loadSignalValue(address(this), signal)) {\n            revert SS_SIGNAL_NOT_FOUND();\n        }\n    }\n\n    /// @inheritdoc ISignalService\n    function isChainDataSynced(\n        uint64 _chainId,\n        bytes32 _kind,\n        uint64 _blockId,\n        bytes32 _chainData\n    )\n        public\n        view\n        nonZeroValue(_chainData)\n        returns (bool)\n    {\n        bytes32 signal = signalForChainData(_chainId, _kind, _blockId);\n        return _loadSignalValue(address(this), signal) == _chainData;\n    }\n\n    /// @inheritdoc ISignalService\n    function isSignalSent(address _app, bytes32 _signal) public view returns (bool) {\n        return _loadSignalValue(_app, _signal) != 0;\n    }\n\n    /// @inheritdoc ISignalService\n    function getSyncedChainData(\n        uint64 _chainId,\n        bytes32 _kind,\n        uint64 _blockId\n    )\n        public\n        view\n        returns (uint64 blockId_, bytes32 chainData_)\n    {\n        blockId_ = _blockId != 0 ? _blockId : topBlockId[_chainId][_kind];\n\n        if (blockId_ != 0) {\n            bytes32 signal = signalForChainData(_chainId, _kind, blockId_);\n            chainData_ = _loadSignalValue(address(this), signal);\n            if (chainData_ == 0) revert SS_SIGNAL_NOT_FOUND();\n        }\n    }\n\n    /// @inheritdoc ISignalService\n    function signalForChainData(\n        uint64 _chainId,\n        bytes32 _kind,\n        uint64 _blockId\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(_chainId, _kind, _blockId));\n    }\n\n    /// @notice Returns the slot for a signal.\n    /// @param _chainId The chainId of the signal.\n    /// @param _app The address that initiated the signal.\n    /// @param _signal The signal (message) that was sent.\n    /// @return The slot for the signal.\n    function getSignalSlot(\n        uint64 _chainId,\n        address _app,\n        bytes32 _signal\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(\"SIGNAL\", _chainId, _app, _signal));\n    }\n\n    function _verifyHopProof(\n        uint64 _chainId,\n        address _app,\n        bytes32 _signal,\n        bytes32 _value,\n        HopProof memory _hop,\n        address _signalService\n    )\n        internal\n        virtual\n        validSender(_app)\n        nonZeroValue(_signal)\n        nonZeroValue(_value)\n        returns (bytes32)\n    {\n        return LibTrieProof.verifyMerkleProof(\n            _hop.rootHash,\n            _signalService,\n            getSignalSlot(_chainId, _app, _signal),\n            _value,\n            _hop.accountProof,\n            _hop.storageProof\n        );\n    }\n\n    function _authorizePause(address) internal pure override {\n        revert SS_UNSUPPORTED();\n    }\n\n    function _syncChainData(\n        uint64 _chainId,\n        bytes32 _kind,\n        uint64 _blockId,\n        bytes32 _chainData\n    )\n        private\n        returns (bytes32 signal_)\n    {\n        signal_ = signalForChainData(_chainId, _kind, _blockId);\n        _sendSignal(address(this), signal_, _chainData);\n\n        if (topBlockId[_chainId][_kind] < _blockId) {\n            topBlockId[_chainId][_kind] = _blockId;\n        }\n        emit ChainDataSynced(_chainId, _blockId, _kind, _chainData, signal_);\n    }\n\n    function _sendSignal(\n        address _app,\n        bytes32 _signal,\n        bytes32 _value\n    )\n        private\n        validSender(_app)\n        nonZeroValue(_signal)\n        nonZeroValue(_value)\n        returns (bytes32 slot_)\n    {\n        slot_ = getSignalSlot(uint64(block.chainid), _app, _signal);\n        assembly {\n            sstore(slot_, _value)\n        }\n        emit SignalSent(_app, _signal, slot_, _value);\n    }\n\n    function _cacheChainData(\n        HopProof memory _hop,\n        uint64 _chainId,\n        uint64 _blockId,\n        bytes32 _signalRoot,\n        bool _isFullProof,\n        bool _isLastHop\n    )\n        private\n    {\n        // cache state root\n        bool cacheStateRoot = _hop.cacheOption == CacheOption.CACHE_BOTH\n            || _hop.cacheOption == CacheOption.CACHE_STATE_ROOT;\n\n        if (cacheStateRoot && _isFullProof && !_isLastHop) {\n            _syncChainData(_chainId, LibSignals.STATE_ROOT, _blockId, _hop.rootHash);\n        }\n\n        // cache signal root\n        bool cacheSignalRoot = _hop.cacheOption == CacheOption.CACHE_BOTH\n            || _hop.cacheOption == CacheOption.CACHE_SIGNAL_ROOT;\n\n        if (cacheSignalRoot && (_isFullProof || !_isLastHop)) {\n            _syncChainData(_chainId, LibSignals.SIGNAL_ROOT, _blockId, _signalRoot);\n        }\n    }\n\n    function _loadSignalValue(\n        address _app,\n        bytes32 _signal\n    )\n        private\n        view\n        validSender(_app)\n        nonZeroValue(_signal)\n        returns (bytes32 value_)\n    {\n        bytes32 slot = getSignalSlot(uint64(block.chainid), _app, _signal);\n        assembly {\n            value_ := sload(slot)\n        }\n    }\n}"
    }
  ]
}