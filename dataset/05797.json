{
  "Title": "[N-04] Typo error in comments",
  "Content": "\n*There are 9 instances of this issue:*\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/interfaces/IRootBridgeAgent.sol#L50C1-L51C68\n\nCorrect \"singned\" to \"signed\".\n\n```solidity\nFile: IRootBridgeAgent.sol\n50:  *       0x04 | Call to Root Router without Deposit + singned message.\n51:  *       0x05 | Call to Root Router with Deposit + singned message.\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/RootPort.sol#L42C1-L44C1\n\nCorrect \"core router\" to \"core root bridge agent\".\n\n```solidity\nFile: RootPort.sol\n43:     /// @notice The address of the core router in charge of adding new tokens to the system.\n44:     address public coreRootBridgeAgentAddress;\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/RootPort.sol#L60\n\nCorrect \"Mapping from address to BridgeAgent\" to \"Mapping from chainId to IsActive (bool)\".\n\n```solidity\nFile: RootPort.sol\n61:     /// @notice Mapping from address to Bridge Agent. \n62:     mapping(uint256 chainId => bool isActive) public isChainId;\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/RootBridgeAgent.sol#L64\n\nCorrect \"Layerzer Zero\" to \"LayerZero\".\n\n```solidity\nFile: RootBridgeAgent.sol\n65:     /// @notice Message Path for each connected Branch Bridge Agent as bytes for Layzer Zero interaction = localAddress + destinationAddress abi.encodePacked()\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/CoreRootRouter.sol#L153\n\nCorrect the below statement to \"@param _dstChainId Chain Id of the branch chain for the bridge agent to be toggled\".\n\n```solidity\nFile: src/CoreRootRouter.sol\n153:      * @param _dstChainId Chain Id of the branch chain where the new Bridge Agent will be deployed.\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/CoreRootRouter.sol#L183\n\nCorrect below comment to \"@param _dstChainId Chain Id of the branch chain for the bridge agent to be removed\".\n\n```solidity\nFile: src/CoreRootRouter.sol\n183:      * @param _dstChainId Chain Id of the branch chain where the new Bridge Agent will be deployed.\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchPort.sol#L177\n\nCorrect \"startegy\" to \"strategy\".\n\n```solidity\nFile: BranchPort.sol\n178:  // Withdraw tokens from startegy \n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchBridgeAgent.sol#L86C1-L87C76\n\nCorrect \"deposits hash\" to \"deposits nonce\".\n\n```solidity\nFile: src/BranchBridgeAgent.sol\n86:     /// @notice Mapping from Pending deposits hash to Deposit Struct.\n87:     mapping(uint256 depositNonce => Deposit depositInfo) public getDeposit;\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-09-maia",
  "Code": [
    {
      "filename": "src/interfaces/IRootBridgeAgent.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ILayerZeroReceiver} from \"./ILayerZeroReceiver.sol\";\n\nimport {\n    GasParams,\n    DepositParams,\n    DepositMultipleParams,\n    Settlement,\n    SettlementInput,\n    SettlementMultipleInput,\n    SettlementParams\n} from \"./BridgeAgentStructs.sol\";\n\n/*///////////////////////////////////////////////////////////////\n                            ENUMS\n//////////////////////////////////////////////////////////////*/\n\n/**\n * @title  Root Bridge Agent Contract\n * @author MaiaDAO\n * @notice Contract responsible for interfacing with Users and Routers acting as a middleman to\n *         access LayerZero cross-chain messaging and Port communication for asset management.\n * @dev    Bridge Agents allow for the encapsulation of business logic as well as the standardized\n *         cross-chain communication, allowing for the creation of custom Routers to perform\n *         actions as a response to remote user requests. This contract is for deployment in the Root\n *         Chain Omnichain Environment based on Arbitrum.\n *         The Root Bridge Agent is responsible for sending/receiving requests to/from the LayerZero Messaging Layer for\n *         execution, as well as requests tokens clearances and tx execution from the `RootBridgeAgentExecutor`.\n *         Remote execution is \"sandboxed\" within 2 different layers/nestings:\n *         - 1: Upon receiving a request from LayerZero Messaging Layer to avoid blocking future requests due\n *              to execution reversion, ensuring our app is Non-Blocking.\n *              (See https://github.com/LayerZero-Labs/solidity-examples/blob/8e62ebc886407aafc89dbd2a778e61b7c0a25ca0/contracts/lzApp/NonblockingLzApp.sol)\n *         - 2: The call to `RootBridgeAgentExecutor` is in charge of requesting token deposits for each\n *              remote interaction as well as performing the Router calls if any of the calls initiated\n *              by the Router led to an invalid state change in both the token deposit clearances as well as\n *              the external interactions will be reverted and caught by the `RootBridgeAgent`.\n *\n *          Func IDs for calling these  functions through the messaging layer:\n *\n *       ROOT BRIDGE AGENT DEPOSIT FLAGS\n *       ------------------------------\n *       ID   | DESCRIPTION\n *       -----+------------------------\n *       0x00 | Branch Router System Request / Response.\n *       0x01 | Call to Root Router without Deposit.\n *       0x02 | Call to Root Router with Deposit.\n *       0x03 | Call to Root Router with Deposit of Multiple Tokens.\n *       0x04 | Call to Root Router without Deposit + singned message.\n *       0x05 | Call to Root Router with Deposit + singned message.\n *       0x06 | Call to Root Router with Deposit of Multiple Tokens + signed message.\n *       0x07 | Call to `retrySettlement()´. (retries sending a settlement w/ new calldata for execution + new gas)\n *       0x08 | Call to `retrieveDeposit()´. (clears a deposit that has not been executed yet triggering `_fallback`)\n *       0x09 | Call to `_fallback()`. (reopens a settlement for asset redemption)\n *\n *\n *          Encoding Scheme for different Root Bridge Agent Deposit Flags:\n *\n *           - ht = hToken\n *           - t = Token\n *           - A = Amount\n *           - D = Deposit\n *           - b = bytes\n *           - n = number of assets\n *       _____________________________________________________________________________________________________________\n *      |            Flag               |        Deposit Info        |             Token Info             |   DATA   |\n *      |           1 byte              |         4-25 bytes         |       104 or (128 * n) bytes       |   ---\t |\n *      |                               |                            |           hT - t - A - D           |          |\n *      |_______________________________|____________________________|____________________________________|__________|\n *      | callOutSystem = 0x0   \t    |                 4b(nonce)  |            -------------           |   ---\t |\n *      | callOut = 0x1                 |                 4b(nonce)  |            -------------           |   ---\t |\n *      | callOutSingle = 0x2           |                 4b(nonce)  |        20b + 20b + 32b + 32b       |   ---\t |\n *      | callOutMulti = 0x3            |         1b(n) + 4b(nonce)  |   \t  32b + 32b + 32b + 32b       |   ---\t |\n *      | callOutSigned = 0x4           |    20b(recip) + 4b(nonce)  |   \t      -------------           |   ---    |\n *      | callOutSignedSingle = 0x5     |           20b + 4b(nonce)  |        20b + 20b + 32b + 32b       |   ---\t |\n *      | callOutSignedMultiple = 0x6   |   20b + 1b(n) + 4b(nonce)  |        32b + 32b + 32b + 32b       |   ---\t |\n *      |_______________________________|____________________________|____________________________________|__________|\n *\n *          Generic Contract Interaction Flow:\n *\n *                 BridgeAgent.lzReceive()\n *                           |\n *                           V\n *              BridgeAgentExecutor.execute**()\n *                           |\n *                           V\n *                   Router.execute**()\n *                           |\n *                           V\n *            BridgeAgentExecutor (txExecuted)\n *\n */\ninterface IRootBridgeAgent is ILayerZeroReceiver {\n    /*///////////////////////////////////////////////////////////////\n                            VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function that returns the current settlement nonce.\n     *   @return nonce bridge agent's current settlement nonce\n     *\n     */\n    function settlementNonce() external view returns (uint32 nonce);\n\n    /**\n     * @notice External function that returns a given settlement entry.\n     *   @param _settlementNonce Identifier for token settlement.\n     *\n     */\n    function getSettlementEntry(uint32 _settlementNonce) external view returns (Settlement memory);\n\n    /**\n     * @notice External function to get the Bridge Agent Executor Address.\n     * @return address Bridge Agent Executor Address.\n     */\n    function bridgeAgentExecutorAddress() external view returns (address);\n\n    /**\n     * @notice External function to get the Root Bridge Agent's Factory Address.\n     *   @return address Root Bridge Agent's Factory Address.\n     */\n    function factoryAddress() external view returns (address);\n\n    /**\n     * @notice External function to get the attached Branch Bridge Agent for a given chain.\n     *   @param _chainId Chain ID of the Branch Bridge Agent.\n     *   @return address Branch Bridge Agent Address.\n     */\n    function getBranchBridgeAgent(uint256 _chainId) external view returns (address);\n\n    /**\n     * @notice External function to verify a given chain has been allowed by the Root Bridge Agent's Manager\n     *         for new Branch Bridge Agent creation.\n     *   @param _chainId Chain ID of the Branch Bridge Agent.\n     *   @return bool True if the chain has been allowed for new Branch Bridge Agent creation.\n     */\n    function isBranchBridgeAgentAllowed(uint256 _chainId) external view returns (bool);\n\n    /**\n     * @notice External function that returns the message value needed for a cross-chain call according to\n     *         the destination chain and the given calldata and gas requirements.\n     *   @param _dstChainId destination Chain ID.\n     *   @param _payload Calldata for branch router execution.\n     *   @param _gasLimit Gas limit for cross-chain message.\n     *   @param _remoteBranchExecutionGas Gas limit for branch router execution.\n     *   @return _fee Message value needed for cross-chain call.\n     */\n    function getFeeEstimate(\n        uint256 _gasLimit,\n        uint256 _remoteBranchExecutionGas,\n        bytes calldata _payload,\n        uint16 _dstChainId\n    ) external view returns (uint256 _fee);\n\n    /*///////////////////////////////////////////////////////////////\n                        ROOT ROUTER CALL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice External function performs call to LayerZero Endpoint Contract for cross-chain messaging.\n     *   @param _recipient address to receive any outstanding gas on the destination chain.\n     *   @param _dstChainId Chain to bridge to.\n     *   @param _params Calldata for function call.\n     *   @param _gParams Gas Parameters for cross-chain message.\n     *   @dev Internal function performs call to LayerZero Endpoint Contract for cross-chain messaging.\n     */\n    function callOut(\n        address payable _refundee,\n        address _recipient,\n        uint16 _dstChainId,\n        bytes memory _params,\n        GasParams calldata _gParams\n    ) external payable;\n\n    /**\n     * @notice External function to move assets from root chain to branch omnichain environment.\n     *   @param _refundee the effective owner of the settlement this address receives excess gas deposited on source chain\n     *                    for a cross-chain call and is allowed to redeeming assets after a failed settlement fallback.\n     *                    This address' Virtual Account is also allowed.\n     *   @param _recipient recipient of bridged tokens and any outstanding gas on the destination chain.\n     *   @param _dstChainId chain to bridge to.\n     *   @param _params parameters for function call on branch chain.\n     *   @param _sParams settlement parameters for asset bridging to branch chains.\n     *   @param _gParams Gas Parameters for cross-chain message.\n     *   @param _hasFallbackToggled Flag to toggle fallback function.\n     *\n     */\n    function callOutAndBridge(\n        address payable _refundee,\n        address _recipient,\n        uint16 _dstChainId,\n        bytes calldata _params,\n        SettlementInput calldata _sParams,\n        GasParams calldata _gParams,\n        bool _hasFallbackToggled\n    ) external payable;\n\n    /**\n     * @notice External function to move assets from branch chain to root omnichain environment.\n     *   @param _refundee the effective owner of the settlement this address receives excess gas deposited on source chain\n     *                    for a cross-chain call and is allowed to redeeming assets after a failed settlement fallback.\n     *                    This address' Virtual Account is also allowed.\n     *   @param _recipient recipient of bridged tokens.\n     *   @param _dstChainId chain to bridge to.\n     *   @param _params parameters for function call on branch chain.\n     *   @param _sParams settlement parameters for asset bridging to branch chains.\n     *   @param _gParams Gas Parameters for cross-chain message.\n     *   @param _hasFallbackToggled Flag to toggle fallback function.\n     *\n     *\n     */\n    function callOutAndBridgeMultiple(\n        address payable _refundee,\n        address _recipient,\n        uint16 _dstChainId,\n        bytes calldata _params,\n        SettlementMultipleInput calldata _sParams,\n        GasParams calldata _gParams,\n        bool _hasFallbackToggled\n    ) external payable;\n\n    /*///////////////////////////////////////////////////////////////\n                        SETTLEMENT FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to retry a user's Settlement balance.\n     *   @param _settlementNonce Identifier for token settlement.\n     *   @param _recipient recipient of bridged tokens and any outstanding gas on the destination chain.\n     *   @param _params Calldata for function call in branch chain.\n     *   @param _gParams Gas Parameters for cross-chain message.\n     *   @param _hasFallbackToggled Flag to toggle fallback function.\n     *\n     */\n    function retrySettlement(\n        uint32 _settlementNonce,\n        address _recipient,\n        bytes calldata _params,\n        GasParams calldata _gParams,\n        bool _hasFallbackToggled\n    ) external payable;\n\n    /**\n     * @notice Function that allows retrieval of failed Settlement's foricng fallback to be triggered.\n     *   @param _settlementNonce Identifier for token settlement.\n     *   @param _gParams Gas Parameters for cross-chain message.\n     *\n     */\n    function retrieveSettlement(uint32 _settlementNonce, GasParams calldata _gParams) external payable;\n\n    /**\n     * @notice Function that allows redemption of failed Settlement's global tokens.\n     *   @param _depositNonce Identifier for token deposit.\n     *\n     */\n    function redeemSettlement(uint32 _depositNonce) external;\n\n    /*///////////////////////////////////////////////////////////////\n                    TOKEN MANAGEMENT FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to move assets from branch chain to root omnichain environment.\n     * @dev Called in response to Bridge Agent Executor.\n     *   @param _recipient recipient of bridged token.\n     *   @param _dParams Cross-Chain Deposit of Multiple Tokens Params.\n     *   @param _srcChainId chain to bridge from.\n     *\n     */\n    function bridgeIn(address _recipient, DepositParams memory _dParams, uint256 _srcChainId) external;\n\n    /**\n     * @notice Function to move assets from branch chain to root omnichain environment.\n     * @dev Called in response to Bridge Agent Executor.\n     *   @param _recipient recipient of bridged tokens.\n     *   @param _dParams Cross-Chain Deposit of Multiple Tokens Params.\n     *   @param _srcChainId chain to bridge from.\n     *   @dev Since the input data is encodePacked we need to parse it:\n     *     1. First byte is the number of assets to be bridged in. Equals length of all arrays.\n     *     2. Next 4 bytes are the nonce of the deposit.\n     *     3. Last 32 bytes after the token related information are the chain to bridge to.\n     *     4. Token related information starts at index PARAMS_TKN_START is encoded as follows:\n     *         1. N * 32 bytes for the hToken address.\n     *         2. N * 32 bytes for the underlying token address.\n     *         3. N * 32 bytes for the amount of hTokens to be bridged in.\n     *         4. N * 32 bytes for the amount of underlying tokens to be bridged in.\n     *     5. Each of the 4 token related arrays are of length N and start at the following indexes:\n     *         1. PARAMS_TKN_START [hToken address has no offset from token information start].\n     *         2. PARAMS_TKN_START + (PARAMS_ADDRESS_SIZE * N)\n     *         3. PARAMS_TKN_START + (PARAMS_AMT_OFFSET * N)\n     *         4. PARAMS_TKN_START + (PARAMS_DEPOSIT_OFFSET * N)\n     *\n     */\n    function bridgeInMultiple(address _recipient, DepositMultipleParams calldata _dParams, uint256 _srcChainId)\n        external;\n\n    /*///////////////////////////////////////////////////////////////\n                            LAYER ZERO FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice External function to receive cross-chain messages from LayerZero Endpoint Contract without blocking.\n     *   @param _endpoint address of the LayerZero Endpoint Contract.\n     *   @param _srcChainId Chain ID of the sender.\n     *   @param _srcAddress address path of the recipient + sender.\n     *   @param _payload Calldata for function call.\n     */\n    function lzReceiveNonBlocking(\n        address _endpoint,\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        bytes calldata _payload\n    ) external;\n\n    /*///////////////////////////////////////////////////////////////\n                            ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Adds a new branch bridge agent to a given branch chainId\n     *   @param _branchChainId chainId of the branch chain\n     */\n    function approveBranchBridgeAgent(uint256 _branchChainId) external;\n\n    /**\n     * @notice Updates the address of the branch bridge agent\n     *   @param _newBranchBridgeAgent address of the new branch bridge agent\n     *   @param _branchChainId chainId of the branch chain\n     */\n    function syncBranchBridgeAgent(address _newBranchBridgeAgent, uint256 _branchChainId) external;\n\n    /*///////////////////////////////////////////////////////////////\n                             EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event LogExecute(uint256 indexed depositNonce, uint256 indexed srcChainId);\n    event LogFallback(uint256 indexed settlementNonce, uint256 indexed dstChainId);\n\n    /*///////////////////////////////////////////////////////////////\n                            ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error ExecutionFailure();\n    error GasErrorOrRepeatedTx();\n    error AlreadyExecutedTransaction();\n    error UnknownFlag();\n\n    error NotDao();\n\n    error LayerZeroUnauthorizedEndpoint();\n    error LayerZeroUnauthorizedCaller();\n\n    error AlreadyAddedBridgeAgent();\n    error UnrecognizedExecutor();\n    error UnrecognizedPort();\n    error UnrecognizedBridgeAgent();\n    error UnrecognizedLocalBridgeAgent();\n    error UnrecognizedBridgeAgentManager();\n    error UnrecognizedRouter();\n\n    error UnrecognizedUnderlyingAddress();\n    error UnrecognizedLocalAddress();\n\n    error SettlementRetryUnavailable();\n    error SettlementRetryUnavailableUseCallout();\n    error SettlementRedeemUnavailable();\n    error SettlementRetrieveUnavailable();\n    error NotSettlementOwner();\n\n    error InsufficientBalanceForSettlement();\n    error InsufficientGasForFees();\n    error InvalidInputParams();\n    error InvalidInputParamsLength();\n\n    error CallerIsNotPool();\n    error AmountsAreZero();\n}"
    },
    {
      "filename": "src/RootPort.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {IERC20hTokenRootFactory} from \"./interfaces/IERC20hTokenRootFactory.sol\";\nimport {IRootBridgeAgent as IBridgeAgent} from \"./interfaces/IRootBridgeAgent.sol\";\nimport {IRootPort, ICoreRootRouter, GasParams, VirtualAccount} from \"./interfaces/IRootPort.sol\";\n\nimport {ERC20hTokenRoot} from \"./token/ERC20hTokenRoot.sol\";\n\n/// @title Root Port - Omnichain Token Management Contract\n/// @author MaiaDAO\ncontract RootPort is Ownable, IRootPort {\n    using SafeTransferLib for address;\n\n    /*///////////////////////////////////////////////////////////////\n                            SETUP STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice True if setup is still ongoing, false otherwise.\n    bool internal _setup;\n\n    /// @notice True if core setup is still ongoing, false otherwise.\n    bool internal _setupCore;\n\n    /*///////////////////////////////////////////////////////////////\n                        ROOT PORT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Local Chain Id\n    uint256 public immutable localChainId;\n\n    /// @notice The address of local branch port responsible for handling local transactions.\n    address public localBranchPortAddress;\n\n    /// @notice The address of the core router in charge of adding new tokens to the system.\n    address public coreRootRouterAddress;\n\n    /// @notice The address of the core router in charge of adding new tokens to the system.\n    address public coreRootBridgeAgentAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                        VIRTUAL ACCOUNT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from user address to Virtual Account.\n    mapping(address user => VirtualAccount account) public getUserAccount;\n\n    /// @notice Holds the mapping from Virtual account to router address => bool.\n    /// @notice Stores whether a router is approved to spend a virtual account.\n    mapping(VirtualAccount acount => mapping(address router => bool allowed)) public isRouterApproved;\n\n    /*///////////////////////////////////////////////////////////////\n                        BRIDGE AGENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from address to Bridge Agent.\n    mapping(uint256 chainId => bool isActive) public isChainId;\n\n    /// @notice Mapping from address to isBridgeAgent (bool).\n    mapping(address bridgeAgent => bool isActive) public isBridgeAgent;\n\n    /// @notice Bridge Agents deployed in root chain.\n    address[] public bridgeAgents;\n\n    /// @notice Mapping address Bridge Agent => address Bridge Agent Manager\n    mapping(address bridgeAgent => address bridgeAgentManager) public getBridgeAgentManager;\n\n    /*///////////////////////////////////////////////////////////////\n                    BRIDGE AGENT FACTORIES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from Underlying Address to isUnderlying (bool).\n    mapping(address bridgeAgentFactory => bool isActive) public isBridgeAgentFactory;\n\n    /// @notice Bridge Agents deployed in root chain.\n    address[] public bridgeAgentFactories;\n\n    /*///////////////////////////////////////////////////////////////\n                            hTOKENS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping with all global hTokens deployed in the system.\n    mapping(address token => bool isGlobalToken) public isGlobalAddress;\n\n    /// @notice ChainId -> Local Address -> Global Address\n    mapping(address chainId => mapping(uint256 localAddress => address globalAddress)) public getGlobalTokenFromLocal;\n\n    /// @notice ChainId -> Global Address -> Local Address\n    mapping(address chainId => mapping(uint256 globalAddress => address localAddress)) public getLocalTokenFromGlobal;\n\n    /// @notice ChainId -> Underlying Address -> Local Address\n    mapping(address chainId => mapping(uint256 underlyingAddress => address localAddress)) public\n        getLocalTokenFromUnderlying;\n\n    /// @notice Mapping from Local Address to Underlying Address.\n    mapping(address chainId => mapping(uint256 localAddress => address underlyingAddress)) public\n        getUnderlyingTokenFromLocal;\n\n    /*///////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Root Port.\n     * @param _localChainId layer zero chain id of the local chain.\n     */\n    constructor(uint256 _localChainId) {\n        localChainId = _localChainId;\n        isChainId[_localChainId] = true;\n\n        _initializeOwner(msg.sender);\n        _setup = true;\n        _setupCore = true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    INITIALIZATION FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     *  @notice Function to initialize the Root Port.\n     *   @param _bridgeAgentFactory The address of the Bridge Agent Factory.\n     *   @param _coreRootRouter The address of the Core Root Router.\n     */\n    function initialize(address _bridgeAgentFactory, address _coreRootRouter) external onlyOwner {\n        require(_bridgeAgentFactory != address(0), \"Bridge Agent Factory cannot be 0 address.\");\n        require(_coreRootRouter != address(0), \"Core Root Router cannot be 0 address.\");\n        require(_setup, \"Setup ended.\");\n        _setup = false;\n\n        isBridgeAgentFactory[_bridgeAgentFactory] = true;\n        bridgeAgentFactories.push(_bridgeAgentFactory);\n\n        coreRootRouterAddress = _coreRootRouter;\n    }\n\n    /**\n     *  @notice Function to initialize the Root Chain Core Contracts in Port Storage.\n     *   @param _coreRootBridgeAgent The address of the Core Root Bridge Agent.\n     *   @param _coreLocalBranchBridgeAgent The address of the Core Arbitrum Branch Bridge Agent.\n     *   @param _localBranchPortAddress The address of the Arbitrum Branch Port.\n     */\n    function initializeCore(\n        address _coreRootBridgeAgent,\n        address _coreLocalBranchBridgeAgent,\n        address _localBranchPortAddress\n    ) external onlyOwner {\n        require(_coreRootBridgeAgent != address(0), \"Core Root Bridge Agent cannot be 0 address.\");\n        require(_coreLocalBranchBridgeAgent != address(0), \"Core Local Branch Bridge Agent cannot be 0 address.\");\n        require(_localBranchPortAddress != address(0), \"Local Branch Port Address cannot be 0 address.\");\n        require(isBridgeAgent[_coreRootBridgeAgent], \"Core Bridge Agent doesn't exist.\");\n        require(_setupCore, \"Core Setup ended.\");\n        _setupCore = false;\n\n        coreRootBridgeAgentAddress = _coreRootBridgeAgent;\n        localBranchPortAddress = _localBranchPortAddress;\n        IBridgeAgent(_coreRootBridgeAgent).syncBranchBridgeAgent(_coreLocalBranchBridgeAgent, localChainId);\n        getBridgeAgentManager[_coreRootBridgeAgent] = owner();\n    }\n\n    /// @notice Function being overriden to prevent mistakenly renouncing ownership.\n    function renounceOwnership() public payable override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        EXTERNAL VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootPort\n    function getLocalToken(address _localAddress, uint256 _srcChainId, uint256 _dstChainId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _getLocalToken(_localAddress, _srcChainId, _dstChainId);\n    }\n\n    /**\n     * @notice View Function returns Local Token's Local Address on another chain.\n     * @param _localAddress The address of the token in the local chain.\n     * @param _srcChainId The chainId of the chain where the token is deployed.\n     * @param _dstChainId The chainId of the chain for which the token address is requested.\n     */\n    function _getLocalToken(address _localAddress, uint256 _srcChainId, uint256 _dstChainId)\n        internal\n        view\n        returns (address)\n    {\n        address globalAddress = getGlobalTokenFromLocal[_localAddress][_srcChainId];\n        return getLocalTokenFromGlobal[globalAddress][_dstChainId];\n    }\n\n    /// @inheritdoc IRootPort\n    function getUnderlyingTokenFromGlobal(address _globalAddress, uint256 _srcChainId)\n        external\n        view\n        override\n        returns (address)\n    {\n        address localAddress = getLocalTokenFromGlobal[_globalAddress][_srcChainId];\n        return getUnderlyingTokenFromLocal[localAddress][_srcChainId];\n    }\n\n    /// @inheritdoc IRootPort\n    function isGlobalToken(address _globalAddress, uint256 _srcChainId) external view override returns (bool) {\n        return getLocalTokenFromGlobal[_globalAddress][_srcChainId] != address(0);\n    }\n\n    /// @inheritdoc IRootPort\n    function isLocalToken(address _localAddress, uint256 _srcChainId) external view override returns (bool) {\n        return getGlobalTokenFromLocal[_localAddress][_srcChainId] != address(0);\n    }\n\n    /// @inheritdoc IRootPort\n    function isLocalToken(address _localAddress, uint256 _srcChainId, uint256 _dstChainId)\n        external\n        view\n        returns (bool)\n    {\n        return _getLocalToken(_localAddress, _srcChainId, _dstChainId) != address(0);\n    }\n\n    /// @inheritdoc IRootPort\n    function isUnderlyingToken(address _underlyingToken, uint256 _srcChainId) external view override returns (bool) {\n        return getLocalTokenFromUnderlying[_underlyingToken][_srcChainId] != address(0);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        hTOKEN MANAGEMENT FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootPort\n    function setAddresses(\n        address _globalAddress,\n        address _localAddress,\n        address _underlyingAddress,\n        uint256 _srcChainId\n    ) external override requiresCoreRootRouter {\n        if (_globalAddress == address(0)) revert InvalidGlobalAddress();\n        if (_localAddress == address(0)) revert InvalidLocalAddress();\n        if (_underlyingAddress == address(0)) revert InvalidUnderlyingAddress();\n\n        isGlobalAddress[_globalAddress] = true;\n        getGlobalTokenFromLocal[_localAddress][_srcChainId] = _globalAddress;\n        getLocalTokenFromGlobal[_globalAddress][_srcChainId] = _localAddress;\n        getLocalTokenFromUnderlying[_underlyingAddress][_srcChainId] = _localAddress;\n        getUnderlyingTokenFromLocal[_localAddress][_srcChainId] = _underlyingAddress;\n\n        emit LocalTokenAdded(_underlyingAddress, _localAddress, _globalAddress, _srcChainId);\n    }\n\n    /// @inheritdoc IRootPort\n    function setLocalAddress(address _globalAddress, address _localAddress, uint256 _srcChainId)\n        external\n        override\n        requiresCoreRootRouter\n    {\n        if (_localAddress == address(0)) revert InvalidLocalAddress();\n\n        getGlobalTokenFromLocal[_localAddress][_srcChainId] = _globalAddress;\n        getLocalTokenFromGlobal[_globalAddress][_srcChainId] = _localAddress;\n\n        emit GlobalTokenAdded(_localAddress, _globalAddress, _srcChainId);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        hTOKEN ACCOUNTING FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootPort\n    function bridgeToRoot(address _recipient, address _hToken, uint256 _amount, uint256 _deposit, uint256 _srcChainId)\n        external\n        override\n        requiresBridgeAgent\n    {\n        if (!isGlobalAddress[_hToken]) revert UnrecognizedToken();\n\n        if (_amount - _deposit > 0) {\n            unchecked {\n                _hToken.safeTransfer(_recipient, _amount - _deposit);\n            }\n        }\n\n        if (_deposit > 0) if (!ERC20hTokenRoot(_hToken).mint(_recipient, _deposit, _srcChainId)) revert UnableToMint();\n    }\n\n    /// @inheritdoc IRootPort\n    function bridgeToRootFromLocalBranch(address _from, address _hToken, uint256 _amount)\n        external\n        override\n        requiresLocalBranchPort\n    {\n        if (!isGlobalAddress[_hToken]) revert UnrecognizedToken();\n\n        _hToken.safeTransferFrom(_from, address(this), _amount);\n    }\n\n    function bridgeToLocalBranchFromRoot(address _to, address _hToken, uint256 _amount)\n        external\n        override\n        requiresLocalBranchPort\n    {\n        if (!isGlobalAddress[_hToken]) revert UnrecognizedToken();\n\n        _hToken.safeTransfer(_to, _amount);\n    }\n\n    /// @inheritdoc IRootPort\n    function burn(address _from, address _hToken, uint256 _amount, uint256 _srcChainId)\n        external\n        override\n        requiresBridgeAgent\n    {\n        if (!isGlobalAddress[_hToken]) revert UnrecognizedToken();\n        ERC20hTokenRoot(_hToken).burn(_from, _amount, _srcChainId);\n    }\n\n    /// @inheritdoc IRootPort\n    function burnFromLocalBranch(address _from, address _hToken, uint256 _amount)\n        external\n        override\n        requiresLocalBranchPort\n    {\n        if (!isGlobalAddress[_hToken]) revert UnrecognizedToken();\n\n        ERC20hTokenRoot(_hToken).burn(_from, _amount, localChainId);\n    }\n\n    /// @inheritdoc IRootPort\n    function mintToLocalBranch(address _to, address _hToken, uint256 _amount)\n        external\n        override\n        requiresLocalBranchPort\n    {\n        if (!isGlobalAddress[_hToken]) revert UnrecognizedToken();\n        if (!ERC20hTokenRoot(_hToken).mint(_to, _amount, localChainId)) revert UnableToMint();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    VIRTUAL ACCOUNT MANAGEMENT FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootPort\n    function fetchVirtualAccount(address _user) external override returns (VirtualAccount account) {\n        account = getUserAccount[_user];\n        if (address(account) == address(0)) account = addVirtualAccount(_user);\n    }\n\n    /**\n     * @notice Creates a new virtual account for a user.\n     * @param _user address of the user to associate a virtual account with.\n     */\n    function addVirtualAccount(address _user) internal returns (VirtualAccount newAccount) {\n        if (_user == address(0)) revert InvalidUserAddress();\n\n        newAccount = new VirtualAccount{salt: keccak256(abi.encode(_user))}(_user, address(this));\n        getUserAccount[_user] = newAccount;\n\n        emit VirtualAccountCreated(_user"
    }
  ]
}