{
  "Title": "[G-06] Internal/Private functions only called once can be inlined to save gas",
  "Content": "\nNot inlining costs 20 to 40 gas because of two extra JUMP instructions and additional stack operations needed for function calls.\n\nAffected code:\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/OndoPriceOracle.sol#L119\n```solidity\nFile: /contracts/lending/OndoPriceOracle.sol\n119:  function _setFTokenToCToken(address fToken, address cToken) internal {\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/OndoPriceOracleV2.sol#L210\n```solidity\nFile: /contracts/lending/OndoPriceOracleV2.sol\n210:  function _setFTokenToCToken(address fToken, address cToken) internal {\n\n251:  function _setFTokenToChainlinkOracle(\n252:    address fToken,\n253:    address chainlinkOracle\n254:  ) internal {\n\n324:  function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2023-01-ondo-finance-contest",
  "Code": [
    {
      "filename": "contracts/lending/OndoPriceOracle.sol",
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n */\npragma solidity 0.6.12;\n\nimport \"./IOndoPriceOracle.sol\";\nimport \"contracts/lending/compound/Ownable.sol\";\n\n/// @notice Interface for generalizing different cToken oracles\ninterface CTokenOracle {\n  function getUnderlyingPrice(address cToken) external view returns (uint256);\n}\n\n/// @notice Helper interface for standardizing common calls to\n///         fTokens and cTokens\ninterface CTokenLike {\n  function underlying() external view returns (address);\n}\n\n/**\n * @title OndoPriceOracle\n * @author Ondo Finance\n * @notice This contract acts as a custom price oracle for the flux finance\n *         lending market. It allows for the owner to set the underlying price\n *         directly in contract storage or set an fToken-to-cToken\n *         association for piggy backing on an existing cToken's oracle.\n */\ncontract OndoPriceOracle is IOndoPriceOracle, Ownable {\n  /// @notice Initially set to contracts/lending/compound/uniswap/UniswapAnchoredView.sol\n  CTokenOracle public cTokenOracle =\n    CTokenOracle(0x65c816077C29b557BEE980ae3cC2dCE80204A0C5);\n\n  /// @notice Contract storage for fToken's underlying asset prices\n  mapping(address => uint256) public fTokenToUnderlyingPrice;\n\n  /// @notice fToken to cToken associations for piggy backing off\n  ///         of cToken oracles\n  mapping(address => address) public fTokenToCToken;\n\n  /**\n   * @notice Retrieve the price of the provided fToken\n   *         contract's underlying asset\n   *\n   * @param fToken fToken contract address\n   *\n   * @dev This function first attempts to check if the price has been set directly \n          in contract storage. If not set, we check if there is a corresponding cToken\n   *      set within `fTokenToCToken` and piggy back on an external price oracle.\n   */\n  function getUnderlyingPrice(\n    address fToken\n  ) external view override returns (uint256) {\n    if (fTokenToUnderlyingPrice[fToken] != 0) {\n      return fTokenToUnderlyingPrice[fToken];\n    } else {\n      // Price is not manually set, attempt to retrieve price from Compound's\n      // oracle\n      address cTokenAddress = fTokenToCToken[fToken];\n      return cTokenOracle.getUnderlyingPrice(cTokenAddress);\n    }\n  }\n\n  /**\n   * @notice Sets the price of an fToken contract's underlying asset\n   *\n   * @param fToken fToken contract address\n   * @param price  New price of underlying asset\n   */\n  function setPrice(address fToken, uint256 price) external override onlyOwner {\n    uint256 oldPrice = fTokenToUnderlyingPrice[fToken];\n    fTokenToUnderlyingPrice[fToken] = price;\n    emit UnderlyingPriceSet(fToken, oldPrice, price);\n  }\n\n  /**\n   * @notice Associates a custom fToken with an external cToken\n   *\n   * @param fToken fToken contract address\n   * @param cToken cToken contract address\n   */\n  function setFTokenToCToken(\n    address fToken,\n    address cToken\n  ) external override onlyOwner {\n    address oldCToken = fTokenToCToken[fToken];\n    _setFTokenToCToken(fToken, cToken);\n    emit FTokenToCTokenSet(fToken, oldCToken, cToken);\n  }\n\n  /**\n   * @notice Sets the external oracle address\n   *\n   * @param newOracle cToken oracle contract address\n   */\n  function setOracle(address newOracle) external override onlyOwner {\n    address oldOracle = address(cTokenOracle);\n    cTokenOracle = CTokenOracle(newOracle);\n    emit CTokenOracleSet(oldOracle, newOracle);\n  }\n\n  /**\n   * @notice Private implementation function for setting fToken\n   *         to cToken implementation\n   *\n   * @param fToken fToken contract address\n   * @param cToken cToken contract address\n   */\n  function _setFTokenToCToken(address fToken, address cToken) internal {\n    require(\n      CTokenLike(fToken).underlying() == CTokenLike(cToken).underlying(),\n      \"cToken and fToken must have the same underlying asset if cToken nonzero\"\n    );\n    fTokenToCToken[fToken] = cToken;\n  }\n}"
    },
    {
      "filename": "contracts/lending/OndoPriceOracleV2.sol",
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n */\npragma solidity 0.8.16;\n\nimport \"./IOndoPriceOracleV2.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/access/Ownable.sol\";\nimport \"contracts/lending/chainlink/AggregatorV3Interface.sol\";\n\n/// @notice Interface for generalizing different cToken oracles\ninterface CTokenOracle {\n  function getUnderlyingPrice(address cToken) external view returns (uint256);\n}\n\n/// @notice Helper interface for standardizing comnmon calls to\n///         fTokens and cTokens\ninterface CTokenLike {\n  function underlying() external view returns (address);\n}\n\n/// @notice Helper interface for interacting with underlying assets\n///         that are ERC20 compliant\ninterface IERC20Like {\n  function decimals() external view returns (uint8);\n}\n\n/**\n * @title OndoPriceOracleV2\n * @author Ondo Finance\n * @notice This contract acts as a custom price oracle for the Flux lending\n *         market protocol. It allows for the owner to set the underlying price\n *         directly in contract storage, to set an fToken-to-cToken\n *         association for price retrieval using Compound's oracle, and\n *         to set an association between an fToken and a Chainlink\n *         oracle for price retrieval. It also allows the owner to\n *         set a price ceiling (a.k.a \"cap\") on an fToken's underlying asset.\n */\ncontract OndoPriceOracleV2 is IOndoPriceOracleV2, Ownable {\n  /// @notice Initially set to contracts/lending/compound/uniswap/UniswapAnchoredView.sol\n  CTokenOracle public cTokenOracle =\n    CTokenOracle(0x65c816077C29b557BEE980ae3cC2dCE80204A0C5);\n\n  /// @notice fToken to Oracle Type association\n  mapping(address => OracleType) public fTokenToOracleType;\n\n  /// @notice Contract storage for fToken's underlying asset prices\n  mapping(address => uint256) public fTokenToUnderlyingPrice;\n\n  /// @notice fToken to cToken associations for piggy backing off\n  ///         of Compound's Oracle\n  mapping(address => address) public fTokenToCToken;\n\n  struct ChainlinkOracleInfo {\n    AggregatorV3Interface oracle;\n    uint256 scaleFactor;\n  }\n\n  /// @notice fToken to Chainlink oracle association\n  mapping(address => ChainlinkOracleInfo) public fTokenToChainlinkOracle;\n\n  /// @notice Price cap for the underlying asset of an fToken. Optional.\n  mapping(address => uint256) public fTokenToUnderlyingPriceCap;\n\n  /// @notice The maximum amount of time delay we will tolerate from all\n  ///         Chainlink oracles.\n  uint256 public maxChainlinkOracleTimeDelay = 90000; // 25 hours\n\n  /**\n   * @notice Retrieve the price of the provided fToken\n   *         contract's underlying asset\n   *\n   * @param fToken fToken contract address\n   *\n   * @dev This function attempts to retrieve the price based on the associated\n   *      `OracleType`. This can mean retrieving from Compound's oracle, a\n   *      Chainlink oracle, or even a price set manually within contract\n   *      storage. It will cap the price if a price cap is set in\n   *      `fTokenToUnderlyingPriceCap`.\n   * @dev Only supports oracle prices denominated in USD\n   */\n  function getUnderlyingPrice(\n    address fToken\n  ) external view override returns (uint256) {\n    uint256 price;\n\n    // Get price of fToken depending on OracleType\n    OracleType oracleType = fTokenToOracleType[fToken];\n    if (oracleType == OracleType.MANUAL) {\n      // Get price stored in contract storage\n      price = fTokenToUnderlyingPrice[fToken];\n    } else if (oracleType == OracleType.COMPOUND) {\n      // Get associated cToken and call Compound oracle\n      address cTokenAddress = fTokenToCToken[fToken];\n      price = cTokenOracle.getUnderlyingPrice(cTokenAddress);\n    } else if (oracleType == OracleType.CHAINLINK) {\n      // Get price from Chainlink oracle\n      price = getChainlinkOraclePrice(fToken);\n    } else {\n      revert(\"Oracle type not supported\");\n    }\n\n    // If price cap is set, take the min.\n    if (fTokenToUnderlyingPriceCap[fToken] > 0) {\n      price = _min(price, fTokenToUnderlyingPriceCap[fToken]);\n    }\n\n    return price;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                   Price Cap & Oracle Type Setter\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Sets the price cap for the provided fToken's underlying asset\n   *\n   * @param fToken fToken contract address\n   */\n  function setPriceCap(\n    address fToken,\n    uint256 value\n  ) external override onlyOwner {\n    uint256 oldPriceCap = fTokenToUnderlyingPriceCap[fToken];\n    fTokenToUnderlyingPriceCap[fToken] = value;\n    emit PriceCapSet(fToken, oldPriceCap, value);\n  }\n\n  /**\n   * @notice Sets the oracle type for the provided fToken\n   *\n   * @param fToken     fToken contract address\n   * @param oracleType Oracle Type of fToken\n   */\n  function setFTokenToOracleType(\n    address fToken,\n    OracleType oracleType\n  ) external override onlyOwner {\n    fTokenToOracleType[fToken] = oracleType;\n    emit FTokenToOracleTypeSet(fToken, oracleType);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            Manual Oracle\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Sets the price of an fToken contract's underlying asset\n   *\n   * @param fToken fToken contract address\n   * @param price  New price of underlying asset\n   */\n  function setPrice(address fToken, uint256 price) external override onlyOwner {\n    require(\n      fTokenToOracleType[fToken] == OracleType.MANUAL,\n      \"OracleType must be Manual\"\n    );\n    uint256 oldPrice = fTokenToUnderlyingPrice[fToken];\n    fTokenToUnderlyingPrice[fToken] = price;\n    emit UnderlyingPriceSet(fToken, oldPrice, price);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          Compound Oracle\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Sets the external oracle address for Compound oracleType\n   *\n   * @param newOracle cToken oracle contract address\n   */\n  function setOracle(address newOracle) external override onlyOwner {\n    address oldOracle = address(cTokenOracle);\n    cTokenOracle = CTokenOracle(newOracle);\n    emit CTokenOracleSet(oldOracle, newOracle);\n  }\n\n  /**\n   * @notice Associates a custom fToken with an external cToken\n   *\n   * @param fToken fToken contract address\n   * @param cToken cToken contract address\n   */\n  function setFTokenToCToken(\n    address fToken,\n    address cToken\n  ) external override onlyOwner {\n    address oldCToken = fTokenToCToken[fToken];\n    _setFTokenToCToken(fToken, cToken);\n    emit FTokenToCTokenSet(fToken, oldCToken, cToken);\n  }\n\n  /**\n   * @notice Private implementation function for setting fToken\n   *         to cToken implementation\n   *\n   * @param fToken fToken contract address\n   * @param cToken cToken contract address\n   */\n  function _setFTokenToCToken(address fToken, address cToken) internal {\n    require(\n      fTokenToOracleType[fToken] == OracleType.COMPOUND,\n      \"OracleType must be Compound\"\n    );\n    require(\n      CTokenLike(fToken).underlying() == CTokenLike(cToken).underlying(),\n      \"cToken and fToken must have the same underlying asset\"\n    );\n    fTokenToCToken[fToken] = cToken;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          Chainlink Oracle\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Associates a custom fToken with a Chainlink oracle\n   *\n   * @param fToken             fToken contract address\n   * @param newChainlinkOracle Chainlink oracle address\n   *\n   */\n  function setFTokenToChainlinkOracle(\n    address fToken,\n    address newChainlinkOracle\n  ) external override onlyOwner {\n    address oldChainlinkOracle = address(\n      fTokenToChainlinkOracle[fToken].oracle\n    );\n    _setFTokenToChainlinkOracle(fToken, newChainlinkOracle);\n    emit ChainlinkOracleSet(fToken, oldChainlinkOracle, newChainlinkOracle);\n  }\n\n  /**\n   * @notice Internal implementation function for setting fToken to\n   *         chainlinkOracle implementation\n   *\n   * @param fToken          fToken contract address\n   * @param chainlinkOracle cToken contract address\n   */\n  function _setFTokenToChainlinkOracle(\n    address fToken,\n    address chainlinkOracle\n  ) internal {\n    require(\n      fTokenToOracleType[fToken] == OracleType.CHAINLINK,\n      \"OracleType must be Chainlink\"\n    );\n    address underlying = CTokenLike(fToken).underlying();\n    fTokenToChainlinkOracle[fToken].scaleFactor = (10 **\n      (36 -\n        uint256(IERC20Like(underlying).decimals()) -\n        uint256(AggregatorV3Interface(chainlinkOracle).decimals())));\n    fTokenToChainlinkOracle[fToken].oracle = AggregatorV3Interface(\n      chainlinkOracle\n    );\n  }\n\n  /**\n   * @notice Retrieve price of fToken's underlying asset from a Chainlink\n   *         oracle\n   *\n   * @param fToken fToken contract address\n   *\n   * @dev This function is public for observability purposes only.\n   */\n  function getChainlinkOraclePrice(\n    address fToken\n  ) public view returns (uint256) {\n    require(\n      fTokenToOracleType[fToken] == OracleType.CHAINLINK,\n      \"fToken is not configured for Chainlink oracle\"\n    );\n    ChainlinkOracleInfo memory chainlinkInfo = fTokenToChainlinkOracle[fToken];\n    (\n      uint80 roundId,\n      int answer,\n      ,\n      uint updatedAt,\n      uint80 answeredInRound\n    ) = chainlinkInfo.oracle.latestRoundData();\n    require(\n      (answeredInRound >= roundId) &&\n        (updatedAt >= block.timestamp - maxChainlinkOracleTimeDelay),\n      \"Chainlink oracle price is stale\"\n    );\n    require(answer >= 0, \"Price cannot be negative\");\n    // Scale to decimals needed in Comptroller (18 decimal underlying -> 18 decimals; 6 decimal underlying -> 30 decimals)\n    // Scales by same conversion factor as in Compound Oracle\n    return uint256(answer) * chainlinkInfo.scaleFactor;\n  }\n\n  /**\n   * @notice Set the max time delay that we will tolerate from a Chainlink\n   *         oracle contract `latestRoundData()` response\n   *\n   * @param _maxChainlinkOracleTimeDelay New Max time delay (in seconds)\n   */\n  function setMaxChainlinkOracleTimeDelay(\n    uint256 _maxChainlinkOracleTimeDelay\n  ) external override onlyOwner {\n    uint256 oldMaxDelay = maxChainlinkOracleTimeDelay;\n    maxChainlinkOracleTimeDelay = _maxChainlinkOracleTimeDelay;\n    emit MaxChainlinkOracleTimeDelaySet(\n      oldMaxDelay,\n      _maxChainlinkOracleTimeDelay\n    );\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                                Utils\n  //////////////////////////////////////////////////////////////*/\n\n  function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n}"
    }
  ]
}