{
  "Title": "[G-04] By updating `emit`, extra emit usage can be reduced",
  "Content": "\nIn the `mint` function in the `Bio.sol` contract, the protocol emits two emits (the `_mint` and bioAdded emits). By updating the emit of Solady's `_mint` function, the use of one extra emit can be reduced.\n\nReference: https://github.com/ethereum/go-ethereum/blob/master/params/protocol_params.go#L78-L82\n\n```diff \ncanto-bio-protocol/lib/solady/lib/solmate/src/tokens/ERC721.sol:\n\n+ event Transfer(address from, address indexed to, uint256 indexed id, string indexed bio);\n\n+ 157:     function _mint(address to, uint256 id) internal virtual {\n+ 158:         require(to != address(0), \"INVALID_RECIPIENT\");\n+ 159: \n+ 160:         require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n+ 161: \n+ 162:         // Counter overflow is incredibly unrealistic.\n+ 163:         unchecked {\n+ 164:             _balanceOf[to]++;\n+ 165:         }\n+ 166: \n+ 167:         _ownerOf[id] = to;\n+ 168: \n+ 169:         emit Transfer(address(0), to, tokenId, _bio );\n+ 170:     }\n\n\ncanto-bio-protocol/src/Bio.sol:\n\n23:     event BioAdded(address indexed minter, uint256 indexed nftID, string indexed bio);\n  120      /// @param _bio The text to add\n  121:     function mint(string calldata _bio) external {\n  122:         // We check the length in bytes, so will be higher for UTF-8 characters. But sufficient for this check\n  123:         if (bytes(_bio).length == 0 || bytes(_bio).length > 200) revert InvalidBioLength(bytes(_bio).length);\n  124:         uint256 tokenId = ++numMinted;\n  125:         bio[tokenId] = _bio;\n- 126:        _mint(msg.sender, tokenId,);\n+ 126:        _mint(msg.sender, tokenId, _bio);\n\n- 127:        emit BioAdded(msg.sender, tokenId, _bio);\n  128:     }\n\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2023-03-canto-identity-subprotocols-contest",
  "Code": [
    {
      "filename": "params/protocol_params.go",
      "content": "// Copyright 2015 The go-ethereum Authors\n// This file is part of the go-ethereum library.\n//\n// The go-ethereum library is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// The go-ethereum library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.\n\npackage params\n\nimport (\n\t\"math/big\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n)\n\nconst (\n\tGasLimitBoundDivisor uint64 = 1024               // The bound divisor of the gas limit, used in update calculations.\n\tMinGasLimit          uint64 = 5000               // Minimum the gas limit may ever be.\n\tMaxGasLimit          uint64 = 0x7fffffffffffffff // Maximum the gas limit (2^63-1).\n\tGenesisGasLimit      uint64 = 4712388            // Gas limit of the Genesis block.\n\n\tMaximumExtraDataSize  uint64 = 32    // Maximum size extra data may be after Genesis.\n\tExpByteGas            uint64 = 10    // Times ceil(log256(exponent)) for the EXP instruction.\n\tSloadGas              uint64 = 50    // Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added.\n\tCallValueTransferGas  uint64 = 9000  // Paid for CALL when the value transfer is non-zero.\n\tCallNewAccountGas     uint64 = 25000 // Paid for CALL when the destination address didn't exist prior.\n\tTxGas                 uint64 = 21000 // Per transaction not creating a contract. NOTE: Not payable on data of calls between transactions.\n\tTxGasContractCreation uint64 = 53000 // Per transaction that creates a contract. NOTE: Not payable on data of calls between transactions.\n\tTxDataZeroGas         uint64 = 4     // Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions.\n\tQuadCoeffDiv          uint64 = 512   // Divisor for the quadratic particle of the memory cost equation.\n\tLogDataGas            uint64 = 8     // Per byte in a LOG* operation's data.\n\tCallStipend           uint64 = 2300  // Free gas given at beginning of call.\n\n\tKeccak256Gas     uint64 = 30 // Once per KECCAK256 operation.\n\tKeccak256WordGas uint64 = 6  // Once per word of the KECCAK256 operation's data.\n\tInitCodeWordGas  uint64 = 2  // Once per word of the init code when creating a contract.\n\n\tSstoreSetGas    uint64 = 20000 // Once per SSTORE operation.\n\tSstoreResetGas  uint64 = 5000  // Once per SSTORE operation if the zeroness changes from zero.\n\tSstoreClearGas  uint64 = 5000  // Once per SSTORE operation if the zeroness doesn't change.\n\tSstoreRefundGas uint64 = 15000 // Once per SSTORE operation if the zeroness changes to zero.\n\n\tNetSstoreNoopGas  uint64 = 200   // Once per SSTORE operation if the value doesn't change.\n\tNetSstoreInitGas  uint64 = 20000 // Once per SSTORE operation from clean zero.\n\tNetSstoreCleanGas uint64 = 5000  // Once per SSTORE operation from clean non-zero.\n\tNetSstoreDirtyGas uint64 = 200   // Once per SSTORE operation from dirty.\n\n\tNetSstoreClearRefund      uint64 = 15000 // Once per SSTORE operation for clearing an originally existing storage slot\n\tNetSstoreResetRefund      uint64 = 4800  // Once per SSTORE operation for resetting to the original non-zero value\n\tNetSstoreResetClearRefund uint64 = 19800 // Once per SSTORE operation for resetting to the original zero value\n\n\tSstoreSentryGasEIP2200            uint64 = 2300  // Minimum gas required to be present for an SSTORE call, not consumed\n\tSstoreSetGasEIP2200               uint64 = 20000 // Once per SSTORE operation from clean zero to non-zero\n\tSstoreResetGasEIP2200             uint64 = 5000  // Once per SSTORE operation from clean non-zero to something else\n\tSstoreClearsScheduleRefundEIP2200 uint64 = 15000 // Once per SSTORE operation for clearing an originally existing storage slot\n\n\tColdAccountAccessCostEIP2929 = uint64(2600) // COLD_ACCOUNT_ACCESS_COST\n\tColdSloadCostEIP2929         = uint64(2100) // COLD_SLOAD_COST\n\tWarmStorageReadCostEIP2929   = uint64(100)  // WARM_STORAGE_READ_COST\n\n\t// In EIP-2200: SstoreResetGas was 5000.\n\t// In EIP-2929: SstoreResetGas was changed to '5000 - COLD_SLOAD_COST'.\n\t// In EIP-3529: SSTORE_CLEARS_SCHEDULE is defined as SSTORE_RESET_GAS + ACCESS_LIST_STORAGE_KEY_COST\n\t// Which becomes: 5000 - 2100 + 1900 = 4800\n\tSstoreClearsScheduleRefundEIP3529 uint64 = SstoreResetGasEIP2200 - ColdSloadCostEIP2929 + TxAccessListStorageKeyGas\n\n\tJumpdestGas   uint64 = 1     // Once per JUMPDEST operation.\n\tEpochDuration uint64 = 30000 // Duration between proof-of-work epochs.\n\n\tCreateDataGas         uint64 = 200   //\n\tCallCreateDepth       uint64 = 1024  // Maximum depth of call/create stack.\n\tExpGas                uint64 = 10    // Once per EXP instruction\n\tLogGas                uint64 = 375   // Per LOG* operation.\n\tCopyGas               uint64 = 3     //\n\tStackLimit            uint64 = 1024  // Maximum size of VM stack allowed.\n\tTierStepGas           uint64 = 0     // Once per operation, for a selection of them.\n\tLogTopicGas           uint64 = 375   // Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas.\n\tCreateGas             uint64 = 32000 // Once per CREATE operation & contract-creation transaction.\n\tCreate2Gas            uint64 = 32000 // Once per CREATE2 operation\n\tCreateNGasEip4762     uint64 = 1000  // Once per CREATEn operations post-verkle\n\tSelfdestructRefundGas uint64 = 24000 // Refunded following a selfdestruct operation.\n\tMemoryGas             uint64 = 3     // Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL.\n\n\tTxDataNonZeroGasFrontier  uint64 = 68   // Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions.\n\tTxDataNonZeroGasEIP2028   uint64 = 16   // Per byte of non zero data attached to a transaction after EIP 2028 (part in Istanbul)\n\tTxAccessListAddressGas    uint64 = 2400 // Per address specified in EIP 2930 access list\n\tTxAccessListStorageKeyGas uint64 = 1900 // Per storage key specified in EIP 2930 access list\n\n\t// These have been changed during the course of the chain\n\tCallGasFrontier              uint64 = 40  // Once per CALL operation & message call transaction.\n\tCallGasEIP150                uint64 = 700 // Static portion of gas for CALL-derivates after EIP 150 (Tangerine)\n\tBalanceGasFrontier           uint64 = 20  // The cost of a BALANCE operation\n\tBalanceGasEIP150             uint64 = 400 // The cost of a BALANCE operation after Tangerine\n\tBalanceGasEIP1884            uint64 = 700 // The cost of a BALANCE operation after EIP 1884 (part of Istanbul)\n\tExtcodeSizeGasFrontier       uint64 = 20  // Cost of EXTCODESIZE before EIP 150 (Tangerine)\n\tExtcodeSizeGasEIP150         uint64 = 700 // Cost of EXTCODESIZE after EIP 150 (Tangerine)\n\tSloadGasFrontier             uint64 = 50\n\tSloadGasEIP150               uint64 = 200\n\tSloadGasEIP1884              uint64 = 800  // Cost of SLOAD after EIP 1884 (part of Istanbul)\n\tSloadGasEIP2200              uint64 = 800  // Cost of SLOAD after EIP 2200 (part of Istanbul)\n\tExtcodeHashGasConstantinople uint64 = 400  // Cost of EXTCODEHASH (introduced in Constantinople)\n\tExtcodeHashGasEIP1884        uint64 = 700  // Cost of EXTCODEHASH after EIP 1884 (part in Istanbul)\n\tSelfdestructGasEIP150        uint64 = 5000 // Cost of SELFDESTRUCT post EIP 150 (Tangerine)\n\n\t// EXP has a dynamic portion depending on the size of the exponent\n\tExpByteFrontier uint64 = 10 // was set to 10 in Frontier\n\tExpByteEIP158   uint64 = 50 // was raised to 50 during Eip158 (Spurious Dragon)\n\n\t// Extcodecopy has a dynamic AND a static cost. This represents only the\n\t// static portion of the gas. It was changed during EIP 150 (Tangerine)\n\tExtcodeCopyBaseFrontier uint64 = 20\n\tExtcodeCopyBaseEIP150   uint64 = 700\n\n\t// CreateBySelfdestructGas is used when the refunded account is one that does\n\t// not exist. This logic is similar to call.\n\t// Introduced in Tangerine Whistle (Eip 150)\n\tCreateBySelfdestructGas uint64 = 25000\n\n\tDefaultBaseFeeChangeDenominator = 8          // Bounds the amount the base fee can change between blocks.\n\tDefaultElasticityMultiplier     = 2          // Bounds the maximum gas limit an EIP-1559 block may have.\n\tInitialBaseFee                  = 1000000000 // Initial base fee for EIP-1559 blocks.\n\n\tMaxCodeSize     = 24576           // Maximum bytecode to permit for a contract\n\tMaxInitCodeSize = 2 * MaxCodeSize // Maximum initcode to permit in a creation transaction and create instructions\n\n\t// Precompiled contract gas prices\n\n\tEcrecoverGas        uint64 = 3000 // Elliptic curve sender recovery gas price\n\tSha256BaseGas       uint64 = 60   // Base price for a SHA256 operation\n\tSha256PerWordGas    uint64 = 12   // Per-word price for a SHA256 operation\n\tRipemd160BaseGas    uint64 = 600  // Base price for a RIPEMD160 operation\n\tRipemd160PerWordGas uint64 = 120  // Per-word price for a RIPEMD160 operation\n\tIdentityBaseGas     uint64 = 15   // Base price for a data copy operation\n\tIdentityPerWordGas  uint64 = 3    // Per-work price for a data copy operation\n\n\tBn256AddGasByzantium             uint64 = 500    // Byzantium gas needed for an elliptic curve addition\n\tBn256AddGasIstanbul              uint64 = 150    // Gas needed for an elliptic curve addition\n\tBn256ScalarMulGasByzantium       uint64 = 40000  // Byzantium gas needed for an elliptic curve scalar multiplication\n\tBn256ScalarMulGasIstanbul        uint64 = 6000   // Gas needed for an elliptic curve scalar multiplication\n\tBn256PairingBaseGasByzantium     uint64 = 100000 // Byzantium base price for an elliptic curve pairing check\n\tBn256PairingBaseGasIstanbul      uint64 = 45000  // Base price for an elliptic curve pairing check\n\tBn256PairingPerPointGasByzantium uint64 = 80000  // Byzantium per-point price for an elliptic curve pairing check\n\tBn256PairingPerPointGasIstanbul  uint64 = 34000  // Per-point price for an elliptic curve pairing check\n\n\tBls12381G1AddGas          uint64 = 500   // Price for BLS12-381 elliptic curve G1 point addition\n\tBls12381G1MulGas          uint64 = 12000 // Price for BLS12-381 elliptic curve G1 point scalar multiplication\n\tBls12381G2AddGas          uint64 = 800   // Price for BLS12-381 elliptic curve G2 point addition\n\tBls12381G2MulGas          uint64 = 45000 // Price for BLS12-381 elliptic curve G2 point scalar multiplication\n\tBls12381PairingBaseGas    uint64 = 65000 // Base gas price for BLS12-381 elliptic curve pairing check\n\tBls12381PairingPerPairGas uint64 = 43000 // Per-point pair gas price for BLS12-381 elliptic curve pairing check\n\tBls12381MapG1Gas          uint64 = 5500  // Gas price for BLS12-381 mapping field element to G1 operation\n\tBls12381MapG2Gas          uint64 = 75000 // Gas price for BLS12-381 mapping field element to G2 operation\n\n\t// The Refund Quotient is the cap on how much of the used gas can be refunded. Before EIP-3529,\n\t// up to half the consumed gas could be refunded. Redefined as 1/5th in EIP-3529\n\tRefundQuotient        uint64 = 2\n\tRefundQuotientEIP3529 uint64 = 5\n\n\tBlobTxBytesPerFieldElement         = 32      // Size in bytes of a field element\n\tBlobTxFieldElementsPerBlob         = 4096    // Number of field elements stored in a single data blob\n\tBlobTxBlobGasPerBlob               = 1 << 17 // Gas consumption of a single data blob (== blob byte size)\n\tBlobTxMinBlobGasprice              = 1       // Minimum gas price for data blobs\n\tBlobTxBlobGaspriceUpdateFraction   = 3338477 // Controls the maximum rate of change for blob gas price\n\tBlobTxPointEvaluationPrecompileGas = 50000   // Gas price for the point evaluation precompile.\n\n\tBlobTxTargetBlobGasPerBlock = 3 * BlobTxBlobGasPerBlob // Target consumable blob gas for data blobs per block (for 1559-like pricing)\n\tMaxBlobGasPerBlock          = 6 * BlobTxBlobGasPerBlob // Maximum consumable blob gas for data blobs per block\n)\n\n// Gas discount table for BLS12-381 G1 and G2 multi exponentiation operations\nvar Bls12381MultiExpDiscountTable = [128]uint64{1200, 888, 764, 641, 594, 547, 500, 453, 438, 423, 408, 394, 379, 364, 349, 334, 330, 326, 322, 318, 314, 310, 306, 302, 298, 294, 289, 285, 281, 277, 273, 269, 268, 266, 265, 263, 262, 260, 259, 257, 256, 254, 253, 251, 250, 248, 247, 245, 244, 242, 241, 239, 238, 236, 235, 233, 232, 231, 229, 228, 226, 225, 223, 222, 221, 220, 219, 219, 218, 217, 216, 216, 215, 214, 213, 213, 212, 211, 211, 210, 209, 208, 208, 207, 206, 205, 205, 204, 203, 202, 202, 201, 200, 199, 199, 198, 197, 196, 196, 195, 194, 193, 193, 192, 191, 191, 190, 189, 188, 188, 187, 186, 185, 185, 184, 183, 182, 182, 181, 180, 179, 179, 178, 177, 176, 176, 175, 174}\n\nvar (\n\tDifficultyBoundDivisor = big.NewInt(2048)   // The bound divisor of the difficulty, used in the update calculations.\n\tGenesisDifficulty      = big.NewInt(131072) // Difficulty of the Genesis block.\n\tMinimumDifficulty      = big.NewInt(131072) // The minimum that the difficulty may ever be.\n\tDurationLimit          = big.NewInt(13)     // The decision boundary on the blocktime duration used to determine whether difficulty should go up or not.\n\n\t// BeaconRootsAddress is the address where historical beacon roots are stored as per EIP-4788\n\tBeaconRootsAddress = common.HexToAddress(\"0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02\")\n\n\t// BeaconRootsCode is the code where historical beacon roots are stored as per EIP-4788\n\tBeaconRootsCode = common.FromHex(\"3373fffffffffffffffffffffffffffffffffffffffe14604d57602036146024575f5ffd5b5f35801560495762001fff810690815414603c575f5ffd5b62001fff01545f5260205ff35b5f5ffd5b62001fff42064281555f359062001fff015500\")\n\n\t// SystemAddress is where the system-transaction is sent from as per EIP-4788\n\tSystemAddress = common.HexToAddress(\"0xfffffffffffffffffffffffffffffffffffffffe\")\n)"
    }
  ]
}