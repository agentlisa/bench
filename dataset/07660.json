{
  "Title": "[M-14] Cross-chain replay attacks are possible with deployLPToken",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LPTokenFactory.sol#L27-L48\n\n\n# Vulnerability details\n\n### Impact\nMistakes made on one chain can be re-applied to a new chain\n\nThere is no chain.id in the data\n\nIf a user does `deployLPToken` using the wrong network, an attacker can replay the action on the correct chain, and steal the funds a-la the wintermute gnosis safe attack, where the attacker can create the same address that the user tried to, and steal the funds from there\n\n\nhttps://mirror.xyz/0xbuidlerdao.eth/lOE5VN-BHI0olGOXe27F0auviIuoSlnou_9t3XRJseY\n\n\n### Proof of Concept\n\n```js\ncontracts/liquid-staking/LPTokenFactory.sol:\n  26      /// @param _tokenName Name of the LP token to be deployed\n  27:     function deployLPToken(\n  28:         address _deployer,\n  29:         address _transferHookProcessor,\n  30:         string calldata _tokenSymbol,\n  31:         string calldata _tokenName\n  32:     ) external returns (address) {\n  33:         require(address(_deployer) != address(0), \"Zero address\");\n  34:         require(bytes(_tokenSymbol).length != 0, \"Symbol cannot be zero\");\n  35:         require(bytes(_tokenName).length != 0, \"Name cannot be zero\");\n  36: \n  37:         address newInstance = Clones.clone(lpTokenImplementation);\n  38:         ILPTokenInit(newInstance).init(\n  39:             _deployer,\n  40:             _transferHookProcessor,\n  41:             _tokenSymbol,\n  42:             _tokenName\n  43:         );\n  44: \n  45:         emit LPTokenDeployed(newInstance);\n  46: \n  47:         return newInstance;\n  48:     }\n```\n\n### Tools Used\nManual Code Review\n\n### Recommended Mitigation Steps\nInclude the chain.id \n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
  "Code": [
    {
      "filename": "contracts/liquid-staking/LPTokenFactory.sol",
      "content": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport { ILPTokenInit } from \"../interfaces/ILPTokenInit.sol\";\n\n/// @notice Contract for deploying a new LP token\ncontract LPTokenFactory {\n\n    /// @notice Emitted when a new LP token instance is deployed\n    event LPTokenDeployed(address indexed factoryCloneToken);\n\n    /// @notice Address of LP token implementation that is cloned on each LP token\n    address public lpTokenImplementation;\n\n    /// @param _lpTokenImplementation Address of LP token implementation that is cloned on each LP token deployment\n    constructor(address _lpTokenImplementation) {\n        require(_lpTokenImplementation != address(0), \"Address cannot be zero\");\n\n        lpTokenImplementation = _lpTokenImplementation;\n    }\n\n    /// @notice Deploys a new LP token\n    /// @param _tokenSymbol Symbol of the LP token to be deployed\n    /// @param _tokenName Name of the LP token to be deployed\n    function deployLPToken(\n        address _deployer,\n        address _transferHookProcessor,\n        string calldata _tokenSymbol,\n        string calldata _tokenName\n    ) external returns (address) {\n        require(address(_deployer) != address(0), \"Zero address\");\n        require(bytes(_tokenSymbol).length != 0, \"Symbol cannot be zero\");\n        require(bytes(_tokenName).length != 0, \"Name cannot be zero\");\n\n        address newInstance = Clones.clone(lpTokenImplementation);\n        ILPTokenInit(newInstance).init(\n            _deployer,\n            _transferHookProcessor,\n            _tokenSymbol,\n            _tokenName\n        );\n\n        emit LPTokenDeployed(newInstance);\n\n        return newInstance;\n    }\n}"
    }
  ]
}