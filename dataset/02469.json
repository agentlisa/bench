{
  "Title": "M-4: Attackers can call UToken.redeem() and drain the funds in assetManager",
  "Content": "# Issue M-4: Attackers can call UToken.redeem() and drain the funds in assetManager \n\nSource: https://github.com/sherlock-audit/2023-02-union-judging/issues/12 \n\n## Found by \nchaduke\n\n## Summary\nAttackers can call ``UToken.redeem()`` and drain the funds in assetManager, taking advantage of the following vulnerability: due to round error, it is possible that  ``uTokenAmount = 0``; the ``redeem()``function does not check whether ``uTokenAmount = 0`` and will redeem the amount of ``underlyingAmount`` even when zero uTokens are burned. \n\n## Vulnerability Detail\nConsider the following attack scenario:\n\n1) Suppose ``exchangeRate = 1000 WAD``, that is each utoken exchanges for 1000 underlying tokens. \n\n2) Attacker B calls ``redeem(0, 999)``, then the else-part of the following code will get executed:\n```javascript\n if (amountIn > 0) {\n            // We calculate the exchange rate and the amount of underlying to be redeemed:\n            // uTokenAmount = amountIn\n            // underlyingAmount = amountIn x exchangeRateCurrent\n            uTokenAmount = amountIn;\n            underlyingAmount = (amountIn * exchangeRate) / WAD;\n        } else {\n            // We get the current exchange rate and calculate the amount to be redeemed:\n            // uTokenAmount = amountOut / exchangeRate\n            // underlyingAmount = amountOut\n            uTokenAmount = (amountOut * WAD) / exchangeRate;\n            underlyingAmount = amountOut;\n        }\n```\n3) we have ``uTokenAmount = 999*WAD/1000WAD = 0``, and ``underlyingAmount = 999``.\n\n4) Since ``redeeem()`` does not check whether ``uTokenAmount = 0`` and the function will proceed. When finished, the attacker will get 999 underlying tokens, but burned no utokens. He stole 999 underlying tokens.\n\n5) The attacker can accomplish draining the ``assetManger`` by writing a malicious contract/function using a loop to run ``redeem(0, exchangeRate/WAD-1)`` multiple times (as long as not running of gas) and will be able to steal more funds in one SINGLE transaction.  Running this transaction a few times will drain ``assetManager`` easily.  This attack will be successful when ``exchangeRate/WAD-1 > 0``. Here we need to consider that ``exchangeRate`` might change due to the decreasing of ``totalReeemable``. So in each iteration, when we call ``redeem(0, exchangeRate/WAD-1)``, the second argument is recalculated. \n\n## Impact\nAn attacker can keep calling redeem() and drain the funds in ``assetManager``. \n\n## Code Snippet\n[https://github.com/sherlock-audit/2023-02-union/blob/main/union-v2-contracts/contracts/market/UToken.sol#L737-L771](https://github.com/sherlock-audit/2023-02-union/blob/main/union-v2-contracts/contracts/market/UToken.sol#L737-L771)\n\n## Tool used\nRemix\n\nManual Review\n\n## Recommendation\nRevise ``redeem()`` so that it will revert when ``uTokenAmount = 0``.\n\n## Discussion\n\n**kingjacob**\n\npoints valid, but not easy to increase exchangeRate exponentially. becasue exchangeRate starts from 1e18, 10x of exchangeRate means UToken value, by accruing interests, has increased 10x comparing to the underlying DAI. and the attack can profit 9 DAI in that case)\n\n**hrishibhat**\n\nAgree with the Sponsor on the severity of the issue as exchangeRate cannot be increase exponentially. Considering this a valid medium. \n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/44",
  "Code": [
    {
      "filename": "union-v2-contracts/contracts/market/UToken.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC20PermitUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\n\nimport {Controller} from \"../Controller.sol\";\nimport {IUserManager} from \"../interfaces/IUserManager.sol\";\nimport {IAssetManager} from \"../interfaces/IAssetManager.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {IInterestRateModel} from \"../interfaces/IInterestRateModel.sol\";\n\n/**\n *  @title UToken Contract\n *  @dev Union accountBorrows can borrow and repay thru this component.\n */\ncontract UToken is IUToken, Controller, ERC20PermitUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeCastUpgradeable for uint256;\n\n    /* -------------------------------------------------------------------\n      Types \n    ------------------------------------------------------------------- */\n\n    struct BorrowSnapshot {\n        uint256 principal;\n        uint256 interest;\n        uint256 interestIndex;\n        uint256 lastRepay; //Calculate if it is overdue\n    }\n\n    /* -------------------------------------------------------------------\n      Storage \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Wad do you want\n     */\n    uint256 public constant WAD = 1e18;\n\n    /**\n     * @dev Maximum borrow rate that can ever be applied (.005% / block)\n     */\n    uint256 internal constant BORROW_RATE_MAX_MANTISSA = 0.005e16;\n\n    /**\n     *  @dev Maximum fraction of interest that can be set aside for reserves\n     */\n    uint256 internal constant RESERVE_FACTORY_MAX_MANTISSA = 1e18;\n\n    /**\n     *  @dev Initial exchange rate used when minting the first UTokens (used when totalSupply = 0)\n     */\n    uint256 public initialExchangeRateMantissa;\n\n    /**\n     *  @dev Fraction of interest currently set aside for reserves\n     */\n    uint256 public reserveFactorMantissa;\n\n    /**\n     *  @dev Block number that interest was last accrued at\n     */\n    uint256 public accrualBlockNumber;\n\n    /**\n     *  @dev Accumulator of the total earned interest rate since the opening of the market\n     */\n    uint256 public borrowIndex;\n\n    /**\n     *  @dev Total amount of outstanding borrows of the underlying in this market\n     */\n    uint256 public totalBorrows;\n\n    /**\n     *  @dev Total amount of reserves of the underlying held in this market\n     */\n    uint256 public totalReserves;\n\n    /**\n     *  @dev Calculates the exchange rate from the underlying to the uToken\n     */\n    uint256 public totalRedeemable;\n\n    /**\n     *  @dev overdue duration, based on the number of blocks\n     */\n    uint256 public override overdueBlocks;\n\n    /**\n     *  @dev fee paid at loan origin\n     */\n    uint256 public originationFee;\n\n    /**\n     * @dev The max allowed value for originationFee\n     */\n    uint256 public originationFeeMax;\n\n    /**\n     *  @dev The debt limit for the whole system\n     */\n    uint256 public debtCeiling;\n\n    /**\n     *  @dev Max amount that can be borrowed by a single member\n     */\n    uint256 public maxBorrow;\n\n    /**\n     *  @dev Min amount that can be borrowed by a single member\n     */\n    uint256 public minBorrow;\n\n    /**\n     *  @dev Asset manager contract address\n     */\n    address public assetManager;\n\n    /**\n     *  @dev User manager contract address\n     */\n    address public userManager;\n\n    /**\n     * @dev Address of underlying token\n     */\n    address public underlying;\n\n    /**\n     * @dev Interest rate model used for calculating interest rate\n     */\n    IInterestRateModel public interestRateModel;\n\n    /**\n     * @notice Mapping of account addresses to outstanding borrow balances\n     */\n    mapping(address => BorrowSnapshot) internal accountBorrows;\n\n    /* -------------------------------------------------------------------\n      Errors \n    ------------------------------------------------------------------- */\n\n    error AccrueInterestFailed();\n    error AccrueBlockParity();\n    error AmountExceedGlobalMax();\n    error AmountExceedMaxBorrow();\n    error AmountLessMinBorrow();\n    error AmountError();\n    error AmountZero();\n    error BorrowRateExceedLimit();\n    error WithdrawFailed();\n    error CallerNotMember();\n    error CallerNotUserManager();\n    error InitExchangeRateNotZero();\n    error InsufficientFundsLeft();\n    error MemberIsOverdue();\n    error ReserveFactoryExceedLimit();\n    error DepositToAssetManagerFailed();\n    error OriginationFeeExceedLimit();\n\n    /* -------------------------------------------------------------------\n      Events \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Change of the interest rate model\n     *  @param oldInterestRateModel Old interest rate model address\n     *  @param newInterestRateModel New interest rate model address\n     */\n    event LogNewMarketInterestRateModel(address oldInterestRateModel, address newInterestRateModel);\n\n    /**\n     *  @dev Mint uToken by depositing token\n     *  @param minter address of minter\n     *  @param underlyingAmount amount of underlying token\n     *  @param uTokenAmount amount of uToken\n     */\n    event LogMint(address minter, uint256 underlyingAmount, uint256 uTokenAmount);\n\n    /**\n     *  @dev Redeem token for uToken\n     */\n    event LogRedeem(address redeemer, uint256 amountIn, uint256 amountOut, uint256 redeemAmount);\n\n    /**\n     *  @dev Token added to the reserves\n     *  @param reserver address of sender that added to reservers\n     *  @param actualAddAmount amount of tokens added\n     *  @param totalReservesNew new total reserve amount\n     */\n    event LogReservesAdded(address reserver, uint256 actualAddAmount, uint256 totalReservesNew);\n\n    /**\n     *  @dev Token removed from the reserves\n     *  @param receiver receiver address of tokens\n     *  @param reduceAmount amount of tokens to withdraw\n     *  @param totalReservesNew new total reserves amount\n     */\n    event LogReservesReduced(address receiver, uint256 reduceAmount, uint256 totalReservesNew);\n\n    /**\n     *  @dev Event borrow\n     *  @param account Member address\n     *  @param amount Borrow amount\n     *  @param fee Origination fee\n     */\n    event LogBorrow(address indexed account, address indexed to, uint256 amount, uint256 fee);\n\n    /**\n     *  @dev Event repay\n     *  @param account Member address\n     *  @param amount Repay amount\n     */\n    event LogRepay(address indexed payer, address indexed account, uint256 amount);\n\n    /* -------------------------------------------------------------------\n      Modifiers \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev modifier limit member\n     */\n    modifier onlyMember(address account) {\n        if (!IUserManager(userManager).checkIsMember(account)) revert CallerNotMember();\n        _;\n    }\n\n    modifier onlyUserManager() {\n        if (msg.sender != userManager) revert CallerNotUserManager();\n        _;\n    }\n\n    /* -------------------------------------------------------------------\n      Constructor/Initializer \n    ------------------------------------------------------------------- */\n\n    function __UToken_init(\n        string memory name_,\n        string memory symbol_,\n        address underlying_,\n        uint256 initialExchangeRateMantissa_,\n        uint256 reserveFactorMantissa_,\n        uint256 originationFee_,\n        uint256 originationFeeMax_,\n        uint256 debtCeiling_,\n        uint256 maxBorrow_,\n        uint256 minBorrow_,\n        uint256 overdueBlocks_,\n        address admin_\n    ) public initializer {\n        if (initialExchangeRateMantissa_ == 0) revert InitExchangeRateNotZero();\n        if (reserveFactorMantissa_ > RESERVE_FACTORY_MAX_MANTISSA) revert ReserveFactoryExceedLimit();\n        Controller.__Controller_init(admin_);\n        ERC20Upgradeable.__ERC20_init(name_, symbol_);\n        ERC20PermitUpgradeable.__ERC20Permit_init(name_);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        underlying = underlying_;\n        originationFee = originationFee_;\n        originationFeeMax = originationFeeMax_;\n        debtCeiling = debtCeiling_;\n        maxBorrow = maxBorrow_;\n        minBorrow = minBorrow_;\n        overdueBlocks = overdueBlocks_;\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        reserveFactorMantissa = reserveFactorMantissa_;\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = WAD;\n    }\n\n    /* -------------------------------------------------------------------\n      Setters \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev set Asset Manager contract address\n     *  Accept claims only from the admin\n     */\n    function setAssetManager(address assetManager_) external onlyAdmin {\n        assetManager = assetManager_;\n    }\n\n    /**\n     *  @dev set User Manager contract address\n     *  Accept claims only from the admin\n     */\n    function setUserManager(address userManager_) external onlyAdmin {\n        userManager = userManager_;\n    }\n\n    /**\n     *  @dev Change loan origination fee value\n     *  Accept claims only from the admin\n     *  @param originationFee_ Fees deducted for each loan transaction\n     */\n    function setOriginationFee(uint256 originationFee_) external override onlyAdmin {\n        if (originationFee_ > originationFeeMax) revert OriginationFeeExceedLimit();\n        originationFee = originationFee_;\n    }\n\n    /**\n     *  @dev Update the market debt ceiling to a fixed amount, for example, 1 billion DAI etc.\n     *  Accept claims only from the admin\n     *  @param debtCeiling_ The debt limit for the whole system\n     */\n    function setDebtCeiling(uint256 debtCeiling_) external override onlyAdmin {\n        debtCeiling = debtCeiling_;\n    }\n\n    /**\n     *  @dev Update the minimum loan size\n     *  Accept claims only from the admin\n     *  @param minBorrow_ Minimum loan amount per user\n     */\n    function setMinBorrow(uint256 minBorrow_) external override onlyAdmin {\n        minBorrow = minBorrow_;\n    }\n\n    /**\n     *  @dev Update the max loan size\n     *  Accept claims only from the admin\n     *  @param maxBorrow_ Max loan amount per user\n     */\n    function setMaxBorrow(uint256 maxBorrow_) external override onlyAdmin {\n        maxBorrow = maxBorrow_;\n    }\n\n    /**\n     *  @dev Change loan overdue duration, based on the number of blocks\n     *  Accept claims only from the admin\n     *  @param overdueBlocks_ Maximum late repayment block. The number of arrivals is a default\n     */\n    function setOverdueBlocks(uint256 overdueBlocks_) external override onlyAdmin {\n        overdueBlocks = overdueBlocks_;\n    }\n\n    /**\n     *  @dev Change to a different interest rate model\n     *  Accept claims only from the admin\n     *  @param newInterestRateModel_ New interest rate model address\n     */\n    function setInterestRateModel(address newInterestRateModel_) external override onlyAdmin {\n        address oldInterestRateModel = address(interestRateModel);\n        address newInterestRateModel = newInterestRateModel_;\n        interestRateModel = IInterestRateModel(newInterestRateModel);\n        emit LogNewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n    }\n\n    /**\n     *  @dev set reserve factor mantissa\n     *  Accept claims only from the admin\n     */\n    function setReserveFactor(uint256 reserveFactorMantissa_) external override onlyAdmin {\n        if (reserveFactorMantissa_ > RESERVE_FACTORY_MAX_MANTISSA) revert ReserveFactoryExceedLimit();\n        reserveFactorMantissa = reserveFactorMantissa_;\n    }\n\n    /* -------------------------------------------------------------------\n      View Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Returns the remaining amount that can be borrowed from the market.\n     *  @return Remaining total amount\n     */\n    function getRemainingDebtCeiling() public view override returns (uint256) {\n        return debtCeiling >= totalBorrows ? debtCeiling - totalBorrows : 0;\n    }\n\n    /**\n     *  @dev Get the last repay block\n     *  @param account Member address\n     *  @return lastRepay\n     */\n    function getLastRepay(address account) public view override returns (uint256) {\n        return accountBorrows[account].lastRepay;\n    }\n\n    /**\n     *  @dev Check if the member's loan is overdue\n     *  @param account Member address\n     *  @return isOverdue\n     */\n    function checkIsOverdue(address account) public view override returns (bool isOverdue) {\n        if (getBorrowed(account) != 0) {\n            uint256 lastRepay = getLastRepay(account);\n            uint256 diff = getBlockNumber() - lastRepay;\n            isOverdue = overdueBlocks < diff;\n        }\n    }\n\n    /**\n     *  @dev Get the origination fee\n     *  @param amount Amount to be calculated\n     *  @return Handling fee\n     */\n    function calculatingFee(uint256 amount) public view override returns (uint256) {\n        return (originationFee * amount) / WAD;\n    }\n\n    /**\n     *  @dev Get the borrowed principle\n     *  @param account Member address\n     *  @return borrowed\n     */\n    function getBorrowed(address account) public view override returns (uint256) {\n        return accountBorrows[account].principal;\n    }\n\n    /**\n     *  @dev Get a member's current owed balance, including the principle and interest but without updating the user's states.\n     *  @param account Member address\n     *  @return Borrowed amount\n     */\n    function borrowBalanceView(address account) public view override returns (uint256) {\n        return getBorrowed(account) + calculatingInterest(account);\n    }\n\n    /**\n     *  @dev Get a member's total owed, including the principle and the interest calculated based on the interest index.\n     *  @param account Member address\n     *  @return Borrowed amount\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (uint256) {\n        BorrowSnapshot memory loan = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (loan.principal == 0) {\n            return 0;\n        }\n\n        uint256 principalTimesIndex = (loan.principal + loan.interest) * borrowIndex;\n        return principalTimesIndex / loan.interestIndex;\n    }\n\n    /**\n     *  @dev Get the borrowing interest rate per block\n     *  @return Borrow rate\n     */\n    function borrowRatePerBlock() public view override returns (uint256) {\n        uint256 borrowRateMantissa = interestRateModel.getBorrowRate();\n        if (borrowRateMantissa > BORROW_RATE_MAX_MANTISSA) revert BorrowRateExceedLimit();\n\n        return borrowRateMantissa;\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this UToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external view override returns (uint256) {\n        return interestRateModel.getSupplyRate(reserveFactorMantissa);\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the UToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public view returns (uint256) {\n        uint256 totalSupply_ = totalSupply();\n        return totalSupply_ == 0 ? initialExchangeRateMantissa : (totalRedeemable * WAD) / totalSupply_;\n    }\n\n    /**\n     *  @dev Calculating member's borrowed interest\n     *  @param account Member address\n     *  @return Interest amount\n     */\n    function calculatingInterest(address account) public view override returns (uint256) {\n        BorrowSnapshot memory loan = accountBorrows[account];\n\n        if (loan.principal == 0) {\n            return 0;\n        }\n\n        uint256 borrowRate = borrowRatePerBlock();\n        uint256 currentBlockNumber = getBlockNumber();\n        uint256 blockDelta = currentBlockNumber - accrualBlockNumber;\n        uint256 simpleInterestFactor = borrowRate * blockDelta;\n        uint256 borrowIndexNew = (simpleInterestFactor * borrowIndex) / WAD + borrowIndex;\n\n        uint256 principalTimesIndex = (loan.principal + loan.interest) * borrowIndexNew;\n        uint256 balance = principalTimesIndex / loan.interestIndex;\n\n        return balance - getBorrowed(account);\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public nonReentrant returns (uint256) {\n        if (!accrueInterest()) revert AccrueInterestFailed();\n        return exchangeRateStored();\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external view override returns (uint256) {\n        return (exchangeRateStored() * balanceOf(owner)) / WAD;\n    }\n\n    /* -------------------------------------------------------------------\n       Borrowing/Repay Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Borrowing from the market\n     *  Accept claims only from the member\n     *  Borrow amount must in the range of creditLimit, minBorrow, maxBorrow, debtCeiling and not overdue\n     *  @param amount Borrow amount\n     */\n    function borrow(address to, uint256 amount) external override onlyMember(msg.sender) whenNotPaused nonReentrant {\n        IAssetManager assetManagerContract = IAssetManager(assetManager);\n        if (amount < minBorrow) revert AmountLessMinBorrow();\n        if (amount > getRemainingDebtCeiling()) revert AmountExceedGlobalMax();\n\n        // Calculate the origination fee\n        uint256 fee = calculatingFee(amount);\n\n        if (borrowBalanceView(msg.sender) + amount + fee > maxBorrow) revert AmountExceedMaxBorrow();\n        if (checkIsOverdue(msg.sender)) revert MemberIsOverdue();\n        if (amount > assetManagerContract.getLoanableAmount(underlying)) revert InsufficientFundsLeft();\n        if (!accrueInterest()) revert AccrueInterestFailed();\n\n        uint256 borrowedAmount = borrowBalanceStoredInternal(msg.sender);\n\n        // Initialize the last repayment date to the current block number\n        if (getLastRepay(msg.sender) == 0) {\n            accountBorrows[msg.sender].lastRepay = getBlockNumber();\n        }\n\n        // Withdraw the borrowed amount of tokens from the assetManager and send them to the borrower\n        uint256 remaining = assetManagerContract.withdraw(underlying, to, amount);\n        if (remaining > amount) revert WithdrawFailed();\n        uint256 actualAmount = amount - remaining;\n\n        fee = calculatingFee(actualAmount);\n        uint256 accountBorrowsNew = borrowedAmount + actualAmount + fee;\n        uint256 totalBorrowsNew = totalBorrows + actualAmount + fee;\n\n        // Update internal balances\n        accountBorrows[msg.sender].principal += actualAmount + fee;\n        uint256 newPrincipal = getBorrowed(msg.sender);\n        accountBorrows[msg.sender].interest = accountBorrowsNew - newPrincipal;\n        accountBorrows[msg.sender].interestIndex = borrowIndex;\n        totalBorrows = totalBorrowsNew;\n\n        // The origination fees contribute to the reserve and not to the\n        // uDAI minters redeemable amount.\n        totalReserves += fee;\n\n        // Call update locked on the userManager to lock this borrowers stakers. This function\n        // will revert if the account does not have enough vouchers to cover the borrow amount. ie\n        // the borrower is trying to borrow more than is able to be underwritten\n        IUserManager(userManager).updateLocked(msg.sender, (actualAmount + fee).toUint96(), true);\n\n        emit LogBorrow(msg.sender, to, actualAmount, fee);\n    }\n\n    /**\n     * @dev Helper function to repay interest amount\n     * @param borrower Borrower address\n     */\n    function repayInterest(address borrower) external override whenNotPaused nonReentrant {\n        if (!accrueInterest()) revert AccrueInterestFailed();\n        uint256 interest = calculatingInterest(borrower);\n        _repayBorrowFresh(msg.sender, borrower, interest, interest);\n    }\n\n    /**\n     * @notice Repay outstanding borrow\n     * @dev Repay borrow see _repayBorrowFresh\n     */\n    function repayBorrow(address borrower, uint256 amount) external override whenNotPaused nonReentrant {\n        if (!accrueInterest()) revert AccrueInterestFailed();\n        uint256 interest = calculatingInterest(borrower);\n        _repayBorrowFresh(msg.sender, borrower, amount, interest);\n    }\n\n    /**\n     *  @dev Repay the loan\n     *  Updated member lastPaymentEpoch only when the repayment amount is greater than interest\n     *  @param payer Payer address\n     *  @param borrower Borrower address\n     *  @param amount Repay amount\n     *  @param interest Interest amount\n     */\n    function _repayBorrowFresh(address payer, address borrower, uint256 amount, uint256 interest) internal {\n        if (getBlockNumber() != accrualBlockNumber) revert AccrueBlockParity();\n        uint256 borrowedAmount = borrowBalanceStoredInternal(borrower);\n        uint256 repayAmount = amount > borrowedAmount ? borrowedAmount : amount;\n        if (repayAmount == 0) revert AmountZero();\n\n        uint256 toReserveAmount;\n        uint256 toRedeemableAmount;\n\n        if (repayAmount >= interest) {\n            // If the repayment amount is greater than the interest (min payment)\n            bool isOverdue = checkIsOverdue(borrower);\n\n            // Interest is split between the reserves and the uToken minters based on\n            // the reserveFactorMantissa When set to WAD all the interest is paid to teh reserves.\n            // any interest that isn't sent to the reserves is added to the redeemable amount\n            // and can be redeemed by uToken minters.\n            toReserveAmount = (interest * reserveFactorMantissa) / WAD;\n            toRedeemableAmount = interest - toReserveAmount;\n\n            // Update the total borrows to reduce by the amount of principal that has\n            // been paid off\n            totalBorrows -= (repayAmount - interest);\n\n            // Update the account borrows to reflect the repayment\n            accountBorrows[borrower].principal = borrowedAmount - repayAmount;\n            accountBorrows[borrower].interest = 0;\n\n            // Call update locked on the userManager to lock this borrowers stakers. This function\n            // will revert if the account does not have enough vouchers to cover the repay amount. ie\n            // the borrower is trying to repay more than is locked (owed)\n            IUserManager(userManager).updateLocked(borrower, (repayAmount - interest).toUint96(), false);\n\n            if (isOverdue) {\n                // For borrowers that are paying back overdue balances we need to update their\n                // frozen balance and the global total frozen balance on the UserManager\n                IUserManager(userManager).onRepayBorrow(borrower);\n            }\n\n            if (getBorrowed(borrower) == 0) {\n                // If the principal is now 0 we can reset the last repaid block to 0.\n                // which indicates that the borrower has no outstanding loans.\n                accountBorrows[borrower].lastRepay = 0;\n            } else {\n                // Save the current block number as last repaid\n                accountBorrows[borrower].lastRepay = getBlockNumber();\n            }\n        } else {\n            // For repayments that don't pay off the minimum we just need to adjust the\n            // global balances and reduce the amount of interest accrued for the borrower\n            toReserveAmount = (repayAmount * reserveFactorMantissa) / WAD;\n            toRedeemableAmount = repayAmount - toReserveAmount;\n            accountBorrows[borrower].interest = interest - repayAmount;\n        }\n\n        totalReserves += toReserveAmount;\n        totalRedeemable += toRedeemableAmount;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        // Transfer underlying token that have been repaid and then deposit\n        // then in the asset manager so they can be distributed between the\n        // underlying money markets\n        IERC20Upgradeable(underlying).safeTransferFrom(payer, address(this), repayAmount);\n        _depositToAssetManager(repayAmount);\n\n        emit LogRepay(payer, borrower, repayAmount);\n    }\n\n    /**\n     *  @dev Accrue interest\n     *  @return Accrue interest finished\n     */\n    function accrueInterest() public override returns (bool) {\n        uint256 borrowRate = borrowRatePerBlock();\n        uint256 currentBlockNumber = getBlockNumber();\n        uint256 blockDelta = currentBlockNumber - accrualBlockNumber;\n\n        uint256 simpleInterestFactor = borrowRate * blockDelta;\n        uint256 borrowIndexNew = (simpleInterestFactor * borrowIndex) / WAD + borrowIndex;\n\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n\n        return true;\n    }\n\n    function debtWriteOff(address borrower, uint256 amount) external override whenNotPaused onlyUserManager {\n        if (amount == 0) revert AmountZero();\n\n        uint256 oldPrincipal = getBorrowed(borrower);\n        uint256 repayAmount = amount > oldPrincipal ? oldPrincipal : amount;\n\n        accountBorrows[borrower].principal = oldPrincipal - repayAmount;\n        totalBorrows -= repayAmount;\n\n        if (repayAmount == oldPrincipal) {\n            // If all principal is written off, we can reset the last repaid block to 0.\n            // which indicates that the borrower has no outstanding loans.\n            accountBorrows[borrower].lastRepay = 0;\n        }\n    }\n\n    /* -------------------------------------------------------------------\n       mint and redeem uToken Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Mint uTokens by depositing tokens\n     * @param amountIn The amount of the underlying asset to supply\n     */\n    function mint(uint256 amountIn) external override whenNotPaused nonReentrant {\n        if (!accrueInterest()) revert AccrueInterestFailed();\n        uint256 exchangeRate = exchangeRateStored();\n        IERC20Upgradeable assetToken = IERC20Upgradeable(underlying);\n        uint256 balanceBefore = assetToken.balanceOf(address(this));\n        assetToken.safeTransferFrom(msg.sender, address(this), amountIn);\n        uint256 balanceAfter = assetToken.balanceOf(address(this));\n        uint256 actualMintAmount = balanceAfter - balanceBefore;\n        totalRedeemable += actualMintAmount;\n        uint256 mintTokens = (actualMintAmount * WAD) / exchangeRate;\n        _mint(msg.sender, mintTokens);\n\n        _depositToAssetManager(actualMintAmount);\n\n        emit LogMint(msg.sender, actualMintAmount, mintTokens);\n    }\n\n    /**\n     * @notice User redeems uTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param amountIn The number of uTokens to redeem into underlying\n     *        (only one of amountIn or amountOut may be non-zero)\n     * @param amountOut The number of underlying tokens to receive from\n     *        (only one of amountIn or amountOut may be non-zero)\n     */\n    function redeem(uint256 amountIn, uint256 amountOut) external override whenNotPaused nonReentrant {\n        if (!accrueInterest()) revert AccrueInterestFailed();\n        if (amountIn != 0 && amountOut != 0) revert AmountError();\n        if (amountIn == 0 && amountOut == 0) revert AmountZero();\n\n        uint256 exchangeRate = exchangeRateStored();\n\n        // Amount of the uToken to burn\n        uint256 uTokenAmount;\n\n        // Amount of the underlying token to redeem\n        uint256 underlyingAmount;\n\n        if (amountIn > 0) {\n            // We calculate the exchange rate and the amount of underlying to be redeemed:\n            // uTokenAmount = amountIn\n            // underlyingAmount = amountIn x exchangeRateCurrent\n            uTokenAmount = amountIn;\n            underlyingAmount = (amountIn * exchangeRate) / WAD;\n        } else {\n            // We get the current exchange rate and calculate the amount to be redeemed:\n            // uTokenAmount = amountOut / exchangeRate\n            // underlyingAmount = amountOut\n            uTokenAmount = (amountOut * WAD) / exchangeRate;\n            underlyingAmount = amountOut;\n        }\n\n        uint256 remaining = IAssetManager(assetManager).withdraw(underlying, msg.sender, underlyingAmount);\n        if (remaining > underlyingAmount) revert WithdrawFailed();\n        uint256 actualAmount = underlyingAmount - remaining;\n        totalRedeemable -= actualAmount;\n        uint256 realUtokenAmount = (actualAmount * WAD) / exchangeRate;\n        _burn(msg.sender, realUtokenAmount);\n        emit LogRedeem(msg.sender, amountIn, amountOut, actualAmount);\n    }\n\n    /* -------------------------------------------------------------------\n       Reserve Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Add tokens to the reseve\n     * @param addAmount amount of tokens to add\n     */\n    function addReserves(uint256 addAmount) external override whenNotPaused nonReentrant {\n        if (!accrueInterest()) revert AccrueInterestFailed();\n        IERC20Upgradeable assetToken = IERC20Upgradeable(underlying);\n        uint256 balanceBefore = assetToken.balanceOf(address(this));\n        assetToken.safeTransferFrom(msg.sender, address(this), addAmount);\n        uint256 balanceAfter = assetToken.balanceOf(address(this));\n        uint256 actualAddAmount = balanceAfter - balanceBefore;\n\n        totalReserves += actualAddAmount;\n\n        _depositToAssetManager(balanceAfter);\n\n        emit LogReservesAdded(msg.sender, actualAddAmount, totalReserves);\n    }\n\n    /**\n     * @dev Remove tokens to the reserve\n     * @param receiver address to receive tokens\n     * @param reduceAmount amount of tokens to remove\n     */\n    function removeReserves(\n        address receiver,\n        uint256 reduceAmount\n    ) external override whenNotPaused nonReentrant onlyAdmin {\n        if (reduceAmount > totalReserves) revert AmountError();\n        if (!accrueInterest()) revert AccrueInterestFailed();\n\n        uint256 remaining = IAssetManager(assetManager).withdraw(underlying, receiver, reduceAmount);\n        if (remaining > reduceAmount) revert WithdrawFailed();\n        uint256 actualAmount = reduceAmount - remaining;\n        totalReserves -= actualAmount;\n\n        emit LogReservesReduced(receiver, actualAmount, totalReserves);\n    }\n\n    /* -------------------------------------------------------------------\n       Internal Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n\n    /**\n     *  @dev Deposit tokens to the asset manager\n     */\n    function _depositToAssetManager(uint256 amount) internal {\n        IERC20Upgradeable assetToken = IERC20Upgradeable(underlying);\n\n        uint256 currentAllowance = assetToken.allowance(address(this), assetManager);\n        if (currentAllowance < amount) {\n            assetToken.safeIncreaseAllowance(assetManager, amount - currentAllowance);\n        }\n\n        if (!IAssetManager(assetManager).deposit(underlying, amount)) revert DepositToAssetManagerFailed();\n    }\n}"
    }
  ]
}