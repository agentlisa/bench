{
  "Title": "M-1: WETH was never set in baseLeverageExecutor.sol",
  "Content": "# Issue M-1: WETH was never set in baseLeverageExecutor.sol \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/12 \n\n## Found by \nAuditorPraise\n## Summary\nWETH State Var was never set in baseLeverageExecutor.sol\n## Vulnerability Details\nsee summary\n## Impact\nWETH will be address zero, it won't be possible to wrap and unwrap ETH\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/leverage/BaseLeverageExecutor.sol#L47\n## Tool used\n\nManual Review\n\n## Recommendation\ninitialize the WETH state Var via the constructor.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**WangAudit** commented:\n> looks like it's intended\n\n\n\n**nevillehuang**\n\n@0xRektora @maarcweiss \n\nJust to double confirm, afaik `weth` seems to be never be set anywhere in the contracts so this issue is true correct?\n\n**cryptotechmaker**\n\nFixed here https://github.com/Tapioca-DAO/Tapioca-bar/pull/346\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/Tapioca-bar/pull/346.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/contracts/markets/leverage/BaseLeverageExecutor.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {IZeroXSwapper} from \"tapioca-periph/interfaces/periph/IZeroXSwapper.sol\";\nimport {IWeth9} from \"tapioca-periph/interfaces/external/weth/IWeth9.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nstruct SToftInfo {\n    bool isTokenInToft;\n    bool isTokenOutToft;\n}\n\nstruct SLeverageSwapData {\n    uint256 minAmountOut;\n    SToftInfo toftInfo;\n    bytes swapperData;\n}\n\nabstract contract BaseLeverageExecutor is Ownable {\n    using SafeApprove for address;\n    using SafeERC20 for IERC20;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n\n    IZeroXSwapper public swapper;\n    ICluster public cluster;\n    IWeth9 public weth;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n\n    error MinAmountNotValid(uint256 expected, uint256 received);\n    error SwapperNotAuthorized();\n    error SwapperNotValid();\n    error SenderNotValid();\n    error TokenNotValid();\n    error NativeNotSupported();\n\n    constructor(IZeroXSwapper _swapper, ICluster _cluster) {\n        swapper = _swapper;\n        cluster = _cluster;\n    }\n\n    receive() external payable {}\n\n    // ******************** //\n    // *** OWNER METHODS *** //\n    // ******************** //\n\n    /// @notice sets swapper\n    /// @param _swapper the new IZeroXSwapper\n    function setSwapper(IZeroXSwapper _swapper) external onlyOwner {\n        swapper = _swapper;\n    }\n\n    /// @notice sets cluster\n    /// @param _cluster the new ICluster\n    function setCluster(ICluster _cluster) external onlyOwner {\n        cluster = _cluster;\n    }\n\n    // ********************* //\n    // *** PUBLIC METHODS *** //\n    // ********************* //\n\n    /**\n     * @notice Buys an asked amount of collateral with an asset using the ZeroXSwapper.\n     * @dev Expects the token to be already transferred to this contract.\n     * @param assetAddress asset address.\n     * @param collateralAddress collateral address.\n     * @param assetAmountIn amount to swap.\n     * @param data SLeverageSwapData.\n     */\n    function getCollateral(address assetAddress, address collateralAddress, uint256 assetAmountIn, bytes calldata data)\n        external\n        payable\n        virtual\n        returns (uint256 collateralAmountOut)\n    {}\n\n    /**\n     * @notice Buys an asked amount of asset with a collateral using the ZeroXSwapper.\n     * @dev Expects the token to be already transferred to this contract.\n     * @param collateralAddress collateral address.\n     * @param assetAddress asset address.\n     * @param collateralAmountIn amount to swap.\n     * @param data SLeverageSwapData.\n     */\n    function getAsset(address collateralAddress, address assetAddress, uint256 collateralAmountIn, bytes calldata data)\n        external\n        virtual\n        returns (uint256 assetAmountOut)\n    {}\n\n    // *********************** //\n    // *** INTERNAL METHODS *** //\n    // *********************** //\n\n    /**\n     * @notice Sell `tokenIn` and buy `tokenOut`.\n     * @dev Sends the `amountOut` of `tokenOut` to the sender if `sendBack` is true, by wrapping or transferring it.\n     *\n     * @param tokenIn token to swap. Can be tOFT.\n     * @param tokenOut token to receive. Can be tOFT.\n     * @param amountIn amount to swap.\n     * @param data SLeverageSwapData.\n     */\n    function _swapAndTransferToSender(\n        bool sendBack,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        bytes memory data\n    ) internal returns (uint256 amountOut) {\n        SLeverageSwapData memory swapData = abi.decode(data, (SLeverageSwapData));\n\n        // If the tokenIn is a tOFT, unwrap it. Handles ETH and ERC20.\n        if (swapData.toftInfo.isTokenInToft) {\n            tokenIn = _handleToftUnwrap(tokenIn, amountIn);\n        }\n\n        // Approve the swapper to spend the tokenIn, and perform the swap.\n        tokenIn.safeApprove(address(swapper), amountIn);\n        IZeroXSwapper.SZeroXSwapData memory swapperData =\n            abi.decode(swapData.swapperData, (IZeroXSwapper.SZeroXSwapData));\n        amountOut = swapper.swap(swapperData, amountIn, swapData.minAmountOut);\n        if (amountOut < swapData.minAmountOut) revert MinAmountNotValid(swapData.minAmountOut, amountOut);\n        tokenIn.safeApprove(address(swapper), 0);\n\n        // If the tokenOut is a tOFT, wrap it. Handles ETH and ERC20.\n        // If `sendBack` is true, wrap the `amountOut to` the sender. else, wrap it to this contract.\n        if (swapData.toftInfo.isTokenOutToft) {\n            _handleToftWrapToSender(sendBack, tokenOut, amountOut);\n        } else if (sendBack == true) {\n            // If the token wasn't sent by the wrap OP, send it as a transfer.\n            IERC20(tokenOut).safeTransfer(msg.sender, amountOut);\n        }\n    }\n\n    /**\n     * @notice Unwraps a tOFT token if it is the tokenIn. If the tOFT is an ERC20, it unwraps it and returns the ERC20 address.\n     * if the tOFT is an ETH, it unwraps it and returns the WETH address.\n     *\n     * @param tokenIn tOFT token to unwrap.\n     * @param amountIn amount to unwrap.\n     * @return tokenToSwap address of the token to swap. Either WETH or the ERC20 address.\n     */\n    function _handleToftUnwrap(address tokenIn, uint256 amountIn) internal returns (address tokenToSwap) {\n        ITOFT(tokenIn).unwrap(address(this), amountIn); // Sends ETH to `receive()` if not an ERC20.\n        tokenIn = ITOFT(tokenIn).erc20();\n        // If the tokenIn is ETH, wrap it to WETH.\n        if (tokenIn == address(0)) {\n            weth.deposit{value: amountIn}();\n            tokenToSwap = address(weth);\n        } else {\n            tokenToSwap = tokenIn;\n        }\n    }\n\n    /**\n     * @notice Wrap an ERC20 or ETH to a `tokenOut` tOFT token.\n     * @dev Wraps the amountOut and sends it to the sender.\n     *\n     * @param sendBack if true, sends the `amountOut` to the sender. Else, sends it to this contract.\n     * @param tokenOut tOFT token.\n     * @param amountOut amount to wrap.\n     */\n    function _handleToftWrapToSender(bool sendBack, address tokenOut, uint256 amountOut) internal {\n        address toftErc20 = ITOFT(tokenOut).erc20();\n        address wrapsTo = sendBack == true ? msg.sender : address(this);\n\n        if (toftErc20 == address(0)) {\n            // If the tOFT is for ETH, withdraw from WETH and wrap it.\n            weth.withdraw(amountOut);\n            ITOFT(tokenOut).wrap{value: amountOut}(address(this), wrapsTo, amountOut);\n        } else {\n            // If the tOFT is for an ERC20, wrap it.\n            toftErc20.safeApprove(tokenOut, amountOut);\n            ITOFT(tokenOut).wrap(address(this), wrapsTo, amountOut);\n            toftErc20.safeApprove(tokenOut, 0);\n        }\n    }\n}"
    }
  ]
}