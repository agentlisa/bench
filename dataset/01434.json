{
  "Title": "Owner can incorrectly pull funds from contests not yet expired",
  "Content": "# Owner can incorrectly pull funds from contests not yet expired\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-08-sparkn/blob/main/src/ProxyFactory.sol#L195-L218\">https://github.com/Cyfrin/2023-08-sparkn/blob/main/src/ProxyFactory.sol#L195-L218</a>\n\n\n## Summary\nOwner can incorrectly pull funds from a closed contest which has not yet expired using `distributeByOwner()`.\n\n## Vulnerability Details\nThe `distributeByOwner()` function has 5 parameters: `proxy, organizer, contestId, implementation, data`. However, there is no 'linkage' between `proxy` and the remaining params. <br>\nIn order to check if the contest has expired, it uses `bytes32 salt = _calculateSalt(organizer, contestId, implementation);`. There is no check if this is indeed the salt of the `proxy` address. Hence, the owner can by mistake call `distributeByOwner()` with an incorrect `proxy` address of a contest which is closed, but not yet expired and drain its funds incorrectly.<br>\n**PoC:** (run via `forge test --mt test_OwnerCanIncorrectlyPullFundsFromContestsNotYetExpired -vv`)\n```js\n    function test_OwnerCanIncorrectlyPullFundsFromContestsNotYetExpired() public {\n        // Imagine that 2 contests are started by the same organizer & sponsor. This is just for\n        // simplicity; the organizers/sponsors can be considered as different too for the contests in question.\n\n        vm.startPrank(factoryAdmin);\n        bytes32 randomId_1 = keccak256(abi.encode(\"Jason\", \"015\")); // contest_1\n        bytes32 randomId_2 = keccak256(abi.encode(\"Watson\", \"016\")); // contest_2\n        proxyFactory.setContest(organizer, randomId_1, block.timestamp + 8 days, address(distributor));\n        proxyFactory.setContest(organizer, randomId_2, block.timestamp + 10 days, address(distributor));\n        vm.stopPrank();\n\n        bytes32 salt_1 = keccak256(abi.encode(organizer, randomId_1, address(distributor)));\n        address proxyAddress_1 = proxyFactory.getProxyAddress(salt_1, address(distributor));\n        bytes32 salt_2 = keccak256(abi.encode(organizer, randomId_2, address(distributor)));\n        address proxyAddress_2 = proxyFactory.getProxyAddress(salt_2, address(distributor));\n\n        vm.startPrank(sponsor);\n        // sponsor funds both his contests\n        MockERC20(jpycv2Address).transfer(proxyAddress_1, 10000 ether);\n        MockERC20(jpycv2Address).transfer(proxyAddress_2, 500 ether);\n        vm.stopPrank();\n\n        // before\n        assertEq(MockERC20(jpycv2Address).balanceOf(user1), 0 ether, \"user1 balance not zero\");\n        assertEq(MockERC20(jpycv2Address).balanceOf(stadiumAddress), 0 ether, \"STADIUM balance not zero\");\n        assertEq(MockERC20(jpycv2Address).balanceOf(proxyAddress_1), 10000 ether, \"proxy1 balance not 10000e18\");\n        assertEq(MockERC20(jpycv2Address).balanceOf(proxyAddress_2), 500 ether, \"proxy2 balance not 500e18\");\n\n        bytes memory data = createData();\n\n        // 9 days later, organizer deploy and distribute -- for contest_1\n        vm.warp(9 days);\n        vm.prank(organizer);\n        proxyFactory.deployProxyAndDistribute(randomId_1, address(distributor), data);\n        // sponsor send token to proxy by mistake\n        vm.prank(sponsor);\n        MockERC20(jpycv2Address).transfer(proxyAddress_1, 11000 ether);\n\n        // 11 days later, organizer deploy and distribute -- for contest_2\n        vm.warp(11 days);\n        vm.prank(organizer);\n        proxyFactory.deployProxyAndDistribute(randomId_2, address(distributor), data);\n        // sponsor send token to proxy by mistake\n        vm.prank(sponsor);\n        MockERC20(jpycv2Address).transfer(proxyAddress_2, 600 ether);\n\n        // create data to send the token to admin\n        bytes memory dataToSendToAdmin = createDataToSendToAdmin();\n\n        // 16 days later from the start date, contest_1 has EXPIRED,\n        // but contest_2 is only CLOSED, not \"EXPIRED\".\n        // Hence, Owner should NOT be able to distribute rewards from funds reserved for contest_2.\n        vm.warp(16 days);\n        vm.prank(factoryAdmin);\n        // Owner provides `proxyAddress_2` by mistake, but remaining params are for `contest_1`\n        proxyFactory.distributeByOwner(proxyAddress_2, organizer, randomId_1, address(distributor), dataToSendToAdmin);\n        // above call should have reverted with \"ProxyFactory__ContestIsNotExpired()\"\n\n        // after\n        // STADIUM balance has now become (5% of 10000) + (5% of 500) + 600\n        assertEq(MockERC20(jpycv2Address).balanceOf(stadiumAddress), 1125 ether, \"STADIUM balance not 1125e18\");\n        assertEq(MockERC20(jpycv2Address).balanceOf(proxyAddress_1), 11000 ether, \"proxy1 balance not 11000e18\");\n        // contest_2 is fully drained\n        assertEq(MockERC20(jpycv2Address).balanceOf(proxyAddress_2), 0, \"proxy2 balance not zero\");\n    }\n```\nThe above is even more serious if Owner is *trying to return the funds to `sponsor1` using `distributeByOwner()`*. Sponsor1 will get Sponsor2's funds (95% of funds, at the most).<br>\n**OR**<br>\nIf the owner, upon a request from the sponsor, is trying to distribute `contest_1's` extra funds deposited by the sponsor as rewards to its winners. These winners would be completely different from the winners of `contest_2`, but funds from `contest_2` will be redirected to \"winner_1s\".<br>\n<br>\nNoteworthy is the fact that once any sponsor deposits extra funds by mistake later on *(after proxy has been deployed via `deployProxyAndDistribute()` or similar functions & the rewards have been distributed once)* he can only take the help of the owner to send the funds to any specific address(es).\n\n## Impact\n- **Loss of funds** as it can be drained by the owner by mistake from a not-yet-expired contest.\n- **Funds/Rewards could be sent to incorrect sponsor/winners**\n- **Bypasses intended functionality**.\n\n## Tools Used\nManual review, forge.\n\n## Recommendations\nAdd the following line inside `distributeByOwner()`:\n```\nrequire(getProxyAddress(salt, implementation) == proxy);\n```",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/cllcnja1h0001lc08z7w0orxx",
  "Code": [
    {
      "filename": "src/ProxyFactory.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// Layout of Contract:\n// version\n// imports\n// errors\n// interfaces, libraries, contracts\n// Type declarations\n// State variables\n// Events\n// Modifiers\n// Functions\n\n// Layout of Functions:\n// constructor\n// receive function (if exists)\n// fallback function (if exists)\n// external\n// public\n// internal\n// private\n// view & pure functions\n\npragma solidity 0.8.18;\n\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\nimport {ECDSA} from \"openzeppelin/utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"openzeppelin/utils/cryptography/EIP712.sol\";\nimport {Proxy} from \"./Proxy.sol\";\n\n/**\n * @title ProxyFactory contract\n * @notice This contract is the main entry point for users to use SPARKN's contracts.\n * @notice It will be used to deploy proxy contracts for every contest in SPARKN.\n * @dev This contract is the factory contract which will be used to deploy proxy contracts.\n */\ncontract ProxyFactory is Ownable, EIP712 {\n    //////////////////////\n    /////// Error ////////\n    //////////////////////\n    error ProxyFactory__NoEmptyArray();\n    error ProxyFactory__NoZeroAddress();\n    error ProxyFactory__CloseTimeNotInRange();\n    error ProxyFactory__InvalidSignature();\n    error ProxyFactory__ContestIsAlreadyRegistered();\n    error ProxyFactory__ContestIsNotClosed();\n    error ProxyFactory__ContestIsNotRegistered();\n    error ProxyFactory__ContestIsNotExpired();\n    error ProxyFactory__DelegateCallFailed();\n    error ProxyFactory__ProxyAddressCannotBeZero();\n\n    /////////////////////\n    /////// Event ///////\n    /////////////////////\n    event SetContest(\n        address indexed organizer, bytes32 indexed contestId, uint256 closeTime, address indexed implementation\n    );\n    event Distributed(address indexed proxy, bytes data);\n\n    ////////////////////////////////\n    /////// State Variables ////////\n    ////////////////////////////////\n    // contest distribution expiration\n    uint256 public constant EXPIRATION_TIME = 7 days;\n    uint256 public constant MAX_CONTEST_PERIOD = 28 days;\n\n    /// @notice record contest close time by salt\n    /// @dev The contest doesn't exist when value is 0\n    mapping(bytes32 => uint256) public saltToCloseTime;\n    /// @dev record whitelisted tokens\n    mapping(address => bool) public whitelistedTokens;\n\n    ////////////////////////////\n    /////// Constructor ////////\n    ////////////////////////////\n    /**\n     * @notice The constructor will set the whitelist tokens. e.g. USDC, JPYCv1, JPYCv2, USDT, DAI\n     * @notice the array is not supposed to be so long because only major tokens will get listed\n     * @param _whitelistedTokens The tokens array to get whitelisted\n     */\n    constructor(address[] memory _whitelistedTokens) EIP712(\"ProxyFactory\", \"1\") Ownable() {\n        if (_whitelistedTokens.length == 0) revert ProxyFactory__NoEmptyArray();\n        for (uint256 i; i < _whitelistedTokens.length;) {\n            if (_whitelistedTokens[i] == address(0)) revert ProxyFactory__NoZeroAddress();\n            whitelistedTokens[_whitelistedTokens[i]] = true;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    ////////////////////////////////////////////\n    /////// External & Public functions ////////\n    ////////////////////////////////////////////\n    /**\n     * @notice Only owner can set contest's properties\n     * @notice close time must be less than 28 days from now\n     * @dev Set contest close time, implementation address, organizer, contest id\n     * @dev only owner can call this function\n     * @param organizer The owner of the contest\n     * @param contestId The contest id\n     * @param closeTime The contest close time\n     * @param implementation The implementation address\n     */\n    function setContest(address organizer, bytes32 contestId, uint256 closeTime, address implementation)\n        public\n        onlyOwner\n    {\n        if (organizer == address(0) || implementation == address(0)) revert ProxyFactory__NoZeroAddress();\n        if (closeTime > block.timestamp + MAX_CONTEST_PERIOD || closeTime < block.timestamp) {\n            revert ProxyFactory__CloseTimeNotInRange();\n        }\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] != 0) revert ProxyFactory__ContestIsAlreadyRegistered();\n        saltToCloseTime[salt] = closeTime;\n        emit SetContest(organizer, contestId, closeTime, implementation);\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute winner's prize\n     * @dev the caller can only control his own contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution data\n     * @return The proxy address\n     */\n    function deployProxyAndDistribute(bytes32 contestId, address implementation, bytes calldata data)\n        public\n        returns (address)\n    {\n        bytes32 salt = _calculateSalt(msg.sender, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        // can set close time to current time and end it immediately if organizer wish\n        if (saltToCloseTime[salt] > block.timestamp) revert ProxyFactory__ContestIsNotClosed();\n        address proxy = _deployProxy(msg.sender, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute prize on behalf of organizer\n     * @dev the caller can only control his own contest\n     * @dev It uess EIP712 to verify the signature to avoid replay attacks\n     * @dev front run is allowed because it will only help the tx sender\n     * @param organizer The organizer of the contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param signature The signature from organizer\n     * @param data The prize distribution data\n     * @return proxy The proxy address\n     */\n    function deployProxyAndDistributeBySignature(\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata signature,\n        bytes calldata data\n    ) public returns (address) {\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(contestId, data)));\n        if (ECDSA.recover(digest, signature) != organizer) revert ProxyFactory__InvalidSignature();\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        if (saltToCloseTime[salt] > block.timestamp) revert ProxyFactory__ContestIsNotClosed();\n        address proxy = _deployProxy(organizer, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute prize on behalf of organizer by owner\n     * @notice This can only be called after contest is expired\n     * @dev the caller must be owner\n     * @param organizer The organizer of the contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution data\n     * @return proxy The proxy address\n     */\n    function deployProxyAndDistributeByOwner(\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata data\n    ) public onlyOwner returns (address) {\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        if (saltToCloseTime[salt] + EXPIRATION_TIME > block.timestamp) revert ProxyFactory__ContestIsNotExpired();\n        // require(saltToCloseTime[salt] == 0, \"Contest is not registered\");\n        // require(saltToCloseTime[salt] < block.timestamp + EXPIRATION_TIME, \"Contest is not expired\");\n        address proxy = _deployProxy(organizer, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice Owner can rescue funds if token is stuck after the deployment and contest is over for a while\n     * @dev only owner can call this function and it is supposed not to be called often\n     * @dev fee sent to stadium address is included in the logic contract\n     * @param proxy The proxy address\n     * @param organizer The contest organizer\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution calling data\n     */\n    function distributeByOwner(\n        address proxy,\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata data\n    ) public onlyOwner {\n        if (proxy == address(0)) revert ProxyFactory__ProxyAddressCannotBeZero();\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        // distribute only when it exists and expired\n        if (saltToCloseTime[salt] + EXPIRATION_TIME > block.timestamp) revert ProxyFactory__ContestIsNotExpired();\n        _distribute(proxy, data);\n    }\n\n    /// @notice This address can be used to send ERC20 tokens before deployment of proxy\n    /// @dev Calculate the proxy address using salt and implementation address\n    /// @param salt The salt\n    /// @param implementation The implementation address\n    /// @return proxy The calculated proxy address\n    function getProxyAddress(bytes32 salt, address implementation) public view returns (address proxy) {\n        bytes memory code = abi.encodePacked(type(Proxy).creationCode, uint256(uint160(implementation)));\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(code)));\n        proxy = address(uint160(uint256(hash)));\n    }\n\n    ///////////////////////////////////\n    /////// Internal functions ////////\n    ///////////////////////////////////\n    /// @dev Deploy proxy and return the proxy address\n    /// @dev This is an internal function\n    /// @param organizer The contest organizer\n    /// @param contestId The contest id\n    /// @param implementation The implementation address\n    function _deployProxy(address organizer, bytes32 contestId, address implementation) internal returns (address) {\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        address proxy = address(new Proxy{salt: salt}(implementation));\n        return proxy;\n    }\n\n    /// @dev The internal function to be used to call proxy to distribute prizes to the winners\n    /// @dev the data passed in should be the calling data of the distributing logic\n    /// @param proxy The proxy address\n    /// @param data The prize distribution data\n    function _distribute(address proxy, bytes calldata data) internal {\n        (bool success,) = proxy.call(data);\n        if (!success) revert ProxyFactory__DelegateCallFailed();\n        emit Distributed(proxy, data);\n    }\n\n    /// @dev Calculate salt using contest organizer address and contestId, implementation address\n    /// @dev This is an internal function\n    /// @param organizer The contest organizer\n    /// @param contestId The contest id\n    /// @param implementation The implementation address\n    function _calculateSalt(address organizer, bytes32 contestId, address implementation)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(organizer, contestId, implementation));\n    }\n}"
    }
  ]
}