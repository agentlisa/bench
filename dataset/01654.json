{
  "Title": "M-12: It's dangerous for makers to set token decimal by manual",
  "Content": "# Issue M-12: It's dangerous for makers to set token decimal by manual \n\nSource: https://github.com/sherlock-audit/2023-06-dodo-judging/issues/242 \n\n## Found by \nProtocol Team\n## Vulnerability Detail\nhttps://github.com/sherlock-audit/2023-06-dodo/blob/a8d30e611acc9762029f8756d6a5b81825faf348/new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Maker.sol#L158C1-L178C57\n\nContract does not check decimal but record the variable directly.\n\n## Impact\nIf maker entered wrong decimal, swap will transfer more or less amount than expected. \n\n## Tool Used\nManual Review\n\n## Recommandation\nIn setNewToken function, taking token decimal through token's interface rather than entering by maker.\n```solidity\nstate.tokenMMInfoMap[token].decimal = IERC20(token).decimal();\n``` \n\n\n\n## Discussion\n\n**Attens1423**\n\nin new calculation model, we don't need token decimal anymore. fix pr:https://github.com/DODOEX/new-dodo-v3/pull/32\n\n**hrishibhat**\n\nPlease note: This issue is not part of the contest submissions and is not eligible for contest rewards. \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/89",
  "Code": [
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Maker.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport \"../lib/MakerTypes.sol\";\nimport \"../lib/Types.sol\";\nimport \"../lib/InitializableOwnable.sol\";\nimport \"../lib/Errors.sol\";\nimport {ID3MM} from \"../intf/ID3MM.sol\";\n\n/// @notice D3Maker is a dependent price controll model. Maker could set token price and other price \n/// parameters to control swap. The key part is MakerState(in D3Maker) and flag(in D3MM) parameter. MakerState \n/// contains token price, amount and swap fee. Specially for token price, which is supposed to be set frequently,\n/// we use one slot to compress 3 token price with dependent price array. Flags in D3MM decide whether this token's \n/// cumulative volumn change, which means resetting integral start point. Every function should reset cumulative\n/// volumn.\n/// @dev maker could not delete token function\ncontract D3Maker is InitializableOwnable {\n    MakerTypes.MakerState internal state;\n    address public _POOL_;\n\n    // ============== Event =============\n    // use operatorIndex to distinct different setting, 1 = setMaxInterval  2 = setTokensPrice, 3 = setNSPriceSlot,\n    // 4 = setStablePriceSlot, 5 = setTokensAmounts, 6 = setTokensKs\n    event SetPoolInfo(uint256 indexed operatorIndex);\n    event SetNewToken(address indexed token);\n\n    // ============== init =============\n    function init(address owner, address pool, uint256 maxInterval) external {\n        initOwner(owner);\n        _POOL_ = pool;\n        state.heartBeat.maxInterval = maxInterval;\n    }\n\n    // ============= Read for tokenMMInfo =================\n    function getTokenMMInfoForPool(address token)\n        external\n        view\n        returns (Types.TokenMMInfo memory tokenMMInfo, uint256 tokenIndex)\n    {\n        if (state.tokenMMInfoMap[token].amountInfo == 0) {\n            // invalid token\n            return (tokenMMInfo, 0);\n        }\n        // get mtFee\n        uint256 mtFeeRate = ID3MM(_POOL_).getFeeRate();\n        // deal with priceInfo\n        uint80 priceInfo = getOneTokenPriceSet(token);\n        (\n            tokenMMInfo.askUpPrice,\n            tokenMMInfo.askDownPrice,\n            tokenMMInfo.bidUpPrice,\n            tokenMMInfo.bidDownPrice,\n            tokenMMInfo.swapFeeRate\n        ) = MakerTypes.parseAllPrice(priceInfo, state.tokenMMInfoMap[token].decimal, mtFeeRate);\n        // lpfee add mtFee\n        tokenMMInfo.mtFeeRate = mtFeeRate;\n        uint64 amountInfo = state.tokenMMInfoMap[token].amountInfo;\n        tokenMMInfo.askAmount = MakerTypes.parseAskAmount(amountInfo);\n        tokenMMInfo.bidAmount = MakerTypes.parseBidAmount(amountInfo);\n        tokenMMInfo.kAsk = MakerTypes.parseK(state.tokenMMInfoMap[token].kAsk);\n        tokenMMInfo.kBid = MakerTypes.parseK(state.tokenMMInfoMap[token].kBid);\n        tokenIndex = getOneTokenOriginIndex(token);\n    }\n\n    // ================== Read parameters ==============\n\n    /// @notice give one token's address, give back token's priceInfo\n    function getOneTokenPriceSet(address token) public view returns (uint80 priceSet) {\n        require(state.priceListInfo.tokenIndexMap[token] > 0, Errors.INVALID_TOKEN);\n        uint256 tokenOriIndex = state.priceListInfo.tokenIndexMap[token] - 1;\n        uint256 tokenIndex = (tokenOriIndex / 2);\n        uint256 tokenIndexInnerSlot = tokenIndex % MakerTypes.PRICE_QUANTITY_IN_ONE_SLOT;\n\n        uint256 curAllPrices = tokenOriIndex % 2 == 1\n            ? state.priceListInfo.tokenPriceNS[tokenIndex / MakerTypes.PRICE_QUANTITY_IN_ONE_SLOT]\n            : state.priceListInfo.tokenPriceStable[tokenIndex / MakerTypes.PRICE_QUANTITY_IN_ONE_SLOT];\n        curAllPrices = curAllPrices >> (MakerTypes.ONE_PRICE_BIT * tokenIndexInnerSlot);\n        priceSet = uint80(curAllPrices & ((2 ** (MakerTypes.ONE_PRICE_BIT)) - 1));\n    }\n\n    /// @notice get one token index. odd for none-stable, even for stable,  true index = (tokenIndex[address] - 1) / 2\n    function getOneTokenOriginIndex(address token) public view returns (uint256) {\n        require(state.priceListInfo.tokenIndexMap[token] > 0, Errors.INVALID_TOKEN);\n        return state.priceListInfo.tokenIndexMap[token] - 1;\n    }\n\n    /// @notice get all stable token Info\n    /// @return numberOfStable stable tokens' quantity\n    /// @return tokenPriceStable stable tokens' price slot array. each data contains up to 3 token prices\n    function getStableTokenInfo()\n        external\n        view\n        returns (uint256 numberOfStable, uint256[] memory tokenPriceStable, uint256 curFlag)\n    {\n        numberOfStable = state.priceListInfo.numberOfStable;\n        tokenPriceStable = state.priceListInfo.tokenPriceStable;\n        curFlag = ID3MM(_POOL_).allFlag();\n    }\n\n    /// @notice get all non-stable token Info\n    /// @return number stable tokens' quantity\n    /// @return tokenPrices stable tokens' price slot array. each data contains up to 3 token prices\n    function getNSTokenInfo() external view returns (uint256 number, uint256[] memory tokenPrices, uint256 curFlag) {\n        number = state.priceListInfo.numberOfNS;\n        tokenPrices = state.priceListInfo.tokenPriceNS;\n        curFlag = ID3MM(_POOL_).allFlag();\n    }\n\n    /// @notice used for construct several price in one price slot\n    /// @param priceSlot origin price slot\n    /// @param slotInnerIndex token index in slot\n    /// @param priceSet the token info needed to update\n    function stickPrice(\n        uint256 priceSlot,\n        uint256 slotInnerIndex,\n        uint256 priceSet\n    ) public pure returns (uint256 newPriceSlot) {\n        uint256 leftPriceSet = priceSlot >> ((slotInnerIndex + 1) * MakerTypes.ONE_PRICE_BIT);\n        uint256 rightPriceSet = priceSlot & ((2 ** (slotInnerIndex * MakerTypes.ONE_PRICE_BIT)) - 1);\n        newPriceSlot = (leftPriceSet << ((slotInnerIndex + 1) * MakerTypes.ONE_PRICE_BIT))\n            + (priceSet << (slotInnerIndex * MakerTypes.ONE_PRICE_BIT)) + rightPriceSet;\n    }\n\n    function checkHeartbeat() public view returns (bool) {\n        if (block.timestamp - state.heartBeat.lastHeartBeat <= state.heartBeat.maxInterval) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // ============= Set params ===========\n\n    /// @notice maker could use multicall to set different params in one tx.\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n            if (!success) {\n                assembly {\n                    revert(add(result, 32), mload(result))\n                }\n            }\n\n            results[i] = result;\n        }\n    }\n\n    /// @notice maker set a new token info\n    /// @param token token's address\n    /// @param priceSet packed price, [mid price(16) | mid price decimal(8) | fee rate(16) | ask up rate (16) | bid down rate(16)]\n    /// @param amountSet describe ask and bid amount and K, [ask amounts(16) | ask amounts decimal(8) | bid amounts(16) | bid amounts decimal(8) ] = one slot could contains 4 token info\n    /// @param stableOrNot describe this token is stable or not, true = stable coin\n    /// @param kAsk k of ask curve\n    /// @param kBid k of bid curve\n    /// @param tokenDecimal token's decimal\n    function setNewToken(\n        address token,\n        bool stableOrNot,\n        uint80 priceSet,\n        uint64 amountSet,\n        uint16 kAsk,\n        uint16 kBid,\n        uint8 tokenDecimal\n    ) external onlyOwner {\n        require(state.priceListInfo.tokenIndexMap[token] == 0, Errors.HAVE_SET_TOKEN_INFO);\n        // check amount\n        require(kAsk >= 0 && kAsk <= 10000, Errors.K_LIMIT);\n        require(kBid >= 0 && kBid <= 10000, Errors.K_LIMIT);\n\n        // set new token info\n        state.tokenMMInfoMap[token].priceInfo = priceSet;\n        state.tokenMMInfoMap[token].amountInfo = amountSet;\n        state.tokenMMInfoMap[token].kAsk = kAsk;\n        state.tokenMMInfoMap[token].kBid = kBid;\n        state.tokenMMInfoMap[token].decimal = tokenDecimal;\n        state.heartBeat.lastHeartBeat = block.timestamp;\n\n        // set token price index\n        uint256 tokenIndex;\n        if (stableOrNot) {\n            // is stable\n            tokenIndex = state.priceListInfo.numberOfStable * 2;\n            uint256 innerSlotIndex = state.priceListInfo.numberOfStable % MakerTypes.PRICE_QUANTITY_IN_ONE_SLOT;\n            uint256 slotIndex = state.priceListInfo.numberOfStable / MakerTypes.PRICE_QUANTITY_IN_ONE_SLOT;\n            if (innerSlotIndex == 0) {\n                state.priceListInfo.tokenPriceStable.push(priceSet);\n            } else {\n                state.priceListInfo.tokenPriceStable[slotIndex] = (\n                    uint256(priceSet) << (MakerTypes.ONE_PRICE_BIT * innerSlotIndex)\n                ) + state.priceListInfo.tokenPriceStable[slotIndex];\n            }\n            state.priceListInfo.numberOfStable++;\n        } else {\n            tokenIndex = state.priceListInfo.numberOfNS * 2 + 1;\n            uint256 innerSlotIndex = state.priceListInfo.numberOfNS % MakerTypes.PRICE_QUANTITY_IN_ONE_SLOT;\n            uint256 slotIndex = state.priceListInfo.numberOfNS / MakerTypes.PRICE_QUANTITY_IN_ONE_SLOT;\n            if (innerSlotIndex == 0) {\n                state.priceListInfo.tokenPriceNS.push(priceSet);\n            } else {\n                state.priceListInfo.tokenPriceNS[slotIndex] = (\n                    uint256(priceSet) << (MakerTypes.ONE_PRICE_BIT * innerSlotIndex)\n                ) + state.priceListInfo.tokenPriceNS[slotIndex];\n            }\n            state.priceListInfo.numberOfNS++;\n        }\n        // to avoid reset the same token, tokenIndexMap record index from 1, but actualIndex = tokenIndex[address] - 1\n        state.priceListInfo.tokenIndexMap[token] = tokenIndex + 1;\n        state.tokenMMInfoMap[token].tokenIndex = uint8(tokenIndex);\n\n        emit SetNewToken(token);\n    }\n\n    /// @notice set token prices\n    /// @param tokens token address set\n    /// @param tokenPrices token prices set, each number pack one token all price.Each format is the same with priceSet\n    /// [mid price(16) | mid price decimal(8) | fee rate(16) | ask up rate (16) | bid down rate(16)] = one slot could contains 3 token info\n    function setTokensPrice(\n        address[] calldata tokens,\n        uint80[] calldata tokenPrices\n    ) external onlyOwner {\n        require(tokens.length == tokenPrices.length, Errors.PRICES_LENGTH_NOT_MATCH);\n        uint256[] memory haveWrittenToken = new uint256[](tokens.length);\n        uint256 curFlag = ID3MM(_POOL_).allFlag();\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            if (haveWrittenToken[i] == 1) continue;\n\n            haveWrittenToken[i] = 1;\n            address curToken = tokens[i];\n            uint80 curTokenPriceSet = tokenPrices[i];\n            //_checkUpAndDownPrice(curTokenPriceSet);\n\n            {\n                uint256 tokenIndex = state.priceListInfo.tokenIndexMap[curToken] - 1;\n                curFlag = curFlag & ~(1 << tokenIndex);\n            }\n\n            // get slot price\n            uint256 curTokenIndex = (state.priceListInfo.tokenIndexMap[curToken] - 1) / 2;\n            uint256 slotIndex = curTokenIndex / MakerTypes.PRICE_QUANTITY_IN_ONE_SLOT;\n            uint256 priceInfoSet = (state.priceListInfo.tokenIndexMap[curToken] - 1) % 2 == 1\n                ? state.priceListInfo.tokenPriceNS[slotIndex]\n                : state.priceListInfo.tokenPriceStable[slotIndex];\n\n            priceInfoSet = stickPrice(\n                priceInfoSet, curTokenIndex % MakerTypes.PRICE_QUANTITY_IN_ONE_SLOT, uint256(curTokenPriceSet)\n            );\n\n            // find one slot token\n            for (uint256 j = i + 1; j < tokens.length; ++j) {\n                address tokenJ = tokens[j];\n                uint256 tokenJOriIndex = (state.priceListInfo.tokenIndexMap[tokenJ] - 1);\n                if (\n                    haveWrittenToken[j] == 1 // have written\n                        || (state.priceListInfo.tokenIndexMap[curToken] - 1) % 2 != tokenJOriIndex % 2 // not the same stable type\n                        || tokenJOriIndex / 2 / MakerTypes.PRICE_QUANTITY_IN_ONE_SLOT != slotIndex\n                ) {\n                    // not one slot\n                    continue;\n                }\n                //_checkUpAndDownPrice(tokenPrices[j]);\n                priceInfoSet = stickPrice(\n                    priceInfoSet, (tokenJOriIndex / 2) % MakerTypes.PRICE_QUANTITY_IN_ONE_SLOT, uint256(tokenPrices[j])\n                );\n\n                haveWrittenToken[j] = 1;\n                {\n                    uint256 tokenIndex = state.priceListInfo.tokenIndexMap[tokenJ] - 1;\n                    curFlag = curFlag & ~(1 << tokenIndex);\n                }\n            }\n\n            if ((state.priceListInfo.tokenIndexMap[curToken] - 1) % 2 == 1) {\n                state.priceListInfo.tokenPriceNS[slotIndex] = priceInfoSet;\n            } else {\n                state.priceListInfo.tokenPriceStable[slotIndex] = priceInfoSet;\n            }\n        }\n        state.heartBeat.lastHeartBeat = block.timestamp;\n        ID3MM(_POOL_).setNewAllFlag(curFlag);\n\n        emit SetPoolInfo(2);\n    }\n\n    /// @notice user set PriceListInfo.tokenPriceNS price info, only for none-stable coin\n    /// @param slotIndex tokenPriceNS index\n    /// @param priceSlots tokenPriceNS price info, every data has packed all 3 token price info\n    /// @param newAllFlag maker update token cumulative status,\n    /// for allFlag, tokenOriIndex represent bit index in allFlag. eg: tokenA has origin index 3, that means (allFlag >> 3) & 1 = token3's flag\n    /// flag = 0 means to reset cumulative. flag = 1 means not to reset cumulative.\n    /// @dev maker should be responsible for data availability\n    function setNSPriceSlot(\n        uint256[] calldata slotIndex,\n        uint256[] calldata priceSlots,\n        uint256 newAllFlag\n    ) external onlyOwner {\n        require(slotIndex.length == priceSlots.length, Errors.PRICE_SLOT_LENGTH_NOT_MATCH);\n        for (uint256 i = 0; i < slotIndex.length; ++i) {\n            state.priceListInfo.tokenPriceNS[slotIndex[i]] = priceSlots[i];\n        }\n        ID3MM(_POOL_).setNewAllFlag(newAllFlag);\n        state.heartBeat.lastHeartBeat = block.timestamp;\n\n        emit SetPoolInfo(3);\n    }\n\n    /// @notice user set PriceListInfo.tokenPriceStable price info, only for stable coin\n    /// @param slotIndex tokenPriceStable index\n    /// @param priceSlots tokenPriceStable price info, every data has packed all 3 token price info\n    /// @param newAllFlag maker update token cumulative status,\n    /// for allFlag, tokenOriIndex represent bit index in allFlag. eg: tokenA has origin index 3, that means (allFlag >> 3) & 1 = token3's flag\n    /// flag = 0 means to reset cumulative. flag = 1 means not to reset cumulative.\n    /// @dev maker should be responsible for data availability\n    function setStablePriceSlot(\n        uint256[] calldata slotIndex,\n        uint256[] calldata priceSlots,\n        uint256 newAllFlag\n    ) external onlyOwner {\n        require(slotIndex.length == priceSlots.length, Errors.PRICE_SLOT_LENGTH_NOT_MATCH);\n        for (uint256 i = 0; i < slotIndex.length; ++i) {\n            state.priceListInfo.tokenPriceStable[slotIndex[i]] = priceSlots[i];\n        }\n        ID3MM(_POOL_).setNewAllFlag(newAllFlag);\n        state.heartBeat.lastHeartBeat = block.timestamp;\n\n        emit SetPoolInfo(4);\n    }\n\n    /// @notice set token Amounts\n    /// @param tokens token address set\n    /// @param tokenAmounts token amounts set, each number pack one token all amounts.Each format is the same with amountSetAndK\n    /// [ask amounts(16) | ask amounts decimal(8) | bid amounts(16) | bid amounts decimal(8) ]\n    function setTokensAmounts(\n        address[] calldata tokens,\n        uint64[] calldata tokenAmounts\n    ) external onlyOwner {\n        require(tokens.length == tokenAmounts.length, Errors.AMOUNTS_LENGTH_NOT_MATCH);\n        uint256 curFlag = ID3MM(_POOL_).allFlag();\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            address curToken = tokens[i];\n            uint64 curTokenAmountSet = tokenAmounts[i];\n\n            state.tokenMMInfoMap[curToken].amountInfo = curTokenAmountSet;\n            {\n                uint256 tokenIndex = state.priceListInfo.tokenIndexMap[curToken] - 1;\n                curFlag = curFlag & ~(1 << tokenIndex);\n            }\n        }\n        state.heartBeat.lastHeartBeat = block.timestamp;\n        ID3MM(_POOL_).setNewAllFlag(curFlag);\n\n        emit SetPoolInfo(5);\n    }\n\n    /// @notice set token Ks\n    /// @param tokens token address set\n    /// @param tokenKs token k_ask and k_bid, structure like [kAsk(16) | kBid(16)]\n    function setTokensKs(address[] calldata tokens, uint32[] calldata tokenKs) external onlyOwner {\n        require(tokens.length == tokenKs.length, Errors.K_LENGTH_NOT_MATCH);\n        uint256 curFlag = ID3MM(_POOL_).allFlag();\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            address curToken = tokens[i];\n            uint32 curTokenK = tokenKs[i];\n            uint16 kAsk = uint16(curTokenK >> 16);\n            uint16 kBid = uint16(curTokenK & 0xffff);\n\n            require(kAsk >= 0 && kAsk <= 10000, Errors.K_LIMIT);\n            require(kBid >= 0 && kBid <= 10000, Errors.K_LIMIT);\n\n            state.tokenMMInfoMap[curToken].kAsk = kAsk;\n            state.tokenMMInfoMap[curToken].kBid = kBid;\n\n            {\n                uint256 tokenIndex = state.priceListInfo.tokenIndexMap[curToken] - 1;\n                curFlag = curFlag & ~(1 << tokenIndex);\n            }\n        }\n        state.heartBeat.lastHeartBeat = block.timestamp;\n        ID3MM(_POOL_).setNewAllFlag(curFlag);\n\n        emit SetPoolInfo(6);\n    }\n\n    /// @notice set acceptable setting interval, if setting gap > maxInterval, swap will revert.\n    function setHeartbeat(uint256 newMaxInterval) public onlyOwner {\n        state.heartBeat.maxInterval = newMaxInterval;\n\n        emit SetPoolInfo(1);\n    }\n}"
    }
  ]
}