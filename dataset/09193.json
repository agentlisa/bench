{
  "Title": "[G-06] Use `unchecked {}` for calculations that cannot overflow",
  "Content": "The subtraction below can be `unchecked {}` because of the check that comes before it\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/src/Cally.sol   #1\n\n417:         uint256 delta = auctionEndTimestamp > block.timestamp ? auctionEndTimestamp - block.timestamp : 0;\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L417\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-05-cally-contest",
  "Code": [
    {
      "filename": "contracts/src/Cally.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n/**\n\n\n    ██████╗ █████╗  ██╗     ██╗  ██╗   ██╗\n    ██╔════╝██╔══██╗██║     ██║  ╚██╗ ██╔╝\n    ██║     ███████║██║     ██║   ╚████╔╝ \n    ██║     ██╔══██║██║     ██║    ╚██╔╝  \n    ╚██████╗██║  ██║███████╗███████╗██║   \n     ╚═════╝╚═╝  ╚═╝╚══════╝╚══════╝╚═╝   \n                                      \n\n    \n    NFT & ERC20 covered call vaults.\n    this is intended to be a public good.\n    pog pog pog.\n    \n\n*/\n\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"solmate/utils/ReentrancyGuard.sol\";\nimport \"openzeppelin/access/Ownable.sol\";\n\nimport \"./CallyNft.sol\";\n\n/// @title Cally - https://cally.finance\n/// @author out.eth\n/// @notice NFT & ERC20 covered call vaults\ncontract Cally is CallyNft, ReentrancyGuard, Ownable {\n    using SafeTransferLib for ERC20;\n    using SafeTransferLib for address payable;\n\n    /// @notice Fires when a new vault has been created\n    /// @param vaultId The newly minted vault NFT\n    /// @param from The account that created the vault\n    /// @param token The token address of the underlying asset\n    event NewVault(uint256 indexed vaultId, address indexed from, address indexed token);\n\n    /// @notice Fires when an option has been bought from a vault\n    /// @param optionId The newly minted option NFT\n    /// @param from The account that bought the option\n    /// @param token The token address of the underlying asset\n    event BoughtOption(uint256 indexed optionId, address indexed from, address indexed token);\n\n    /// @notice Fires when an option is exercised\n    /// @param optionId The option NFT which is being exercised\n    /// @param from The account that exercised the option\n    event ExercisedOption(uint256 indexed optionId, address indexed from);\n\n    /// @notice Fires when someone harvests their ETH balance\n    /// @param from The account that is harvesting\n    /// @param amount The amount of ETH which was harvested\n    event Harvested(address indexed from, uint256 amount);\n\n    /// @notice Fires when someone initiates a withdrawal on their vault\n    /// @param vaultId The vault NFT which is being withdrawn\n    /// @param from The account that is initiating the withdrawal\n    event InitiatedWithdrawal(uint256 indexed vaultId, address indexed from);\n\n    /// @notice Fires when someone withdraws their vault\n    /// @param vaultId The vault NFT which is being withdrawn\n    /// @param from The account that is withdrawing\n    event Withdrawal(uint256 indexed vaultId, address indexed from);\n\n    enum TokenType {\n        ERC721,\n        ERC20\n    }\n\n    struct Vault {\n        uint256 tokenIdOrAmount;\n        address token;\n        uint8 premiumIndex; // indexes into `premiumOptions`\n        uint8 durationDays; // days\n        uint8 dutchAuctionStartingStrikeIndex; // indexes into `strikeOptions`\n        uint32 currentExpiration;\n        bool isExercised;\n        bool isWithdrawing;\n        TokenType tokenType;\n        uint256 currentStrike;\n        uint256 dutchAuctionReserveStrike;\n    }\n\n    uint32 public constant AUCTION_DURATION = 24 hours;\n\n    // prettier-ignore\n    uint256[] public premiumOptions = [0.01 ether, 0.025 ether, 0.05 ether, 0.075 ether, 0.1 ether, 0.25 ether, 0.5 ether, 0.75 ether, 1.0 ether, 2.5 ether, 5.0 ether, 7.5 ether, 10 ether, 25 ether, 50 ether, 75 ether, 100 ether];\n    // prettier-ignore\n    uint256[] public strikeOptions = [1 ether, 2 ether, 3 ether, 5 ether, 8 ether, 13 ether, 21 ether, 34 ether, 55 ether, 89 ether, 144 ether, 233 ether, 377 ether, 610 ether, 987 ether, 1597 ether, 2584 ether, 4181 ether, 6765 ether];\n\n    uint256 public feeRate = 0;\n    uint256 public protocolUnclaimedFees = 0;\n\n    /// @notice The current vault index. Used for determining which\n    ///         tokenId to use when minting a new vault. Increments by\n    ///         2 on each new mint.\n    uint256 public vaultIndex = 1;\n\n    /// @notice Mapping of vault tokenId -> vault information\n    mapping(uint256 => Vault) private _vaults;\n\n    /// @notice Mapping of vault tokenId -> vault beneficiary.\n    ///         Beneficiary is credited the premium when option is\n    ///         purchased or strike ETH when option is exercised.\n    mapping(uint256 => address) private _vaultBeneficiaries;\n\n    /// @notice The unharvested ethBalance of each account\n    mapping(address => uint256) public ethBalance;\n\n    /*********************\n        ADMIN FUNCTIONS\n    **********************/\n\n    /// @notice Sets the fee that is applied on exercise\n    /// @param feeRate_ The new fee rate: fee = 1% = (1 / 100) * 1e18\n    function setFee(uint256 feeRate_) external onlyOwner {\n        feeRate = feeRate_;\n    }\n\n    /// @notice Withdraws the protocol fees and sends to current owner\n    function withdrawProtocolFees() external onlyOwner returns (uint256 amount) {\n        amount = protocolUnclaimedFees;\n        protocolUnclaimedFees = 0;\n        payable(msg.sender).safeTransferETH(amount);\n    }\n\n    /**************************\n        MAIN LOGIC FUNCTIONS\n    ***************************/\n\n    /*\n        standard lifecycle:\n            createVault\n            buyOption (repeats)\n            exercise\n            initiateWithdraw\n            withdraw\n\n        [*] setVaultBeneficiary\n        [*] harvest\n\n        [*] can be called anytime in lifecycle\n    */\n\n    /// @notice Creates a new vault that perpetually sells calls\n    ///         on the underlying assets until a call option is exercised\n    ///         or the owner initiates a withdrawal.\n    /// @param tokenIdOrAmount The tokenId (NFT) or amount (ERC20) to vault\n    /// @param token The address of the NFT or ERC20 contract to vault\n    /// @param premiumIndex The index into the premiumOptions of each call that is sold\n    /// @param durationDays The length/duration of each call that is sold in days\n    /// @param dutchAuctionStartingStrikeIndex The index into the strikeOptions for the starting strike for each dutch auction\n    /// @param dutchAuctionReserveStrike The reserve strike for each dutch auction\n    /// @param tokenType The type of the underlying asset (NFT or ERC20)\n    function createVault(\n        uint256 tokenIdOrAmount,\n        address token,\n        uint8 premiumIndex,\n        uint8 durationDays,\n        uint8 dutchAuctionStartingStrikeIndex,\n        uint256 dutchAuctionReserveStrike,\n        TokenType tokenType\n    ) external returns (uint256 vaultId) {\n        require(premiumIndex < premiumOptions.length, \"Invalid premium index\");\n        require(dutchAuctionStartingStrikeIndex < strikeOptions.length, \"Invalid strike index\");\n        require(dutchAuctionReserveStrike < strikeOptions[dutchAuctionStartingStrikeIndex], \"Reserve strike too small\");\n        require(durationDays > 0, \"durationDays too small\");\n        require(tokenType == TokenType.ERC721 || tokenType == TokenType.ERC20, \"Invalid token type\");\n\n        Vault memory vault = Vault({\n            tokenIdOrAmount: tokenIdOrAmount,\n            token: token,\n            premiumIndex: premiumIndex,\n            durationDays: durationDays,\n            dutchAuctionStartingStrikeIndex: dutchAuctionStartingStrikeIndex,\n            currentExpiration: uint32(block.timestamp),\n            isExercised: false,\n            isWithdrawing: false,\n            tokenType: tokenType,\n            currentStrike: 0,\n            dutchAuctionReserveStrike: dutchAuctionReserveStrike\n        });\n\n        // vault index should always be odd\n        vaultIndex += 2;\n        vaultId = vaultIndex;\n        _vaults[vaultId] = vault;\n\n        // give msg.sender vault token\n        _mint(msg.sender, vaultId);\n\n        emit NewVault(vaultId, msg.sender, token);\n\n        // transfer the NFTs or ERC20s to the contract\n        vault.tokenType == TokenType.ERC721\n            ? ERC721(vault.token).transferFrom(msg.sender, address(this), vault.tokenIdOrAmount)\n            : ERC20(vault.token).safeTransferFrom(msg.sender, address(this), vault.tokenIdOrAmount);\n    }\n\n    /// @notice Buys an option from a vault at a fixed premium and variable strike\n    ///         which is dependent on the dutch auction. Premium is credited to\n    ///         vault beneficiary.\n    /// @param vaultId The tokenId of the vault to buy the option from\n    function buyOption(uint256 vaultId) external payable returns (uint256 optionId) {\n        Vault memory vault = _vaults[vaultId];\n\n        // vaultId should always be odd\n        require(vaultId % 2 != 0, \"Not vault type\");\n\n        // check vault exists\n        require(ownerOf(vaultId) != address(0), \"Vault does not exist\");\n\n        // check that the vault still has the NFTs as collateral\n        require(vault.isExercised == false, \"Vault already exercised\");\n\n        // check that the vault is not in withdrawing state\n        require(vault.isWithdrawing == false, \"Vault is being withdrawn\");\n\n        // check enough eth was sent to cover premium\n        uint256 premium = getPremium(vaultId);\n        require(msg.value >= premium, \"Incorrect ETH amount sent\");\n\n        // check option associated with the vault has expired\n        uint32 auctionStartTimestamp = vault.currentExpiration;\n        require(block.timestamp >= auctionStartTimestamp, \"Auction not started\");\n\n        // set new currentStrike\n        vault.currentStrike = getDutchAuctionStrike(\n            strikeOptions[vault.dutchAuctionStartingStrikeIndex],\n            vault.currentExpiration + AUCTION_DURATION,\n            vault.dutchAuctionReserveStrike\n        );\n\n        // set new expiration\n        vault.currentExpiration = uint32(block.timestamp) + (vault.durationDays * 1 days);\n\n        // update the vault with the new option expiration and strike\n        _vaults[vaultId] = vault;\n\n        // force transfer the vault's associated option from old owner to new owner\n        // option id for a respective vault is always vaultId + 1\n        optionId = vaultId + 1;\n        _forceTransfer(msg.sender, optionId);\n\n        // increment vault beneficiary's unclaimed premiums\n        address beneficiary = getVaultBeneficiary(vaultId);\n        ethBalance[beneficiary] += msg.value;\n\n        emit BoughtOption(optionId, msg.sender, vault.token);\n    }\n\n    /// @notice Exercises a call option and sends the underlying assets to the\n    ///         exerciser and the strike ETH to the vault beneficiary.\n    /// @param optionId The tokenId of the option to exercise\n    function exercise(uint256 optionId) external payable {\n        // optionId should always be even\n        require(optionId % 2 == 0, \"Not option type\");\n\n        // check owner\n        require(msg.sender == ownerOf(optionId), \"You are not the owner\");\n\n        uint256 vaultId = optionId - 1;\n        Vault memory vault = _vaults[vaultId];\n\n        // check option hasn't expired\n        require(block.timestamp < vault.currentExpiration, \"Option has expired\");\n\n        // check correct ETH amount was sent to pay the strike\n        require(msg.value == vault.currentStrike, \"Incorrect ETH sent for strike\");\n\n        // burn the option token\n        _burn(optionId);\n\n        // mark the vault as exercised\n        vault.isExercised = true;\n        _vaults[vaultId] = vault;\n\n        // collect protocol fee\n        uint256 fee = 0;\n        if (feeRate > 0) {\n            fee = (msg.value * feeRate) / 1e18;\n            protocolUnclaimedFees += fee;\n        }\n\n        // increment vault beneficiary's ETH balance\n        ethBalance[getVaultBeneficiary(vaultId)] += msg.value - fee;\n\n        emit ExercisedOption(optionId, msg.sender);\n\n        // transfer the NFTs or ERC20s to the exerciser\n        vault.tokenType == TokenType.ERC721\n            ? ERC721(vault.token).transferFrom(address(this), msg.sender, vault.tokenIdOrAmount)\n            : ERC20(vault.token).safeTransfer(msg.sender, vault.tokenIdOrAmount);\n    }\n\n    /// @notice Initiates a withdrawal so that the vault will no longer sell\n    ///         another call once the currently active call option has expired.\n    /// @param vaultId The tokenId of the vault to initiate a withdrawal on\n    function initiateWithdraw(uint256 vaultId) external {\n        // vaultId should always be odd\n        require(vaultId % 2 != 0, \"Not vault type\");\n\n        // check msg.sender owns the vault\n        require(msg.sender == ownerOf(vaultId), \"You are not the owner\");\n\n        _vaults[vaultId].isWithdrawing = true;\n\n        emit InitiatedWithdrawal(vaultId, msg.sender);\n    }\n\n    /// @notice Sends the underlying assets back to the vault owner and claims any\n    ///         unharvested premiums for the owner. Vault and it's associated option\n    ///         NFT are burned.\n    /// @param vaultId The tokenId of the vault to withdraw\n    function withdraw(uint256 vaultId) external nonReentrant {\n        // vaultId should always be odd\n        require(vaultId % 2 != 0, \"Not vault type\");\n\n        // check owner\n        require(msg.sender == ownerOf(vaultId), \"You are not the owner\");\n\n        Vault memory vault = _vaults[vaultId];\n\n        // check vault can be withdrawn\n        require(vault.isExercised == false, \"Vault already exercised\");\n        require(vault.isWithdrawing, \"Vault not in withdrawable state\");\n        require(block.timestamp > vault.currentExpiration, \"Option still active\");\n\n        // burn option and vault\n        uint256 optionId = vaultId + 1;\n        _burn(optionId);\n        _burn(vaultId);\n\n        emit Withdrawal(vaultId, msg.sender);\n\n        // claim any ETH still in the account\n        harvest();\n\n        // transfer the NFTs or ERC20s back to the owner\n        vault.tokenType == TokenType.ERC721\n            ? ERC721(vault.token).transferFrom(address(this), msg.sender, vault.tokenIdOrAmount)\n            : ERC20(vault.token).safeTransfer(msg.sender, vault.tokenIdOrAmount);\n    }\n\n    /// @notice Sets the vault beneficiary that will receive premiums/strike ETH from the vault\n    /// @param vaultId The tokenId of the vault to update\n    /// @param beneficiary The new vault beneficiary\n    function setVaultBeneficiary(uint256 vaultId, address beneficiary) external {\n        // vaultId's should always be odd\n        require(vaultId % 2 != 0, \"Not vault type\");\n        require(msg.sender == ownerOf(vaultId), \"Not owner\");\n\n        _vaultBeneficiaries[vaultId] = beneficiary;\n    }\n\n    /// @notice Sends any unclaimed ETH (premiums/strike) to the msg.sender\n    function harvest() public returns (uint256 amount) {\n        // reset premiums\n        amount = ethBalance[msg.sender];\n        ethBalance[msg.sender] = 0;\n\n        emit Harvested(msg.sender, amount);\n\n        // transfer premiums to owner\n        payable(msg.sender).safeTransferETH(amount);\n    }\n\n    /**********************\n        GETTER FUNCTIONS\n    ***********************/\n\n    /// @notice Get the current beneficiary for a vault\n    /// @param vaultId The tokenId of the vault to fetch the beneficiary for\n    /// @return beneficiary The beneficiary for the vault\n    function getVaultBeneficiary(uint256 vaultId) public view returns (address beneficiary) {\n        address currentBeneficiary = _vaultBeneficiaries[vaultId];\n\n        // return the current owner if vault beneficiary is not set\n        return currentBeneficiary == address(0) ? ownerOf(vaultId) : currentBeneficiary;\n    }\n\n    /// @notice Get details for a vault\n    /// @param vaultId The tokenId of the vault to fetch the details for\n    function vaults(uint256 vaultId) external view returns (Vault memory) {\n        return _vaults[vaultId];\n    }\n\n    /// @notice Get the fixed option premium for a vault\n    /// @param vaultId The tokenId of the vault to fetch the premium for\n    /// @return premium The premium for the vault\n    function getPremium(uint256 vaultId) public view returns (uint256 premium) {\n        Vault memory vault = _vaults[vaultId];\n        return premiumOptions[vault.premiumIndex];\n    }\n\n    /// @notice Get the current dutch auction strike for a start value and end\n    ///         timestamp. Strike decreases exponentially to 0 over time starting\n    ///         at startingStrike. Minimum value returned is reserveStrike.\n    /// @param startingStrike The starting strike value\n    /// @param auctionEndTimestamp The unix timestamp when the auction ends\n    /// @param reserveStrike The minimum value for the strike\n    /// @return strike The strike\n    function getDutchAuctionStrike(\n        uint256 startingStrike,\n        uint32 auctionEndTimestamp,\n        uint256 reserveStrike\n    ) public view returns (uint256 strike) {\n        /*\n            delta = max(auctionEnd - currentTimestamp, 0)\n            progress = delta / auctionDuration\n            auctionStrike = progress^2 * startingStrike\n            strike = max(auctionStrike, reserveStrike)\n        */\n        uint256 delta = auctionEndTimestamp > block.timestamp ? auctionEndTimestamp - block.timestamp : 0;\n        uint256 progress = (1e18 * delta) / AUCTION_DURATION;\n        uint256 auctionStrike = (progress * progress * startingStrike) / (1e18 * 1e18);\n\n        // max(auctionStrike, reserveStrike)\n        strike = auctionStrike > reserveStrike ? auctionStrike : reserveStrike;\n    }\n\n    /*************************\n        OVVERIDES FUNCTIONS\n    **************************/\n\n    /// @dev Resets the beneficiary address when transferring vault NFTs.\n    ///      The new beneficiary will be the account receiving the vault NFT.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public override {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n        require(to != address(0), \"INVALID_RECIPIENT\");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // reset the beneficiary\n        bool isVaultToken = id % 2 != 0;\n        if (isVaultToken) {\n            _vaultBeneficiaries[id] = address(0);\n        }\n\n        _ownerOf[id] = to;\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        require(_ownerOf[tokenId] != address(0), \"URI query for NOT_MINTED token\");\n\n        bool isVaultToken = tokenId % 2 != 0;\n        Vault memory vault = _vaults[isVaultToken ? tokenId : tokenId - 1];\n\n        string memory jsonStr = renderJson(\n            vault.token,\n            vault.tokenIdOrAmount,\n            getPremium(vault.premiumIndex),\n            vault.durationDays,\n            strikeOptions[vault.dutchAuctionStartingStrikeIndex],\n            vault.currentExpiration,\n            vault.currentStrike,\n            vault.isExercised,\n            isVaultToken\n        );\n\n        return string(abi.encodePacked(\"data:application/json;base64,\", Base64.encode(bytes(jsonStr))));\n    }\n}"
    }
  ]
}