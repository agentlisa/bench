{
  "Title": "3S-LENFT-N14 protocol/Gauges/LendingGauge.sol: Entire WorkingBalance struct is being loaded from storage just to access one field",
  "Content": "#### Description\n\nThe current implementation of the _checkpoint() function of the LendingGauge contract has the following [code](https://github.com/leNFT/contracts/blob/master/contracts/protocol/Gauges/LendingGauge.sol#L272-L277) to load the WorkingBalance struct from storage:\n\n```solidity\nDataTypes.WorkingBalance memory oldWorkingBalance;\nif (_workingBalanceHistory[user].length > 0) {\noldWorkingBalance = _workingBalanceHistory[user][\n_workingBalanceHistory[user].length - 1\n];\n}\n```\n\nSince the oldWorkingBalance variable is only used once to read the oldWorkingBalance.weight, this variable should be loaded instead of the entire struct.\n\n#### Recommendation\nReplace the above code with:\n\n```solidity\nuint256 oldWorkingBalanceWeight;\nif (_workingBalanceHistory[user].length > 0) {\noldWorkingBalanceWeight = _workingBalanceHistory[user][\n_workingBalanceHistory[user].length - 1].weight;\n}\n```\nAnd change variable `oldWorkingBalance.weight` to `oldWorkingBalanceWeight` on [line 288](https://github.com/leNFT/contracts/blob/master/contracts/protocol/Gauges/LendingGauge.sol#L288)",
  "Impact": "GAS",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/protocol/Gauges/LendingGauge.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nimport {IAddressProvider} from \"../../interfaces/IAddressProvider.sol\";\nimport {INativeToken} from \"../../interfaces/INativeToken.sol\";\nimport {IGaugeController} from \"../../interfaces/IGaugeController.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {DataTypes} from \"../../libraries/types/DataTypes.sol\";\nimport {IVotingEscrow} from \"../../interfaces/IVotingEscrow.sol\";\nimport {IGauge} from \"../../interfaces/IGauge.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {PercentageMath} from \"../../libraries/utils/PercentageMath.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {SafeCast} from \"../../libraries/utils/SafeCast.sol\";\n\n/// @title LendingGauge contract\n/// @author leNFT\n/// @notice Liquidity Gauge contract. Distributes incentives to users who have deposited into the LendingPool.\n/// @dev The gauge tracks the balance and work done by users, which are then used to calculate rewards.\ncontract LendingGauge is IGauge, ERC165 {\n    IAddressProvider private immutable _addressProvider;\n    address private immutable _lpToken;\n    mapping(address => uint256) private _balanceOf;\n    mapping(address => DataTypes.WorkingBalance[])\n        private _workingBalanceHistory;\n    mapping(address => uint256) private _workingBalancePointer;\n    mapping(address => uint256) private _userNextClaimableEpoch;\n    uint256 private _workingWeight;\n    uint256[] private _workingWeightHistory;\n\n    using SafeERC20 for IERC20;\n\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n\n    /// @notice Constructor function for LendingGauge\n    /// @param addressProvider The address provider contract\n    /// @param lpToken_ The address of the LendingPool token\n    constructor(IAddressProvider addressProvider, address lpToken_) {\n        _addressProvider = addressProvider;\n        _lpToken = lpToken_;\n        _workingWeightHistory = [0];\n    }\n\n    /// @notice Returns the address of the LendingPool token\n    /// @return The address of the LendingPool token\n    function getLPToken() external view returns (address) {\n        return _lpToken;\n    }\n\n    /// @notice Returns the total supply of the LendingPool token in the contract\n    /// @return The total supply of the LendingPool token in the contract\n    function getTotalSupply() public view returns (uint256) {\n        return IERC20(_lpToken).balanceOf(address(this));\n    }\n\n    /// @notice Returns the balance of staked LP tokens for a given user\n    /// @param user The address of the user to check balance for\n    /// @return The balance of the user\n    function getBalanceOf(address user) external view returns (uint256) {\n        return _balanceOf[user];\n    }\n\n    /// @notice Claims the gauge rewards for the user and updates the user's next claimable epoch\n    /// @dev Will give a maximum of 50 epochs worth of rewards\n    /// @return amountToClaim The amount of gauge rewards claimed\n    function claim() external returns (uint256 amountToClaim) {\n        _checkpoint(msg.sender);\n\n        IVotingEscrow votingEscrow = IVotingEscrow(\n            _addressProvider.getVotingEscrow()\n        );\n        IGaugeController gaugeController = IGaugeController(\n            _addressProvider.getGaugeController()\n        );\n\n        // Get maximum number of user epochs\n        uint256 workingBalanceHistoryLength = _workingBalanceHistory[msg.sender]\n            .length;\n\n        // Check if user has any user actions and therefore something to claim\n        if (workingBalanceHistoryLength == 0) {\n            return 0;\n        }\n\n        // Set the next claimable epoch if it's the first time the user claims\n        if (_userNextClaimableEpoch[msg.sender] == 0) {\n            _userNextClaimableEpoch[msg.sender] =\n                votingEscrow.getEpoch(\n                    _workingBalanceHistory[msg.sender][0].timestamp\n                ) +\n                1;\n        }\n        // Iterate over a max of 50 epochs and/or user epochs\n        uint256 nextClaimableEpoch = _userNextClaimableEpoch[msg.sender];\n        uint256 currentEpoch = votingEscrow.getEpoch(block.timestamp);\n        for (uint256 i = 0; i < 50 && nextClaimableEpoch < currentEpoch; ) {\n            // Get the current user working Balance and its epoch\n            DataTypes.WorkingBalance\n                memory workingBalance = _workingBalanceHistory[msg.sender][\n                    _workingBalancePointer[msg.sender]\n                ];\n\n            // Check if the user entire balance history has been iterated\n            // This should never be the case since the checkpoint function is called before this function and it pushes one working balance to the history\n            if (\n                _workingBalancePointer[msg.sender] ==\n                workingBalanceHistoryLength - 1\n            ) {\n                if (_workingWeightHistory[nextClaimableEpoch] > 0) {\n                    amountToClaim +=\n                        (gaugeController.getGaugeRewards(\n                            address(this),\n                            nextClaimableEpoch\n                        ) *\n                            workingBalance.weight *\n                            _maturityMultiplier(\n                                block.timestamp - workingBalance.timestamp\n                            )) /\n                        (_workingWeightHistory[nextClaimableEpoch] *\n                            PercentageMath.PERCENTAGE_FACTOR);\n                }\n\n                nextClaimableEpoch++;\n            } else {\n                // We haven't iterated over the entire user history\n                DataTypes.WorkingBalance\n                    memory nextWorkingBalance = _workingBalanceHistory[\n                        msg.sender\n                    ][_workingBalancePointer[msg.sender] + 1];\n\n                // Check if the next working balance is in the same epoch as the current working balance\n                if (\n                    votingEscrow.getEpoch(nextWorkingBalance.timestamp) ==\n                    votingEscrow.getEpoch(workingBalance.timestamp)\n                ) {\n                    _workingBalancePointer[msg.sender]++;\n                }\n                // Check if the next working balance is in the next claimable epoch\n                else if (\n                    votingEscrow.getEpoch(nextWorkingBalance.timestamp) ==\n                    nextClaimableEpoch\n                ) {\n                    // If the next working balance has no decrease in balance we can claim the rewards\n                    if (\n                        _workingWeightHistory[nextClaimableEpoch] > 0 &&\n                        workingBalance.amount <= nextWorkingBalance.amount\n                    ) {\n                        amountToClaim +=\n                            (gaugeController.getGaugeRewards(\n                                address(this),\n                                nextClaimableEpoch\n                            ) *\n                                _maturityMultiplier(\n                                    nextWorkingBalance.timestamp -\n                                        workingBalance.timestamp\n                                ) *\n                                workingBalance.weight) /\n                            (_workingWeightHistory[nextClaimableEpoch] *\n                                PercentageMath.PERCENTAGE_FACTOR);\n                    }\n                    _workingBalancePointer[msg.sender]++;\n                    nextClaimableEpoch++;\n                } else {\n                    // THe next working balance is not in the next claimable epoch\n                    if (_workingWeightHistory[nextClaimableEpoch] > 0) {\n                        amountToClaim +=\n                            (gaugeController.getGaugeRewards(\n                                address(this),\n                                nextClaimableEpoch\n                            ) *\n                                _maturityMultiplier(\n                                    nextWorkingBalance.timestamp -\n                                        workingBalance.timestamp\n                                ) *\n                                workingBalance.weight) /\n                            (_workingWeightHistory[nextClaimableEpoch] *\n                                PercentageMath.PERCENTAGE_FACTOR);\n                    }\n                    nextClaimableEpoch++;\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        _userNextClaimableEpoch[msg.sender] = nextClaimableEpoch;\n\n        // Claim the rewards if there are any\n        if (amountToClaim > 0) {\n            INativeToken(_addressProvider.getNativeToken()).mintGaugeRewards(\n                msg.sender,\n                amountToClaim\n            );\n\n            emit Claim(msg.sender, amountToClaim);\n        }\n    }\n\n    /// @notice Updates the total weight history by recording the current total weight for the current epoch and 128 previous epochs.\n    /// @dev This function will break if it is not used for 128 epochs in a row.\n    function writeTotalWeightHistory() public {\n        // Update last saved weight checkpoint and record weight for epochs\n        // Will break if is not used for 128 epochs\n        uint256 currentEpoch = IVotingEscrow(_addressProvider.getVotingEscrow())\n            .getEpoch(block.timestamp);\n        for (uint256 i = 0; i < 2 ** 7; i++) {\n            //Increase epoch\n            if (_workingWeightHistory.length >= currentEpoch) {\n                break;\n            }\n\n            // Save epoch total weight\n            _workingWeightHistory.push(_workingWeight);\n        }\n    }\n\n    /// @notice Gets the maturity boost for a given time interval since inception\n    /// @param timeInterval The time interval to get the boost for.\n    /// @return The maturity boost.\n    function _maturityMultiplier(\n        uint256 timeInterval\n    ) internal view returns (uint256) {\n        uint256 lpMaturityPeriod = IGaugeController(\n            _addressProvider.getGaugeController()\n        ).getLPMaturityPeriod();\n        if (timeInterval > lpMaturityPeriod) {\n            return PercentageMath.PERCENTAGE_FACTOR;\n        } else {\n            return\n                (PercentageMath.PERCENTAGE_FACTOR * timeInterval) /\n                lpMaturityPeriod;\n        }\n    }\n\n    /// @notice Updates the working balance of a user by computing the new amount based on the user's voting balance and the total voting supply.\n    /// @dev This function also saves the total weight history and the user's working balance history.\n    /// @param user The address of the user.\n    function _checkpoint(address user) internal {\n        // Get user ve balance and total ve balance\n        IVotingEscrow votingEscrow = IVotingEscrow(\n            _addressProvider.getVotingEscrow()\n        );\n\n        // Make sure the voting escrow's total supply is up to date\n        IVotingEscrow(votingEscrow).writeTotalWeightHistory();\n\n        uint256 userVotingBalance = votingEscrow.getUserWeight(user);\n        uint256 totalVotingSupply = votingEscrow.getTotalWeight();\n        uint256 newWeight;\n\n        // Save the total weight history\n        writeTotalWeightHistory();\n\n        if (totalVotingSupply == 0) {\n            newWeight = _balanceOf[user];\n        } else {\n            newWeight = Math.min(\n                _balanceOf[user],\n                (PercentageMath.HALF_PERCENTAGE_FACTOR *\n                    _balanceOf[user] +\n                    (PercentageMath.HALF_PERCENTAGE_FACTOR *\n                        userVotingBalance *\n                        getTotalSupply()) /\n                    totalVotingSupply) / PercentageMath.PERCENTAGE_FACTOR\n            );\n        }\n\n        uint256 oldWorkingBalanceWeight;\n        if (_workingBalanceHistory[user].length > 0) {\n            oldWorkingBalanceWeight = _workingBalanceHistory[user][\n                _workingBalanceHistory[user].length - 1\n            ].weight;\n        }\n        DataTypes.WorkingBalance memory newWorkingBalance = DataTypes\n            .WorkingBalance({\n                amount: SafeCast.toUint128(_balanceOf[user]),\n                weight: SafeCast.toUint128(newWeight),\n                timestamp: SafeCast.toUint40(block.timestamp)\n            });\n\n        _workingWeight =\n            _workingWeight +\n            newWorkingBalance.weight -\n            oldWorkingBalanceWeight;\n\n        _workingBalanceHistory[user].push(newWorkingBalance);\n    }\n\n    /// @notice Computes the boost of a user based on their working balance and their balance.\n    /// @param user The address of the user.\n    /// @return The boost of the user.\n    function getUserBoost(address user) external view returns (uint256) {\n        if (_balanceOf[user] == 0) {\n            return 0;\n        }\n\n        return\n            (2 *\n                _workingBalanceHistory[user][\n                    _workingBalanceHistory[user].length - 1\n                ].weight *\n                PercentageMath.PERCENTAGE_FACTOR) / _balanceOf[user];\n    }\n\n    /// @notice Returns the current maturity boost for a user\n    /// @param user The address of the user whose maturity boost will be returned.\n    /// @return The current maturity boost for the user.\n    function getUserMaturityMultiplier(\n        address user\n    ) external view returns (uint256) {\n        uint256 workingBalanceHistoryLength = _workingBalanceHistory[user]\n            .length;\n        if (workingBalanceHistoryLength == 0) {\n            return 0;\n        }\n\n        return\n            _maturityMultiplier(\n                block.timestamp -\n                    _workingBalanceHistory[user][\n                        workingBalanceHistoryLength - 1\n                    ].timestamp\n            );\n    }\n\n    /// @notice Updates the working balance of a user if one of their locks has expired.\n    /// @param tokenId The tokenId of the user's lock that has expired.\n    function kick(uint256 tokenId) external {\n        address votingEscrowAddress = _addressProvider.getVotingEscrow();\n        // Get user locked balance end time\n        uint256 lockEnd = IVotingEscrow(votingEscrowAddress)\n            .getLock(tokenId)\n            .end;\n\n        if (lockEnd < block.timestamp) {\n            _checkpoint(IERC721(votingEscrowAddress).ownerOf(tokenId));\n        }\n    }\n\n    /// @notice Deposits LP tokens into the contract and updates the user's balance and working balance.\n    /// @param amount The amount of LP tokens to deposit.\n    function deposit(uint256 amount) external {\n        require(amount > 0, \"LG:D:AMOUNT_ZERO\");\n\n        // Update balance\n        _balanceOf[msg.sender] += amount;\n\n        IERC20(_lpToken).safeTransferFrom(msg.sender, address(this), amount);\n\n        _checkpoint(msg.sender);\n\n        emit Deposit(msg.sender, amount);\n    }\n\n    /// @notice Withdraws LP tokens from the contract and updates the user's balance and working balance.\n    /// @param amount The amount of LP tokens to withdraw.\n    function withdraw(uint256 amount) external {\n        require(\n            amount <= _balanceOf[msg.sender],\n            \"LG:W:AMOUNT_EXCEEDS_BALANCE\"\n        );\n\n        // Update balance\n        _balanceOf[msg.sender] -= amount;\n\n        IERC20(_lpToken).safeTransfer(msg.sender, amount);\n\n        _checkpoint(msg.sender);\n\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(ERC165) returns (bool) {\n        return\n            interfaceId == type(IGauge).interfaceId ||\n            ERC165.supportsInterface(interfaceId);\n    }\n}"
    },
    {
      "filename": "contracts/protocol/Gauges/LendingGauge.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nimport {IAddressProvider} from \"../../interfaces/IAddressProvider.sol\";\nimport {INativeToken} from \"../../interfaces/INativeToken.sol\";\nimport {IGaugeController} from \"../../interfaces/IGaugeController.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {DataTypes} from \"../../libraries/types/DataTypes.sol\";\nimport {IVotingEscrow} from \"../../interfaces/IVotingEscrow.sol\";\nimport {IGauge} from \"../../interfaces/IGauge.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {PercentageMath} from \"../../libraries/utils/PercentageMath.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {SafeCast} from \"../../libraries/utils/SafeCast.sol\";\n\n/// @title LendingGauge contract\n/// @author leNFT\n/// @notice Liquidity Gauge contract. Distributes incentives to users who have deposited into the LendingPool.\n/// @dev The gauge tracks the balance and work done by users, which are then used to calculate rewards.\ncontract LendingGauge is IGauge, ERC165 {\n    IAddressProvider private immutable _addressProvider;\n    address private immutable _lpToken;\n    mapping(address => uint256) private _balanceOf;\n    mapping(address => DataTypes.WorkingBalance[])\n        private _workingBalanceHistory;\n    mapping(address => uint256) private _workingBalancePointer;\n    mapping(address => uint256) private _userNextClaimableEpoch;\n    uint256 private _workingWeight;\n    uint256[] private _workingWeightHistory;\n\n    using SafeERC20 for IERC20;\n\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n\n    /// @notice Constructor function for LendingGauge\n    /// @param addressProvider The address provider contract\n    /// @param lpToken_ The address of the LendingPool token\n    constructor(IAddressProvider addressProvider, address lpToken_) {\n        _addressProvider = addressProvider;\n        _lpToken = lpToken_;\n        _workingWeightHistory = [0];\n    }\n\n    /// @notice Returns the address of the LendingPool token\n    /// @return The address of the LendingPool token\n    function getLPToken() external view returns (address) {\n        return _lpToken;\n    }\n\n    /// @notice Returns the total supply of the LendingPool token in the contract\n    /// @return The total supply of the LendingPool token in the contract\n    function getTotalSupply() public view returns (uint256) {\n        return IERC20(_lpToken).balanceOf(address(this));\n    }\n\n    /// @notice Returns the balance of staked LP tokens for a given user\n    /// @param user The address of the user to check balance for\n    /// @return The balance of the user\n    function getBalanceOf(address user) external view returns (uint256) {\n        return _balanceOf[user];\n    }\n\n    /// @notice Claims the gauge rewards for the user and updates the user's next claimable epoch\n    /// @dev Will give a maximum of 50 epochs worth of rewards\n    /// @return amountToClaim The amount of gauge rewards claimed\n    function claim() external returns (uint256 amountToClaim) {\n        _checkpoint(msg.sender);\n\n        IVotingEscrow votingEscrow = IVotingEscrow(\n            _addressProvider.getVotingEscrow()\n        );\n        IGaugeController gaugeController = IGaugeController(\n            _addressProvider.getGaugeController()\n        );\n\n        // Get maximum number of user epochs\n        uint256 workingBalanceHistoryLength = _workingBalanceHistory[msg.sender]\n            .length;\n\n        // Check if user has any user actions and therefore something to claim\n        if (workingBalanceHistoryLength == 0) {\n            return 0;\n        }\n\n        // Set the next claimable epoch if it's the first time the user claims\n        if (_userNextClaimableEpoch[msg.sender] == 0) {\n            _userNextClaimableEpoch[msg.sender] =\n                votingEscrow.getEpoch(\n                    _workingBalanceHistory[msg.sender][0].timestamp\n                ) +\n                1;\n        }\n        // Iterate over a max of 50 epochs and/or user epochs\n        uint256 nextClaimableEpoch = _userNextClaimableEpoch[msg.sender];\n        uint256 currentEpoch = votingEscrow.getEpoch(block.timestamp);\n        for (uint256 i = 0; i < 50 && nextClaimableEpoch < currentEpoch; ) {\n            // Get the current user working Balance and its epoch\n            DataTypes.WorkingBalance\n                memory workingBalance = _workingBalanceHistory[msg.sender][\n                    _workingBalancePointer[msg.sender]\n                ];\n\n            // Check if the user entire balance history has been iterated\n            // This should never be the case since the checkpoint function is called before this function and it pushes one working balance to the history\n            if (\n                _workingBalancePointer[msg.sender] ==\n                workingBalanceHistoryLength - 1\n            ) {\n                if (_workingWeightHistory[nextClaimableEpoch] > 0) {\n                    amountToClaim +=\n                        (gaugeController.getGaugeRewards(\n                            address(this),\n                            nextClaimableEpoch\n                        ) *\n                            workingBalance.weight *\n                            _maturityMultiplier(\n                                block.timestamp - workingBalance.timestamp\n                            )) /\n                        (_workingWeightHistory[nextClaimableEpoch] *\n                            PercentageMath.PERCENTAGE_FACTOR);\n                }\n\n                nextClaimableEpoch++;\n            } else {\n                // We haven't iterated over the entire user history\n                DataTypes.WorkingBalance\n                    memory nextWorkingBalance = _workingBalanceHistory[\n                        msg.sender\n                    ][_workingBalancePointer[msg.sender] + 1];\n\n                // Check if the next working balance is in the same epoch as the current working balance\n                if (\n                    votingEscrow.getEpoch(nextWorkingBalance.timestamp) ==\n                    votingEscrow.getEpoch(workingBalance.timestamp)\n                ) {\n                    _workingBalancePointer[msg.sender]++;\n                }\n                // Check if the next working balance is in the next claimable epoch\n                else if (\n                    votingEscrow.getEpoch(nextWorkingBalance.timestamp) ==\n                    nextClaimableEpoch\n                ) {\n                    // If the next working balance has no decrease in balance we can claim the rewards\n                    if (\n                        _workingWeightHistory[nextClaimableEpoch] > 0 &&\n                        workingBalance.amount <= nextWorkingBalance.amount\n                    ) {\n                        amountToClaim +=\n                            (gaugeController.getGaugeRewards(\n                                address(this),\n                                nextClaimableEpoch\n                            ) *\n                                _maturityMultiplier(\n                                    nextWorkingBalance.timestamp -\n                                        workingBalance.timestamp\n                                ) *\n                                workingBalance.weight) /\n                            (_workingWeightHistory[nextClaimableEpoch] *\n                                PercentageMath.PERCENTAGE_FACTOR);\n                    }\n                    _workingBalancePointer[msg.sender]++;\n                    nextClaimableEpoch++;\n                } else {\n                    // THe next working balance is not in the next claimable epoch\n                    if (_workingWeightHistory[nextClaimableEpoch] > 0) {\n                        amountToClaim +=\n                            (gaugeController.getGaugeRewards(\n                                address(this),\n                                nextClaimableEpoch\n                            ) *\n                                _maturityMultiplier(\n                                    nextWorkingBalance.timestamp -\n                                        workingBalance.timestamp\n                                ) *\n                                workingBalance.weight) /\n                            (_workingWeightHistory[nextClaimableEpoch] *\n                                PercentageMath.PERCENTAGE_FACTOR);\n                    }\n                    nextClaimableEpoch++;\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        _userNextClaimableEpoch[msg.sender] = nextClaimableEpoch;\n\n        // Claim the rewards if there are any\n        if (amountToClaim > 0) {\n            INativeToken(_addressProvider.getNativeToken()).mintGaugeRewards(\n                msg.sender,\n                amountToClaim\n            );\n\n            emit Claim(msg.sender, amountToClaim);\n        }\n    }\n\n    /// @notice Updates the total weight history by recording the current total weight for the current epoch and 128 previous epochs.\n    /// @dev This function will break if it is not used for 128 epochs in a row.\n    function writeTotalWeightHistory() public {\n        // Update last saved weight checkpoint and record weight for epochs\n        // Will break if is not used for 128 epochs\n        uint256 currentEpoch = IVotingEscrow(_addressProvider.getVotingEscrow())\n            .getEpoch(block.timestamp);\n        for (uint256 i = 0; i < 2 ** 7; i++) {\n            //Increase epoch\n            if (_workingWeightHistory.length >= currentEpoch) {\n                break;\n            }\n\n            // Save epoch total weight\n            _workingWeightHistory.push(_workingWeight);\n        }\n    }\n\n    /// @notice Gets the maturity boost for a given time interval since inception\n    /// @param timeInterval The time interval to get the boost for.\n    /// @return The maturity boost.\n    function _maturityMultiplier(\n        uint256 timeInterval\n    ) internal view returns (uint256) {\n        uint256 lpMaturityPeriod = IGaugeController(\n            _addressProvider.getGaugeController()\n        ).getLPMaturityPeriod();\n        if (timeInterval > lpMaturityPeriod) {\n            return PercentageMath.PERCENTAGE_FACTOR;\n        } else {\n            return\n                (PercentageMath.PERCENTAGE_FACTOR * timeInterval) /\n                lpMaturityPeriod;\n        }\n    }\n\n    /// @notice Updates the working balance of a user by computing the new amount based on the user's voting balance and the total voting supply.\n    /// @dev This function also saves the total weight history and the user's working balance history.\n    /// @param user The address of the user.\n    function _checkpoint(address user) internal {\n        // Get user ve balance and total ve balance\n        IVotingEscrow votingEscrow = IVotingEscrow(\n            _addressProvider.getVotingEscrow()\n        );\n\n        // Make sure the voting escrow's total supply is up to date\n        IVotingEscrow(votingEscrow).writeTotalWeightHistory();\n\n        uint256 userVotingBalance = votingEscrow.getUserWeight(user);\n        uint256 totalVotingSupply = votingEscrow.getTotalWeight();\n        uint256 newWeight;\n\n        // Save the total weight history\n        writeTotalWeightHistory();\n\n        if (totalVotingSupply == 0) {\n            newWeight = _balanceOf[user];\n        } else {\n            newWeight = Math.min(\n                _balanceOf[user],\n                (PercentageMath.HALF_PERCENTAGE_FACTOR *\n                    _balanceOf[user] +\n                    (PercentageMath.HALF_PERCENTAGE_FACTOR *\n                        userVotingBalance *\n                        getTotalSupply()) /\n                    totalVotingSupply) / PercentageMath.PERCENTAGE_FACTOR\n            );\n        }\n\n        uint256 oldWorkingBalanceWeight;\n        if (_workingBalanceHistory[user].length > 0) {\n            oldWorkingBalanceWeight = _workingBalanceHistory[user][\n                _workingBalanceHistory[user].length - 1\n            ].weight;\n        }\n        DataTypes.WorkingBalance memory newWorkingBalance = DataTypes\n            .WorkingBalance({\n                amount: SafeCast.toUint128(_balanceOf[user]),\n                weight: SafeCast.toUint128(newWeight),\n                timestamp: SafeCast.toUint40(block.timestamp)\n            });\n\n        _workingWeight =\n            _workingWeight +\n            newWorkingBalance.weight -\n            oldWorkingBalanceWeight;\n\n        _workingBalanceHistory[user].push(newWorkingBalance);\n    }\n\n    /// @notice Computes the boost of a user based on their working balance and their balance.\n    /// @param user The address of the user.\n    /// @return The boost of the user.\n    function getUserBoost(address user) external view returns (uint256) {\n        if (_balanceOf[user] == 0) {\n            return 0;\n        }\n\n        return\n            (2 *\n                _workingBalanceHistory[user][\n                    _workingBalanceHistory[user].length - 1\n                ].weight *\n                PercentageMath.PERCENTAGE_FACTOR) / _balanceOf[user];\n    }\n\n    /// @notice Returns the current maturity boost for a user\n    /// @param user The address of the user whose maturity boost will be returned.\n    /// @return The current maturity boost for the user.\n    function getUserMaturityMultiplier(\n        address user\n    ) external view returns (uint256) {\n        uint256 workingBalanceHistoryLength = _workingBalanceHistory[user]\n            .length;\n        if (workingBalanceHistoryLength == 0) {\n            return 0;\n        }\n\n        return\n            _maturityMultiplier(\n                block.timestamp -\n                    _workingBalanceHistory[user][\n                        workingBalanceHistoryLength - 1\n                    ].timestamp\n            );\n    }\n\n    /// @notice Updates the working balance of a user if one of their locks has expired.\n    /// @param tokenId The tokenId of the user's lock that has expired.\n    function kick(uint256 tokenId) external {\n        address votingEscrowAddress = _addressProvider.getVotingEscrow();\n        // Get user locked balance end time\n        uint256 lockEnd = IVotingEscrow(votingEscrowAddress)\n            .getLock(tokenId)\n            .end;\n\n        if (lockEnd < block.timestamp) {\n            _checkpoint(IERC721(votingEscrowAddress).ownerOf(tokenId));\n        }\n    }\n\n    /// @notice Deposits LP tokens into the contract and updates the user's balance and working balance.\n    /// @param amount The amount of LP tokens to deposit.\n    function deposit(uint256 amount) external {\n        require(amount > 0, \"LG:D:AMOUNT_ZERO\");\n\n        // Update balance\n        _balanceOf[msg.sender] += amount;\n\n        IERC20(_lpToken).safeTransferFrom(msg.sender, address(this), amount);\n\n        _checkpoint(msg.sender);\n\n        emit Deposit(msg.sender, amount);\n    }\n\n    /// @notice Withdraws LP tokens from the contract and updates the user's balance and working balance.\n    /// @param amount The amount of LP tokens to withdraw.\n    function withdraw(uint256 amount) external {\n        require(\n            amount <= _balanceOf[msg.sender],\n            \"LG:W:AMOUNT_EXCEEDS_BALANCE\"\n        );\n\n        // Update balance\n        _balanceOf[msg.sender] -= amount;\n\n        IERC20(_lpToken).safeTransfer(msg.sender, amount);\n\n        _checkpoint(msg.sender);\n\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(ERC165) returns (bool) {\n        return\n            interfaceId == type(IGauge).interfaceId ||\n            ERC165.supportsInterface(interfaceId);\n    }\n}"
    }
  ]
}