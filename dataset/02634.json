{
  "Title": "H-5: Users are unable close or add to their Lyra vault positions when price is stale or circuit breaker is tripped",
  "Content": "# Issue H-5: Users are unable close or add to their Lyra vault positions when price is stale or circuit breaker is tripped \n\nSource: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/69 \n\n## Found by \n0x52, rvierdiiev\n\n## Summary\n\nUsers are unable close or add to their Lyra vault positions when price is stale or circuit breaker is tripped. This is problematic for a few reasons. First is that the circuit breaker can be tripped indefinitely which means their collateral could be frozen forever and they will be accumulating interest the entire time they are frozen. The second is that since they can't add any additional collateral to their loan, the loan may end up being underwater by the time the price is no longer stale or circuit breaker is no longer tripped. They may have wanted to add more assets and now they are liquidated, which is unfair as users who are liquidated are effectively forced to pay a fee to the liquidator.\n\n## Vulnerability Detail\n\n    function _checkIfCollateralIsActive(bytes32 _currencyKey) internal view override {\n            \n             //Lyra LP tokens use their associated LiquidityPool to check if they're active\n             ILiquidityPoolAvalon LiquidityPool = ILiquidityPoolAvalon(collateralBook.liquidityPoolOf(_currencyKey));\n             bool isStale;\n             uint circuitBreakerExpiry;\n             //ignore first output as this is the token price and not needed yet.\n             (, isStale, circuitBreakerExpiry) = LiquidityPool.getTokenPriceWithCheck();\n             require( !(isStale), \"Global Cache Stale, can't trade\");\n             require(circuitBreakerExpiry < block.timestamp, \"Lyra Circuit Breakers active, can't trade\");\n    }\n\nThe above lines are run every time a user a user tries to interact with the vault. Currently this is overly restrictive and can lead to a lot of undesired situations, as explained in the summary.\n\n## Impact\n\nFrozen assets, unfair interest accumulation and unfair liquidations\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Lyra.sol#L45-L55\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe contract is frozen when price is stale or circuit breaker is tripped to prevent price manipulation. While it should restrict a majority of actions there are a two that don't need any price validation. If a user wishes to close out their entire loan then there is no need for price validation because the user has no more debt and therefore doesn't need to maintain any level of collateralization. The other situation is if a user adds collateral to their vault and doesn't take out any more loans. In this scenario, the collateralization can only increase, which means that price validation is not necessary.\n\nI recommend the following changes to closeLoan:\n\n    -   _checkIfCollateralIsActive(currencyKey);\n        uint256 isoUSDdebt = (isoUSDLoanAndInterest[_collateralAddress][msg.sender] * virtualPrice) / LOAN_SCALE;\n        require( isoUSDdebt >= _USDToVault, \"Trying to return more isoUSD than borrowed!\");\n        uint256 outstandingisoUSD = isoUSDdebt - _USDToVault;\n        if(outstandingisoUSD >= TENTH_OF_CENT){ //ignore leftover debts less than $0.001\n    +       //only need to check collateral value if user has remaining debt\n    +       _checkIfCollateralIsActive(currencyKey);\n            uint256 collateralLeft = collateralPosted[_collateralAddress][msg.sender] - _collateralToUser;\n            uint256 colInUSD = priceCollateralToUSD(currencyKey, collateralLeft); \n            uint256 borrowMargin = (outstandingisoUSD * minOpeningMargin) / LOAN_SCALE;\n            require(colInUSD > borrowMargin , \"Remaining debt fails to meet minimum margin!\");\n        }\n\nI recommend removing liquidation threshold check from increaseCollateralAmount:\n\n        //debatable check begins here \n    -   uint256 totalCollat = collateralPosted[_collateralAddress][msg.sender] + _colAmount;\n    -   uint256 colInUSD = priceCollateralToUSD(currencyKey, totalCollat);\n    -   uint256 USDborrowed = (isoUSDLoanAndInterest[_collateralAddress][msg.sender] * virtualPrice) / LOAN_SCALE;\n    -   uint256 borrowMargin = (USDborrowed * liquidatableMargin) / LOAN_SCALE;\n    -   require(colInUSD >= borrowMargin, \"Liquidation margin not met!\");\n        //debatable check ends here\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix. \nThe liquidation threshold for `increaseCollateralAmount()` has been removed as part of the fix for issue #229\n\nWill update when the closeLoan check has been improved.\n\n**kree-dotcom**\n\n`closeLoan()` fixed here https://github.com/kree-dotcom/isomorph/commit/c14410687e0f2095dd9103b00157b8784430875e\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/22",
  "Code": [
    {
      "filename": "contracts/Isomorph/contracts/Vault_Lyra.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Vault_Lyra.sol for isomorph.loans\n// Bug bounties available\n\npragma solidity =0.8.9; \npragma abicoder v2;\n\n// External Lyra interface\nimport \"./helper/interfaces/ILiquidityPoolAvalon.sol\";\n\n//Vault Base for common functions\nimport \"./Vault_Base_ERC20.sol\";\n\n\ncontract Vault_Lyra is Vault_Base_ERC20{\n\n    constructor(\n        address _isoUSD, //isoUSD address\n        address _treasury, //treasury address\n        address _collateralBook //collateral structure book address\n        ){\n        require(_isoUSD != address(0), \"Zero Address used isoUSD\");\n        require(_treasury != address(0), \"Zero Address used Treasury\");\n        require(_collateralBook != address(0), \"Zero Address used Collateral\");\n        isoUSD = IisoUSDToken(_isoUSD);\n        treasury = _treasury;\n        collateralBook = ICollateralBook(_collateralBook);\n        _setupRole(ADMIN_ROLE, msg.sender);\n        _setupRole(PAUSER_ROLE, msg.sender);\n       \n    } \n    \n    \n\n    \n    /**\n        Internal helper and check functions\n     */\n\n    /// @dev process for Lyra LP assets\n    /// @dev this uses the liquidity Pool associated with the LP token to verify the circuit breaker is not active\n    /// @dev to be overly cautious if the CB is active we revert\n    /// @notice if any of them aren't the function will revert.\n    /// @param _currencyKey the code used by synthetix to identify different synths, linked in collateral structure to collateral address\n    function _checkIfCollateralIsActive(bytes32 _currencyKey) internal view override {\n            \n             //Lyra LP tokens use their associated LiquidityPool to check if they're active\n             ILiquidityPoolAvalon LiquidityPool = ILiquidityPoolAvalon(collateralBook.liquidityPoolOf(_currencyKey));\n             bool isStale;\n             uint circuitBreakerExpiry;\n             //ignore first output as this is the token price and not needed yet.\n             (, isStale, circuitBreakerExpiry) = LiquidityPool.getTokenPriceWithCheck();\n             require( !(isStale), \"Global Cache Stale, can't trade\");\n             require(circuitBreakerExpiry < block.timestamp, \"Lyra Circuit Breakers active, can't trade\");\n    }\n    \n\n    /// @param _liquidityPool the address of the liquidityPool relating to the Lyra collateral we're using\n    /// @notice there is a withdrawal fee for Lyra LPs, so we depreciate LP tokens by this to get the fair value\n    /// @notice because the withdrawal fee is dynamic we must fetch it on each LP token valuation in case it's changed\n    function _getWithdrawalFee(ILiquidityPoolAvalon _liquidityPool) internal view returns(\n        uint256 ){\n        ILiquidityPoolAvalon.LiquidityPoolParameters memory params = _liquidityPool.lpParams();\n        return ( params.withdrawalFee );\n    }\n    \n\n    /**\n        Public functions \n    */\n\n\n    //isoUSD is assumed to be valued at $1 by all of the system to avoid oracle attacks. \n    /// @param _currencyKey code used by the system to identify each collateral\n    /// @param _amount quantity of collateral to price into sUSD\n    /// @return returns the value of the given collateral in sUSD which is assumed to be pegged at $1.\n    function priceCollateralToUSD(bytes32 _currencyKey, uint256 _amount) public view override returns(uint256){\n         //The LiquidityPool associated with the LP Token is used for pricing\n        ILiquidityPoolAvalon LiquidityPool = ILiquidityPoolAvalon(collateralBook.liquidityPoolOf(_currencyKey));\n        //we have already checked for stale greeks so here we call the basic price function.\n        uint256 tokenPrice = LiquidityPool.getTokenPrice();          \n        uint256 withdrawalFee = _getWithdrawalFee(LiquidityPool);\n        uint256 USDValue  = (_amount * tokenPrice) / LOAN_SCALE;\n        //we remove the Liquidity Pool withdrawalFee \n        //as there's no way to remove the LP position without paying this.\n        uint256 USDValueAfterFee = USDValue * (LOAN_SCALE- withdrawalFee)/LOAN_SCALE;\n        return(USDValueAfterFee);\n    }\n\n    /**\n        External user loan interaction functions\n     */\n\n\n     /**\n      * @notice Only Vaults can mint isoUSD.\n      * @dev Mints 'USDborrowed' amount of isoUSD to vault and transfers to msg.sender and emits transfer event.\n      * @param _collateralAddress address of collateral token being used.\n      * @param _colAmount amount of collateral tokens being used.\n      * @param _USDborrowed amount of isoUSD to be minted, it is then split into the amount sent and the opening fee.\n     **/\n    function openLoan(\n        address _collateralAddress,\n        uint256 _colAmount,\n        uint256 _USDborrowed\n        ) external override whenNotPaused \n        {\n        _collateralExists(_collateralAddress);\n        IERC20 collateral = IERC20(_collateralAddress);\n        \n        require(collateral.balanceOf(msg.sender) >= _colAmount, \"User lacks collateral quantity!\");\n        //make sure virtual price is related to current time before fetching collateral details\n        //slither-disable-next-line reentrancy-vulnerabilities-1\n        _updateVirtualPrice(block.timestamp, _collateralAddress);  \n        \n        (   \n            bytes32 currencyKey,\n            uint256 minOpeningMargin,\n            ,\n            ,\n            ,\n            uint256 virtualPrice,\n            \n        ) = _getCollateral(_collateralAddress);\n        //check for frozen or paused collateral\n        _checkIfCollateralIsActive(currencyKey);\n        //make sure the total isoUSD borrowed doesn't exceed the opening borrow margin ratio\n        uint256 colInUSD = priceCollateralToUSD(currencyKey, _colAmount + collateralPosted[_collateralAddress][msg.sender]);\n        uint256 totalUSDborrowed = _USDborrowed +  (isoUSDLoanAndInterest[_collateralAddress][msg.sender] * virtualPrice)/LOAN_SCALE;\n        uint256 borrowMargin = (totalUSDborrowed * minOpeningMargin) / LOAN_SCALE;\n        require(colInUSD >= borrowMargin, \"Minimum margin not met!\");\n\n        //update mappings with new loan amounts\n        collateralPosted[_collateralAddress][msg.sender] = collateralPosted[_collateralAddress][msg.sender] + _colAmount;\n        isoUSDLoaned[_collateralAddress][msg.sender] = isoUSDLoaned[_collateralAddress][msg.sender] + _USDborrowed;\n        isoUSDLoanAndInterest[_collateralAddress][msg.sender] = isoUSDLoanAndInterest[_collateralAddress][msg.sender] + ((_USDborrowed * LOAN_SCALE) / virtualPrice);\n        \n        emit OpenOrIncreaseLoan(msg.sender, _USDborrowed, currencyKey, _colAmount);\n\n        //Now all effects are handled, transfer the assets so we follow CEI pattern\n        _increaseCollateral(collateral, _colAmount);\n        _increaseLoan(_USDborrowed);\n        \n        \n    }\n\n\n    /**\n      * @dev Increases collateral supplied against an existing loan. \n      * @notice Checks adding the collateral will keep the user above liquidation, \n      * @notice this debatable check isn't technically needed but feels fairer to end users.\n      * @param _collateralAddress address of collateral token being used.\n      * @param _colAmount amount of collateral tokens being used.\n     **/\n    function increaseCollateralAmount(\n        address _collateralAddress,\n        uint256 _colAmount\n        ) external override whenNotPaused \n        {\n        _collateralExists(_collateralAddress);\n        require(collateralPosted[_collateralAddress][msg.sender] > 0, \"No existing collateral!\"); //feels like semantic overloading and also problematic for dust after a loan is 'closed'\n        require(_colAmount > 0 , \"Zero amount\"); //Not strictly needed, prevents event spamming though\n        //make sure virtual price is related to current time before fetching collateral details\n        //slither-disable-next-line reentrancy-vulnerabilities-1\n        _updateVirtualPrice(block.timestamp, _collateralAddress);\n        IERC20 collateral = IERC20(_collateralAddress);\n        require(collateral.balanceOf(msg.sender) >= _colAmount, \"User lacks collateral amount\");\n        (   \n            bytes32 currencyKey,\n            ,\n            uint256 liquidatableMargin,\n            ,\n            ,\n            uint256 virtualPrice,\n            \n        ) = _getCollateral(_collateralAddress);\n        //check for frozen or paused collateral\n        _checkIfCollateralIsActive(currencyKey);\n        //debatable check begins here \n        uint256 totalCollat = collateralPosted[_collateralAddress][msg.sender] + _colAmount;\n        uint256 colInUSD = priceCollateralToUSD(currencyKey, totalCollat);\n        uint256 USDborrowed = (isoUSDLoanAndInterest[_collateralAddress][msg.sender] * virtualPrice) / LOAN_SCALE;\n        uint256 borrowMargin = (USDborrowed * liquidatableMargin) / LOAN_SCALE;\n        require(colInUSD >= borrowMargin, \"Liquidation margin not met!\");\n        //debatable check ends here\n        //update mapping with new collateral amount\n        collateralPosted[_collateralAddress][msg.sender] = collateralPosted[_collateralAddress][msg.sender] + _colAmount;\n        emit IncreaseCollateral(msg.sender, currencyKey, _colAmount);\n        //Now all effects are handled, transfer the collateral so we follow CEI pattern\n        _increaseCollateral(collateral, _colAmount);\n        \n    }\n\n\n     /**\n      * @notice Only Vault can destroy isoUSD.\n      * @dev destroys USDreturned of isoUSD held by caller, returns user collateral, close debt \n      * @dev if debt remains, checks minimum collateral ratio is upheld \n      * @dev if cost of a transaction can be <$0.01 YOU MUST UPDATE TENTH_OF_CENT check otherwise users can open microloans and close, withdrawing collateral without repaying. \n      * @param _collateralAddress address of collateral token being used.\n      * @param _collateralToUser amount of collateral tokens being returned to user.\n      * @param _USDToVault amount of isoUSD to be burnt.\n     **/\n\n    function closeLoan(\n        address _collateralAddress,\n        uint256 _collateralToUser,\n        uint256 _USDToVault\n        ) external override whenNotPaused  \n        {\n        _collateralExists(_collateralAddress);\n        _closeLoanChecks(_collateralAddress, _collateralToUser, _USDToVault);\n        //make sure virtual price is related to current time before fetching collateral details\n        //slither-disable-next-line reentrancy-vulnerabilities-1\n        _updateVirtualPrice(block.timestamp, _collateralAddress);\n        (   \n            bytes32 currencyKey,\n            uint256 minOpeningMargin,\n            ,\n            ,\n            ,\n            uint256 virtualPrice,\n            \n        ) = _getCollateral(_collateralAddress);\n        //check for frozen or paused collateral\n        _checkIfCollateralIsActive(currencyKey);\n        uint256 isoUSDdebt = (isoUSDLoanAndInterest[_collateralAddress][msg.sender] * virtualPrice) / LOAN_SCALE;\n        require( isoUSDdebt >= _USDToVault, \"Trying to return more isoUSD than borrowed!\");\n        uint256 outstandingisoUSD = isoUSDdebt - _USDToVault;\n        if(outstandingisoUSD >= TENTH_OF_CENT){ //ignore leftover debts less than $0.001\n            uint256 collateralLeft = collateralPosted[_collateralAddress][msg.sender] - _collateralToUser;\n            uint256 colInUSD = priceCollateralToUSD(currencyKey, collateralLeft); \n            uint256 borrowMargin = (outstandingisoUSD * minOpeningMargin) / LOAN_SCALE;\n            require(colInUSD > borrowMargin , \"Remaining debt fails to meet minimum margin!\");\n        }\n\n        //record paying off loan principle before interest\n        //slither-disable-next-line uninitialized-local-variables\n        uint256 interestPaid;\n        uint256 loanPrinciple = isoUSDLoaned[_collateralAddress][msg.sender];\n        if( loanPrinciple >= _USDToVault){\n            //pay off loan principle first\n            isoUSDLoaned[_collateralAddress][msg.sender] = loanPrinciple - _USDToVault;\n        }\n        else{\n            interestPaid = _USDToVault - loanPrinciple;\n            //loan principle is fully repaid so record this.\n            isoUSDLoaned[_collateralAddress][msg.sender] = 0;\n        }\n\n        //update mappings with reduced amounts\n        isoUSDLoanAndInterest[_collateralAddress][msg.sender] = isoUSDLoanAndInterest[_collateralAddress][msg.sender] - ((_USDToVault * LOAN_SCALE) / virtualPrice);\n        collateralPosted[_collateralAddress][msg.sender] = collateralPosted[_collateralAddress][msg.sender] - _collateralToUser;\n        emit ClosedLoan(msg.sender, _USDToVault, currencyKey, _collateralToUser);\n        //Now all effects are handled, transfer the assets so we follow CEI pattern\n        _decreaseLoan(_collateralAddress, _collateralToUser, _USDToVault, interestPaid);\n        }\n    \n    \n\n    /**\n        Liquidation functions\n\n\n     /**\n      * @notice Anyone can liquidate any other undercollateralised loan.\n      * @notice The max acceptable liquidation quantity is calculated using viewLiquidatableAmount\n      * @dev checks that partial liquidation would be insufficient to recollaterize the loanHolder's debt \n      * @dev caller is paid 1e18 -`LIQUIDATION_RETURN` as reward for calling the liquidation.\n      * @dev In the event of full liquidation being insufficient the leftover debt is written off and an event tracking this is emitted.\n      * @param _loanHolder address of loanee being liquidated.\n      * @param _collateralAddress address of collateral token being used.\n     **/\n        \n        function callLiquidation(\n            address _loanHolder,\n            address _collateralAddress\n        ) external override whenNotPaused  \n        {   \n            _collateralExists(_collateralAddress);\n            require(_loanHolder != address(0), \"Zero address used\"); \n             //make sure virtual price is related to current time before fetching collateral details\n            //slither-disable-next-line reentrancy-vulnerabilities-1\n            _updateVirtualPrice(block.timestamp, _collateralAddress);\n            (\n                bytes32 currencyKey,\n                ,\n                uint256 liquidatableMargin,\n                ,\n                ,\n                uint256 virtualPrice,\n                \n            ) = _getCollateral(_collateralAddress);\n            //check for frozen or paused collateral\n            _checkIfCollateralIsActive(currencyKey);\n            //check how much of the specified loan should be closed\n            uint256 isoUSDBorrowed = (isoUSDLoanAndInterest[_collateralAddress][_loanHolder] * virtualPrice) / LOAN_SCALE;\n            uint256 totalUserCollateral = collateralPosted[_collateralAddress][_loanHolder];\n            uint256 currentPrice = priceCollateralToUSD(currencyKey, LOAN_SCALE); //assumes LOAN_SCALE = 1 ether, i.e. one unit of collateral!\n            uint256 liquidationAmount = viewLiquidatableAmount(totalUserCollateral, currentPrice, isoUSDBorrowed, liquidatableMargin);\n            require(liquidationAmount > 0 , \"Loan not liquidatable\");\n            //if complete liquidation falls short of recovering the position we settle for complete liquidation\n            if(liquidationAmount > totalUserCollateral){\n                liquidationAmount = totalUserCollateral;\n            }\n            uint256 isoUSDreturning = liquidationAmount*currentPrice*LIQUIDATION_RETURN/LOAN_SCALE/LOAN_SCALE;  \n            \n            //if the liquidation is the entire loan we need to record more\n            if(totalUserCollateral == liquidationAmount){\n                //and some of the loan is not being repaid.\n                if(isoUSDBorrowed > isoUSDreturning){\n                    //if a user is being fully liquidated we will forgive any remaining debt so it\n                    // doesn't roll over if they open a new loan of the same collateral.\n                    delete isoUSDLoanAndInterest[_collateralAddress][_loanHolder];\n                    emit BadDebtCleared(_loanHolder, msg.sender, isoUSDBorrowed - isoUSDreturning, currencyKey);\n                    \n                }\n            }\n            //finally we call an internal function that updates mappings\n            // burns the liquidator's isoUSD and transfers the collateral to the liquidator as payment\n            _liquidate(_loanHolder, _collateralAddress, liquidationAmount, isoUSDreturning, currencyKey, virtualPrice);\n            \n        } \n}"
    }
  ]
}