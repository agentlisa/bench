{
  "Title": "[M-01] The owner of a `LSP0ERC725Account` can become the owner again after renouncing ownership",
  "Content": "\nThe `renounceOwnership()` function allows the owner of a `LSP0ERC725Account` to renounce ownership through a two-step process. When `renounceOwnership()` is first called, `_renounceOwnershipStartedAt` is set to `block.number` to indicate that the process has started:\n\n[LSP14Ownable2Step.sol#L159-L167](https://github.com/code-423n4/2023-06-lukso/blob/main/contracts/LSP14Ownable2Step/LSP14Ownable2Step.sol#L159-L167)\n\n```solidity\n        if (\n            currentBlock > confirmationPeriodEnd ||\n            _renounceOwnershipStartedAt == 0\n        ) {\n            _renounceOwnershipStartedAt = currentBlock;\n            delete _pendingOwner;\n            emit RenounceOwnershipStarted();\n            return;\n        }\n```\n\nWhen `renounceOwnership()` is called again, the owner is then set to `address(0)`:\n\n[LSP14Ownable2Step.sol#L176-L178](https://github.com/code-423n4/2023-06-lukso/blob/main/contracts/LSP14Ownable2Step/LSP14Ownable2Step.sol#L176-L178)\n\n```solidity\n        _setOwner(address(0));\n        delete _renounceOwnershipStartedAt;\n        emit OwnershipRenounced();\n```\n\nHowever, as `_pendingOwner` is only deleted in the first call to `renounceOwnership()`, an owner could regain ownership of the account after the second call to `renounceOwnership()` by doing the following:\n\n1. Call `renounceOwnership()` for the first time to initiate the process.\n2. Using `execute()`, to perform a delegate call that overwrites `_pendingOwner` to their own address.\n3. Call `renounceOwnership()` again to set the owner to `address(0)`.\n\nAs `_pendingOwner` is still set to the owner's address, they can call `acceptOwnership()` at anytime to regain ownership of the account.\n\n### Impact\n\nEven after the `renounceOwnership()` process is completed, an owner might still be able to regain ownership of an LSP0 account.\n\nThis could potentially be dangerous if users assume that an LSP0 account will never be able to call restricted functions after ownership is renounced, as stated in [the following comment](https://github.com/code-423n4/2023-06-lukso/blob/main/contracts/LSP0ERC725Account/LSP0ERC725AccountCore.sol#L652):\n\n> Leaves the contract without an owner. Once ownership of the contract has been renounced, any functions that are restricted to be called by the owner will be permanently inaccessible, making these functions not callable anymore and unusable.\n\nFor example, if a protocol's admin is set to a `LSP0ERC725Account`, the owner could gain the community's trust by renouncing ownership. After the protocol has gained a significant TVL, the owner could then regain ownership of the account and proceed to rug the protocol.\n\n### Proof of Concept\n\nThe following Foundry test demonstrates how an owner can regain ownership of a `LSP0ERC725Account` after `renounceOwnership()` has been called twice:\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\nimport \"../../contracts/LSP0ERC725Account/LSP0ERC725Account.sol\";\n\ncontract Implementation {\n    // _pendingOwner is at slot 3 for LSP0ERC725Account\n    bytes32[3] __gap;\n    address _pendingOwner; \n\n    function setPendingOwner(address newPendingOwner) external {\n        _pendingOwner = newPendingOwner;\n    }\n}\n\ncontract RenounceOwnership_POC is Test {\n    LSP0ERC725Account account;\n\n    function setUp() public {\n        // Deploy LSP0 account with this address as owner\n        account = new LSP0ERC725Account(address(this));\n    }\n\n    function testCanRegainOwnership() public {\n        // Call renounceOwnership() to initiate the process\n        account.renounceOwnership();\n\n        // Overwrite _pendingOwner using a delegatecall\n        Implementation implementation = new Implementation();\n        account.execute(\n            4, // OPERATION_4_DELEGATECALL\n            address(implementation),\n            0,\n            abi.encodeWithSelector(Implementation.setPendingOwner.selector, address(this))\n        );\n\n        // _pendingOwner is now set to this address\n        assertEq(account.pendingOwner(), address(this));\n\n        // Call renounceOwnership() again to renounce ownership\n        vm.roll(block.number + 200);\n        account.renounceOwnership();\n\n        // Owner is now set to address(0)\n        assertEq(account.owner(), address(0));\n\n        // Call acceptOwnership() to regain ownership\n        account.acceptOwnership();\n        \n        // Owner is now set to address(this) again\n        assertEq(account.owner(), address(this));\n    }\n}\n```\n\n### Recommended Mitigation\n\nConsider deleting `_pendingOwner` when `renounceOwnership()` is called for a second time as well:\n\n[LSP14Ownable2Step.sol#L176-L178](https://github.com/code-423n4/2023-06-lukso/blob/main/contracts/LSP14Ownable2Step/LSP14Ownable2Step.sol#L176-L178)\n\n```diff\n        _setOwner(address(0));\n        delete _renounceOwnershipStartedAt;\n+       delete _pendingOwner;\n        emit OwnershipRenounced();\n```\n\n### Assessed type\n\nCall/delegatecall\n\n**[minhquanym (lookout) commented](https://github.com/code-423n4/2023-06-lukso-findings/issues/124#issuecomment-1636699364):**\n > In this scenario, `renounceOwnership()` is initiated before `setPendingOwner()` is called. In case the calls order is reversed, the `_pendingOwner` will be deleted.\n> \n> Not sure this is intended or not so leaving for sponsor review.\n\n**[CJ42 (LUKSO) confirmed](https://github.com/code-423n4/2023-06-lukso-findings/issues/124#issuecomment-1649876572)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-lukso",
  "Code": [
    {
      "filename": "contracts/LSP14Ownable2Step/LSP14Ownable2Step.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// interfaces\nimport {ILSP14Ownable2Step} from \"./ILSP14Ownable2Step.sol\";\n\n// modules\nimport {\n    OwnableUnset\n} from \"../../submodules/ERC725/implementations/contracts/custom/OwnableUnset.sol\";\n\n// libraries\nimport {LSP1Utils} from \"../LSP1UniversalReceiver/LSP1Utils.sol\";\n\n// errors\nimport \"./LSP14Errors.sol\";\n\n// constants\nimport {\n    _TYPEID_LSP14_OwnershipTransferStarted,\n    _TYPEID_LSP14_OwnershipTransferred_SenderNotification,\n    _TYPEID_LSP14_OwnershipTransferred_RecipientNotification\n} from \"./LSP14Constants.sol\";\n\n/**\n * @title LSP14Ownable2Step\n * @author Fabian Vogelsteller <fabian@lukso.network>, Jean Cavallera (CJ42), Yamen Merhi (YamenMerhi), Daniel Afteni (B00ste)\n * @dev This contract is a modified version of the OwnableUnset implementation, where transferring and renouncing ownership\n *      works as a 2 steps process. This can be used as a confirmation mechanism to prevent potential mistakes when\n *      transferring ownership of the contract, where the control of the contract could be lost forever.\n */\nabstract contract LSP14Ownable2Step is ILSP14Ownable2Step, OwnableUnset {\n    using LSP1Utils for address;\n\n    /**\n     * @dev The number of block that MUST pass before one is able to\n     *  confirm renouncing ownership\n     */\n    uint256 public constant RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY = 200;\n\n    /**\n     * @dev The number of blocks during which one can renounce ownership\n     */\n    uint256 public constant RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD = 200;\n\n    /**\n     * @dev The block number saved when initiating the process of renouncing ownerhsip\n     */\n    uint256 private _renounceOwnershipStartedAt;\n\n    /**\n     * @dev see `pendingOwner()`\n     */\n    address private _pendingOwner;\n\n    /**\n     * @inheritdoc ILSP14Ownable2Step\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @inheritdoc ILSP14Ownable2Step\n     */\n    function transferOwnership(\n        address newOwner\n    ) public virtual override(OwnableUnset, ILSP14Ownable2Step) onlyOwner {\n        _transferOwnership(newOwner);\n\n        address currentOwner = owner();\n        emit OwnershipTransferStarted(currentOwner, newOwner);\n\n        newOwner.tryNotifyUniversalReceiver(\n            _TYPEID_LSP14_OwnershipTransferStarted,\n            \"\"\n        );\n        require(\n            currentOwner == owner(),\n            \"LSP14: newOwner MUST accept ownership in a separate transaction\"\n        );\n    }\n\n    /**\n     * @inheritdoc ILSP14Ownable2Step\n     */\n    function acceptOwnership() public virtual {\n        address previousOwner = owner();\n\n        _acceptOwnership();\n\n        previousOwner.tryNotifyUniversalReceiver(\n            _TYPEID_LSP14_OwnershipTransferred_SenderNotification,\n            \"\"\n        );\n\n        msg.sender.tryNotifyUniversalReceiver(\n            _TYPEID_LSP14_OwnershipTransferred_RecipientNotification,\n            \"\"\n        );\n    }\n\n    /**\n     * @inheritdoc ILSP14Ownable2Step\n     */\n    function renounceOwnership()\n        public\n        virtual\n        override(OwnableUnset, ILSP14Ownable2Step)\n        onlyOwner\n    {\n        _renounceOwnership();\n    }\n\n    // --- Internal methods\n\n    /**\n     * @dev set the pending owner of the contract and cancel any renounce ownership\n     * process that was previously started.\n     *\n     * @param newOwner The address of the new pending owner.\n     *\n     * Requirements:\n     * - `newOwner` cannot be the address of the contract itself.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        if (newOwner == address(this)) revert CannotTransferOwnershipToSelf();\n\n        _pendingOwner = newOwner;\n        delete _renounceOwnershipStartedAt;\n    }\n\n    /**\n     * @dev set the pending owner of the contract as the new owner.\n     */\n    function _acceptOwnership() internal virtual {\n        require(\n            msg.sender == pendingOwner(),\n            \"LSP14: caller is not the pendingOwner\"\n        );\n\n        _setOwner(msg.sender);\n        delete _pendingOwner;\n    }\n\n    /**\n     * @dev initiate or confirm the process of renouncing ownership\n     * after a specific delay of blocks have passed.\n     */\n    function _renounceOwnership() internal virtual {\n        uint256 currentBlock = block.number;\n        uint256 confirmationPeriodStart = _renounceOwnershipStartedAt +\n            RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY;\n        uint256 confirmationPeriodEnd = confirmationPeriodStart +\n            RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD;\n\n        // On the creation of a new network, `currentBlock` will be smaller than `confirmationPeriodEnd`,\n        // `_renounceOwnershipStartedAt == 0` will indicate that a renounceOwnership call is happening for the first time\n        if (\n            currentBlock > confirmationPeriodEnd ||\n            _renounceOwnershipStartedAt == 0\n        ) {\n            _renounceOwnershipStartedAt = currentBlock;\n            delete _pendingOwner;\n            emit RenounceOwnershipStarted();\n            return;\n        }\n\n        if (currentBlock < confirmationPeriodStart) {\n            revert NotInRenounceOwnershipInterval(\n                confirmationPeriodStart,\n                confirmationPeriodEnd\n            );\n        }\n\n        _setOwner(address(0));\n        delete _renounceOwnershipStartedAt;\n        emit OwnershipRenounced();\n    }\n}"
    },
    {
      "filename": "contracts/LSP14Ownable2Step/LSP14Ownable2Step.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// interfaces\nimport {ILSP14Ownable2Step} from \"./ILSP14Ownable2Step.sol\";\n\n// modules\nimport {\n    OwnableUnset\n} from \"../../submodules/ERC725/implementations/contracts/custom/OwnableUnset.sol\";\n\n// libraries\nimport {LSP1Utils} from \"../LSP1UniversalReceiver/LSP1Utils.sol\";\n\n// errors\nimport \"./LSP14Errors.sol\";\n\n// constants\nimport {\n    _TYPEID_LSP14_OwnershipTransferStarted,\n    _TYPEID_LSP14_OwnershipTransferred_SenderNotification,\n    _TYPEID_LSP14_OwnershipTransferred_RecipientNotification\n} from \"./LSP14Constants.sol\";\n\n/**\n * @title LSP14Ownable2Step\n * @author Fabian Vogelsteller <fabian@lukso.network>, Jean Cavallera (CJ42), Yamen Merhi (YamenMerhi), Daniel Afteni (B00ste)\n * @dev This contract is a modified version of the OwnableUnset implementation, where transferring and renouncing ownership\n *      works as a 2 steps process. This can be used as a confirmation mechanism to prevent potential mistakes when\n *      transferring ownership of the contract, where the control of the contract could be lost forever.\n */\nabstract contract LSP14Ownable2Step is ILSP14Ownable2Step, OwnableUnset {\n    using LSP1Utils for address;\n\n    /**\n     * @dev The number of block that MUST pass before one is able to\n     *  confirm renouncing ownership\n     */\n    uint256 public constant RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY = 200;\n\n    /**\n     * @dev The number of blocks during which one can renounce ownership\n     */\n    uint256 public constant RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD = 200;\n\n    /**\n     * @dev The block number saved when initiating the process of renouncing ownerhsip\n     */\n    uint256 private _renounceOwnershipStartedAt;\n\n    /**\n     * @dev see `pendingOwner()`\n     */\n    address private _pendingOwner;\n\n    /**\n     * @inheritdoc ILSP14Ownable2Step\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @inheritdoc ILSP14Ownable2Step\n     */\n    function transferOwnership(\n        address newOwner\n    ) public virtual override(OwnableUnset, ILSP14Ownable2Step) onlyOwner {\n        _transferOwnership(newOwner);\n\n        address currentOwner = owner();\n        emit OwnershipTransferStarted(currentOwner, newOwner);\n\n        newOwner.tryNotifyUniversalReceiver(\n            _TYPEID_LSP14_OwnershipTransferStarted,\n            \"\"\n        );\n        require(\n            currentOwner == owner(),\n            \"LSP14: newOwner MUST accept ownership in a separate transaction\"\n        );\n    }\n\n    /**\n     * @inheritdoc ILSP14Ownable2Step\n     */\n    function acceptOwnership() public virtual {\n        address previousOwner = owner();\n\n        _acceptOwnership();\n\n        previousOwner.tryNotifyUniversalReceiver(\n            _TYPEID_LSP14_OwnershipTransferred_SenderNotification,\n            \"\"\n        );\n\n        msg.sender.tryNotifyUniversalReceiver(\n            _TYPEID_LSP14_OwnershipTransferred_RecipientNotification,\n            \"\"\n        );\n    }\n\n    /**\n     * @inheritdoc ILSP14Ownable2Step\n     */\n    function renounceOwnership()\n        public\n        virtual\n        override(OwnableUnset, ILSP14Ownable2Step)\n        onlyOwner\n    {\n        _renounceOwnership();\n    }\n\n    // --- Internal methods\n\n    /**\n     * @dev set the pending owner of the contract and cancel any renounce ownership\n     * process that was previously started.\n     *\n     * @param newOwner The address of the new pending owner.\n     *\n     * Requirements:\n     * - `newOwner` cannot be the address of the contract itself.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        if (newOwner == address(this)) revert CannotTransferOwnershipToSelf();\n\n        _pendingOwner = newOwner;\n        delete _renounceOwnershipStartedAt;\n    }\n\n    /**\n     * @dev set the pending owner of the contract as the new owner.\n     */\n    function _acceptOwnership() internal virtual {\n        require(\n            msg.sender == pendingOwner(),\n            \"LSP14: caller is not the pendingOwner\"\n        );\n\n        _setOwner(msg.sender);\n        delete _pendingOwner;\n    }\n\n    /**\n     * @dev initiate or confirm the process of renouncing ownership\n     * after a specific delay of blocks have passed.\n     */\n    function _renounceOwnership() internal virtual {\n        uint256 currentBlock = block.number;\n        uint256 confirmationPeriodStart = _renounceOwnershipStartedAt +\n            RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY;\n        uint256 confirmationPeriodEnd = confirmationPeriodStart +\n            RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD;\n\n        // On the creation of a new network, `currentBlock` will be smaller than `confirmationPeriodEnd`,\n        // `_renounceOwnershipStartedAt == 0` will indicate that a renounceOwnership call is happening for the first time\n        if (\n            currentBlock > confirmationPeriodEnd ||\n            _renounceOwnershipStartedAt == 0\n        ) {\n            _renounceOwnershipStartedAt = currentBlock;\n            delete _pendingOwner;\n            emit RenounceOwnershipStarted();\n            return;\n        }\n\n        if (currentBlock < confirmationPeriodStart) {\n            revert NotInRenounceOwnershipInterval(\n                confirmationPeriodStart,\n                confirmationPeriodEnd\n            );\n        }\n\n        _setOwner(address(0));\n        delete _renounceOwnershipStartedAt;\n        emit OwnershipRenounced();\n    }\n}"
    },
    {
      "filename": "contracts/LSP0ERC725Account/LSP0ERC725AccountCore.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\n// interfaces\nimport {IERC1271} from \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport {ILSP0ERC725Account} from \"./ILSP0ERC725Account.sol\";\nimport {\n    ILSP1UniversalReceiver\n} from \"../LSP1UniversalReceiver/ILSP1UniversalReceiver.sol\";\n\n// libraries\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {\n    ERC165Checker\n} from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {LSP1Utils} from \"../LSP1UniversalReceiver/LSP1Utils.sol\";\nimport {LSP2Utils} from \"../LSP2ERC725YJSONSchema/LSP2Utils.sol\";\n\n// modules\nimport {ERC725YCore} from \"../../submodules/ERC725/implementations/contracts/ERC725YCore.sol\";\nimport {ERC725XCore} from \"../../submodules/ERC725/implementations/contracts/ERC725XCore.sol\";\nimport {\n    OwnableUnset\n} from \"../../submodules/ERC725/implementations/contracts/custom/OwnableUnset.sol\";\nimport {LSP14Ownable2Step} from \"../LSP14Ownable2Step/LSP14Ownable2Step.sol\";\nimport {LSP17Extendable} from \"../LSP17ContractExtension/LSP17Extendable.sol\";\nimport {\n    LSP20CallVerification\n} from \"../LSP20CallVerification/LSP20CallVerification.sol\";\n\n// constants\nimport \"../../submodules/ERC725/implementations/contracts/constants.sol\";\nimport {\n    _INTERFACEID_LSP0,\n    _INTERFACEID_ERC1271,\n    _ERC1271_MAGICVALUE,\n    _ERC1271_FAILVALUE,\n    _TYPEID_LSP0_OwnershipTransferStarted,\n    _TYPEID_LSP0_OwnershipTransferred_SenderNotification,\n    _TYPEID_LSP0_OwnershipTransferred_RecipientNotification\n} from \"../LSP0ERC725Account/LSP0Constants.sol\";\nimport {\n    _INTERFACEID_LSP1,\n    _LSP1_UNIVERSAL_RECEIVER_DELEGATE_PREFIX,\n    _LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY\n} from \"../LSP1UniversalReceiver/LSP1Constants.sol\";\nimport {_INTERFACEID_LSP14} from \"../LSP14Ownable2Step/LSP14Constants.sol\";\n\nimport {\n    _LSP17_EXTENSION_PREFIX\n} from \"../LSP17ContractExtension/LSP17Constants.sol\";\nimport {\n    _INTERFACEID_LSP20_CALL_VERIFICATION\n} from \"../LSP20CallVerification/LSP20Constants.sol\";\n\n// errors\nimport {\n    ERC725Y_DataKeysValuesLengthMismatch\n} from \"../../submodules/ERC725/implementations/contracts/errors.sol\";\nimport {\n    NoExtensionFoundForFunctionSelector\n} from \"../LSP17ContractExtension/LSP17Errors.sol\";\n\n/**\n * @title The Core Implementation of LSP0-ERC725Account Standard\n *        https://github.com/lukso-network/LIPs/blob/main/LSPs/LSP-0-ERC725Account.md\n *\n * @author Fabian Vogelsteller <fabian@lukso.network>, Jean Cavallera (CJ42)\n * @dev A smart contract account including basic functionalities such as:\n * - Detecting supported standards using ERC165\n *   https://eips.ethereum.org/EIPS/eip-165\n *\n * - Executing several operation on other addresses including creating contracts using ERC725X\n *   https://github.com/ERC725Alliance/ERC725/blob/develop/docs/ERC-725.md\n *\n * - Storing data in a generic way using ERC725Y\n *   https://github.com/ERC725Alliance/ERC725/blob/develop/docs/ERC-725.md\n *\n * - Validating signatures using ERC1271\n *   https://eips.ethereum.org/EIPS/eip-1271\n *\n * - Receiving notification and react on them using LSP1\n *   https://github.com/lukso-network/LIPs/blob/main/LSPs/LSP-1-UniversalReceiver.md\n *\n * - Secure ownership management using LSP14\n *   https://github.com/lukso-network/LIPs/blob/main/LSPs/LSP-14-Ownable2Step.md\n *\n * - Extending the account with new functions and interfaceIds of future standards using LSP17\n *   https://github.com/lukso-network/LIPs/blob/main/LSPs/LSP-17-ContractExtension.md\n *\n * - Verifying calls on the owner to allow unified and standard interaction with the account using LSP20\n *   https://github.com/lukso-network/LIPs/blob/main/LSPs/LSP-20-CallVerification.md\n */\nabstract contract LSP0ERC725AccountCore is\n    ERC725XCore,\n    ERC725YCore,\n    IERC1271,\n    ILSP0ERC725Account,\n    ILSP1UniversalReceiver,\n    LSP14Ownable2Step,\n    LSP17Extendable,\n    LSP20CallVerification\n{\n    using ERC165Checker for address;\n    using LSP1Utils for address;\n    using Address for address;\n\n    /**\n     * @dev Executed:\n     * - when receiving some native tokens without any additional data.\n     * - on empty calls to the contract.\n     *\n     * @custom:events {ValueReceived} event when receiving native tokens.\n     */\n    receive() external payable virtual {\n        if (msg.value != 0) {\n            emit ValueReceived(msg.sender, msg.value);\n        }\n    }\n\n    // solhint-disable no-complex-fallback\n\n    /**\n     * @notice Achieves the goal of [LSP17-ContractExtension] standard by extending the contract to\n     * handle calls of functions that do not exist natively, forwarding the function call to the\n     * extension address mapped to the function being called.\n     *\n     * @dev This function is executed when:\n     *    - sending data of length less than 4 bytes to the contract.\n     *    - the first 4 bytes of the calldata do not match any publicly callable functions from the contract ABI.\n     *    - receiving native tokens with some calldata.\n     *\n     * 1. If the data is equal or longer than 4 bytes, the ERC725Y storage is queried with the following data key:\n     *   `[_LSP17_EXTENSION_PREFIX] + <bytes4 (msg.sig)>` (Check [LSP2-ERC725YJSONSchema] for encoding the data key)\n     *\n     *   - If there is no address stored under the following data key, revert with {NoExtensionFoundForFunctionSelector(bytes4)}\n     *     The data key relative to `bytes4(0)` is an exception, where no reverts occurs if there is no extension address stored under\n     *\n     *     This exception is made to allow users to send random data (graffiti) to the account and to be able to react on it.\n     *\n     *   - If there is an address, forward the `msg.data` to the extension using the CALL opcode,\n     *     appending 52 bytes (20 bytes of `msg.sender` and 32 bytes of `msg.value`).\n     *     Return what the calls returns, or revert if the call failed\n     *\n     * @custom:return if the data sent to this function is of length less than 4 bytes (not a function selector)\n     *\n     * @custom:events {ValueReceived} event when receiving native tokens.\n     */\n    fallback() external payable virtual {\n        if (msg.value != 0) {\n            emit ValueReceived(msg.sender, msg.value);\n        }\n\n        if (msg.data.length < 4) {\n            return;\n        }\n\n        _fallbackLSP17Extendable();\n    }\n\n    /**\n     * @dev Allows a caller to batch different function calls in one call.\n     * Perform a delegatecall on self, to call different functions with preserving the context\n     * It is not possible to send value along the functions call due to the use of delegatecall.\n     *\n     * @param data An array of ABI encoded function calls to be called on the contract.\n     * @return results An array of values returned by the executed functions.\n     */\n    function batchCalls(\n        bytes[] calldata data\n    ) public returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i; i < data.length; ) {\n            (bool success, bytes memory result) = address(this).delegatecall(\n                data[i]\n            );\n\n            if (!success) {\n                // Look for revert reason and bubble it up if present\n                if (result.length > 0) {\n                    // The easiest way to bubble the revert reason is using memory via assembly\n                    // solhint-disable no-inline-assembly\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        let returndata_size := mload(result)\n                        revert(add(32, result), returndata_size)\n                    }\n                } else {\n                    revert(\"LSP0: batchCalls reverted\");\n                }\n            }\n\n            results[i] = result;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Executes any call on other addresses.\n     *\n     * @param operationType The operation to execute: `CALL = 0`, `CREATE = 1` `CREATE2 = 2`, `STATICCALL = 3`, `DELEGATECALL = 4`.\n     * @param target The address (smart contract/EOA) to interact with, `target` will be unused if a contract is created (`CREATE` & `CREATE2`).\n     * @param value The amount of native tokens to transfer (in Wei).\n     * @param data The call data to execute on `target`, or the bytecode of the contract to deploy.\n     *\n     * @custom:requirements\n     * - if a `value` is provided, the contract MUST have at least this amount in its balance to execute successfully.\n     * - if the operation type is `STATICCALL` or `DELEGATECALL`, `value` SHOULD be 0.\n     * - `target` SHOULD be `address(0)` when deploying a contract.\n     * - MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to [LSP20-CallVerification] specification\n     *\n     * @custom:events\n     * - {Executed} event, when a call is executed under `operationType` 0, 3 and 4\n     * - {ContractCreated} event, when a contract is created under `operationType` 1 and 2\n     * - {ValueReceived} event when receiving native tokens.\n     */\n    function execute(\n        uint256 operationType,\n        address target,\n        uint256 value,\n        bytes memory data\n    ) public payable virtual override returns (bytes memory) {\n        if (msg.value != 0) {\n            emit ValueReceived(msg.sender, msg.value);\n        }\n\n        address _owner = owner();\n\n        // If the caller is the owner perform execute directly\n        if (msg.sender == _owner) {\n            return ERC725XCore._execute(operationType, target, value, data);\n        }\n\n        // If the caller is not the owner, call {lsp20VerifyCall} on the owner\n        // Depending on the magicValue returned, a second call is done after execution\n        bool verifyAfter = LSP20CallVerification._verifyCall(_owner);\n\n        // Perform the execution\n        bytes memory result = ERC725XCore._execute(\n            operationType,\n            target,\n            value,\n            data\n        );\n\n        // if verifyAfter is true, Call {lsp20VerifyCallResult} on the owner\n        if (verifyAfter) {\n            LSP20CallVerification._verifyCallResult(_owner, abi.encode(result));\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Generic batch executor function that executes any call on other addresses\n     *\n     * @param operationsType The list of operations type used: `CALL = 0`, `CREATE = 1`, `CREATE2 = 2`, `STATICCALL = 3`, `DELEGATECALL = 4`.\n     * @param targets The list of addresses to call. `targets` will be unused if a contract is created (`CREATE` & `CREATE2`).\n     * @param values The list of native token amounts to transfer (in Wei).\n     * @param datas The list of call data to execute on `targets`, or the creation bytecode of the contracts to deploy.\n     *\n     * @custom:requirements\n     * - The length of the parameters provided MUST be equal\n     * - if a `value` is provided, the contract MUST have at least this amount in its balance to execute successfully.\n     * - if the operation type is `STATICCALL` or `DELEGATECALL`, `value` SHOULD be 0.\n     * - `target` SHOULD be `address(0)` when deploying a contract.\n     * - MUST pass when called by the owner or by an authorised address that pass the verification check performed\n     * on the owner accordinng to [LSP20-CallVerification] specification\n     *\n     * @custom:events\n     * - {Executed} event, when a call is executed under `operationType` 0, 3 and 4 (each iteration)\n     * - {ContractCreated} event, when a contract is created under `operationType` 1 and 2 (each iteration)\n     * - {ValueReceived} event when receiving native tokens.\n     */\n    function executeBatch(\n        uint256[] memory operationsType,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory datas\n    ) public payable virtual override returns (bytes[] memory) {\n        if (msg.value != 0) {\n            emit ValueReceived(msg.sender, msg.value);\n        }\n\n        address _owner = owner();\n\n        // If the caller is the owner perform execute directly\n        if (msg.sender == _owner) {\n            return\n                ERC725XCore._executeBatch(\n                    operationsType,\n                    targets,\n                    values,\n                    datas\n                );\n        }\n\n        // If the caller is not the owner, call {lsp20VerifyCall} on the owner\n        // Depending on the magicValue returned, a second call is done after execution\n        bool verifyAfter = LSP20CallVerification._verifyCall(_owner);\n\n        // Perform the execution\n        bytes[] memory results = ERC725XCore._executeBatch(\n            operationsType,\n            targets,\n            values,\n            datas\n        );\n\n        // if verifyAfter is true, Call {lsp20VerifyCallResult} on the owner\n        if (verifyAfter) {\n            LSP20CallVerification._verifyCallResult(\n                _owner,\n                abi.encode(results)\n            );\n        }\n\n        return results;\n    }\n\n    /**\n     * @dev Sets singular data for a given `dataKey`\n     *\n     * @param dataKey The key to retrieve stored value\n     * @param dataValue The value to set\n     *\n     * @custom:requirements\n     * - MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to [LSP20-CallVerification] specification\n     *\n     * @custom:events\n     * - {ValueReceived} event when receiving native tokens.\n     * - {DataChanged} event.\n     */\n    function setData(\n        bytes32 dataKey,\n        bytes memory dataValue\n    ) public payable virtual override {\n        if (msg.value != 0) {\n            emit ValueReceived(msg.sender, msg.value);\n        }\n\n        address _owner = owner();\n\n        // If the caller is the owner perform setData directly\n        if (msg.sender == _owner) {\n            return _setData(dataKey, dataValue);\n        }\n\n        // If the caller is not the owner, call {lsp20VerifyCall} on the owner\n        // Depending on the magicValue returned, a second call is done after setting data\n        bool verifyAfter = _verifyCall(_owner);\n\n        _setData(dataKey, dataValue);\n\n        // If verifyAfter is true, Call {lsp20VerifyCallResult} on the owner\n        // The setData function does not return, second parameter of {_verifyCallResult} will be empty\n        if (verifyAfter) {\n            _verifyCallResult(_owner, \"\");\n        }\n    }\n\n    /**\n     * @dev Sets array of data for multiple given `dataKeys`\n     *\n     * @param dataKeys The array of data keys for values to set\n     * @param dataValues The array of values to set\n     *\n     * @custom:requirements\n     * - MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to [LSP20-CallVerification] specification\n     *\n     * @custom:events\n     * - {ValueReceived} event when receiving native tokens.\n     * - {DataChanged} event. (on each iteration of setting data)\n     */\n    function setDataBatch(\n        bytes32[] memory dataKeys,\n        bytes[] memory dataValues\n    ) public payable virtual override {\n        if (msg.value != 0) {\n            emit ValueReceived(msg.sender, msg.value);\n        }\n\n        if (dataKeys.length != dataValues.length) {\n            revert ERC725Y_DataKeysValuesLengthMismatch();\n        }\n\n        address _owner = owner();\n\n        // If the caller is the owner perform setData directly\n        if (msg.sender == _owner) {\n            for (uint256 i = 0; i < dataKeys.length; ) {\n                _setData(dataKeys[i], dataValues[i]);\n\n                unchecked {\n                    ++i;\n                }\n            }\n\n            return;\n        }\n\n        // If the caller is not the owner, call {lsp20VerifyCall} on the owner\n        // Depending on the magicValue returned, a second call is done after setting data\n        bool verifyAfter = _verifyCall(_owner);\n\n        for (uint256 i = 0; i < dataKeys.length; ) {\n            _setData(dataKeys[i], dataValues[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // If verifyAfter is true, Call {lsp20VerifyCallResult} on the owner\n        // The setData function does not return, second parameter of {_verifyCallResult} will be empty\n        if (verifyAfter) {\n            _verifyCallResult(_owner, \"\");\n        }\n    }\n\n    /**\n     * @notice Achieves the goal of [LSP1-UniversalReceiver] by allowing the account to be notified about incoming/outgoing\n     * transactions and enabling reactions to these actions.\n     *\n     * The reaction is achieved by having two external contracts (UniversalReceiverDelegates) that react on the whole transaction\n     * and on the specific typeId, respectively.\n     *\n     * The notification is achieved by emitting a {UniversalReceiver} event on the call with the function parameters, call options, and the\n     * response of the UniversalReceiverDelegates (URD) contract.\n     *\n     * @dev The function performs the following steps:\n     *\n     * 1. Query the ERC725Y storage with the data key `[_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY]`.\n     *      - If there is an address stored under the data key, check if this address supports the LSP1 interfaceId.\n     *\n     *      - If yes, call this address with the typeId and data (params), along with additional calldata consisting of 20 bytes of `msg.sender` and 32 bytes of `msg.value`. If not, continue the execution of the function.\n     *\n     *\n     * 2. Query the ERC725Y storage with the data key `[_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY] + <bytes32 typeId>`.\n     *   (Check [LSP2-ERC725YJSONSchema] for encoding the data key)\n     *\n     *      - If there is an address stored under the data key, check if this address supports the LSP1 interfaceId.\n     *\n     *      - If yes, call this address with the typeId and data (params), along with additional calldata consisting of 20 bytes of `msg.sender` and 32 bytes of `msg.value`. If not, continue the execution of the function.\n     *\n     * @param typeId The type of call received.\n     * @param receivedData The data received.\n     *\n     * @return returnedValues The ABI encoded return value of the LSP1UniversalReceiverDelegate call and the LSP1TypeIdDelegate call.\n     *\n     * @custom:events\n     * - {ValueReceived} when receiving native tokens.\n     * - {UniversalReceiver} event.\n     */\n    function universalReceiver(\n        bytes32 typeId,\n        bytes calldata receivedData\n    ) public payable virtual returns (bytes memory returnedValues) {\n        if (msg.value != 0) {\n            emit ValueReceived(msg.sender, msg.value);\n        }\n\n        // Query the ERC725Y storage with the data key {_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY}\n        bytes memory lsp1DelegateValue = _getData(\n            _LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY\n        );\n        bytes memory resultDefaultDelegate;\n\n        if (lsp1DelegateValue.length >= 20) {\n            address universalReceiverDelegate = address(\n                bytes20(lsp1DelegateValue)\n            );\n\n            // Checking LSP1 InterfaceId support\n            if (\n                universalReceiverDelegate.supportsERC165InterfaceUnchecked(\n                    _INTERFACEID_LSP1\n                )\n            ) {\n                // calling {universalReceiver} function on URD appending the caller and the value sent\n                resultDefaultDelegate = universalReceiverDelegate\n                    .callUniversalReceiverWithCallerInfos(\n                        typeId,\n                        receivedData,\n                        msg.sender,\n                        msg.value\n                    );\n            }\n        }\n\n        // Generate the data key {_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY + <bytes32 typeId>}\n        bytes32 lsp1typeIdDelegateKey = LSP2Utils.generateMappingKey(\n            _LSP1_UNIVERSAL_RECEIVER_DELEGATE_PREFIX,\n            bytes20(typeId)\n        );\n\n        // Query the ERC725Y storage with the data key {_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY + <bytes32 typeId>}\n        bytes memory lsp1TypeIdDelegateValue = _getData(lsp1typeIdDelegateKey);\n        bytes memory resultTypeIdDelegate;\n\n        if (lsp1TypeIdDelegateValue.length >= 20) {\n            address universalReceiverDelegate = address(\n                bytes20(lsp1TypeIdDelegateValue)\n            );\n\n            // Checking LSP1 InterfaceId support\n            if (\n                universalReceiverDelegate.supportsERC165InterfaceUnchecked(\n                    _INTERFACEID_LSP1\n                )\n            ) {\n                // calling {universalReceiver} function on URD appending the caller and the value sent\n                resultTypeIdDelegate = universalReceiverDelegate\n                    .callUniversalReceiverWithCallerInfos(\n                        typeId,\n                        receivedData,\n                        msg.sender,\n                        msg.value\n                    );\n            }\n        }\n\n        returnedValues = abi.encode(\n            resultDefaultDelegate,\n            resultTypeIdDelegate\n        );\n        emit UniversalReceiver(\n            msg.sender,\n            msg.value,\n            typeId,\n            receivedData,\n            returnedValues\n        );\n    }\n\n    /**\n     * @notice Achieves the goal of LSP14Ownable2Step b"
    }
  ]
}