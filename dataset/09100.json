{
  "Title": "[G-11] `internal` functions not called by the contract should be removed to save deployment gas",
  "Content": "\nIf the functions are required by an interface, the contract should inherit from that interface and use the `override` keyword\n\n*There are 2 instances of this issue:*\n\n```solidity\nFile: smart-contracts/GeneralVault.sol   #1\n\n204:    function _getAssetYields(uint256 _WETHAmount) internal view returns (AssetYield[] memory) {\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L204>\n\n```solidity\nFile: smart-contracts/GeneralVault.sol   #2\n\n235:    function _depositYield(address _asset, uint256 _amount) internal {\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L235>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-05-sturdy-contest",
  "Code": [
    {
      "filename": "smart-contracts/GeneralVault.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol';\nimport {PercentageMath} from '../libraries/math/PercentageMath.sol';\nimport {Errors} from '../libraries/helpers/Errors.sol';\nimport {VersionedInitializable} from '../../protocol/libraries/sturdy-upgradeability/VersionedInitializable.sol';\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IERC20Detailed} from '../../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\n\n/**\n * @title GeneralVault\n * @notice Basic feature of vault\n * @author Sturdy\n **/\n\ncontract GeneralVault is VersionedInitializable {\n  using SafeMath for uint256;\n  using PercentageMath for uint256;\n\n  event ProcessYield(address indexed collateralAsset, uint256 yieldAmount);\n  event DepositCollateral(address indexed collateralAsset, address indexed from, uint256 amount);\n  event WithdrawCollateral(address indexed collateralAsset, address indexed to, uint256 amount);\n  event SetTreasuryInfo(address indexed treasuryAddress, uint256 fee);\n\n  modifier onlyAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  modifier onlyYieldProcessor() {\n    require(\n      _addressesProvider.getAddress('YIELD_PROCESSOR') == msg.sender,\n      Errors.CALLER_NOT_POOL_ADMIN\n    );\n    _;\n  }\n\n  struct AssetYield {\n    address asset;\n    uint256 amount;\n  }\n\n  address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n  ILendingPoolAddressesProvider internal _addressesProvider;\n\n  // vault fee 20%\n  uint256 internal _vaultFee;\n  address internal _treasuryAddress;\n\n  uint256 public constant VAULT_REVISION = 0x1;\n\n  /**\n   * @dev Function is invoked by the proxy contract when the Vault contract is deployed.\n   * @param _provider The address of the provider\n   **/\n  function initialize(ILendingPoolAddressesProvider _provider) public initializer {\n    _addressesProvider = _provider;\n  }\n\n  function getRevision() internal pure override returns (uint256) {\n    return VAULT_REVISION;\n  }\n\n  /**\n   * @dev Deposits an `amount` of asset as collateral to borrow other asset.\n   * @param _asset The asset address for collateral\n   *  _asset = 0x0000000000000000000000000000000000000000 means to use ETH as collateral\n   * @param _amount The deposit amount\n   */\n  function depositCollateral(address _asset, uint256 _amount) external payable virtual {\n    // Deposit asset to vault and receive stAsset\n    // Ex: if user deposit 100ETH, this will deposit 100ETH to Lido and receive 100stETH TODO No Lido\n    (address _stAsset, uint256 _stAssetAmount) = _depositToYieldPool(_asset, _amount);\n\n    // Deposit stAsset to lendingPool, then user will get aToken of stAsset\n    ILendingPool(_addressesProvider.getLendingPool()).deposit(\n      _stAsset,\n      _stAssetAmount,\n      msg.sender,\n      0\n    );\n\n    emit DepositCollateral(_asset, msg.sender, _amount);\n  }\n\n  /**\n   * @dev Withdraw an `amount` of asset used as collateral to user.\n   * @param _asset The asset address for collateral\n   *  _asset = 0x0000000000000000000000000000000000000000 means to use ETH as collateral\n   * @param _amount The amount to be withdrawn\n   * @param _to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   */\n  function withdrawCollateral(\n    address _asset,\n    uint256 _amount,\n    address _to\n  ) external virtual {\n    // Before withdraw from lending pool, get the stAsset address and withdrawal amount\n    // Ex: In Lido vault, it will return stETH address and same amount\n    (address _stAsset, uint256 _stAssetAmount) = _getWithdrawalAmount(_asset, _amount);\n\n    // withdraw from lendingPool, it will convert user's aToken to stAsset\n    uint256 _amountToWithdraw = ILendingPool(_addressesProvider.getLendingPool()).withdrawFrom(\n      _stAsset,\n      _stAssetAmount,\n      msg.sender,\n      address(this)\n    );\n\n    // Withdraw from vault, it will convert stAsset to asset and send to user\n    // Ex: In Lido vault, it will return ETH or stETH to user\n    uint256 withdrawAmount = _withdrawFromYieldPool(_asset, _amountToWithdraw, _to);\n\n    if (_amount == type(uint256).max) {\n      uint256 decimal = IERC20Detailed(_asset).decimals();\n      _amount = _amountToWithdraw.mul(this.pricePerShare()).div(10**decimal);\n    }\n    require(withdrawAmount >= _amount.percentMul(99_00), Errors.VT_WITHDRAW_AMOUNT_MISMATCH);\n\n    emit WithdrawCollateral(_asset, _to, _amount);\n  }\n\n  /**\n   * @dev Withdraw an `amount` of asset used as collateral to user on liquidation.\n   * @param _asset The asset address for collateral\n   *  _asset = 0x0000000000000000000000000000000000000000 means to use ETH as collateral\n   * @param _amount The amount to be withdrawn\n   */\n  function withdrawOnLiquidation(address _asset, uint256 _amount)\n    external\n    virtual\n    returns (uint256)\n  {\n    return _amount;\n  }\n\n  // /**\n  //  * @dev Convert an `amount` of asset used as collateral to swappable asset on liquidation.\n  //  * @param _amountIn The amount of collateral asset\n  //  */\n  // function convertOnLiquidation(address _assetOut, uint256 _amountIn) external virtual {}\n\n  /**\n   * @dev Get yield based on strategy and re-deposit\n   */\n  function processYield() external virtual {}\n\n  /**\n   * @dev Get price per share based on yield strategy\n   */\n  function pricePerShare() external view virtual returns (uint256) {}\n\n  /**\n   * @dev Set treasury address and vault fee\n   * @param _treasury The treasury address\n   * @param _fee The vault fee which has more two decimals, ex: 100% = 100_00\n   */\n  function setTreasuryInfo(address _treasury, uint256 _fee) external onlyAdmin {\n    require(_treasury != address(0), Errors.VT_TREASURY_INVALID);\n    require(_fee <= 30_00, Errors.VT_FEE_TOO_BIG);\n    _treasuryAddress = _treasury;\n    _vaultFee = _fee;\n\n    emit SetTreasuryInfo(_treasury, _fee);\n  }\n\n  /**\n   * @dev Get yield based on strategy and re-deposit\n   */\n  function _getYield(address _stAsset) internal returns (uint256) {\n    uint256 yieldStAsset = _getYieldAmount(_stAsset);\n    require(yieldStAsset > 0, Errors.VT_PROCESS_YIELD_INVALID);\n\n    ILendingPool(_addressesProvider.getLendingPool()).getYield(_stAsset, yieldStAsset);\n    return yieldStAsset;\n  }\n\n  /**\n   * @dev Get yield amount based on strategy\n   */\n  function _getYieldAmount(address _stAsset) internal view returns (uint256) {\n    (uint256 stAssetBalance, uint256 aTokenBalance) = ILendingPool(\n      _addressesProvider.getLendingPool()\n    ).getTotalBalanceOfAssetPair(_stAsset);\n\n    // when deposit for collateral, stAssetBalance = aTokenBalance\n    // But stAssetBalance should increase overtime, so vault can grab yield from lendingPool.\n    // yield = stAssetBalance - aTokenBalance\n    if (stAssetBalance >= aTokenBalance) return stAssetBalance.sub(aTokenBalance);\n\n    return 0;\n  }\n\n  /**\n   * @dev Get the list of asset and asset's yield amount\n   **/\n  function _getAssetYields(uint256 _WETHAmount) internal view returns (AssetYield[] memory) {\n    // Get total borrowing asset volume and volumes and assets\n    (\n      uint256 totalVolume,\n      uint256[] memory volumes,\n      address[] memory assets,\n      uint256 length\n    ) = ILendingPool(_addressesProvider.getLendingPool()).getBorrowingAssetAndVolumes();\n\n    if (totalVolume == 0) return new AssetYield[](0);\n\n    AssetYield[] memory assetYields = new AssetYield[](length);\n    uint256 extraWETHAmount = _WETHAmount;\n\n    for (uint256 i = 0; i < length; i++) {\n      assetYields[i].asset = assets[i];\n      if (i != length - 1) {\n        // Distribute wethAmount based on percent of asset volume\n        assetYields[i].amount = _WETHAmount.percentMul(\n          volumes[i].mul(PercentageMath.PERCENTAGE_FACTOR).div(totalVolume)\n        );\n        extraWETHAmount = extraWETHAmount.sub(assetYields[i].amount);\n      } else {\n        // without calculation, set remained extra amount\n        assetYields[i].amount = extraWETHAmount;\n      }\n    }\n\n    return assetYields;\n  }\n\n  function _depositYield(address _asset, uint256 _amount) internal {\n    ILendingPool(_addressesProvider.getLendingPool()).depositYield(_asset, _amount);\n  }\n\n  /**\n   * @dev Deposit to yield pool based on strategy and receive stAsset\n   */\n  function _depositToYieldPool(address _asset, uint256 _amount)\n    internal\n    virtual\n    returns (address, uint256)\n  {}\n\n  /**\n   * @dev Withdraw from yield pool based on strategy with stAsset and deliver asset\n   */\n  function _withdrawFromYieldPool(\n    address _asset,\n    uint256 _amount,\n    address _to\n  ) internal virtual returns (uint256) {}\n\n  /**\n   * @dev Get Withdrawal amount of stAsset based on strategy\n   */\n  function _getWithdrawalAmount(address _asset, uint256 _amount)\n    internal\n    view\n    virtual\n    returns (address, uint256)\n  {}\n}"
    },
    {
      "filename": "smart-contracts/GeneralVault.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol';\nimport {PercentageMath} from '../libraries/math/PercentageMath.sol';\nimport {Errors} from '../libraries/helpers/Errors.sol';\nimport {VersionedInitializable} from '../../protocol/libraries/sturdy-upgradeability/VersionedInitializable.sol';\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IERC20Detailed} from '../../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\n\n/**\n * @title GeneralVault\n * @notice Basic feature of vault\n * @author Sturdy\n **/\n\ncontract GeneralVault is VersionedInitializable {\n  using SafeMath for uint256;\n  using PercentageMath for uint256;\n\n  event ProcessYield(address indexed collateralAsset, uint256 yieldAmount);\n  event DepositCollateral(address indexed collateralAsset, address indexed from, uint256 amount);\n  event WithdrawCollateral(address indexed collateralAsset, address indexed to, uint256 amount);\n  event SetTreasuryInfo(address indexed treasuryAddress, uint256 fee);\n\n  modifier onlyAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  modifier onlyYieldProcessor() {\n    require(\n      _addressesProvider.getAddress('YIELD_PROCESSOR') == msg.sender,\n      Errors.CALLER_NOT_POOL_ADMIN\n    );\n    _;\n  }\n\n  struct AssetYield {\n    address asset;\n    uint256 amount;\n  }\n\n  address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n  ILendingPoolAddressesProvider internal _addressesProvider;\n\n  // vault fee 20%\n  uint256 internal _vaultFee;\n  address internal _treasuryAddress;\n\n  uint256 public constant VAULT_REVISION = 0x1;\n\n  /**\n   * @dev Function is invoked by the proxy contract when the Vault contract is deployed.\n   * @param _provider The address of the provider\n   **/\n  function initialize(ILendingPoolAddressesProvider _provider) public initializer {\n    _addressesProvider = _provider;\n  }\n\n  function getRevision() internal pure override returns (uint256) {\n    return VAULT_REVISION;\n  }\n\n  /**\n   * @dev Deposits an `amount` of asset as collateral to borrow other asset.\n   * @param _asset The asset address for collateral\n   *  _asset = 0x0000000000000000000000000000000000000000 means to use ETH as collateral\n   * @param _amount The deposit amount\n   */\n  function depositCollateral(address _asset, uint256 _amount) external payable virtual {\n    // Deposit asset to vault and receive stAsset\n    // Ex: if user deposit 100ETH, this will deposit 100ETH to Lido and receive 100stETH TODO No Lido\n    (address _stAsset, uint256 _stAssetAmount) = _depositToYieldPool(_asset, _amount);\n\n    // Deposit stAsset to lendingPool, then user will get aToken of stAsset\n    ILendingPool(_addressesProvider.getLendingPool()).deposit(\n      _stAsset,\n      _stAssetAmount,\n      msg.sender,\n      0\n    );\n\n    emit DepositCollateral(_asset, msg.sender, _amount);\n  }\n\n  /**\n   * @dev Withdraw an `amount` of asset used as collateral to user.\n   * @param _asset The asset address for collateral\n   *  _asset = 0x0000000000000000000000000000000000000000 means to use ETH as collateral\n   * @param _amount The amount to be withdrawn\n   * @param _to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   */\n  function withdrawCollateral(\n    address _asset,\n    uint256 _amount,\n    address _to\n  ) external virtual {\n    // Before withdraw from lending pool, get the stAsset address and withdrawal amount\n    // Ex: In Lido vault, it will return stETH address and same amount\n    (address _stAsset, uint256 _stAssetAmount) = _getWithdrawalAmount(_asset, _amount);\n\n    // withdraw from lendingPool, it will convert user's aToken to stAsset\n    uint256 _amountToWithdraw = ILendingPool(_addressesProvider.getLendingPool()).withdrawFrom(\n      _stAsset,\n      _stAssetAmount,\n      msg.sender,\n      address(this)\n    );\n\n    // Withdraw from vault, it will convert stAsset to asset and send to user\n    // Ex: In Lido vault, it will return ETH or stETH to user\n    uint256 withdrawAmount = _withdrawFromYieldPool(_asset, _amountToWithdraw, _to);\n\n    if (_amount == type(uint256).max) {\n      uint256 decimal = IERC20Detailed(_asset).decimals();\n      _amount = _amountToWithdraw.mul(this.pricePerShare()).div(10**decimal);\n    }\n    require(withdrawAmount >= _amount.percentMul(99_00), Errors.VT_WITHDRAW_AMOUNT_MISMATCH);\n\n    emit WithdrawCollateral(_asset, _to, _amount);\n  }\n\n  /**\n   * @dev Withdraw an `amount` of asset used as collateral to user on liquidation.\n   * @param _asset The asset address for collateral\n   *  _asset = 0x0000000000000000000000000000000000000000 means to use ETH as collateral\n   * @param _amount The amount to be withdrawn\n   */\n  function withdrawOnLiquidation(address _asset, uint256 _amount)\n    external\n    virtual\n    returns (uint256)\n  {\n    return _amount;\n  }\n\n  // /**\n  //  * @dev Convert an `amount` of asset used as collateral to swappable asset on liquidation.\n  //  * @param _amountIn The amount of collateral asset\n  //  */\n  // function convertOnLiquidation(address _assetOut, uint256 _amountIn) external virtual {}\n\n  /**\n   * @dev Get yield based on strategy and re-deposit\n   */\n  function processYield() external virtual {}\n\n  /**\n   * @dev Get price per share based on yield strategy\n   */\n  function pricePerShare() external view virtual returns (uint256) {}\n\n  /**\n   * @dev Set treasury address and vault fee\n   * @param _treasury The treasury address\n   * @param _fee The vault fee which has more two decimals, ex: 100% = 100_00\n   */\n  function setTreasuryInfo(address _treasury, uint256 _fee) external onlyAdmin {\n    require(_treasury != address(0), Errors.VT_TREASURY_INVALID);\n    require(_fee <= 30_00, Errors.VT_FEE_TOO_BIG);\n    _treasuryAddress = _treasury;\n    _vaultFee = _fee;\n\n    emit SetTreasuryInfo(_treasury, _fee);\n  }\n\n  /**\n   * @dev Get yield based on strategy and re-deposit\n   */\n  function _getYield(address _stAsset) internal returns (uint256) {\n    uint256 yieldStAsset = _getYieldAmount(_stAsset);\n    require(yieldStAsset > 0, Errors.VT_PROCESS_YIELD_INVALID);\n\n    ILendingPool(_addressesProvider.getLendingPool()).getYield(_stAsset, yieldStAsset);\n    return yieldStAsset;\n  }\n\n  /**\n   * @dev Get yield amount based on strategy\n   */\n  function _getYieldAmount(address _stAsset) internal view returns (uint256) {\n    (uint256 stAssetBalance, uint256 aTokenBalance) = ILendingPool(\n      _addressesProvider.getLendingPool()\n    ).getTotalBalanceOfAssetPair(_stAsset);\n\n    // when deposit for collateral, stAssetBalance = aTokenBalance\n    // But stAssetBalance should increase overtime, so vault can grab yield from lendingPool.\n    // yield = stAssetBalance - aTokenBalance\n    if (stAssetBalance >= aTokenBalance) return stAssetBalance.sub(aTokenBalance);\n\n    return 0;\n  }\n\n  /**\n   * @dev Get the list of asset and asset's yield amount\n   **/\n  function _getAssetYields(uint256 _WETHAmount) internal view returns (AssetYield[] memory) {\n    // Get total borrowing asset volume and volumes and assets\n    (\n      uint256 totalVolume,\n      uint256[] memory volumes,\n      address[] memory assets,\n      uint256 length\n    ) = ILendingPool(_addressesProvider.getLendingPool()).getBorrowingAssetAndVolumes();\n\n    if (totalVolume == 0) return new AssetYield[](0);\n\n    AssetYield[] memory assetYields = new AssetYield[](length);\n    uint256 extraWETHAmount = _WETHAmount;\n\n    for (uint256 i = 0; i < length; i++) {\n      assetYields[i].asset = assets[i];\n      if (i != length - 1) {\n        // Distribute wethAmount based on percent of asset volume\n        assetYields[i].amount = _WETHAmount.percentMul(\n          volumes[i].mul(PercentageMath.PERCENTAGE_FACTOR).div(totalVolume)\n        );\n        extraWETHAmount = extraWETHAmount.sub(assetYields[i].amount);\n      } else {\n        // without calculation, set remained extra amount\n        assetYields[i].amount = extraWETHAmount;\n      }\n    }\n\n    return assetYields;\n  }\n\n  function _depositYield(address _asset, uint256 _amount) internal {\n    ILendingPool(_addressesProvider.getLendingPool()).depositYield(_asset, _amount);\n  }\n\n  /**\n   * @dev Deposit to yield pool based on strategy and receive stAsset\n   */\n  function _depositToYieldPool(address _asset, uint256 _amount)\n    internal\n    virtual\n    returns (address, uint256)\n  {}\n\n  /**\n   * @dev Withdraw from yield pool based on strategy with stAsset and deliver asset\n   */\n  function _withdrawFromYieldPool(\n    address _asset,\n    uint256 _amount,\n    address _to\n  ) internal virtual returns (uint256) {}\n\n  /**\n   * @dev Get Withdrawal amount of stAsset based on strategy\n   */\n  function _getWithdrawalAmount(address _asset, uint256 _amount)\n    internal\n    view\n    virtual\n    returns (address, uint256)\n  {}\n}"
    }
  ]
}