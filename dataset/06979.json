{
  "Title": "[M-01] `KUMABondToken.approve()` should revert if the owner of the tokenId is blacklisted",
  "Content": "\nIt is still possible for a blacklisted user's bond token to be approved.\n\n### Proof of Concept\n\n[KUMABondToken.approve()](https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/mcag-contracts/KUMABondToken.sol#L143) only checks if `msg.sender` and `to` are not blacklisted. It doesn't check if the owner of the `tokenId` is not blacklisted.\n\nFor example, the following scenario allows a blacklisted user's bond token to be approved:\n\n1.  User A have a bond token bt1.\n2.  User A calls `KUMABondToken.setApprovalForAll(B, true)`, and user B can operate on all user A's bond tokens.\n3.  User A is blacklisted.\n4.  User B calls `KUMABondToken.approve(C, bt1)` to approve user C to operate on bond token bt1.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\n`KUMABondToken.approve()` should revert if the owner of the tokenId is blacklisted:\n\n```\ndiff --git a/src/mcag-contracts/KUMABondToken.sol b/src/mcag-contracts/KUMABondToken.sol\nindex 569a042..906fe7b 100644\n--- a/src/mcag-contracts/KUMABondToken.sol\n+++ b/src/mcag-contracts/KUMABondToken.sol\n@@ -146,6 +146,7 @@ contract KUMABondToken is ERC721, Pausable, IKUMABondToken {\n         whenNotPaused\n         notBlacklisted(to)\n         notBlacklisted(msg.sender)\n+        notBlacklisted(ERC721.ownerOf(tokenId))\n     {\n         address owner = ERC721.ownerOf(tokenId);\n\n```\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-02-kuma-findings/issues/22#issuecomment-1445451817):**\n > The Warden has shown an inconsistency in implementation for the blacklist functionality.\n> \n> Because a transfer would still be broken, due to `transferFrom` performing a check on all accounts involved, I agree with Medium Severity.\n\n**[m19 (KUMA) confirmed and commented](https://github.com/code-423n4/2023-02-kuma-findings/issues/22#issuecomment-1447505962):**\n > We confirmed this issue in a test and intend to fix it:\n> \n> ```\n>     function test_approve_RevertWhen_TokenOwnerBlacklistedAndApproveCalledByOperator() external {\n>         _kumaBondToken.issueBond(_alice, _bond);\n>         vm.prank(_alice);\n>         _kumaBondToken.setApprovalForAll(address(this), true);\n>         _blacklist.blacklist(_alice);\n>         vm.expectRevert(abi.encodeWithSelector(Errors.BLACKLIST_ACCOUNT_IS_BLACKLISTED.selector, _alice));\n>         _kumaBondToken.approve(_bob, 1);\n>     }\n> ```\n\n**[m19 (KUMA) mitigated](https://github.com/code-423n4/2023-02-kuma-findings/issues/3#issuecomment-1447507612):**\n > https://github.com/code-423n4/2023-02-kuma/pull/4 \n>\n **Status:** Mitigation confirmed by [0xsomeone](https://github.com/code-423n4/2023-03-kuma-mitigation-contest-findings/issues/19), [0x52](https://github.com/code-423n4/2023-03-kuma-mitigation-contest-findings/issues/12), and [hihen](https://github.com/code-423n4/2023-03-kuma-mitigation-contest-findings/issues/2).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-02-kuma",
  "Code": [
    {
      "filename": "src/mcag-contracts/KUMABondToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport {IBlacklist} from \"./interfaces/IBlacklist.sol\";\nimport {Counters} from \"@openzeppelin/contracts/utils/Counters.sol\";\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {Errors} from \"./libraries/Errors.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {IKUMABondToken} from \"./interfaces/IKUMABondToken.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {Roles} from \"./libraries/Roles.sol\";\n\ncontract KUMABondToken is ERC721, Pausable, IKUMABondToken {\n    using Counters for Counters.Counter;\n\n    IAccessControl public immutable override accessController;\n    IBlacklist public immutable override blacklist;\n\n    Counters.Counter private _tokenIdCounter;\n    string private _uri;\n\n    mapping(uint256 => Bond) private _bonds;\n\n    modifier onlyRole(bytes32 role) {\n        if (!accessController.hasRole(role, msg.sender)) {\n            revert Errors.ACCESS_CONTROL_ACCOUNT_IS_MISSING_ROLE(msg.sender, role);\n        }\n        _;\n    }\n\n    /**\n     * @dev Throws if argument account is blacklisted\n     * @param account The address to check\n     */\n    modifier notBlacklisted(address account) {\n        if (blacklist.isBlacklisted(account)) {\n            revert Errors.BLACKLIST_ACCOUNT_IS_BLACKLISTED(account);\n        }\n        _;\n    }\n\n    constructor(IAccessControl _accessController, IBlacklist _blacklist) ERC721(\"KUMA Bonds\", \"KUMA\") {\n        if (address(_accessController) == address(0) || address(_blacklist) == address(0)) {\n            revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n        }\n        accessController = _accessController;\n        blacklist = _blacklist;\n\n        emit AccessControllerSet(address(_accessController));\n        emit BlacklistSet(address(_blacklist));\n    }\n\n    /**\n     * @notice Mints a bond NFT to the specified address.\n     * @dev Can only be called under specific conditions :\n     *      - Caller must have MINT_ROLE\n     *      - Receiver must not be blacklisted\n     *      - Contract must not be paused\n     * @param to Bond NFT receiver.\n     * @param bond Bond struct storing metadata.\n     */\n    function issueBond(address to, Bond calldata bond)\n        external\n        override\n        onlyRole(Roles.MCAG_MINT_ROLE)\n        notBlacklisted(to)\n        whenNotPaused\n    {\n        _tokenIdCounter.increment();\n        uint256 tokenId = _tokenIdCounter.current();\n        _bonds[tokenId] = bond;\n        _safeMint(to, tokenId);\n        emit BondIssued(tokenId, bond);\n    }\n\n    /**\n     * @notice Burns a bond NFT.\n     * @dev Can only be called under specific conditions :\n     *      - Caller must have BURN_ROLE\n     *      - Contract must not be paused\n     *      - Caller must be the owner of the bond\n     * @param tokenId bond Id.\n     */\n    function redeem(uint256 tokenId) external override onlyRole(Roles.MCAG_BURN_ROLE) whenNotPaused {\n        if (_ownerOf(tokenId) != _msgSender()) {\n            revert Errors.ERC721_CALLER_IS_NOT_TOKEN_OWNER();\n        }\n        delete _bonds[tokenId];\n        _burn(tokenId);\n        emit BondRedeemed(tokenId);\n    }\n\n    /**\n     * @notice Sets a new base uri.\n     * @dev Can only be called by `MCAG_SET_URI_ROLE`.\n     * @param newUri New base uri.\n     */\n    function setUri(string memory newUri) external override onlyRole(Roles.MCAG_SET_URI_ROLE) {\n        emit UriSet(_uri, newUri);\n        _uri = newUri;\n    }\n\n    /**\n     * @dev See {Pausable-_pause}.\n     */\n    function pause() external override onlyRole(Roles.MCAG_PAUSE_ROLE) {\n        _pause();\n    }\n\n    /**\n     * @dev See {Pausable-_unpause}.\n     */\n    function unpause() external override onlyRole(Roles.MCAG_UNPAUSE_ROLE) {\n        _unpause();\n    }\n\n    /**\n     * @return Current token id counter.\n     */\n    function getTokenIdCounter() external view override returns (uint256) {\n        return _tokenIdCounter.current();\n    }\n\n    /**\n     * @param tokenId Bond id.\n     * @return Bond struct storing metadata of the selected bond id.\n     */\n    function getBond(uint256 tokenId) external view override returns (Bond memory) {\n        if (_ownerOf(tokenId) == address(0)) {\n            revert Errors.ERC721_INVALID_TOKEN_ID();\n        }\n        return _bonds[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     * @dev Adds the following conditions to the call :\n     *      - Caller and spender must not be blacklisted\n     *      - Contract must not be paused\n     */\n    function approve(address to, uint256 tokenId)\n        public\n        override(ERC721, IERC721)\n        whenNotPaused\n        notBlacklisted(to)\n        notBlacklisted(msg.sender)\n    {\n        address owner = ERC721.ownerOf(tokenId);\n\n        if (to == owner) {\n            revert Errors.ERC721_APPROVAL_TO_CURRENT_OWNER();\n        }\n\n        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {\n            revert Errors.ERC721_APPROVE_CALLER_IS_NOT_TOKEN_OWNER_OR_APPROVED_FOR_ALL();\n        }\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     * @dev Adds the following conditions to the call :\n     *      - Caller and operator must not be blacklisted\n     *      - Contract must not be paused\n     */\n    function setApprovalForAll(address operator, bool approved)\n        public\n        override(ERC721, IERC721)\n        whenNotPaused\n        notBlacklisted(msg.sender)\n        notBlacklisted(operator)\n    {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     * @dev Adds the following conditions to the call :\n     *      - Caller, from and to must not be blacklisted\n     *      - Contract must not be paused\n     */\n    function transferFrom(address from, address to, uint256 tokenId)\n        public\n        override(ERC721, IERC721)\n        whenNotPaused\n        notBlacklisted(msg.sender)\n        notBlacklisted(from)\n        notBlacklisted(to)\n    {\n        if (!_isApprovedOrOwner(_msgSender(), tokenId)) {\n            revert Errors.ERC721_CALLER_IS_NOT_TOKEN_OWNER_OR_APPROVED();\n        }\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     * @dev Adds the following conditions to the call :\n     *      - Caller, from and to must not be blacklisted\n     *      - Contract must not be paused\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        override(ERC721, IERC721)\n        whenNotPaused\n        notBlacklisted(msg.sender)\n        notBlacklisted(from)\n        notBlacklisted(to)\n    {\n        if (!_isApprovedOrOwner(_msgSender(), tokenId)) {\n            revert Errors.ERC721_CALLER_IS_NOT_TOKEN_OWNER_OR_APPROVED();\n        }\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev See {IERC721-_baseUri}.\n     */\n    function _baseURI() internal view override returns (string memory) {\n        return _uri;\n    }\n}"
    }
  ]
}