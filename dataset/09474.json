{
  "Title": "[M-04] New vest reset `unlockBegin` of existing vest without removing vested amount",
  "Content": "_Submitted by gzeon, also found by cccz, TrungOre, minhquanym, cmichel, 0xDjango, and rayn_\n\n<https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/StakedCitadelVester.sol#L143>\n\n<https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/StakedCitadelVester.sol#L109>\n\n### Impact\n\nWhen `vest` is called by xCTDL vault, the previous amount will re-lock according to the new vesting timeline. While this is as described in L127, `claimableBalance` might revert due to underflow if `vesting[recipient].claimedAmounts` > 0 because the user will need to vest the `claimedAmounts` again which should not be an expected behavior as it is already vested.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/StakedCitadelVester.sol#L143>\n\n            vesting[recipient].lockedAmounts =\n                vesting[recipient].lockedAmounts +\n                _amount;\n            vesting[recipient].unlockBegin = _unlockBegin;\n            vesting[recipient].unlockEnd = _unlockBegin + vestingDuration;\n\n<https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/StakedCitadelVester.sol#L109>\n\n            uint256 locked = vesting[recipient].lockedAmounts;\n            uint256 claimed = vesting[recipient].claimedAmounts;\n            if (block.timestamp >= vesting[recipient].unlockEnd) {\n                return locked - claimed;\n            }\n            return\n                ((locked * (block.timestamp - vesting[recipient].unlockBegin)) /\n                    (vesting[recipient].unlockEnd -\n                        vesting[recipient].unlockBegin)) - claimed;\n\n### Recommended Mitigation Steps\n\nReset claimedAmounts on new vest\n\n            vesting[recipient].lockedAmounts =\n                vesting[recipient].lockedAmounts - \n                vesting[recipient].claimedAmounts +\n                _amount;\n            vesting[recipient].claimedAmounts = 0\n            vesting[recipient].unlockBegin = _unlockBegin;\n            vesting[recipient].unlockEnd = _unlockBegin + vestingDuration;\n\n**[shuklaayush (BadgerDAO) confirmed and commented](https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/158#issuecomment-1110273728):**\n > I think this is valid and was fixed in \n> https://github.com/Citadel-DAO/citadel-contracts/pull/44\n\n**[jack-the-pug (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/158#issuecomment-1140759899):**\n > I'm downgrading this to Medium as there are no funds directly at risk, but a malfunction and leak of value. The user will have to wait for a longer than expected time to claim their vested funds.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-04-badger-citadel-contest",
  "Code": [
    {
      "filename": "src/StakedCitadelVester.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./lib/GlobalAccessControlManaged.sol\";\n\n/**\n * @title Staked Citadel Vesting Utility.\n * @notice Time-locks tokens on users' behalf according to an unlock schedule.\n */\ncontract StakedCitadelVester is\n    GlobalAccessControlManaged,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    bytes32 public constant CONTRACT_GOVERNANCE_ROLE =\n        keccak256(\"CONTRACT_GOVERNANCE_ROLE\");\n\n    struct VestingParams {\n        uint256 unlockBegin;\n        uint256 unlockEnd;\n        uint256 lockedAmounts;\n        uint256 claimedAmounts;\n    }\n\n    IERC20Upgradeable public vestingToken;\n    address public vault;\n    mapping(address => VestingParams) public vesting;\n\n    uint256 public constant INITIAL_VESTING_DURATION = 86400 * 21; // 21 days of vesting\n    uint256 public vestingDuration;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    event Vest(\n        address indexed recipient,\n        uint256 _amount,\n        uint256 _unlockBegin,\n        uint256 _unlockEnd\n    );\n    event Claimed(\n        address indexed owner,\n        address indexed recipient,\n        uint256 amount\n    );\n\n    event SetVestingDuration(uint256 duration);\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    function initialize(\n        address _gac,\n        address _vestingToken,\n        address _vault\n    ) external initializer {\n        require(_vestingToken != address(0), \"Address zero invalid\");\n        require(_vault != address(0), \"Address zero invalid\");\n\n        __GlobalAccessControlManaged_init(_gac);\n        __ReentrancyGuard_init();\n\n        vestingDuration = INITIAL_VESTING_DURATION;\n\n        vestingToken = IERC20Upgradeable(_vestingToken);\n        vault = _vault;\n    }\n\n    /// ==========================\n    /// ===== Public actions =====\n    /// ==========================\n\n    /**\n     * @notice Claims the caller's tokens that have been unlocked, sending them to `recipient`.\n     * @param recipient The account to transfer unlocked tokens to.\n     * @param amount The amount to transfer. If greater than the claimable amount, the maximum is transferred.\n     */\n    function claim(address recipient, uint256 amount) external {\n        uint256 claimable = claimableBalance(msg.sender);\n        if (amount > claimable) {\n            amount = claimable;\n        }\n        if (amount != 0) {\n            vesting[msg.sender].claimedAmounts =\n                vesting[msg.sender].claimedAmounts +\n                amount;\n            vestingToken.safeTransfer(recipient, amount);\n            emit Claimed(msg.sender, recipient, amount);\n        }\n    }\n\n    /// =======================\n    /// ===== Public view =====\n    /// =======================\n\n    /**\n     * @notice Returns the maximum number of tokens currently claimable by `recipient`.\n     * @param recipient The account to check the claimable balance of.\n     * @return The number of tokens currently claimable.\n     */\n    function claimableBalance(address recipient) public view returns (uint256) {\n        uint256 locked = vesting[recipient].lockedAmounts;\n        uint256 claimed = vesting[recipient].claimedAmounts;\n        if (block.timestamp >= vesting[recipient].unlockEnd) {\n            return locked - claimed;\n        }\n        return\n            ((locked * (block.timestamp - vesting[recipient].unlockBegin)) /\n                (vesting[recipient].unlockEnd -\n                    vesting[recipient].unlockBegin)) - claimed;\n    }\n\n    /// =========================\n    /// ===== Vault actions =====\n    /// =========================\n\n    /**\n     * @dev setup vesting for recipient.\n     * @notice note that a given address can only have one active vest at a time.\n     * @notice adding a new vest before claiming completely from the previous will re-lock the previous amount according to the new vesting timeline.\n     * @param recipient The account for which vesting will be setup.\n     * @param _amount amount that will be vested\n     * @param _unlockBegin The time at which unlocking of tokens will begin.\n     */\n    function vest(\n        address recipient,\n        uint256 _amount,\n        uint256 _unlockBegin\n    ) external {\n        require(msg.sender == vault, \"StakedCitadelVester: only xCTDL vault\");\n        require(_amount > 0, \"StakedCitadelVester: cannot vest 0\");\n\n        vesting[recipient].lockedAmounts =\n            vesting[recipient].lockedAmounts +\n            _amount;\n        vesting[recipient].unlockBegin = _unlockBegin;\n        vesting[recipient].unlockEnd = _unlockBegin + vestingDuration;\n\n        emit Vest(\n            recipient,\n            vesting[recipient].lockedAmounts,\n            _unlockBegin,\n            vesting[recipient].unlockEnd\n        );\n    }\n\n    /// ==============================\n    /// ===== Governance actions =====\n    /// ==============================\n\n    /**\n     * @notice modify vesting duration\n     * @dev does not affect currently active vests, only future vests\n     * @param _duration new vesting duration\n     */\n    function setVestingDuration(uint256 _duration)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        vestingDuration = _duration;\n        emit SetVestingDuration(_duration);\n    }\n}"
    },
    {
      "filename": "src/StakedCitadelVester.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./lib/GlobalAccessControlManaged.sol\";\n\n/**\n * @title Staked Citadel Vesting Utility.\n * @notice Time-locks tokens on users' behalf according to an unlock schedule.\n */\ncontract StakedCitadelVester is\n    GlobalAccessControlManaged,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    bytes32 public constant CONTRACT_GOVERNANCE_ROLE =\n        keccak256(\"CONTRACT_GOVERNANCE_ROLE\");\n\n    struct VestingParams {\n        uint256 unlockBegin;\n        uint256 unlockEnd;\n        uint256 lockedAmounts;\n        uint256 claimedAmounts;\n    }\n\n    IERC20Upgradeable public vestingToken;\n    address public vault;\n    mapping(address => VestingParams) public vesting;\n\n    uint256 public constant INITIAL_VESTING_DURATION = 86400 * 21; // 21 days of vesting\n    uint256 public vestingDuration;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    event Vest(\n        address indexed recipient,\n        uint256 _amount,\n        uint256 _unlockBegin,\n        uint256 _unlockEnd\n    );\n    event Claimed(\n        address indexed owner,\n        address indexed recipient,\n        uint256 amount\n    );\n\n    event SetVestingDuration(uint256 duration);\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    function initialize(\n        address _gac,\n        address _vestingToken,\n        address _vault\n    ) external initializer {\n        require(_vestingToken != address(0), \"Address zero invalid\");\n        require(_vault != address(0), \"Address zero invalid\");\n\n        __GlobalAccessControlManaged_init(_gac);\n        __ReentrancyGuard_init();\n\n        vestingDuration = INITIAL_VESTING_DURATION;\n\n        vestingToken = IERC20Upgradeable(_vestingToken);\n        vault = _vault;\n    }\n\n    /// ==========================\n    /// ===== Public actions =====\n    /// ==========================\n\n    /**\n     * @notice Claims the caller's tokens that have been unlocked, sending them to `recipient`.\n     * @param recipient The account to transfer unlocked tokens to.\n     * @param amount The amount to transfer. If greater than the claimable amount, the maximum is transferred.\n     */\n    function claim(address recipient, uint256 amount) external {\n        uint256 claimable = claimableBalance(msg.sender);\n        if (amount > claimable) {\n            amount = claimable;\n        }\n        if (amount != 0) {\n            vesting[msg.sender].claimedAmounts =\n                vesting[msg.sender].claimedAmounts +\n                amount;\n            vestingToken.safeTransfer(recipient, amount);\n            emit Claimed(msg.sender, recipient, amount);\n        }\n    }\n\n    /// =======================\n    /// ===== Public view =====\n    /// =======================\n\n    /**\n     * @notice Returns the maximum number of tokens currently claimable by `recipient`.\n     * @param recipient The account to check the claimable balance of.\n     * @return The number of tokens currently claimable.\n     */\n    function claimableBalance(address recipient) public view returns (uint256) {\n        uint256 locked = vesting[recipient].lockedAmounts;\n        uint256 claimed = vesting[recipient].claimedAmounts;\n        if (block.timestamp >= vesting[recipient].unlockEnd) {\n            return locked - claimed;\n        }\n        return\n            ((locked * (block.timestamp - vesting[recipient].unlockBegin)) /\n                (vesting[recipient].unlockEnd -\n                    vesting[recipient].unlockBegin)) - claimed;\n    }\n\n    /// =========================\n    /// ===== Vault actions =====\n    /// =========================\n\n    /**\n     * @dev setup vesting for recipient.\n     * @notice note that a given address can only have one active vest at a time.\n     * @notice adding a new vest before claiming completely from the previous will re-lock the previous amount according to the new vesting timeline.\n     * @param recipient The account for which vesting will be setup.\n     * @param _amount amount that will be vested\n     * @param _unlockBegin The time at which unlocking of tokens will begin.\n     */\n    function vest(\n        address recipient,\n        uint256 _amount,\n        uint256 _unlockBegin\n    ) external {\n        require(msg.sender == vault, \"StakedCitadelVester: only xCTDL vault\");\n        require(_amount > 0, \"StakedCitadelVester: cannot vest 0\");\n\n        vesting[recipient].lockedAmounts =\n            vesting[recipient].lockedAmounts +\n            _amount;\n        vesting[recipient].unlockBegin = _unlockBegin;\n        vesting[recipient].unlockEnd = _unlockBegin + vestingDuration;\n\n        emit Vest(\n            recipient,\n            vesting[recipient].lockedAmounts,\n            _unlockBegin,\n            vesting[recipient].unlockEnd\n        );\n    }\n\n    /// ==============================\n    /// ===== Governance actions =====\n    /// ==============================\n\n    /**\n     * @notice modify vesting duration\n     * @dev does not affect currently active vests, only future vests\n     * @param _duration new vesting duration\n     */\n    function setVestingDuration(uint256 _duration)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        vestingDuration = _duration;\n        emit SetVestingDuration(_duration);\n    }\n}"
    },
    {
      "filename": "src/StakedCitadelVester.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./lib/GlobalAccessControlManaged.sol\";\n\n/**\n * @title Staked Citadel Vesting Utility.\n * @notice Time-locks tokens on users' behalf according to an unlock schedule.\n */\ncontract StakedCitadelVester is\n    GlobalAccessControlManaged,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    bytes32 public constant CONTRACT_GOVERNANCE_ROLE =\n        keccak256(\"CONTRACT_GOVERNANCE_ROLE\");\n\n    struct VestingParams {\n        uint256 unlockBegin;\n        uint256 unlockEnd;\n        uint256 lockedAmounts;\n        uint256 claimedAmounts;\n    }\n\n    IERC20Upgradeable public vestingToken;\n    address public vault;\n    mapping(address => VestingParams) public vesting;\n\n    uint256 public constant INITIAL_VESTING_DURATION = 86400 * 21; // 21 days of vesting\n    uint256 public vestingDuration;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    event Vest(\n        address indexed recipient,\n        uint256 _amount,\n        uint256 _unlockBegin,\n        uint256 _unlockEnd\n    );\n    event Claimed(\n        address indexed owner,\n        address indexed recipient,\n        uint256 amount\n    );\n\n    event SetVestingDuration(uint256 duration);\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    function initialize(\n        address _gac,\n        address _vestingToken,\n        address _vault\n    ) external initializer {\n        require(_vestingToken != address(0), \"Address zero invalid\");\n        require(_vault != address(0), \"Address zero invalid\");\n\n        __GlobalAccessControlManaged_init(_gac);\n        __ReentrancyGuard_init();\n\n        vestingDuration = INITIAL_VESTING_DURATION;\n\n        vestingToken = IERC20Upgradeable(_vestingToken);\n        vault = _vault;\n    }\n\n    /// ==========================\n    /// ===== Public actions =====\n    /// ==========================\n\n    /**\n     * @notice Claims the caller's tokens that have been unlocked, sending them to `recipient`.\n     * @param recipient The account to transfer unlocked tokens to.\n     * @param amount The amount to transfer. If greater than the claimable amount, the maximum is transferred.\n     */\n    function claim(address recipient, uint256 amount) external {\n        uint256 claimable = claimableBalance(msg.sender);\n        if (amount > claimable) {\n            amount = claimable;\n        }\n        if (amount != 0) {\n            vesting[msg.sender].claimedAmounts =\n                vesting[msg.sender].claimedAmounts +\n                amount;\n            vestingToken.safeTransfer(recipient, amount);\n            emit Claimed(msg.sender, recipient, amount);\n        }\n    }\n\n    /// =======================\n    /// ===== Public view =====\n    /// =======================\n\n    /**\n     * @notice Returns the maximum number of tokens currently claimable by `recipient`.\n     * @param recipient The account to check the claimable balance of.\n     * @return The number of tokens currently claimable.\n     */\n    function claimableBalance(address recipient) public view returns (uint256) {\n        uint256 locked = vesting[recipient].lockedAmounts;\n        uint256 claimed = vesting[recipient].claimedAmounts;\n        if (block.timestamp >= vesting[recipient].unlockEnd) {\n            return locked - claimed;\n        }\n        return\n            ((locked * (block.timestamp - vesting[recipient].unlockBegin)) /\n                (vesting[recipient].unlockEnd -\n                    vesting[recipient].unlockBegin)) - claimed;\n    }\n\n    /// =========================\n    /// ===== Vault actions =====\n    /// =========================\n\n    /**\n     * @dev setup vesting for recipient.\n     * @notice note that a given address can only have one active vest at a time.\n     * @notice adding a new vest before claiming completely from the previous will re-lock the previous amount according to the new vesting timeline.\n     * @param recipient The account for which vesting will be setup.\n     * @param _amount amount that will be vested\n     * @param _unlockBegin The time at which unlocking of tokens will begin.\n     */\n    function vest(\n        address recipient,\n        uint256 _amount,\n        uint256 _unlockBegin\n    ) external {\n        require(msg.sender == vault, \"StakedCitadelVester: only xCTDL vault\");\n        require(_amount > 0, \"StakedCitadelVester: cannot vest 0\");\n\n        vesting[recipient].lockedAmounts =\n            vesting[recipient].lockedAmounts +\n            _amount;\n        vesting[recipient].unlockBegin = _unlockBegin;\n        vesting[recipient].unlockEnd = _unlockBegin + vestingDuration;\n\n        emit Vest(\n            recipient,\n            vesting[recipient].lockedAmounts,\n            _unlockBegin,\n            vesting[recipient].unlockEnd\n        );\n    }\n\n    /// ==============================\n    /// ===== Governance actions =====\n    /// ==============================\n\n    /**\n     * @notice modify vesting duration\n     * @dev does not affect currently active vests, only future vests\n     * @param _duration new vesting duration\n     */\n    function setVestingDuration(uint256 _duration)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        vestingDuration = _duration;\n        emit SetVestingDuration(_duration);\n    }\n}"
    },
    {
      "filename": "src/StakedCitadelVester.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./lib/GlobalAccessControlManaged.sol\";\n\n/**\n * @title Staked Citadel Vesting Utility.\n * @notice Time-locks tokens on users' behalf according to an unlock schedule.\n */\ncontract StakedCitadelVester is\n    GlobalAccessControlManaged,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    bytes32 public constant CONTRACT_GOVERNANCE_ROLE =\n        keccak256(\"CONTRACT_GOVERNANCE_ROLE\");\n\n    struct VestingParams {\n        uint256 unlockBegin;\n        uint256 unlockEnd;\n        uint256 lockedAmounts;\n        uint256 claimedAmounts;\n    }\n\n    IERC20Upgradeable public vestingToken;\n    address public vault;\n    mapping(address => VestingParams) public vesting;\n\n    uint256 public constant INITIAL_VESTING_DURATION = 86400 * 21; // 21 days of vesting\n    uint256 public vestingDuration;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    event Vest(\n        address indexed recipient,\n        uint256 _amount,\n        uint256 _unlockBegin,\n        uint256 _unlockEnd\n    );\n    event Claimed(\n        address indexed owner,\n        address indexed recipient,\n        uint256 amount\n    );\n\n    event SetVestingDuration(uint256 duration);\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    function initialize(\n        address _gac,\n        address _vestingToken,\n        address _vault\n    ) external initializer {\n        require(_vestingToken != address(0), \"Address zero invalid\");\n        require(_vault != address(0), \"Address zero invalid\");\n\n        __GlobalAccessControlManaged_init(_gac);\n        __ReentrancyGuard_init();\n\n        vestingDuration = INITIAL_VESTING_DURATION;\n\n        vestingToken = IERC20Upgradeable(_vestingToken);\n        vault = _vault;\n    }\n\n    /// ==========================\n    /// ===== Public actions =====\n    /// ==========================\n\n    /**\n     * @notice Claims the caller's tokens that have been unlocked, sending them to `recipient`.\n     * @param recipient The account to transfer unlocked tokens to.\n     * @param amount The amount to transfer. If greater than the claimable amount, the maximum is transferred.\n     */\n    function claim(address recipient, uint256 amount) external {\n        uint256 claimable = claimableBalance(msg.sender);\n        if (amount > claimable) {\n            amount = claimable;\n        }\n        if (amount != 0) {\n            vesting[msg.sender].claimedAmounts =\n                vesting[msg.sender].claimedAmounts +\n                amount;\n            vestingToken.safeTransfer(recipient, amount);\n            emit Claimed(msg.sender, recipient, amount);\n        }\n    }\n\n    /// =======================\n    /// ===== Public view =====\n    /// =======================\n\n    /**\n     * @notice Returns the maximum number of tokens currently claimable by `recipient`.\n     * @param recipient The account to check the claimable balance of.\n     * @return The number of tokens currently claimable.\n     */\n    function claimableBalance(address recipient) public view returns (uint256) {\n        uint256 locked = vesting[recipient].lockedAmounts;\n        uint256 claimed = vesting[recipient].claimedAmounts;\n        if (block.timestamp >= vesting[recipient].unlockEnd) {\n            return locked - claimed;\n        }\n        return\n            ((locked * (block.timestamp - vesting[recipient].unlockBegin)) /\n                (vesting[recipient].unlockEnd -\n                    vesting[recipient].unlockBegin)) - claimed;\n    }\n\n    /// =========================\n    /// ===== Vault actions =====\n    /// =========================\n\n    /**\n     * @dev setup vesting for recipient.\n     * @notice note that a given address can only have one active vest at a time.\n     * @notice adding a new vest before claiming completely from the previous will re-lock the previous amount according to the new vesting timeline.\n     * @param recipient The account for which vesting will be setup.\n     * @param _amount amount that will be vested\n     * @param _unlockBegin The time at which unlocking of tokens will begin.\n     */\n    function vest(\n        address recipient,\n        uint256 _amount,\n        uint256 _unlockBegin\n    ) external {\n        require(msg.sender == vault, \"StakedCitadelVester: only xCTDL vault\");\n        require(_amount > 0, \"StakedCitadelVester: cannot vest 0\");\n\n        vesting[recipient].lockedAmounts =\n            vesting[recipient].lockedAmounts +\n            _amount;\n        vesting[recipient].unlockBegin = _unlockBegin;\n        vesting[recipient].unlockEnd = _unlockBegin + vestingDuration;\n\n        emit Vest(\n            recipient,\n            vesting[recipient].lockedAmounts,\n            _unlockBegin,\n            vesting[recipient].unlockEnd\n        );\n    }\n\n    /// ==============================\n    /// ===== Governance actions =====\n    /// ==============================\n\n    /**\n     * @notice modify vesting duration\n     * @dev does not affect currently active vests, only future vests\n     * @param _duration new vesting duration\n     */\n    function setVestingDuration(uint256 _duration)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        vestingDuration = _duration;\n        emit SetVestingDuration(_duration);\n    }\n}"
    }
  ]
}