{
  "Title": "[M-10] `PrizePool` -> Winners wouldn't be able to claim prize correctly in `claimPrize` function",
  "Content": "\nIn `PrizePool.sol` vaults can call the `claimPrize()` function to claim prizes for winners. The `claimPrize` calls `_getTier(_tier, numberOfTiers)` function to get back the `prizeSize` but there is a problem in the [`_getTier`](https://github.com/GenerationSoftware/pt-v5-prize-pool/blob/4bc8a12b857856828c018510b5500d722b79ca3a/src/abstract/TieredLiquidityDistributor.sol#L471) function:\n\n```solidity\n  function _getTier(uint8 _tier, uint8 _numberOfTiers) internal view returns (Tier memory) {\n    Tier memory tier = _tiers[_tier];\n    uint16 _lastClosedDrawId = lastClosedDrawId;\n    if (tier.drawId != _lastClosedDrawId) {\n      tier.drawId = _lastClosedDrawId;\n      tier.prizeSize = uint96(\n        _computePrizeSize(\n          _tier,\n          _numberOfTiers,\n          fromUD34x4toUD60x18(tier.prizeTokenPerShare),\n          fromUD34x4toUD60x18(prizeTokenPerShare)\n        )\n      );\n    }\n    return tier;\n  }\n```\n\nAs you can see, it calls the `_computePrizeSize` function and downcasts the returned result. Since it returns `uint256` by downcasting it to `uint96`, it's possible to result in the incorrect number in the value overflow. When downcasting from one type to another, Solidity will not revert, but overflows.\nThis means, there is a possibility the `prizeSize` value will result in the incorrect prize size and vaults can't claim the prizes correctly for winners.\n\n### Recommended Mitigation Steps\n\nCheck whether the result of `prizeSize` exceeds `type(uint96).max` or not, if so, revert the tx. I recommend to use [SafeCast](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol) by OpenZeppelin for casting different types safely.\n\nI also found some other downcastings in the codebase, but since they are pegged to vault share values and you already check for overflows, there is no problem.\n\n### Assessed type\n\nUnder/Overflow\n\n**[asselstine (PoolTogether) confirmed and commented](https://github.com/code-423n4/2023-07-pooltogether-findings/issues/399#issuecomment-1644716829):**\n > Hmm; looks like the Tier struct has an extra 16 bits available to pack.  Will increase `prizeSize` type to `uint112` and add safe casting.\n\n**[Picodes (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-07-pooltogether-findings/issues/399#issuecomment-1666619614):**\n > Downgrading to Med as there is no proof of impact or discussion about the chances of this occurring in the report.\n\n**[asselstine (PoolTogether) commented](https://github.com/code-423n4/2023-07-pooltogether-findings/issues/399#issuecomment-1683002833):**\n> Come to think of it, since prizes are in POOL and its supply is 10m with 18 decimals, then prizes can never be more than ~1e25.\n\n**[PoolTogether mitigated](https://github.com/code-423n4/2023-08-pooltogether-mitigation#individual-prs):**\n> Improved handling of prize size overflow.<br>\n> PR: https://github.com/GenerationSoftware/pt-v5-prize-pool/pull/16\n\n**Status**: Mitigation confirmed. Full details in reports from [0xStalin](https://github.com/code-423n4/2023-08-pooltogether-mitigation-findings/issues/85) and [dirk\\_y](https://github.com/code-423n4/2023-08-pooltogether-mitigation-findings/issues/16).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-pooltogether",
  "Code": [
    {
      "filename": "src/abstract/TieredLiquidityDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport { E, SD59x18, sd, toSD59x18, fromSD59x18 } from \"prb-math/SD59x18.sol\";\nimport { UD60x18, ud, toUD60x18, fromUD60x18, intoSD59x18 } from \"prb-math/UD60x18.sol\";\nimport { UD2x18, intoUD60x18 } from \"prb-math/UD2x18.sol\";\nimport { SD1x18, unwrap, UNIT } from \"prb-math/SD1x18.sol\";\n\nimport { UD34x4, fromUD60x18 as fromUD60x18toUD34x4, intoUD60x18 as fromUD34x4toUD60x18, toUD34x4 } from \"../libraries/UD34x4.sol\";\nimport { TierCalculationLib } from \"../libraries/TierCalculationLib.sol\";\n\n/// @notice Struct that tracks tier liquidity information.\nstruct Tier {\n  uint16 drawId;\n  uint96 prizeSize;\n  UD34x4 prizeTokenPerShare;\n}\n\n/// @notice Emitted when the number of tiers is less than the minimum number of tiers.\n/// @param numTiers The invalid number of tiers\nerror NumberOfTiersLessThanMinimum(uint8 numTiers);\n\n/// @notice Emitted when the number of tiers is greater than the max tiers\n/// @param numTiers The invalid number of tiers\nerror NumberOfTiersGreaterThanMaximum(uint8 numTiers);\n\n/// @notice Emitted when there is insufficient liquidity to consume.\n/// @param requestedLiquidity The requested amount of liquidity\nerror InsufficientLiquidity(uint104 requestedLiquidity);\n\n/// @title Tiered Liquidity Distributor\n/// @author PoolTogether Inc.\n/// @notice A contract that distributes liquidity according to PoolTogether V5 distribution rules.\ncontract TieredLiquidityDistributor {\n\n  /* ============ Events ============ */\n\n  /// @notice Emitted when the reserve is consumed due to insufficient prize liquidity.\n  /// @param amount The amount to decrease by\n  event ReserveConsumed(uint256 amount);\n\n  /* ============ Constants ============ */\n\n  uint8 internal constant MINIMUM_NUMBER_OF_TIERS = 3;\n  uint8 internal constant MAXIMUM_NUMBER_OF_TIERS = 15;\n\n  UD60x18 internal immutable CANARY_PRIZE_COUNT_FOR_2_TIERS;\n  UD60x18 internal immutable CANARY_PRIZE_COUNT_FOR_3_TIERS;\n  UD60x18 internal immutable CANARY_PRIZE_COUNT_FOR_4_TIERS;\n  UD60x18 internal immutable CANARY_PRIZE_COUNT_FOR_5_TIERS;\n  UD60x18 internal immutable CANARY_PRIZE_COUNT_FOR_6_TIERS;\n  UD60x18 internal immutable CANARY_PRIZE_COUNT_FOR_7_TIERS;\n  UD60x18 internal immutable CANARY_PRIZE_COUNT_FOR_8_TIERS;\n  UD60x18 internal immutable CANARY_PRIZE_COUNT_FOR_9_TIERS;\n  UD60x18 internal immutable CANARY_PRIZE_COUNT_FOR_10_TIERS;\n  UD60x18 internal immutable CANARY_PRIZE_COUNT_FOR_11_TIERS;\n  UD60x18 internal immutable CANARY_PRIZE_COUNT_FOR_12_TIERS;\n  UD60x18 internal immutable CANARY_PRIZE_COUNT_FOR_13_TIERS;\n  UD60x18 internal immutable CANARY_PRIZE_COUNT_FOR_14_TIERS;\n\n  //////////////////////// START GENERATED CONSTANTS ////////////////////////\n  // The following constants are precomputed using the script/generateConstants.s.sol script.\n\n  /// @notice The number of draws that should statistically occur between grand prizes.\n  uint16 internal constant GRAND_PRIZE_PERIOD_DRAWS = 365;\n\n  /// @notice The estimated number of prizes given X tiers.\n  uint32 internal constant ESTIMATED_PRIZES_PER_DRAW_FOR_2_TIERS = 4;\n  uint32 internal constant ESTIMATED_PRIZES_PER_DRAW_FOR_3_TIERS = 16;\n  uint32 internal constant ESTIMATED_PRIZES_PER_DRAW_FOR_4_TIERS = 66;\n  uint32 internal constant ESTIMATED_PRIZES_PER_DRAW_FOR_5_TIERS = 270;\n  uint32 internal constant ESTIMATED_PRIZES_PER_DRAW_FOR_6_TIERS = 1108;\n  uint32 internal constant ESTIMATED_PRIZES_PER_DRAW_FOR_7_TIERS = 4517;\n  uint32 internal constant ESTIMATED_PRIZES_PER_DRAW_FOR_8_TIERS = 18358;\n  uint32 internal constant ESTIMATED_PRIZES_PER_DRAW_FOR_9_TIERS = 74435;\n  uint32 internal constant ESTIMATED_PRIZES_PER_DRAW_FOR_10_TIERS = 301239;\n  uint32 internal constant ESTIMATED_PRIZES_PER_DRAW_FOR_11_TIERS = 1217266;\n  uint32 internal constant ESTIMATED_PRIZES_PER_DRAW_FOR_12_TIERS = 4912619;\n  uint32 internal constant ESTIMATED_PRIZES_PER_DRAW_FOR_13_TIERS = 19805536;\n  uint32 internal constant ESTIMATED_PRIZES_PER_DRAW_FOR_14_TIERS = 79777187;\n\n  /// @notice The odds for each tier and number of tiers pair.\n  SD59x18 internal constant TIER_ODDS_0_3 = SD59x18.wrap(2739726027397260);\n  SD59x18 internal constant TIER_ODDS_1_3 = SD59x18.wrap(52342392259021369);\n  SD59x18 internal constant TIER_ODDS_2_3 = SD59x18.wrap(1000000000000000000);\n  SD59x18 internal constant TIER_ODDS_0_4 = SD59x18.wrap(2739726027397260);\n  SD59x18 internal constant TIER_ODDS_1_4 = SD59x18.wrap(19579642462506911);\n  SD59x18 internal constant TIER_ODDS_2_4 = SD59x18.wrap(139927275620255366);\n  SD59x18 internal constant TIER_ODDS_3_4 = SD59x18.wrap(1000000000000000000);\n  SD59x18 internal constant TIER_ODDS_0_5 = SD59x18.wrap(2739726027397260);\n  SD59x18 internal constant TIER_ODDS_1_5 = SD59x18.wrap(11975133168707466);\n  SD59x18 internal constant TIER_ODDS_2_5 = SD59x18.wrap(52342392259021369);\n  SD59x18 internal constant TIER_ODDS_3_5 = SD59x18.wrap(228784597949733865);\n  SD59x18 internal constant TIER_ODDS_4_5 = SD59x18.wrap(1000000000000000000);\n  SD59x18 internal constant TIER_ODDS_0_6 = SD59x18.wrap(2739726027397260);\n  SD59x18 internal constant TIER_ODDS_1_6 = SD59x18.wrap(8915910667410451);\n  SD59x18 internal constant TIER_ODDS_2_6 = SD59x18.wrap(29015114005673871);\n  SD59x18 internal constant TIER_ODDS_3_6 = SD59x18.wrap(94424100034951094);\n  SD59x18 internal constant TIER_ODDS_4_6 = SD59x18.wrap(307285046878222004);\n  SD59x18 internal constant TIER_ODDS_5_6 = SD59x18.wrap(1000000000000000000);\n  SD59x18 internal constant TIER_ODDS_0_7 = SD59x18.wrap(2739726027397260);\n  SD59x18 internal constant TIER_ODDS_1_7 = SD59x18.wrap(7324128348251604);\n  SD59x18 internal constant TIER_ODDS_2_7 = SD59x18.wrap(19579642462506911);\n  SD59x18 internal constant TIER_ODDS_3_7 = SD59x18.wrap(52342392259021369);\n  SD59x18 internal constant TIER_ODDS_4_7 = SD59x18.wrap(139927275620255366);\n  SD59x18 internal constant TIER_ODDS_5_7 = SD59x18.wrap(374068544013333694);\n  SD59x18 internal constant TIER_ODDS_6_7 = SD59x18.wrap(1000000000000000000);\n  SD59x18 internal constant TIER_ODDS_0_8 = SD59x18.wrap(2739726027397260);\n  SD59x18 internal constant TIER_ODDS_1_8 = SD59x18.wrap(6364275529026907);\n  SD59x18 internal constant TIER_ODDS_2_8 = SD59x18.wrap(14783961098420314);\n  SD59x18 internal constant TIER_ODDS_3_8 = SD59x18.wrap(34342558671878193);\n  SD59x18 internal constant TIER_ODDS_4_8 = SD59x18.wrap(79776409602255901);\n  SD59x18 internal constant TIER_ODDS_5_8 = SD59x18.wrap(185317453770221528);\n  SD59x18 internal constant TIER_ODDS_6_8 = SD59x18.wrap(430485137687959592);\n  SD59x18 internal constant TIER_ODDS_7_8 = SD59x18.wrap(1000000000000000000);\n  SD59x18 internal constant TIER_ODDS_0_9 = SD59x18.wrap(2739726027397260);\n  SD59x18 internal constant TIER_ODDS_1_9 = SD59x18.wrap(5727877794074876);\n  SD59x18 internal constant TIER_ODDS_2_9 = SD59x18.wrap(11975133168707466);\n  SD59x18 internal constant TIER_ODDS_3_9 = SD59x18.wrap(25036116265717087);\n  SD59x18 internal constant TIER_ODDS_4_9 = SD59x18.wrap(52342392259021369);\n  SD59x18 internal constant TIER_ODDS_5_9 = SD59x18.wrap(109430951602859902);\n  SD59x18 internal constant TIER_ODDS_6_9 = SD59x18.wrap(228784597949733865);\n  SD59x18 internal constant TIER_ODDS_7_9 = SD59x18.wrap(478314329651259628);\n  SD59x18 internal constant TIER_ODDS_8_9 = SD59x18.wrap(1000000000000000000);\n  SD59x18 internal constant TIER_ODDS_0_10 = SD59x18.wrap(2739726027397260);\n  SD59x18 internal constant TIER_ODDS_1_10 = SD59x18.wrap(5277233889074595);\n  SD59x18 internal constant TIER_ODDS_2_10 = SD59x18.wrap(10164957094799045);\n  SD59x18 internal constant TIER_ODDS_3_10 = SD59x18.wrap(19579642462506911);\n  SD59x18 internal constant TIER_ODDS_4_10 = SD59x18.wrap(37714118749773489);\n  SD59x18 internal constant TIER_ODDS_5_10 = SD59x18.wrap(72644572330454226);\n  SD59x18 internal constant TIER_ODDS_6_10 = SD59x18.wrap(139927275620255366);\n  SD59x18 internal constant TIER_ODDS_7_10 = SD59x18.wrap(269526570731818992);\n  SD59x18 internal constant TIER_ODDS_8_10 = SD59x18.wrap(519159484871285957);\n  SD59x18 internal constant TIER_ODDS_9_10 = SD59x18.wrap(1000000000000000000);\n  SD59x18 internal constant TIER_ODDS_0_11 = SD59x18.wrap(2739726027397260);\n  SD59x18 internal constant TIER_ODDS_1_11 = SD59x18.wrap(4942383282734483);\n  SD59x18 internal constant TIER_ODDS_2_11 = SD59x18.wrap(8915910667410451);\n  SD59x18 internal constant TIER_ODDS_3_11 = SD59x18.wrap(16084034459031666);\n  SD59x18 internal constant TIER_ODDS_4_11 = SD59x18.wrap(29015114005673871);\n  SD59x18 internal constant TIER_ODDS_5_11 = SD59x18.wrap(52342392259021369);\n  SD59x18 internal constant TIER_ODDS_6_11 = SD59x18.wrap(94424100034951094);\n  SD59x18 internal constant TIER_ODDS_7_11 = SD59x18.wrap(170338234127496669);\n  SD59x18 internal constant TIER_ODDS_8_11 = SD59x18.wrap(307285046878222004);\n  SD59x18 internal constant TIER_ODDS_9_11 = SD59x18.wrap(554332974734700411);\n  SD59x18 internal constant TIER_ODDS_10_11 = SD59x18.wrap(1000000000000000000);\n  SD59x18 internal constant TIER_ODDS_0_12 = SD59x18.wrap(2739726027397260);\n  SD59x18 internal constant TIER_ODDS_1_12 = SD59x18.wrap(4684280039134314);\n  SD59x18 internal constant TIER_ODDS_2_12 = SD59x18.wrap(8009005012036743);\n  SD59x18 internal constant TIER_ODDS_3_12 = SD59x18.wrap(13693494143591795);\n  SD59x18 internal constant TIER_ODDS_4_12 = SD59x18.wrap(23412618868232833);\n  SD59x18 internal constant TIER_ODDS_5_12 = SD59x18.wrap(40030011078337707);\n  SD59x18 internal constant TIER_ODDS_6_12 = SD59x18.wrap(68441800379112721);\n  SD59x18 internal constant TIER_ODDS_7_12 = SD59x18.wrap(117019204165776974);\n  SD59x18 internal constant TIER_ODDS_8_12 = SD59x18.wrap(200075013628233217);\n  SD59x18 internal constant TIER_ODDS_9_12 = SD59x18.wrap(342080698323914461);\n  SD59x18 internal constant TIER_ODDS_10_12 = SD59x18.wrap(584876652230121477);\n  SD59x18 internal constant TIER_ODDS_11_12 = SD59x18.wrap(1000000000000000000);\n  SD59x18 internal constant TIER_ODDS_0_13 = SD59x18.wrap(2739726027397260);\n  SD59x18 internal constant TIER_ODDS_1_13 = SD59x18.wrap(4479520628784180);\n  SD59x18 internal constant TIER_ODDS_2_13 = SD59x18.wrap(7324128348251604);\n  SD59x18 internal constant TIER_ODDS_3_13 = SD59x18.wrap(11975133168707466);\n  SD59x18 internal constant TIER_ODDS_4_13 = SD59x18.wrap(19579642462506911);\n  SD59x18 internal constant TIER_ODDS_5_13 = SD59x18.wrap(32013205494981721);\n  SD59x18 internal constant TIER_ODDS_6_13 = SD59x18.wrap(52342392259021369);\n  SD59x18 internal constant TIER_ODDS_7_13 = SD59x18.wrap(85581121447732876);\n  SD59x18 internal constant TIER_ODDS_8_13 = SD59x18.wrap(139927275620255366);\n  SD59x18 internal constant TIER_ODDS_9_13 = SD59x18.wrap(228784597949733866);\n  SD59x18 internal constant TIER_ODDS_10_13 = SD59x18.wrap(374068544013333694);\n  SD59x18 internal constant TIER_ODDS_11_13 = SD59x18.wrap(611611432212751966);\n  SD59x18 internal constant TIER_ODDS_12_13 = SD59x18.wrap(1000000000000000000);\n  SD59x18 internal constant TIER_ODDS_0_14 = SD59x18.wrap(2739726027397260);\n  SD59x18 internal constant TIER_ODDS_1_14 = SD59x18.wrap(4313269422986724);\n  SD59x18 internal constant TIER_ODDS_2_14 = SD59x18.wrap(6790566987074365);\n  SD59x18 internal constant TIER_ODDS_3_14 = SD59x18.wrap(10690683906783196);\n  SD59x18 internal constant TIER_ODDS_4_14 = SD59x18.wrap(16830807002169641);\n  SD59x18 internal constant TIER_ODDS_5_14 = SD59x18.wrap(26497468900426949);\n  SD59x18 internal constant TIER_ODDS_6_14 = SD59x18.wrap(41716113674084931);\n  SD59x18 internal constant TIER_ODDS_7_14 = SD59x18.wrap(65675485708038160);\n  SD59x18 internal constant TIER_ODDS_8_14 = SD59x18.wrap(103395763485663166);\n  SD59x18 internal constant TIER_ODDS_9_14 = SD59x18.wrap(162780431564813557);\n  SD59x18 internal constant TIER_ODDS_10_14 = SD59x18.wrap(256272288217119098);\n  SD59x18 internal constant TIER_ODDS_11_14 = SD59x18.wrap(403460570024895441);\n  SD59x18 internal constant TIER_ODDS_12_14 = SD59x18.wrap(635185461125249183);\n  SD59x18 internal constant TIER_ODDS_13_14 = SD59x18.wrap(1000000000000000000);\n  SD59x18 internal constant TIER_ODDS_0_15 = SD59x18.wrap(2739726027397260);\n  SD59x18 internal constant TIER_ODDS_1_15 = SD59x18.wrap(4175688124417637);\n  SD59x18 internal constant TIER_ODDS_2_15 = SD59x18.wrap(6364275529026907);\n  SD59x18 internal constant TIER_ODDS_3_15 = SD59x18.wrap(9699958857683993);\n  SD59x18 internal constant TIER_ODDS_4_15 = SD59x18.wrap(14783961098420314);\n  SD59x18 internal constant TIER_ODDS_5_15 = SD59x18.wrap(22532621938542004);\n  SD59x18 internal constant TIER_ODDS_6_15 = SD59x18.wrap(34342558671878193);\n  SD59x18 internal constant TIER_ODDS_7_15 = SD59x18.wrap(52342392259021369);\n  SD59x18 internal constant TIER_ODDS_8_15 = SD59x18.wrap(79776409602255901);\n  SD59x18 internal constant TIER_ODDS_9_15 = SD59x18.wrap(121589313257458259);\n  SD59x18 internal constant TIER_ODDS_10_15 = SD59x18.wrap(185317453770221528);\n  SD59x18 internal constant TIER_ODDS_11_15 = SD59x18.wrap(282447180198804430);\n  SD59x18 internal constant TIER_ODDS_12_15 = SD59x18.wrap(430485137687959592);\n  SD59x18 internal constant TIER_ODDS_13_15 = SD59x18.wrap(656113662171395111);\n  SD59x18 internal constant TIER_ODDS_14_15 = SD59x18.wrap(1000000000000000000);\n\n  //////////////////////// END GENERATED CONSTANTS ////////////////////////\n\n  /// @notice The Tier liquidity data.\n  mapping(uint8 => Tier) internal _tiers;\n\n  /// @notice The number of shares to allocate to each prize tier.\n  uint8 public immutable tierShares;\n\n  /// @notice The number of shares to allocate to the canary tier.\n  uint8 public immutable canaryShares;\n\n  /// @notice The number of shares to allocate to the reserve.\n  uint8 public immutable reserveShares;\n\n  /// @notice The current number of prize tokens per share.\n  UD34x4 public prizeTokenPerShare;\n\n  /// @notice The number of tiers for the last closed draw. The last tier is the canary tier.\n  uint8 public numberOfTiers;\n\n  /// @notice The draw id of the last closed draw.\n  uint16 internal lastClosedDrawId;\n\n  /// @notice The amount of available reserve.\n  uint104 internal _reserve;\n\n  /**\n   * @notice Constructs a new Prize Pool.\n   * @param _numberOfTiers The number of tiers to start with. Must be greater than or equal to the minimum number of tiers.\n   * @param _tierShares The number of shares to allocate to each tier\n   * @param _canaryShares The number of shares to allocate to the canary tier.\n   * @param _reserveShares The number of shares to allocate to the reserve.\n   */\n  constructor(uint8 _numberOfTiers, uint8 _tierShares, uint8 _canaryShares, uint8 _reserveShares) {\n    numberOfTiers = _numberOfTiers;\n    tierShares = _tierShares;\n    canaryShares = _canaryShares;\n    reserveShares = _reserveShares;\n\n    CANARY_PRIZE_COUNT_FOR_2_TIERS = TierCalculationLib.canaryPrizeCount(\n      2,\n      _canaryShares,\n      _reserveShares,\n      _tierShares\n    );\n    CANARY_PRIZE_COUNT_FOR_3_TIERS = TierCalculationLib.canaryPrizeCount(\n      3,\n      _canaryShares,\n      _reserveShares,\n      _tierShares\n    );\n    CANARY_PRIZE_COUNT_FOR_4_TIERS = TierCalculationLib.canaryPrizeCount(\n      4,\n      _canaryShares,\n      _reserveShares,\n      _tierShares\n    );\n    CANARY_PRIZE_COUNT_FOR_5_TIERS = TierCalculationLib.canaryPrizeCount(\n      5,\n      _canaryShares,\n      _reserveShares,\n      _tierShares\n    );\n    CANARY_PRIZE_COUNT_FOR_6_TIERS = TierCalculationLib.canaryPrizeCount(\n      6,\n      _canaryShares,\n      _reserveShares,\n      _tierShares\n    );\n    CANARY_PRIZE_COUNT_FOR_7_TIERS = TierCalculationLib.canaryPrizeCount(\n      7,\n      _canaryShares,\n      _reserveShares,\n      _tierShares\n    );\n    CANARY_PRIZE_COUNT_FOR_8_TIERS = TierCalculationLib.canaryPrizeCount(\n      8,\n      _canaryShares,\n      _reserveShares,\n      _tierShares\n    );\n    CANARY_PRIZE_COUNT_FOR_9_TIERS = TierCalculationLib.canaryPrizeCount(\n      9,\n      _canaryShares,\n      _reserveShares,\n      _tierShares\n    );\n    CANARY_PRIZE_COUNT_FOR_10_TIERS = TierCalculationLib.canaryPrizeCount(\n      10,\n      _canaryShares,\n      _reserveShares,\n      _tierShares\n    );\n    CANARY_PRIZE_COUNT_FOR_11_TIERS = TierCalculationLib.canaryPrizeCount(\n      11,\n      _canaryShares,\n      _reserveShares,\n      _tierShares\n    );\n    CANARY_PRIZE_COUNT_FOR_12_TIERS = TierCalculationLib.canaryPrizeCount(\n      12,\n      _canaryShares,\n      _reserveShares,\n      _tierShares\n    );\n    CANARY_PRIZE_COUNT_FOR_13_TIERS = TierCalculationLib.canaryPrizeCount(\n      13,\n      _canaryShares,\n      _reserveShares,\n      _tierShares\n    );\n    CANARY_PRIZE_COUNT_FOR_14_TIERS = TierCalculationLib.canaryPrizeCount(\n      14,\n      _canaryShares,\n      _reserveShares,\n      _tierShares\n    );\n\n    if (_numberOfTiers < MINIMUM_NUMBER_OF_TIERS) {\n      revert NumberOfTiersLessThanMinimum(_numberOfTiers);\n    }\n    if (_numberOfTiers > MAXIMUM_NUMBER_OF_TIERS) {\n      revert NumberOfTiersGreaterThanMaximum(_numberOfTiers);\n    }\n  }\n\n  /// @notice Adjusts the number of tiers and distributes new liquidity.\n  /// @param _nextNumberOfTiers The new number of tiers. Must be greater than minimum\n  /// @param _prizeTokenLiquidity The amount of fresh liquidity to distribute across the tiers and reserve\n  function _nextDraw(uint8 _nextNumberOfTiers, uint96 _prizeTokenLiquidity) internal {\n    if (_nextNumberOfTiers < MINIMUM_NUMBER_OF_TIERS) {\n      revert NumberOfTiersLessThanMinimum(_nextNumberOfTiers);\n    }\n\n    uint8 numTiers = numberOfTiers;\n    UD60x18 _prizeTokenPerShare = fromUD34x4toUD60x18(prizeTokenPerShare);\n    (\n      uint16 closedDrawId,\n      uint104 newReserve,\n      UD60x18 newPrizeTokenPerShare\n    ) = _computeNewDistributions(\n        numTiers,\n        _nextNumberOfTiers,\n        _prizeTokenPerShare,\n        _prizeTokenLiquidity\n      );\n\n    // need to redistribute to the canary tier and any new tiers (if expanding)\n    uint8 start;\n    uint8 end;\n    // if we are expanding, need to reset the canary tier and all of the new tiers\n    if (_nextNumberOfTiers > numTiers) {\n      start = numTiers - 1;\n      end = _nextNumberOfTiers;\n    } else {\n      // just reset the canary tier\n      start = _nextNumberOfTiers - 1;\n      end = _nextNumberOfTiers;\n    }\n    for (uint8 i = start; i < end; i++) {\n      _tiers[i] = Tier({\n        drawId: closedDrawId,\n        prizeTokenPerShare: prizeTokenPerShare,\n        prizeSize: uint96(\n          _computePrizeSize(i, _nextNumberOfTiers, _prizeTokenPerShare, newPrizeTokenPerShare)\n        )\n      });\n    }\n\n    prizeTokenPerShare = fromUD60x18toUD34x4(newPrizeTokenPerShare);\n    numberOfTiers = _nextNumberOfTiers;\n    lastClosedDrawId = closedDrawId;\n    _reserve += newReserve;\n  }\n\n  /// @notice Computes the liquidity that will be distributed for the next draw given the next number of tiers and prize liquidity.\n  /// @param _numberOfTiers The current number of tiers\n  /// @param _nextNumberOfTiers The next number of tiers to use to compute distribution\n  /// @param _prizeTokenLiquidity The amount of fresh liquidity to distribute across the tiers and reserve\n  /// @return closedDrawId The drawId that this is for\n  /// @return newReserve The amount of liquidity that will be added to the reserve\n  /// @return newPrizeTokenPerShare The new prize token per share\n  function _computeNewDistributions(\n    uint8 _numberOfTiers,\n    uint8 _nextNumberOfTiers,\n    uint256 _prizeTokenLiquidity\n  ) internal view returns (uint16 closedDrawId, uint104 newReserve, UD60x18 newPrizeTokenPerShare) {\n    return\n      _computeNewDistributions(\n        _numberOfTiers,\n        _nextNumberOfTiers,\n        fromUD34x4toUD60x18(prizeTokenPerShare),\n        _prizeTokenLiquidity\n      );\n  }\n\n  /// @notice Computes the liquidity that will be distributed for the next draw given the next number of tiers and prize liquidity.\n  /// @param _numberOfTiers The current number of tiers\n  /// @param _nextNumberOfTiers The next number of tiers to use to compute distribution\n  /// @param _currentPrizeTokenPerShare The current prize token per share\n  /// @param _prizeTokenLiquidity The amount of fresh liquidity to distribute across the tiers and reserve\n  /// @return closedDrawId The drawId that this is for\n  /// @return newReserve The amount of liquidity that will be added to the reserve\n  /// @return newPrizeTokenPerShare The new prize token per share\n  function _computeNewDistributions(\n    uint8 _numberOfTiers,\n    uint8 _nextNumberOfTiers,\n    UD60x18 _currentPrizeTokenPerShare,\n    uint _prizeTokenLiquidity\n  ) internal view returns (uint16 closedDrawId, uint104 newReserve, UD60x18 newPrizeTokenPerShare) {\n    closedDrawId = lastClosedDrawId + 1;\n    uint256 totalShares = _getTotalShares(_nextNumberOfTiers);\n    UD60x18 deltaPrizeTokensPerShare = (toUD60x18(_prizeTokenLiquidity).div(toUD60x18(totalShares)))\n      .floor();\n\n    newPrizeTokenPerShare = _currentPrizeTokenPerShare.add(deltaPrizeTokensPerShare);\n\n    uint reclaimed = _getTierLiquidityToReclaim(\n      _numberOfTiers,\n      _nextNumberOfTiers,\n      _currentPrizeTokenPerShare\n    );\n    uint computedLiquidity = fromUD60x18(deltaPrizeTokensPerShare.mul(toUD60x18(totalShares)));\n    uint remainder = (_prizeTokenLiquidity - computedLiquidity);\n\n    newReserve = uint104(\n      fromUD60x18(deltaPrizeTokensPerShare.mul(toUD60x18(reserveShares))) + // reserve portion\n        reclaimed + // reclaimed liquidity from tiers\n        remainder // remainder\n    );\n  }\n\n  /// @notice Returns the prize size for the given tier.\n  /// @param _tier The tier to retrieve\n  /// @return The prize size for the tier\n  function getTierPrizeSize(uint8 _tier) external view returns (uint96) {\n    return _getTier(_tier, numberOfTiers).prizeSize;\n  }\n\n  /// @notice Returns the estimated number of prizes for the given tier.\n  /// @param _tier The tier to retrieve\n  /// @return The estimated number of prizes\n  function getTierPrizeCount(uint8 _tier) external view returns (uint32) {\n    return _getTierPrizeCount(_tier, numberOfTiers);\n  }\n\n  /// @notice Returns the estimated number of prizes for the given tier and number of tiers.\n  /// @param _tier The tier to retrieve\n  /// @param _numberOfTiers The number of tiers, should match the current number of tiers\n  /// @return The estimated number of prizes\n  function getTierPrizeCount(uint8 _tier, uint8 _numberOfTiers) external view returns (uint32) {\n    return _getTierPrizeCount(_tier, _numberOfTiers);\n  }\n\n  /// @notice Returns the number of available prizes for the given tier.\n  /// @param _tier The tier to retrieve\n  /// @param _numberOfTiers The number of tiers, should match the current number of tiers\n  /// @return The number of available prizes\n  function _getTierPrizeCount(uint8 _tier, uint8 _numberOfTiers) internal view returns (uint32) {\n    return\n      _isCanaryTier(_tier, _numberOfTiers)\n        ? _canaryPrizeCount(_numberOfTiers)\n        : uint32(TierCalculationLib.prizeCount(_tier));\n  }\n\n  /// @notice Retrieves an up-to-date Tier struct for the given tier.\n  /// @param _tier The tier to retrieve\n  /// @param _numberOfTiers The number of tiers, should match the current. Passed explicitly as an optimization\n  /// @return An up-to-date Tier struct; if the prize is outdated then it is recomputed based on available liquidity and the draw id updated.\n  function _getTier(uint8 _tier, uint8 _numberOfTiers) internal view returns (Tier memory) {\n    Tier memory tier = _tiers[_tier];\n    uint16 _lastClosedDrawId = lastClosedDrawId;\n    if (tier.drawId != _lastClosedDrawId) {\n      tier.drawId = _lastClosedDrawId;\n      tier.prizeSize = uint96(\n        _computePrizeSize(\n          _tier,\n          _numberOfTiers,\n          fromUD34x4toUD60x18(tier.prizeTokenPerShare),\n          fromUD34x4toUD60x18(prizeTokenPerShare)\n        )\n      );\n    }\n    return tier;\n  }\n\n  /// @notice Computes the total shares in the system. That is `(number of tiers * tier shares) + canary shares + reserve shares`.\n  /// @return The total shares\n  function getTotalShares() external view returns (uint256) {\n    return _getTotalShares(numberOfTiers);\n  }\n\n  /// @notice Computes the total shares in the system given the number of tiers. That is `(number of tiers * tier shares) + canary shares + reserve shares`.\n  /// @param _numberOfTiers The number of tiers to calculate the total shares for\n  /// @return The total shares\n  function _getTotalShares(uint8 _numberOfTiers) internal view returns (uint256) {\n    return\n      uint256(_numberOfTiers - 1) *\n      uint256(tierShares) +\n      uint256(canaryShares) +\n      uint256(reserveShares);\n  }\n\n  /// @notice Computes the number of shares for the given tier. If the tier is the canary tier, then the canary shares are returned. Normal tier shares otherwise.\n  /// @param _tier The tier to request share for\n  /// @param _numTiers The number of tiers. Passed explicitly as an optimization\n  /// @return The number of shares for the given tier\n  function _computeShares(uint8 _tier, uint8 _numTiers) internal view returns (uint8) {\n    return _isCanaryTier(_tier, _numTiers) ? canaryShares : tierShares;\n  }\n\n  /// @notice Consumes liquidity from the given tier.\n  /// @param _tierStruct The tier to consume liquidity from\n  /// @param _tier The tier number\n  /// @param _liquidity The amount of liquidity to consume\n  /// @return An updated Tier struct after consumption\n  function _consumeLiquidity(\n    Tier memory _tierStruct,\n    uint8 _tier,\n    uint104 _liquidity\n  ) internal returns (Tier memory) {\n    uint8 _shares = _computeShares(_tier, numberOfTiers);\n    uint104 remainingLiquidity = uint104(\n      fromUD60x18(\n        _getTierRemainingLiquidity(\n          _shares,\n          fromUD34x4toUD60x18(_tierStruct.prizeTokenPerShare),\n          fromUD34x4toUD60x18(prizeTokenPerShare)\n        )\n      )\n    );\n    if (_liquidity > remainingLiquidity) {\n      uint104 excess = _liquidity - remainingLiquidity;\n      if (excess > _reserve) {\n        revert InsufficientLiquidity(_liquidity);\n      }\n      _reserve -= excess;\n      emit ReserveConsumed(excess);\n      _tierStruct.prizeTokenPerShare = prizeTokenPerShare;\n    } else {\n      UD34x4 delta = fromUD60x18toUD34x4(toUD60x18(_liquidity).div(toUD60x18(_shares)));\n      _tierStruct.prizeTokenPerShare = UD34x4.wrap(\n        UD34x4.unwrap(_tierStruct.prizeTokenPerShare) + UD34x4.unwrap(delta)\n      );\n    }\n    _tiers[_tier] = _tierStruct;\n    return _tierStruct;\n  }\n\n  /// @notice Computes the prize size of the given tier.\n  /// @param _tier The tier to compute the prize size of\n  /// @param _numberOfTiers The current number of tiers\n  /// @param _tierPrizeTokenPerShare The prizeTokenPerShare of the Tier struct\n  /// @param _prizeTokenPerShare The global prizeTokenPerShare\n  /// @return The prize size\n  function _computePrizeSize(\n    uint8 _tier,\n    uint8 _numberOfTiers,\n    UD60x18 _tierPrizeTokenPerShare,\n    UD60x18 _prizeTokenPerShare\n  ) internal view returns (uint256) {\n    uint256 prizeSize;\n    if (_prizeTokenPerShare.gt(_tierPrizeTokenPerShare)) {\n      if (_isCanaryTier(_tier, _numberOfTiers)) {\n        prizeSize = _computePrizeSize(\n          _tierPrizeTokenPerShare,\n          _prizeTokenPerShare,\n          _canaryPrizeCountFractional(_numberOfTiers),\n          canaryShares\n        );\n      } else {\n        prizeSize = _computePrizeSize(\n          _tierPrizeTokenPerShare,\n          _prizeTokenPerShare,\n          toUD60x18(TierCalculationLib.prizeCount(_tier)),\n          tierShares\n        );\n      }\n    }\n    return prizeSize;\n  }\n\n  /// @notice Computes the prize size with the given parameters.\n  /// @param _tierPrizeTokenPerShare The prizeTokenPerShare of the Tier struct\n  /// @param _prizeTokenPerShare The global prizeTokenPerShare\n  /// @param _fractionalPrizeCount The prize count as UD60x18\n  /// @param _shares The number of shares that the tier has\n  /// @return The prize size\n  function _computePrizeSize(\n    UD60x18 _tierPrizeTokenPerShare,\n    UD60x18 _prizeTokenPerShare,\n    UD60x18 _fractionalPrizeCount,\n    uint8 _shares\n  ) internal pure returns (uint256) {\n    return\n      fromUD60x18(\n        _prizeTokenPerShare.sub(_tierPrizeTokenPerShare).mul(toUD60x18(_shares)).div(\n          _fractionalPrizeCount\n        )\n      );\n  }\n\n  function _isCanaryTier(uint8 _tier, uint8 _numberOfTiers) internal pure returns (bool) {\n    return _tier == _numberOfTiers - 1;\n  }\n\n  /// @notice Reclaims liquidity from tiers, starting at the highest tier.\n  /// @param _numberOfTiers The existing number of tiers\n  /// @param _nextNumberOfTiers The next number of tiers. Must be less than _numberOfTiers\n  /// @return The total reclaimed liquidity\n  function _getTierLiquidityToReclaim(\n    uint8 _numberOfTiers,\n    uint8 _nextNumberOfTiers,\n    UD60x18 _prizeTokenPerShare\n  ) internal view returns (uint256) {\n    UD60x18 reclaimedLiquidity;\n    // need to redistribute to the canary tier and any new tiers (if expanding)\n    uint8 start;\n    uint8 end;\n    // if we are expanding, need to reset the canary tier and all of the new tiers\n    if (_nextNumberOfTiers < _numberOfTiers) {\n      start = _nextNumberOfTiers - 1;\n      end = _numberOfTiers;\n    } else {\n      // just reset the canary tier\n      start = _numberOfTiers - 1;\n      end = _numberOfTiers;\n    }\n    for (uint8 i = start; i < end; i++) {\n      Tier memory tierLiquidity = _tiers[i];\n      uint8 shares = _computeShares(i, _numberOfTiers);\n      UD60x18 liq = _getTierRemainingLiquidity(\n        shares,\n        fromUD34x4toUD60x18(tierLiquidity.prizeTokenPerShare),\n        _prizeTokenPerShare\n      );\n      reclaimedLiquidity = reclaimedLiquidity.add(liq);\n    }\n    return fromUD60x18(reclaimedLiquidity);\n  }\n\n  /// @notice Computes the remaining liquidity available to a tier.\n  /// @param _tier The tier to compute the liquidity for\n  /// @return The remaining liquidity\n  function getTierRemainingLiquidity(uint8 _tier) external view returns (uint256) {\n    uint8 _numTiers = numberOfTiers;\n    return\n      fromUD60x18(\n        _getTierRemainingLiquidity(\n          _computeShares(_tier, _numTiers),\n          fromUD34x4toUD60x18(_getTier(_tier, _numTiers).prizeTokenPerShare),\n          fromUD34x4toUD60x18(prizeTokenPerShare)\n        )\n      );\n  }\n\n  /// @notice Computes the remaining tier liquidity.\n  /// @param _shares The number of shares that the tier has (can be tierShares or canaryShares)\n  /// @param _tierPrizeTokenPerShare The prizeTokenPerShare of the Tier struct\n  /// @param _prizeTokenPerShare The global prizeTokenPerShare\n  /// @return The remaining available liquidity\n  function _getTierRemainingLiquidity(\n    uint256 _shares,\n    UD60x18 _tierPrizeTokenPerShare,\n    UD60x18 _prizeTokenPerShare\n  ) internal pure returns (UD60x18) {\n    if (_tierPrizeTokenPerShare.gte(_prizeTokenPerShare)) {\n      return ud(0);\n    }\n    UD60x18 delta = _prizeTokenPerShare.sub(_tierPrizeTokenPerShare);\n    return delta.mul(toUD60x18(_shares));\n  }\n\n  /// @notice Retrieves the id of the next draw to be closed.\n  /// @return The next draw id\n  function getOpenDrawId() external view returns (uint16) {\n    return lastClosedDrawId + 1;\n  }\n\n  /// @notice Estimates the number of prizes that will be awarded.\n  /// @return The estimated prize count\n  function estimatedPrizeCount() external view returns (uint32) {\n    return _estimatedPrizeCount(numberOfTiers);\n  }\n\n  /// @notice Estimates the number of prizes that will be awarded given a number of tiers.\n  /// @param numTiers The number of tiers\n  /// @return The estimated prize count for the given number of tiers\n  function estimatedPrizeCount(uint8 numTiers) external pure returns (uint32) {\n    return _estimatedPrizeCount(numTiers);\n  }\n\n  /// @notice Returns the number of canary prizes as a fraction. This allows the canary prize size to accurately represent the number of tiers + 1.\n  /// @param numTiers The number of prize tiers\n  /// @return The number of canary prizes\n  function canaryPrizeCountFractional(uint8 numTiers) external view returns (UD60x18) {\n    return _canaryPrizeCountFractional(numTiers);\n  }\n\n  /// @notice Computes the number of canary prizes for the last closed draw.\n  /// @return The number of canary prizes\n  function canaryPrizeCount() external view returns (uint32) {\n    return _canaryPrizeCount(numberOfTiers);\n  }\n\n  /// @notice Computes the number of canary prizes for the last closed draw\n  /// @param _numberOfTiers The number of tiers\n  /// @return The number of canary prizes\n  function _canaryPrizeCount(uint8 _numberOfTiers) internal view returns (uint32) {\n    return uint32(fromUD60x18(_canaryPrizeCountFractional(_numberOfTiers).floor()));\n  }\n\n  /// @notice Computes the number of canary prizes given the number of tiers.\n  /// @param _numTiers The number of prize tiers\n  /// @return The num"
    }
  ]
}