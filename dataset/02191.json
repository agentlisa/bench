{
  "Title": "M-26: Vault could `rebalance()` before funds arrive from xChainController",
  "Content": "# Issue M-26: Vault could `rebalance()` before funds arrive from xChainController \n\nSource: https://github.com/sherlock-audit/2023-01-derby-judging/issues/268 \n\n## Found by \nCh\\_301\n\n## Summary\nInvoke [sendFundsToVault()](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XChainController.sol#L409-L441) to Push funds from xChainController to vaults. which is call [xTransferToVaults()](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L362-L377)\n\nFor the cross-chain rebalancing `xTransferToVaults()` will execute this logic \n```solidity\n       ...\n      pushFeedbackToVault(_chainId, _vault, _relayerFee);\n      xTransfer(_asset, _amount, _vault, _chainId, _slippage, _relayerFee);\n       ...\n```\n- [pushFeedbackToVault()](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L384-L389) Is to invoke [receiveFunds()](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/MainVault.sol#L330-L333) \n`pushFeedbackToVault()` always [travel through the slow path](https://docs.connext.network/concepts/how-it-works/transaction-flow#requirements-1)\n- [xTransfer()](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L133-L161) to transfer funds from one chain to another\nIf fast liquidity is not available, the `xTransfer()` will go through the **slow path**.\n\nThe vulnerability is if the `xcall()` of `pushFeedbackToVault()` excited successfully before `xTransfer()` transfer the funds to the vault, anyone can invoke [rebalance()](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Vault.sol#L135-L154) this will lead to rebalancing Vaults with Imperfect funds (this could be true only if funds that are expected to be received from XChainController are greater than `reservedFunds` and `liquidityPerc` together )\n\n## Vulnerability Detail\nThe above scenario could be done in two possible cases \n1-  `xTransfer()` will go through the **slow path** but because [High Slippage](https://docs.connext.network/developers/guides/handling-failures#high-slippage) the cross-chain message will wait until slippage conditions improve (relayers will continuously re-attempt the transfer execution).\n\n2- [Connext Team says](https://discord.com/channels/454734546869551114/941007820768280587/1051555409376333834) \n```diff\nAll messages are added to a Merkle root which is sent across chains every 30 mins\nAnd then those messages are executed by off-chain actors called routers\n\nso it is indeed possible that messages are received out of order (and potentially with increased latency in between due to batch times) \nFor \"fast path\" (unauthenticated) messages, latency is not a concern, but ordering may still be (this is an artifact of the chain itself too btw)\none thing you can do is add a nonce to your messages so that you can yourself order them at destination\n```\nso `pushFeedbackToVault()` and `xTransfer()` could be added to a different Merkle root and this will lead to executing `receiveFunds()` before funds arrive.\n\n## Impact\nThe vault could `rebalance()` before funds arrive from xChainController, this will reduce rewards\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nCheck if funds are arrived or not \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/13",
  "Code": [
    {
      "filename": "derby-yield-optimiser/contracts/XChainController.sol",
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"./Interfaces/IXProvider.sol\";\r\n\r\ncontract XChainController {\r\n  using SafeERC20 for IERC20;\r\n\r\n  struct vaultInfo {\r\n    int256 totalCurrentAllocation;\r\n    uint256 totalUnderlying;\r\n    uint256 totalSupply;\r\n    uint256 totalWithdrawalRequests;\r\n    // (chainId => bool): true == off // false == on\r\n    mapping(uint32 => bool) chainIdOff;\r\n    // (chainId => currentAllocation)\r\n    mapping(uint32 => int256) currentAllocationPerChain;\r\n    // (chainId => totalUnderlying)\r\n    mapping(uint32 => uint256) totalUnderlyingPerChain;\r\n    // (chainId => vaultAddress)\r\n    mapping(uint32 => address) vaultChainAddress;\r\n    // (chainId => underlyingAddress): e.g USDC\r\n    mapping(uint32 => address) vaultUnderlyingAddress;\r\n    // (chainId => totalWithdrawalRequests): total withdrawal requests in LP Token\r\n    mapping(uint32 => uint256) withdrawalRequests;\r\n    // (chainId => amountToDeposit)\r\n    mapping(uint32 => uint256) amountToDepositPerChain;\r\n  }\r\n\r\n  // activeVaults; number of active vaults for vaultNumber, set in XChainRebalance\r\n  // stage 0 Ready; waiting for game to send allocations\r\n  // stage 1 AllocationsReceived; allocations received from game, ready to rebalance XChain and set activeVaults\r\n  // stage 2 UnderlyingReceived; underlyings received from all active vault contracts\r\n  // stage 3 FundsReceived; funds received from all active vault contracts\r\n  struct vaultStages {\r\n    uint256 activeVaults;\r\n    bool ready; // stage 0\r\n    bool allocationsReceived; // stage 1\r\n    uint256 underlyingReceived; // stage 2\r\n    uint256 fundsReceived; // stage 3\r\n    uint256 fundsSent; // stage 4\r\n  }\r\n\r\n  address private dao;\r\n  address private guardian;\r\n  address public game;\r\n  address public xProviderAddr;\r\n  IXProvider public xProvider;\r\n\r\n  uint32[] public chainIds;\r\n  uint32 public homeChain;\r\n  int256 public minimumAmount;\r\n\r\n  // (vaultNumber => vaultInfo struct)\r\n  mapping(uint256 => vaultInfo) internal vaults;\r\n  // (vaultNumber => vaultStages struct)\r\n  mapping(uint256 => vaultStages) public vaultStage;\r\n\r\n  event SendXChainAmount(\r\n    address _vault,\r\n    uint32 _chainId,\r\n    uint256 _amountToSendXChain,\r\n    uint256 _exchangeRate,\r\n    bool _receivingFunds\r\n  );\r\n\r\n  event SentFundsToVault(address _vault, uint32 _chainId, uint256 _amount, address _asset);\r\n\r\n  modifier onlyGame() {\r\n    require(msg.sender == game, \"xController: only Game\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyDao() {\r\n    require(msg.sender == dao, \"xController: only DAO\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyGuardian() {\r\n    require(msg.sender == guardian, \"xController: only Guardian\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyXProvider() {\r\n    require(msg.sender == address(xProvider), \"xController: only xProviderAddr\");\r\n    _;\r\n  }\r\n\r\n  // vaultStage 0\r\n  modifier onlyWhenReady(uint256 _vaultNumber) {\r\n    require(vaultStage[_vaultNumber].ready, \"Not all vaults are ready\");\r\n    _;\r\n  }\r\n\r\n  // vaultStage 1\r\n  modifier onlyWhenAllocationsReceived(uint256 _vaultNumber) {\r\n    require(vaultStage[_vaultNumber].allocationsReceived, \"Allocations not received from game\");\r\n    _;\r\n  }\r\n\r\n  // vaultStage 2\r\n  modifier onlyWhenUnderlyingsReceived(uint256 _vaultNumber) {\r\n    require(\r\n      vaultStage[_vaultNumber].underlyingReceived == vaultStage[_vaultNumber].activeVaults,\r\n      \"Not all underlyings received\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  // vaultStage 3\r\n  modifier onlyWhenFundsReceived(uint256 _vaultNumber) {\r\n    require(\r\n      vaultStage[_vaultNumber].fundsReceived == vaultStage[_vaultNumber].activeVaults,\r\n      \"Not all funds received\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  constructor(address _game, address _dao, address _guardian, uint32 _homeChain) {\r\n    game = _game;\r\n    dao = _dao;\r\n    guardian = _guardian;\r\n    homeChain = _homeChain;\r\n    minimumAmount = 1000e6;\r\n  }\r\n\r\n  /// @notice Setter for number of active vaults for vaultNumber, set in xChainRebalance\r\n  /// @param _vaultNumber Number of the vault\r\n  /// @param _activeVaults Number active vaults, calculated in xChainRebalance\r\n  function setActiveVaults(uint256 _vaultNumber, uint256 _activeVaults) internal {\r\n    vaultStage[_vaultNumber].activeVaults = _activeVaults;\r\n  }\r\n\r\n  /// @notice Setter for stage 0:\r\n  /// @notice Ready; waiting for game to send allocations\r\n  function setReady(uint256 _vaultNumber, bool _state) internal {\r\n    vaultStage[_vaultNumber].ready = _state;\r\n  }\r\n\r\n  /// @notice Setter for stage 1:\r\n  /// @notice AllocationsReceived; allocations received from game, ready to rebalance XChain and set activeVaults\r\n  function setAllocationsReceived(\r\n    uint256 _vaultNumber,\r\n    bool _state\r\n  ) internal onlyWhenReady(_vaultNumber) {\r\n    vaultStage[_vaultNumber].allocationsReceived = _state;\r\n  }\r\n\r\n  /// @notice Setter to tick up stage 2:\r\n  /// @notice UnderlyingReceived; underlyings received from all active vault contracts\r\n  function upUnderlyingReceived(\r\n    uint256 _vaultNumber\r\n  ) internal onlyWhenAllocationsReceived(_vaultNumber) {\r\n    vaultStage[_vaultNumber].underlyingReceived++;\r\n  }\r\n\r\n  /// @notice Step 4 end; Push funds from vaults to xChainController\r\n  /// @notice FundsReceived; funds received from all active vault contracts\r\n  function upFundsReceived(\r\n    uint256 _vaultNumber\r\n  ) external onlyXProvider onlyWhenUnderlyingsReceived(_vaultNumber) {\r\n    vaultStage[_vaultNumber].fundsReceived++;\r\n  }\r\n\r\n  /// @notice Resets all stages in vaultStage struct for a vaultNumber\r\n  function resetVaultStages(uint256 _vaultNumber) internal {\r\n    vaultStage[_vaultNumber].ready = true;\r\n    vaultStage[_vaultNumber].allocationsReceived = false;\r\n    vaultStage[_vaultNumber].underlyingReceived = 0;\r\n    vaultStage[_vaultNumber].fundsReceived = 0;\r\n    vaultStage[_vaultNumber].fundsSent = 0;\r\n  }\r\n\r\n  /// @notice Resets underlying for a vaultNumber at the start of a rebalancing period\r\n  function resetVaultUnderlying(uint256 _vaultNumber) internal {\r\n    vaults[_vaultNumber].totalUnderlying = 0;\r\n    vaultStage[_vaultNumber].underlyingReceived = 0;\r\n    vaults[_vaultNumber].totalSupply = 0;\r\n  }\r\n\r\n  /// @notice Resets underlying for a vaultNumber per chainId at the start of a rebalancing period\r\n  function resetVaultUnderlyingForChain(uint256 _vaultNumber, uint32 _chainId) internal {\r\n    vaults[_vaultNumber].totalUnderlyingPerChain[_chainId] = 0;\r\n  }\r\n\r\n  /// @notice Step 1 end; Game pushes totalDeltaAllocations to xChainController\r\n  /// @param _vaultNumber Number of Vault\r\n  /// @param _deltas Delta allocations array received from game, indexes match chainIds[] set in this contract\r\n  function receiveAllocationsFromGame(\r\n    uint256 _vaultNumber,\r\n    int256[] memory _deltas\r\n  ) external onlyXProvider onlyWhenReady(_vaultNumber) {\r\n    return receiveAllocationsFromGameInt(_vaultNumber, _deltas);\r\n  }\r\n\r\n  /// @notice Step 1 end; Game pushes totalDeltaAllocations to xChainController\r\n  /// @param _vaultNumber Number of Vault\r\n  /// @param _deltas Delta allocations array received from game, indexes match chainIds[] set in this contract\r\n  function receiveAllocationsFromGameInt(uint256 _vaultNumber, int256[] memory _deltas) internal {\r\n    uint256 activeVaults;\r\n\r\n    for (uint256 i = 0; i < chainIds.length; i++) {\r\n      uint32 chain = chainIds[i];\r\n      activeVaults += settleCurrentAllocation(_vaultNumber, chain, _deltas[i]);\r\n      resetVaultUnderlyingForChain(_vaultNumber, chain);\r\n    }\r\n\r\n    resetVaultUnderlying(_vaultNumber);\r\n    setActiveVaults(_vaultNumber, activeVaults);\r\n    setAllocationsReceived(_vaultNumber, true);\r\n    setReady(_vaultNumber, false);\r\n  }\r\n\r\n  /// @notice Helper to settle the total current allocation with the delta allocations received from Game\r\n  /// @notice Will set a chainId on/off depending on the currentAllocation and incoming deltaAllocation\r\n  /// @dev if currentAllocation = 0 and deltaAllocation = 0, chainId will be set to Off and feedback will be send to vault\r\n  /// @param _vaultNumber Number of Vault\r\n  /// @param _chainId Number of chain used\r\n  /// @param _deltas Delta allocations array received from game, indexes match chainIds[] set in this contract\r\n  function settleCurrentAllocation(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    int256 _deltas\r\n  ) internal returns (uint256 activeVault) {\r\n    if (getCurrentAllocation(_vaultNumber, _chainId) == 0 && _deltas == 0) {\r\n      vaults[_vaultNumber].chainIdOff[_chainId] = true;\r\n      activeVault = 0;\r\n    } else {\r\n      vaults[_vaultNumber].chainIdOff[_chainId] = false;\r\n      activeVault = 1;\r\n    }\r\n\r\n    vaults[_vaultNumber].totalCurrentAllocation += _deltas;\r\n    vaults[_vaultNumber].currentAllocationPerChain[_chainId] += _deltas;\r\n\r\n    require(vaults[_vaultNumber].totalCurrentAllocation >= 0, \"Allocation underflow\");\r\n  }\r\n\r\n  /// @notice Will send feedback to the vault if it is turned on or off by settleCurrentAllocation\r\n  /// @notice Step 1.5, toggle vault on or off\r\n  /// @param _vaultNumber Number of vault\r\n  /// @param _chainId Chain id of the vault where the funds need to be sent\r\n  function sendFeedbackToVault(uint256 _vaultNumber, uint32 _chainId) external payable {\r\n    address vault = getVaultAddress(_vaultNumber, _chainId);\r\n    require(vault != address(0), \"xChainController: not a valid vaultnumber\");\r\n    xProvider.pushStateFeedbackToVault{value: msg.value}(\r\n      vault,\r\n      _chainId,\r\n      vaults[_vaultNumber].chainIdOff[_chainId]\r\n    );\r\n  }\r\n\r\n  /// @notice See setTotalUnderlyingInt below\r\n  function setTotalUnderlying(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    uint256 _underlying,\r\n    uint256 _totalSupply,\r\n    uint256 _withdrawalRequests\r\n  ) external onlyXProvider onlyWhenAllocationsReceived(_vaultNumber) {\r\n    require(getTotalUnderlyingOnChain(_vaultNumber, _chainId) == 0, \"TotalUnderlying already set\");\r\n    setTotalUnderlyingInt(_vaultNumber, _chainId, _underlying, _totalSupply, _withdrawalRequests);\r\n  }\r\n\r\n  /// @notice Step 2 end; Vaults push totalUnderlying, totalSupply and totalWithdrawalRequests to xChainController\r\n  /// @notice Receive and set totalUnderlyings from the vaults for every chainId\r\n  /// @param _vaultNumber number of the vault\r\n  /// @param _chainId Number of chain used\r\n  /// @param _underlying totalUnderling plus vault balance in vaultcurrency e.g USDC\r\n  /// @param _totalSupply Supply of the LP token of the vault on given chainId\r\n  /// @param _withdrawalRequests Total amount of withdrawal requests from the vault in LP Tokens\r\n  function setTotalUnderlyingInt(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    uint256 _underlying,\r\n    uint256 _totalSupply,\r\n    uint256 _withdrawalRequests\r\n  ) internal {\r\n    vaults[_vaultNumber].totalUnderlyingPerChain[_chainId] = _underlying;\r\n    vaults[_vaultNumber].withdrawalRequests[_chainId] = _withdrawalRequests;\r\n    vaults[_vaultNumber].totalSupply += _totalSupply;\r\n    vaults[_vaultNumber].totalUnderlying += _underlying;\r\n    vaults[_vaultNumber].totalWithdrawalRequests += _withdrawalRequests;\r\n    vaultStage[_vaultNumber].underlyingReceived++;\r\n  }\r\n\r\n  /// @notice Step 3 trigger; xChainController pushes exchangeRate and amount the vaults have to send back to all vaults\r\n  /// @notice Calculates the amounts the vaults on each chainId have to send or receive\r\n  /// @param _vaultNumber Number of vault\r\n  /// @param _chain Chain id of the vault where the funds need to be sent\r\n  function pushVaultAmounts(\r\n    uint256 _vaultNumber,\r\n    uint16 _chain\r\n  ) external payable onlyWhenUnderlyingsReceived(_vaultNumber) {\r\n    address vault = getVaultAddress(_vaultNumber, _chain);\r\n    require(vault != address(0), \"xChainController: not a valid vaultnumber\");\r\n    int256 totalAllocation = getCurrentTotalAllocation(_vaultNumber);\r\n    uint256 totalWithdrawalRequests = getTotalWithdrawalRequests(_vaultNumber);\r\n    uint256 totalUnderlying = getTotalUnderlyingVault(_vaultNumber) - totalWithdrawalRequests;\r\n    uint256 totalSupply = getTotalSupply(_vaultNumber);\r\n\r\n    uint256 decimals = xProvider.getDecimals(vault);\r\n    uint256 newExchangeRate = (totalUnderlying * (10 ** decimals)) / totalSupply;\r\n\r\n    if (!getVaultChainIdOff(_vaultNumber, _chain)) {\r\n      int256 amountToChain = calcAmountToChain(\r\n        _vaultNumber,\r\n        _chain,\r\n        totalUnderlying,\r\n        totalAllocation\r\n      );\r\n      (int256 amountToDeposit, uint256 amountToWithdraw) = calcDepositWithdraw(\r\n        _vaultNumber,\r\n        _chain,\r\n        amountToChain\r\n      );\r\n\r\n      sendXChainAmount(_vaultNumber, _chain, amountToDeposit, amountToWithdraw, newExchangeRate);\r\n    }\r\n  }\r\n\r\n  /// @notice Calculates the amounts the vaults on each chainId have to send or receive\r\n  /// @param _vaultNumber number of the vault\r\n  /// @param _chainId Number of chain used\r\n  /// @param _amountToChain Amount in vaultcurrency that should be on given chainId\r\n  function calcDepositWithdraw(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    int256 _amountToChain\r\n  ) internal view returns (int256, uint256) {\r\n    uint256 currentUnderlying = getTotalUnderlyingOnChain(_vaultNumber, _chainId);\r\n\r\n    int256 amountToDeposit = _amountToChain - int256(currentUnderlying);\r\n    uint256 amountToWithdraw = amountToDeposit < 0\r\n      ? currentUnderlying - uint256(_amountToChain)\r\n      : 0;\r\n\r\n    return (amountToDeposit, amountToWithdraw);\r\n  }\r\n\r\n  /// @notice Calculates the amounts the vaults has to send back to the xChainController\r\n  /// @param _totalUnderlying Total underlying on all chains for given vaultNumber\r\n  /// @param _totalAllocation Total allocation on all chains for given vaultNumber\r\n  function calcAmountToChain(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    uint256 _totalUnderlying,\r\n    int256 _totalAllocation\r\n  ) internal view returns (int256) {\r\n    int256 allocation = getCurrentAllocation(_vaultNumber, _chainId);\r\n    uint256 withdrawalRequests = getWithdrawalRequests(_vaultNumber, _chainId);\r\n\r\n    int256 amountToChain = (int(_totalUnderlying) * allocation) / _totalAllocation;\r\n    amountToChain += int(withdrawalRequests);\r\n\r\n    return amountToChain;\r\n  }\r\n\r\n  /// @notice Sends out cross-chain messages to vaults with the amount the vault has to send back\r\n  /// @dev if the xChainController needs to deposit, the amount will be 0 so the vault knows it will receive currency\r\n  /// @param _amountDeposit Amount the vault will receive from the xChainController\r\n  /// @param _amountToWithdraw Amount the vault will have to send back to the xChainController\r\n  /// @param _exchangeRate New exchangerate for vaults\r\n  function sendXChainAmount(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    int256 _amountDeposit,\r\n    uint256 _amountToWithdraw,\r\n    uint256 _exchangeRate\r\n  ) internal {\r\n    address vault = getVaultAddress(_vaultNumber, _chainId);\r\n    bool receivingFunds;\r\n    uint256 amountToSend = 0;\r\n\r\n    if (_amountDeposit > 0 && _amountDeposit < minimumAmount) {\r\n      vaultStage[_vaultNumber].fundsReceived++;\r\n    } else if (_amountDeposit >= minimumAmount) {\r\n      receivingFunds = true;\r\n      setAmountToDeposit(_vaultNumber, _chainId, _amountDeposit);\r\n      vaultStage[_vaultNumber].fundsReceived++;\r\n    }\r\n\r\n    if (_amountToWithdraw > 0 && _amountToWithdraw < uint(minimumAmount)) {\r\n      vaultStage[_vaultNumber].fundsReceived++;\r\n    } else if (_amountToWithdraw >= uint(minimumAmount)) {\r\n      amountToSend = _amountToWithdraw;\r\n    }\r\n\r\n    xProvider.pushSetXChainAllocation{value: msg.value}(\r\n      vault,\r\n      _chainId,\r\n      amountToSend,\r\n      _exchangeRate,\r\n      receivingFunds\r\n    );\r\n    emit SendXChainAmount(vault, _chainId, amountToSend, _exchangeRate, receivingFunds);\r\n  }\r\n\r\n  /// @notice Step 5 trigger; Push funds from xChainController to vaults\r\n  /// @notice Send amount to deposit from xController to vault and reset all stages for the vault\r\n  /// @param _vaultNumber Number of vault\r\n  /// @param _slippage Slippage tollerance for xChain swap, in BPS (i.e. 30 = 0.3%)\r\n  /// @param _chain Chain id of the vault where the funds need to be sent\r\n  /// @param _relayerFee The fee offered to the relayers\r\n  function sendFundsToVault(\r\n    uint256 _vaultNumber,\r\n    uint256 _slippage,\r\n    uint32 _chain,\r\n    uint256 _relayerFee\r\n  ) external payable onlyWhenFundsReceived(_vaultNumber) {\r\n    address vault = getVaultAddress(_vaultNumber, _chain);\r\n    require(vault != address(0), \"xChainController: not a valid vaultnumber\");\r\n    if (!getVaultChainIdOff(_vaultNumber, _chain)) {\r\n      uint256 amountToDeposit = getAmountToDeposit(_vaultNumber, _chain);\r\n\r\n      if (amountToDeposit > 0) {\r\n        address underlying = getUnderlyingAddress(_vaultNumber, _chain);\r\n\r\n        uint256 balance = IERC20(underlying).balanceOf(address(this));\r\n        if (amountToDeposit > balance) amountToDeposit = balance;\r\n\r\n        IERC20(underlying).safeIncreaseAllowance(address(xProvider), amountToDeposit);\r\n        xProvider.xTransferToVaults{value: msg.value}(\r\n          vault,\r\n          _chain,\r\n          amountToDeposit,\r\n          underlying,\r\n          _slippage,\r\n          _relayerFee\r\n        );\r\n        setAmountToDeposit(_vaultNumber, _chain, 0);\r\n        emit SentFundsToVault(vault, _chain, amountToDeposit, underlying);\r\n      }\r\n    }\r\n    vaultStage[_vaultNumber].fundsSent++;\r\n    if (vaultStage[_vaultNumber].fundsSent == chainIds.length) resetVaultStages(_vaultNumber);\r\n  }\r\n\r\n  /// @notice Helper to get total current allocation of vaultNumber\r\n  function getTotalUnderlyingOnChain(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId\r\n  ) internal view returns (uint256) {\r\n    return vaults[_vaultNumber].totalUnderlyingPerChain[_chainId];\r\n  }\r\n\r\n  /// @notice Gets saved totalUnderlying for vaultNumber\r\n  function getTotalUnderlyingVault(\r\n    uint256 _vaultNumber\r\n  ) internal view onlyWhenUnderlyingsReceived(_vaultNumber) returns (uint256) {\r\n    return vaults[_vaultNumber].totalUnderlying;\r\n  }\r\n\r\n  /// @notice Helper to get vault address of vaultNumber with given chainID\r\n  function getVaultAddress(uint256 _vaultNumber, uint32 _chainId) internal view returns (address) {\r\n    return vaults[_vaultNumber].vaultChainAddress[_chainId];\r\n  }\r\n\r\n  /// @notice Helper to get underyling address of vaultNumber with given chainID eg USDC\r\n  function getUnderlyingAddress(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId\r\n  ) internal view returns (address) {\r\n    return vaults[_vaultNumber].vaultUnderlyingAddress[_chainId];\r\n  }\r\n\r\n  /// @notice Helper to get current allocation per chain of vaultNumber with given chainID\r\n  function getCurrentAllocation(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId\r\n  ) internal view returns (int256) {\r\n    return vaults[_vaultNumber].currentAllocationPerChain[_chainId];\r\n  }\r\n\r\n  /// @notice Helper to get total current allocation of vaultNumber\r\n  function getCurrentTotalAllocation(uint256 _vaultNumber) internal view returns (int256) {\r\n    return vaults[_vaultNumber].totalCurrentAllocation;\r\n  }\r\n\r\n  /// @notice Helper to get if vault is active or not\r\n  function getVaultChainIdOff(uint256 _vaultNumber, uint32 _chainId) public view returns (bool) {\r\n    return vaults[_vaultNumber].chainIdOff[_chainId];\r\n  }\r\n\r\n  /// @notice Helper to set the amount to deposit in a chain vault\r\n  function setAmountToDeposit(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    int256 _amountToDeposit\r\n  ) internal {\r\n    vaults[_vaultNumber].amountToDepositPerChain[_chainId] = uint256(_amountToDeposit);\r\n  }\r\n\r\n  /// @notice Helper to get the amount to deposit in a chain vault\r\n  function getAmountToDeposit(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId\r\n  ) internal view returns (uint256) {\r\n    return vaults[_vaultNumber].amountToDepositPerChain[_chainId];\r\n  }\r\n\r\n  /// @notice Helper to get total supply from the vault on given chainId\r\n  function getTotalSupply(uint256 _vaultNumber) internal view returns (uint256) {\r\n    return vaults[_vaultNumber].totalSupply;\r\n  }\r\n\r\n  /// @notice Helper to get withdrawal requests from the vault on given chainId\r\n  function getWithdrawalRequests(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId\r\n  ) internal view returns (uint256) {\r\n    return vaults[_vaultNumber].withdrawalRequests[_chainId];\r\n  }\r\n\r\n  /// @notice Helper to get total withdrawal requests from the vault on given chainId\r\n  function getTotalWithdrawalRequests(uint256 _vaultNumber) internal view returns (uint256) {\r\n    return vaults[_vaultNumber].totalWithdrawalRequests;\r\n  }\r\n\r\n  /// @notice Getter for chainId array\r\n  function getChainIds() public view returns (uint32[] memory) {\r\n    return chainIds;\r\n  }\r\n\r\n  /// @notice Getter for dao address\r\n  function getDao() public view returns (address) {\r\n    return dao;\r\n  }\r\n\r\n  /// @notice Getter for guardian address\r\n  function getGuardian() public view returns (address) {\r\n    return guardian;\r\n  }\r\n\r\n  /*\r\n  Only Dao functions\r\n  */\r\n\r\n  /// @notice Set Vault address and underlying for a particulair chainId\r\n  /// @param _vaultNumber number of Vault\r\n  /// @param _chainId Number of chain used\r\n  /// @param _address address of the Vault\r\n  /// @param _underlying underlying of the Vault eg USDC\r\n  function setVaultChainAddress(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    address _address,\r\n    address _underlying\r\n  ) external onlyDao {\r\n    vaults[_vaultNumber].vaultChainAddress[_chainId] = _address;\r\n    vaults[_vaultNumber].vaultUnderlyingAddress[_chainId] = _underlying;\r\n  }\r\n\r\n  /// @notice Setter for xProvider address\r\n  /// @param _xProvider new address of xProvider on this chain\r\n  function setHomeXProvider(address _xProvider) external onlyDao {\r\n    xProvider = IXProvider(_xProvider);\r\n  }\r\n\r\n  /// @notice Setter for homeChain Id\r\n  /// @param _homeChainId New home chainId\r\n  function setHomeChainId(uint32 _homeChainId) external onlyDao {\r\n    homeChain = _homeChainId;\r\n  }\r\n\r\n  /// @notice Setter for DAO address\r\n  /// @param _dao DAO address\r\n  function setDao(address _dao) external onlyDao {\r\n    dao = _dao;\r\n  }\r\n\r\n  /// @notice Setter for guardian address\r\n  /// @param _guardian new address of the guardian\r\n  function setGuardian(address _guardian) external onlyDao {\r\n    guardian = _guardian;\r\n  }\r\n\r\n  /// @notice Setter for new game address\r\n  /// @param _game New address of the game\r\n  function setGame(address _game) external onlyDao {\r\n    game = _game;\r\n  }\r\n\r\n  /// @notice Setter for minumum amount to send xchain\r\n  /// @param _amount New minimum amount\r\n  function setMinimumAmount(int256 _amount) external onlyDao {\r\n    minimumAmount = _amount;\r\n  }\r\n\r\n  /*\r\n  Only Guardian functions\r\n  */\r\n\r\n  /// @notice Setter for chainId array\r\n  /// @param _chainIds array of all the used chainIds\r\n  function setChainIds(uint32[] memory _chainIds) external onlyGuardian {\r\n    chainIds = _chainIds;\r\n  }\r\n\r\n  /// @notice Resets all stages in vaultStage struct for a vaultNumber\r\n  /// @notice Must be run when a new vaultNumber is deployed\r\n  /// @dev onlyGuardian modifier so the dao can reset all stages for a vaultNumber incase something goes wrong\r\n  function resetVaultStagesDao(uint256 _vaultNumber) external onlyGuardian {\r\n    return resetVaultStages(_vaultNumber);\r\n  }\r\n\r\n  /// @notice Step 1: Guardian function\r\n  function receiveAllocationsFromGameGuard(\r\n    uint256 _vaultNumber,\r\n    int256[] memory _deltas\r\n  ) external onlyGuardian {\r\n    return receiveAllocationsFromGameInt(_vaultNumber, _deltas);\r\n  }\r\n\r\n  /// @notice Step 2: Guardian function\r\n  function setTotalUnderlyingGuard(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    uint256 _underlying,\r\n    uint256 _totalSupply,\r\n    uint256 _withdrawalRequests\r\n  ) external onlyGuardian {\r\n    return\r\n      setTotalUnderlyingInt(_vaultNumber, _chainId, _underlying, _totalSupply, _withdrawalRequests);\r\n  }\r\n\r\n  /// @notice Step 4: Guardian function\r\n  function setFundsReceivedGuard(\r\n    uint256 _vaultNumber,\r\n    uint256 _fundsReceived\r\n  ) external onlyGuardian {\r\n    vaultStage[_vaultNumber].fundsReceived = _fundsReceived;\r\n  }\r\n\r\n  /// @notice Guardian setter for number of active vaults for vaultNumber, set in xChainRebalance\r\n  function setActiveVaultsGuard(uint256 _vaultNumber, uint256 _activeVaults) external onlyGuardian {\r\n    vaultStage[_vaultNumber].activeVaults = _activeVaults;\r\n  }\r\n\r\n  /// @notice Guardian setter for stage 0:\r\n  function setReadyGuard(uint256 _vaultNumber, bool _state) external onlyGuardian {\r\n    vaultStage[_vaultNumber].ready = _state;\r\n  }\r\n\r\n  /// @notice Guardian setter for stage 1:\r\n  function setAllocationsReceivedGuard(uint256 _vaultNumber, bool _state) external onlyGuardian {\r\n    vaultStage[_vaultNumber].allocationsReceived = _state;\r\n  }\r\n\r\n  /// @notice Guardian setter to tick up stage 2:\r\n  function setUnderlyingReceivedGuard(\r\n    uint256 _vaultNumber,\r\n    uint256 _underlyingReceived\r\n  ) external onlyGuardian {\r\n    vaultStage[_vaultNumber].underlyingReceived = _underlyingReceived;\r\n  }\r\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/XProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IVault.sol\";\nimport \"./Interfaces/IXChainController.sol\";\nimport \"./Interfaces/IGame.sol\";\nimport \"./Interfaces/ExternalInterfaces/IConnext.sol\";\nimport \"./Interfaces/ExternalInterfaces/IXReceiver.sol\";\n\ncontract XProvider is IXReceiver {\n  using SafeERC20 for IERC20;\n\n  address public immutable connext;\n\n  address private dao;\n  address private guardian;\n  address public xController;\n  address public xControllerProvider;\n  address public game;\n\n  uint32 public homeChain;\n  uint32 public xControllerChain;\n  uint32 public gameChain;\n\n  // (domainID => contract address) mapping domainIDs to trusted remote xProvider on that specific domain\n  mapping(uint32 => address) public trustedRemoteConnext;\n  // (vaultAddress => bool): used for whitelisting vaults\n  mapping(address => bool) public vaultWhitelist;\n  // (vaultNumber => vaultAddress): used for guardian when xCall fails\n  mapping(uint256 => address) public vaults;\n\n  event SetTrustedRemote(uint32 _srcChainId, bytes _srcAddress);\n  event SetTrustedRemoteConnext(uint32 _srcChainId, address _srcAddress);\n\n  modifier onlyDao() {\n    require(msg.sender == dao, \"xProvider: only DAO\");\n    _;\n  }\n\n  modifier onlyGuardian() {\n    require(msg.sender == guardian, \"only Guardian\");\n    _;\n  }\n\n  modifier onlyController() {\n    require(msg.sender == xController, \"xProvider: only Controller\");\n    _;\n  }\n\n  modifier onlyVaults() {\n    require(vaultWhitelist[msg.sender], \"xProvider: only vault\");\n    _;\n  }\n\n  modifier onlyGame() {\n    require(msg.sender == game, \"xProvider: only Game\");\n    _;\n  }\n\n  /// @notice Solution for the low-level call in xReceive that is seen as an external call\n  modifier onlySelf() {\n    require(msg.sender == address(this), \"xProvider: only Self\");\n    _;\n  }\n\n  modifier onlySelfOrVault() {\n    require(\n      msg.sender == address(this) || vaultWhitelist[msg.sender],\n      \"xProvider: only Self or Vault\"\n    );\n    _;\n  }\n\n  /** @notice A modifier for authenticated calls.\n   * This is an important security consideration. If the target contract\n   * function should be authenticated, it must check three things:\n   *    1) The originating call comes from the expected origin domain.\n   *    2) The originating call comes from the expected source contract.\n   *    3) The call to this contract comes from Connext.\n   */\n  modifier onlySource(address _originSender, uint32 _origin) {\n    require(_originSender == trustedRemoteConnext[_origin] && msg.sender == connext, \"Not trusted\");\n    _;\n  }\n\n  constructor(\n    address _connext,\n    address _dao,\n    address _guardian,\n    address _game,\n    address _xController,\n    uint32 _homeChain\n  ) {\n    connext = _connext;\n    dao = _dao;\n    guardian = _guardian;\n    game = _game;\n    xController = _xController;\n    homeChain = _homeChain;\n  }\n\n  /// @notice Function to send function selectors crossChain\n  /// @param _destinationDomain chain Id of destination chain\n  /// @param _callData Function selector to call on receiving chain with params\n  /// @param _relayerFee The fee offered to the relayers, if 0 use the complete msg.value\n  function xSend(uint32 _destinationDomain, bytes memory _callData, uint256 _relayerFee) internal {\n    address target = trustedRemoteConnext[_destinationDomain];\n    require(target != address(0), \"XProvider: destination chain not trusted\");\n    uint256 relayerFee = _relayerFee != 0 ? _relayerFee : msg.value;\n\n    IConnext(connext).xcall{value: relayerFee}(\n      _destinationDomain, // _destination: Domain ID of the destination chain\n      target, // _to: address of the target contract\n      address(0), // _asset: use address zero for 0-value transfers\n      msg.sender, // _delegate: address that can revert or forceLocal on destination\n      0, // _amount: 0 because no funds are being transferred\n      0, // _slippage: can be anything between 0-10000 because no funds are being transferred\n      _callData // _callData: the encoded calldata to send\n    );\n  }\n\n  /// @notice Transfers funds from one chain to another.\n  /// @param _token Address of the token on this domain.\n  /// @param _amount The amount to transfer.\n  /// @param _recipient The destination address (e.g. a wallet).\n  /// @param _destinationDomain The destination domain ID.\n  /// @param _slippage Slippage tollerance for xChain swap, in BPS (i.e. 30 = 0.3%)\n  /// @param _relayerFee The fee offered to the relayers for confirmation message, msg.value - _relayerFee is what goes to the routers\n  function xTransfer(\n    address _token,\n    uint256 _amount,\n    address _recipient,\n    uint32 _destinationDomain,\n    uint256 _slippage,\n    uint256 _relayerFee\n  ) internal {\n    require(\n      IERC20(_token).allowance(msg.sender, address(this)) >= _amount,\n      \"User must approve amount\"\n    );\n\n    // User sends funds to this contract\n    IERC20(_token).transferFrom(msg.sender, address(this), _amount);\n\n    // This contract approves transfer to Connext\n    IERC20(_token).approve(address(connext), _amount);\n\n    IConnext(connext).xcall{value: (msg.value - _relayerFee)}(\n      _destinationDomain, // _destination: Domain ID of the destination chain\n      _recipient, // _to: address receiving the funds on the destination\n      _token, // _asset: address of the token contract\n      msg.sender, // _delegate: address that can revert or forceLocal on destination\n      _amount, // _amount: amount of tokens to transfer\n      _slippage, // _slippage: the maximum amount of slippage the user will accept in BPS (e.g. 30 = 0.3%)\n      bytes(\"\") // _callData: empty bytes because we're only sending funds\n    );\n  }\n\n  /// @notice function implemented from IXReceive from connext, standard way to receive messages with connext.\n  /// @param _transferId not used here because only relevant in case of a value transfer. Still in the signature to comply with IXReceive.\n  /// @param _amount not used here because only relevant in case of a value transfer. Still in the signature to comply with IXReceive.\n  /// @param _asset not used here because only relevant in case of a value transfer. Still in the signature to comply with IXReceive.\n  /// @param _originSender sender contract.\n  /// @param _origin sender domain id.\n  /// @param _callData calldata, contains function signature which has to be called in this contract as well as the values, hashed and encoded.\n  function xReceive(\n    bytes32 _transferId,\n    uint256 _amount,\n    address _asset,\n    address _originSender,\n    uint32 _origin,\n    bytes memory _callData\n  ) external onlySource(_originSender, _origin) returns (bytes memory) {\n    (bool success, ) = address(this).call(_callData);\n    require(success, \"xReceive: No success\");\n  }\n\n  /// @notice Step 1 push; Game pushes totalDeltaAllocations to xChainController\n  /// @notice Pushes the delta allocations from the game to the xChainController\n  /// @param _vaultNumber number of the vault\n  /// @param _deltas Array with delta Allocations for all chainIds\n  function pushAllocations(\n    uint256 _vaultNumber,\n    int256[] memory _deltas\n  ) external payable onlyGame {\n    if (homeChain == xControllerChain) {\n      return IXChainController(xController).receiveAllocationsFromGame(_vaultNumber, _deltas);\n    }\n    bytes4 selector = bytes4(keccak256(\"receiveAllocations(uint256,int256[])\"));\n    byte"
    }
  ]
}