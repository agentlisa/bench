{
  "Title": "[L05] Lack of input validation in the Heap library",
  "Content": "Neither the [`heapifyDown`](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/common/libraries/Heap.sol#L45-L54) nor the [`siftDown`](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/common/libraries/Heap.sol#L13-L43) functions of the [`Heap` library](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/common/libraries/Heap.sol#L9) are validating that both array parameters have the same length.\n\n\nThis will not generate a security incident with the codebase as it is, since in the [`Election` contract](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/governance/Election.sol) , the [`heapifyDown` function](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/governance/Election.sol#L887) is being called with the `keys` and `votesForNextMember` arrays as parameters, which [will always have the same length](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/governance/Election.sol#L856-L867).\n\n\nHowever, this could introduce bugs and vulnerabilities in the future, if the library is used in a different part of the code or if the `keys` and `votesForNextMember` array have a different length.\n\n\nConsider introducing a `require` statement validating the parameters of any of these functions so that the code will remain secure in the future.\n\n\n***Update:** Fixed in [pull request #3121](https://github.com/celo-org/celo-monorepo/pull/3121).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/libraries/Heap.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"../FixidityLib.sol\";\n\n/**\n * @title Simple heap implementation\n */\nlibrary Heap {\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  /**\n   * @notice Fixes the heap invariant.\n   * @param keys Pointers to values\n   * @param values Values that are compared, only the pointers are changed by this method.\n   * @param start Node for which the invariant might have changed.\n   * @param length Size of the heap.\n   */\n  function siftDown(\n    uint256[] memory keys,\n    FixidityLib.Fraction[] memory values,\n    uint256 start,\n    uint256 length\n  ) internal pure {\n    uint256 i = start;\n    while (true) {\n      uint256 leftChild = i.mul(2).add(1);\n      uint256 rightChild = i.mul(2).add(2);\n      uint256 maxIndex = i;\n      if (leftChild < length && values[keys[leftChild]].gt(values[keys[maxIndex]])) {\n        maxIndex = leftChild;\n      }\n      if (rightChild < length && values[keys[rightChild]].gt(values[keys[maxIndex]])) {\n        maxIndex = rightChild;\n      }\n      if (maxIndex == i) break;\n      uint256 tmpKey = keys[i];\n      keys[i] = keys[maxIndex];\n      keys[maxIndex] = tmpKey;\n      i = maxIndex;\n    }\n  }\n\n  /**\n   * @notice Fixes the heap invariant if top has been changed.\n   * @param keys Pointers to values\n   * @param values Values that are compared, only the pointers are changed by this method.\n   */\n  function heapifyDown(uint256[] memory keys, FixidityLib.Fraction[] memory values) internal pure {\n    siftDown(keys, values, 0, keys.length);\n  }\n\n}"
    }
  ]
}