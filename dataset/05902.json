{
  "Title": "[H-02] Put settlement can be anticipated and lead to user losses and bonding DoS",
  "Content": "\n<https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVault.sol#L278-L281> \n\n<https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVaultLP.sol#L118-L135> \n\n<https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVaultLP.sol#L145-L175>\n\nThe liquidity providers deposit `WETH` into the `PerpetualAtlanticVaultLP` which in turn provides the required collateral for put options writing. Writing puts locks collateral and to write more puts excess collateral is needed. Once a put is *in the money* it can be exercised by the `RdpxCoreV2` contract, which forces the liquidity providers to take on `rdpx` at above market prices (i.e. they take a loss).\n\nThe issue is that liquidity providers to the `PerpetualAtlanticVaultLP` can anticipate when they might take losses. Users may then take the precautionary action to avoid losses by exiting the LP prior to put settlements. By doing this, the users who are not as fast, or as technically sophisticated, are forced to take on more losses (as losses are then spread among less LPs).\n\n**Importantly, this is not dependent on MEV and will also happen on chains where MEV is not possible.**\n\nThis issue has two root causes:\n\n1.  The price-threshold for settlement is known\n2.  `PerpetualAtlanticVaultLP` allows redemptions at any time as long as there is excess collateral available\n\n**This has a second order effect**: by having the ability to anticipate when settlements will happen, if any puts are in the money, there is likely to be redemptions from the `PerpetualAtlanticVaultLP` which will drain all the available collateral. If all the available collateral is drained from the vault, then other users will not be able to bond using the `RdpxV2Core` contracts, as calls to `purchase` will [revert](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVault.sol#L278-L281) due to insufficient collateral in the put options vault.\n\nThe issue has been classified as high for the following reasons:\n\n1.  The depositors who are either too slow, or are not as technically sophisticated, are forced to take more of the losses related to settlement of put options (as losses are spread among less participants).\n2.  The token economic incentive is to anticipate calls to `settle` and avoid taking losses, and `deposit` again thereafter. This *will* create market-related periods of insufficient collateral, leading to regular (albeit temporary) DoS of the bonding mechanism which can impact the `ETH` peg of the `DpxEthToken` (not to mention the poor optics for the project).\n\n### Proof of Concept\n\nAs the price-threshold for settlement is known, depositors into the `PerpetualAtlanticVaultLP` have a few options to avoid this loss:\n\n1.  Users can simply monitor the `rdpxPriceInEth` and, once the price is close to the strike price, remove their liquidity through `redeem()`. They can then deposit after settlement to take up a greater number of shares.\n\n2.  Users can monitor the mempool (may be an issue in later versions of Arbitrum or other chains) for calls to `PerpetualAtlanticVault::settle()` and front-run this with a call to `redeem` to avoid losses.\n\n3.  As `settle()` is a manual call from the Dopex multisig, this may take the form of a weekly process. Users may come to anticipate this and pull the available assets from the LP at those regular intervals.\n\nRegardless of the method, the end result is the same.\n\nThe below coded PoC demonstrates the issue. One of the users, Bob (`address(1)`), anticipates a call to `settle()` - either through front-running or a market-related decision. Bob then enters and exits the pool right before and after the `settle` call. Dave (`address(2)`), who is another liquidity provider, does not anticipate the `settle()` call. We note the differences in PnL this creates in the console output.\n\nNote: The PoC was created using the `perp-vault/Integration.t.sol` file, and should be placed in the `tests/perp-vault` directory in a `.sol` file. The PoC can then be run with `forge test --match-test testPoCHigh3 -vvv`\n\nApologies for the extended setup code at the start, this is needed for an accurate test, the PoC start point is marked clearly.\n\n<details>\n\n    // SPDX-License-Identifier: UNLICENSED\n    pragma solidity 0.8.19;\n\n    import { Test } from \"forge-std/Test.sol\";\n    import \"forge-std/console.sol\";\n\n    import { ERC721Holder } from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\n    import { Setup } from \"./Setup.t.sol\";\n    import { PerpetualAtlanticVault } from \"contracts/perp-vault/PerpetualAtlanticVault.sol\";\n\n    contract PoC is ERC721Holder, Setup {\n      // ================================ HELPERS ================================ //\n      function mintWeth(uint256 _amount, address _to) public {\n        weth.mint(_to, _amount);\n      }\n\n      function mintRdpx(uint256 _amount, address _to) public {\n        rdpx.mint(_to, _amount);\n      }\n\n      function deposit(uint256 _amount, address _from) public {\n        vm.startPrank(_from, _from);\n        vaultLp.deposit(_amount, _from);\n        vm.stopPrank();\n      }\n\n      function purchase(uint256 _amount, address _as) public returns (uint256 id) {\n        vm.startPrank(_as, _as);\n        (, id) = vault.purchase(_amount, _as);\n        vm.stopPrank();\n      }\n\n      function setApprovals(address _as) public {\n        vm.startPrank(_as, _as);\n        rdpx.approve(address(vault), type(uint256).max);\n        rdpx.approve(address(vaultLp), type(uint256).max);\n        weth.approve(address(vault), type(uint256).max);\n        weth.approve(address(vaultLp), type(uint256).max);\n        vm.stopPrank();\n      }\n\n      // ================================ CORE ================================ //\n\n      /**\n      Assumptions & config:\n        - address(this) is impersonating the rdpxV2Core contract\n        - premium per option: 0.05 weth\n        - epoch duration: 1 day; 86400 seconds\n        - initial price of rdpx: 0.2 weth\n        - pricing precision is in 0.1 gwei\n        - premium precision is in 0.1 gwei\n        - rdpx and weth denomination in wei\n      **/\n\n      function testPoCHigh3() external {\n        // Setup starts here ----------------------------->\n        setApprovals(address(1));\n        setApprovals(address(2));\n        setApprovals(address(3));\n\n        mintWeth(5 ether, address(1));\n        mintWeth(5 ether, address(2));\n        mintWeth(25 ether, address(3));\n\n        /// The users deposit\n        deposit(5 ether, address(1));\n        deposit(5 ether, address(2));\n        deposit(25 ether, address(3));\n\n        uint256 userBalance = vaultLp.balanceOf(address(1));\n        assertEq(userBalance, 5 ether);\n        userBalance = vaultLp.balanceOf(address(2));\n        assertEq(userBalance, 5 ether);\n        userBalance = vaultLp.balanceOf(address(3));\n        assertEq(userBalance, 25 ether);\n\n        // premium = 100 * 0.05 weth = 5 weth\n        uint256 tokenId = purchase(100 ether, address(this)); // 0.015 gwei * 100 ether / 0.1 gwei = 15 ether collateral activated\n\n        skip(86500); // expires epoch 1\n        vault.updateFunding();\n        vault.updateFundingPaymentPointer();\n        uint256[] memory strikes = new uint256[](1);\n        strikes[0] = 0.015 gwei;\n        uint256 fundingAccrued = vault.calculateFunding(strikes);\n        assertEq(fundingAccrued, 5 ether);\n        uint256[] memory tokenIds = new uint256[](1);\n        tokenIds[0] = tokenId;\n\n        /// ---------------- POC STARTS HERE ---------------------------------------------------///\n        // At this point the Core contract has purchased options to sell 100 rdpx tokens\n\n        // The market moves against `rdpx` and the puts are now in the money\n        priceOracle.updateRdpxPrice(0.010 gwei);\n\n        // Bob, a savvy user, sees there is collateral available to withdraw, and\n        // because he monitors the price he knows the vault is about to take a loss\n        // thus, he withdraws his capital, expecting a call to settle.\n        userBalance = vaultLp.balanceOf(address(1));\n        vm.startPrank(address(1));\n        vaultLp.redeem(userBalance, address(1), address(1));\n        vm.stopPrank();\n\n        vm.startPrank(address(this), address(this));\n        (uint256 ethAmount, uint256 rdpxAmount) = vault.settle(tokenIds);\n        vm.stopPrank();\n\n        // Bob now re-enters the LP Vault\n        vm.startPrank(address(1));\n        vaultLp.deposit(weth.balanceOf(address(1)), address(1));\n        vm.stopPrank();\n\n        // Now we tally up the scores\n        console.log(\"User Bob ends with (WETH, RDPX, Shares):\");\n        userBalance = vaultLp.balanceOf(address(1));\n        (uint256 aBob, uint256 bBob) = vaultLp.redeemPreview(userBalance);\n        console.log(aBob, bBob, userBalance);\n        userBalance = vaultLp.balanceOf(address(2));\n        (uint256 aDave, uint256 bDave) = vaultLp.redeemPreview(userBalance);\n        console.log(\"User Dave ends with (WETH, RDPX, Shares):\");\n        console.log(aDave, bDave, userBalance);\n\n        /** \n            Bob and Dave both started with 5 ether deposited into the vault LP.\n            Bob ends up with shares worth 4.08 WETH + 16.32 RDPX\n            Dave ends up with shares worth 3.48 WETH + 13.94 RDPX\n            Thus we can conclude that by anticipating calls to `settle`, \n            either by monitoring the market or through front-running,\n            Bob has forced Dave to take on more of the losses.\n        */\n      }\n    }\n\n</details>\n\nThe result is that even though Bob and Dave both started with 5 WETH deposited, by anticipating the call to `settle()`, Bob was able to force Dave to take more of the losses while Bob was able to reenter and gain more shares than he started with. He has twisted the knife, so to speak.\n\n*Importantly, because the economic incentive is to exit and enter the pool in this way, it is likely to create a race condition where all the available collateral becomes withdrawn the moment the puts are in the money, meaning no user can bond (as options purchasing will revert [due to this check](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVault.sol#L278-L281)). This leads to temporary DoS of the bonding mechanism, until either the team takes direct action (setting `putsRequired` to `false`) or new deposits come back into the vault*\n\n### Tools Used\n\nFoundry.\n\n### Recommended Mitigation Steps\n\nOne option would be to rework the deposits to allow a \"cooling off period\" after deposits, meaning that assets can't be withdrawn until a set date in the future.\n\nAnother option would be to mint more shares to the vault itself in response to calls to `settle()` which accrue to users. These shares can then be distributed to the users as they redeem based on their time in the vault (in effect rewarding the hodlers).\n\nThis is not a trivial change, as it will impact the token economics of the project.\n\n**[psytama (Dopex) confirmed](https://github.com/code-423n4/2023-08-dopex-findings/issues/1584#issuecomment-1734037608)**\n\n**[Alex the Entreprenerd (Judge) commented](https://github.com/code-423n4/2023-08-dopex-findings/issues/1584#issuecomment-1772839989):**\n> I'm understanding that LPs are able to indeed able to redeem up to `totalAvailableCollateral`.\n> \n> For this reason, I agree with the validity of the finding.\n>\n> Conflicted on severity as total loss is capped, however, am thinking High is correct because new depositors are effectively guaranteed a loss, and there seems to be no rational way to avoid this scenario.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-08-dopex",
  "Code": [
    {
      "filename": "contracts/perp-vault/PerpetualAtlanticVault.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Libraries\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Contracts\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { ERC721Enumerable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport { ERC721Burnable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport { ERC4626 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { Counters } from \"@openzeppelin/contracts/utils/Counters.sol\";\nimport { IPerpetualAtlanticVaultLP } from \"./IPerpetualAtlanticVaultLP.sol\";\nimport { ContractWhitelist } from \"../helper/ContractWhitelist.sol\";\nimport { Pausable } from \"../helper/Pausable.sol\";\n\n// Interfaces\nimport { IPerpetualAtlanticVault } from \"./IPerpetualAtlanticVault.sol\";\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\nimport { IOptionPricing } from \"../interfaces/IOptionPricing.sol\";\nimport { IRdpxEthOracle } from \"../interfaces/IRdpxEthOracle.sol\";\nimport { IVolatilityOracle } from \"../interfaces/IVolatilityOracle.sol\";\n\n/// @title Contract to offer perpetual atlantic rDPX PUT options to the rdpxV2Core contract\n/// @dev Option tokens are in erc20 18 decimals & Strikes are in 1e8 precision\ncontract PerpetualAtlanticVault is\n  IPerpetualAtlanticVault,\n  ReentrancyGuard,\n  Pausable,\n  ERC721,\n  ERC721Enumerable,\n  ERC721Burnable,\n  AccessControl,\n  ContractWhitelist\n{\n  using SafeERC20 for IERC20WithBurn;\n  using Counters for Counters.Counter;\n\n  /// @dev Token ID counter for write positions\n  Counters.Counter private _tokenIdCounter;\n\n  /// @dev Manager role which handles bootstrapping\n  bytes32 public constant MANAGER_ROLE = keccak256(\"MANAGER_ROLE\");\n\n  /// @dev Rdpx v2 core role which can purchase and settle options\n  bytes32 public constant RDPXV2CORE_ROLE = keccak256(\"RDPXV2CORE_ROLE\");\n\n  /// @dev Underlying assets symbol\n  string public underlyingSymbol;\n\n  /// @dev Contract addresses\n  Addresses public addresses;\n\n  /// @dev Collateral Token\n  IERC20WithBurn public collateralToken;\n\n  /// @dev The precision of the collateral token\n  uint256 public collateralPrecision;\n\n  /// @dev tokenId => OptionPosition\n  mapping(uint256 => OptionPosition) public optionPositions;\n\n  /// @dev number of options funding has been accounted for the epoch\n  mapping(uint256 => uint256) public fundingPaymentsAccountedFor;\n\n  /// @dev the funding accounted for the epoch and strike\n  mapping(uint256 => mapping(uint256 => uint256))\n    public fundingPaymentsAccountedForPerStrike;\n\n  /// @dev the total funding for the epoch\n  mapping(uint256 => uint256) public totalFundingForEpoch;\n\n  /// @dev amount of options per strike\n  mapping(uint256 => uint256) public optionsPerStrike;\n\n  /// @dev latest funding update per strike\n  mapping(uint256 => uint256) public latestFundingPerStrike;\n\n  // @dev Funding rate for the epoch\n  mapping(uint256 => uint256) public fundingRates;\n\n  /// @dev the pointer to the lattest funding payment timestamp\n  /// @notice Explain to an end user what this does\n  /// @dev Explain to a developer any extra details\n  /// @return Documents the return variables of a contractâ€™s function state variable\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  uint256 public latestFundingPaymentPointer = 0;\n\n  /// @dev the total number of active options\n  uint256 public totalActiveOptions;\n\n  /// @dev genesis timestamp\n  uint256 public genesis;\n\n  /// @dev the timestamp of the last update where funding was paid for\n  uint256 public lastUpdateTime;\n\n  /// @dev the duration between funding payments\n  uint256 public fundingDuration = 7 days;\n\n  /// @dev the precision to round up to\n  uint256 public roundingPrecision = 1e6;\n\n  // ================================ CONSTRUCTOR ================================ //\n\n  /// @notice Contract constructor\n  /// @param _name ERC721 name\n  /// @param _symbol ERC721 symbol\n  /// @param _collateralToken Collateral token of the perpetual atlantic vault\n  /// @param _gensis Gensis time for funding calculation\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    address _collateralToken,\n    uint256 _gensis\n  ) ERC721(_name, _symbol) {\n    _validate(_collateralToken != address(0), 1);\n\n    collateralToken = IERC20WithBurn(_collateralToken);\n    underlyingSymbol = collateralToken.symbol();\n    collateralPrecision = 10 ** collateralToken.decimals();\n    genesis = _gensis;\n\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _setupRole(MANAGER_ROLE, msg.sender);\n  }\n\n  // ================================ ADMIN FUNCTIONS ================================ //\n\n  /**\n   * @notice Pauses the vault for emergency cases\n   * @dev    Can only be called by the owner\n   **/\n  function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _pause();\n  }\n\n  /**\n   * @notice Unpauses the vault\n   * @dev    Can only be called by the owner\n   **/\n  function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _unpause();\n  }\n\n  /**\n   * @notice Add a contract to the whitelist\n   * @dev    Can only be called by the owner\n   * @param  _contract Address of the contract that needs to be added to the whitelist\n   **/\n  function addToContractWhitelist(\n    address _contract\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _addToContractWhitelist(_contract);\n  }\n\n  /**\n   * @notice Remove a contract to the whitelist\n   * @dev    Can only be called by the owner\n   * @param  _contract Address of the contract that needs to be removed from the whitelist\n   **/\n  function removeFromContractWhitelist(\n    address _contract\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _removeFromContractWhitelist(_contract);\n  }\n\n  /**\n   * @notice Sets (adds) a list of addresses to the address list\n   * @dev    Can only be called by the owner\n   * @param  _optionPricing Address of the option pricing contract\n   * @param  _assetPriceOracle Address of the asset price oracle contract\n   * @param  _volatilityOracle Address of the volatility oracle contract\n   * @param  _feeDistributor Address of the fee distributor contract\n   * @param  _rdpx Address of the rdpx contract\n   * @param  _perpetualAtlanticVaultLP Address of the perpetual atlantic vault lp contract\n   * @param  _rdpxV2Core Address of the rdpx v2 rdpxV2Core contract\n   **/\n  function setAddresses(\n    address _optionPricing,\n    address _assetPriceOracle,\n    address _volatilityOracle,\n    address _feeDistributor,\n    address _rdpx,\n    address _perpetualAtlanticVaultLP,\n    address _rdpxV2Core\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_optionPricing != address(0), 1);\n    _validate(_assetPriceOracle != address(0), 1);\n    _validate(_volatilityOracle != address(0), 1);\n    _validate(_feeDistributor != address(0), 1);\n    _validate(_rdpx != address(0), 1);\n    _validate(_perpetualAtlanticVaultLP != address(0), 1);\n    _validate(_rdpxV2Core != address(0), 1);\n\n    addresses = Addresses({\n      optionPricing: _optionPricing,\n      assetPriceOracle: _assetPriceOracle,\n      volatilityOracle: _volatilityOracle,\n      feeDistributor: _feeDistributor,\n      rdpx: _rdpx,\n      perpetualAtlanticVaultLP: _perpetualAtlanticVaultLP,\n      rdpxV2Core: _rdpxV2Core\n    });\n    collateralToken.safeApprove(\n      addresses.perpetualAtlanticVaultLP,\n      type(uint256).max\n    );\n    emit AddressesSet(addresses);\n  }\n\n  /**\n   * @notice Transfers all funds to msg.sender\n   * @dev    Can only be called by the owner\n   * @param  tokens The list of erc20 tokens to withdraw\n   **/\n  function emergencyWithdraw(\n    address[] calldata tokens\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _whenPaused();\n    IERC20WithBurn token;\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      token = IERC20WithBurn(tokens[i]);\n      token.safeTransfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    emit EmergencyWithdraw(msg.sender, tokens);\n  }\n\n  /**\n   * @notice Updates the funding duration\n   * @dev    Can only be called by the owner\n   **/\n  function updateFundingDuration(\n    uint256 _fundingDuration\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    fundingDuration = _fundingDuration;\n  }\n\n  function setLpAllowance(bool increase) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    increase\n      ? collateralToken.approve(\n        addresses.perpetualAtlanticVaultLP,\n        type(uint256).max\n      )\n      : collateralToken.approve(addresses.perpetualAtlanticVaultLP, 0);\n  }\n\n  // ================================ TREASURY FUNCTIONS ================================ //\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function purchase(\n    uint256 amount,\n    address to\n  )\n    external\n    nonReentrant\n    onlyRole(RDPXV2CORE_ROLE)\n    returns (uint256 premium, uint256 tokenId)\n  {\n    _whenNotPaused();\n    _validate(amount > 0, 2);\n\n    updateFunding();\n\n    uint256 currentPrice = getUnderlyingPrice(); // price of underlying wrt collateralToken\n    uint256 strike = roundUp(currentPrice - (currentPrice / 4)); // 25% below the current price\n    IPerpetualAtlanticVaultLP perpetualAtlanticVaultLp = IPerpetualAtlanticVaultLP(\n        addresses.perpetualAtlanticVaultLP\n      );\n\n    // Check if vault has enough collateral to write the options\n    uint256 requiredCollateral = (amount * strike) / 1e8;\n\n    _validate(\n      requiredCollateral <= perpetualAtlanticVaultLp.totalAvailableCollateral(),\n      3\n    );\n\n    uint256 timeToExpiry = nextFundingPaymentTimestamp() - block.timestamp;\n\n    // Get total premium for all options being purchased\n    premium = calculatePremium(strike, amount, timeToExpiry, 0);\n\n    // Transfer premium from msg.sender to PerpetualAtlantics vault\n    collateralToken.safeTransferFrom(msg.sender, address(this), premium);\n\n    perpetualAtlanticVaultLp.lockCollateral(requiredCollateral);\n    _updateFundingRate(premium);\n\n    // Mint the option tokens\n    tokenId = _mintOptionToken();\n    optionPositions[tokenId] = OptionPosition({\n      strike: strike,\n      amount: amount,\n      positionId: tokenId\n    });\n\n    totalActiveOptions += amount;\n    fundingPaymentsAccountedFor[latestFundingPaymentPointer] += amount;\n    optionsPerStrike[strike] += amount;\n\n    // record the number of options funding has been accounted for the epoch and strike\n    fundingPaymentsAccountedForPerStrike[latestFundingPaymentPointer][\n      strike\n    ] += amount;\n\n    emit Purchase(strike, amount, premium, to, msg.sender);\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function settle(\n    uint256[] memory optionIds\n  )\n    external\n    nonReentrant\n    onlyRole(RDPXV2CORE_ROLE)\n    returns (uint256 ethAmount, uint256 rdpxAmount)\n  {\n    _whenNotPaused();\n    _isEligibleSender();\n\n    updateFunding();\n\n    for (uint256 i = 0; i < optionIds.length; i++) {\n      uint256 strike = optionPositions[optionIds[i]].strike;\n      uint256 amount = optionPositions[optionIds[i]].amount;\n\n      // check if strike is ITM\n      _validate(strike >= getUnderlyingPrice(), 7);\n\n      ethAmount += (amount * strike) / 1e8;\n      rdpxAmount += amount;\n      optionsPerStrike[strike] -= amount;\n      totalActiveOptions -= amount;\n\n      // Burn option tokens from user\n      _burn(optionIds[i]);\n\n      optionPositions[optionIds[i]].strike = 0;\n    }\n\n    // Transfer collateral token from perpetual vault to rdpx rdpxV2Core\n    collateralToken.safeTransferFrom(\n      addresses.perpetualAtlanticVaultLP,\n      addresses.rdpxV2Core,\n      ethAmount\n    );\n    // Transfer rdpx from rdpx rdpxV2Core to perpetual vault\n    IERC20WithBurn(addresses.rdpx).safeTransferFrom(\n      addresses.rdpxV2Core,\n      addresses.perpetualAtlanticVaultLP,\n      rdpxAmount\n    );\n\n    IPerpetualAtlanticVaultLP(addresses.perpetualAtlanticVaultLP).subtractLoss(\n      ethAmount\n    );\n    IPerpetualAtlanticVaultLP(addresses.perpetualAtlanticVaultLP)\n      .unlockLiquidity(ethAmount);\n    IPerpetualAtlanticVaultLP(addresses.perpetualAtlanticVaultLP).addRdpx(\n      rdpxAmount\n    );\n\n    emit Settle(ethAmount, rdpxAmount, optionIds);\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function payFunding() external onlyRole(RDPXV2CORE_ROLE) returns (uint256) {\n    _whenNotPaused();\n    _isEligibleSender();\n\n    _validate(\n      totalActiveOptions ==\n        fundingPaymentsAccountedFor[latestFundingPaymentPointer],\n      6\n    );\n\n    collateralToken.safeTransferFrom(\n      addresses.rdpxV2Core,\n      address(this),\n      totalFundingForEpoch[latestFundingPaymentPointer]\n    );\n    _updateFundingRate(totalFundingForEpoch[latestFundingPaymentPointer]);\n\n    emit PayFunding(\n      msg.sender,\n      totalFundingForEpoch[latestFundingPaymentPointer],\n      latestFundingPaymentPointer\n    );\n\n    return (totalFundingForEpoch[latestFundingPaymentPointer]);\n  }\n\n  // ================================ PUBLIC/EXTERNAL FUNCTIONS ================================ //\n\n  /**\n   * @notice Function to calculate the funding of options for the next epoch\n   * @param  strikes array of strikes to calculate the funding for\n   * @return fundingAmount the funding of options\n   **/\n  function calculateFunding(\n    uint256[] memory strikes\n  ) external nonReentrant returns (uint256 fundingAmount) {\n    _whenNotPaused();\n    _isEligibleSender();\n\n    updateFundingPaymentPointer();\n\n    for (uint256 i = 0; i < strikes.length; i++) {\n      _validate(optionsPerStrike[strikes[i]] > 0, 4);\n      _validate(\n        latestFundingPerStrike[strikes[i]] != latestFundingPaymentPointer,\n        5\n      );\n      uint256 strike = strikes[i];\n\n      uint256 amount = optionsPerStrike[strike] -\n        fundingPaymentsAccountedForPerStrike[latestFundingPaymentPointer][\n          strike\n        ];\n\n      uint256 timeToExpiry = nextFundingPaymentTimestamp() -\n        (genesis + ((latestFundingPaymentPointer - 1) * fundingDuration));\n\n      uint256 premium = calculatePremium(\n        strike,\n        amount,\n        timeToExpiry,\n        getUnderlyingPrice()\n      );\n\n      latestFundingPerStrike[strike] = latestFundingPaymentPointer;\n      fundingAmount += premium;\n\n      // Record number of options that funding payments were accounted for, for this epoch\n      fundingPaymentsAccountedFor[latestFundingPaymentPointer] += amount;\n\n      // record the number of options funding has been accounted for the epoch and strike\n      fundingPaymentsAccountedForPerStrike[latestFundingPaymentPointer][\n        strike\n      ] += amount;\n\n      // Record total funding for this epoch\n      // This does not need to be done in purchase() since it's already accounted for using `addProceeds()`\n      totalFundingForEpoch[latestFundingPaymentPointer] += premium;\n\n      emit CalculateFunding(\n        msg.sender,\n        amount,\n        strike,\n        premium,\n        latestFundingPaymentPointer\n      );\n    }\n  }\n\n  /// @dev Helper function that updates the latest funding payment pointer based on current timestamp\n  function updateFundingPaymentPointer() public {\n    while (block.timestamp >= nextFundingPaymentTimestamp()) {\n      if (lastUpdateTime < nextFundingPaymentTimestamp()) {\n        uint256 currentFundingRate = fundingRates[latestFundingPaymentPointer];\n\n        uint256 startTime = lastUpdateTime == 0\n          ? (nextFundingPaymentTimestamp() - fundingDuration)\n          : lastUpdateTime;\n\n        lastUpdateTime = nextFundingPaymentTimestamp();\n\n        collateralToken.safeTransfer(\n          addresses.perpetualAtlanticVaultLP,\n          (currentFundingRate * (nextFundingPaymentTimestamp() - startTime)) /\n            1e18\n        );\n\n        IPerpetualAtlanticVaultLP(addresses.perpetualAtlanticVaultLP)\n          .addProceeds(\n            (currentFundingRate * (nextFundingPaymentTimestamp() - startTime)) /\n              1e18\n          );\n\n        emit FundingPaid(\n          msg.sender,\n          ((currentFundingRate * (nextFundingPaymentTimestamp() - startTime)) /\n            1e18),\n          latestFundingPaymentPointer\n        );\n      }\n\n      latestFundingPaymentPointer += 1;\n      emit FundingPaymentPointerUpdated(latestFundingPaymentPointer);\n    }\n  }\n\n  /**\n   * @notice function to transfer funding into the LP in a drip-vested manner\n   * @dev    addProceeds() is invoked to update totalCollateral in LP\n   **/\n  function updateFunding() public {\n    updateFundingPaymentPointer();\n    uint256 currentFundingRate = fundingRates[latestFundingPaymentPointer];\n    uint256 startTime = lastUpdateTime == 0\n      ? (nextFundingPaymentTimestamp() - fundingDuration)\n      : lastUpdateTime;\n    lastUpdateTime = block.timestamp;\n\n    collateralToken.safeTransfer(\n      addresses.perpetualAtlanticVaultLP,\n      (currentFundingRate * (block.timestamp - startTime)) / 1e18\n    );\n\n    IPerpetualAtlanticVaultLP(addresses.perpetualAtlanticVaultLP).addProceeds(\n      (currentFundingRate * (block.timestamp - startTime)) / 1e18\n    );\n\n    emit FundingPaid(\n      msg.sender,\n      ((currentFundingRate * (block.timestamp - startTime)) / 1e18),\n      latestFundingPaymentPointer\n    );\n  }\n\n  // ================================ VIEWS ================================ //\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function getUnderlyingPrice() public view returns (uint256) {\n    return IRdpxEthOracle(addresses.assetPriceOracle).getRdpxPriceInEth();\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function getVolatility(uint256 _strike) public view returns (uint256) {\n    return IVolatilityOracle(addresses.volatilityOracle).getVolatility(_strike);\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function calculatePremium(\n    uint256 _strike,\n    uint256 _amount,\n    uint256 timeToExpiry,\n    uint256 _price\n  ) public view returns (uint256 premium) {\n    premium = ((IOptionPricing(addresses.optionPricing).getOptionPrice(\n      _strike,\n      _price > 0 ? _price : getUnderlyingPrice(),\n      getVolatility(_strike),\n      timeToExpiry\n    ) * _amount) / 1e8);\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function calculatePnl(\n    uint256 price,\n    uint256 strike,\n    uint256 amount\n  ) public pure returns (uint256) {\n    return strike > price ? ((strike - price) * amount) / 1e8 : 0;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function nextFundingPaymentTimestamp()\n    public\n    view\n    returns (uint256 timestamp)\n  {\n    return genesis + (latestFundingPaymentPointer * fundingDuration);\n  }\n\n  /**\n   * @dev Function to round up a value to the roundingPrecision.\n   * @param _strike the strike\n   * @return strike rounded up to the nearest roundingPrecision\n   **/\n  function roundUp(uint256 _strike) public view returns (uint256 strike) {\n    uint256 remainder = _strike % roundingPrecision;\n    if (remainder == 0) {\n      return _strike;\n    } else {\n      return _strike - remainder + roundingPrecision;\n    }\n  }\n\n  // ================================ PRIVATE/HELPER FUNCTIONS ================================ //\n\n  /// @dev Internal function to mint a option token\n  function _mintOptionToken() private returns (uint256 tokenId) {\n    tokenId = _tokenIdCounter.current();\n    _tokenIdCounter.increment();\n    _mint(addresses.rdpxV2Core, tokenId);\n  }\n\n  function _updateFundingRate(uint256 amount) private {\n    if (fundingRates[latestFundingPaymentPointer] == 0) {\n      uint256 startTime;\n      if (lastUpdateTime > nextFundingPaymentTimestamp() - fundingDuration) {\n        startTime = lastUpdateTime;\n      } else {\n        startTime = nextFundingPaymentTimestamp() - fundingDuration;\n      }\n      uint256 endTime = nextFundingPaymentTimestamp();\n      fundingRates[latestFundingPaymentPointer] =\n        (amount * 1e18) /\n        (endTime - startTime);\n    } else {\n      uint256 startTime = lastUpdateTime;\n      uint256 endTime = nextFundingPaymentTimestamp();\n      if (endTime == startTime) return;\n      fundingRates[latestFundingPaymentPointer] =\n        fundingRates[latestFundingPaymentPointer] +\n        ((amount * 1e18) / (endTime - startTime));\n    }\n  }\n\n  /**\n   * @dev    internal function to validate checks\n   * @param  _clause the boolean clause to validate\n   * @param  _errorCode error code for error mapping below\n   **/\n  function _validate(bool _clause, uint256 _errorCode) private pure {\n    if (!_clause) revert PerpetualAtlanticVaultError(_errorCode);\n  }\n\n  // ================================ ERRORS ================================ //\n\n  /**\n   * @dev  Custom Error used to validate checks within the contract's functions.\n   *       The uint256 error code corresponds to an error message.\n   **/\n  error PerpetualAtlanticVaultError(uint256);\n\n  // ================================ Solidity Required Overrides ================================ //\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 tokenId,\n    uint256 batchSize\n  ) internal override(ERC721, ERC721Enumerable) {\n    _whenNotPaused();\n    super._beforeTokenTransfer(from, to, tokenId, batchSize);\n  }\n\n  function supportsInterface(\n    bytes4 interfaceId\n  )\n    public\n    view\n    override(ERC721, ERC721Enumerable, AccessControl)\n    returns (bool)\n  {\n    return super.supportsInterface(interfaceId);\n  }\n}\n\n// ERROR CODES\n// E1: \"Zero address\",\n// E2: \"Amount must be greater than 0\",\n// E3: \"Insufficient collateral for purchase\",\n// E4: \"No options for strike\",\n// E5: \"Option strike already funded\",\n// E6: \"All funding payments must be accounted for\",\n// E7: \"Option is not ITM\""
    },
    {
      "filename": "contracts/perp-vault/PerpetualAtlanticVaultLP.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Contracts\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\n\n// Libraries\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\n\n// Interfaces\nimport { IPerpetualAtlanticVault } from \"./IPerpetualAtlanticVault.sol\";\nimport { IPerpetualAtlanticVaultLP } from \"./IPerpetualAtlanticVaultLP.sol\";\n\n/**\n * @title PerpetaulAtlanticVault LP Token\n */\ncontract PerpetualAtlanticVaultLP is ERC20, IPerpetualAtlanticVaultLP {\n  using SafeERC20 for IERC20WithBurn;\n  using SafeTransferLib for ERC20;\n  using FixedPointMathLib for uint256;\n\n  // ================================ EVENTS ================================ //\n\n  event Deposit(\n    address indexed caller,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  event Withdraw(\n    address indexed caller,\n    address indexed receiver,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  // ================================ STATE VARIABLES ================================ //\n\n  /// @dev The address of the perpetual Atlantic Vault contract creating the lp token\n  IPerpetualAtlanticVault public perpetualAtlanticVault;\n\n  /// @dev The collateral token\n  ERC20 public collateral;\n\n  /// @dev The symbol reperesenting the underlying asset of the perpetualatlanticvault lp\n  string public underlyingSymbol;\n\n  /// @dev The symbol representing the collateral token of the perpetualatlanticvault lp\n  string public collateralSymbol;\n\n  /// @dev Total collateral available\n  uint256 private _totalCollateral;\n\n  /// @dev Active collateral\n  uint256 private _activeCollateral;\n\n  /// @dev Total rdpx available\n  uint256 private _rdpxCollateral;\n\n  /// @dev address of rdpx token\n  address public rdpx;\n\n  /// @dev address of the rdpx rdpxV2Core contract\n  address public rdpxRdpxV2Core;\n\n  // ================================ CONSTRUCTOR ================================ //\n\n  /**\n   * @param _perpetualAtlanticVault The address of the perpetual atlantic vault contract creating the lp token\n   * @param _rdpxRdpxV2Core The address of the rdpx rdpxV2Core contract\n   * @param _collateral The address of the collateral asset in the perpetualatlanticvault contract\n   * @param _collateralSymbol The symbol of the collateral asset token\n   * @param _rdpx The address of the rdpx token\n   */\n  constructor(\n    address _perpetualAtlanticVault,\n    address _rdpxRdpxV2Core,\n    address _collateral,\n    address _rdpx,\n    string memory _collateralSymbol\n  )\n    ERC20(\n      \"PerpetualAtlanticVault LP Token\",\n      _collateralSymbol,\n      ERC20(_collateral).decimals()\n    )\n  {\n    require(\n      _perpetualAtlanticVault != address(0) || _rdpx != address(0),\n      \"ZERO_ADDRESS\"\n    );\n    perpetualAtlanticVault = IPerpetualAtlanticVault(_perpetualAtlanticVault);\n    rdpxRdpxV2Core = _rdpxRdpxV2Core;\n    collateralSymbol = _collateralSymbol;\n    rdpx = _rdpx;\n    collateral = ERC20(_collateral);\n\n    symbol = string.concat(_collateralSymbol, \"-LP\");\n\n    collateral.approve(_perpetualAtlanticVault, type(uint256).max);\n    ERC20(rdpx).approve(_perpetualAtlanticVault, type(uint256).max);\n  }\n\n  // ================================ PUBLIC FUNCTIONS ================================ //\n\n  /**\n   * @notice deposit into ERC4626 token\n   * @param assets assets\n   * @param receiver receiver\n   * @return shares shares of LP tokens minted\n   */\n  function deposit(\n    uint256 assets,\n    address receiver\n  ) public virtual returns (uint256 shares) {\n    // Check for rounding error since we round down in previewDeposit.\n    require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n    perpetualAtlanticVault.updateFunding();\n\n    // Need to transfer before minting or ERC777s could reenter.\n    collateral.transferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    _totalCollateral += assets;\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n  }\n\n  /**\n   * @notice redeem ERC4626 token\n   * @param shares shares\n   * @param receiver receiver\n   * @param owner owner\n   * @return assets native tokens to be received\n   * @return rdpxAmount rdpx tokens to be received\n   */\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) public returns (uint256 assets, uint256 rdpxAmount) {\n    perpetualAtlanticVault.updateFunding();\n\n    if (msg.sender != owner) {\n      uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n      if (allowed != type(uint256).max) {\n        allowance[owner][msg.sender] = allowed - shares;\n      }\n    }\n    (assets, rdpxAmount) = redeemPreview(shares);\n\n    // Check for rounding error since we round down in previewRedeem.\n    require(assets != 0, \"ZERO_ASSETS\");\n\n    _rdpxCollateral -= rdpxAmount;\n\n    beforeWithdraw(assets, shares);\n\n    _burn(owner, shares);\n\n    collateral.transfer(receiver, assets);\n\n    IERC20WithBurn(rdpx).safeTransfer(receiver, rdpxAmount);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n  }\n\n  // ================================ PERP VAULT FUNCTIONS ================================ //\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function lockCollateral(uint256 amount) public onlyPerpVault {\n    _activeCollateral += amount;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function unlockLiquidity(uint256 amount) public onlyPerpVault {\n    _activeCollateral -= amount;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function addProceeds(uint256 proceeds) public onlyPerpVault {\n    require(\n      collateral.balanceOf(address(this)) >= _totalCollateral + proceeds,\n      \"Not enough collateral token was sent\"\n    );\n    _totalCollateral += proceeds;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function subtractLoss(uint256 loss) public onlyPerpVault {\n    require(\n      collateral.balanceOf(address(this)) == _totalCollateral - loss,\n      \"Not enough collateral was sent out\"\n    );\n    _totalCollateral -= loss;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function addRdpx(uint256 amount) public onlyPerpVault {\n    require(\n      IERC20WithBurn(rdpx).balanceOf(address(this)) >= _rdpxCollateral + amount,\n      \"Not enough rdpx token was sent\"\n    );\n    _rdpxCollateral += amount;\n  }\n\n  // ================================ INTERNAL FUNCTUONS ================================ //\n\n  function _convertToAssets(\n    uint256 shares\n  ) internal view virtual returns (uint256 assets, uint256 rdpxAmount) {\n    uint256 supply = totalSupply;\n    return\n      (supply == 0)\n        ? (shares, 0)\n        : (\n          shares.mulDivDown(totalCollateral(), supply),\n          shares.mulDivDown(_rdpxCollateral, supply)\n        );\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address,\n    uint256\n  ) internal virtual {}\n\n  // ================================ VIEWS ================================ //\n\n  /// @notice Returns the total active collateral\n  function activeCollateral() public view returns (uint256) {\n    return _activeCollateral;\n  }\n\n  /// @notice Returns the total collateral\n  function totalCollateral() public view returns (uint256) {\n    return _totalCollateral;\n  }\n\n  /// @notice Returns the total rdpx collateral\n  function rdpxCollateral() public view returns (uint256) {\n    return _rdpxCollateral;\n  }\n\n  /// @notice Returns the total available collateral\n  function totalAvailableCollateral() public view returns (uint256) {\n    return _totalCollateral - _activeCollateral;\n  }\n\n  // ================================ PUBLIC VIEW FUNCTIONS ================================ //\n\n  /// @notice Returns the amount of collateral and rdpx per share\n  function redeemPreview(\n    uint256 shares\n  ) public view returns (uint256, uint256) {\n    return _convertToAssets(shares);\n  }\n\n  /// @notice Returns the amount of shares recieved for a given amount of assets\n  function previewDeposit(uint256 assets) public view returns (uint256) {\n    return convertToShares(assets);\n  }\n\n  /// @notice Returns the amount of shares recieved for a given amount of assets\n  function convertToShares(\n    uint256 assets\n  ) public view returns (uint256 shares) {\n    uint256 supply = totalSupply;\n    uint256 rdpxPriceInAlphaToken = perpetualAtlanticVault.getUnderlyingPrice();\n\n    uint256 totalVaultCollateral = totalCollateral() +\n      ((_rdpxCollateral * rdpxPriceInAlphaToken) / 1e8);\n    return\n      supply == 0 ? assets : assets.mulDivDown(supply, totalVaultCollateral);\n  }\n\n  function beforeWithdraw(uint256 assets, uint256 /*shares*/) internal {\n    require(\n      assets <= totalAvailableCollateral(),\n      \"Not enough available assets to satisfy withdrawal\"\n    );\n    _totalCollateral -= assets;\n  }\n\n  // ================================ MODIFIERS ================================ //\n  modifier onlyPerpVault() {\n    require(\n      msg.sender == address(perpetualAtlanticVault),\n      \"Only the perp vault can call this function\"\n    );\n    _;\n  }\n}"
    },
    {
      "filename": "contracts/perp-vault/PerpetualAtlanticVaultLP.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Contracts\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\n\n// Libraries\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\n\n// Interfaces\nimport { IPerpetualAtlanticVault } from \"./IPerpetualAtlanticVault.sol\";\nimport { IPerpetualAtlanticVaultLP } from \"./IPerpetualAtlanticVaultLP.sol\";\n\n/**\n * @title PerpetaulAtlanticVault LP Token\n */\ncontract PerpetualAtlanticVaultLP is ERC20, IPerpetualAtlanticVaultLP {\n  using SafeERC20 for IERC20WithBurn;\n  using SafeTransferLib for ERC20;\n  using FixedPointMathLib for uint256;\n\n  // ================================ EVENTS ================================ //\n\n  event Deposit(\n    address indexed caller,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  event Withdraw(\n    address indexed caller,\n    address indexed receiver,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  // ================================ STATE VARIABLES ================================ //\n\n  /// @dev The address of the perpetual Atlantic Vault contract creating the lp token\n  IPerpetualAtlanticVault public perpetualAtlanticVault;\n\n  /// @dev The collateral token\n  ERC20 public collateral;\n\n  /// @dev The symbol reperesenting the underlying asset of the perpetualatlanticvault lp\n  string public underlyingSymbol;\n\n  /// @dev The symbol representing the collateral token of the perpetualatlanticvault lp\n  stri"
    }
  ]
}