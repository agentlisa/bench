{
  "Title": "[G-01] Refactor `PendlePowerFarmController.increaseReservedForCompound()` function to avoid unnecessary copying from storage to memory and vice-versa",
  "Content": "\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L497-#L524\n\nThe `PendlePowerFarmController.increaseReservedForCompound()` function can be refactored to be better gas efficient by avoiding unnecessary copying of values from storage to memory updating the values then copying back to storage. Having to copy from the storage variable `pendleChildCompoundInfo[_pendleMarket]` into a memory variable `childInfo` would mean that every storage slot of `pendleChildCompoundInfo[_pendleMarket]` would be read (even those not needed in the function); which would cost 2100 gas units for every slot read. Then, it has to update the memory variable in the while loop before copying the memory variable into the storage is absolutely gas inefficient.\n\nWe can rectify this by making the `childInfo` variable a storage variable, doing this would avoid having copy values from storage to memory since the it is passed by reference also there would be absolutely no need to copy from memory back to storage. The diff below shows how the code should be refactored:\n\n```solidity\nfile: contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol\n\n497:    function increaseReservedForCompound(\n498:        address _pendleMarket,\n499:        uint256[] calldata _amounts\n500:    )\n501:        external\n502:        onlyChildContract(_pendleMarket)\n503:    {\n504:        CompoundStruct memory childInfo = pendleChildCompoundInfo[\n505:            _pendleMarket\n506:        ];\n507:\n508:        uint256 i;\n509:        uint256 length = childInfo.rewardTokens.length;\n510:\n511:        while (i < length) {\n512:            childInfo.reservedForCompound[i] += _amounts[i];\n513:            unchecked {\n514:                ++i;\n515:            }\n516:        }\n517:\n518:        pendleChildCompoundInfo[_pendleMarket] = childInfo;\n519:\n520:        emit IncreaseReservedForCompound(\n521:            _pendleMarket,\n522:            _amounts\n523:        );\n524:    }\n```\n\n```diff\ndiff --git a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.solindex 15cb863..842b94e 100644\n--- a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol\n+++ b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol\n@@ -501,7 +501,7 @@ contract PendlePowerFarmController is PendlePowerFarmControllerHelper {\n         external\n         onlyChildContract(_pendleMarket)\n     {\n-        CompoundStruct memory childInfo = pendleChildCompoundInfo[\n+        CompoundStruct storage childInfo = pendleChildCompoundInfo[\n             _pendleMarket\n         ];\n\n@@ -515,8 +515,6 @@ contract PendlePowerFarmController is PendlePowerFarmControllerHelper {\n             }\n         }\n\n-        pendleChildCompoundInfo[_pendleMarket] = childInfo;\n-\n         emit IncreaseReservedForCompound(\n             _pendleMarket,\n             _amounts\n```\n\nEstimated gas saved: 13672 gas units.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./PendlePowerFarmTokenFactory.sol\";\nimport \"./PendlePowerFarmControllerHelper.sol\";\n\ncontract PendlePowerFarmController is PendlePowerFarmControllerHelper {\n\n    PendlePowerFarmTokenFactory public immutable PENDLE_POWER_FARM_TOKEN_FACTORY;\n\n    constructor(\n        address _vePendle,\n        address _pendleToken,\n        address _voterContract,\n        address _voterRewardsClaimerAddress,\n        address _wiseOracleHub\n    )\n        PendlePowerFarmControllerBase(\n            _vePendle,\n            _pendleToken,\n            _voterContract,\n            _voterRewardsClaimerAddress,\n            _wiseOracleHub\n        )\n    {\n        PENDLE_POWER_FARM_TOKEN_FACTORY = new PendlePowerFarmTokenFactory(\n            address(this)\n        );\n    }\n\n    function withdrawLp(\n        address _pendleMarket,\n        address _to,\n        uint256 _amount\n    )\n        external\n        onlyChildContract(_pendleMarket)\n    {\n        _safeTransfer(\n            _pendleMarket,\n            _to,\n            _amount\n        );\n\n        emit WithdrawLp(\n            _pendleMarket,\n            _to,\n            _amount\n        );\n    }\n\n    function exchangeRewardsForCompoundingWithIncentive(\n        address _pendleMarket,\n        address _rewardToken,\n        uint256 _rewardAmount\n    )\n        external\n        syncSupply(_pendleMarket)\n        returns (uint256)\n    {\n        CompoundStruct memory childInfo = pendleChildCompoundInfo[\n            _pendleMarket\n        ];\n\n        uint256 index = _findIndex(\n            childInfo.rewardTokens,\n            _rewardToken\n        );\n\n        if (childInfo.reservedForCompound[index] < _rewardAmount) {\n            revert NotEnoughCompound();\n        }\n\n        uint256 sendingAmount = _getAmountToSend(\n            _pendleMarket,\n            _getTokensInETH(\n                _rewardToken,\n                _rewardAmount\n            )\n        );\n\n        childInfo.reservedForCompound[index] -= _rewardAmount;\n        pendleChildCompoundInfo[_pendleMarket] = childInfo;\n\n        _safeTransferFrom(\n            _pendleMarket,\n            msg.sender,\n            address(this),\n            sendingAmount\n        );\n\n        IPendlePowerFarmToken(pendleChildAddress[_pendleMarket]).addCompoundRewards(\n            sendingAmount\n        );\n\n        _safeTransfer(\n            childInfo.rewardTokens[index],\n            msg.sender,\n            _rewardAmount\n        );\n\n        emit ExchangeRewardsForCompounding(\n            _pendleMarket,\n            _rewardToken,\n            _rewardAmount,\n            sendingAmount\n        );\n\n        return sendingAmount;\n    }\n\n    function exchangeLpFeesForPendleWithIncentive(\n        address _pendleMarket,\n        uint256 _pendleChildShares\n    )\n        external\n        syncSupply(_pendleMarket)\n        returns (\n            uint256,\n            uint256\n        )\n    {\n        if (_pendleChildShares == 0) {\n            revert ZeroShares();\n        }\n\n        address pendleChild = pendleChildAddress[\n            _pendleMarket\n        ];\n\n        uint256 tokenAmountSend = _getAmountToSend(\n            PENDLE_TOKEN_ADDRESS,\n            _getTokensInETH(\n                pendleChild,\n                _pendleChildShares\n            )\n        );\n\n        reservedPendleForLocking += tokenAmountSend;\n\n        _safeTransferFrom(\n            PENDLE_TOKEN_ADDRESS,\n            msg.sender,\n            address(this),\n            tokenAmountSend\n        );\n\n        uint256 withdrawnAmount = IPendlePowerFarmToken(pendleChild).withdrawExactShares(\n            _pendleChildShares\n        );\n\n        _safeTransfer(\n            _pendleMarket,\n            msg.sender,\n            withdrawnAmount\n        );\n\n        emit ExchangeLpFeesForPendle(\n            _pendleMarket,\n            _pendleChildShares,\n            tokenAmountSend,\n            withdrawnAmount\n        );\n\n        return(\n            tokenAmountSend,\n            withdrawnAmount\n        );\n    }\n\n    function skim(\n        address _pendleMarket\n    )\n        external\n        returns (uint256)\n    {\n        address childMarket = pendleChildAddress[\n            _pendleMarket\n        ];\n\n        if (childMarket == ZERO_ADDRESS) {\n            revert WrongAddress();\n        }\n\n        uint256 balance = IPendleMarket(_pendleMarket).balanceOf(\n            address(this)\n        );\n\n        uint256 totalAssets = IPendlePowerFarmToken(\n            childMarket\n        ).totalLpAssets();\n\n        if (balance < totalAssets + 1) {\n            revert NothingToSkim();\n        }\n\n        uint256 difference = balance\n            - totalAssets\n            + 1;\n\n        _safeTransfer(\n            _pendleMarket,\n            master,\n            difference\n        );\n\n        return difference;\n    }\n\n    function addPendleMarket(\n        address _pendleMarket,\n        string memory _tokenName,\n        string memory _symbolName,\n        uint16 _maxCardinality\n    )\n        external\n        onlyMaster\n    {\n        if (pendleChildAddress[_pendleMarket] > ZERO_ADDRESS) {\n            revert AlreadySet();\n        }\n\n        address pendleChild = PENDLE_POWER_FARM_TOKEN_FACTORY.deploy(\n            _pendleMarket,\n            _tokenName,\n            _symbolName,\n            _maxCardinality\n        );\n\n        pendleChildAddress[_pendleMarket] = pendleChild;\n\n        _setRewardTokens(\n            _pendleMarket,\n            _getRewardTokens(\n                _pendleMarket\n            )\n        );\n\n        CompoundStruct storage childInfo = pendleChildCompoundInfo[\n            _pendleMarket\n        ];\n\n        uint256 rewardTokensLength = childInfo\n            .rewardTokens\n            .length;\n\n        childInfo.lastIndex = new uint128[](\n            rewardTokensLength\n        );\n\n        childInfo.reservedForCompound = new uint256[](\n            rewardTokensLength\n        );\n\n        uint256 i;\n\n        while (i < rewardTokensLength) {\n\n            address token = childInfo.rewardTokens[i];\n\n            childInfo.lastIndex[i] = _getUserRewardIndex(\n                _pendleMarket,\n                token,\n                address(this)\n            );\n\n            childInfo.reservedForCompound[i] = 0;\n\n            _checkFeed(\n                token\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        _checkFeed(\n            _pendleMarket\n        );\n\n        activePendleMarkets.push(\n            _pendleMarket\n        );\n\n        emit AddPendleMarket(\n            _pendleMarket,\n            pendleChild\n        );\n    }\n\n    function updateRewardTokens(\n        address _pendleMarket\n    )\n        external\n        onlyChildContract(_pendleMarket)\n        returns (bool)\n    {\n        address[] memory rewardTokens = _getRewardTokens(\n            _pendleMarket\n        );\n\n        if (_compareHashes(_pendleMarket, rewardTokens) == true) {\n            return false;\n        }\n\n        _setRewardTokens(\n            _pendleMarket,\n            rewardTokens\n        );\n\n        emit UpdateRewardTokens(\n            _pendleMarket,\n            rewardTokens\n        );\n\n        return true;\n    }\n\n    function changeExchangeIncentive(\n        uint256 _newExchangeIncentive\n    )\n        external\n        onlyMaster\n    {\n        exchangeIncentive = _newExchangeIncentive;\n\n        emit ChangeExchangeIncentive(\n            _newExchangeIncentive\n        );\n    }\n\n    function changeMintFee(\n        address _pendleMarket,\n        uint256 _newFee\n    )\n        external\n        onlyMaster\n    {\n        address child = pendleChildAddress[\n            _pendleMarket\n        ];\n\n        if (child == ZERO_ADDRESS) {\n            revert WrongAddress();\n        }\n\n        IPendlePowerFarmToken(\n            child\n        ).changeMintFee(\n            _newFee\n        );\n\n        emit ChangeMintFee(\n            _pendleMarket,\n            _newFee\n        );\n    }\n\n    /**\n     * @dev Can also be used to extend existing lock.\n     */\n    function lockPendle(\n        uint256 _amount,\n        uint128 _weeks,\n        bool _fromInside,\n        bool _sameExpiry\n    )\n        external\n        onlyMaster\n        returns (uint256 newVeBalance)\n    {\n        syncAllSupply();\n\n        uint256 currentExpiry = _getExpiry();\n\n        uint128 expiry = _sameExpiry\n            ? uint128(currentExpiry)\n            : _calcExpiry(\n                _weeks\n            );\n\n        if (uint256(expiry) < currentExpiry) {\n            revert LockTimeTooShort();\n        }\n\n        if (_amount > 0) {\n\n            _safeApprove(\n                PENDLE_TOKEN_ADDRESS,\n                VE_PENDLE_CONTRACT_ADDRESS,\n                _amount\n            );\n\n            if (_fromInside == false) {\n                _safeTransferFrom(\n                    PENDLE_TOKEN_ADDRESS,\n                    msg.sender,\n                    address(this),\n                    _amount\n                );\n            }\n        }\n\n        newVeBalance = PENDLE_LOCK.increaseLockPosition(\n            uint128(_amount),\n            expiry\n        );\n\n        syncAllSupply();\n\n        if (_fromInside == false) {\n            return newVeBalance;\n        }\n\n        if (_amount > 0) {\n            reservedPendleForLocking -= _amount;\n        }\n\n        emit LockPendle(\n            _amount,\n            expiry,\n            newVeBalance,\n            _fromInside,\n            _sameExpiry,\n            block.timestamp\n        );\n    }\n\n    function claimArb(\n        uint256 _accrued,\n        bytes32[] calldata _proof\n    )\n        external\n        onlyArbitrum\n    {\n        ARB_REWARDS.claim(\n            master,\n            _accrued,\n            _proof\n        );\n\n        emit ClaimArb(\n            _accrued,\n            _proof,\n            block.timestamp\n        );\n    }\n\n    function withdrawLock()\n        external\n        onlyMaster\n        returns (uint256 amount)\n    {\n        if (IS_ETH_MAIN == false) {\n\n            amount = reservedPendleForLocking;\n            reservedPendleForLocking = 0;\n\n            _safeTransfer(\n                PENDLE_TOKEN_ADDRESS,\n                master,\n                amount\n            );\n\n            emit WithdrawLock(\n                amount,\n                block.timestamp\n            );\n\n            return amount;\n        }\n\n        if (_getExpiry() > block.timestamp) {\n            revert NotExpired();\n        }\n\n        syncAllSupply();\n\n        amount = PENDLE_LOCK.withdraw();\n\n        _safeTransfer(\n            PENDLE_TOKEN_ADDRESS,\n            master,\n            amount\n        );\n\n        syncAllSupply();\n\n        emit WithdrawLock(\n            amount,\n            block.timestamp\n        );\n    }\n\n    function increaseReservedForCompound(\n        address _pendleMarket,\n        uint256[] calldata _amounts\n    )\n        external\n        onlyChildContract(_pendleMarket)\n    {\n        CompoundStruct memory childInfo = pendleChildCompoundInfo[\n            _pendleMarket\n        ];\n\n        uint256 i;\n        uint256 length = childInfo.rewardTokens.length;\n\n        while (i < length) {\n            childInfo.reservedForCompound[i] += _amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n\n        pendleChildCompoundInfo[_pendleMarket] = childInfo;\n\n        emit IncreaseReservedForCompound(\n            _pendleMarket,\n            _amounts\n        );\n    }\n\n    function overWriteIndex(\n        address _pendleMarket,\n        uint256 _tokenIndex\n    )\n        public\n        onlyChildContract(_pendleMarket)\n    {\n        CompoundStruct storage childInfo = pendleChildCompoundInfo[\n            _pendleMarket\n        ];\n\n        childInfo.lastIndex[_tokenIndex] = _getUserRewardIndex(\n            _pendleMarket,\n            childInfo.rewardTokens[_tokenIndex],\n            address(this)\n        );\n    }\n\n    function overWriteIndexAll(\n        address _pendleMarket\n    )\n        external\n        onlyChildContract(_pendleMarket)\n    {\n        uint256 i;\n        uint256 length = pendleChildCompoundInfo[\n            _pendleMarket\n        ].rewardTokens.length;\n\n        while (i < length) {\n            overWriteIndex(\n                _pendleMarket,\n                i\n            );\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function overWriteAmounts(\n        address _pendleMarket\n    )\n        external\n        onlyChildContract(_pendleMarket)\n    {\n        CompoundStruct storage childInfo = pendleChildCompoundInfo[\n            _pendleMarket\n        ];\n\n        childInfo.reservedForCompound = new uint256[](\n            childInfo.rewardTokens.length\n        );\n    }\n\n    function claimVoteRewards(\n        uint256 _amount,\n        bytes32[] calldata _merkleProof\n    )\n        external\n    {\n        PENDLE_VOTE_REWARDS.claimRetail(\n            address(this),\n            _amount,\n            _merkleProof\n        );\n\n        emit ClaimVoteRewards(\n            _amount,\n            _merkleProof,\n            block.timestamp\n        );\n    }\n\n    function forwardETH(\n        address _to,\n        uint256 _amount\n    )\n        external\n        onlyMaster\n    {\n        payable(_to).transfer(\n            _amount\n        );\n    }\n\n    function vote(\n        address[] calldata _pools,\n        uint64[] calldata _weights\n    )\n        external\n        onlyMaster\n    {\n        if (_weights.length != _pools.length) {\n            revert InvalidLength();\n        }\n\n        uint256 i;\n        uint256 len = _weights.length;\n\n        uint256 weightSum;\n\n        while (i < len) {\n            unchecked {\n                weightSum += _weights[i];\n                ++i;\n            }\n        }\n\n        if (weightSum > PRECISION_FACTOR_E18) {\n            revert InvalidWeightSum();\n        }\n\n        PENDLE_VOTER.vote(\n            _pools,\n            _weights\n        );\n    }\n}"
    }
  ]
}