{
  "Title": "[M-03] `setUnboundedKerosineVault` not called during deployment, causing reverts when querying for Kerosene value after adding it as a Kerosene vault",
  "Content": "\n<https://github.com/code-423n4/2024-04-dyad/blob/cd48c684a58158de444b24854ffd8f07d046c31b/script/deploy/Deploy.V2.s.sol#L78-L82>\n\n<https://github.com/code-423n4/2024-04-dyad/blob/cd48c684a58158de444b24854ffd8f07d046c31b/src/core/Vault.kerosine.bounded.sol#L23-L30>\n\n<https://github.com/code-423n4/2024-04-dyad/blob/cd48c684a58158de444b24854ffd8f07d046c31b/README.md?plain=1#L66-L68>\n\n### Root Cause\n\nThe `setUnboundedKerosineVault` function was never called during deployment, nor was it planned to be called post deployment.\n\n### Impact\n\nWithout setting the `unboundedKerosineVault`, any attempt to get the asset price of a dNFT that has uses the bounded Kerosene vault will result in a revert.\n\n### Note Regarding Vault Licenser\n\n`VaultManagerV2`'s `addKerosene()` erroneously does a vault license check using `keroseneManager.isLicensed(vault)` at [`VaultManagerV2.sol#L88`](https://github.com/code-423n4/2024-04-dyad/blob/cd48c684a58158de444b24854ffd8f07d046c31b/src/core/VaultManagerV2.sol#L88) making it impossible to add Kerosene vaults to Notes.\n\nAs clarified by the sponsor in this video [DYAD V2- Kerosene - Code4rena Audit #2](https://www.youtube.com/watch?v=64zoj0iLCy0), the vaults in `keroseneManager` are intended to be used for kerosene value calculation and kerosene vaults are not supposed to be added there.  We updated the relevant Kerosene vault license checks to use `vaultLicenser.isLicensed(vault)` instead as it is aligned with the deployment script at [`Deploy.V2.s.sol#L95`](https://github.com/code-423n4/2024-04-dyad/blob/cd48c684a58158de444b24854ffd8f07d046c31b/script/deploy/Deploy.V2.s.sol#L95) since `unboundedKerosineVault` is added as a licensed vault with `vaultLicenser.add(address(unboundedKerosineVault))`\n\nThe two following code changes were made to `VaultManagerV2.sol` so that the unbounded kerosene vault can be added as a kerosene vault without further changes in the vaults, the vault manager, or the deployment script.\n\n[`VaultManagerV2.sol#L88`](https://github.com/code-423n4/2024-04-dyad/blob/cd48c684a58158de444b24854ffd8f07d046c31b/src/core/VaultManagerV2.sol#L88)\n\nFrom:\n\n```solidity\nif (!keroseneManager.isLicensed(vault))                 revert VaultNotLicensed();\n```\n\nTo:\n\n```solidity\nif (!vaultLicenser.isLicensed(vault))                   revert VaultNotLicensed();\n```\n\nand [`VaultManagerV2.sol#L280`](https://github.com/code-423n4/2024-04-dyad/blob/cd48c684a58158de444b24854ffd8f07d046c31b/src/core/VaultManagerV2.sol#L280)\n\nFrom:\n\n```solidity\nif (keroseneManager.isLicensed(address(vault))) {\n```\n\nTo:\n\n```solidity\nif (vaultLicenser.isLicensed(address(vault))) {\n```\n\n### Proof of Concept\n\nThe following test script demonstrates that the `getKeroseneValue` function reverts when the `unboundedKerosineVault` is not set during deployment.\n\n    forge t --mt test_boundedVaultValueRevert --fork-url <MAINNET_RPC_URL> -vv\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport \"forge-std/console.sol\";\nimport \"forge-std/Test.sol\";\n\nimport {DeployV2, Contracts} from \"../../script/deploy/Deploy.V2.s.sol\";\nimport {Licenser} from \"../../src/core/Licenser.sol\";\nimport {Parameters} from \"../../src/params/Parameters.sol\";\nimport {WETH} from \"../WETH.sol\";\nimport {DNft} from \"../../src/core/DNft.sol\";\n\ncontract V2TestBoundedKeroseneVault is Test, Parameters {\n\n  Contracts contracts;\n\n  function setUp() public {\n    contracts = new DeployV2().run();\n  }\n\n  function test_boundedVaultValueRevert() public {\n    Licenser licenser = Licenser(MAINNET_VAULT_MANAGER_LICENSER);\n    vm.prank(MAINNET_OWNER);\n    licenser.add(address(contracts.vaultManager));\n\n    address alice = makeAddr(\"alice\");\n    vm.prank(MAINNET_OWNER);\n    uint aliceTokenId = DNft(MAINNET_DNFT).mintInsiderNft(alice);    \n\n    // drop 1000 eth into ethVault for initial TVL used for calculating kerosene price\n    vm.deal(address(contracts.ethVault), 1000 ether);\n    vm.prank(address(contracts.ethVault));\n    WETH(payable(MAINNET_WETH)).deposit{value: 1000 ether}();\n\n    // add boundedKerosineVault as a licensed vault since it was commented out in the deploy script\n    vm.prank(MAINNET_OWNER);\n    contracts.vaultLicenser.add(address(contracts.boundedKerosineVault));\n\n    // add boundedKerosineVault to kerosene vault\n    vm.prank(alice);\n    contracts.vaultManager.addKerosene(aliceTokenId, address(contracts.boundedKerosineVault));\n\n    // getKeroseneValue now reverts\n    vm.expectRevert();\n    contracts.vaultManager.getKeroseneValue(aliceTokenId);\n\n    // set the unbounded kerosine vault for the bounded kerosine vault\n    vm.prank(MAINNET_OWNER);\n    contracts.boundedKerosineVault.setUnboundedKerosineVault(contracts.unboundedKerosineVault);\n\n    // this is fine now\n    contracts.vaultManager.getKeroseneValue(aliceTokenId);\n\n  }\n}\n```\n\n### Recommended Mitigation Steps\n\nSet the `unboundedKerosineVault` during deployment.\n\n### Changes to `DeployV2`\n\nCall the `setUnboundedKerosineVault` function during deployment after deploying the bounded Kerosene vault at [`Deploy.V2.s.sol#L78-L82`](https://github.com/code-423n4/2024-04-dyad/blob/cd48c684a58158de444b24854ffd8f07d046c31b/script/deploy/Deploy.V2.s.sol#L78-L82):\n\n```solidity\nboundedKerosineVault.setUnboundedKerosineVault(unboundedKerosineVault);\n```\n\n**[shafu0x (DYAD) acknowledged and commented](https://github.com/code-423n4/2024-04-dyad-findings/issues/829#issuecomment-2091721967):**\n > Doesn't necessarily need to be called in the deployment script.\n\n**[McToady (warden) commented](https://github.com/code-423n4/2024-04-dyad-findings/issues/829#issuecomment-2113716202):**\n > While the sponsor comment is true, the documentation in the audit's README explicitly states:\n> [The whole migration is described in Deploy.V2.s.sol. The only transaction that needs to be done by the multi-sig after the deployment is licensing the new Vault Manager](https://code4rena.com/audits/2024-04-dyad#top).\n> \n> This finding shows that this is, in fact, not the case and that the comments in the provided documentation suggest the team were unaware this would be an issue. Given the deploy script is within the scope of the audit, I believe this issue is a valid finding. If this issue had not been raised and the protocol had deployed as they previously outlined, users who deposit would have their funds stuck (due to both the `withdraw` and `mintDyad` functions reverting) until the DYAD team themselves worked out what the issue was and called the necessary function.\n\n**[Koolex (judge) commented](https://github.com/code-423n4/2024-04-dyad-findings/issues/829#issuecomment-2122885444):**\n > The statement in README is about the migration from `VaultManager` to `VaultManagerV2`.\n> \n> > users who deposit would have their funds stuck (due to both the `withdraw` and `mintDyad` functions reverting). \n> \n> Not sure how the funds will be stuck if the `UnboundedKerosineVault` is not set. `UnboundedKerosineVault` is used in `BoundedKerosineVault` to retrieve the price. So, BoundedKerosineVault will not function till this is set. Furthermore, withdraw is disallowed in `BoundedKerosineVault`.\n\n**[McToady (warden) commented](https://github.com/code-423n4/2024-04-dyad-findings/issues/829#issuecomment-2123597403):**\n > @Koolex - Funds will be stuck because the value of all a users collateral is checked on withdraw (not just the collateral they're attempting to withdraw) in the `collatRatio(id)` call. Therefore, if they have added the bounded kerosene vault to their `vaults`, mapping the `withdraw` function will revert when attempting to calculate the value of their bounded kerosene.\n\n**[Koolex (judge) commented](https://github.com/code-423n4/2024-04-dyad-findings/issues/829#issuecomment-2136837951):**\n > After reviewing README and the comments above again, because of:\n> \n> 1. There is an impact (clarified already by the warden) that will make the protocol not function.\n> 2. The statement in README.\n> \n> > The whole migration is described in Deploy.V2.s.sol. The only transaction that needs to be done by the multi-sig after the deployment is licensing the new Vault Manager.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-04-dyad",
  "Code": [
    {
      "filename": "script/deploy/Deploy.V2.s.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport \"forge-std/Script.sol\";\n\nimport {Parameters}             from \"../../src/params/Parameters.sol\";\nimport {VaultManagerV2}         from \"../../src/core/VaultManagerV2.sol\";\nimport {DNft}                   from \"../../src/core/DNft.sol\";\nimport {Dyad}                   from \"../../src/core/Dyad.sol\";\nimport {Licenser}               from \"../../src/core/Licenser.sol\";\nimport {Vault}                  from \"../../src/core/Vault.sol\";\nimport {VaultWstEth}            from \"../../src/core/Vault.wsteth.sol\";\nimport {IWETH}                  from \"../../src/interfaces/IWETH.sol\";\nimport {IAggregatorV3}          from \"../../src/interfaces/IAggregatorV3.sol\";\nimport {KerosineManager}        from \"../../src/core/KerosineManager.sol\";\nimport {UnboundedKerosineVault} from \"../../src/core/Vault.kerosine.unbounded.sol\";\nimport {BoundedKerosineVault}   from \"../../src/core/Vault.kerosine.bounded.sol\";\nimport {Kerosine}               from \"../../src/staking/Kerosine.sol\";\nimport {KerosineDenominator}    from \"../../src/staking/KerosineDenominator.sol\";\n\nimport {ERC20} from \"@solmate/src/tokens/ERC20.sol\";\n\nstruct Contracts {\n  Kerosine               kerosene;\n  Licenser               vaultLicenser;\n  VaultManagerV2         vaultManager;\n  Vault                  ethVault;\n  VaultWstEth            wstEth;\n  KerosineManager        kerosineManager;\n  UnboundedKerosineVault unboundedKerosineVault;\n  BoundedKerosineVault   boundedKerosineVault;\n  KerosineDenominator    kerosineDenominator;\n}\n\ncontract DeployV2 is Script, Parameters {\n  function run() public returns (Contracts memory) {\n    vm.startBroadcast();  // ----------------------\n\n    Licenser vaultLicenser = new Licenser();\n\n    // Vault Manager needs to be licensed through the Vault Manager Licenser\n    VaultManagerV2 vaultManager = new VaultManagerV2(\n      DNft(MAINNET_DNFT),\n      Dyad(MAINNET_DYAD),\n      vaultLicenser\n    );\n\n    // weth vault\n    Vault ethVault = new Vault(\n      vaultManager,\n      ERC20        (MAINNET_WETH),\n      IAggregatorV3(MAINNET_WETH_ORACLE)\n    );\n\n    // wsteth vault\n    VaultWstEth wstEth = new VaultWstEth(\n      vaultManager, \n      ERC20        (MAINNET_WSTETH), \n      IAggregatorV3(MAINNET_CHAINLINK_STETH)\n    );\n\n    KerosineManager kerosineManager = new KerosineManager();\n\n    kerosineManager.add(address(ethVault));\n    kerosineManager.add(address(wstEth));\n\n    vaultManager.setKeroseneManager(kerosineManager);\n\n    kerosineManager.transferOwnership(MAINNET_OWNER);\n\n    UnboundedKerosineVault unboundedKerosineVault = new UnboundedKerosineVault(\n      vaultManager,\n      Kerosine(MAINNET_KEROSENE), \n      Dyad    (MAINNET_DYAD),\n      kerosineManager\n    );\n\n    BoundedKerosineVault boundedKerosineVault     = new BoundedKerosineVault(\n      vaultManager,\n      Kerosine(MAINNET_KEROSENE), \n      kerosineManager\n    );\n\n    KerosineDenominator kerosineDenominator       = new KerosineDenominator(\n      Kerosine(MAINNET_KEROSENE)\n    );\n\n    unboundedKerosineVault.setDenominator(kerosineDenominator);\n\n    unboundedKerosineVault.transferOwnership(MAINNET_OWNER);\n    boundedKerosineVault.  transferOwnership(MAINNET_OWNER);\n\n    vaultLicenser.add(address(ethVault));\n    vaultLicenser.add(address(wstEth));\n    vaultLicenser.add(address(unboundedKerosineVault));\n    // vaultLicenser.add(address(boundedKerosineVault));\n\n    vaultLicenser.transferOwnership(MAINNET_OWNER);\n\n    vm.stopBroadcast();  // ----------------------------\n\n    return Contracts(\n      Kerosine(MAINNET_KEROSENE),\n      vaultLicenser,\n      vaultManager,\n      ethVault,\n      wstEth,\n      kerosineManager,\n      unboundedKerosineVault,\n      boundedKerosineVault,\n      kerosineDenominator\n    );\n  }\n}"
    },
    {
      "filename": "src/core/Vault.kerosine.bounded.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport {KerosineVault}          from \"./Vault.kerosine.sol\";\nimport {IVaultManager}          from \"../interfaces/IVaultManager.sol\";\nimport {Dyad}                   from \"./Dyad.sol\";\nimport {KerosineManager}        from \"./KerosineManager.sol\";\nimport {UnboundedKerosineVault} from \"./Vault.kerosine.unbounded.sol\";\n\nimport {ERC20} from \"@solmate/src/tokens/ERC20.sol\";\n\ncontract BoundedKerosineVault is KerosineVault {\n  error NotWithdrawable(uint id, address to, uint amount);\n\n  UnboundedKerosineVault public unboundedKerosineVault;\n\n  constructor(\n    IVaultManager   _vaultManager,\n    ERC20           _asset, \n    KerosineManager _kerosineManager\n  ) KerosineVault(_vaultManager, _asset, _kerosineManager) {}\n\n  function setUnboundedKerosineVault(\n    UnboundedKerosineVault _unboundedKerosineVault\n  )\n    external\n    onlyOwner\n  {\n    unboundedKerosineVault = _unboundedKerosineVault;\n  }\n\n  function withdraw(\n    uint    id,\n    address to,\n    uint    amount\n  ) \n    external \n    view\n      onlyVaultManager\n  {\n    revert NotWithdrawable(id, to, amount);\n  }\n\n  function assetPrice() \n    public \n    view \n    override\n    returns (uint) {\n      return unboundedKerosineVault.assetPrice() * 2;\n  }\n}"
    },
    {
      "filename": "README.md?plain=1",
      "content": "# DYAD audit details\n- Total Prize Pool: $36,500 in USDC\n  - HM awards: $28,800 in USDC\n  - QA awards: $1,200 in USDC \n  - Judge awards: $3,600 in USDC\n  - Lookout awards: $2,400 USDC\n  - Scout awards: $500 in USDC\n \n- Join [C4 Discord](https://discord.gg/code4rena) to register\n- Submit findings [using the C4 form](https://code4rena.com/contests/2024-04-dyad/submit)\n- [Read our guidelines for more details](https://docs.code4rena.com/roles/wardens)\n- Starts April 18, 2024 20:00 UTC\n- Ends April 25, 2024 20:00 UTC\n\n## Automated Findings / Publicly Known Issues\n\nThe 4naly3er report can be found [here](https://github.com/code-423n4/2024-04-dyad/blob/main/4naly3er-report.md).\n\n\n\n_Note for C4 wardens: Anything included in this `Automated Findings / Publicly Known Issues` section is considered a publicly known issue and is ineligible for awards._\n* DYAD Multisig controls most of the protocol right now.\n* Unlicensing a vault can cause issues.\n\n# Overview\nDYAD is the first truly capital efficient decentralized stablecoin. Traditionally, two costs make stablecoins inefficient: surplus collateral and DEX liquidity. DYAD minimizes both of these costs through Kerosene, a token that lowers the individual cost to mint DYAD. \n# DYAD\n\n![dyad](https://github.com/code-423n4/2024-04-dyad/blob/main/dyadlogo.jpg?raw=true)\n\n## Contracts\n\n```ml\ncore\n├─ DNft — \"A dNFT gives you the right to mint DYAD\"\n├─ Dyad — \"Stablecoin backed by ETH\"\n├─ VaultManager - \"Manage Vaults for DNfts\"\n├─ VaultManagerV2 - \"VaultManager with flash loan protection\"\n├─ Vault - \"Holds different collateral types\"\n├─ Licenser - \"License VaultManagers or Vaults\"\n├─ KerosineManager - \"Add/Remove Vaults to the Kerosene Calculation\"\n\nstaking\n├─ Kerosine - \"Kerosene ERC20\"\n├─ KerosineDenominator\n├─ Staking - \"Simple staking contract\"\n\nperiphery\n├─ Payments\n```\n\n### Deployed Contracts\n\nAll on Ethereum Mainnet\n\n| Contract | Address |\n|----------|----------|\n| DYAD             | [0x305B58c5F6B5b6606fb13edD11FbDD5e532d5A26](https://etherscan.io/address/0x305b58c5f6b5b6606fb13edd11fbdd5e532d5a26) |\n| dNFT             | [0xDc400bBe0B8B79C07A962EA99a642F5819e3b712](https://etherscan.io/address/0xdc400bbe0b8b79c07a962ea99a642f5819e3b712) |\n| Vault Manager v1 | [0xfaa785c041181a54c700fD993CDdC61dbBfb420f](https://etherscan.io/address/0xfaa785c041181a54c700fd993cddc61dbbfb420f) |\n| wETH Vault       | [0xcF97cEc1907CcF9d4A0DC4F492A3448eFc744F6c](https://etherscan.io/address/0xcf97cec1907ccf9d4a0dc4f492a3448efc744f6c) |\n| wstETH Vault     | [0x7aE80418051b2897729Cbdf388b07C5158C557A1](https://etherscan.io/address/0x7ae80418051b2897729cbdf388b07c5158c557a1)|\n\n### Migration\nThe goal is to migrate from VaultManager to VaultManagerV2. The main reason is the need for a flash loan protection which makes it harder to manipulate the deterministic Kerosene price.\nThe whole migration is described in `Deploy.V2.s.sol`. The only transaction that needs to be done by the multi-sig after the deployment is licensing the new Vault Manager.\n\n## Links\n\n- **Previous audits:**  None\n- **Documentation:** https://dyadstable.notion.site/DYAD-design-outline-v5-1-3fa96f99425e458abbe574f67b795145?pvs=4\n- **Website:** https://www.dyadstable.xyz/\n- **X/Twitter:** https://twitter.com/0xDYAD\n- **Discord:** https://t.co/nzml0Wapkt\n\n---\n\n# Scope\n\n*See [scope.txt](https://github.com/code-423n4/2024-04-dyad/blob/main/scope.txt)*\n\n### Files in scope\n\n\n| File   | Logic Contracts | Interfaces | SLOC  | Purpose | Libraries used |\n| ------ | --------------- | ---------- | ----- | -----   | ------------ |\n| [/src/staking/KerosineDenominator.sol](https://github.com/code-423n4/2024-04-dyad/blob/main/src/staking/KerosineDenominator.sol) | 1| **** | 14 | ||\n| [/src/core/VaultManagerV2.sol](https://github.com/code-423n4/2024-04-dyad/blob/main/src/core/VaultManagerV2.sol) | 1| **** | 166 | ||\n| [/src/core/Vault.kerosine.sol](https://github.com/code-423n4/2024-04-dyad/blob/main/src/core/Vault.kerosine.sol) | 1| **** | 62 | |@solmate/src/utils/SafeTransferLib.sol<br>@solmate/src/tokens/ERC20.sol<br>@solmate/src/auth/Owned.sol|\n| [/src/core/KerosineManager.sol](https://github.com/code-423n4/2024-04-dyad/blob/main/src/core/KerosineManager.sol) | 1| **** | 34 | |@openzeppelin/contracts/utils/structs/EnumerableSet.sol<br>@solmate/src/auth/Owned.sol|\n| [/src/core/Vault.kerosine.bounded.sol](https://github.com/code-423n4/2024-04-dyad/blob/main/src/core/Vault.kerosine.bounded.sol) | 1| **** | 42 | |@solmate/src/tokens/ERC20.sol|\n| [/src/core/Vault.kerosine.unbounded.sol](https://github.com/code-423n4/2024-04-dyad/blob/main/src/core/Vault.kerosine.unbounded.sol) | 1| **** | 60 | |@solmate/src/tokens/ERC20.sol<br>@solmate/src/utils/SafeTransferLib.sol|\n| [/script/deploy/Deploy.V2.s.sol](https://github.com/code-423n4/2024-04-dyad/blob/main/script/deploy/Deploy.V2.s.sol) | 1| **** | 87 | |forge-std/Script.sol<br>@solmate/src/tokens/ERC20.sol|\n| **Totals** | **7** | **** | **465** | | |\n\n### Files out of scope\n\n*See [out_of_scope.txt](https://github.com/code-423n4/2024-04-dyad/blob/main/out_of_scope.txt)*\n\n| File         |\n| ------------ |\n| ./script/Read.s.sol |\n| ./script/deploy/DeployBase.s.sol |\n| ./script/mock/transfer.wsteth.s.sol |\n| ./src/core/DNft.sol |\n| ./src/core/Dyad.sol |\n| ./src/core/Licenser.sol |\n| ./src/core/Vault.sol |\n| ./src/core/Vault.wsteth.sol |\n| ./src/interfaces/IAggregatorV3.sol |\n| ./src/interfaces/IDNft.sol |\n| ./src/interfaces/IDyad.sol |\n| ./src/interfaces/IStaking.sol |\n| ./src/interfaces/IVault.sol |\n| ./src/interfaces/IVaultManager.sol |\n| ./src/interfaces/IWETH.sol |\n| ./src/interfaces/IWstETH.sol |\n| ./src/params/DNftParameters.sol |\n| ./src/params/Parameters.sol |\n| ./src/periphery/Payments.sol |\n| ./src/staking/Kerosine.sol |\n| ./src/staking/Staking.sol |\n| ./test/BaseTest.sol |\n| ./test/ERC20Mock.sol |\n| ./test/OracleMock.sol |\n| ./test/Payments.t.sol |\n| ./test/Vault.wsteth.t.sol |\n| ./test/VaultManager.t.sol |\n| ./test/VaultManagerHelper.t.sol |\n| ./test/WETH.sol |\n| ./test/fork/v2.t.sol |\n|./src/core/VaultManager.sol|\n| Totals: 31 |\n\n## Scoping Q &amp; A\n\n### General questions\n\n| Question                                | Answer                       |\n| --------------------------------------- | ---------------------------- |\n| ERC20 used by the protocol              |       Kerosene, weth, wseth   |\n| Test coverage                           | 33.64%                        |\n| ERC721 used  by the protocol            |            DNFT             |\n| ERC777 used by the protocol             |           None                |\n| ERC1155 used by the protocol            |              None            |\n| Chains the protocol will be deployed on | Ethereum |\n\n### ERC20 token behaviors in scope\n\n- The only tokens in scope are: weth, wsteth.\n- Vulnerabilities related to these token behaviours are only considered valid if they actually exist in tokens which are used, i.e. Kerosene, weth, etc.\n\n### External integrations (e.g., Uniswap) behavior in scope:\n\n\n| Question                                                  | Answer |\n| --------------------------------------------------------- | ------ |\n| Enabling/disabling fees (e.g. Blur disables/enables fees) | No   |\n| Pausability (e.g. Uniswap pool gets paused)               |  Yes   |\n| Upgradeability (e.g. Uniswap gets upgraded)               |   Yes  |\n\n\n### EIP compliance\nNone\n\n\n# Additional context\n\n## Main invariants\n\n- TVL > DYAD total supply\n\n\n## Attack ideas (where to focus for bugs)\n* Manipulation of Kerosene Price.\n\n* Flash Loan attacks.\n\n\n\n## All trusted roles in the protocol\n\nDYAD Multisig: 0xDeD796De6a14E255487191963dEe436c45995813\n\n\n| Role                                | Description                       |\n| --------------------------------------- | ---------------------------- |\n| DYAD Multisig                          | Ability to: License new Vault Manager, License new Vaults, Change the kerosene denominator contract, Add new vaults to the Kerosene Manager               |\n\n\n## Any novel or unique curve logic or mathematical models implemented in the contracts:\n\nNone\n\n\n## Running tests\n\n\n```bash\ngit clone https://github.com/code-423n4/2024-04-dyad.git\ngit submodule update --init --recursive\ncd 2024-04-dyad\nforge install\nforge test\n```\nTo run code coverage\n```bash\nforge coverage\n```\nTo run gas benchmarks\n```bash\nforge test --gas-report\n```\n\n![Screenshot from 2024-04-18 17-44-08](https://github.com/code-423n4/2024-04-dyad/blob/main/screenshot1.png?raw=true)\n![Screenshot from 2024-04-18 17-45-57](https://github.com/code-423n4/2024-04-dyad/blob/main/screenshot2.png?raw=true)\n![Screenshot from 2024-04-18 17-46-17](https://github.com/code-423n4/2024-04-dyad/blob/main/screenshot3.png?raw=true)\n![Screenshot from 2024-04-18 17-47-42](https://github.com/code-423n4/2024-04-dyad/blob/main/screenshot4.png?raw=true)\n![Screenshot from 2024-04-18 17-48-09](https://github.com/code-423n4/2024-04-dyad/blob/main/screenshot5.png?raw=true)\n\n\n\n\n## Miscellaneous\nEmployees of DYAD and employees' family members are ineligible to participate in this audit."
    },
    {
      "filename": "src/core/VaultManagerV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport {DNft}            from \"./DNft.sol\";\nimport {Dyad}            from \"./Dyad.sol\";\nimport {Licenser}        from \"./Licenser.sol\";\nimport {Vault}           from \"./Vault.sol\";\nimport {IVaultManager}   from \"../interfaces/IVaultManager.sol\";\nimport {KerosineManager} from \"../../src/core/KerosineManager.sol\";\n\nimport {FixedPointMathLib} from \"@solmate/src/utils/FixedPointMathLib.sol\";\nimport {ERC20}             from \"@solmate/src/tokens/ERC20.sol\";\nimport {SafeTransferLib}   from \"@solmate/src/utils/SafeTransferLib.sol\";\nimport {EnumerableSet}     from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {Initializable}     from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\ncontract VaultManagerV2 is IVaultManager, Initializable {\n  using EnumerableSet     for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint;\n  using SafeTransferLib   for ERC20;\n\n  uint public constant MAX_VAULTS          = 5;\n  uint public constant MAX_VAULTS_KEROSENE = 5;\n\n  uint public constant MIN_COLLATERIZATION_RATIO = 1.5e18; // 150%\n  uint public constant LIQUIDATION_REWARD        = 0.2e18; //  20%\n\n  DNft     public immutable dNft;\n  Dyad     public immutable dyad;\n  Licenser public immutable vaultLicenser;\n\n  KerosineManager public keroseneManager;\n\n  mapping (uint => EnumerableSet.AddressSet) internal vaults; \n  mapping (uint => EnumerableSet.AddressSet) internal vaultsKerosene; \n\n  mapping (uint => uint) public idToBlockOfLastDeposit;\n\n  modifier isDNftOwner(uint id) {\n    if (dNft.ownerOf(id) != msg.sender)   revert NotOwner();    _;\n  }\n  modifier isValidDNft(uint id) {\n    if (dNft.ownerOf(id) == address(0))   revert InvalidDNft(); _;\n  }\n  modifier isLicensed(address vault) {\n    if (!vaultLicenser.isLicensed(vault)) revert NotLicensed(); _;\n  }\n\n  constructor(\n    DNft          _dNft,\n    Dyad          _dyad,\n    Licenser      _licenser\n  ) {\n    dNft          = _dNft;\n    dyad          = _dyad;\n    vaultLicenser = _licenser;\n  }\n\n  function setKeroseneManager(KerosineManager _keroseneManager) \n    external\n      initializer \n    {\n      keroseneManager = _keroseneManager;\n  }\n\n  /// @inheritdoc IVaultManager\n  function add(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (vaults[id].length() >= MAX_VAULTS) revert TooManyVaults();\n    if (!vaultLicenser.isLicensed(vault))  revert VaultNotLicensed();\n    if (!vaults[id].add(vault))            revert VaultAlreadyAdded();\n    emit Added(id, vault);\n  }\n\n  function addKerosene(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (vaultsKerosene[id].length() >= MAX_VAULTS_KEROSENE) revert TooManyVaults();\n    if (!keroseneManager.isLicensed(vault))                 revert VaultNotLicensed();\n    if (!vaultsKerosene[id].add(vault))                     revert VaultAlreadyAdded();\n    emit Added(id, vault);\n  }\n\n  /// @inheritdoc IVaultManager\n  function remove(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (Vault(vault).id2asset(id) > 0) revert VaultHasAssets();\n    if (!vaults[id].remove(vault))     revert VaultNotAdded();\n    emit Removed(id, vault);\n  }\n\n  function removeKerosene(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (Vault(vault).id2asset(id) > 0)     revert VaultHasAssets();\n    if (!vaultsKerosene[id].remove(vault)) revert VaultNotAdded();\n    emit Removed(id, vault);\n  }\n\n  /// @inheritdoc IVaultManager\n  function deposit(\n    uint    id,\n    address vault,\n    uint    amount\n  ) \n    external \n      isValidDNft(id)\n  {\n    idToBlockOfLastDeposit[id] = block.number;\n    Vault _vault = Vault(vault);\n    _vault.asset().safeTransferFrom(msg.sender, address(vault), amount);\n    _vault.deposit(id, amount);\n  }\n\n  /// @inheritdoc IVaultManager\n  function withdraw(\n    uint    id,\n    address vault,\n    uint    amount,\n    address to\n  ) \n    public\n      isDNftOwner(id)\n  {\n    if (idToBlockOfLastDeposit[id] == block.number) revert DepositedInSameBlock();\n    uint dyadMinted = dyad.mintedDyad(address(this), id);\n    Vault _vault = Vault(vault);\n    uint value = amount * _vault.assetPrice() \n                  * 1e18 \n                  / 10**_vault.oracle().decimals() \n                  / 10**_vault.asset().decimals();\n    if (getNonKeroseneValue(id) - value < dyadMinted) revert NotEnoughExoCollat();\n    _vault.withdraw(id, to, amount);\n    if (collatRatio(id) < MIN_COLLATERIZATION_RATIO)  revert CrTooLow(); \n  }\n\n  /// @inheritdoc IVaultManager\n  function mintDyad(\n    uint    id,\n    uint    amount,\n    address to\n  )\n    external \n      isDNftOwner(id)\n  {\n    uint newDyadMinted = dyad.mintedDyad(address(this), id) + amount;\n    if (getNonKeroseneValue(id) < newDyadMinted)     revert NotEnoughExoCollat();\n    dyad.mint(id, to, amount);\n    if (collatRatio(id) < MIN_COLLATERIZATION_RATIO) revert CrTooLow(); \n    emit MintDyad(id, amount, to);\n  }\n\n  /// @inheritdoc IVaultManager\n  function burnDyad(\n    uint id,\n    uint amount\n  ) \n    external \n      isValidDNft(id)\n  {\n    dyad.burn(id, msg.sender, amount);\n    emit BurnDyad(id, amount, msg.sender);\n  }\n\n  /// @inheritdoc IVaultManager\n  function redeemDyad(\n    uint    id,\n    address vault,\n    uint    amount,\n    address to\n  )\n    external \n      isDNftOwner(id)\n    returns (uint) { \n      dyad.burn(id, msg.sender, amount);\n      Vault _vault = Vault(vault);\n      uint asset = amount \n                    * (10**(_vault.oracle().decimals() + _vault.asset().decimals())) \n                    / _vault.assetPrice() \n                    / 1e18;\n      withdraw(id, vault, asset, to);\n      emit RedeemDyad(id, vault, amount, to);\n      return asset;\n  }\n\n  /// @inheritdoc IVaultManager\n  function liquidate(\n    uint id,\n    uint to\n  ) \n    external \n      isValidDNft(id)\n      isValidDNft(to)\n    {\n      uint cr = collatRatio(id);\n      if (cr >= MIN_COLLATERIZATION_RATIO) revert CrTooHigh();\n      dyad.burn(id, msg.sender, dyad.mintedDyad(address(this), id));\n\n      uint cappedCr               = cr < 1e18 ? 1e18 : cr;\n      uint liquidationEquityShare = (cappedCr - 1e18).mulWadDown(LIQUIDATION_REWARD);\n      uint liquidationAssetShare  = (liquidationEquityShare + 1e18).divWadDown(cappedCr);\n\n      uint numberOfVaults = vaults[id].length();\n      for (uint i = 0; i < numberOfVaults; i++) {\n          Vault vault      = Vault(vaults[id].at(i));\n          uint  collateral = vault.id2asset(id).mulWadUp(liquidationAssetShare);\n          vault.move(id, to, collateral);\n      }\n      emit Liquidate(id, msg.sender, to);\n  }\n\n  function collatRatio(\n    uint id\n  )\n    public \n    view\n    returns (uint) {\n      uint _dyad = dyad.mintedDyad(address(this), id);\n      if (_dyad == 0) return type(uint).max;\n      return getTotalUsdValue(id).divWadDown(_dyad);\n  }\n\n  function getTotalUsdValue(\n    uint id\n  ) \n    public \n    view\n    returns (uint) {\n      return getNonKeroseneValue(id) + getKeroseneValue(id);\n  }\n\n  function getNonKeroseneValue(\n    uint id\n  ) \n    public \n    view\n    returns (uint) {\n      uint totalUsdValue;\n      uint numberOfVaults = vaults[id].length(); \n      for (uint i = 0; i < numberOfVaults; i++) {\n        Vault vault = Vault(vaults[id].at(i));\n        uint usdValue;\n        if (vaultLicenser.isLicensed(address(vault))) {\n          usdValue = vault.getUsdValue(id);        \n        }\n        totalUsdValue += usdValue;\n      }\n      return totalUsdValue;\n  }\n\n  function getKeroseneValue(\n    uint id\n  ) \n    public \n    view\n    returns (uint) {\n      uint totalUsdValue;\n      uint numberOfVaults = vaultsKerosene[id].length(); \n      for (uint i = 0; i < numberOfVaults; i++) {\n        Vault vault = Vault(vaultsKerosene[id].at(i));\n        uint usdValue;\n        if (keroseneManager.isLicensed(address(vault))) {\n          usdValue = vault.getUsdValue(id);        \n        }\n        totalUsdValue += usdValue;\n      }\n      return totalUsdValue;\n  }\n\n  // ----------------- MISC ----------------- //\n\n  function getVaults(\n    uint id\n  ) \n    external \n    view \n    returns (address[] memory) {\n      return vaults[id].values();\n  }\n\n  function hasVault(\n    uint    id,\n    address vault\n  ) \n    external \n    view \n    returns (bool) {\n      return vaults[id].contains(vault);\n  }\n}"
    },
    {
      "filename": "script/deploy/Deploy.V2.s.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport \"forge-std/Script.sol\";\n\nimport {Parameters}             from \"../../src/params/Parameters.sol\";\nimport {VaultManagerV2}         from \"../../src/core/VaultManagerV2.sol\";\nimport {DNft}                   from \"../../src/core/DNft.sol\";\nimport {Dyad}                   from \"../../src/core/Dyad.sol\";\nimport {Licenser}               from \"../../src/core/Licenser.sol\";\nimport {Vault}                  from \"../../src/core/Vault.sol\";\nimport {VaultWstEth}            from \"../../src/core/Vault.wsteth.sol\";\nimport {IWETH}                  from \"../../src/interfaces/IWETH.sol\";\nimport {IAggregatorV3}          from \"../../src/interfaces/IAggregatorV3.sol\";\nimport {KerosineManager}        from \"../../src/core/KerosineManager.sol\";\nimport {UnboundedKerosineVault} from \"../../src/core/Vault.kerosine.unbounded.sol\";\nimport {BoundedKerosineVault}   from \"../../src/core/Vault.kerosine.bounded.sol\";\nimport {Kerosine}               from \"../../src/staking/Kerosine.sol\";\nimport {KerosineDenominator}    from \"../../src/staking/KerosineDenominator.sol\";\n\nimport {ERC20} from \"@solmate/src/tokens/ERC20.sol\";\n\nstruct Contracts {\n  Kerosine               kerosene;\n  Licenser               vaultLicenser;\n  VaultManagerV2         vaultManager;\n  Vault                  ethVault;\n  VaultWstEth            wstEth;\n  KerosineManager        kerosineManager;\n  UnboundedKerosineVault unboundedKerosineVault;\n  BoundedKerosineVault   boundedKerosineVault;\n  KerosineDenominator    kerosineDenominator;\n}\n\ncontract DeployV2 is Script, Parameters {\n  function run() public returns (Contracts memory) {\n    vm.startBroadcast();  // ----------------------\n\n    Licenser vaultLicenser = new Licenser();\n\n    // Vault Manager needs to be licensed through the Vault Manager Licenser\n    VaultManagerV2 vaultManager = new VaultManagerV2(\n      DNft(MAINNET_DNFT),\n      Dyad(MAINNET_DYAD),\n      vaultLicenser\n    );\n\n    // weth vault\n    Vault ethVault = new Vault(\n      vaultManager,\n      ERC20        (MAINNET_WETH),\n      IAggregatorV3(MAINNET_WETH_ORACLE)\n    );\n\n    // wsteth vault\n    VaultWstEth wstEth = new VaultWstEth(\n      vaultManager, \n      ERC20        (MAINNET_WSTETH), \n      IAggregatorV3(MAINNET_CHAINLINK_STETH)\n    );\n\n    KerosineManager kerosineManager = new KerosineManager();\n\n    kerosineManager.add(address(ethVault));\n    kerosineManager.add(address(wstEth));\n\n    vaultManager.setKeroseneManager(kerosineManager);\n\n    kerosineManager.transferOwnership(MAINNET_OWNER);\n\n    UnboundedKerosineVault unboundedKerosineVault = new UnboundedKerosineVault(\n      vaultManager,\n      Kerosine(MAINNET_KEROSENE), \n      Dyad    (MAINNET_DYAD),\n      kerosineManager\n    );\n\n    BoundedKerosineVault boundedKerosineVault     = new BoundedKerosineVault(\n      vaultManager,\n      Kerosine(MAINNET_KEROSENE), \n      kerosineManager\n    );\n\n    KerosineDenominator kerosineDenominator       = new KerosineDenominator(\n      Kerosine(MAINNET_KEROSENE)\n    );\n\n    unboundedKerosineVault.setDenominator(kerosineDenominator);\n\n    unboundedKerosineVault.transferOwnership(MAINNET_OWNER);\n    boundedKerosineVault.  transferOwnership(MAINNET_OWNER);\n\n    vaultLicenser.add(address(ethVault));\n    vaultLicenser.add(address(wstEth));\n    vaultLicenser.add(address(unboundedKerosineVault));\n    // vaultLicenser.add(address(boundedKerosineVault));\n\n    vaultLicenser.transferOwnership(MAINNET_OWNER);\n\n    vm.stopBroadcast();  // ----------------------------\n\n    return Contracts(\n      Kerosine(MAINNET_KEROSENE),\n      vaultLicenser,\n      vaultManager,\n      ethVault,\n      wstEth,\n      kerosineManager,\n      unboundedKerosineVault,\n      boundedKerosineVault,\n      kerosineDenominator\n    );\n  }\n}"
    },
    {
      "filename": "src/core/VaultManagerV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport {DNft}            from \"./DNft.sol\";\nimport {Dyad}            from \"./Dyad.sol\";\nimport {Licenser}        from \"./Licenser.sol\";\nimport {Vault}           from \"./Vault.sol\";\nimport {IVaultManager}   from \"../interfaces/IVaultManager.sol\";\nimport {KerosineManager} from \"../../src/core/KerosineManager.sol\";\n\nimport {FixedPointMathLib} from \"@solmate/src/utils/FixedPointMathLib.sol\";\nimport {ERC20}             from \"@solmate/src/tokens/ERC20.sol\";\nimport {SafeTransferLib}   from \"@solmate/src/utils/SafeTransferLib.sol\";\nimport {EnumerableSet}     from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {Initializable}     from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\ncontract VaultManagerV2 is IVaultManager, Initializable {\n  using EnumerableSet     for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint;\n  using SafeTransferLib   for ERC20;\n\n  uint public constant MAX_VAULTS          = 5;\n  uint public constant MAX_VAULTS_KEROSENE = 5;\n\n  uint public constant MIN_COLLATERIZATION_RATIO = 1.5e18; // 150%\n  uint public constant LIQUIDATION_REWARD        = 0.2e18; //  20%\n\n  DNft     public immutable dNft;\n  Dyad     public immutable dyad;\n  Licenser public immutable vaultLicenser;\n\n  KerosineManager public keroseneManager;\n\n  mapping (uint => EnumerableSet.AddressSet) internal vaults; \n  mapping (uint => EnumerableSet.AddressSet) internal vaultsKerosene; \n\n  mapping (uint => uint) public idToBlockOfLastDeposit;\n\n  modifier isDNftOwner(uint id) {\n    if (dNft.ownerOf(id) != msg.sender)   revert NotOwner();    _;\n  }\n  modifier isValidDNft(uint id) {\n    if (dNft.ownerOf(id) == address(0))   revert InvalidDNft(); _;\n  }\n  modifier isLicensed(address vault) {\n    if (!vaultLicenser.isLicensed(vault)) revert NotLicensed(); _;\n  }\n\n  constructor(\n    DNft          _dNft,\n    Dyad          _dyad,\n    Licenser      _licenser\n  ) {\n    dNft          = _dNft;\n    dyad          = _dyad;\n    vaultLicenser = _licenser;\n  }\n\n  function setKeroseneManager(KerosineManager _keroseneManager) \n    external\n      initializer \n    {\n      keroseneManager = _keroseneManager;\n  }\n\n  /// @inheritdoc IVaultManager\n  function add(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (vaults[id].length() >= MAX_VAULTS) revert TooManyVaults();\n    if (!vaultLicenser.isLicensed(vault))  revert VaultNotLicensed();\n    if (!vaults[id].add(vault))            revert VaultAlreadyAdded();\n    emit Added(id, vault);\n  }\n\n  function addKerosene(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (vaultsKerosene[id].length() >= MAX_VAULTS_KEROSENE) revert TooManyVaults();\n    if (!keroseneManager.isLicensed(vault))                 revert VaultNotLicensed();\n    if (!vaultsKerosene[id].add(vault))                     revert VaultAlreadyAdded();\n    emit Added(id, vault);\n  }\n\n  /// @inheritdoc IVaultManager\n  function remove(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (Vault(vault).id2asset(id) > 0) revert VaultHasAssets();\n    if (!vaults[id].remove(vault))     revert VaultNotAdded();\n    emit Removed(id, vault);\n  }\n\n  function removeKerosene(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (Vault(vault).id2asset(id) > 0)     revert VaultHasAssets();\n    if (!vaultsKerosene[id].remove(vault)) revert VaultNotAdded();\n    emit Removed(id, vault);\n  }\n\n  /// @inheritdoc IVaultManager\n  function deposit(\n    uint    id,\n    address vault,\n    uint    amount\n  ) \n    external \n      isValidDNft(id)\n  {\n    idToBlockOfLastDeposit[id] = block.number;\n    Vault _vault = Vault(vault);\n    _vault.asset().safeTransferFrom(msg.sender, address(vault), amount);\n    _vault.deposit(id, amount);\n  }\n\n  /// @inheritdoc IVaultManager\n  function withdraw(\n    uint    id,\n    address vault,\n    uint    amount,\n    address to\n  ) \n    public\n      isDNftOwner(id)\n  {\n    if (idToBlockOfLastDeposit[id] == block.number) revert DepositedInSameBlock();\n    uint dyadMinted = dyad.mintedDyad(address(this), id);\n    Vault _vault = Vault(vault);\n    uint value = amount * _vault.assetPrice() \n                  * 1e18 \n                  / 10**_vault.oracle().decimals() \n                  / 10**_vault.asset().decimals();\n    if (getNonKeroseneValue(id) - value < dyadMinted) revert NotEnoughExoCollat();\n    _vault.withdraw(id, to, amount);\n    if (collatRatio(id) < MIN_COLLATERIZATION_RATIO)  revert CrTooLow(); \n  }\n\n  /// @inheritdoc IVaultManager\n  function mintDyad(\n    uint    id,\n    uint    amount,\n    address to\n  )\n    external \n      isDNftOwner(id)\n  {\n    uint newDyadMinted = dyad.mintedDyad(address(this), id) + amount;\n    if (getNonKeroseneValue(id) < newDyadMinted)     revert NotEnoughExoCollat();\n    dyad.mint(id, to, amount);\n    if (collatRatio(id) < MIN_COLLATERIZATION_RATIO) revert CrTooLow(); \n    emit MintDyad(id, amount, to);\n  }\n\n  /// @inheritdoc IVaultManager\n  function burnDyad(\n    uint id,\n    uint amount\n  ) \n    external \n      isValidDNft(id)\n  {\n    dyad.burn(id, msg.sender, amount);\n    emit BurnDyad(id, amount, msg.sender);\n  }\n\n  /// @inheritdoc IVaultManager\n  function redeemDyad(\n    uint    id,\n    address vault,\n    uint    amount,\n    address to\n  )\n    external \n      isDNftOwner(id)\n    returns (uint) { \n      dyad.burn(id, msg.sender, amount);\n      Vault _vault = Vault(vault);\n      uint asset = amount \n                    * (10**(_vault.oracle().decimals() + _vault.asset().decimals())) \n                    / _vault.assetPrice() \n                    / 1e18;\n      withdraw(id, vault, asset, to);\n      emit RedeemDyad(id, vault, amount, to);\n      return asset;\n  }\n\n  /// @inheritdoc IVaultManager\n  function liquidate(\n    uint id,\n    uint to\n  ) \n    external \n      isValidDNft(id)\n      isValidDNft(to)\n    {\n      uint cr = collatRatio(id);\n      if (cr >= MIN_COLLATERIZATION_RATIO) revert CrTooHigh();\n      dyad.burn(id, msg.sender, dyad.mintedDyad(address(this), id));\n\n      uint cappedCr               = cr < 1e18 ? 1e18 : cr;\n      uint liquidationEquityShare = (cappedCr - 1e18).mulWadDown(LIQUIDATION_REWARD);\n      uint li"
    }
  ]
}