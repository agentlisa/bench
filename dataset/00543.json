{
  "Title": "M-2: Benign esfrxETH holders incur more loss than expected",
  "Content": "# Issue M-2: Benign esfrxETH holders incur more loss than expected \n\nSource: https://github.com/sherlock-audit/2024-01-napier-judging/issues/82 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nxiaoming90\n## Summary\n\nMalicious esfrxETH holders can avoid \"pro-rated\" loss and have the remaining esfrxETH holders incur all the loss due to the fee charged by FRAX during unstaking. As a result, the rest of the esfrxETH holders incur more losses than expected compared to if malicious esfrxETH holders had not used this trick in the first place.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/adapters/frax/SFrxETHAdapter.sol#L22\n\n```solidity\nFile: SFrxETHAdapter.sol\n17: /// @title SFrxETHAdapter - esfrxETH\n18: /// @dev Important security note:\n19: /// 1. The vault share price (esfrxETH / WETH) increases as sfrxETH accrues staking rewards.\n20: /// However, the share price decreases when frxETH (sfrxETH) is withdrawn.\n21: /// Withdrawals are processed by the FraxEther redemption queue contract.\n22: /// Frax takes a fee at the time of withdrawal requests, which temporarily reduces the share price.\n23: /// This loss is pro-rated among all esfrxETH holders.\n24: /// As a mitigation measure, we allow only authorized rebalancers to request withdrawals.\n25: ///\n26: /// 2. This contract doesn't independently keep track of the sfrxETH balance, so it is possible\n27: /// for an attacker to directly transfer sfrxETH to this contract, increase the share price.\n28: contract SFrxETHAdapter is BaseLSTAdapter, IERC721Receiver {\n```\n\nIn the `SFrxETHAdapter`'s comments above, it is stated that the share price will decrease due to the fee taken by FRAX during the withdrawal request. This loss is supposed to be 'pro-rated' among all esfrxETH holders. However, this report reveals that malicious esfrxETH holders can circumvent this 'pro-rated' loss, leaving the remaining esfrxETH holders to bear the entire loss. Furthermore, the report demonstrates that the current mitigation measure, which allows only authorized rebalancers to request withdrawals, is insufficient to prevent this exploitation.\n\nWhenever a rebalancers submit a withdrawal request to withdraw staked ETH from FRAX, it will first reside in the mempool of the blockchain and anyone can see it. Malicious esfrxETH holders can front-run it to withdraw their shares from the adaptor.\n\nWhen the withdrawal request TX is executed, the remaining esfrxETH holders in the adaptor will incur the fee. Once executed, the malicious esfrxETH deposits back to the adaptors.\n\nNote that no fee is charged to the users for any deposit or withdrawal operation. Thus, as long as the gain from this action is more than the gas cost, it makes sense for the esfrxETH holders to do so.\n\n## Impact\n\nThe rest of the esfrxETH holders incur more losses than expected compared to if malicious esfrxETH holders had not used this trick in the first place.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/adapters/frax/SFrxETHAdapter.sol#L22\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe best way to discourage users from withdrawing their assets and depositing them back to take advantage of a particular event is to impose a fee upon depositing and withdrawing. \n\n\n\n## Discussion\n\n**massun-onibakuchi**\n\nWe'll submit transactions using private rpc like flashbot.\n\n\n**xiaoming9090**\n\nEscalate.\n\nAgree with the sponsor that this attack would be prevented if the withdraw request transaction is submitted via private RPC like flash-bot.\n\nHowever, this attack and its mitigation (using a private RPC) were not highlighted as a known issue under the contest’s README.\n\nThus, this issue should be considered valid and not excluded, as the mitigation measures are shared post-audit.\n\n**sherlock-admin2**\n\n> Escalate.\n> \n> Agree with the sponsor that this attack would be prevented if the withdraw request transaction is submitted via private RPC like flash-bot.\n> \n> However, this attack and its mitigation (using a private RPC) were not highlighted as a known issue under the contest’s README.\n> \n> Thus, this issue should be considered valid and not excluded, as the mitigation measures are shared post-audit.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**cvetanovv**\n\nI think @xiaoming9090 is right here. Nowhere is it described that private rpc like flashbot will be used. So in my opinion it can be valid Medium.\n\n**Czar102**\n\nPlanning to accept the escalation and make the issue a valid Medium.\n\n**Czar102**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [xiaoming9090](https://github.com/sherlock-audit/2024-01-napier-judging/issues/82/#issuecomment-1987103039): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/171",
  "Code": [
    {
      "filename": "napier-v1/src/adapters/frax/SFrxETHAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/IERC20.sol\";\nimport {IWETH9} from \"../../interfaces/IWETH9.sol\";\nimport {IERC4626} from \"@openzeppelin/contracts@4.9.3/interfaces/IERC4626.sol\";\nimport {IFrxETHMinter} from \"./interfaces/IFrxETHMinter.sol\";\nimport {IFraxEtherRedemptionQueue} from \"./interfaces/IFraxEtherRedemptionQueue.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts@4.9.3/token/ERC721/IERC721Receiver.sol\";\n\nimport {ERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/ERC20.sol\";\nimport {BaseLSTAdapter} from \"../BaseLSTAdapter.sol\";\n\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport \"../../Constants.sol\" as Constants;\n\n/// @title SFrxETHAdapter - esfrxETH\n/// @dev Important security note:\n/// 1. The vault share price (esfrxETH / WETH) increases as sfrxETH accrues staking rewards.\n/// However, the share price decreases when frxETH (sfrxETH) is withdrawn.\n/// Withdrawals are processed by the FraxEther redemption queue contract.\n/// Frax takes a fee at the time of withdrawal requests, which temporarily reduces the share price.\n/// This loss is pro-rated among all esfrxETH holders.\n/// As a mitigation measure, we allow only authorized rebalancers to request withdrawals.\n///\n/// 2. This contract doesn't independently keep track of the sfrxETH balance, so it is possible\n/// for an attacker to directly transfer sfrxETH to this contract, increase the share price.\ncontract SFrxETHAdapter is BaseLSTAdapter, IERC721Receiver {\n    using SafeCast for uint256;\n\n    error InvariantViolation();\n\n    /// @notice frxETH\n    IERC20 constant FRXETH = IERC20(Constants.FRXETH);\n\n    /// @notice sfrxETH\n    IERC4626 constant STAKED_FRXETH = IERC4626(Constants.STAKED_FRXETH);\n\n    /// @dev FraxEther redemption queue contract https://etherscan.io/address/0x82bA8da44Cd5261762e629dd5c605b17715727bd\n    IFraxEtherRedemptionQueue constant REDEMPTION_QUEUE =\n        IFraxEtherRedemptionQueue(0x82bA8da44Cd5261762e629dd5c605b17715727bd);\n\n    /// @dev FraxEther minter contract\n    IFrxETHMinter constant FRXETH_MINTER = IFrxETHMinter(0xbAFA44EFE7901E04E39Dad13167D089C559c1138);\n\n    receive() external payable {}\n\n    constructor(address _rebalancer) BaseLSTAdapter(_rebalancer) ERC20(\"Napier FrxETH Adapter\", \"eFrxETH\") {\n        FRXETH.approve(address(STAKED_FRXETH), type(uint256).max);\n        FRXETH.approve(address(REDEMPTION_QUEUE), type(uint256).max);\n    }\n\n    function claimWithdrawal() external override {\n        uint256 _requestId = requestId;\n        uint256 _withdrawalQueueEth = withdrawalQueueEth;\n        if (_requestId == 0) revert NoPendingWithdrawal();\n\n        /// WRITE ///\n        delete withdrawalQueueEth;\n        delete requestId;\n        bufferEth += _withdrawalQueueEth.toUint128();\n\n        /// INTERACT ///\n        uint256 balanceBefore = address(this).balance;\n        REDEMPTION_QUEUE.burnRedemptionTicketNft(_requestId, payable(this));\n        if (address(this).balance < balanceBefore + _withdrawalQueueEth) revert InvariantViolation();\n\n        IWETH9(Constants.WETH).deposit{value: _withdrawalQueueEth}();\n    }\n\n    /// @notice Mint sfrxETH using WETH\n    function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        FRXETH_MINTER.submit{value: stakeAmount}();\n        uint256 received = STAKED_FRXETH.deposit(stakeAmount, address(this));\n        if (received == 0) revert InvariantViolation();\n\n        return stakeAmount;\n    }\n\n    function requestWithdrawalAll() external override nonReentrant onlyRebalancer {\n        if (requestId != 0) revert WithdrawalPending();\n        uint256 _requestId = REDEMPTION_QUEUE.redemptionQueueState().nextNftId;\n        /// INTERACT ///\n        // Redeem all sfrxETH for frxETH\n        uint256 balance = STAKED_FRXETH.balanceOf(address(this));\n        uint256 withdrawAmount = STAKED_FRXETH.redeem(balance, address(this), address(this));\n\n        REDEMPTION_QUEUE.enterRedemptionQueue({amountToRedeem: withdrawAmount.toUint120(), recipient: address(this)});\n\n        /// WRITE ///\n        withdrawalQueueEth = REDEMPTION_QUEUE.nftInformation(_requestId).amount; // cast uint120 to uint128\n        requestId = _requestId;\n    }\n\n    /// @notice Request about `withdrawAmount` of ETH to be unstaked from sfrxETH.\n    /// @param withdrawAmount Amount of ETH to withdraw\n    function _requestWithdrawal(uint256 withdrawAmount) internal override returns (uint256, uint256) {\n        uint256 _requestId = REDEMPTION_QUEUE.redemptionQueueState().nextNftId; // Dev: Ensure id is not 0\n        /// INTERACT ///\n        uint256 frxEthBalanceBefore = FRXETH.balanceOf(address(this)); // 0 is expected if no one has donated frxETH to this contract\n        STAKED_FRXETH.withdraw(withdrawAmount, address(this), address(this));\n        uint256 frxEthWithdrawn = FRXETH.balanceOf(address(this)) - frxEthBalanceBefore;\n        // Transfer frxETH and mint redemption ticket.\n        // note: `amountToRedeem` is an amount in frxETH, not ETH.\n        // However, frxETH would be soft-pegged to ETH, so we treat them as 1:1 for simplicity here.\n        // Also, actual ETH amount to withdraw would be slightly less than `withdrawAmount` due to the redemption fee.\n        REDEMPTION_QUEUE.enterRedemptionQueue({amountToRedeem: frxEthWithdrawn.toUint120(), recipient: address(this)});\n        /// WRITE ///\n        // Note: The redemption queue contract returns the exact amount of ETH to withdraw.\n        uint256 queueEth = REDEMPTION_QUEUE.nftInformation(_requestId).amount; // cast uint120 to uint128\n        return (queueEth, _requestId);\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        uint256 balance = STAKED_FRXETH.balanceOf(address(this));\n        uint256 balanceInFrxEth = STAKED_FRXETH.convertToAssets(balance);\n        return withdrawalQueueEth + bufferEth + balanceInFrxEth; // 1 frxEth = 1 ETH\n    }\n\n    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n        return 0x150b7a02; // bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n    }\n}"
    },
    {
      "filename": "napier-v1/src/adapters/frax/SFrxETHAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/IERC20.sol\";\nimport {IWETH9} from \"../../interfaces/IWETH9.sol\";\nimport {IERC4626} from \"@openzeppelin/contracts@4.9.3/interfaces/IERC4626.sol\";\nimport {IFrxETHMinter} from \"./interfaces/IFrxETHMinter.sol\";\nimport {IFraxEtherRedemptionQueue} from \"./interfaces/IFraxEtherRedemptionQueue.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts@4.9.3/token/ERC721/IERC721Receiver.sol\";\n\nimport {ERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/ERC20.sol\";\nimport {BaseLSTAdapter} from \"../BaseLSTAdapter.sol\";\n\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport \"../../Constants.sol\" as Constants;\n\n/// @title SFrxETHAdapter - esfrxETH\n/// @dev Important security note:\n/// 1. The vault share price (esfrxETH / WETH) increases as sfrxETH accrues staking rewards.\n/// However, the share price decreases when frxETH (sfrxETH) is withdrawn.\n/// Withdrawals are processed by the FraxEther redemption queue contract.\n/// Frax takes a fee at the time of withdrawal requests, which temporarily reduces the share price.\n/// This loss is pro-rated among all esfrxETH holders.\n/// As a mitigation measure, we allow only authorized rebalancers to request withdrawals.\n///\n/// 2. This contract doesn't independently keep track of the sfrxETH balance, so it is possible\n/// for an attacker to directly transfer sfrxETH to this contract, increase the share price.\ncontract SFrxETHAdapter is BaseLSTAdapter, IERC721Receiver {\n    using SafeCast for uint256;\n\n    error InvariantViolation();\n\n    /// @notice frxETH\n    IERC20 constant FRXETH = IERC20(Constants.FRXETH);\n\n    /// @notice sfrxETH\n    IERC4626 constant STAKED_FRXETH = IERC4626(Constants.STAKED_FRXETH);\n\n    /// @dev FraxEther redemption queue contract https://etherscan.io/address/0x82bA8da44Cd5261762e629dd5c605b17715727bd\n    IFraxEtherRedemptionQueue constant REDEMPTION_QUEUE =\n        IFraxEtherRedemptionQueue(0x82bA8da44Cd5261762e629dd5c605b17715727bd);\n\n    /// @dev FraxEther minter contract\n    IFrxETHMinter constant FRXETH_MINTER = IFrxETHMinter(0xbAFA44EFE7901E04E39Dad13167D089C559c1138);\n\n    receive() external payable {}\n\n    constructor(address _rebalancer) BaseLSTAdapter(_rebalancer) ERC20(\"Napier FrxETH Adapter\", \"eFrxETH\") {\n        FRXETH.approve(address(STAKED_FRXETH), type(uint256).max);\n        FRXETH.approve(address(REDEMPTION_QUEUE), type(uint256).max);\n    }\n\n    function claimWithdrawal() external override {\n        uint256 _requestId = requestId;\n        uint256 _withdrawalQueueEth = withdrawalQueueEth;\n        if (_requestId == 0) revert NoPendingWithdrawal();\n\n        /// WRITE ///\n        delete withdrawalQueueEth;\n        delete requestId;\n        bufferEth += _withdrawalQueueEth.toUint128();\n\n        /// INTERACT ///\n        uint256 balanceBefore = address(this).balance;\n        REDEMPTION_QUEUE.burnRedemptionTicketNft(_requestId, payable(this));\n        if (address(this).balance < balanceBefore + _withdrawalQueueEth) revert InvariantViolation();\n\n        IWETH9(Constants.WETH).deposit{value: _withdrawalQueueEth}();\n    }\n\n    /// @notice Mint sfrxETH using WETH\n    function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        FRXETH_MINTER.submit{value: stakeAmount}();\n        uint256 received = STAKED_FRXETH.deposit(stakeAmount, address(this));\n        if (received == 0) revert InvariantViolation();\n\n        return stakeAmount;\n    }\n\n    function requestWithdrawalAll() external override nonReentrant onlyRebalancer {\n        if (requestId != 0) revert WithdrawalPending();\n        uint256 _requestId = REDEMPTION_QUEUE.redemptionQueueState().nextNftId;\n        /// INTERACT ///\n        // Redeem all sfrxETH for frxETH\n        uint256 balance = STAKED_FRXETH.balanceOf(address(this));\n        uint256 withdrawAmount = STAKED_FRXETH.redeem(balance, address(this), address(this));\n\n        REDEMPTION_QUEUE.enterRedemptionQueue({amountToRedeem: withdrawAmount.toUint120(), recipient: address(this)});\n\n        /// WRITE ///\n        withdrawalQueueEth = REDEMPTION_QUEUE.nftInformation(_requestId).amount; // cast uint120 to uint128\n        requestId = _requestId;\n    }\n\n    /// @notice Request about `withdrawAmount` of ETH to be unstaked from sfrxETH.\n    /// @param withdrawAmount Amount of ETH to withdraw\n    function _requestWithdrawal(uint256 withdrawAmount) internal override returns (uint256, uint256) {\n        uint256 _requestId = REDEMPTION_QUEUE.redemptionQueueState().nextNftId; // Dev: Ensure id is not 0\n        /// INTERACT ///\n        uint256 frxEthBalanceBefore = FRXETH.balanceOf(address(this)); // 0 is expected if no one has donated frxETH to this contract\n        STAKED_FRXETH.withdraw(withdrawAmount, address(this), address(this));\n        uint256 frxEthWithdrawn = FRXETH.balanceOf(address(this)) - frxEthBalanceBefore;\n        // Transfer frxETH and mint redemption ticket.\n        // note: `amountToRedeem` is an amount in frxETH, not ETH.\n        // However, frxETH would be soft-pegged to ETH, so we treat them as 1:1 for simplicity here.\n        // Also, actual ETH amount to withdraw would be slightly less than `withdrawAmount` due to the redemption fee.\n        REDEMPTION_QUEUE.enterRedemptionQueue({amountToRedeem: frxEthWithdrawn.toUint120(), recipient: address(this)});\n        /// WRITE ///\n        // Note: The redemption queue contract returns the exact amount of ETH to withdraw.\n        uint256 queueEth = REDEMPTION_QUEUE.nftInformation(_requestId).amount; // cast uint120 to uint128\n        return (queueEth, _requestId);\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        uint256 balance = STAKED_FRXETH.balanceOf(address(this));\n        uint256 balanceInFrxEth = STAKED_FRXETH.convertToAssets(balance);\n        return withdrawalQueueEth + bufferEth + balanceInFrxEth; // 1 frxEth = 1 ETH\n    }\n\n    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n        return 0x150b7a02; // bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n    }\n}"
    }
  ]
}