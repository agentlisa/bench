{
  "Title": "M-8: In over liquidation, if the liquidatee has USDC-denominated assets for sale, the liquidator can buy the assets with USDC to avoid paying USDC to the liquidatee",
  "Content": "# Issue M-8: In over liquidation, if the liquidatee has USDC-denominated assets for sale, the liquidator can buy the assets with USDC to avoid paying USDC to the liquidatee \n\nSource: https://github.com/sherlock-audit/2023-04-jojo-judging/issues/369 \n\n## Found by \ncccz, monrel\n## Summary\nIn over liquidation, if the liquidatee has USDC-denominated assets for sale, the liquidator can buy the assets with USDC to avoid paying USDC to the liquidatee\n## Vulnerability Detail\nIn JUSDBank contract, if the liquidator wants to liquidate more collateral than the borrowings of the liquidatee, the liquidator can pay additional USDC to get the liquidatee's collateral. \n```solidity\n        } else {\n            //            actualJUSD = actualCollateral * priceOff\n            //            = JUSDBorrowed * priceOff / priceOff * (1-insuranceFeeRate)\n            //            = JUSDBorrowed / (1-insuranceFeeRate)\n            //            insuranceFee = actualJUSD * insuranceFeeRate\n            //            = actualCollateral * priceOff * insuranceFeeRate\n            //            = JUSDBorrowed * insuranceFeeRate / (1- insuranceFeeRate)\n            liquidateData.actualCollateral = JUSDBorrowed\n                .decimalDiv(priceOff)\n                .decimalDiv(JOJOConstant.ONE - reserve.insuranceFeeRate);\n            liquidateData.insuranceFee = JUSDBorrowed\n                .decimalMul(reserve.insuranceFeeRate)\n                .decimalDiv(JOJOConstant.ONE - reserve.insuranceFeeRate);\n            liquidateData.actualLiquidatedT0 = liquidatedInfo.t0BorrowBalance;\n            liquidateData.actualLiquidated = JUSDBorrowed;\n        }\n\n        liquidateData.liquidatedRemainUSDC = (amount -\n            liquidateData.actualCollateral).decimalMul(price);\n```\nThe liquidator needs to pay USDC in the callback and the JUSDBank contract will require the final USDC balance of the liquidatee to increase.\n```solidity\n        require(\n            IERC20(primaryAsset).balanceOf(liquidated) -\n                primaryLiquidatedAmount >=\n                liquidateData.liquidatedRemainUSDC,\n            JUSDErrors.LIQUIDATED_AMOUNT_NOT_ENOUGH\n        );\n```\nIf the liquidatee has USDC-denominated assets for sale, the liquidator can purchase the assets with USDC in the callback, so that the liquidatee's USDC balance will increase and the liquidator will not need to send USDC to the liquidatee to pass the check in the JUSDBank contract.\n## Impact\nIn case of over liquidation, the liquidator does not need to pay additional USDC to the liquidatee\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/JUSDBank.sol#L188-L204\n\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider banning over liquidation\n\n\n\n## Discussion\n\n**JoscelynFarr**\n\nThat is in our consideration, if the liquidation triggered, there is a possibility for liquidator to liquidate all collaterals, and the remain collateral will return by the USDC to liquidatee\n\n**JoscelynFarr**\n\nIn fact, I don't understand how the attack occurs\n\n**Trumpero**\n\nThis issue states that the USDC balance of a liquidated user will be validated as the result of liquidation. However, the liquidator can purchase USDC instead of directly transfer USDC in the callback function (when the liquidated user sells USDC elsewhere). After that, the balance check for liquidation is still fulfilled, but the liquidated user will lose assets.\n\n**hrishibhat**\n\nAdditional comment from the Watson:\n\nAssume liquidationPriceOff = 5% and ETH : USDC = 2000 : 1.\nAlice's unhealthy position is borrowed for 100000 JUSD, collateral is 60 ETH, meanwhile Alice sells 7 ETH for 14000 USDC in other protocol.\nBob liquidates 60 ETH of Alice's position, Bob needs to pay 100000 JUSD, and 60 * 2000 - 100000 / 0.95 = 14737 USDC. In the JOJOFlashLoan callback, Bob sends 100000 JUSD to the contract and buys the 7 ETH that Alice sold in the other protocol (It increases Alice's USDC balance by 14000), and then Bob just send another 14737-14000=737 USDC to Alice to pass the following check\n```\n        require(\n            IERC20(primaryAsset).balanceOf(liquidated) -\n                primaryLiquidatedAmount >=\n                liquidateData.liquidatedRemainUSDC,\n            JUSDErrors.LIQUIDATED_AMOUNT_NOT_ENOUGH\n        );\n```\n\n**JoscelynFarr**\n\nfix commit:\nhttps://github.com/JOJOexchange/JUSDV1/commit/5918d68be9b5b021691f768da98df5f712ac6edd\n\n**IAm0x52**\n\nNeed validation of amount sent to `liquidated`\n\n**IAm0x52**\n\nFix looks good. Reentrancy exists if _primaryAsset is also a collateral but team has explicitly stated that this is never the case.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/70",
  "Code": [
    {
      "filename": "JUSDV1/src/Impl/JUSDBank.sol",
      "content": "/*\n    Copyright 2022 JOJO Exchange\n    SPDX-License-Identifier: BUSL-1.1*/\npragma solidity 0.8.9;\n\nimport \"../Interface/IJUSDBank.sol\";\nimport \"../Interface/IFlashLoanReceive.sol\";\nimport \"./JUSDBankStorage.sol\";\nimport \"./JUSDOperation.sol\";\nimport \"./JUSDView.sol\";\nimport \"./JUSDMulticall.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@JOJO/contracts/intf/IDealer.sol\";\nimport {IPriceChainLink} from \"../Interface/IPriceChainLink.sol\";\n\ncontract JUSDBank is IJUSDBank, JUSDOperation, JUSDView, JUSDMulticall {\n    using DecimalMath for uint256;\n    using SafeERC20 for IERC20;\n\n    constructor(\n        uint256 _maxReservesNum,\n        address _insurance,\n        address _JUSD,\n        address _JOJODealer,\n        uint256 _maxPerAccountBorrowAmount,\n        uint256 _maxTotalBorrowAmount,\n        uint256 _borrowFeeRate,\n        address _primaryAsset\n    ) {\n        maxReservesNum = _maxReservesNum;\n        JUSD = _JUSD;\n        JOJODealer = _JOJODealer;\n        insurance = _insurance;\n        maxPerAccountBorrowAmount = _maxPerAccountBorrowAmount;\n        maxTotalBorrowAmount = _maxTotalBorrowAmount;\n        borrowFeeRate = _borrowFeeRate;\n        t0Rate = JOJOConstant.ONE;\n        primaryAsset = _primaryAsset;\n        lastUpdateTimestamp = uint32(block.timestamp);\n    }\n\n    // --------------------------event-----------------------\n\n    event HandleBadDebt(address indexed liquidatedTrader, uint256 borrowJUSDT0);\n    event Deposit(\n        address indexed collateral,\n        address indexed from,\n        address indexed to,\n        address operator,\n        uint256 amount\n    );\n    event Borrow(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bool isDepositToJOJO\n    );\n    event Repay(address indexed from, address indexed to, uint256 amount);\n    event Withdraw(\n        address indexed collateral,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bool ifInternal\n    );\n    event Liquidate(\n        address indexed collateral,\n        address indexed liquidator,\n        address indexed liquidated,\n        address operator,\n        uint256 collateralAmount,\n        uint256 liquidatedAmount,\n        uint256 insuranceFee\n    );\n    event FlashLoan(address indexed collateral, uint256 amount);\n\n    /// @notice to ensure msg.sender is from account or msg.sender is the sub account of from\n    /// so that msg.sender can send the transaction\n    modifier isValidOperator(address operator, address client) {\n        require(\n            msg.sender == client || operatorRegistry[client][operator],\n            JUSDErrors.CAN_NOT_OPERATE_ACCOUNT\n        );\n        _;\n    }\n    modifier isLiquidator(address liquidator) {\n        if(isLiquidatorWhitelistOpen){\n            require(isLiquidatorWhiteList[liquidator], \"liquidator is not in the liquidator white list\");\n        }\n        _;\n    }\n\n    function deposit(\n        address from,\n        address collateral,\n        uint256 amount,\n        address to\n    ) external override nonReentrant isValidOperator(msg.sender, from) {\n        DataTypes.ReserveInfo storage reserve = reserveInfo[collateral];\n        DataTypes.UserInfo storage user = userInfo[to];\n        //        deposit\n        _deposit(reserve, user, amount, collateral, to, from);\n    }\n\n    function borrow(\n        uint256 amount,\n        address to,\n        bool isDepositToJOJO\n    ) external override nonReentrant nonFlashLoanReentrant{\n        //     t0BorrowedAmount = borrowedAmount /  getT0Rate\n        DataTypes.UserInfo storage user = userInfo[msg.sender];\n        _borrow(user, isDepositToJOJO, to, amount, msg.sender);\n        require(\n            _isAccountSafeAfterBorrow(user, getTRate()),\n            JUSDErrors.AFTER_BORROW_ACCOUNT_IS_NOT_SAFE\n        );\n    }\n\n    function repay(\n        uint256 amount,\n        address to\n    ) external override nonReentrant returns (uint256) {\n        DataTypes.UserInfo storage user = userInfo[to];\n        uint256 tRate = getTRate();\n        return _repay(user, msg.sender, to, amount, tRate);\n    }\n\n    function withdraw(\n        address collateral,\n        uint256 amount,\n        address to,\n        bool isInternal\n    ) external override nonReentrant nonFlashLoanReentrant{\n        DataTypes.UserInfo storage user = userInfo[msg.sender];\n        _withdraw(amount, collateral, to, msg.sender, isInternal);\n        uint256 tRate = getTRate();\n        require(\n            _isAccountSafe(user, tRate),\n            JUSDErrors.AFTER_WITHDRAW_ACCOUNT_IS_NOT_SAFE\n        );\n    }\n\n    function liquidate(\n        address liquidated,\n        address collateral,\n        address liquidator,\n        uint256 amount,\n        bytes memory afterOperationParam,\n        uint256 expectPrice\n    )\n        external\n        override\n        isValidOperator(msg.sender, liquidator)\n        nonFlashLoanReentrant\n        returns (DataTypes.LiquidateData memory liquidateData)\n    {\n        uint256 JUSDBorrowedT0 = userInfo[liquidated].t0BorrowBalance;\n        uint256 primaryLiquidatedAmount = IERC20(primaryAsset).balanceOf(\n            liquidated\n        );\n        uint256 primaryInsuranceAmount = IERC20(primaryAsset).balanceOf(\n            insurance\n        );\n        isValidLiquidator(liquidated, liquidator);\n        // 1. calculate the liquidate amount\n        liquidateData = _calculateLiquidateAmount(\n            liquidated,\n            collateral,\n            amount\n        );\n        require(\n        // condition: actual liquidate price < max buy price,\n        // price lower, better\n            (liquidateData.insuranceFee + liquidateData.actualLiquidated).decimalDiv(liquidateData.actualCollateral)\n                <= expectPrice,\n            JUSDErrors.LIQUIDATION_PRICE_PROTECTION\n        );\n        // 2. after liquidation flashloan operation\n        _afterLiquidateOperation(\n            afterOperationParam,\n            amount,\n            collateral,\n            liquidated,\n            liquidateData\n        );\n\n        // 3. price protect\n        require(\n            JUSDBorrowedT0 - userInfo[liquidated].t0BorrowBalance >=\n                liquidateData.actualLiquidatedT0,\n            JUSDErrors.REPAY_AMOUNT_NOT_ENOUGH\n        );\n        require(\n            IERC20(primaryAsset).balanceOf(insurance) -\n                primaryInsuranceAmount >=\n                liquidateData.insuranceFee,\n            JUSDErrors.INSURANCE_AMOUNT_NOT_ENOUGH\n        );\n        require(\n            IERC20(primaryAsset).balanceOf(liquidated) -\n                primaryLiquidatedAmount >=\n                liquidateData.liquidatedRemainUSDC,\n            JUSDErrors.LIQUIDATED_AMOUNT_NOT_ENOUGH\n        );\n        emit Liquidate(\n            collateral,\n            liquidator,\n            liquidated,\n            msg.sender,\n            liquidateData.actualCollateral,\n            liquidateData.actualLiquidated,\n            liquidateData.insuranceFee\n        );\n    }\n\n    function handleDebt(\n        address[] calldata liquidatedTraders\n    ) external onlyOwner {\n        for (uint256 i; i < liquidatedTraders.length; i = i + 1) {\n            _handleBadDebt(liquidatedTraders[i]);\n        }\n    }\n\n    function flashLoan(\n        address receiver,\n        address collateral,\n        uint256 amount,\n        address to,\n        bytes memory param\n    ) external nonFlashLoanReentrant {\n        DataTypes.UserInfo storage user = userInfo[msg.sender];\n        _withdraw(amount, collateral, receiver, msg.sender, false);\n        // repay\n        IFlashLoanReceive(receiver).JOJOFlashLoan(\n            collateral,\n            amount,\n            to,\n            param\n        );\n        require(\n            _isAccountSafe(user, getTRate()),\n            JUSDErrors.AFTER_FLASHLOAN_ACCOUNT_IS_NOT_SAFE\n        );\n        emit FlashLoan(collateral, amount);\n    }\n\n    function _deposit(\n        DataTypes.ReserveInfo storage reserve,\n        DataTypes.UserInfo storage user,\n        uint256 amount,\n        address collateral,\n        address to,\n        address from\n    ) internal {\n        require(reserve.isDepositAllowed, JUSDErrors.RESERVE_NOT_ALLOW_DEPOSIT);\n        require(amount != 0, JUSDErrors.DEPOSIT_AMOUNT_IS_ZERO);\n        IERC20(collateral).safeTransferFrom(from, address(this), amount);\n        _addCollateralIfNotExists(user, collateral);\n        user.depositBalance[collateral] += amount;\n        reserve.totalDepositAmount += amount;\n        require(\n            user.depositBalance[collateral] <=\n                reserve.maxDepositAmountPerAccount,\n            JUSDErrors.EXCEED_THE_MAX_DEPOSIT_AMOUNT_PER_ACCOUNT\n        );\n        require(\n            reserve.totalDepositAmount <= reserve.maxTotalDepositAmount,\n            JUSDErrors.EXCEED_THE_MAX_DEPOSIT_AMOUNT_TOTAL\n        );\n        emit Deposit(collateral, from, to, msg.sender, amount);\n    }\n\n    //    Pass parameter checking, excluding checking legality\n    function _borrow(\n        DataTypes.UserInfo storage user,\n        bool isDepositToJOJO,\n        address to,\n        uint256 tAmount,\n        address from\n    ) internal {\n        uint256 tRate = getTRate();\n        //        tAmount % tRate ？ tAmount / tRate + 1 ： tAmount % tRate\n        uint256 t0Amount = tAmount.decimalRemainder(tRate)\n            ? tAmount.decimalDiv(tRate)\n            : tAmount.decimalDiv(tRate) + 1;\n        user.t0BorrowBalance += t0Amount;\n        t0TotalBorrowAmount += t0Amount;\n        if (isDepositToJOJO) {\n            IERC20(JUSD).approve(address(JOJODealer), tAmount);\n            IDealer(JOJODealer).deposit(0, tAmount, to);\n        } else {\n            IERC20(JUSD).safeTransfer(to, tAmount);\n        }\n        // Personal account hard cap\n        require(\n            user.t0BorrowBalance.decimalMul(tRate) <= maxPerAccountBorrowAmount,\n            JUSDErrors.EXCEED_THE_MAX_BORROW_AMOUNT_PER_ACCOUNT\n        );\n        // Global account hard cap\n        require(\n            t0TotalBorrowAmount.decimalMul(tRate) <= maxTotalBorrowAmount,\n            JUSDErrors.EXCEED_THE_MAX_BORROW_AMOUNT_TOTAL\n        );\n        emit Borrow(from, to, tAmount, isDepositToJOJO);\n    }\n\n    function _repay(\n        DataTypes.UserInfo storage user,\n        address payer,\n        address to,\n        uint256 amount,\n        uint256 tRate\n    ) internal returns (uint256) {\n        require(amount != 0, JUSDErrors.REPAY_AMOUNT_IS_ZERO);\n        uint256 JUSDBorrowed = user.t0BorrowBalance.decimalMul(tRate);\n        uint256 tBorrowAmount;\n        uint256 t0Amount;\n        if (JUSDBorrowed <= amount) {\n            tBorrowAmount = JUSDBorrowed;\n            t0Amount = user.t0BorrowBalance;\n        } else {\n            tBorrowAmount = amount;\n            t0Amount = amount.decimalDiv(tRate);\n        }\n        IERC20(JUSD).safeTransferFrom(payer, address(this), tBorrowAmount);\n        user.t0BorrowBalance -= t0Amount;\n        t0TotalBorrowAmount -= t0Amount;\n        emit Repay(payer, to, tBorrowAmount);\n        return tBorrowAmount;\n    }\n\n    function _withdraw(\n        uint256 amount,\n        address collateral,\n        address to,\n        address from,\n        bool isInternal\n    ) internal {\n        DataTypes.ReserveInfo storage reserve = reserveInfo[collateral];\n        DataTypes.UserInfo storage fromAccount = userInfo[from];\n        require(amount != 0, JUSDErrors.WITHDRAW_AMOUNT_IS_ZERO);\n        require(\n            amount <= fromAccount.depositBalance[collateral],\n            JUSDErrors.WITHDRAW_AMOUNT_IS_TOO_BIG\n        );\n\n        fromAccount.depositBalance[collateral] -= amount;\n        if (isInternal) {\n            DataTypes.UserInfo storage toAccount = userInfo[to];\n            _addCollateralIfNotExists(toAccount, collateral);\n            toAccount.depositBalance[collateral] += amount;\n            require(\n                toAccount.depositBalance[collateral] <=\n                    reserve.maxDepositAmountPerAccount,\n                JUSDErrors.EXCEED_THE_MAX_DEPOSIT_AMOUNT_PER_ACCOUNT\n            );\n        } else {\n            reserve.totalDepositAmount -= amount;\n            IERC20(collateral).safeTransfer(to, amount);\n        }\n        emit Withdraw(collateral, from, to, amount, isInternal);\n        _removeEmptyCollateral(fromAccount, collateral);\n    }\n\n    function isValidLiquidator(address liquidated, address liquidator) internal view {\n        require(\n            liquidator != liquidated,\n            JUSDErrors.SELF_LIQUIDATION_NOT_ALLOWED\n        );\n        if(isLiquidatorWhitelistOpen){\n            require(isLiquidatorWhiteList[liquidator], JUSDErrors.LIQUIDATOR_NOT_IN_THE_WHITELIST);\n        }\n    }\n\n    /// @notice liquidate is divided into three steps,\n    // 1. determine whether liquidatedTrader is safe\n    // 2. calculate the collateral amount actually liquidated\n    // 3. transfer the insurance fee\n    function _calculateLiquidateAmount(\n        address liquidated,\n        address collateral,\n        uint256 amount\n    ) internal view returns (DataTypes.LiquidateData memory liquidateData) {\n        DataTypes.UserInfo storage liquidatedInfo = userInfo[liquidated];\n        require(amount != 0, JUSDErrors.LIQUIDATE_AMOUNT_IS_ZERO);\n        require(\n            amount <= liquidatedInfo.depositBalance[collateral],\n            JUSDErrors.LIQUIDATE_AMOUNT_IS_TOO_BIG\n        );\n        uint256 tRate = getTRate();\n        require(\n            _isStartLiquidation(liquidatedInfo, tRate),\n            JUSDErrors.ACCOUNT_IS_SAFE\n        );\n        DataTypes.ReserveInfo memory reserve = reserveInfo[collateral];\n        uint256 price = IPriceChainLink(reserve.oracle).getAssetPrice();\n        uint256 priceOff = price.decimalMul(\n            DecimalMath.ONE - reserve.liquidationPriceOff\n        );\n        uint256 liquidateAmount = amount.decimalMul(priceOff).decimalMul(\n            JOJOConstant.ONE - reserve.insuranceFeeRate\n        );\n        uint256 JUSDBorrowed = liquidatedInfo.t0BorrowBalance.decimalMul(tRate);\n        /*\n        liquidateAmount <= JUSDBorrowed\n        liquidateAmount = amount * priceOff * (1-insuranceFee)\n        actualJUSD = actualCollateral * priceOff\n        insuranceFee = actualCollateral * priceOff * insuranceFeeRate\n        */\n        if (liquidateAmount <= JUSDBorrowed) {\n            liquidateData.actualCollateral = amount;\n            liquidateData.insuranceFee = amount.decimalMul(priceOff).decimalMul(\n                reserve.insuranceFeeRate\n            );\n            liquidateData.actualLiquidatedT0 = liquidateAmount.decimalDiv(\n                tRate\n            );\n            liquidateData.actualLiquidated = liquidateAmount;\n        } else {\n            //            actualJUSD = actualCollateral * priceOff\n            //            = JUSDBorrowed * priceOff / priceOff * (1-insuranceFeeRate)\n            //            = JUSDBorrowed / (1-insuranceFeeRate)\n            //            insuranceFee = actualJUSD * insuranceFeeRate\n            //            = actualCollateral * priceOff * insuranceFeeRate\n            //            = JUSDBorrowed * insuranceFeeRate / (1- insuranceFeeRate)\n            liquidateData.actualCollateral = JUSDBorrowed\n                .decimalDiv(priceOff)\n                .decimalDiv(JOJOConstant.ONE - reserve.insuranceFeeRate);\n            liquidateData.insuranceFee = JUSDBorrowed\n                .decimalMul(reserve.insuranceFeeRate)\n                .decimalDiv(JOJOConstant.ONE - reserve.insuranceFeeRate);\n            liquidateData.actualLiquidatedT0 = liquidatedInfo.t0BorrowBalance;\n            liquidateData.actualLiquidated = JUSDBorrowed;\n        }\n\n        liquidateData.liquidatedRemainUSDC = (amount -\n            liquidateData.actualCollateral).decimalMul(price);\n    }\n\n    function _addCollateralIfNotExists(\n        DataTypes.UserInfo storage user,\n        address collateral\n    ) internal {\n        if (!user.hasCollateral[collateral]) {\n            user.hasCollateral[collateral] = true;\n            user.collateralList.push(collateral);\n        }\n    }\n\n    function _removeEmptyCollateral(\n        DataTypes.UserInfo storage user,\n        address collateral\n    ) internal {\n        if (user.depositBalance[collateral] == 0) {\n            user.hasCollateral[collateral] = false;\n            address[] storage collaterals = user.collateralList;\n            for (uint256 i; i < collaterals.length; i = i + 1) {\n                if (collaterals[i] == collateral) {\n                    collaterals[i] = collaterals[collaterals.length - 1];\n                    collaterals.pop();\n                    break;\n                }\n            }\n        }\n    }\n\n    function _afterLiquidateOperation(\n        bytes memory afterOperationParam,\n        uint256 flashloanAmount,\n        address collateral,\n        address liquidated,\n        DataTypes.LiquidateData memory liquidateData\n    ) internal {\n        (address flashloanAddress, bytes memory param) = abi.decode(\n            afterOperationParam,\n            (address, bytes)\n        );\n        _withdraw(\n            flashloanAmount,\n            collateral,\n            flashloanAddress,\n            liquidated,\n            false\n        );\n        param = abi.encode(liquidateData, param);\n        IFlashLoanReceive(flashloanAddress).JOJOFlashLoan(\n            collateral,\n            flashloanAmount,\n            liquidated,\n            param\n        );\n    }\n\n    /// @notice handle the bad debt\n    /// @param liquidatedTrader need to be liquidated\n    function _handleBadDebt(address liquidatedTrader) internal {\n        DataTypes.UserInfo storage liquidatedTraderInfo = userInfo[\n            liquidatedTrader\n        ];\n        uint256 tRate = getTRate();\n        if (\n            liquidatedTraderInfo.collateralList.length == 0 &&\n            _isStartLiquidation(liquidatedTraderInfo, tRate)\n        ) {\n            DataTypes.UserInfo storage insuranceInfo = userInfo[insurance];\n            uint256 borrowJUSDT0 = liquidatedTraderInfo.t0BorrowBalance;\n            insuranceInfo.t0BorrowBalance += borrowJUSDT0;\n            liquidatedTraderInfo.t0BorrowBalance = 0;\n            emit HandleBadDebt(liquidatedTrader, borrowJUSDT0);\n        }\n    }\n}"
    }
  ]
}