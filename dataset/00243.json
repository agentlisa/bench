{
  "Title": "Misleading Documentation",
  "Content": "Throughout the codebase, there are instances of misleading documentation:\n\n\n* In [line 80](https://github.com/mantlenetworkio/op-geth/blob/4d05b2cd9a2b8096680eb9b2e87e473a44a43922/core/types/transaction.go#L80) of `transaction.go`, the comment currently says \"This is implemented by DynamicFeeTx, LegacyTx and AccessListTx\", but should be updated to include the `BlobTx` and `DepositTx` types.\n* In [line 377](https://github.com/mantlenetworkio/op-geth/blob/4d05b2cd9a2b8096680eb9b2e87e473a44a43922/core/types/transaction.go#L377) of `transaction.go`, the comment currently says \"gas \\* gasPrice + value\", but should say \"(gas \\* gasPrice) + (blobGas \\* blobGasPrice) + value\" instead.\n* In [line 655](https://github.com/mantlenetworkio/op-geth/blob/4d05b2cd9a2b8096680eb9b2e87e473a44a43922/core/state_transition.go#L655) of `state_transition.go`, the comment currently says \"Return ETH for remaining gas\", but should say \"MNT\" instead.\n\n\nFurthermore, there is misleading documentation in the developer documentation as well:\n\n\n* The [\"*BASEFEE Adjustment Mechanism*\" section \"Application of EIP-1559 in Mantle v2\"](https://docs-v2.mantle.xyz/devs/concepts/tx-fee/eip-1559#application-of-eip-1559-in-mantle-v2) is outdated. With the [Mantle `BaseFee` upgrade](https://github.com/mantlenetworkio/op-geth/blob/4d05b2cd9a2b8096680eb9b2e87e473a44a43922/params/config.go#L680), the [`BaseFee` is set](https://github.com/mantlenetworkio/op-geth/blob/4d05b2cd9a2b8096680eb9b2e87e473a44a43922/consensus/misc/eip1559.go#L57-L59) by a config contract (or remains as the last `BaseFee`).\n\n\nConsider fixing the reported documentation instances to improve the overall readability of the codebase.\n\n\n***Update:** Partially resolved in [pull request #41](https://github.com/mantlenetworkio/op-geth/pull/41) at commit [44c9a41](https://github.com/mantlenetworkio/op-geth/pull/41/commits/44c9a4154ba92dd32def5957f6b51d420aa382ad) and [pull request #52](https://github.com/mantlenetworkio/op-geth/pull/52) at commit [2527a58](https://github.com/mantlenetworkio/op-geth/pull/52/commits/2527a58e28c0fcb2674820375e71cc1b33dfed27). While the comments on line 377 in `transaction.go` and line 655 in `state_transition.go` have been resolved, the comment on line 80 in `transaction.go` as well as the developer documentation remain unchanged.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "core/types/transaction.go",
      "content": "// Copyright 2014 The go-ethereum Authors\n// This file is part of the go-ethereum library.\n//\n// The go-ethereum library is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// The go-ethereum library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.\n\npackage types\n\nimport (\n\t\"bytes\"\n\t\"container/heap\"\n\t\"errors\"\n\t\"io\"\n\t\"math/big\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/common/math\"\n\t\"github.com/ethereum/go-ethereum/crypto\"\n\t\"github.com/ethereum/go-ethereum/log\"\n\t\"github.com/ethereum/go-ethereum/rlp\"\n)\n\nvar (\n\tErrInvalidSig           = errors.New(\"invalid transaction v, r, s values\")\n\tErrUnexpectedProtection = errors.New(\"transaction type does not supported EIP-155 protected signatures\")\n\tErrInvalidTxType        = errors.New(\"transaction type not valid in this context\")\n\tErrTxTypeNotSupported   = errors.New(\"transaction type not supported\")\n\tErrGasFeeCapTooLow      = errors.New(\"fee cap less than base fee\")\n\terrShortTypedTx         = errors.New(\"typed transaction too short\")\n\terrInvalidYParity       = errors.New(\"'yParity' field must be 0 or 1\")\n\terrVYParityMismatch     = errors.New(\"'v' and 'yParity' fields do not match\")\n\terrVYParityMissing      = errors.New(\"missing 'yParity' or 'v' field in transaction\")\n)\n\n// Transaction types.\nconst (\n\tLegacyTxType     = 0x00\n\tAccessListTxType = 0x01\n\tDynamicFeeTxType = 0x02\n\tBlobTxType       = 0x03\n)\n\n// Transaction is an Ethereum transaction.\ntype Transaction struct {\n\tinner TxData    // Consensus contents of a transaction\n\ttime  time.Time // Time first seen locally (spam avoidance)\n\n\t// caches\n\thash atomic.Value\n\tsize atomic.Value\n\tfrom atomic.Value\n\n\tmetaTxParams atomic.Value\n\n\t// cache of RollupGasData details to compute the gas the tx takes on L1 for its share of rollup data\n\trollupGas atomic.Value\n}\n\n// NewTx creates a new transaction.\nfunc NewTx(inner TxData) *Transaction {\n\ttx := new(Transaction)\n\ttx.setDecoded(inner.copy(), 0)\n\treturn tx\n}\n\n// TxData is the underlying data of a transaction.\n//\n// This is implemented by DynamicFeeTx, LegacyTx and AccessListTx.\ntype TxData interface {\n\ttxType() byte // returns the type ID\n\tcopy() TxData // creates a deep copy and initializes all fields\n\n\tchainID() *big.Int\n\taccessList() AccessList\n\tdata() []byte\n\tgas() uint64\n\tgasPrice() *big.Int\n\tgasTipCap() *big.Int\n\tgasFeeCap() *big.Int\n\tvalue() *big.Int\n\tnonce() uint64\n\tto() *common.Address\n\tisSystemTx() bool\n\n\trawSignatureValues() (v, r, s *big.Int)\n\tsetSignatureValues(chainID, v, r, s *big.Int)\n\n\t// effectiveGasPrice computes the gas price paid by the transaction, given\n\t// the inclusion block baseFee.\n\t//\n\t// Unlike other TxData methods, the returned *big.Int should be an independent\n\t// copy of the computed value, i.e. callers are allowed to mutate the result.\n\t// Method implementations can use 'dst' to store the result.\n\teffectiveGasPrice(dst *big.Int, baseFee *big.Int) *big.Int\n}\n\n// EncodeRLP implements rlp.Encoder\nfunc (tx *Transaction) EncodeRLP(w io.Writer) error {\n\tif tx.Type() == LegacyTxType {\n\t\treturn rlp.Encode(w, tx.inner)\n\t}\n\t// It's an EIP-2718 typed TX envelope.\n\tbuf := encodeBufferPool.Get().(*bytes.Buffer)\n\tdefer encodeBufferPool.Put(buf)\n\tbuf.Reset()\n\tif err := tx.encodeTyped(buf); err != nil {\n\t\treturn err\n\t}\n\treturn rlp.Encode(w, buf.Bytes())\n}\n\n// encodeTyped writes the canonical encoding of a typed transaction to w.\nfunc (tx *Transaction) encodeTyped(w *bytes.Buffer) error {\n\tw.WriteByte(tx.Type())\n\treturn rlp.Encode(w, tx.inner)\n}\n\n// MarshalBinary returns the canonical encoding of the transaction.\n// For legacy transactions, it returns the RLP encoding. For EIP-2718 typed\n// transactions, it returns the type and payload.\nfunc (tx *Transaction) MarshalBinary() ([]byte, error) {\n\tif tx.Type() == LegacyTxType {\n\t\treturn rlp.EncodeToBytes(tx.inner)\n\t}\n\tvar buf bytes.Buffer\n\terr := tx.encodeTyped(&buf)\n\treturn buf.Bytes(), err\n}\n\n// DecodeRLP implements rlp.Decoder\nfunc (tx *Transaction) DecodeRLP(s *rlp.Stream) error {\n\tkind, size, err := s.Kind()\n\tswitch {\n\tcase err != nil:\n\t\treturn err\n\tcase kind == rlp.List:\n\t\t// It's a legacy transaction.\n\t\tvar inner LegacyTx\n\t\terr := s.Decode(&inner)\n\t\tif err == nil {\n\t\t\ttx.setDecoded(&inner, rlp.ListSize(size))\n\t\t}\n\t\treturn err\n\tdefault:\n\t\t// It's an EIP-2718 typed TX envelope.\n\t\tvar b []byte\n\t\tif b, err = s.Bytes(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tinner, err := tx.decodeTyped(b)\n\t\tif err == nil {\n\t\t\ttx.setDecoded(inner, uint64(len(b)))\n\t\t}\n\t\treturn err\n\t}\n}\n\n// UnmarshalBinary decodes the canonical encoding of transactions.\n// It supports legacy RLP transactions and EIP2718 typed transactions.\nfunc (tx *Transaction) UnmarshalBinary(b []byte) error {\n\tif len(b) > 0 && b[0] > 0x7f {\n\t\t// It's a legacy transaction.\n\t\tvar data LegacyTx\n\t\terr := rlp.DecodeBytes(b, &data)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttx.setDecoded(&data, uint64(len(b)))\n\t\treturn nil\n\t}\n\t// It's an EIP2718 typed transaction envelope.\n\tinner, err := tx.decodeTyped(b)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttx.setDecoded(inner, uint64(len(b)))\n\treturn nil\n}\n\n// decodeTyped decodes a typed transaction from the canonical format.\nfunc (tx *Transaction) decodeTyped(b []byte) (TxData, error) {\n\tif len(b) <= 1 {\n\t\treturn nil, errShortTypedTx\n\t}\n\tswitch b[0] {\n\tcase AccessListTxType:\n\t\tvar inner AccessListTx\n\t\terr := rlp.DecodeBytes(b[1:], &inner)\n\t\treturn &inner, err\n\tcase DynamicFeeTxType:\n\t\tvar inner DynamicFeeTx\n\t\terr := rlp.DecodeBytes(b[1:], &inner)\n\t\treturn &inner, err\n\tcase DepositTxType:\n\t\tvar inner DepositTx\n\t\terr := rlp.DecodeBytes(b[1:], &inner)\n\t\treturn &inner, err\n\tcase BlobTxType:\n\t\tvar inner BlobTx\n\t\terr := rlp.DecodeBytes(b[1:], &inner)\n\t\treturn &inner, err\n\tdefault:\n\t\treturn nil, ErrTxTypeNotSupported\n\t}\n}\n\n// setDecoded sets the inner transaction and size after decoding.\nfunc (tx *Transaction) setDecoded(inner TxData, size uint64) {\n\ttx.inner = inner\n\ttx.time = time.Now()\n\tif size > 0 {\n\t\ttx.size.Store(size)\n\t}\n}\n\nfunc sanityCheckSignature(v *big.Int, r *big.Int, s *big.Int, maybeProtected bool) error {\n\tif isProtectedV(v) && !maybeProtected {\n\t\treturn ErrUnexpectedProtection\n\t}\n\n\tvar plainV byte\n\tif isProtectedV(v) {\n\t\tchainID := deriveChainId(v).Uint64()\n\t\tplainV = byte(v.Uint64() - 35 - 2*chainID)\n\t} else if maybeProtected {\n\t\t// Only EIP-155 signatures can be optionally protected. Since\n\t\t// we determined this v value is not protected, it must be a\n\t\t// raw 27 or 28.\n\t\tplainV = byte(v.Uint64() - 27)\n\t} else {\n\t\t// If the signature is not optionally protected, we assume it\n\t\t// must already be equal to the recovery id.\n\t\tplainV = byte(v.Uint64())\n\t}\n\tif !crypto.ValidateSignatureValues(plainV, r, s, false) {\n\t\treturn ErrInvalidSig\n\t}\n\n\treturn nil\n}\n\nfunc isProtectedV(V *big.Int) bool {\n\tif V.BitLen() <= 8 {\n\t\tv := V.Uint64()\n\t\treturn v != 27 && v != 28 && v != 1 && v != 0\n\t}\n\t// anything not 27 or 28 is considered protected\n\treturn true\n}\n\n// Protected says whether the transaction is replay-protected.\nfunc (tx *Transaction) Protected() bool {\n\tswitch tx := tx.inner.(type) {\n\tcase *LegacyTx:\n\t\treturn tx.V != nil && isProtectedV(tx.V)\n\tdefault:\n\t\treturn true\n\t}\n}\n\n// Type returns the transaction type.\nfunc (tx *Transaction) Type() uint8 {\n\treturn tx.inner.txType()\n}\n\n// ChainId returns the EIP155 chain ID of the transaction. The return value will always be\n// non-nil. For legacy transactions which are not replay-protected, the return value is\n// zero.\nfunc (tx *Transaction) ChainId() *big.Int {\n\treturn tx.inner.chainID()\n}\n\n// Data returns the input data of the transaction.\nfunc (tx *Transaction) Data() []byte { return tx.inner.data() }\n\n// AccessList returns the access list of the transaction.\nfunc (tx *Transaction) AccessList() AccessList { return tx.inner.accessList() }\n\n// Gas returns the gas limit of the transaction.\nfunc (tx *Transaction) Gas() uint64 { return tx.inner.gas() }\n\n// GasPrice returns the gas price of the transaction.\nfunc (tx *Transaction) GasPrice() *big.Int { return new(big.Int).Set(tx.inner.gasPrice()) }\n\n// GasTipCap returns the gasTipCap per gas of the transaction.\nfunc (tx *Transaction) GasTipCap() *big.Int { return new(big.Int).Set(tx.inner.gasTipCap()) }\n\n// GasFeeCap returns the fee cap per gas of the transaction.\nfunc (tx *Transaction) GasFeeCap() *big.Int { return new(big.Int).Set(tx.inner.gasFeeCap()) }\n\n// Value returns the ether amount of the transaction.\nfunc (tx *Transaction) Value() *big.Int { return new(big.Int).Set(tx.inner.value()) }\n\n// Nonce returns the sender account nonce of the transaction.\nfunc (tx *Transaction) Nonce() uint64 { return tx.inner.nonce() }\n\n// EffectiveNonce returns the nonce that was actually used as part of transaction execution\n// Returns nil if the effective nonce is not known\nfunc (tx *Transaction) EffectiveNonce() *uint64 {\n\ttype txWithEffectiveNonce interface {\n\t\teffectiveNonce() *uint64\n\t}\n\n\tif itx, ok := tx.inner.(txWithEffectiveNonce); ok {\n\t\treturn itx.effectiveNonce()\n\t}\n\tnonce := tx.inner.nonce()\n\treturn &nonce\n}\n\n// To returns the recipient address of the transaction.\n// For contract-creation transactions, To returns nil.\nfunc (tx *Transaction) To() *common.Address {\n\treturn copyAddressPtr(tx.inner.to())\n}\n\n// SourceHash returns the hash that uniquely identifies the source of the deposit tx,\n// e.g. a user deposit event, or a L1 info deposit included in a specific L2 block height.\n// Non-deposit transactions return a zeroed hash.\nfunc (tx *Transaction) SourceHash() common.Hash {\n\tif dep, ok := tx.inner.(*DepositTx); ok {\n\t\treturn dep.SourceHash\n\t}\n\treturn common.Hash{}\n}\n\n// Mint returns the MNT to mint in the deposit tx.\n// This returns nil if there is nothing to mint, or if this is not a deposit tx.\nfunc (tx *Transaction) Mint() *big.Int {\n\tif dep, ok := tx.inner.(*DepositTx); ok {\n\t\treturn dep.Mint\n\t}\n\treturn nil\n}\n\n// ETHValue returns the BVM_ETH to mint in the deposit tx.\n// This returns nil if there is nothing to mint, or if this is not a deposit tx.\nfunc (tx *Transaction) ETHValue() *big.Int {\n\tif dep, ok := tx.inner.(*DepositTx); ok {\n\t\treturn dep.EthValue\n\t}\n\treturn nil\n}\n\n// ETHTxValue returns the BVM_ETH to be transferred in the deposit tx.\n// This returns nil if there is nothing to transfer, or if this is not a deposit tx.\nfunc (tx *Transaction) ETHTxValue() *big.Int {\n\tif dep, ok := tx.inner.(*DepositTx); ok {\n\t\treturn dep.EthTxValue\n\t}\n\treturn nil\n}\n\n// IsDepositTx returns true if the transaction is a deposit tx type.\nfunc (tx *Transaction) IsDepositTx() bool {\n\treturn tx.Type() == DepositTxType\n}\n\n// IsSystemTx returns true for deposits that are system transactions. These transactions\n// are executed in an unmetered environment & do not contribute to the block gas limit.\nfunc (tx *Transaction) IsSystemTx() bool {\n\treturn tx.inner.isSystemTx()\n}\n\n// Cost returns gas * gasPrice + value.\nfunc (tx *Transaction) Cost() *big.Int {\n\ttotal := new(big.Int).Mul(tx.GasPrice(), new(big.Int).SetUint64(tx.Gas()))\n\tif tx.Type() == BlobTxType {\n\t\ttotal.Add(total, new(big.Int).Mul(tx.BlobGasFeeCap(), new(big.Int).SetUint64(tx.BlobGas())))\n\t}\n\treturn total\n}\n\n// RollupDataGas is the amount of gas it takes to confirm the tx on L1 as a rollup\nfunc (tx *Transaction) RollupDataGas() RollupGasData {\n\tif tx.Type() == DepositTxType {\n\t\treturn RollupGasData{}\n\t}\n\tif v := tx.rollupGas.Load(); v != nil {\n\t\treturn v.(RollupGasData)\n\t}\n\tdata, err := tx.MarshalBinary()\n\tif err != nil { // Silent error, invalid txs will not be marshalled/unmarshalled for batch submission anyway.\n\t\tlog.Error(\"failed to encode tx for L1 cost computation\", \"err\", err)\n\t}\n\tvar out RollupGasData\n\tfor _, byt := range data {\n\t\tif byt == 0 {\n\t\t\tout.Zeroes++\n\t\t} else {\n\t\t\tout.Ones++\n\t\t}\n\t}\n\ttx.rollupGas.Store(out)\n\treturn out\n}\n\n// RawSignatureValues returns the V, R, S signature values of the transaction.\n// The return values should not be modified by the caller.\nfunc (tx *Transaction) RawSignatureValues() (v, r, s *big.Int) {\n\treturn tx.inner.rawSignatureValues()\n}\n\n// GasFeeCapCmp compares the fee cap of two transactions.\nfunc (tx *Transaction) GasFeeCapCmp(other *Transaction) int {\n\treturn tx.inner.gasFeeCap().Cmp(other.inner.gasFeeCap())\n}\n\n// GasFeeCapIntCmp compares the fee cap of the transaction against the given fee cap.\nfunc (tx *Transaction) GasFeeCapIntCmp(other *big.Int) int {\n\treturn tx.inner.gasFeeCap().Cmp(other)\n}\n\n// GasTipCapCmp compares the gasTipCap of two transactions.\nfunc (tx *Transaction) GasTipCapCmp(other *Transaction) int {\n\treturn tx.inner.gasTipCap().Cmp(other.inner.gasTipCap())\n}\n\n// GasTipCapIntCmp compares the gasTipCap of the transaction against the given gasTipCap.\nfunc (tx *Transaction) GasTipCapIntCmp(other *big.Int) int {\n\treturn tx.inner.gasTipCap().Cmp(other)\n}\n\n// EffectiveGasTip returns the effective miner gasTipCap for the given base fee.\n// Note: if the effective gasTipCap is negative, this method returns both error\n// the actual negative value, _and_ ErrGasFeeCapTooLow\nfunc (tx *Transaction) EffectiveGasTip(baseFee *big.Int) (*big.Int, error) {\n\tif tx.Type() == DepositTxType {\n\t\treturn new(big.Int), nil\n\t}\n\tif baseFee == nil {\n\t\treturn tx.GasTipCap(), nil\n\t}\n\tvar err error\n\tgasFeeCap := tx.GasFeeCap()\n\tif gasFeeCap.Cmp(baseFee) == -1 {\n\t\terr = ErrGasFeeCapTooLow\n\t}\n\treturn math.BigMin(tx.GasTipCap(), gasFeeCap.Sub(gasFeeCap, baseFee)), err\n}\n\n// EffectiveGasTipValue is identical to EffectiveGasTip, but does not return an\n// error in case the effective gasTipCap is negative\nfunc (tx *Transaction) EffectiveGasTipValue(baseFee *big.Int) *big.Int {\n\teffectiveTip, _ := tx.EffectiveGasTip(baseFee)\n\treturn effectiveTip\n}\n\n// EffectiveGasTipCmp compares the effective gasTipCap of two transactions assuming the given base fee.\nfunc (tx *Transaction) EffectiveGasTipCmp(other *Transaction, baseFee *big.Int) int {\n\tif baseFee == nil {\n\t\treturn tx.GasTipCapCmp(other)\n\t}\n\treturn tx.EffectiveGasTipValue(baseFee).Cmp(other.EffectiveGasTipValue(baseFee))\n}\n\n// EffectiveGasTipIntCmp compares the effective gasTipCap of a transaction to the given gasTipCap.\nfunc (tx *Transaction) EffectiveGasTipIntCmp(other *big.Int, baseFee *big.Int) int {\n\tif baseFee == nil {\n\t\treturn tx.GasTipCapIntCmp(other)\n\t}\n\treturn tx.EffectiveGasTipValue(baseFee).Cmp(other)\n}\n\n// BlobGas returns the blob gas limit of the transaction for blob transactions, 0 otherwise.\nfunc (tx *Transaction) BlobGas() uint64 {\n\tif blobtx, ok := tx.inner.(*BlobTx); ok {\n\t\treturn blobtx.blobGas()\n\t}\n\treturn 0\n}\n\n// BlobGasFeeCap returns the blob gas fee cap per blob gas of the transaction for blob transactions, nil otherwise.\nfunc (tx *Transaction) BlobGasFeeCap() *big.Int {\n\tif blobtx, ok := tx.inner.(*BlobTx); ok {\n\t\treturn blobtx.BlobFeeCap.ToBig()\n\t}\n\treturn nil\n}\n\n// BlobHashes returns the hashes of the blob commitments for blob transactions, nil otherwise.\nfunc (tx *Transaction) BlobHashes() []common.Hash {\n\tif blobtx, ok := tx.inner.(*BlobTx); ok {\n\t\treturn blobtx.BlobHashes\n\t}\n\treturn nil\n}\n\n// BlobTxSidecar returns the sidecar of a blob transaction, nil otherwise.\nfunc (tx *Transaction) BlobTxSidecar() *BlobTxSidecar {\n\tif blobtx, ok := tx.inner.(*BlobTx); ok {\n\t\treturn blobtx.Sidecar\n\t}\n\treturn nil\n}\n\n// BlobGasFeeCapCmp compares the blob fee cap of two transactions.\nfunc (tx *Transaction) BlobGasFeeCapCmp(other *Transaction) int {\n\treturn tx.BlobGasFeeCap().Cmp(other.BlobGasFeeCap())\n}\n\n// BlobGasFeeCapIntCmp compares the blob fee cap of the transaction against the given blob fee cap.\nfunc (tx *Transaction) BlobGasFeeCapIntCmp(other *big.Int) int {\n\treturn tx.BlobGasFeeCap().Cmp(other)\n}\n\n// WithoutBlobTxSidecar returns a copy of tx with the blob sidecar removed.\nfunc (tx *Transaction) WithoutBlobTxSidecar() *Transaction {\n\tblobtx, ok := tx.inner.(*BlobTx)\n\tif !ok {\n\t\treturn tx\n\t}\n\tcpy := &Transaction{\n\t\tinner: blobtx.withoutSidecar(),\n\t\ttime:  tx.time,\n\t}\n\t// Note: tx.size cache not carried over because the sidecar is included in size!\n\tif h := tx.hash.Load(); h != nil {\n\t\tcpy.hash.Store(h)\n\t}\n\tif f := tx.from.Load(); f != nil {\n\t\tcpy.from.Store(f)\n\t}\n\treturn cpy\n}\n\n// Hash returns the transaction hash.\nfunc (tx *Transaction) Hash() common.Hash {\n\tif hash := tx.hash.Load(); hash != nil {\n\t\treturn hash.(common.Hash)\n\t}\n\n\tvar h common.Hash\n\tif tx.Type() == LegacyTxType {\n\t\th = rlpHash(tx.inner)\n\t} else {\n\t\th = prefixedRlpHash(tx.Type(), tx.inner)\n\t}\n\ttx.hash.Store(h)\n\treturn h\n}\n\n// Size returns the true encoded storage size of the transaction, either by encoding\n// and returning it, or returning a previously cached value.\nfunc (tx *Transaction) Size() uint64 {\n\tif size := tx.size.Load(); size != nil {\n\t\treturn size.(uint64)\n\t}\n\tc := writeCounter(0)\n\trlp.Encode(&c, &tx.inner)\n\n\tsize := uint64(c)\n\tif tx.Type() != LegacyTxType {\n\t\tsize += 1 // type byte\n\t}\n\ttx.size.Store(size)\n\treturn size\n}\n\n// WithSignature returns a new transaction with the given signature.\n// This signature needs to be in the [R || S || V] format where V is 0 or 1.\nfunc (tx *Transaction) WithSignature(signer Signer, sig []byte) (*Transaction, error) {\n\tr, s, v, err := signer.SignatureValues(tx, sig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcpy := tx.inner.copy()\n\tcpy.setSignatureValues(signer.ChainID(), v, r, s)\n\treturn &Transaction{inner: cpy, time: tx.time}, nil\n}\n\n// Transactions implements DerivableList for transactions.\ntype Transactions []*Transaction\n\n// Len returns the length of s.\nfunc (s Transactions) Len() int { return len(s) }\n\n// EncodeIndex encodes the i'th transaction to w. Note that this does not check for errors\n// because we assume that *Transaction will only ever contain valid txs that were either\n// constructed by decoding or via public API in this package.\nfunc (s Transactions) EncodeIndex(i int, w *bytes.Buffer) {\n\ttx := s[i]\n\tif tx.Type() == LegacyTxType {\n\t\trlp.Encode(w, tx.inner)\n\t} else {\n\t\ttx.encodeTyped(w)\n\t}\n}\n\n// TxDifference returns a new set which is the difference between a and b.\nfunc TxDifference(a, b Transactions) Transactions {\n\tkeep := make(Transactions, 0, len(a))\n\n\tremove := make(map[common.Hash]struct{})\n\tfor _, tx := range b {\n\t\tremove[tx.Hash()] = struct{}{}\n\t}\n\n\tfor _, tx := range a {\n\t\tif _, ok := remove[tx.Hash()]; !ok {\n\t\t\tkeep = append(keep, tx)\n\t\t}\n\t}\n\n\treturn keep\n}\n\n// HashDifference returns a new set which is the difference between a and b.\nfunc HashDifference(a, b []common.Hash) []common.Hash {\n\tkeep := make([]common.Hash, 0, len(a))\n\n\tremove := make(map[common.Hash]struct{})\n\tfor _, hash := range b {\n\t\tremove[hash] = struct{}{}\n\t}\n\n\tfor _, hash := range a {\n\t\tif _, ok := remove[hash]; !ok {\n\t\t\tkeep = append(keep, hash)\n\t\t}\n\t}\n\n\treturn keep\n}\n\n// TxByNonce implements the sort interface to allow sorting a list of transactions\n// by their nonces. This is usually only useful for sorting transactions from a\n// single account, otherwise a nonce comparison doesn't make much sense.\ntype TxByNonce Transactions\n\nfunc (s TxByNonce) Len() int           { return len(s) }\nfunc (s TxByNonce) Less(i, j int) bool { return s[i].Nonce() < s[j].Nonce() }\nfunc (s TxByNonce) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }\n\n// TxWithMinerFee wraps a transaction with its gas price or effective miner gasTipCap\ntype TxWithMinerFee struct {\n\ttx       *Transaction\n\tminerFee *big.Int\n}\n\n// NewTxWithMinerFee creates a wrapped transaction, calculating the effective\n// miner gasTipCap if a base fee is provided.\n// Returns error in case of a negative effective miner gasTipCap.\nfunc NewTxWithMinerFee(tx *Transaction, baseFee *big.Int) (*TxWithMinerFee, error) {\n\tminerFee, err := tx.EffectiveGasTip(baseFee)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &TxWithMinerFee{\n\t\ttx:       tx,\n\t\tminerFee: minerFee,\n\t}, nil\n}\n\n// TxByPriceAndTime implements both the sort and the heap interface, making it useful\n// for all at once sorting as well as individually adding and removing elements.\ntype TxByPriceAndTime []*TxWithMinerFee\n\nfunc (s TxByPriceAndTime) Len() int { return len(s) }\nfunc (s TxByPriceAndTime) Less(i, j int) bool {\n\t// If the prices are equal, use the time the transaction was first seen for\n\t// deterministic sorting\n\tcmp := s[i].minerFee.Cmp(s[j].minerFee)\n\tif cmp == 0 {\n\t\treturn s[i].tx.time.Before(s[j].tx.time)\n\t}\n\treturn cmp > 0\n}\nfunc (s TxByPriceAndTime) Swap(i, j int) { s[i], s[j] = s[j], s[i] }\n\nfunc (s *TxByPriceAndTime) Push(x interface{}) {\n\t*s = append(*s, x.(*TxWithMinerFee))\n}\n\nfunc (s *TxByPriceAndTime) Pop() interface{} {\n\told := *s\n\tn := len(old)\n\tx := old[n-1]\n\told[n-1] = nil\n\t*s = old[0 : n-1]\n\treturn x\n}\n\n// TransactionsByPriceAndNonce represents a set of transactions that can return\n// transactions in a profit-maximizing sorted order, while supporting removing\n// entire batches of transactions for non-executable accounts.\ntype TransactionsByPriceAndNonce struct {\n\ttxs     map[common.Address]Transactions // Per account nonce-sorted list of transactions\n\theads   TxByPriceAndTime                // Next transaction for each unique account (price heap)\n\tsigner  Signer                          // Signer for the set of transactions\n\tbaseFee *big.Int                        // Current base fee\n}\n\n// NewTransactionsByPriceAndNonce creates a transaction set that can retrieve\n// price sorted transactions in a nonce-honouring way.\n//\n// Note, the input map is reowned so the caller should not interact any more with\n// if after providing it to the constructor.\nfunc NewTransactionsByPriceAndNonce(signer Signer, txs map[common.Address]Transactions, baseFee *big.Int) *TransactionsByPriceAndNonce {\n\t// Initialize a price and received time based heap with the head transactions\n\theads := make(TxByPriceAndTime, 0, len(txs))\n\tfor from, accTxs := range txs {\n\t\tacc, _ := Sender(signer, accTxs[0])\n\t\twrapped, err := NewTxWithMinerFee(accTxs[0], baseFee)\n\t\t// Remove transaction if sender doesn't match from, or if wrapping fails.\n\t\tif acc != from || err != nil {\n\t\t\tdelete(txs, from)\n\t\t\tcontinue\n\t\t}\n\t\theads = append(heads, wrapped)\n\t\ttxs[from] = accTxs[1:]\n\t}\n\theap.Init(&heads)\n\n\t// Assemble and return the transaction set\n\treturn &TransactionsByPriceAndNonce{\n\t\ttxs:     txs,\n\t\theads:   heads,\n\t\tsigner:  signer,\n\t\tbaseFee: baseFee,\n\t}\n}\n\n// Peek returns the next transaction by price.\nfunc (t *TransactionsByPriceAndNonce) Peek() *Transaction {\n\tif len(t.heads) == 0 {\n\t\treturn nil\n\t}\n\treturn t.heads[0].tx\n}\n\n// Shift replaces the current best head with the next one from the same account.\nfunc (t *TransactionsByPriceAndNonce) Shift() {\n\tacc, _ := Sender(t.signer, t.heads[0].tx)\n\tif txs, ok := t.txs[acc]; ok && len(txs) > 0 {\n\t\tif wrapped, err := NewTxWithMinerFee(txs[0], t.baseFee); err == nil {\n\t\t\tt.heads[0], t.txs[acc] = wrapped, txs[1:]\n\t\t\theap.Fix(&t.heads, 0)\n\t\t\treturn\n\t\t}\n\t}\n\theap.Pop(&t.heads)\n}\n\n// Pop removes the best transaction, *not* replacing it with the next one from\n// the same account. This should be used when a transaction cannot be executed\n// and hence all subsequent ones should be discarded from the same account.\nfunc (t *TransactionsByPriceAndNonce) Pop() {\n\theap.Pop(&t.heads)\n}\n\n// copyAddressPtr copies an address.\nfunc copyAddressPtr(a *common.Address) *common.Address {\n\tif a == nil {\n\t\treturn nil\n\t}\n\tcpy := *a\n\treturn &cpy\n}"
    },
    {
      "filename": "core/types/transaction.go",
      "content": "// Copyright 2014 The go-ethereum Authors\n// This file is part of the go-ethereum library.\n//\n// The go-ethereum library is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// The go-ethereum library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.\n\npackage types\n\nimport (\n\t\"bytes\"\n\t\"container/heap\"\n\t\"errors\"\n\t\"io\"\n\t\"math/big\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/common/math\"\n\t\"github.com/ethereum/go-ethereum/crypto\"\n\t\"github.com/ethereum/go-ethereum/log\"\n\t\"github.com/ethereum/go-ethereum/rlp\"\n)\n\nvar (\n\tErrInvalidSig           = errors.New(\"invalid transaction v, r, s values\")\n\tErrUnexpectedProtection = errors.New(\"transaction type does not supported EIP-155 protected signatures\")\n\tErrInvalidTxType        = errors.New(\"transaction type not valid in this context\")\n\tErrTxTypeNotSupported   = errors.New(\"transaction type not supported\")\n\tErrGasFeeCapTooLow      = errors.New(\"fee cap less than base fee\")\n\terrShortTypedTx         = errors.New(\"typed transaction too short\")\n\terrInvalidYParity       = errors.New(\"'yParity' field must be 0 or 1\")\n\terrVYParityMismatch     = errors.New(\"'v' and 'yParity' fields do not match\")\n\terrVYParityMissing      = errors.New(\"missing 'yParity' or 'v' field in transaction\")\n)\n\n// Transaction types.\nconst (\n\tLegacyTxType     = 0x00\n\tAccessListTxType = 0x01\n\tDynamicFeeTxType = 0x02\n\tBlobTxType       = 0x03\n)\n\n// Transaction is an Ethereum transaction.\ntype Transaction struct {\n\tinner TxData    // Consensus contents of a transaction\n\ttime  time.Time // Time first seen locally (spam avoidance)\n\n\t// caches\n\thash atomic.Value\n\tsize atomic.Value\n\tfrom atomic.Value\n\n\tmetaTxParams atomic.Value\n\n\t// cache of RollupGasData details to compute the gas the tx takes on L1 for its share of rollup data\n\trollupGas atomic.Value\n}\n\n// NewTx creates a new transaction.\nfunc NewTx(inner TxData) *Transaction {\n\ttx := new(Transaction)\n\ttx.setDecoded(inner.copy(), 0)\n\treturn tx\n}\n\n// TxData is the underlying data of a transaction.\n//\n// This is implemented by DynamicFeeTx, LegacyTx and AccessListTx.\ntype TxData interface {\n\ttxType() byte // returns the type ID\n\tcopy() TxData // creates a deep copy and initializes all fields\n\n\tchainID() *big.Int\n\taccessList() AccessList\n\tdata() []byte\n\tgas() uint64\n\tgasPrice() *big.Int\n\tgasTipCap() *big.Int\n\tgasFeeCap() *big.Int\n\tvalue() *big.Int\n\tnonce() uint64\n\tto() *common.Address\n\tisSystemTx() bool\n\n\trawSignatureValues() (v, r, s *big.Int)\n\tsetSignatureValues(chainID, v, r, s *big.Int)\n\n\t// effectiveGasPrice computes the gas price paid by the transaction, given\n\t// the inclusion block baseFee.\n\t//\n\t// Unlike other TxData methods, the returned *big.Int should be an independent\n\t// copy of the computed value, i.e. callers are allowed to mutate the result.\n\t// Method implementations can use 'dst' to store the result.\n\teffectiveGasPrice(dst *big.Int, baseFee *big.Int) *big.Int\n}\n\n// EncodeRLP implements rlp.Encoder\nfunc (tx *Transaction) EncodeRLP(w io.Writer) error {\n\tif tx.Type() == LegacyTxType {\n\t\treturn rlp.Encode(w, tx.inner)\n\t}\n\t// It's an EIP-2718 typed TX envelope.\n\tbuf := encodeBufferPool.Get().(*bytes.Buffer)\n\tdefer encodeBufferPool.Put(buf)\n\tbuf.Reset()\n\tif err := tx.encodeTyped(buf); err != nil {\n\t\treturn err\n\t}\n\treturn rlp.Encode(w, buf.Bytes())\n}\n\n// encodeTyped writes the canonical encoding of a typed transaction to w.\nfunc (tx *Transaction) encodeTyped(w *bytes.Buffer) error {\n\tw.WriteByte(tx.Type())\n\treturn rlp.Encode(w, tx.inner)\n}\n\n// MarshalBinary returns the canonical encoding of the transaction.\n// For legacy transactions, it returns the RLP encoding. For EIP-2718 typed\n// transactions, it returns the type and payload.\nfunc (tx *Transaction) MarshalBinary() ([]byte, error) {\n\tif tx.Type() == LegacyTxType {\n\t\treturn rlp.EncodeToBytes(tx.inner)\n\t}\n\tvar buf bytes.Buffer\n\terr := tx.encodeTyped(&buf)\n\treturn buf.Bytes(), err\n}\n\n// DecodeRLP implements rlp.Decoder\nfunc (tx *Transaction) DecodeRLP(s *rlp.Stream) error {\n\tkind, size, err := s.Kind()\n\tswitch {\n\tcase err != nil:\n\t\treturn err\n\tcase kind == rlp.List:\n\t\t// It's a legacy transaction.\n\t\tvar inner LegacyTx\n\t\terr := s.Decode(&inner)\n\t\tif err == nil {\n\t\t\ttx.setDecoded(&inner, rlp.ListSize(size))\n\t\t}\n\t\treturn err\n\tdefault:\n\t\t// It's an EIP-2718 typed TX envelope.\n\t\tvar b []byte\n\t\tif b, err = s.Bytes(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tinner, err := tx.decodeTyped(b)\n\t\tif err == nil {\n\t\t\ttx.setDecoded(inner, uint64(len(b)))\n\t\t}\n\t\treturn err\n\t}\n}\n\n// UnmarshalBinary decodes the canonical encoding of transactions.\n// It supports legacy RLP transactions and EIP2718 typed transactions.\nfunc (tx *Transaction) UnmarshalBinary(b []byte) error {\n\tif len(b) > 0 && b[0] > 0x7f {\n\t\t// It's a legacy transaction.\n\t\tvar data LegacyTx\n\t\terr := rlp.DecodeBytes(b, &data)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttx.setDecoded(&data, uint64(len(b)))\n\t\treturn nil\n\t}\n\t// It's an EIP2718 typed transaction envelope.\n\tinner, err := tx.decodeTyped(b)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttx.setDecoded(inner, uint64(len(b)))\n\treturn nil\n}\n\n// decodeTyped decodes a typed transaction from the canonical format.\nfunc (tx *Transaction) decodeTyped(b []byte) (TxData, error) {\n\tif len(b) <= 1 {\n\t\treturn nil, errShortTypedTx\n\t}\n\tswitch b[0] {\n\tcase AccessListTxType:\n\t\tvar inner AccessListTx\n\t\terr := rlp.DecodeBytes(b[1:], &inner)\n\t\treturn &inner, err\n\tcase DynamicFeeTxType:\n\t\tvar inner DynamicFeeTx\n\t\terr := rlp.DecodeBytes(b[1:], &inner)\n\t\treturn &inner, err\n\tcase DepositTxType:\n\t\tvar inner DepositTx\n\t\terr := rlp.DecodeBytes(b[1:], &inner)\n\t\treturn &inner, err\n\tcase BlobTxType:\n\t\tvar inner BlobTx\n\t\terr := rlp.DecodeBytes(b[1:], &inner)\n\t\treturn &inner, err\n\tdefault:\n\t\treturn nil, ErrTxTypeNotSupported\n\t}\n}\n\n// setDecoded sets the inner transaction and size after decoding.\nfunc (tx *Transaction) setDecoded(inner TxData, size uint64) {\n\ttx.inner = inner\n\ttx.time = time.Now()\n\tif size > 0 {\n\t\ttx.size.Store(size)\n\t}\n}\n\nfunc sanityCheckSignature(v *big.Int, r *big.Int, s *big.Int, maybeProtected bool) error {\n\tif isProtectedV(v) && !maybeProtected {\n\t\treturn ErrUnexpectedProtection\n\t}\n\n\tvar plainV byte\n\tif isProtectedV(v) {\n\t\tchainID := deriveChainId(v).Uint64()\n\t\tplainV = byte(v.Uint64() - 35 - 2*chainID)\n\t} else if maybeProtected {\n\t\t// Only EIP-155 signatures can be optionally protected. Since\n\t\t// we determined this v value is not protected, it must be a\n\t\t// raw 27 or 28.\n\t\tplainV = byte(v.Uint64() - 27)\n\t} else {\n\t\t// If the signature is not optionally protected, we assume it\n\t\t// must already be equal to the recovery id.\n\t\tplainV = byte(v.Uint64())\n\t}\n\tif !crypto.ValidateSignatureValues(plainV, r, s, false) {\n\t\treturn ErrInvalidSig\n\t}\n\n\treturn nil\n}\n\nfunc isProtectedV(V *big.Int) bool {\n\tif V.BitLen() <= 8 {\n\t\tv := V.Uint64()\n\t\treturn v != 27 && v != 28 && v != 1 && v != 0\n\t}\n\t// anything not 27 or 28 is considered protected\n\treturn true\n}\n\n// Protected says whether the transaction is replay-protected.\nfunc (tx *Transaction) Protected() bool {\n\tswitch tx := tx.inner.(type) {\n\tcase *LegacyTx:\n\t\treturn tx.V != nil && isProtectedV(tx.V)\n\tdefault:\n\t\treturn true\n\t}\n}\n\n// Type returns the transaction type.\nfunc (tx *Transaction) Type() uint8 {\n\treturn tx.inner.txType()\n}\n\n// ChainId returns the EIP155 chain ID of the transaction. The return value will always be\n// non-nil. For legacy transactions which are not replay-protected, the return value is\n// zero.\nfunc (tx *Transaction) ChainId() *big.Int {\n\treturn tx.inner.chainID()\n}\n\n// Data returns the input data of the transaction.\nfunc (tx *Transaction) Data() []byte { return tx.inner.data() }\n\n// AccessList returns the access list of the transaction.\nfunc (tx *Transaction) AccessList() AccessList { return tx.inner.accessList() }\n\n// Gas returns the gas limit of the transaction.\nfunc (tx *Transaction) Gas() uint64 { return tx.inner.gas() }\n\n// GasPrice returns the gas price of the transaction.\nfunc (tx *Transaction) GasPrice() *big.Int { return new(big.Int).Set(tx.inner.gasPrice()) }\n\n// GasTipCap returns the gasTipCap per gas of the transaction.\nfunc (tx *Transaction) GasTipCap() *big.Int { return new(big.Int).Set(tx.inner.gasTipCap()) }\n\n// GasFeeCap returns the fee cap per gas of the transaction.\nfunc (tx *Transaction) GasFeeCap() *big.Int { return new(big.Int).Set(tx.inner.gasFeeCap()) }\n\n// Value returns the ether amount of the transaction.\nfunc (tx *Transaction) Value() *big.Int { return new(big.Int).Set(tx.inner.value()) }\n\n// Nonce returns the sender a"
    }
  ]
}