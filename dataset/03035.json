{
  "Title": "H-1: A malicious early user/attacker can manipulate the LToken's pricePerShare to take an unfair share of future users' deposits",
  "Content": "# Issue H-1: A malicious early user/attacker can manipulate the LToken's pricePerShare to take an unfair share of future users' deposits \nSource: https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/004-H \n## Found by \nkankodu, JohnSmith, PwnPatrol, WATCHPUG, berndartmueller, hyh, \\_\\_141345\\_\\_, IllIllI, TomJ\n\n## Summary\n\nA well known attack vector for almost all shares based liquidity pool contracts, where an early user can manipulate the price per share and profit from late users' deposits because of the precision loss caused by the rather large value of price per share.\n\n## Vulnerability Detail\n\nA malicious early user can `deposit()` with `1 wei` of `asset` token as the first depositor of the LToken, and get `1 wei` of shares.\n\nThen the attacker can send `10000e18 - 1` of `asset` tokens and inflate the price per share from 1.0000 to an extreme value of 1.0000e22 ( from `(1 + 10000e18 - 1) / 1`) .\n\nAs a result, the future user who deposits `19999e18` will only receive `1 wei` (from `19999e18 * 1 / 10000e18`) of shares token.\n\nThey will immediately lose `9999e18` or half of their deposits if they `redeem()` right after the `deposit()`.\n\n## Impact\n\nThe attacker can profit from future users' deposits. While the late users will lose part of their funds to the attacker.\n\n## Code Snippet\n\nhttps://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/src/tokens/utils/ERC4626.sol#L48-L60\n\n```solidity\nfunction deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n    beforeDeposit(assets, shares);\n\n    // Check for rounding error since we round down in previewDeposit.\n    require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n    // Need to transfer before minting or ERC777s could reenter.\n    asset.safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n}\n```\n\nhttps://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/src/tokens/utils/ERC4626.sol#L138-L140\n\n```solidity\nfunction previewDeposit(uint256 assets) public view virtual returns (uint256) {\n    return convertToShares(assets);\n}\n```\n\nhttps://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/src/tokens/utils/ERC4626.sol#L126-L131\n\n```solidity\nfunction convertToShares(uint256 assets) public view virtual returns (uint256) {\n    uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n    return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n}\n```\n\nhttps://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/src/tokens/LToken.sol#L191-L193\n\n```solidity\nfunction totalAssets() public view override returns (uint) {\n    return asset.balanceOf(address(this)) + getBorrows() - getReserves();\n}\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider requiring a minimal amount of share tokens to be minted for the first minter, and send a port of the initial mints as a reserve to the DAO so that the pricePerShare can be more resistant to manipulation.\n\n```solidity\nfunction deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n    beforeDeposit(assets, shares);\n\n    // Check for rounding error since we round down in previewDeposit.\n    require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n    // for the first mint, we require the mint amount > (10 ** decimals) / 100\n    // and send (10 ** decimals) / 1_000_000 of the initial supply as a reserve to DAO\n    if (totalSupply == 0 && decimals >= 6) {\n        require(shares > 10 ** (decimals - 2));\n        uint256 reserveShares = 10 ** (decimals - 6);\n        _mint(DAO, reserveShares);\n        shares -= reserveShares;\n    }\n\n    // Need to transfer before minting or ERC777s could reenter.\n    asset.safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n}\n\nfunction mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n    beforeDeposit(assets, shares);\n\n    assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n    // for the first mint, we require the mint amount > (10 ** decimals) / 100\n    // and send (10 ** decimals) / 1_000_000 of the initial supply as a reserve to DAO\n    if (totalSupply == 0 && decimals >= 6) {\n        require(shares > 10 ** (decimals - 2));\n        uint256 reserveShares = 10 ** (decimals - 6);\n        _mint(DAO, reserveShares);\n        shares -= reserveShares;\n    }\n\n    // Need to transfer before minting or ERC777s could reenter.\n    asset.safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n}\n```\n## Sentiment Team\nFixed as recommended but instead of sending these shares to the DAO, we burn them. PR [here](https://github.com/sentimentxyz/protocol/pull/232).\n\n## Lead Senior Watson\nConfirmed fix. \n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/1",
  "Code": [
    {
      "filename": "src/tokens/utils/ERC4626.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.15;\n\nimport {ERC20 as CustomERC20} from \"./ERC20.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\nabstract contract ERC4626 is CustomERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public asset;\n\n    function initERC4626(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) internal {\n        asset = _asset;\n        initERC20(_name, _symbol, asset.decimals());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        beforeDeposit(assets, shares);\n\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        beforeDeposit(assets, shares);\n\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function beforeDeposit(uint256 assets, uint256 shares) internal virtual {}\n}"
    },
    {
      "filename": "src/tokens/utils/ERC4626.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.15;\n\nimport {ERC20 as CustomERC20} from \"./ERC20.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\nabstract contract ERC4626 is CustomERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public asset;\n\n    function initERC4626(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) internal {\n        asset = _asset;\n        initERC20(_name, _symbol, asset.decimals());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        beforeDeposit(assets, shares);\n\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        beforeDeposit(assets, shares);\n\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function beforeDeposit(uint256 assets, uint256 shares) internal virtual {}\n}"
    },
    {
      "filename": "src/tokens/utils/ERC4626.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.15;\n\nimport {ERC20 as CustomERC20} from \"./ERC20.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\nabstract contract ERC4626 is CustomERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public asset;\n\n    function initERC4626(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) internal {\n        asset = _asset;\n        initERC20(_name, _symbol, asset.decimals());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        beforeDeposit(assets, shares);\n\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        beforeDeposit(assets, shares);\n\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function beforeDeposit(uint256 assets, uint256 shares) internal virtual {}\n}"
    },
    {
      "filename": "src/tokens/LToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {Errors} from \"../utils/Errors.sol\";\nimport {Pausable} from \"../utils/Pausable.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"./utils/ERC4626.sol\";\nimport {IRegistry} from \"../interface/core/IRegistry.sol\";\nimport {IRateModel} from \"../interface/core/IRateModel.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ILToken} from \"../interface/tokens/ILToken.sol\";\n\n/**\n    @title Lending Token\n    @notice Lending token with ERC4626 implementation\n*/\ncontract LToken is Pausable, ERC4626, ILToken {\n    using FixedPointMathLib for uint;\n    using SafeTransferLib for ERC20;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Utility variable to indicate if contract is initialized\n    bool private initialized;\n\n    /// @notice Registry\n    IRegistry public registry;\n\n    /// @notice Rate Model\n    IRateModel public rateModel;\n\n    /// @notice Account Manager\n    address public accountManager;\n\n    /// @notice Protocol treasury\n    address public treasury;\n\n    /// @notice Total amount of borrows\n    uint public borrows;\n\n    /// @notice Timestamp of when the state of the LToken was last updated\n    uint public lastUpdated;\n\n    /// @notice Protocol reserves\n    uint public reserves;\n\n    /// @notice Reserve factor\n    uint public reserveFactor;\n\n    /// @notice Total borrow shares minted\n    uint public totalBorrowShares;\n\n    /// @notice Mapping of account to borrow in terms of shares\n    mapping (address => uint) public borrowsOf;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   EVENTS                                   */\n    /* -------------------------------------------------------------------------- */\n\n    event ReservesRedeemed(address indexed treasury, uint amt);\n\n    /* -------------------------------------------------------------------------- */\n    /*                              CUSTOM MODIFIERS                              */\n    /* -------------------------------------------------------------------------- */\n\n    modifier accountManagerOnly() {\n        if (msg.sender != accountManager) revert Errors.AccountManagerOnly();\n        _;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Contract initialization function\n        @dev Can only be invoked once\n        @param _asset Underlying ERC20 token\n        @param _name Name of LToken\n        @param _symbol Symbol of LToken\n        @param _registry Address of Registry\n        @param _reserveFactor Borrow Fee\n        @param _treasury Protocol treasury\n    */\n    function init(\n        ERC20 _asset,\n        string calldata _name,\n        string calldata _symbol,\n        IRegistry _registry,\n        uint _reserveFactor,\n        address _treasury\n    ) external {\n        if (initialized) revert Errors.ContractAlreadyInitialized();\n\n        if (\n            address(_asset) == address(0) ||\n            address(_registry) == address(0) ||\n            _treasury == address(0)\n        ) revert Errors.ZeroAddress();\n\n        initialized = true;\n        initPausable(msg.sender);\n        initERC4626(_asset, _name, _symbol);\n        registry = _registry;\n        reserveFactor = _reserveFactor;\n        treasury = _treasury;\n    }\n\n    /**\n        @notice Initializes external dependencies\n        @param _rateModel Name of rate model contract\n    */\n    function initDep(string calldata _rateModel) external adminOnly {\n        rateModel = IRateModel(registry.getAddress(_rateModel));\n        accountManager = registry.getAddress('ACCOUNT_MANAGER');\n    }\n\n    /**\n        @notice Lends a specified amount of underlying asset to an account\n        @param account Address of account\n        @param amt Amount of token to lend\n        @return isFirstBorrow Returns if the account is borrowing the asset for\n            the first time\n    */\n    function lendTo(address account, uint amt)\n        external\n        whenNotPaused\n        accountManagerOnly\n        returns (bool isFirstBorrow)\n    {\n        updateState();\n        isFirstBorrow = (borrowsOf[account] == 0);\n\n        uint borrowShares;\n        require((borrowShares = convertAssetToBorrowShares(amt)) != 0, \"ZERO_BORROW_SHARES\");\n        totalBorrowShares += borrowShares;\n        borrowsOf[account] += borrowShares;\n\n        borrows += amt;\n        asset.safeTransfer(account, amt);\n        return isFirstBorrow;\n    }\n\n    /**\n        @notice Collects a specified amount of underlying asset from an account\n        @param account Address of account\n        @param amt Amount of token to collect\n        @return bool Returns true if account has no debt\n    */\n    function collectFrom(address account, uint amt)\n        external\n        accountManagerOnly\n        returns (bool)\n    {\n        uint borrowShares;\n        require((borrowShares = convertAssetToBorrowShares(amt)) != 0, \"ZERO_BORROW_SHARES\");\n        borrowsOf[account] -= borrowShares;\n        totalBorrowShares -= borrowShares;\n\n        borrows -= amt;\n        return (borrowsOf[account] == 0);\n    }\n\n    /**\n        @notice Returns Borrow balance of given account\n        @param account Address of account\n        @return borrowBalance Amount of underlying tokens borrowed\n    */\n    function getBorrowBalance(address account) external view returns (uint) {\n        return convertBorrowSharesToAsset(borrowsOf[account]);\n    }\n\n    function getReserves() public view returns (uint) {\n        return reserves + borrows.mulWadUp(getRateFactor())\n        .mulWadUp(reserveFactor);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              PUBLIC FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Returns total amount of underlying assets\n            totalAssets = underlying balance + totalBorrows + delta\n            delta = totalBorrows * RateFactor\n        @return totalAssets Total amount of underlying assets\n    */\n    function totalAssets() public view override returns (uint) {\n        return asset.balanceOf(address(this)) + getBorrows() - getReserves();\n    }\n\n    function getBorrows() public view returns (uint) {\n        return borrows + borrows.mulWadUp(getRateFactor());\n    }\n\n    /// @notice Updates state of the lending pool\n    function updateState() public {\n        if (lastUpdated == block.timestamp) return;\n        uint rateFactor = getRateFactor();\n        uint interestAccrued = borrows.mulWadUp(rateFactor);\n        borrows += interestAccrued;\n        reserves += interestAccrued.mulWadUp(reserveFactor);\n        lastUpdated = block.timestamp;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @dev Rate Factor = Timestamp Delta * 1e18 (Scales timestamp delta to 18 decimals) * Interest Rate Per Block\n            Timestamp Delta = Number of seconds since last update\n    */\n    function getRateFactor() internal view returns (uint) {\n        return (block.timestamp == lastUpdated) ?\n            0 :\n            ((block.timestamp - lastUpdated)*1e18)\n            .mulWadUp(\n                rateModel.getBorrowRatePerSecond(\n                    asset.balanceOf(address(this)),\n                    borrows\n                )\n            );\n    }\n\n    function convertAssetToBorrowShares(uint amt) internal view returns (uint) {\n        uint256 supply = totalBorrowShares;\n        return supply == 0 ? amt : amt.mulDivUp(supply, getBorrows());\n    }\n\n    function convertBorrowSharesToAsset(uint debt) internal view returns (uint) {\n        uint256 supply = totalBorrowShares;\n        return supply == 0 ? debt : debt.mulDivDown(getBorrows(), supply);\n    }\n\n    function beforeDeposit(uint, uint) internal override { updateState(); }\n    function beforeWithdraw(uint, uint) internal override { updateState(); }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               ADMIN FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    function redeemReserves(uint amt) external adminOnly {\n        updateState();\n        reserves -= amt;\n        emit ReservesRedeemed(treasury, amt);\n        asset.safeTransfer(treasury, amt);\n    }\n}"
    }
  ]
}