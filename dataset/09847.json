{
  "Title": "[G-06] anchor\\_basset\\_reward :: execute\\_increase\\_balance/execute\\_decrease\\_balance",
  "Content": "\nFunction: execute\\_increase\\_balance/execute\\_decrease\\_balance\n\nContract:<br>\n<https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/anchor-bAsset-contracts/contracts/anchor_basset_reward/src/user.rs#L80>\n<https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/anchor-bAsset-contracts/contracts/anchor_basset_reward/src/user.rs#L125>\n\nRecommendation:<br>\nIn both the function add a check for `amount!=0`\n\n**[Alex the Entreprenerd (triage) commented](https://github.com/code-423n4/2022-02-anchor-findings/issues/12#issuecomment-1205887536):**\n > Probably most interesting report.\n\n\n\n***\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-02-anchor-contest",
  "Code": [
    {
      "filename": "contracts/anchor-bAsset-contracts/contracts/anchor_basset_reward/src/user.rs",
      "content": "use crate::querier::query_token_contract;\nuse crate::state::{\n    read_config, read_holder, read_holders, read_state, store_holder, store_state, Config, Holder,\n    State,\n};\nuse basset::reward::{AccruedRewardsResponse, HolderResponse, HoldersResponse};\n\nuse cosmwasm_std::{\n    attr, BankMsg, Coin, CosmosMsg, Decimal, Deps, DepsMut, Env, MessageInfo, Response, StdError,\n    StdResult, Uint128,\n};\n\nuse crate::math::{\n    decimal_multiplication_in_256, decimal_subtraction_in_256, decimal_summation_in_256,\n};\nuse basset::deduct_tax;\nuse std::str::FromStr;\nuse terra_cosmwasm::TerraMsgWrapper;\n\npub fn execute_claim_rewards(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    recipient: Option<String>,\n) -> StdResult<Response<TerraMsgWrapper>> {\n    let holder_addr = info.sender;\n    let holder_addr_raw = deps.api.addr_canonicalize(holder_addr.as_str())?;\n    let recipient = match recipient {\n        Some(value) => deps.api.addr_validate(value.as_str()).unwrap(),\n        None => holder_addr.clone(),\n    };\n\n    let mut holder: Holder = read_holder(deps.storage, &holder_addr_raw)?;\n    let mut state: State = read_state(deps.storage)?;\n    let config: Config = read_config(deps.storage)?;\n\n    let reward_with_decimals =\n        calculate_decimal_rewards(state.global_index, holder.index, holder.balance)?;\n\n    let all_reward_with_decimals =\n        decimal_summation_in_256(reward_with_decimals, holder.pending_rewards);\n    let decimals = get_decimals(all_reward_with_decimals)?;\n\n    let rewards = all_reward_with_decimals * Uint128::new(1);\n\n    if rewards.is_zero() {\n        return Err(StdError::generic_err(\"No rewards have accrued yet\"));\n    }\n\n    let new_balance = (state.prev_reward_balance.checked_sub(rewards))?;\n    state.prev_reward_balance = new_balance;\n    store_state(deps.storage, &state)?;\n\n    holder.pending_rewards = decimals;\n    holder.index = state.global_index;\n    store_holder(deps.storage, &holder_addr_raw, &holder)?;\n\n    let bank_msg: CosmosMsg<TerraMsgWrapper> = CosmosMsg::Bank(BankMsg::Send {\n        to_address: recipient.to_string(),\n        amount: vec![deduct_tax(\n            &deps.querier,\n            Coin {\n                denom: config.reward_denom,\n                amount: rewards,\n            },\n        )?],\n    });\n\n    let res = Response::new()\n        .add_attributes(vec![\n            attr(\"action\", \"claim_reward\"),\n            attr(\"holder_address\", holder_addr),\n            attr(\"rewards\", rewards),\n        ])\n        .add_message(bank_msg);\n\n    Ok(res)\n}\n\npub fn execute_increase_balance(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    address: String,\n    amount: Uint128,\n) -> StdResult<Response<TerraMsgWrapper>> {\n    let config = read_config(deps.storage)?;\n    let owner_human = deps.api.addr_humanize(&config.hub_contract)?;\n    let address_raw = deps.api.addr_canonicalize(&address)?;\n    let sender = info.sender;\n\n    let token_address = deps\n        .api\n        .addr_humanize(&query_token_contract(deps.as_ref(), owner_human)?)?;\n\n    // Check sender is token contract\n    if sender != token_address {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let mut state: State = read_state(deps.storage)?;\n    let mut holder: Holder = read_holder(deps.storage, &address_raw)?;\n\n    // get decimals\n    let rewards = calculate_decimal_rewards(state.global_index, holder.index, holder.balance)?;\n\n    holder.index = state.global_index;\n    holder.pending_rewards = decimal_summation_in_256(rewards, holder.pending_rewards);\n    holder.balance += amount;\n    state.total_balance += amount;\n\n    store_holder(deps.storage, &address_raw, &holder)?;\n    store_state(deps.storage, &state)?;\n\n    let attributes = vec![\n        attr(\"action\", \"increase_balance\"),\n        attr(\"holder_address\", address),\n        attr(\"amount\", amount),\n    ];\n\n    let res = Response::new().add_attributes(attributes);\n    Ok(res)\n}\n\npub fn execute_decrease_balance(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    address: String,\n    amount: Uint128,\n) -> StdResult<Response<TerraMsgWrapper>> {\n    let config = read_config(deps.storage)?;\n    let hub_contract = deps.api.addr_humanize(&config.hub_contract)?;\n    let address_raw = deps.api.addr_canonicalize(&address)?;\n\n    // Check sender is token contract\n    if query_token_contract(deps.as_ref(), hub_contract)?\n        != deps.api.addr_canonicalize(info.sender.as_str())?\n    {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let mut state: State = read_state(deps.storage)?;\n    let mut holder: Holder = read_holder(deps.storage, &address_raw)?;\n    if holder.balance < amount {\n        return Err(StdError::generic_err(format!(\n            \"Decrease amount cannot exceed user balance: {}\",\n            holder.balance\n        )));\n    }\n\n    let rewards = calculate_decimal_rewards(state.global_index, holder.index, holder.balance)?;\n\n    holder.index = state.global_index;\n    holder.pending_rewards = decimal_summation_in_256(rewards, holder.pending_rewards);\n    holder.balance = (holder.balance.checked_sub(amount))?;\n    state.total_balance = (state.total_balance.checked_sub(amount))?;\n\n    store_holder(deps.storage, &address_raw, &holder)?;\n    store_state(deps.storage, &state)?;\n\n    let attributes = vec![\n        attr(\"action\", \"decrease_balance\"),\n        attr(\"holder_address\", address),\n        attr(\"amount\", amount),\n    ];\n\n    let res = Response::new().add_attributes(attributes);\n\n    Ok(res)\n}\n\npub fn query_accrued_rewards(deps: Deps, address: String) -> StdResult<AccruedRewardsResponse> {\n    let global_index = read_state(deps.storage)?.global_index;\n\n    let holder: Holder = read_holder(deps.storage, &deps.api.addr_canonicalize(&address)?)?;\n    let reward_with_decimals =\n        calculate_decimal_rewards(global_index, holder.index, holder.balance)?;\n    let all_reward_with_decimals =\n        decimal_summation_in_256(reward_with_decimals, holder.pending_rewards);\n\n    let rewards = all_reward_with_decimals * Uint128::new(1);\n\n    Ok(AccruedRewardsResponse { rewards })\n}\n\npub fn query_holder(deps: Deps, address: String) -> StdResult<HolderResponse> {\n    let holder: Holder = read_holder(deps.storage, &deps.api.addr_canonicalize(&address)?)?;\n    Ok(HolderResponse {\n        address,\n        balance: holder.balance,\n        index: holder.index,\n        pending_rewards: holder.pending_rewards,\n    })\n}\n\npub fn query_holders(\n    deps: Deps,\n    start_after: Option<String>,\n    limit: Option<u32>,\n) -> StdResult<HoldersResponse> {\n    let start_after = if let Some(start_after) = start_after {\n        Some(deps.api.addr_validate(&start_after)?)\n    } else {\n        None\n    };\n\n    let holders: Vec<HolderResponse> = read_holders(deps, start_after, limit)?;\n\n    Ok(HoldersResponse { holders })\n}\n\n// calculate the reward based on the sender's index and the global index.\nfn calculate_decimal_rewards(\n    global_index: Decimal,\n    user_index: Decimal,\n    user_balance: Uint128,\n) -> StdResult<Decimal> {\n    let decimal_balance = Decimal::from_ratio(user_balance, Uint128::new(1));\n    Ok(decimal_multiplication_in_256(\n        decimal_subtraction_in_256(global_index, user_index),\n        decimal_balance,\n    ))\n}\n\n// calculate the reward with decimal\nfn get_decimals(value: Decimal) -> StdResult<Decimal> {\n    let stringed: &str = &*value.to_string();\n    let parts: &[&str] = &*stringed.split('.').collect::<Vec<&str>>();\n    match parts.len() {\n        1 => Ok(Decimal::zero()),\n        2 => {\n            let decimals = Decimal::from_str(&*(\"0.\".to_owned() + parts[1]))?;\n            Ok(decimals)\n        }\n        _ => Err(StdError::generic_err(\"Unexpected number of dots\")),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    pub fn proper_calculate_rewards() {\n        let global_index = Decimal::from_ratio(Uint128::new(9), Uint128::new(100));\n        let user_index = Decimal::zero();\n        let user_balance = Uint128::new(1000);\n        let reward = calculate_decimal_rewards(global_index, user_index, user_balance).unwrap();\n        assert_eq!(reward.to_string(), \"90\");\n    }\n\n    #[test]\n    pub fn proper_get_decimals() {\n        let global_index = Decimal::from_ratio(Uint128::new(9999999), Uint128::new(100000000));\n        let user_index = Decimal::zero();\n        let user_balance = Uint128::new(10);\n        let reward = get_decimals(\n            calculate_decimal_rewards(global_index, user_index, user_balance).unwrap(),\n        )\n        .unwrap();\n        assert_eq!(reward.to_string(), \"0.9999999\");\n    }\n}"
    },
    {
      "filename": "contracts/anchor-bAsset-contracts/contracts/anchor_basset_reward/src/user.rs",
      "content": "use crate::querier::query_token_contract;\nuse crate::state::{\n    read_config, read_holder, read_holders, read_state, store_holder, store_state, Config, Holder,\n    State,\n};\nuse basset::reward::{AccruedRewardsResponse, HolderResponse, HoldersResponse};\n\nuse cosmwasm_std::{\n    attr, BankMsg, Coin, CosmosMsg, Decimal, Deps, DepsMut, Env, MessageInfo, Response, StdError,\n    StdResult, Uint128,\n};\n\nuse crate::math::{\n    decimal_multiplication_in_256, decimal_subtraction_in_256, decimal_summation_in_256,\n};\nuse basset::deduct_tax;\nuse std::str::FromStr;\nuse terra_cosmwasm::TerraMsgWrapper;\n\npub fn execute_claim_rewards(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    recipient: Option<String>,\n) -> StdResult<Response<TerraMsgWrapper>> {\n    let holder_addr = info.sender;\n    let holder_addr_raw = deps.api.addr_canonicalize(holder_addr.as_str())?;\n    let recipient = match recipient {\n        Some(value) => deps.api.addr_validate(value.as_str()).unwrap(),\n        None => holder_addr.clone(),\n    };\n\n    let mut holder: Holder = read_holder(deps.storage, &holder_addr_raw)?;\n    let mut state: State = read_state(deps.storage)?;\n    let config: Config = read_config(deps.storage)?;\n\n    let reward_with_decimals =\n        calculate_decimal_rewards(state.global_index, holder.index, holder.balance)?;\n\n    let all_reward_with_decimals =\n        decimal_summation_in_256(reward_with_decimals, holder.pending_rewards);\n    let decimals = get_decimals(all_reward_with_decimals)?;\n\n    let rewards = all_reward_with_decimals * Uint128::new(1);\n\n    if rewards.is_zero() {\n        return Err(StdError::generic_err(\"No rewards have accrued yet\"));\n    }\n\n    let new_balance = (state.prev_reward_balance.checked_sub(rewards))?;\n    state.prev_reward_balance = new_balance;\n    store_state(deps.storage, &state)?;\n\n    holder.pending_rewards = decimals;\n    holder.index = state.global_index;\n    store_holder(deps.storage, &holder_addr_raw, &holder)?;\n\n    let bank_msg: CosmosMsg<TerraMsgWrapper> = CosmosMsg::Bank(BankMsg::Send {\n        to_address: recipient.to_string(),\n        amount: vec![deduct_tax(\n            &deps.querier,\n            Coin {\n                denom: config.reward_denom,\n                amount: rewards,\n            },\n        )?],\n    });\n\n    let res = Response::new()\n        .add_attributes(vec![\n            attr(\"action\", \"claim_reward\"),\n            attr(\"holder_address\", holder_addr),\n            attr(\"rewards\", rewards),\n        ])\n        .add_message(bank_msg);\n\n    Ok(res)\n}\n\npub fn execute_increase_balance(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    address: String,\n    amount: Uint128,\n) -> StdResult<Response<TerraMsgWrapper>> {\n    let config = read_config(deps.storage)?;\n    let owner_human = deps.api.addr_humanize(&config.hub_contract)?;\n    let address_raw = deps.api.addr_canonicalize(&address)?;\n    let sender = info.sender;\n\n    let token_address = deps\n        .api\n        .addr_humanize(&query_token_contract(deps.as_ref(), owner_human)?)?;\n\n    // Check sender is token contract\n    if sender != token_address {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let mut state: State = read_state(deps.storage)?;\n    let mut holder: Holder = read_holder(deps.storage, &address_raw)?;\n\n    // get decimals\n    let rewards = calculate_decimal_rewards(state.global_index, holder.index, holder.balance)?;\n\n    holder.index = state.global_index;\n    holder.pending_rewards = decimal_summation_in_256(rewards, holder.pending_rewards);\n    holder.balance += amount;\n    state.total_balance += amount;\n\n    store_holder(deps.storage, &address_raw, &holder)?;\n    store_state(deps.storage, &state)?;\n\n    let attributes = vec![\n        attr(\"action\", \"increase_balance\"),\n        attr(\"holder_address\", address),\n        attr(\"amount\", amount),\n    ];\n\n    let res = Response::new().add_attributes(attributes);\n    Ok(res)\n}\n\npub fn execute_decrease_balance(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    address: String,\n    amount: Uint128,\n) -> StdResult<Response<TerraMsgWrapper>> {\n    let config = read_config(deps.storage)?;\n    let hub_contract = deps.api.addr_humanize(&config.hub_contract)?;\n    let address_raw = deps.api.addr_canonicalize(&address)?;\n\n    // Check sender is token contract\n    if query_token_contract(deps.as_ref(), hub_contract)?\n        != deps.api.addr_canonicalize(info.sender.as_str())?\n    {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let mut state: State = read_state(deps.storage)?;\n    let mut holder: Holder = read_holder(deps.storage, &address_raw)?;\n    if holder.balance < amount {\n        return Err(StdError::generic_err(format!(\n            \"Decrease amount cannot exceed user balance: {}\",\n            holder.balance\n        )));\n    }\n\n    let rewards = calculate_decimal_rewards(state.global_index, holder.index, holder.balance)?;\n\n    holder.index = state.global_index;\n    holder.pending_rewards = decimal_summation_in_256(rewards, holder.pending_rewards);\n    holder.balance = (holder.balance.checked_sub(amount))?;\n    state.total_balance = (state.total_balance.checked_sub(amount))?;\n\n    store_holder(deps.storage, &address_raw, &holder)?;\n    store_state(deps.storage, &state)?;\n\n    let attributes = vec![\n        attr(\"action\", \"decrease_balance\"),\n        attr(\"holder_address\", address),\n        attr(\"amount\", amount),\n    ];\n\n    let res = Response::new().add_attributes(attributes);\n\n    Ok(res)\n}\n\npub fn query_accrued_rewards(deps: Deps, address: String) -> StdResult<AccruedRewardsResponse> {\n    let global_index = read_state(deps.storage)?.global_index;\n\n    let holder: Holder = read_holder(deps.storage, &deps.api.addr_canonicalize(&address)?)?;\n    let reward_with_decimals =\n        calculate_decimal_rewards(global_index, holder.index, holder.balance)?;\n    let all_reward_with_decimals =\n        decimal_summation_in_256(reward_with_decimals, holder.pending_rewards);\n\n    let rewards = all_reward_with_decimals * Uint128::new(1);\n\n    Ok(AccruedRewardsResponse { rewards })\n}\n\npub fn query_holder(deps: Deps, address: String) -> StdResult<HolderResponse> {\n    let holder: Holder = read_holder(deps.storage, &deps.api.addr_canonicalize(&address)?)?;\n    Ok(HolderResponse {\n        address,\n        balance: holder.balance,\n        index: holder.index,\n        pending_rewards: holder.pending_rewards,\n    })\n}\n\npub fn query_holders(\n    deps: Deps,\n    start_after: Option<String>,\n    limit: Option<u32>,\n) -> StdResult<HoldersResponse> {\n    let start_after = if let Some(start_after) = start_after {\n        Some(deps.api.addr_validate(&start_after)?)\n    } else {\n        None\n    };\n\n    let holders: Vec<HolderResponse> = read_holders(deps, start_after, limit)?;\n\n    Ok(HoldersResponse { holders })\n}\n\n// calculate the reward based on the sender's index and the global index.\nfn calculate_decimal_rewards(\n    global_index: Decimal,\n    user_index: Decimal,\n    user_balance: Uint128,\n) -> StdResult<Decimal> {\n    let decimal_balance = Decimal::from_ratio(user_balance, Uint128::new(1));\n    Ok(decimal_multiplication_in_256(\n        decimal_subtraction_in_256(global_index, user_index),\n        decimal_balance,\n    ))\n}\n\n// calculate the reward with decimal\nfn get_decimals(value: Decimal) -> StdResult<Decimal> {\n    let stringed: &str = &*value.to_string();\n    let parts: &[&str] = &*stringed.split('.').collect::<Vec<&str>>();\n    match parts.len() {\n        1 => Ok(Decimal::zero()),\n        2 => {\n            let decimals = Decimal::from_str(&*(\"0.\".to_owned() + parts[1]))?;\n            Ok(decimals)\n        }\n        _ => Err(StdError::generic_err(\"Unexpected number of dots\")),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    pub fn proper_calculate_rewards() {\n        let global_index = Decimal::from_ratio(Uint128::new(9), Uint128::new(100));\n        let user_index = Decimal::zero();\n        let user_balance = Uint128::new(1000);\n        let reward = calculate_decimal_rewards(global_index, user_index, user_balance).unwrap();\n        assert_eq!(reward.to_string(), \"90\");\n    }\n\n    #[test]\n    pub fn proper_get_decimals() {\n        let global_index = Decimal::from_ratio(Uint128::new(9999999), Uint128::new(100000000));\n        let user_index = Decimal::zero();\n        let user_balance = Uint128::new(10);\n        let reward = get_decimals(\n            calculate_decimal_rewards(global_index, user_index, user_balance).unwrap(),\n        )\n        .unwrap();\n        assert_eq!(reward.to_string(), \"0.9999999\");\n    }\n}"
    }
  ]
}