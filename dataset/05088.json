{
  "Title": "[H-03] Incorrect bad debt accounting can lead to a state where the `claimFeesBeneficial` function is permanently bricked and no new incentives can be distributed, potentially locking pending and future protocol fees in the `FeeManager` contract",
  "Content": "\nProtocol fees can be collected from the `WiseLending` contract and sent to the `FeeManager` contract via the permissionless `FeeManager::claimWiseFees` function. During this call, incentives will only be distributed for `incentive owners` if `totalBadDebtETH` (global bad debt) is equal to `0`:\n\n[`FeeManager::claimWiseFees`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L663-L670)\n\n```solidity\n663:        if (totalBadDebtETH == 0) { // @audit: incentives only distributed if there is no global bad debt\n664:\n665:            tokenAmount = _distributeIncentives( // @audit: distributes incentives for `incentive owners` via `gatheredIncentiveToken` mapping\n666:                tokenAmount,\n667:                _poolToken,\n668:                underlyingTokenAddress\n669:            );\n670:        }\n```\n\nThe fees sent to the `FeeManager` are then able to be claimed by `beneficials` via the `FeeManager::claimFeesBeneficial` function or by `incentive owners` via the `FeeManager::claimIncentives` function (if incentives have been distributed to the owners):\n\n[`FeeManager::claimIncentives`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L284-L293)\n\n```solidity\n284:    function claimIncentives(\n285:        address _feeToken\n286:    )\n287:        public\n288:    {\n289:        uint256 amount = gatheredIncentiveToken[msg.sender][_feeToken]; // @audit: mapping incremented in _distributeIncentives function\n290:\n291:        if (amount == 0) {\n292:            revert NoIncentive();\n293:        }\n```\n\nHowever, `beneficials` are only able to claim fees if there is currently no global bad debt in the system (`totalBadDebtETH == 0`).\n\n[`FeeManager::claimFeesBeneficial`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L689-L699)\n\n```solidity\n689:    function claimFeesBeneficial(\n690:        address _feeToken,\n691:        uint256 _amount\n692:    )\n693:        external\n694:    {\n695:        address caller = msg.sender;\n696:\n697:        if (totalBadDebtETH > 0) { // @audit: can't claim fees when there is bad debt\n698:            revert ExistingBadDebt();\n699:        }\n```\n\nBelow I will explain how the bad debt accounting logic used during partial liquidations can result in a state where `totalBadDebtETH` is permanently greater than `0`. When this occurs, `beneficials` will no longer be able to claim fees via the `FeeManager::claimFeesBeneficial` function and new incentives will no longer be distributed when fees are permissionlessly collected via the `FeeManager::claimWiseFees` function.\n\nWhen a position is partially liquidated, the `WiseSecurity::checkBadDebtLiquidation` function is executed to check if the position has created bad debt, i.e. if the position's overall borrow value is greater than the overall (unweighted) collateral value. If the post liquidation state of the position created bad debt, then the bad debt is recorded in a global and position-specific state:\n\n[`WiseSecurity::checkBadDebtLiquidation`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol#L405-L436)\n\n```solidity\n405:    function checkBadDebtLiquidation(\n406:        uint256 _nftId\n407:    )\n408:        external\n409:        onlyWiseLending\n410:    {\n411:        uint256 bareCollateral = overallETHCollateralsBare(\n412:            _nftId\n413:        );\n414:\n415:        uint256 totalBorrow = overallETHBorrowBare(\n416:            _nftId\n417:        );\n418:\n419:        if (totalBorrow < bareCollateral) { // @audit: LTV < 100%\n420:            return;\n421:        }\n422:\n423:        unchecked {\n424:            uint256 diff = totalBorrow\n425:                - bareCollateral;\n426:\n427:            FEE_MANAGER.increaseTotalBadDebtLiquidation( // @audit: global state, totalBadDebtETH += diff\n428:                diff\n429:            );\n430:\n431:            FEE_MANAGER.setBadDebtUserLiquidation( // @audit: position state, badDebtPosition[_nftId] = diff\n432:                _nftId,\n433:                diff\n434:            );\n435:        }\n436:    }\n```\n\n[`FeeManagerHeper.sol`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManagerHelper.sol#L77-L94)\n\n```solidity\n77:    function _setBadDebtPosition(\n78:        uint256 _nftId,\n79:        uint256 _amount\n80:    )\n81:        internal\n82:    {\n83:        badDebtPosition[_nftId] = _amount; // @audit: position bad debt set\n84:    }\n85:\n86:    /**\n87:     * @dev Internal increase function for global bad debt amount.\n88:     */\n89:    function _increaseTotalBadDebt(\n90:        uint256 _amount\n91:    )\n92:        internal\n93:    {\n94:        totalBadDebtETH += _amount; // @audit: total bad debt incremented\n```\n\nAs we can see above, the method by which the global and position's state is updated is not consistent (total debt increases, but position's debt is set to recent debt). Since liquidations can be partial, a position with bad debt can undergo multiple partial liquidations and each time the `totalBadDebtETH` will be incremented. However, the `badDebtPosition` for the position will only be updated with the most recent bad debt that was recorded during the last partial liquidation. Note that due to the condition on line 419 of `WiseSecurity::checkBadDebtLiquidation`, the `badDebtPosition` will be reset to `0` when `totalBorrow == bareCollateral` (`LTV == 100%`). However, in this case, any previously recorded bad debt for the position will *not* be deducted from the `totalBadDebtETH`. Lets consider two examples:\n\n**Scenario 1**: Due to a market crash, a position's LTV goes above 100%. The position gets partially liquidated, incrementing `totalBadDebtETH` by `x` (bad debt from 1st liquidation) and setting `badDebtPosition[_nftId]` to `x`. The position gets partially liquidated again, this time incrementing `totalBadDebtETH` by `y` (bad debt from 2nd liquidation) and setting `badDebtPosition[_nftId]` to `y`. The resulting state:\n\n```\ntotalBadDebtETH == x + y\nbadDebtPosition[_nftId] == y\n```\n\n**Scenario 2**: Due to a market crash, a position's LTV goes above 100%. The position gets partially liquidated, incrementing `totalBadDebtETH` by `x` and setting `badDebtPosition[_nftId]` to `x`. The position gets partially liquidated again, but this time the `totalBorrow` is equal to `bareCollateral` (`LTV == 100%`) and thus no bad debt is created. Due to the condition on line 419, `totalBadDebtETH` will be incremented by `0`, but `badDebtPosition[_nftId]` will be reset to `0`. The resulting state:\n\n```\ntotalBadDebtETH == x\nbadDebtPosition[_nftId] == 0\n```\n\nNote: Scenario 1 is more likely to occur since Scenario 2 requires the additional partial liquidation to result in an LTV of exactly 100% for the position.\n\nAs we can see, partial liquidations can lead to `totalBadDebtETH` being artificially inflated with respect to the actual bad debt created by a position.\n\nWhen bad debt is created, it is able to be paid back via the [`FeeManager::paybackBadDebtForToken`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L730-L744) or [`FeeManager::paybackBadDebtNoReward`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L816-L826) functions. However, the maximum amount of bad debt that can be deducted during these calls is capped at the bad debt recorded for the position specified (`badDebtPosition[_nftId]`). Therefore, the excess \"fake\" bad debt can not be deducted from `totalBadDebtETH`, resulting in `totalBadDebtETH` being permanently greater than `0`.\n\nBelow is the logic that deducts the bad debt created by a position when it is paid off via one of the payback functions mentioned above:\n\n[`FeeManagerHelper::_updateUserBadDebt`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManagerHelper.sol#L170-L181)\n\n```solidity\n170:        unchecked {\n171:            uint256 newBadDebt = currentBorrowETH\n172:                - currentCollateralBareETH;\n173:\n174:            _setBadDebtPosition( // @audit: badDebtPosition[_nftId] = newBadDebt\n175:                _nftId,\n176:                newBadDebt\n177:            );\n178:\n179:            newBadDebt > currentBadDebt // @audit: totalBadDebtETH updated with respect to change in badDebtPosition\n180:                ? _increaseTotalBadDebt(newBadDebt - currentBadDebt)\n181:                : _decreaseTotalBadDebt(currentBadDebt - newBadDebt);\n```\n\nThe above code is invoked in the [`FeeManagerHelper::updatePositionCurrentBadDebt`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManagerHelper.sol#L270-L285) function, which is in turn invoked during both of the payback functions previously mentioned. You will notice that the above code properly takes into account the change in the bad debt of the position in question. I.e. if the `badDebtPosition[_nftId]` decreased (after being paid back), then the `totalBadDebtETH` will decrease as well. Therefore, the `totalBadDebtETH` can only be deducted by at most the current bad debt of a position. Returning to the previous example in Scenario 1, this means that `totalBadDebtETH` would remain equal to `x`, since only `y` amount of bad debt can be paid back.\n\n### Impact\n\nIn the event a position creates bad debt, partial liquidations of that position can lead to the global `totalBadDebtETH` state variable being artificially inflated. This additional \"fake debt\" can not be deducted from the global state when the actual bad debt of the position is paid back. Thus, the `FeeManager::claimFeesBeneficial` function will be permanently DOS-ed, preventing any `beneficials` from claiming fees in the `FeeManager` contract. Additionally, no new incentives are able to be distributed to `incentive owners` in this state. However, protocol fees can still be collected in this state via the permissionless `FeeManager::claimWiseFees` function, and since `incentive owners` and `beneficials` are the only entities able to claim these fees, this can lead to fees being permanently locked in the `FeeManager` contract.\n\n### Justification for Medium Severity\n\nAlthough not directly affecting end users, the function of claiming beneficial fees and distributing new incentives will be permanently bricked. To make matters worse, anyone can continue to collect fees via the permissionless `FeeManager::claimWiseFees` function, which will essentially \"burn\" any pending or future fees by locking them in the `FeeManager` (assuming all previously gathered incentives have been claimed). This value is, therefore, leaked from the protocol every time additional fees are collected in this state.\n\nOnce this state is reached, any pending or future fees should ideally be left in the `WiseLending` contract, providing value back to the users instead of allowing that value to be unnecessarily \"burned\". However, the permissionless nature of the `FeeManager::claimWiseFees` function allows bad actors to further grief the protocol during this state by continuing to collect fees.\n\nNote: Once this state is reached, and `WiseLending` is made aware of the implications, all fees (for all pools) can be set to `0` by the `master` address. This would ensure that no future fees are sent to the `FeeManager`. However, this does not stop pending fees from being collected. Additionally, a true decentralized system (such as a DAO) would likely have some latency between proposing such a change (decreasing fee value) and executing that change. Therefore, any fees distributed during that period can be collected.\n\n### Proof of Concept\n\nPlace the following test in the `contracts/` directory and run with `forge test --match-path contracts/BadDebtTest.t.sol`:\n\n<details>\n\n```solidity\n// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./WiseLendingBaseDeployment.t.sol\";\n\ncontract BadDebtTest is BaseDeploymentTest {\n    address borrower = address(0x01010101);\n    address lender = address(0x02020202);\n\n    uint256 depositAmountETH = 10e18; // 10 ether\n    uint256 depositAmountToken = 10; // 10 ether\n    uint256 borrowAmount = 5e18; // 5 ether\n\n    uint256 nftIdLiquidator; // nftId of lender\n    uint256 nftIdLiquidatee; // nftId of borrower\n\n    uint256 debtShares;\n\n    function _setupIndividualTest() internal override {\n        _deployNewWiseLending(false);\n\n        // set token value for simple calculations\n        MOCK_CHAINLINK_2.setValue(1 ether); // 1 token == 1 ETH\n        assertEq(MOCK_CHAINLINK_2.latestAnswer(), MOCK_CHAINLINK_ETH_ETH.latestAnswer());\n        vm.stopPrank();\n        \n        // fund lender and borrower\n        vm.deal(lender, depositAmountETH);\n        deal(address(MOCK_WETH), lender, depositAmountETH);\n        deal(address(MOCK_ERC20_2), borrower, depositAmountToken * 2);\n    }\n\n\n    function testScenario1() public {\n        // --- scenario is set up --- //\n        _setUpScenario();\n\n        // --- shortfall event/crash creates bad debt, position partially liquidated logging bad debt --- //\n        _marketCrashCreatesBadDebt();\n\n        // --- borrower gets partially liquidated again --- //\n        vm.prank(lender);\n\n        LENDING_INSTANCE.liquidatePartiallyFromTokens(\n            nftIdLiquidatee,\n            nftIdLiquidator, \n            address(MOCK_WETH),\n            address(MOCK_ERC20_2),\n            debtShares * 2e16 / 1e18\n        );\n\n        // --- global bad det increases again, but user bad debt is set to current bad debt created --- // \n        uint256 newTotalBadDebt = FEE_MANAGER_INSTANCE.totalBadDebtETH();\n        uint256 newUserBadDebt = FEE_MANAGER_INSTANCE.badDebtPosition(nftIdLiquidatee);\n        \n        assertGt(newUserBadDebt, 0); // userBadDebt reset to new bad debt, newUserBadDebt == current_bad_debt_created\n        assertGt(newTotalBadDebt, newUserBadDebt); // global bad debt incremented again\n        // newTotalBadDebt = old_global_bad_debt + current_bad_debt_created\n        \n        // --- user bad debt is paid off, but global bad is only partially paid off (remainder is fake debt) --- // \n        _tryToPayBackGlobalDebt();\n\n        // --- protocol fees can no longer be claimed since totalBadDebtETH will remain > 0 --- // \n        vm.expectRevert(bytes4(keccak256(\"ExistingBadDebt()\")));\n        FEE_MANAGER_INSTANCE.claimFeesBeneficial(address(0), 0);\n    }\n\n    function testScenario2() public {\n        // --- scenario is set up --- // \n        _setUpScenario();\n\n        // --- shortfall event/crash creates bad debt, position partially liquidated logging bad debt --- //\n        _marketCrashCreatesBadDebt();\n        \n        // --- Position manipulated so second partial liquidation results in totalBorrow == bareCollateral --- //\n        // borrower adds collateral\n        vm.prank(borrower);\n\n        LENDING_INSTANCE.solelyDeposit(\n            nftIdLiquidatee, \n            address(MOCK_ERC20_2), \n            6\n        );\n\n        // borrower gets partially liquidated again\n        vm.prank(lender);\n\n        LENDING_INSTANCE.liquidatePartiallyFromTokens(\n            nftIdLiquidatee,\n            nftIdLiquidator, \n            address(MOCK_WETH),\n            address(MOCK_ERC20_2),\n            debtShares * 2e16 / 1e18\n        );\n        \n        uint256 collateral = SECURITY_INSTANCE.overallETHCollateralsBare(nftIdLiquidatee);\n        uint256 debt = SECURITY_INSTANCE.overallETHBorrowBare(nftIdLiquidatee);\n        assertEq(collateral, debt); // LTV == 100% exactly\n\n        // --- global bad debt is unchanged, while user bad debt is reset to 0 --- // \n        uint256 newTotalBadDebt = FEE_MANAGER_INSTANCE.totalBadDebtETH();\n        uint256 newUserBadDebt = FEE_MANAGER_INSTANCE.badDebtPosition(nftIdLiquidatee);\n\n        assertEq(newUserBadDebt, 0); // user bad debt reset to 0\n        assertGt(newTotalBadDebt, 0); // global bad debt stays the same (fake debt)\n\n        // --- attempts to pay back fake global debt result in a noop, totalBadDebtETH still > 0 --- // \n        uint256 paybackShares = _tryToPayBackGlobalDebt();\n        \n        assertEq(LENDING_INSTANCE.userBorrowShares(nftIdLiquidatee, address(MOCK_WETH)), paybackShares); // no shares were paid back\n\n        // --- protocol fees can no longer be claimed since totalBadDebtETH will remain > 0 --- //\n        vm.expectRevert(bytes4(keccak256(\"ExistingBadDebt()\")));\n        FEE_MANAGER_INSTANCE.claimFeesBeneficial(address(0), 0);\n    }\n\n    function _setUpScenario() internal {\n        // lender supplies ETH\n        vm.startPrank(lender);\n\n        nftIdLiquidator = POSITION_NFTS_INSTANCE.mintPosition();\n\n        LENDING_INSTANCE.depositExactAmountETH{value: depositAmountETH}(nftIdLiquidator);\n\n        vm.stopPrank();\n\n        // borrower supplies collateral token and borrows ETH\n        vm.startPrank(borrower);\n\n        MOCK_ERC20_2.approve(address(LENDING_INSTANCE), depositAmountToken * 2);\n\n        nftIdLiquidatee = POSITION_NFTS_INSTANCE.mintPosition();\n        \n        LENDING_INSTANCE.solelyDeposit( // supply collateral\n            nftIdLiquidatee, \n            address(MOCK_ERC20_2), \n            depositAmountToken\n        );\n\n        debtShares = LENDING_INSTANCE.borrowExactAmountETH(nftIdLiquidatee, borrowAmount); // borrow ETH\n\n        vm.stopPrank();\n    }\n\n    function _marketCrashCreatesBadDebt() internal {\n        // shortfall event/crash occurs\n        vm.prank(MOCK_DEPLOYER);\n\n        MOCK_CHAINLINK_2.setValue(0.3 ether);\n\n        // borrower gets partially liquidated\n        vm.startPrank(lender);\n\n        MOCK_WETH.approve(address(LENDING_INSTANCE), depositAmountETH);\n\n        LENDING_INSTANCE.liquidatePartiallyFromTokens(\n            nftIdLiquidatee,\n            nftIdLiquidator, \n            address(MOCK_WETH),\n            address(MOCK_ERC20_2),\n            debtShares * 2e16 / 1e18 + 1 \n        );\n\n        vm.stopPrank();\n\n        // global and user bad debt is increased\n        uint256 totalBadDebt = FEE_MANAGER_INSTANCE.totalBadDebtETH();\n        uint256 userBadDebt = FEE_MANAGER_INSTANCE.badDebtPosition(nftIdLiquidatee);\n\n        assertGt(totalBadDebt, 0); \n        assertGt(userBadDebt, 0);\n        assertEq(totalBadDebt, userBadDebt); // user bad debt and global bad debt are the same\n    }\n\n    function _tryToPayBackGlobalDebt() internal returns (uint256 paybackShares) {\n        // lender attempts to pay back global debt\n        paybackShares = LENDING_INSTANCE.userBorrowShares(nftIdLiquidatee, address(MOCK_WETH));\n        uint256 paybackAmount = LENDING_INSTANCE.paybackAmount(address(MOCK_WETH), paybackShares);\n\n        vm.startPrank(lender);\n\n        MOCK_WETH.approve(address(FEE_MANAGER_INSTANCE), paybackAmount);\n        \n        FEE_MANAGER_INSTANCE.paybackBadDebtNoReward(\n            nftIdLiquidatee, \n            address(MOCK_WETH), \n            paybackShares\n        );\n\n        vm.stopPrank();\n\n        // global bad debt and user bad debt updated\n        uint256 finalTotalBadDebt = FEE_MANAGER_INSTANCE.totalBadDebtETH();\n        uint256 finalUserBadDebt = FEE_MANAGER_INSTANCE.badDebtPosition(nftIdLiquidatee);\n\n        assertEq(finalUserBadDebt, 0); // user has no more bad debt, all paid off\n        assertGt(finalTotalBadDebt, 0); // protocol still thinks there is bad debt\n    }\n}\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nI would recommend updating `totalBadDebtETH` with the `difference` of the previous and new bad debt of a position in the `WiseSecurity::checkBadDebtLiquidation` function, similar to how it is done in the `FeeManagerHelper::_updateUserBadDebt` internal function.\n\nExample implementation:\n\n```diff\ndiff --git a/./WiseSecurity/WiseSecurity.sol b/./WiseSecurity/WiseSecurity.sol\nindex d2cfb24..75a34e8 100644\n--- a/./WiseSecurity/WiseSecurity.sol\n+++ b/./WiseSecurity/WiseSecurity.sol\n@@ -424,14 +424,22 @@ contract WiseSecurity is WiseSecurityHelper, ApprovalHelper {\n             uint256 diff = totalBorrow\n                 - bareCollateral;\n\n-            FEE_MANAGER.increaseTotalBadDebtLiquidation(\n-                diff\n-            );\n+            uint256 currentBadDebt = FEE_MANAGER.badDebtPosition(_nftId);\n\n             FEE_MANAGER.setBadDebtUserLiquidation(\n                 _nftId,\n                 diff\n             );\n+\n+            if (diff > currentBadDebt) {\n+                FEE_MANAGER.increaseTotalBadDebtLiquidation(\n+                    diff - currentBadDebt\n+                );\n+            } else {\n+                FEE_MANAGER.decreaseTotalBadDebtLiquidation(\n+                    currentBadDebt - diff\n+                );\n+            }\n         }\n     }\n```\n\n**[Trust (judge) increased severity to High](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/74#issuecomment-2021274755)**\n\n**[vonMangoldt (Wise Lending) commented via duplicate issue #243](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/243#issuecomment-2009558588):**\n> This doesn't lead to loss of user funds though. Hence, it should be downgraded since one could just migrate and redeploy after discovering that. Otherwise good find.\n\n**[Foon256 (Wise Lending) commented via duplicate issue #243](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/243#issuecomment-2009622123):**\n> Would agree with that! This is a good insight, but users' funds are never at risk. This is related to the `feeManager` and the fees taken from the protocol. Therefore, a Medium issue.\n\n**[Alex the Entreprenerd (Appellate Court judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/74#issuecomment-2056796083):**\n > ### Summary of the issue\n >\n> When a market accrues bad debt, which can be inflated due to an accounting error, fees and incentives will no longer be distributed.\n> *Note: The discussion had quite a bit of back and forth, for this reason the whole conversation is pasted below:*\n> \n> ### Discussion\n>\n> **Alex the Entreprenerd (Appellate Court lead judge) commented:**\n> This seems to be tied to a specific interpretation of this discussion we've had around loss of yield as high.\n> \n> **hickuphh3 (judge 2) commented:**\n> Fees would be considered as matured yield? Given that it extends beyond the protocol to beneficials and incentive owners, I'm leaning towards a high more than a medium.\n> \n> **Alex the Entreprenerd (Appellate Court lead judge) commented:**\n> Yes it would be considered matured. I don't have an opinion on this report yet and will follow up later today with my notes.\n>\n>Not fully made up my mind but here's a couple of points:\n> \n> For Medium: Loss of Yield -> There is no loss of principal so Med seems fine.\n> \n> For High: The contract is not losing yield in some case, the contract is losing 100% of all yield. The contract is no longer serving it's purpose.\n> \n> External Conditions: Bad debt must be formed. Bad debt handling is part of the system design, so assuming this can happen is fair, and starting from a scenario in which this can happen is also fair.\n> \n> That said, in reality, this may never happen.\n> \n> My main point for downgrading is that while the contract is losing all of the yield, nothing beside that is impacted, not fully sure on this one.\n> \n> **LSDan (judge 3) commented:**\n> I'm aligned with high on this one. Even though the conditions that lead to it are rare and there are arguably external conditions in some scenarios, there is a direct loss of funds and the functional loss of a contract's purpose. Once this situation occurs, there is no clean way back from it.\n> \n> **Alex the Entreprenerd (Appellate Court lead judge) commented:**\n> I think this is the issue where we will have some contention. I think the Sponsor interpretation is important to keep in mind as it's pretty rational. I would like to think about it a bit more.\n> \n>**Alex the Entreprenerd (Appellate Court lead judge) commented:**\n> I'm leaning towards Med on this report, I think the Sponsors POV is valid.\n> \n> There is an accounting error, it would not cause permanent loss of funds. It would be mitigated by deprecating the market and creating a new one.\n> \n> My main argument is that if this was live, this would trigger a re-deploy but it would not trigger any white hat rescue operation, as funds would be safe.\n> \n> **hickuphh3 (judge 2) commented**:\n> [#74](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/74): When we stick to the c4a rules to which we agreed, all the loss of fees are no user funds and therefore, should be treated differently.\n> \n> The core argument for Medium severity is that fees are a secondary concern.\n> \n> This goes against the supreme court decision where fees shouldn't be treated as 2nd class citizens [here](https://docs.code4rena.com/awarding/judging-criteria/severity-categorization#loss-of-fees-as-low).\n> \n> Loss of fees should be regarded as an impact similar to any other loss of capital. Loss of real amounts depends on specific conditions and likelihood considerations.\n> \n> Likelihood: Requirement of bad debt formation. Once there is, funds (fees) are permanently bricked. \n> \n> There is an accounting error, it would not cause permanent loss of funds; it would be mitigated by deprecating the market and creating a new one.\n> \n> The funds you are referring to are user funds? Separately, I don't see how it would mitigate the bricking once it happens.\n> \n> **Alex the Entreprenerd (Appellate Court lead judge) commented:**\n> I don't think that the ruling means that loss of fees should be treated as high at all times.\n> \n> The main argument is that the broken accounting doesn't create a state that is not recoverable:\n> - Some fees are lost.\n> - User deprecates market (raises interests or pauses).\n> - Deployes new Market.\n> - System resumes functioning as intended.\n> \n> My main argument is that this would not cause a War Room, it would cause a deprecation that the system can handle.\n> \n> **hickuphh3 (judge 2) commented:**\n> In what cases/scenarios would loss of fees be high then? Most, if not all, won't have a war room for protocol fees.\n> \n> The reason I would consider to justify downgrading is the low likelihood of the external requirement of bad debt formation `+` `>=` 2 partial liquidations.\n> \n> I would dissent and argue for high severity. \n> - Permanent loss of unclaimed fees.\n> - Blast radius: affects not just the protocol, but incentive owners and beneficiaries.\n>\n>Had the fees gone only to the protocol, I'd lean a bit more towards Medium.\n> \n> Is `WiseLending` immutable in a `poolToken` instance? \n> \n> What contracts would have to be re-deployed?\n> \n> **Alex the Entreprenerd (Appellate Court lead judge) commented:**\n> Liquidation premium being denied could be a valid High loss of yield, loss of gas for refunds when the system entire goal is that (e.g. keepers, voting on Nouns).\n> \n> ### Alex the Entreprenerd's (Appellate Court lead judge) Input\n>\n> The finding shows how in the specific case of liquidations with bad debt, a market will stop accounting for fees.\n> \n> 2 aggravating circumstances seem to be:\n> - Inability to pause and replace each market.\n> - The Math for bad debt is also wrong, leading to the inability to fix the bug.\n> \n> This would still cause a loss of fees for a certain period of time, as the admin would eventually be able to set the market fees to either a state that would cause users to stop using it or `0` as a means to stop the loss.\n> \n> I think that the accounting mistake is notable, and I understand the reasoning for raising severity.\n> \n> That said, because we have to judge by impact of the finding, I believe Medium Severity to be most appropriate.\n> \n> ### hickuphh3's (judge 2) Input\n>\n> I maintain my stance for High severity for the reasons I stated above:\n> - Permanent loss of unclaimed fees.\n> - Impact on protocol ecosystem: beneficiaries and incentive owners.\n> \n> ### LSDan’s (judge 3) Input\n>\n> I'm still of the opinion that High is most appropriate here. The impact is significant enough that raising the severity beyond medium makes sense.\n> \n> ### Deliberation\n>\n> The severity is kept at High Severity, with a non-unanimous verdict.\n> \n> ### Additional Context by the Lead Judge\n> \n> I recommend monitoring how this decision influences future decisions on severities, especially when it comes to a percentage loss of yield, an attacker having the button to cause a loss of yield, against this instance which is the permanent inability for the contract to record a gain of yield. \n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/74#issuecomment-2082898865):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/FeeManager/FeeManager.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\n/**\n * @author Christoph Krpoun\n * @author René Hochmuth\n * @author Vitally Marinchenko\n */\n\nimport \"./FeeManagerHelper.sol\";\n\n/**\n * @dev Purpose of this contract is to organize fee distribution from wiseLending.\n * The feeManager aquires fee token in form of shares from each pool and can call them\n * with \"claimWiseFees()\" for each pool.\n *\n * Furthermore, this contracts has two different incentive\n * structures which can be used to bootstrap the WISE ecosystem (beneficial and incnetiveOwner roles).\n *\n * Additionally, this contract keeps track of the bad debt of each postion and has a simple mechanism\n * to pay them back via incentives. The incentive amount is funded by the gathered fees.\n */\n\ncontract FeeManager is FeeManagerHelper {\n\n    constructor(\n        address _master,\n        address _aaveAddress,\n        address _wiseLendingAddress,\n        address _oracleHubAddress,\n        address _wiseSecurityAddress,\n        address _positionNFTAddress\n    )\n        DeclarationsFeeManager(\n            _master,\n            _aaveAddress,\n            _wiseLendingAddress,\n            _oracleHubAddress,\n            _wiseSecurityAddress,\n            _positionNFTAddress\n        )\n    {}\n\n    /**\n     * @dev Allows to adjust the paid out incentive\n     * percentage for user to reduce bad debt.\n     */\n    function setRepayBadDebtIncentive(\n        uint256 _percent\n    )\n        external\n        onlyMaster\n    {\n        _checkValue(\n            _percent\n        );\n\n        paybackIncentive = _percent;\n    }\n\n    /**\n     * @dev Maps underlying token with corresponding aToken.\n     * Sets bool to identify pool token as aToken.\n     */\n    function setAaveFlag(\n        address _poolToken,\n        address _underlyingToken\n    )\n        external\n        onlyMaster\n    {\n        _setAaveFlag(\n            _poolToken,\n            _underlyingToken\n        );\n    }\n\n    /**\n     * @dev Bulk function for setting aave flag for multiple pools.\n     */\n    function setAaveFlagBulk(\n        address[] calldata _poolTokens,\n        address[] calldata _underlyingTokens\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 l = _poolTokens.length;\n\n        while (i < l) {\n            _setAaveFlag(\n                _poolTokens[i],\n                _underlyingTokens[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Function to adjust pool fee. Fee can not be greater than 100%\n     * or lower than 1%. Can be adjusted for each pool individually.\n     */\n    function setPoolFee(\n        address _poolToken,\n        uint256 _newFee\n    )\n        external\n        onlyMaster\n    {\n        _checkValue(\n            _newFee\n        );\n\n        WISE_LENDING.setPoolFee(\n            _poolToken,\n            _newFee\n        );\n\n        emit PoolFeeChanged(\n            _poolToken,\n            _newFee,\n            block.timestamp\n        );\n    }\n\n    /**\n    * @dev Function to adjust pool fees in bulk. Fee for each pool can not be\n    * greater than 100% or lower than 1%. Can be adjusted for each pool individually.\n    */\n    function setPoolFeeBulk(\n        address[] calldata _poolTokens,\n        uint256[] calldata _newFees\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 l = _poolTokens.length;\n\n        while (i < l) {\n\n            _checkValue(\n                _newFees[i]\n            );\n\n            WISE_LENDING.setPoolFee(\n                _poolTokens[i],\n                _newFees[i]\n            );\n\n            emit PoolFeeChanged(\n                _poolTokens[i],\n                _newFees[i],\n                block.timestamp\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Function to propose new incentive master. This role can increase\n     * the incentive amount for both incentive mappings. These are two roles\n     * for incentivising external persons e.g. developers.\n     */\n    function proposeIncentiveMaster(\n        address _proposedIncentiveMaster\n    )\n        external\n        onlyIncentiveMaster\n    {\n        if (_proposedIncentiveMaster == ZERO_ADDRESS) {\n            revert ZeroAddress();\n        }\n\n        proposedIncentiveMaster = _proposedIncentiveMaster;\n\n        emit IncentiveMasterProposed(\n            _proposedIncentiveMaster,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Claim proposed incentive master by proposed entity.\n     */\n    function claimOwnershipIncentiveMaster()\n        external\n    {\n        if (msg.sender != proposedIncentiveMaster) {\n            revert NotAllowed();\n        }\n\n        incentiveMaster = proposedIncentiveMaster;\n        proposedIncentiveMaster = ZERO_ADDRESS;\n\n        emit ClaimedOwnershipIncentiveMaster(\n            incentiveMaster,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Increase function for increasing incentive amount for entity A.\n     * Only callable by incentive master.\n     */\n    function increaseIncentiveA(\n        uint256 _value\n    )\n        external\n        onlyIncentiveMaster\n    {\n        incentiveUSD[incentiveOwnerA] += _value;\n\n        emit IncentiveIncreasedA(\n            _value,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Increase function for increasing incentive amount for entity B.\n     * Only callable by incentive master.\n     */\n    function increaseIncentiveB(\n        uint256 _value\n    )\n        external\n        onlyIncentiveMaster\n    {\n        incentiveUSD[incentiveOwnerB] += _value;\n\n        emit IncentiveIncreasedB(\n            _value,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function to claim all gathered incetives.\n     */\n    function claimIncentivesBulk()\n        external\n    {\n        address tokenAddress;\n\n        uint256 i;\n        uint256 l = getPoolTokenAddressesLength();\n\n        while (i < l) {\n\n            tokenAddress = poolTokenAddresses[i];\n\n            if (isAaveToken[tokenAddress] == true) {\n                tokenAddress = underlyingToken[\n                    tokenAddress\n                ];\n            }\n\n            claimIncentives(\n                tokenAddress\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ClaimedIncentivesBulk(\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Claims gathered incentives for a specific token.\n     */\n    function claimIncentives(\n        address _feeToken\n    )\n        public\n    {\n        uint256 amount = gatheredIncentiveToken[msg.sender][_feeToken];\n\n        if (amount == 0) {\n            revert NoIncentive();\n        }\n\n        delete gatheredIncentiveToken[msg.sender][_feeToken];\n\n        emit ClaimedIncentives(\n            msg.sender,\n            _feeToken,\n            amount,\n            block.timestamp\n        );\n\n        _safeTransfer(\n            _feeToken,\n            msg.sender,\n            amount\n        );\n    }\n\n    /**\n     * @dev Function changing incentiveOwnerA! Only callable by\n     * incentiveOwnerA.\n     */\n    function changeIncentiveUSDA(\n        address _newOwner\n    )\n        external\n    {\n        if (msg.sender != incentiveOwnerA) {\n            revert NotAllowed();\n        }\n\n        if (_newOwner == incentiveOwnerA) {\n            revert NotAllowed();\n        }\n\n        if (_newOwner == incentiveOwnerB) {\n            revert NotAllowed();\n        }\n\n        incentiveUSD[_newOwner] = incentiveUSD[\n            incentiveOwnerA\n        ];\n\n        delete incentiveUSD[\n            incentiveOwnerA\n        ];\n\n        incentiveOwnerA = _newOwner;\n\n        emit IncentiveOwnerAChanged(\n            _newOwner,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function changing incentiveOwnerB! Only callable by\n     * incentiveOwnerB.\n     */\n    function changeIncentiveUSDB(\n        address _newOwner\n    )\n        external\n    {\n        if (msg.sender != incentiveOwnerB) {\n            revert NotAllowed();\n        }\n\n        if (_newOwner == incentiveOwnerA) {\n            revert NotAllowed();\n        }\n\n        if (_newOwner == incentiveOwnerB) {\n            revert NotAllowed();\n        }\n\n        incentiveUSD[_newOwner] = incentiveUSD[\n            incentiveOwnerB\n        ];\n\n        delete incentiveUSD[\n            incentiveOwnerB\n        ];\n\n        incentiveOwnerB = _newOwner;\n\n        emit IncentiveOwnerBChanged(\n            _newOwner,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function adding new pool token to pool token list.\n     * Called during pool creation and only callable by wiseLending\n     * contract.\n     */\n    function addPoolTokenAddress(\n        address _poolToken\n    )\n        external\n        onlyWiseLending\n    {\n        poolTokenAddresses.push(\n            _poolToken\n        );\n\n        poolTokenAdded[_poolToken] = true;\n\n        emit PoolTokenAdded(\n            _poolToken,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function to add pool token manualy. Only\n     * callable by feeManager master.\n     */\n    function addPoolTokenAddressManual(\n        address _poolToken\n    )\n        external\n        onlyMaster\n    {\n        if (poolTokenAdded[_poolToken] == true) {\n            revert PoolAlreadyAdded();\n        }\n\n        poolTokenAddresses.push(\n            _poolToken\n        );\n\n        poolTokenAdded[_poolToken] = true;\n\n        emit PoolTokenAdded(\n            _poolToken,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function to remove pool token manualy from pool\n     * token list. Only callable by feeManager master.\n     */\n    function removePoolTokenManual(\n        address _poolToken\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 len = getPoolTokenAddressesLength();\n        uint256 lastEntry = len - 1;\n        bool found;\n\n        if (poolTokenAdded[_poolToken] == false) {\n            revert PoolNotPresent();\n        }\n\n        while (i < len) {\n\n            if (_poolToken != poolTokenAddresses[i]) {\n\n                unchecked {\n                    ++i;\n                }\n\n                continue;\n            }\n\n            found = true;\n\n            if (i != lastEntry) {\n                poolTokenAddresses[i] = poolTokenAddresses[lastEntry];\n            }\n\n            break;\n        }\n\n        if (found == true) {\n\n            poolTokenAddresses.pop();\n            poolTokenAdded[_poolToken] = false;\n\n            emit PoolTokenRemoved(\n                _poolToken,\n                block.timestamp\n            );\n\n            return;\n        }\n\n        revert PoolNotPresent();\n    }\n\n    /**\n     * @dev Increase function for total bad debt of\n     * wiseLending. Only callable by wiseSecurity contract\n     * during liquidation.\n     */\n    function increaseTotalBadDebtLiquidation(\n        uint256 _amount\n    )\n        external\n        onlyWiseSecurity\n    {\n        _increaseTotalBadDebt(\n            _amount\n        );\n\n        emit BadDebtIncreasedLiquidation(\n            _amount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Increase function for bad debt of a position.\n     * Only callable by wiseSecurity contract during liquidation.\n     */\n    function setBadDebtUserLiquidation(\n        uint256 _nftId,\n        uint256 _amount\n    )\n        external\n        onlyWiseSecurity\n    {\n        _setBadDebtPosition(\n            _nftId,\n            _amount\n        );\n\n        emit SetBadDebtPosition(\n            _nftId,\n            _amount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Set function to declare an address as beneficial for\n     * a fee token. Address can claim gathered fee token as long as\n     * it is declared as beneficial. Only setable by master.\n     */\n    function setBeneficial(\n        address _user,\n        address[] calldata _feeTokens\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 l = _feeTokens.length;\n\n        while (i < l) {\n            _setAllowedTokens(\n                _user,\n                _feeTokens[i],\n                true\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit SetBeneficial(\n            _user,\n            _feeTokens,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Set function to remove an address as beneficial for\n     * a fee token. Only setable by master.\n     */\n    function revokeBeneficial(\n        address _user,\n        address[] memory _feeTokens\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 l = _feeTokens.length;\n\n        while (i < l) {\n            _setAllowedTokens(\n                _user,\n                _feeTokens[i],\n                false\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit RevokeBeneficial(\n            _user,\n            _feeTokens,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Claim all fees from wiseLending and send them to feeManager.\n     */\n    function claimWiseFeesBulk()\n        external\n    {\n        uint256 i;\n        uint256 l = getPoolTokenAddressesLength();\n\n        while (i < l) {\n            claimWiseFees(\n                poolTokenAddresses[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ClaimedFeesWiseBulk(\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Claim fees from wiseLending and send them to feeManager for\n     * a specific pool.\n     */\n    function claimWiseFees(\n        address _poolToken\n    )\n        public\n    {\n        address underlyingTokenAddress = _poolToken;\n\n        uint256 shares = WISE_LENDING.getPositionLendingShares(\n            FEE_MANAGER_NFT,\n            _poolToken\n        );\n\n        if (shares == 0) {\n            return;\n        }\n\n        uint256 tokenAmount = WISE_LENDING.withdrawExactShares(\n            FEE_MANAGER_NFT,\n            _poolToken,\n            shares\n        );\n\n        if (isAaveToken[_poolToken] == true) {\n\n            underlyingTokenAddress = underlyingToken[\n                _poolToken\n            ];\n\n            tokenAmount = AAVE.withdraw(\n                underlyingTokenAddress,\n                tokenAmount,\n                address(this)\n            );\n        }\n\n        if (totalBadDebtETH == 0) {\n\n            tokenAmount = _distributeIncentives(\n                tokenAmount,\n                _poolToken,\n                underlyingTokenAddress\n            );\n        }\n\n        _increaseFeeTokens(\n            underlyingTokenAddress,\n            tokenAmount\n        );\n\n        emit ClaimedFeesWise(\n            underlyingTokenAddress,\n            tokenAmount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function for beneficial to claim gathered fees. Can only\n     * claim fees for which the beneficial is allowed. Can only claim\n     * token which are inside the feeManager.\n     */\n    function claimFeesBeneficial(\n        address _feeToken,\n        uint256 _amount\n    )\n        external\n    {\n        address caller = msg.sender;\n\n        if (totalBadDebtETH > 0) {\n            revert ExistingBadDebt();\n        }\n\n        if (allowedTokens[caller][_feeToken] == false) {\n            revert NotAllowed();\n        }\n\n        _decreaseFeeTokens(\n            _feeToken,\n            _amount\n        );\n\n        _safeTransfer(\n            _feeToken,\n            caller,\n            _amount\n        );\n\n        emit ClaimedFeesBeneficial(\n            caller,\n            _feeToken,\n            _amount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function for paying back bad debt of a position. Caller\n     * chooses postion, token and receive token. Only gathered fee token\n     * can be distributed as receive token. Caller gets 5% more\n     * in ETH value as incentive.\n     */\n    function paybackBadDebtForToken(\n        uint256 _nftId,\n        address _paybackToken,\n        address _receivingToken,\n        uint256 _shares\n    )\n        external\n        returns (\n            uint256 paybackAmount,\n            uint256 receivingAmount\n        )\n    {\n        updatePositionCurrentBadDebt(\n            _nftId\n        );\n\n        if (badDebtPosition[_nftId] == 0) {\n            return (\n                0,\n                0\n            );\n        }\n\n        if (WISE_LENDING.getTotalDepositShares(_receivingToken) == 0) {\n            revert PoolNotActive();\n        }\n\n        if (WISE_LENDING.getTotalDepositShares(_paybackToken) == 0) {\n            revert PoolNotActive();\n        }\n\n        paybackAmount = WISE_LENDING.paybackAmount(\n            _paybackToken,\n            _shares\n        );\n\n        WISE_LENDING.corePaybackFeeManager(\n            _paybackToken,\n            _nftId,\n            paybackAmount,\n            _shares\n        );\n\n        _updateUserBadDebt(\n            _nftId\n        );\n\n        receivingAmount = getReceivingToken(\n            _paybackToken,\n            _receivingToken,\n            paybackAmount\n        );\n\n        _decreaseFeeTokens(\n            _receivingToken,\n            receivingAmount\n        );\n\n        _safeTransferFrom(\n            _paybackToken,\n            msg.sender,\n            address(WISE_LENDING),\n            paybackAmount\n        );\n\n        _safeTransfer(\n            _receivingToken,\n            msg.sender,\n            receivingAmount\n        );\n\n        emit PayedBackBadDebt(\n            _nftId,\n            msg.sender,\n            _paybackToken,\n            _receivingToken,\n            paybackAmount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function for paying back bad debt of a position. Caller\n     * chooses postion, token and receive token. Caller gets no\n     * receive token!\n     */\n    function paybackBadDebtNoReward(\n        uint256 _nftId,\n        address _paybackToken,\n        uint256 _shares\n    )\n        external\n        returns (uint256 paybackAmount)\n    {\n        updatePositionCurrentBadDebt(\n            _nftId\n        );\n\n        if (badDebtPosition[_nftId] == 0) {\n            return 0;\n        }\n\n        if (WISE_LENDING.getTotalDepositShares(_paybackToken) == 0) {\n            revert PoolNotActive();\n        }\n\n        paybackAmount = WISE_LENDING.paybackAmount(\n            _paybackToken,\n            _shares\n        );\n\n        WISE_LENDING.corePaybackFeeManager(\n            _paybackToken,\n            _nftId,\n            paybackAmount,\n            _shares\n        );\n\n        _updateUserBadDebt(\n            _nftId\n        );\n\n        emit PayedBackBadDebtFree(\n            _nftId,\n            msg.sender,\n            _paybackToken,\n            paybackAmount,\n            block.timestamp\n        );\n\n        _safeTransferFrom(\n            _paybackToken,\n            msg.sender,\n            address(WISE_LENDING),\n            paybackAmount\n        );\n    }\n\n    /**\n     * @dev Returning the number of pool token\n     * addresses saved inside the feeManager.\n     */\n    function getPoolTokenAddressesLength()\n        public\n        view\n        returns (uint256)\n    {\n        return poolTokenAddresses.length;\n    }\n\n    /**\n     * @dev Returns the pool token address\n     * at the _index postion of the array.\n     */\n    function getPoolTokenAdressesByIndex(\n        uint256 _index\n    )\n        external\n        view\n        returns (address)\n    {\n        return poolTokenAddresses[_index];\n    }\n\n    /**\n     * @dev Bulk function for updating pools - loops through\n     * all pools saved inside the poolTokenAddresses array.\n     */\n    function syncAllPools()\n        external\n    {\n        uint256 i;\n        uint256 l = poolTokenAddresses.length;\n\n        while (i < l) {\n            WISE_LENDING.syncManually(\n                poolTokenAddresses[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/FeeManager/FeeManager.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\n/**\n * @author Christoph Krpoun\n * @author René Hochmuth\n * @author Vitally Marinchenko\n */\n\nimport \"./FeeManagerHelper.sol\";\n\n/**\n * @dev Purpose of this contract is to organize fee distribution from wiseLending.\n * The feeManager aquires fee token in form of shares from each pool and can call them\n * with \"claimWiseFees()\" for each pool.\n *\n * Furthermore, this contracts has two different incentive\n * structures which can be used to bootstrap the WISE ecosystem (beneficial and incnetiveOwner roles).\n *\n * Additionally, this contract keeps track of the bad debt of each postion and has a simple mechanism\n * to pay them back via incentives. The incentive amount is funded by the gathered fees.\n */\n\ncontract FeeManager is FeeManagerHelper {\n\n    constructor(\n        address _master,\n        address _aaveAddress,\n        address _wiseLendingAddress,\n        address _oracleHubAddress,\n        address _wiseSecurityAddress,\n        address _positionNFTAddress\n    )\n        DeclarationsFeeManager(\n            _master,\n            _aaveAddress,\n            _wiseLendingAddress,\n            _oracleHubAddress,\n            _wiseSecurityAddress,\n            _positionNFTAddress\n        )\n    {}\n\n    /**\n     * @dev Allows to adjust the paid out incentive\n     * percentage for user to reduce bad debt.\n     */\n    function setRepayBadDebtIncentive(\n        uint256 _percent\n    )\n        external\n        onlyMaster\n    {\n        _checkValue(\n            _percent\n        );\n\n        paybackIncentive = _percent;\n    }\n\n    /**\n     * @dev Maps underlying token with corresponding aToken.\n     * Sets bool to identify pool token as aToken.\n     */\n    function setAaveFlag(\n        address _poolToken,\n        address _underlyingToken\n    )\n        external\n        onlyMaster\n    {\n        _setAaveFlag(\n            _poolToken,\n            _underlyingToken\n        );\n    }\n\n    /**\n     * @dev Bulk function for setting aave flag for multiple pools.\n     */\n    function setAaveFlagBulk(\n        address[] calldata _poolTokens,\n        address[] calldata _underlyingTokens\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 l = _poolTokens.length;\n\n        while (i < l) {\n            _setAaveFlag(\n                _poolTokens[i],\n                _underlyingTokens[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Function to adjust pool fee. Fee can not be greater than 100%\n     * or lower than 1%. Can be adjusted for each pool individually.\n     */\n    function setPoolFee(\n        address _poolToken,\n        uint256 _newFee\n    )\n        external\n        onlyMaster\n    {\n        _checkValue(\n            _newFee\n        );\n\n        WISE_LENDING.setPoolFee(\n            _poolToken,\n            _newFee\n        );\n\n        emit PoolFeeChanged(\n            _poolToken,\n            _newFee,\n            block.timestamp\n        );\n    }\n\n    /**\n    * @dev Function to adjust pool fees in bulk. Fee for each pool can not be\n    * greater than 100% or lower than 1%. Can be adjusted for each pool individually.\n    */\n    function setPoolFeeBulk(\n        address[] calldata _poolTokens,\n        uint256[] calldata _newFees\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 l = _poolTokens.length;\n\n        while (i < l) {\n\n            _checkValue(\n                _newFees[i]\n            );\n\n            WISE_LENDING.setPoolFee(\n                _poolTokens[i],\n                _newFees[i]\n            );\n\n            emit PoolFeeChanged(\n                _poolTokens[i],\n                _newFees[i],\n                block.timestamp\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Function to propose new incentive master. This role can increase\n     * the incentive amount for both incentive mappings. These are two roles\n     * for incentivising external persons e.g. developers.\n     */\n    function proposeIncentiveMaster(\n        address _proposedIncentiveMaster\n    )\n        external\n        onlyIncentiveMaster\n    {\n        if (_proposedIncentiveMaster == ZERO_ADDRESS) {\n            revert ZeroAddress();\n        }\n\n        proposedIncentiveMaster = _proposedIncentiveMaster;\n\n        emit IncentiveMasterProposed(\n            _proposedIncentiveMaster,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Claim proposed incentive master by proposed entity.\n     */\n    function claimOwnershipIncentiveMaster()\n        external\n    {\n        if (msg.sender != proposedIncentiveMaster) {\n            revert NotAllowed();\n        }\n\n        incentiveMaster = proposedIncentiveMaster;\n        proposedIncentiveMaster = ZERO_ADDRESS;\n\n        emit ClaimedOwnershipIncentiveMaster(\n            incentiveMaster,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Increase function for increasing incentive amount for entity A.\n     * Only callable by incentive master.\n     */\n    function increaseIncentiveA(\n        uint256 _value\n    )\n        external\n        onlyIncentiveMaster\n    {\n        incentiveUSD[incentiveOwnerA] += _value;\n\n        emit IncentiveIncreasedA(\n            _value,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Increase function for increasing incentive amount for entity B.\n     * Only callable by incentive master.\n     */\n    function increaseIncentiveB(\n        uint256 _value\n    )\n        external\n        onlyIncentiveMaster\n    {\n        incentiveUSD[incentiveOwnerB] += _value;\n\n        emit IncentiveIncreasedB(\n            _value,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function to claim all gathered incetives.\n     */\n    function claimIncentivesBulk()\n        external\n    {\n        address tokenAddress;\n\n        uint256 i;\n        uint256 l = getPoolTokenAddressesLength();\n\n        while (i < l) {\n\n            tokenAddress = poolTokenAddresses[i];\n\n            if (isAaveToken[tokenAddress] == true) {\n                tokenAddress = underlyingToken[\n                    tokenAddress\n                ];\n            }\n\n            claimIncentives(\n                tokenAddress\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ClaimedIncentivesBulk(\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Claims gathered incentives for a specific token.\n     */\n    function claimIncentives(\n        address _feeToken\n    )\n        public\n    {\n        uint256 amount = gatheredIncentiveToken[msg.sender][_feeToken];\n\n        if (amount == 0) {\n            revert NoIncentive();\n        }\n\n        delete gatheredIncentiveToken[msg.sender][_feeToken];\n\n        emit ClaimedIncentives(\n            msg.sender,\n            _feeToken,\n            amount,\n            block.timestamp\n        );\n\n        _safeTransfer(\n            _feeToken,\n            msg.sender,\n            amount\n        );\n    }\n\n    /**\n     * @dev Function changing incentiveOwnerA! Only callable by\n     * incentiveOwnerA.\n     */\n    function changeIncentiveUSDA(\n        address _newOwner\n    )\n        external\n    {\n        if (msg.sender != incentiveOwnerA) {\n            revert NotAllowed();\n        }\n\n        if (_newOwner == incentiveOwnerA) {\n            revert NotAllowed();\n        }\n\n        if (_newOwner == incentiveOwnerB) {\n            revert NotAllowed();\n        }\n\n        incentiveUSD[_newOwner] = incentiveUSD[\n            incentiveOwnerA\n        ];\n\n        delete incentiveUSD[\n            incentiveOwnerA\n        ];\n\n        incentiveOwnerA = _newOwner;\n\n        emit IncentiveOwnerAChanged(\n            _newOwner,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function changing incentiveOwnerB! Only callable by\n     * incentiveOwnerB.\n     */\n    function changeIncentiveUSDB(\n        address _newOwner\n    )\n        external\n    {\n        if (msg.sender != incentiveOwnerB) {\n            revert NotAllowed();\n        }\n\n        if (_newOwner == incentiveOwnerA) {\n            revert NotAllowed();\n        }\n\n        if (_newOwner == incentiveOwnerB) {\n            revert NotAllowed();\n        }\n\n        incentiveUSD[_newOwner] = incentiveUSD[\n            incentiveOwnerB\n        ];\n\n        delete incentiveUSD[\n            incentiveOwnerB\n        ];\n\n        incentiveOwnerB = _newOwner;\n\n        emit IncentiveOwnerBChanged(\n            _newOwner,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function adding new pool token to pool token list.\n     * Called during pool creation and only callable by wiseLending\n     * contract.\n     */\n    function addPoolTokenAddress(\n        address _poolToken\n    )\n        external\n        onlyWiseLending\n    {\n        poolTokenAddresses.push(\n            _poolToken\n        );\n\n        poolTokenAdded[_poolToken] = true;\n\n        emit PoolTokenAdded(\n            _poolToken,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function to add pool token manualy. Only\n     * callable by feeManager master.\n     */\n    function addPoolTokenAddressManual(\n        address _poolToken\n    )\n        external\n        onlyMaster\n    {\n        if (poolTokenAdded[_poolToken] == true) {\n            revert PoolAlreadyAdded();\n        }\n\n        poolTokenAddresses.push(\n            _poolToken\n        );\n\n        poolTokenAdded[_poolToken] = true;\n\n        emit PoolTokenAdded(\n            _poolToken,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function to remove pool token manualy from pool\n     * token list. Only callable by feeManager master.\n     */\n    function removePoolTokenManual(\n        address _poolToken\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 len = getPoolTokenAddressesLength();\n        uint256 lastEntry = len - 1;\n        bool found;\n\n        if (poolTokenAdded[_poolToken] == false) {\n            revert PoolNotPresent();\n        }\n\n        while (i < len) {\n\n            if (_poolToken != poolTokenAddresses[i]) {\n\n                unchecked {\n                    ++i;\n                }\n\n                continue;\n            }\n\n            found = true;\n\n            if (i != lastEntry) {\n                poolTokenAddresses[i] = poolTokenAddresses[lastEntry];\n            }\n\n            break;\n        }\n\n        if (found == true) {\n\n            poolTokenAddresses.pop();\n            poolTokenAdded[_poolToken] = false;\n\n            emit PoolTokenRemoved(\n                _poolToken,\n                block.timestamp\n            );\n\n            return;\n        }\n\n        revert PoolNotPresent();\n    }\n\n    /**\n     * @dev Increase function for total bad debt of\n     * wiseLending. Only callable by wiseSecurity contract\n     * during liquidation.\n     */\n    function increaseTotalBadDebtLiquidation(\n        uint256 _amount\n    )\n        external\n        onlyWiseSecurity\n    {\n        _increaseTotalBadDebt(\n            _amount\n        );\n\n        emit BadDebtIncreasedLiquidation(\n            _amount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Increase function for bad debt of a position.\n     * Only callable by wiseSecurity contract during liquidation.\n     */\n    function setBadDebtUserLiquidation(\n        uint256 _nftId,\n        uint256 _amount\n    )\n        external\n        onlyWiseSecurity\n    {\n        _setBadDebtPosition(\n            _nftId,\n            _amount\n        );\n\n        emit SetBadDebtPosition(\n            _nftId,\n            _amount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Set function to declare an address as beneficial for\n     * a fee token. Address can claim gathered fee token as long as\n     * it is declared as beneficial. Only setable by master.\n     */\n    function setBeneficial(\n        address _user,\n        address[] calldata _feeTokens\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 l = _feeTokens.length;\n\n        while (i < l) {\n            _setAllowedTokens(\n                _user,\n                _feeTokens[i],\n                true\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit SetBeneficial(\n            _user,\n            _feeTokens,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Set function to remove an address as beneficial for\n     * a fee token. Only setable by master.\n     */\n    function revokeBeneficial(\n        address _user,\n        address[] memory _feeTokens\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;"
    }
  ]
}