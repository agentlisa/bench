{
  "Title": "[M-01] Almost all rarity rank combinations cannot be, and are not uniformly, generated",
  "Content": "\nOnly a tiny fraction, 0.0002427\\%, of all rarity rank combinations are possible.\nThe probability distribution of the possible combinations (assuming the DNA is uniformly random) is not uniform: 24\\% of combinations are twice as likely as the rest.\n\n### Proof of Concept\n\n`AiArenaHelper.createPhysicalAttributes()` may set six `finalAttributeProbabilityIndexes` using [the following calculation](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/AiArenaHelper.sol#L107-L109).\n\n```solidity\nuint256 rarityRank = (dna / attributeToDnaDivisor[attributes[i]]) % 100;\nuint256 attributeIndex = dnaToIndex(generation, rarityRank, attributes[i]);\nfinalAttributeProbabilityIndexes[i] = attributeIndex;\n```\n\n`attributeToDnaDivisor` [is by default `[2, 3, 5, 7, 11, 13]`](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/AiArenaHelper.sol#L20). Each `rarityRank` by itself is in the range `0..99`, and ostensibly the total number of combinations of the six `rarityRank`s should then be 100\\^6. However, only 2,427,000 different combinations are possible, which is only 0.0002427\\% of all combinations that should be possible.\n\nAs a function of `dna` the vector of the six `rarityRank`s repeats every 3,003,000 integers (=2 &bull; 3 &bull; 5 &bull; 7 &bull; 11 &bull; 13 &bull; 100). But it turns out that 576,000 of these appear twice. For example, a `dna` of `0` or `1` yield the same combination of `rarityRank`s (`[0,0,0,0,0,0]`), as do `16` and `17` (`[8,5,3,2,1,1]`), and `22` and `23` (`[11,7,4,3,2,1]`), etc.\nThat is, about 24\\% of the combinations are twice as likely as the rest.\n\nThe `rarityRank`s are input to `dnaToIndex()` which then will also be biased and restricted in output (depending on the attribute probabilities).\n\n### Recommended Mitigation Steps\n\nExtract multiple small random numbers by repeatedly taking the modulo and dividing. I.e.\n\n```diff\n- uint256 rarityRank = (dna / attributeToDnaDivisor[attributes[i]]) % 100;\n+ uint256 rarityRank = dna % 100;\n+ dna /= 100;\n```\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/1979#issuecomment-1999028030):**\n > Agree that `rarityRank` determination isn't uniformly random.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-ai-arena",
  "Code": [
    {
      "filename": "src/AiArenaHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\n// pragma solidity ^0.8.20;\npragma solidity >=0.8.0 <0.9.0;\n\nimport { FighterOps } from \"./FighterOps.sol\";\n\n/// @title AI Arena Helper\n/// @author ArenaX Labs Inc.\n/// @notice This contract generates and manages an AI Arena fighters physical attributes.\ncontract AiArenaHelper {\n\n    /*//////////////////////////////////////////////////////////////\n                            STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice List of attributes\n    string[] public attributes = [\"head\", \"eyes\", \"mouth\", \"body\", \"hands\", \"feet\"];\n\n    /// @notice Default DNA divisors for attributes\n    uint8[] public defaultAttributeDivisor = [2, 3, 5, 7, 11, 13];\n\n    /// The address that has owner privileges (initially the contract deployer).\n    address _ownerAddress;\n\n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/    \n    \n    /// @notice Mapping tracking fighter generation to attribute probabilities\n    mapping(uint256 => mapping(string => uint8[])) public attributeProbabilities;\n\n    /// @notice Mapping of attribute to DNA divisors\n    mapping(string => uint8) public attributeToDnaDivisor;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Constructor to initialize the contract with the attribute probabilities for gen 0.\n    /// @param probabilities An array of attribute probabilities for the generation.\n    constructor(uint8[][] memory probabilities) {\n        _ownerAddress = msg.sender;\n\n        // Initialize the probabilities for each attribute\n        addAttributeProbabilities(0, probabilities);\n\n        uint256 attributesLength = attributes.length;\n        for (uint8 i = 0; i < attributesLength; i++) {\n            attributeProbabilities[0][attributes[i]] = probabilities[i];\n            attributeToDnaDivisor[attributes[i]] = defaultAttributeDivisor[i];\n        }\n    } \n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Transfers ownership from one address to another.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param newOwnerAddress The address of the new owner\n    function transferOwnership(address newOwnerAddress) external {\n        require(msg.sender == _ownerAddress);\n        _ownerAddress = newOwnerAddress;\n    }\n\n    /// @notice Add attribute divisors for attributes.\n    /// @param attributeDivisors An array of attribute divisors.\n    function addAttributeDivisor(uint8[] memory attributeDivisors) external {\n        require(msg.sender == _ownerAddress);\n        require(attributeDivisors.length == attributes.length);\n\n        uint256 attributesLength = attributes.length;\n        for (uint8 i = 0; i < attributesLength; i++) {\n            attributeToDnaDivisor[attributes[i]] = attributeDivisors[i];\n        }\n    }    \n\n    /// @notice Create physical attributes for a fighter based on DNA.\n    /// @param dna The DNA of the fighter.\n    /// @param iconsType Type of icons fighter (0 means it's not an icon).\n    /// @param dendroidBool Whether the fighter is a dendroid or not\n    /// @return Fighter physical attributes.\n    function createPhysicalAttributes(\n        uint256 dna, \n        uint8 generation, \n        uint8 iconsType, \n        bool dendroidBool\n    ) \n        external \n        view \n        returns (FighterOps.FighterPhysicalAttributes memory) \n    {\n        if (dendroidBool) {\n            return FighterOps.FighterPhysicalAttributes(99, 99, 99, 99, 99, 99);\n        } else {\n            uint256[] memory finalAttributeProbabilityIndexes = new uint[](attributes.length);\n\n            uint256 attributesLength = attributes.length;\n            for (uint8 i = 0; i < attributesLength; i++) {\n                if (\n                  i == 0 && iconsType == 2 || // Custom icons head (beta helmet)\n                  i == 1 && iconsType > 0 || // Custom icons eyes (red diamond)\n                  i == 4 && iconsType == 3 // Custom icons hands (bowling ball)\n                ) {\n                    finalAttributeProbabilityIndexes[i] = 50;\n                } else {\n                    uint256 rarityRank = (dna / attributeToDnaDivisor[attributes[i]]) % 100;\n                    uint256 attributeIndex = dnaToIndex(generation, rarityRank, attributes[i]);\n                    finalAttributeProbabilityIndexes[i] = attributeIndex;\n                }\n            }\n            return FighterOps.FighterPhysicalAttributes(\n                finalAttributeProbabilityIndexes[0],\n                finalAttributeProbabilityIndexes[1],\n                finalAttributeProbabilityIndexes[2],\n                finalAttributeProbabilityIndexes[3],\n                finalAttributeProbabilityIndexes[4],\n                finalAttributeProbabilityIndexes[5]\n            );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            PUBLIC FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n     /// @notice Add attribute probabilities for a given generation.\n     /// @dev Only the owner can call this function.\n     /// @param generation The generation number.\n     /// @param probabilities An array of attribute probabilities for the generation.\n    function addAttributeProbabilities(uint256 generation, uint8[][] memory probabilities) public {\n        require(msg.sender == _ownerAddress);\n        require(probabilities.length == 6, \"Invalid number of attribute arrays\");\n\n        uint256 attributesLength = attributes.length;\n        for (uint8 i = 0; i < attributesLength; i++) {\n            attributeProbabilities[generation][attributes[i]] = probabilities[i];\n        }\n    }\n\n     /// @notice Delete attribute probabilities for a given generation. \n     /// @dev Only the owner can call this function.\n     /// @param generation The generation number.\n    function deleteAttributeProbabilities(uint8 generation) public {\n        require(msg.sender == _ownerAddress);\n\n        uint256 attributesLength = attributes.length;\n        for (uint8 i = 0; i < attributesLength; i++) {\n            attributeProbabilities[generation][attributes[i]] = new uint8[](0);\n        }\n    }\n\n     /// @dev Get the attribute probabilities for a given generation and attribute.\n     /// @param generation The generation number.\n     /// @param attribute The attribute name.\n     /// @return Attribute probabilities.\n    function getAttributeProbabilities(uint256 generation, string memory attribute) \n        public \n        view \n        returns (uint8[] memory) \n    {\n        return attributeProbabilities[generation][attribute];\n    }    \n\n     /// @dev Convert DNA and rarity rank into an attribute probability index.\n     /// @param attribute The attribute name.\n     /// @param rarityRank The rarity rank.\n     /// @return attributeProbabilityIndex attribute probability index.\n    function dnaToIndex(uint256 generation, uint256 rarityRank, string memory attribute) \n        public \n        view \n        returns (uint256 attributeProbabilityIndex) \n    {\n        uint8[] memory attrProbabilities = getAttributeProbabilities(generation, attribute);\n        \n        uint256 cumProb = 0;\n        uint256 attrProbabilitiesLength = attrProbabilities.length;\n        for (uint8 i = 0; i < attrProbabilitiesLength; i++) {\n            cumProb += attrProbabilities[i];\n            if (cumProb >= rarityRank) {\n                attributeProbabilityIndex = i + 1;\n                break;\n            }\n        }\n        return attributeProbabilityIndex;\n    }\n}"
    },
    {
      "filename": "src/AiArenaHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\n// pragma solidity ^0.8.20;\npragma solidity >=0.8.0 <0.9.0;\n\nimport { FighterOps } from \"./FighterOps.sol\";\n\n/// @title AI Arena Helper\n/// @author ArenaX Labs Inc.\n/// @notice This contract generates and manages an AI Arena fighters physical attributes.\ncontract AiArenaHelper {\n\n    /*//////////////////////////////////////////////////////////////\n                            STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice List of attributes\n    string[] public attributes = [\"head\", \"eyes\", \"mouth\", \"body\", \"hands\", \"feet\"];\n\n    /// @notice Default DNA divisors for attributes\n    uint8[] public defaultAttributeDivisor = [2, 3, 5, 7, 11, 13];\n\n    /// The address that has owner privileges (initially the contract deployer).\n    address _ownerAddress;\n\n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/    \n    \n    /// @notice Mapping tracking fighter generation to attribute probabilities\n    mapping(uint256 => mapping(string => uint8[])) public attributeProbabilities;\n\n    /// @notice Mapping of attribute to DNA divisors\n    mapping(string => uint8) public attributeToDnaDivisor;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Constructor to initialize the contract with the attribute probabilities for gen 0.\n    /// @param probabilities An array of attribute probabilities for the generation.\n    constructor(uint8[][] memory probabilities) {\n        _ownerAddress = msg.sender;\n\n        // Initialize the probabilities for each attribute\n        addAttributeProbabilities(0, probabilities);\n\n        uint256 attributesLength = attributes.length;\n        for (uint8 i = 0; i < attributesLength; i++) {\n            attributeProbabilities[0][attributes[i]] = probabilities[i];\n            attributeToDnaDivisor[attributes[i]] = defaultAttributeDivisor[i];\n        }\n    } \n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Transfers ownership from one address to another.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param newOwnerAddress The address of the new owner\n    function transferOwnership(address newOwnerAddress) external {\n        require(msg.sender == _ownerAddress);\n        _ownerAddress = newOwnerAddress;\n    }\n\n    /// @notice Add attribute divisors for attributes.\n    /// @param attributeDivisors An array of attribute divisors.\n    function addAttributeDivisor(uint8[] memory attributeDivisors) external {\n        require(msg.sender == _ownerAddress);\n        require(attributeDivisors.length == attributes.length);\n\n        uint256 attributesLength = attributes.length;\n        for (uint8 i = 0; i < attributesLength; i++) {\n            attributeToDnaDivisor[attributes[i]] = attributeDivisors[i];\n        }\n    }    \n\n    /// @notice Create physical attributes for a fighter based on DNA.\n    /// @param dna The DNA of the fighter.\n    /// @param iconsType Type of icons fighter (0 means it's not an icon).\n    /// @param dendroidBool Whether the fighter is a dendroid or not\n    /// @return Fighter physical attributes.\n    function createPhysicalAttributes(\n        uint256 dna, \n        uint8 generation, \n        uint8 iconsType, \n        bool dendroidBool\n    ) \n        external \n        view \n        returns (FighterOps.FighterPhysicalAttributes memory) \n    {\n        if (dendroidBool) {\n            return FighterOps.FighterPhysicalAttributes(99, 99, 99, 99, 99, 99);\n        } else {\n            uint256[] memory finalAttributeProbabilityIndexes = new uint[](attributes.length);\n\n            uint256 attributesLength = attributes.length;\n            for (uint8 i = 0; i < attributesLength; i++) {\n                if (\n                  i == 0 && iconsType == 2 || // Custom icons head (beta helmet)\n                  i == 1 && iconsType > 0 || // Custom icons eyes (red diamond)\n                  i == 4 && iconsType == 3 // Custom icons hands (bowling ball)\n                ) {\n                    finalAttributeProbabilityIndexes[i] = 50;\n                } else {\n                    uint256 rarityRank = (dna / attributeToDnaDivisor[attributes[i]]) % 100;\n                    uint256 attributeIndex = dnaToIndex(generation, rarityRank, attributes[i]);\n                    finalAttributeProbabilityIndexes[i] = attributeIndex;\n                }\n            }\n            return FighterOps.FighterPhysicalAttributes(\n                finalAttributeProbabilityIndexes[0],\n                finalAttributeProbabilityIndexes[1],\n                finalAttributeProbabilityIndexes[2],\n                finalAttributeProbabilityIndexes[3],\n                finalAttributeProbabilityIndexes[4],\n                finalAttributeProbabilityIndexes[5]\n            );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            PUBLIC FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n     /// @notice Add attribute probabilities for a given generation.\n     /// @dev Only the owner can call this function.\n     /// @param generation The generation number.\n     /// @param probabilities An array of attribute probabilities for the generation.\n    function addAttributeProbabilities(uint256 generation, uint8[][] memory probabilities) public {\n        require(msg.sender == _ownerAddress);\n        require(probabilities.length == 6, \"Invalid number of attribute arrays\");\n\n        uint256 attributesLength = attributes.length;\n        for (uint8 i = 0; i < attributesLength; i++) {\n            attributeProbabilities[generation][attributes[i]] = probabilities[i];\n        }\n    }\n\n     /// @notice Delete attribute probabilities for a given generation. \n     /// @dev Only the owner can call this function.\n     /// @param generation The generation number.\n    function deleteAttributeProbabilities(uint8 generation) public {\n        require(msg.sender == _ownerAddress);\n\n        uint256 attributesLength = attributes.length;\n        for (uint8 i = 0; i < attributesLength; i++) {\n            attributeProbabilities[generation][attributes[i]] = new uint8[](0);\n        }\n    }\n\n     /// @dev Get the attribute probabilities for a given generation and attribute.\n     /// @param generation The generation number.\n     /// @param attribute The attribute name.\n     /// @return Attribute probabilities.\n    function getAttributeProbabilities(uint256 generation, string memory attribute) \n        public \n        view \n        returns (uint8[] memory) \n    {\n        return attributeProbabilities[generation][attribute];\n    }    \n\n     /// @dev Convert DNA and rarity rank into an attribute probability index.\n     /// @param attribute The attribute name.\n     /// @param rarityRank The rarity rank.\n     /// @return attributeProbabilityIndex attribute probability index.\n    function dnaToIndex(uint256 generation, uint256 rarityRank, string memory attribute) \n        public \n        view \n        returns (uint256 attributeProbabilityIndex) \n    {\n        uint8[] memory attrProbabilities = getAttributeProbabilities(generation, attribute);\n        \n        uint256 cumProb = 0;\n        uint256 attrProbabilitiesLength = attrProbabilities.length;\n        for (uint8 i = 0; i < attrProbabilitiesLength; i++) {\n            cumProb += attrProbabilities[i];\n            if (cumProb >= rarityRank) {\n                attributeProbabilityIndex = i + 1;\n                break;\n            }\n        }\n        return attributeProbabilityIndex;\n    }\n}"
    }
  ]
}