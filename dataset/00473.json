{
  "Title": "H-8: Heap is incorrectly stores the removed operator ID which can lead to division by zero in deposit/withdrawal flow",
  "Content": "# Issue H-8: Heap is incorrectly stores the removed operator ID which can lead to division by zero in deposit/withdrawal flow \n\nSource: https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/193 \n\n## Found by \nalmurhasan, itsabinashb, lemonmon, mstpr-brainbot, shaka, thec00n\n## Summary\nAn operator's strategy can be reset by the owner calling `setOperatorStrategyCaps` to \"0\". This action sets the utilization to \"0\" and removes the operator from the heap. Consequently, this means that the operator has unwound all its strategy shares and can no longer receive any more deposits. However, due to how the heap is organized, if an operator who had funds before is reset to \"0\", the heap will not successfully remove the operator. As a result, when ordering the heap, a division by \"0\" will occur, causing the transaction to revert on deposits and withdrawals indefinitely.\n## Vulnerability Detail\nIn order to break down the issue, let's divide the issue to 2 parts which their combination is the issue itself\n\n**1- Heap is not removing the removed ID from the heaps storage when the operator is removed**\n\nWhen the operator is removed, the operator will be removed from the heap as follows:\n```solidity\nfunction setOperatorStrategyCap(\n        RioLRTOperatorRegistryStorageV1.StorageV1 storage s,\n        uint8 operatorId,\n        IRioLRTOperatorRegistry.StrategyShareCap memory newShareCap\n    ) internal {\n        .\n        OperatorUtilizationHeap.Data memory utilizationHeap = s.getOperatorUtilizationHeapForStrategy(newShareCap.strategy);\n        // If the current cap is greater than 0 and the new cap is 0, remove the operator from the strategy.\n        if (currentShareDetails.cap > 0 && newShareCap.cap == 0) {\n            // If the operator has allocations, queue them for exit.\n            if (currentShareDetails.allocation > 0) {\n                operatorDetails.queueOperatorStrategyExit(operatorId, newShareCap.strategy);\n            }\n            // Remove the operator from the utilization heap.\n            -> utilizationHeap.removeByID(operatorId);\n        }\n        .\n\n        // Persist the updated heap to the active operators tracking.\n        -> utilizationHeap.store(s.activeOperatorsByStrategyShareUtilization[newShareCap.strategy]);\n         .\n    }\n```\n\n`removeByID` calls the internal `_remove` function which is **NOT** removes the last element! `self.count` is decreased however, the index is still the previous value of the `self.count`\n```solidity\nfunction _remove(Data memory self, uint8 i) internal pure {\n        self.operators[i] = self.operators[self.count--];\n    }\n```\n\n**For example, if there are 3 operators as follows:**\noperatorId: 1, utilization: 50%\noperatorId: 2, utilization: 60%\noperatorId: 3, utilization: 70%\nthen, the `heap.count` would be 3\nand the order would be: 1, 2, 3 in the heap\nheap.operators[1] = operatorId 1\nheap.operators[2] = operatorId 2\nheap.operators[3] = operatorId 3\n\n**if we remove the operator Id 2:**\n`heap.count` = 2\norder: 1,3\nheap.operators[1] = operatorId 1\nheap.operators[2] = operatorId 2\n**heap.operators[3] = operatorId 0**  THIS SHOULD BE \"0\" since its removed but it is \"3\" in the current implementation!\n\nAs shown here, the operators[3] should be \"0\" since there isn't any operator3 in the heap anymore but the heap keeps the value and not resets it. \n\n**Here a test shows the above issue:**\n```solidity\n// forge test --match-contract OperatorUtilizationHeapTest --match-test test_removingDoesNotUpdatesStoredHeap -vv\n    function test_removingDoesNotUpdatesStoredHeap() public {\n        OperatorUtilizationHeap.Data memory heap = OperatorUtilizationHeap.initialize(5);\n\n        heap.insert(OperatorUtilizationHeap.Operator({id: 1, utilization: 50}));\n        heap.store(heapStore);\n\n        heap.insert(OperatorUtilizationHeap.Operator({id: 2, utilization: 60}));\n        heap.store(heapStore);\n\n        heap.insert(OperatorUtilizationHeap.Operator({id: 3, utilization: 70}));\n        heap.store(heapStore);\n\n        console.log(\"Heaps count\", heap.count);\n        console.log(\"1st\", heap.operators[1].id);\n        console.log(\"2nd\", heap.operators[2].id);\n        console.log(\"3rd\", heap.operators[3].id);\n\n        // remove 2\n        heap.removeByID(3);\n        heap.store(heapStore);\n\n        console.log(\"Heaps count\", heap.count);\n        console.log(\"1st\", heap.operators[1].id);\n        console.log(\"2nd\", heap.operators[2].id);\n        console.log(\"3rd\", heap.operators[3].id);\n    }\n```\n**Logs:**\n<img width=\"563\" alt=\"image\" src=\"https://github.com/sherlock-audit/2024-02-rio-vesting-core-protocol-mstpr/assets/120012681/72ce2e8c-dd74-4e77-9bd7-f1096923165e\">\n\n\n**2- When the operator cap is reseted the allocations/deallocations will not work due to above heap issue because of division by zero**\n\nNow, take the above example, we removed the operatorId 3 from the heap by setting its cap to \"0\". Now, there are only operators 1 and 2 active for that specific strategy.\nWhen there are idle funds in the deposit pool before the rebalance call, the excess funds that are not requested as withdrawals will be pushed to EigenLayer as follows:\n```solidity\nfunction rebalance(address asset) external checkRebalanceDelayMet(asset) {\n       .\n       .\n        -> (uint256 sharesReceived, bool isDepositCapped) = depositPool().depositBalanceIntoEigenLayer(asset);\n        .\n    }\n```\n```solidity\n function depositBalanceIntoEigenLayer(address asset) external onlyCoordinator returns (uint256, bool) {\n        uint256 amountToDeposit = asset.getSelfBalance();\n        if (amountToDeposit == 0) return (0, false);\n        .\n        .\n        -> return (OperatorOperations.depositTokenToOperators(operatorRegistry(), asset, strategy, sharesToAllocate), isDepositCapped);\n    }\n```\n\n```solidity\nfunction depositTokenToOperators(\n        IRioLRTOperatorRegistry operatorRegistry,\n        address token,\n        address strategy,\n        uint256 sharesToAllocate\n    ) internal returns (uint256 sharesReceived) {\n       -> (uint256 sharesAllocated, IRioLRTOperatorRegistry.OperatorStrategyAllocation[] memory  allocations) = operatorRegistry.allocateStrategyShares(\n            strategy, sharesToAllocate\n        );\n        .\n        .\n    }\n```\n```solidity\nfunction allocateStrategyShares(address strategy, uint256 sharesToAllocate) external onlyDepositPool returns (uint256 sharesAllocated, OperatorStrategyAllocation[] memory allocations) {\n        -> OperatorUtilizationHeap.Data memory heap = s.getOperatorUtilizationHeapForStrategy(strategy);\n       .\n       .\n       .\n       .\n    }\n```\n\n```solidity\nfunction getOperatorUtilizationHeapForStrategy(RioLRTOperatorRegistryStorageV1.StorageV1 storage s, address strategy) internal view returns (OperatorUtilizationHeap.Data memory heap) {\n        uint8 numActiveOperators = s.activeOperatorCount;\n        if (numActiveOperators == 0) return OperatorUtilizationHeap.Data(new OperatorUtilizationHeap.Operator[](0), 0);\n        \n        heap = OperatorUtilizationHeap.initialize(MAX_ACTIVE_OPERATOR_COUNT);\n        LibMap.Uint8Map storage operators = s.activeOperatorsByStrategyShareUtilization[strategy];\n\n        IRioLRTOperatorRegistry.OperatorShareDetails memory operatorShares;\n        unchecked {\n            uint8 i;\n            for (i = 0; i < numActiveOperators; ++i) {\n                uint8 operatorId = operators.get(i);\n\n                // Non-existent operator ID. We've reached the end of the heap.\n                if (operatorId == 0) break;\n\n                operatorShares = s.operatorDetails[operatorId].shareDetails[strategy];\n                heap.operators[i + 1] = OperatorUtilizationHeap.Operator({\n                    id: operatorId,\n                    -> utilization: operatorShares.allocation.divWad(operatorShares.cap)\n                });\n            }\n            heap.count = i;\n        }\n    }\n```\nAs we can see in one above code snippet, the `numActiveOperators` is 3. Since the stored heaps last element is not set to \"0\" it will point to operatorId 3 which has a cap of \"0\" after the removal. This will make the\n```solidity\nutilization: operatorShares.allocation.divWad(operatorShares.cap)\n```\npart of the code to perform a division by zero and the function will revert. \n\n**Coded PoC:**\n```solidity\n// forge test --match-contract RioLRTOperatorRegistryTest --match-test test_Capped0ValidatorBricksFlow -vv\n    function test_Capped0ValidatorBricksFlow() public {\n        // Add 3 operators\n        addOperatorDelegators(reLST.operatorRegistry, address(reLST.rewardDistributor), 3);\n\n        // The caps for each operator is 1000e18, we will delete the id 2 so we need funds there\n        // any number that is more than 1000 should be ok for that experiement \n        uint256 AMOUNT = 1002e18;\n\n        // Allocate to cbETH strategy.\n        cbETH.approve(address(reLST.coordinator), type(uint256).max);\n        uint256 lrtAmount = reLST.coordinator.deposit(CBETH_ADDRESS, AMOUNT);\n\n        // Push funds into EigenLayer.\n        vm.prank(EOA, EOA);\n        reLST.coordinator.rebalance(CBETH_ADDRESS);\n\n        // Build the empty caps\n        IRioLRTOperatorRegistry.StrategyShareCap[] memory zeroStrategyShareCaps =\n            new IRioLRTOperatorRegistry.StrategyShareCap[](1);\n        zeroStrategyShareCaps[0] = IRioLRTOperatorRegistry.StrategyShareCap({strategy: CBETH_STRATEGY, cap: 0});\n\n        // Set the caps of CBETH_STRATEGY for operator 2 as \"0\"\n        reLST.operatorRegistry.setOperatorStrategyShareCaps(2, zeroStrategyShareCaps);\n\n        // Try an another deposit, we expect revert when we do the rebalance\n        reLST.coordinator.deposit(CBETH_ADDRESS, 10e18);\n\n        // Push funds into EigenLayer. Expect revert, due to division by \"0\"\n        skip(reETH.coordinator.rebalanceDelay());\n        vm.startPrank(EOA, EOA);\n        vm.expectRevert(bytes4(keccak256(\"DivWadFailed()\")));\n        reLST.coordinator.rebalance(CBETH_ADDRESS);\n        vm.stopPrank();\n    }\n```\n## Impact\nCore logic broken, withdrawal/deposits can not be performed. \n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/utils/OperatorRegistryV1Admin.sol#L231C5-L270C6\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/utils/OperatorUtilizationHeap.sol#L94-L110\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTCoordinator.sol#L121-L151\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTDepositPool.sol#L47-L67\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/utils/OperatorOperations.sol#L51-L68\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTOperatorRegistry.sol#L342-L392\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/utils/OperatorRegistryV1Admin.sol#L327-L351\n## Tool used\n\nManual Review\n\n## Recommendation\nWhen removing from the heap also remove the last element from the heap.\n\n**I am not sure of this, but this might work**\n```solidity\nfunction _remove(Data memory self, uint8 i) internal pure {\n        self.operators[i] = self.operators[--self.count];\n    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/rio-org/rio-sherlock-audit/pull/3.\n\n**nevillehuang**\n\nSeverity could be higher, given a use of the function correctly results in blocking of withdrawals. Leaving medium for now on grounds of admin error\n\n**shaka0x**\n\nEscalate\n\n> Leaving medium for now on grounds of admin error.\n\nI respectfully disagree with this reasoning. I think the severity of the issue and its duplicate should be high, as there is no admin error involved. There is an error in the implementation that is produced after an admin action. Otherwise, all issues at deployment or in protected functions can technically be considered as admin errors.\n\n\n\n\n\n**sherlock-admin2**\n\n> Escalate\n> \n> > Leaving medium for now on grounds of admin error.\n> \n> I respectfully disagree with this reasoning. I think the severity of the issue and its duplicate should be high, as there is no admin error involved. There is an error in the implementation that is produced after an admin action. Otherwise, all issues at deployment or in protected functions can technically be considered as admin errors.\n> \n> \n> \n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\nAgree that this issue should be high severity since withdrawals can be blocked permanently\n\n**Czar102**\n\n@nevillehuang @mstpr can't the admin remediate the situation?\n\n**nevillehuang**\n\n@solimander Could you confirm if admin remediation is possible by resetting validator cap of removed operator? Given the intended admin workflow results in blocking of funds I think the impact is severe\n\n**solimander**\n\n@nevillehuang Remediation is possible by deactivating the operator:\n\n```solidity\n// forge test --mt test_capped0ValidatorBricksFlowRecovery\nfunction test_capped0ValidatorBricksFlowRecovery() public {\n    // Add 3 operators\n    addOperatorDelegators(reLST.operatorRegistry, address(reLST.rewardDistributor), 3);\n\n    // The caps for each operator is 1000e18, we will delete the id 2 so we need funds there\n    // any number that is more than 1000 should be ok for that experiement\n    uint256 AMOUNT = 1002e18;\n\n    // Allocate to cbETH strategy.\n    cbETH.approve(address(reLST.coordinator), type(uint256).max);\n    uint256 lrtAmount = reLST.coordinator.deposit(CBETH_ADDRESS, AMOUNT);\n\n    // Push funds into EigenLayer.\n    vm.prank(EOA, EOA);\n    reLST.coordinator.rebalance(CBETH_ADDRESS);\n\n    // Build the empty caps\n    IRioLRTOperatorRegistry.StrategyShareCap[] memory zeroStrategyShareCaps =\n        new IRioLRTOperatorRegistry.StrategyShareCap[](1);\n    zeroStrategyShareCaps[0] = IRioLRTOperatorRegistry.StrategyShareCap({strategy: CBETH_STRATEGY, cap: 0});\n\n    // Set the caps of CBETH_STRATEGY for operator 2 as \"0\"\n    reLST.operatorRegistry.setOperatorStrategyShareCaps(2, zeroStrategyShareCaps);\n\n    // Try an another deposit, we expect revert when we do the rebalance\n    reLST.coordinator.deposit(CBETH_ADDRESS, 10e18);\n\n    // Push funds into EigenLayer. Expect revert, due to division by \"0\"\n    skip(reETH.coordinator.rebalanceDelay());\n    vm.startPrank(EOA, EOA);\n    vm.expectRevert(bytes4(keccak256('DivWadFailed()')));\n    reLST.coordinator.rebalance(CBETH_ADDRESS);\n    vm.stopPrank();\n\n    // Deactivate the operator to recover the system\n    reLST.operatorRegistry.deactivateOperator(2);\n\n    // Rebalance succeeds\n    vm.prank(EOA, EOA);\n    reLST.coordinator.rebalance(CBETH_ADDRESS);\n}\n```\n\nThis acts as a temporary fix, which would unblock rebalances while the issue is patched.\n\n**mstpr**\n\n> @nevillehuang @mstpr can't the admin remediate the situation?\n\nnot really.\n\nThe admin needs to reset the cap for the operator. However, when this happens, the operator's cap is reset to \"0,\" allowing deposits to be made again. If the admin sets an operator's cap to \"0,\" it's likely that the operator will not be used. To address the above issue, the admin must reset it to a value. However, this means that new deposits can be made to the operator. Although the admin can set the cap back to a value, all users must withdraw their funds before new deposits are made. Since the admin does not control all users, this is not feasible and cannot be fixed in my opinion.\n\n\nIf the operator is deactivated instead of its cap resetted to \"0\" then it is even worse. Then, the admin has to readd the operator back to system and needs to push funds to that operator such that the heap reorders correctly. Though, to do that admin needs significant amount of funds to push to system to increase the utilization. \n\nOverall it might be possible but it is extremely hard and requires capital. What do you think @shaka0x @itsabinashb ?\n\n\n**shaka0x**\n\n> > @nevillehuang @mstpr can't the admin remediate the situation?\n> \n> not really.\n> \n> The admin needs to reset the cap for the operator. However, when this happens, the operator's cap is reset to \"0,\" allowing deposits to be made again. If the admin sets an operator's cap to \"0,\" it's likely that the operator will not be used. To address the above issue, the admin must reset it to a value. However, this means that new deposits can be made to the operator. Although the admin can set the cap back to a value, all users must withdraw their funds before new deposits are made. Since the admin does not control all users, this is not feasible and cannot be fixed in my opinion.\n> \n> If the operator is deactivated instead of its cap resetted to \"0\" then it is even worse. Then, the admin has to readd the operator back to system and needs to push funds to that operator such that the heap reorders correctly. Though, to do that admin needs significant amount of funds to push to system to increase the utilization.\n> \n> Overall it might be possible but it is extremely hard and requires capital. What do you think @shaka0x @itsabinashb ?\n\nI do agree with the above comments and would like to add that the proposed solution will not work for the cases described in my PoCs (https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/316), where the bug appears after deactivating an operator.\n\n**Czar102**\n\n@solimander do you agree with the above comments?\n\n@itsabinashb please do not post unnecessarily long code/result snippets directly in a comment, it's better to put them in a gist.\n\nIf @solimander agrees, I'm planning to accept the escalation and consider this issue a valid High severity one.\n\n**solimander**\n\n@Czar102 After reviewing @shaka0x's POCs, I do agree with the above comments.\n\n**Czar102**\n\nResult:\nHigh\nHas duplicates\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [shaka0x](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/193/#issuecomment-2023444945): accepted\n\n**zrax-x**\n\n@nevillehuang Is [issue#16](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/16) a duplicate? I can't seem to understand what the problem described in [issue#16](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/16) is.  I believe that it misses the point and has no negative impact.\nAnd [issue#155](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/155), [issue#127](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/127).\n\n**itsabinashb**\n\n> Is [issue#16](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/16) a duplicate? I can't seem to understand what the problem described in [issue#16](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/16) is. I believe that it misses the point and has no negative impact. And [issue#155](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/155).\n\nIssue number 16 shows exact root cause which is same as this submission.\n\n**zrax-x**\n\n> > Is [issue#16](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/16) a duplicate? I can't seem to understand what the problem described in [issue#16](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/16) is. I believe that it misses the point and has no negative impact. And [issue#155](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/155).\n> \n> Issue number 16 shows exact root cause which is same as this submission.\n\nHowever, you did not accurately describe the harm caused, which is \"division by zero\".\n\n**solimander**\n\nI do agree that #16 does sort of miss the point as the core issue is not mentioned. The issue is not that the removed operator ID still exists in memory, but that it's not correctly removed from storage.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/176",
  "Code": [
    {
      "filename": "rio-sherlock-audit/contracts/utils/OperatorRegistryV1Admin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {LibMap} from '@solady/utils/LibMap.sol';\nimport {CREATE3} from '@solady/utils/CREATE3.sol';\nimport {FixedPointMathLib} from '@solady/utils/FixedPointMathLib.sol';\nimport {BeaconProxy} from '@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol';\nimport {RioLRTOperatorRegistryStorageV1} from 'contracts/restaking/storage/RioLRTOperatorRegistryStorageV1.sol';\nimport {IRioLRTOperatorDelegator} from 'contracts/interfaces/IRioLRTOperatorDelegator.sol';\nimport {IRioLRTOperatorRegistry} from 'contracts/interfaces/IRioLRTOperatorRegistry.sol';\nimport {OperatorUtilizationHeap} from 'contracts/utils/OperatorUtilizationHeap.sol';\nimport {IRioLRTAssetRegistry} from 'contracts/interfaces/IRioLRTAssetRegistry.sol';\nimport {BEACON_CHAIN_STRATEGY} from 'contracts/utils/Constants.sol';\nimport {Array} from 'contracts/utils/Array.sol';\nimport {Asset} from 'contracts/utils/Asset.sol';\n\n/// @title Administrative functions for the operator registry.\nlibrary OperatorRegistryV1Admin {\n    using OperatorRegistryV1Admin for RioLRTOperatorRegistryStorageV1.StorageV1;\n    using OperatorRegistryV1Admin for IRioLRTOperatorRegistry.OperatorDetails;\n    using OperatorUtilizationHeap for OperatorUtilizationHeap.Data;\n    using FixedPointMathLib for *;\n    using LibMap for *;\n    using Array for *;\n    using Asset for *;\n\n    /// @notice The maximum number of operators allowed in the registry.\n    uint8 public constant MAX_OPERATOR_COUNT = 254;\n\n    /// @notice The maximum number of active operators allowed.\n    uint8 public constant MAX_ACTIVE_OPERATOR_COUNT = 64;\n\n    /// @notice Adds a new operator to the registry, deploying a delegator contract and\n    /// delegating to the provided `operator`.\n    /// @param s The operator registry v1 storage accessor.\n    /// @param token The address of the liquid restaking token.\n    /// @param operatorDelegatorBeacon The operator delegator beacon address.\n    /// @param config The new operator's configuration.\n    function addOperator(\n        RioLRTOperatorRegistryStorageV1.StorageV1 storage s,\n        address token,\n        address operatorDelegatorBeacon,\n        IRioLRTOperatorRegistry.OperatorConfig memory config\n    ) external returns (uint8 operatorId, address delegator) {\n        if (config.operator == address(0)) revert IRioLRTOperatorRegistry.INVALID_OPERATOR();\n        if (config.initialManager == address(0)) revert IRioLRTOperatorRegistry.INVALID_MANAGER();\n        if (config.initialEarningsReceiver == address(0)) revert IRioLRTOperatorRegistry.INVALID_EARNINGS_RECEIVER();\n\n        if (s.operatorCount == MAX_OPERATOR_COUNT) revert IRioLRTOperatorRegistry.MAX_OPERATOR_COUNT_EXCEEDED();\n        if (s.activeOperatorCount == MAX_ACTIVE_OPERATOR_COUNT) {\n            revert IRioLRTOperatorRegistry.MAX_ACTIVE_OPERATOR_COUNT_EXCEEDED();\n        }\n\n        // Increment the operator count before assignment (First operator ID is 1)\n        operatorId = ++s.operatorCount;\n        s.activeOperatorCount += 1;\n\n        // Create the operator with the provided salt and initialize it.\n        delegator = CREATE3.deploy(\n            computeOperatorSalt(operatorId),\n            abi.encodePacked(type(BeaconProxy).creationCode, abi.encode(operatorDelegatorBeacon, '')),\n            0\n        );\n        IRioLRTOperatorDelegator(delegator).initialize(token, config.operator);\n\n        IRioLRTOperatorRegistry.OperatorDetails storage _operator = s.operatorDetails[operatorId];\n        _operator.active = true;\n        _operator.manager = config.initialManager;\n        _operator.earningsReceiver = config.initialEarningsReceiver;\n        _operator.delegator = delegator;\n\n        emit IRioLRTOperatorRegistry.OperatorAdded(\n            operatorId,\n            config.operator,\n            delegator,\n            config.initialManager,\n            config.initialEarningsReceiver,\n            config.initialMetadataURI\n        );\n\n        // Populate the strategy share allocation caps for the operator.\n        for (uint256 i = 0; i < config.strategyShareCaps.length; ++i) {\n            s.setOperatorStrategyCap(operatorId, config.strategyShareCaps[i]);\n        }\n\n        // Populate the validator cap for the operator, if applicable.\n        if (config.validatorCap > 0) {\n            s.setOperatorValidatorCap(operatorId, config.validatorCap);\n        }\n    }\n\n    /// @notice Activates an operator.\n    /// @param s The operator registry v1 storage accessor.\n    /// @param operatorId The operator's ID.\n    function activateOperator(RioLRTOperatorRegistryStorageV1.StorageV1 storage s, uint8 operatorId) external {\n        IRioLRTOperatorRegistry.OperatorDetails storage operator = s.operatorDetails[operatorId];\n\n        if (operator.delegator == address(0)) revert IRioLRTOperatorRegistry.INVALID_OPERATOR_DELEGATOR();\n        if (operator.active) revert IRioLRTOperatorRegistry.OPERATOR_ALREADY_ACTIVE();\n\n        operator.active = true;\n        s.activeOperatorCount += 1;\n\n        emit IRioLRTOperatorRegistry.OperatorActivated(operatorId);\n    }\n\n    /// Deactivates an operator, exiting all remaining stake to the\n    /// asset manager.\n    /// @param s The operator registry v1 storage accessor.\n    /// @param assetRegistry The asset registry contract.\n    /// @param operatorId The operator's ID.\n    function deactivateOperator(\n        RioLRTOperatorRegistryStorageV1.StorageV1 storage s,\n        IRioLRTAssetRegistry assetRegistry,\n        uint8 operatorId\n    ) external {\n        IRioLRTOperatorRegistry.OperatorDetails storage operator = s.operatorDetails[operatorId];\n\n        if (operator.delegator == address(0)) revert IRioLRTOperatorRegistry.INVALID_OPERATOR_DELEGATOR();\n        if (!operator.active) revert IRioLRTOperatorRegistry.OPERATOR_ALREADY_INACTIVE();\n\n        // Queue exits for all strategies with non-zero allocations.\n        address[] memory strategies = assetRegistry.getAssetStrategies();\n        for (uint256 i = 0; i < strategies.length; ++i) {\n            s.setOperatorStrategyCap(\n                operatorId, IRioLRTOperatorRegistry.StrategyShareCap({strategy: strategies[i], cap: 0})\n            );\n        }\n        if (operator.validatorDetails.cap > 0) {\n            s.setOperatorValidatorCap(operatorId, 0);\n        }\n\n        operator.active = false;\n        s.activeOperatorCount -= 1;\n\n        emit IRioLRTOperatorRegistry.OperatorDeactivated(operatorId);\n    }\n\n    // forgefmt: disable-next-item\n    /// Queues a complete exit from the specified strategy for the provided operator.\n    /// @param operator The storage accessor for the operator that's exiting.\n    /// @param operatorId The operator's ID.\n    /// @param strategy The strategy to exit.\n    function queueOperatorStrategyExit(IRioLRTOperatorRegistry.OperatorDetails storage operator, uint8 operatorId, address strategy) internal {\n        IRioLRTOperatorDelegator delegator = IRioLRTOperatorDelegator(operator.delegator);\n\n        uint256 sharesToExit;\n        if (strategy == BEACON_CHAIN_STRATEGY) {\n            // Queues an exit for verified validators only. Unverified validators must by exited once verified,\n            // and ETH must be scraped into the deposit pool. Exits are rounded to the nearest Gwei. It is not\n            // possible to exit ETH with precision less than 1 Gwei. We do not populate `sharesToExit` if the\n            // Eigen Pod shares are not greater than 0.\n            int256 eigenPodShares = delegator.getEigenPodShares();\n            if (eigenPodShares > 0) {\n                sharesToExit = uint256(eigenPodShares).reducePrecisionToGwei();\n            }\n        } else {\n            sharesToExit = operator.shareDetails[strategy].allocation;\n        }\n        if (sharesToExit == 0) revert IRioLRTOperatorRegistry.CANNOT_EXIT_ZERO_SHARES();\n\n        // Queues a withdrawal to the deposit pool.\n        bytes32 withdrawalRoot = delegator.queueWithdrawalForOperatorExit(strategy, sharesToExit);\n        emit IRioLRTOperatorRegistry.OperatorStrategyExitQueued(operatorId, strategy, sharesToExit, withdrawalRoot);\n    }\n\n    /// @notice Sets the operator's strategy share allocation caps.\n    /// @param s The operator registry v1 storage accessor.\n    /// @param operatorId The operator's ID.\n    /// @param newStrategyShareCaps The new strategy share allocation caps.\n    function setOperatorStrategyShareCaps(\n        RioLRTOperatorRegistryStorageV1.StorageV1 storage s,\n        uint8 operatorId,\n        IRioLRTOperatorRegistry.StrategyShareCap[] calldata newStrategyShareCaps\n    ) external {\n        for (uint256 i = 0; i < newStrategyShareCaps.length; ++i) {\n            s.setOperatorStrategyCap(operatorId, newStrategyShareCaps[i]);\n        }\n    }\n\n    /// @notice Sets the security daemon to a new account (`newSecurityDaemon`).\n    /// @param s The operator registry v1 storage accessor.\n    /// @param newSecurityDaemon The new security daemon address.\n    function setSecurityDaemon(RioLRTOperatorRegistryStorageV1.StorageV1 storage s, address newSecurityDaemon)\n        external\n    {\n        s.securityDaemon = newSecurityDaemon;\n\n        emit IRioLRTOperatorRegistry.SecurityDaemonSet(newSecurityDaemon);\n    }\n\n    /// @notice Sets the proof uploader to a new account (`newProofUploader`).\n    /// @param s The operator registry v1 storage accessor.\n    /// @param newProofUploader The new proof uploader address.\n    function setProofUploader(RioLRTOperatorRegistryStorageV1.StorageV1 storage s, address newProofUploader) external {\n        s.proofUploader = newProofUploader;\n\n        emit IRioLRTOperatorRegistry.ProofUploaderSet(newProofUploader);\n    }\n\n    /// @notice Sets the minimum acceptable delay between an operator signaling intent to register\n    // for an AVS and completing registration.\n    /// @param s The operator registry v1 storage accessor.\n    /// @param newMinStakerOptOutBlocks The new min staker opt out blocks.\n    function setMinStakerOptOutBlocks(\n        RioLRTOperatorRegistryStorageV1.StorageV1 storage s,\n        uint24 newMinStakerOptOutBlocks\n    ) external {\n        s.minStakerOptOutBlocks = newMinStakerOptOutBlocks;\n\n        emit IRioLRTOperatorRegistry.MinStakerOptOutBlocksSet(newMinStakerOptOutBlocks);\n    }\n\n    /// @dev Sets the amount of time (in seconds) before uploaded validator keys are considered \"vetted\".\n    /// @param s The operator registry v1 storage accessor.\n    /// @param newValidatorKeyReviewPeriod The new validator key review period.\n    function setValidatorKeyReviewPeriod(\n        RioLRTOperatorRegistryStorageV1.StorageV1 storage s,\n        uint24 newValidatorKeyReviewPeriod\n    ) external {\n        s.validatorKeyReviewPeriod = newValidatorKeyReviewPeriod;\n\n        emit IRioLRTOperatorRegistry.ValidatorKeyReviewPeriodSet(newValidatorKeyReviewPeriod);\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Sets the strategy share cap for a given operator.\n    /// @param s The operator registry v1 storage accessor.\n    /// @param operatorId The unique identifier of the operator.\n    /// @param newShareCap The new share cap details including the strategy and cap.\n    function setOperatorStrategyCap(\n        RioLRTOperatorRegistryStorageV1.StorageV1 storage s,\n        uint8 operatorId,\n        IRioLRTOperatorRegistry.StrategyShareCap memory newShareCap\n    ) internal {\n        IRioLRTOperatorRegistry.OperatorDetails storage operatorDetails = s.operatorDetails[operatorId];\n        if (operatorDetails.delegator == address(0)) revert IRioLRTOperatorRegistry.INVALID_OPERATOR_DELEGATOR();\n\n        IRioLRTOperatorRegistry.OperatorShareDetails memory currentShareDetails = operatorDetails.shareDetails[newShareCap.strategy];\n\n        // If the new cap is the same as the current, no update is necessary.\n        if (currentShareDetails.cap == newShareCap.cap) {\n            return;\n        }\n        OperatorUtilizationHeap.Data memory utilizationHeap = s.getOperatorUtilizationHeapForStrategy(newShareCap.strategy);\n\n        // If the current cap is greater than 0 and the new cap is 0, remove the operator from the strategy.\n        if (currentShareDetails.cap > 0 && newShareCap.cap == 0) {\n            // If the operator has allocations, queue them for exit.\n            if (currentShareDetails.allocation > 0) {\n                operatorDetails.queueOperatorStrategyExit(operatorId, newShareCap.strategy);\n            }\n            // Remove the operator from the utilization heap.\n            utilizationHeap.removeByID(operatorId);\n        } else if (currentShareDetails.cap == 0 && newShareCap.cap > 0) {\n            // If the current cap is 0 and the new cap is greater than 0, insert the operator into the heap.\n            utilizationHeap.insert(OperatorUtilizationHeap.Operator(operatorId, 0));\n        } else {\n            // Otherwise, update the operator's utilization in the heap.\n            utilizationHeap.updateUtilizationByID(operatorId, currentShareDetails.allocation.divWad(newShareCap.cap));\n        }\n\n        // Persist the updated heap to the active operators tracking.\n        utilizationHeap.store(s.activeOperatorsByStrategyShareUtilization[newShareCap.strategy]);\n\n        // Update the share cap in the operator details.\n        operatorDetails.shareDetails[newShareCap.strategy].cap = newShareCap.cap;\n\n        emit IRioLRTOperatorRegistry.OperatorStrategyShareCapSet(operatorId, newShareCap.strategy, newShareCap.cap);\n    }\n\n    /// @notice Sets the operator's maximum active validator cap.\n    /// @param s The operator registry v1 storage accessor.\n    /// @param operatorId The unique identifier of the operator.\n    /// @param newValidatorCap The new maximum active validator cap.\n    function setOperatorValidatorCap(\n        RioLRTOperatorRegistryStorageV1.StorageV1 storage s,\n        uint8 operatorId,\n        uint40 newValidatorCap\n    ) internal {\n        IRioLRTOperatorRegistry.OperatorDetails storage operatorDetails = s.operatorDetails[operatorId];\n        if (operatorDetails.delegator == address(0)) revert IRioLRTOperatorRegistry.INVALID_OPERATOR_DELEGATOR();\n\n        IRioLRTOperatorRegistry.OperatorValidatorDetails memory validatorDetails = operatorDetails.validatorDetails;\n\n        // If the new validator cap is the same as the current, no update is necessary.\n        if (validatorDetails.cap == newValidatorCap) {\n            return;\n        }\n\n        // Calculate the active deposits (deposited minus exited).\n        uint40 activeDeposits = validatorDetails.deposited - validatorDetails.exited;\n        OperatorUtilizationHeap.Data memory utilizationHeap = s.getOperatorUtilizationHeapForETH();\n\n        // If the current cap is greater than 0 and the new cap is 0, remove the operator from ETH deposit tracking.\n        if (validatorDetails.cap > 0 && newValidatorCap == 0) {\n            // If there are active deposits, queue the operator for strategy exit.\n            if (activeDeposits > 0) {\n                operatorDetails.queueOperatorStrategyExit(operatorId, BEACON_CHAIN_STRATEGY);\n                s.operatorDetails[operatorId].validatorDetails.exited += activeDeposits;\n            }\n            // Remove the operator from the utilization heap.\n            utilizationHeap.removeByID(operatorId);\n        } else if (validatorDetails.cap == 0 && newValidatorCap > 0) {\n            // If the current cap is 0 and the new cap is greater than 0, insert the operator into the heap.\n            utilizationHeap.insert(OperatorUtilizationHeap.Operator(operatorId, 0));\n        } else {\n            // Otherwise, update the operator's utilization in the heap.\n            utilizationHeap.updateUtilizationByID(operatorId, activeDeposits.divWad(newValidatorCap));\n        }\n\n        // Persist the updated heap to the active operators tracking for ETH deposits.\n        utilizationHeap.store(s.activeOperatorsByETHDepositUtilization);\n\n        // Update the validator cap in the operator details.\n        operatorDetails.validatorDetails.cap = newValidatorCap;\n\n        emit IRioLRTOperatorRegistry.OperatorValidatorCapSet(operatorId, newValidatorCap);\n    }\n\n    // forgefmt: disable-next-item\n    /// @dev Returns the operator utilization heap for the specified strategy.\n    /// Utilization is calculated as the operator's current allocation divided by their cap,\n    /// unless the cap is 0, in which case the operator is considered to have max utilization.\n    /// @param s The operator registry v1 storage accessor.\n    /// @param strategy The strategy to get the heap for.\n    function getOperatorUtilizationHeapForStrategy(RioLRTOperatorRegistryStorageV1.StorageV1 storage s, address strategy) internal view returns (OperatorUtilizationHeap.Data memory heap) {\n        uint8 numActiveOperators = s.activeOperatorCount;\n        if (numActiveOperators == 0) return OperatorUtilizationHeap.Data(new OperatorUtilizationHeap.Operator[](0), 0);\n        \n        heap = OperatorUtilizationHeap.initialize(MAX_ACTIVE_OPERATOR_COUNT);\n        LibMap.Uint8Map storage operators = s.activeOperatorsByStrategyShareUtilization[strategy];\n\n        IRioLRTOperatorRegistry.OperatorShareDetails memory operatorShares;\n        unchecked {\n            uint8 i;\n            for (i = 0; i < numActiveOperators; ++i) {\n                uint8 operatorId = operators.get(i);\n\n                // Non-existent operator ID. We've reached the end of the heap.\n                if (operatorId == 0) break;\n\n                operatorShares = s.operatorDetails[operatorId].shareDetails[strategy];\n                heap.operators[i + 1] = OperatorUtilizationHeap.Operator({\n                    id: operatorId,\n                    utilization: operatorShares.allocation.divWad(operatorShares.cap)\n                });\n            }\n            heap.count = i;\n        }\n    }\n\n    /// @dev Returns the ETH deposit operator utilization heap.\n    /// Utilization is calculated as the operator's active deposit count divided by their cap,\n    /// unless the cap is 0, in which case the operator is considered to have max utilization.\n    /// @param s The operator registry v1 storage accessor.\n    function getOperatorUtilizationHeapForETH(RioLRTOperatorRegistryStorageV1.StorageV1 storage s)\n        internal\n        view\n        returns (OperatorUtilizationHeap.Data memory heap)\n    {\n        uint8 numActiveOperators = s.activeOperatorCount;\n        if (numActiveOperators == 0) return OperatorUtilizationHeap.Data(new OperatorUtilizationHeap.Operator[](0), 0);\n\n        heap = OperatorUtilizationHeap.initialize(MAX_ACTIVE_OPERATOR_COUNT);\n\n        uint256 activeDeposits;\n        IRioLRTOperatorRegistry.OperatorValidatorDetails memory validators;\n        unchecked {\n            uint8 i;\n            for (i = 0; i < numActiveOperators; ++i) {\n                uint8 operatorId = s.activeOperatorsByETHDepositUtilization.get(i);\n\n                // Non-existent operator ID. We've reached the end of the heap.\n                if (operatorId == 0) break;\n\n                validators = s.operatorDetails[operatorId].validatorDetails;\n                activeDeposits = validators.deposited - validators.exited;\n                heap.operators[i + 1] = OperatorUtilizationHeap.Operator({\n                    id: operatorId,\n                    utilization: activeDeposits.divWad(validators.cap)\n                });\n            }\n            heap.count = i;\n        }\n    }\n\n    /// @notice Computes the salt for an operator delegator, which is the\n    /// operator ID converted to `bytes32`.\n    /// @param operatorId The operator's ID.\n    function computeOperatorSalt(uint8 operatorId) internal pure returns (bytes32) {\n        return bytes32(uint256(operatorId));\n    }\n}"
    },
    {
      "filename": "rio-sherlock-audit/contracts/utils/OperatorUtilizationHeap.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {LibMap} from '@solady/utils/LibMap.sol';\n\n/// @title Operator Utilization Heap.\n/// @notice The `OperatorUtilizationHeap` library provides functionality for managing an in-memory heap data\n/// structure that organizes operators based on their utilization. The heap allows for efficient insertion,\n/// removal, and update of operator utilizations, as well as retrieval of the operators with the minimum\n/// or maximum utilizations.\n/// https://people.scs.carleton.ca/~santoro/Reports/MinMaxHeap.pdf\nlibrary OperatorUtilizationHeap {\n    using OperatorUtilizationHeap for Data;\n    using LibMap for *;\n\n    /// @notice Thrown when an operator is not found in the heap.\n    error OPERATOR_NOT_FOUND();\n\n    /// @notice Thrown when attempting to initialize a heap with a size of 0.\n    error INVALID_HEAP_SIZE();\n\n    /// @notice Thrown when attempting an operation on an invalid operator index.\n    error INVALID_INDEX();\n\n    /// @notice Thrown when attempting to insert an operator into a full heap.\n    error HEAP_OVERFLOW();\n\n    /// @notice Thrown when attempting to fetch an operator from an empty heap.\n    error HEAP_UNDERFLOW();\n\n    /// @notice The root index of the heap.\n    uint8 constant ROOT_INDEX = 1;\n\n    /// @notice The data structure representing an operator and its utilization.\n    struct Operator {\n        uint8 id;\n        uint256 utilization;\n    }\n\n    /// @notice The data structure representing the heap.\n    struct Data {\n        Operator[] operators;\n        uint8 count;\n    }\n\n    /// @notice Initializes the heap.\n    /// @param maxSize The maximum number of operators that can be stored in the heap.\n    function initialize(uint8 maxSize) internal pure returns (Data memory) {\n        if (maxSize == 0) revert INVALID_HEAP_SIZE();\n        return Data(new Operator[](maxSize + 1), 0);\n    }\n\n    /// @notice Returns whether the heap is empty.\n    /// @param self The heap.\n    function isEmpty(Data memory self) internal pure returns (bool) {\n        return self.count == 0;\n    }\n\n    /// @notice Returns whether the heap is full.\n    /// @param self The heap.\n    function isFull(Data memory self) internal pure returns (bool) {\n        return self.count == self.operators.length - 1;\n    }\n\n    /// @notice Inserts the heap into storage.\n    /// @param self The heap.\n    /// @param heapStore The stored heap.\n    function store(Data memory self, LibMap.Uint8Map storage heapStore) internal {\n        for (uint8 i = 0; i < self.count;) {\n            unchecked {\n                heapStore.set(i, self.operators[i + 1].id);\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Inserts an operator into the heap.\n    /// @param self The heap.\n    /// @param o The operator to insert.\n    function insert(Data memory self, Operator memory o) internal pure {\n        if (self.isEmpty()) {\n            self._push(o);\n            return;\n        }\n        if (self.isFull()) revert HEAP_OVERFLOW();\n\n        self._push(o);\n        self._bubbleUp(self.count);\n    }\n\n    /// @notice Removes an operator from the heap.\n    /// @param self The heap.\n    /// @param index The index of the operator to remove.\n    function remove(Data memory self, uint8 index) internal pure {\n        if (index < ROOT_INDEX || index > self.count) revert INVALID_INDEX();\n\n        self._remove(index);\n        self._bubbleUp(index);\n        self._bubbleDown(index);\n    }\n\n    /// @notice Removes an operator from the heap by its ID.\n    /// @param self The heap.\n    /// @param id The ID of the operator to remove.\n    function removeByID(Data memory self, uint8 id) internal pure {\n        (uint8 index, bool found) = self._findOperatorIndex(id);\n        if (!found) revert OPERATOR_NOT_FOUND();\n\n        self.remove(index);\n    }\n\n    /// @notice Updates the utilization of an operator in the heap.\n    /// @param self The heap.\n    /// @param index The index of the operator to update.\n    /// @param newUtilization The new utilization of the operator.\n    function updateUtilization(Data memory self, uint8 index, uint256 newUtilization) internal pure {\n        if (index < ROOT_INDEX || index > self.count) revert INVALID_INDEX();\n\n        uint256 oldUtilization = self.operators[index].utilization;\n        if (newUtilization == oldUtilization) return;\n\n        self.operators[index].utilization = newUtilization;\n\n        self._bubbleUp(index);\n        self._bubbleDown(index);\n    }\n\n    /// @notice Updates the utilization of an operator in the heap by its ID.\n    /// @param self The heap.\n    /// @param id The ID of the operator to update.\n    /// @param newUtilization The new utilization of the operator.\n    function updateUtilizationByID(Data memory self, uint8 id, uint256 newUtilization) internal pure {\n        (uint8 index, bool found) = self._findOperatorIndex(id);\n        if (!found) revert OPERATOR_NOT_FOUND();\n\n        self.updateUtilization(index, newUtilization);\n    }\n\n    /// @notice Extracts the minimum operator from the heap.\n    /// @param self The heap.\n    function extractMin(Data memory self) internal pure returns (Operator memory o) {\n        if (self.isEmpty()) revert HEAP_UNDERFLOW();\n\n        o = self.operators[ROOT_INDEX];\n\n        self._remove(ROOT_INDEX);\n        self._bubbleDownMin(ROOT_INDEX);\n    }\n\n    /// @notice Extracts the maximum operator from the heap.\n    /// @param self The heap.\n    function extractMax(Data memory self) internal pure returns (Operator memory o) {\n        if (self.isEmpty()) revert HEAP_UNDERFLOW();\n\n        // If the heap only contains one element, it's both the min and max.\n        if (self.count == 1) {\n            return self.operators[self.count--];\n        }\n\n        // If the heap has a second level, find the maximum value in that level.\n        uint8 maxIndex = 2;\n        if (self.count >= 3 && self.operators[3].utilization > self.operators[2].utilization) {\n            maxIndex = 3;\n        }\n        o = self.operators[maxIndex];\n\n        self._remove(maxIndex);\n        self._bubbleDownMax(maxIndex);\n    }\n\n    /// @notice Returns the minimum operator from the heap.\n    /// @param self The heap.\n    function getMin(Data memory self) internal pure returns (Operator memory) {\n        if (self.isEmpty()) revert HEAP_UNDERFLOW();\n\n        return self.operators[ROOT_INDEX];\n    }\n\n    /// @notice Returns the maximum operator from the heap.\n    /// @param self The heap.\n    function getMax(Data memory self) internal pure returns (Operator memory) {\n        if (self.isEmpty()) revert HEAP_UNDERFLOW();\n\n        // If the heap only contains one element, it's both the min and max.\n        if (self.count == 1) {\n            return self.operators[ROOT_INDEX];\n        }\n\n        // If the heap has a second level, find the maximum value in that level.\n        uint8 maxIndex = 2;\n        if (self.count >= 3 && self.operators[3].utilization > self.operators[2].utilization) {\n            maxIndex = 3;\n        }\n        return self.operators[maxIndex];\n    }\n\n    /// @notice Returns the index of the maximum operator from the heap.\n    /// @param self The heap.\n    function getMaxIndex(Data memory self) internal pure returns (uint8) {\n        if (self.isEmpty()) revert HEAP_UNDERFLOW();\n\n        // If the heap only contains one element, it's the root index.\n        if (self.count == 1) {\n            return ROOT_INDEX;\n        }\n\n        // If the heap has a second level, find the maximum value in that level.\n        uint8 maxIndex = 2;\n        if (self.count >= 3 && self.operators[3].utilization > self.operators[2].utilization) {\n            maxIndex = 3;\n        }\n        return maxIndex;\n    }\n\n    /// @dev Adjusts the position of an operator downwards in the heap to ensure the\n    /// heap's properties are maintained.\n    /// @param self The heap.\n    /// @param i The index of the operator to bubble down.\n    function _bubbleDown(Data memory self, uint8 i) internal pure {\n        if (_isOnMinLevel(i)) {\n            self._bubbleDownMin(i);\n        } else {\n            self._bubbleDownMax(i);\n        }\n    }\n\n    /// @dev Adjusts the position of an operator downwards in the heap to ensure the\n    /// heap's properties are maintained. The operator is assumed to be on a min level.\n    /// @param self The heap.\n    /// @param i The index of the operator to bubble down.\n    function _bubbleDownMin(Data memory self, uint8 i) internal pure {\n        if (self._hasChildren(i)) {\n            uint8 m = self._getSmallestChildIndexOrGrandchild(i);\n            if (_isGrandchild(i, m)) {\n                if (self.operators[m].utilization < self.operators[i].utilization) {\n                    self._swap(m, i);\n                    uint8 parentOfM = m / 2;\n                    if (self.operators[m].utilization > self.operators[parentOfM].utilization) {\n                        self._swap(m, parentOfM);\n                    }\n                    self._bubbleDownMin(m);\n                }\n            } else {\n                if (self.operators[m].utilization < self.operators[i].utilization) {\n                    self._swap(m, i);\n                }\n            }\n        }\n    }\n\n    /// @dev Adjusts the position of an operator downwards in the heap to ensure the\n    /// heap's properties are maintained. The operator is assumed to be on a max level.\n    /// @param self The heap.\n    /// @param i The index of the operator to bubble down.\n    function _bubbleDownMax(Data memory self, uint8 i) internal pure {\n        if (self._hasChildren(i)) {\n            uint8 m = self._getLargestChildIndexOrGrandchild(i);\n            if (_isGrandchild(i, m)) {\n                if (self.operators[m].utilization > self.operators[i].utilization) {\n                    self._swap(m, i);\n                    uint8 parentOfM = m / 2;\n                    if (self.operators[m].utilization < self.operators[parentOfM].utilization) {\n                        self._swap(m, parentOfM);\n                    }\n                    self._bubbleDownMax(m);\n                }\n            } else {\n                if (self.operators[m].utilization > self.operators[i].utilization) {\n                    self._swap(m, i);\n                }\n            }\n        }\n    }\n\n    /// @dev Adjusts the position of an operator upwards in the heap to ensure the\n    /// heap's properties are maintained.\n    /// @param self The heap.\n    /// @param i The index of the operator to bubble up.\n    function _bubbleUp(Data memory self, uint8 i) internal pure {\n        if (i == ROOT_INDEX) return;\n\n        uint8 parentIndex = i / 2;\n        if (_isOnMinLevel(i)) {\n            if (_hasParent(i) && self.operators[i].utilization > self.operators[parentIndex].utilization) {\n                self._swap(i, parentIndex);\n                self._bubbleUpMax(parentIndex);\n            } else {\n                self._bubbleUpMin(i);\n            }\n        } else {\n            if (_hasParent(i) && self.operators[i].utilization < self.operators[parentIndex].utilization) {\n                self._swap(i, parentIndex);\n                self._bubbleUpMin(parentIndex);\n            } else {\n                self._bubbleUpMax(i);\n            }\n        }\n    }\n\n    // forgefmt: disable-next-item\n    /// @dev Adjusts the position of an operator upwards in the heap to ensure the\n    /// heap's properties are maintained. The operator is assumed to be on a min level.\n    /// @param self The heap.\n    /// @param i The index of the operator to bubble up.\n    function _bubbleUpMin(Data memory self, uint8 i) internal pure {\n        if (_hasGrandparent(i)) {\n            uint8 grandparentIndex = i / 4;\n            if (self.operators[i].utilization < self.operators[grandparentIndex].utilization) {\n                self._swap(i, grandparentIndex);\n                self._bubbleUpMin(grandparentIndex);\n            }\n        }\n    }\n\n    // forgefmt: disable-next-item\n    /// @dev Adjusts the position of an operator upwards in the heap to ensure the\n    /// heap's properties are maintained. The operator is assumed to be on a max level.\n    /// @param self The heap.\n    /// @param i The index of the operator to bubble up.\n    function _bubbleUpMax(Data memory self, uint8 i) internal pure {\n        if (_hasGrandparent(i)) {\n            uint8 grandparentIndex = i / 4;\n            if (self.operators[i].utilization > self.operators[grandparentIndex].utilization) {\n                self._swap(i, grandparentIndex);\n                self._bubbleUpMax(grandparentIndex);\n            }\n        }\n    }\n\n    /// @dev Returns whether the node at the specified index has a grandparent.\n    /// @param i The index of the node in the heap.\n    function _hasGrandparent(uint8 i) internal pure returns (bool) {\n        return i > 3;\n    }\n\n    /// @dev Returns whether the node at the specified index has a parent.\n    /// @param i The index of the node in the heap.\n    function _hasParent(uint8 i)"
    }
  ]
}