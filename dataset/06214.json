{
  "Title": "[H-03] The amount of debt removed during `liquidation` may be worth more than the account's collateral",
  "Content": "\nThe contract decreases user's debts but may not take the full worth in collateral from the user, leading to the contract losing potential funds from the missing collateral.\n\n### Proof of concept\n\nDuring the `liquidate()` function call, the function `_updateBorrowAndCollateralShare()` is eventually invoked. This function liquidates a user's debt and collateral based on the value of the **collateral** they own.\n\nIn particular, the equivalent amount of debt, `availableBorrowPart` is calculated from the user's collateral on line 225 through the `computeClosingFactor()` function call.\n\nThen, an additional fee through the `liquidationBonusAmount` is applied to the debt, which is then compared to the user's debt on line 240. The minimum of the two is assigned `borrowPart`, which intuitively means the maximum amount of debt that can be removed from the user's debt.\n\n`borrowPart` is then increased by a bonus through `liquidationMultiplier`, and then converted to generate `collateralShare`, which represents the amount of collateral equivalent in value to `borrowPart` (plus some fees and bonus).\n\nThis new `collateralShare` may be more than the collateral that the user owns. In that case, the `collateralShare` is simply decreased to the user's collateral.\n\n`collateralShare` is then removed from the user's collateral.\n\nThe problem lies in that although the `collateralShare` is equivalent to the `borrowPart`, or the debt removed from the user's account, it could be worth more than the collateral that the user owns in the first place. Hence, the contract loses out on funds, as debt is removed for less than it is actually worth.\n\nTo demonstrate, we provide a runnable POC.\n\n### Preconditions\n\n```solidity\n... \nif (collateralShare > userCollateralShare[user]) {\n        require(false, \"collateralShare and borrowPart not worth the same\"); //@audit add this line\n        collateralShare = userCollateralShare[user];\n    }\n    userCollateralShare[user] -= collateralShare;\n...\n```\n\nAdd the `require` statement to line [261](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/singularity/SGLLiquidation.sol#L261). This require statement essentially reverts the contract when the `if` condition satisfies. The `if` condition holds true when the `collateralShare` is greater that the user's collateral, which is the target bug.\n\nOnce the changes have been made, add the following test into the `singularity.test.ts` test in `tapioca-bar-audit/test`\n\n### Code\n\n<details>\n\n```typescript\nit('POC', async () => {\n            const {\n                usdc,\n                wbtc,\n                yieldBox,\n                wbtcDepositAndAddAsset,\n                usdcDepositAndAddCollateralWbtcSingularity,\n                eoa1,\n                approveTokensAndSetBarApproval,\n                deployer,\n                wbtcUsdcSingularity,\n                multiSwapper,\n                wbtcUsdcOracle,\n                __wbtcUsdcPrice,\n            } = await loadFixture(register);\n\n            const assetId = await wbtcUsdcSingularity.assetId();\n            const collateralId = await wbtcUsdcSingularity.collateralId();\n            const wbtcMintVal = ethers.BigNumber.from((1e8).toString()).mul(1);\n            const usdcMintVal = wbtcMintVal\n                .mul(1e10)\n                .mul(__wbtcUsdcPrice.div((1e18).toString()));\n\n            // We get asset\n            await wbtc.freeMint(wbtcMintVal);\n            await usdc.connect(eoa1).freeMint(usdcMintVal);\n\n            // We approve external operators\n            await approveTokensAndSetBarApproval();\n            await approveTokensAndSetBarApproval(eoa1);\n\n            // We lend WBTC as deployer\n            await wbtcDepositAndAddAsset(wbtcMintVal);\n            expect(\n                await wbtcUsdcSingularity.balanceOf(deployer.address),\n            ).to.be.equal(await yieldBox.toShare(assetId, wbtcMintVal, false));\n\n            // We deposit USDC collateral\n            await usdcDepositAndAddCollateralWbtcSingularity(usdcMintVal, eoa1);\n            expect(\n                await wbtcUsdcSingularity.userCollateralShare(eoa1.address),\n            ).equal(await yieldBox.toShare(collateralId, usdcMintVal, false));\n\n            // We borrow 74% collateral, max is 75%\n\n            console.log(\"Collateral amt: \", usdcMintVal);\n            const wbtcBorrowVal = usdcMintVal\n                .mul(74)\n                .div(100)\n                .div(__wbtcUsdcPrice.div((1e18).toString()))\n                .div(1e10);\n            console.log(\"WBTC borrow val: \", wbtcBorrowVal);\n            console.log(\"[$] Original price: \", __wbtcUsdcPrice.div((1e18).toString()));\n            await wbtcUsdcSingularity\n                .connect(eoa1)\n                .borrow(eoa1.address, eoa1.address, wbtcBorrowVal.toString());\n            await yieldBox\n                .connect(eoa1)\n                .withdraw(\n                    assetId,\n                    eoa1.address,\n                    eoa1.address,\n                    wbtcBorrowVal,\n                    0,\n                );\n\n            const data = new ethers.utils.AbiCoder().encode(['uint256'], [1]);\n            // Can't liquidate\n            await expect(\n                wbtcUsdcSingularity.liquidate(\n                    [eoa1.address],\n                    [wbtcBorrowVal],\n                    multiSwapper.address,\n                    data,\n                    data,\n                ),\n            ).to.be.reverted;\n            console.log(\"Price Drop: 120%\");\n            const priceDrop = __wbtcUsdcPrice.mul(40).div(100);\n            await wbtcUsdcOracle.set(__wbtcUsdcPrice.add(priceDrop));\n            await wbtcUsdcSingularity.updateExchangeRate()\n            console.log(\"Running liquidation... \");\n            await expect(\n                wbtcUsdcSingularity.liquidate(\n                    [eoa1.address],\n                    [wbtcBorrowVal],\n                    multiSwapper.address,\n                    data,\n                    data,\n                ),\n            ).to.be.revertedWith(\"collateralShare and borrowPart not worth the same\");\n            console.log(\"[*] Reverted with reason: collateralShare and borrowPart not worth the same [Bug]\");\n            //console.log(\"Collateral Share after liquidation: \", (await wbtcUsdcSingularity.userCollateralShare(eoa1.address)));\n            //console.log(\"Borrow part after liquidation: \", (await wbtcUsdcSingularity.userBorrowPart(eoa1.address)));\n        });\n```\n\n</details>\n\n### Expected Result\n\n```bash\nCollateral amt:  BigNumber { value: \"10000000000000000000000\" }\nWBTC borrow val:  BigNumber { value: \"74000000\" }\n[$] Original price:  BigNumber { value: \"10000\" }\nPrice Drop: 120%\nRunning liquidation... \n[*] Reverted with reason: collateralShare and borrowPart not worth the same [Bug]\n      âœ” POC (2289ms)\n```\n\nAs demonstrated, the function call reverts due to the `require` statement added in the preconditions.\n\n### Recommended Mitigation\n\nOne potential mitigation for this issue would be to calculate the `borrowPart` depending on the existing users' collateral factoring in the fees and bonuses. The `collateralShare` with the fees and bonuses should not exceed the user's collateral.\n\n**[cryptotechmaker (Tapioca) confirmed](https://github.com/code-423n4/2023-07-tapioca-findings/issues/1620#issuecomment-1707830868)**\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/markets/singularity/SGLLiquidation.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"./SGLCommon.sol\";\n\n// solhint-disable max-line-length\n\n/// @title Singularity liquidation module\n/// @notice Singularity module for liquidation type actions\ncontract SGLLiquidation is SGLCommon {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n\n    /// @notice Entry point for liquidations.\n    /// @dev Will call `closedLiquidation()` if not LQ exists or no LQ bid avail exists. Otherwise use LQ.\n    /// @param users An array of user addresses.\n    /// @param maxBorrowParts A one-to-one mapping to `users`, contains maximum (partial) borrow amounts (to liquidate) of the respective user.\n    ///        Ignore for `orderBookLiquidation()`\n    /// @param swapper Contract address of the `MultiSwapper` implementation. See `setSwapper`.\n    ///        Ignore for `orderBookLiquidation()`\n    /// @param collateralToAssetSwapData Extra swap data\n    ///        Ignore for `orderBookLiquidation()`\n    /// @param usdoToBorrowedSwapData Extra swap data\n    ///        Ignore for `closedLiquidation()`\n    function liquidate(\n        address[] calldata users,\n        uint256[] calldata maxBorrowParts,\n        ISwapper swapper,\n        bytes calldata collateralToAssetSwapData,\n        bytes calldata usdoToBorrowedSwapData\n    ) external notPaused {\n        // Oracle can fail but we still need to allow liquidations\n        (, uint256 _exchangeRate) = updateExchangeRate();\n        _accrue();\n\n        if (address(liquidationQueue) != address(0)) {\n            (, bool bidAvail, uint256 bidAmount) = liquidationQueue\n                .getNextAvailBidPool();\n            if (bidAvail) {\n                uint256 needed = 0;\n                for (uint256 i = 0; i < maxBorrowParts.length; i++) {\n                    needed += maxBorrowParts[i];\n                }\n                if (bidAmount >= needed) {\n                    _orderBookLiquidation(\n                        users,\n                        _exchangeRate,\n                        usdoToBorrowedSwapData\n                    );\n                    return;\n                }\n            }\n        }\n        _closedLiquidation(\n            users,\n            maxBorrowParts,\n            swapper,\n            _exchangeRate,\n            collateralToAssetSwapData\n        );\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _computeAssetAmountToSolvency(\n        address user,\n        uint256 _exchangeRate\n    ) private view returns (uint256) {\n        // accrue must have already been called!\n        uint256 borrowPart = userBorrowPart[user];\n        if (borrowPart == 0) return 0;\n        uint256 collateralShare = userCollateralShare[user];\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        uint256 collateralAmountInAsset = yieldBox.toAmount(\n            collateralId,\n            (collateralShare *\n                (EXCHANGE_RATE_PRECISION / FEE_PRECISION) *\n                lqCollateralizationRate),\n            false\n        ) / _exchangeRate;\n        // Obviously it's not `borrowPart` anymore but `borrowAmount`\n        borrowPart = (borrowPart * _totalBorrow.elastic) / _totalBorrow.base;\n\n        return\n            borrowPart >= collateralAmountInAsset\n                ? borrowPart - collateralAmountInAsset\n                : 0;\n    }\n\n    function _orderBookLiquidation(\n        address[] calldata users,\n        uint256 _exchangeRate,\n        bytes memory swapData\n    ) private {\n        uint256 allCollateralShare;\n        uint256 allBorrowAmount;\n        uint256 allBorrowPart;\n        Rebase memory _totalBorrow = totalBorrow;\n\n        for (uint256 i = 0; i < users.length; i++) {\n            address user = users[i];\n            if (!_isSolvent(user, _exchangeRate)) {\n                uint256 borrowAmount = _computeAssetAmountToSolvency(\n                    user,\n                    _exchangeRate\n                );\n\n                if (borrowAmount == 0) {\n                    continue;\n                }\n\n                uint256 borrowPart;\n                {\n                    uint256 availableBorrowPart = userBorrowPart[user];\n                    borrowPart = _totalBorrow.toBase(borrowAmount, false);\n                    userBorrowPart[user] = availableBorrowPart - borrowPart;\n                }\n                uint256 amountWithBonus = borrowAmount +\n                    (borrowAmount * liquidationMultiplier) /\n                    FEE_PRECISION;\n                uint256 collateralShare = yieldBox.toShare(\n                    collateralId,\n                    (amountWithBonus * _exchangeRate) / EXCHANGE_RATE_PRECISION,\n                    false\n                );\n                userCollateralShare[user] -= collateralShare;\n                emit LogRemoveCollateral(\n                    user,\n                    address(liquidationQueue),\n                    collateralShare\n                );\n                emit LogRepay(\n                    address(liquidationQueue),\n                    user,\n                    borrowAmount,\n                    borrowPart\n                );\n\n                // Keep totals\n                allCollateralShare += collateralShare;\n                allBorrowAmount += borrowAmount;\n                allBorrowPart += borrowPart;\n            }\n        }\n        require(allBorrowAmount != 0, \"SGL: solvent\");\n\n        _totalBorrow.elastic -= uint128(allBorrowAmount);\n        _totalBorrow.base -= uint128(allBorrowPart);\n        totalBorrow = _totalBorrow;\n        totalCollateralShare -= allCollateralShare;\n\n        uint256 allBorrowShare = yieldBox.toShare(\n            assetId,\n            allBorrowAmount,\n            true\n        );\n\n        // Transfer collateral to be liquidated\n        yieldBox.transfer(\n            address(this),\n            address(liquidationQueue),\n            collateralId,\n            allCollateralShare\n        );\n\n        // LiquidationQueue pay debt\n        liquidationQueue.executeBids(\n            yieldBox.toAmount(collateralId, allCollateralShare, true),\n            swapData\n        );\n\n        uint256 returnedShare = yieldBox.balanceOf(address(this), assetId) -\n            uint256(totalAsset.elastic);\n        uint256 extraShare = returnedShare - allBorrowShare;\n        uint256 callerShare = (extraShare * callerFee) / FEE_PRECISION; // 1% goes to caller\n\n        emit Liquidated(\n            msg.sender,\n            users,\n            callerShare,\n            returnedShare - callerShare,\n            allBorrowAmount,\n            allCollateralShare\n        );\n\n        yieldBox.transfer(address(this), msg.sender, assetId, callerShare);\n\n        totalAsset.elastic += uint128(returnedShare - callerShare);\n        emit LogAddAsset(\n            address(liquidationQueue),\n            address(this),\n            returnedShare - callerShare,\n            0\n        );\n    }\n\n    function _updateBorrowAndCollateralShare(\n        address user,\n        uint256 maxBorrowPart,\n        uint256 _exchangeRate\n    )\n        private\n        returns (\n            uint256 borrowAmount,\n            uint256 borrowPart,\n            uint256 collateralShare\n        )\n    {\n        uint256 collateralPartInAsset = (yieldBox.toAmount(\n            collateralId,\n            userCollateralShare[user],\n            false\n        ) * EXCHANGE_RATE_PRECISION) / _exchangeRate;\n\n        uint256 borrowAssetDecimals = asset.safeDecimals();\n        uint256 collateralDecimals = collateral.safeDecimals();\n\n        uint256 availableBorrowPart = computeClosingFactor(\n            userBorrowPart[user],\n            collateralPartInAsset,\n            borrowAssetDecimals,\n            collateralDecimals,\n            FEE_PRECISION_DECIMALS\n        );\n\n        if (liquidationBonusAmount > 0) {\n            availableBorrowPart =\n                availableBorrowPart +\n                (availableBorrowPart * liquidationBonusAmount) /\n                FEE_PRECISION;\n        }\n\n        borrowPart = maxBorrowPart > availableBorrowPart\n            ? availableBorrowPart\n            : maxBorrowPart;\n\n        if (borrowPart > userBorrowPart[user]) {\n            borrowPart = userBorrowPart[user];\n        }\n\n        userBorrowPart[user] = userBorrowPart[user] - borrowPart;\n\n        borrowAmount = totalBorrow.toElastic(borrowPart, false);\n\n        uint256 amountWithBonus = borrowAmount +\n            (borrowAmount * liquidationMultiplier) /\n            FEE_PRECISION;\n        collateralShare = yieldBox.toShare(\n            collateralId,\n            (amountWithBonus * _exchangeRate) / EXCHANGE_RATE_PRECISION,\n            false\n        );\n        if (collateralShare > userCollateralShare[user]) {\n            collateralShare = userCollateralShare[user];\n        }\n        userCollateralShare[user] -= collateralShare;\n        require(borrowAmount != 0, \"SGL: solvent\");\n\n        totalBorrow.elastic -= uint128(borrowAmount);\n        totalBorrow.base -= uint128(borrowPart);\n    }\n\n    function _extractLiquidationFees(\n        uint256 borrowShare,\n        uint256 callerReward,\n        address swapper\n    ) private returns (uint256 feeShare, uint256 callerShare) {\n        uint256 returnedShare = yieldBox.balanceOf(address(this), assetId) -\n            uint256(totalAsset.elastic);\n        uint256 extraShare = returnedShare - borrowShare;\n        feeShare = (extraShare * protocolFee) / FEE_PRECISION; // x% of profit goes to fee.\n        callerShare = (extraShare * callerReward) / FEE_PRECISION; //  y%  of profit goes to caller.\n\n        yieldBox.transfer(address(this), penrose.feeTo(), assetId, feeShare);\n        yieldBox.transfer(address(this), msg.sender, assetId, callerShare);\n\n        totalAsset.elastic += uint128(returnedShare - feeShare - callerShare);\n\n        emit LogAddAsset(\n            swapper,\n            address(this),\n            extraShare - feeShare - callerShare,\n            0\n        );\n    }\n\n    function _liquidateUser(\n        address user,\n        uint256 maxBorrowPart,\n        ISwapper swapper,\n        uint256 _exchangeRate,\n        bytes calldata dexData\n    ) private {\n        if (_isSolvent(user, _exchangeRate)) return;\n\n        (\n            uint256 startTVLInAsset,\n            uint256 maxTVLInAsset\n        ) = _computeMaxAndMinLTVInAsset(\n                userCollateralShare[user],\n                _exchangeRate\n            );\n        uint256 callerReward = _getCallerReward(\n            userBorrowPart[user],\n            startTVLInAsset,\n            maxTVLInAsset\n        );\n\n        (\n            uint256 borrowAmount,\n            uint256 borrowPart,\n            uint256 collateralShare\n        ) = _updateBorrowAndCollateralShare(user, maxBorrowPart, _exchangeRate);\n        emit LogRemoveCollateral(user, address(swapper), collateralShare);\n        emit LogRepay(address(swapper), user, borrowAmount, borrowPart);\n\n        uint256 borrowShare = yieldBox.toShare(assetId, borrowAmount, true);\n\n        // Closed liquidation using a pre-approved swapper\n        require(penrose.swappers(swapper), \"SGL: Invalid swapper\");\n\n        // Swaps the users collateral for the borrowed asset\n        yieldBox.transfer(\n            address(this),\n            address(swapper),\n            collateralId,\n            collateralShare\n        );\n\n        uint256 minAssetAmount = 0;\n        if (dexData.length > 0) {\n            minAssetAmount = abi.decode(dexData, (uint256));\n        }\n\n        ISwapper.SwapData memory swapData = swapper.buildSwapData(\n            collateralId,\n            assetId,\n            0,\n            collateralShare,\n            true,\n            true\n        );\n        swapper.swap(swapData, minAssetAmount, address(this), \"\");\n\n        (uint256 feeShare, uint256 callerShare) = _extractLiquidationFees(\n            borrowShare,\n            callerReward,\n            address(swapper)\n        );\n\n        address[] memory _users = new address[](1);\n        _users[0] = user;\n        emit Liquidated(\n            msg.sender,\n            _users,\n            callerShare,\n            feeShare,\n            borrowAmount,\n            collateralShare\n        );\n    }\n\n    /// @notice Handles the liquidation of users' balances, once the users' amount of collateral is too low.\n    /// @dev Closed liquidations Only, 90% of extra shares goes to caller and 10% to protocol\n    /// @param users An array of user addresses.\n    /// @param maxBorrowParts A one-to-one mapping to `users`, contains maximum (partial) borrow amounts (to liquidate) of the respective user.\n    /// @param swapper Contract address of the `MultiSwapper` implementation. See `setSwapper`.\n    /// @param swapData Swap necessar data\n    function _closedLiquidation(\n        address[] calldata users,\n        uint256[] calldata maxBorrowParts,\n        ISwapper swapper,\n        uint256 _exchangeRate,\n        bytes calldata swapData\n    ) private {\n        uint256 liquidatedCount = 0;\n        for (uint256 i = 0; i < users.length; i++) {\n            address user = users[i];\n            if (!_isSolvent(user, _exchangeRate)) {\n                liquidatedCount++;\n                _liquidateUser(\n                    user,\n                    maxBorrowParts[i],\n                    swapper,\n                    _exchangeRate,\n                    swapData\n                );\n            }\n        }\n        require(liquidatedCount > 0, \"SGL: no users found\");\n    }\n}"
    }
  ]
}