{
  "Title": "[M-03] Fee on transfer tokens will not behave as expected",
  "Content": "\n<https://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/TimeswapV2Option.sol#L145-L148> \n\n<https://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/TimeswapV2Option.sol#L235>\n\n### Impact\n\nAccording to [Whitepaper 1.1 Permissionless](https://github.com/code-423n4/2023-01-timeswap/blob/main/whitepaper.pdf):\n\n\"In Timeswap, liquidity providers can create pools for any ERC20 pair, without permission. It is designed to be generalized and works\nfor any pair of tokens, at any time frame, and at any market state ...\n\nIf fee on transfer token(s) is/are entailed, it will specifically make `mint()` and `swap()` revert in TimeswapV2Option.sol when checking if the token0 or token1 balance target is achieved.\n\n### Proof of Concept\n\n[File: TimeswapV2Option.sol#L144-L148](https://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/TimeswapV2Option.sol#L144-L148)\n\n```solidity\n        // check if the token0 balance target is achieved.\n        if (token0AndLong0Amount != 0) Error.checkEnough(IERC20(token0).balanceOf(address(this)), currentProcess.balance0Target);\n\n        // check if the token1 balance target is achieved.\n        if (token1AndLong1Amount != 0) Error.checkEnough(IERC20(token1).balanceOf(address(this)), currentProcess.balance1Target);\n```\n\n[File: TimeswapV2Option.sol#L234-L235](https://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/TimeswapV2Option.sol#L234-L235)\n\n```solidity\n        // check if the token0 or token1 balance target is achieved.\n        Error.checkEnough(IERC20(param.isLong0ToLong1 ? token1 : token0).balanceOf(address(this)), param.isLong0ToLong1 ? currentProcess.balance1Target : currentProcess.balance0Target);\n```\n\n[File: Error.sol#L148-L153](https://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-library/src/Error.sol#L148-L153)\n\n```solidity\n    /// @dev Reverts when token amount not received.\n    /// @param balance The balance amount being subtracted.\n    /// @param balanceTarget The amount target.\n    function checkEnough(uint256 balance, uint256 balanceTarget) internal pure {\n        if (balance < balanceTarget) revert NotEnoughReceived(balance, balanceTarget);\n    }\n```\n\nAs can be seen from the code blocks above, `checkEnough()` is meant to be reverting when token amount has not been received. But in the case of deflationary tokens, the error is going to be thrown even though the token amount has been received due to the fee factor making `balance < balanceTarget`, i.e the contract balance of token0 and/or token1 always less than `currentProcess.balance0Target` or `currentProcess.balance1Target`.\n\n### Recommended Mitigation Steps\n\nConsider:\n\n1.  Whitelisting token0 and token1 ensuring no fee-on-transfer token is allowed when deploying a new Timeswap V2 Option pair contract, or\n2.  Calculating the balance before and after the [transfer to the recipient](https://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/TimeswapV2Option.sol#L220) during the process, and use the difference between those two balances as the amount received rather than using the input amount (`token0AndLong0Amount` or `token1AndLong1Amount`) if deflationary token is going to be allowed in the protocol.\n\n**[vhawk19 (Timeswap) acknowledged and commented](https://github.com/code-423n4/2023-01-timeswap-findings/issues/247#issuecomment-1430795527):**\n > Not supported by design.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-01-timeswap",
  "Code": [
    {
      "filename": "packages/v2-option/src/TimeswapV2Option.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {Math} from \"@timeswap-labs/v2-library/src/Math.sol\";\nimport {Error} from \"@timeswap-labs/v2-library/src/Error.sol\";\n\nimport {NoDelegateCall} from \"./NoDelegateCall.sol\";\n\nimport {ITimeswapV2Option} from \"./interfaces/ITimeswapV2Option.sol\";\nimport {ITimeswapV2OptionDeployer} from \"./interfaces/ITimeswapV2OptionDeployer.sol\";\nimport {ITimeswapV2OptionMintCallback} from \"./interfaces/callbacks/ITimeswapV2OptionMintCallback.sol\";\nimport {ITimeswapV2OptionBurnCallback} from \"./interfaces/callbacks/ITimeswapV2OptionBurnCallback.sol\";\nimport {ITimeswapV2OptionSwapCallback} from \"./interfaces/callbacks/ITimeswapV2OptionSwapCallback.sol\";\nimport {ITimeswapV2OptionCollectCallback} from \"./interfaces/callbacks/ITimeswapV2OptionCollectCallback.sol\";\n\nimport {Option, OptionLibrary} from \"./structs/Option.sol\";\nimport {Process, ProcessLibrary} from \"./structs/Process.sol\";\nimport {StrikeAndMaturity} from \"./structs/StrikeAndMaturity.sol\";\n\nimport {TimeswapV2OptionPosition, PositionLibrary} from \"./enums/Position.sol\";\nimport {TimeswapV2OptionMint, TimeswapV2OptionBurn, TimeswapV2OptionSwap, TimeswapV2OptionCollect, TransactionLibrary} from \"./enums/Transaction.sol\";\n\nimport {TimeswapV2OptionMintParam, TimeswapV2OptionBurnParam, TimeswapV2OptionSwapParam, TimeswapV2OptionCollectParam, ParamLibrary} from \"./structs/Param.sol\";\nimport {TimeswapV2OptionMintCallbackParam, TimeswapV2OptionBurnCallbackParam, TimeswapV2OptionSwapCallbackParam, TimeswapV2OptionCollectCallbackParam} from \"./structs/CallbackParam.sol\";\n\n/// @title Timeswap V2 Options for a given pair\n/// @author Timeswap Labs\n/// @notice Holds the option of all strikes and maturies.\ncontract TimeswapV2Option is ITimeswapV2Option, NoDelegateCall {\n    using OptionLibrary for Option;\n    using ProcessLibrary for Process[];\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n\n    /* ===== MODEL ===== */\n\n    /// @inheritdoc ITimeswapV2Option\n    address public immutable override optionFactory;\n    /// @inheritdoc ITimeswapV2Option\n    address public immutable override token0;\n    /// @inheritdoc ITimeswapV2Option\n    address public immutable override token1;\n\n    /// @dev mapping of all option state for all strikes and maturies.\n    mapping(uint256 => mapping(uint256 => Option)) private options;\n    /// @dev Always start and end as an empty array for every transaction.\n    /// Process the token requirement for every option interaction call.\n    Process[] private processing;\n\n    mapping(uint256 => mapping(uint256 => bool)) private hasInteracted;\n    StrikeAndMaturity[] private listOfOptions;\n\n    function addOptionEnumerationIfNecessary(uint256 strike, uint256 maturity) private {\n        if (!hasInteracted[strike][maturity]) {\n            hasInteracted[strike][maturity] = true;\n            listOfOptions.push(StrikeAndMaturity({strike: strike, maturity: maturity}));\n        }\n    }\n\n    /* ===== INIT ===== */\n\n    constructor() NoDelegateCall() {\n        (optionFactory, token0, token1) = ITimeswapV2OptionDeployer(msg.sender).parameter();\n    }\n\n    // Can be overidden for testing purposes.\n    function blockTimestamp() internal view virtual returns (uint96) {\n        return uint96(block.timestamp); // truncation is desired\n    }\n\n    /* ===== VIEW ===== */\n\n    function getByIndex(uint256 id) external view override returns (StrikeAndMaturity memory) {\n        return listOfOptions[id];\n    }\n\n    function numberOfOptions() external view override returns (uint256) {\n        return listOfOptions.length;\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function totalPosition(uint256 strike, uint256 maturity, TimeswapV2OptionPosition position) external view override returns (uint256) {\n        return options[strike][maturity].totalPosition(strike, position);\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function positionOf(uint256 strike, uint256 maturity, address owner, TimeswapV2OptionPosition position) external view override returns (uint256) {\n        return options[strike][maturity].positionOf(owner, position);\n    }\n\n    /* ===== UPDATE ===== */\n\n    /// @inheritdoc ITimeswapV2Option\n    function transferPosition(uint256 strike, uint256 maturity, address to, TimeswapV2OptionPosition position, uint256 amount) external override {\n        if (!hasInteracted[strike][maturity]) Error.inactiveOptionChoice(strike, maturity);\n        if (to == address(0)) Error.zeroAddress();\n        if (amount == 0) Error.zeroInput();\n        PositionLibrary.check(position);\n\n        options[strike][maturity].transferPosition(to, position, amount);\n\n        emit TransferPosition(strike, maturity, msg.sender, to, position, amount);\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function mint(\n        TimeswapV2OptionMintParam calldata param\n    ) external override noDelegateCall returns (uint256 token0AndLong0Amount, uint256 token1AndLong1Amount, uint256 shortAmount, bytes memory data) {\n        ParamLibrary.check(param, blockTimestamp());\n        addOptionEnumerationIfNecessary(param.strike, param.maturity);\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main mint logic calculation\n        (token0AndLong0Amount, token1AndLong1Amount, shortAmount) = option.mint(param.strike, param.long0To, param.long1To, param.shortTo, param.transaction, param.amount0, param.amount1);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0AndLong0Amount, token1AndLong1Amount, true, true);\n\n        // add a new process\n        // stores the token0 and token1 balance target required from the msg.sender to achieve.\n        Process storage currentProcess = (processing.push() = Process(\n            param.strike,\n            param.maturity,\n            IERC20(token0).balanceOf(address(this)) + token0AndLong0Amount,\n            IERC20(token1).balanceOf(address(this)) + token1AndLong1Amount\n        ));\n\n        // ask the msg.sender to transfer token0 and/or token1 to this contract.\n        data = ITimeswapV2OptionMintCallback(msg.sender).timeswapV2OptionMintCallback(\n            TimeswapV2OptionMintCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                token0AndLong0Amount: token0AndLong0Amount,\n                token1AndLong1Amount: token1AndLong1Amount,\n                shortAmount: shortAmount,\n                data: param.data\n            })\n        );\n\n        // check if the token0 balance target is achieved.\n        if (token0AndLong0Amount != 0) Error.checkEnough(IERC20(token0).balanceOf(address(this)), currentProcess.balance0Target);\n\n        // check if the token1 balance target is achieved.\n        if (token1AndLong1Amount != 0) Error.checkEnough(IERC20(token1).balanceOf(address(this)), currentProcess.balance1Target);\n\n        // finish the process.\n        processing.pop();\n\n        emit Mint(param.strike, param.maturity, msg.sender, param.long0To, param.long1To, param.shortTo, token0AndLong0Amount, token1AndLong1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function burn(\n        TimeswapV2OptionBurnParam calldata param\n    ) external override noDelegateCall returns (uint256 token0AndLong0Amount, uint256 token1AndLong1Amount, uint256 shortAmount, bytes memory data) {\n        if (!hasInteracted[param.strike][param.maturity]) Error.inactiveOptionChoice(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp());\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main burn logic calculation\n        (token0AndLong0Amount, token1AndLong1Amount, shortAmount) = option.burn(param.strike, param.transaction, param.amount0, param.amount1);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0AndLong0Amount, token1AndLong1Amount, false, false);\n\n        // transfer token0 amount to recipient.\n        if (token0AndLong0Amount != 0) IERC20(token0).safeTransfer(param.token0To, token0AndLong0Amount);\n\n        // transfer token1 amount to recipient.\n        if (token1AndLong1Amount != 0) IERC20(token1).safeTransfer(param.token1To, token1AndLong1Amount);\n\n        // skip callback if there is no data.\n        if (param.data.length != 0)\n            data = ITimeswapV2OptionBurnCallback(msg.sender).timeswapV2OptionBurnCallback(\n                TimeswapV2OptionBurnCallbackParam({\n                    strike: param.strike,\n                    maturity: param.maturity,\n                    token0AndLong0Amount: token0AndLong0Amount,\n                    token1AndLong1Amount: token1AndLong1Amount,\n                    shortAmount: shortAmount,\n                    data: param.data\n                })\n            );\n\n        option.long0[msg.sender] -= token0AndLong0Amount;\n        option.long1[msg.sender] -= token1AndLong1Amount;\n        option.short[msg.sender] -= shortAmount;\n\n        emit Burn(param.strike, param.maturity, msg.sender, param.token0To, param.token1To, token0AndLong0Amount, token1AndLong1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function swap(TimeswapV2OptionSwapParam calldata param) external override noDelegateCall returns (uint256 token0AndLong0Amount, uint256 token1AndLong1Amount, bytes memory data) {\n        if (!hasInteracted[param.strike][param.maturity]) Error.inactiveOptionChoice(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp());\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main swap logic calculation\n        (token0AndLong0Amount, token1AndLong1Amount) = option.swap(param.strike, param.longTo, param.isLong0ToLong1, param.transaction, param.amount);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0AndLong0Amount, token1AndLong1Amount, !param.isLong0ToLong1, param.isLong0ToLong1);\n\n        // add a new process\n        // stores the token0 and token1 balance target required from the msg.sender to achieve.\n        Process storage currentProcess = (processing.push() = Process(\n            param.strike,\n            param.maturity,\n            param.isLong0ToLong1 ? IERC20(token0).balanceOf(address(this)) - token0AndLong0Amount : IERC20(token0).balanceOf(address(this)) + token0AndLong0Amount,\n            param.isLong0ToLong1 ? IERC20(token1).balanceOf(address(this)) + token1AndLong1Amount : IERC20(token1).balanceOf(address(this)) - token1AndLong1Amount\n        ));\n\n        // transfer token to recipient.\n        IERC20(param.isLong0ToLong1 ? token0 : token1).safeTransfer(param.tokenTo, param.isLong0ToLong1 ? token0AndLong0Amount : token1AndLong1Amount);\n\n        // ask the msg.sender to transfer token0 or token1 to this contract.\n        data = ITimeswapV2OptionSwapCallback(msg.sender).timeswapV2OptionSwapCallback(\n            TimeswapV2OptionSwapCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                isLong0ToLong1: param.isLong0ToLong1,\n                token0AndLong0Amount: token0AndLong0Amount,\n                token1AndLong1Amount: token1AndLong1Amount,\n                data: param.data\n            })\n        );\n\n        // check if the token0 or token1 balance target is achieved.\n        Error.checkEnough(IERC20(param.isLong0ToLong1 ? token1 : token0).balanceOf(address(this)), param.isLong0ToLong1 ? currentProcess.balance1Target : currentProcess.balance0Target);\n\n        if (param.isLong0ToLong1) option.long0[msg.sender] -= token0AndLong0Amount;\n        else option.long1[msg.sender] -= token1AndLong1Amount;\n\n        // finish the process.\n        processing.pop();\n\n        emit Swap(param.strike, param.maturity, msg.sender, param.tokenTo, param.longTo, param.isLong0ToLong1, token0AndLong0Amount, token1AndLong1Amount);\n    }\n\n    function collect(TimeswapV2OptionCollectParam calldata param) external override noDelegateCall returns (uint256 token0Amount, uint256 token1Amount, uint256 shortAmount, bytes memory data) {\n        if (!hasInteracted[param.strike][param.maturity]) Error.inactiveOptionChoice(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp());\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main collect logic calculation\n        (token0Amount, token1Amount, shortAmount) = option.collect(param.strike, param.transaction, param.amount);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0Amount, token1Amount, false, false);\n\n        // transfer token0 amount to recipient.\n        if (token0Amount != 0) IERC20(token0).safeTransfer(param.token0To, token0Amount);\n\n        // transfer token1 amount to recipient.\n        if (token1Amount != 0) IERC20(token1).safeTransfer(param.token1To, token1Amount);\n\n        // skip callback if there is no data.\n        if (param.data.length != 0)\n            data = ITimeswapV2OptionCollectCallback(msg.sender).timeswapV2OptionCollectCallback(\n                TimeswapV2OptionCollectCallbackParam({\n                    strike: param.strike,\n                    maturity: param.maturity,\n                    token0Amount: token0Amount,\n                    token1Amount: token1Amount,\n                    shortAmount: shortAmount,\n                    data: param.data\n                })\n            );\n\n        option.short[msg.sender] -= shortAmount;\n\n        emit Collect(param.strike, param.maturity, msg.sender, param.token0To, param.token1To, token0Amount, token1Amount, shortAmount);\n    }\n}"
    },
    {
      "filename": "packages/v2-option/src/TimeswapV2Option.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {Math} from \"@timeswap-labs/v2-library/src/Math.sol\";\nimport {Error} from \"@timeswap-labs/v2-library/src/Error.sol\";\n\nimport {NoDelegateCall} from \"./NoDelegateCall.sol\";\n\nimport {ITimeswapV2Option} from \"./interfaces/ITimeswapV2Option.sol\";\nimport {ITimeswapV2OptionDeployer} from \"./interfaces/ITimeswapV2OptionDeployer.sol\";\nimport {ITimeswapV2OptionMintCallback} from \"./interfaces/callbacks/ITimeswapV2OptionMintCallback.sol\";\nimport {ITimeswapV2OptionBurnCallback} from \"./interfaces/callbacks/ITimeswapV2OptionBurnCallback.sol\";\nimport {ITimeswapV2OptionSwapCallback} from \"./interfaces/callbacks/ITimeswapV2OptionSwapCallback.sol\";\nimport {ITimeswapV2OptionCollectCallback} from \"./interfaces/callbacks/ITimeswapV2OptionCollectCallback.sol\";\n\nimport {Option, OptionLibrary} from \"./structs/Option.sol\";\nimport {Process, ProcessLibrary} from \"./structs/Process.sol\";\nimport {StrikeAndMaturity} from \"./structs/StrikeAndMaturity.sol\";\n\nimport {TimeswapV2OptionPosition, PositionLibrary} from \"./enums/Position.sol\";\nimport {TimeswapV2OptionMint, TimeswapV2OptionBurn, TimeswapV2OptionSwap, TimeswapV2OptionCollect, TransactionLibrary} from \"./enums/Transaction.sol\";\n\nimport {TimeswapV2OptionMintParam, TimeswapV2OptionBurnParam, TimeswapV2OptionSwapParam, TimeswapV2OptionCollectParam, ParamLibrary} from \"./structs/Param.sol\";\nimport {TimeswapV2OptionMintCallbackParam, TimeswapV2OptionBurnCallbackParam, TimeswapV2OptionSwapCallbackParam, TimeswapV2OptionCollectCallbackParam} from \"./structs/CallbackParam.sol\";\n\n/// @title Timeswap V2 Options for a given pair\n/// @author Timeswap Labs\n/// @notice Holds the option of all strikes and maturies.\ncontract TimeswapV2Option is ITimeswapV2Option, NoDelegateCall {\n    using OptionLibrary for Option;\n    using ProcessLibrary for Process[];\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n\n    /* ===== MODEL ===== */\n\n    /// @inheritdoc ITimeswapV2Option\n    address public immutable override optionFactory;\n    /// @inheritdoc ITimeswapV2Option\n    address public immutable override token0;\n    /// @inheritdoc ITimeswapV2Option\n    address public immutable override token1;\n\n    /// @dev mapping of all option state for all strikes and maturies.\n    mapping(uint256 => mapping(uint256 => Option)) private options;\n    /// @dev Always start and end as an empty array for every transaction.\n    /// Process the token requirement for every option interaction call.\n    Process[] private processing;\n\n    mapping(uint256 => mapping(uint256 => bool)) private hasInteracted;\n    StrikeAndMaturity[] private listOfOptions;\n\n    function addOptionEnumerationIfNecessary(uint256 strike, uint256 maturity) private {\n        if (!hasInteracted[strike][maturity]) {\n            hasInteracted[strike][maturity] = true;\n            listOfOptions.push(StrikeAndMaturity({strike: strike, maturity: maturity}));\n        }\n    }\n\n    /* ===== INIT ===== */\n\n    constructor() NoDelegateCall() {\n        (optionFactory, token0, token1) = ITimeswapV2OptionDeployer(msg.sender).parameter();\n    }\n\n    // Can be overidden for testing purposes.\n    function blockTimestamp() internal view virtual returns (uint96) {\n        return uint96(block.timestamp); // truncation is desired\n    }\n\n    /* ===== VIEW ===== */\n\n    function getByIndex(uint256 id) external view override returns (StrikeAndMaturity memory) {\n        return listOfOptions[id];\n    }\n\n    function numberOfOptions() external view override returns (uint256) {\n        return listOfOptions.length;\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function totalPosition(uint256 strike, uint256 maturity, TimeswapV2OptionPosition position) external view override returns (uint256) {\n        return options[strike][maturity].totalPosition(strike, position);\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function positionOf(uint256 strike, uint256 maturity, address owner, TimeswapV2OptionPosition position) external view override returns (uint256) {\n        return options[strike][maturity].positionOf(owner, position);\n    }\n\n    /* ===== UPDATE ===== */\n\n    /// @inheritdoc ITimeswapV2Option\n    function transferPosition(uint256 strike, uint256 maturity, address to, TimeswapV2OptionPosition position, uint256 amount) external override {\n        if (!hasInteracted[strike][maturity]) Error.inactiveOptionChoice(strike, maturity);\n        if (to == address(0)) Error.zeroAddress();\n        if (amount == 0) Error.zeroInput();\n        PositionLibrary.check(position);\n\n        options[strike][maturity].transferPosition(to, position, amount);\n\n        emit TransferPosition(strike, maturity, msg.sender, to, position, amount);\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function mint(\n        TimeswapV2OptionMintParam calldata param\n    ) external override noDelegateCall returns (uint256 token0AndLong0Amount, uint256 token1AndLong1Amount, uint256 shortAmount, bytes memory data) {\n        ParamLibrary.check(param, blockTimestamp());\n        addOptionEnumerationIfNecessary(param.strike, param.maturity);\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main mint logic calculation\n        (token0AndLong0Amount, token1AndLong1Amount, shortAmount) = option.mint(param.strike, param.long0To, param.long1To, param.shortTo, param.transaction, param.amount0, param.amount1);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0AndLong0Amount, token1AndLong1Amount, true, true);\n\n        // add a new process\n        // stores the token0 and token1 balance target required from the msg.sender to achieve.\n        Process storage currentProcess = (processing.push() = Process(\n            param.strike,\n            param.maturity,\n            IERC20(token0).balanceOf(address(this)) + token0AndLong0Amount,\n            IERC20(token1).balanceOf(address(this)) + token1AndLong1Amount\n        ));\n\n        // ask the msg.sender to transfer token0 and/or token1 to this contract.\n        data = ITimeswapV2OptionMintCallback(msg.sender).timeswapV2OptionMintCallback(\n            TimeswapV2OptionMintCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                token0AndLong0Amount: token0AndLong0Amount,\n                token1AndLong1Amount: token1AndLong1Amount,\n                shortAmount: shortAmount,\n                data: param.data\n            })\n        );\n\n        // check if the token0 balance target is achieved.\n        if (token0AndLong0Amount != 0) Error.checkEnough(IERC20(token0).balanceOf(address(this)), currentProcess.balance0Target);\n\n        // check if the token1 balance target is achieved.\n        if (token1AndLong1Amount != 0) Error.checkEnough(IERC20(token1).balanceOf(address(this)), currentProcess.balance1Target);\n\n        // finish the process.\n        processing.pop();\n\n        emit Mint(param.strike, param.maturity, msg.sender, param.long0To, param.long1To, param.shortTo, token0AndLong0Amount, token1AndLong1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function burn(\n        TimeswapV2OptionBurnParam calldata param\n    ) external override noDelegateCall returns (uint256 token0AndLong0Amount, uint256 token1AndLong1Amount, uint256 shortAmount, bytes memory data) {\n        if (!hasInteracted[param.strike][param.maturity]) Error.inactiveOptionChoice(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp());\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main burn logic calculation\n        (token0AndLong0Amount, token1AndLong1Amount, shortAmount) = option.burn(param.strike, param.transaction, param.amount0, param.amount1);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0AndLong0Amount, token1AndLong1Amount, false, false);\n\n        // transfer token0 amount to recipient.\n        if (token0AndLong0Amount != 0) IERC20(token0).safeTransfer(param.token0To, token0AndLong0Amount);\n\n        // transfer token1 amount to recipient.\n        if (token1AndLong1Amount != 0) IERC20(token1).safeTransfer(param.token1To, token1AndLong1Amount);\n\n        // skip callback if there is no data.\n        if (param.data.length != 0)\n            data = ITimeswapV2OptionBurnCallback(msg.sender).timeswapV2OptionBurnCallback(\n                TimeswapV2OptionBurnCallbackParam({\n                    strike: param.strike,\n                    maturity: param.maturity,\n                    token0AndLong0Amount: token0AndLong0Amount,\n                    token1AndLong1Amount: token1AndLong1Amount,\n                    shortAmount: shortAmount,\n                    data: param.data\n                })\n            );\n\n        option.long0[msg.sender] -= token0AndLong0Amount;\n        option.long1[msg.sender] -= token1AndLong1Amount;\n        option.short[msg.sender] -= shortAmount;\n\n        emit Burn(param.strike, param.maturity, msg.sender, param.token0To, param.token1To, token0AndLong0Amount, token1AndLong1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function swap(TimeswapV2OptionSwapParam calldata param) external override noDelegateCall returns (uint256 token0AndLong0Amount, uint256 token1AndLong1Amount, bytes memory data) {\n        if (!hasInteracted[param.strike][param.maturity]) Error.inactiveOptionChoice(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp());\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main swap logic calculation\n        (token0AndLong0Amount, token1AndLong1Amount) = option.swap(param.strike, param.longTo, param.isLong0ToLong1, param.transaction, param.amount);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0AndLong0Amount, token1AndLong1Amount, !param.isLong0ToLong1, param.isLong0ToLong1);\n\n        // add a new process\n        // stores the token0 and token1 balance target required from the msg.sender to achieve.\n        Process storage currentProcess = (processing.push() = Process(\n            param.strike,\n            param.maturity,\n            param.isLong0ToLong1 ? IERC20(token0).balanceOf(address(this)) - token0AndLong0Amount : IERC20(token0).balanceOf(address(this)) + token0AndLong0Amount,\n            param.isLong0ToLong1 ? IERC20(token1).balanceOf(address(this)) + token1AndLong1Amount : IERC20(token1).balanceOf(address(this)) - token1AndLong1Amount\n        ));\n\n        // transfer token to recipient.\n        IERC20(param.isLong0ToLong1 ? token0 : token1).safeTransfer(param.tokenTo, param.isLong0ToLong1 ? token0AndLong0Amount : token1AndLong1Amount);\n\n        // ask the msg.sender to transfer token0 or token1 to this contract.\n        data = ITimeswapV2OptionSwapCallback(msg.sender).timeswapV2OptionSwapCallback(\n            TimeswapV2OptionSwapCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                isLong0ToLong1: param.isLong0ToLong1,\n                token0AndLong0Amount: token0AndLong0Amount,\n                token1AndLong1Amount: token1AndLong1Amount,\n                data: param.data\n            })\n        );\n\n        // check if the token0 or token1 balance target is achieved.\n        Error.checkEnough(IERC20(param.isLong0ToLong1 ? token1 : token0).balanceOf(address(this)), param.isLong0ToLong1 ? currentProcess.balance1Target : currentProcess.balance0Target);\n\n        if (param.isLong0ToLong1) option.long0[msg.sender] -= token0AndLong0Amount;\n        else option.long1[msg.sender] -= token1AndLong1Amount;\n\n        // finish the process.\n        processing.pop();\n\n        emit Swap(param.strike, param.maturity, msg.sender, param.tokenTo, param.longTo, param.isLong0ToLong1, token0AndLong0Amount, token1AndLong1Amount);\n    }\n\n    function collect(TimeswapV2OptionCollectParam calldata param) external override noDelegateCall returns (uint256 token0Amount, uint256 token1Amount, uint256 shortAmount, bytes memory data) {\n        if (!hasInteracted[param.strike][param.maturity]) Error.inactiveOptionChoice(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp());\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main collect logic calculation\n        (token0Amount, token1Amount, shortAmount) = option.collect(param.strike, param.transaction, param.amount);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0Amount, token1Amount, false, false);\n\n        // transfer token0 amount to recipient.\n        if (token0Amount != 0) IERC20(token0).safeTransfer(param.token0To, token0Amount);\n\n        // transfer token1 amount to recipient.\n        if (token1Amount != 0) IERC20(token1).safeTransfer(param.token1To, token1Amount);\n\n        // skip callback if there is no data.\n        if (param.data.length != 0)\n            data = ITimeswapV2OptionCollectCallback(msg.sender).timeswapV2OptionCollectCallback(\n                TimeswapV2OptionCollectCallbackParam({\n                    strike: param.strike,\n                    maturity: param.maturity,\n                    token0Amount: token0Amount,\n                    token1Amount: token1Amount,\n                    shortAmount: shortAmount,\n                    data: param.data\n                })\n            );\n\n        option.short[msg.sender] -= shortAmount;\n\n        emit Collect(param.strike, param.maturity, msg.sender, param.token0To, param.token1To, token0Amount, token1Amount, shortAmount);\n    }\n}"
    },
    {
      "filename": "packages/v2-option/src/TimeswapV2Option.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {Math} from \"@timeswap-labs/v2-library/src/Math.sol\";\nimport {Error} from \"@timeswap-labs/v2-library/src/Error.sol\";\n\nimport {NoDelegateCall} from \"./NoDelegateCall.sol\";\n\nimport {ITimeswapV2Option} from \"./interfaces/ITimeswapV2Option.sol\";\nimport {ITimeswapV2OptionDeployer} from \"./interfaces/ITimeswapV2OptionDeployer.sol\";\nimport {ITimeswapV2OptionMintCallback} from \"./interfaces/callbacks/ITimeswapV2OptionMintCallback.sol\";\nimport {ITimeswapV2OptionBurnCallback} from \"./interfaces/callbacks/ITimeswapV2OptionBurnCallback.sol\";\nimport {ITimeswapV2OptionSwapCallback} from \"./interfaces/callbacks/ITimeswapV2OptionSwapCallback.sol\";\nimport {ITimeswapV2OptionCollectCallback} from \"./interfaces/callbacks/ITimeswapV2OptionCollectCallback.sol\";\n\nimport {Option, OptionLibrary} from \"./structs/Option.sol\";\nimport {Process, ProcessLibrary} from \"./structs/Process.sol\";\nimport {StrikeAndMaturity} from \"./structs/StrikeAndMaturity.sol\";\n\nimport {TimeswapV2OptionPosition, PositionLibrary} from \"./enums/Position.sol\";\nimport {TimeswapV2OptionMint, TimeswapV2OptionBurn, TimeswapV2OptionSwap, TimeswapV2OptionCollect, TransactionLibrary} from \"./enums/Transaction.sol\";\n\nimport {TimeswapV2OptionMintParam, TimeswapV2OptionBurnParam, TimeswapV2OptionSwapParam, TimeswapV2OptionCollectParam, ParamLibrary} from \"./structs/Param.sol\";\nimport {TimeswapV2OptionMintCallbackParam, TimeswapV2OptionBurnCallbackParam, TimeswapV2OptionSwapCallbackParam, TimeswapV2OptionCollectCallbackParam} from \"./structs/CallbackParam.sol\";\n\n/// @title Timeswap V2 Options for a given pair\n/// @author Timeswap Labs\n/// @notice Holds the option of all strikes and maturies.\ncontract TimeswapV2Option is ITimeswapV2Option, NoDelegateCall {\n    using OptionLibrary for Option;\n    using ProcessLibrary for Process[];\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n\n    /* ===== MODEL ===== */\n\n    /// @inheritdoc ITimeswapV2Option\n    address public immutable override optionFactory;\n    /// @inheritdoc ITimeswapV2Option\n    address public immutable override token0;\n    /// @inheritdoc ITimeswapV2Option\n    address public immutable override token1;\n\n    /// @dev mapping of all option state for all strikes and maturies.\n    mapping(uint256 => mapping(uint256 => Option)) private options;\n    /// @dev Always start and end as an empty array for every transaction.\n    /// Process the token requirement for every option interaction call.\n    Process[] private processing;\n\n    mapping(uint256 => mapping(uint256 => bool)) private hasInteracted;\n    StrikeAndMaturity[] private listOfOptions;\n\n    function addOptionEnumerationIfNecessary(uint256 strike, uint256 maturity) private {\n        if (!hasInteracted[strike][maturity]) {\n            hasInteracted[strike][maturity] = true;\n            listOfOptions.push(StrikeAndMaturity({strike: strike, maturity: maturity}));\n        }\n    }\n\n    /* ===== INIT ===== */\n\n    constructor() NoDelegateCall() {\n        (optionFactory, token0, token1) = ITimeswapV2OptionDeployer(msg.sender).parameter();\n    }\n\n    // Can be overidden for testing purposes.\n    function blockTimestamp() internal view virtual returns (uint96) {\n        return uint96(block.timestamp); // truncation is desired\n    }\n\n    /* ===== VIEW ===== */\n\n    function getByIndex(uint256 id) external view override returns (StrikeAndMaturity memory) {\n        return listOfOptions[id];\n    }\n\n    function numberOfOptions() external view override returns (uint256) {\n        return listOfOptions.length;\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function totalPosition(uint256 strike, uint256 maturity, TimeswapV2OptionPosition position) external view override returns (uint256) {\n        return options[strike][maturity].totalPosition(strike, position);\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function positionOf(uint256 strike, uint256 maturity, address owner, TimeswapV2OptionPosition position) external view override returns (uint256) {\n        return options[strike][maturity].positionOf(owner, position);\n    }\n\n    /* ===== UPDATE ===== */\n\n    /// @inheritdoc ITimeswapV2Option\n    function transferPosition(uint256 strike, uint256 maturity, address to, TimeswapV2OptionPosition position, uint256 amount) external override {\n        if (!hasInteracted[strike][maturity]) Error.inactiveOptionChoice(strike, maturity);\n        if (to == address(0)) Error.zeroAddress();\n        if (amount == 0) Error.zeroInput();"
    }
  ]
}