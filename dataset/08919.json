{
  "Title": "[M-09] in notifyRewardAmount() of VE3DRewardPool and BaseRewardPool some tokes will be locked and not distributed becasue of rounding error",
  "Content": "_Submitted by unforgiven_\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/BaseRewardPool.sol#L327-L345>\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DRewardPool.sol#L367-L384>\n\n### Impact\n\nFunction `notifyRewardAmount()` calculates `rewardRate` for reward token/s in `VE3DRewardPool` and `BaseRewardPool`. to calculate `rewardRate` it divides `reward` amount to `duration` but because of the rounding error in division, some of `reward` amount wouldn't get distributed and stuck in contract (`rewardRate * duration < reward`). and contract don't redistributes them or don't have any mechanism to recover them. This bug can be more damaging if the precision of `rewardToken` is low or token price is high.\n\n### Proof of Concept\n\nThis is `notifyRewardAmount()` code in `BaseRewardPool`: (contract `VE3DRewardPool` is similar)\n\n        function notifyRewardAmount(uint256 reward) internal updateReward(address(0)) {\n            historicalRewards = historicalRewards.add(reward);\n            if (block.timestamp >= periodFinish) {\n                rewardRate = reward.div(duration);\n            } else {\n                uint256 remaining = periodFinish.sub(block.timestamp);\n                uint256 leftover = remaining.mul(rewardRate);\n                reward = reward.add(leftover);\n                rewardRate = reward.div(duration);\n            }\n            currentRewards = reward;\n            lastUpdateTime = block.timestamp;\n            periodFinish = block.timestamp.add(duration);\n            emit RewardAdded(reward);\n        }\n\nAs you can see it sets `rewardRate = reward.div(duration);` and this is where the rounding error happens. and even if contract distributes all in all the duration it will distribute `rewardRate * duration` which can be lower than `reward` and the extra reward amount will stuck in contract. This is `queueNewRewards()` code which calls `notifyRewardAmount()`:\n\n        function queueNewRewards(uint256 _rewards) external returns (bool) {\n            require(msg.sender == operator, \"!authorized\");\n\n            _rewards = _rewards.add(queuedRewards);\n\n            if (block.timestamp >= periodFinish) {\n                notifyRewardAmount(_rewards);\n                queuedRewards = 0;\n                return true;\n            }\n\n            //et = now - (finish-duration)\n            uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));\n            //current at now: rewardRate * elapsedTime\n            uint256 currentAtNow = rewardRate * elapsedTime;\n            uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n\n            //uint256 queuedRatio = currentRewards.mul(1000).div(_rewards);\n            if (queuedRatio < newRewardRatio) {\n                notifyRewardAmount(_rewards);\n                queuedRewards = 0;\n            } else {\n                queuedRewards = _rewards;\n            }\n            return true;\n        }\n\nAs you can see it queues `rewardToken`  and when the reward amount reach some point it calls `notifyRewardAmount()` and set `queuedRewards`  to `0x0`. `notifyRewardAmount()` will set `rewardRate` based on `reward amount` but because of the rounding error some of the reward token `0 =< unused < duration` will stuck in contract and pool will not distribute it. if the token has low precision or has higher price then this amount value can be very big because `notifyRewardAmount()` can be called multiple times.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nadd extra amount to `queuedRewards` so it would be distributed on next `notifyRewardAmount()` or add other mechanism to recover it.\n\n**[solvetony (veToken Finance) disagreed with severity and commented](https://github.com/code-423n4/2022-05-vetoken-findings/issues/165#issuecomment-1156647102):**\n > Will be fixed by two solutions, adding precision and by adding another function. Middle risk.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-05-vetoken-findings/issues/165#issuecomment-1193398878):**\n > The warden has shown how, due to rounding errors, `rewardRate` may round down and cause a certain amount of tokens not to be distributed.\n> \n> In lack of a way for the `operator` to re-queue the undistributed rewards, those tokens will be lost.\n> \n> Because we know `duration` is `604800` we can see that the `rewardRate` max loss is `604799`.\n> \n> Meaning the potential max dust due to rounding down can be upwards of a number with 12 decimals<br>\n> <img width=\"239\" alt=\"Screenshot 2022-07-24 at 23 38 33\" src=\"https://user-images.githubusercontent.com/13383782/180666870-ce02ff32-84d5-4d8c-9dc1-cc0bf9d5ef9b.png\">\n> \n> \n> Because the finding is limited to loss of Yield, I believe Medium Severity to be more appropriate.\n> \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-vetoken-finance-contest",
  "Code": [
    {
      "filename": "contracts/BaseRewardPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n/**\n *Submitted for verification at Etherscan.io on 2020-07-17\n */\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: BaseRewardPool.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IRewards.sol\";\nimport \"./Interfaces/IDeposit.sol\";\n\ncontract BaseRewardPool {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public rewardToken;\n    IERC20 public stakingToken;\n    uint256 public constant duration = 7 days;\n    uint256 constant BLOCKS_PER_DAY = 6450;\n    uint256 constant BLOCKS_PER_YEAR = BLOCKS_PER_DAY * 365;\n    uint256 constant EXTRA_REWARD_POOLS = 3;\n\n    address public operator;\n    address public rewardManager;\n\n    uint256 public pid;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 public queuedRewards = 0;\n    uint256 public currentRewards = 0;\n    uint256 public historicalRewards = 0;\n    uint256 public constant newRewardRatio = 830;\n    uint256 private _totalSupply;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) private _balances;\n\n    address[] public extraRewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event ExtraRewardAdded(address indexed reward);\n    event ExtraRewardCleared();\n    event RewardUpdated(\n        address indexed user,\n        uint256 reward,\n        uint256 rewardPerTokenStored,\n        uint256 lastUpdateTime\n    );\n    event Donated(uint256 queuedRewards);\n\n    constructor(\n        uint256 pid_,\n        address stakingToken_,\n        address rewardToken_,\n        address operator_,\n        address rewardManager_\n    ) {\n        pid = pid_;\n        stakingToken = IERC20(stakingToken_);\n        rewardToken = IERC20(rewardToken_);\n        operator = operator_;\n        rewardManager = rewardManager_;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    function addExtraReward(address _reward) external returns (bool) {\n        require(msg.sender == rewardManager, \"!authorized\");\n        require(_reward != address(0), \"!reward setting\");\n        require(extraRewards.length < EXTRA_REWARD_POOLS, \"!extra reward pools exceed\");\n\n        extraRewards.push(_reward);\n        emit ExtraRewardAdded(_reward);\n        return true;\n    }\n\n    function clearExtraRewards() external {\n        require(msg.sender == rewardManager, \"!authorized\");\n        delete extraRewards;\n        emit ExtraRewardCleared();\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        emit RewardUpdated(account, rewards[account], rewardPerTokenStored, lastUpdateTime);\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(\n                    totalSupply()\n                )\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    function stake(uint256 _amount) public updateReward(msg.sender) returns (bool) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        for (uint256 i = 0; i < extraRewards.length; i++) {\n            IRewards(extraRewards[i]).stake(msg.sender, _amount);\n        }\n\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[msg.sender] = _balances[msg.sender].add(_amount);\n\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(msg.sender, _amount);\n\n        return true;\n    }\n\n    function stakeAll() external returns (bool) {\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n        return true;\n    }\n\n    function stakeFor(address _for, uint256 _amount) public updateReward(_for) returns (bool) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        for (uint256 i = 0; i < extraRewards.length; i++) {\n            IRewards(extraRewards[i]).stake(_for, _amount);\n        }\n\n        //give to _for\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[_for] = _balances[_for].add(_amount);\n\n        //take away from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(_for, _amount);\n\n        return true;\n    }\n\n    function withdraw(uint256 amount, bool claim) public updateReward(msg.sender) returns (bool) {\n        require(amount > 0, \"RewardPool : Cannot withdraw 0\");\n\n        //also withdraw from linked rewards\n        for (uint256 i = 0; i < extraRewards.length; i++) {\n            IRewards(extraRewards[i]).withdraw(msg.sender, amount);\n        }\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n\n        if (claim) {\n            getReward(msg.sender, true);\n        }\n\n        return true;\n    }\n\n    function withdrawAll(bool claim) external {\n        withdraw(_balances[msg.sender], claim);\n    }\n\n    function withdrawAndUnwrap(uint256 amount, bool claim)\n        public\n        updateReward(msg.sender)\n        returns (bool)\n    {\n        //also withdraw from linked rewards\n        for (uint256 i = 0; i < extraRewards.length; i++) {\n            IRewards(extraRewards[i]).withdraw(msg.sender, amount);\n        }\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        //tell operator to withdraw from here directly to user\n        IDeposit(operator).withdrawTo(pid, amount, msg.sender);\n        emit Withdrawn(msg.sender, amount);\n\n        //get rewards too\n        if (claim) {\n            getReward(msg.sender, true);\n        }\n        return true;\n    }\n\n    function withdrawAllAndUnwrap(bool claim) external {\n        withdrawAndUnwrap(_balances[msg.sender], claim);\n    }\n\n    function getReward(address _account, bool _claimExtras)\n        public\n        updateReward(_account)\n        returns (bool)\n    {\n        uint256 reward = earned(_account);\n        if (reward > 0) {\n            rewards[_account] = 0;\n            rewardToken.safeTransfer(_account, reward);\n            IDeposit(operator).rewardClaimed(pid, _account, reward);\n            emit RewardPaid(_account, reward);\n        }\n\n        //also get rewards from linked rewards\n        if (_claimExtras) {\n            for (uint256 i = 0; i < extraRewards.length; i++) {\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n        return true;\n    }\n\n    function getReward() external returns (bool) {\n        getReward(msg.sender, true);\n        return true;\n    }\n\n    function donate(uint256 _amount) external {\n        IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), _amount);\n        queuedRewards = queuedRewards.add(_amount);\n        emit Donated(queuedRewards);\n    }\n\n    function queueNewRewards(uint256 _rewards) external returns (bool) {\n        require(msg.sender == operator, \"!authorized\");\n\n        _rewards = _rewards.add(queuedRewards);\n\n        if (block.timestamp >= periodFinish) {\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n            return true;\n        }\n\n        //et = now - (finish-duration)\n        uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));\n        //current at now: rewardRate * elapsedTime\n        uint256 currentAtNow = rewardRate * elapsedTime;\n        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n\n        //uint256 queuedRatio = currentRewards.mul(1000).div(_rewards);\n        if (queuedRatio < newRewardRatio) {\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n        } else {\n            queuedRewards = _rewards;\n        }\n        return true;\n    }\n\n    function notifyRewardAmount(uint256 reward) internal updateReward(address(0)) {\n        historicalRewards = historicalRewards.add(reward);\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            reward = reward.add(leftover);\n            rewardRate = reward.div(duration);\n        }\n        currentRewards = reward;\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n\n    function getAPY() external view returns (uint256) {\n        return rewardRate.mul(BLOCKS_PER_YEAR).mul(1e18).div(totalSupply());\n    }\n}"
    },
    {
      "filename": "contracts/VE3DRewardPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n/**\n *Submitted for verification at Etherscan.io on 2020-07-17\n */\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: vetokenRewardPool.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./Interfaces/IVeAssetDeposit.sol\";\nimport \"./Interfaces/IRewards.sol\";\n\ncontract VE3DRewardPool is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    IERC20 public immutable stakingToken;\n    uint256 public constant duration = 7 days;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    address public immutable rewardManager;\n\n    uint256 public constant newRewardRatio = 830;\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    // reward token => reward token info\n    mapping(address => RewardTokenInfo) public rewardTokenInfo;\n    // list of reward tokens\n    EnumerableSet.AddressSet internal rewardTokens;\n    EnumerableSet.AddressSet internal operators;\n\n    address[] public extraRewards;\n\n    struct RewardTokenInfo {\n        address veAssetDeposits;\n        address ve3TokenRewards;\n        address ve3Token;\n        uint256 queuedRewards;\n        uint256 rewardRate;\n        uint256 historicalRewards;\n        uint256 rewardPerTokenStored;\n        uint256 currentRewards;\n        uint256 periodFinish;\n        uint256 lastUpdateTime;\n        mapping(address => uint256) userRewardPerTokenPaid;\n        mapping(address => uint256) rewards;\n    }\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    constructor(address stakingToken_, address rewardManager_) {\n        stakingToken = IERC20(stakingToken_);\n\n        rewardManager = rewardManager_;\n    }\n\n    function addReward(\n        address _rewardToken,\n        address _veAssetDeposits,\n        address _ve3TokenRewards,\n        address _ve3Token\n    ) external onlyOwner {\n        rewardTokenInfo[_rewardToken].veAssetDeposits = _veAssetDeposits;\n        rewardTokenInfo[_rewardToken].ve3TokenRewards = _ve3TokenRewards;\n        rewardTokenInfo[_rewardToken].ve3Token = _ve3Token;\n        rewardTokens.add(_rewardToken);\n    }\n\n    function addOperator(address _newOperator) public onlyOwner {\n        operators.add(_newOperator);\n    }\n\n    function removeOperator(address _operator) public onlyOwner {\n        operators.remove(_operator);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    function addExtraReward(address _reward) external {\n        require(msg.sender == rewardManager, \"!authorized\");\n        require(_reward != address(0), \"!reward setting\");\n\n        extraRewards.push(_reward);\n    }\n\n    function clearExtraRewards() external {\n        require(msg.sender == rewardManager, \"!authorized\");\n        delete extraRewards;\n    }\n\n    modifier updateReward(address account) {\n        address _rewardToken;\n        for (uint256 i = 0; i < rewardTokens.length(); i++) {\n            _rewardToken = rewardTokens.at(i);\n            rewardTokenInfo[_rewardToken].rewardPerTokenStored = rewardPerToken(_rewardToken);\n            rewardTokenInfo[_rewardToken].lastUpdateTime = lastTimeRewardApplicable(_rewardToken);\n            if (account != address(0)) {\n                rewardTokenInfo[_rewardToken].rewards[account] = earnedReward(\n                    _rewardToken,\n                    account\n                );\n                rewardTokenInfo[_rewardToken].userRewardPerTokenPaid[account] = rewardTokenInfo[\n                    _rewardToken\n                ].rewardPerTokenStored;\n            }\n        }\n\n        _;\n    }\n\n    function lastTimeRewardApplicable(address _rewardToken) public view returns (uint256) {\n        return Math.min(block.timestamp, rewardTokenInfo[_rewardToken].periodFinish);\n    }\n\n    function rewardPerToken(address _rewardToken) public view returns (uint256) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            return rewardTokenInfo[_rewardToken].rewardPerTokenStored;\n        }\n        return\n            rewardTokenInfo[_rewardToken].rewardPerTokenStored.add(\n                lastTimeRewardApplicable(_rewardToken)\n                    .sub(rewardTokenInfo[_rewardToken].lastUpdateTime)\n                    .mul(rewardTokenInfo[_rewardToken].rewardRate)\n                    .mul(1e18)\n                    .div(supply)\n            );\n    }\n\n    function earnedReward(address _rewardToken, address account) internal view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(\n                    rewardPerToken(_rewardToken).sub(\n                        rewardTokenInfo[_rewardToken].userRewardPerTokenPaid[account]\n                    )\n                )\n                .div(1e18)\n                .add(rewardTokenInfo[_rewardToken].rewards[account]);\n    }\n\n    function earned(address _rewardToken, address account) external view returns (uint256) {\n        uint256 depositFeeRate = IVeAssetDeposit(rewardTokenInfo[_rewardToken].veAssetDeposits)\n            .lockIncentive();\n\n        uint256 r = earnedReward(_rewardToken, account);\n        uint256 fees = r.mul(depositFeeRate).div(FEE_DENOMINATOR);\n\n        //fees dont apply until whitelist+veVeAsset lock begins so will report\n        //slightly less value than what is actually received.\n        return r.sub(fees);\n    }\n\n    function stake(uint256 _amount) public updateReward(msg.sender) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).stake(msg.sender, _amount);\n        }\n\n        //add supply\n        _totalSupply = _totalSupply.add(_amount);\n        //add to sender balance sheet\n        _balances[msg.sender] = _balances[msg.sender].add(_amount);\n        //take tokens from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit Staked(msg.sender, _amount);\n    }\n\n    function stakeAll() external {\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n    }\n\n    function stakeFor(address _for, uint256 _amount) public updateReward(_for) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).stake(_for, _amount);\n        }\n\n        //add supply\n        _totalSupply = _totalSupply.add(_amount);\n        //add to _for's balance sheet\n        _balances[_for] = _balances[_for].add(_amount);\n        //take tokens from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit Staked(msg.sender, _amount);\n    }\n\n    function withdraw(uint256 _amount, bool claim) public updateReward(msg.sender) {\n        require(_amount > 0, \"RewardPool : Cannot withdraw 0\");\n\n        //also withdraw from linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).withdraw(msg.sender, _amount);\n        }\n\n        _totalSupply = _totalSupply.sub(_amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(_amount);\n        stakingToken.safeTransfer(msg.sender, _amount);\n        emit Withdrawn(msg.sender, _amount);\n\n        if (claim) {\n            getReward(msg.sender, true, false);\n        }\n    }\n\n    function withdrawAll(bool claim) external {\n        withdraw(_balances[msg.sender], claim);\n    }\n\n    function getReward(\n        address _account,\n        bool _claimExtras,\n        bool _stake\n    ) public updateReward(_account) {\n        address _rewardToken;\n        for (uint256 i = 0; i < rewardTokens.length(); i++) {\n            _rewardToken = rewardTokens.at(i);\n\n            uint256 reward = earnedReward(_rewardToken, _account);\n            if (reward > 0) {\n                rewardTokenInfo[_rewardToken].rewards[_account] = 0;\n                IERC20(_rewardToken).safeApprove(rewardTokenInfo[_rewardToken].veAssetDeposits, 0);\n                IERC20(_rewardToken).safeApprove(\n                    rewardTokenInfo[_rewardToken].veAssetDeposits,\n                    reward\n                );\n                IVeAssetDeposit(rewardTokenInfo[_rewardToken].veAssetDeposits).deposit(\n                    reward,\n                    false\n                );\n\n                uint256 ve3TokenBalance = IERC20(rewardTokenInfo[_rewardToken].ve3Token).balanceOf(\n                    address(this)\n                );\n                if (_stake) {\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeApprove(\n                        rewardTokenInfo[_rewardToken].ve3TokenRewards,\n                        0\n                    );\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeApprove(\n                        rewardTokenInfo[_rewardToken].ve3TokenRewards,\n                        ve3TokenBalance\n                    );\n                    IRewards(rewardTokenInfo[_rewardToken].ve3TokenRewards).stakeFor(\n                        _account,\n                        ve3TokenBalance\n                    );\n                } else {\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeTransfer(\n                        _account,\n                        ve3TokenBalance\n                    );\n                }\n                emit RewardPaid(_account, ve3TokenBalance);\n            }\n        }\n\n        //also get rewards from linked rewards\n        if (_claimExtras) {\n            uint256 length = extraRewards.length;\n            for (uint256 i = 0; i < length; i++) {\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n    }\n\n    function getReward(bool _stake) external {\n        getReward(msg.sender, true, _stake);\n    }\n\n    function donate(address _rewardToken, uint256 _amount) external {\n        IERC20(_rewardToken).safeTransferFrom(msg.sender, address(this), _amount);\n        rewardTokenInfo[_rewardToken].queuedRewards += _amount;\n    }\n\n    function queueNewRewards(address _rewardToken, uint256 _rewards) external {\n        require(operators.contains(_msgSender()), \"!authorized\");\n\n        _rewards = _rewards.add(rewardTokenInfo[_rewardToken].queuedRewards);\n\n        if (block.timestamp >= rewardTokenInfo[_rewardToken].periodFinish) {\n            notifyRewardAmount(_rewardToken, _rewards);\n            rewardTokenInfo[_rewardToken].queuedRewards = 0;\n            return;\n        }\n\n        //et = now - (finish-duration)\n        uint256 elapsedTime = block.timestamp.sub(\n            rewardTokenInfo[_rewardToken].periodFinish.sub(duration)\n        );\n        //current at now: rewardRate * elapsedTime\n        uint256 currentAtNow = rewardTokenInfo[_rewardToken].rewardRate * elapsedTime;\n        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n        if (queuedRatio < newRewardRatio) {\n            notifyRewardAmount(_rewardToken, _rewards);\n            rewardTokenInfo[_rewardToken].queuedRewards = 0;\n        } else {\n            rewardTokenInfo[_rewardToken].queuedRewards = _rewards;\n        }\n    }\n\n    function notifyRewardAmount(address _rewardToken, uint256 reward)\n        internal\n        updateReward(address(0))\n    {\n        rewardTokenInfo[_rewardToken].historicalRewards += reward;\n        if (block.timestamp >= rewardTokenInfo[_rewardToken].periodFinish) {\n            rewardTokenInfo[_rewardToken].rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = rewardTokenInfo[_rewardToken].periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardTokenInfo[_rewardToken].rewardRate);\n            reward = reward.add(leftover);\n            rewardTokenInfo[_rewardToken].rewardRate = reward.div(duration);\n        }\n        rewardTokenInfo[_rewardToken].currentRewards = reward;\n        rewardTokenInfo[_rewardToken].lastUpdateTime = block.timestamp;\n        rewardTokenInfo[_rewardToken].periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n}"
    }
  ]
}