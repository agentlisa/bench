{
  "Title": "[M-05] The settledPrice maybe exceed maximumPrice",
  "Content": "# Lines of code\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/BuyCrowdfundBase.sol#L122\n\n\n# Vulnerability details\n\n## Impact\n\nBuyCrowdfundBase.sol _buy()\nWhen callValue = 0 is settledPrice to totalContributions ignoring whether totalContributions > maximumPrice\nresulting in the minimum proportion of participants expected to become smaller\n\n## Proof of Concept\n```\n    function _buy(\n        IERC721 token,\n        uint256 tokenId,\n        address payable callTarget,\n        uint96 callValue,\n        bytes calldata callData,\n        FixedGovernanceOpts memory governanceOpts\n    )\n    ...\n            settledPrice_ = callValue == 0 ? totalContributions : callValue;  //**** not check totalContributions>maximumPrice****//\n            if (settledPrice_ == 0) {\n                // Still zero, which means no contributions.\n                revert NoContributionsError();\n            }\n            settledPrice = settledPrice_;    \n```\n\n(AuctionCrowdfund.sol finalize()  similar)\n\n## Recommended Mitigation Steps\nadd check\n\n```\n    function _buy(\n        IERC721 token,\n        uint256 tokenId,\n        address payable callTarget,\n        uint96 callValue,\n        bytes calldata callData,\n        FixedGovernanceOpts memory governanceOpts\n    )\n    ...\n            settledPrice_ = callValue == 0 ? totalContributions : callValue;\n            if (settledPrice_ == 0) {\n                // Still zero, which means no contributions.\n                revert NoContributionsError();\n            }\n\n+++         if (maximumPrice_ != 0 && settledPrice_ > maximumPrice_) {\n+++                settledPrice_ = maximumPrice_;\n+++         }\n\n            settledPrice = settledPrice_;    \n```\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-09-partydao-contest",
  "Code": [
    {
      "filename": "contracts/crowdfund/BuyCrowdfundBase.sol",
      "content": "// SPDX-License-Identifier: Beta Software\npragma solidity ^0.8;\n\nimport \"../tokens/IERC721.sol\";\nimport \"../party/Party.sol\";\nimport \"../utils/Implementation.sol\";\nimport \"../utils/LibSafeERC721.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\nimport \"./Crowdfund.sol\";\n\n// Base for BuyCrowdfund and CollectionBuyCrowdfund\nabstract contract BuyCrowdfundBase is Implementation, Crowdfund {\n    using LibSafeERC721 for IERC721;\n    using LibSafeCast for uint256;\n    using LibRawResult for bytes;\n\n    struct BuyCrowdfundBaseOptions {\n        // The name of the crowdfund.\n        // This will also carry over to the governance party.\n        string name;\n        // The token symbol for both the crowdfund and the governance NFTs.\n        string symbol;\n        // How long this crowdfund has to bid on the NFT, in seconds.\n        uint40 duration;\n        // Maximum amount this crowdfund will pay for the NFT.\n        // If zero, no maximum.\n        uint96 maximumPrice;\n        // An address that receieves an extra share of the final voting power\n        // when the party transitions into governance.\n        address payable splitRecipient;\n        // What percentage (in bps) of the final total voting power `splitRecipient`\n        // receives.\n        uint16 splitBps;\n        // If ETH is attached during deployment, it will be interpreted\n        // as a contribution. This is who gets credit for that contribution.\n        address initialContributor;\n        // If there is an initial contribution, this is who they will delegate their\n        // voting power to when the crowdfund transitions to governance.\n        address initialDelegate;\n        // The gatekeeper contract to use (if non-null) to restrict who can\n        // contribute to this crowdfund.\n        IGateKeeper gateKeeper;\n        // The gatekeeper contract to use (if non-null).\n        bytes12 gateKeeperId;\n        // Governance options.\n        FixedGovernanceOpts governanceOpts;\n    }\n\n    event Won(Party party, IERC721 token, uint256 tokenId, uint256 settledPrice);\n\n    error MaximumPriceError(uint96 callValue, uint96 maximumPrice);\n    error NoContributionsError();\n    error FailedToBuyNFTError(IERC721 token, uint256 tokenId);\n    error InvalidCallTargetError(address callTarget);\n\n    /// @notice When this crowdfund expires.\n    uint40 public expiry;\n    /// @notice Maximum amount this crowdfund will pay for the NFT. If zero, no maximum.\n    uint96 public maximumPrice;\n    /// @notice What the NFT was actually bought for.\n    uint96 public settledPrice;\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) Crowdfund(globals) {}\n\n    // Initialize storage for proxy contracts.\n    function _initialize(BuyCrowdfundBaseOptions memory opts)\n        internal\n    {\n        expiry = uint40(opts.duration + block.timestamp);\n        maximumPrice = opts.maximumPrice;\n        Crowdfund._initialize(CrowdfundOptions({\n            name: opts.name,\n            symbol: opts.symbol,\n            splitRecipient: opts.splitRecipient,\n            splitBps: opts.splitBps,\n            initialContributor: opts.initialContributor,\n            initialDelegate: opts.initialDelegate,\n            gateKeeper: opts.gateKeeper,\n            gateKeeperId: opts.gateKeeperId,\n            governanceOpts: opts.governanceOpts\n        }));\n    }\n\n    // Execute arbitrary calldata to perform a buy, creating a party\n    // if it successfully buys the NFT.\n    function _buy(\n        IERC721 token,\n        uint256 tokenId,\n        address payable callTarget,\n        uint96 callValue,\n        bytes calldata callData,\n        FixedGovernanceOpts memory governanceOpts\n    )\n        internal\n        onlyDelegateCall\n        returns (Party party_)\n    {\n        // Ensure the call target isn't trying to reenter or trying to do\n        // anything weird with `PartyFactory`.\n        IPartyFactory partyFactory = _getPartyFactory();\n        if (callTarget == address(partyFactory) || callTarget == address(this)) {\n            revert InvalidCallTargetError(callTarget);\n        }\n        // Check that the crowdfund is still active.\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        if (lc != CrowdfundLifecycle.Active) {\n            revert WrongLifecycleError(lc);\n        }\n        // Used to store the price the NFT was bought for.\n        uint96 settledPrice_;\n        {\n            uint96 maximumPrice_ = maximumPrice;\n            if (maximumPrice_ != 0 && callValue > maximumPrice_) {\n                revert MaximumPriceError(callValue, maximumPrice);\n            }\n            // If the purchase would be free, set the settled price to\n            // `totalContributions` so everybody who contributed wins.\n            settledPrice_ = callValue == 0 ? totalContributions : callValue;\n            if (settledPrice_ == 0) {\n                // Still zero, which means no contributions.\n                revert NoContributionsError();\n            }\n            settledPrice = settledPrice_;\n        }\n        {\n            // Execute the call to buy the NFT.\n            (bool s, bytes memory r) = callTarget.call{ value: callValue }(callData);\n            if (!s) {\n                r.rawRevert();\n            }\n        }\n        // Make sure we acquired the NFT we want.\n        if (token.safeOwnerOf(tokenId) != address(this)) {\n            revert FailedToBuyNFTError(token, tokenId);\n        }\n        emit Won(\n            // Create a party around the newly bought NFT.\n            party_ = _createParty(partyFactory, governanceOpts, token, tokenId),\n            token,\n            tokenId,\n            settledPrice_\n        );\n    }\n\n    /// @inheritdoc Crowdfund\n    function getCrowdfundLifecycle() public override view returns (CrowdfundLifecycle) {\n        // If there is a settled price then we tried to buy the NFT.\n        if (settledPrice != 0) {\n            return address(party) != address(0)\n                // If we have a party, then we succeeded buying the NFT.\n                ? CrowdfundLifecycle.Won\n                // Otherwise we're in the middle of the buy().\n                : CrowdfundLifecycle.Busy;\n        }\n        if (block.timestamp >= expiry) {\n            // Expired but nothing to do so skip straight to lost.\n            return CrowdfundLifecycle.Lost;\n        }\n        return CrowdfundLifecycle.Active;\n    }\n\n    function _getFinalPrice()\n        internal\n        override\n        view\n        returns (uint256)\n    {\n        return settledPrice;\n    }\n}"
    }
  ]
}