{
  "Title": "[32] Non-existent facets would be assumed to be unfreezable due to the wrong conditional keyword in `isFacetFreezable()`",
  "Content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Getters.sol#L162-L174\n\n```solidity\n    /// @inheritdoc IGetters\n    function isFacetFreezable(address _facet) external view returns (bool isFreezable) {\n        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();\n\n        // There is no direct way to get whether the facet address is freezable,\n        // so we get it from one of the selectors that are associated with the facet.\n        uint256 selectorsArrayLen = ds.facetToSelectors[_facet].selectors.length;\n        //@audit\n        if (selectorsArrayLen != 0) {\n            bytes4 selector0 = ds.facetToSelectors[_facet].selectors[0];\n            isFreezable = ds.selectorToFacet[selector0].isFreezable;\n        }\n    }\n\n```\n\nThis function is used to determine if a facet is freezable, issue here is that it wrongly uses `if()` instead of `require()` now since `if` is used, in the case where the facet is none existent `selectorsArrayLen == 0` would be true and as such the function would return `false` whereas it should revert since the facet is non-existent\n\n### Impact\n\nUsers would be confused at this, since there is no difference between unfreezable facets and non-existent ones considering the current implementation of `isFacetFreezable()`.\n\n### Recommended Mitigation Steps\n\nConsider changing the `if()` condition to `require()` that way only real unfreezable facets would return `false`.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Getters.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {ZkSyncStateTransitionBase} from \"./ZkSyncStateTransitionBase.sol\";\nimport {PubdataPricingMode} from \"../ZkSyncStateTransitionStorage.sol\";\nimport {VerifierParams} from \"../../../state-transition/chain-interfaces/IVerifier.sol\";\nimport {Diamond} from \"../../libraries/Diamond.sol\";\nimport {PriorityQueue, PriorityOperation} from \"../../../state-transition/libraries/PriorityQueue.sol\";\nimport {UncheckedMath} from \"../../../common/libraries/UncheckedMath.sol\";\nimport {IGetters} from \"../../chain-interfaces/IGetters.sol\";\nimport {ILegacyGetters} from \"../../chain-interfaces/ILegacyGetters.sol\";\n\n// While formally the following import is not used, it is needed to inherit documentation from it\nimport {IZkSyncStateTransitionBase} from \"../../chain-interfaces/IZkSyncStateTransitionBase.sol\";\n\n/// @title Getters Contract implements functions for getting contract state from outside the blockchain.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract GettersFacet is ZkSyncStateTransitionBase, IGetters, ILegacyGetters {\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @inheritdoc IZkSyncStateTransitionBase\n    string public constant override getName = \"GettersFacet\";\n\n    /*//////////////////////////////////////////////////////////////\n                            CUSTOM GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IGetters\n    function getVerifier() external view returns (address) {\n        return address(s.verifier);\n    }\n\n    /// @inheritdoc IGetters\n    function getAdmin() external view returns (address) {\n        return s.admin;\n    }\n\n    /// @inheritdoc IGetters\n    function getPendingAdmin() external view returns (address) {\n        return s.pendingAdmin;\n    }\n\n    /// @inheritdoc IGetters\n    function getBridgehub() external view returns (address) {\n        return address(s.bridgehub);\n    }\n\n    /// @inheritdoc IGetters\n    function getStateTransitionManager() external view returns (address) {\n        return address(s.stateTransitionManager);\n    }\n\n    /// @inheritdoc IGetters\n    function getBaseToken() external view returns (address) {\n        return address(s.baseToken);\n    }\n\n    /// @inheritdoc IGetters\n    function getBaseTokenBridge() external view returns (address) {\n        return address(s.baseTokenBridge);\n    }\n\n    /// @inheritdoc IGetters\n    function baseTokenGasPriceMultiplierNominator() external view returns (uint128) {\n        return s.baseTokenGasPriceMultiplierNominator;\n    }\n\n    /// @inheritdoc IGetters\n    function baseTokenGasPriceMultiplierDenominator() external view returns (uint128) {\n        return s.baseTokenGasPriceMultiplierDenominator;\n    }\n\n    /// @inheritdoc IGetters\n    function getTotalBatchesCommitted() external view returns (uint256) {\n        return s.totalBatchesCommitted;\n    }\n\n    /// @inheritdoc IGetters\n    function getTotalBatchesVerified() external view returns (uint256) {\n        return s.totalBatchesVerified;\n    }\n\n    /// @inheritdoc IGetters\n    function getTotalBatchesExecuted() external view returns (uint256) {\n        return s.totalBatchesExecuted;\n    }\n\n    /// @inheritdoc IGetters\n    function getTotalPriorityTxs() external view returns (uint256) {\n        return s.priorityQueue.getTotalPriorityTxs();\n    }\n\n    /// @inheritdoc IGetters\n    function getFirstUnprocessedPriorityTx() external view returns (uint256) {\n        return s.priorityQueue.getFirstUnprocessedPriorityTx();\n    }\n\n    /// @inheritdoc IGetters\n    function getPriorityQueueSize() external view returns (uint256) {\n        return s.priorityQueue.getSize();\n    }\n\n    /// @inheritdoc IGetters\n    function priorityQueueFrontOperation() external view returns (PriorityOperation memory) {\n        return s.priorityQueue.front();\n    }\n\n    /// @inheritdoc IGetters\n    function isValidator(address _address) external view returns (bool) {\n        return s.validators[_address];\n    }\n\n    /// @inheritdoc IGetters\n    function l2LogsRootHash(uint256 _batchNumber) external view returns (bytes32) {\n        return s.l2LogsRootHashes[_batchNumber];\n    }\n\n    /// @inheritdoc IGetters\n    function storedBatchHash(uint256 _batchNumber) external view returns (bytes32) {\n        return s.storedBatchHashes[_batchNumber];\n    }\n\n    /// @inheritdoc IGetters\n    function getL2BootloaderBytecodeHash() external view returns (bytes32) {\n        return s.l2BootloaderBytecodeHash;\n    }\n\n    /// @inheritdoc IGetters\n    function getL2DefaultAccountBytecodeHash() external view returns (bytes32) {\n        return s.l2DefaultAccountBytecodeHash;\n    }\n\n    /// @inheritdoc IGetters\n    function getVerifierParams() external view returns (VerifierParams memory) {\n        return s.verifierParams;\n    }\n\n    /// @inheritdoc IGetters\n    function getProtocolVersion() external view returns (uint256) {\n        return s.protocolVersion;\n    }\n\n    /// @inheritdoc IGetters\n    function getL2SystemContractsUpgradeTxHash() external view returns (bytes32) {\n        return s.l2SystemContractsUpgradeTxHash;\n    }\n\n    /// @inheritdoc IGetters\n    function getL2SystemContractsUpgradeBatchNumber() external view returns (uint256) {\n        return s.l2SystemContractsUpgradeBatchNumber;\n    }\n\n    /// @inheritdoc IGetters\n    function isDiamondStorageFrozen() external view returns (bool) {\n        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();\n        return ds.isFrozen;\n    }\n\n    /// @inheritdoc IGetters\n    function isFacetFreezable(address _facet) external view returns (bool isFreezable) {\n        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();\n\n        // There is no direct way to get whether the facet address is freezable,\n        // so we get it from one of the selectors that are associated with the facet.\n        uint256 selectorsArrayLen = ds.facetToSelectors[_facet].selectors.length;\n        if (selectorsArrayLen != 0) {\n            bytes4 selector0 = ds.facetToSelectors[_facet].selectors[0];\n            isFreezable = ds.selectorToFacet[selector0].isFreezable;\n        }\n    }\n\n    /// @inheritdoc IGetters\n    function getPriorityTxMaxGasLimit() external view returns (uint256) {\n        return s.priorityTxMaxGasLimit;\n    }\n\n    /// @inheritdoc IGetters\n    function isFunctionFreezable(bytes4 _selector) external view returns (bool) {\n        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();\n        require(ds.selectorToFacet[_selector].facetAddress != address(0), \"g2\");\n        return ds.selectorToFacet[_selector].isFreezable;\n    }\n\n    /// @inheritdoc IGetters\n    function isEthWithdrawalFinalized(uint256 _l2BatchNumber, uint256 _l2MessageIndex) external view returns (bool) {\n        return s.isEthWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex];\n    }\n\n    /// @inheritdoc IGetters\n    function getPubdataPricingMode() external view returns (PubdataPricingMode) {\n        return s.feeParams.pubdataPricingMode;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            DIAMOND LOUPE\n     //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IGetters\n    function facets() external view returns (Facet[] memory result) {\n        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();\n\n        uint256 facetsLen = ds.facets.length;\n        result = new Facet[](facetsLen);\n\n        for (uint256 i = 0; i < facetsLen; i = i.uncheckedInc()) {\n            address facetAddr = ds.facets[i];\n            Diamond.FacetToSelectors memory facetToSelectors = ds.facetToSelectors[facetAddr];\n\n            result[i] = Facet(facetAddr, facetToSelectors.selectors);\n        }\n    }\n\n    /// @inheritdoc IGetters\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory) {\n        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();\n        return ds.facetToSelectors[_facet].selectors;\n    }\n\n    /// @inheritdoc IGetters\n    function facetAddresses() external view returns (address[] memory) {\n        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();\n        return ds.facets;\n    }\n\n    /// @inheritdoc IGetters\n    function facetAddress(bytes4 _selector) external view returns (address) {\n        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();\n        return ds.selectorToFacet[_selector].facetAddress;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPRECATED METHODS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ILegacyGetters\n    function getTotalBlocksCommitted() external view returns (uint256) {\n        return s.totalBatchesCommitted;\n    }\n\n    /// @inheritdoc ILegacyGetters\n    function getTotalBlocksVerified() external view returns (uint256) {\n        return s.totalBatchesVerified;\n    }\n\n    /// @inheritdoc ILegacyGetters\n    function getTotalBlocksExecuted() external view returns (uint256) {\n        return s.totalBatchesExecuted;\n    }\n\n    /// @inheritdoc ILegacyGetters\n    function storedBlockHash(uint256 _batchNumber) external view returns (bytes32) {\n        return s.storedBatchHashes[_batchNumber];\n    }\n\n    /// @inheritdoc ILegacyGetters\n    function getL2SystemContractsUpgradeBlockNumber() external view returns (uint256) {\n        return s.l2SystemContractsUpgradeBatchNumber;\n    }\n}"
    }
  ]
}