{
  "Title": "[07] Notice - Slippage and Interest Free Loan for Arbitrageurs",
  "Content": "\nBecause `redeem` doesn't burn FEI, any caller can `mint` and `redeem` multiple times in the same tx with the goal of arbing out the FEI - DAI pair.\n\n[SimpleFeiDaiPSM.sol#L105-L106](https://github.com/code-423n4/2022-09-tribe/blob/769b0586b4975270b669d7d1581aa5672d6999d5/contracts/peg/SimpleFeiDaiPSM.sol#L105-L106)\n\n```solidity\n    function burnFeiHeld() external {\n\n```\n\nWhile FEI being tradeable for DAI is enforcing a 1-1 trade (FEI price goes up due to arbing, up to 100% + FEE), allowing the opposite swap is a easy target for arbitrageurs.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-09-tribe",
  "Code": [
    {
      "filename": "contracts/peg/SimpleFeiDaiPSM.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../fei/Fei.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @notice contract to create a permanent governanceless FEI-DAI PSM\n/// As long as Tribe DAO's governance is active, the funds in this contract\n/// can still be accessed : the Tribe DAO can mint FEI at will and get the DAI\n/// in this contract, and could revoke the MINTER role from this contract,\n/// preventing it to create new FEI.\n/// This contract acts as a FEI sink and can burn the FEI it holds.\n/// Burning the MINTER_ROLE from the Tribe DAO will make this PSM act\n/// like a permanent feeless FEI-DAI wrapper.\ncontract SimpleFeiDaiPSM {\n    using SafeERC20 for Fei;\n    using SafeERC20 for IERC20;\n\n    IERC20 private constant DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    Fei private constant FEI = Fei(0x956F47F50A910163D8BF957Cf5846D573E7f87CA);\n\n    // ----------------------------------------------------------------------------\n    // Peg Stability Module functionalities\n    // ----------------------------------------------------------------------------\n\n    /// @notice event emitted upon a redemption\n    event Redeem(address to, uint256 amountFeiIn, uint256 amountAssetOut);\n    /// @notice event emitted when fei gets minted\n    event Mint(address to, uint256 amountIn, uint256 amountFeiOut);\n\n    /// @notice mint `amountFeiOut` FEI to address `to` for `amountIn` underlying tokens\n    /// @dev see getMintAmountOut() to pre-calculate amount out\n    function mint(\n        address to,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) external returns (uint256 amountFeiOut) {\n        amountFeiOut = amountIn;\n        require(amountFeiOut >= minAmountOut, \"SimpleFeiDaiPSM: Mint not enough out\");\n        DAI.safeTransferFrom(msg.sender, address(this), amountIn);\n        FEI.mint(to, amountFeiOut);\n        emit Mint(to, amountIn, amountIn);\n    }\n\n    /// @notice redeem `amountFeiIn` FEI for `amountOut` underlying tokens and send to address `to`\n    /// @dev see getRedeemAmountOut() to pre-calculate amount out\n    /// @dev FEI received is not burned, see `burnFeiHeld()` below to batch-burn the FEI redeemed\n    function redeem(\n        address to,\n        uint256 amountFeiIn,\n        uint256 minAmountOut\n    ) external returns (uint256 amountOut) {\n        amountOut = amountFeiIn;\n        require(amountOut >= minAmountOut, \"SimpleFeiDaiPSM: Redeem not enough out\");\n        FEI.safeTransferFrom(msg.sender, address(this), amountFeiIn);\n        DAI.safeTransfer(to, amountOut);\n        emit Redeem(to, amountFeiIn, amountFeiIn);\n    }\n\n    /// @notice calculate the amount of FEI out for a given `amountIn` of underlying\n    function getMintAmountOut(uint256 amountIn) external pure returns (uint256) {\n        return amountIn;\n    }\n\n    /// @notice calculate the amount of underlying out for a given `amountFeiIn` of FEI\n    function getRedeemAmountOut(uint256 amountIn) external pure returns (uint256) {\n        return amountIn;\n    }\n\n    // ----------------------------------------------------------------------------\n    // Functions to make this contract compatible with the PCVDeposit interface\n    // and accounted for in the Fei Protocol's Collateralization Oracle\n    // ----------------------------------------------------------------------------\n\n    address public constant balanceReportedIn = address(DAI);\n\n    /// @notice gets the effective balance of \"balanceReportedIn\" token if the deposit were fully withdrawn\n    function balance() external view returns (uint256) {\n        return DAI.balanceOf(address(this));\n    }\n\n    /// @notice gets the resistant token balance and protocol owned fei of this deposit\n    function resistantBalanceAndFei() external view returns (uint256, uint256) {\n        return (DAI.balanceOf(address(this)), FEI.balanceOf(address(this)));\n    }\n\n    // ----------------------------------------------------------------------------\n    // These view functions are meant to make this contract's interface\n    // as similar as possible to the FixedPricePSM as possible.\n    // ----------------------------------------------------------------------------\n\n    uint256 public constant mintFeeBasisPoints = 0;\n    uint256 public constant redeemFeeBasisPoints = 0;\n    address public constant underlyingToken = address(DAI);\n    uint256 public constant getMaxMintAmountOut = type(uint256).max;\n    bool public constant paused = false;\n    bool public constant redeemPaused = false;\n    bool public constant mintPaused = false;\n\n    // ----------------------------------------------------------------------------\n    // This contract should act as a FEI sink if needed\n    // ----------------------------------------------------------------------------\n\n    /// @notice Burns all FEI on this contract.\n    function burnFeiHeld() external {\n        uint256 feiBalance = FEI.balanceOf(address(this));\n        if (feiBalance != 0) {\n            FEI.burn(feiBalance);\n        }\n    }\n}"
    }
  ]
}