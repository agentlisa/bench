{
  "Title": "[M-05] No Storage Gap for Upgradeable Contract Might Lead to Storage Slot Collision",
  "Content": "_Submitted by 0x1337_\n\n[AlchemicTokenV2Base.sol#L20](https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemicTokenV2Base.sol#L20)<br>\n[CrossChainCanonicalBase.sol#L12](https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/CrossChainCanonicalBase.sol#L12)<br>\n[TransmuterV2.sol#L26](https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/TransmuterV2.sol#L26)<br>\n[CrossChainCanonicalAlchemicTokenV2.sol#L7](https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/CrossChainCanonicalAlchemicTokenV2.sol#L7)<br>\n\nFor upgradeable contracts, there must be storage gap to \"allow developers to freely add new state variables in the future without compromising the storage compatibility with existing deployments\" (quote OpenZeppelin). Otherwise it may be very difficult to write new implementation code. Without storage gap, the variable in child contract might be overwritten by the upgraded base contract if new variables are added to the base contract. This could have unintended and very serious consequences to the child contracts, potentially causing loss of user fund or cause the contract to malfunction completely.\n\nRefer to the bottom part of this article: <https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable>\n\n### Proof of Concept\n\nSeveral contracts are intended to be upgradeable contracts in the code base, including\n\n*   AlchemicTokenV2Base\n*   CrossChainCanonicalBase\n*   CrossChainCanonicalAlchemicTokenV2\n*   TransmuterV2\n\nHowever, none of these contracts contain storage gap. The storage gap is essential for upgradeable contract because \"It allows us to freely add new state variables in the future without compromising the storage compatibility with existing deployments\". Refer to the bottom part of this article:\n\n<https://docs.openzeppelin.com/contracts/3.x/upgradeable>\n\nAs an example, both the `AlchemicTokenV2Base` and the `CrossChainCanonicalBase` are intended to act as the base contracts in the project. If the contract inheriting the base contract contains additional variable, then the base contract cannot be upgraded to include any additional variable, because it would overwrite the variable declared in its child contract. This greatly limits contract upgradeability.\n\n### Recommended Mitigation Steps\n\nRecommend adding appropriate storage gap at the end of upgradeable contracts such as the below. Please reference OpenZeppelin upgradeable contract templates.\n\n```solidity\nuint256[50] private __gap;\n```\n\n**[0xfoobar (Alchemix) confirmed](https://github.com/code-423n4/2022-05-alchemix-findings/issues/44#issuecomment-1140765969)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-05-alchemix-findings/issues/44#issuecomment-1153292612):**\n > Agree with warden and severity. Storage gaps are essential wherever inheritance is used by an upgradeable contract.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-alchemix-contest",
  "Code": [
    {
      "filename": "contracts-full/AlchemicTokenV2Base.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.11;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {IllegalArgument, IllegalState, Unauthorized} from \"./base/Errors.sol\";\n\nimport {IERC3156FlashBorrower} from \"./interfaces/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"./interfaces/IERC3156FlashLender.sol\";\n\n/// @title  AlchemicTokenV2\n/// @author Alchemix Finance\n///\n/// @notice This is the contract for version two alchemic tokens.\n/// @notice Initially, the contract deployer is given both the admin and minter role. This allows them to pre-mine\n///         tokens, transfer admin to a timelock contract, and lastly, grant the staking pools the minter role. After\n///         this is done, the deployer must revoke their admin role and minter role.\ncontract AlchemicTokenV2Base is ERC20Upgradeable, AccessControlUpgradeable, IERC3156FlashLender, ReentrancyGuardUpgradeable {\n  /// @notice The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n  /// @notice The identifier of the role which allows accounts to mint tokens.\n  bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n\n  /// @notice The expected return value from a flash mint receiver\n  bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n  /// @notice The maximum number of basis points needed to represent 100%.\n  uint256 public constant BPS = 10000;\n\n  /// @notice A set of addresses which are whitelisted for minting new tokens.\n  mapping(address => bool) public whitelisted;\n\n  /// @notice A set of addresses which are paused from minting new tokens.\n  mapping(address => bool) public paused;\n\n  /// @notice The amount that each address is permitted to mint.\n  mapping(address => uint256) public mintCeiling;\n\n  /// @notice The amount of tokens that each address has already minted.\n  mapping(address => uint256) public totalMinted;\n\n  /// @notice Fee for flash minting\n  uint256 public flashMintFee;\n\n  /// @notice Max flash mint amount\n  uint256 public maxFlashLoanAmount;\n\n  /// @notice An event which is emitted when a minter is paused from minting.\n  ///\n  /// @param minter The address of the minter which was paused.\n  /// @param state  A flag indicating if the alchemist is paused or unpaused.\n  event Paused(address minter, bool state);\n\n  /// @notice An event which is emitted when the flash mint fee is updated.\n  ///\n  /// @param fee The new flash mint fee.\n  event SetFlashMintFee(uint256 fee);\n\n  function __AlchemicTokenV2Base_init() internal {\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(SENTINEL_ROLE, msg.sender);\n    _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n  }\n\n  /// @dev A modifier which checks that the caller has the admin role.\n  modifier onlyAdmin() {\n    if (!hasRole(ADMIN_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks that the caller has the sentinel role.\n  modifier onlySentinel() {\n    if(!hasRole(SENTINEL_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks if whitelisted for minting.\n  modifier onlyWhitelisted() {\n    if(!whitelisted[msg.sender]) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @notice Sets the flash minting fee.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param newFee The new flash mint fee.\n  function setFlashFee(uint256 newFee) external onlyAdmin {\n    flashMintFee = newFee;\n    emit SetFlashMintFee(flashMintFee);\n  }\n\n  /// @notice Mints tokens to `a recipient.`\n  ///\n  /// @notice This function reverts if `msg.sender` is not whitelisted.\n  /// @notice This function reverts if `msg.sender` is paused.\n  /// @notice This function reverts if `msg.sender` has exceeded their mintable ceiling.\n  ///\n  /// @param recipient The address to mint the tokens to.\n  /// @param amount    The amount of tokens to mint.\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    if (paused[msg.sender]) {\n      revert IllegalState();\n    }\n\n    uint256 total = amount + totalMinted[msg.sender];\n    if (total > mintCeiling[msg.sender]) {\n      revert IllegalState();\n    }\n\n    totalMinted[msg.sender] = total;\n\n    _mint(recipient, amount);\n  }\n\n  /// @notice Sets `minter` as whitelisted to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter The account to permit to mint.\n  /// @param state  A flag indicating if the minter should be able to mint.\n  function setWhitelist(address minter, bool state) external onlyAdmin {\n    whitelisted[minter] = state;\n  }\n\n  /// @notice Sets `sentinel` as a sentinel.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param sentinel The address to set as a sentinel.\n  function setSentinel(address sentinel) external onlyAdmin {\n    _setupRole(SENTINEL_ROLE, sentinel);\n  }\n\n  /// @notice Sets the maximum amount of tokens that `minter` is allowed to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter  The address of the minter.\n  /// @param maximum The maximum amount of tokens that the minter is allowed to mint.\n  function setCeiling(address minter, uint256 maximum) external onlyAdmin {\n    mintCeiling[minter] = maximum;\n  }\n\n  /// @notice Pauses `minter` from minting tokens.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param minter The address to set as paused or unpaused.\n  /// @param state  A flag indicating if the minter should be paused or unpaused.\n  function pauseMinter(address minter, bool state) external onlySentinel {\n    paused[minter] = state;\n    emit Paused(minter, state);\n  }\n\n  /// @notice Burns `amount` tokens from `msg.sender`.\n  ///\n  /// @param amount The amount of tokens to be burned.\n  function burn(uint256 amount) external {\n    _burn(msg.sender, amount);\n  }\n\n  /// @dev Destroys `amount` tokens from `account`, deducting from the caller's allowance.\n  ///\n  /// @param account The address the burn tokens from.\n  /// @param amount  The amount of tokens to burn.\n  function burnFrom(address account, uint256 amount) external {\n    uint256 newAllowance = allowance(account, msg.sender) - amount;\n\n    _approve(account, msg.sender, newAllowance);\n    _burn(account, amount);\n  }\n\n  /// @notice Lowers the number of tokens which the `msg.sender` has minted.\n  ///\n  /// @notice This reverts if the `msg.sender` is not whitelisted.\n  ///\n  /// @param amount The amount to lower the minted amount by.\n  function lowerHasMinted(uint256 amount) external onlyWhitelisted {\n    totalMinted[msg.sender] = totalMinted[msg.sender] - amount;\n  }\n\n  /// @notice Adjusts the maximum flashloan amount.\n  ///\n  /// @param _maxFlashLoanAmount The maximum flashloan amount.\n  function setMaxFlashLoan(uint _maxFlashLoanAmount) external onlyAdmin {\n    maxFlashLoanAmount = _maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the maximum amount to be flash loaned of a token.\n  ///\n  /// @param token The address of the token.\n  ///\n  /// @return The maximum amount of `token` that can be flashed loaned.\n  function maxFlashLoan(address token) public view override returns (uint256) {\n    if (token != address(this)) {\n      return 0;\n    }\n    return maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the flash loan fee of `amount` of `token`.\n  ///\n  /// @param token  The address of the token.`\n  /// @param amount The amount of `token` to flash mint.\n  ///\n  /// @return The flash loan fee.\n  function flashFee(address token, uint256 amount) public view override returns (uint256) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n    return amount * flashMintFee / BPS;\n  }\n\n  /// @notice Performs a flash mint (called flash loan to confirm with ERC3156 standard).\n  ///\n  /// @param receiver The address which will receive the flash minted tokens.\n  /// @param token    The address of the token to flash mint.\n  /// @param amount   How much to flash mint.\n  /// @param data     ABI encoded data to pass to the receiver.\n  ///\n  /// @return If the flash loan was successful.\n  function flashLoan(\n    IERC3156FlashBorrower receiver,\n    address token,\n    uint256 amount,\n    bytes calldata data\n  ) external override nonReentrant returns (bool) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n\n    if (amount > maxFlashLoan(token)) {\n      revert IllegalArgument();\n    }\n\n    uint256 fee = flashFee(token, amount);\n\n    _mint(address(receiver), amount);\n\n    if (receiver.onFlashLoan(msg.sender, token, amount, fee, data) != CALLBACK_SUCCESS) {\n      revert IllegalState();\n    }\n\n    _burn(address(receiver), amount + fee); // Will throw error if not enough to burn\n\n    return true;\n  }\n}"
    },
    {
      "filename": "contracts-full/CrossChainCanonicalBase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport {ERC20PermitUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {IllegalArgument, IllegalState} from \"./base/Errors.sol\";\n\nimport {TokenUtils} from \"./libraries/TokenUtils.sol\";\n\ncontract CrossChainCanonicalBase is ERC20PermitUpgradeable, ReentrancyGuardUpgradeable, OwnableUpgradeable {\n\n    // Constants for various precisions\n    uint256 private constant FEE_PRECISION = 1e6; // Okay to use constant declarations since compiler does not reserve a storage slot\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Swap fee numerators, denominator of FEE_PRECISION\n    mapping(address => uint256[2]) public swapFees;\n    mapping(address => bool) public feeExempt;\n\n    // Acceptable old tokens\n    address[] public bridgeTokensArray; // Used for external UIs\n    mapping(address => bool) public bridgeTokens; // Used for the logic checks\n\n    // Administrative booleans\n    bool public exchangesPaused; // Pause old token exchanges in case of an emergency\n    mapping(address => bool) public bridgeTokenEnabled;\n\n    /* ========== MODIFIERS ========== */\n\n    modifier validBridgeToken(address tokenAddress) {\n        if (!bridgeTokenEnabled[tokenAddress]) {\n            revert IllegalState();\n        }\n        _;\n    }\n\n    /* ========== INITIALIZER ========== */\n\n    function __CrossChainCanonicalBase_init(\n        string memory _name,\n        string memory _symbol,\n        address _creatorAddress,\n        address[] memory _bridgeTokens\n    ) internal {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n        __EIP712_init_unchained(_name, \"1\");\n        __ERC20_init_unchained(_name, _symbol);\n        __ERC20Permit_init_unchained(_name);\n        __ReentrancyGuard_init_unchained(); // Note: this is called here but not in AlchemicTokenV2Base. Careful if inheriting that without this\n        _transferOwnership(_creatorAddress);\n\n        // Initialize the starting old tokens\n        for (uint256 i = 0; i < _bridgeTokens.length; i++){ \n            // Mark as accepted\n            bridgeTokens[_bridgeTokens[i]] = true;\n\n            // Add to the array\n            bridgeTokensArray.push(_bridgeTokens[i]);\n\n            // Set a small swap fee initially of 0.04%\n            swapFees[_bridgeTokens[i]] = [400, 400];\n\n            // Make sure swapping is on\n            bridgeTokenEnabled[_bridgeTokens[i]] = true;\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    // Helpful for UIs\n    function allBridgeTokens() external view returns (address[] memory) {\n        return bridgeTokensArray;\n    }\n\n    function _isFeeExempt(address targetAddress) internal view returns (bool) {\n        return feeExempt[targetAddress];\n    }\n\n    /* ========== PUBLIC FUNCTIONS ========== */\n\n    // Exchange old tokens for these canonical tokens\n    function exchangeOldForCanonical(address bridgeTokenAddress, uint256 tokenAmount) external nonReentrant validBridgeToken(bridgeTokenAddress) returns (uint256 canonicalTokensOut) {\n        if (exchangesPaused) {\n            revert IllegalState();\n        }\n\n        if (!bridgeTokenEnabled[bridgeTokenAddress]) {\n            revert IllegalState();\n        }\n\n        // Pull in the old tokens\n        TokenUtils.safeTransferFrom(bridgeTokenAddress, msg.sender, address(this), tokenAmount);\n\n        // Handle the fee, if applicable\n        canonicalTokensOut = tokenAmount;\n        if (!_isFeeExempt(msg.sender)) {\n            canonicalTokensOut -= ((canonicalTokensOut * swapFees[bridgeTokenAddress][0]) / FEE_PRECISION);\n        }\n\n        // Mint canonical tokens and give it to the sender\n        super._mint(msg.sender, canonicalTokensOut);\n    }\n\n    // Exchange canonical tokens for old tokens\n    function exchangeCanonicalForOld(address bridgeTokenAddress, uint256 tokenAmount) external nonReentrant validBridgeToken(bridgeTokenAddress) returns (uint256 bridgeTokensOut) {\n        if (exchangesPaused) {\n            revert IllegalState();\n        }\n\n        if (!bridgeTokenEnabled[bridgeTokenAddress]) {\n            revert IllegalState();\n        }\n\n        // Burn the canonical tokens\n        super._burn(msg.sender, tokenAmount);\n\n        // Handle the fee, if applicable\n        bridgeTokensOut = tokenAmount;\n        if (!_isFeeExempt(msg.sender)) {\n            bridgeTokensOut -= ((bridgeTokensOut * swapFees[bridgeTokenAddress][1]) / FEE_PRECISION);\n        }\n\n        // Give old tokens to the sender\n        TokenUtils.safeTransfer(bridgeTokenAddress, msg.sender, bridgeTokensOut);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS, BUT CUSTODIAN CAN CALL TOO ========== */\n\n    function toggleExchanges() external onlyOwner {\n        exchangesPaused = !exchangesPaused;\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function addBridgeToken(address bridgeTokenAddress) external onlyOwner {\n        // Make sure the token is not already present\n        for (uint i = 0; i < bridgeTokensArray.length; i++){ \n            if (bridgeTokensArray[i] == bridgeTokenAddress) {\n                revert IllegalState();\n            }\n        }\n\n        // Add the old token\n        bridgeTokensArray.push(bridgeTokenAddress);\n\n        // Turn swapping on\n        bridgeTokenEnabled[bridgeTokenAddress] = true;\n\n        emit BridgeTokenAdded(bridgeTokenAddress);\n    }\n\n    function toggleBridgeToken(address bridgeTokenAddress, bool enabled) external onlyOwner {\n        // Toggle swapping\n        bridgeTokenEnabled[bridgeTokenAddress] = enabled;\n\n        emit BridgeTokenToggled(bridgeTokenAddress, enabled);\n    }\n\n    function setSwapFees(address bridgeTokenAddress, uint256 _bridgeToCanonical, uint256 _canonicalToOld) external onlyOwner {\n        swapFees[bridgeTokenAddress] = [_bridgeToCanonical, _canonicalToOld];\n\n        emit SwapFeeSet(bridgeTokenAddress, _bridgeToCanonical, _canonicalToOld);\n    }\n\n    function toggleFeesForAddress(address targetAddress) external onlyOwner {\n        feeExempt[targetAddress] = !feeExempt[targetAddress];\n    }\n\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n        if (tokenAddress == address(this)) {\n            revert IllegalArgument();\n        }\n\n        if (bridgeTokenEnabled[tokenAddress]) {\n            revert IllegalState();\n        }\n\n        TokenUtils.safeTransfer(address(tokenAddress), msg.sender, tokenAmount);\n    }\n\n    /* ========== EVENTS ========== */\n\n    event BridgeTokenAdded(address indexed bridgeTokenAddress);\n    event BridgeTokenToggled(address indexed bridgeTokenAddress, bool state);\n    event SwapFeeSet(address indexed bridgeTokenAddress, uint bridgeToCanonical, uint canonicalToOld);\n}"
    },
    {
      "filename": "contracts-full/TransmuterV2.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./base/Errors.sol\";\n\nimport \"./interfaces/IWhitelist.sol\";\n\nimport \"./interfaces/transmuter/ITransmuterV2.sol\";\nimport \"./interfaces/transmuter/ITransmuterBuffer.sol\";\n\nimport \"./libraries/FixedPointMath.sol\";\nimport \"./libraries/LiquidityMath.sol\";\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/Tick.sol\";\nimport \"./libraries/TokenUtils.sol\";\n\n/// @title TransmuterV2\n///\n/// @notice A contract which facilitates the exchange of synthetic assets for their underlying\n//          asset. This contract guarantees that synthetic assets are exchanged exactly 1:1\n//          for the underlying asset.\ncontract TransmuterV2 is ITransmuterV2, Initializable, ReentrancyGuardUpgradeable, AccessControlUpgradeable {\n  using FixedPointMath for FixedPointMath.Number;\n  using Tick for Tick.Cache;\n\n  struct Account {\n    // The total number of unexchanged tokens that an account has deposited into the system\n    uint256 unexchangedBalance;\n    // The total number of exchanged tokens that an account has had credited\n    uint256 exchangedBalance;\n    // The tick that the account has had their deposit associated in\n    uint256 occupiedTick;\n  }\n\n  struct UpdateAccountParams {\n    // The owner address whose account will be modified\n    address owner;\n    // The amount to change the account's unexchanged balance by\n    int256 unexchangedDelta;\n    // The amount to change the account's exchanged balance by\n    int256 exchangedDelta;\n  }\n\n  struct ExchangeCache {\n    // The total number of unexchanged tokens that exist at the start of the exchange call\n    uint256 totalUnexchanged;\n    // The tick which has been satisfied up to at the start of the exchange call\n    uint256 satisfiedTick;\n    // The head of the active ticks queue at the start of the exchange call\n    uint256 ticksHead;\n  }\n\n  struct ExchangeState {\n    // The position in the buffer of current tick which is being examined\n    uint256 examineTick;\n    // The total number of unexchanged tokens that currently exist in the system for the current distribution step\n    uint256 totalUnexchanged;\n    // The tick which has been satisfied up to, inclusive\n    uint256 satisfiedTick;\n    // The amount of tokens to distribute for the current step\n    uint256 distributeAmount;\n    // The accumulated weight to write at the new tick after the exchange is completed\n    FixedPointMath.Number accumulatedWeight;\n    // Reserved for the maximum weight of the current distribution step\n    FixedPointMath.Number maximumWeight;\n    // Reserved for the dusted weight of the current distribution step\n    FixedPointMath.Number dustedWeight;\n  }\n\n  struct UpdateAccountCache {\n    // The total number of unexchanged tokens that the account held at the start of the update call\n    uint256 unexchangedBalance;\n    // The total number of exchanged tokens that the account held at the start of the update call\n    uint256 exchangedBalance;\n    // The tick that the account's deposit occupies at the start of the update call\n    uint256 occupiedTick;\n    // The total number of unexchanged tokens that exist at the start of the update call\n    uint256 totalUnexchanged;\n    // The current tick that is being written to\n    uint256 currentTick;\n  }\n\n  struct UpdateAccountState {\n    // The updated unexchanged balance of the account being updated\n    uint256 unexchangedBalance;\n    // The updated exchanged balance of the account being updated\n    uint256 exchangedBalance;\n    // The updated total unexchanged balance\n    uint256 totalUnexchanged;\n  }\n\n  address public constant ZERO_ADDRESS = address(0);\n\n  /// @dev The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN = keccak256(\"ADMIN\");\n\n  /// @dev The identitifer of the sentinel role\n  bytes32 public constant SENTINEL = keccak256(\"SENTINEL\");\n\n  /// @inheritdoc ITransmuterV2\n  string public constant override version = \"2.2.0\";\n\n  /// @dev the synthetic token to be transmuted\n  address public syntheticToken;\n\n  /// @dev the underlying token to be received\n  address public override underlyingToken;\n\n  /// @dev The total amount of unexchanged tokens which are held by all accounts.\n  uint256 public totalUnexchanged;\n\n  /// @dev The total amount of tokens which are in the auxiliary buffer.\n  uint256 public totalBuffered;\n\n  /// @dev A mapping specifying all of the accounts.\n  mapping(address => Account) private accounts;\n\n  // @dev The tick buffer which stores all of the tick information along with the tick that is\n  //      currently being written to. The \"current\" tick is the tick at the buffer write position.\n  Tick.Cache private ticks;\n\n  // The tick which has been satisfied up to, inclusive.\n  uint256 private satisfiedTick;\n\n  /// @dev contract pause state\n  bool public isPaused;\n\n  /// @dev the source of the exchanged collateral\n  address public buffer;\n\n  /// @dev The address of the external whitelist contract.\n  address public override whitelist;\n\n  /// @dev The amount of decimal places needed to normalize collateral to debtToken\n  uint256 public override conversionFactor;\n\n  constructor() initializer {}\n\n  function initialize(\n    address _syntheticToken,\n    address _underlyingToken,\n    address _buffer,\n    address _whitelist\n  ) external initializer {\n    _setupRole(ADMIN, msg.sender);\n    _setRoleAdmin(ADMIN, ADMIN);\n    _setRoleAdmin(SENTINEL, ADMIN);\n\n    syntheticToken = _syntheticToken;\n    underlyingToken = _underlyingToken;\n    uint8 debtTokenDecimals = TokenUtils.expectDecimals(syntheticToken);\n    uint8 underlyingTokenDecimals = TokenUtils.expectDecimals(underlyingToken);\n    conversionFactor = 10**(debtTokenDecimals - underlyingTokenDecimals);\n    buffer = _buffer;\n    // Push a blank tick to function as a sentinel value in the active ticks queue.\n    ticks.next();\n\n    isPaused = false;\n    whitelist = _whitelist;\n  }\n\n  /// @dev A modifier which checks if caller is an alchemist.\n  modifier onlyBuffer() {\n    if (msg.sender != buffer) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks if caller is a sentinel or admin.\n  modifier onlySentinelOrAdmin() {\n    if (!hasRole(SENTINEL, msg.sender) && !hasRole(ADMIN, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks if caller is a sentinel.\n  modifier notPaused() {\n    if (isPaused) {\n      revert IllegalState();\n    }\n    _;\n  }\n\n  function _onlyAdmin() internal view {\n    if (!hasRole(ADMIN, msg.sender)) {\n      revert Unauthorized();\n    }\n  }\n\n  function setCollateralSource(address _newCollateralSource) external {\n    _onlyAdmin();\n    buffer = _newCollateralSource;\n  }\n\n  function setPause(bool pauseState) external onlySentinelOrAdmin {\n    isPaused = pauseState;\n    emit Paused(isPaused);\n  }\n\n  /// @inheritdoc ITransmuterV2\n  function deposit(uint256 amount, address owner) external override nonReentrant {\n    _onlyWhitelisted();\n    _updateAccount(\n      UpdateAccountParams({\n        owner: owner,\n        unexchangedDelta: SafeCast.toInt256(amount),\n        exchangedDelta: 0\n      })\n    );\n    TokenUtils.safeTransferFrom(syntheticToken, msg.sender, address(this), amount);\n    emit Deposit(msg.sender, owner, amount);\n  }\n\n  /// @inheritdoc ITransmuterV2\n  function withdraw(uint256 amount, address recipient) external override nonReentrant {\n    _onlyWhitelisted();\n    _updateAccount(\n      UpdateAccountParams({ \n        owner: msg.sender,\n        unexchangedDelta: -SafeCast.toInt256(amount),\n        exchangedDelta: 0\n      })\n    );\n    TokenUtils.safeTransfer(syntheticToken, recipient, amount);\n    emit Withdraw(msg.sender, recipient, amount);\n  }\n\n  /// @inheritdoc ITransmuterV2\n  function claim(uint256 amount, address recipient) external override nonReentrant {\n    _onlyWhitelisted();\n    _updateAccount(\n      UpdateAccountParams({\n        owner: msg.sender,\n        unexchangedDelta: 0,\n        exchangedDelta: -SafeCast.toInt256(_normalizeUnderlyingTokensToDebt(amount))\n      })\n    );\n    TokenUtils.safeBurn(syntheticToken, _normalizeUnderlyingTokensToDebt(amount));\n    ITransmuterBuffer(buffer).withdraw(underlyingToken, amount, msg.sender);\n    emit Claim(msg.sender, recipient, amount);\n  }\n\n  /// @inheritdoc ITransmuterV2\n  function exchange(uint256 amount) external override nonReentrant onlyBuffer notPaused {\n    uint256 normaizedAmount = _normalizeUnderlyingTokensToDebt(amount);\n\n    if (totalUnexchanged == 0) {\n      totalBuffered += normaizedAmount;\n      emit Exchange(msg.sender, amount);\n      return;\n    }\n\n    // Push a storage reference to the current tick.\n    Tick.Info storage current = ticks.current();\n\n    ExchangeCache memory cache = ExchangeCache({\n      totalUnexchanged: totalUnexchanged,\n      satisfiedTick: satisfiedTick,\n      ticksHead: ticks.head\n    });\n\n    ExchangeState memory state = ExchangeState({\n      examineTick: cache.ticksHead,\n      totalUnexchanged: cache.totalUnexchanged,\n      satisfiedTick: cache.satisfiedTick,\n      distributeAmount: normaizedAmount,\n      accumulatedWeight: current.accumulatedWeight,\n      maximumWeight: FixedPointMath.encode(0),\n      dustedWeight: FixedPointMath.encode(0)\n    });\n\n    // Distribute the buffered tokens as part of the exchange.\n    state.distributeAmount += totalBuffered;\n    totalBuffered = 0;\n\n    // Push a storage reference to the next tick to write to.\n    Tick.Info storage next = ticks.next();\n\n    // Only iterate through the active ticks queue when it is not empty.\n    while (state.examineTick != 0) {\n      // Check if there is anything left to distribute.\n      if (state.distributeAmount == 0) {\n        break;\n      }\n\n      Tick.Info storage examineTickData = ticks.get(state.examineTick);\n\n      // Add the weight for the distribution step to the accumulated weight.\n      state.accumulatedWeight = state.accumulatedWeight.add(\n        FixedPointMath.rational(state.distributeAmount, state.totalUnexchanged)\n      );\n\n      // Clear the distribute amount.\n      state.distributeAmount = 0;\n\n      // Calculate the current maximum weight in the system.\n      state.maximumWeight = state.accumulatedWeight.sub(examineTickData.accumulatedWeight);\n\n      // Check if there exists at least one account which is completely satisfied..\n      if (state.maximumWeight.n < FixedPointMath.ONE) {\n        break;\n      }\n\n      // Calculate how much weight of the distributed weight is dust.\n      state.dustedWeight = FixedPointMath.Number(state.maximumWeight.n - FixedPointMath.ONE);\n\n      // Calculate how many tokens to distribute in the next step. These are tokens from any tokens which\n      // were over allocated to accounts occupying the tick with the maximum weight.\n      state.distributeAmount = LiquidityMath.calculateProduct(examineTickData.totalBalance, state.dustedWeight);\n\n      // Remove the tokens which were completely exchanged from the total unexchanged balance.\n      state.totalUnexchanged -= examineTickData.totalBalance;\n\n      // Write that all ticks up to and including the examined tick have been satisfied.\n      state.satisfiedTick = state.examineTick;\n\n      // Visit the next active tick. This is equivalent to popping the head of the active ticks queue.\n      state.examineTick = examineTickData.next;\n    }\n\n    // Write the accumulated weight to the next tick.\n    next.accumulatedWeight = state.accumulatedWeight;\n\n    if (cache.totalUnexchanged != state.totalUnexchanged) {\n      totalUnexchanged = state.totalUnexchanged;\n    }\n\n    if (cache.satisfiedTick != state.satisfiedTick) {\n      satisfiedTick = state.satisfiedTick;\n    }\n\n    if (cache.ticksHead != state.examineTick) {\n      ticks.head = state.examineTick;\n    }\n\n    if (state.distributeAmount > 0) {\n      totalBuffered += state.distributeAmount;\n    }\n\n    emit Exchange(msg.sender, amount);\n  }\n\n  /// @inheritdoc ITransmuterV2\n  function getUnexchangedBalance(address owner) external view override returns (uint256 unexchangedBalance) {\n    Account storage account = accounts[owner];\n\n    if (account.occupiedTick <= satisfiedTick) {\n      return 0;\n    }\n\n    unexchangedBalance = account.unexchangedBalance;\n\n    uint256 exchanged = LiquidityMath.calculateProduct(\n      unexchangedBalance,\n      ticks.getWeight(account.occupiedTick, ticks.position)\n    );\n\n    unexchangedBalance -= exchanged;\n\n    return unexchangedBalance;\n  }\n\n  /// @inheritdoc ITransmuterV2\n  function getExchangedBalance(address owner) external view override returns (uint256 exchangedBalance) {\n    return _getExchangedBalance(owner);\n  }\n\n  function getClaimableBalance(address owner) external view override returns (uint256 claimableBalance) {\n    return _normalizeDebtTokensToUnderlying(_getExchangedBalance(owner));\n  }\n\n  /// @dev Updates an account.\n  ///\n  /// @param params The call parameters.\n  function _updateAccount(UpdateAccountParams memory params) internal {\n    Account storage account = accounts[params.owner];\n\n    UpdateAccountCache memory cache = UpdateAccountCache({\n      unexchangedBalance: account.unexchangedBalance,\n      exchangedBalance: account.exchangedBalance,\n      occupiedTick: account.occupiedTick,\n      totalUnexchanged: totalUnexchanged,\n      currentTick: ticks.position\n    });\n\n    UpdateAccountState memory state = UpdateAccountState({\n      unexchangedBalance: cache.unexchangedBalance,\n      exchangedBalance: cache.exchangedBalance,\n      totalUnexchanged: cache.totalUnexchanged\n    });\n\n    // Updating an account is broken down into five steps:\n    // 1). Synchronize the account if it previously occupied a satisfied tick\n    // 2). Update the account balances to account for exchanged tokens, if any\n    // 3). Apply the deltas to the account balances\n    // 4). Update the previously occupied and or current tick's liquidity\n    // 5). Commit changes to the account and global state when needed\n\n    // Step one:\n    // ---------\n    // Check if the tick that the account was occupying previously was satisfied. If it was, we acknowledge\n    // that all of the tokens were exchanged.\n    if (state.unexchangedBalance > 0 && satisfiedTick >= cache.occupiedTick) {\n      state.unexchangedBalance = 0;\n      state.exchangedBalance += cache.unexchangedBalance;\n    }\n\n    // Step Two:\n    // ---------\n    // Calculate how many tokens were exchanged since the last update.\n    if (state.unexchangedBalance > 0) {\n      uint256 exchanged = LiquidityMath.calculateProduct(\n        state.unexchangedBalance,\n        ticks.getWeight(cache.occupiedTick, cache.currentTick)\n      );\n\n      state.totalUnexchanged -= exchanged;\n      state.unexchangedBalance -= exchanged;\n      state.exchangedBalance += exchanged;\n    }\n\n    // Step Three:\n    // -----------\n    // Apply the unexchanged and exchanged deltas to the state.\n    state.totalUnexchanged = LiquidityMath.addDelta(state.totalUnexchanged, params.unexchangedDelta);\n    state.unexchangedBalance = LiquidityMath.addDelta(state.unexchangedBalance, params.unexchangedDelta);\n    state.exchangedBalance = LiquidityMath.addDelta(state.exchangedBalance, params.exchangedDelta);\n\n    // Step Four:\n    // ----------\n    // The following is a truth table relating various values which in combinations specify which logic branches\n    // need to be executed in order to update liquidity in the previously occupied and or current tick.\n    //\n    // Some states are not obtainable and are just discarded by setting all the branches to false.\n    //\n    // | P | C | M | Modify Liquidity | Add Liquidity | Subtract Liquidity |\n    // |---|---|---|------------------|---------------|--------------------|\n    // | F | F | F | F                | F             | F                  |\n    // | F | F | T | F                | F             | F                  |\n    // | F | T | F | F                | T             | F                  |\n    // | F | T | T | F                | T             | F                  |\n    // | T | F | F | F                | F             | T                  |\n    // | T | F | T | F                | F             | T                  |\n    // | T | T | F | T                | F             | F                  |\n    // | T | T | T | F                | T"
    }
  ]
}