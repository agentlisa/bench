{
  "Title": "Not formalized stablecoin minting to addresses",
  "Content": "##### Description\n\nAdmin of `ControllerFactory` can mint any amount of stablecoin to any address calling `set_debt_ceiling`. It is designed to mint tokens to Controllers, but the function does not check that a receiver is among Controllers.\n- https://github.com/curvefi/curve-stablecoin/blob/0d9265cc2dbd221b0f27f880fac1c590e1f12d28/contracts/ControllerFactory.vy#L306-L313\n\nMoreover, this function is used to mint tokens to PegKeepers, and there are no checks that a receiver is among PegKeepers. The whole process is not protected and requires strong admin attention.\n\n##### Recommendation\n\nWe recommend checking that the inputted address in `set_debt_ceiling` is allowed to receive mint stablecoins (is among either Controllers or PegKeepers).\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/ControllerFactory.vy",
      "content": "# @version 0.3.7\n\ninterface ERC20:\n    def mint(_to: address, _value: uint256) -> bool: nonpayable\n    def burnFrom(_to: address, _value: uint256) -> bool: nonpayable\n    def balanceOf(_user: address) -> uint256: view\n    def decimals() -> uint256: view\n\ninterface PriceOracle:\n    def price() -> uint256: view\n    def price_w() -> uint256: nonpayable\n\ninterface AMM:\n    def set_admin(_admin: address): nonpayable\n\ninterface Controller:\n    def total_debt() -> uint256: view\n    def minted() -> uint256: view\n    def redeemed() -> uint256: view\n    def collect_fees() -> uint256: nonpayable\n\ninterface MonetaryPolicy:\n    def rate_write() -> uint256: nonpayable\n\n\nevent AddMarket:\n    collateral: indexed(address)\n    controller: address\n    amm: address\n    monetary_policy: address\n    ix: uint256\n\nevent SetDebtCeiling:\n    addr: indexed(address)\n    debt_ceiling: uint256\n\nevent MintForMarket:\n    addr: indexed(address)\n    amount: uint256\n\nevent RemoveFromMarket:\n    addr: indexed(address)\n    amount: uint256\n\nevent SetImplementations:\n    amm: address\n    controller: address\n\nevent SetAdmin:\n    admin: address\n\nevent SetFeeReceiver:\n    fee_receiver: address\n\n\nMAX_CONTROLLERS: constant(uint256) = 50000\nSTABLECOIN: immutable(ERC20)\ncontrollers: public(address[MAX_CONTROLLERS])\namms: public(address[MAX_CONTROLLERS])\nadmin: public(address)\nfee_receiver: public(address)\ncontroller_implementation: public(address)\namm_implementation: public(address)\n\nn_collaterals: public(uint256)\ncollaterals: public(address[MAX_CONTROLLERS])\ncollaterals_index: public(HashMap[address, uint256[1000]])\n\ndebt_ceiling: public(HashMap[address, uint256])\ndebt_ceiling_residual: public(HashMap[address, uint256])\n\n# Limits\nMIN_A: constant(uint256) = 2\nMAX_A: constant(uint256) = 10000\nMAX_FEE: constant(uint256) = 10**17  # 10%\nMAX_ADMIN_FEE: constant(uint256) = 10**18  # 100%\nMAX_LOAN_DISCOUNT: constant(uint256) = 5 * 10**17\nMIN_LIQUIDATION_DISCOUNT: constant(uint256) = 10**16\n\nWETH: public(immutable(address))\n\n\n@external\ndef __init__(stablecoin: ERC20,\n             admin: address,\n             fee_receiver: address,\n             weth: address):\n    \"\"\"\n    @notice Factory which creates both controllers and AMMs from blueprints\n    @param stablecoin Stablecoin address\n    @param admin Admin of the factory (ideally DAO)\n    @param fee_receiver Receiver of interest and admin fees\n    @param weth Address of WETH contract address\n    \"\"\"\n    STABLECOIN = stablecoin\n    self.admin = admin\n    self.fee_receiver = fee_receiver\n    WETH = weth\n\n\n@internal\n@pure\ndef ln_int(_x: uint256) -> int256:\n    \"\"\"\n    @notice Logarithm ln() function based on log2. Not very gas-efficient but brief\n    \"\"\"\n    # adapted from: https://medium.com/coinmonks/9aef8515136e\n    # and vyper log implementation\n    # This can be much more optimal but that's not important here\n    x: uint256 = _x\n    res: uint256 = 0\n    for i in range(8):\n        t: uint256 = 2**(7 - i)\n        p: uint256 = 2**t\n        if x >= p * 10**18:\n            x /= p\n            res += t * 10**18\n    d: uint256 = 10**18\n    for i in range(59):  # 18 decimals: math.log2(10**10) == 59.7\n        if (x >= 2 * 10**18):\n            res += d\n            x /= 2\n        x = x * x / 10**18\n        d /= 2\n    # Now res = log2(x)\n    # ln(x) = log2(x) / log2(e)\n    return convert(res * 10**18 / 1442695040888963328, int256)\n## End of low-level math\n\n\n@external\n@view\ndef stablecoin() -> ERC20:\n    return STABLECOIN\n\n\n@internal\ndef _set_debt_ceiling(addr: address, debt_ceiling: uint256, update: bool):\n    \"\"\"\n    @notice Set debt ceiling for a market\n    @param addr Controller address\n    @param debt_ceiling Value for stablecoin debt ceiling\n    @param update Whether to actually update the debt ceiling (False is used for burning the residuals)\n    \"\"\"\n    old_debt_residual: uint256 = self.debt_ceiling_residual[addr]\n\n    if debt_ceiling > old_debt_residual:\n        to_mint: uint256 = debt_ceiling - old_debt_residual\n        STABLECOIN.mint(addr, to_mint)\n        self.debt_ceiling_residual[addr] = debt_ceiling\n        log MintForMarket(addr, to_mint)\n\n    if debt_ceiling < old_debt_residual:\n        diff: uint256 = min(old_debt_residual - debt_ceiling, STABLECOIN.balanceOf(addr))\n        STABLECOIN.burnFrom(addr, diff)\n        self.debt_ceiling_residual[addr] = old_debt_residual - diff\n        log RemoveFromMarket(addr, diff)\n\n    if update:\n        self.debt_ceiling[addr] = debt_ceiling\n        log SetDebtCeiling(addr, debt_ceiling)\n\n\n@external\n@nonreentrant('lock')\ndef add_market(token: address, A: uint256, fee: uint256, admin_fee: uint256,\n               _price_oracle_contract: address,\n               monetary_policy: address, loan_discount: uint256, liquidation_discount: uint256,\n               debt_ceiling: uint256) -> address[2]:\n    \"\"\"\n    @notice Add a new market, creating an AMM and a Controller from a blueprint\n    @param token Collateral token address\n    @param A Amplification coefficient; one band size is 1/A\n    @param fee AMM fee in the market's AMM\n    @param admin_fee AMM admin fee\n    @param _price_oracle_contract Address of price oracle contract for this market\n    @param monetary_policy Monetary policy for this market\n    @param loan_discount Loan discount: allowed to borrow only up to x_down * (1 - loan_discount)\n    @param liquidation_discount Discount which defines a bad liquidation threshold\n    @param debt_ceiling Debt ceiling for this market\n    @return (Controller, AMM)\n    \"\"\"\n    assert msg.sender == self.admin, \"Only admin\"\n    assert A >= MIN_A and A <= MAX_A, \"Wrong A\"\n    assert fee < MAX_FEE, \"Fee too high\"\n    assert admin_fee < MAX_ADMIN_FEE, \"Admin fee too high\"\n    assert liquidation_discount >= MIN_LIQUIDATION_DISCOUNT, \"Liquidation discount too low\"\n    assert loan_discount <= MAX_LOAN_DISCOUNT, \"Loan discount too high\"\n    assert loan_discount > liquidation_discount, \"need loan_discount>liquidation_discount\"\n    MonetaryPolicy(monetary_policy).rate_write()  # Test that MonetaryPolicy has correct ABI\n\n    p: uint256 = PriceOracle(_price_oracle_contract).price()  # This also validates price oracle ABI\n    assert p > 0\n    assert PriceOracle(_price_oracle_contract).price_w() == p\n    A_ratio: uint256 = 10**18 * A / (A - 1)\n\n    amm: address = create_from_blueprint(\n        self.amm_implementation,\n        STABLECOIN.address, 10**(18 - STABLECOIN.decimals()),\n        token, 10**(18 - ERC20(token).decimals()),  # <- This validates ERC20 ABI\n        A, isqrt(A_ratio * 10**18), self.ln_int(A_ratio),\n        p, fee, admin_fee, _price_oracle_contract,\n        code_offset=3)\n    controller: address = create_from_blueprint(\n        self.controller_implementation,\n        token, monetary_policy, loan_discount, liquidation_discount, amm,\n        code_offset=3)\n    AMM(amm).set_admin(controller)\n    self._set_debt_ceiling(controller, debt_ceiling, True)\n\n    N: uint256 = self.n_collaterals\n    self.collaterals[N] = token\n    for i in range(1000):\n        if self.collaterals_index[token][i] == 0:\n            self.collaterals_index[token][i] = 2**128 + N\n            break\n        assert i != 999, \"Too many controllers for same collateral\"\n    self.controllers[N] = controller\n    self.amms[N] = amm\n    self.n_collaterals = N + 1\n\n    log AddMarket(token, controller, amm, monetary_policy, N)\n    return [controller, amm]\n\n\n@external\n@view\ndef total_debt() -> uint256:\n    \"\"\"\n    @notice Sum of all debts across controllers\n    \"\"\"\n    total: uint256 = 0\n    n_collaterals: uint256 = self.n_collaterals\n    for i in range(MAX_CONTROLLERS):\n        if i == n_collaterals:\n            break\n        total += Controller(self.controllers[i]).total_debt()\n    return total\n\n\n@external\n@view\ndef get_controller(collateral: address, i: uint256 = 0) -> address:\n    \"\"\"\n    @notice Get controller address for collateral\n    @param collateral Address of collateral token\n    @param i Iterate over several controllers for collateral if needed\n    \"\"\"\n    return self.controllers[self.collaterals_index[collateral][i] - 2**128]\n\n\n@external\n@view\ndef get_amm(collateral: address, i: uint256 = 0) -> address:\n    \"\"\"\n    @notice Get AMM address for collateral\n    @param collateral Address of collateral token\n    @param i Iterate over several amms for collateral if needed\n    \"\"\"\n    return self.amms[self.collaterals_index[collateral][i] - 2**128]\n\n\n@external\n@nonreentrant('lock')\ndef set_implementations(controller: address, amm: address):\n    \"\"\"\n    @notice Set new implementations (blueprints) for controller and amm. Doesn't change existing ones\n    @param controller Address of the controller blueprint\n    @param amm Address of the AMM blueprint\n    \"\"\"\n    assert msg.sender == self.admin\n    assert controller != empty(address)\n    assert amm != empty(address)\n    self.controller_implementation = controller\n    self.amm_implementation = amm\n    log SetImplementations(amm, controller)\n\n\n@external\n@nonreentrant('lock')\ndef set_admin(admin: address):\n    \"\"\"\n    @notice Set admin of the factory (should end up with DAO)\n    @param admin Address of the admin\n    \"\"\"\n    assert msg.sender == self.admin\n    self.admin = admin\n    log SetAdmin(admin)\n\n\n@external\n@nonreentrant('lock')\ndef set_fee_receiver(fee_receiver: address):\n    \"\"\"\n    @notice Set fee receiver who earns interest (DAO)\n    @param fee_receiver Address of the receiver\n    \"\"\"\n    assert msg.sender == self.admin\n    assert fee_receiver != empty(address)\n    self.fee_receiver = fee_receiver\n    log SetFeeReceiver(fee_receiver)\n\n\n@external\n@nonreentrant('lock')\ndef set_debt_ceiling(_to: address, debt_ceiling: uint256):\n    \"\"\"\n    @notice Set debt ceiling of the address - mint the token amount given for it\n    @param _to Address to allow borrowing for\n    @param debt_ceiling Maximum allowed to be allowed to mint for it\n    \"\"\"\n    assert msg.sender == self.admin\n    self._set_debt_ceiling(_to, debt_ceiling, True)\n\n\n@external\n@nonreentrant('lock')\ndef rug_debt_ceiling(_to: address):\n    \"\"\"\n    @notice Remove stablecoins above the debt ceiling from the address and burn them\n    @param _to Address to remove stablecoins from\n    \"\"\"\n    self._set_debt_ceiling(_to, self.debt_ceiling[_to], False)\n\n\n@external\n@nonreentrant('lock')\ndef collect_fees_above_ceiling(_to: address):\n    \"\"\"\n    @notice If the receiver is the controller - increase the debt ceiling if it's not enough to claim admin fees\n            and claim them\n    @param _to Address of the controller\n    \"\"\"\n    assert msg.sender == self.admin\n    old_debt_residual: uint256 = self.debt_ceiling_residual[_to]\n    assert self.debt_ceiling[_to] > 0 or old_debt_residual > 0\n\n    admin_fees: uint256 = Controller(_to).total_debt() + Controller(_to).redeemed() - Controller(_to).minted()\n    b: uint256 = STABLECOIN.balanceOf(_to)\n    if admin_fees > b:\n        to_mint: uint256 = admin_fees - b\n        STABLECOIN.mint(_to, to_mint)\n        self.debt_ceiling_residual[_to] = old_debt_residual + to_mint\n    Controller(_to).collect_fees()"
    }
  ]
}