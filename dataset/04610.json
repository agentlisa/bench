{
  "Title": "Strategy and agent contracts can be set to invalid ones",
  "Content": "Strategy contracts `PricingStrategy` and `CeilingStrategy` as well as `FinalizationAgent` each have an [`isSane`](https://github.com/CoinFabrik/ico/blob/142f43f3bec4afd0ffff3fce06946cf67cb0272f/contracts/Crowdsale.sol#L463) function and [an accompanying one](https://github.com/CoinFabrik/ico/blob/142f43f3bec4afd0ffff3fce06946cf67cb0272f/contracts/Crowdsale.sol#L463) in `Crowdsale`, whose apparent purpose is to validate their correct setup with respect to a `Crowdsale` instance. Although the instances can be changed mid-crowdsale, they are not validated, and the contract could be left in an invalid state. Consider adding the validation for each in the setters [`setPricingStrategy`](https://github.com/CoinFabrik/ico/blob/142f43f3bec4afd0ffff3fce06946cf67cb0272f/contracts/Crowdsale.sol#L392), [`setCeilingStrategy`](https://github.com/CoinFabrik/ico/blob/142f43f3bec4afd0ffff3fce06946cf67cb0272f/contracts/Crowdsale.sol#L404) and [`setFinalizeAgent`](https://github.com/CoinFabrik/ico/blob/142f43f3bec4afd0ffff3fce06946cf67cb0272f/contracts/Crowdsale.sol#L332). For example, add `isPricingSane();` after [line 396](https://github.com/CoinFabrik/ico/blob/142f43f3bec4afd0ffff3fce06946cf67cb0272f/contracts/Crowdsale.sol#L396).\n\n\n**Update:** Hubii replied *“Now setters are internal to prevent modifications during the crowdsale, and we now check if they are valid.”* Fixed in [`5a90957abf3f792951b3aad66d6eb0317f0500ca`](https://github.com/CoinFabrik/ico/commit/5a90957abf3f792951b3aad66d6eb0317f0500ca).\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Crowdsale.sol",
      "content": "pragma solidity ^0.4.11;\n\n/**\n * Originally from https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n\nimport \"./Haltable.sol\";\nimport \"./FractionalERC20.sol\";\nimport \"./PricingStrategy.sol\";\nimport \"./FinalizeAgent.sol\";\nimport \"./SafeMath.sol\";\nimport \"./CeilingStrategy.sol\";\nimport \"./MintableToken.sol\";\n\n/**\n * Concrete base contract for token sales.\n *\n * Handles\n * - start and end dates\n * - accepting investments\n * - minimum funding goal and refund\n * - various statistics during the crowdfund\n * - different pricing strategies\n * - different investment policies (require server side customer id, allow only whitelisted addresses)\n *\n */\ncontract Crowdsale is Haltable {\n\n  /* Max investment count when we are still allowed to change the multisig address */\n  uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n\n  using SafeMath for uint;\n\n  /* The token we are selling */\n  FractionalERC20 public token;\n\n  /* How we are going to price our offering */\n  PricingStrategy public pricingStrategy;\n\n  /* How we are going to limit our offering */\n  CeilingStrategy public ceilingStrategy;\n\n  /* Post-success callback */\n  FinalizeAgent public finalizeAgent;\n\n  /* tokens will be transfered from this address */\n  address public multisigWallet;\n\n  /* if the funding goal is not reached, investors may withdraw their funds */\n  uint public minimumFundingGoal;\n\n  /* the funding cannot exceed this cap; may be set later on during the crowdsale */\n  uint public weiFundingCap = 0;\n\n  /* the UNIX timestamp start date of the crowdsale */\n  uint public startsAt;\n\n  /* the UNIX timestamp end date of the crowdsale */\n  uint public endsAt;\n\n  /* the number of tokens already sold through this contract*/\n  uint public tokensSold = 0;\n\n  /* How many wei of funding we have raised */\n  uint public weiRaised = 0;\n\n  /* How many distinct addresses have invested */\n  uint public investorCount = 0;\n\n  /* How many wei we have returned back to the contract after a failed crowdfund. */\n  uint public loadedRefund = 0;\n\n  /* How many wei we have given back to investors.*/\n  uint public weiRefunded = 0;\n\n  /* Has this crowdsale been finalized */\n  bool public finalized;\n\n  /* Do we need to have unique contributor id for each customer */\n  bool public requireCustomerId;\n\n  /**\n    * Do we verify that contributor has been cleared on the server side (accredited investors only).\n    * This method was first used in FirstBlood crowdsale to ensure all contributors have accepted terms on sale (on the web).\n    */\n  bool public requiredSignedAddress;\n\n  /* Server side address that signed allowed contributors (Ethereum addresses) that can participate the crowdsale */\n  address public signerAddress;\n\n  /** How many ETH each address has invested to this crowdsale */\n  mapping (address => uint) public investedAmountOf;\n\n  /** How many tokens this crowdsale has credited for each investor address */\n  mapping (address => uint) public tokenAmountOf;\n\n  /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */\n  mapping (address => bool) public earlyParticipantWhitelist;\n\n  /** This is for manual testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */\n  uint public ownerTestValue;\n\n  /** State machine\n   *\n   * - Preparing: All contract initialization calls and variables have not been set yet\n   * - Prefunding: We have not passed start time yet\n   * - Funding: Active crowdsale\n   * - Success: Minimum funding goal reached\n   * - Failure: Minimum funding goal not reached before ending time\n   * - Finalized: The finalized has been called and succesfully executed\n   * - Refunding: Refunds are loaded on the contract for reclaim.\n   */\n  enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding}\n\n  // A new investment was made\n  event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n\n  // Refund was processed for a contributor\n  event Refund(address investor, uint weiAmount);\n\n  // The rules about what kind of investments we accept were changed\n  event InvestmentPolicyChanged(bool requireCustomerId, bool requiredSignedAddress, address signerAddress);\n\n  // Address early participation whitelist status changed\n  event Whitelisted(address addr, bool status);\n\n  // Crowdsale end time has been changed\n  event EndsAtChanged(uint endsAt);\n\n  function Crowdsale(address _token, PricingStrategy _pricingStrategy, CeilingStrategy _ceilingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) {\n\n    token = FractionalERC20(_token);\n\n    setPricingStrategy(_pricingStrategy);\n\n    require(_multisigWallet != 0);\n    multisigWallet = _multisigWallet;\n\n    require(_ceilingStrategy.isCeilingStrategy());\n    ceilingStrategy = _ceilingStrategy;\n\n\n    // Don't mess the dates\n    require(_start != 0 && _end != 0);\n    require(_start < _end);\n    startsAt = _start;\n    endsAt = _end;\n\n    // Minimum funding goal can be zero\n    minimumFundingGoal = _minimumFundingGoal;\n  }\n\n  /**\n   * Don't expect to just send in money and get tokens.\n   */\n  function() payable {\n    require(false);\n  }\n\n  /**\n   * Make an investment.\n   *\n   * Crowdsale must be running for one to invest.\n   * We must have not pressed the emergency brake.\n   *\n   * @param receiver The Ethereum address who receives the tokens\n   * @param customerId (optional) UUID v4 to track the successful payments on the server side\n   *\n   */\n  function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n\n    // Determine if it's a good time to accept investment from this participant\n    if(getState() == State.PreFunding) {\n      // Are we whitelisted for early deposit\n      require(earlyParticipantWhitelist[receiver]);\n    } else if(getState() == State.Funding) {\n      // Retail participants can only come in when the crowdsale is running\n      // pass\n    } else {\n      // Unwanted state\n      require(false);\n    }\n\n    uint weiAmount = ceilingStrategy.weiAllowedToReceive(msg.value, weiRaised, investedAmountOf[receiver], weiFundingCap);\n    uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n    \n    // Dust transaction if no tokens can be given\n    require(tokenAmount != 0);\n\n    if(investedAmountOf[receiver] == 0) {\n       // A new investor\n       investorCount++;\n    }\n\n    // Update investor\n    investedAmountOf[receiver] = investedAmountOf[receiver].add(weiAmount);\n    tokenAmountOf[receiver] = tokenAmountOf[receiver].add(tokenAmount);\n\n    // Update totals\n    weiRaised = weiRaised.add(weiAmount);\n    tokensSold = tokensSold.add(tokenAmount);\n\n    assignTokens(receiver, tokenAmount);\n\n    // Pocket the money\n    assert(multisigWallet.send(weiAmount));\n\n    // Return excess of money\n    uint weiToReturn = msg.value.sub(weiAmount);\n    if (weiToReturn > 0) {\n      assert(msg.sender.send(weiToReturn));\n    }\n\n    // Tell us that the investment was completed successfully\n    Invested(receiver, weiAmount, tokenAmount, customerId);\n\n  }\n\n  function setFundingCap(uint newCap) public onlyOwner {\n    weiFundingCap = ceilingStrategy.relaxFundingCap(newCap, weiRaised);\n  }\n\n  /**\n   * Preallocate tokens for the early investors.\n   *\n   * Preallocated tokens have been sold before the actual crowdsale opens.\n   * This function mints the tokens and moves the crowdsale needle.\n   *\n   * Investor count is not handled; it is assumed this goes for multiple investors\n   * and the token distribution happens outside the smart contract flow.\n   *\n   * No money is exchanged, as the crowdsale team already have received the payment.\n   *\n   * @param fullTokens tokens as full tokens - decimal places added internally\n   * @param weiPrice Price of a single full token in wei\n   *\n   */\n  function preallocate(address receiver, uint fullTokens, uint weiPrice) public onlyOwner {\n\n    uint tokenAmount = fullTokens * 10**token.decimals();\n    uint weiAmount = weiPrice * tokenAmount; // This can be also 0, in which case we give out tokens for free\n\n    weiRaised = weiRaised.add(weiAmount);\n    tokensSold = tokensSold.add(tokenAmount);\n\n    investedAmountOf[receiver] = investedAmountOf[receiver].add(weiAmount);\n    tokenAmountOf[receiver] = tokenAmountOf[receiver].add(tokenAmount);\n\n    assignTokens(receiver, tokenAmount);\n\n    // Tell us that the investment was a success\n    Invested(receiver, weiAmount, tokenAmount, 0);\n  }\n\n  /**\n   * Allow anonymous contributions to this crowdsale.\n   */\n  function investWithSignedAddress(address addr, uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\n     bytes32 hash = sha256(addr);\n     require(ecrecover(hash, v, r, s) == signerAddress);\n     require(customerId != 0);  // UUIDv4 sanity check\n     investInternal(addr, customerId);\n  }\n\n  /**\n   * Track who is the customer making the payment so we can send thank you email.\n   */\n  function investWithCustomerId(address addr, uint128 customerId) public payable {\n    require(!requiredSignedAddress); // Crowdsale allows only server-side signed participants\n    require(customerId != 0);  // UUIDv4 sanity check\n    investInternal(addr, customerId);\n  }\n\n  /**\n   * Allow anonymous contributions to this crowdsale.\n   */\n  function invest(address addr) public payable {\n    require(!requireCustomerId); // Crowdsale needs to track participants for thank you email\n    require(!requiredSignedAddress); // Crowdsale allows only server-side signed participants\n    investInternal(addr, 0);\n  }\n\n  /**\n   * Invest to tokens, recognize the payer and clear his address.\n   *\n   */\n  function buyWithSignedAddress(uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\n    investWithSignedAddress(msg.sender, customerId, v, r, s);\n  }\n\n  /**\n   * Invest to tokens, recognize the payer.\n   *\n   */\n  function buyWithCustomerId(uint128 customerId) public payable {\n    investWithCustomerId(msg.sender, customerId);\n  }\n\n  /**\n   * The basic entry point to participate the crowdsale process.\n   *\n   * Pay for funding, get invested tokens back in the sender address.\n   */\n  function buy() public payable {\n    invest(msg.sender);\n  }\n\n  /**\n   * Finalize a succcesful crowdsale.\n   *\n   * The owner can trigger a call the contract that provides post-crowdsale actions, like releasing the tokens.\n   */\n  function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n\n    // Invalid input once finalized\n    require(!finalized);\n\n    // Finalizing is optional. We only call it if we are given a finalizing agent.\n    if(address(finalizeAgent) != 0) {\n      finalizeAgent.finalizeCrowdsale();\n    }\n\n    finalized = true;\n  }\n\n  /**\n   * Allow to (re)set finalize agent.\n   *\n   * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes.\n   */\n  function setFinalizeAgent(FinalizeAgent addr) onlyOwner {\n    // Don't allow setting bad agent\n    require(addr.isFinalizeAgent());\n\n    finalizeAgent = addr;\n  }\n\n  /**\n   * Set policy do we need to have server-side customer ids for the investments.\n   *\n   */\n  function setRequireCustomerId(bool value) onlyOwner {\n    requireCustomerId = value;\n    InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\n  }\n\n  /**\n   * Set policy if all investors must be cleared on the server side first.\n   *\n   * This is e.g. for the accredited investor clearing.\n   *\n   */\n  function setRequireSignedAddress(bool value, address _signerAddress) onlyOwner {\n    requiredSignedAddress = value;\n    signerAddress = _signerAddress;\n    InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\n  }\n\n  /**\n   * Allow addresses to do early participation.\n   *\n   */\n  function setEarlyParticipantWhitelist(address addr, bool status) onlyOwner {\n    earlyParticipantWhitelist[addr] = status;\n    Whitelisted(addr, status);\n  }\n\n  /**\n   * Allow crowdsale owner to close early or extend the crowdsale.\n   *\n   * This is useful e.g. for a manual soft cap implementation:\n   * - after X amount is reached determine manual closing\n   *\n   * This may put the crowdsale to an invalid state,\n   * but we trust owners know what they are doing.\n   *\n   */\n  function setEndsAt(uint time) onlyOwner {\n    // Don't change the past\n    require(now <= time);\n\n    endsAt = time;\n    EndsAtChanged(endsAt);\n  }\n\n  /**\n   * Allow to (re)set pricing strategy.\n   *\n   * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes.\n   */\n  function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner {\n    // Don't allow setting bad agent\n    require(_pricingStrategy.isPricingStrategy());\n\n    pricingStrategy = _pricingStrategy;\n  }\n\n  /**\n   * Allow to (re)set ceiling strategy.\n   *\n   * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes.\n   */\n  function setCeilingStrategy(CeilingStrategy _ceilingStrategy) onlyOwner {\n    require(_ceilingStrategy.isCeilingStrategy());\n\n    ceilingStrategy = _ceilingStrategy;\n  }\n\n  /**\n   * Allow to change the team multisig address in the case of emergency.\n   *\n   * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun\n   * (we have done only few test transactions). After the crowdsale is started up,\n   * the multisig address stays locked for safety reasons.\n   */\n  function setMultisig(address addr) public onlyOwner {\n    // Change (?)\n    require(investorCount <= MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE);\n\n    multisigWallet = addr;\n  }\n\n  /**\n   * Allow load refunds back on the contract for the refunding.\n   *\n   * The team can transfer the funds back on the smart contract in the case that the minimum goal was not reached.\n   */\n  function loadRefund() public payable inState(State.Failure) {\n    require(msg.value != 0);\n    loadedRefund = loadedRefund.add(msg.value);\n  }\n\n  /**\n   * Investors can claim refund.\n   */\n  function refund() public inState(State.Refunding) {\n    uint weiValue = investedAmountOf[msg.sender];\n    require(weiValue != 0);\n    investedAmountOf[msg.sender] = 0;\n    weiRefunded = weiRefunded.add(weiValue);\n    Refund(msg.sender, weiValue);\n    assert(msg.sender.send(weiValue));\n  }\n\n  /**\n   * @return true if the crowdsale has raised enough money to be a success\n   */\n  function isMinimumGoalReached() public constant returns (bool reached) {\n    return weiRaised >= minimumFundingGoal;\n  }\n\n  /**\n   * Check if the contract relationship looks good.\n   */\n  function isFinalizerSane() public constant returns (bool sane) {\n    return finalizeAgent.isSane();\n  }\n\n  /**\n   * Check if the contract relationship looks good.\n   */\n  function isPricingSane() public constant returns (bool sane) {\n    return pricingStrategy.isSane(address(this));\n  }\n\n  /**\n   * Check if the contract relationship looks good.\n   */\n  function isCeilingSane() public constant returns (bool sane) {\n    return ceilingStrategy.isSane(address(this));\n  }\n\n  /**\n   * Crowdfund state machine management.\n   *\n   * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale.\n   */\n  function getState() public constant returns (State) {\n    if(finalized) return State.Finalized;\n    else if (address(finalizeAgent) == 0) return State.Preparing;\n    else if (!isFinalizerSane()) return State.Preparing;\n    else if (!isPricingSane()) return State.Preparing;\n    else if (block.timestamp < startsAt) return State.PreFunding;\n    else if (block.timestamp <= endsAt && !ceilingStrategy.isCrowdsaleFull(weiRaised, weiFundingCap)) return State.Funding;\n    else if (isMinimumGoalReached()) return State.Success;\n    else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\n    else return State.Failure;\n  }\n\n  /** This is for manual testing of multisig wallet interaction */\n  function setOwnerTestValue(uint val) onlyOwner {\n    ownerTestValue = val;\n  }\n\n  function assignTokens(address receiver, uint tokenAmount) private {\n    MintableToken mintableToken = MintableToken(token);\n    mintableToken.mint(receiver, tokenAmount);\n  }\n\n  /** Interface marker. */\n  function isCrowdsale() public constant returns (bool) {\n    return true;\n  }\n\n  //\n  // Modifiers\n  //\n\n  /** Modified allowing execution only if the crowdsale is currently running.  */\n  modifier inState(State state) {\n    require(getState() == state);\n    _;\n  }\n\n}"
    }
  ]
}