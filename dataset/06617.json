{
  "Title": "[H-02] PositionManager's `moveLiquidity` can set wrong deposit time and permanently freeze LP funds moved",
  "Content": "\n`moveLiquidity()` set new destination index LP entry deposit time to be equal to the source index deposit time, while destination bucket might have defaulted after that time.\n\nThis is generally not correct as source bucket bankruptcy is controlled (i.e. LP shares that are moved are healthy), while the destination bucket's bankruptcy time, being arbitrary, can be higher than source index deposit time, and in this case the funds will become inaccessible after such a move (i.e. healthy shares will be marked as defaulted due to incorrect deposit time used).\n\nIn other words the funds are moved from healthy non-default zone to an arbitrary point, which can be either healthy or not. In the latter case this constitutes a loss for an owner as `toIndex` bucket bankruptcy time exceeding deposit time means that all other retrieval operations will be blocked.\n\n### Impact\n\nOwner will permanently lose access to the LP shares whenever `positions[params_.tokenId][params_.toIndex]` bucket bankruptcy time is greater than `positions[params_.tokenId][params_.fromIndex].depositTime`.\n\n`moveLiquidity()` is a common operation, while source and destination bucket bankruptcy times can be related in an arbitrary manner, and the net impact is permanent fund freeze, so this is a fund loss without material prerequisites, setting the severity to be high.\n\n### Proof of Concept\n\n`moveLiquidity()` sets `toPosition` deposit time to be `fromPosition.depositTime`:\n\n<https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L262-L323>\n\n```solidity\n    function moveLiquidity(\n        MoveLiquidityParams calldata params_\n    ) external override mayInteract(params_.pool, params_.tokenId) nonReentrant {\n        Position storage fromPosition = positions[params_.tokenId][params_.fromIndex];\n\n        MoveLiquidityLocalVars memory vars;\n>>      vars.depositTime = fromPosition.depositTime;\n\n        // handle the case where owner attempts to move liquidity after they've already done so\n        if (vars.depositTime == 0) revert RemovePositionFailed();\n\n        // ensure bucketDeposit accounts for accrued interest\n        IPool(params_.pool).updateInterest();\n\n        // retrieve info of bucket from which liquidity is moved  \n        (\n            vars.bucketLP,\n            vars.bucketCollateral,\n            vars.bankruptcyTime,\n            vars.bucketDeposit,\n        ) = IPool(params_.pool).bucketInfo(params_.fromIndex);\n\n        // check that bucket hasn't gone bankrupt since memorialization\n        if (vars.depositTime <= vars.bankruptcyTime) revert BucketBankrupt();\n\n        // calculate the max amount of quote tokens that can be moved, given the tracked LP\n        vars.maxQuote = _lpToQuoteToken(\n            vars.bucketLP,\n            vars.bucketCollateral,\n            vars.bucketDeposit,\n            fromPosition.lps,\n            vars.bucketDeposit,\n            _priceAt(params_.fromIndex)\n        );\n\n        EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];\n\n        // remove bucket index from which liquidity is moved from tracked positions\n        if (!positionIndex.remove(params_.fromIndex)) revert RemovePositionFailed();\n\n        // update bucket set at which a position has liquidity\n        // slither-disable-next-line unused-return\n        positionIndex.add(params_.toIndex);\n\n        // move quote tokens in pool\n        (\n            vars.lpbAmountFrom,\n            vars.lpbAmountTo,\n        ) = IPool(params_.pool).moveQuoteToken(\n            vars.maxQuote,\n            params_.fromIndex,\n            params_.toIndex,\n            params_.expiry\n        );\n\n        Position storage toPosition = positions[params_.tokenId][params_.toIndex];\n\n        // update position LP state\n        fromPosition.lps -= vars.lpbAmountFrom;\n        toPosition.lps   += vars.lpbAmountTo;\n        // update position deposit time to the from bucket deposit time\n>>      toPosition.depositTime = vars.depositTime;\n```\n\nI.e. there is no check for `params_.toIndex` bucket situation, the time is just copied.\n\nWhile there is checking logic in LenderActions, which checks for `toBucket` bankruptcy and sets the time accordingly:\n\n<https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/libraries/external/LenderActions.sol#L315-L327>\n\n```solidity\n        vars.toBucketDepositTime = toBucketLender.depositTime;\n        if (vars.toBucketBankruptcyTime >= vars.toBucketDepositTime) {\n            // bucket is bankrupt and deposit was done before bankruptcy time, reset lender lp amount\n            toBucketLender.lps = toBucketLP_;\n\n            // set deposit time of the lender's to bucket as bucket's last bankruptcy timestamp + 1 so deposit won't get invalidated\n            vars.toBucketDepositTime = vars.toBucketBankruptcyTime + 1;\n        } else {\n            toBucketLender.lps += toBucketLP_;\n        }\n\n        // set deposit time to the greater of the lender's from bucket and the target bucket\n        toBucketLender.depositTime = Maths.max(vars.fromBucketDepositTime, vars.toBucketDepositTime);\n```\n\nThis way, while bucket structure deposit time will be controlled and updated, PositionManager's structure will have the deposit time copied over.\n\nIn the case when `positions[params_.tokenId][params_.fromIndex].depositTime` was less than `params_.toIndex` `bankruptcyTime`, this will freeze these LP funds as further attempts to use them will be blocked:\n\n<https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L262-L285>\n\n```solidity\n    function moveLiquidity(\n        MoveLiquidityParams calldata params_\n    ) external override mayInteract(params_.pool, params_.tokenId) nonReentrant {\n        Position storage fromPosition = positions[params_.tokenId][params_.fromIndex];\n\n        MoveLiquidityLocalVars memory vars;\n>>      vars.depositTime = fromPosition.depositTime;\n\n        // handle the case where owner attempts to move liquidity after they've already done so\n        if (vars.depositTime == 0) revert RemovePositionFailed();\n\n        // ensure bucketDeposit accounts for accrued interest\n        IPool(params_.pool).updateInterest();\n\n        // retrieve info of bucket from which liquidity is moved  \n        (\n            vars.bucketLP,\n            vars.bucketCollateral,\n>>          vars.bankruptcyTime,\n            vars.bucketDeposit,\n        ) = IPool(params_.pool).bucketInfo();\n\n        // check that bucket hasn't gone bankrupt since memorialization\n>>      if (vars.depositTime <= vars.bankruptcyTime) revert BucketBankrupt();\n```\n\n<https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L352-L372>\n\n```solidity\n    function reedemPositions(\n        RedeemPositionsParams calldata params_\n    ) external override mayInteract(params_.pool, params_.tokenId) {\n        EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];\n\n        ...\n\n        for (uint256 i = 0; i < indexesLength; ) {\n            index = params_.indexes[i];\n\n            Position memory position = positions[params_.tokenId][index];\n\n            if (position.depositTime == 0 || position.lps == 0) revert RemovePositionFailed();\n\n            // check that bucket didn't go bankrupt after memorialization\n>>          if (_bucketBankruptAfterDeposit(pool, index, position.depositTime)) revert BucketBankrupt();\n```\n\n<https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L436-L443>\n\n```solidity\n    function _bucketBankruptAfterDeposit(\n        IPool pool_,\n        uint256 index_,\n        uint256 depositTime_\n    ) internal view returns (bool) {\n        (, , uint256 bankruptcyTime, , ) = pool_.bucketInfo(index_);\n>>      return depositTime_ <= bankruptcyTime;\n    }\n```\n\n### Recommended Mitigation Steps\n\nConsider using the resulting time of the destination position, for example:\n\n<https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L262-L323>\n\n```diff\n    function moveLiquidity(\n        MoveLiquidityParams calldata params_\n    ) external override mayInteract(params_.pool, params_.tokenId) nonReentrant {\n        Position storage fromPosition = positions[params_.tokenId][params_.fromIndex];\n\n        MoveLiquidityLocalVars memory vars;\n        vars.depositTime = fromPosition.depositTime;\n\n        ...\n\n        Position storage toPosition = positions[params_.tokenId][params_.toIndex];\n\n        // update position LP state\n        fromPosition.lps -= vars.lpbAmountFrom;\n        toPosition.lps   += vars.lpbAmountTo;\n-       // update position deposit time to the from bucket deposit time\n+       // update position deposit time with the renewed to bucket deposit time\n+       (, vars.depositTime) = pool.lenderInfo(params_.toIndex, address(this));\n        toPosition.depositTime = vars.depositTime;\n```\n\nNotice, that this time value will be influenced by the other PositionManager positions in the `params_.toIndex` bucket, but the surface described will be closed as it will be controlled against `params_.toIndex` bucket bankruptcy time.\n\n**[ith-harvey (Ajna) confirmed](https://github.com/code-423n4/2023-05-ajna-findings/issues/494#issuecomment-1554797890)**\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-05-ajna",
  "Code": [
    {
      "filename": "ajna-core/src/PositionManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { ERC20 }           from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport { IERC20 }          from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { ERC721 }          from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport { EnumerableSet }   from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport { Multicall }       from '@openzeppelin/contracts/utils/Multicall.sol';\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport { SafeERC20 }       from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport { IPool }                        from './interfaces/pool/IPool.sol';\nimport { IPositionManager }             from './interfaces/position/IPositionManager.sol';\nimport { IPositionManagerOwnerActions } from './interfaces/position/IPositionManagerOwnerActions.sol';\nimport { IPositionManagerDerivedState } from './interfaces/position/IPositionManagerDerivedState.sol';\nimport { Position }                     from './interfaces/position/IPositionManagerState.sol';\n\nimport { ERC20PoolFactory }  from './ERC20PoolFactory.sol';\nimport { ERC721PoolFactory } from './ERC721PoolFactory.sol';\n\nimport { PermitERC721 } from './base/PermitERC721.sol';\n\nimport {\n    _lpToQuoteToken,\n    _priceAt\n}                      from './libraries/helpers/PoolHelper.sol';\nimport { tokenSymbol } from './libraries/helpers/SafeTokenNamer.sol';\n\nimport { PositionNFTSVG } from './libraries/external/PositionNFTSVG.sol';\n\n/**\n *  @title  Position Manager Contract\n *  @notice Used by Pool lenders to optionally mint `NFT` that represents their positions.\n *          `Lenders` can:\n *          - `mint` positions `NFT` token for a specific pool\n *          - `memorialize` positions for given buckets\n *          - `move liquidity` in pool\n *          - `redeem` positions for given buckets\n *          - `burn` positions `NFT`\n */\ncontract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, ReentrancyGuard {\n\n    using EnumerableSet for EnumerableSet.UintSet;\n    using SafeERC20     for ERC20;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /// @dev Mapping of `token id => ajna pool address` for which token was minted.\n    mapping(uint256 => address) public override poolKey;\n\n    /// @dev Mapping of `token id => ajna pool address` for which token was minted.\n    mapping(uint256 => mapping(uint256 => Position)) internal positions;\n    /// @dev Mapping of `token id => nonce` value used for permit.\n    mapping(uint256 => uint96)                       internal nonces;\n    /// @dev Mapping of `token id => bucket indexes` associated with position.\n    mapping(uint256 => EnumerableSet.UintSet)        internal positionIndexes;\n\n    /// @dev Id of the next token that will be minted. Skips `0`.\n    uint176 private _nextId = 1;\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @dev The `ERC20` pools factory contract, used to check if address is an `Ajna` pool.\n    ERC20PoolFactory  private immutable erc20PoolFactory;\n    /// @dev The `ERC721` pools factory contract, used to check if address is an `Ajna` pool.\n    ERC721PoolFactory private immutable erc721PoolFactory;\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    /// @dev Struct used for `moveLiquidity` function local vars.\n    struct MoveLiquidityLocalVars {\n        uint256 bucketLP;         // [WAD] amount of LP in from bucket\n        uint256 bucketCollateral; // [WAD] amount of collateral in from bucket\n        uint256 bankruptcyTime;   // from bucket bankruptcy time\n        uint256 bucketDeposit;    // [WAD] from bucket deposit\n        uint256 depositTime;      // lender deposit time in from bucekt\n        uint256 maxQuote;         // [WAD] max amount that can be moved from bucket\n        uint256 lpbAmountFrom;    // [WAD] the LP redeemed from bucket\n        uint256 lpbAmountTo;      // [WAD] the LP awarded in to bucket\n    }\n\n    /*****************/\n    /*** Modifiers ***/\n    /*****************/\n\n    /**\n     *  @dev   Modifier used to check if sender can interact with token id.\n     *  @param pool_    `Ajna` pool address.\n     *  @param tokenId_ Id of positions `NFT`.\n     */\n    modifier mayInteract(address pool_, uint256 tokenId_) {\n\n        // revert if token id is not a valid / minted id\n        _requireMinted(tokenId_);\n\n        // revert if sender is not owner of or entitled to operate on token id\n        if (!_isApprovedOrOwner(msg.sender, tokenId_)) revert NoAuth();\n\n        // revert if the token id is not minted for given pool address\n        if (pool_ != poolKey[tokenId_]) revert WrongPool();\n\n        _;\n    }\n\n    /*******************/\n    /*** Constructor ***/\n    /*******************/\n\n    constructor(\n        ERC20PoolFactory erc20Factory_,\n        ERC721PoolFactory erc721Factory_\n    ) PermitERC721(\"Ajna Positions NFT-V1\", \"AJNA-V1-POS\", \"1\") {\n        erc20PoolFactory  = erc20Factory_;\n        erc721PoolFactory = erc721Factory_;\n    }\n\n    /********************************/\n    /*** Owner External Functions ***/\n    /********************************/\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    === Write state ===\n     *  @dev    `nonces`: remove `tokenId` nonce\n     *  @dev    `poolKey`: remove `tokenId => pool` mapping\n     *  @dev    === Revert on ===\n     *  @dev    - `mayInteract`:\n     *  @dev       token id is not a valid / minted id\n     *  @dev       sender is not owner `NoAuth()`\n     *  @dev       token id not minted for given pool `WrongPool()`\n     *  @dev    - positions token to burn has liquidity `LiquidityNotRemoved()`\n     *  @dev    === Emit events ===\n     *  @dev    - `Burn`\n     */\n    function burn(\n        BurnParams calldata params_\n    ) external override mayInteract(params_.pool, params_.tokenId) {\n        // revert if trying to burn an positions token that still has liquidity\n        if (positionIndexes[params_.tokenId].length() != 0) revert LiquidityNotRemoved();\n\n        // remove permit nonces and pool mapping for burned token\n        delete nonces[params_.tokenId];\n        delete poolKey[params_.tokenId];\n\n        _burn(params_.tokenId);\n\n        emit Burn(msg.sender, params_.tokenId);\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    External calls to `Pool` contract:\n     *  @dev    - `lenderInfo()`: get lender position in bucket\n     *  @dev    - `transferLP()`: transfer `LP` ownership to `PositionManager` contract\n     *  @dev    === Write state ===\n     *  @dev    `positionIndexes`: add bucket index\n     *  @dev    `positions`: update `tokenId => bucket id` position\n     *  @dev    === Revert on ===\n     *  @dev    positions token to burn has liquidity `LiquidityNotRemoved()`\n     *  @dev    === Emit events ===\n     *  @dev    - `MemorializePosition`\n     */\n    function memorializePositions(\n        MemorializePositionsParams calldata params_\n    ) external override {\n        EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];\n\n        IPool   pool  = IPool(poolKey[params_.tokenId]);\n        address owner = ownerOf(params_.tokenId);\n\n        uint256 indexesLength = params_.indexes.length;\n        uint256 index;\n\n        for (uint256 i = 0; i < indexesLength; ) {\n            index = params_.indexes[i];\n\n            // record bucket index at which a position has added liquidity\n            // slither-disable-next-line unused-return\n            positionIndex.add(index);\n\n            (uint256 lpBalance, uint256 depositTime) = pool.lenderInfo(index, owner);\n\n            Position memory position = positions[params_.tokenId][index];\n\n            // check for previous deposits\n            if (position.depositTime != 0) {\n                // check that bucket didn't go bankrupt after prior memorialization\n                if (_bucketBankruptAfterDeposit(pool, index, position.depositTime)) {\n                    // if bucket did go bankrupt, zero out the LP tracked by position manager\n                    position.lps = 0;\n                }\n            }\n\n            // update token position LP\n            position.lps += lpBalance;\n            // set token's position deposit time to the original lender's deposit time\n            position.depositTime = depositTime;\n\n            // save position in storage\n            positions[params_.tokenId][index] = position;\n\n            unchecked { ++i; }\n        }\n\n        // update pool LP accounting and transfer ownership of LP to PositionManager contract\n        pool.transferLP(owner, address(this), params_.indexes);\n\n        emit MemorializePosition(owner, params_.tokenId, params_.indexes);\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    === Write state ===\n     *  @dev    `poolKey`: update `tokenId => pool` mapping\n     *  @dev    === Revert on ===\n     *  @dev    provided pool not valid `NotAjnaPool()`\n     *  @dev    === Emit events ===\n     *  @dev    - `Mint`\n     */\n    function mint(\n        MintParams calldata params_\n    ) external override nonReentrant returns (uint256 tokenId_) {\n        tokenId_ = _nextId++;\n\n        // revert if the address is not a valid Ajna pool\n        if (!_isAjnaPool(params_.pool, params_.poolSubsetHash)) revert NotAjnaPool();\n\n        // record which pool the tokenId was minted in\n        poolKey[tokenId_] = params_.pool;\n\n        _mint(params_.recipient, tokenId_);\n\n        emit Mint(params_.recipient, params_.pool, tokenId_);\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    External calls to `Pool` contract:\n     *  @dev    `bucketInfo()`: get from bucket info\n     *  @dev    `moveQuoteToken()`: move liquidity between buckets\n     *  @dev    === Write state ===\n     *  @dev    `positionIndexes`: remove from bucket index\n     *  @dev    `positionIndexes`: add to bucket index\n     *  @dev    `positions`: update from bucket position\n     *  @dev    `positions`: update to bucket position\n     *  @dev    === Revert on ===\n     *  @dev    - `mayInteract`:\n     *  @dev      token id is not a valid / minted id\n     *  @dev      sender is not owner `NoAuth()`\n     *  @dev      token id not minted for given pool `WrongPool()`\n     *  @dev    - positions token to burn has liquidity `LiquidityNotRemoved()`\n     *  @dev    === Emit events ===\n     *  @dev    - `MoveLiquidity`\n     */\n    function moveLiquidity(\n        MoveLiquidityParams calldata params_\n    ) external override mayInteract(params_.pool, params_.tokenId) nonReentrant {\n        Position storage fromPosition = positions[params_.tokenId][params_.fromIndex];\n\n        MoveLiquidityLocalVars memory vars;\n        vars.depositTime = fromPosition.depositTime;\n\n        // handle the case where owner attempts to move liquidity after they've already done so\n        if (vars.depositTime == 0) revert RemovePositionFailed();\n\n        // ensure bucketDeposit accounts for accrued interest\n        IPool(params_.pool).updateInterest();\n\n        // retrieve info of bucket from which liquidity is moved  \n        (\n            vars.bucketLP,\n            vars.bucketCollateral,\n            vars.bankruptcyTime,\n            vars.bucketDeposit,\n        ) = IPool(params_.pool).bucketInfo(params_.fromIndex);\n\n        // check that bucket hasn't gone bankrupt since memorialization\n        if (vars.depositTime <= vars.bankruptcyTime) revert BucketBankrupt();\n\n        // calculate the max amount of quote tokens that can be moved, given the tracked LP\n        vars.maxQuote = _lpToQuoteToken(\n            vars.bucketLP,\n            vars.bucketCollateral,\n            vars.bucketDeposit,\n            fromPosition.lps,\n            vars.bucketDeposit,\n            _priceAt(params_.fromIndex)\n        );\n\n        EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];\n\n        // remove bucket index from which liquidity is moved from tracked positions\n        if (!positionIndex.remove(params_.fromIndex)) revert RemovePositionFailed();\n\n        // update bucket set at which a position has liquidity\n        // slither-disable-next-line unused-return\n        positionIndex.add(params_.toIndex);\n\n        // move quote tokens in pool\n        (\n            vars.lpbAmountFrom,\n            vars.lpbAmountTo,\n        ) = IPool(params_.pool).moveQuoteToken(\n            vars.maxQuote,\n            params_.fromIndex,\n            params_.toIndex,\n            params_.expiry\n        );\n\n        Position storage toPosition = positions[params_.tokenId][params_.toIndex];\n\n        // update position LP state\n        fromPosition.lps -= vars.lpbAmountFrom;\n        toPosition.lps   += vars.lpbAmountTo;\n        // update position deposit time to the from bucket deposit time\n        toPosition.depositTime = vars.depositTime;\n\n        emit MoveLiquidity(\n            ownerOf(params_.tokenId),\n            params_.tokenId,\n            params_.fromIndex,\n            params_.toIndex,\n            vars.lpbAmountFrom,\n            vars.lpbAmountTo\n        );\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    External calls to `Pool` contract:\n     *  @dev    `increaseLPAllowance()`: approve ownership for transfer\n     *  @dev    `transferLP()`: transfer `LP` ownership from `PositionManager` contract\n     *  @dev    === Write state ===\n     *  @dev    `positionIndexes`: remove from bucket index\n     *  @dev    `positions`: delete bucket position\n     *  @dev    === Revert on ===\n     *  @dev    - `mayInteract`:\n     *  @dev      token id is not a valid / minted id\n     *  @dev      sender is not owner `NoAuth()`\n     *  @dev      token id not minted for given pool `WrongPool()`\n     *  @dev    - position not tracked `RemoveLiquidityFailed()`\n     *  @dev    === Emit events ===\n     *  @dev    - `RedeemPosition`\n     */\n    function reedemPositions(\n        RedeemPositionsParams calldata params_\n    ) external override mayInteract(params_.pool, params_.tokenId) {\n        EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];\n\n        IPool pool = IPool(params_.pool);\n\n        uint256 indexesLength = params_.indexes.length;\n        uint256[] memory lpAmounts = new uint256[](indexesLength);\n\n        uint256 index;\n\n        for (uint256 i = 0; i < indexesLength; ) {\n            index = params_.indexes[i];\n\n            Position memory position = positions[params_.tokenId][index];\n\n            if (position.depositTime == 0 || position.lps == 0) revert RemovePositionFailed();\n\n            // check that bucket didn't go bankrupt after memorialization\n            if (_bucketBankruptAfterDeposit(pool, index, position.depositTime)) revert BucketBankrupt();\n\n            // remove bucket index at which a position has added liquidity\n            if (!positionIndex.remove(index)) revert RemovePositionFailed();\n\n            lpAmounts[i] = position.lps;\n\n            // remove LP tracked by position manager at bucket index\n            delete positions[params_.tokenId][index];\n\n            unchecked { ++i; }\n        }\n\n        address owner = ownerOf(params_.tokenId);\n\n        // approve owner to take over the LP ownership (required for transferLP pool call)\n        pool.increaseLPAllowance(owner, params_.indexes, lpAmounts);\n        // update pool lps accounting and transfer ownership of lps from PositionManager contract\n        pool.transferLP(address(this), owner, params_.indexes);\n\n        emit RedeemPosition(owner, params_.tokenId, params_.indexes);\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    /**\n     *  @notice Retrieves token's next nonce for permit.\n     *  @param  tokenId_ Address of the `Ajna` pool to retrieve accumulators of.\n     *  @return Incremented token permit nonce.\n     */\n    function _getAndIncrementNonce(\n        uint256 tokenId_\n    ) internal override returns (uint256) {\n        return uint256(nonces[tokenId_]++);\n    }\n\n    /**\n     *  @notice Checks that a provided pool address was deployed by an `Ajna` factory.\n     *  @param  pool_       Address of the `Ajna` pool.\n     *  @param  subsetHash_ Factory's subset hash pool.\n     *  @return `True` if a valid `Ajna` pool, `false` otherwise.\n     */\n    function _isAjnaPool(\n        address pool_,\n        bytes32 subsetHash_\n    ) internal view returns (bool) {\n        address collateralAddress = IPool(pool_).collateralAddress();\n        address quoteAddress      = IPool(pool_).quoteTokenAddress();\n\n        address erc20DeployedPoolAddress  = erc20PoolFactory.deployedPools(subsetHash_, collateralAddress, quoteAddress);\n        address erc721DeployedPoolAddress = erc721PoolFactory.deployedPools(subsetHash_, collateralAddress, quoteAddress);\n\n        return (pool_ == erc20DeployedPoolAddress || pool_ == erc721DeployedPoolAddress);\n    }\n\n    /**\n     *  @notice Checks that a bucket index associated with a given `NFT` didn't go bankrupt after memorialization.\n     *  @param  pool_        The address of the pool of memorialized position.\n     *  @param  index_       The bucket index to check deposit time for.\n     *  @param  depositTime_ The recorded deposit time of the position.\n     *  @return `True` if the bucket went bankrupt after that position memorialzied their `LP`.\n     */\n    function _bucketBankruptAfterDeposit(\n        IPool pool_,\n        uint256 index_,\n        uint256 depositTime_\n    ) internal view returns (bool) {\n        (, , uint256 bankruptcyTime, , ) = pool_.bucketInfo(index_);\n        return depositTime_ <= bankruptcyTime;\n    }\n\n    /**********************/\n    /*** View Functions ***/\n    /**********************/\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function getLP(\n        uint256 tokenId_,\n        uint256 index_\n    ) external override view returns (uint256) {\n        Position memory position = positions[tokenId_][index_];\n        return _bucketBankruptAfterDeposit(IPool(poolKey[tokenId_]), index_, position.depositTime) ? 0 : position.lps;\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function getPositionIndexes(\n        uint256 tokenId_\n    ) external view override returns (uint256[] memory) {\n        return positionIndexes[tokenId_].values();\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function getPositionIndexesFiltered(\n        uint256 tokenId_\n    ) external view override returns (uint256[] memory filteredIndexes_) {\n        uint256[] memory indexes = positionIndexes[tokenId_].values();\n        uint256 indexesLength = indexes.length;\n\n        // filter out bankrupt buckets\n        filteredIndexes_ = new uint256[](indexesLength);\n        uint256 filteredIndexesLength = 0;\n        IPool pool = IPool(poolKey[tokenId_]);\n        for (uint256 i = 0; i < indexesLength; ) {\n            if (!_bucketBankruptAfterDeposit(pool, indexes[i], positions[tokenId_][indexes[i]].depositTime)) {\n                filteredIndexes_[filteredIndexesLength++] = indexes[i];\n            }\n            unchecked { ++i; }\n        }\n\n        // resize array\n        assembly { mstore(filteredIndexes_, filteredIndexesLength) }\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function getPositionInfo(\n        uint256 tokenId_,\n        uint256 index_\n    ) external view override returns (uint256, uint256) {\n        return (\n            positions[tokenId_][index_].lps,\n            positions[tokenId_][index_].depositTime\n        );\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function isPositionBucketBankrupt(\n        uint256 tokenId_,\n        uint256 index_\n    ) external view override returns (bool) {\n        return _bucketBankruptAfterDeposit(IPool(poolKey[tokenId_]), index_, positions[tokenId_][index_].depositTime);\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function isIndexInPosition(\n        uint256 tokenId_,\n        uint256 index_\n    ) external override view returns (bool) {\n        return positionIndexes[tokenId_].contains(index_);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(\n        uint256 tokenId_\n    ) public view override(ERC721) returns (string memory) {\n        require(_exists(tokenId_));\n\n        address collateralTokenAddress = IPool(poolKey[tokenId_]).collateralAddress();\n        address quoteTokenAddress      = IPool(poolKey[tokenId_]).quoteTokenAddress();\n\n        PositionNFTSVG.ConstructTokenURIParams memory params = PositionNFTSVG.ConstructTokenURIParams({\n            collateralTokenSymbol: tokenSymbol(collateralTokenAddress),\n            quoteTokenSymbol:      tokenSymbol(quoteTokenAddress),\n            tokenId:               tokenId_,\n            pool:                  poolKey[tokenId_],\n            owner:                 ownerOf(tokenId_),\n            indexes:               positionIndexes[tokenId_].values()\n        });\n\n        return PositionNFTSVG.constructTokenURI(params);\n    }\n\n}"
    },
    {
      "filename": "ajna-core/src/libraries/external/LenderActions.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport {\n    AddQuoteParams,\n    MoveQuoteParams,\n    RemoveQuoteParams\n}                     from '../../interfaces/pool/commons/IPoolInternals.sol';\nimport {\n    Bucket,\n    DepositsState,\n    Lender,\n    PoolState\n}                     from '../../interfaces/pool/commons/IPoolState.sol';\n\nimport { _depositFeeRate, _priceAt, MAX_FENWICK_INDEX } from '../helpers/PoolHelper.sol';\n\nimport { Deposits } from '../internal/Deposits.sol';\nimport { Buckets }  from '../internal/Buckets.sol';\nimport { Maths }    from '../internal/Maths.sol';\n\n/**\n    @title  LenderActions library\n    @notice External library containing logic for lender actors:\n            - `Lenders`: add, remove and move quote tokens;\n            - `Traders`: add, remove and move quote tokens; add and remove collateral\n */\nlibrary LenderActions {\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    /// @dev Struct used for `moveQuoteToken` function local vars.\n    struct MoveQuoteLocalVars {\n        uint256 fromBucketPrice;            // [WAD] Price of the bucket to move amount from.\n        uint256 fromBucketCollateral;       // [WAD] Total amount of collateral in from bucket.\n        uint256 fromBucketLP;               // [WAD] Total amount of LP in from bucket.\n        uint256 fromBucketLenderLP;         // [WAD] Amount of LP owned by lender in from bucket.\n        uint256 fromBucketDepositTime;      // Time of lender deposit in the bucket to move amount from.\n        uint256 fromBucketRemainingLP;      // Amount of LP remaining in from bucket after move.\n        uint256 fromBucketRemainingDeposit; // Amount of scaled deposit remaining in from bucket after move.\n        uint256 toBucketPrice;              // [WAD] Price of the bucket to move amount to.\n        uint256 toBucketBankruptcyTime;     // Time the bucket to move amount to was marked as insolvent.\n        uint256 toBucketDepositTime;        // Time of lender deposit in the bucket to move amount to.\n        uint256 toBucketUnscaledDeposit;    // Amount of unscaled deposit in to bucket.\n        uint256 toBucketDeposit;            // Amount of scaled deposit in to bucket.\n        uint256 toBucketScale;              // Scale deposit of to bucket.\n        uint256 ptp;                        // [WAD] Pool Threshold Price.\n        uint256 htp;                        // [WAD] Highest Threshold Price.\n    }\n\n    /// @dev Struct used for `removeQuoteToken` function local vars.\n    struct RemoveDepositParams {\n        uint256 depositConstraint; // [WAD] Constraint on deposit in quote token.\n        uint256 lpConstraint;      // [WAD] Constraint in LPB terms.\n        uint256 bucketLP;          // [WAD] Total LPB in the bucket.\n        uint256 bucketCollateral;  // [WAD] Claimable collateral in the bucket.\n        uint256 price;             // [WAD] Price of bucket.\n        uint256 index;             // Bucket index.\n        uint256 dustLimit;         // Minimum amount of deposit which may reside in a bucket.\n    }\n\n    /**************/\n    /*** Events ***/\n    /**************/\n\n    // See `IPoolEvents` for descriptions\n    event AddQuoteToken(address indexed lender, uint256 indexed index, uint256 amount, uint256 lpAwarded, uint256 lup);\n    event BucketBankruptcy(uint256 indexed index, uint256 lpForfeited);\n    event MoveQuoteToken(address indexed lender, uint256 indexed from, uint256 indexed to, uint256 amount, uint256 lpRedeemedFrom, uint256 lpAwardedTo, uint256 lup);\n    event RemoveQuoteToken(address indexed lender, uint256 indexed index, uint256 amount, uint256 lpRedeemed, uint256 lup);\n\n    /**************/\n    /*** Errors ***/\n    /**************/\n\n    // See `IPoolErrors` for descriptions\n    error BucketBankruptcyBlock();\n    error CannotMergeToHigherPrice();\n    error DustAmountNotExceeded();\n    error InvalidIndex();\n    error InvalidAmount();\n    error LUPBelowHTP();\n    error NoClaim();\n    error InsufficientLP();\n    error InsufficientLiquidity();\n    error InsufficientCollateral();\n    error MoveToSameIndex();\n\n    /***************************/\n    /***  External Functions ***/\n    /***************************/\n\n    /**\n     *  @notice See `IERC20PoolLenderActions` and `IERC721PoolLenderActions` for descriptions\n     *  @dev    === Write state ===\n     *  @dev    - `Buckets.addCollateral`:\n     *  @dev      increment `bucket.collateral` and `bucket.lps` accumulator\n     *  @dev      `addLenderLP`: increment `lender.lps` accumulator and `lender.depositTime `state\n     *  @dev    === Reverts on ===\n     *  @dev    invalid bucket index `InvalidIndex()`\n     */\n    function addCollateral(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        uint256 collateralAmountToAdd_,\n        uint256 index_\n    ) external returns (uint256 bucketLP_) {\n        // revert if no amount to be added\n        if (collateralAmountToAdd_ == 0) revert InvalidAmount();\n        // revert if adding at invalid index\n        if (index_ == 0 || index_ > MAX_FENWICK_INDEX) revert InvalidIndex();\n\n        uint256 bucketDeposit = Deposits.valueAt(deposits_, index_);\n        uint256 bucketPrice   = _priceAt(index_);\n\n        bucketLP_ = Buckets.addCollateral(\n            buckets_[index_],\n            msg.sender,\n            bucketDeposit,\n            collateralAmountToAdd_,\n            bucketPrice\n        );\n    }\n\n    /**\n     *  @notice See `IPoolLenderActions` for descriptions\n     *  @dev    === Write state ===\n     *  @dev    - `Deposits.unscaledAdd` (add new amount in `Fenwick` tree): update `values` array state \n     *  @dev    - increment `bucket.lps` accumulator\n     *  @dev    - increment `lender.lps` accumulator and `lender.depositTime` state\n     *  @dev    === Reverts on ===\n     *  @dev    invalid bucket index `InvalidIndex()`\n     *  @dev    same block when bucket becomes insolvent `BucketBankruptcyBlock()`\n     *  @dev    === Emit events ===\n     *  @dev    - `AddQuoteToken`\n     */\n    function addQuoteToken(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        PoolState calldata poolState_,\n        AddQuoteParams calldata params_\n    ) external returns (uint256 bucketLP_, uint256 lup_) {\n        // revert if no amount to be added\n        if (params_.amount == 0) revert InvalidAmount();\n        // revert if adding to an invalid index\n        if (params_.index == 0 || params_.index > MAX_FENWICK_INDEX) revert InvalidIndex();\n\n        Bucket storage bucket = buckets_[params_.index];\n\n        uint256 bankruptcyTime = bucket.bankruptcyTime;\n\n        // cannot deposit in the same block when bucket becomes insolvent\n        if (bankruptcyTime == block.timestamp) revert BucketBankruptcyBlock();\n\n        uint256 unscaledBucketDeposit = Deposits.unscaledValueAt(deposits_, params_.index);\n        uint256 bucketScale           = Deposits.scale(deposits_, params_.index);\n        uint256 bucketDeposit         = Maths.wmul(bucketScale, unscaledBucketDeposit);\n        uint256 bucketPrice           = _priceAt(params_.index);\n        uint256 addedAmount           = params_.amount;\n\n        // charge unutilized deposit fee where appropriate\n        uint256 lupIndex = Deposits.findIndexOfSum(deposits_, poolState_.debt);\n        bool depositBelowLup = lupIndex != 0 && params_.index > lupIndex;\n        if (depositBelowLup) {\n            addedAmount = Maths.wmul(addedAmount, Maths.WAD - _depositFeeRate(poolState_.rate));\n        }\n\n        bucketLP_ = Buckets.quoteTokensToLP(\n            bucket.collateral,\n            bucket.lps,\n            bucketDeposit,\n            addedAmount,\n            bucketPrice\n        );\n\n        Deposits.unscaledAdd(deposits_, params_.index, Maths.wdiv(addedAmount, bucketScale));\n\n        // update lender LP\n        Buckets.addLenderLP(bucket, bankruptcyTime, msg.sender, bucketLP_);\n\n        // update bucket LP\n        bucket.lps += bucketLP_;\n\n        // only need to recalculate LUP if the deposit was above it\n        if (!depositBelowLup) {\n            lupIndex = Deposits.findIndexOfSum(deposits_, poolState_.debt);\n        }\n        lup_ = _priceAt(lupIndex);\n\n        emit AddQuoteToken(\n            msg.sender,\n            params_.index,\n            addedAmount,\n            bucketLP_,\n            lup_\n        );\n    }\n\n    /**\n     *  @notice See `IPoolLenderActions` for descriptions\n     *  @dev    === Write state ===\n     *  @dev    - `_removeMaxDeposit`:\n     *  @dev      `Deposits.unscaledRemove` (remove amount in `Fenwick` tree, from index): update `values` array state\n     *  @dev    - `Deposits.unscaledAdd` (add amount in `Fenwick` tree, to index): update `values` array state\n     *  @dev    - decrement `lender.lps` accumulator for from bucket\n     *  @dev    - increment `lender.lps` accumulator and `lender.depositTime` state for to bucket\n     *  @dev    - decrement `bucket.lps` accumulator for from bucket\n     *  @dev    - increment `bucket.lps` accumulator for to bucket\n     *  @dev    === Reverts on ===\n     *  @dev    same index `MoveToSameIndex()`\n     *  @dev    dust amount `DustAmountNotExceeded()`\n     *  @dev    invalid index `InvalidIndex()`\n     *  @dev    === Emit events ===\n     *  @dev    - `BucketBankruptcy`\n     *  @dev    - `MoveQuoteToken`\n     */\n    function moveQuoteToken(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        PoolState calldata poolState_,\n        MoveQuoteParams calldata params_\n    ) external returns (uint256 fromBucketRedeemedLP_, uint256 toBucketLP_, uint256 movedAmount_, uint256 lup_) {\n        if (params_.maxAmountToMove == 0)\n            revert InvalidAmount();\n        if (params_.fromIndex == params_.toIndex)\n            revert MoveToSameIndex();\n        if (params_.maxAmountToMove != 0 && params_.maxAmountToMove < poolState_.quoteDustLimit)\n            revert DustAmountNotExceeded();\n        if (params_.toIndex == 0 || params_.toIndex > MAX_FENWICK_INDEX) \n            revert InvalidIndex();\n\n        Bucket storage toBucket = buckets_[params_.toIndex];\n\n        MoveQuoteLocalVars memory vars;\n        vars.toBucketBankruptcyTime = toBucket.bankruptcyTime;\n\n        // cannot move in the same block when target bucket becomes insolvent\n        if (vars.toBucketBankruptcyTime == block.timestamp) revert BucketBankruptcyBlock();\n\n        Bucket storage fromBucket       = buckets_[params_.fromIndex];\n        Lender storage fromBucketLender = fromBucket.lenders[msg.sender];\n\n        vars.fromBucketPrice       = _priceAt(params_.fromIndex);\n        vars.fromBucketCollateral  = fromBucket.collateral;\n        vars.fromBucketLP          = fromBucket.lps;\n        vars.fromBucketDepositTime = fromBucketLender.depositTime;\n\n        vars.toBucketPrice         = _priceAt(params_.toIndex);\n\n        if (fromBucket.bankruptcyTime < vars.fromBucketDepositTime) vars.fromBucketLenderLP = fromBucketLender.lps;\n\n        (movedAmount_, fromBucketRedeemedLP_, vars.fromBucketRemainingDeposit) = _removeMaxDeposit(\n            deposits_,\n            RemoveDepositParams({\n                depositConstraint: params_.maxAmountToMove,\n                lpConstraint:      vars.fromBucketLenderLP,\n                bucketLP:          vars.fromBucketLP,\n                bucketCollateral:  vars.fromBucketCollateral,\n                price:             vars.fromBucketPrice,\n                index:             params_.fromIndex,\n                dustLimit:         poolState_.quoteDustLimit"
    }
  ]
}