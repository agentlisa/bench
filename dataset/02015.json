{
  "Title": "M-13: A borrower/lender or liquidator will fail to withdraw the collateral assets due to reaching a gas limit",
  "Content": "# Issue M-13: A borrower/lender or liquidator will fail to withdraw the collateral assets due to reaching a gas limit \n\nSource: https://github.com/sherlock-audit/2023-03-teller-judging/issues/357 \n\n## Found by \n0xmuxyz, HonorLt, cccz, yixxas\n## Summary\nWithin the TellerV2#`submitBid()`, there is no limitation that how many collateral assets a borrower can assign into the `_collateralInfo` array parameter.\n\nThis lead to some bad scenarios like this due to reaching gas limit:\n- A borrower or a lender fail to withdraw the collateral assets when the loan would not be liquidated.\n- A liquidator will fail to withdraw the collateral assets when the loan would be liquidated.\n\n## Vulnerability Detail\n\nWithin the ICollateralEscrowV1, the `Collateral` struct would be defined line this:\nhttps://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/interfaces/escrow/ICollateralEscrowV1.sol#L10-L15\n```solidity\nstruct Collateral {\n    CollateralType _collateralType;\n    uint256 _amount;\n    uint256 _tokenId;\n    address _collateralAddress;\n}\n```\n\nWithin the CollateralManager, the CollateralInfo struct would be defined like this:\nhttps://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/CollateralManager.sol#L34-L37\n```solidity\n    /**\n     * Since collateralInfo is mapped (address assetAddress => Collateral) that means\n     * that only a single tokenId per nft per loan can be collateralized.\n     * Ex. Two bored apes cannot be used as collateral for a single loan.\n     */\n    struct CollateralInfo {\n        EnumerableSetUpgradeable.AddressSet collateralAddresses;\n        mapping(address => Collateral) collateralInfo;\n    }\n```\n\nWithin the CollateralManager, the `_bidCollaterals` storage would be defined like this:\nhttps://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/CollateralManager.sol#L27\n```solidity\n    // bidIds -> validated collateral info\n    mapping(uint256 => CollateralInfo) internal _bidCollaterals;\n```\n\nWhen a borrower submits a bid, the TellerV2#`submitBid()` would be called.\nWithin the TellerV2#`submitBid()`, multiple collaterals, which are ERC20/ERC721/ERC1155, can be assigned into the `_collateralInfo` array parameter by a borrower.\nAnd then, these collateral assets stored into the `_collateralInfo` array would be associated with `bidId_` through internally calling the CollateralManager#`commitCollateral()` like this:\nhttps://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/TellerV2.sol#L311\nhttps://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/TellerV2.sol#L325\n```solidity\n    function submitBid(\n        address _lendingToken,\n        uint256 _marketplaceId,\n        uint256 _principal,\n        uint32 _duration,\n        uint16 _APR,\n        string calldata _metadataURI,\n        address _receiver,\n        Collateral[] calldata _collateralInfo /// @audit\n    ) public override whenNotPaused returns (uint256 bidId_) {\n        ...\n        bool validation = collateralManager.commitCollateral(\n            bidId_,\n            _collateralInfo /// @audit \n        );\n        ...\n```\n\nWithin the CollateralManager#`commitCollateral()`, each collateral asset (`info`) would be associated with a `_bidId` respectively by calling the CollateralManager#`_commitCollateral()` in the for-loop like this:\nhttps://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/CollateralManager.sol#L127\n```solidity\n    /**\n     * @notice Checks the validity of a borrower's multiple collateral balances and commits it to a bid.\n     * @param _bidId The id of the associated bid.\n     * @param _collateralInfo Additional information about the collateral assets.\n     * @return validation_ Boolean indicating if the collateral balances were validated.\n     */\n    function commitCollateral(\n        uint256 _bidId,\n        Collateral[] calldata _collateralInfo  /// @audit\n    ) public returns (bool validation_) {\n        address borrower = tellerV2.getLoanBorrower(_bidId);\n        (validation_, ) = checkBalances(borrower, _collateralInfo);\n\n        if (validation_) {\n            for (uint256 i; i < _collateralInfo.length; i++) {    \n                Collateral memory info = _collateralInfo[i];\n                _commitCollateral(_bidId, info);  /// @audit\n            }\n        }\n    }\n```\n\nWithin the CollateralManager#`_commitCollateral()`, the `_collateralInfo` would be stored into the `_bidCollaterals` storage like this:\nhttps://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/CollateralManager.sol#L428\nhttps://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/CollateralManager.sol#L430-L434\n```solidity\n    /**\n     * @notice Checks the validity of a borrower's collateral balance and commits it to a bid.\n     * @param _bidId The id of the associated bid.\n     * @param _collateralInfo Additional information about the collateral asset.\n     */\n    function _commitCollateral(\n        uint256 _bidId,\n        Collateral memory _collateralInfo\n    ) internal virtual {\n        CollateralInfo storage collateral = _bidCollaterals[_bidId];\n        collateral.collateralAddresses.add(_collateralInfo._collateralAddress);\n        collateral.collateralInfo[\n            _collateralInfo._collateralAddress\n        ] = _collateralInfo;  /// @audit\n        ...\n```\n\nWhen the deposited-collateral would be withdrawn by a borrower or a lender, the CollateralManager#`withdraw()` would be called.\nWithin the CollateralManager#`withdraw()`, the CollateralManager#`_withdraw()` would be called like this:\nhttps://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/CollateralManager.sol#L253\nhttps://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/CollateralManager.sol#L255\n```solidity\n    /**\n     * @notice Withdraws deposited collateral from the created escrow of a bid that has been successfully repaid.\n     * @param _bidId The id of the bid to withdraw collateral for.\n     */\n    function withdraw(uint256 _bidId) external {\n        BidState bidState = tellerV2.getBidState(_bidId);\n        if (bidState == BidState.PAID) {\n            _withdraw(_bidId, tellerV2.getLoanBorrower(_bidId)); /// @audit \n        } else if (tellerV2.isLoanDefaulted(_bidId)) {\n            _withdraw(_bidId, tellerV2.getLoanLender(_bidId));  /// @audit \n           ...\n```\n\nWhen the deposited-collateral would be liquidated by a liquidator, the CollateralManager#`liquidateCollateral()` would be called.\nWithin the CollateralManager#`liquidateCollateral()`, the CollateralManager#`_withdraw()` would be called like this:\nhttps://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/CollateralManager.sol#L278\n```solidity\n    /**\n     * @notice Sends the deposited collateral to a liquidator of a bid.\n     * @notice Can only be called by the protocol.\n     * @param _bidId The id of the liquidated bid.\n     * @param _liquidatorAddress The address of the liquidator to send the collateral to.\n     */\n    function liquidateCollateral(uint256 _bidId, address _liquidatorAddress)\n        external\n        onlyTellerV2\n    {\n        if (isBidCollateralBacked(_bidId)) {\n            BidState bidState = tellerV2.getBidState(_bidId);\n            require(\n                bidState == BidState.LIQUIDATED,\n                \"Loan has not been liquidated\"\n            );\n            _withdraw(_bidId, _liquidatorAddress);  /// @audit\n        }\n    }\n```\n\nWithin the CollateralManager#`_withdraw()`, each collateral asset (`collateralInfo._collateralAddress`) would be withdrawn by internally calling the ICollateralEscrowV1#`withdraw()` in a for-loop like this:\nhttps://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/CollateralManager.sol#L394-L409\n```solidity\n    /**\n     * @notice Withdraws collateral to a given receiver's address.\n     * @param _bidId The id of the bid to withdraw collateral for.\n     * @param _receiver The address to withdraw the collateral to.\n     */\n    function _withdraw(uint256 _bidId, address _receiver) internal virtual {\n        for (\n            uint256 i;\n            i < _bidCollaterals[_bidId].collateralAddresses.length(); /// @audit\n            i++\n        ) {\n            // Get collateral info\n            Collateral storage collateralInfo = _bidCollaterals[_bidId]\n                .collateralInfo[\n                    _bidCollaterals[_bidId].collateralAddresses.at(i)\n                ];\n            // Withdraw collateral from escrow and send it to bid lender\n            ICollateralEscrowV1(_escrows[_bidId]).withdraw(   /// @audit\n                collateralInfo._collateralAddress,\n                collateralInfo._amount,\n                _receiver\n            );\n```\n\nHowever, within the TellerV2#`submitBid()`, there is no limitation that how many collateral assets a borrower can assign into the `_collateralInfo` array parameter.\n\nThis lead to a bad scenario like below:\n- ① A borrower assign too many number of the collateral assets (ERC20/ERC721/ERC1155) into the `_collateralInfo` array parameter when the borrower call the TellerV2#`submitBid()` to submit a bid.\n- ② Then, a lender accepts the bid via calling the TellerV2#`lenderAcceptBid()`\n- ③ Then, a borrower or a lender try to withdraw the collateral, which is not liquidated, by calling the CollateralManager#`withdraw()`. Or, a liquidator try to withdraw the collateral, which is liquidated, by calling the CollateralManager#`liquidateCollateral()`\n- ④ But, the transaction of the CollateralManager#`withdraw()` or the CollateralManager#`liquidateCollateral()` will be reverted in the for-loop of the CollateralManager#`_withdraw()` because that transaction will reach a gas limit.\n\n\n## Impact\nDue to reaching gas limit, some bad scenarios would occur like this:\n- A borrower or a lender fail to withdraw the collateral assets when the loan would not be liquidated.\n- A liquidator will fail to withdraw the collateral assets when the loan would be liquidated.\n\n## Code Snippet\n- https://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/interfaces/escrow/ICollateralEscrowV1.sol#L10-L15\n- https://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/CollateralManager.sol#L34-L37\n- https://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/CollateralManager.sol#L27\n- https://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/TellerV2.sol#L311\n- https://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/TellerV2.sol#L325\n- https://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/CollateralManager.sol#L127\n- https://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/CollateralManager.sol#L428\n- https://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/CollateralManager.sol#L430-L434\n- https://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/CollateralManager.sol#L253\n- https://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/CollateralManager.sol#L255\n- https://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/CollateralManager.sol#L278\n- https://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/CollateralManager.sol#L394-L409\n\n## Tool used\nManual Review\n\n## Recommendation\nWithin the TellerV2#`submitBid()`, consider adding a limitation about how many collateral assets a borrower can assign into the `_collateralInfo` array parameter.\n\n\n\n## Discussion\n\n**ethereumdegen**\n\nThank you for your feedback.  This is very similar / essentially the same as the 'collateral poisoning' issue that had been identified in the README of this contest as a known-issue:  it had been explained and known that collateral could be made impossible to withdraw which could impact the ability to do the last repayment of a loan.   This is a slight variation in that it describes that the collateral could be so vast that withdrawing it would exceed the gas limit of a block.  Thank you for this perspective.  In any case we do plan to separate the repayment logic from the collateral withdraw logic to mitigate such an issue.  \n\n**ctf-sec**\n\nEscalate for 10 USDC. this is low / medium issue.\n\nAs the sponsor say\n\n> his is very similar / essentially the same as the 'collateral poisoning' issue that had been identified in the README of this contest as a known-issue: it had been explained and known that collateral could be made impossible to withdraw which could impact the ability to do the last repayment of a loan. \n\naccording to the previous description, the issue should be marked as low and non-reward\n\nbut DOS and exceed the gas limit of block make this a medium, definitely not a high finding\n\nAccording to https://docs.sherlock.xyz/audits/judging/judging\n\n> Medium: There is a viable scenario (even if unlikely) that could cause the protocol to enter a state where a material amount of funds can be lost. The attack path is possible with assumptions that either mimic on-chain conditions or reflect conditions that have a reasonable chance of becoming true in the future. The more expensive the attack is for an attacker, the less likely it will be included as a Medium (holding all other factors constant). The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\n\nand\n\n> Could Denial-of-Service (DOS), griefing, or locking of contracts count as a Medium (or High) issue? It would not count if the DOS, etc. lasts a known, finite amount of time <1 year. If it will result in funds being inaccessible for >=1 year, then it would count as a loss of funds and be eligible for a Medium or High designation. The greater the cost of the attack for an attacker, the less severe the issue becomes.\n\nThe cost of making the collateral loop for exceed block gas limit is clearly very high + it only impact single lendering / borrow loan, not all loan states.\n\nSo this should be a medium / low finiding, definitely not high severity issue.\n\n\n\n\n\n**sherlock-admin**\n\n > Escalate for 10 USDC. this is low / medium issue.\n> \n> As the sponsor say\n> \n> > his is very similar / essentially the same as the 'collateral poisoning' issue that had been identified in the README of this contest as a known-issue: it had been explained and known that collateral could be made impossible to withdraw which could impact the ability to do the last repayment of a loan. \n> \n> according to the previous description, the issue should be marked as low and non-reward\n> \n> but DOS and exceed the gas limit of block make this a medium, definitely not a high finding\n> \n> According to https://docs.sherlock.xyz/audits/judging/judging\n> \n> > Medium: There is a viable scenario (even if unlikely) that could cause the protocol to enter a state where a material amount of funds can be lost. The attack path is possible with assumptions that either mimic on-chain conditions or reflect conditions that have a reasonable chance of becoming true in the future. The more expensive the attack is for an attacker, the less likely it will be included as a Medium (holding all other factors constant). The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\n> \n> and\n> \n> > Could Denial-of-Service (DOS), griefing, or locking of contracts count as a Medium (or High) issue? It would not count if the DOS, etc. lasts a known, finite amount of time <1 year. If it will result in funds being inaccessible for >=1 year, then it would count as a loss of funds and be eligible for a Medium or High designation. The greater the cost of the attack for an attacker, the less severe the issue becomes.\n> \n> The cost of making the collateral loop for exceed block gas limit is clearly very high + it only impact single lendering / borrow loan, not all loan states.\n> \n> So this should be a medium / low finiding, definitely not high severity issue.\n> \n> \n> \n> \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Trumpero**\n\nThis issue differs from the known issue as it highlights a scenario where the loan was successfully accepted but can't be withdrawn due to the gas limit. However, this situation is unlikely, so I agree that it should be a medium issue.\n\n**hrishibhat**\n\nEscalation accepted\n\nValid medium\nThis can be considered as a valid medium.\n\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Valid medium\n> This can be considered as a valid medium.\n> \n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.\n\n**IAm0x52**\n\nFixed [here](https://github.com/teller-protocol/teller-protocol-v2/pull/69/files) by separating withdraw and repay logic\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/62",
  "Code": [
    {
      "filename": "teller-protocol-v2/packages/contracts/contracts/interfaces/escrow/ICollateralEscrowV1.sol",
      "content": "// SPDX-Licence-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nenum CollateralType {\n    ERC20,\n    ERC721,\n    ERC1155\n}\n\nstruct Collateral {\n    CollateralType _collateralType;\n    uint256 _amount;\n    uint256 _tokenId;\n    address _collateralAddress;\n}\n\ninterface ICollateralEscrowV1 {\n    /**\n     * @notice Deposits a collateral asset into the escrow.\n     * @param _collateralType The type of collateral asset to deposit (ERC721, ERC1155).\n     * @param _collateralAddress The address of the collateral token.\n     * @param _amount The amount to deposit.\n     */\n    function depositAsset(\n        CollateralType _collateralType,\n        address _collateralAddress,\n        uint256 _amount,\n        uint256 _tokenId\n    ) external payable;\n\n    /**\n     * @notice Withdraws a collateral asset from the escrow.\n     * @param _collateralAddress The address of the collateral contract.\n     * @param _amount The amount to withdraw.\n     * @param _recipient The address to send the assets to.\n     */\n    function withdraw(\n        address _collateralAddress,\n        uint256 _amount,\n        address _recipient\n    ) external;\n\n    function getBid() external view returns (uint256);\n\n    function initialize(uint256 _bidId) external;\n}"
    },
    {
      "filename": "teller-protocol-v2/packages/contracts/contracts/CollateralManager.sol",
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\n// Contracts\nimport \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n// Libraries\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\n// Interfaces\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"./interfaces/ICollateralManager.sol\";\nimport { Collateral, CollateralType, ICollateralEscrowV1 } from \"./interfaces/escrow/ICollateralEscrowV1.sol\";\nimport \"./interfaces/ITellerV2.sol\";\n\ncontract CollateralManager is OwnableUpgradeable, ICollateralManager {\n    /* Storage */\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n    ITellerV2 public tellerV2;\n    address private collateralEscrowBeacon; // The address of the escrow contract beacon\n    mapping(uint256 => address) public _escrows; // bidIds -> collateralEscrow\n    // bidIds -> validated collateral info\n    mapping(uint256 => CollateralInfo) internal _bidCollaterals;\n\n    /**\n     * Since collateralInfo is mapped (address assetAddress => Collateral) that means\n     * that only a single tokenId per nft per loan can be collateralized.\n     * Ex. Two bored apes cannot be used as collateral for a single loan.\n     */\n    struct CollateralInfo {\n        EnumerableSetUpgradeable.AddressSet collateralAddresses;\n        mapping(address => Collateral) collateralInfo;\n    }\n\n    /* Events */\n    event CollateralEscrowDeployed(uint256 _bidId, address _collateralEscrow);\n    event CollateralCommitted(\n        uint256 _bidId,\n        CollateralType _type,\n        address _collateralAddress,\n        uint256 _amount,\n        uint256 _tokenId\n    );\n    event CollateralClaimed(uint256 _bidId);\n    event CollateralDeposited(\n        uint256 _bidId,\n        CollateralType _type,\n        address _collateralAddress,\n        uint256 _amount,\n        uint256 _tokenId\n    );\n    event CollateralWithdrawn(\n        uint256 _bidId,\n        CollateralType _type,\n        address _collateralAddress,\n        uint256 _amount,\n        uint256 _tokenId,\n        address _recipient\n    );\n\n    /* Modifiers */\n    modifier onlyTellerV2() {\n        require(_msgSender() == address(tellerV2), \"Sender not authorized\");\n        _;\n    }\n\n    /* External Functions */\n\n    /**\n     * @notice Initializes the collateral manager.\n     * @param _collateralEscrowBeacon The address of the escrow implementation.\n     * @param _tellerV2 The address of the protocol.\n     */\n    function initialize(address _collateralEscrowBeacon, address _tellerV2)\n        external\n        initializer\n    {\n        collateralEscrowBeacon = _collateralEscrowBeacon;\n        tellerV2 = ITellerV2(_tellerV2);\n        __Ownable_init_unchained();\n    }\n\n    /**\n     * @notice Sets the address of the Beacon contract used for the collateral escrow contracts.\n     * @param _collateralEscrowBeacon The address of the Beacon contract.\n     */\n    function setCollateralEscrowBeacon(address _collateralEscrowBeacon)\n        external\n        reinitializer(2)\n    {\n        collateralEscrowBeacon = _collateralEscrowBeacon;\n    }\n\n    /**\n     * @notice Checks to see if a bid is backed by collateral.\n     * @param _bidId The id of the bid to check.\n     */\n\n    function isBidCollateralBacked(uint256 _bidId)\n        public\n        virtual\n        returns (bool)\n    {\n        return _bidCollaterals[_bidId].collateralAddresses.length() > 0;\n    }\n\n    /**\n     * @notice Checks the validity of a borrower's multiple collateral balances and commits it to a bid.\n     * @param _bidId The id of the associated bid.\n     * @param _collateralInfo Additional information about the collateral assets.\n     * @return validation_ Boolean indicating if the collateral balances were validated.\n     */\n    function commitCollateral(\n        uint256 _bidId,\n        Collateral[] calldata _collateralInfo\n    ) public returns (bool validation_) {\n        address borrower = tellerV2.getLoanBorrower(_bidId);\n        (validation_, ) = checkBalances(borrower, _collateralInfo);\n\n        if (validation_) {\n            for (uint256 i; i < _collateralInfo.length; i++) {\n                Collateral memory info = _collateralInfo[i];\n                _commitCollateral(_bidId, info);\n            }\n        }\n    }\n\n    /**\n     * @notice Checks the validity of a borrower's collateral balance and commits it to a bid.\n     * @param _bidId The id of the associated bid.\n     * @param _collateralInfo Additional information about the collateral asset.\n     * @return validation_ Boolean indicating if the collateral balance was validated.\n     */\n    function commitCollateral(\n        uint256 _bidId,\n        Collateral calldata _collateralInfo\n    ) public returns (bool validation_) {\n        address borrower = tellerV2.getLoanBorrower(_bidId);\n        validation_ = _checkBalance(borrower, _collateralInfo);\n        if (validation_) {\n            _commitCollateral(_bidId, _collateralInfo);\n        }\n    }\n\n    /**\n     * @notice Re-checks the validity of a borrower's collateral balance committed to a bid.\n     * @param _bidId The id of the associated bid.\n     * @return validation_ Boolean indicating if the collateral balance was validated.\n     */\n    function revalidateCollateral(uint256 _bidId)\n        external\n        returns (bool validation_)\n    {\n        Collateral[] memory collateralInfos = getCollateralInfo(_bidId);\n        address borrower = tellerV2.getLoanBorrower(_bidId);\n        (validation_, ) = _checkBalances(borrower, collateralInfos, true);\n    }\n\n    /**\n     * @notice Checks the validity of a borrower's multiple collateral balances.\n     * @param _borrowerAddress The address of the borrower holding the collateral.\n     * @param _collateralInfo Additional information about the collateral assets.\n     */\n    function checkBalances(\n        address _borrowerAddress,\n        Collateral[] calldata _collateralInfo\n    ) public returns (bool validated_, bool[] memory checks_) {\n        return _checkBalances(_borrowerAddress, _collateralInfo, false);\n    }\n\n    /**\n     * @notice Deploys a new collateral escrow and deposits collateral.\n     * @param _bidId The associated bidId of the collateral escrow.\n     */\n    function deployAndDeposit(uint256 _bidId) external onlyTellerV2 {\n        if (isBidCollateralBacked(_bidId)) {\n            (address proxyAddress, ) = _deployEscrow(_bidId);\n            _escrows[_bidId] = proxyAddress;\n\n            for (\n                uint256 i;\n                i < _bidCollaterals[_bidId].collateralAddresses.length();\n                i++\n            ) {\n                _deposit(\n                    _bidId,\n                    _bidCollaterals[_bidId].collateralInfo[\n                        _bidCollaterals[_bidId].collateralAddresses.at(i)\n                    ]\n                );\n            }\n\n            emit CollateralEscrowDeployed(_bidId, proxyAddress);\n        }\n    }\n\n    /**\n     * @notice Gets the address of a deployed escrow.\n     * @notice _bidId The bidId to return the escrow for.\n     * @return The address of the escrow.\n     */\n    function getEscrow(uint256 _bidId) external view returns (address) {\n        return _escrows[_bidId];\n    }\n\n    /**\n     * @notice Gets the collateral info for a given bid id.\n     * @param _bidId The bidId to return the collateral info for.\n     * @return infos_ The stored collateral info.\n     */\n    function getCollateralInfo(uint256 _bidId)\n        public\n        view\n        returns (Collateral[] memory infos_)\n    {\n        CollateralInfo storage collateral = _bidCollaterals[_bidId];\n        address[] memory collateralAddresses = collateral\n            .collateralAddresses\n            .values();\n        infos_ = new Collateral[](collateralAddresses.length);\n        for (uint256 i; i < collateralAddresses.length; i++) {\n            infos_[i] = collateral.collateralInfo[collateralAddresses[i]];\n        }\n    }\n\n    /**\n     * @notice Gets the collateral asset amount for a given bid id on the TellerV2 contract.\n     * @param _bidId The ID of a bid on TellerV2.\n     * @param _collateralAddress An address used as collateral.\n     * @return amount_ The amount of collateral of type _collateralAddress.\n     */\n    function getCollateralAmount(uint256 _bidId, address _collateralAddress)\n        public\n        view\n        returns (uint256 amount_)\n    {\n        amount_ = _bidCollaterals[_bidId]\n            .collateralInfo[_collateralAddress]\n            ._amount;\n    }\n\n    /**\n     * @notice Withdraws deposited collateral from the created escrow of a bid that has been successfully repaid.\n     * @param _bidId The id of the bid to withdraw collateral for.\n     */\n    function withdraw(uint256 _bidId) external {\n        BidState bidState = tellerV2.getBidState(_bidId);\n        if (bidState == BidState.PAID) {\n            _withdraw(_bidId, tellerV2.getLoanBorrower(_bidId));\n        } else if (tellerV2.isLoanDefaulted(_bidId)) {\n            _withdraw(_bidId, tellerV2.getLoanLender(_bidId));\n            emit CollateralClaimed(_bidId);\n        } else {\n            revert(\"collateral cannot be withdrawn\");\n        }\n    }\n\n    /**\n     * @notice Sends the deposited collateral to a liquidator of a bid.\n     * @notice Can only be called by the protocol.\n     * @param _bidId The id of the liquidated bid.\n     * @param _liquidatorAddress The address of the liquidator to send the collateral to.\n     */\n    function liquidateCollateral(uint256 _bidId, address _liquidatorAddress)\n        external\n        onlyTellerV2\n    {\n        if (isBidCollateralBacked(_bidId)) {\n            BidState bidState = tellerV2.getBidState(_bidId);\n            require(\n                bidState == BidState.LIQUIDATED,\n                \"Loan has not been liquidated\"\n            );\n            _withdraw(_bidId, _liquidatorAddress);\n        }\n    }\n\n    /* Internal Functions */\n\n    /**\n     * @notice Deploys a new collateral escrow.\n     * @param _bidId The associated bidId of the collateral escrow.\n     */\n    function _deployEscrow(uint256 _bidId)\n        internal\n        virtual\n        returns (address proxyAddress_, address borrower_)\n    {\n        proxyAddress_ = _escrows[_bidId];\n        // Get bid info\n        borrower_ = tellerV2.getLoanBorrower(_bidId);\n        if (proxyAddress_ == address(0)) {\n            require(borrower_ != address(0), \"Bid does not exist\");\n\n            BeaconProxy proxy = new BeaconProxy(\n                collateralEscrowBeacon,\n                abi.encodeWithSelector(\n                    ICollateralEscrowV1.initialize.selector,\n                    _bidId\n                )\n            );\n            proxyAddress_ = address(proxy);\n        }\n    }\n\n    /*\n        * @notice Deploys a new collateral escrow contract. Deposits collateral into a collateral escrow.\n        * @param _bidId The associated bidId of the collateral escrow.\n        * @param collateralInfo The collateral info to deposit.\n\n    */\n    function _deposit(uint256 _bidId, Collateral memory collateralInfo)\n        internal\n        virtual\n    {\n        require(collateralInfo._amount > 0, \"Collateral not validated\");\n        (address escrowAddress, address borrower) = _deployEscrow(_bidId);\n        ICollateralEscrowV1 collateralEscrow = ICollateralEscrowV1(\n            escrowAddress\n        );\n        // Pull collateral from borrower & deposit into escrow\n        if (collateralInfo._collateralType == CollateralType.ERC20) {\n            IERC20Upgradeable(collateralInfo._collateralAddress).transferFrom(\n                borrower,\n                address(this),\n                collateralInfo._amount\n            );\n            IERC20Upgradeable(collateralInfo._collateralAddress).approve(\n                escrowAddress,\n                collateralInfo._amount\n            );\n            collateralEscrow.depositAsset(\n                CollateralType.ERC20,\n                collateralInfo._collateralAddress,\n                collateralInfo._amount,\n                0\n            );\n        } else if (collateralInfo._collateralType == CollateralType.ERC721) {\n            IERC721Upgradeable(collateralInfo._collateralAddress).transferFrom(\n                borrower,\n                address(this),\n                collateralInfo._tokenId\n            );\n            IERC721Upgradeable(collateralInfo._collateralAddress).approve(\n                escrowAddress,\n                collateralInfo._tokenId\n            );\n            collateralEscrow.depositAsset(\n                CollateralType.ERC721,\n                collateralInfo._collateralAddress,\n                collateralInfo._amount,\n                collateralInfo._tokenId\n            );\n        } else if (collateralInfo._collateralType == CollateralType.ERC1155) {\n            bytes memory data;\n            IERC1155Upgradeable(collateralInfo._collateralAddress)\n                .safeTransferFrom(\n                    borrower,\n                    address(this),\n                    collateralInfo._tokenId,\n                    collateralInfo._amount,\n                    data\n                );\n            IERC1155Upgradeable(collateralInfo._collateralAddress)\n                .setApprovalForAll(escrowAddress, true);\n            collateralEscrow.depositAsset(\n                CollateralType.ERC1155,\n                collateralInfo._collateralAddress,\n                collateralInfo._amount,\n                collateralInfo._tokenId\n            );\n        } else {\n            revert(\"Unexpected collateral type\");\n        }\n        emit CollateralDeposited(\n            _bidId,\n            collateralInfo._collateralType,\n            collateralInfo._collateralAddress,\n            collateralInfo._amount,\n            collateralInfo._tokenId\n        );\n    }\n\n    /**\n     * @notice Withdraws collateral to a given receiver's address.\n     * @param _bidId The id of the bid to withdraw collateral for.\n     * @param _receiver The address to withdraw the collateral to.\n     */\n    function _withdraw(uint256 _bidId, address _receiver) internal virtual {\n        for (\n            uint256 i;\n            i < _bidCollaterals[_bidId].collateralAddresses.length();\n            i++\n        ) {\n            // Get collateral info\n            Collateral storage collateralInfo = _bidCollaterals[_bidId]\n                .collateralInfo[\n                    _bidCollaterals[_bidId].collateralAddresses.at(i)\n                ];\n            // Withdraw collateral from escrow and send it to bid lender\n            ICollateralEscrowV1(_escrows[_bidId]).withdraw(\n                collateralInfo._collateralAddress,\n                collateralInfo._amount,\n                _receiver\n            );\n            emit CollateralWithdrawn(\n                _bidId,\n                collateralInfo._collateralType,\n                collateralInfo._collateralAddress,\n                collateralInfo._amount,\n                collateralInfo._tokenId,\n                _receiver\n            );\n        }\n    }\n\n    /**\n     * @notice Checks the validity of a borrower's collateral balance and commits it to a bid.\n     * @param _bidId The id of the associated bid.\n     * @param _collateralInfo Additional information about the collateral asset.\n     */\n    function _commitCollateral(\n        uint256 _bidId,\n        Collateral memory _collateralInfo\n    ) internal virtual {\n        CollateralInfo storage collateral = _bidCollaterals[_bidId];\n        collateral.collateralAddresses.add(_collateralInfo._collateralAddress);\n        collateral.collateralInfo[\n            _collateralInfo._collateralAddress\n        ] = _collateralInfo;\n        emit CollateralCommitted(\n            _bidId,\n            _collateralInfo._collateralType,\n            _collateralInfo._collateralAddress,\n            _collateralInfo._amount,\n            _collateralInfo._tokenId\n        );\n    }\n\n    /**\n     * @notice Checks the validity of a borrower's multiple collateral balances.\n     * @param _borrowerAddress The address of the borrower holding the collateral.\n     * @param _collateralInfo Additional information about the collateral assets.\n     * @param _shortCircut  if true, will return immediately until an invalid balance\n     */\n    function _checkBalances(\n        address _borrowerAddress,\n        Collateral[] memory _collateralInfo,\n        bool _shortCircut\n    ) internal virtual returns (bool validated_, bool[] memory checks_) {\n        checks_ = new bool[](_collateralInfo.length);\n        validated_ = true;\n        for (uint256 i; i < _collateralInfo.length; i++) {\n            bool isValidated = _checkBalance(\n                _borrowerAddress,\n                _collateralInfo[i]\n            );\n            checks_[i] = isValidated;\n            if (!isValidated) {\n                validated_ = false;\n                if (_shortCircut) {\n                    return (validated_, checks_);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Checks the validity of a borrower's single collateral balance.\n     * @param _borrowerAddress The address of the borrower holding the collateral.\n     * @param _collateralInfo Additional information about the collateral asset.\n     * @return validation_ Boolean indicating if the collateral balances were validated.\n     */\n    function _checkBalance(\n        address _borrowerAddress,\n        Collateral memory _collateralInfo\n    ) internal virtual returns (bool) {\n        CollateralType collateralType = _collateralInfo._collateralType;\n\n        if (collateralType == CollateralType.ERC20) {\n            return\n                _collateralInfo._amount <=\n                IERC20Upgradeable(_collateralInfo._collateralAddress).balanceOf(\n                    _borrowerAddress\n                );\n        } else if (collateralType == CollateralType.ERC721) {\n            return\n                _borrowerAddress ==\n                IERC721Upgradeable(_collateralInfo._collateralAddress).ownerOf(\n                    _collateralInfo._tokenId\n                );\n        } else if (collateralType == CollateralType.ERC1155) {\n            return\n                _collateralInfo._amount <=\n                IERC1155Upgradeable(_collateralInfo._collateralAddress)\n                    .balanceOf(_borrowerAddress, _collateralInfo._tokenId);\n        } else {\n            return false;\n        }\n    }\n\n    // On NFT Received handlers\n\n    function onERC721Received(address, address, uint256, bytes calldata)\n        external\n        pure\n        returns (bytes4)\n    {\n        return\n            bytes4(\n                keccak256(\"onERC721Received(address,address,uint256,bytes)\")\n            );\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256 id,\n        uint256 value,\n        bytes calldata\n    ) external returns (bytes4) {\n        return\n            bytes4(\n                keccak256(\n                    \"onERC1155Received(address,address,uint256,uint256,bytes)\"\n                )\n            );\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes calldata\n    ) external returns (bytes4) {\n        require(\n            _ids.length == 1,\n            \"Only allowed one asset batch transfer per transaction.\"\n        );\n        return\n            bytes4(\n                keccak256(\n                    \"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"\n                )\n            );\n    }\n}"
    },
    {
      "filename": "teller-protocol-v2/packages/contracts/contracts/CollateralManager.sol",
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\n// Contracts\nimport \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n// Libraries\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\n// Interfaces\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"./interfaces/ICollateralManager.sol\";\nimport { Collateral, CollateralType, ICollateralEscrowV1 } from \"./interfaces/escrow/ICollateralEscrowV1.sol\";\nimport \"./interfaces/ITellerV2.sol\";\n\ncontract CollateralManager is OwnableUpgradeable, ICollateralManager {\n    /* Storage */\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n    ITellerV2 public tellerV2;\n    address private collateralEscrowBeacon; // The address of the escrow contract beacon\n    mapping(uint256 => address) public _escrows; // bidIds -> collateralEscrow\n    // bidIds -> validated collateral info\n    mapping(uint256 => CollateralInfo) internal _bidCollaterals;\n\n    /**\n     * Since collateralInfo is mapped (address assetAddress => Collateral) that means\n     * that only a single tokenId per nft per loan can be collateralized.\n     * Ex. Two bored apes cannot be used as collateral for a single loan.\n     */\n    struct CollateralInfo {\n        EnumerableSetUpgradeable.AddressSet collateralAddresses;\n        mapping(address => Collateral) collateralInfo;\n    }\n\n    /* Events */\n    event CollateralEscrowDeployed(uint256 _bidId, address _collateralEscrow);\n    event CollateralCommitted(\n        uint256 _bidId,\n        CollateralType _type,\n        address _collateralAddress,\n        uint256 _amount,\n        uint256 _tokenId\n    );\n    event CollateralClaimed(uint256 _bidId);\n    event CollateralDeposited(\n        uint256 _bidId,\n        CollateralType _type,\n        address _collateralAddress,\n        uint256 _amount,\n        uint256 _tokenId\n    );\n    event CollateralWithdrawn(\n        uint256 _bidId,\n        CollateralType _type,\n        address _collateralAddress,\n        uint256 _amount,\n        uint256 _tokenId,\n        address _recipient\n    );\n\n    /* Modifiers */\n    modifier onlyTellerV2() {\n        require(_msgSender() == address(tellerV2), \"Sender not authorized\");\n        _;\n    }\n\n    /* External Functions */\n\n    /**\n     * @notice Initializes the collateral manager.\n     * @param _collateralEscrowBeacon The address of the escrow implementation.\n     * @param _tellerV2 The address of the protocol.\n     */\n    function initialize(address _collateralEscrowBeacon, address _tellerV2)\n        external\n        initializer\n    {\n        collateralEscrowBeacon = _collateralEscrowBeacon;\n        tellerV2 = ITellerV2(_tellerV2);\n        __Ownable_init_unchained();\n    }\n\n    /**\n     * @notice Sets the address of the Beacon contract used for the collateral escrow contracts.\n     * @param _collateralEscrowBeacon The address of the Beacon contract.\n     */\n    function setCollateralEscrowBeacon(address _collateralEscrowBeacon)\n        external\n        reinitializer(2)\n    {\n        collateralEscrowBeacon = _collateralEscrowBeacon;\n    }\n\n    /**\n     * @notice Checks to see if a bid is backed by collateral.\n     * @param _bidId The id of the bid to check.\n     */\n\n    function isBidCollateralBacked(uint256 _bidId)\n        public\n        virtual\n        returns (bool)\n    {\n        return _bidCollaterals[_bidId].collateralAddresses.length() > 0;\n    }\n\n    /**\n     * @notice Checks the validity of a borrower's multiple collateral balances and commits it to a bid.\n     * @param _bidId The id of the associated bid.\n     * @param _collateralInfo Additional information about the collateral assets.\n     * @return validation_ Boolean indicating if the collateral balances were validated.\n     */\n    function commitCollateral(\n        uint256 _bidId,\n        Collateral[] calldata _collateralInfo\n    ) public returns (bool validation_) {\n        address borrower = tellerV2.getLoanBorrower(_bidId);\n        (validation_, ) = checkBalances(borrower, _collateralInfo);\n\n        if (validation_) {\n            for (uint256 i; i < _collateralInfo.length; i++) {\n                Collateral memory info = _collateralInfo[i];\n                _commitCollateral(_bidId, info);\n            }\n        }\n    }\n\n    /**\n     * @notice Checks the validity of a borrower's collateral balance and commits it to a bid.\n     * @param _bidId The id of the associated bid.\n     * @param _collateralInfo Additional information about the collateral asset.\n     * @return validation_ Boolean indicating if the collateral balance was validated.\n     */\n    function commitCollateral(\n        uint256 _bidId,\n        Collateral calldata _collateralInfo\n    ) public returns (bool validation_) {\n        address borrower = tellerV2.getLoanBorrower(_bidId);\n        validation_ = _checkBalance(borrower, _collateralInfo);\n        if (validation_) {\n            _commitCollateral(_bidId, _collateralInfo);\n        }\n    }\n\n    /**\n     * @notice Re-checks the validity of a borrower's collateral balance committed to a bid.\n     * @param _bidId The id of the associated bid.\n     * @return validation_ Boolean indicating if the collateral balance was validated.\n     */\n    function revalidateCollateral(uint256 _bidId)\n        external\n        returns (bool validation_)\n    {\n        Collateral[] memory collateralInfos = getCollateralInfo(_bidId);\n        address borrower = tellerV2.getLoanBorrower(_bidId);\n        (validation_, ) = _checkBalances(borrower, collateralInfos, true);\n    }\n\n    /**\n     * @notice Checks the validity of a borrower's multiple collateral balances.\n     * @param _borrowerAddress The address of the borrower holding the collateral.\n     * @param _collateralInfo Additional information about the collateral assets.\n     */\n    function checkBalances(\n        address _borrowerAddress,\n        Collateral[] calldata _collateralInfo\n    ) public returns (bool validated_, bool[] memory checks_) {\n        return _checkBalances(_borrowerAddress, _collateralInfo, false);\n    }\n\n    /**\n     * @notice Deploys a new collateral escrow and deposits collateral.\n     * @param _bidId The associated bidId of the collateral escrow.\n     */\n    function deployAndDeposit(uint256 _bidId) external onlyTellerV2 {\n        if (isBidCollateralBacked(_bidId)) {\n            (address proxyAddress, ) = _deployEscrow(_bidId);\n            _escrows[_bidId] = proxyAddress;\n\n            for (\n                uint256 i;\n                i < _bidCollaterals[_bidId].collateralAddresses.length();\n                i++\n            ) {\n                _deposit(\n                    _bidId,\n                    _bidCollaterals[_bidId].collateralInfo[\n                        _bidCollaterals[_bidId].collateralAddresses.at(i)\n                    ]\n                );\n            }\n\n            emit CollateralEscrowDeployed(_bidId, proxyAddress);\n        }\n    }\n\n    /**\n     * @notice Gets the address of a deployed escrow.\n     * @notice _bidId The bidId to return the escrow for.\n     * @return The address of the escrow.\n     */\n    function getEscrow(uint256 _bidId) external view returns (address) {\n        return _escrows[_bidId];\n    }\n\n    /**\n     * @notice Gets the collateral info for a given bid id.\n     * @param _bidId The bidId to return the collateral info for.\n     * @return infos_ The stored collateral info.\n     */\n    function getCollateralInfo(uint256 _bidId)\n        public\n        view\n        returns (Collateral[] memory infos_)\n    {\n        CollateralInfo storage collateral = _bidCollaterals[_bidId];\n        address[] memory collateralAddresses = collateral\n            .collateralAddresses\n            .values();\n        infos_ = new Collateral[](collateralAddresses.length);\n        for (uint256 i; i < collateralAddresses.length; i++) {\n            infos_[i] = collateral.collateralInfo[collateralAddresses[i]];\n        }\n    }\n\n    /**\n     * @notice Gets the collateral asset amount for a given bid id on the TellerV2 contract.\n     * @param _bidId The ID of a bid on TellerV2.\n     * @param _collateralAddress An address used as collateral.\n     * @return amount_ The amount of collateral of type _collateralAddress.\n     */\n    function getCollateralAmount(uint256 _bidId, address _collateralAddress)\n        public\n        view\n        returns (uint256 amount_)\n    {\n        amount_ = _bidCollaterals[_bidId]\n            .collateralInfo[_collateralAddress]\n            ._amount;\n    }\n\n    /**\n     * @notice Withdraws deposited collateral from the created escrow of a bid that has been successfully repaid.\n     * @param _bidId The id of the bid to withdraw collateral for.\n     */\n    function withdraw(uint256 _bidId) external {\n        BidState bidState = tellerV2.getBidState(_bidId);\n        if (bidState == BidState.PAID) {\n            _withdraw(_bidId, tellerV2.getLoanBorrower(_bidId));\n        } else if (tellerV2.isLoanDefaulted(_bidId)) {\n            _withdraw(_bidId, tellerV2.getLoanLender(_bidId));\n            emit CollateralClaimed(_bidId);\n        } else {\n            revert(\"collateral cannot be withdrawn\");\n        }\n    }\n\n    /**\n     * @notice Sends the deposited collateral to a liquidator of a bid.\n     * @notice Can only be called by the protocol.\n     * @param _bidId The id of the liquidated bid.\n     * @param _liquidatorAddress The address of the liquidator to send the collateral to.\n     */\n    function liquidateCollateral(uint256 _bidId, address _liquidatorAddress)\n        external\n        onlyTellerV2\n    {\n        if (isBidCollateralBacked(_bidId)) {\n            BidState bidState = tellerV2.getBidState(_bidId);\n            require(\n                bidState == BidState.LIQUIDATED,\n                \"Loan has not been liquidated\"\n            );\n            _withdraw(_bidId, _liquidatorAddress);\n        }\n    }\n\n    /* Internal Functions */\n\n    /**\n     * @notice Deploys a new collateral escrow.\n     * @param _bidId The associated bidId of the collateral escrow.\n     */\n    function _deployEscrow(uint256 _bidId)\n        internal\n        virtual\n        returns (address proxyAddress_, address borrower_)\n    {\n        proxyAddress_ = _escrows[_bidId];\n        // Get bid info\n        borrower_ = tellerV2.getLoanBorrower(_bidId);\n        if (proxyAddress_ == address(0)) {\n            require(borrower_ != address(0), \"Bid does not exist\");\n\n            BeaconProxy proxy = new BeaconProxy(\n                collateralEscrowBeacon,\n                abi.encodeWithSelector(\n                    ICollateralEscrowV1.initialize.selector,\n                    _bidId\n                )\n            );\n            proxyAddress_ = address(proxy);\n        }\n    }\n\n    /*\n        * @notice Deploys a new collateral escrow contract. Deposits collateral into a collateral escrow.\n        * @param _bidId The associated bidId of the collateral escrow.\n        * @param collateralInfo The collateral info to deposit.\n\n    */\n    function _deposit(uint256 _bidId, Collateral memory collateralInfo)\n        internal\n        virtual\n    {\n        require(collateralInfo._amount > 0, \"Co"
    }
  ]
}