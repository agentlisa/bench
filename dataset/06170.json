{
  "Title": "[R-03] `AxelarGateway::onlyMintLimiter` could have a more descriptive name",
  "Content": "\nhttps://github.com/code-423n4/2023-07-axelar/blob/main/contracts/cgp/AxelarGateway.sol#L87-L88\n\n```solidity\nFile: cgp/AxelarGateway.sol\n\n87:    modifier onlyMintLimiter() {\n88:        if (msg.sender != getAddress(KEY_MINT_LIMITER) && msg.sender != getAddress(KEY_GOVERNANCE)) revert NotMintLimiter();\n```\n\n`onlyMintLimiter` could be named `onlyMintLimiterOrGov` since this is what it verifies.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-axelar",
  "Code": [
    {
      "filename": "contracts/cgp/AxelarGateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { SafeTokenCall, SafeTokenTransfer, SafeTokenTransferFrom } from '../gmp-sdk/util/SafeTransfer.sol';\nimport { IERC20 } from '../gmp-sdk/interfaces/IERC20.sol';\nimport { IAxelarGateway } from './interfaces/IAxelarGateway.sol';\nimport { IGovernable } from './interfaces/IGovernable.sol';\nimport { IAxelarAuth } from './interfaces/IAxelarAuth.sol';\nimport { IBurnableMintableCappedERC20 } from './interfaces/IBurnableMintableCappedERC20.sol';\nimport { ITokenDeployer } from './interfaces/ITokenDeployer.sol';\n\nimport { ECDSA } from './ECDSA.sol';\nimport { DepositHandler } from './DepositHandler.sol';\nimport { AdminMultisigBase } from './AdminMultisigBase.sol';\n\ncontract AxelarGateway is IAxelarGateway, IGovernable, AdminMultisigBase {\n    using SafeTokenCall for IERC20;\n    using SafeTokenTransfer for IERC20;\n    using SafeTokenTransferFrom for IERC20;\n\n    error InvalidImplementation();\n\n    enum TokenType {\n        InternalBurnable,\n        InternalBurnableFrom,\n        External\n    }\n\n    /// @dev Removed slots; Should avoid re-using\n    // bytes32 internal constant KEY_ALL_TOKENS_FROZEN = keccak256('all-tokens-frozen');\n    // bytes32 internal constant PREFIX_TOKEN_FROZEN = keccak256('token-frozen');\n\n    /// @dev Storage slot with the address of the current implementation. `keccak256('eip1967.proxy.implementation') - 1`.\n    bytes32 internal constant KEY_IMPLEMENTATION = bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\n\n    /// @dev Storage slot with the address of the current governance. `keccak256('governance') - 1`.\n    bytes32 internal constant KEY_GOVERNANCE = bytes32(0xabea6fd3db56a6e6d0242111b43ebb13d1c42709651c032c7894962023a1f909);\n\n    /// @dev Storage slot with the address of the current governance. `keccak256('mint-limiter') - 1`.\n    bytes32 internal constant KEY_MINT_LIMITER = bytes32(0x627f0c11732837b3240a2de89c0b6343512886dd50978b99c76a68c6416a4d92);\n\n    // AUDIT: slot names should be prefixed with some standard string\n    bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');\n    bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');\n    bytes32 internal constant PREFIX_TOKEN_TYPE = keccak256('token-type');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED = keccak256('contract-call-approved');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT = keccak256('contract-call-approved-with-mint');\n    bytes32 internal constant PREFIX_TOKEN_MINT_LIMIT = keccak256('token-mint-limit');\n    bytes32 internal constant PREFIX_TOKEN_MINT_AMOUNT = keccak256('token-mint-amount');\n\n    bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');\n    bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');\n    bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL = keccak256('approveContractCall');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT = keccak256('approveContractCallWithMint');\n    bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');\n\n    // solhint-disable-next-line var-name-mixedcase\n    address internal immutable AUTH_MODULE;\n    // solhint-disable-next-line var-name-mixedcase\n    address internal immutable TOKEN_DEPLOYER_IMPLEMENTATION;\n\n    constructor(address authModule_, address tokenDeployerImplementation_) {\n        if (authModule_.code.length == 0) revert InvalidAuthModule();\n        if (tokenDeployerImplementation_.code.length == 0) revert InvalidTokenDeployer();\n\n        AUTH_MODULE = authModule_;\n        TOKEN_DEPLOYER_IMPLEMENTATION = tokenDeployerImplementation_;\n    }\n\n    modifier onlySelf() {\n        if (msg.sender != address(this)) revert NotSelf();\n\n        _;\n    }\n\n    modifier onlyGovernance() {\n        if (msg.sender != getAddress(KEY_GOVERNANCE)) revert NotGovernance();\n\n        _;\n    }\n\n    /*\n     * @dev Reverts with an error if the sender is not the mint limiter or governance.\n     */\n    modifier onlyMintLimiter() {\n        if (msg.sender != getAddress(KEY_MINT_LIMITER) && msg.sender != getAddress(KEY_GOVERNANCE)) revert NotMintLimiter();\n\n        _;\n    }\n\n    /******************\\\n    |* Public Methods *|\n    \\******************/\n\n    function sendToken(\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        string calldata symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit TokenSent(msg.sender, destinationChain, destinationAddress, symbol, amount);\n    }\n\n    function callContract(\n        string calldata destinationChain,\n        string calldata destinationContractAddress,\n        bytes calldata payload\n    ) external {\n        emit ContractCall(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload);\n    }\n\n    function callContractWithToken(\n        string calldata destinationChain,\n        string calldata destinationContractAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit ContractCallWithToken(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload, symbol, amount);\n    }\n\n    function isContractCallApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) external view override returns (bool) {\n        return getBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash));\n    }\n\n    function isContractCallAndMintApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external view override returns (bool) {\n        return\n            getBool(\n                _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount)\n            );\n    }\n\n    function validateContractCall(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash);\n        valid = getBool(key);\n        if (valid) _setBool(key, false);\n    }\n\n    function validateContractCallAndMint(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash, symbol, amount);\n        valid = getBool(key);\n        if (valid) {\n            // Prevent re-entrance\n            _setBool(key, false);\n            _mintToken(symbol, msg.sender, amount);\n        }\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function authModule() public view override returns (address) {\n        return AUTH_MODULE;\n    }\n\n    function governance() public view override returns (address) {\n        return getAddress(KEY_GOVERNANCE);\n    }\n\n    function mintLimiter() public view override returns (address) {\n        return getAddress(KEY_MINT_LIMITER);\n    }\n\n    function tokenDeployer() public view returns (address) {\n        return TOKEN_DEPLOYER_IMPLEMENTATION;\n    }\n\n    function tokenMintLimit(string memory symbol) public view override returns (uint256) {\n        return getUint(_getTokenMintLimitKey(symbol));\n    }\n\n    function tokenMintAmount(string memory symbol) public view override returns (uint256) {\n        return getUint(_getTokenMintAmountKey(symbol, block.timestamp / 6 hours));\n    }\n\n    /// @dev This function is kept around to keep things working for internal\n    /// tokens that were deployed before the token freeze functionality was removed\n    function allTokensFrozen() external pure override returns (bool) {\n        return false;\n    }\n\n    /// @dev Deprecated.\n    function adminEpoch() external pure override returns (uint256) {\n        return 0;\n    }\n\n    /// @dev Deprecated.\n    function adminThreshold(uint256) external pure override returns (uint256) {\n        return 0;\n    }\n\n    /// @dev Deprecated.\n    function admins(uint256) external pure override returns (address[] memory) {\n        return new address[](0);\n    }\n\n    function implementation() public view override returns (address) {\n        return getAddress(KEY_IMPLEMENTATION);\n    }\n\n    function tokenAddresses(string memory symbol) public view override returns (address) {\n        return getAddress(_getTokenAddressKey(symbol));\n    }\n\n    /// @dev This function is kept around to keep things working for internal\n    /// tokens that were deployed before the token freeze functionality was removed\n    function tokenFrozen(string memory) external pure override returns (bool) {\n        return false;\n    }\n\n    function isCommandExecuted(bytes32 commandId) public view override returns (bool) {\n        return getBool(_getIsCommandExecutedKey(commandId));\n    }\n\n    function contractId() public pure returns (bytes32) {\n        return keccak256('axelar-gateway');\n    }\n\n    /************************\\\n    |* Governance Functions *|\n    \\************************/\n\n    function transferGovernance(address newGovernance) external override onlyGovernance {\n        if (newGovernance == address(0)) revert InvalidGovernance();\n\n        _transferGovernance(newGovernance);\n    }\n\n    function transferMintLimiter(address newMintLimiter) external override onlyMintLimiter {\n        if (newMintLimiter == address(0)) revert InvalidMintLimiter();\n\n        _transferMintLimiter(newMintLimiter);\n    }\n\n    function setTokenMintLimits(string[] calldata symbols, uint256[] calldata limits) external override onlyMintLimiter {\n        uint256 length = symbols.length;\n        if (length != limits.length) revert InvalidSetMintLimitsParams();\n\n        for (uint256 i; i < length; ++i) {\n            string memory symbol = symbols[i];\n            uint256 limit = limits[i];\n\n            if (tokenAddresses(symbol) == address(0)) revert TokenDoesNotExist(symbol);\n\n            _setTokenMintLimit(symbol, limit);\n        }\n    }\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata setupParams\n    ) external override onlyGovernance {\n        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();\n\n        if (AxelarGateway(newImplementation).contractId() != contractId()) revert InvalidImplementation();\n\n        emit Upgraded(newImplementation);\n\n        // AUDIT: If `newImplementation.setup` performs `selfdestruct`, it will result in the loss of _this_ implementation (thereby losing the gateway)\n        //        if `upgrade` is entered within the context of _this_ implementation itself.\n        if (setupParams.length != 0) {\n            (bool success, ) = newImplementation.delegatecall(abi.encodeWithSelector(IAxelarGateway.setup.selector, setupParams));\n\n            if (!success) revert SetupFailed();\n        }\n\n        _setImplementation(newImplementation);\n    }\n\n    /**********************\\\n    |* External Functions *|\n    \\**********************/\n\n    /// @dev Not publicly accessible as overshadowed in the proxy\n    function setup(bytes calldata params) external override {\n        // Prevent setup from being called on a non-proxy (the implementation).\n        if (implementation() == address(0)) revert NotProxy();\n\n        (address governance_, address mintLimiter_, bytes memory newOperatorsData) = abi.decode(params, (address, address, bytes));\n\n        if (governance_ != address(0)) _transferGovernance(governance_);\n        if (mintLimiter_ != address(0)) _transferMintLimiter(mintLimiter_);\n\n        if (newOperatorsData.length != 0) {\n            IAxelarAuth(AUTH_MODULE).transferOperatorship(newOperatorsData);\n\n            emit OperatorshipTransferred(newOperatorsData);\n        }\n    }\n\n    function execute(bytes calldata input) external override {\n        (bytes memory data, bytes memory proof) = abi.decode(input, (bytes, bytes));\n\n        bytes32 messageHash = ECDSA.toEthSignedMessageHash(keccak256(data));\n\n        // returns true for current operators\n        bool allowOperatorshipTransfer = IAxelarAuth(AUTH_MODULE).validateProof(messageHash, proof);\n\n        uint256 chainId;\n        bytes32[] memory commandIds;\n        string[] memory commands;\n        bytes[] memory params;\n\n        (chainId, commandIds, commands, params) = abi.decode(data, (uint256, bytes32[], string[], bytes[]));\n\n        if (chainId != block.chainid) revert InvalidChainId();\n\n        uint256 commandsLength = commandIds.length;\n\n        if (commandsLength != commands.length || commandsLength != params.length) revert InvalidCommands();\n\n        for (uint256 i; i < commandsLength; ++i) {\n            bytes32 commandId = commandIds[i];\n\n            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */\n\n            bytes4 commandSelector;\n            bytes32 commandHash = keccak256(abi.encodePacked(commands[i]));\n\n            if (commandHash == SELECTOR_DEPLOY_TOKEN) {\n                commandSelector = AxelarGateway.deployToken.selector;\n            } else if (commandHash == SELECTOR_MINT_TOKEN) {\n                commandSelector = AxelarGateway.mintToken.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL) {\n                commandSelector = AxelarGateway.approveContractCall.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT) {\n                commandSelector = AxelarGateway.approveContractCallWithMint.selector;\n            } else if (commandHash == SELECTOR_BURN_TOKEN) {\n                commandSelector = AxelarGateway.burnToken.selector;\n            } else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {\n                if (!allowOperatorshipTransfer) continue;\n\n                allowOperatorshipTransfer = false;\n                commandSelector = AxelarGateway.transferOperatorship.selector;\n            } else {\n                continue; /* Ignore if unknown command received */\n            }\n\n            // Prevent a re-entrancy from executing this command before it can be marked as successful.\n            _setCommandExecuted(commandId, true);\n\n            (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));\n\n            if (success) emit Executed(commandId);\n            else _setCommandExecuted(commandId, false);\n        }\n    }\n\n    /******************\\\n    |* Self Functions *|\n    \\******************/\n\n    function deployToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory name, string memory symbol, uint8 decimals, uint256 cap, address tokenAddress, uint256 mintLimit) = abi.decode(\n            params,\n            (string, string, uint8, uint256, address, uint256)\n        );\n\n        // Ensure that this symbol has not been taken.\n        if (tokenAddresses(symbol) != address(0)) revert TokenAlreadyExists(symbol);\n\n        if (tokenAddress == address(0)) {\n            // If token address is no specified, it indicates a request to deploy one.\n            bytes32 salt = keccak256(abi.encodePacked(symbol));\n\n            (bool success, bytes memory data) = TOKEN_DEPLOYER_IMPLEMENTATION.delegatecall(\n                abi.encodeWithSelector(ITokenDeployer.deployToken.selector, name, symbol, decimals, cap, salt)\n            );\n\n            if (!success) revert TokenDeployFailed(symbol);\n\n            tokenAddress = abi.decode(data, (address));\n\n            _setTokenType(symbol, TokenType.InternalBurnableFrom);\n        } else {\n            // If token address is specified, ensure that there is a contact at the specified address.\n            if (tokenAddress.code.length == uint256(0)) revert TokenContractDoesNotExist(tokenAddress);\n\n            // Mark that this symbol is an external token, which is needed to differentiate between operations on mint and burn.\n            _setTokenType(symbol, TokenType.External);\n        }\n\n        _setTokenAddress(symbol, tokenAddress);\n        _setTokenMintLimit(symbol, mintLimit);\n\n        emit TokenDeployed(symbol, tokenAddress);\n    }\n\n    function mintToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, address account, uint256 amount) = abi.decode(params, (string, address, uint256));\n\n        _mintToken(symbol, account, amount);\n    }\n\n    function burnToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, bytes32 salt) = abi.decode(params, (string, bytes32));\n\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            address depositHandlerAddress = _getCreate2Address(salt, keccak256(abi.encodePacked(type(DepositHandler).creationCode)));\n\n            if (_hasCode(depositHandlerAddress)) return;\n\n            DepositHandler depositHandler = new DepositHandler{ salt: salt }();\n\n            (bool success, bytes memory returnData) = depositHandler.execute(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20.transfer.selector, address(this), IERC20(tokenAddress).balanceOf(address(depositHandler)))\n            );\n\n            if (!success || (returnData.length != uint256(0) && !abi.decode(returnData, (bool)))) revert BurnFailed(symbol);\n\n            // NOTE: `depositHandler` must always be destroyed in the same runtime context that it is deployed.\n            depositHandler.destroy(address(this));\n        } else {\n            IBurnableMintableCappedERC20(tokenAddress).burn(salt);\n        }\n    }\n\n    function approveContractCall(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, bytes32, uint256));\n\n        _setContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash);\n        emit ContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, sourceTxHash, sourceEventIndex);\n    }\n\n    function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            string memory symbol,\n            uint256 amount,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, string, uint256, bytes32, uint256));\n\n        _setContractCallApprovedWithMint(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount);\n        emit ContractCallApprovedWithMint(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            contractAddress,\n            payloadHash,\n            symbol,\n            amount,\n            sourceTxHash,\n            sourceEventIndex\n        );\n    }\n\n    function transferOperatorship(bytes calldata newOperatorsData, bytes32) external onlySelf {\n        IAxelarAuth(AUTH_MODULE).transferOperatorship(newOperatorsData);\n\n        emit OperatorshipTransferred(newOperatorsData);\n    }\n\n    /********************\\\n    |* Internal Methods *|\n    \\********************/\n\n    function _hasCode(address addr) internal view returns (bool) {\n        bytes32 codehash = addr.codehash;\n\n        // https://eips.ethereum.org/EIPS/eip-1052\n        return codehash != bytes32(0) && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    }\n\n    function _mintToken(\n        string memory symbol,\n        address account,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        _setTokenMintAmount(symbol, tokenMintAmount(symbol) + amount);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            IERC20(tokenAddress).safeTransfer(account, amount);\n        } else {\n            IBurnableMintableCappedERC20(tokenAddress).mint(account, amount);\n        }\n    }\n\n    function _burnTokenFrom(\n        address sender,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n        if (amount == 0) revert InvalidAmount();\n\n        TokenType tokenType = _getTokenType(symbol);\n\n        if (tokenType == TokenType.External) {\n            IERC20(tokenAddress).safeTransferFrom(sender, address(this), amount);\n        } else if (tokenType == TokenType.InternalBurnableFrom) {\n            IERC20(tokenAddress).safeCall(abi.encodeWithSelector(IBurnableMintableCappedERC20.burnFrom.selector, sender, amount));\n        } else {\n            IERC20(tokenAddress).safeTransferFrom(sender, IBurnableMintableCappedERC20(tokenAddress).depositAddress(bytes32(0)), amount);\n            IBurnableMintableCappedERC20(tokenAddress).burn(bytes32(0));\n        }\n    }\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getTokenMintLimitKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_MINT_LIMIT, symbol));\n    }\n\n    function _getTokenMintAmountKey(string memory symbol, uint256 day) internal pure returns (bytes32) {\n        // abi.encode to securely hash dynamic-length symbol data followed by day\n        return keccak256(abi.encode(PREFIX_TOKEN_MINT_AMOUNT, symbol, day));\n    }\n\n    function _getTokenTypeKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_TYPE, symbol));\n    }\n\n    function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));\n    }\n\n    function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));\n    }\n\n    function _getIsContractCallApprovedKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(PREFIX_CONTRACT_CALL_APPROVED, commandId, sourceChain, sourceAddress, contractAddress, payloadHash));\n    }\n\n    function _getIsContractCallApprovedWithMintKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT,\n                    commandId,\n                    sourceChain,\n                    sourceAddress,\n                    contractAddress,\n                    payloadHash,\n                    symbol,\n                    amount\n                )\n            );\n    }\n\n    /********************\\\n    |* Internal Getters *|\n    \\********************/\n\n    function _getCreate2Address(bytes32 salt, bytes32 codeHash) internal view returns (address) {\n        return address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, codeHash)))));\n    }\n\n    function _getTokenType(string memory symbol) internal view returns (TokenType) {\n        return TokenType(getUint(_getTokenTypeKey(symbol)));\n    }\n\n    /********************\\\n    |* Internal Setters *|\n    \\********************/\n\n    function _setTokenMintLimit(string memory symbol, uint256 limit) internal {\n        _setUint(_getTokenMintLimitKey(symbol), limit);\n\n        emit TokenMintLimitUpdated(symbol, limit);\n    }\n\n    function _setTokenMintAmount(string memory symbol, uint256 amount) internal {\n        uint256 limit = tokenMintLimit(symbol);\n        if (limit > 0 && amount > limit) revert ExceedMintLimit(symbol);\n\n        _setUint(_getTokenMintAmountKey(symbol, block.timestamp / 6 hours), amount);\n    }\n\n    function _setTokenType(string memory symbol, TokenType tokenType) internal {\n        _setUint(_getTokenTypeKey(symbol), uint256(tokenType));\n    }\n\n    function _setTokenAddress(string memory symbol, address tokenAddress) internal {\n        _setAddress(_getTokenAddressKey(symbol), tokenAddress);\n    }\n\n    function _setCommandExecuted(bytes32 commandId, bool executed) internal {\n        _setBool(_getIsCommandExecutedKey(commandId), executed);\n    }\n\n    function _setContractCallApproved(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal {\n        _setBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash), true);\n    }\n\n    function _setContractCallApprovedWithMint(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        _setBool(\n            _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount),\n            true\n        );\n    }\n\n    function _setImplementation(address newImplementation) internal {\n        _setAddress(KEY_IMPLEMENTATION, newImplementation);\n    }\n\n    function _transferGovernance(address newGovernance) internal {\n        emit GovernanceTransferred(getAddress(KEY_GOVERNANCE), newGovernance);\n\n        _setAddress(KEY_GOVERNANCE, newGovernance);\n    }\n\n    function _transferMintLimiter(address newMintLimiter) internal {\n        emit MintLimiterTransferred(getAddress(KEY_MINT_LIMITER), newMintLimiter);\n\n        _setAddress(KEY_MINT_LIMITER, newMintLimiter);\n    }\n}"
    }
  ]
}