{
  "Title": "M-9: `CrossCurrencyfCashVault` Cannot Settle Its Assets In Pieces",
  "Content": "# Issue M-9: `CrossCurrencyfCashVault` Cannot Settle Its Assets In Pieces \n\nSource: https://github.com/sherlock-audit/2022-09-notional-judging/issues/79 \n\n## Found by \nxiaoming90\n\n## Summary\n\nThe `CrossCurrencyfCashVault` vault cannot settle its assets in pieces. Thus, it might cause the vault to incur unnecessary slippage.\n\n## Vulnerability Detail\n\nThe settle vault function is designed in a manner where its assets can be settled in pieces. Therefore, the `settleVault` function accepts a `strategyTokens` or `strategyTokensToRedeem` parameter to allow the caller to specify the number of strategy tokens to be settled.\n\nThe reason as mentioned in Notional's walkthrough video (Refer to the explanation at [15.50min](https://youtu.be/GZJvLqUzK_0?t=940) mark) is that in some cases the caller might want to break down into multiple transactions due to massive slippage.\n\nFor instance, the vault might utilize a 2 day settlement period to allow the vault to settle its assets in pieces so that it can avoid unnecessary transaction costs associated with converting all its assets back to USDC in a single transaction. \n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/CrossCurrencyfCashVault.sol#L121\n\n```solidity\nFile: CrossCurrencyfCashVault.sol\n113:     /**\n114:      * @notice During settlement all of the fCash balance in the lend currency will be redeemed to the\n115:      * underlying token and traded back to the borrow currency. All of the borrow currency will be deposited\n116:      * into the Notional contract as asset tokens and held for accounts to withdraw. Settlement can only\n117:      * be called after maturity.\n118:      * @param maturity the maturity to settle\n119:      * @param settlementTrade details for the settlement trade\n120:      */\n121:     function settleVault(uint256 maturity, uint256 strategyTokens, bytes calldata settlementTrade) external {\n122:         require(maturity <= block.timestamp, \"Cannot Settle\");\n123:         VaultState memory vaultState = NOTIONAL.getVaultState(address(this), maturity);\n124:         require(vaultState.isSettled == false);\n125:         require(vaultState.totalStrategyTokens >= strategyTokens);\n126: \n127:         RedeemParams memory params = abi.decode(settlementTrade, (RedeemParams));\n128:     \n129:         // The only way for underlying value to be negative would be if the vault has somehow ended up with a borrowing\n130:         // position in the lend underlying currency. This is explicitly prevented during redemption.\n131:         uint256 underlyingValue = convertStrategyToUnderlying(\n132:             address(0), vaultState.totalStrategyTokens, maturity\n133:         ).toUint();\n134: \n135:         // Authenticate the minimum purchase amount, all tokens will be sold given this slippage limit.\n136:         uint256 minAllowedPurchaseAmount = (underlyingValue * settlementSlippageLimit) / SETTLEMENT_SLIPPAGE_PRECISION;\n137:         require(params.minPurchaseAmount >= minAllowedPurchaseAmount, \"Purchase Limit\");\n138: \n139:         NOTIONAL.redeemStrategyTokensToCash(maturity, strategyTokens, settlementTrade);\n140: \n141:         // If there are no more strategy tokens left, then mark the vault as settled\n142:         vaultState = NOTIONAL.getVaultState(address(this), maturity);\n143:         if (vaultState.totalStrategyTokens == 0) {\n144:             NOTIONAL.settleVault(address(this), maturity);\n145:         }\n146:     }\n```\n\nDuring vault settlement, the `CrossCurrencyfCashVault._redeemFromNotional` function will be called, and the code in lines 252-262 will be executed. However, it was observed that the `strategyTokens` parameter is ignored, and the vault will forcefully settle all the strategy tokens in one go. As such, there is no way for the caller to break down the settle vault transaction into multiple transactions.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/CrossCurrencyfCashVault.sol#L243\n\n```solidity\nFile: CrossCurrencyfCashVault.sol\n243:     function _redeemFromNotional(\n244:         address account,\n245:         uint256 strategyTokens,\n246:         uint256 maturity,\n247:         bytes calldata data\n248:     ) internal override returns (uint256 borrowedCurrencyAmount) {\n249:         uint256 balanceBefore = LEND_UNDERLYING_TOKEN.balanceOf(address(this));\n250:         RedeemParams memory params = abi.decode(data, (RedeemParams));\n251: \n252:         if (maturity <= block.timestamp) {\n253:             // Only allow the vault to redeem past maturity to settle all positions\n254:             require(account == address(this));\n255:             NOTIONAL.settleAccount(address(this));\n256:             (int256 cashBalance, /* */, /* */) = NOTIONAL.getAccountBalance(LEND_CURRENCY_ID, address(this));\n257: \n258:             // It should never be possible that this contract has a negative cash balance\n259:             require(0 <= cashBalance && cashBalance <= int256(uint256(type(uint88).max)));\n260: \n261:             // Withdraws all cash to underlying\n262:             NOTIONAL.withdraw(LEND_CURRENCY_ID, uint88(uint256(cashBalance)), true);\n263:         } else {\n264:             // Sells fCash on Notional AMM (via borrowing)\n265:             BalanceActionWithTrades[] memory action = _encodeBorrowTrade(\n266:                 maturity,\n267:                 strategyTokens,\n268:                 params.maxBorrowRate\n269:             );\n270:             NOTIONAL.batchBalanceAndTradeAction(address(this), action);\n271: \n272:             // Check that we have not somehow borrowed into a negative fCash position, vault borrows\n273:             // are not included in account context\n274:             AccountContext memory accountContext = NOTIONAL.getAccountContext(address(this));\n275:             require(accountContext.hasDebt == 0x00);\n276:         }\n277: \n278:         uint256 balanceAfter = LEND_UNDERLYING_TOKEN.balanceOf(address(this));\n279:         \n280:         // Trade back to borrow currency for repayment\n281:         Trade memory trade = Trade({\n282:             tradeType: TradeType.EXACT_IN_SINGLE,\n283:             sellToken: address(LEND_UNDERLYING_TOKEN),\n284:             buyToken: address(_underlyingToken()),\n285:             amount: balanceAfter - balanceBefore,\n286:             limit: params.minPurchaseAmount,\n287:             deadline: block.timestamp,\n288:             exchangeData: params.exchangeData\n289:         });\n290: \n291:         (/* */, borrowedCurrencyAmount) = _executeTrade(params.dexId, trade);\n292:     }\n```\n\n## Impact\n\nThe vault might incur unnecessary slippage during settlement as the settlement cannot be broken into multiple transactions.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/CrossCurrencyfCashVault.sol#L121\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/CrossCurrencyfCashVault.sol#L243\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIt is recommended to update the `CrossCurrencyfCashVault._redeemFromNotional` function to allow the vault to be settled in multiple transactions.\n\n## Discussion\n\n**jeffywu**\n\nValid suggestion.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/2",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/CrossCurrencyfCashVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {IWrappedfCashFactory} from \"../../interfaces/notional/IWrappedfCashFactory.sol\";\nimport {WETH9} from \"../../interfaces/WETH9.sol\";\nimport {IWrappedfCashComplete as IWrappedfCash} from \"../../interfaces/notional/IWrappedfCash.sol\";\nimport {BaseStrategyVault} from \"./BaseStrategyVault.sol\";\nimport {IERC20} from \"../utils/TokenUtils.sol\";\nimport {\n    AccountContext,\n    BalanceActionWithTrades,\n    DepositActionType,\n    TradeActionType,\n    BatchLend,\n    Token,\n    TokenType,\n    VaultState\n} from \"../global/Types.sol\";\nimport {Constants} from \"../global/Constants.sol\";\nimport {DateTime} from \"../global/DateTime.sol\";\nimport {TypeConvert} from \"../global/TypeConvert.sol\";\nimport {ITradingModule, DexId, TradeType, Trade} from \"../../interfaces/trading/ITradingModule.sol\";\nimport {TradeHandler} from \"../trading/TradeHandler.sol\";\n\n/**\n * @notice This vault borrows in one currency, trades it to a different currency\n * and lends on Notional in that currency. It will be paired with another vault\n * that lends and borrows in the opposite direction.\n */\ncontract CrossCurrencyfCashVault is BaseStrategyVault {\n    using TypeConvert for uint256;\n    using TypeConvert for int256;\n\n    uint256 public constant SETTLEMENT_SLIPPAGE_PRECISION = 1e18;\n\n    struct DepositParams {\n        // Minimum purchase amount of the lend underlying token, this is\n        // based on the deposit + borrowed amount and must be set to a non-zero\n        // value to establish a slippage limit.\n        uint256 minPurchaseAmount;\n        // Minimum annualized lending rate, can be set to zero for no slippage limit\n        uint32 minLendRate;\n        // ID of the desired DEX to trade on, _depositFromNotional will always trade\n        // using an EXACT_IN_SINGLE trade which is supported by all DEXes\n        uint16 dexId;\n        // Exchange data depending on the selected dexId\n        bytes exchangeData;\n    }\n\n    struct RedeemParams {\n        // Minimum purchase amount of the borrow underlying token, this is\n        // based on the amount of lend underlying received and must be set to a non-zero\n        // value to establish a slippage limit.\n        uint256 minPurchaseAmount;\n        // Maximum annualized borrow rate, can be set to zero for no slippage limit\n        uint32 maxBorrowRate;\n        // ID of the desired DEX to trade on, _depositFromNotional will always trade\n        // using an EXACT_IN_SINGLE trade which is supported by all DEXes\n        uint16 dexId;\n        // Exchange data depending on the selected dexId\n        bytes exchangeData;\n    }\n\n    uint16 public LEND_CURRENCY_ID;\n    IERC20 public LEND_UNDERLYING_TOKEN;\n    /// @notice a maximum slippage limit in 1e18 precision, uint64 is sufficient to hold the maximum value which\n    /// is 1e18\n    uint64 public settlementSlippageLimit;\n    // NOTE: 2 bytes left in first storage slot here\n\n    constructor(NotionalProxy notional_, ITradingModule tradingModule_)\n        BaseStrategyVault(notional_, tradingModule_) {}\n\n    function strategy() external override view returns (bytes4) {\n        return bytes4(keccak256(\"CrossCurrencyfCash\"));\n    }\n    function initialize(\n        string memory name_,\n        uint16 borrowCurrencyId_,\n        uint16 lendCurrencyId_,\n        uint64 settlementSlippageLimit_\n    ) external initializer {\n        __INIT_VAULT(name_, borrowCurrencyId_);\n\n        LEND_CURRENCY_ID = lendCurrencyId_;\n        (\n            Token memory assetToken,\n            Token memory underlyingToken,\n            /* ETHRate memory ethRate */,\n            /* AssetRateParameters memory assetRate */\n        ) = NOTIONAL.getCurrencyAndRates(lendCurrencyId_);\n\n        IERC20 tokenAddress = assetToken.tokenType == TokenType.NonMintable ?\n            IERC20(assetToken.tokenAddress) : IERC20(underlyingToken.tokenAddress);\n        LEND_UNDERLYING_TOKEN = tokenAddress;\n\n        // Allow Notional to pull the lend underlying currency\n        tokenAddress.approve(address(NOTIONAL), type(uint256).max);\n\n        // This value cannot be greater than 1e18\n        require(settlementSlippageLimit_ < SETTLEMENT_SLIPPAGE_PRECISION);\n        settlementSlippageLimit = settlementSlippageLimit_;\n    }\n\n    function updateSettlementSlippageLimit(uint64 newSlippageLimit) external {\n        require(msg.sender == NOTIONAL.owner());\n        require(newSlippageLimit < SETTLEMENT_SLIPPAGE_PRECISION);\n        settlementSlippageLimit = newSlippageLimit;\n    }\n\n    /**\n     * @notice During settlement all of the fCash balance in the lend currency will be redeemed to the\n     * underlying token and traded back to the borrow currency. All of the borrow currency will be deposited\n     * into the Notional contract as asset tokens and held for accounts to withdraw. Settlement can only\n     * be called after maturity.\n     * @param maturity the maturity to settle\n     * @param settlementTrade details for the settlement trade\n     */\n    function settleVault(uint256 maturity, uint256 strategyTokens, bytes calldata settlementTrade) external {\n        require(maturity <= block.timestamp, \"Cannot Settle\");\n        VaultState memory vaultState = NOTIONAL.getVaultState(address(this), maturity);\n        require(vaultState.isSettled == false);\n        require(vaultState.totalStrategyTokens >= strategyTokens);\n\n        RedeemParams memory params = abi.decode(settlementTrade, (RedeemParams));\n    \n        // The only way for underlying value to be negative would be if the vault has somehow ended up with a borrowing\n        // position in the lend underlying currency. This is explicitly prevented during redemption.\n        uint256 underlyingValue = convertStrategyToUnderlying(\n            address(0), vaultState.totalStrategyTokens, maturity\n        ).toUint();\n\n        // Authenticate the minimum purchase amount, all tokens will be sold given this slippage limit.\n        uint256 minAllowedPurchaseAmount = (underlyingValue * settlementSlippageLimit) / SETTLEMENT_SLIPPAGE_PRECISION;\n        require(params.minPurchaseAmount >= minAllowedPurchaseAmount, \"Purchase Limit\");\n\n        NOTIONAL.redeemStrategyTokensToCash(maturity, strategyTokens, settlementTrade);\n\n        // If there are no more strategy tokens left, then mark the vault as settled\n        vaultState = NOTIONAL.getVaultState(address(this), maturity);\n        if (vaultState.totalStrategyTokens == 0) {\n            NOTIONAL.settleVault(address(this), maturity);\n        }\n    }\n\n    /**\n     * @notice Converts the amount of fCash the vault holds into underlying denomination for the\n     * borrow currency.\n     * @param strategyTokens each strategy token is equivalent to 1 unit of fCash\n     * @param maturity the maturity of the fCash\n     * @return underlyingValue the value of the lent fCash in terms of the borrowed currency\n     */\n    function convertStrategyToUnderlying(\n        address /* account */,\n        uint256 strategyTokens,\n        uint256 maturity\n    ) public override view returns (int256 underlyingValue) {\n        int256 pvInternal;\n        if (maturity <= block.timestamp) {\n            // After maturity, strategy tokens no longer have a present value\n            pvInternal = strategyTokens.toInt();\n        } else {\n            // This is the non-risk adjusted oracle price for fCash, present value is used in case\n            // liquidation is required. The liquidator may need to exit the fCash position in order\n            // to repay a flash loan.\n            pvInternal = NOTIONAL.getPresentfCashValue(\n                LEND_CURRENCY_ID, maturity, strategyTokens.toInt(), block.timestamp, false\n            );\n        }\n\n        IERC20 underlyingToken = _underlyingToken();\n        (int256 rate, int256 rateDecimals) = TRADING_MODULE.getOraclePrice(\n            address(LEND_UNDERLYING_TOKEN), address(underlyingToken)\n        );\n        int256 borrowTokenDecimals = int256(10**underlyingToken.decimals());\n\n        // Convert this back to the borrow currency, external precision\n        // (pv (8 decimals) * borrowTokenDecimals * rate) / (rateDecimals * 8 decimals)\n        return (pvInternal * borrowTokenDecimals * rate) /\n            (rateDecimals * int256(Constants.INTERNAL_TOKEN_PRECISION));\n    }\n\n    /**\n     * @notice Will receive a deposit from Notional in underlying tokens of the borrowed currency.\n     * Needs to first trade that deposit into the lend currency and then lend it to fCash on the\n     * corresponding maturity.\n     * @param depositUnderlyingExternal amount of tokens deposited in the borrow currency\n     * @param maturity the maturity that was borrowed at, will also be the maturity that is lent to\n     * @param data DepositParams\n     * @return lendfCashMinted the amount of strategy tokens (fCash lent) generated\n     */\n    function _depositFromNotional(\n        address /* account */,\n        uint256 depositUnderlyingExternal,\n        uint256 maturity,\n        bytes calldata data\n    ) internal override returns (uint256 lendfCashMinted) {\n        DepositParams memory params = abi.decode(data, (DepositParams));\n        Trade memory trade = Trade({\n            tradeType: TradeType.EXACT_IN_SINGLE,\n            sellToken: address(_underlyingToken()),\n            buyToken: address(LEND_UNDERLYING_TOKEN),\n            amount: depositUnderlyingExternal,\n            limit: params.minPurchaseAmount,\n            deadline: block.timestamp,\n            exchangeData: params.exchangeData\n        });\n\n        (/* */, uint256 lendUnderlyingTokens) = _executeTrade(params.dexId, trade);\n\n        // Now we lend the underlying amount\n        (uint256 fCashAmount, /* */, bytes32 encodedTrade) = NOTIONAL.getfCashLendFromDeposit(\n            LEND_CURRENCY_ID,\n            lendUnderlyingTokens,\n            maturity,\n            params.minLendRate,\n            block.timestamp,\n            true // useUnderlying is true\n        );\n\n        BatchLend[] memory action = new BatchLend[](1);\n        action[0].currencyId = LEND_CURRENCY_ID;\n        action[0].depositUnderlying = true;\n        action[0].trades = new bytes32[](1);\n        action[0].trades[0] = encodedTrade;\n        NOTIONAL.batchLend(address(this), action);\n\n        // fCash is the strategy token in this case, batchLend will always mint exactly fCashAmount\n        return fCashAmount;\n    }\n\n    /**\n     * @notice Withdraws lent fCash from Notional (by selling it prior to maturity or withdrawing post maturity),\n     * and trades it all back to the borrowed currency.\n     * @param account the account that is doing the redemption\n     * @param strategyTokens the amount of fCash to redeem\n     * @param maturity the maturity of the fCash\n     * @param data RedeemParams\n     * @return borrowedCurrencyAmount the amount of borrowed currency raised by the redemption\n     */\n    function _redeemFromNotional(\n        address account,\n        uint256 strategyTokens,\n        uint256 maturity,\n        bytes calldata data\n    ) internal override returns (uint256 borrowedCurrencyAmount) {\n        uint256 balanceBefore = LEND_UNDERLYING_TOKEN.balanceOf(address(this));\n        RedeemParams memory params = abi.decode(data, (RedeemParams));\n\n        if (maturity <= block.timestamp) {\n            // Only allow the vault to redeem past maturity to settle all positions\n            require(account == address(this));\n            NOTIONAL.settleAccount(address(this));\n            (int256 cashBalance, /* */, /* */) = NOTIONAL.getAccountBalance(LEND_CURRENCY_ID, address(this));\n\n            // It should never be possible that this contract has a negative cash balance\n            require(0 <= cashBalance && cashBalance <= int256(uint256(type(uint88).max)));\n\n            // Withdraws all cash to underlying\n            NOTIONAL.withdraw(LEND_CURRENCY_ID, uint88(uint256(cashBalance)), true);\n        } else {\n            // Sells fCash on Notional AMM (via borrowing)\n            BalanceActionWithTrades[] memory action = _encodeBorrowTrade(\n                maturity,\n                strategyTokens,\n                params.maxBorrowRate\n            );\n            NOTIONAL.batchBalanceAndTradeAction(address(this), action);\n\n            // Check that we have not somehow borrowed into a negative fCash position, vault borrows\n            // are not included in account context\n            AccountContext memory accountContext = NOTIONAL.getAccountContext(address(this));\n            require(accountContext.hasDebt == 0x00);\n        }\n\n        uint256 balanceAfter = LEND_UNDERLYING_TOKEN.balanceOf(address(this));\n        \n        // Trade back to borrow currency for repayment\n        Trade memory trade = Trade({\n            tradeType: TradeType.EXACT_IN_SINGLE,\n            sellToken: address(LEND_UNDERLYING_TOKEN),\n            buyToken: address(_underlyingToken()),\n            amount: balanceAfter - balanceBefore,\n            limit: params.minPurchaseAmount,\n            deadline: block.timestamp,\n            exchangeData: params.exchangeData\n        });\n\n        (/* */, borrowedCurrencyAmount) = _executeTrade(params.dexId, trade);\n    }\n\n    function _encodeBorrowTrade(\n        uint256 maturity,\n        uint256 fCashAmount,\n        uint32 maxImpliedRate\n    ) private view returns (BalanceActionWithTrades[] memory action) {\n        (uint256 marketIndex, bool isIdiosyncratic) = DateTime.getMarketIndex(\n            Constants.MAX_TRADED_MARKET_INDEX,\n            maturity,\n            block.timestamp\n        );\n        require(!isIdiosyncratic);\n        require(fCashAmount <= uint256(type(uint88).max));\n\n        action = new BalanceActionWithTrades[](1);\n        action[0].actionType = DepositActionType.None;\n        action[0].currencyId = LEND_CURRENCY_ID;\n        action[0].withdrawEntireCashBalance = true;\n        action[0].redeemToUnderlying = true;\n        action[0].trades = new bytes32[](1);\n        action[0].trades[0] = bytes32(\n            (uint256(uint8(TradeActionType.Borrow)) << 248) |\n            (uint256(marketIndex) << 240) |\n            (uint256(fCashAmount) << 152) |\n            (uint256(maxImpliedRate) << 120)\n        );\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/CrossCurrencyfCashVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {IWrappedfCashFactory} from \"../../interfaces/notional/IWrappedfCashFactory.sol\";\nimport {WETH9} from \"../../interfaces/WETH9.sol\";\nimport {IWrappedfCashComplete as IWrappedfCash} from \"../../interfaces/notional/IWrappedfCash.sol\";\nimport {BaseStrategyVault} from \"./BaseStrategyVault.sol\";\nimport {IERC20} from \"../utils/TokenUtils.sol\";\nimport {\n    AccountContext,\n    BalanceActionWithTrades,\n    DepositActionType,\n    TradeActionType,\n    BatchLend,\n    Token,\n    TokenType,\n    VaultState\n} from \"../global/Types.sol\";\nimport {Constants} from \"../global/Constants.sol\";\nimport {DateTime} from \"../global/DateTime.sol\";\nimport {TypeConvert} from \"../global/TypeConvert.sol\";\nimport {ITradingModule, DexId, TradeType, Trade} from \"../../interfaces/trading/ITradingModule.sol\";\nimport {TradeHandler} from \"../trading/TradeHandler.sol\";\n\n/**\n * @notice This vault borrows in one currency, trades it to a different currency\n * and lends on Notional in that currency. It will be paired with another vault\n * that lends and borrows in the opposite direction.\n */\ncontract CrossCurrencyfCashVault is BaseStrategyVault {\n    using TypeConvert for uint256;\n    using TypeConvert for int256;\n\n    uint256 public constant SETTLEMENT_SLIPPAGE_PRECISION = 1e18;\n\n    struct DepositParams {\n        // Minimum purchase amount of the lend underlying token, this is\n        // based on the deposit + borrowed amount and must be set to a non-zero\n        // value to establish a slippage limit.\n        uint256 minPurchaseAmount;\n        // Minimum annualized lending rate, can be set to zero for no slippage limit\n        uint32 minLendRate;\n        // ID of the desired DEX to trade on, _depositFromNotional will always trade\n        // using an EXACT_IN_SINGLE trade which is supported by all DEXes\n        uint16 dexId;\n        // Exchange data depending on the selected dexId\n        bytes exchangeData;\n    }\n\n    struct RedeemParams {\n        // Minimum purchase amount of the borrow underlying token, this is\n        // based on the amount of lend underlying received and must be set to a non-zero\n        // value to establish a slippage limit.\n        uint256 minPurchaseAmount;\n        // Maximum annualized borrow rate, can be set to zero for no slippage limit\n        uint32 maxBorrowRate;\n        // ID of the desired DEX to trade on, _depositFromNotional will always trade\n        // using an EXACT_IN_SINGLE trade which is supported by all DEXes\n        uint16 dexId;\n        // Exchange data depending on the selected dexId\n        bytes exchangeData;\n    }\n\n    uint16 public LEND_CURRENCY_ID;\n    IERC20 public LEND_UNDERLYING_TOKEN;\n    /// @notice a maximum slippage limit in 1e18 precision, uint64 is sufficient to hold the maximum value which\n    /// is 1e18\n    uint64 public settlementSlippageLimit;\n    // NOTE: 2 bytes left in first storage slot here\n\n    constructor(NotionalProxy notional_, ITradingModule tradingModule_)\n        BaseStrategyVault(notional_, tradingModule_) {}\n\n    function strategy() external override view returns (bytes4) {\n        return bytes4(keccak256(\"CrossCurrencyfCash\"));\n    }\n    function initialize(\n        string memory name_,\n        uint16 borrowCurrencyId_,\n        uint16 lendCurrencyId_,\n        uint64 settlementSlippageLimit_\n    ) external initializer {\n        __INIT_VAULT(name_, borrowCurrencyId_);\n\n        LEND_CURRENCY_ID = lendCurrencyId_;\n        (\n            Token memory assetToken,\n            Token memory underlyingToken,\n            /* ETHRate memory ethRate */,\n            /* AssetRateParameters memory assetRate */\n        ) = NOTIONAL.getCurrencyAndRates(lendCurrencyId_);\n\n        IERC20 tokenAddress = assetToken.tokenType == TokenType.NonMintable ?\n            IERC20(assetToken.tokenAddress) : IERC20(underlyingToken.tokenAddress);\n        LEND_UNDERLYING_TOKEN = tokenAddress;\n\n        // Allow Notional to pull the lend underlying currency\n        tokenAddress.approve(address(NOTIONAL), type(uint256).max);\n\n        // This value cannot be greater than 1e18\n        require(settlementSlippageLimit_ < SETTLEMENT_SLIPPAGE_PRECISION);\n        settlementSlippageLimit = settlementSlippageLimit_;\n    }\n\n    function updateSettlementSlippageLimit(uint64 newSlippageLimit) external {\n        require(msg.sender == NOTIONAL.owner());\n        require(newSlippageLimit < SETTLEMENT_SLIPPAGE_PRECISION);\n        settlementSlippageLimit = newSlippageLimit;\n    }\n\n    /**\n     * @notice During settlement all of the fCash balance in the lend currency will be redeemed to the\n     * underlying token and traded back to the borrow currency. All of the borrow currency will be deposited\n     * into the Notional contract as asset tokens and held for accounts to withdraw. Settlement can only\n     * be called after maturity.\n     * @param maturity the maturity to settle\n     * @param settlementTrade details for the settlement trade\n     */\n    function settleVault(uint256 maturity, uint256 strategyTokens, bytes calldata settlementTrade) external {\n        require(maturity <= block.timestamp, \"Cannot Settle\");\n        VaultState memory vaultState = NOTIONAL.getVaultState(address(this), maturity);\n        require(vaultState.isSettled == false);\n        require(vaultState.totalStrategyTokens >= strategyTokens);\n\n        RedeemParams memory params = abi.decode(settlementTrade, (RedeemParams));\n    \n        // The only way for underlying value to be negative would be if the vault has somehow ended up with a borrowing\n        // position in the lend underlying currency. This is explicitly prevented during redemption.\n        uint256 underlyingValue = convertStrategyToUnderlying(\n            address(0), vaultState.totalStrategyTokens, maturity\n        ).toUint();\n\n        // Authenticate the minimum purchase amount, all tokens will be sold given this slippage limit.\n        uint256 minAllowedPurchaseAmount = (underlyingValue * settlementSlippageLimit) / SETTLEMENT_SLIPPAGE_PRECISION;\n        require(params.minPurchaseAmount >= minAllowedPurchaseAmount, \"Purchase Limit\");\n\n        NOTIONAL.redeemStrategyTokensToCash(maturity, strategyTokens, settlementTrade);\n\n        // If there are no more strategy tokens left, then mark the vault as settled\n        vaultState = NOTIONAL.getVaultState(address(this), maturity);\n        if (vaultState.totalStrategyTokens == 0) {\n            NOTIONAL.settleVault(address(this), maturity);\n        }\n    }\n\n    /**\n     * @notice Converts the amount of fCash the vault holds into underlying denomination for the\n     * borrow currency.\n     * @param strategyTokens each strategy token is equivalent to 1 unit of fCash\n     * @param maturity the maturity of the fCash\n     * @return underlyingValue the value of the lent fCash in terms of the borrowed currency\n     */\n    function convertStrategyToUnderlying(\n        address /* account */,\n        uint256 strategyTokens,\n        uint256 maturity\n    ) public override view returns (int256 underlyingValue) {\n        int256 pvInternal;\n        if (maturity <= block.timestamp) {\n            // After maturity, strategy tokens no longer have a present value\n            pvInternal = strategyTokens.toInt();\n        } else {\n            // This is the non-risk adjusted oracle price for fCash, present value is used in case\n            // liquidation is required. The liquidator may need to exit the fCash position in order\n            // to repay a flash loan.\n            pvInternal = NOTIONAL.getPresentfCashValue(\n                LEND_CURRENCY_ID, maturity, strategyTokens.toInt(), block.timestamp, false\n            );\n        }\n\n        IERC20 underlyingToken = _underlyingToken();\n        (int256 rate, int256 rateDecimals) = TRADING_MODULE.getOraclePrice(\n            address(LEND_UNDERLYING_TOKEN), address(underlyingToken)\n        );\n        int256 borrowTokenDecimals = int256(10**underlyingToken.decimals());\n\n        // Convert this back to the borrow currency, external precision\n        // (pv (8 decimals) * borrowTokenDecimals * rate) / (rateDecimals * 8 decimals)\n        return (pvInternal * borrowTokenDecimals * rate) /\n            (rateDecimals * int256(Constants.INTERNAL_TOKEN_PRECISION));\n    }\n\n    /**\n     * @notice Will receive a deposit from Notional in underlying tokens of the borrowed currency.\n     * Needs to first trade that deposit into the lend currency and then lend it to fCash on the\n     * corresponding maturity.\n     * @param depositUnderlyingExternal amount of tokens deposited in the borrow currency\n     * @param maturity the maturity that was borrowed at, will also be the maturity that is lent to\n     * @param data DepositParams\n     * @return lendfCashMinted the amount of strategy tokens (fCash lent) generated\n     */\n    function _depositFromNotional(\n        address /* account */,\n        uint256 depositUnderlyingExternal,\n        uint256 maturity,\n        bytes calldata data\n    ) internal override returns (uint256 lendfCashMinted) {\n        DepositParams memory params = abi.decode(data, (DepositParams));\n        Trade memory trade = Trade({\n            tradeType: TradeType.EXACT_IN_SINGLE,\n            sellToken: address(_underlyingToken()),\n            buyToken: address(LEND_UNDERLYING_TOKEN),\n            amount: depositUnderlyingExternal,\n            limit: params.minPurchaseAmount,\n            deadline: block.timestamp,\n            exchangeData: params.exchangeData\n        });\n\n        (/* */, uint256 lendUnderlyingTokens) = _executeTrade(params.dexId, trade);\n\n        // Now we lend the underlying amount\n        (uint256 fCashAmount, /* */, bytes32 encodedTrade) = NOTIONAL.getfCashLendFromDeposit(\n            LEND_CURRENCY_ID,\n            lendUnderlyingTokens,\n            maturity,\n            params.minLendRate,\n            block.timestamp,\n            true // useUnderlying is true\n        );\n\n        BatchLend[] memory action = new BatchLend[](1);\n        action[0].currencyId = LEND_CURRENCY_ID;\n        action[0].depositUnderlying = true;\n        action[0].trades = new bytes32[](1);\n        action[0].trades[0] = encodedTrade;\n        NOTIONAL.batchLend(address(this), action);\n\n        // fCash is the strategy token in this case, batchLend will always mint exactly fCashAmount\n        return fCashAmount;\n    }\n\n    /**\n     * @notice Withdraws lent fCash from Notional (by selling it prior to maturity or withdrawing post maturity),\n     * and trades it all back to the borrowed currency.\n     * @param account the account that is doing the redemption\n     * @param strategyTokens the amount of fCash to redeem\n     * @param maturity the maturity of the fCash\n     * @param data RedeemParams\n     * @return borrowedCurrencyAmount the amount of borrowed currency raised by the redemption\n     */\n    function _redeemFromNotional(\n        address account,\n        uint256 strategyTokens,\n        uint256 maturity,\n        bytes calldata data\n    ) internal override returns (uint256 borrowedCurrencyAmount) {\n        uint256 balanceBefore = LEND_UNDERLYING_TOKEN.balanceOf(address(this));\n        RedeemParams memory params = abi.decode(data, (RedeemParams));\n\n        if (maturity <= block.timestamp) {\n            // Only allow the vault to redeem past maturity to settle all positions\n            require(account == address(this));\n            NOTIONAL.settleAccount(address(this));\n            (int256 cashBalance, /* */, /* */) = NOTIONAL.getAccountBalance(LEND_CURRENCY_ID, address(this));\n\n            // It should never be possible that this contract has a negative cash balance\n            require(0 <= cashBalance && cashBalance <= int256(uint256(type(uint88).max)));\n\n            // Withdraws all cash to underlying\n            NOTIONAL.withdraw(LEND_CURRENCY_ID, uint88(uint256(cashBalance)), true);\n        } else {\n            // Sells fCash on Notional AMM (via borrowing)\n            BalanceActionWithTrades[] memory action = _encodeBorrowTrade(\n                maturity,\n                strategyTokens,\n                params.maxBorrowRate\n            );\n            NOTIONAL.batchBalanceAndTradeAction(address(this), action);\n\n            // Check that we have not somehow borrowed into a negative fCash position, vault borrows\n            // are not included in account context\n            AccountContext memory accountContext = NOTIONAL.getAccountContext(address(this));\n            require(accountContext.hasDebt == 0x00);\n        }\n\n        uint256 balanceAfter = LEND_UNDERLYING_TOKEN.balanceOf(address(this));\n        \n        // Trade back to borrow currency for repayment\n        Trade memory trade = Trade({\n            tradeType: TradeType.EXACT_IN_SINGLE,\n            sellToken: address(LEND_UNDERLYING_TOKEN),\n            buyToken: address(_underlyingToken()),\n            amount: balanceAfter - balanceBefore,\n            limit: params.minPurchaseAmount,\n            deadline: block.timestamp,\n            exchangeData: params.exchangeData\n        });\n\n        (/* */, borrowedCurrencyAmount) = _executeTrade(params.dexId, trade);\n    }\n\n    function _encodeBorrowTrade(\n        uint256 maturity,\n        uint256 fCashAmount,\n        uint32 maxImpliedRate\n    ) private view returns (BalanceActionWithTrades[] memory action) {\n        (uint256 marketIndex, bool isIdiosyncratic) = DateTime.getMarketIndex(\n            Constants.MAX_TRADED_MARKET_INDEX,\n            maturity,\n            block.timestamp\n        );\n        require(!isIdiosyncratic);\n        require(fCashAmount <= uint256(type(uint88).max));\n\n        action = new BalanceActionWithTrades[](1);\n        action[0].actionType = DepositActionType.None;\n        action[0].currencyId = LEND_CURRENCY_ID;\n        action[0].withdrawEntireCashBalance = true;\n        action[0].redeemToUnderlying = true;\n        action[0].trades = new bytes32[](1);\n        action[0].trades[0] = bytes32(\n            (uint256(uint8(TradeActionType.Borrow)) << 248) |\n            (uint256(marketIndex) << 240) |\n            (uint256(fCashAmount) << 152) |\n            (uint256(maxImpliedRate) << 120)\n        );\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/CrossCurrencyfCashVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {IWrappedfCashFactory} from \"../../interfaces/notional/IWrappedfCashFactory.sol\";\nimport {WETH9} from \"../../interfaces/WETH9.sol\";\nimport {IWrappedfCashComplete as IWrappedfCash} from \"../../interfaces/notional/IWrappedfCash.sol\";\nimport {BaseStrategyVault} from \"./BaseStrategyVault.sol\";\nimport {IERC20} from \"../utils/TokenUtils.sol\";\nimport {\n    AccountContext,\n    BalanceActionWithTrades,\n    DepositActionType,\n    TradeActionType,\n    BatchLend,\n    Token,\n    TokenType,\n    VaultState\n} from \"../global/Types.sol\";\nimport {Constants} from \"../global/Constants.sol\";\nimport {DateTime} from \"../global/DateTime.sol\";\nimport {TypeConvert} from \"../global/TypeConvert.sol\";\nimport {ITradingModule, DexId, TradeType, Trade} from \"../../interfaces/trading/ITradingModule.sol\";\nimport {TradeHandler} from \"../trading/TradeHandler.sol\";\n\n/**\n * @notice This vault borrows in one currency, trades it to a different currency\n * and lends on Notional in that currency. It will be paired with another vault\n * that lends and borrows in the opposite direction.\n */\ncontract CrossCurrencyfCashVault is BaseStrategyVault {\n    using TypeConvert for uint256;\n    using TypeConvert for int256;\n\n    uint256 public constant SETTLEMENT_SLIPPAGE_PRECISION = 1e18;\n\n    struct DepositParams {\n        // Minimum purchase amount of the lend underlying token, this is\n        // based on the deposit + borrowed amount and must be set to a non-zero\n        // value to establish a slippage limit.\n        uint256 minPurchaseAmount;\n        // Minimum annualized lending rate, can be set to zero for no slippage limit\n        uint32 minLendRate;\n        // ID of the desired DEX to trade on, _depositFromNotional will always trade\n        // using an EXACT_IN_SINGLE trade which is supported by all DEXes\n        uint16 dexId;\n        // Exchange data depending on the selected dexId\n        bytes exchangeData;\n    }\n\n    struct RedeemParams {\n        // Minimum purchase amount of the borrow underlying token, this is\n        // based on the amount of lend underlying received and must be set to a non-zero\n        // value to establish a slippage limit.\n        uint256 minPurchaseAmount;\n        // Maximum annualized borrow rate, can be set to zero for no slippage limit\n        uint32 maxBorrowRate;\n        // ID of the desired DEX to trade on, _depositFromNotional will always trade\n        // using an EXACT_IN_SINGLE trade which is supported by all DEXes\n        uint16 dexId;\n        // Exchange data depending on the selected dexId\n        bytes exchangeData;\n    }\n\n    uint16 public LEND_CURRENCY_ID;\n    IERC20 public LEND_UNDERLYING_TOKEN;\n    /// @notice a maximum slippage limit in 1e18 precision, uint64 is sufficient to hold the maximum value which\n    /// is 1e18\n    uint64 public settlementSlippageLimit;\n    // NOTE: 2 bytes left in first storage slot here\n\n    constructor(NotionalProxy notional_, ITradingModule tradingModule_)\n        BaseStrategyVault(notional_, tradingModule_) {}\n\n    function strategy() external override view returns (bytes4) {\n        return bytes4(keccak256(\"CrossCurrencyfCash\"));\n    }\n    function initialize(\n        string memory name_,\n        uint16 borrowCurrencyId_,\n        uint16 lendCurrencyId_,\n        uint64 settlementSlippageLimit_\n    ) external initializer {\n        __INIT_VAULT(name_, borrowCurrencyId_);\n\n        LEND_CURRENCY_ID = lendCurrencyId_;\n        (\n            Token memory assetToken,\n            Token memory underlyingToken,\n            /* ETHRate memory ethRate */,\n            /* AssetRateParameters memory assetRate */\n        ) = NOTIONAL.getCurrencyAndRates(lendCurrencyId_);\n\n        IERC20 tokenAddress = assetToken.tokenType == TokenType.NonMintable ?\n            IERC20(assetToken.tokenAddress) : IERC"
    }
  ]
}