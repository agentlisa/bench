{
  "Title": "[M-22] Potential Gas Manipulation via Bytecode Compression",
  "Content": "\nMalicious operators could exploit this issue to overcharge users by artificially increasing the length of the dictionary without any benefit to the encoding process. As a result, users may end up paying higher gas costs for message publication in L1, leading to an adverse financial impact. This issue undermines the intended efficiency and cost-effectiveness of the compression mechanism.\n\n### Proof of Concept\n\nWhen processing L2 transactions, it is essential to mark the user's provided `factoryDeps` on L2 and subsequently publish them to L1.\n\n`bootloader::processL2Tx >> bootloader::l2TxExecution >> bootloader::ZKSYNC_NEAR_CALL_markFactoryDepsL2 >> bootloader::sendCompressedBytecode >> Compressor::publishCompressedBytecode` \n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/contracts/Compressor.sol#L54>\n\nThis process involves compression to reduce gas consumption during publishing to L1. The sequence of actions are as follows:\n\n1. The remaining gas allocated by the user is utilized to initiate the publication of `factoryDeps`.\n\n    <https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/bootloader/bootloader.yul#L1242>\n\n2. Compressed data is sent to L1.\n\n    <https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/contracts/Compressor.sol#L79>\n\n3. Gas consumption is determined by the length of the transmitted message.\n\n    <https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/contracts/L1Messenger.sol#L153>\n\nHowever, this process could be exploited by a malicious operator to overcharge users. Through manipulation of the compression method, the operator could inflate gas costs. In this context, not only may the compressed bytecode fail to be shorter than the original, but it could even become longer.\n\nTo illustrate, consider an example where the bytecode to be compressed and published is `ABCB` (with each character representing 8 bytes). Notably, the second and fourth 8-byte segments are identical.\n\nIn an ideal compression scenario, the `_rawCompressedData` would appear as: `0x0003ABC0000000100020001`. Here, `ABC` forms the `dictionary`, and `encodedData` is `0x0000000100020001`. The prefix `0x0003` indicates the dictionary's length in 8-byte segments, while the `encodedData` references the dictionary's segments in this order: `0, 1, 2, 1`, which corresponds to `A, B, C, and B`, respectively.\n\nHowever, a malicious operator, could artificially extend the dictionary length. They might modify `_rawCompressedData` to be: `0x0004ABCX0000000100020001`. In this scenario, `ABCX` constitutes the `dictionary`, while `encodedData` remains `0x0000000100020001`. This essentially introduces an extra 8-byte `X` to the dictionary, which serves no functional purpose, just increases the dictionary length. The `encodedData` still references the same segments, `0, 1, 2, 1`, without employing the added `X`.\n\nIn summary, this manipulation increases the dictionary's length by appending an unnecessary chunk, while not functional, this lengthening of the dictionary results in higher charges for users. Importantly, the dictionary remains valid, as it remains possible to decode the original bytecode from `_rawCompressedData` using the `encodedData`.\n\n### Recommended Mitigation Steps\n\nThe function `publishCompressedBytecode` should be revised as follows, where an array named `usedDictionaryIndex` is introduced to monitor the utilization of dictionary chunks. Subsequently, it validates whether all chunks in the dictionary have been utilized.\n\n```solidity\nfunction publishCompressedBytecode(\n        bytes calldata _bytecode,\n        bytes calldata _rawCompressedData\n    ) external payable onlyCallFromBootloader returns (bytes32 bytecodeHash) {\n        unchecked {\n            (bytes calldata dictionary, bytes calldata encodedData) = _decodeRawBytecode(_rawCompressedData);\n\n            require(dictionary.length % 8 == 0, \"Dictionary length should be a multiple of 8\");\n            require(dictionary.length <= 2 ** 16 * 8, \"Dictionary is too big\");\n            require(\n                encodedData.length * 4 == _bytecode.length,\n                \"Encoded data length should be 4 times shorter than the original bytecode\"\n            );\n\n            // This code is added\n            bool[] memory usedDictionaryIndex = new bool[](\n                dictionary.length / 8\n            );\n            //////////////////////\n\n            for (uint256 encodedDataPointer = 0; encodedDataPointer < encodedData.length; encodedDataPointer += 2) {\n                uint256 indexOfEncodedChunk = uint256(encodedData.readUint16(encodedDataPointer)) * 8;\n                require(indexOfEncodedChunk < dictionary.length, \"Encoded chunk index is out of bounds\");\n\n                // This code is added\n                usedDictionaryIndex[indexOfEncodedChunk] = true;\n                //////////////////////\n\n                uint64 encodedChunk = dictionary.readUint64(indexOfEncodedChunk);\n                uint64 realChunk = _bytecode.readUint64(encodedDataPointer * 4);\n\n                require(encodedChunk == realChunk, \"Encoded chunk does not match the original bytecode\");\n            }\n\n            // This code is added\n            for (uint256 i = 0; i < usedDictionaryIndex.length; ++i) {\n                require(\n                    usedDictionaryIndex[i],\n                    \"the dictionary includes chunks that are useless\"\n                );\n            }\n            //////////////////////\n        }\n\n        bytecodeHash = Utils.hashL2Bytecode(_bytecode);\n        L1_MESSENGER_CONTRACT.sendToL1(_rawCompressedData);\n        KNOWN_CODE_STORAGE_CONTRACT.markBytecodeAsPublished(bytecodeHash);\n    }\n```\n\n### Assessed type\n\nContext\n\n**[miladpiri (zkSync) confirmed and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/71#issuecomment-1794747554):**\n > Valid report. This report is about providing useless long compressed data leading to consume userâ€™s gas more (if it consumes much gas, nothing is left for the execution, so it will fail).\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/71#issuecomment-1829778364):**\n > The Warden has shown a way for the Operator to burn excess gas as a strategy to maximize profits, since this directly conflicts with the refund system. Medium seems appropriate.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/system-contracts/contracts/Compressor.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {ICompressor, OPERATION_BITMASK, LENGTH_BITS_OFFSET, MAX_ENUMERATION_INDEX_SIZE} from \"./interfaces/ICompressor.sol\";\nimport {ISystemContract} from \"./interfaces/ISystemContract.sol\";\nimport {Utils} from \"./libraries/Utils.sol\";\nimport {UnsafeBytesCalldata} from \"./libraries/UnsafeBytesCalldata.sol\";\nimport {EfficientCall} from \"./libraries/EfficientCall.sol\";\nimport {\n    L1_MESSENGER_CONTRACT,\n    INITIAL_WRITE_STARTING_POSITION,\n    COMPRESSED_INITIAL_WRITE_SIZE,\n    STATE_DIFF_ENTRY_SIZE,\n    STATE_DIFF_ENUM_INDEX_OFFSET,\n    STATE_DIFF_FINAL_VALUE_OFFSET,\n    STATE_DIFF_DERIVED_KEY_OFFSET,\n    DERIVED_KEY_LENGTH,\n    VALUE_LENGTH,\n    ENUM_INDEX_LENGTH,\n    KNOWN_CODE_STORAGE_CONTRACT\n} from \"./Constants.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice Contract with code pertaining to compression for zkEVM; at the moment this is used for bytecode compression\n * and state diff compression validation.\n * @dev Every deployed bytecode/published state diffs in zkEVM should be publicly restorable from the L1 data availability.\n * For this reason, the user may request the sequencer to publish the original bytecode and mark it as known.\n * Or the user may compress the bytecode and publish it instead (fewer data onchain!). At the end of every L1 Batch\n * we publish pubdata, part of which contains the state diffs that occurred within the batch.\n */\ncontract Compressor is ICompressor, ISystemContract {\n    using UnsafeBytesCalldata for bytes;\n\n    /// @notice Verify the compressed bytecode and publish it on the L1.\n    /// @param _bytecode The original bytecode to be verified against.\n    /// @param _rawCompressedData The compressed bytecode in a format of:\n    ///    - 2 bytes: the length of the dictionary\n    ///    - N bytes: the dictionary\n    ///    - M bytes: the encoded data\n    /// @dev The dictionary is a sequence of 8-byte chunks, each of them has the associated index.\n    /// @dev The encoded data is a sequence of 2-byte chunks, each of them is an index of the dictionary.\n    /// @dev The compression algorithm works as follows:\n    ///     1. The original bytecode is split into 8-byte chunks.\n    ///     Since the bytecode size is always a multiple of 32, this is always possible.\n    ///     2. For each 8-byte chunk in the original bytecode:\n    ///         * If the chunk is not already in the dictionary, it is added to the dictionary array.\n    ///         * If the dictionary becomes overcrowded (2^16 + 1 elements), the compression process will fail.\n    ///         * The 2-byte index of the chunk in the dictionary is added to the encoded data.\n    /// @dev Currently, the method may be called only from the bootloader because the server is not ready to publish bytecodes\n    /// in internal transactions. However, in the future, we will allow everyone to publish compressed bytecodes.\n    function publishCompressedBytecode(\n        bytes calldata _bytecode,\n        bytes calldata _rawCompressedData\n    ) external payable onlyCallFromBootloader returns (bytes32 bytecodeHash) {\n        unchecked {\n            (bytes calldata dictionary, bytes calldata encodedData) = _decodeRawBytecode(_rawCompressedData);\n\n            require(dictionary.length % 8 == 0, \"Dictionary length should be a multiple of 8\");\n            require(dictionary.length <= 2 ** 16 * 8, \"Dictionary is too big\");\n            require(\n                encodedData.length * 4 == _bytecode.length,\n                \"Encoded data length should be 4 times shorter than the original bytecode\"\n            );\n\n            for (uint256 encodedDataPointer = 0; encodedDataPointer < encodedData.length; encodedDataPointer += 2) {\n                uint256 indexOfEncodedChunk = uint256(encodedData.readUint16(encodedDataPointer)) * 8;\n                require(indexOfEncodedChunk < dictionary.length, \"Encoded chunk index is out of bounds\");\n\n                uint64 encodedChunk = dictionary.readUint64(indexOfEncodedChunk);\n                uint64 realChunk = _bytecode.readUint64(encodedDataPointer * 4);\n\n                require(encodedChunk == realChunk, \"Encoded chunk does not match the original bytecode\");\n            }\n        }\n\n        bytecodeHash = Utils.hashL2Bytecode(_bytecode);\n        L1_MESSENGER_CONTRACT.sendToL1(_rawCompressedData);\n        KNOWN_CODE_STORAGE_CONTRACT.markBytecodeAsPublished(bytecodeHash);\n    }\n\n    /// @notice Verifies that the compression of state diffs has been done correctly for the {_stateDiffs} param.\n    /// @param _numberOfStateDiffs The number of state diffs being checked.\n    /// @param _enumerationIndexSize Number of bytes used to represent an enumeration index for repeated writes.\n    /// @param _stateDiffs Encoded full state diff structs. See the first dev comment below for encoding.\n    /// @param _compressedStateDiffs The compressed state diffs\n    /// @dev We don't verify that the size of {_stateDiffs} is equivalent to {_numberOfStateDiffs} * STATE_DIFF_ENTRY_SIZE since that check is\n    ///      done within the L1Messenger calling contract.\n    /// @return stateDiffHash Hash of the encoded (uncompressed) state diffs to be committed to via system log.\n    /// @dev This check assumes that the ordering of state diffs are sorted by (address, key) for the encoded state diffs and\n    ///      then the compressed are sorted the same but with all the initial writes coming before the repeated writes.\n    /// @dev state diff:   [20bytes address][32bytes key][32bytes derived key][8bytes enum index][32bytes initial value][32bytes final value]\n    /// @dev The compression format:\n    ///     - 2 bytes: number of initial writes\n    ///     - N bytes initial writes\n    ///         - 32 bytes derived key\n    ///         - 1 byte metadata: \n    ///             - first 5 bits: length in bytes of compressed value\n    ///             - last 3 bits: operation\n    ///                 - 0 -> Nothing (32 bytes)\n    ///                 - 1 -> Add\n    ///                 - 2 -> Subtract\n    ///                 - 3 -> Transform (< 32 bytes)\n    ///         - Len Bytes: Compressed Value\n    ///     - M bytes repeated writes\n    ///         - {_enumerationIndexSize} bytes for enumeration index\n    ///         - 1 byte metadata: \n    ///             - first 5 bits: length in bytes of compressed value\n    ///             - last 3 bits: operation\n    ///                 - 0 -> Nothing (32 bytes)\n    ///                 - 1 -> Add\n    ///                 - 2 -> Subtract\n    ///                 - 3 -> Transform (< 32 bytes)\n    ///         - Len Bytes: Compressed Value\n    function verifyCompressedStateDiffs(\n        uint256 _numberOfStateDiffs,\n        uint256 _enumerationIndexSize,\n        bytes calldata _stateDiffs,\n        bytes calldata _compressedStateDiffs\n    ) external payable onlyCallFrom(address(L1_MESSENGER_CONTRACT)) returns (bytes32 stateDiffHash) {\n        // We do not enforce the operator to use the optimal, i.e. the minimally possible _enumerationIndexSize. \n        // We do enforce however, that the _enumerationIndexSize is not larger than 8 bytes long, which is the \n        // maximal ever possible size for enumeration index.\n        require(_enumerationIndexSize <= MAX_ENUMERATION_INDEX_SIZE, \"enumeration index size is too large\");\n\n        uint256 numberOfInitialWrites = uint256(_compressedStateDiffs.readUint16(0));\n\n        uint256 stateDiffPtr = 2;\n        uint256 numInitialWritesProcessed = 0;\n\n        // Process initial writes\n        for (uint256 i = 0; i < _numberOfStateDiffs * STATE_DIFF_ENTRY_SIZE; i += STATE_DIFF_ENTRY_SIZE) {\n            bytes calldata stateDiff = _stateDiffs[i:i + STATE_DIFF_ENTRY_SIZE];\n            uint64 enumIndex = stateDiff.readUint64(84);\n            if (enumIndex != 0) {\n                // It is a repeated write, so we skip it.\n                continue;\n            }\n\n            numInitialWritesProcessed++;\n\n            bytes32 derivedKey = stateDiff.readBytes32(52);\n            uint256 initValue = stateDiff.readUint256(92);\n            uint256 finalValue = stateDiff.readUint256(124);\n            require(derivedKey == _compressedStateDiffs.readBytes32(stateDiffPtr), \"iw: initial key mismatch\");            \n            stateDiffPtr += 32;\n\n            uint8 metadata = uint8(bytes1(_compressedStateDiffs[stateDiffPtr]));\n            stateDiffPtr++;\n            uint8 operation = metadata & OPERATION_BITMASK;\n            uint8 len = operation == 0 ? 32 : metadata >> LENGTH_BITS_OFFSET;\n            _verifyValueCompression(\n                initValue,\n                finalValue,\n                operation,\n                _compressedStateDiffs[stateDiffPtr:stateDiffPtr + len]\n            );\n            stateDiffPtr += len;\n        }\n\n        require(numInitialWritesProcessed == numberOfInitialWrites, \"Incorrect number of initial storage diffs\");\n\n        // Process repeated writes\n        for (uint256 i = 0; i < _numberOfStateDiffs * STATE_DIFF_ENTRY_SIZE; i += STATE_DIFF_ENTRY_SIZE) {\n            bytes calldata stateDiff = _stateDiffs[i:i + STATE_DIFF_ENTRY_SIZE];\n            uint64 enumIndex = stateDiff.readUint64(84);\n            if (enumIndex == 0) {\n                continue;\n            }\n\n            uint256 initValue = stateDiff.readUint256(92);\n            uint256 finalValue = stateDiff.readUint256(124);\n            uint256 compressedEnumIndex = _sliceToUint256(_compressedStateDiffs[stateDiffPtr:stateDiffPtr + _enumerationIndexSize]);\n            require(enumIndex == compressedEnumIndex, \"rw: enum key mismatch\");\n            stateDiffPtr += _enumerationIndexSize;\n\n            uint8 metadata = uint8(bytes1(_compressedStateDiffs[stateDiffPtr]));\n            stateDiffPtr += 1;\n            uint8 operation = metadata & OPERATION_BITMASK;\n            uint8 len = operation == 0 ? 32 : metadata >> LENGTH_BITS_OFFSET;\n            _verifyValueCompression(\n                initValue,\n                finalValue,\n                operation,\n                _compressedStateDiffs[stateDiffPtr:stateDiffPtr + len]\n            );\n            stateDiffPtr += len;\n        }\n\n        require(stateDiffPtr == _compressedStateDiffs.length, \"Extra data in _compressedStateDiffs\");\n\n        stateDiffHash = EfficientCall.keccak(_stateDiffs);\n    }\n\n    /// @notice Decode the raw compressed data into the dictionary and the encoded data.\n    /// @param _rawCompressedData The compressed bytecode in a format of:\n    ///    - 2 bytes: the bytes length of the dictionary\n    ///    - N bytes: the dictionary\n    ///    - M bytes: the encoded data\n    function _decodeRawBytecode(\n        bytes calldata _rawCompressedData\n    ) internal pure returns (bytes calldata dictionary, bytes calldata encodedData) {\n        unchecked {\n            // The dictionary length can't be more than 2^16, so it fits into 2 bytes.\n            uint256 dictionaryLen = uint256(_rawCompressedData.readUint16(0));\n            dictionary = _rawCompressedData[2:2 + dictionaryLen * 8];\n            encodedData = _rawCompressedData[2 + dictionaryLen * 8:];\n        }\n    }\n\n    /// @notice Verify value compression was done correct given initial value, final value, operation, and compressed value\n    /// @param _initialValue Previous value of key/enumeration index.\n    /// @param _finalValue Updated value of key/enumeration index.\n    /// @param _operation The operation that was performed on value.\n    /// @param _compressedValue The slice of calldata with compressed value either representing the final \n    /// value or difference between initial and final value. It should be of arbitrary length less than or equal to 32 bytes.\n    /// @dev It is the responsibility of the caller of this function to ensure that the `_compressedValue` has length no longer than 32 bytes.\n    /// @dev Operation id mapping:\n    /// 0 -> Nothing (32 bytes)\n    /// 1 -> Add\n    /// 2 -> Subtract\n    /// 3 -> Transform (< 32 bytes)\n    function _verifyValueCompression(\n        uint256 _initialValue,\n        uint256 _finalValue,\n        uint256 _operation,\n        bytes calldata _compressedValue\n    ) internal pure {\n        uint256 convertedValue = _sliceToUint256(_compressedValue);\n\n        unchecked {\n            if (_operation == 0 || _operation == 3) {\n                require(convertedValue == _finalValue, \"transform or no compression: compressed and final mismatch\");\n            } else if (_operation == 1) {\n                require(_initialValue + convertedValue == _finalValue, \"add: initial plus converted not equal to final\");\n            } else if (_operation == 2) {\n                require(_initialValue - convertedValue == _finalValue, \"sub: initial minus converted not equal to final\");\n            } else {\n                revert(\"unsupported operation\");\n            }\n        }\n    }\n\n    /// @notice Converts a calldata slice into uint256. It is the responsibility of the caller to ensure that\n    /// the _calldataSlice has length no longer than 32 bytes\n    /// @param _calldataSlice The calldata slice to convert to uint256\n    /// @return number The uint256 representation of the calldata slice\n    function _sliceToUint256(bytes calldata _calldataSlice) internal pure returns (uint256 number) {\n        number = uint256(bytes32(_calldataSlice));\n        number >>= (256 - (_calldataSlice.length * 8));\n    }\n}"
    },
    {
      "filename": "code/system-contracts/bootloader/bootloader.yul",
      "content": "object \"Bootloader\" {\n    code {\n    }\n    object \"Bootloader_deployed\" {\n        code {\n            ////////////////////////////////////////////////////////////////////////////\n            //                      Function Declarations\n            ////////////////////////////////////////////////////////////////////////////\n\n            // While we definitely cannot control the gas price on L1,\n            // we need to check the operator does not provide any absurd numbers there\n            function MAX_ALLOWED_L1_GAS_PRICE() -> ret {\n                // 100k gwei\n                ret := 100000000000000\n            }\n\n            function MAX_ALLOWED_FAIR_L2_GAS_PRICE() -> ret {\n                // 10k gwei\n                ret := 10000000000000\n            }\n\n            /// @dev This method ensures that the prices provided by the operator\n            /// are not absurdly high\n            function validateOperatorProvidedPrices(l1GasPrice, fairL2GasPrice) {\n                if gt(l1GasPrice, MAX_ALLOWED_L1_GAS_PRICE()) {\n                    assertionError(\"L1 gas price too high\")\n                }\n\n                if gt(fairL2GasPrice, MAX_ALLOWED_FAIR_L2_GAS_PRICE()) {\n                    assertionError(\"L2 fair gas price too high\")\n                }\n            }\n\n            /// @dev Returns the baseFee for this batch based on the\n            /// L1 gas price and the fair L2 gas price.\n            function getBaseFee(l1GasPrice, fairL2GasPrice) -> baseFee, gasPricePerPubdata {\n                // By default, we want to provide the fair L2 gas price.\n                // That it means that the operator controls\n                // what the value of the baseFee will be. In the future, \n                // a better system, aided by EIP1559 should be added. \n\n                let pubdataBytePriceETH := safeMul(l1GasPrice, L1_GAS_PER_PUBDATA_BYTE(), \"aoa\")\n\n                baseFee := max(\n                    fairL2GasPrice,\n                    ceilDiv(pubdataBytePriceETH, MAX_L2_GAS_PER_PUBDATA())\n                )\n                gasPricePerPubdata := ceilDiv(pubdataBytePriceETH, baseFee)\n            }\n\n            /// @dev It should be always possible to submit a transaction \n            /// that consumes such amount of public data.\n            function GUARANTEED_PUBDATA_PER_TX() -> ret {\n                ret := {{GUARANTEED_PUBDATA_BYTES}}\n            }\n\n            /// @dev The maximal gasPerPubdata, which allows users to still be \n            /// able to send `GUARANTEED_PUBDATA_PER_TX` onchain.\n            function MAX_L2_GAS_PER_PUBDATA() -> ret {\n                ret := div(MAX_GAS_PER_TRANSACTION(), GUARANTEED_PUBDATA_PER_TX())\n            }\n\n            /// @dev The computational overhead for a batch.\n            /// It includes the combined price for 1 instance of all the circuits \n            /// (since they might be partially filled), the price for running\n            /// the common parts of the bootloader as well as general maintainance of the system.\n            function BATCH_OVERHEAD_L2_GAS() -> ret {\n                ret := {{BATCH_OVERHEAD_L2_GAS}}\n            }\n\n            /// @dev The overhead for the interaction with L1.\n            /// It should cover proof verification as well as other minor \n            /// overheads for committing/executing a transaction in a batch.\n            function BATCH_OVERHEAD_L1_GAS() -> ret {\n                ret := {{BATCH_OVERHEAD_L1_GAS}}\n            }\n\n            /// @dev The maximal number of gas available to the transaction\n            function MAX_GAS_PER_TRANSACTION() -> ret {\n                ret := {{MAX_GAS_PER_TRANSACTION}}\n            }\n\n            /// @dev The number of L1 gas needed to be spent for\n            /// L1 byte. While a single pubdata byte costs `16` gas, \n            /// we demand at least 17 to cover up for the costs of additional\n            /// hashing of it, etc.\n            function L1_GAS_PER_PUBDATA_BYTE() -> ret {\n                ret := 17\n            }\n\n            /// @dev The size of the bootloader memory that is to spent by the transaction's\n            /// encodings.\n            function BOOTLOADER_MEMORY_FOR_TXS() -> ret {\n                ret := {{BOOTLOADER_MEMORY_FOR_TXS}}\n            }\n\n            /// @dev Whether the batch is allowed to accept transactions with\n            /// gasPerPubdataByteLimit = 0. On mainnet, this is forbidden for safety reasons.\n            function FORBID_ZERO_GAS_PER_PUBDATA() -> ret {\n                ret := {{FORBID_ZERO_GAS_PER_PUBDATA}}\n            }\n            \n            /// @dev The maximum number of transactions per L1 batch.\n            function MAX_TRANSACTIONS_IN_BATCH() -> ret {\n                ret := {{MAX_TRANSACTIONS_IN_BATCH}}\n            }\n\n            /// @dev The slot from which the scratch space starts.\n            /// Scatch space is used for various temporary values\n            function SCRATCH_SPACE_BEGIN_SLOT() -> ret {\n                ret := 8\n            }\n\n            /// @dev The byte from which the scratch space starts.\n            /// Scratch space is used for various temporary values\n            function SCRATCH_SPACE_BEGIN_BYTE() -> ret {\n                ret := mul(SCRATCH_SPACE_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The first 32 slots are reserved for event emitting for the \n            /// debugging purposes\n            function SCRATCH_SPACE_SLOTS() -> ret {\n                ret := 32\n            }\n\n            /// @dev Slots reserved for saving the paymaster context\n            /// @dev The paymasters are allowed to consume at most \n            /// 32 slots (1024 bytes) for their context.\n            /// The 33 slots are required since the first one stores the length of the calldata.\n            function PAYMASTER_CONTEXT_SLOTS() -> ret {\n                ret := 33\n            }\n        \n            /// @dev Bytes reserved for saving the paymaster context\n            function PAYMASTER_CONTEXT_BYTES() -> ret {\n                ret := mul(PAYMASTER_CONTEXT_SLOTS(), 32)\n            }\n\n            /// @dev Slot from which the paymaster context starts\n            function PAYMASTER_CONTEXT_BEGIN_SLOT() -> ret {\n                ret := add(SCRATCH_SPACE_BEGIN_SLOT(), SCRATCH_SPACE_SLOTS())\n            }\n\n            /// @dev The byte from which the paymaster context starts\n            function PAYMASTER_CONTEXT_BEGIN_BYTE() -> ret {\n                ret := mul(PAYMASTER_CONTEXT_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev Each tx must have at least this amount of unused bytes before them to be able to \n            /// encode the postOp operation correctly.\n            function MAX_POSTOP_SLOTS() -> ret {\n                // Before the actual transaction encoding, the postOp contains 6 slots:\n                // 1. Context offset\n                // 2. Transaction offset\n                // 3. Transaction hash\n                // 4. Suggested signed hash\n                // 5. Transaction result\n                // 6. Maximum refunded gas\n                // And one more slot for the padding selector\n                ret := add(PAYMASTER_CONTEXT_SLOTS(), 7)\n            }\n\n            /// @dev Slots needed to store the canonical and signed hash for the current L2 transaction.\n            function CURRENT_L2_TX_HASHES_RESERVED_SLOTS() -> ret {\n                ret := 2\n            }\n\n            /// @dev Slot from which storing of the current canonical and signed hashes begins\n            function CURRENT_L2_TX_HASHES_BEGIN_SLOT() -> ret {\n                ret := add(PAYMASTER_CONTEXT_BEGIN_SLOT(), PAYMASTER_CONTEXT_SLOTS())\n            }\n\n            /// @dev The byte from which storing of the current canonical and signed hashes begins\n            function CURRENT_L2_TX_HASHES_BEGIN_BYTE() -> ret {\n                ret := mul(CURRENT_L2_TX_HASHES_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The maximum number of new factory deps that are allowed in a transaction\n            function MAX_NEW_FACTORY_DEPS() -> ret {\n                ret := 32\n            }\n\n            /// @dev Besides the factory deps themselves, we also need another 4 slots for: \n            /// selector, marker of whether the user should pay for the pubdata,\n            /// the offset for the encoding of the array as well as the length of the array.\n            function NEW_FACTORY_DEPS_RESERVED_SLOTS() -> ret {\n                ret := add(MAX_NEW_FACTORY_DEPS(), 4)\n            }\n\n            /// @dev The slot starting from which the factory dependencies are stored\n            function NEW_FACTORY_DEPS_BEGIN_SLOT() -> ret {\n                ret := add(CURRENT_L2_TX_HASHES_BEGIN_SLOT(), CURRENT_L2_TX_HASHES_RESERVED_SLOTS())\n            }\n\n            /// @dev The byte starting from which the factory dependencies are stored\n            function NEW_FACTORY_DEPS_BEGIN_BYTE() -> ret {\n                ret := mul(NEW_FACTORY_DEPS_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The slot starting from which the refunds provided by the operator are stored\n            function TX_OPERATOR_REFUND_BEGIN_SLOT() -> ret {\n                ret := add(NEW_FACTORY_DEPS_BEGIN_SLOT(), NEW_FACTORY_DEPS_RESERVED_SLOTS())\n            }\n\n            /// @dev The byte starting from which the refunds provided by the operator are stored\n            function TX_OPERATOR_REFUND_BEGIN_BYTE() -> ret {\n                ret := mul(TX_OPERATOR_REFUND_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The number of slots dedicated for the refunds for the transactions.\n            /// It is equal to the number of transactions in the batch.\n            function TX_OPERATOR_REFUNDS_SLOTS() -> ret {\n                ret := MAX_TRANSACTIONS_IN_BATCH()\n            }\n\n            /// @dev The slot starting from which the overheads proposed by the operator will be stored\n            function TX_SUGGESTED_OVERHEAD_BEGIN_SLOT() -> ret {\n                ret := add(TX_OPERATOR_REFUND_BEGIN_SLOT(), TX_OPERATOR_REFUNDS_SLOTS())\n            }\n\n            /// @dev The byte starting from which the overheads proposed by the operator will be stored\n            function TX_SUGGESTED_OVERHEAD_BEGIN_BYTE() -> ret {\n                ret := mul(TX_SUGGESTED_OVERHEAD_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The number of slots dedicated for the overheads for the transactions.\n            /// It is equal to the number of transactions in the batch.\n            function TX_SUGGESTED_OVERHEAD_SLOTS() -> ret {\n                ret := MAX_TRANSACTIONS_IN_BATCH()\n            }\n\n            /// @dev The slot starting from which the maximum number of gas that the operator \"trusts\"\n            /// the transaction to use for its execution is stored. Sometimes, the operator may know that\n            /// a certain transaction can be allowed more gas that what the protocol-level worst-case allows.\n            function TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT() -> ret {\n                ret := add(TX_SUGGESTED_OVERHEAD_BEGIN_SLOT(), TX_SUGGESTED_OVERHEAD_SLOTS())\n            }\n\n            /// @dev byte starting from which the maximum number of gas that the operator \"trusts\"\n            /// the transaction to use for its execution is stored. \n            function TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_BYTE() -> ret {\n                ret := mul(TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The number of slots dedicated for the trusted gas limits for the transactions.\n            /// It is equal to the number of transactions in the batch.\n            function TX_OPERATOR_TRUSTED_GAS_LIMIT_SLOTS() -> ret {\n                ret := MAX_TRANSACTIONS_IN_BATCH()\n            }\n\n            /// @dev The slot starting from the L2 block information for transactions is stored.\n            function TX_OPERATOR_L2_BLOCK_INFO_BEGIN_SLOT() -> ret {\n                ret := add(TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT(), TX_OPERATOR_TRUSTED_GAS_LIMIT_SLOTS())\n            }\n\n            /// @dev The byte starting from which the L2 block information for transactions is stored.\n            function TX_OPERATOR_L2_BLOCK_INFO_BEGIN_BYTE() -> ret {\n                ret := mul(TX_OPERATOR_L2_BLOCK_INFO_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The size of each of the L2 block information. Each L2 block information contains four fields:\n            /// - number of the block\n            /// - timestamp of the block\n            /// - hash of the previous block\n            /// - the maximal number of virtual blocks to create\n            function TX_OPERATOR_L2_BLOCK_INFO_SLOT_SIZE() -> ret {\n                ret := 4\n            }\n\n            /// @dev The size of each of the L2 block information in bytes.\n            function TX_OPERATOR_L2_BLOCK_INFO_SIZE_BYTES() -> ret {\n                ret := mul(TX_OPERATOR_L2_BLOCK_INFO_SLOT_SIZE(), 32)\n            }\n\n            /// @dev The number of slots dedicated for the L2 block information for the transactions.\n            /// Note, that an additional slot is required for the fictive L2 block at the end of the batch. \n            /// For technical reasons inside the sequencer implementation, \n            /// each batch ends with a fictive block with no transactions.\n            function TX_OPERATOR_L2_BLOCK_INFO_SLOTS() -> ret {\n                ret := mul(add(MAX_TRANSACTIONS_IN_BATCH(), 1), TX_OPERATOR_L2_BLOCK_INFO_SLOT_SIZE())\n            }\n\n            /// @dev The slot starting from which the compressed bytecodes are located in the bootloader's memory.\n            /// Each compressed bytecode is provided in the following format:\n            /// - 32 byte formatted bytecode hash\n            /// - 32 byte of zero (it will be replaced within the code with left-padded selector of the `publishCompressedBytecode`).\n            /// - ABI-encoding of the parameters of the `publishCompressedBytecode` method. \n            /// \n            /// At the slot `TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT()` the pointer to the currently processed compressed bytecode\n            /// is stored, i.e. this pointer will be increased once the current bytecode which the pointer points to is published.\n            /// At the start of the bootloader, the value stored at the `TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT` is equal to \n            /// `TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT + 32`, where the hash of the first compressed bytecode to publish should be stored.\n            function COMPRESSED_BYTECODES_BEGIN_SLOT() -> ret {\n                ret := add(TX_OPERATOR_L2_BLOCK_INFO_BEGIN_SLOT(), TX_OPERATOR_L2_BLOCK_INFO_SLOTS())\n            }\n\n            /// @dev The byte starting from which the compressed bytecodes are located in the bootloader's memory.\n            function COMPRESSED_BYTECODES_BEGIN_BYTE() -> ret {\n                ret := mul(COMPRESSED_BYTECODES_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The number of slots dedicated to the compressed bytecodes.\n            function COMPRESSED_BYTECODES_SLOTS() -> ret {\n                ret := {{COMPRESSED_BYTECODES_SLOTS}}\n            }\n\n            /// @dev The slot right after the last slot of the compressed bytecodes memory area.\n            function COMPRESSED_BYTECODES_END_SLOT() -> ret {\n                ret := add(COMPRESSED_BYTECODES_BEGIN_SLOT(), COMPRESSED_BYTECODES_SLOTS())\n            }\n\n            /// @dev The first byte in memory right after the compressed bytecodes memory area.\n            function COMPRESSED_BYTECODES_END_BYTE() -> ret {\n                ret := mul(COMPRESSED_BYTECODES_END_SLOT(), 32)\n            }\n\n            /// @dev Slots needed to store priority txs L1 data (`chainedPriorityTxsHash` and `numberOfLayer1Txs`).\n            function PRIORITY_TXS_L1_DATA_RESERVED_SLOTS() -> ret {\n                ret := 2\n            }\n\n            /// @dev Slot from which storing of the priority txs L1 data begins.\n            function PRIORITY_TXS_L1_DATA_BEGIN_SLOT() -> ret {\n                ret := add(COMPRESSED_BYTECODES_BEGIN_SLOT(), COMPRESSED_BYTECODES_SLOTS())\n            }\n\n            /// @dev The byte from which storing of the priority txs L1 data begins.\n            function PRIORITY_TXS_L1_DATA_BEGIN_BYTE() -> ret {\n                ret := mul(PRIORITY_TXS_L1_DATA_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev Slot from which storing of the L1 Messenger pubdata begins.\n            function OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_BEGIN_SLOT() -> ret {\n                ret := add(PRIORITY_TXS_L1_DATA_BEGIN_SLOT(), PRIORITY_TXS_L1_DATA_RESERVED_SLOTS())\n            }\n\n            /// @dev The byte storing of the L1 Messenger pubdata begins.\n            function OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_BEGIN_BYTE() -> ret {\n                ret := mul(OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev Slots needed to store L1 Messenger pubdata.\n            /// @dev Note that are many more these than the maximal pubdata in batch, since \n            /// it needs to also accomodate uncompressed state diffs that are required for the state diff\n            /// compression verification.\n            function OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_SLOTS() -> ret {\n                ret := {{OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_SLOTS}}\n            }\n\n            /// @dev The slot right after the last slot of the L1 Messenger pubdata memory area.\n            function OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_END_SLOT() -> ret {\n                ret := add(OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_BEGIN_SLOT(), OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_SLOTS())\n            }\n\n            /// @dev The slot from which the bootloader transactions' descriptions begin\n            function TX_DESCRIPTION_BEGIN_SLOT() -> ret {\n                ret := OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_END_SLOT()\n            }\n\n            /// @dev The byte from which the bootloader transactions' descriptions begin\n            function TX_DESCRIPTION_BEGIN_BYTE() -> ret {\n                ret := mul(TX_DESCRIPTION_BEGIN_SLOT(), 32)\n            }\n\n            // Each tx description has the following structure\n            // \n            // struct BootloaderTxDescription {\n            //     uint256 txMeta;\n            //     uint256 txDataOffset;\n            // }\n            //\n            // `txMeta` contains flags to manipulate the transaction execution flow.\n            // For playground batches:\n            //      It can have the following information (0 byte is LSB and 31 byte is MSB):\n            //      0 byte: `execute`, bool. Denotes whether transaction should be executed by the bootloader.\n            //      31 byte: server-side tx execution mode\n            // For proved batches:\n            //      It can simply denotes whether to execute the transaction (0 to stop executing the batch, 1 to continue) \n            //\n            // Each such encoded struct consumes 2 words\n            function TX_DESCRIPTION_SIZE() -> ret {\n                ret := 64\n            }\n\n            /// @dev The byte right after the basic description of bootloader transactions\n            function TXS_IN_BATCH_LAST_PTR() -> ret {\n                ret := add(TX_DESCRIPTION_BEGIN_BYTE(), mul(MAX_TRANSACTIONS_IN_BA"
    }
  ]
}