{
  "Title": "M-2: Unsafe ERC20 methods",
  "Content": "# Issue M-2: Unsafe ERC20 methods \n\nSource: https://github.com/sherlock-audit/2022-11-telcoin-judging/issues/82 \n\n## Found by \n0x4non, 0xAgro, yixxas, 0xheynacho, Bnke0x0, WATCHPUG, aphak5010, rotcivegaf, Mukund, hickuphh3, pashov, hyh, Deivitto, rvierdiiev, eierina\n\n## Summary\n\nUsing unsafe ERC20 methods can revert the transaction for certain tokens.\n\n## Vulnerability Detail\n\nThere are many [Weird ERC20 Tokens](https://www.hacknote.co/17c261f7d8fWbdml/doc/182a568ab5cUOpDM) that won't work correctly using the standard `IERC20` interface.\n\nFor example, `IERC20(token).transferFrom()` and `IERC20(token).transfer()` will fail for some tokens as they may not conform to the standard IERC20 interface. And if `_aggregator` does not always consume all the allowance given at L72, the transaction will also revert on the next call, because there are certain tokens that do not allow approval of a non-zero number when the current allowance is not zero (eg, USDT).\n\n## Impact\n\nThe contract will malfunction for certain tokens.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-telcoin/blob/main/contracts/fee-buyback/FeeBuyback.sol#L94-L97\n\nhttps://github.com/sherlock-audit/2022-11-telcoin/blob/main/contracts/fee-buyback/FeeBuyback.sol#L47-L82\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider using `SafeERC20` for `transferFrom`, `transfer` and `approve`.\n\n## Discussion\n\n**amshirif**\n\nhttps://github.com/telcoin/telcoin-staking/pull/6\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/25",
  "Code": [
    {
      "filename": "contracts/fee-buyback/FeeBuyback.sol",
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity ^0.8.0;\n\n//imports\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./TieredOwnership.sol\";\nimport \"./IFeeBuyback.sol\";\nimport \"./ISimplePlugin.sol\";\n\n/**\n * @title FeeBuyback\n * @author Amir Shirif, Telcoin, LLC.\n * @notice Helps facilitate a secondary swap, if required, to allow the referrer of a user to receive a fraction of the generated transaction fee, based on the stake of the referrer.\n */\ncontract FeeBuyback is IFeeBuyback, TieredOwnership {\n  //MATIC address\n  address constant public MATIC = 0x0000000000000000000000000000000000001010;\n  //1 inch aggregator address\n  address immutable public _aggregator;\n  //location of fee rewards\n  address immutable public _safe;\n  //reward token\n  IERC20 immutable public _telcoin;\n  //destination of rewards\n  ISimplePlugin immutable public _referral;\n\n  //constructor\n  constructor(address aggregator_, address safe_, IERC20 telcoin_, ISimplePlugin referral_) TieredOwnership() {\n    _aggregator = aggregator_;\n    _safe = safe_;\n    _telcoin = telcoin_;\n    _referral = referral_;\n  }\n\n  /**\n   * @notice submits wallet transactions\n   * @dev a secondary swap may occur\n   * @dev staking contract updates may be made\n   * @dev function can be paused\n   * @param wallet address of the primary transaction\n   * @param walletData bytes wallet data for primary transaction\n   * @param token address the token that is being swapped from in a secondary transaction\n   * @param amount uint256 the quantity of the token being swapped\n   * @param swapData bytes swap data from primary transaction\n   * @return boolean representing if a referral transaction was made\n   */\n  function submit(address wallet, bytes memory walletData, address token, address recipient, uint256 amount, bytes memory swapData) external override payable onlyOwner() returns (bool) {\n    //Perform user swap first\n    //Verify success\n    (bool walletResult,) = wallet.call{value: 0}(walletData);\n    require(walletResult, \"FeeBuyback: wallet transaction failed\");\n\n    //check if this is a referral transaction\n    //if not exit execution\n    if (token == address(0) || recipient == address(0) || amount == 0 ) {\n      return false;\n    }\n\n    //if swapped token is in TEL, no swap is necessary\n    //do simple transfer from and submit\n    if (token == address(_telcoin)) {\n      _telcoin.transferFrom(_safe, address(this), amount);\n      _telcoin.approve(address(_referral), _telcoin.balanceOf(address(this)));\n      require(_referral.increaseClaimableBy(recipient, _telcoin.balanceOf(address(this))), \"FeeBuyback: balance was not adjusted\");\n      return true;\n    }\n\n    //MATIC does not allow for approvals\n    //ERC20s only\n    if (token != MATIC) {\n      IERC20(token).transferFrom(_safe, address(this), amount);\n      IERC20(token).approve(_aggregator, amount);\n    }\n\n    //Perform secondary swap from fee token to TEL\n    //do simple transfer from and submit\n    (bool swapResult,) = _aggregator.call{value: msg.value}(swapData);\n    require(swapResult, \"FeeBuyback: swap transaction failed\");\n    _telcoin.approve(address(_referral), _telcoin.balanceOf(address(this)));\n    require(_referral.increaseClaimableBy(recipient, _telcoin.balanceOf(address(this))), \"FeeBuyback: balance was not adjusted\");\n    return true;\n  }\n\n  /**\n  * @notice Sends ERC20 tokens trapped in contract to external address\n  * @dev Only an owner is allowed to make this function call\n  * @param account is the receiving address\n  * @param externalToken is the token being sent\n  * @param amount is the quantity being sent\n  * @return boolean value indicating whether the operation succeeded.\n  *\n  * Emits a {Transfer} event.\n  */\n  function rescueERC20(address account, address externalToken, uint256 amount) public onlyExecutor() returns (bool) {\n    IERC20(externalToken).transfer(account, amount);\n    return true;\n  }\n}"
    },
    {
      "filename": "contracts/fee-buyback/FeeBuyback.sol",
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity ^0.8.0;\n\n//imports\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./TieredOwnership.sol\";\nimport \"./IFeeBuyback.sol\";\nimport \"./ISimplePlugin.sol\";\n\n/**\n * @title FeeBuyback\n * @author Amir Shirif, Telcoin, LLC.\n * @notice Helps facilitate a secondary swap, if required, to allow the referrer of a user to receive a fraction of the generated transaction fee, based on the stake of the referrer.\n */\ncontract FeeBuyback is IFeeBuyback, TieredOwnership {\n  //MATIC address\n  address constant public MATIC = 0x0000000000000000000000000000000000001010;\n  //1 inch aggregator address\n  address immutable public _aggregator;\n  //location of fee rewards\n  address immutable public _safe;\n  //reward token\n  IERC20 immutable public _telcoin;\n  //destination of rewards\n  ISimplePlugin immutable public _referral;\n\n  //constructor\n  constructor(address aggregator_, address safe_, IERC20 telcoin_, ISimplePlugin referral_) TieredOwnership() {\n    _aggregator = aggregator_;\n    _safe = safe_;\n    _telcoin = telcoin_;\n    _referral = referral_;\n  }\n\n  /**\n   * @notice submits wallet transactions\n   * @dev a secondary swap may occur\n   * @dev staking contract updates may be made\n   * @dev function can be paused\n   * @param wallet address of the primary transaction\n   * @param walletData bytes wallet data for primary transaction\n   * @param token address the token that is being swapped from in a secondary transaction\n   * @param amount uint256 the quantity of the token being swapped\n   * @param swapData bytes swap data from primary transaction\n   * @return boolean representing if a referral transaction was made\n   */\n  function submit(address wallet, bytes memory walletData, address token, address recipient, uint256 amount, bytes memory swapData) external override payable onlyOwner() returns (bool) {\n    //Perform user swap first\n    //Verify success\n    (bool walletResult,) = wallet.call{value: 0}(walletData);\n    require(walletResult, \"FeeBuyback: wallet transaction failed\");\n\n    //check if this is a referral transaction\n    //if not exit execution\n    if (token == address(0) || recipient == address(0) || amount == 0 ) {\n      return false;\n    }\n\n    //if swapped token is in TEL, no swap is necessary\n    //do simple transfer from and submit\n    if (token == address(_telcoin)) {\n      _telcoin.transferFrom(_safe, address(this), amount);\n      _telcoin.approve(address(_referral), _telcoin.balanceOf(address(this)));\n      require(_referral.increaseClaimableBy(recipient, _telcoin.balanceOf(address(this))), \"FeeBuyback: balance was not adjusted\");\n      return true;\n    }\n\n    //MATIC does not allow for approvals\n    //ERC20s only\n    if (token != MATIC) {\n      IERC20(token).transferFrom(_safe, address(this), amount);\n      IERC20(token).approve(_aggregator, amount);\n    }\n\n    //Perform secondary swap from fee token to TEL\n    //do simple transfer from and submit\n    (bool swapResult,) = _aggregator.call{value: msg.value}(swapData);\n    require(swapResult, \"FeeBuyback: swap transaction failed\");\n    _telcoin.approve(address(_referral), _telcoin.balanceOf(address(this)));\n    require(_referral.increaseClaimableBy(recipient, _telcoin.balanceOf(address(this))), \"FeeBuyback: balance was not adjusted\");\n    return true;\n  }\n\n  /**\n  * @notice Sends ERC20 tokens trapped in contract to external address\n  * @dev Only an owner is allowed to make this function call\n  * @param account is the receiving address\n  * @param externalToken is the token being sent\n  * @param amount is the quantity being sent\n  * @return boolean value indicating whether the operation succeeded.\n  *\n  * Emits a {Transfer} event.\n  */\n  function rescueERC20(address account, address externalToken, uint256 amount) public onlyExecutor() returns (bool) {\n    IERC20(externalToken).transfer(account, amount);\n    return true;\n  }\n}"
    }
  ]
}