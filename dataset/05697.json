{
  "Title": "[10] `L1⇒L2` transactions are not free, but bootloader behaves like they are",
  "Content": "\nIn [Mailbox, function `requestL2Transaction`](https://github.com/code-423n4/2023-10-zksync/blob/c3ff020df5d11fe91209bd99d7fb0ec1272dc387/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L270C1-L270C19), the `isFree` parameter of the call to `_requestL2Transaction` is hard-coded to `false`:\n\n```solidity\n        canonicalTxHash = _requestL2Transaction(\n            sender,                        // from\n            _contractL2,                   // to\n            _l2Value,                      // bridged ETH\n            _calldata,                     // the usual calldata\n            _l2GasLimit,                   // the amount of gas user is willing to spend\n            _l2GasPerPubdataByteLimit,     // the amount of gas per pubdata the operator may charge\n            _factoryDeps,                  // bytecode to be marked as known on L2\n            false,                         // isFree\n            _refundRecipient               // who is gonna receive the excess of gas or the whole ETH if the tx fails\n        );\n```\n\nSo the calculation of the L2 gas price:\n\n[Mailbox, lines 303 to 307](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L303C1-L307C10)\n\n```solidity\n            params.l2GasPrice = _isFree ? 0 : _deriveL2GasPrice(tx.gasprice, _l2GasPerPubdataByteLimit);\n            uint256 baseCost = params.l2GasPrice * _l2GasLimit;\n```\n\nDefaults to:\n\n```solidity\n            params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, _l2GasPerPubdataByteLimit);\n            uint256 baseCost = params.l2GasPrice * _l2GasLimit;\n```\n\nTaking into account that its value can never be zero because:\n\n```solidity\n      function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPricePerPubdata) internal pure returns (uint256) {\n            uint256 pubdataPriceETH = L1_GAS_PER_PUBDATA_BYTE * _l1GasPrice;\n            uint256 minL2GasPriceETH = (pubdataPriceETH + _gasPricePerPubdata - 1) / _gasPricePerPubdata;\n            \n            return Math.max(FAIR_L2_GAS_PRICE, minL2GasPriceETH);\n      }\n```\n\nThis returns at least `FAIR_L2_GAS_PRICE`. If we go to [bootloader, function `processL1Tx`](https://github.com/code-423n4/2023-10-zksync/blob/c3ff020df5d11fe91209bd99d7fb0ec1272dc387/code/system-contracts/bootloader/bootloader.yul#L878C1-L951C18), the `refundGas` the user will receive is the sum of:\n\n*Note: please see calculation in warden's [original submission](https://github.com/code-423n4/2023-10-zksync-findings/issues/548).*\n\n`reservedGas` is the excess of gas between what the user provided and what the operator is willing to use, and `refundGas` (not the final one) is the remaining gas that is left after preparing and executing the requested transaction. It is expected then that `_refundRecipient` will receive `refundGas * gasPrice` as a compensation for providing more gas than the needed for the execution of the `L1⇒L2` transaction.\n\nHowever, we see in:\n\n[Mailbox, lines 929 to 932](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L929C1-L932C45)\n\n```solidity\n                // Note, that for now, the `L1->L2` transactions are free, i.e. the gasPrice\n                // for such transactions is always zero, so the `refundGas` is not used anywhere\n                // except for notifications for the operator for API purposes. \n                notifyAboutRefund(refundGas)\n```\n\nIt is never used, as it assumes that \"L1⇒L2 transactions are free\", which is not true. If the transaction does not revert, then `_refundRecipient` will receive:\n\n[bootloader, line 950](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L950)\n\n```solidity\n                    toRefundRecipient := safeSub(getReserved0(innerTxDataOffset), safeAdd(getValue(innerTxDataOffset), payToOperator, \"kpa\"), \"ysl\")\n```\n\nThis equals to `msg.value - (l2Value + payToOperator)`. I kindly suggest changing the code to:\n\n[bootloader, lines 929 to 952](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L929C1-L952C1)\n\n```diff\n-               // Note, that for now, the `L1->L2` transactions are free, i.e. the gasPrice\n-               // for such transactions is always zero, so the `refundGas` is not used anywhere\n-               // except for notifications for the operator for API purposes. \n                notifyAboutRefund(refundGas)\n\n                // Paying the fee to the operator\n                mintEther(BOOTLOADER_FORMAL_ADDR(), payToOperator, false)\n\n                let toRefundRecipient\n                switch success\n                case 0 {\n                    // If the transaction reverts, then minting the msg.value to the user has been reverted\n                    // as well, so we can simply mint everything that the user has deposited to \n                    // the refund recipient\n\n                    toRefundRecipient := safeSub(getReserved0(innerTxDataOffset), payToOperator, \"vji\")\n                }\n                default {\n-                   // If the transaction succeeds, then it is assumed that msg.value was transferred correctly. However, the remaining \n-                   // ETH deposited will be given to the refund recipient.\n+                   // If the transaction succeeds, then it is assumed that msg.value was transferred correctly, so refundGas is \n+                   // sent to the refund recipient.\n\n-                   toRefundRecipient := safeSub(getReserved0(innerTxDataOffset), safeAdd(getValue(innerTxDataOffset), payToOperator, \"kpa\"), \"ysl\")\n+                   toRefundRecipient := safeMul(refundGas, gasPrice, \"whatever error you want\")\n                }\n```\n\nIf both equations are equal, that is, `refundGas * gasPrice = msg.value - (l2Value + payToOperator)`, then this is more explicit and saves gas by not doing `safeSub`s nor `safeAdd`s (QA). If they are **NOT**, then this code is the correct one, as you are giving the refund recipient exactly the calculated `refundGas`, no more, no less.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport {IMailbox, TxStatus} from \"../interfaces/IMailbox.sol\";\nimport {Merkle} from \"../libraries/Merkle.sol\";\nimport {PriorityQueue, PriorityOperation} from \"../libraries/PriorityQueue.sol\";\nimport {TransactionValidator} from \"../libraries/TransactionValidator.sol\";\nimport {L2Message, L2Log} from \"../Storage.sol\";\nimport {UncheckedMath} from \"../../common/libraries/UncheckedMath.sol\";\nimport {UnsafeBytes} from \"../../common/libraries/UnsafeBytes.sol\";\nimport {L2ContractHelper} from \"../../common/libraries/L2ContractHelper.sol\";\nimport {AddressAliasHelper} from \"../../vendor/AddressAliasHelper.sol\";\nimport {IAllowList} from \"../../common/interfaces/IAllowList.sol\";\nimport {Base} from \"./Base.sol\";\nimport {\n    REQUIRED_L2_GAS_PRICE_PER_PUBDATA,\n    FAIR_L2_GAS_PRICE,\n    L1_GAS_PER_PUBDATA_BYTE,\n    L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH,\n    PRIORITY_OPERATION_L2_TX_TYPE,\n    PRIORITY_EXPIRATION,\n    MAX_NEW_FACTORY_DEPS\n} from \"../Config.sol\";\nimport {\n    L2_BOOTLOADER_ADDRESS,\n    L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n    L2_ETH_TOKEN_SYSTEM_CONTRACT_ADDR\n} from \"../../common/L2ContractAddresses.sol\";\n\n\n/// @title zkSync Mailbox contract providing interfaces for L1 <-> L2 interaction.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract MailboxFacet is Base, IMailbox {\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    string public constant override getName = \"MailboxFacet\";\n\n    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 batch number\n    /// @param _batchNumber The executed L2 batch number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 batch where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @notice Prove that a specific L2 log was sent in a specific L2 batch\n    /// @param _batchNumber The executed L2 batch number in which the log appeared\n    /// @param _index The position of the l2log in the L2 logs Merkle tree\n    /// @param _log Information about the sent log\n    /// @param _proof Merkle proof for inclusion of the L2 log\n    /// @return Whether the proof is correct and L2 log is included in batch\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @notice Prove that the L1 -> L2 transaction was processed with the specified status.\n    /// @param _l2TxHash The L2 canonical transaction hash\n    /// @param _l2BatchNumber The L2 batch number where the transaction was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction\n    /// @param _status The execution status of the L1 -> L2 transaction (true - success & 0 - fail)\n    /// @return Whether the proof is correct and the transaction was actually executed with provided status\n    /// NOTE: It may return `false` for incorrect proof, but it doesn't mean that the L1 -> L2 transaction has an opposite status!\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view override returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    /// @notice Transfer ether from the contract to the receiver\n    /// @dev Reverts only if the transfer call failed\n    function _withdrawFunds(address _to, uint256 _amount) internal {\n        bool callSuccess;\n        // Low-level assembly call, to avoid any memory copying (save gas)\n        assembly {\n            callSuccess := call(gas(), _to, _amount, 0, 0, 0, 0)\n        }\n        require(callSuccess, \"pz\");\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, \"xx\");\n\n        bytes32 hashedLog = keccak256(\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, \"tw\");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    /// @param _gasPrice expected L1 gas price at which the user requests the transaction execution\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount of L2 gas that the operator may charge the user for a single byte of pubdata.\n    /// @return The estimated ETH spent on L2 gas for the transaction\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public pure returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in ETH to be paid.\n    /// @param _l1GasPrice The gas price on L1.\n    /// @param _gasPricePerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in ETH\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPricePerPubdata) internal pure returns (uint256) {\n        uint256 pubdataPriceETH = L1_GAS_PER_PUBDATA_BYTE * _l1GasPrice;\n        uint256 minL2GasPriceETH = (pubdataPriceETH + _gasPricePerPubdata - 1) / _gasPricePerPubdata;\n\n        return Math.max(FAIR_L2_GAS_PRICE, minL2GasPriceETH);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external override nonReentrant senderCanCallFunction(s.allowList) {\n        require(!s.isEthWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex], \"jj\");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_ETH_TOKEN_SYSTEM_CONTRACT_ADDR,\n            data: _message\n        });\n\n        (address _l1WithdrawReceiver, uint256 _amount) = _parseL2WithdrawalMessage(_message);\n\n        bool proofValid = proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n        require(proofValid, \"pi\"); // Failed to verify that withdrawal was actually initialized on L2\n\n        s.isEthWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex] = true;\n        _withdrawFunds(_l1WithdrawReceiver, _amount);\n\n        emit EthWithdrawalFinalized(_l1WithdrawReceiver, _amount);\n    }\n\n    /// @notice Request execution of L2 transaction from L1.\n    /// @param _contractL2 The L2 receiver address\n    /// @param _l2Value `msg.value` of L2 transaction\n    /// @param _calldata The input of the L2 transaction\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount L2 gas that the operator may charge the user for single byte of pubdata.\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient's address to eliminate sending funds to addresses out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds are controllable,\n    /// since address aliasing to the from address for the L2 tx will be applied if the L1 `msg.sender` is a contract.\n    /// Without address aliasing for L1 contracts as refund recipients they would not be able to make proper L2 tx requests\n    /// through the Mailbox to use or withdraw the funds from L2, and the funds would be lost.\n    /// @return canonicalTxHash The hash of the requested L2 transaction. This hash can be used to follow the transaction status\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable nonReentrant senderCanCallFunction(s.allowList) returns (bytes32 canonicalTxHash) {\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        address sender = msg.sender;\n        if (sender != tx.origin) {\n            sender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        // Enforcing that `_l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using \"exotic\" numbers for _l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, \"qp\");\n\n        // The L1 -> L2 transaction may be failed and funds will be sent to the `_refundRecipient`,\n        // so we use `msg.value` instead of `_l2Value` as the bridged amount.\n        _verifyDepositLimit(msg.sender, msg.value);\n        canonicalTxHash = _requestL2Transaction(\n            sender,\n            _contractL2,\n            _l2Value,\n            _calldata,\n            _l2GasLimit,\n            _l2GasPerPubdataByteLimit,\n            _factoryDeps,\n            false,\n            _refundRecipient\n        );\n    }\n\n    function _verifyDepositLimit(address _depositor, uint256 _amount) internal {\n        IAllowList.Deposit memory limitData = IAllowList(s.allowList).getTokenDepositLimitData(address(0)); // address(0) denotes the ETH\n        if (!limitData.depositLimitation) return; // no deposit limitation is placed for ETH\n\n        require(s.totalDepositedAmountPerUser[_depositor] + _amount <= limitData.depositCap, \"d2\");\n        s.totalDepositedAmountPerUser[_depositor] += _amount;\n    }\n\n    function _requestL2Transaction(\n        address _sender,\n        address _contractAddressL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        bool _isFree,\n        address _refundRecipient\n    ) internal returns (bytes32 canonicalTxHash) {\n        require(_factoryDeps.length <= MAX_NEW_FACTORY_DEPS, \"uj\");\n        uint64 expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n        uint256 txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Here we manually assign fields for the struct to prevent \"stack too deep\" error\n        WritePriorityOpParams memory params;\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        // Using a new scope to prevent \"stack too deep\" error\n        {\n            params.l2GasPrice = _isFree ? 0 : _deriveL2GasPrice(tx.gasprice, _l2GasPerPubdataByteLimit);\n            uint256 baseCost = params.l2GasPrice * _l2GasLimit;\n            require(msg.value >= baseCost + _l2Value, \"mv\"); // The `msg.value` doesn't cover the transaction cost\n        }\n\n        // If the `_refundRecipient` is not provided, we use the `_sender` as the recipient.\n        address refundRecipient = _refundRecipient == address(0) ? _sender : _refundRecipient;\n        // If the `_refundRecipient` is a smart contract, we apply the L1 to L2 alias to prevent foot guns.\n        if (refundRecipient.code.length > 0) {\n            refundRecipient = AddressAliasHelper.applyL1ToL2Alias(refundRecipient);\n        }\n\n        params.sender = _sender;\n        params.txId = txId;\n        params.l2Value = _l2Value;\n        params.contractAddressL2 = _contractAddressL2;\n        params.expirationTimestamp = expirationTimestamp;\n        params.l2GasLimit = _l2GasLimit;\n        params.l2GasPricePerPubdata = _l2GasPerPubdataByteLimit;\n        params.valueToMint = msg.value;\n        params.refundRecipient = refundRecipient;\n\n        canonicalTxHash = _writePriorityOp(params, _calldata, _factoryDeps);\n    }\n\n    function _serializeL2Transaction(\n        WritePriorityOpParams memory _priorityOpParams,\n        bytes calldata _calldata,\n        bytes[] calldata _factoryDeps\n    ) internal pure returns (L2CanonicalTransaction memory transaction) {\n        transaction = L2CanonicalTransaction({\n            txType: PRIORITY_OPERATION_L2_TX_TYPE,\n            from: uint256(uint160(_priorityOpParams.sender)),\n            to: uint256(uint160(_priorityOpParams.contractAddressL2)),\n            gasLimit: _priorityOpParams.l2GasLimit,\n            gasPerPubdataByteLimit: _priorityOpParams.l2GasPricePerPubdata,\n            maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as \"nonce\" for L1->L2 transactions\n            nonce: uint256(_priorityOpParams.txId),\n            value: _priorityOpParams.l2Value,\n            reserved: [_priorityOpParams.valueToMint, uint256(uint160(_priorityOpParams.refundRecipient)), 0, 0],\n            data: _calldata,\n            signature: new bytes(0),\n            factoryDeps: _hashFactoryDeps(_factoryDeps),\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        WritePriorityOpParams memory _priorityOpParams,\n        bytes calldata _calldata,\n        bytes[] calldata _factoryDeps\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams, _calldata, _factoryDeps);\n\n        bytes memory transactionEncoding = abi.encode(transaction);\n\n        TransactionValidator.validateL1ToL2Transaction(transaction, transactionEncoding, s.priorityTxMaxGasLimit);\n\n        canonicalTxHash = keccak256(transactionEncoding);\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationTimestamp: _priorityOpParams.expirationTimestamp,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that is needed for the operator to simulate priority queue offchain\n        emit NewPriorityRequest(\n            _priorityOpParams.txId,\n            canonicalTxHash,\n            _priorityOpParams.expirationTimestamp,\n            transaction,\n            _factoryDeps\n        );\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] calldata _factoryDeps)\n        internal\n        pure\n        returns (uint256[] memory hashedFactoryDeps)\n    {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n\n    /// @dev Decode the withdraw message that came from L2\n    function _parseL2WithdrawalMessage(bytes memory _message)\n        internal\n        pure\n        returns (address l1Receiver, uint256 amount)\n    {\n        // We check that the message is long enough to read the data.\n        // Please note that there are two versions of the message:\n        // 1. The message that is sent by `withdraw(address _l1Receiver)`\n        // It should be equal to the length of the bytes4 function signature + address l1Receiver + uint256 amount = 4 + 20 + 32 = 56 (bytes).\n        // 2. The message that is sent by `withdrawWithMessage(address _l1Receiver, bytes calldata _additionalData)`\n        // It should be equal to the length of the following:\n        // bytes4 function signature + address l1Receiver + uint256 amount + address l2Sender + bytes _additionalData =\n        // = 4 + 20 + 32 + 32 + _additionalData.length >= 68 (bytes).\n\n        // So the data is expected to be at least 56 bytes long.\n        require(_message.length >= 56, \"pm\");\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_message, 0);\n        require(bytes4(functionSignature) == this.finalizeEthWithdrawal.selector, \"is\");\n\n        (l1Receiver, offset) = UnsafeBytes.readAddress(_message, offset);\n        (amount, offset) = UnsafeBytes.readUint256(_message, offset);\n    }\n}"
    },
    {
      "filename": "code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport {IMailbox, TxStatus} from \"../interfaces/IMailbox.sol\";\nimport {Merkle} from \"../libraries/Merkle.sol\";\nimport {PriorityQueue, PriorityOperation} from \"../libraries/PriorityQueue.sol\";\nimport {TransactionValidator} from \"../libraries/TransactionValidator.sol\";\nimport {L2Message, L2Log} from \"../Storage.sol\";\nimport {UncheckedMath} from \"../../common/libraries/UncheckedMath.sol\";\nimport {UnsafeBytes} from \"../../common/libraries/UnsafeBytes.sol\";\nimport {L2ContractHelper} from \"../../common/libraries/L2ContractHelper.sol\";\nimport {AddressAliasHelper} from \"../../vendor/AddressAliasHelper.sol\";\nimport {IAllowList} from \"../../common/interfaces/IAllowList.sol\";\nimport {Base} from \"./Base.sol\";\nimport {\n    REQUIRED_L2_GAS_PRICE_PER_PUBDATA,\n    FAIR_L2_GAS_PRICE,\n    L1_GAS_PER_PUBDATA_BYTE,\n    L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH,\n    PRIORITY_OPERATION_L2_TX_TYPE,\n    PRIORITY_EXPIRATION,\n    MAX_NEW_FACTORY_DEPS\n} from \"../Config.sol\";\nimport {\n    L2_BOOTLOADER_ADDRESS,\n    L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n    L2_ETH_TOKEN_SYSTEM_CONTRACT_ADDR\n} from \"../../common/L2ContractAddresses.sol\";\n\n\n/// @title zkSync Mailbox contract providing interfaces for L1 <-> L2 interaction.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract MailboxFacet is Base, IMailbox {\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    string public constant override getName = \"MailboxFacet\";\n\n    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 batch number\n    /// @param _batchNumber The executed L2 batch number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 batch where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @notice Prove that a specific L2 log was sent in a specific L2 batch\n    /// @param _batchNumber The executed L2 batch number in which the log appeared\n    /// @param _index The position of the l2log in the L2 logs Merkle tree\n    /// @param _log Information about the sent log\n    /// @param _proof Merkle proof for inclusion of the L2 log\n    /// @return Whether the proof is correct and L2 log is included in batch\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @notice Prove that the L1 -> L2 transaction was processed with the specified status.\n    /// @param _l2TxHash The L2 canonical transaction hash\n    /// @param _l2BatchNumber The L2 batch number where the transaction was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction\n    /// @param _status The execution status of the L1 -> L2 transaction (true - success & 0 - fail)\n    /// @return Whether the proof is correct and the transaction was actually executed with provided status\n    /// NOTE: It may return `false` for incorrect proof, but it doesn't mean that the L1 -> L2 transaction has an opposite status!\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view override returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    /// @notice Transfer ether from the contract to the receiver\n    /// @dev Reverts only if the transfer call failed\n    function _withdrawFunds(address _to, uint256 _amount) internal {\n        bool callSuccess;\n        // Low-level assembly call, to avoid any memory copying (save gas)\n        assembly {\n            callSuccess := call(gas(), _to, _amount, 0, 0, 0, 0)\n        }\n        require(callSuccess, \"pz\");\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, \"xx\");\n\n        bytes32 hashedLog = keccak256(\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, \"tw\");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    /// @param _gasPrice expected L1 gas price at which the user requests the transaction execution\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount of L2 gas that the operator may charge the user for a single byte of pubdata.\n    /// @return The estimated ETH spent on L2 gas for the transaction\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public pure returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in ETH to be paid.\n    /// @param _l1GasPrice The gas price on L1.\n    /// @param _gasPricePerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in ETH\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPricePerPubdata) internal pure returns (uint256) {\n        uint256 pubdataPriceETH = L1_GAS_PER_PUBDATA_BYTE * _l1GasPrice;\n        uint256 minL2GasPriceETH = (pubdataPriceETH + _gasPricePerPubdata - 1) / _gasPricePerPubdata;\n\n        return Math.max(FAIR_L2_GAS_PRICE, minL2GasPriceETH);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external override nonReentrant senderCanCallFunction(s.allowList) {\n        require(!s.isEthWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex], \"jj\");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_ETH_TOKEN_SYSTEM_CONTRACT_ADDR,\n            data: _message\n        });\n\n        (address _l1WithdrawReceiver, uint256 _amount) = _parseL2WithdrawalMessage(_message);\n\n        bool proofValid = proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n        require(proofValid, \"pi\"); // Failed to verify that withdrawal was actually initialized on L2\n\n        s.isEthWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex] = true;\n        _withdrawFunds(_l1WithdrawReceiver, _amount);\n\n        emit EthWithdrawalFinalized(_l1WithdrawReceiver, _amount);\n    }\n\n    /// @notice Request execution of L2 transaction from L1.\n    /// @param _contractL2 The L2 receiver address\n    /// @param _l2Value `msg.value` of L2 transaction\n    /// @param _calldata The input of the L2 transaction\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount L2 gas that the operator may charge the user for single byte of pubdata.\n    /// @param _factoryDeps A"
    }
  ]
}