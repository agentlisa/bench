{
  "Title": "Potentially Stuck USDC From Pausing",
  "Content": "Currently the [`L2USDCGateway`](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L2/gateways/usdc/L2USDCGateway.sol#L106-L116) has pausing functionality that its L1 counterpart does not have. This is a feature that will be used by the protocol to do supply locking in the future.\n\n\nAn issue arises when the `L2USDCGateway` is paused while the `L1USDCGateway` remains unpaused and usable. Users may still use the gateway to submit messages from L1 to L2, and while the transaction could succeed on L1, it will fail during finalization on L2 via the [paused deposit check](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L2/gateways/usdc/L2USDCGateway.sol#L93) in the [`finalizeDepositERC20` function](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L2/gateways/usdc/L2USDCGateway.sol#L82-L100). Therefore, the users who deposited L1 USDC will have their tokens locked in the gateway and unable to replay their transaction. Assuming that the transaction was not skipped, [dropMessage](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L1/L1ScrollMessenger.sol#L241) cannot be called to obtain a refund.\n\n\nAs USDC is one of the most widely used tokens, this issue could cause a high volume of users to have locked funds. Consider adding the same pausing functionality to the `L1USDCGateway` and updating the pausing state on both sides at the same time. Furthermore, consider implementing a refund mechanism to unlock user funds when their message from L1 to L2 fails.\n\n\n***Update:** Acknowledged, not resolved. The Scroll team stated:*\n\n\n\n> *We will ensure that in L1 `pauseDeposit` will be called first and in the meantime, in L2, `pauseWithdraw` will be called. After this, the pending L1=>L2 or L2=>L1 messages are relayed. The pausing withdraw in L1 and pausing deposit in L2 will enable (actually not needed but just in case). We will help relay pending L2=>L1 message if users forget to withdraw the USDC. We will also help replay L1=>L2 messages if they fail in L2 due to running out of gas. Skipped messages are not possible in the USDC gateway, since we disabled deposit/withdraw with data.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/L2/gateways/usdc/L2USDCGateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.16;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {IFiatToken} from \"../../../interfaces/IFiatToken.sol\";\nimport {IL1ERC20Gateway} from \"../../../L1/gateways/IL1ERC20Gateway.sol\";\nimport {IL2ScrollMessenger} from \"../../IL2ScrollMessenger.sol\";\nimport {IL2ERC20Gateway} from \"../IL2ERC20Gateway.sol\";\n\nimport {ScrollGatewayBase, IScrollGateway} from \"../../../libraries/gateway/ScrollGatewayBase.sol\";\nimport {L2ERC20Gateway} from \"../L2ERC20Gateway.sol\";\n\n/// @title L2USDCGateway\n/// @notice The `L2USDCGateway` contract is used to withdraw `USDC` token in layer 2 and\n/// finalize deposit `USDC` from layer 1.\ncontract L2USDCGateway is OwnableUpgradeable, ScrollGatewayBase, L2ERC20Gateway {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of L1 USDC address.\n    address public immutable l1USDC;\n\n    /// @notice The address of L2 USDC address.\n    address public immutable l2USDC;\n\n    /*************\n     * Variables *\n     *************/\n\n    bool public depositPaused;\n\n    bool public withdrawPaused;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(address _l1USDC, address _l2USDC) {\n        _disableInitializers();\n\n        l1USDC = _l1USDC;\n        l2USDC = _l2USDC;\n    }\n\n    function initialize(\n        address _counterpart,\n        address _router,\n        address _messenger\n    ) external initializer {\n        require(_router != address(0), \"zero router address\");\n        ScrollGatewayBase._initialize(_counterpart, _router, _messenger);\n\n        OwnableUpgradeable.__Ownable_init();\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL2ERC20Gateway\n    function getL1ERC20Address(address) external view override returns (address) {\n        return l1USDC;\n    }\n\n    /// @inheritdoc IL2ERC20Gateway\n    function getL2ERC20Address(address) public view override returns (address) {\n        return l2USDC;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL2ERC20Gateway\n    function finalizeDepositERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable override onlyCallByCounterpart nonReentrant {\n        require(msg.value == 0, \"nonzero msg.value\");\n        require(_l1Token == l1USDC, \"l1 token not USDC\");\n        require(_l2Token == l2USDC, \"l2 token not USDC\");\n        require(!depositPaused, \"deposit paused\");\n\n        require(IFiatToken(_l2Token).mint(_to, _amount), \"mint USDC failed\");\n\n        _doCallback(_to, _data);\n\n        emit FinalizeDepositERC20(_l1Token, _l2Token, _from, _to, _amount, _data);\n    }\n\n    /*******************************\n     * Public Restricted Functions *\n     *******************************/\n\n    /// @notice Change the deposit pause status of this contract.\n    /// @param _paused The new status, `true` means paused and `false` means not paused.\n    function pauseDeposit(bool _paused) external onlyOwner {\n        depositPaused = _paused;\n    }\n\n    /// @notice Change the withdraw pause status of this contract.\n    /// @param _paused The new status, `true` means paused and `false` means not paused.\n    function pauseWithdraw(bool _paused) external onlyOwner {\n        withdrawPaused = _paused;\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @inheritdoc L2ERC20Gateway\n    function _withdraw(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) internal virtual override nonReentrant {\n        require(_amount > 0, \"withdraw zero amount\");\n        require(_token == l2USDC, \"only USDC is allowed\");\n        require(!withdrawPaused, \"withdraw paused\");\n\n        // 1. Extract real sender if this call is from L1GatewayRouter.\n        address _from = msg.sender;\n        if (router == msg.sender) {\n            (_from, _data) = abi.decode(_data, (address, bytes));\n        }\n\n        // 2. Transfer token into this contract.\n        IERC20Upgradeable(_token).safeTransferFrom(_from, address(this), _amount);\n        require(IFiatToken(_token).burn(_amount), \"burn USDC failed\");\n\n        // 3. Generate message passed to L1USDCGateway.\n        address _l1USDC = l1USDC;\n        bytes memory _message = abi.encodeCall(\n            IL1ERC20Gateway.finalizeWithdrawERC20,\n            (_l1USDC, _token, _from, _to, _amount, _data)\n        );\n\n        // 4. Send message to L1ScrollMessenger.\n        IL2ScrollMessenger(messenger).sendMessage{value: msg.value}(counterpart, 0, _message, _gasLimit);\n\n        emit WithdrawERC20(_l1USDC, _token, _from, _to, _amount, _data);\n    }\n}"
    },
    {
      "filename": "contracts/src/L2/gateways/usdc/L2USDCGateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.16;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {IFiatToken} from \"../../../interfaces/IFiatToken.sol\";\nimport {IL1ERC20Gateway} from \"../../../L1/gateways/IL1ERC20Gateway.sol\";\nimport {IL2ScrollMessenger} from \"../../IL2ScrollMessenger.sol\";\nimport {IL2ERC20Gateway} from \"../IL2ERC20Gateway.sol\";\n\nimport {ScrollGatewayBase, IScrollGateway} from \"../../../libraries/gateway/ScrollGatewayBase.sol\";\nimport {L2ERC20Gateway} from \"../L2ERC20Gateway.sol\";\n\n/// @title L2USDCGateway\n/// @notice The `L2USDCGateway` contract is used to withdraw `USDC` token in layer 2 and\n/// finalize deposit `USDC` from layer 1.\ncontract L2USDCGateway is OwnableUpgradeable, ScrollGatewayBase, L2ERC20Gateway {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of L1 USDC address.\n    address public immutable l1USDC;\n\n    /// @notice The address of L2 USDC address.\n    address public immutable l2USDC;\n\n    /*************\n     * Variables *\n     *************/\n\n    bool public depositPaused;\n\n    bool public withdrawPaused;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(address _l1USDC, address _l2USDC) {\n        _disableInitializers();\n\n        l1USDC = _l1USDC;\n        l2USDC = _l2USDC;\n    }\n\n    function initialize(\n        address _counterpart,\n        address _router,\n        address _messenger\n    ) external initializer {\n        require(_router != address(0), \"zero router address\");\n        ScrollGatewayBase._initialize(_counterpart, _router, _messenger);\n\n        OwnableUpgradeable.__Ownable_init();\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL2ERC20Gateway\n    function getL1ERC20Address(address) external view override returns (address) {\n        return l1USDC;\n    }\n\n    /// @inheritdoc IL2ERC20Gateway\n    function getL2ERC20Address(address) public view override returns (address) {\n        return l2USDC;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL2ERC20Gateway\n    function finalizeDepositERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable override onlyCallByCounterpart nonReentrant {\n        require(msg.value == 0, \"nonzero msg.value\");\n        require(_l1Token == l1USDC, \"l1 token not USDC\");\n        require(_l2Token == l2USDC, \"l2 token not USDC\");\n        require(!depositPaused, \"deposit paused\");\n\n        require(IFiatToken(_l2Token).mint(_to, _amount), \"mint USDC failed\");\n\n        _doCallback(_to, _data);\n\n        emit FinalizeDepositERC20(_l1Token, _l2Token, _from, _to, _amount, _data);\n    }\n\n    /*******************************\n     * Public Restricted Functions *\n     *******************************/\n\n    /// @notice Change the deposit pause status of this contract.\n    /// @param _paused The new status, `true` means paused and `false` means not paused.\n    function pauseDeposit(bool _paused) external onlyOwner {\n        depositPaused = _paused;\n    }\n\n    /// @notice Change the withdraw pause status of this contract.\n    /// @param _paused The new status, `true` means paused and `false` means not paused.\n    function pauseWithdraw(bool _paused) external onlyOwner {\n        withdrawPaused = _paused;\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @inheritdoc L2ERC20Gateway\n    function _withdraw(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) internal virtual override nonReentrant {\n        require(_amount > 0, \"withdraw zero amount\");\n        require(_token == l2USDC, \"only USDC is allowed\");\n        require(!withdrawPaused, \"withdraw paused\");\n\n        // 1. Extract real sender if this call is from L1GatewayRouter.\n        address _from = msg.sender;\n        if (router == msg.sender) {\n            (_from, _data) = abi.decode(_data, (address, bytes));\n        }\n\n        // 2. Transfer token into this contract.\n        IERC20Upgradeable(_token).safeTransferFrom(_from, address(this), _amount);\n        require(IFiatToken(_token).burn(_amount), \"burn USDC failed\");\n\n        // 3. Generate message passed to L1USDCGateway.\n        address _l1USDC = l1USDC;\n        bytes memory _message = abi.encodeCall(\n            IL1ERC20Gateway.finalizeWithdrawERC20,\n            (_l1USDC, _token, _from, _to, _amount, _data)\n        );\n\n        // 4. Send message to L1ScrollMessenger.\n        IL2ScrollMessenger(messenger).sendMessage{value: msg.value}(counterpart, 0, _message, _gasLimit);\n\n        emit WithdrawERC20(_l1USDC, _token, _from, _to, _amount, _data);\n    }\n}"
    }
  ]
}