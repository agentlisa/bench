{
  "Title": "M-5: PartyBFacetImpl.chargeFundingRate should check whether quoteIds is empty array to prevent partyANonces from being increased, causing some operations of partyA to fail",
  "Content": "# Issue M-5: PartyBFacetImpl.chargeFundingRate should check whether quoteIds is empty array to prevent partyANonces from being increased, causing some operations of partyA to fail \n\nSource: https://github.com/sherlock-audit/2023-08-symmetrical-judging/issues/41 \n\n## Found by \nnobody2018\n\n[[PartyBFacetImpl.chargeFundingRate](https://github.com/sherlock-audit/2023-08-symmetrical/blob/main/symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol#L310-L315)](https://github.com/sherlock-audit/2023-08-symmetrical/blob/main/symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol#L310-L315) can increase `partyANonces[partyA]` by 1 with the `quoteIds` empty array. Some functions that partyA can call will use `partyANonces[partyA]` to verify the signature. This opens up the opportunity for partyB to DOS partyA until PartyB makes a profit or reduces its losses.\n\n## Vulnerability Detail\n\n```solidity\nFile: symmio-core\\contracts\\facets\\PartyB\\PartyBFacetImpl.sol\n310:     function chargeFundingRate(\n311:         address partyA,\n312:         uint256[] memory quoteIds,\n313:         int256[] memory rates,\n314:         PairUpnlSig memory upnlSig\n315:     ) internal {\n316:         LibMuon.verifyPairUpnl(upnlSig, msg.sender, partyA);\n317:         require(quoteIds.length == rates.length, \"PartyBFacet: Length not match\");\n318:         int256 partyBAvailableBalance = LibAccount.partyBAvailableBalanceForLiquidation(\n319:             upnlSig.upnlPartyB,\n320:             msg.sender,\n321:             partyA\n322:         );\n323:         int256 partyAAvailableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n324:             upnlSig.upnlPartyA,\n325:             partyA\n326:         );\n327:         uint256 epochDuration;\n328:         uint256 windowTime;\n329:         for (uint256 i = 0; i < quoteIds.length; i++) {\n......//quoteIds is empty array, so code is never executed.\n390:         }\n391:         require(partyAAvailableBalance >= 0, \"PartyBFacet: PartyA will be insolvent\");\n392:         require(partyBAvailableBalance >= 0, \"PartyBFacet: PartyB will be insolvent\");\n393:         AccountStorage.layout().partyBNonces[msg.sender][partyA] += 1;\n394:->       AccountStorage.layout().partyANonces[partyA] += 1;\n395:     }\n```\n\nAs long as `partyBAvailableBalance`(L318) and `partyAAvailableBalance`(L323) are greater than or equal to 0, that is to say, PartyA and PartyB are solvent. Then, partyB can add 1 to `partyANonces[partyA]` at little cost which is the gas of tx.\n\nAn example is given to illustrate how to cause losses for partyA. Assume that partyA requests to close a quote via [[PartyAFacetImpl.requestToClosePosition](https://github.com/sherlock-audit/2023-08-symmetrical/blob/main/symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol#L150)](https://github.com/sherlock-audit/2023-08-symmetrical/blob/main/symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol#L150). PartyB ignored it. partyA can only wait for `maLayout.forceCloseCooldown` seconds, and then call [[PartyAFacetImpl.forceClosePosition](https://github.com/sherlock-audit/2023-08-symmetrical/blob/main/symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol#L239)](https://github.com/sherlock-audit/2023-08-symmetrical/blob/main/symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol#L239) to forcefully close the quote. \n\n```solidity\nFile: symmio-core\\contracts\\facets\\PartyA\\PartyAFacetImpl.sol\n239:     function forceClosePosition(uint256 quoteId, PairUpnlAndPriceSig memory upnlSig) internal {\n240:         AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n241:         MAStorage.Layout storage maLayout = MAStorage.layout();\n242:         Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n......//assume codes here are executed\n273:->       LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n......\n283:     }\n```\n\nL273, [[LibMuon.verifyPairUpnlAndPrice](https://github.com/sherlock-audit/2023-08-symmetrical/blob/main/symmio-core/contracts/libraries/LibMuon.sol#L181-L182)](https://github.com/sherlock-audit/2023-08-symmetrical/blob/main/symmio-core/contracts/libraries/LibMuon.sol#L181-L182) is used to verify signatures, where `partyBNonces[partyB][partyA]` and `partyANonces[partyA]` are used internally.\n\nIf the current price goes against partyB, then partyB can front-run `forceClosePosition` and call `chargeFundingRate` to increase the nonces of both parties by 1. In this way, partyA's `forceClosePosition` will inevitably revert because the nonces are incorrect.\n\nSimilarly, if partyA wants to deallocate funds via [[AccountFacetImpl.deallocate](https://github.com/sherlock-audit/2023-08-symmetrical/blob/main/symmio-core/contracts/facets/Account/AccountFacetImpl.sol#L53)](https://github.com/sherlock-audit/2023-08-symmetrical/blob/main/symmio-core/contracts/facets/Account/AccountFacetImpl.sol#L53), partyB can also prevent this operation via `chargeFundingRate`.\n\n## Impact\n\nDue to this issue, partyB can increase nonces of any partyA with little cost, causing some operations of partyA to fail (refer to the Vulnerability Detail section). This opens up the opportunity for partyB to turn the table.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-08-symmetrical/blob/main/symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol#L310-L315\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n```solidity\nFile: symmio-core\\contracts\\facets\\PartyB\\PartyBFacetImpl.sol\n310:     function chargeFundingRate(\n311:         address partyA,\n312:         uint256[] memory quoteIds,\n313:         int256[] memory rates,\n314:         PairUpnlSig memory upnlSig\n315:     ) internal {\n316:         LibMuon.verifyPairUpnl(upnlSig, msg.sender, partyA);\n317:-        require(quoteIds.length == rates.length, \"PartyBFacet: Length not match\");\n317:+        require(quoteIds.length > 0 && quoteIds.length == rates.length, \"PartyBFacet: Length is 0 or Length not match\");\n```\n\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> valid medium\n\n\n\n**securitygrid**\n\nEscalate\nThis is not a dup of #31. Please review it.\nThis issue describes how PartyB uses `chargeFundingRate` to cause PartyA to suffer losses. \n**All PartyB can easily take advantage of it against PartyA, making themselves always profitable**.\nConsider the following two situations here:\n1. If the current price goes for PartyB, then the quote is closed and PartyB makes a profit.\n2. If the current price goes against PartyB, then PartyB can use this issue to prevent PartyA from forcibly closing the quote until the price goes for PartyB.\n\n\n\n**sherlock-admin2**\n\n > Escalate\n> This is not a dup of #31. Please review it.\n> This issue describes how PartyB uses `chargeFundingRate` to cause PartyA to suffer losses. \n> **All PartyB can easily take advantage of it against PartyA, making themselves always profitable**.\n> Consider the following two situations here:\n> 1. If the current price goes for PartyB, then the quote is closed and PartyB makes a profit.\n> 2. If the current price goes against PartyB, then PartyB can use this issue to prevent PartyA from forcibly closing the quote until the price goes for PartyB.\n> \n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\n> Escalate This is not a dup of #31. Please review it. This issue describes how PartyB uses `chargeFundingRate` to cause PartyA to suffer losses. **All PartyB can easily take advantage of it against PartyA, making themselves always profitable**. Consider the following two situations here:\n> \n> 1. If the current price goes for PartyB, then the quote is closed and PartyB makes a profit.\n> 2. If the current price goes against PartyB, then PartyB can use this issue to prevent PartyA from forcibly closing the quote until the price goes for PartyB.\n> \n> So this issue can be H.\n\nAgreed, although both stems from the same root case of abusing chargeFundingRate to increment nonce, it is not a duplicate of #31 given that issue is invalid. This is talking about partyB potentially causing losses to partyA not about preventing its own liquidation process.\n\n@MoonKnightDev want to hear ur thoughts on this, given protocol determines party B is a trusted role. \n\n**panprog**\n\nEscalate\n\nI believe this is a valid medium. It is similar to #31 in that it uses nonce increase to block certain functionality, however #31 only lists liquidation as impact (which is invalid), while this issue shows valid impact for partyB to be able to avoid `forceClosePosition`. I think function from #31 (`deallocate`) and also `transferAllocation` can also be used for the same (increase partyB nonce to prevent `forceClosePosition`).\n\nSo from my view:\n- core reason: the same as #31 (which also mentions `chargeFundingRate`, without details though)\n- impact: this issue - valid medium. #31 - invalid.\n\nIf identifiying core reason is enough to make issue valid, then #31 should also be a (valid) dup of this. But I personally think that lack of correct impact should keep it invalid.\n\nAs to why it's medium - it requires partyB to be malicious, and since partyB is semi-trusted role - as established in previous contest, all issues caused by malicious partyB should be treated as medium.\n\nBased on all of this I think this should be a valid medium while #31 should remain invalid.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> I believe this is a valid medium. It is similar to #31 in that it uses nonce increase to block certain functionality, however #31 only lists liquidation as impact (which is invalid), while this issue shows valid impact for partyB to be able to avoid `forceClosePosition`. I think function from #31 (`deallocate`) and also `transferAllocation` can also be used for the same (increase partyB nonce to prevent `forceClosePosition`).\n> \n> So from my view:\n> - core reason: the same as #31 (which also mentions `chargeFundingRate`, without details though)\n> - impact: this issue - valid medium. #31 - invalid.\n> \n> If identifiying core reason is enough to make issue valid, then #31 should also be a (valid) dup of this. But I personally think that lack of correct impact should keep it invalid.\n> \n> As to why it's medium - it requires partyB to be malicious, and since partyB is semi-trusted role - as established in previous contest, all issues caused by malicious partyB should be treated as medium.\n> \n> Based on all of this I think this should be a valid medium while #31 should remain invalid.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\n> Escalate\n> \n> I believe this is a valid medium. It is similar to #31 in that it uses nonce increase to block certain functionality, however #31 only lists liquidation as impact (which is invalid), while this issue shows valid impact for partyB to be able to avoid `forceClosePosition`. I think function from #31 (`deallocate`) and also `transferAllocation` can also be used for the same (increase partyB nonce to prevent `forceClosePosition`).\n> \n> So from my view:\n> \n> * core reason: the same as [xiaoming90 - PartyB can block liquidation by incrementing the nonce #31](https://github.com/sherlock-audit/2023-08-symmetrical-judging/issues/31) (which also mentions `chargeFundingRate`, without details though)\n> * impact: this issue - valid medium. [xiaoming90 - PartyB can block liquidation by incrementing the nonce #31](https://github.com/sherlock-audit/2023-08-symmetrical-judging/issues/31) - invalid.\n> \n> If identifiying core reason is enough to make issue valid, then #31 should also be a (valid) dup of this. But I personally think that lack of correct impact should keep it invalid.\n> \n> As to why it's medium - it requires partyB to be malicious, and since partyB is semi-trusted role - as established in previous contest, all issues caused by malicious partyB should be treated as medium.\n> \n> Based on all of this I think this should be a valid medium while #31 should remain invalid.\n\nAgree with this escalation. Unless there is a sufficient penalty mechanism in place for partyB to avoid abusing this vulnerability, this submission should be a valid medium. And given #31 wrongly identifies the attack path from the root cause, it is a valid low based on sherlocks rule [here](https://docs.sherlock.xyz/audits/judging/judging#ix.-duplication-rules) and thus is invalid:\n\n> - In addition to this, there is a submission D which identifies the core issue but does not clearly describe the impact or an attack path. Then D is considered low.\n\n**securitygrid**\n\nAgree that this is M since some issues about malicious partyB were M in previous contest.\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nConsidering this a valid issue on its own based on the above comments\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [securitygrid](https://github.com/sherlock-audit/2023-08-symmetrical-judging/issues/41/#issuecomment-1723552615): accepted\n- [panprog](https://github.com/sherlock-audit/2023-08-symmetrical-judging/issues/41/#issuecomment-1724285656): accepted\n\n**MoonKnightDev**\n\nFixed Code PR: https://github.com/SYMM-IO/symmio-core/pull/37/commits/80eb930a4c8ba8f4a89f17ad085412f9a41a11cd\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/108",
  "Code": [
    {
      "filename": "symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibSolvency.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../libraries/LibPartyB.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/GlobalAppStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary PartyBFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function lockQuote(uint256 quoteId, SingleUpnlSig memory upnlSig, bool increaseNonce) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        LibMuon.verifyPartyBUpnl(upnlSig, msg.sender, quote.partyA);\n        LibPartyB.checkPartyBValidationToLockQuote(quoteId, upnlSig.upnl);\n        if (increaseNonce) {\n            accountLayout.partyBNonces[msg.sender][quote.partyA] += 1;\n        }\n        quote.statusModifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.LOCKED;\n        quote.partyB = msg.sender;\n        // lock funds for partyB\n        accountLayout.partyBPendingLockedBalances[msg.sender][quote.partyA].addQuote(quote);\n        quoteLayout.partyBPendingQuotes[msg.sender][quote.partyA].push(quote.id);\n    }\n\n    function unlockQuote(uint256 quoteId) internal returns (QuoteStatus) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.LOCKED, \"PartyBFacet: Invalid state\");\n        if (block.timestamp > quote.deadline) {\n            QuoteStatus result = LibQuote.expireQuote(quoteId);\n            return result;\n        } else {\n            quote.statusModifyTimestamp = block.timestamp;\n            quote.quoteStatus = QuoteStatus.PENDING;\n            accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n            LibQuote.removeFromPartyBPendingQuotes(quote);\n            quote.partyB = address(0);\n            return QuoteStatus.PENDING;\n        }\n    }\n\n    function acceptCancelRequest(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.CANCEL_PENDING, \"PartyBFacet: Invalid state\");\n        quote.statusModifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.CANCELED;\n        accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n        accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n        // send trading Fee back to partyA\n        accountLayout.allocatedBalances[quote.partyA] += LibQuote.getTradingFee(quoteId);\n\n        LibQuote.removeFromPendingQuotes(quote);\n    }\n\n    function openPosition(\n        uint256 quoteId,\n        uint256 filledAmount,\n        uint256 openedPrice,\n        PairUpnlAndPriceSig memory upnlSig\n    ) internal returns (uint256 currentId) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        require(accountLayout.suspendedAddresses[quote.partyA] == false, \"PartyBFacet: PartyA is suspended\");\n        require(\n            SymbolStorage.layout().symbols[quote.symbolId].isValid,\n            \"PartyBFacet: Symbol is not valid\"\n        );\n\n        require(!GlobalAppStorage.layout().partyBEmergencyStatus[quote.partyB], \"PartyBFacet: PartyB is in emergency mode\");\n        require(!GlobalAppStorage.layout().emergencyMode, \"PartyBFacet: System is in emergency mode\");\n\n        require(\n            quote.quoteStatus == QuoteStatus.LOCKED ||\n                quote.quoteStatus == QuoteStatus.CANCEL_PENDING,\n            \"PartyBFacet: Invalid state\"\n        );\n        require(block.timestamp <= quote.deadline, \"PartyBFacet: Quote is expired\");\n        if (quote.orderType == OrderType.LIMIT) {\n            require(\n                quote.quantity >= filledAmount && filledAmount > 0,\n                \"PartyBFacet: Invalid filledAmount\"\n            );\n            accountLayout.balances[GlobalAppStorage.layout().feeCollector] +=\n                (filledAmount * quote.requestedOpenPrice * quote.tradingFee) / 1e36;\n        } else {\n            require(quote.quantity == filledAmount, \"PartyBFacet: Invalid filledAmount\");\n            accountLayout.balances[GlobalAppStorage.layout().feeCollector] +=\n                (filledAmount * quote.marketPrice * quote.tradingFee) / 1e36;\n        }\n        if (quote.positionType == PositionType.LONG) {\n            require(\n                openedPrice <= quote.requestedOpenPrice,\n                \"PartyBFacet: Opened price isn't valid\"\n            );\n        } else {\n            require(\n                openedPrice >= quote.requestedOpenPrice,\n                \"PartyBFacet: Opened price isn't valid\"\n            );\n        }\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n\n        quote.openedPrice = openedPrice;\n        quote.initialOpenedPrice = openedPrice;\n\n\n        accountLayout.partyANonces[quote.partyA] += 1;\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        quote.statusModifyTimestamp = block.timestamp;\n\n        LibQuote.removeFromPendingQuotes(quote);\n\n        if (quote.quantity == filledAmount) {\n            accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n            accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n            quote.lockedValues.mul(openedPrice).div(quote.requestedOpenPrice);\n\n            // check locked values\n            require(\n                quote.lockedValues.total() >=\n                SymbolStorage.layout().symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"PartyBFacet: Quote value is low\"\n            );\n        }\n            // partially fill\n        else {\n            currentId = ++quoteLayout.lastId;\n            QuoteStatus newStatus;\n            if (quote.quoteStatus == QuoteStatus.CANCEL_PENDING) {\n                newStatus = QuoteStatus.CANCELED;\n            } else {\n                newStatus = QuoteStatus.PENDING;\n                quoteLayout.partyAPendingQuotes[quote.partyA].push(currentId);\n            }\n            LockedValues memory filledLockedValues = LockedValues(\n                (quote.lockedValues.cva * filledAmount) / quote.quantity,\n                (quote.lockedValues.mm * filledAmount) / quote.quantity,\n                (quote.lockedValues.lf * filledAmount) / quote.quantity\n            );\n            LockedValues memory appliedFilledLockedValues = filledLockedValues;\n            appliedFilledLockedValues = appliedFilledLockedValues.mulMem(openedPrice);\n            appliedFilledLockedValues = appliedFilledLockedValues.divMem(quote.requestedOpenPrice);\n            // check that opened position is not minor position\n            require(\n                appliedFilledLockedValues.total() >=\n                    SymbolStorage.layout().symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"PartyBFacet: Quote value is low\"\n            );\n            // check that new pending position is not minor position\n            require(\n                (quote.lockedValues.total() - filledLockedValues.total()) >=\n                    SymbolStorage.layout().symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"PartyBFacet: Quote value is low\"\n            );\n\n            Quote memory q = Quote({\n                id: currentId,\n                partyBsWhiteList: quote.partyBsWhiteList,\n                symbolId: quote.symbolId,\n                positionType: quote.positionType,\n                orderType: quote.orderType,\n                openedPrice: 0,\n                initialOpenedPrice: 0,\n                requestedOpenPrice: quote.requestedOpenPrice,\n                marketPrice: quote.marketPrice,\n                quantity: quote.quantity - filledAmount,\n                closedAmount: 0,\n                lockedValues: LockedValues(0, 0, 0),\n                initialLockedValues: LockedValues(0, 0, 0),\n                maxFundingRate: quote.maxFundingRate,\n                partyA: quote.partyA,\n                partyB: address(0),\n                quoteStatus: newStatus,\n                avgClosedPrice: 0,\n                requestedClosePrice: 0,\n                parentId: quote.id,\n                createTimestamp: quote.createTimestamp,\n                statusModifyTimestamp: block.timestamp,\n                quantityToClose: 0,\n                lastFundingPaymentTimestamp: 0,\n                deadline: quote.deadline,\n                tradingFee: quote.tradingFee\n            });\n\n            quoteLayout.quoteIdsOf[quote.partyA].push(currentId);\n            quoteLayout.quotes[currentId] = q;\n            Quote storage newQuote = quoteLayout.quotes[currentId];\n\n            if (newStatus == QuoteStatus.CANCELED) {\n                // send trading Fee back to partyA\n                accountLayout.allocatedBalances[newQuote.partyA] += LibQuote.getTradingFee(newQuote.id);\n                // part of quote has been filled and part of it has been canceled\n                accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n                accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(\n                    quote\n                );\n            } else {\n                accountLayout.pendingLockedBalances[quote.partyA].sub(filledLockedValues);\n                accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(\n                    quote\n                );\n            }\n            newQuote.lockedValues = quote.lockedValues.sub(filledLockedValues);\n            newQuote.initialLockedValues = newQuote.lockedValues;\n            quote.quantity = filledAmount;\n            quote.lockedValues = appliedFilledLockedValues;\n        }\n        // lock with amount of filledAmount\n        accountLayout.lockedBalances[quote.partyA].addQuote(quote);\n        accountLayout.partyBLockedBalances[quote.partyB][quote.partyA].addQuote(quote);\n\n        LibSolvency.isSolventAfterOpenPosition(quoteId, filledAmount, upnlSig);\n        // check leverage (is in 18 decimals)\n        require(\n            quote.quantity * quote.openedPrice / quote.lockedValues.total() <= SymbolStorage.layout().symbols[quote.symbolId].maxLeverage,\n            \"PartyBFacet: Leverage is high\"\n        );\n\n        quote.quoteStatus = QuoteStatus.OPENED;\n        LibQuote.addToOpenPositions(quoteId);\n    }\n\n    function fillCloseRequest(\n        uint256 quoteId,\n        uint256 filledAmount,\n        uint256 closedPrice,\n        PairUpnlAndPriceSig memory upnlSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(\n            quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n                quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"PartyBFacet: Invalid state\"\n        );\n        require(block.timestamp <= quote.deadline, \"PartyBFacet: Quote is expired\");\n        if (quote.positionType == PositionType.LONG) {\n            require(\n                closedPrice >= quote.requestedClosePrice,\n                \"PartyBFacet: Closed price isn't valid\"\n            );\n        } else {\n            require(\n                closedPrice <= quote.requestedClosePrice,\n                \"PartyBFacet: Closed price isn't valid\"\n            );\n        }\n        if (quote.orderType == OrderType.LIMIT) {\n            require(quote.quantityToClose >= filledAmount, \"PartyBFacet: Invalid filledAmount\");\n        } else {\n            require(quote.quantityToClose == filledAmount, \"PartyBFacet: Invalid filledAmount\");\n        }\n\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n        LibSolvency.isSolventAfterClosePosition(quoteId, filledAmount, closedPrice, upnlSig);\n\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        accountLayout.partyANonces[quote.partyA] += 1;\n        LibQuote.closeQuote(quote, filledAmount, closedPrice);\n    }\n\n    function acceptCancelCloseRequest(uint256 quoteId) internal {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"PartyBFacet: Invalid state\"\n        );\n        quote.statusModifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.OPENED;\n        quote.requestedClosePrice = 0;\n        quote.quantityToClose = 0;\n    }\n\n    function emergencyClosePosition(uint256 quoteId, PairUpnlAndPriceSig memory upnlSig) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.OPENED || quote.quoteStatus == QuoteStatus.CLOSE_PENDING, \"PartyBFacet: Invalid state\");\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n        uint256 filledAmount = LibQuote.quoteOpenAmount(quote);\n        quote.quantityToClose = filledAmount;\n        quote.requestedClosePrice = upnlSig.price;\n        LibSolvency.isSolventAfterClosePosition(quoteId, filledAmount, upnlSig.price, upnlSig);\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        accountLayout.partyANonces[quote.partyA] += 1;\n        LibQuote.closeQuote(quote, filledAmount, upnlSig.price);\n    }\n\n    function chargeFundingRate(\n        address partyA,\n        uint256[] memory quoteIds,\n        int256[] memory rates,\n        PairUpnlSig memory upnlSig\n    ) internal {\n        LibMuon.verifyPairUpnl(upnlSig, msg.sender, partyA);\n        require(quoteIds.length == rates.length, \"PartyBFacet: Length not match\");\n        int256 partyBAvailableBalance = LibAccount.partyBAvailableBalanceForLiquidation(\n            upnlSig.upnlPartyB,\n            msg.sender,\n            partyA\n        );\n        int256 partyAAvailableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            upnlSig.upnlPartyA,\n            partyA\n        );\n        uint256 epochDuration;\n        uint256 windowTime;\n        for (uint256 i = 0; i < quoteIds.length; i++) {\n            Quote storage quote = QuoteStorage.layout().quotes[quoteIds[i]];\n            require(quote.partyA == partyA, \"PartyBFacet: Invalid quote\");\n            require(quote.partyB == msg.sender, \"PartyBFacet: Sender isn't partyB of quote\");\n            require(\n                quote.quoteStatus == QuoteStatus.OPENED ||\n                    quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n                \"PartyBFacet: Invalid state\"\n            );\n            epochDuration = SymbolStorage.layout().symbols[quote.symbolId].fundingRateEpochDuration;\n            require(epochDuration > 0, \"PartyBFacet: Zero funding epoch duration\");\n            windowTime = SymbolStorage.layout().symbols[quote.symbolId].fundingRateWindowTime;\n            uint256 latestEpochTimestamp = (block.timestamp / epochDuration) * epochDuration;\n            uint256 paidTimestamp;\n            if (block.timestamp <= latestEpochTimestamp + windowTime) {\n                require(\n                    latestEpochTimestamp > quote.lastFundingPaymentTimestamp,\n                    \"PartyBFacet: Funding already paid for this window\"\n                );\n                paidTimestamp = latestEpochTimestamp;\n            } else {\n                uint256 nextEpochTimestamp = latestEpochTimestamp + epochDuration;\n                require(\n                    block.timestamp >= nextEpochTimestamp - windowTime,\n                    \"PartyBFacet: Current timestamp is out of window\"\n                );\n                require(\n                    nextEpochTimestamp > quote.lastFundingPaymentTimestamp,\n                    \"PartyBFacet: Funding already paid for this window\"\n                );\n                paidTimestamp = nextEpochTimestamp;\n            }\n            if (rates[i] >= 0) {\n                require(\n                    uint256(rates[i]) <= quote.maxFundingRate,\n                    \"PartyBFacet: High funding rate\"\n                );\n                uint256 priceDiff = (quote.openedPrice * uint256(rates[i])) / 1e18;\n                if (quote.positionType == PositionType.LONG) {\n                    quote.openedPrice += priceDiff;\n                } else {\n                    quote.openedPrice -= priceDiff;\n                }\n                partyAAvailableBalance -= int256(LibQuote.quoteOpenAmount(quote) * priceDiff / 1e18);\n                partyBAvailableBalance += int256(LibQuote.quoteOpenAmount(quote) * priceDiff / 1e18);\n            } else {\n                require(\n                    uint256(-rates[i]) <= quote.maxFundingRate,\n                    \"PartyBFacet: High funding rate\"\n                );\n                uint256 priceDiff = (quote.openedPrice * uint256(-rates[i])) / 1e18;\n                if (quote.positionType == PositionType.LONG) {\n                    quote.openedPrice -= priceDiff;\n                } else {\n                    quote.openedPrice += priceDiff;\n                }\n                partyAAvailableBalance += int256(LibQuote.quoteOpenAmount(quote) * priceDiff / 1e18);\n                partyBAvailableBalance -= int256(LibQuote.quoteOpenAmount(quote) * priceDiff / 1e18);\n            }\n            quote.lastFundingPaymentTimestamp = paidTimestamp;\n        }\n        require(partyAAvailableBalance >= 0, \"PartyBFacet: PartyA will be insolvent\");\n        require(partyBAvailableBalance >= 0, \"PartyBFacet: PartyB will be insolvent\");\n        AccountStorage.layout().partyBNonces[msg.sender][partyA] += 1;\n        AccountStorage.layout().partyANonces[partyA] += 1;\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibSolvency.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary PartyAFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function sendQuote(\n        address[] memory partyBsWhiteList,\n        uint256 symbolId,\n        PositionType positionType,\n        OrderType orderType,\n        uint256 price,\n        uint256 quantity,\n        uint256 cva,\n        uint256 mm,\n        uint256 lf,\n        uint256 maxFundingRate,\n        uint256 deadline,\n        SingleUpnlAndPriceSig memory upnlSig\n    ) internal returns (uint256 currentId) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n\n        require(\n            quoteLayout.partyAPendingQuotes[msg.sender].length < maLayout.pendingQuotesValidLength,\n            \"PartyAFacet: Number of pending quotes out of range\"\n        );\n        require(symbolLayout.symbols[symbolId].isValid, \"PartyAFacet: Symbol is not valid\");\n        require(deadline >= block.timestamp, \"PartyAFacet: Low deadline\");\n\n        LockedValues memory lockedValues = LockedValues(cva, mm, lf);\n        uint256 tradingPrice = orderType == OrderType.LIMIT ? price : upnlSig.price;\n        uint256 notionalValue = (quantity * tradingPrice) / 1e18;\n        require(\n            lockedValues.total() <= notionalValue,\n            \"PartyAFacet: Leverage can't be lower than one\"\n        );\n\n        require(\n            lockedValues.lf >=\n                (symbolLayout.symbols[symbolId].minAcceptablePortionLF * lockedValues.total()) /\n                    1e18,\n            \"PartyAFacet: LF is not enough\"\n        );\n\n        require(\n            lockedValues.total() >= symbolLayout.symbols[symbolId].minAcceptableQuoteValue,\n            \"PartyAFacet: Quote value is low\"\n        );\n        for (uint8 i = 0; i < partyBsWhiteList.length; i++) {\n            require(\n                partyBsWhiteList[i] != msg.sender,\n                \"PartyAFacet: Sender isn't allowed in partyBWhiteList\"\n            );\n        }\n\n        LibMuon.verifyPartyAUpnlAndPrice(upnlSig, msg.sender, symbolId);\n\n        int256 availableBalance = LibAccount.partyAAvailableForQuote(upnlSig.upnl, msg.sender);\n        require(availableBalance > 0, \"PartyAFacet: Available balance is lower than zero\");\n        require(\n            uint256(availableBalance) >=\n                lockedValues.total() +\n                    ((quantity * tradingPrice * symbolLayout.symbols[symbolId].tradingFee) / 1e36),\n            \"PartyAFacet: insufficient available balance\"\n        );\n\n        // lock funds the in middle of way\n        accountLayout.pendingLockedBalances[msg.sender].add(lockedValues);\n        currentId = ++quoteLayout.lastId;\n        accountLayout.partyANonces[msg.sender] += 1;\n\n        // create quote.\n        Quote memory quote = Quote({\n            id: currentId,\n            partyBsWhiteList: partyBsWhiteList,\n            symbolId: symbolId,\n            positionType: positionType,\n            orderType: orderType,\n            openedPrice: 0,\n            initialOpenedPrice: 0,\n            requestedOpenPrice: price,\n            marketPrice: upnlSig.price,\n            quantity: quantity,\n            closedAmount: 0,\n            lockedValues: lockedValues,\n            initialLockedValues: lockedValues,\n            maxFundingRate: maxFundingRate,\n            partyA: msg.sender,\n            partyB: address(0),\n            quoteStatus: QuoteStatus.PENDING,\n            avgClosedPrice: 0,\n            requestedClosePrice: 0,\n            parentId: 0,\n            createTimestamp: block.timestamp,\n            statusModifyTimestamp: block.timestamp,\n            quantityToClose: 0,\n            lastFundingPaymentTimestamp: 0,\n            deadline: deadline,\n            tradingFee: symbolLayout.symbols[symbolId].tradingFee\n        });\n        quoteLayout.quoteIdsOf[msg.sender].push(currentId);\n        quoteLayout.partyAPendingQuotes[msg.sender].push(currentId);\n        quoteLayout.quotes[currentId] = quote;\n        \n        accountLayout.allocatedBalances[msg.sender] -= LibQuote.getTradingFee(currentId);\n    }\n\n    function requestToCancelQuote(uint256 quoteId) internal returns (QuoteStatus result) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(\n            quote.quoteStatus == QuoteStatus.PENDING || quote.quoteStatus == QuoteStatus.LOCKED,\n            \"PartyAFacet: Invalid state\"\n        );\n\n        if (block.timestamp > quote.deadline) {\n            result = LibQuote.expireQuote(quoteId);\n        } else if (quote.quoteStatus == QuoteStatus.PENDING) {\n            quote.quoteStatus = QuoteStatus.CANCELED;\n            accountLayout.allocatedBalances[quote.partyA] += LibQuote.getTradingFee(quote.id);\n            accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n            LibQuote.removeFromPartyAPendingQuotes(quote);\n            result = QuoteStatus.CANCELED;\n        } else {\n            // Quote is locked\n            quote.quoteStatus = QuoteStatus.CANCEL_PENDING;\n            result = QuoteStatus.CANCEL_PENDING;\n        }\n        quote.statusModifyTimestamp = block.timestamp;\n    }\n\n    function requestToClosePosition(\n        uint256 quoteId,\n        uint256 closePrice,\n        uint256 quantityToClose,\n        OrderType orderType,\n        uint256 deadline\n    ) internal {\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(quote.quoteStatus == QuoteStatus.OPENED, \"PartyAFacet: Invalid state\");\n        require(deadline >= block.timestamp, \"PartyAFacet: Low deadline\");\n        require(\n            LibQuote.quoteOpenAmount(quote) >= quantityToClose,\n            \"PartyAFacet: Invalid quantityToClose\"\n        );\n\n        // check that remaining position is not too small\n        if (LibQuote.quoteOpenAmount(quote) > quantityToClose) {\n            require(\n                ((LibQuote.quoteOpenAmount(quote) - quantityToClose) * quote.lockedValues.total()) /\n                    LibQuote.quoteOpenAmount(quote) >=\n                    symbolLayout.symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"PartyAFacet: Remaining quote value is low\"\n            );\n        }\n\n        quote.statusModifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.CLOSE_PENDING;\n        quote.requestedClosePrice = closePrice;\n        quote.quantityToClose = quantityToClose;\n        quote.orderType = orderType;\n        quote.deadline = deadline;\n    }\n\n    function requestToCancelCloseRequest(uint256 quoteId) internal returns (QuoteStatus) {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(quote.quoteStatus == QuoteStatus.CLOSE_PENDING, \"PartyAFacet: Invalid state\");\n        if (block.timestamp > quote.deadline) {\n            LibQuote.expireQuote(quoteId);\n            return QuoteStatus.OPENED;\n        } else {\n            quote.statusModifyTimestamp = block.timestamp;\n            quote.quoteStatus = QuoteStatus.CANCEL_CLOSE_PENDING;\n            return QuoteStatus.CANCEL_CLOSE_PENDING;\n        }\n    }\n\n    function forceCancelQuote(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(quote.quoteStatus == QuoteStatus.CANCEL_PENDING, \"PartyAFacet: Invalid state\");\n        require(\n            block.timestamp > quote.statusModifyTimestamp + maLayout.forceCancelCooldown,\n            \"PartyAFacet: Cooldown not reached\"\n        );\n        quote.statusModifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.CANCELED;\n        accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n        accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n\n        // send trading Fee back to partyA\n        accountLayout.allocatedBalances[quote.partyA] += LibQuote.getTradingFee(quote.id);\n\n        LibQuote.removeFromPendingQuotes(quote);\n    }\n\n    function forceCancelCloseRequest(uint256 quoteId) internal {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"PartyAFacet: Invalid state\"\n        );\n        require(\n            block.timestamp > quote.statusModifyTimestamp + maLayout.forceCancelCloseCooldown,\n            \"PartyAFacet: Cooldown not reached\"\n        );\n\n        quote.statusModifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.OPENED;\n        quote.requestedClosePrice = 0;\n        quote.quantityToClose = 0;\n    }\n\n    function forceClosePosition(uint256 quoteId, PairUpnlAndPriceSig memory upnlSig) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        uint256 filledAmount = quote.quantityToClose;\n        require(quote.quoteStatus == QuoteStatus.CLOSE_PENDING, \"PartyAFacet: Invalid state\");\n        require(\n            block.timestamp > quote.statusModifyTimestamp + maLayout.forceCloseCooldown,\n            \"PartyAFacet: Cooldown not reached\"\n        );\n        require(block.timestamp <= quote.deadline, \"PartyBFacet: Quote is expired\");\n        require(\n            quote.orderType == OrderType.LIMIT,\n            \"PartyBFacet: Quote's order type should be LIMIT\"\n        );\n        if (quote.positionType == PositionType.LONG) {\n            require(\n                upnlSig.price >=\n                    quote.requestedClosePrice +\n                        (quote.requestedClosePrice * maLayout.forceCloseGapRatio) /\n                        1e18,\n                \"PartyAFacet: Requested close price not reached\"\n            );\n        } else {\n            require(\n                upnlSig.price <=\n                    quote.requestedClosePrice -\n                        (quote.requestedClosePrice * maLayout.forceCloseGapRatio) /\n                        1e18,\n                \"PartyAFacet: Requested close price not reached\"\n            );\n        }\n\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n        LibSolvency.isSolventAfterClosePosition(\n            quoteId,\n            filledAmount,\n            upnlSig.price,\n            upnlSig\n        );\n        accountLayout.partyANonces[quote.partyA] += 1;\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        LibQuote.closeQuote(quote, filledAmount, upnlSig.price);\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/libraries/LibMuon.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../libraries/LibMuonV04ClientBase.sol\";\nimport \"../storages/MuonStorage.sol\";\nimport \"../storages/AccountStorage.sol\";\n\nlibrary LibMuon {\n    using ECDSA for bytes32;\n\n    function getChainId() internal view returns (uint256 id) {\n        assembly {\n            id := chainid()\n        }\n    }\n\n    // CONTEXT for commented out lines\n    // We're utilizing muon signatures for asset pricing and user uPNLs calculations. \n    // Even though these signatures are necessary for full testing of the system, particularly when invoking various methods.\n    // The process of creating automated functional signature for tests has proven to be either impractical or excessively time-consuming. therefore, we've established commenting out the necessary code as a workaround specifically for testing.\n    // Essentially, during testing, we temporarily disable the code sections responsible for validating these signatures. The sections I'm referring to are located within the LibMuon file. Specifically, the body of the 'verifyTSSAndGateway' method is a prime candidate for temporary disablement. In addition, several 'require' statements within other functions of this file, which examine the signatures' expiration status, also need to be temporarily disabled.\n    // However, it is crucial to note that these lines should not be disabled in the production deployed version. \n    // We emphasize this because they are only disabled for testing purposes.\n\n    function verifyTSSAndGateway(\n        bytes32 hash,\n        SchnorrSign memory sign,\n        bytes memory gatewaySignature\n    ) internal view {\n//       bool verified = LibMuonV04ClientBase.muonVerify(\n//           uint256(hash),\n//           sign,\n//           MuonStorage.layout().muonPublicKey\n//       );\n//       require(verified, \"LibMuon: TSS not verified\");\n//\n//       hash = hash.toEthSignedMessageHash();\n//       address gatewaySignatureSigner = hash.recover("
    }
  ]
}