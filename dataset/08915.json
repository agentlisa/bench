{
  "Title": "[M-01] compromised `owner` can drain funds from`VeTokenMinter.sol`",
  "Content": "_Submitted by SmartSek, also found by ch13fd357r0y3r_\n\nCompromised `owner` can `withdraw()` entire balance of `VeTokenMinter.sol` to any other account.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L77-L81>\n\n```\nfunction withdraw(address _destination, uint256 _amount) external onlyOwner {\n    veToken.safeTransfer(_destination, _amount);\n\n    emit Withdraw(_destination, _amount);\n}\n```\n\nThe `owner` can choose any `_destination` and `_amount` to send funds to with no delay or limit.\nThese funds could be used to call `Booster.deposit()` and then `Booster.withdraw()`(withdraw) the equivalent in `lptoken`.\n\n### Recommended Mitigation Steps\n\nConsider implementing a timelock on `VeTokenMinter.withdraw()` and changing the `destination` to an address that `owner` has no control over.\n\nExample of similar issues illustrating the severity of the finding can be found [here (H-09)](https://code4rena.com/reports/2022-01-insure).\n\n**[solvetony (veToken Finance) acknowledged and commented](https://github.com/code-423n4/2022-05-vetoken-findings/issues/69#issuecomment-1156609426):**\n > Requires compromised owner.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-05-vetoken-findings/issues/69#issuecomment-1175569241):**\n > Finding is valid, but contingent on a Malicious or Compromised Admin, Medium Severity is more appropriate.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-vetoken-finance-contest",
  "Code": [
    {
      "filename": "contracts/VeTokenMinter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract VeTokenMinter is Ownable {\n    using SafeERC20 for ERC20;\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 public constant maxSupply = 30 * 1000000 * 1e18; //30mil\n    ERC20 public veToken;\n    EnumerableSet.AddressSet internal operators;\n    uint256 public totalCliffs;\n    uint256 public reductionPerCliff;\n    uint256 public totalSupply;\n    mapping(address => uint256) public veAssetWeights;\n    uint256 public totalWeight;\n\n    event Withdraw(address destination, uint256 amount);\n\n    constructor(address veTokenAddress) {\n        veToken = ERC20(veTokenAddress);\n        totalCliffs = 1000;\n        reductionPerCliff = maxSupply.div(totalCliffs);\n    }\n\n    function addOperator(address _newOperator) public onlyOwner {\n        operators.add(_newOperator);\n    }\n\n    function removeOperator(address _operator) public onlyOwner {\n        operators.remove(_operator);\n    }\n\n    ///@dev weight is 10**25 precision\n    function updateveAssetWeight(address veAssetOperator, uint256 newWeight) external onlyOwner {\n        require(operators.contains(veAssetOperator), \"not an veAsset operator\");\n        totalWeight -= veAssetWeights[veAssetOperator];\n        veAssetWeights[veAssetOperator] = newWeight;\n        totalWeight += newWeight;\n    }\n\n    function mint(address _to, uint256 _amount) external {\n        require(operators.contains(_msgSender()), \"not an operator\");\n\n        uint256 supply = totalSupply;\n\n        //use current supply to gauge cliff\n        //this will cause a bit of overflow into the next cliff range\n        //but should be within reasonable levels.\n        //requires a max supply check though\n        uint256 cliff = supply.div(reductionPerCliff);\n        //mint if below total cliffs\n        if (cliff < totalCliffs) {\n            //for reduction% take inverse of current cliff\n            uint256 reduction = totalCliffs.sub(cliff);\n            //reduce\n            _amount = _amount.mul(reduction).div(totalCliffs);\n\n            //supply cap check\n            uint256 amtTillMax = maxSupply.sub(supply);\n            if (_amount > amtTillMax) {\n                _amount = amtTillMax;\n            }\n\n            //mint\n            veToken.safeTransfer(_to, _amount);\n            totalSupply += _amount;\n        }\n    }\n\n    function withdraw(address _destination, uint256 _amount) external onlyOwner {\n        veToken.safeTransfer(_destination, _amount);\n\n        emit Withdraw(_destination, _amount);\n    }\n}"
    }
  ]
}