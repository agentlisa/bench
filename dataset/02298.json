{
  "Title": "M-16: Hats can be overwritten",
  "Content": "# Issue M-16: Hats can be overwritten \n\nSource: https://github.com/sherlock-audit/2023-02-hats-judging/issues/11 \n\n## Found by \nAllarious, carrot\n\n## Summary\nChild hats can be created under a non-existent admin. Creating the admin allows overwriting the properties of the child-hats, which goes against the immutability of hats.\n## Vulnerability Detail\nWhen creating a hat, the code never checks if the admin passed actually exists or not. Thus it allows the creation of a hat under an admin who hasn't been created yet. \nLets say top hat is 1.0.0, and we call admin the hat 1.1.0 and child is hat 1.1.1. The child can be created before admin. When admin (1.1.0) is created after this, it overwrites the  `lastHatId` of the admin, as shown here\nhttps://github.com/Hats-Protocol/hats-protocol/blob/fafcfdf046c0369c1f9e077eacd94a328f9d7af0/src/Hats.sol#L421-L439\n```solidity\n    function _createHat(\n        uint256 _id,\n        string calldata _details,\n        uint32 _maxSupply,\n        address _eligibility,\n        address _toggle,\n        bool _mutable,\n        string calldata _imageURI\n    ) internal returns (Hat memory hat) {\n        hat.details = _details;\n        hat.maxSupply = _maxSupply;\n        hat.eligibility = _eligibility;\n        hat.toggle = _toggle;\n        hat.imageURI = _imageURI;\n        hat.config = _mutable ? uint96(3 << 94) : uint96(1 << 95);\n        _hats[_id] = hat;\n\n\n        emit HatCreated(_id, _details, _maxSupply, _eligibility, _toggle, _mutable, _imageURI);\n    }\n```\nNow, the next eligible hat for this admin is 1.1.1, which is a hat that was already created and minted. This can allow the admin to change the properties of the child, even if the child hat was previously immutable. \nThis contradicts the immutability of hats, and can be used to rug users in multiple ways, and is thus classified as high severity.\nThis attack can be carried out by any hat wearer on their child tree, mutating their properties.\n## Impact\n\n## Code Snippet\nThe attack can be demonstrated with the following code which carries out the following steps:\n1. Child 1.1.1 is created with max supply 10, and false mutability. Thus its properties should be locked.\n2. Admin 1.1.0 is created\n3. Child 1.1.1 is re-created, now with supply of 20, overwriting its previous instance\n4. The children are shown to be on the same hatId, and their max supplies are shown to be different values.\n```solidity\nfunction testATTACKoverwrite() public {\n        vm.startPrank(address(topHatWearer));\n        uint256 emptyAdmin = hats.getNextId(topHatId);\n        uint256 child1 = hats.createHat(\n            emptyAdmin,\n            _details,\n            10,\n            _eligibility,\n            _toggle,\n            false,\n            secondHatImageURI\n        );\n        (, uint256 maxsup, , , , , , , ) = hats.viewHat(child1);\n        assertEq(maxsup, 10);\n        hats.createHat(\n            topHatId,\n            _details,\n            _maxSupply,\n            _eligibility,\n            _toggle,\n            false,\n            secondHatImageURI\n        );\n        uint256 child2 = hats.createHat(\n            emptyAdmin,\n            _details,\n            20,\n            _eligibility,\n            _toggle,\n            false,\n            secondHatImageURI\n        );\n        (,  maxsup, , , , , , , ) = hats.viewHat(child1);\n        assertEq(child1, child2);\n        assertEq(maxsup, 20);\n    }\n```\n## Tool used\n\nManual Review\n\n## Recommendation\nCheck if admin exists, before minting by checking any of its properties against default values\n```solidity\nrequire(_hats[admin].maxSupply > 0, \"Admin not created\")\n```\n\n\n## Discussion\n\n**spengrah**\n\nThe ability for an admin to skip levels when creating hats is a desired feature. However, we definitely do not want those hats to be able to overwritten if/when the skipped admins are created. Therefore, what we need to do is not overwrite a hat's `lastHatId` property when creating it.\n\nFor example, add something like the following to `_createHat`:\n\n```solidity\nuint16 lastId = hat.lastHatId;\nif (lastId > 0) hat.lastHatId = lastId;\n```\n\n\n**spengrah**\n\nhttps://github.com/Hats-Protocol/hats-protocol/pull/109\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/48",
  "Code": [
    {
      "filename": "src/Hats.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\n// Copyright (C) 2023 Haberdasher Labs\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.13;\n\nimport { ERC1155 } from \"lib/ERC1155/ERC1155.sol\";\n// import { console2 } from \"forge-std/Test.sol\"; //remove after testing\nimport \"./Interfaces/IHats.sol\";\nimport \"./HatsIdUtilities.sol\";\nimport \"./Interfaces/IHatsToggle.sol\";\nimport \"./Interfaces/IHatsEligibility.sol\";\nimport \"solbase/utils/Base64.sol\";\nimport \"solbase/utils/LibString.sol\";\n\n/// @title Hats Protocol\n/// @notice Hats are DAO-native, revocable, and programmable roles that are represented as non-transferable ERC-1155-similar tokens for composability\n/// @dev This is a multitenant contract that can manage all hats for a given chain. While it fully implements the ERC1155 interface, it does not fully comply with the ERC1155 standard.\n/// @author Haberdasher Labs\ncontract Hats is IHats, ERC1155, HatsIdUtilities {\n    /*//////////////////////////////////////////////////////////////\n                              HATS DATA MODELS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice A Hat object containing the hat's properties\n    /// @dev The members are packed to minimize storage costs\n    /// @custom:member eligibility Module that rules on wearer eligibiliy and standing\n    /// @custom:member maxSupply The max number of hats with this id that can exist\n    /// @custom:member supply The number of this hat that currently exist\n    /// @custom:member lastHatId Indexes how many different child hats an admin has\n    /// @custom:member toggle Module that sets the hat's status\n    /**\n     * @custom:member config Holds status and other settings, with this bitwise schema:\n     *\n     *  0th bit  | `active` status; can be altered by toggle\n     *  1        | `mutable` setting\n     *  2 - 95   | unassigned\n     */\n    /// @custom:member details Holds arbitrary metadata about the hat\n    /// @custom:member imageURI A uri pointing to an image for the hat\n    struct Hat {\n        // 1st storage slot\n        address eligibility; // ─┐ 20\n        uint32 maxSupply; //     │ 4\n        uint32 supply; //        │ 4\n        uint16 lastHatId; //    ─┘ 2\n        // 2nd slot\n        address toggle; //      ─┐ 20\n        uint96 config; //       ─┘ 12\n        // 3rd+ slot (optional)\n        string details;\n        string imageURI;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              HATS STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The name of the contract, typically including the version\n    string public name;\n\n    /// @notice The first 4 bytes of the id of the last tophat created.\n    uint32 public lastTopHatId; // first tophat id starts at 1\n\n    /// @notice The fallback image URI for hat tokens with no `imageURI` specified in their branch\n    string public baseImageURI;\n\n    /// @dev Internal mapping of hats to hat ids. See HatsIdUtilities.sol for more info on how hat ids work\n    mapping(uint256 => Hat) internal _hats; // key: hatId => value: Hat struct\n\n    /// @notice Mapping of wearers in bad standing for certain hats\n    /// @dev Used by external contracts to trigger penalties for wearers in bad standing\n    ///      hatId => wearer => !standing\n    mapping(uint256 => mapping(address => bool)) public badStandings;\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice All arguments are immutable; they can only be set once during construction\n    /// @param _name The name of this contract, typically including the version\n    /// @param _baseImageURI The fallback image URI\n    constructor(string memory _name, string memory _baseImageURI) {\n        name = _name;\n        baseImageURI = _baseImageURI;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              HATS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Creates and mints a Hat that is its own admin, i.e. a \"topHat\"\n    /// @dev A topHat has no eligibility and no toggle\n    /// @param _target The address to which the newly created topHat is minted\n    /// @param _details A description of the Hat [optional]\n    /// @param _imageURI The image uri for this top hat and the fallback for its\n    ///                  downstream hats [optional]\n    /// @return topHatId The id of the newly created topHat\n    function mintTopHat(address _target, string calldata _details, string calldata _imageURI)\n        public\n        returns (uint256 topHatId)\n    {\n        // create hat\n\n        topHatId = uint256(++lastTopHatId) << 224;\n\n        _createHat(\n            topHatId,\n            _details, // details\n            1, // maxSupply = 1\n            address(0), // there is no eligibility\n            address(0), // it has no toggle\n            false, // its immutable\n            _imageURI\n        );\n\n        _mintHat(_target, topHatId);\n    }\n\n    /// @notice Creates a new hat. The msg.sender must wear the `_admin` hat.\n    /// @dev Initializes a new Hat struct, but does not mint any tokens.\n    /// @param _details A description of the Hat\n    /// @param _maxSupply The total instances of the Hat that can be worn at once\n    /// @param _admin The id of the Hat that will control who wears the newly created hat\n    /// @param _eligibility The address that can report on the Hat wearer's status\n    /// @param _toggle The address that can deactivate the Hat\n    /// @param _mutable Whether the hat's properties are changeable after creation\n    /// @param _imageURI The image uri for this hat and the fallback for its\n    ///                  downstream hats [optional]\n    /// @return newHatId The id of the newly created Hat\n    function createHat(\n        uint256 _admin,\n        string calldata _details,\n        uint32 _maxSupply,\n        address _eligibility,\n        address _toggle,\n        bool _mutable,\n        string calldata _imageURI\n    ) public returns (uint256 newHatId) {\n        if (uint16(_admin) > 0) {\n            revert MaxLevelsReached();\n        }\n\n        if (_eligibility == address(0)) revert ZeroAddress();\n        if (_toggle == address(0)) revert ZeroAddress();\n\n        newHatId = getNextId(_admin);\n\n        // to create a hat, you must be wearing one of its admin hats\n        _checkAdmin(newHatId);\n\n        // create the new hat\n        _createHat(newHatId, _details, _maxSupply, _eligibility, _toggle, _mutable, _imageURI);\n\n        // increment _admin.lastHatId\n        // use the overflow check to constrain to correct number of hats per level\n        ++_hats[_admin].lastHatId;\n    }\n\n    /// @notice Creates new hats in batch. The msg.sender must be an admin of each hat.\n    /// @dev This is a convenience function that loops through the arrays and calls `createHat`.\n    /// @param _admins Array of ids of admins for each hat to create\n    /// @param _details Array of details for each hat to create\n    /// @param _maxSupplies Array of supply caps for each hat to create\n    /// @param _eligibilityModules Array of eligibility module addresses for each hat to\n    /// create\n    /// @param _toggleModules Array of toggle module addresses for each hat to create\n    /// @param _mutables Array of mutable flags for each hat to create\n    /// @param _imageURIs Array of imageURIs for each hat to create\n    /// @return success True if all createHat calls succeeded\n    function batchCreateHats(\n        uint256[] calldata _admins,\n        string[] calldata _details,\n        uint32[] calldata _maxSupplies,\n        address[] memory _eligibilityModules,\n        address[] memory _toggleModules,\n        bool[] calldata _mutables,\n        string[] calldata _imageURIs\n    ) public returns (bool success) {\n        // check if array lengths are the same\n        uint256 length = _admins.length; // save an MLOAD\n\n        {\n            bool sameLengths = (\n                length == _details.length // details\n                    && length == _maxSupplies.length // supplies\n                    && length == _eligibilityModules.length // eligibility\n                    && length == _toggleModules.length // toggle\n                    && length == _mutables.length // mutable\n                    && length == _imageURIs.length\n            ); // imageURI\n            if (!sameLengths) revert BatchArrayLengthMismatch();\n        }\n\n        // loop through and create each hat\n        for (uint256 i = 0; i < length;) {\n            createHat(\n                _admins[i],\n                _details[i],\n                _maxSupplies[i],\n                _eligibilityModules[i],\n                _toggleModules[i],\n                _mutables[i],\n                _imageURIs[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        success = true;\n    }\n\n    /// @notice Gets the id of the next child hat of the hat `_admin`\n    /// @dev Does not incrememnt lastHatId\n    /// @param _admin The id of the hat to serve as the admin for the next child hat\n    /// @return nextId The new hat id\n    function getNextId(uint256 _admin) public view returns (uint256 nextId) {\n        uint16 nextHatId = _hats[_admin].lastHatId + 1;\n        nextId = buildHatId(_admin, nextHatId);\n    }\n\n    /// @notice Mints an ERC1155-similar token of the Hat to an eligible recipient, who then \"wears\" the hat\n    /// @dev The msg.sender must wear an admin Hat of `_hatId`, and the recipient must be eligible to wear `_hatId`\n    /// @param _hatId The id of the Hat to mint\n    /// @param _wearer The address to which the Hat is minted\n    /// @return success Whether the mint succeeded\n    function mintHat(uint256 _hatId, address _wearer) public returns (bool success) {\n        Hat storage hat = _hats[_hatId];\n        if (hat.maxSupply == 0) revert HatDoesNotExist(_hatId);\n\n        if (!isEligible(_wearer, _hatId)) revert NotEligible();\n\n        // only the wearer of a hat's admin Hat can mint it\n        _checkAdmin(_hatId);\n\n        if (hat.supply >= hat.maxSupply) {\n            revert AllHatsWorn(_hatId);\n        }\n\n        if (_staticBalanceOf(_wearer, _hatId) > 0) {\n            revert AlreadyWearingHat(_wearer, _hatId);\n        }\n\n        _mintHat(_wearer, _hatId);\n\n        success = true;\n    }\n\n    /// @notice Mints new hats in batch. The msg.sender must be an admin of each hat.\n    /// @dev This is a convenience function that loops through the arrays and calls `mintHat`.\n    /// @param _hatIds Array of ids of hats to mint\n    /// @param _wearers Array of addresses to which the hats will be minted\n    /// @return success True if all mintHat calls succeeded\n    function batchMintHats(uint256[] calldata _hatIds, address[] calldata _wearers) public returns (bool success) {\n        uint256 length = _hatIds.length;\n        if (length != _wearers.length) revert BatchArrayLengthMismatch();\n\n        for (uint256 i = 0; i < length;) {\n            mintHat(_hatIds[i], _wearers[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        success = true;\n    }\n\n    /// @notice Toggles a Hat's status from active to deactive, or vice versa\n    /// @dev The msg.sender must be set as the hat's toggle\n    /// @param _hatId The id of the Hat for which to adjust status\n    /// @param _newStatus The new status to set\n    /// @return toggled Whether the status was toggled\n    function setHatStatus(uint256 _hatId, bool _newStatus) external returns (bool toggled) {\n        Hat storage hat = _hats[_hatId];\n\n        if (msg.sender != hat.toggle) {\n            revert NotHatsToggle();\n        }\n\n        toggled = _processHatStatus(_hatId, _newStatus);\n    }\n\n    /// @notice Checks a hat's toggle module and processes the returned status\n    /// @dev May change the hat's status in storage\n    /// @param _hatId The id of the Hat whose toggle we are checking\n    /// @return toggled Whether there was a new status\n    function checkHatStatus(uint256 _hatId) external returns (bool toggled) {\n        Hat storage hat = _hats[_hatId];\n        bool newStatus;\n\n        bytes memory data = abi.encodeWithSignature(\"getHatStatus(uint256)\", _hatId);\n        (bool success, bytes memory returndata) = hat.toggle.staticcall(data);\n\n        /* \n        * if function call succeeds with data of length == 32, then we know the contract exists \n        * and has the getHatStatus function.\n        * But — since function selectors don't include return types — we still can't assume that the return data is a boolean, \n        * so we treat it as a uint so it will always safely decode without throwing.\n        */\n        if (success && returndata.length == 32) {\n            // check the returndata manually\n            uint256 uintReturndata = abi.decode(returndata, (uint256));\n            // false condition\n            if (uintReturndata == 0) {\n                newStatus = false;\n                // true condition\n            } else if (uintReturndata == 1) {\n                newStatus = true;\n            }\n            // invalid condition\n            else {\n                revert NotHatsToggle();\n            }\n        } else {\n            revert NotHatsToggle();\n        }\n\n        toggled = _processHatStatus(_hatId, newStatus);\n    }\n\n    /// @notice Report from a hat's eligibility on the status of one of its wearers and, if `false`, revoke their hat\n    /// @dev Burns the wearer's hat, if revoked\n    /// @param _hatId The id of the hat\n    /// @param _wearer The address of the hat wearer whose status is being reported\n    /// @param _eligible Whether the wearer is eligible for the hat (will be revoked if\n    /// false)\n    /// @param _standing False if the wearer is no longer in good standing (and potentially should be penalized)\n    /// @return updated Whether the report succeeded\n    function setHatWearerStatus(uint256 _hatId, address _wearer, bool _eligible, bool _standing)\n        external\n        returns (bool updated)\n    {\n        Hat storage hat = _hats[_hatId];\n\n        if (msg.sender != hat.eligibility) {\n            revert NotHatsEligibility();\n        }\n\n        updated = _processHatWearerStatus(_hatId, _wearer, _eligible, _standing);\n    }\n\n    /// @notice Check a hat's eligibility for a report on the status of one of the hat's wearers and, if `false`, revoke their hat\n    /// @dev Burns the wearer's hat, if revoked\n    /// @param _hatId The id of the hat\n    /// @param _wearer The address of the Hat wearer whose status report is being requested\n    /// @return updated Whether the wearer's status was altered\n    function checkHatWearerStatus(uint256 _hatId, address _wearer) public returns (bool updated) {\n        bool eligible;\n        bool standing;\n\n        (bool success, bytes memory returndata) = _hats[_hatId].eligibility.staticcall(\n            abi.encodeWithSignature(\"getWearerStatus(address,uint256)\", _wearer, _hatId)\n        );\n\n        /* \n        * if function call succeeds with data of length == 64, then we know the contract exists \n        * and has the getWearerStatus function (which returns two words).\n        * But — since function selectors don't include return types — we still can't assume that the return data is two booleans, \n        * so we treat it as a uint so it will always safely decode without throwing.\n        */\n        if (success && returndata.length == 64) {\n            // check the returndata manually\n            (uint256 firstWord, uint256 secondWord) = abi.decode(returndata, (uint256, uint256));\n            // returndata is valid\n            if (firstWord < 2 && secondWord < 2) {\n                standing = (secondWord == 1) ? true : false;\n                // never eligible if in bad standing\n                eligible = (standing && firstWord == 1) ? true : false;\n            }\n            // returndata is invalid\n            else {\n                revert NotHatsEligibility();\n            }\n        } else {\n            revert NotHatsEligibility();\n        }\n\n        updated = _processHatWearerStatus(_hatId, _wearer, eligible, standing);\n    }\n\n    /// @notice Stop wearing a hat, aka \"renounce\" it\n    /// @dev Burns the msg.sender's hat\n    /// @param _hatId The id of the Hat being renounced\n    function renounceHat(uint256 _hatId) external {\n        if (_staticBalanceOf(msg.sender, _hatId) < 1) {\n            revert NotHatWearer();\n        }\n        // remove the hat\n        _burnHat(msg.sender, _hatId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              HATS INTERNAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Internal call for creating a new hat\n    /// @dev Initializes a new Hat struct, but does not mint any tokens\n    /// @param _id ID of the hat to be stored\n    /// @param _details A description of the hat\n    /// @param _maxSupply The total instances of the Hat that can be worn at once\n    /// @param _eligibility The address that can report on the Hat wearer's status\n    /// @param _toggle The address that can deactivate the hat [optional]\n    /// @param _mutable Whether the hat's properties are changeable after creation\n    /// @param _imageURI The image uri for this top hat and the fallback for its\n    ///                  downstream hats [optional]\n    /// @return hat The contents of the newly created hat\n    function _createHat(\n        uint256 _id,\n        string calldata _details,\n        uint32 _maxSupply,\n        address _eligibility,\n        address _toggle,\n        bool _mutable,\n        string calldata _imageURI\n    ) internal returns (Hat memory hat) {\n        hat.details = _details;\n        hat.maxSupply = _maxSupply;\n        hat.eligibility = _eligibility;\n        hat.toggle = _toggle;\n        hat.imageURI = _imageURI;\n        hat.config = _mutable ? uint96(3 << 94) : uint96(1 << 95);\n        _hats[_id] = hat;\n\n        emit HatCreated(_id, _details, _maxSupply, _eligibility, _toggle, _mutable, _imageURI);\n    }\n\n    /// @notice Internal function to process hat status\n    /// @dev Updates a hat's status if different from current\n    /// @param _hatId The id of the Hat in quest\n    /// @param _newStatus The status to potentially change to\n    /// @return updated - Whether the status was updated\n    function _processHatStatus(uint256 _hatId, bool _newStatus) internal returns (bool updated) {\n        // optimize later\n        Hat storage hat = _hats[_hatId];\n\n        if (_newStatus != _getHatStatus(hat)) {\n            _setHatStatus(hat, _newStatus);\n            emit HatStatusChanged(_hatId, _newStatus);\n            updated = true;\n        }\n    }\n\n    /// @notice Internal call to process wearer status from the eligibility module\n    /// @dev Burns the wearer's Hat token if _eligible is false, and updates badStandings\n    /// state if necessary\n    /// @param _hatId The id of the Hat to revoke\n    /// @param _wearer The address of the wearer in question\n    /// @param _eligible Whether _wearer is eligible for the Hat (if false, this function\n    /// will revoke their Hat)\n    /// @param _standing Whether _wearer is in good standing (to be recorded in storage)\n    /// @return updated Whether the wearer standing was updated\n    function _processHatWearerStatus(uint256 _hatId, address _wearer, bool _eligible, bool _standing)\n        internal\n        returns (bool updated)\n    {\n        // revoke/burn the hat if _wearer has a positive balance\n        if (_staticBalanceOf(_wearer, _hatId) > 0) {\n            // always ineligible if in bad standing\n            if (!_eligible || !_standing) {\n                _burnHat(_wearer, _hatId);\n            }\n        }\n\n        // record standing for use by other contracts\n        // note: here, standing and badStandings are opposite\n        // i.e. if standing (true = good standing)\n        // then badStandings[_hatId][wearer] will be false\n        // if they are different, then something has changed, and we need to update\n        // badStandings marker\n        if (_standing == badStandings[_hatId][_wearer]) {\n            badStandings[_hatId][_wearer] = !_standing;\n            updated = true;\n\n            emit WearerStandingChanged(_hatId, _wearer, _standing);\n        }\n    }\n\n    /// @notice Internal function to set a hat's status in storage\n    /// @dev Flips the 0th bit of _hat.config via bitwise operation\n    /// @param _hat The hat object\n    /// @param _status The status to set for the hat\n    function _setHatStatus(Hat storage _hat, bool _status) internal {\n        if (_status) {\n            _hat.config |= uint96(1 << 95);\n        } else {\n            _hat.config &= ~uint96(1 << 95);\n        }\n    }\n\n    /**\n     * @notice Internal function to retrieve an account's internal \"static\" balance directly from internal storage,\n     * @dev This function bypasses the dynamic `_isActive` and `_isEligible` checks\n     * @param _account The account to check\n     * @param _hatId The hat to check\n     * @return staticBalance The account's static of the hat, from internal storage\n     */\n    function _staticBalanceOf(address _account, uint256 _hatId) internal view returns (uint256 staticBalance) {\n        staticBalance = _balanceOf[_account][_hatId];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              HATS ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Checks whether msg.sender is an admin of a hat, and reverts if not\n    function _checkAdmin(uint256 _hatId) internal view {\n        if (!isAdminOfHat(msg.sender, _hatId)) {\n            revert NotAdmin(msg.sender, _hatId);\n        }\n    }\n\n    /// @notice checks whether the msg.sender is either an admin or wearer or a hat, and reverts the appropriate error if not\n    function _checkAdminOrWearer(uint256 _hatId) internal view {\n        if (!isAdminOfHat(msg.sender, _hatId) && !isWearerOfHat(msg.sender, _hatId)) {\n            revert NotAdminOrWearer();\n        }\n    }\n\n    /// @notice Transfers a hat from one wearer to another eligible wearer\n    /// @dev The hat must be mutable, and the transfer must be initiated by an admin\n    /// @param _hatId The hat in question\n    /// @param _from The current wearer\n    /// @param _to The new wearer\n    function transferHat(uint256 _hatId, address _from, address _to) public {\n        _checkAdmin(_hatId);\n\n        // cannot transfer immutable hats, except for tophats, which can always transfer themselves\n        if (!isTopHat(_hatId)) {\n            if (!_isMutable(_hats[_hatId])) revert Immutable();\n        }\n\n        // Checks storage instead of `isWearerOfHat` since admins may want to transfer revoked Hats to new wearers\n        if (_staticBalanceOf(_from, _hatId) < 1) {\n            revert NotHatWearer();\n        }\n\n        // Check if recipient is already wearing hat; also checks storage to maintain balance == 1 invariant\n        if (_staticBalanceOf(_to, _hatId) > 0) {\n            revert AlreadyWearingHat(_to, _hatId);\n        }\n\n        if (!isEligible(_to, _hatId)) revert NotEligible();\n\n        //Adjust balances\n        _balanceOf[_from][_hatId] = 0;\n        _balanceOf[_to][_hatId] = 1;\n\n        emit TransferSingle(msg.sender, _from, _to, _hatId, 1);\n    }\n\n    /// @notice Set a mutable hat to immutable\n    /// @dev Sets the second bit of hat.config to 0\n    /// @param _hatId The id of the Hat to make immutable\n    function makeHatImmutable(uint256 _hatId) external {\n        _checkAdmin(_hatId);\n\n        Hat storage hat = _hats[_hatId];\n\n        if (!_isMutable(hat)) {\n            revert Immutable();\n        }\n\n        hat.config &= ~uint96(1 << 94);\n\n        emit HatMutabilityChanged(_hatId);\n    }\n\n    /// @notice Change a hat's details\n    /// @dev Hat must be mutable, except for tophats\n    /// @param _hatId The id of the Hat to change\n    /// @param _newDetails The new details\n    function changeHatDetails(uint256 _hatId, string calldata _newDetails) external {\n        _checkAdmin(_hatId);\n        Hat storage hat = _hats[_hatId];\n\n        // a tophat can change its own details, but otherwise only mutable hat details can be changed\n        if (!isTopHat(_hatId)) {\n            if (!_isMutable(hat)) revert Immutable();\n        }\n\n        hat.details = _newDetails;\n\n        emit HatDetailsChanged(_hatId, _newDetails);\n    }\n\n    /// @notice Change a hat's details\n    /// @dev Hat must be mutable\n    /// @param _hatId The id of the Hat to change\n    /// @param _newEligibility The new eligibility module\n    function changeHatEligibility(uint256 _hatId, address _newEligibility) external {\n        if (_newEligibility == address(0)) revert ZeroAddress();\n\n        _checkAdmin(_hatId);\n        Hat storage hat = _hats[_hatId];\n\n        if (!_isMutable(hat)) {\n            revert Immutable();\n        }\n\n        hat.eligibility = _newEligibility;\n\n        emit HatEligibilityChanged(_hatId, _newEligibility);\n    }\n\n    /// @notice Change a hat's details\n    /// @dev Hat must be mutable\n    /// @param _hatId The id of the Hat to change\n    /// @param _newToggle The new toggle module\n    function changeHatToggle(uint256 _hatId, address _newToggle) external {\n        if (_newToggle == address(0)) revert ZeroAddress();\n\n        _checkAdmin(_hatId);\n        Hat storage hat = _hats[_hatId];\n\n        if (!_isMutable(hat)) {\n            revert Immutable();\n        }\n\n        hat.toggle = _newToggle;\n\n        emit HatToggleChanged(_hatId, _newToggle);\n    }\n\n    /// @notice Change a hat's details\n    /// @dev Hat must be mutable, except for tophats\n    /// @param _hatId The id of the Hat to change\n    /// @param _newImageURI The new imageURI\n    function changeHatImageURI(uint256 _hatId, string calldata _newImageURI) external {\n        _checkAdmin(_hatId);\n        Hat storage hat = _hats[_hatId];\n\n        // a tophat can change its own imageURI, but otherwise only mutable hat imageURIs can be changed\n        if (!isTopHat(_hatId)) {\n            if (!_isMutable(hat)) revert Immutable();\n        }\n\n        hat.imageURI = _newImageURI;\n\n        emit HatImageURIChanged(_hatId, _newImageURI);\n    }\n\n    /// @notice Change a hat's details\n    /// @dev Hat must be mutable; new max supply cannot be greater than current supply\n    /// @param _hatId The id of the Hat to change\n    /// @param _newMaxSupply The new max supply\n    function changeHatMaxSupply(uint256 _hatId, uint32 _newMaxSupply) external {\n        _checkAdmin(_hatId);\n        Hat storage hat = _hats[_hatId];\n\n        if (!_isMutable(hat)) {\n            revert Immutable();\n        }\n\n        if (_newMaxSupply < hat.supply) {\n            revert NewMaxSupplyTooLow();\n        }\n\n        if (_newMaxSupply != hat.maxSupply) {\n            hat.maxSupply = _newMaxSupply;\n            emit HatMaxSupplyChanged(_hatId, _newMaxSupply);\n        }\n    }\n\n    /// @notice Submits a request to link a Hat Tree under a parent tree. Requests can be\n    /// submitted by either...\n    ///     a) the wearer of a tophat, previous to any linkage, or\n    ///     b) the admin(s) of an already-linked tophat (aka tree root), where such a\n    ///        request is to move the tree root to another admin within the same parent\n    ///        tree\n    /// @dev A tophat can have at most 1 request at a time. Submitting a new request will\n    ///      replace the existing request.\n    /// @param _topHatDomain The domain of the tophat to link\n    /// @param _requestedAdminHat The hat that will administer the linked tree\n    function requestLinkTopHatToTree(uint32 _topHatDomain, uint256 _requestedAdminHat) external {\n        uint256 fullTopHatId = uint256(_topHatDomain) << 224; // (256 - TOPHAT_ADDRESS_SPACE);\n\n        // The wearer of an unlinked tophat is also the admin of same; once a tophat is linked, its wearer is no longer its admin\n        _checkAdmin(fullTopHatId);\n\n        linkedTreeRequests[_topHatDomain] = _requestedAdminHat;\n        emit TopHatLinkRequested(_topHatDomain, _requestedAdminHat);\n    }\n\n    /// @notice Approve a request to link a Tree under a parent tree\n    /// @dev Requests can only be approved by wearer or an admin of the `_newAdminHat`, and there\n    ///      can only be one link per tree root at a given time.\n    /// @param _topHatDomain The 32 bit domain of the tophat to link\n    /// @param _newAdminHat The hat that will administer the linked tree\n    function approveLinkTopHatToTree(uint32 _topHatDomain, uint256 _newAdminHat) external {\n        // for everything but the last hat level, check the admin of `_newAdminHat`'s theoretical child hat, since either wearer or admin of `_newAdminHat` can approve\n        if (getHatLevel(_newAdminHat) < MAX_LEVELS) {\n            _checkAdmin(buildHatId(_newAdminHat, 1));\n        } else {\n            // the above buildHatId trick doesn't work for the last hat level, so we need to explicitly check both admin and wearer in this case\n            _checkAdminOrWearer(_newAdminHat);\n        }\n\n        // Linkages must be initiated by a request\n        if (_newAdminHat != linkedTreeRequests[_topHatDomain]) revert LinkageNotRequested();\n\n        // remove the request -- ensures all linkages are initialized by unique requests,\n        // except for relinks (see `relinkTopHatWithinTree`)\n        delete linkedTreeRequests[_topHatDomain];\n\n        // execute the link. Replaces existing link, if any.\n        _linkTopHatToTree(_topHatDomain, _newAdminHat);\n    }\n\n    /// @notice Unlink a Tree from the parent tree\n    /// @dev This can only be called by an admin of the tree root\n    /// @param _topHatDomain The 32 bit domain of the tophat to unlink\n    function unlinkTopHatFromTree(uint32 _topHatDomain) external {\n        uint256 fullTopHatId = uint256(_topHatDomain) << 224; // (256 - TOPHAT_ADDRESS_SPACE);\n        _checkAdmin(fullTopHatId);\n\n        delete linkedTreeAdmins[_topHatDomain];\n        emit TopHatLinked(_topHatDomain, 0);\n    }\n\n    /// @notice Move a tree root to a different position within the same parent tree,\n    ///         without a request\n    /// @dev Caller must be both an admin tree root and admin or wearer of `_newAdminHat`\n    /// @param _topHatDomain The 32 bit domain of the tophat to relink\n    /// @param _newAdminHat The new admin for the linked tree\n    function relinkTopHatWithinTree(uint32 _topHatDomain, uint256 _newAdminHat) external {\n        uint256 fullTopHatId = uint256(_topHatDomain) << 224; // (256 - TOPHAT_ADDRESS_SPACE);\n\n        // msg.sender being capable of both requesting and approving allows us to skip the request step\n        _checkAdmin(fullTopHatId); // \"requester\" must be admin\n\n        // \"approver\" can be wearer or admin\n        if (getHatLevel(_newAdminHat) < MAX_LEVELS) {\n            _checkAdmin(buildHatId(_newAdminHat, 1));\n        } else {\n            // the above buildHatId trick doesn't work for the last hat level, so we need to explicitly check both admin and wearer in this case\n            _checkAdminOrWearer(_newAdminHat);\n        }\n\n        // execute the new link, replacing the old link\n        _linkTopHatToTree(_topHatDomain, _newAdminHat);\n    }\n\n    /// @notice Internal function to link a Tree under a parent Tree, with protection against circular linkages and relinking to a separate Tree\n    /// @dev Linking `_topHatDomain` replaces any existing links\n    /// @param _topHatDomain The 32 bit domain of the tophat to link\n    /// @param _newAdminHat The new admin for the linked tree\n    function _linkTopHatToTree(uint32 _topHatDomain, uint256 _newAdminHat) internal {\n        if (!noCircularLinkage(_topHatDomain, _newAdminHat)) revert CircularLinkage();\n\n        // disallow relinking to separate tree\n        if (linkedTreeAdmins[_topHatDomain] > 0) {\n            if (!sameTippyTopHatDomain(_topHatDomain, _newAdminHat)) {\n                revert CrossTreeLinkage();\n            }\n        }\n\n        linkedTreeAdmins[_topHatDomain] = _newAdminHat;\n        emit TopHatLinked(_topHatDomain, _newAdminHat"
    }
  ]
}