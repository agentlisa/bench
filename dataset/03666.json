{
  "Title": "Unnecessary check in initialization",
  "Content": "##### Description\nConstructor of the proxy contains unnecessary check:\nhttps://github.com/lidofinance/withdrawals-manager-stub/blob/c41292ed9c3be765d06c4249b9f2ad4d427b84bf/contracts/WithdrawalsManagerProxy.sol#L70\n##### Recommendation\nWe recommend to delete this check.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/WithdrawalsManagerProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"OpenZeppelin/openzeppelin-contracts@4.0.0/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\nimport \"OpenZeppelin/openzeppelin-contracts@4.0.0/contracts/utils/Address.sol\";\n\nimport \"./WithdrawalsManagerStub.sol\";\n\n/**\n * @dev Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.1.0/contracts/utils/StorageSlot.sol\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n\n/**\n * @dev A proxy for Lido Ethereum 2.0 withdrawals manager contract.\n *\n * Though the Beacon chain already supports setting withdrawal credentials pointing to a smart\n * contract, the withdrawals specification is not yet final and might change before withdrawals\n * are enabled in the Merge network. This means that Lido cannot deploy the final implementation\n * of the withdrawals manager contract yet. At the same time, it's desirable to have withdrawal\n * credentials pointing to a smart contract since this would avoid the need to migrate a lot of\n * validators to new withdrawal credentials once withdrawals are enabled.\n *\n * To solve this, Lido uses an upgradeable proxy controlled by the DAO. Initially, it uses a stub\n * implementation contract, WithdrawalsManagerStub, that cannot receive Ether. The implementation\n * can only be changed by LDO holders collectively by performing a DAO vote. Lido will set validator\n * withdrawal credentials pointing to this proxy contract.\n *\n * When Ethereum 2.0 withdrawals specification is finalized, Lido DAO will prepare the new\n * implementation contract and initiate a vote among LDO holders for upgrading this proxy to the\n * new implementation.\n *\n * Once withdrawals are enabled in Ethereum 2.0, Lido DAO members will start a vote among LDO\n * holders for disabling the upgradeability forever and locking the implementation by changing\n * proxy admin from the DAO Voting contract to a zero address (which is an irreversible action).\n */\ncontract WithdrawalsManagerProxy is ERC1967Proxy {\n    /**\n     * @dev The address of Lido DAO Voting contract.\n     */\n    address internal constant LIDO_VOTING = 0x2e59A20f205bB85a89C53f1936454680651E618e;\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Initializes the upgradeable proxy with the initial stub implementation.\n     */\n    constructor() ERC1967Proxy(address(new WithdrawalsManagerStub()), new bytes(0)) {\n        assert(ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _setAdmin(LIDO_VOTING);\n    }\n\n    /**\n     * @return Returns the current implementation address.\n     */\n    function implementation() external view returns (address) {\n        return _implementation();\n    }\n\n    /**\n     * @dev Upgrades the proxy to a new implementation, optionally performing an additional\n     * setup call.\n     *\n     * Can only be called by the proxy admin until the proxy is ossified.\n     * Cannot be called after the proxy is ossified.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @param setupCalldata Data for the setup call. The call is skipped if data is empty.\n     */\n    function proxy_upgradeTo(address newImplementation, bytes memory setupCalldata) external {\n        address admin = _getAdmin();\n        require(admin != address(0), \"proxy: ossified\");\n        require(msg.sender == admin, \"proxy: unauthorized\");\n\n        _upgradeTo(newImplementation);\n\n        if (setupCalldata.length > 0) {\n            Address.functionDelegateCall(newImplementation, setupCalldata, \"proxy: setup failed\");\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Returns the current admin of the proxy.\n     */\n    function proxy_getAdmin() external view returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function proxy_changeAdmin(address newAdmin) external {\n        address admin = _getAdmin();\n        require(msg.sender == admin, \"proxy: unauthorized\");\n        emit AdminChanged(admin, newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Returns whether the implementation is locked forever.\n     */\n    function proxy_getIsOssified() external view returns (bool) {\n        return _getAdmin() == address(0);\n    }\n}"
    }
  ]
}