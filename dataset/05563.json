{
  "Title": "[L-01] Redundant check",
  "Content": "https://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/LiquidationLibrary.sol#L863\n\n`_redistributeDebt` will never be called if debt = 0.\n\nhttps://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/LiquidationLibrary.sol#L525-L527\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-badger",
  "Code": [
    {
      "filename": "packages/contracts/contracts/LiquidationLibrary.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\nimport \"./Interfaces/ICdpManagerData.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/IEBTCToken.sol\";\nimport \"./Interfaces/ISortedCdps.sol\";\nimport \"./Dependencies/ICollateralTokenOracle.sol\";\nimport \"./CdpManagerStorage.sol\";\n\n/// @title LiquidationLibrary mainly provide necessary logic to fulfill liquidation for eBTC Cdps.\n/// @dev This contract shares same base and storage layout with CdpManager and is the delegatecall destination from CdpManager\ncontract LiquidationLibrary is CdpManagerStorage {\n    constructor(\n        address _borrowerOperationsAddress,\n        address _collSurplusPool,\n        address _ebtcToken,\n        address _sortedCdps,\n        address _activePool,\n        address _priceFeed,\n        address _collateral\n    )\n        CdpManagerStorage(\n            address(0),\n            address(0),\n            _borrowerOperationsAddress,\n            _collSurplusPool,\n            _ebtcToken,\n            _sortedCdps,\n            _activePool,\n            _priceFeed,\n            _collateral\n        )\n    {}\n\n    /// @notice Fully liquidate a single Cdp by ID. Cdp must meet the criteria for liquidation at the time of execution.\n    /// @notice callable by anyone, attempts to liquidate the CdpId. Executes successfully if Cdp meets the conditions for liquidation (e.g. in Normal Mode, it liquidates if the Cdp's ICR < the system MCR).\n    /// @dev forwards msg.data directly to the liquidation library using OZ proxy core delegation function\n    /// @param _cdpId ID of the Cdp to liquidate.\n    function liquidate(bytes32 _cdpId) external nonReentrantSelfAndBOps {\n        _liquidateIndividualCdpSetup(_cdpId, 0, _cdpId, _cdpId);\n    }\n\n    /// @notice Partially liquidate a single Cdp.\n    /// @dev forwards msg.data directly to the liquidation library using OZ proxy core delegation function\n    /// @param _cdpId ID of the Cdp to partially liquidate.\n    /// @param _partialAmount Amount to partially liquidate.\n    /// @param _upperPartialHint Upper hint for reinsertion of the Cdp into the linked list.\n    /// @param _lowerPartialHint Lower hint for reinsertion of the Cdp into the linked list.\n    function partiallyLiquidate(\n        bytes32 _cdpId,\n        uint256 _partialAmount,\n        bytes32 _upperPartialHint,\n        bytes32 _lowerPartialHint\n    ) external nonReentrantSelfAndBOps {\n        require(_partialAmount != 0, \"LiquidationLibrary: use `liquidate` for 100%\");\n        _liquidateIndividualCdpSetup(_cdpId, _partialAmount, _upperPartialHint, _lowerPartialHint);\n    }\n\n    // Single CDP liquidation function.\n    function _liquidateIndividualCdpSetup(\n        bytes32 _cdpId,\n        uint256 _partialAmount,\n        bytes32 _upperPartialHint,\n        bytes32 _lowerPartialHint\n    ) internal {\n        _requireCdpIsActive(_cdpId);\n\n        _syncAccounting(_cdpId);\n\n        uint256 _price = priceFeed.fetchPrice();\n\n        // prepare local variables\n        uint256 _ICR = getCachedICR(_cdpId, _price); // @audit syncAccounting already called, guarenteed to be synced\n        (uint256 _TCR, uint256 systemColl, uint256 systemDebt) = _getTCRWithSystemDebtAndCollShares(\n            _price\n        );\n\n        // If CDP is above MCR\n        if (_ICR >= MCR) {\n            // We must be in RM\n            require(\n                _checkICRAgainstLiqThreshold(_ICR, _TCR),\n                \"LiquidationLibrary: ICR is not below liquidation threshold in current mode\"\n            );\n\n            // == Grace Period == //\n            uint128 cachedLastGracePeriodStartTimestamp = lastGracePeriodStartTimestamp;\n            require(\n                cachedLastGracePeriodStartTimestamp != UNSET_TIMESTAMP,\n                \"LiquidationLibrary: Recovery Mode grace period not started\"\n            );\n            require(\n                block.timestamp >\n                    cachedLastGracePeriodStartTimestamp + recoveryModeGracePeriodDuration,\n                \"LiquidationLibrary: Recovery mode grace period still in effect\"\n            );\n        } // Implicit Else Case, Implies ICR < MRC, meaning the CDP is liquidatable\n\n        bool _recoveryModeAtStart = _TCR < CCR ? true : false;\n        LiquidationLocals memory _liqState = LiquidationLocals(\n            _cdpId,\n            _partialAmount,\n            _price,\n            _ICR,\n            _upperPartialHint,\n            _lowerPartialHint,\n            (_recoveryModeAtStart),\n            _TCR,\n            0,\n            0,\n            0,\n            0,\n            0\n        );\n\n        LiquidationRecoveryModeLocals memory _rs = LiquidationRecoveryModeLocals(\n            systemDebt,\n            systemColl,\n            0,\n            0,\n            0,\n            _cdpId,\n            _price,\n            _ICR,\n            0,\n            0\n        );\n\n        _liquidateIndividualCdpSetupCDP(_liqState, _rs);\n    }\n\n    // liquidate given CDP by repaying debt in full or partially if its ICR is below MCR or TCR in recovery mode.\n    // For partial liquidation, caller should use HintHelper smart contract to get correct hints for reinsertion into sorted CDP list\n    function _liquidateIndividualCdpSetupCDP(\n        LiquidationLocals memory _liqState,\n        LiquidationRecoveryModeLocals memory _recoveryState\n    ) internal {\n        LiquidationValues memory liquidationValues;\n\n        uint256 startingSystemDebt = _recoveryState.entireSystemDebt;\n        uint256 startingSystemColl = _recoveryState.entireSystemColl;\n\n        if (_liqState.partialAmount == 0) {\n            (\n                liquidationValues.debtToBurn,\n                liquidationValues.totalCollToSendToLiquidator,\n                liquidationValues.debtToRedistribute,\n                liquidationValues.liquidatorCollSharesReward,\n                liquidationValues.collSurplus\n            ) = _liquidateCdpInGivenMode(_liqState, _recoveryState);\n        } else {\n            (\n                liquidationValues.debtToBurn,\n                liquidationValues.totalCollToSendToLiquidator\n            ) = _liquidateCDPPartially(_liqState);\n            if (\n                liquidationValues.totalCollToSendToLiquidator == 0 &&\n                liquidationValues.debtToBurn == 0\n            ) {\n                // retry with fully liquidation\n                (\n                    liquidationValues.debtToBurn,\n                    liquidationValues.totalCollToSendToLiquidator,\n                    liquidationValues.debtToRedistribute,\n                    liquidationValues.liquidatorCollSharesReward,\n                    liquidationValues.collSurplus\n                ) = _liquidateCdpInGivenMode(_liqState, _recoveryState);\n            }\n        }\n\n        _finalizeLiquidation(\n            liquidationValues.debtToBurn,\n            liquidationValues.totalCollToSendToLiquidator,\n            liquidationValues.debtToRedistribute,\n            liquidationValues.liquidatorCollSharesReward,\n            liquidationValues.collSurplus,\n            startingSystemColl,\n            startingSystemDebt,\n            _liqState.price\n        );\n    }\n\n    // liquidate (and close) the CDP from an external liquidator\n    // this function would return the liquidated debt and collateral of the given CDP\n    function _liquidateCdpInGivenMode(\n        LiquidationLocals memory _liqState,\n        LiquidationRecoveryModeLocals memory _recoveryState\n    ) private returns (uint256, uint256, uint256, uint256, uint256) {\n        if (_liqState.recoveryModeAtStart) {\n            LiquidationRecoveryModeLocals\n                memory _outputState = _liquidateIndividualCdpSetupCDPInRecoveryMode(_recoveryState);\n\n            // housekeeping leftover collateral for liquidated CDP\n            if (_outputState.totalSurplusCollShares > 0) {\n                activePool.transferSystemCollShares(\n                    address(collSurplusPool),\n                    _outputState.totalSurplusCollShares\n                );\n            }\n\n            return (\n                _outputState.totalDebtToBurn,\n                _outputState.totalCollSharesToSend,\n                _outputState.totalDebtToRedistribute,\n                _outputState.totalLiquidatorRewardCollShares,\n                _outputState.totalSurplusCollShares\n            );\n        } else {\n            LiquidationLocals memory _outputState = _liquidateIndividualCdpSetupCDPInNormalMode(\n                _liqState\n            );\n            return (\n                _outputState.totalDebtToBurn,\n                _outputState.totalCollSharesToSend,\n                _outputState.totalDebtToRedistribute,\n                _outputState.totalLiquidatorRewardCollShares,\n                _outputState.totalSurplusCollShares\n            );\n        }\n    }\n\n    function _liquidateIndividualCdpSetupCDPInNormalMode(\n        LiquidationLocals memory _liqState\n    ) private returns (LiquidationLocals memory) {\n        // liquidate entire debt\n        (\n            uint256 _totalDebtToBurn,\n            uint256 _totalColToSend,\n            uint256 _liquidatorReward\n        ) = _closeCdpByLiquidation(_liqState.cdpId);\n        uint256 _cappedColPortion;\n        uint256 _collSurplus;\n        uint256 _debtToRedistribute;\n        address _borrower = sortedCdps.getOwnerAddress(_liqState.cdpId);\n\n        // I don't see an issue emitting the CdpUpdated() event up here and avoiding this extra cache, any objections?\n        emit CdpUpdated(\n            _liqState.cdpId,\n            _borrower,\n            msg.sender,\n            _totalDebtToBurn,\n            _totalColToSend,\n            0,\n            0,\n            0,\n            CdpOperation.liquidateInNormalMode\n        );\n\n        {\n            (\n                _cappedColPortion,\n                _collSurplus,\n                _debtToRedistribute\n            ) = _calculateFullLiquidationSurplusAndCap(\n                _liqState.ICR,\n                _liqState.price,\n                _totalDebtToBurn,\n                _totalColToSend\n            );\n            if (_collSurplus > 0) {\n                // due to division precision loss, should be zero surplus in normal mode\n                _cappedColPortion = _cappedColPortion + _collSurplus;\n                _collSurplus = 0;\n            }\n            if (_debtToRedistribute > 0) {\n                _totalDebtToBurn = _totalDebtToBurn - _debtToRedistribute;\n            }\n        }\n        _liqState.totalDebtToBurn = _liqState.totalDebtToBurn + _totalDebtToBurn;\n        _liqState.totalCollSharesToSend = _liqState.totalCollSharesToSend + _cappedColPortion;\n        _liqState.totalDebtToRedistribute = _liqState.totalDebtToRedistribute + _debtToRedistribute;\n        _liqState.totalLiquidatorRewardCollShares =\n            _liqState.totalLiquidatorRewardCollShares +\n            _liquidatorReward;\n\n        // Emit events\n        uint _debtToColl = (_totalDebtToBurn * DECIMAL_PRECISION) / _liqState.price;\n        uint _cappedColl = collateral.getPooledEthByShares(_cappedColPortion + _liquidatorReward);\n\n        emit CdpLiquidated(\n            _liqState.cdpId,\n            _borrower,\n            _totalDebtToBurn,\n            // please note this is the collateral share of the liquidated CDP\n            _cappedColPortion,\n            CdpOperation.liquidateInNormalMode,\n            msg.sender,\n            _cappedColl > _debtToColl ? (_cappedColl - _debtToColl) : 0\n        );\n\n        return _liqState;\n    }\n\n    function _liquidateIndividualCdpSetupCDPInRecoveryMode(\n        LiquidationRecoveryModeLocals memory _recoveryState\n    ) private returns (LiquidationRecoveryModeLocals memory) {\n        // liquidate entire debt\n        (\n            uint256 _totalDebtToBurn,\n            uint256 _totalColToSend,\n            uint256 _liquidatorReward\n        ) = _closeCdpByLiquidation(_recoveryState.cdpId);\n\n        // cap the liquidated collateral if required\n        uint256 _cappedColPortion;\n        uint256 _collSurplus;\n        uint256 _debtToRedistribute;\n        address _borrower = sortedCdps.getOwnerAddress(_recoveryState.cdpId);\n\n        // I don't see an issue emitting the CdpUpdated() event up here and avoiding an extra cache of the values, any objections?\n        emit CdpUpdated(\n            _recoveryState.cdpId,\n            _borrower,\n            msg.sender,\n            _totalDebtToBurn,\n            _totalColToSend,\n            0,\n            0,\n            0,\n            CdpOperation.liquidateInRecoveryMode\n        );\n\n        // avoid stack too deep\n        {\n            (\n                _cappedColPortion,\n                _collSurplus,\n                _debtToRedistribute\n            ) = _calculateFullLiquidationSurplusAndCap(\n                _recoveryState.ICR,\n                _recoveryState.price,\n                _totalDebtToBurn,\n                _totalColToSend\n            );\n            if (_collSurplus > 0) {\n                collSurplusPool.increaseSurplusCollShares(_borrower, _collSurplus);\n                _recoveryState.totalSurplusCollShares =\n                    _recoveryState.totalSurplusCollShares +\n                    _collSurplus;\n            }\n            if (_debtToRedistribute > 0) {\n                _totalDebtToBurn = _totalDebtToBurn - _debtToRedistribute;\n            }\n        }\n        _recoveryState.totalDebtToBurn = _recoveryState.totalDebtToBurn + _totalDebtToBurn;\n        _recoveryState.totalCollSharesToSend =\n            _recoveryState.totalCollSharesToSend +\n            _cappedColPortion;\n        _recoveryState.totalDebtToRedistribute =\n            _recoveryState.totalDebtToRedistribute +\n            _debtToRedistribute;\n        _recoveryState.totalLiquidatorRewardCollShares =\n            _recoveryState.totalLiquidatorRewardCollShares +\n            _liquidatorReward;\n\n        // check if system back to normal mode\n        _recoveryState.entireSystemDebt = _recoveryState.entireSystemDebt > _totalDebtToBurn\n            ? _recoveryState.entireSystemDebt - _totalDebtToBurn\n            : 0;\n        _recoveryState.entireSystemColl = _recoveryState.entireSystemColl > _totalColToSend\n            ? _recoveryState.entireSystemColl - _totalColToSend\n            : 0;\n\n        uint _debtToColl = (_totalDebtToBurn * DECIMAL_PRECISION) / _recoveryState.price;\n        uint _cappedColl = collateral.getPooledEthByShares(_cappedColPortion + _liquidatorReward);\n        emit CdpLiquidated(\n            _recoveryState.cdpId,\n            _borrower,\n            _totalDebtToBurn,\n            // please note this is the collateral share of the liquidated CDP\n            _cappedColPortion,\n            CdpOperation.liquidateInRecoveryMode,\n            msg.sender,\n            _cappedColl > _debtToColl ? (_cappedColl - _debtToColl) : 0\n        );\n\n        return _recoveryState;\n    }\n\n    // liquidate (and close) the CDP from an external liquidator\n    // this function would return the liquidated debt and collateral of the given CDP\n    // without emmiting events\n    function _closeCdpByLiquidation(bytes32 _cdpId) private returns (uint256, uint256, uint256) {\n        // calculate entire debt to repay\n        (uint256 entireDebt, uint256 entireColl) = getSyncedDebtAndCollShares(_cdpId);\n\n        // housekeeping after liquidation by closing the CDP\n        uint256 _liquidatorReward = Cdps[_cdpId].liquidatorRewardShares;\n        _closeCdp(_cdpId, Status.closedByLiquidation);\n\n        return (entireDebt, entireColl, _liquidatorReward);\n    }\n\n    // Liquidate partially the CDP by an external liquidator\n    // This function would return the liquidated debt and collateral of the given CDP\n    function _liquidateCDPPartially(\n        LiquidationLocals memory _partialState\n    ) private returns (uint256, uint256) {\n        bytes32 _cdpId = _partialState.cdpId;\n        uint256 _partialDebt = _partialState.partialAmount;\n\n        // calculate entire debt to repay\n        CdpDebtAndCollShares memory _debtAndColl = _getSyncedDebtAndCollShares(_cdpId);\n        _requirePartialLiqDebtSize(_partialDebt, _debtAndColl.debt, _partialState.price);\n        uint256 newDebt = _debtAndColl.debt - _partialDebt;\n\n        // credit to https://arxiv.org/pdf/2212.07306.pdf for details\n        (uint256 _partialColl, uint256 newColl, ) = _calculatePartialLiquidationSurplusAndCap(\n            _partialState.ICR,\n            _partialState.price,\n            _partialDebt,\n            _debtAndColl.collShares\n        );\n\n        // early return: if new collateral is zero, we have a full liqudiation\n        if (newColl == 0) {\n            return (0, 0);\n        }\n\n        // If we have coll remaining, it must meet minimum CDP size requirements\n        _requirePartialLiqCollSize(collateral.getPooledEthByShares(newColl));\n\n        // updating the CDP accounting for partial liquidation\n        _partiallyReduceCdpDebt(_cdpId, _partialDebt, _partialColl);\n\n        // reInsert into sorted CDP list after partial liquidation\n        {\n            _reInsertPartialLiquidation(\n                _partialState,\n                EbtcMath._computeNominalCR(newColl, newDebt),\n                _debtAndColl.debt,\n                _debtAndColl.collShares\n            );\n            uint _debtToColl = (_partialDebt * DECIMAL_PRECISION) / _partialState.price;\n            uint _cappedColl = collateral.getPooledEthByShares(_partialColl);\n            emit CdpPartiallyLiquidated(\n                _cdpId,\n                sortedCdps.getOwnerAddress(_cdpId),\n                _partialDebt,\n                _partialColl,\n                CdpOperation.partiallyLiquidate,\n                msg.sender,\n                _cappedColl > _debtToColl ? (_cappedColl - _debtToColl) : 0\n            );\n        }\n        return (_partialDebt, _partialColl);\n    }\n\n    function _partiallyReduceCdpDebt(\n        bytes32 _cdpId,\n        uint256 _partialDebt,\n        uint256 _partialColl\n    ) internal {\n        Cdp storage _cdp = Cdps[_cdpId];\n\n        uint256 _coll = _cdp.coll;\n        uint256 _debt = _cdp.debt;\n\n        _cdp.coll = _coll - _partialColl;\n        _cdp.debt = _debt - _partialDebt;\n        _updateStakeAndTotalStakes(_cdpId);\n    }\n\n    // Re-Insertion into SortedCdp list after partial liquidation\n    function _reInsertPartialLiquidation(\n        LiquidationLocals memory _partialState,\n        uint256 _newNICR,\n        uint256 _oldDebt,\n        uint256 _oldColl\n    ) internal {\n        bytes32 _cdpId = _partialState.cdpId;\n\n        // ensure new ICR does NOT decrease due to partial liquidation\n        // if original ICR is above LICR\n        if (_partialState.ICR > LICR) {\n            require(\n                getCachedICR(_cdpId, _partialState.price) >= _partialState.ICR,\n                \"LiquidationLibrary: !_newICR>=_ICR\"\n            );\n        }\n\n        // reInsert into sorted CDP list\n        sortedCdps.reInsert(\n            _cdpId,\n            _newNICR,\n            _partialState.upperPartialHint,\n            _partialState.lowerPartialHint\n        );\n        emit CdpUpdated(\n            _cdpId,\n            sortedCdps.getOwnerAddress(_cdpId),\n            msg.sender,\n            _oldDebt,\n            _oldColl,\n            Cdps[_cdpId].debt,\n            Cdps[_cdpId].coll,\n            Cdps[_cdpId].stake,\n            CdpOperation.partiallyLiquidate\n        );\n    }\n\n    function _finalizeLiquidation(\n        uint256 totalDebtToBurn,\n        uint256 totalCollSharesToSend,\n        uint256 totalDebtToRedistribute,\n        uint256 totalLiquidatorRewardCollShares,\n        uint256 totalSurplusCollShares,\n        uint256 systemInitialCollShares,\n        uint256 systemInitialDebt,\n        uint256 price\n    ) internal {\n        // update the staking and collateral snapshots\n        _updateSystemSnapshotsExcludeCollRemainder(totalCollSharesToSend);\n\n        emit Liquidation(totalDebtToBurn, totalCollSharesToSend, totalLiquidatorRewardCollShares);\n\n        _syncGracePeriodForGivenValues(\n            systemInitialCollShares - totalCollSharesToSend - totalSurplusCollShares,\n            systemInitialDebt - totalDebtToBurn,\n            price\n        );\n\n        // redistribute debt if any\n        if (totalDebtToRedistribute > 0) {\n            _redistributeDebt(totalDebtToRedistribute);\n        }\n\n        // burn the debt from liquidator\n        ebtcToken.burn(msg.sender, totalDebtToBurn);\n\n        // offset debt from Active Pool\n        activePool.decreaseSystemDebt(totalDebtToBurn);\n\n        // CEI: ensure sending back collateral to liquidator is last thing to do\n        activePool.transferSystemCollSharesAndLiquidatorReward(\n            msg.sender,\n            totalCollSharesToSend,\n            totalLiquidatorRewardCollShares\n        );\n    }\n\n    // Partial Liquidation Cap Logic\n    function _calculatePartialLiquidationSurplusAndCap(\n        uint256 _ICR,\n        uint256 _price,\n        uint256 _totalDebtToBurn,\n        uint256 _totalColToSend\n    ) private view returns (uint256 toLiquidator, uint256 collSurplus, uint256 debtToRedistribute) {\n        uint256 _incentiveColl;\n\n        // CLAMP\n        if (_ICR > LICR) {\n            // Cap at 10%\n            _incentiveColl = (_totalDebtToBurn * (_ICR > MCR ? MCR : _ICR)) / _price;\n        } else {\n            // Min 103%\n            _incentiveColl = (_totalDebtToBurn * LICR) / _price;\n        }\n\n        toLiquidator = collateral.getSharesByPooledEth(_incentiveColl);\n\n        /// @audit MUST be like so, else we have debt redistribution, which we assume cannot happen in partial\n        assert(toLiquidator < _totalColToSend); // Assert is correct here for Echidna\n\n        /// Because of above we can subtract\n        collSurplus = _totalColToSend - toLiquidator; // Can use unchecked but w/e\n    }\n\n    function _calculateFullLiquidationSurplusAndCap(\n        uint256 _ICR,\n        uint256 _price,\n        uint256 _totalDebtToBurn,\n        uint256 _totalColToSend\n    ) private view returns (uint256 toLiquidator, uint256 collSurplus, uint256 debtToRedistribute) {\n        uint256 _incentiveColl;\n\n        if (_ICR > LICR) {\n            _incentiveColl = (_totalDebtToBurn * (_ICR > MCR ? MCR : _ICR)) / _price;\n\n            // Convert back to shares\n            toLiquidator = collateral.getSharesByPooledEth(_incentiveColl);\n        } else {\n            // for full liquidation, there would be some bad debt to redistribute\n            _incentiveColl = collateral.getPooledEthByShares(_totalColToSend);\n\n            // Since it's full and there's bad debt we use spot conversion to\n            // Determine the amount of debt that willl be repaid after adding the LICR discount\n            // Basically this is buying underwater Coll\n            // By repaying debt at 3% discount\n            // Can there be a rounding error where the _debtToRepay > debtToBurn?\n            uint256 _debtToRepay = (_incentiveColl * _price) / LICR;\n\n            debtToRedistribute = _debtToRepay < _totalDebtToBurn\n                ? _totalDebtToBurn - _debtToRepay //  Bad Debt (to be redistributed) is (CdpDebt - Repaid)\n                : 0; // Else 0 (note we may underpay per the comment above, althought that may be imaginary)\n\n            // now CDP owner should have zero surplus to claim\n            toLiquidator = _totalColToSend;\n        }\n\n        toLiquidator = toLiquidator < _totalColToSend ? toLiquidator : _totalColToSend;\n        collSurplus = (toLiquidator == _totalColToSend) ? 0 : _totalColToSend - toLiquidator;\n    }\n\n    // --- Batch liquidation functions ---\n\n    function _getLiquidationValuesNormalMode(\n        uint256 _price,\n        uint256 _TCR,\n        LocalVariables_LiquidationSequence memory vars,\n        LiquidationValues memory singleLiquidation\n    ) internal {\n        LiquidationLocals memory _liqState = LiquidationLocals(\n            vars.cdpId,\n            0,\n            _price,\n            vars.ICR,\n            vars.cdpId,\n            vars.cdpId,\n            (false),\n            _TCR,\n            0,\n            0,\n            0,\n            0,\n            0\n        );\n\n        LiquidationLocals memory _outputState = _liquidateIndividualCdpSetupCDPInNormalMode(\n            _liqState\n        );\n\n        singleLiquidation.entireCdpDebt = _outputState.totalDebtToBurn;\n        singleLiquidation.debtToBurn = _outputState.totalDebtToBurn;\n        singleLiquidation.totalCollToSendToLiquidator = _outputState.totalCollSharesToSend;\n        singleLiquidation.collSurplus = _outputState.totalSurplusCollShares;\n        singleLiquidation.debtToRedistribute = _outputState.totalDebtToRedistribute;\n        singleLiquidation.liquidatorCollSharesReward = _outputState.totalLiquidatorRewardCollShares;\n    }\n\n    function _getLiquidationValuesRecoveryMode(\n        uint256 _price,\n        uint256 _systemDebt,\n        uint256 _systemCollShares,\n        LocalVariables_LiquidationSequence memory vars,\n        LiquidationValues memory singleLiquidation\n    ) internal {\n        LiquidationRecoveryModeLocals memory _recState = LiquidationRecoveryModeLocals(\n            _systemDebt,\n            _systemCollShares,\n            0,\n            0,\n            0,\n            vars.cdpId,\n            _price,\n            vars.ICR,\n            0,\n            0\n        );\n\n        LiquidationRecoveryModeLocals\n            memory _outputState = _liquidateIndividualCdpSetupCDPInRecoveryMode(_recState);\n\n        singleLiquidation.entireCdpDebt = _outputState.totalDebtToBurn;\n        singleLiquidation.debtToBurn = _outputState.totalDebtToBurn;\n        singleLiquidation.totalCollToSendToLiquidator = _outputState.totalCollSharesToSend;\n        singleLiquidation.collSurplus = _outputState.totalSurplusCollShares;\n        singleLiquidation.debtToRedistribute = _outputState.totalDebtToRedistribute;\n        singleLiquidation.liquidatorCollSharesReward = _outputState.totalLiquidatorRewardCollShares;\n    }\n\n    /// @notice Attempt to liquidate a custom list of Cdps provided by the caller\n    /// @notice Callable by anyone, accepts a custom list of Cdps addresses as an argument.\n    /// @notice Steps through the provided list and attempts to liquidate every Cdp, until it reaches the end or it runs out of gas.\n    /// @notice A Cdp is liquidated only if it meets the conditions for liquidation.\n    /// @dev forwards msg.data directly to the liquidation library using OZ proxy core delegation function\n    /// @param _cdpArray Array of Cdps to liquidate.\n    function batchLiquidateCdps(bytes32[] memory _cdpArray) external nonReentrantSelfAndBOps {\n        require(\n            _cdpArray.length != 0,\n            \"LiquidationLibrary: Calldata address array must not be empty\"\n        );\n\n        LocalVariables_OuterLiquidationFunction memory vars;\n        LiquidationTotals memory totals;\n\n        // taking fee to avoid accounted for the calculation of the TCR\n        _syncGlobalAccounting();\n\n        vars.price = priceFeed.fetchPrice();\n        (uint256 _TCR, uint256 systemColl, uint256 systemDebt) = _getTCRWithSystemDebtAndCollShares(\n            vars.price\n        );\n        vars.recoveryModeAtStart = _TCR < CCR ? true : false;\n\n        // Perform the appropriate batch liquidation - tally values and obtain their totals.\n        if (vars.recoveryModeAtStart) {\n            totals = _getTotalFromBatchLiquidate_RecoveryMode(\n                vars.price,\n                systemColl,\n                systemDebt,\n                _cdpArray\n            );\n        } else {\n            //  if !vars.recoveryModeAtStart\n            totals = _getTotalsFromBatchLiquidate_NormalMode(vars.price, _TCR, _cdpArray);\n        }\n\n        require(totals.totalDebtInSequence > 0, \"LiquidationLibrary: nothing to liquidate\");\n\n        // housekeeping leftover collateral for liquidated CDPs\n        if (totals.totalCollSurplus > 0) {\n            activePool.transferSystemCollShares(address(collSurplusPool), totals.totalCollSurplus);\n        }\n\n        _finalizeLiquidation(\n            totals.totalDebtToBurn,\n            totals.totalCollToSendToLiquidator,\n            totals.totalDebtToRedistribute,\n            totals.totalCollReward,\n            totals.totalCollSurplus,\n            systemColl,\n            systemDebt,\n            vars.price\n        );\n    }\n\n    /*\n     * This function is used when the batch liquidation starts during Recovery Mode. However, it\n     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation processing\n     */\n    function _getTotalFromBatchLiquidate_RecoveryMode(\n        uint256 _price,\n        uint256 _systemCollShares,\n        uint256 _systemDebt,\n        bytes32[] memory _cdpArray\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.backToNormalMode = false;\n        vars.entireSystemDebt = _systemDebt;\n        vars.entireSystemColl = _systemCollShares;\n        uint256 _TCR = _computeTCRWithGivenSystemValues(\n            vars.entireSystemColl,\n            vars.entireSystemDebt,\n            _price\n        );\n        uint256 _cnt = _cdpArray.length;\n        bool[] memory _liqFlags = new bool[](_cnt);\n        uint256 _start;\n        for (vars.i = _start; ; ) {\n            vars.cdpId = _cdpArray[vars.i];\n            // only for active cdps\n            if (vars.cdpId != bytes32(0) && Cdps[vars.cdpId].status == Status.active) {\n                vars.ICR = getSyncedICR(vars.cdpId, _price);\n\n                if (\n                    !vars.backToNormalMode &&\n                    (_checkICRAgainstMCR(vars.ICR) || canLiquidateRecoveryMode(vars.ICR, _TCR))\n                ) {\n                    vars.price = _price;\n                    _syncAccounting(vars.cdpId);\n                    _getLiquidationValuesRecoveryMode(\n                        _price,\n                        vars.entireSystemDebt,\n                        vars.entireSystemColl,\n                        vars,\n                        singleLiquidation\n                    );\n\n                    // Update aggregate trackers\n                    vars.entireSystemDebt = vars.entireSystemDebt - singleLiquidation.debtToBurn;\n                    vars.entireSystemColl =\n                        vars.entireSystemColl -\n                        singleLiquidation.totalCollToSendToLiquidator -\n                        singleLiquidation.collSurplus;\n\n                    // Add liquidation values to their respective running totals\n                    totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n                    _TCR = _computeTCRWithGivenSystemValues(\n                        vars.entireSystemColl,\n                        vars.entireSystemDebt,\n                        _price\n                    );\n                    vars.backToNormalMode = _TCR < CCR ? false : true;\n                    _liqFlags[vars.i] = true;\n                } else if (vars.backToNormalMode && _checkICRAgainstMCR(vars.ICR)) {\n                    _syncAccounting(vars.cdpId);\n                    _getLiquidationValuesNormalMode(_price, _TCR, vars, singleLiquidation);\n\n                    // Add liquidation values to their respective running totals\n                    totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n                    _liqFlags[vars.i] = true;\n                }\n                // In Normal Mode skip cdps with ICR >= MCR\n            }\n            ++vars.i;\n            if (vars.i == _cnt) {\n                break;\n            }\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode(\n        uint256 _price,\n        uint256 _TCR,\n        bytes32[] memory _cdpArray\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n        uint256 _cnt = _cdpArray.length;\n        uint256 _start;\n        for (vars.i = _start; ; ) {\n            vars.cdpId = _cdpArray[vars.i];\n            // only for active cdps\n            if (vars.cdpId != bytes32(0) && Cdps[vars.cdpId].status == Status.active) {\n                vars.ICR = getSyncedICR(vars.cdpId, _price);\n\n                if (_checkICRAgainstMCR(vars.ICR)) {\n                    _syncAccounting(vars.cdpId);\n                    _getLiquidationValuesNormalMode(_price, _TCR, vars, singleLiquidation);\n\n                    // Add liquidation values to their respective running totals\n                    totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n                }\n            }\n            ++vars.i;\n            if (vars.i == _cnt) {\n                break;\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    function _addLiquidationValuesToTotals(\n        LiquidationTotals memory oldTotals,\n        LiquidationVa"
    }
  ]
}