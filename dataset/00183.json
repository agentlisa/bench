{
  "Title": "M-13: `Edition.supportsInterface` is not EIP1155 compliant",
  "Content": "# Issue M-13: `Edition.supportsInterface` is not EIP1155 compliant \n\nSource: https://github.com/sherlock-audit/2024-04-titles-judging/issues/287 \n\n## Found by \nCodeWasp, ZdravkoHr., cducrest-brainbot, xiaoming90\n## Summary\nAccording to the [ERC-1155 specification](https://eips.ethereum.org/EIPS/eip-1155#specification), the smart contracts that are implementing it `MUST` have a `supportsInferface(bytes4)` function that returns true for values `0xd9b67a26` and `0x0e89341c`.  The current implementation of [Edition.sol](https://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/editions/Edition.sol) will return `false` for both these values.\n## Vulnerability Detail\nThe contract inherits from `ERC1155` and `ERC2981`.\n```solidity\ncontract Edition is IEdition, ERC1155, ERC2981, Initializable, OwnableRoles\n```\nThe [supportsInterface()](https://github.com/sherlock-audit/2024-04-titles/blob/d7f60952df22da00b772db5d3a8272a988546089/wallflower-contract-v2/src/editions/Edition.sol#L465C1-L472C6) function of `Edition` returns the result of executing `super.supportsInterface()`\n```solidity\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(IEdition, ERC1155, ERC2981)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n```\nSince both [ERC1155](https://github.com/Vectorized/solady/blob/91d5f64b39a4d20a3ce1b5e985103b8ea4dc1cfc/src/tokens/ERC1155.sol#L454-L461) and [ERC2981](https://github.com/Vectorized/solady/blob/91d5f64b39a4d20a3ce1b5e985103b8ea4dc1cfc/src/tokens/ERC2981.sol#L58-L65) implement that function and `ERC2981` is the more derived contract of the two, `Edition.supportsInterface()` will end up executing only `ERC2981.supportsInterface()`. \n\n\n## Impact\nMedium. The contract is to be a strict implementation of `ERC1155`, but it does not implement the mandatory `ERC1155.supportsInterface()` function.\n\n## Code Snippet\nPoC for [Edition.t.sol](https://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/test/editions/Edition.t.sol)\n```solidity\n    function test_interface() public {\n        assertFalse(edition.supportsInterface(bytes4(0xd9b67a26)));\n        assertFalse(edition.supportsInterface(bytes4(0x0e89341c)));\n    }\n```\n\n## Tool used\n\nFoundry\n\n## Recommendation\nInstead of relying on `super`, return the union of `ERC1155.supportsInterface(interfaceId)` and `ERC2981.supportsInterface(interfaceId)`.\n```diff\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(IEdition, ERC1155, ERC2981)\n        returns (bool)\n    {\n-       return super.supportsInterface(interfaceId);\n+       return ERC1155.supportsInterface(interfaceId) || ERC2981.supportsInterface(interfaceId);\n    }\n```\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/326",
  "Code": [
    {
      "filename": "wallflower-contract-v2/src/editions/Edition.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {Initializable} from \"lib/solady/src/utils/Initializable.sol\";\nimport {OwnableRoles} from \"lib/solady/src/auth/OwnableRoles.sol\";\nimport {Ownable} from \"lib/solady/src/auth/Ownable.sol\";\nimport {ERC2981} from \"lib/solady/src/tokens/ERC2981.sol\";\nimport {SafeTransferLib} from \"lib/solady/src/utils/SafeTransferLib.sol\";\n\nimport {ERC1155} from \"solady/tokens/ERC1155.sol\";\nimport {IEdition} from \"src/interfaces/IEdition.sol\";\nimport {FeeManager} from \"src/fees/FeeManager.sol\";\nimport {TitlesGraph} from \"src/graph/TitlesGraph.sol\";\nimport {Node, NodeType, Target, Strategy} from \"src/shared/Common.sol\";\n\nimport {\n    EDITION_MANAGER_ROLE,\n    EDITION_MINTER_ROLE,\n    EDITION_PUBLISHER_ROLE,\n    Metadata,\n    Node,\n    Strategy,\n    Comment,\n    FeeStrategyUpdated,\n    MaxSupplyReached,\n    Minted,\n    NotImplemented,\n    NotOpen,\n    Published,\n    TimeframeUpdated,\n    WorkTransferred\n} from \"src/shared/Common.sol\";\n\n/// @title Edition\n/// @notice An ERC1155 contract representing a collection of related works. Each work is represented by a token ID.\ncontract Edition is IEdition, ERC1155, ERC2981, Initializable, OwnableRoles {\n    using SafeTransferLib for address;\n\n    /// @notice An individual work within the Edition.\n    /// @param creator The creator of the work.\n    /// @param maxSupply The maximum number of mintable tokens for the work.\n    /// @param totalSupply The total number of minted tokens for the work.\n    /// @param opensAt The timestamp after which the work is mintable.\n    /// @param closesAt The timestamp after which the work is no longer mintable. If `0`, there is no closing time.\n    /// @param strategy The fee strategy for the work.\n    struct Work {\n        address creator;\n        uint256 maxSupply;\n        uint256 totalSupply;\n        uint64 opensAt;\n        uint64 closesAt;\n        Strategy strategy;\n    }\n\n    /// @notice The total number of works in the Edition. Also the ID of the latest work.\n    uint256 public totalWorks;\n\n    /// @notice The collection of works in the Edition.\n    mapping(uint256 => Work) public works;\n\n    /// @notice The metadata for the Edition and its works.\n    /// @dev The Edition key is 0, while the work keys are the token IDs.\n    mapping(uint256 => Metadata) public _metadata;\n\n    /// @notice The fee manager contract.\n    FeeManager public FEE_MANAGER;\n\n    /// @notice The TitlesGraph contract.\n    TitlesGraph public GRAPH;\n\n    /// @notice Initialize the Edition contract.\n    /// @param feeManager_ The fee manager contract.\n    /// @param graph_ The TitlesGraph contract.\n    /// @param owner_ The owner of the Edition contract.\n    /// @param controller_ The controller of the Edition contract.\n    /// @dev This function is called by the {EditionFactory} when creating a new Edition to set the fee manager and owner.\n    /// @dev The controller is granted the {EDITION_MANAGER_ROLE} to allow management of the Edition contract.\n    function initialize(\n        FeeManager feeManager_,\n        TitlesGraph graph_,\n        address owner_,\n        address controller_,\n        Metadata calldata metadata_\n    ) external initializer {\n        _initializeOwner(owner_);\n        FEE_MANAGER = feeManager_;\n        GRAPH = graph_;\n\n        _grantRoles(controller_, EDITION_MANAGER_ROLE);\n        _grantRoles(owner_, EDITION_PUBLISHER_ROLE);\n\n        _metadata[0] = metadata_;\n    }\n\n    /// @notice Create a new work in the Edition.\n    /// @param creator_ The creator of the work.\n    /// @param maxSupply_ The maximum number of mintable tokens for the work.\n    /// @param opensAt_ The timestamp after which the work is mintable.\n    /// @param closesAt_ The timestamp after which the work is no longer mintable.\n    /// @param attributions_ The attributions for the work.\n    /// @param strategy_ The fee strategy for the work.\n    /// @param metadata_ The metadata for the work.\n    function publish(\n        address creator_,\n        uint256 maxSupply_,\n        uint64 opensAt_,\n        uint64 closesAt_,\n        Node[] calldata attributions_,\n        Strategy calldata strategy_,\n        Metadata calldata metadata_\n    ) external override onlyRoles(EDITION_MANAGER_ROLE) returns (uint256 tokenId) {\n        tokenId = ++totalWorks;\n\n        _metadata[tokenId] = metadata_;\n        works[tokenId] = Work({\n            creator: creator_,\n            totalSupply: 0,\n            maxSupply: maxSupply_,\n            opensAt: opensAt_,\n            closesAt: closesAt_,\n            strategy: FEE_MANAGER.validateStrategy(strategy_)\n        });\n\n        Node memory _node = node(tokenId);\n        for (uint256 i = 0; i < attributions_.length; i++) {\n            // wake-disable-next-line reentrancy, unchecked-return-value\n            GRAPH.createEdge(_node, attributions_[i], attributions_[i].data);\n        }\n\n        emit Published(address(this), tokenId);\n    }\n\n    /// @notice Get the name of the Edition.\n    /// @return The name of the Edition.\n    function name() public view override returns (string memory) {\n        return _metadata[0].label;\n    }\n\n    /// @notice Get the name for a given Work.\n    /// @param tokenId The ID of the work.\n    /// @return The name of the work.\n    function name(uint256 tokenId) public view returns (string memory) {\n        return _metadata[tokenId].label;\n    }\n\n    /// @notice Get the owner of the Edition.\n    /// @return The owner of the Edition.\n    /// @dev The owner of the Edition contract has the right to manage roles.\n    function owner() public view override(IEdition, Ownable) returns (address) {\n        return super.owner();\n    }\n\n    function uri() public view returns (string memory) {\n        return _metadata[0].uri;\n    }\n\n    /// @notice Get the URI for the given token ID.\n    /// @param tokenId_ The ID of the token.\n    /// @return The URI for the token.\n    function uri(uint256 tokenId_)\n        public\n        view\n        virtual\n        override(IEdition, ERC1155)\n        returns (string memory)\n    {\n        return _metadata[tokenId_].uri;\n    }\n\n    /// @notice Get the creator of the Edition. Alias for {owner}.\n    /// @return The creator of the Edition.\n    function creator() public view override returns (address) {\n        return owner();\n    }\n\n    /// @notice Get the creator of the given work.\n    /// @param tokenId The ID of the work.\n    /// @return The creator of the work.\n    function creator(uint256 tokenId) public view override returns (address) {\n        return works[tokenId].creator;\n    }\n\n    /// @notice Get the {Node} for the collection.\n    /// @return The node for the edition.\n    function node() public view returns (Node memory) {\n        return Node({\n            nodeType: NodeType.COLLECTION_ERC1155,\n            creator: Target({target: owner(), chainId: block.chainid}),\n            entity: Target({target: address(this), chainId: block.chainid}),\n            data: \"\"\n        });\n    }\n\n    /// @notice Get the {Node} for the given work.\n    /// @param tokenId The token ID of the work.\n    /// @return The node for the work.\n    function node(uint256 tokenId) public view returns (Node memory) {\n        return Node({\n            nodeType: NodeType.TOKEN_ERC1155,\n            creator: Target({target: works[tokenId].creator, chainId: block.chainid}),\n            entity: Target({target: address(this), chainId: block.chainid}),\n            data: abi.encode(tokenId)\n        });\n    }\n\n    /// @notice Get the mint fee for one token for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @return The mint fee for the token.\n    function mintFee(uint256 tokenId_) public view returns (uint256) {\n        return mintFee(tokenId_, 1);\n    }\n\n    /// @notice Get the mint fee for an `amount` of tokens for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @param amount_ The amount of tokens to mint.\n    /// @return The mint fee for the tokens.\n    function mintFee(uint256 tokenId_, uint256 amount_) public view returns (uint256) {\n        if (tokenId_ == 0 || tokenId_ > totalWorks) return 0;\n        return FEE_MANAGER.getMintFee(works[tokenId_].strategy, amount_).amount;\n    }\n\n    /// @notice Mint a new token for the given work.\n    /// @param to_ The address to mint the token to.\n    /// @param tokenId_ The ID of the work to mint.\n    /// @param amount_ The amount of tokens to mint.\n    /// @param referrer_ The address of the referrer.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    function mint(\n        address to_,\n        uint256 tokenId_,\n        uint256 amount_,\n        address referrer_,\n        bytes calldata data_\n    ) external payable override {\n        // wake-disable-next-line reentrancy\n        FEE_MANAGER.collectMintFee{value: msg.value}(\n            this, tokenId_, amount_, msg.sender, referrer_, works[tokenId_].strategy\n        );\n\n        _issue(to_, tokenId_, amount_, data_);\n        _refundExcess();\n    }\n\n    /// @notice Mint a new token for the given work with a public comment.\n    /// @param to_ The address to mint the token to.\n    /// @param tokenId_ The ID of the work to mint.\n    /// @param amount_ The amount of tokens to mint.\n    /// @param referrer_ The address of the referrer.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    /// @param comment_ The public comment associated with the mint. Emitted as an event.\n    /// @dev This function is used to mint a token with a public comment, allowing the mint to be associated with a message which will be emitted as an event.\n    function mintWithComment(\n        address to_,\n        uint256 tokenId_,\n        uint256 amount_,\n        address referrer_,\n        bytes calldata data_,\n        string calldata comment_\n    ) external payable {\n        Strategy memory strategy = works[tokenId_].strategy;\n        // wake-disable-next-line reentrancy\n        FEE_MANAGER.collectMintFee{value: msg.value}(\n            this, tokenId_, amount_, msg.sender, referrer_, strategy\n        );\n\n        _issue(to_, tokenId_, amount_, data_);\n        _refundExcess();\n\n        emit Comment(address(this), tokenId_, to_, comment_);\n    }\n\n    /// @notice Mint multiple tokens for the given works.\n    /// @param to_ The address to mint the tokens to.\n    /// @param tokenIds_ The IDs of the works to mint.\n    /// @param amounts_ The amounts of each work to mint.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    function mintBatch(\n        address to_,\n        uint256[] calldata tokenIds_,\n        uint256[] calldata amounts_,\n        bytes calldata data_\n    ) external payable {\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\n            Work storage work = works[tokenIds_[i]];\n\n            // wake-disable-next-line reentrancy\n            FEE_MANAGER.collectMintFee{value: msg.value}(\n                this, tokenIds_[i], amounts_[i], msg.sender, address(0), work.strategy\n            );\n\n            _checkTime(work.opensAt, work.closesAt);\n            _updateSupply(work, amounts_[i]);\n        }\n\n        _batchMint(to_, tokenIds_, amounts_, data_);\n        _refundExcess();\n    }\n\n    /// @notice Mint a token to a set of receivers for the given work.\n    /// @param receivers_ The addresses to mint the tokens to.\n    /// @param tokenId_ The ID of the work to mint.\n    /// @param amount_ The amount of tokens to mint.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    function mintBatch(\n        address[] calldata receivers_,\n        uint256 tokenId_,\n        uint256 amount_,\n        bytes calldata data_\n    ) external payable {\n        // wake-disable-next-line reentrancy\n        FEE_MANAGER.collectMintFee{value: msg.value}(\n            this, tokenId_, amount_, msg.sender, address(0), works[tokenId_].strategy\n        );\n\n        for (uint256 i = 0; i < receivers_.length; i++) {\n            _issue(receivers_[i], tokenId_, amount_, data_);\n        }\n\n        _refundExcess();\n    }\n\n    /// @notice Mint a token from the given work to a set of receivers.\n    /// @param receivers_ The addresses to mint the tokens to.\n    /// @param tokenId_ The ID of the work to mint.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    /// @dev This function is used to mint one token for each receiver of a given work, bypassing mint fees. It is intended for promotional purposes.\n    function promoMint(address[] calldata receivers_, uint256 tokenId_, bytes calldata data_)\n        external\n        onlyOwnerOrRoles(EDITION_MANAGER_ROLE | EDITION_MINTER_ROLE)\n    {\n        for (uint256 i = 0; i < receivers_.length; i++) {\n            _issue(receivers_[i], tokenId_, 1, data_);\n        }\n    }\n\n    /// @notice Get the metadata for the given ID.\n    /// @param id_ The ID of the work, or `0` for the Edition.\n    /// @return The metadata for the ID.\n    function metadata(uint256 id_) external view returns (Metadata memory) {\n        return _metadata[id_];\n    }\n\n    /// @notice Get the maximum supply for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @return The maximum supply for the work.\n    function maxSupply(uint256 tokenId_) external view override returns (uint256) {\n        return works[tokenId_].maxSupply;\n    }\n\n    /// @notice Get the total supply for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @return The total supply for the work.\n    function totalSupply(uint256 tokenId_) external view override returns (uint256) {\n        return works[tokenId_].totalSupply;\n    }\n\n    /// @notice Get the fee strategy for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @return The fee strategy for the work.\n    function feeStrategy(uint256 tokenId_) external view override returns (Strategy memory) {\n        return works[tokenId_].strategy;\n    }\n\n    /// @notice Set the fee strategy for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @param strategy_ The fee strategy for the work.\n    /// @dev This function only updates the strategy locally and will NOT change the fee route.\n    function setFeeStrategy(uint256 tokenId_, Strategy calldata strategy_) external {\n        if (msg.sender != works[tokenId_].creator) revert Unauthorized();\n        works[tokenId_].strategy = FEE_MANAGER.validateStrategy(strategy_);\n    }\n\n    /// @notice Set the metadata for a given ID.\n    /// @param id_ The ID of the work, or `0` for the Edition\n    /// @param metadata_ The new metadata.\n    function setMetadata(uint256 id_, Metadata calldata metadata_) external {\n        // Only the owner can update the Edition metadata\n        if (id_ == 0 && msg.sender != owner()) revert Unauthorized();\n\n        // Only the creator can update the work metadata\n        if (id_ > 0 && msg.sender != works[id_].creator) revert Unauthorized();\n\n        _metadata[id_] = metadata_;\n    }\n\n    /// @notice Set the ERC2981 royalty target for the given work.\n    /// @param tokenId The ID of the work.\n    /// @param target The address to receive royalties.\n    function setRoyaltyTarget(uint256 tokenId, address target)\n        external\n        onlyRoles(EDITION_MANAGER_ROLE)\n    {\n        _setTokenRoyalty(tokenId, target, works[tokenId].strategy.royaltyBps);\n    }\n\n    /// @notice Sets the open and close times for the given work.\n    /// @param tokenId The ID of the work.\n    /// @param opensAt The timestamp after which the work is mintable.\n    /// @param closesAt The timestamp after which the work is no longer mintable.\n    /// @dev Only the creator of the work can call this function.\n    function setTimeframe(uint256 tokenId, uint64 opensAt, uint64 closesAt) external {\n        Work storage work = works[tokenId];\n        if (msg.sender != work.creator) revert Unauthorized();\n\n        // Update the open and close times for the work\n        work.opensAt = opensAt;\n        work.closesAt = closesAt;\n\n        emit TimeframeUpdated(address(this), tokenId, opensAt, closesAt);\n    }\n\n    function transferWork(address to_, uint256 tokenId_) external {\n        Work storage work = works[tokenId_];\n        if (msg.sender != work.creator) revert Unauthorized();\n\n        // Transfer the work to the new creator\n        work.creator = to_;\n\n        emit WorkTransferred(address(this), tokenId_, to_);\n    }\n\n    /// @inheritdoc OwnableRoles\n    function grantRoles(address user_, uint256 roles_)\n        public\n        payable\n        override\n        onlyRoles(EDITION_MANAGER_ROLE)\n    {\n        _grantRoles(user_, roles_);\n    }\n\n    /// @inheritdoc OwnableRoles\n    function revokeRoles(address user_, uint256 roles_)\n        public\n        payable\n        override\n        onlyRoles(EDITION_MANAGER_ROLE)\n    {\n        _removeRoles(user_, roles_);\n    }\n\n    /// @notice Grant the publisher role to the given address, allowing it to publish new works within the Edition.\n    /// @param publisher_ The address to grant the role to.\n    /// @dev This function is used by the owner or manager to grant the {EDITION_PUBLISHER_ROLE} to an address, allowing it to publish new works within the Edition.\n    function grantPublisherRole(address publisher_)\n        external\n        onlyRolesOrOwner(EDITION_MANAGER_ROLE)\n    {\n        _grantRoles(publisher_, EDITION_PUBLISHER_ROLE);\n    }\n\n    /// @notice Revoke the publisher role from the given address, preventing it from publishing new works. Does not affect existing works.\n    /// @param publisher_ The address to revoke the role from.\n    /// @dev This function is used by the owner or manager to revoke the {EDITION_PUBLISHER_ROLE} from an address, preventing it from publishing new works within the Edition.\n    function revokePublisherRole(address publisher_)\n        external\n        onlyRolesOrOwner(EDITION_MANAGER_ROLE)\n    {\n        _removeRoles(publisher_, EDITION_PUBLISHER_ROLE);\n    }\n\n    /// @notice Check if the contract supports the given interface.\n    /// @param interfaceId The interface ID to check.\n    /// @return True if the contract supports the interface, false otherwise.\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(IEdition, ERC1155, ERC2981)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /// @notice Issue tokens for the given work.\n    /// @param to_ The address to issue the tokens to.\n    /// @param tokenId_ The ID of the work to issue.\n    /// @param amount_ The amount of tokens to issue.\n    /// @param data_ The data associated with the issuance. Reserved for future use.\n    /// @dev This function is used by the {mint} and {mintBatch} functions to mint tokens and reverts if the new total supply would exceed the maximum supply.\n    function _issue(address to_, uint256 tokenId_, uint256 amount_, bytes calldata data_)\n        internal\n    {\n        Work storage work = works[tokenId_];\n        _checkTime(work.opensAt, work.closesAt);\n        _updateSupply(work, amount_);\n        _mint(to_, tokenId_, amount_, data_);\n        emit Minted(address(this), tokenId_, to_, amount_, data_);\n    }\n\n    /// @notice Update the total supply for the given work.\n    /// @param work The work to update.\n    /// @param amount_ The amount to add to the total supply.\n    /// @dev This function increments the total supply for a given work and reverts if the new total exceeds the maximum supply.\n    function _updateSupply(Work storage work, uint256 amount_) internal {\n        if ((work.totalSupply += amount_) > work.maxSupply) {\n            revert MaxSupplyReached();\n        }\n    }\n\n    /// @notice Checks that the current block time falls within the given range.\n    /// @param start_ The timestamp after which the work is mintable.\n    /// @param end_ The timestamp after which the work is no longer mintable.\n    /// @dev This function is used to check that the current block time falls within the given range and reverts if not.\n    function _checkTime(uint64 start_, uint64 end_) internal view {\n        if (block.timestamp < start_ || (end_ != 0 && block.timestamp > end_)) {\n            revert NotOpen(start_, end_);\n        }\n    }\n\n    /// @notice Refund any excess ETH sent to the contract.\n    /// @dev This function is called after minting tokens to refund any ETH left in the contract after all fees have been collected.\n    function _refundExcess() internal {\n        if (msg.value > 0 && address(this).balance > 0) {\n            msg.sender.safeTransferETH(address(this).balance);\n        }\n    }\n}"
    },
    {
      "filename": "src/tokens/ERC1155.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple ERC1155 implementation.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC1155.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC1155/ERC1155.sol)\n///\n/// @dev Note:\n/// - The ERC1155 standard allows for self-approvals.\n///   For performance, this implementation WILL NOT revert for such actions.\n///   Please add any checks with overrides if desired.\n/// - The transfer functions use the identity precompile (0x4)\n///   to copy memory internally.\n///\n/// If you are overriding:\n/// - Make sure all variables written to storage are properly cleaned\n//    (e.g. the bool value for `isApprovedForAll` MUST be either 1 or 0 under the hood).\n/// - Check that the overridden function is actually used in the function you want to\n///   change the behavior of. Much of the code has been manually inlined for performance.\nabstract contract ERC1155 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The lengths of the input arrays are not the same.\n    error ArrayLengthsMismatch();\n\n    /// @dev Cannot mint or transfer to the zero address.\n    error TransferToZeroAddress();\n\n    /// @dev The recipient's balance has overflowed.\n    error AccountBalanceOverflow();\n\n    /// @dev Insufficient balance.\n    error InsufficientBalance();\n\n    /// @dev Only the token owner or an approved account can manage the tokens.\n    error NotOwnerNorApproved();\n\n    /// @dev Cannot safely transfer to a contract that does not implement\n    /// the ERC1155Receiver interface.\n    error TransferToNonERC1155ReceiverImplementer();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Emitted when `amount` of token `id` is transferred\n    /// from `from` to `to` by `operator`.\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    /// @dev Emitted when `amounts` of token `ids` are transferred\n    /// from `from` to `to` by `operator`.\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\n\n    /// @dev Emitted when the Uniform Resource Identifier (URI) for token `id`\n    /// is updated to `value`. This event is not used in the base contract.\n    /// You may need to emit this event depending on your URI logic.\n    ///\n    /// See: https://eips.ethereum.org/EIPS/eip-1155#metadata\n    event URI(string value, uint256 indexed id);\n\n    /// @dev `keccak256(bytes(\"TransferSingle(address,address,address,uint256,uint256)\"))`.\n    uint256 private constant _TRANSFER_SINGLE_EVENT_SIGNATURE =\n        0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62;\n\n    /// @dev `keccak256(bytes(\"TransferBatch(address,address,address,uint256[],uint256[])\"))`.\n    uint256 private constant _TRANSFER_BATCH_EVENT_SIGNATURE =\n        0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb;\n\n    /// @dev `keccak256(bytes(\"ApprovalForAll(address,address,bool)\"))`.\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The `ownerSlotSeed` of a given owner is given by.\n    /// ```\n    ///     let ownerSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, owner))\n    /// ```\n    ///\n    /// The balance slot of `owner` is given by.\n    /// ```\n    ///     mstore(0x20, ownerSlotSeed)\n    ///     mstore(0x00, id)\n    ///     let balanceSlot := keccak256(0x00, 0x40)\n    /// ```\n    ///\n    /// The operator approval slot of `owner` is given by.\n    /// ```\n    ///     mstore(0x20, ownerSlotSeed)\n    ///     mstore(0x00, operator)\n    ///     let operatorApprovalSlot := keccak256(0x0c, 0x34)\n    /// ```\n    uint256 private constant _ERC1155_MASTER_SLOT_SEED = 0x9a31110384e0b0c9;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      ERC1155 METADATA                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the URI for token `id`.\n    ///\n    /// You can either return the same templated URI for all token IDs,\n    /// (e.g. \"https://example.com/api/{id}.json\"),\n    /// or return a unique URI for each `id`.\n    ///\n    /// See: https://eips.ethereum.org/EIPS/eip-1155#metadata\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          ERC1155                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the amount of `id` owned by `owner`.\n    function balanceOf(address owner, uint256 id) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, owner)\n            mstore(0x00, id)\n            result := sload(keccak256(0x00, 0x40))\n        }\n    }\n\n    /// @dev Returns whether `operator` is approved to manage the tokens of `owner`.\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, owner)\n            mstore(0x00, operator)\n            result := sload(keccak256(0x0c, 0x34))\n        }\n    }\n\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller.\n    ///\n    /// Emits a {ApprovalForAll} event.\n    function setApprovalForAll(address operator, bool isApproved) public virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`msg.sender`, `operator`).\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, caller())\n            mstore(0x00, operator)\n            sstore(keccak256(0x0c, 0x34), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            // forgefmt: disable-next-line\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), shr(96, shl(96, operator)))\n        }\n    }\n\n    /// @dev Transfers `amount` of `id` from `from` to `to`.\n    ///\n    /// Requirements:\n    /// - `to` cannot be the zero address.\n    /// - `from` must have at least `amount` of `id`.\n    /// - If the caller is not `from`,\n    ///   it must be approved to manage the tokens of `from`.\n    /// - If `to` refers to a smart contract, it must implement\n    ///   {ERC1155-onERC1155Reveived}, which is called upon a batch transfer.\n    ///\n    /// Emits a {TransferSingle} event.\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, to, _single(id), _single(amount), data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))\n            mstore(0x20, fromSlotSeed)\n            // Clear the upper 96 bits.\n            from := shr(96, fromSlotSeed)\n            to := shr(96, toSlotSeed)\n            // Revert if `to` is the zero address.\n            if iszero(to) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // If the caller is not `from`, do the authorization check.\n            if iszero(eq(caller(), from)) {\n                mstore(0x00, caller())\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Subtract and store the updated balance of `from`.\n            {\n                mstore(0x00, id)\n                let fromBalanceSlot := keccak256(0x00, 0x40)\n                let fromBalance := sload(fromBalanceSlot)\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n            }\n            // Increase and store the updated balance of `to`.\n            {\n                mstore(0x20, toSlotSeed)\n                let toBalanceSlot := keccak256(0x00, 0x40)\n                let toBalanceBefore := sload(toBalanceSlot)\n                let toBalanceAfter := add(toBalanceBefore, amount)\n                if lt(toBalanceAfter, toBalanceBefore) {\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceAfter)\n            }\n            // Emit a {TransferSingle} event.\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), from, to)\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, to, _single(id), _single(amount), data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Do the {onERC1155Received} check if `to` is a smart contract.\n            if extcodesize(to) {\n                // Prepare the calldata.\n                let m := mload(0x40)\n                // `onERC1155Received(address,address,uint256,uint256,bytes)`.\n                mstore(m, 0xf23a6e61)\n                mstore(add(m, 0x20), caller())\n                mstore(add(m, 0x40), from)\n                mstore(add(m, 0x60), id)\n                mstore(add(m, 0x80), amount)\n                mstore(add(m, 0xa0), 0xa0)\n                calldatacopy(add(m, 0xc0), sub(data.offset, 0x20), add(0x20, data.length))\n                // Revert if the call reverts.\n                if iszero(call(gas(), to, 0, add(m, 0x1c), add(0xc4, data.length), m, 0x20)) {\n                    if returndatasize() {\n                        // Bubble up the revert if the call reverts.\n                        returndatacopy(m, 0x00, returndatasize())\n                        revert(m, returndatasize())\n                    }\n                }\n                // Load the returndata and compare it with the function selector.\n                if iszero(eq(mload(m), shl(224, 0xf23a6e61))) {\n                    mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Transfers `amounts` of `ids` from `from` to `to`.\n    ///\n    /// Requirements:\n    /// - `to` cannot be the zero address.\n    /// - `from` must have at least `amount` of `id`.\n    /// - `ids` and `amounts` must have the same length.\n    /// - If the caller is not"
    }
  ]
}