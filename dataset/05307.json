{
  "Title": "[M-10] The owners of a rental safe can continue to use the old guard policy contract for as long as they want, regardless of a new guard policy upgrade",
  "Content": "\nPolicy contracts such as Guard.sol can be upgraded when needed. However, there is a vulnerability in existing implementation of Guard policy, that allows a rental safe contract to use the outdated Guard.sol for an unlimited amount of time.\n\nThis compromises the security of the rental wallet because unsafe transactions that are checked and reverted in the new guard policy contract can be directly bypassed and permitted in rental safe contract using an old guard policy.\n\n### Proof of Concept\n\nPolicy contracts can be upgraded by protocol executor on Kernel.sol through `executeAction()` -> `_activatePolicy()` -> `_deactivePolicy()`. When Guard.sol needs to be upgraded, the intended flow is a) `_activatePolicy(newGuard)` b) `_deactivePolicy(oldGuard)`, c) admin will whitelist a temporary migration contract which allows any rental safe wallet to make a delegate call to migration contract to upgrade the guard address in storage. This flow can also be confirmed in test: test/integration/upgradeability/GuardPolicyUpgrade.t.sol.\n\nNote in this intended flow, the rental safe contract owner needs to initiate a delegate call to the whitelisted migration contract to update the pointer to the new guard address.\n\nHowever, the issue is (1) there is no enforcement that an existing rental safe contract owner will call the migration contract to upgrade their guard address; (2)  even if the safe owner doesn't call to update their guard address, the rental safe will be able to continue to use the old guard contract to execute transactions, bypassing any new restrictions that might be enforced in the new guard.\n\nThis is because current Guard.sol's key user flows that involve `_checkTransactions()`, `_forwardToHook()`,`_revertNonWhiteListedExtensions()` won't check if the existing Guard.sol address stored in the safe contract is still active, and these flows will only call Storage.sol's view functions or public variables that have no access control to revert when the caller Guard.sol is no longer active in Kernel.\n\nAs a result, even though the active Guard.sol in Kernel.sol is a different address and the old guard doesn't exist in Kernel's storage, all the rental safe flows can still use the old guard to check transactions.\n\n<details>\n\n```solidity\n//src/policies/Guard.sol\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256,\n        uint256,\n        uint256,\n        address,\n        address payable,\n        bytes memory,\n        address\n    ) external override {\n        // Disallow transactions that use delegate call, unless explicitly\n        // permitted by the protocol.\n|>      //@audit There are no checks to see if address(this) (guard) is still active in Kernel.sol\n        //@audit note: when Guard.sol is no longer active, STORE.whitelistedDelegates(to) will still pass, because it's a view funciton with no access control\n|>      if (operation == Enum.Operation.DelegateCall && !STORE.whitelistedDelegates(to)) {\n            revert Errors.GuardPolicy_UnauthorizedDelegateCall(to);\n        }\n        // Require that a function selector exists.\n        if (data.length < 4) {\n            revert Errors.GuardPolicy_FunctionSelectorRequired();\n        }\n        // Fetch the hook to interact with for this transaction.\n        //@audit note: when Guard.sol is no longer active, STORE.contractToHook(to) and STORE.hookOnTransaction(hook) because they are view functions with no access control\n|>      address hook = STORE.contractToHook(to);\n|>      bool isActive = STORE.hookOnTransaction(hook);\n        // If a hook exists and is enabled, forward the control flow to the hook.\n        if (hook != address(0) && isActive) {\n            _forwardToHook(hook, msg.sender, to, value, data);\n        }\n        // If no hook exists, use basic tx check.\n        else {\n            _checkTransaction(msg.sender, to, data);\n        }\n    }\n```\n\n</details>\n\n(<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L324-L331>)\n\n<details>\n\n```solidity\n//src/policies/Guard.sol\n    function _checkTransaction(address from, address to, bytes memory data) private view {\n...\n            //@audit when Guard.sol is no longer active in Kernel, _revertSelectorOnActiveRental() will still work because it only calls view functions with no access control.\n|>          _revertSelectorOnActiveRental(selector, from, to, tokenId);\n...\n            //@audit when Guard.sol is no longer active in Kernel, _revertNonWhitelistedExtension() will still work because it only calls view function with no access control\n|>          _revertNonWhitelistedExtension(extension);\n    }\n\n    function _revertSelectorOnActiveRental(\n        bytes4 selector,\n        address safe,\n        address token,\n        uint256 tokenId\n    ) private view {\n        // Check if the selector is allowed.\n        //@audit when Guard.sol is no longer active in Kernel, STORE.isRentedOut() will still work because it only calls view function with no access control\n|>      if (STORE.isRentedOut(safe, token, tokenId)) {\n            revert Errors.GuardPolicy_UnauthorizedSelector(selector);\n        }\n    }\n\n    function _revertNonWhitelistedExtension(address extension) private view {\n        // Check if the extension is whitelisted.\n        //@audit when Guard.sol is no longer active in Kernel, STORE.whitelistedExtensions() will still work because it only calls view function with no access control\n|>       if (!STORE.whitelistedExtensions(extension)) {\n            revert Errors.GuardPolicy_UnauthorizedExtension(extension);\n        }\n    }\n```\n</details>\n\n(<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L133>)\n(<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L145>)\n\nIn addition, this creates a condition where the behaviors of different rental safe contracts can be uneven, depending on whether a specific rental safe is using a new guard or old guard, they might have different levels of restrictions in executions, which undermines the fairness in the rental process. For example, some new function selectors can be prohibited from execution in the new guard based on the protocol needs, but these selectors will continue to be allowed in rental safes that use the old guard.\n\nFor comparison, a rental safe using an old Stop policy (Stop.sol) will cause revert at `stopRent()` or `stopRentBatch()` flow due to failing permissioned function sig checks, which will force safe owners to migrate to the new Stop.sol. But an old Guard policy allows safe owners to continue using an outdated `checkTransaction()` logics, which I consider it high severity.\n\n### Recommended Mitigation Steps\n\nIn `checkTransaction()` , call Kernal.sol to check whether `address(this)` ( Guard.sol that the safe is pointing to) is still active. This can be done by calling `uint256 index = kernel.getPolicyIndex(address(this))` and then check if the index corresponds to `address(this)` in `kernel.activePolicies`.\n\n**[Alec1017 (reNFT) confirmed](https://github.com/code-423n4/2024-01-renft-findings/issues/267#issuecomment-1910526872)**\n\n**[0xean (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/267#issuecomment-1913247132):**\n > > This compromises the security of the rental wallet because unsafe transactions that are checked and reverted in the new guard policy contract can be directly bypassed and permitted in rental safe contract using an old guard policy.\n> \n> The warden doesn't show how this directly leads to loss of funds.  I think this falls into:\n> \n> >  but the function of the protocol or its availability could be impacted, \n> \n> Therefore should be M.\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/12) - Introduces `isActive` check on the guard policy. Ensures that safes cannot use a guard that has been deactivated.\n\n**Status:** Mitigation error. Full details in report from [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/61), and also included in the [Mitigation Review](#mitigation-review) section below.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-renft",
  "Code": [
    {
      "filename": "src/policies/Guard.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {BaseGuard} from \"@safe-contracts/base/GuardManager.sol\";\nimport {Enum} from \"@safe-contracts/common/Enum.sol\";\nimport {LibString} from \"@solady/utils/LibString.sol\";\n\nimport {IHook} from \"@src/interfaces/IHook.sol\";\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode} from \"@src/libraries/KernelUtils.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {\n    shared_set_approval_for_all_selector,\n    e721_approve_selector,\n    e721_safe_transfer_from_1_selector,\n    e721_safe_transfer_from_2_selector,\n    e721_transfer_from_selector,\n    e721_approve_token_id_offset,\n    e721_safe_transfer_from_1_token_id_offset,\n    e721_safe_transfer_from_2_token_id_offset,\n    e721_transfer_from_token_id_offset,\n    e1155_safe_transfer_from_selector,\n    e1155_safe_batch_transfer_from_selector,\n    e1155_safe_transfer_from_token_id_offset,\n    e1155_safe_batch_transfer_from_token_id_offset,\n    gnosis_safe_set_guard_selector,\n    gnosis_safe_enable_module_selector,\n    gnosis_safe_disable_module_selector,\n    gnosis_safe_enable_module_offset,\n    gnosis_safe_disable_module_offset\n} from \"@src/libraries/RentalConstants.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\n\n/**\n * @title Guard\n * @notice Acts as an interface for all behavior related to guarding transactions\n *         that originate from a rental wallet.\n */\ncontract Guard is Policy, BaseGuard {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](1);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n    }\n\n    /**\n     * @notice Upon policy activation, permissions are requested from the kernel to access\n     *         particular keycode <> function selector pairs. Once these permissions are\n     *         granted, they do not change and can only be revoked when the policy is\n     *         deactivated by the kernel.\n     *\n     * @return requests Array of keycode <> function selector pairs which represent\n     *                  permissions for the policy.\n     */\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](2);\n        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.updateHookPath.selector);\n        requests[1] = Permissions(toKeycode(\"STORE\"), STORE.updateHookStatus.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            Internal Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Loads a `bytes32` value from calldata.\n     *\n     * @param data   Calldata of the transaction to execute.\n     * @param offset Byte offset where the value starts.\n     *\n     * @return value The value retrieved from the data.\n     */\n    function _loadValueFromCalldata(\n        bytes memory data,\n        uint256 offset\n    ) private pure returns (bytes32 value) {\n        // Load the `uint256` from calldata at the offset.\n        assembly {\n            value := mload(add(data, offset))\n        }\n    }\n\n    /**\n     * @dev Reverts if the token is actively rented.\n     *\n     * @param selector Function selector which cannot be called\n     * @param safe     Address of the safe that originated the call\n     * @param token    Address of the token which is actively rented.\n     * @param tokenId  ID of the token which is actively rented.\n     */\n    function _revertSelectorOnActiveRental(\n        bytes4 selector,\n        address safe,\n        address token,\n        uint256 tokenId\n    ) private view {\n        // Check if the selector is allowed.\n        if (STORE.isRentedOut(safe, token, tokenId)) {\n            revert Errors.GuardPolicy_UnauthorizedSelector(selector);\n        }\n    }\n\n    /**\n     * @dev Reverts if the extension is not whitelisted.\n     *\n     * @param extension Address of the extension.\n     */\n    function _revertNonWhitelistedExtension(address extension) private view {\n        // Check if the extension is whitelisted.\n        if (!STORE.whitelistedExtensions(extension)) {\n            revert Errors.GuardPolicy_UnauthorizedExtension(extension);\n        }\n    }\n\n    /**\n     * @dev Forwards a gnosis safe call to a hook contract for further processing.\n     *\n     * @param hook  Address of the hook contract.\n     * @param safe  Address of the rental wallet that originated the call.\n     * @param to    Address that the call is directed to.\n     * @param value Value of ether sent with the call.\n     * @param data  Calldata to execute.\n     */\n    function _forwardToHook(\n        address hook,\n        address safe,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) private {\n        // Call the `onTransaction` hook function.\n        try IHook(hook).onTransaction(safe, to, value, data) {} catch Error(\n            string memory revertReason\n        ) {\n            // Revert with reason given.\n            revert Errors.Shared_HookFailString(revertReason);\n        } catch Panic(uint256 errorCode) {\n            // Convert solidity panic code to string.\n            string memory stringErrorCode = LibString.toString(errorCode);\n\n            // Revert with panic code.\n            revert Errors.Shared_HookFailString(\n                string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n            );\n        } catch (bytes memory revertData) {\n            // Fallback to an error that returns the byte data.\n            revert Errors.Shared_HookFailBytes(revertData);\n        }\n    }\n\n    /**\n     * @dev Prevent transactions that involve transferring an ERC721 or ERC1155 in any\n     *      way, and prevent transactions that involve changing the modules or the\n     *      guard contract.\n     *\n     * @param from Rental safe address that initiated the transaction.\n     * @param to Address that the data is targetted to.\n     * @param data Calldata of the transaction.\n     */\n    function _checkTransaction(address from, address to, bytes memory data) private view {\n        bytes4 selector;\n\n        // Load in the function selector.\n        assembly {\n            selector := mload(add(data, 0x20))\n        }\n\n        if (selector == e721_safe_transfer_from_1_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e721_safe_transfer_from_1_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n        } else if (selector == e721_safe_transfer_from_2_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e721_safe_transfer_from_2_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n        } else if (selector == e721_transfer_from_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e721_transfer_from_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n        } else if (selector == e721_approve_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e721_approve_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n        } else if (selector == e1155_safe_transfer_from_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e1155_safe_transfer_from_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n        } else if (selector == gnosis_safe_enable_module_selector) {\n            // Load the extension address from calldata.\n            address extension = address(\n                uint160(\n                    uint256(\n                        _loadValueFromCalldata(data, gnosis_safe_enable_module_offset)\n                    )\n                )\n            );\n\n            // Check if the extension is whitelisted.\n            _revertNonWhitelistedExtension(extension);\n        } else if (selector == gnosis_safe_disable_module_selector) {\n            // Load the extension address from calldata.\n            address extension = address(\n                uint160(\n                    uint256(\n                        _loadValueFromCalldata(data, gnosis_safe_disable_module_offset)\n                    )\n                )\n            );\n\n            // Check if the extension is whitelisted.\n            _revertNonWhitelistedExtension(extension);\n        } else {\n            // Revert if the `setApprovalForAll` selector is specified. This selector is\n            // shared between ERC721 and ERC1155 tokens.\n            if (selector == shared_set_approval_for_all_selector) {\n                revert Errors.GuardPolicy_UnauthorizedSelector(\n                    shared_set_approval_for_all_selector\n                );\n            }\n\n            // Revert if the `safeBatchTransferFrom` selector is specified. There's no\n            // cheap way to check if individual items in the batch are rented out.\n            // Each token ID would require a call to the storage contract to check\n            // its rental status.\n            if (selector == e1155_safe_batch_transfer_from_selector) {\n                revert Errors.GuardPolicy_UnauthorizedSelector(\n                    e1155_safe_batch_transfer_from_selector\n                );\n            }\n\n            // Revert if the `setGuard` selector is specified.\n            if (selector == gnosis_safe_set_guard_selector) {\n                revert Errors.GuardPolicy_UnauthorizedSelector(\n                    gnosis_safe_set_guard_selector\n                );\n            }\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /** @notice Checks a transaction initiated by a rental safe to decide whether\n     *          it can be allowed or not. During this check, execution control flow\n     *          will be passed to an external hook contract if one exists for the\n     *          target contract.\n     *\n     * @param to             Destination address of Safe transaction.\n     * @param value          Ether value of Safe transaction.\n     * @param data           Data payload of Safe transaction.\n     * @param operation      Operation type of Safe transaction.\n     */\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256,\n        uint256,\n        uint256,\n        address,\n        address payable,\n        bytes memory,\n        address\n    ) external override {\n        // Disallow transactions that use delegate call, unless explicitly\n        // permitted by the protocol.\n        if (operation == Enum.Operation.DelegateCall && !STORE.whitelistedDelegates(to)) {\n            revert Errors.GuardPolicy_UnauthorizedDelegateCall(to);\n        }\n\n        // Require that a function selector exists.\n        if (data.length < 4) {\n            revert Errors.GuardPolicy_FunctionSelectorRequired();\n        }\n\n        // Fetch the hook to interact with for this transaction.\n        address hook = STORE.contractToHook(to);\n        bool isActive = STORE.hookOnTransaction(hook);\n\n        // If a hook exists and is enabled, forward the control flow to the hook.\n        if (hook != address(0) && isActive) {\n            _forwardToHook(hook, msg.sender, to, value, data);\n        }\n        // If no hook exists, use basic tx check.\n        else {\n            _checkTransaction(msg.sender, to, data);\n        }\n    }\n\n    /**\n     * @notice Performs any checks after execution. This is left unimplemented.\n     *\n     * @param txHash Hash of the transaction.\n     * @param success Whether the transaction succeeded.\n     */\n    function checkAfterExecution(bytes32 txHash, bool success) external override {}\n\n    /**\n     * @notice Connects a target contract to a hook.\n     *\n     * @param to   The destination contract of a call.\n     * @param hook The hook middleware contract to sit between the call\n     *             and the destination.\n     */\n    function updateHookPath(address to, address hook) external onlyRole(\"GUARD_ADMIN\") {\n        STORE.updateHookPath(to, hook);\n    }\n\n    /**\n     * @notice Toggle the status of a hook contract, which defines the functionality\n     *         that the hook supports.\n     *\n     * @param hook The hook contract address.\n     * @param bitmap Bitmap of the status.\n     */\n    function updateHookStatus(\n        address hook,\n        uint8 bitmap\n    ) external onlyRole(\"GUARD_ADMIN\") {\n        STORE.updateHookStatus(hook, bitmap);\n    }\n}"
    },
    {
      "filename": "src/policies/Guard.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {BaseGuard} from \"@safe-contracts/base/GuardManager.sol\";\nimport {Enum} from \"@safe-contracts/common/Enum.sol\";\nimport {LibString} from \"@solady/utils/LibString.sol\";\n\nimport {IHook} from \"@src/interfaces/IHook.sol\";\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode} from \"@src/libraries/KernelUtils.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {\n    shared_set_approval_for_all_selector,\n    e721_approve_selector,\n    e721_safe_transfer_from_1_selector,\n    e721_safe_transfer_from_2_selector,\n    e721_transfer_from_selector,\n    e721_approve_token_id_offset,\n    e721_safe_transfer_from_1_token_id_offset,\n    e721_safe_transfer_from_2_token_id_offset,\n    e721_transfer_from_token_id_offset,\n    e1155_safe_transfer_from_selector,\n    e1155_safe_batch_transfer_from_selector,\n    e1155_safe_transfer_from_token_id_offset,\n    e1155_safe_batch_transfer_from_token_id_offset,\n    gnosis_safe_set_guard_selector,\n    gnosis_safe_enable_module_selector,\n    gnosis_safe_disable_module_selector,\n    gnosis_safe_enable_module_offset,\n    gnosis_safe_disable_module_offset\n} from \"@src/libraries/RentalConstants.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\n\n/**\n * @title Guard\n * @notice Acts as an interface for all behavior related to guarding transactions\n *         that originate from a rental wallet.\n */\ncontract Guard is Policy, BaseGuard {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](1);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n    }\n\n    /**\n     * @notice Upon policy activation, permissions are requested from the kernel to access\n     *         particular keycode <> function selector pairs. Once these permissions are\n     *         granted, they do not change and can only be revoked when the policy is\n     *         deactivated by the kernel.\n     *\n     * @return requests Array of keycode <> function selector pairs which represent\n     *                  permissions for the policy.\n     */\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](2);\n        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.updateHookPath.selector);\n        requests[1] = Permissions(toKeycode(\"STORE\"), STORE.updateHookStatus.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            Internal Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Loads a `bytes32` value from calldata.\n     *\n     * @param data   Calldata of the transaction to execute.\n     * @param offset Byte offset where the value starts.\n     *\n     * @return value The value retrieved from the data.\n     */\n    function _loadValueFromCalldata(\n        bytes memory data,\n        uint256 offset\n    ) private pure returns (bytes32 value) {\n        // Load the `uint256` from calldata at the offset.\n        assembly {\n            value := mload(add(data, offset))\n        }\n    }\n\n    /**\n     * @dev Reverts if the token is actively rented.\n     *\n     * @param selector Function selector which cannot be called\n     * @param safe     Address of the safe that originated the call\n     * @param token    Address of the token which is actively rented.\n     * @param tokenId  ID of the token which is actively rented.\n     */\n    function _revertSelectorOnActiveRental(\n        bytes4 selector,\n        address safe,\n        address token,\n        uint256 tokenId\n    ) private view {\n        // Check if the selector is allowed.\n        if (STORE.isRentedOut(safe, token, tokenId)) {\n            revert Errors.GuardPolicy_UnauthorizedSelector(selector);\n        }\n    }\n\n    /**\n     * @dev Reverts if the extension is not whitelisted.\n     *\n     * @param extension Address of the extension.\n     */\n    function _revertNonWhitelistedExtension(address extension) private view {\n        // Check if the extension is whitelisted.\n        if (!STORE.whitelistedExtensions(extension)) {\n            revert Errors.GuardPolicy_UnauthorizedExtension(extension);\n        }\n    }\n\n    /**\n     * @dev Forwards a gnosis safe call to a hook contract for further processing.\n     *\n     * @param hook  Address of the hook contract.\n     * @param safe  Address of the rental wallet that originated the call.\n     * @param to    Address that the call is directed to.\n     * @param value Value of ether sent with the call.\n     * @param data  Calldata to execute.\n     */\n    function _forwardToHook(\n        address hook,\n        address safe,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) private {\n        // Call the `onTransaction` hook function.\n        try IHook(hook).onTransaction(safe, to, value, data) {} catch Error(\n            string memory revertReason\n        ) {\n            // Revert with reason given.\n            revert Errors.Shared_HookFailString(revertReason);\n        } catch Panic(uint256 errorCode) {\n            // Convert solidity panic code to string.\n            string memory stringErrorCode = LibString.toString(errorCode);\n\n            // Revert with panic code.\n            revert Errors.Shared_HookFailString(\n                string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n            );\n        } catch (bytes memory revertData) {\n            // Fallback to an error that returns the byte data.\n            revert Errors.Shared_HookFailBytes(revertData);\n        }\n    }\n\n    /**\n     * @dev Prevent transactions that involve transferring an ERC721 or ERC1155 in any\n     *      way, and prevent transactions that involve changing the modules or the\n     *      guard contract.\n     *\n     * @param from Rental safe address that initiated the transaction.\n     * @param to Address that the data is targetted to.\n     * @param data Calldata of the transaction.\n     */\n    function _checkTransaction(address from, address to, bytes memory data) private view {\n        bytes4 selector;\n\n        // Load in the function selector.\n        assembly {\n            selector := mload(add(data, 0x20))\n        }\n\n        if (selector == e721_safe_transfer_from_1_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e721_safe_transfer_from_1_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n        } else if (selector == e721_safe_transfer_from_2_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e721_safe_transfer_from_2_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n        } else if (selector == e721_transfer_from_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e721_transfer_from_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n        } else if (selector == e721_approve_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e721_approve_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n        } else if (selector == e1155_safe_transfer_from_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e1155_safe_transfer_from_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n        } else if (selector == gnosis_safe_enable_module_selector) {\n            // Load the extension address from calldata.\n            address extension = address(\n                uint160(\n                    uint256(\n                        _loadValueFromCalldata(data, gnosis_safe_enable_module_offset)\n                    )\n                )\n            );\n\n            // Check if the extension is whitelisted.\n            _revertNonWhitelistedExtension(extension);\n        } else if (selector == gnosis_safe_disable_module_selector) {\n            // Load the extension address from calldata.\n            address extension = address(\n                uint160(\n                    uint256(\n                        _loadValueFromCalldata(data, gnosis_safe_disable_module_offset)\n                    )\n                )\n            );\n\n            // Check if the extension is whitelisted.\n            _revertNonWhitelistedExtension(extension);\n        } else {\n            // Revert if the `setApprovalForAll` selector is specified. This selector is\n            // shared between ERC721 and ERC1155 tokens.\n            if (selector == shared_set_approval_for_all_selector) {\n                revert Errors.GuardPolicy_UnauthorizedSelector(\n                    shared_set_approval_for_all_selector\n                );\n            }\n\n            // Revert if the `safeBatchTransferFrom` selector is specified. There's no\n            // cheap way to check if individual items in the batch are rented out.\n            // Each token ID would require a call to the storage contract to check\n            // its rental status.\n            if (selector == e1155_safe_batch_transfer_from_selector) {\n                revert Errors.GuardPolicy_UnauthorizedSelector(\n                    e1155_safe_batch_transfer_from_selector\n                );\n            }\n\n            // Revert if the `setGuard` selector is specified.\n            if (selector == gnosis_safe_set_guard_selector) {\n                revert Errors.GuardPolicy_UnauthorizedSelector(\n                    gnosis_safe_set_guard_selector\n                );\n            }\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /** @notice Checks a transaction initiated by a rental safe to decide whether\n     *          it can be allowed or not. During this check, execution control flow\n     *          will be passed to an external hook contract if one exists for the\n     *          target contract.\n     *\n     * @param to             Destination address of Safe transaction.\n     * @param value          Ether value of Safe transaction.\n     * @param data           Data payload of Safe transaction.\n     * @param operation      Operation type of Safe transaction.\n     */\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256,\n        uint256,\n        uint256,\n        address,\n        address payable,\n        bytes memory,\n        address\n    ) external override {\n        // Disallow transactions that use delegate call, unless explicitly\n        // permitted by the protocol.\n        if (operation == Enum.Operation.DelegateCall && !STORE.whitelistedDelegates(to)) {\n            revert Errors.GuardPolicy_UnauthorizedDelegateCall(to);\n        }\n\n        // Require that a function selector exists.\n        if (data.length < 4) {\n            revert Errors.GuardPolicy_FunctionSelectorRequired();\n        }\n\n        // Fetch the hook to interact with for this transaction.\n        address hook = STORE.contractToHook(to);\n        bool isActive = STORE.hookOnTransaction(hook);\n\n        // If a hook exists and is enabled, forward the control flow to the hook.\n        if (hook != address(0) && isActive) {\n            _forwardToHook(hook, msg.sender, to, value, data);\n        }\n        // If no hook exists, use basic tx check.\n        else {\n            _checkTransaction(msg.sender, to, data);\n        }\n    }\n\n    /**\n     * @notice Performs any checks after execution. This is left unimplemented.\n     *\n     * @param txHash Hash of the transaction.\n     * @param success Whether the transaction succeeded.\n     */\n    function checkAfterExecution(bytes32 txHash, bool success) external override {}\n\n    /**\n     * @notice Connects a target contract to a hook.\n     *\n     * @param to   The destination contract of a call.\n     * @param hook The hook middleware contract to sit between the call\n     *             and the destination.\n     */\n    function updateHookPath(address to, address hook) external onlyRole(\"GUARD_ADMIN\") {\n        STORE.updateHookPath(to, hook);\n    }\n\n    /**\n     * @notice Toggle the status of a hook contract, which defines the functionality\n     *         that the hook supports.\n     *\n     * @param hook The hook contract address.\n     * @param bitmap Bitmap of the status.\n     */\n    function updateHookStatus(\n        address hook,\n        uint8 bitmap\n    ) external onlyRole(\"GUARD_ADMIN\") {\n        STORE.updateHookStatus(hook, bitmap);\n    }\n}"
    },
    {
      "filename": "src/policies/Guard.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {BaseGuard} from \"@safe-contracts/base/GuardManager.sol\";\nimport {Enum} from \"@safe-contracts/common/Enum.sol\";\nimport {LibString} from \"@solady/utils/LibString.sol\";\n\nimport {IHook} from \"@src/interfaces/IHook.sol\";\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode} from \"@src/libraries/KernelUtils.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {\n    shared_set_approval_for_all_selector,\n    e721_approve_selector,\n    e721_safe_transfer_from_1_selector,\n    e721_safe_transfer_from_2_selector,\n    e721_transfer_from_selector,\n    e721_approve_token_id_offset,\n    e721_safe_transfer_from_1_token_id_offset,\n    e721_safe_transfer_from_2_token_id_offset,\n    e721_transfer_from_token_id_offset,\n    e1155_safe_transfer_from_selector,\n    e1155_safe_batch_transfer_from_selector,\n    e1155_safe_transfer_from_token_id_offset,\n    e1155_safe_batch_transfer_from_token_id_offset,\n    gnosis_safe_set_guard_selector,\n    gnosis_safe_enable_module_selector,\n    gnosis_safe_disable_module_selector,\n    gnosis_safe_enable_module_offset,\n    gnosis_safe_disable_module_offset\n} from \"@src/libraries/RentalConstants.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\n\n/**\n * @title Guard\n * @notice Acts as an interface for all behavior related to guarding transactions\n *         that originate from a rental wallet.\n */\ncontract Guard is Policy, BaseGuard {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](1);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n    }\n\n    /**\n     * @notice Upon policy activation, permissions are requested from the kernel to access\n     *         particular keycode <> function selector pairs. Once these permissions are\n     *         granted, they do not change and can only be revoked when the policy is\n     *         deactivated by the kernel.\n     *\n     * @return requests Array of keycode <> function selector pairs which represent\n     *                  permissions for the policy.\n     */\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](2);\n        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.updateHookPath.selector);"
    }
  ]
}