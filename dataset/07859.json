{
  "Title": "[G-01] Optimize NFT delegate deployments by using proxy",
  "Content": "\n<https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateDeployer.sol#L115>\n\nThe cost of NFT delegate deployments can be significantly reduced by deploying proxies instead of clones of the implementation.\n\n### Proof of Concept\n\nThis function is used to deploy new NFT delegates ([JBTiered721DelegateDeployer.sol#L115](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateDeployer.sol#L115)):\n\n```solidity\nfunction _clone(address _targetAddress) internal returns (address _out) {\n  assembly {\n    // Get deployed/runtime code size\n    let _codeSize := extcodesize(_targetAddress)\n\n    // Get a bit of freemem to land the bytecode, not updated as we'll leave this scope right after create(..)\n    let _freeMem := mload(0x40)\n\n    // Shift the length to the length placeholder, in the constructor\n    let _mask := mul(_codeSize, 0x100000000000000000000000000000000000000000000000000000000)\n\n    // Insert the length in the correct sport (after the PUSH3 / 0x62)\n    let _initCode := or(_mask, 0x62000000600081600d8239f3fe00000000000000000000000000000000000000)\n\n    // Store the deployment bytecode\n    mstore(_freeMem, _initCode)\n\n    // Copy the bytecode (our initialise part is 13 bytes long)\n    extcodecopy(_targetAddress, add(_freeMem, 13), 0, _codeSize)\n\n    // Deploy the copied bytecode\n    _out := create(0, _freeMem, _codeSize)\n  }\n```\n\nIt copies the code of an existing contract (`JBTiered721Delegate`, `JB721TieredGovernance`, or `JB721GlobalGovernance`) and deploys a new contract with the same code. This is a costly operation because each of the three contracts is a big contract with a lot of code. It'll be much cheaper to deploy non-upgradable proxies instead.\n\n### Recommended Mitigation Steps\n\nConsider using [the Clones library from OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/Clones.sol)â€“it deploys and absolutely minimal non-upgradable proxy contract. Such proxies, however, [cannot be verified on Etherscan](https://forum.openzeppelin.com/t/how-to-verify-contracts-created-using-clonesupgradeable-clonedeterministic/7746/3). [Some more info](https://blog.openzeppelin.com/workshop-recap-cheap-contract-deployment-through-clones/).\n\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2022-10-juicebox-findings/issues/133#issuecomment-1307653316):**\n > Depending on the number of deployments this could be the biggest gas saving so far.\n\n**[drgorillamd (Juicebox DAO) commented](https://github.com/code-423n4/2022-10-juicebox-findings/issues/133#issuecomment-1318661319):**\n > @Picodes (judge) we didn't use proxies for 2 reasons (it would have obviously been easier;):\n> - this is shifting the gas burden -> each call cost an extra call() cost to the users (on a cold address, that's at least 2600)\n> - the saving of deploying a proxy is a one off, for the project owner, while the gas saved on every call is cumulative through time (and might end up being bigger)\n> \n> \\+ even if using a non-upgradeable proxy, some users have concern with such (I know, ux/docs/education is out of scope;)\n> \n> In summary, not convinced this would be the biggest gas saving, on an overall basis\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2022-10-juicebox-findings/issues/133#issuecomment-1318951912):**\n > Indeed it totally depends on the usage! \n> \n> Giving this option to users could easily save a lot of gas for projects that expect only a few transactions. I also selected this report as it's the only one suggesting this.\n> \n> The deployment of the clone contract would be only `<50k` gas and then per call `<2k` (700 for the `DELEGATECALL` , `2600` for the cold address and then the memory expansion) so it'd be worth it for projects with less than a few hundred transactions.\n\n\n***\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-10-juicebox-contest",
  "Code": [
    {
      "filename": "contracts/JBTiered721DelegateDeployer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport './interfaces/IJBTiered721DelegateDeployer.sol';\nimport './JBTiered721Delegate.sol';\nimport './JB721TieredGovernance.sol';\nimport './JB721GlobalGovernance.sol';\n\n/**\n  @notice\n  Deploys a tier delegate.\n\n  @dev\n  Adheres to -\n  IJBTiered721DelegateDeployer: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.\n*/\ncontract JBTiered721DelegateDeployer is IJBTiered721DelegateDeployer {\n  error INVALID_GOVERNANCE_TYPE();\n\n  //*********************************************************************//\n  // --------------- public immutable stored properties ---------------- //\n  //*********************************************************************//\n\n  /** \n    @notice \n    The contract that supports on-chain governance across all tiers. \n  */\n  JB721GlobalGovernance public immutable globalGovernance;\n\n  /** \n    @notice \n    The contract that supports on-chain governance per-tier. \n  */\n  JB721TieredGovernance public immutable tieredGovernance;\n\n  /** \n    @notice \n    The contract that has no on-chain governance. \n  */\n  JBTiered721Delegate public immutable noGovernance;\n\n  //*********************************************************************//\n  // -------------------------- constructor ---------------------------- //\n  //*********************************************************************//\n\n  constructor(\n    JB721GlobalGovernance _globalGovernance,\n    JB721TieredGovernance _tieredGovernance,\n    JBTiered721Delegate _noGovernance\n  ) {\n    globalGovernance = _globalGovernance;\n    tieredGovernance = _tieredGovernance;\n    noGovernance = _noGovernance;\n  }\n\n  //*********************************************************************//\n  // ---------------------- external transactions ---------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice\n    Deploys a delegate.\n\n    @param _projectId The ID of the project this contract's functionality applies to.\n    @param _deployTiered721DelegateData Data necessary to fulfill the transaction to deploy a delegate.\n\n    @return newDelegate The address of the newly deployed delegate.\n  */\n  function deployDelegateFor(\n    uint256 _projectId,\n    JBDeployTiered721DelegateData memory _deployTiered721DelegateData\n  ) external override returns (IJBTiered721Delegate) {\n    // Deploy the governance variant that was requested\n    address codeToCopy;\n    if (_deployTiered721DelegateData.governanceType == JB721GovernanceType.NONE)\n      codeToCopy = address(noGovernance);\n    else if (_deployTiered721DelegateData.governanceType == JB721GovernanceType.TIERED)\n      codeToCopy = address(tieredGovernance);\n    else if (_deployTiered721DelegateData.governanceType == JB721GovernanceType.GLOBAL)\n      codeToCopy = address(globalGovernance);\n    else revert INVALID_GOVERNANCE_TYPE();\n\n    JB721GlobalGovernance newDelegate = JB721GlobalGovernance(_clone(codeToCopy));\n    newDelegate.initialize(\n      _projectId,\n      _deployTiered721DelegateData.directory,\n      _deployTiered721DelegateData.name,\n      _deployTiered721DelegateData.symbol,\n      _deployTiered721DelegateData.fundingCycleStore,\n      _deployTiered721DelegateData.baseUri,\n      _deployTiered721DelegateData.tokenUriResolver,\n      _deployTiered721DelegateData.contractUri,\n      _deployTiered721DelegateData.pricing,\n      _deployTiered721DelegateData.store,\n      _deployTiered721DelegateData.flags\n    );\n\n    // Transfer the ownership to the specified address.\n    if (_deployTiered721DelegateData.owner != address(0))\n      newDelegate.transferOwnership(_deployTiered721DelegateData.owner);\n\n    emit DelegateDeployed(_projectId, newDelegate, _deployTiered721DelegateData.governanceType);\n\n    return newDelegate;\n  }\n\n  /**\n    @notice Clone and redeploy the bytecode of a given address\n\n    @dev Runtime bytecode needs a constructor -> we append this one\n         to the bytecode, which is a minimalistic one only returning the runtime bytecode\n\n         See https://github.com/drgorillamd/clone-deployed-contract/blob/master/readme.MD for details\n   */\n  function _clone(address _targetAddress) internal returns (address _out) {\n    assembly {\n      // Get deployed/runtime code size\n      let _codeSize := extcodesize(_targetAddress)\n\n      // Get a bit of freemem to land the bytecode, not updated as we'll leave this scope right after create(..)\n      let _freeMem := mload(0x40)\n\n      // Shift the length to the length placeholder, in the constructor\n      let _mask := mul(_codeSize, 0x100000000000000000000000000000000000000000000000000000000)\n\n      // Insert the length in the correct sport (after the PUSH3 / 0x62)\n      let _initCode := or(_mask, 0x62000000600081600d8239f3fe00000000000000000000000000000000000000)\n\n      // Store the deployment bytecode\n      mstore(_freeMem, _initCode)\n\n      // Copy the bytecode (our initialise part is 13 bytes long)\n      extcodecopy(_targetAddress, add(_freeMem, 13), 0, _codeSize)\n\n      // Deploy the copied bytecode\n      _out := create(0, _freeMem, _codeSize)\n    }\n  }\n}"
    },
    {
      "filename": "contracts/JBTiered721DelegateDeployer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport './interfaces/IJBTiered721DelegateDeployer.sol';\nimport './JBTiered721Delegate.sol';\nimport './JB721TieredGovernance.sol';\nimport './JB721GlobalGovernance.sol';\n\n/**\n  @notice\n  Deploys a tier delegate.\n\n  @dev\n  Adheres to -\n  IJBTiered721DelegateDeployer: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.\n*/\ncontract JBTiered721DelegateDeployer is IJBTiered721DelegateDeployer {\n  error INVALID_GOVERNANCE_TYPE();\n\n  //*********************************************************************//\n  // --------------- public immutable stored properties ---------------- //\n  //*********************************************************************//\n\n  /** \n    @notice \n    The contract that supports on-chain governance across all tiers. \n  */\n  JB721GlobalGovernance public immutable globalGovernance;\n\n  /** \n    @notice \n    The contract that supports on-chain governance per-tier. \n  */\n  JB721TieredGovernance public immutable tieredGovernance;\n\n  /** \n    @notice \n    The contract that has no on-chain governance. \n  */\n  JBTiered721Delegate public immutable noGovernance;\n\n  //*********************************************************************//\n  // -------------------------- constructor ---------------------------- //\n  //*********************************************************************//\n\n  constructor(\n    JB721GlobalGovernance _globalGovernance,\n    JB721TieredGovernance _tieredGovernance,\n    JBTiered721Delegate _noGovernance\n  ) {\n    globalGovernance = _globalGovernance;\n    tieredGovernance = _tieredGovernance;\n    noGovernance = _noGovernance;\n  }\n\n  //*********************************************************************//\n  // ---------------------- external transactions ---------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice\n    Deploys a delegate.\n\n    @param _projectId The ID of the project this contract's functionality applies to.\n    @param _deployTiered721DelegateData Data necessary to fulfill the transaction to deploy a delegate.\n\n    @return newDelegate The address of the newly deployed delegate.\n  */\n  function deployDelegateFor(\n    uint256 _projectId,\n    JBDeployTiered721DelegateData memory _deployTiered721DelegateData\n  ) external override returns (IJBTiered721Delegate) {\n    // Deploy the governance variant that was requested\n    address codeToCopy;\n    if (_deployTiered721DelegateData.governanceType == JB721GovernanceType.NONE)\n      codeToCopy = address(noGovernance);\n    else if (_deployTiered721DelegateData.governanceType == JB721GovernanceType.TIERED)\n      codeToCopy = address(tieredGovernance);\n    else if (_deployTiered721DelegateData.governanceType == JB721GovernanceType.GLOBAL)\n      codeToCopy = address(globalGovernance);\n    else revert INVALID_GOVERNANCE_TYPE();\n\n    JB721GlobalGovernance newDelegate = JB721GlobalGovernance(_clone(codeToCopy));\n    newDelegate.initialize(\n      _projectId,\n      _deployTiered721DelegateData.directory,\n      _deployTiered721DelegateData.name,\n      _deployTiered721DelegateData.symbol,\n      _deployTiered721DelegateData.fundingCycleStore,\n      _deployTiered721DelegateData.baseUri,\n      _deployTiered721DelegateData.tokenUriResolver,\n      _deployTiered721DelegateData.contractUri,\n      _deployTiered721DelegateData.pricing,\n      _deployTiered721DelegateData.store,\n      _deployTiered721DelegateData.flags\n    );\n\n    // Transfer the ownership to the specified address.\n    if (_deployTiered721DelegateData.owner != address(0))\n      newDelegate.transferOwnership(_deployTiered721DelegateData.owner);\n\n    emit DelegateDeployed(_projectId, newDelegate, _deployTiered721DelegateData.governanceType);\n\n    return newDelegate;\n  }\n\n  /**\n    @notice Clone and redeploy the bytecode of a given address\n\n    @dev Runtime bytecode needs a constructor -> we append this one\n         to the bytecode, which is a minimalistic one only returning the runtime bytecode\n\n         See https://github.com/drgorillamd/clone-deployed-contract/blob/master/readme.MD for details\n   */\n  function _clone(address _targetAddress) internal returns (address _out) {\n    assembly {\n      // Get deployed/runtime code size\n      let _codeSize := extcodesize(_targetAddress)\n\n      // Get a bit of freemem to land the bytecode, not updated as we'll leave this scope right after create(..)\n      let _freeMem := mload(0x40)\n\n      // Shift the length to the length placeholder, in the constructor\n      let _mask := mul(_codeSize, 0x100000000000000000000000000000000000000000000000000000000)\n\n      // Insert the length in the correct sport (after the PUSH3 / 0x62)\n      let _initCode := or(_mask, 0x62000000600081600d8239f3fe00000000000000000000000000000000000000)\n\n      // Store the deployment bytecode\n      mstore(_freeMem, _initCode)\n\n      // Copy the bytecode (our initialise part is 13 bytes long)\n      extcodecopy(_targetAddress, add(_freeMem, 13), 0, _codeSize)\n\n      // Deploy the copied bytecode\n      _out := create(0, _freeMem, _codeSize)\n    }\n  }\n}"
    }
  ]
}