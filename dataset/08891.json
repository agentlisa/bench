{
  "Title": "[N-10] NatSpec is incomplete",
  "Content": "\n*There are 17 instances of this issue:*\n```solidity\nFile: protocol/contracts/StakerVault.sol\n\n/// @audit Missing: '@param strategy'\n93        /**\n94         * @notice Registers an address as a strategy to be excluded from token accumulation.\n95         * @dev This should be used if a strategy deposits into a stakerVault and should not get gov. tokens.\n96         * @return `true` if success.\n97         */\n98:       function addStrategy(address strategy) external override returns (bool) {\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L93-L98\n\n```solidity\nFile: protocol/contracts/Controller.sol\n\n/// @audit Missing: '@param payer'\n117       /**\n118        * @return the total amount of ETH require by `payer` to cover the fees for\n119        * positions registered in all actions\n120        */\n121:      function getTotalEthRequiredForGas(address payer) external view override returns (uint256) {\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L117-L121\n\n```solidity\nFile: protocol/contracts/utils/Preparable.sol\n\n/// @audit Missing: '@param key'\n33        /**\n34         * @notice Prepares an uint256 that should be committed to the contract\n35         * after `_MIN_DELAY` elapsed\n36         * @param value The value to prepare\n37         * @return `true` if success.\n38         */\n39        function _prepare(\n40            bytes32 key,\n41            uint256 value,\n42            uint256 delay\n43:       ) internal returns (bool) {\n\n/// @audit Missing: '@param delay'\n33        /**\n34         * @notice Prepares an uint256 that should be committed to the contract\n35         * after `_MIN_DELAY` elapsed\n36         * @param value The value to prepare\n37         * @return `true` if success.\n38         */\n39        function _prepare(\n40            bytes32 key,\n41            uint256 value,\n42            uint256 delay\n43:       ) internal returns (bool) {\n\n/// @audit Missing: '@param key'\n57        /**\n58         * @notice Prepares an address that should be committed to the contract\n59         * after `_MIN_DELAY` elapsed\n60         * @param value The value to prepare\n61         * @return `true` if success.\n62         */\n63        function _prepare(\n64            bytes32 key,\n65            address value,\n66            uint256 delay\n67:       ) internal returns (bool) {\n\n/// @audit Missing: '@param delay'\n57        /**\n58         * @notice Prepares an address that should be committed to the contract\n59         * after `_MIN_DELAY` elapsed\n60         * @param value The value to prepare\n61         * @return `true` if success.\n62         */\n63        function _prepare(\n64            bytes32 key,\n65            address value,\n66            uint256 delay\n67:       ) internal returns (bool) {\n\n/// @audit Missing: '@param key'\n81        /**\n82         * @notice Reset a uint256 key\n83         * @return `true` if success.\n84         */\n85:       function _resetUInt256Config(bytes32 key) internal returns (bool) {\n\n/// @audit Missing: '@param key'\n93        /**\n94         * @notice Reset an address key\n95         * @return `true` if success.\n96         */\n97:       function _resetAddressConfig(bytes32 key) internal returns (bool) {\n\n/// @audit Missing: '@param key'\n115       /**\n116        * @notice Execute uint256 config update (with time delay enforced).\n117        * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n118        * @return New value.\n119        */\n120:      function _executeUInt256(bytes32 key) internal returns (uint256) {\n\n/// @audit Missing: '@param key'\n127       /**\n128        * @notice Execute address config update (with time delay enforced).\n129        * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n130        * @return New value.\n131        */\n132:      function _executeAddress(bytes32 key) internal returns (address) {\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L33-L43\n\n```solidity\nFile: protocol/contracts/AddressProvider.sol\n\n/// @audit Missing: '@return'\n79         * @param action Address of action to add.\n80         */\n81:       function addAction(address action) external override onlyGovernance returns (bool) {\n\n/// @audit Missing: '@param freezable'\n207       /**\n208        * @notice Initializes an address\n209        * @param key Key to initialize\n210        * @param initialAddress Address for `key`\n211        */\n212       function initializeAddress(\n213           bytes32 key,\n214           address initialAddress,\n215           bool freezable\n216:      ) public override onlyGovernance {\n\n/// @audit Missing: '@param key'\n264       /**\n265        * @notice Execute update of `key`\n266        * @return New address.\n267        */\n268:      function executeAddress(bytes32 key) external override returns (address) {\n\n/// @audit Missing: '@param key'\n274       /**\n275        * @notice Reset `key`\n276        * @return true if it was reset\n277        */\n278:      function resetAddress(bytes32 key) external override onlyGovernance returns (bool) {\n\n/// @audit Missing: '@param token'\n396       /**\n397        * @notice Tries to get the staker vault for a given token but does not throw if it does not exist\n398        * @return A boolean set to true if the vault exists and the vault address.\n399        */\n400:      function tryGetStakerVault(address token) external view override returns (bool, address) {\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L79-L81\n\n```solidity\nFile: protocol/contracts/tokenomics/InflationManager.sol\n\n/// @audit Missing: '@param lpToken'\n236       /**\n237        * @notice Execute update of lp pool weight (with time delay enforced).\n238        * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n239        * @return New lp pool weight.\n240        */\n241:      function executeLpPoolWeight(address lpToken) external override returns (uint256) {\n\n/// @audit Missing: '@param token'\n321       /**\n322        * @notice Execute update of lp pool weight (with time delay enforced).\n323        * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n324        * @return New lp pool weight.\n325        */\n326:      function executeAmmTokenWeight(address token) external override returns (uint256) {\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L236-L241\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-backd",
  "Code": [
    {
      "filename": "protocol/contracts/StakerVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../libraries/ScaledMath.sol\";\nimport \"../libraries/Errors.sol\";\nimport \"../libraries/AddressProviderHelpers.sol\";\nimport \"../libraries/UncheckedMath.sol\";\n\nimport \"../interfaces/IStakerVault.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/tokenomics/IRewardsGauge.sol\";\nimport \"../interfaces/tokenomics/IInflationManager.sol\";\nimport \"../interfaces/pool/ILiquidityPool.sol\";\nimport \"../interfaces/tokenomics/ILpGauge.sol\";\nimport \"../interfaces/IERC20Full.sol\";\n\nimport \"./utils/Preparable.sol\";\nimport \"./Controller.sol\";\nimport \"./pool/LiquidityPool.sol\";\nimport \"./access/Authorization.sol\";\nimport \"./utils/Pausable.sol\";\n\n/**\n * @notice This contract handles staked tokens from Backd pools\n * However, note that this is NOT an ERC-20 compliant contract and these\n * tokens should never be integrated with any protocol assuming ERC-20 compliant\n * tokens\n * @dev When paused, allows only withdraw/unstake\n */\ncontract StakerVault is IStakerVault, Authorization, Pausable, Initializable, Preparable {\n    using AddressProviderHelpers for IAddressProvider;\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using UncheckedMath for uint256;\n\n    bytes32 internal constant _LP_GAUGE = \"lpGauge\";\n\n    IController public immutable controller;\n\n    IInflationManager public immutable inflationManager;\n    IAddressProvider public immutable addressProvider;\n\n    address public token;\n\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public actionLockedBalances;\n\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    // All the data fields required for the staking tracking\n    uint256 private _poolTotalStaked;\n\n    mapping(address => bool) public strategies;\n    uint256 public strategiesTotalStaked;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        IInflationManager inflationManager_ = controller.inflationManager();\n        require(address(inflationManager_) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        inflationManager = inflationManager_;\n        addressProvider = _controller.addressProvider();\n    }\n\n    function initialize(address _token) external override initializer {\n        token = _token;\n    }\n\n    function initializeLpGauge(address _lpGauge) external override onlyGovernance returns (bool) {\n        require(currentAddresses[_LP_GAUGE] == address(0), Error.ROLE_EXISTS);\n        _setConfig(_LP_GAUGE, _lpGauge);\n        inflationManager.addGaugeForVault(token);\n        return true;\n    }\n\n    function prepareLpGauge(address _lpGauge) external override onlyGovernance returns (bool) {\n        _prepare(_LP_GAUGE, _lpGauge);\n        return true;\n    }\n\n    function executeLpGauge() external override onlyGovernance returns (bool) {\n        _executeAddress(_LP_GAUGE);\n        inflationManager.addGaugeForVault(token);\n        return true;\n    }\n\n    /**\n     * @notice Registers an address as a strategy to be excluded from token accumulation.\n     * @dev This should be used if a strategy deposits into a stakerVault and should not get gov. tokens.\n     * @return `true` if success.\n     */\n    function addStrategy(address strategy) external override returns (bool) {\n        require(msg.sender == address(inflationManager), Error.UNAUTHORIZED_ACCESS);\n        strategies[strategy] = true;\n        return true;\n    }\n\n    /**\n     * @notice Transfer staked tokens to an account.\n     * @dev This is not an ERC20 transfer, as tokens are still owned by this contract, but fees get updated in the LP pool.\n     * @param account Address to transfer to.\n     * @param amount Amount to transfer.\n     * @return `true` if success.\n     */\n    function transfer(address account, uint256 amount) external override notPaused returns (bool) {\n        require(msg.sender != account, Error.SELF_TRANSFER_NOT_ALLOWED);\n        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE);\n\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        pool.handleLpTokenTransfer(msg.sender, account, amount);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(msg.sender);\n            ILpGauge(lpGauge).userCheckpoint(account);\n        }\n\n        balances[msg.sender] -= amount;\n        balances[account] += amount;\n\n        emit Transfer(msg.sender, account, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer staked tokens from src to dst.\n     * @dev This is not an ERC20 transfer, as tokens are still owned by this contract, but fees get updated in the LP pool.\n     * @param src Address to transfer from.\n     * @param dst Address to transfer to.\n     * @param amount Amount to transfer.\n     * @return `true` if success.\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external override notPaused returns (bool) {\n        /* Do not allow self transfers */\n        require(src != dst, Error.SAME_ADDRESS_NOT_ALLOWED);\n\n        /* Get the allowance, infinite for the account owner */\n        uint256 startingAllowance;\n        if (msg.sender == src) {\n            startingAllowance = type(uint256).max;\n        } else {\n            startingAllowance = _allowances[src][msg.sender];\n        }\n        require(startingAllowance >= amount, Error.INSUFFICIENT_ALLOWANCE);\n\n        uint256 srcTokens = balances[src];\n        require(srcTokens >= amount, Error.INSUFFICIENT_BALANCE);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(src);\n            ILpGauge(lpGauge).userCheckpoint(dst);\n        }\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        pool.handleLpTokenTransfer(src, dst, amount);\n\n        /* Update token balances */\n        balances[src] = srcTokens.uncheckedSub(amount);\n        balances[dst] = balances[dst] + amount;\n\n        /* Update allowance if necessary */\n        if (startingAllowance != type(uint256).max) {\n            _allowances[src][msg.sender] = startingAllowance.uncheckedSub(amount);\n        }\n        emit Transfer(src, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Approve staked tokens for spender.\n     * @param spender Address to approve tokens for.\n     * @param amount Amount to approve.\n     * @return `true` if success.\n     */\n    function approve(address spender, uint256 amount) external override notPaused returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice If an action is registered and stakes funds, this updates the actionLockedBalances for the user.\n     * @param account Address that registered the action.\n     * @param amount Amount staked by the action.\n     * @return `true` if success.\n     */\n    function increaseActionLockedBalance(address account, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        require(addressProvider.isAction(msg.sender), Error.UNAUTHORIZED_ACCESS);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(account);\n        }\n        actionLockedBalances[account] += amount;\n        return true;\n    }\n\n    /**\n     * @notice If an action is executed/reset, this updates the actionLockedBalances for the user.\n     * @param account Address that registered the action.\n     * @param amount Amount executed/reset by the action.\n     * @return `true` if success.\n     */\n    function decreaseActionLockedBalance(address account, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        require(addressProvider.isAction(msg.sender), Error.UNAUTHORIZED_ACCESS);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(account);\n        }\n        if (actionLockedBalances[account] > amount) {\n            actionLockedBalances[account] = actionLockedBalances[account].uncheckedSub(amount);\n        } else {\n            actionLockedBalances[account] = 0;\n        }\n        return true;\n    }\n\n    function poolCheckpoint() external override returns (bool) {\n        if (currentAddresses[_LP_GAUGE] != address(0)) {\n            return ILpGauge(currentAddresses[_LP_GAUGE]).poolCheckpoint();\n        }\n        return false;\n    }\n\n    function getLpGauge() external view override returns (address) {\n        return currentAddresses[_LP_GAUGE];\n    }\n\n    function isStrategy(address user) external view override returns (bool) {\n        return strategies[user];\n    }\n\n    /**\n     * @notice Get the total amount of tokens that are staked by actions\n     * @return Total amount staked by actions\n     */\n    function getStakedByActions() external view override returns (uint256) {\n        address[] memory actions = addressProvider.allActions();\n        uint256 total;\n        for (uint256 i; i < actions.length; i = i.uncheckedInc()) {\n            total += balances[actions[i]];\n        }\n        return total;\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function balanceOf(address account) external view override returns (uint256) {\n        return balances[account];\n    }\n\n    function getPoolTotalStaked() external view override returns (uint256) {\n        return _poolTotalStaked;\n    }\n\n    /**\n     * @notice Returns the total balance in the staker vault, including that locked in positions.\n     * @param account Account to query balance for.\n     * @return Total balance in staker vault for account.\n     */\n    function stakedAndActionLockedBalanceOf(address account)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return balances[account] + actionLockedBalances[account];\n    }\n\n    function actionLockedBalanceOf(address account) external view override returns (uint256) {\n        return actionLockedBalances[account];\n    }\n\n    function decimals() external view override returns (uint8) {\n        return IERC20Full(token).decimals();\n    }\n\n    function getToken() external view override returns (address) {\n        return token;\n    }\n\n    function unstake(uint256 amount) public override returns (bool) {\n        return unstakeFor(msg.sender, msg.sender, amount);\n    }\n\n    /**\n     * @notice Stake an amount of vault tokens.\n     * @param amount Amount of token to stake.\n     * @return `true` if success.\n     */\n    function stake(uint256 amount) public override returns (bool) {\n        return stakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Stake amount of vault token on behalf of another account.\n     * @param account Account for which tokens will be staked.\n     * @param amount Amount of token to stake.\n     * @return `true` if success.\n     */\n    function stakeFor(address account, uint256 amount) public override notPaused returns (bool) {\n        require(IERC20(token).balanceOf(msg.sender) >= amount, Error.INSUFFICIENT_BALANCE);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(account);\n        }\n\n        uint256 oldBal = IERC20(token).balanceOf(address(this));\n\n        if (msg.sender != account) {\n            ILiquidityPool pool = addressProvider.getPoolForToken(token);\n            pool.handleLpTokenTransfer(msg.sender, account, amount);\n        }\n\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 staked = IERC20(token).balanceOf(address(this)) - oldBal;\n        require(staked == amount, Error.INVALID_AMOUNT);\n        balances[account] += staked;\n\n        if (strategies[account]) {\n            strategiesTotalStaked += staked;\n        } else {\n            _poolTotalStaked += staked;\n        }\n        emit Staked(account, amount);\n        return true;\n    }\n\n    /**\n     * @notice Unstake tokens on behalf of another account.\n     * @dev Needs to be approved.\n     * @param src Account for which tokens will be unstaked.\n     * @param dst Account receiving the tokens.\n     * @param amount Amount of token to unstake/receive.\n     * @return `true` if success.\n     */\n    function unstakeFor(\n        address src,\n        address dst,\n        uint256 amount\n    ) public override returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 allowance_ = _allowances[src][msg.sender];\n        require(\n            src == msg.sender || allowance_ >= amount || address(pool) == msg.sender,\n            Error.UNAUTHORIZED_ACCESS\n        );\n        require(balances[src] >= amount, Error.INSUFFICIENT_BALANCE);\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(src);\n        }\n        uint256 oldBal = IERC20(token).balanceOf(address(this));\n\n        if (src != dst) {\n            pool.handleLpTokenTransfer(src, dst, amount);\n        }\n\n        IERC20(token).safeTransfer(dst, amount);\n\n        uint256 unstaked = oldBal.uncheckedSub(IERC20(token).balanceOf(address(this)));\n\n        if (src != msg.sender && allowance_ != type(uint256).max && address(pool) != msg.sender) {\n            // update allowance\n            _allowances[src][msg.sender] -= unstaked;\n        }\n        balances[src] -= unstaked;\n\n        if (strategies[src]) {\n            strategiesTotalStaked -= unstaked;\n        } else {\n            _poolTotalStaked -= unstaked;\n        }\n        emit Unstaked(src, amount);\n        return true;\n    }\n\n    function _isAuthorizedToPause(address account) internal view override returns (bool) {\n        return _roleManager().hasRole(Roles.GOVERNANCE, account);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/Controller.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"../interfaces/actions/IAction.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IStakerVault.sol\";\nimport \"../interfaces/pool/ILiquidityPool.sol\";\nimport \"../interfaces/tokenomics/IInflationManager.sol\";\n\nimport \"../libraries/AddressProviderHelpers.sol\";\nimport \"../libraries/UncheckedMath.sol\";\n\nimport \"./utils/Preparable.sol\";\nimport \"./access/Authorization.sol\";\n\ncontract Controller is IController, Authorization, Preparable {\n    using UncheckedMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    IAddressProvider public immutable override addressProvider;\n\n    IInflationManager public inflationManager;\n\n    bytes32 internal constant _KEEPER_REQUIRED_STAKED_BKD = \"KEEPER_REQUIRED_STAKED_BKD\";\n\n    constructor(IAddressProvider _addressProvider)\n        Authorization(_addressProvider.getRoleManager())\n    {\n        addressProvider = _addressProvider;\n    }\n\n    function setInflationManager(address _inflationManager) external onlyGovernance {\n        require(address(inflationManager) == address(0), Error.ADDRESS_ALREADY_SET);\n        require(_inflationManager != address(0), Error.INVALID_ARGUMENT);\n        inflationManager = IInflationManager(_inflationManager);\n    }\n\n    function addStakerVault(address stakerVault)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.POOL_FACTORY)\n        returns (bool)\n    {\n        if (!addressProvider.addStakerVault(stakerVault)) {\n            return false;\n        }\n        if (address(inflationManager) != address(0)) {\n            address lpGauge = IStakerVault(stakerVault).getLpGauge();\n            if (lpGauge != address(0)) {\n                inflationManager.whitelistGauge(lpGauge);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Delists pool.\n     * @param pool Address of pool to delist.\n     * @return `true` if successful.\n     */\n    function removePool(address pool) external override onlyGovernance returns (bool) {\n        if (!addressProvider.removePool(pool)) {\n            return false;\n        }\n        address lpToken = ILiquidityPool(pool).getLpToken();\n\n        if (address(inflationManager) != address(0)) {\n            (bool exists, address stakerVault) = addressProvider.tryGetStakerVault(lpToken);\n            if (exists) {\n                inflationManager.removeStakerVaultFromInflation(stakerVault, lpToken);\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Prepares the minimum amount of staked BKD required by a keeper\n     */\n    function prepareKeeperRequiredStakedBKD(uint256 amount) external override onlyGovernance {\n        require(addressProvider.getBKDLocker() != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        _prepare(_KEEPER_REQUIRED_STAKED_BKD, amount);\n    }\n\n    /**\n     * @notice Resets the minimum amount of staked BKD required by a keeper\n     */\n    function resetKeeperRequiredStakedBKD() external override onlyGovernance {\n        _resetUInt256Config(_KEEPER_REQUIRED_STAKED_BKD);\n    }\n\n    /**\n     * @notice Sets the minimum amount of staked BKD required by a keeper to the prepared value\n     */\n    function executeKeeperRequiredStakedBKD() external override {\n        _executeUInt256(_KEEPER_REQUIRED_STAKED_BKD);\n    }\n\n    /**\n     * @notice Returns true if the given keeper has enough staked BKD to execute actions\n     */\n    function canKeeperExecuteAction(address keeper) external view override returns (bool) {\n        uint256 requiredBKD = getKeeperRequiredStakedBKD();\n        return\n            requiredBKD == 0 ||\n            IERC20(addressProvider.getBKDLocker()).balanceOf(keeper) >= requiredBKD;\n    }\n\n    /**\n     * @return Returns the minimum amount of staked BKD required by a keeper\n     */\n    function getKeeperRequiredStakedBKD() public view override returns (uint256) {\n        return currentUInts256[_KEEPER_REQUIRED_STAKED_BKD];\n    }\n\n    /**\n     * @return the total amount of ETH require by `payer` to cover the fees for\n     * positions registered in all actions\n     */\n    function getTotalEthRequiredForGas(address payer) external view override returns (uint256) {\n        // solhint-disable-previous-line ordering\n        uint256 totalEthRequired;\n        address[] memory actions = addressProvider.allActions();\n        uint256 numActions = actions.length;\n        for (uint256 i; i < numActions; i = i.uncheckedInc()) {\n            totalEthRequired += IAction(actions[i]).getEthRequiredForGas(payer);\n        }\n        return totalEthRequired;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/utils/Preparable.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"../../interfaces/IPreparable.sol\";\nimport \"../../libraries/Errors.sol\";\n\n/**\n * @notice Implements the base logic for a two-phase commit\n * @dev This does not implements any access-control so publicly exposed\n * callers should make sure to have the proper checks in place\n */\ncontract Preparable is IPreparable {\n    uint256 private constant _MIN_DELAY = 3 days;\n\n    mapping(bytes32 => address) public pendingAddresses;\n    mapping(bytes32 => uint256) public pendingUInts256;\n\n    mapping(bytes32 => address) public currentAddresses;\n    mapping(bytes32 => uint256) public currentUInts256;\n\n    /**\n     * @dev Deadlines shares the same namespace regardless of the type\n     * of the pending variable so this needs to be enforced in the caller\n     */\n    mapping(bytes32 => uint256) public deadlines;\n\n    function _prepareDeadline(bytes32 key, uint256 delay) internal {\n        require(deadlines[key] == 0, Error.DEADLINE_NOT_ZERO);\n        require(delay >= _MIN_DELAY, Error.DELAY_TOO_SHORT);\n        deadlines[key] = block.timestamp + delay;\n    }\n\n    /**\n     * @notice Prepares an uint256 that should be committed to the contract\n     * after `_MIN_DELAY` elapsed\n     * @param value The value to prepare\n     * @return `true` if success.\n     */\n    function _prepare(\n        bytes32 key,\n        uint256 value,\n        uint256 delay\n    ) internal returns (bool) {\n        _prepareDeadline(key, delay);\n        pendingUInts256[key] = value;\n        emit ConfigPreparedNumber(key, value, delay);\n        return true;\n    }\n\n    /**\n     * @notice Same as `_prepare(bytes32,uint256,uint256)` but uses a default delay\n     */\n    function _prepare(bytes32 key, uint256 value) internal returns (bool) {\n        return _prepare(key, value, _MIN_DELAY);\n    }\n\n    /**\n     * @notice Prepares an address that should be committed to the contract\n     * after `_MIN_DELAY` elapsed\n     * @param value The value to prepare\n     * @return `true` if success.\n     */\n    function _prepare(\n        bytes32 key,\n        address value,\n        uint256 delay\n    ) internal returns (bool) {\n        _prepareDeadline(key, delay);\n        pendingAddresses[key] = value;\n        emit ConfigPreparedAddress(key, value, delay);\n        return true;\n    }\n\n    /**\n     * @notice Same as `_prepare(bytes32,address,uint256)` but uses a default delay\n     */\n    function _prepare(bytes32 key, address value) internal returns (bool) {\n        return _prepare(key, value, _MIN_DELAY);\n    }\n\n    /**\n     * @notice Reset a uint256 key\n     * @return `true` if success.\n     */\n    function _resetUInt256Config(bytes32 key) internal returns (bool) {\n        require(deadlines[key] != 0, Error.NOTHING_PENDING);\n        deadlines[key] = 0;\n        pendingUInts256[key] = 0;\n        emit ConfigReset(key);\n        return true;\n    }\n\n    /**\n     * @notice Reset an address key\n     * @return `true` if success.\n     */\n    function _resetAddressConfig(bytes32 key) internal returns (bool) {\n        require(deadlines[key] != 0, Error.NOTHING_PENDING);\n        deadlines[key] = 0;\n        pendingAddresses[key] = address(0);\n        emit ConfigReset(key);\n        return true;\n    }\n\n    /**\n     * @dev Checks the deadline of the key and reset it\n     */\n    function _executeDeadline(bytes32 key) internal {\n        uint256 deadline = deadlines[key];\n        require(block.timestamp >= deadline, Error.DEADLINE_NOT_REACHED);\n        require(deadline != 0, Error.DEADLINE_NOT_SET);\n        deadlines[key] = 0;\n    }\n\n    /**\n     * @notice Execute uint256 config update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return New value.\n     */\n    function _executeUInt256(bytes32 key) internal returns (uint256) {\n        _executeDeadline(key);\n        uint256 newValue = pendingUInts256[key];\n        _setConfig(key, newValue);\n        return newValue;\n    }\n\n    /**\n     * @notice Execute address config update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return New value.\n     */\n    function _executeAddress(bytes32 key) internal returns (address) {\n        _executeDeadline(key);\n        address newValue = pendingAddresses[key];\n        _setConfig(key, newValue);\n        return newValue;\n    }\n\n    function _setConfig(bytes32 key, address value) internal returns (address) {\n        emit ConfigUpdatedAddress(key, currentAddresses[key], value);\n        currentAddresses[key] = value;\n        pendingAddresses[key] = address(0);\n        deadlines[key] = 0;\n        return value;\n    }\n\n    function _setConfig(bytes32 key, uint256 value) internal returns (uint256) {\n        uint256 oldValue = currentUInts256[key];\n        currentUInts256[key] = value;\n        pendingUInts256[key] = 0;\n        deadlines[key] = 0;\n        emit ConfigUpdatedNumber(key, oldValue, value);\n        return value;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/AddressProvider.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../interfaces/IGasBank.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/IStakerVault.sol\";\nimport \"../interfaces/oracles/IOracleProvider.sol\";\n\nimport \"../libraries/EnumerableExtensions.sol\";\nimport \"../libraries/EnumerableMapping.sol\";\nimport \"../libraries/AddressProviderKeys.sol\";\nimport \"../libraries/AddressProviderMeta.sol\";\nimport \"../libraries/Roles.sol\";\n\nimport \"./access/AuthorizationBase.sol\";\nimport \"./utils/Preparable.sol\";\n\n// solhint-disable ordering\n\ncontract AddressProvider is IAddressProvider, AuthorizationBase, Initializable, Preparable {\n    using EnumerableMapping for EnumerableMapping.AddressToAddressMap;\n    using EnumerableMapping for EnumerableMapping.Bytes32ToUIntMap;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using EnumerableExtensions for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableMapping.AddressToAddressMap;\n    using EnumerableExtensions for EnumerableMapping.Bytes32ToUIntMap;\n    using AddressProviderMeta for AddressProviderMeta.Meta;\n\n    // LpToken -> stakerVault\n    EnumerableMapping.AddressToAddressMap internal _stakerVaults;\n\n    EnumerableSet.AddressSet internal _whiteListedFeeHandlers;\n\n    // value is encoded as (bool freezable, bool frozen)\n    EnumerableMapping.Bytes32ToUIntMap internal _addressKeyMetas;\n\n    EnumerableSet.AddressSet internal _actions; // list of all actions ever registered\n\n    EnumerableSet.AddressSet internal _vaults; // list of all active vaults\n\n    EnumerableMapping.AddressToAddressMap internal _tokenToPools;\n\n    constructor(address treasury) {\n        AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, false);\n        _addressKeyMetas.set(AddressProviderKeys._TREASURY_KEY, meta.toUInt());\n        _setConfig(AddressProviderKeys._TREASURY_KEY, treasury);\n    }\n\n    function initialize(address roleManager) external initializer {\n        AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, true);\n        _addressKeyMetas.set(AddressProviderKeys._ROLE_MANAGER_KEY, meta.toUInt());\n        _setConfig(AddressProviderKeys._ROLE_MANAGER_KEY, roleManager);\n    }\n\n    function getKnownAddressKeys() external view override returns (bytes32[] memory) {\n        return _addressKeyMetas.keysArray();\n    }\n\n    function addFeeHandler(address feeHandler) external override onlyGovernance returns (bool) {\n        require(!_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_WHITELISTED);\n        _whiteListedFeeHandlers.add(feeHandler);\n        emit FeeHandlerAdded(feeHandler);\n        return true;\n    }\n\n    function removeFeeHandler(address feeHandler) external override onlyGovernance returns (bool) {\n        require(_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_NOT_WHITELISTED);\n        _whiteListedFeeHandlers.remove(feeHandler);\n        emit FeeHandlerRemoved(feeHandler);\n        return true;\n    }\n\n    /**\n     * @notice Adds action.\n     * @param action Address of action to add.\n     */\n    function addAction(address action) external override onlyGovernance returns (bool) {\n        bool result = _actions.add(action);\n        if (result) {\n            emit ActionListed(action);\n        }\n        return result;\n    }\n\n    /**\n     * @notice Adds pool.\n     * @param pool Address of pool to add.\n     */\n    function addPool(address pool)\n        external\n        override\n        onlyRoles2(Roles.POOL_FACTORY, Roles.GOVERNANCE)\n    {\n        require(pool != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n\n        ILiquidityPool ipool = ILiquidityPool(pool);\n        address poolToken = ipool.getLpToken();\n        require(poolToken != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        if (_tokenToPools.set(poolToken, pool)) {\n            address vault = address(ipool.getVault());\n            if (vault != address(0)) {\n                _vaults.add(vault);\n            }\n            emit PoolListed(pool);\n        }\n    }\n\n    /**\n     * @notice Delists pool.\n     * @param pool Address of pool to delist.\n     * @return `true` if successful.\n     */\n    function removePool(address pool) external override onlyRole(Roles.CONTROLLER) returns (bool) {\n        address lpToken = ILiquidityPool(pool).getLpToken();\n        bool removed = _tokenToPools.remove(lpToken);\n        if (removed) {\n            address vault = address(ILiquidityPool(pool).getVault());\n            if (vault != address(0)) {\n                _vaults.remove(vault);\n            }\n            emit PoolDelisted(pool);\n        }\n\n        return removed;\n    }\n\n    /** Vault functions  */\n\n    /**\n     * @notice returns all the registered vaults\n     */\n    function allVaults() external view override returns (address[] memory) {\n        return _vaults.toArray();\n    }\n\n    /**\n     * @notice returns the vault at the given index\n     */\n    function getVaultAtIndex(uint256 index) external view override returns (address) {\n        return _vaults.at(index);\n    }\n\n    /**\n     * @notice returns the number of vaults\n     */\n    function vaultsCount() external view override returns (uint256) {\n        return _vaults.length();\n    }\n\n    function isVault(address vault) external view override returns (bool) {\n        return _vaults.contains(vault);\n    }\n\n    function updateVault(address previousVault, address newVault)\n        external\n        override\n        onlyRole(Roles.POOL)\n    {\n        if (previousVault != address(0)) {\n            _vaults.remove(previousVault);\n        }\n        if (newVault != address(0)) {\n            _vaults.add(newVault);\n        }\n        emit VaultUpdated(previousVault, newVault);\n    }\n\n    /**\n     * @notice Returns the address for the given key\n     */\n    function getAddress(bytes32 key) public view override returns (address) {\n        require(_addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST);\n        return currentAddresses[key];\n    }\n\n    /**\n     * @notice Returns the address for the given key\n     * @dev if `checkExists` is true, it will fail if the key does not exist\n     */\n    function getAddress(bytes32 key, bool checkExists) public view override returns (address) {\n        require(!checkExists || _addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST);\n        return currentAddresses[key];\n    }\n\n    /**\n     * @notice returns the address metadata for the given key\n     */\n    function getAddressMeta(bytes32 key)\n        public\n        view\n        override\n        returns (AddressProviderMeta.Meta memory)\n    {\n        (bool exists, uint256 metadata) = _addressKeyMetas.tryGet(key);\n        require(exists, Error.ADDRESS_DOES_NOT_EXIST);\n        return AddressProviderMeta.fromUInt(metadata);\n    }\n\n    function initializeAddress(bytes32 key, address initialAddress) external override {\n        initializeAddress(key, initialAddress, false);\n    }\n\n    /**\n     * @notice Initializes an address\n     * @param key Key to initialize\n     * @param initialAddress Address for `key`\n     */\n    function initializeAddress(\n        bytes32 key,\n        address initialAddress,\n        bool freezable\n    ) public override onlyGovernance {\n        AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(freezable, false);\n        _initializeAddress(key, initialAddress, meta);\n    }\n\n    /**\n     * @notice Initializes and freezes address\n     * @param key Key to initialize\n     * @param initialAddress Address for `key`\n     */\n    function initializeAndFreezeAddress(bytes32 key, address initialAddress)\n        external\n        override\n        onlyGovernance\n    {\n        AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, true);\n        _initializeAddress(key, initialAddress, meta);\n    }\n\n    /**\n     * @notice Freezes a configuration key, making it immutable\n     * @param key Key to feeze\n     */\n    function freezeAddress(bytes32 key) external override onlyGovernance {\n        AddressProviderMeta.Meta memory meta = getAddressMeta(key);\n        require(!meta.frozen, Error.ADDRESS_FROZEN);\n        require(meta.freezable, Error.INVALID_ARGUMENT);\n        meta.frozen = true;\n        _addressKeyMetas.set(key, meta.toUInt());\n    }\n\n    /**\n     * @notice Prepare update of an address\n     * @param key Key to update"
    }
  ]
}