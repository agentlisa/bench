{
  "Title": "[Gâ€‘02] Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas",
  "Content": "\nWhen a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. **Each iteration of this for-loop costs at least 60 gas** (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution. Note that even if an interface defines a function as having `memory` arguments, it's still valid for implementation contracs to use `calldata` arguments instead.\n\nIf the array is passed to an `internal` function which passes the array to another internal function where the array is modified and therefore `memory` is used in the `external` call, it's still more gass-efficient to use `calldata` when the `external` function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one\n\nNote that I've also flagged instances where the function is `public` but can be marked as `external` since it's not called by the contract, and cases where a constructor is involved\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: src/core/contracts/DataStorageOperator.sol\n\n/// @audit secondsAgos\n88      function getTimepoints(\n89        uint32 time,\n90        uint32[] memory secondsAgos,\n91        int24 tick,\n92        uint16 index,\n93        uint128 liquidity\n94      )\n95        external\n96        view\n97        override\n98        onlyPool\n99        returns (\n100         int56[] memory tickCumulatives,\n101         uint160[] memory secondsPerLiquidityCumulatives,\n102         uint112[] memory volatilityCumulatives,\n103:        uint256[] memory volumePerAvgLiquiditys\n\n```\n\n<https://github.com/code-423n4/2022-09-quickswap/blob/15ea643c85ed936a92d2676a7aabf739b210af39/src/core/contracts/DataStorageOperator.sol#L88-L103>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-09-quickswap",
  "Code": [
    {
      "filename": "src/core/contracts/DataStorageOperator.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport './interfaces/IAlgebraFactory.sol';\nimport './interfaces/IDataStorageOperator.sol';\n\nimport './libraries/DataStorage.sol';\nimport './libraries/Sqrt.sol';\nimport './libraries/AdaptiveFee.sol';\n\nimport './libraries/Constants.sol';\n\ncontract DataStorageOperator is IDataStorageOperator {\n  uint256 constant UINT16_MODULO = 65536;\n  uint128 constant MAX_VOLUME_PER_LIQUIDITY = 100000 << 64; // maximum meaningful ratio of volume to liquidity\n\n  using DataStorage for DataStorage.Timepoint[UINT16_MODULO];\n\n  DataStorage.Timepoint[UINT16_MODULO] public override timepoints;\n  AdaptiveFee.Configuration public feeConfig;\n\n  address private immutable pool;\n  address private immutable factory;\n\n  modifier onlyPool() {\n    require(msg.sender == pool, 'only pool can call this');\n    _;\n  }\n\n  constructor(address _pool) {\n    factory = msg.sender;\n    pool = _pool;\n  }\n\n  /// @inheritdoc IDataStorageOperator\n  function initialize(uint32 time, int24 tick) external override onlyPool {\n    return timepoints.initialize(time, tick);\n  }\n\n  /// @inheritdoc IDataStorageOperator\n  function changeFeeConfiguration(AdaptiveFee.Configuration calldata _feeConfig) external override {\n    require(msg.sender == factory || msg.sender == IAlgebraFactory(factory).owner());\n\n    require(uint256(_feeConfig.alpha1) + uint256(_feeConfig.alpha2) + uint256(_feeConfig.baseFee) <= type(uint16).max, 'Max fee exceeded');\n    require(_feeConfig.gamma1 != 0 && _feeConfig.gamma2 != 0 && _feeConfig.volumeGamma != 0, 'Gammas must be > 0');\n\n    feeConfig = _feeConfig;\n    emit FeeConfiguration(_feeConfig);\n  }\n\n  /// @inheritdoc IDataStorageOperator\n  function getSingleTimepoint(\n    uint32 time,\n    uint32 secondsAgo,\n    int24 tick,\n    uint16 index,\n    uint128 liquidity\n  )\n    external\n    view\n    override\n    onlyPool\n    returns (\n      int56 tickCumulative,\n      uint160 secondsPerLiquidityCumulative,\n      uint112 volatilityCumulative,\n      uint256 volumePerAvgLiquidity\n    )\n  {\n    uint16 oldestIndex;\n    // check if we have overflow in the past\n    uint16 nextIndex = index + 1; // considering overflow\n    if (timepoints[nextIndex].initialized) {\n      oldestIndex = nextIndex;\n    }\n\n    DataStorage.Timepoint memory result = timepoints.getSingleTimepoint(time, secondsAgo, tick, index, oldestIndex, liquidity);\n    (tickCumulative, secondsPerLiquidityCumulative, volatilityCumulative, volumePerAvgLiquidity) = (\n      result.tickCumulative,\n      result.secondsPerLiquidityCumulative,\n      result.volatilityCumulative,\n      result.volumePerLiquidityCumulative\n    );\n  }\n\n  /// @inheritdoc IDataStorageOperator\n  function getTimepoints(\n    uint32 time,\n    uint32[] memory secondsAgos,\n    int24 tick,\n    uint16 index,\n    uint128 liquidity\n  )\n    external\n    view\n    override\n    onlyPool\n    returns (\n      int56[] memory tickCumulatives,\n      uint160[] memory secondsPerLiquidityCumulatives,\n      uint112[] memory volatilityCumulatives,\n      uint256[] memory volumePerAvgLiquiditys\n    )\n  {\n    return timepoints.getTimepoints(time, secondsAgos, tick, index, liquidity);\n  }\n\n  /// @inheritdoc IDataStorageOperator\n  function getAverages(\n    uint32 time,\n    int24 tick,\n    uint16 index,\n    uint128 liquidity\n  ) external view override onlyPool returns (uint112 TWVolatilityAverage, uint256 TWVolumePerLiqAverage) {\n    return timepoints.getAverages(time, tick, index, liquidity);\n  }\n\n  /// @inheritdoc IDataStorageOperator\n  function write(\n    uint16 index,\n    uint32 blockTimestamp,\n    int24 tick,\n    uint128 liquidity,\n    uint128 volumePerLiquidity\n  ) external override onlyPool returns (uint16 indexUpdated) {\n    return timepoints.write(index, blockTimestamp, tick, liquidity, volumePerLiquidity);\n  }\n\n  /// @inheritdoc IDataStorageOperator\n  function calculateVolumePerLiquidity(\n    uint128 liquidity,\n    int256 amount0,\n    int256 amount1\n  ) external pure override returns (uint128 volumePerLiquidity) {\n    uint256 volume = Sqrt.sqrtAbs(amount0) * Sqrt.sqrtAbs(amount1);\n    uint256 volumeShifted;\n    if (volume >= 2**192) volumeShifted = (type(uint256).max) / (liquidity > 0 ? liquidity : 1);\n    else volumeShifted = (volume << 64) / (liquidity > 0 ? liquidity : 1);\n    if (volumeShifted >= MAX_VOLUME_PER_LIQUIDITY) return MAX_VOLUME_PER_LIQUIDITY;\n    else return uint128(volumeShifted);\n  }\n\n  /// @inheritdoc IDataStorageOperator\n  function window() external pure override returns (uint32) {\n    return DataStorage.WINDOW;\n  }\n\n  /// @inheritdoc IDataStorageOperator\n  function getFee(\n    uint32 _time,\n    int24 _tick,\n    uint16 _index,\n    uint128 _liquidity\n  ) external view override onlyPool returns (uint16 fee) {\n    (uint88 volatilityAverage, uint256 volumePerLiqAverage) = timepoints.getAverages(_time, _tick, _index, _liquidity);\n\n    return AdaptiveFee.getFee(volatilityAverage / 15, volumePerLiqAverage, feeConfig);\n  }\n}"
    }
  ]
}