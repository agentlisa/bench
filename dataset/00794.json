{
  "Title": "No validation for `_amount` in migrate function",
  "Content": "# No validation for `_amount` in migrate function\n\n### Severity\nLow Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/sdlPool/SDLPoolPrimary.sol#L264-L272\">https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/sdlPool/SDLPoolPrimary.sol#L264-L272</a>\n\n\n## Summary\n\nIn the `SDLPoolPrimary` contract, the `migrate` function lacks a validation check for the `_amount` parameter. When `_amount` is zero, indicating that no SDL tokens are being staked or migrated, a lock with zero value is created. This could lead to unintended consequences, as creating locks with zero value may not align with the intended behavior of the contract. Implementing a check for non-zero values in `_amount` is recommended to prevent the creation of zero-value locks during migration.\n\n## Vulnerability Details\n\nIn the `migrate` function, there is no explicit check for zero values in the `_amount` parameter. Consequently, when zero is passed as the _amount during migration, a lock with zero value is created. While this does not cause a revert, it might lead to unintended consequences, such as the creation of zero-value locks and potential resource allocation for these locks.\n\n## Impact\n\nAllowing zero values in the `_amount` parameter during migration can lead to the creation of zero-value locks, posing risks such as unnecessary gas costs, increased complexity in auditing and contract comprehension, and potential resource allocation for zero-value locks.\n\n## Tools Used\n\nManual review\n\n## Recommendations\n\nImplement a check at the beginning of the migrate function to ensure that `_amount` is greater than zero. This can prevent the creation of zero-value locks.\n\n```\nif (_amount == 0) revert NonZeroAmountRequired();\n```",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clqf7mgla0001yeyfah59c674",
  "Code": [
    {
      "filename": "contracts/core/sdlPool/SDLPoolPrimary.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\nimport \"./base/SDLPool.sol\";\n\n/**\n * @title SDL Pool Primary\n * @notice Allows users to stake/lock SDL tokens and receive a percentage of the protocol's earned rewards\n * @dev deployed only on the primary chain\n */\ncontract SDLPoolPrimary is SDLPool {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address public delegatorPool;\n\n    event IncomingUpdate(uint256 numNewRESDLTokens, int256 totalRESDLSupplyChange, uint256 mintStartIndex);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice initializes contract\n     * @param _name name of the staking derivative token\n     * @param _symbol symbol of the staking derivative token\n     * @param _sdlToken address of the SDL token\n     * @param _boostController address of the boost controller\n     **/\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address _sdlToken,\n        address _boostController\n    ) public reinitializer(2) {\n        if (delegatorPool == address(0)) {\n            __SDLPoolBase_init(_name, _symbol, _sdlToken, _boostController);\n        } else {\n            delegatorPool = ccipController;\n        }\n    }\n\n    /**\n     * @notice ERC677 implementation to stake/lock SDL tokens or distribute rewards\n     * @dev\n     * - will update/create a lock if the token transferred is SDL or will distribute rewards otherwise\n     *\n     * For Non-SDL:\n     * - reverts if token is unsupported\n     *\n     * For SDL:\n     * - set lockId to 0 to create a new lock or set lockId to > 0 to stake more into an existing lock\n     * - set lockingDuration to 0 to stake without locking or set lockingDuration to > 0 to lock for an amount\n     *   time in seconds\n     * - see _updateLock() for more details on updating an existing lock or _createLock() for more details on\n     *   creating a new lock\n     * @param _sender of the stake\n     * @param _value of the token transfer\n     * @param _calldata encoded lockId (uint256) and lockingDuration (uint64)\n     **/\n    function onTokenTransfer(\n        address _sender,\n        uint256 _value,\n        bytes calldata _calldata\n    ) external override {\n        if (msg.sender != address(sdlToken) && !isTokenSupported(msg.sender)) revert UnauthorizedToken();\n\n        if (_value == 0) revert InvalidValue();\n\n        if (msg.sender == address(sdlToken)) {\n            (uint256 lockId, uint64 lockingDuration) = abi.decode(_calldata, (uint256, uint64));\n            if (lockId != 0) {\n                _storeUpdatedLock(_sender, lockId, _value, lockingDuration);\n            } else {\n                _storeNewLock(_sender, _value, lockingDuration);\n            }\n        } else {\n            distributeToken(msg.sender);\n        }\n    }\n\n    /**\n     * @notice extends the locking duration of a lock\n     * @dev\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if `_lockingDuration` is less than current locking duration of lock\n     * - reverts if `_lockingDuration` is 0 or exceeds the maximum\n     * @param _lockId id of lock\n     * @param _lockingDuration new locking duration to set\n     **/\n    function extendLockDuration(uint256 _lockId, uint64 _lockingDuration) external {\n        if (_lockingDuration == 0) revert InvalidLockingDuration();\n        _storeUpdatedLock(msg.sender, _lockId, 0, _lockingDuration);\n    }\n\n    /**\n     * @notice initiates the unlock period for a lock\n     * @dev\n     * - at least half of the locking duration must have elapsed to initiate the unlock period\n     * - the unlock period consists of half of the locking duration\n     * - boost will be set to 0 upon initiation of the unlock period\n     *\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if a minimum of half the locking duration has not elapsed\n     * @param _lockId id of lock\n     **/\n    function initiateUnlock(uint256 _lockId) external onlyLockOwner(_lockId, msg.sender) updateRewards(msg.sender) {\n        if (locks[_lockId].expiry != 0) revert UnlockAlreadyInitiated();\n        uint64 halfDuration = locks[_lockId].duration / 2;\n        if (locks[_lockId].startTime + halfDuration > block.timestamp) revert HalfDurationNotElapsed();\n\n        uint64 expiry = uint64(block.timestamp) + halfDuration;\n        locks[_lockId].expiry = expiry;\n\n        uint256 boostAmount = locks[_lockId].boostAmount;\n        locks[_lockId].boostAmount = 0;\n        effectiveBalances[msg.sender] -= boostAmount;\n        totalEffectiveBalance -= boostAmount;\n\n        emit InitiateUnlock(msg.sender, _lockId, expiry);\n    }\n\n    /**\n     * @notice withdraws unlocked SDL\n     * @dev\n     * - SDL can only be withdrawn if unlocked (once the unlock period has elapsed or if it was never\n     *   locked in the first place)\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if not unlocked\n     * - reverts if `_amount` exceeds the amount staked in the lock\n     * @param _lockId id of the lock\n     * @param _amount amount to withdraw from the lock\n     **/\n    function withdraw(uint256 _lockId, uint256 _amount)\n        external\n        onlyLockOwner(_lockId, msg.sender)\n        updateRewards(msg.sender)\n    {\n        if (locks[_lockId].startTime != 0) {\n            uint64 expiry = locks[_lockId].expiry;\n            if (expiry == 0) revert UnlockNotInitiated();\n            if (expiry > block.timestamp) revert TotalDurationNotElapsed();\n        }\n\n        uint256 baseAmount = locks[_lockId].amount;\n        if (_amount > baseAmount) revert InsufficientBalance();\n\n        emit Withdraw(msg.sender, _lockId, _amount);\n\n        if (_amount == baseAmount) {\n            delete locks[_lockId];\n            delete lockOwners[_lockId];\n            balances[msg.sender] -= 1;\n            if (tokenApprovals[_lockId] != address(0)) delete tokenApprovals[_lockId];\n            emit Transfer(msg.sender, address(0), _lockId);\n        } else {\n            locks[_lockId].amount = baseAmount - _amount;\n        }\n\n        effectiveBalances[msg.sender] -= _amount;\n        totalEffectiveBalance -= _amount;\n\n        sdlToken.safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * @notice handles an outgoing transfer of an reSDL lock to another chain\n     * @param _sender sender of lock\n     * @param _lockId id of lock\n     * @param _sdlReceiver address to receive underlying SDL on this chain\n     */\n    function handleOutgoingRESDL(\n        address _sender,\n        uint256 _lockId,\n        address _sdlReceiver\n    )\n        external\n        onlyCCIPController\n        onlyLockOwner(_lockId, _sender)\n        updateRewards(_sender)\n        updateRewards(ccipController)\n        returns (Lock memory)\n    {\n        Lock memory lock = locks[_lockId];\n\n        delete locks[_lockId].amount;\n        delete lockOwners[_lockId];\n        balances[_sender] -= 1;\n\n        uint256 totalAmount = lock.amount + lock.boostAmount;\n        effectiveBalances[_sender] -= totalAmount;\n        effectiveBalances[ccipController] += totalAmount;\n\n        sdlToken.safeTransfer(_sdlReceiver, lock.amount);\n\n        emit OutgoingRESDL(_sender, _lockId);\n\n        return lock;\n    }\n\n    /**\n     * @notice handles an incoming transfer of an reSDL lock from another chain\n     * @param _receiver receiver of lock\n     * @param _lockId id of lock\n     * @param _lock lock\n     */\n    function handleIncomingRESDL(\n        address _receiver,\n        uint256 _lockId,\n        Lock calldata _lock\n    ) external onlyCCIPController updateRewards(_receiver) updateRewards(ccipController) {\n        if (lockOwners[_lockId] != address(0)) revert InvalidLockId();\n\n        locks[_lockId] = Lock(_lock.amount, _lock.boostAmount, _lock.startTime, _lock.duration, _lock.expiry);\n        lockOwners[_lockId] = _receiver;\n        balances[_receiver] += 1;\n\n        uint256 totalAmount = _lock.amount + _lock.boostAmount;\n        effectiveBalances[_receiver] += totalAmount;\n        effectiveBalances[ccipController] -= totalAmount;\n\n        emit IncomingRESDL(_receiver, _lockId);\n    }\n\n    /**\n     * @notice handles an incoming update from a secondary chain\n     * @dev updates the total reSDL supply and keeps reSDL lock ids consistent between chains\n     * @param _numNewRESDLTokens number of new reSDL locks to be minted on other chain\n     * @param _totalRESDLSupplyChange total reSDL supply change on other chain\n     */\n    function handleIncomingUpdate(uint256 _numNewRESDLTokens, int256 _totalRESDLSupplyChange)\n        external\n        onlyCCIPController\n        returns (uint256)\n    {\n        uint256 mintStartIndex;\n        if (_numNewRESDLTokens != 0) {\n            mintStartIndex = lastLockId + 1;\n            lastLockId += _numNewRESDLTokens;\n        }\n\n        if (_totalRESDLSupplyChange > 0) {\n            effectiveBalances[ccipController] += uint256(_totalRESDLSupplyChange);\n            totalEffectiveBalance += uint256(_totalRESDLSupplyChange);\n        } else if (_totalRESDLSupplyChange < 0) {\n            effectiveBalances[ccipController] -= uint256(-1 * _totalRESDLSupplyChange);\n            totalEffectiveBalance -= uint256(-1 * _totalRESDLSupplyChange);\n        }\n\n        emit IncomingUpdate(_numNewRESDLTokens, _totalRESDLSupplyChange, mintStartIndex);\n\n        return mintStartIndex;\n    }\n\n    /**\n     * @notice used by the delegator pool to migrate user stakes to this contract\n     * @dev\n     * - creates a new lock to represent the migrated stake\n     * - reverts if `_lockingDuration` exceeds maximum\n     * @param _sender owner of lock\n     * @param _amount amount to stake\n     * @param _lockingDuration duration of lock\n     */\n    function migrate(\n        address _sender,\n        uint256 _amount,\n        uint64 _lockingDuration\n    ) external {\n        if (msg.sender != delegatorPool) revert SenderNotAuthorized();\n        sdlToken.safeTransferFrom(delegatorPool, address(this), _amount);\n        _storeNewLock(_sender, _amount, _lockingDuration);\n    }\n\n    /**\n     * @notice stores a new lock\n     * @param _owner owner of lock\n     * @param _amount amount to stake\n     * @param _lockingDuration duration of lock\n     */\n    function _storeNewLock(\n        address _owner,\n        uint256 _amount,\n        uint64 _lockingDuration\n    ) internal updateRewards(_owner) {\n        Lock memory lock = _createLock(_amount, _lockingDuration);\n        uint256 lockId = lastLockId + 1;\n\n        locks[lockId] = lock;\n        lockOwners[lockId] = _owner;\n        balances[_owner] += 1;\n        lastLockId++;\n\n        uint256 totalAmount = lock.amount + lock.boostAmount;\n        effectiveBalances[_owner] += totalAmount;\n        totalEffectiveBalance += totalAmount;\n\n        emit CreateLock(_owner, lockId, lock.amount, lock.boostAmount, lock.duration);\n        emit Transfer(address(0), _owner, lockId);\n    }\n\n    /**\n     * @notice stores an updated lock\n     * @param _owner owner of lock\n     * @param _amount amount to stake\n     * @param _lockingDuration duration of lock\n     */\n    function _storeUpdatedLock(\n        address _owner,\n        uint256 _lockId,\n        uint256 _amount,\n        uint64 _lockingDuration\n    ) internal onlyLockOwner(_lockId, _owner) updateRewards(_owner) {\n        Lock memory lock = _updateLock(locks[_lockId], _amount, _lockingDuration);\n\n        int256 diffTotalAmount = int256(lock.amount + lock.boostAmount) -\n            int256(locks[_lockId].amount + locks[_lockId].boostAmount);\n\n        if (diffTotalAmount > 0) {\n            effectiveBalances[_owner] += uint256(diffTotalAmount);\n            totalEffectiveBalance += uint256(diffTotalAmount);\n        } else if (diffTotalAmount < 0) {\n            effectiveBalances[_owner] -= uint256(-1 * diffTotalAmount);\n            totalEffectiveBalance -= uint256(-1 * diffTotalAmount);\n        }\n\n        locks[_lockId] = lock;\n\n        emit UpdateLock(_owner, _lockId, lock.amount, lock.boostAmount, lock.duration);\n    }\n}"
    }
  ]
}