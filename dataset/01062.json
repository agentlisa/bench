{
  "Title": "[H-03] High ERC721 utilization rate can be exploited to steal funds",
  "Content": "As discussed in [H-02], the utilization rate for ERC721 markets can become extremely high if the `reserves` value becomes large.\n\nIf the interest market is ever set up with an 18 decimal token, an attacker can exploit this vulnerability to force liquidate innocent users or to steal funds from the interest market.\n\nThere are two important facts that contribute to this issue:\n\n1) As the value of `reserves` approaches the value of `cash + borrows`, the utilization rate approaches infinity. Utilization rates are intended to be capped at 1e18 ([see Compound code comment](https://github.com/compound-finance/compound-protocol/blob/a3214f67b73310d547e00fc578e8355911c9d376/contracts/BaseJumpRateModelV2.sol#L78)), whereas our value can go much higher.\n\n2) The supply rate is calculated in most Compound forks only for convenience. In the ERC721 market, however, it is used to manually calculate the increase in supply interest index, so it is critical that it is calculated correctly. This value is calculated as `utilizationRate(cash, borrows, reserves) * (borrowRate * oneMinusReserveFactor / BASE) / BASE);`\n\nThis supply rate is calculated by multiplying the reduced borrow rate by the utilization rate, because the propotion of funds on the borrow side vs the supply side is equal to `utilization rate`. If we take the increase in borrow interest and want to apply it to the users' supply interest, we need to scale it down by utilization rate to ensure that (ignoring protocol fees) `borrow $ * borrow rate == supply $ * supply rate`.\n\nIn the situation where `utilizationRate` is increased above `1e18`, the result is that the supply rate is made much higher than the borrow rate. The only check performed on the rates returned is that `borrowRateMantissa > borrowRateMaxMantissa`, but the supply rate can far exceed this value as the utilization rate grows. This should never be the case. Because there isn't actually more money being borrowed than supplied, the result is that more interest can be collected from the pool than will be paid into it. This could lead to lack of solvency for the interest market.\n\n**Proof of Concept**\n\nAn attacker can exploit these facts as follows:\n- Let's imagine an ERC721 market.\n- An attacker can cycle an ERC721 through the market by lending it, then borrowing it, etc until they have a large amount of funds borrowed.\n- As interest is accrued, it will lead to reserves being added to the market (USDC that can be claimed by the protocol from the interest market). After paying their fees, the attacker can unwind their deposits and borrows.\n\nWhile there is a hard limit of `borrowRateMaxMantissa` on how high the borrow rate can go, there is no limit on the supply rate, which is calculated as follows:\n```solidity\nuint rateToPool = borrowRate * oneMinusReserveFactor / BASE;\nuint supplyRate = utilizationRate(cash, borrows, reserves) * rateToPool / BASE;\n```\nIn other words, we scale the supply rate by utilization rate. This means the supply rate can grow substantially higher than the borrow rate. This allows the attack to lend funds on the pool to earn this massive supply rate, and claim more interest than was paid to the interest market, leading to a loss of solvency.\n\n**Note on Impact**\n\nNote that, while these situations are extreme, a smaller version of this will be happening organically in the protocol whenever reserves are included in the utilization rate.\n\n**Recommendation**\n\nRemove `reserves` from the utilization rate calculation.\n\nAdditionally, for safety, add an explicit check either that (a) the utilization rate is always less than 1e18 or (b) the supply rate is always less than the borrow rate.\n\n**Review**\n\nFixed as recommended (both new calculation and safety check) in [524828510aa6519749bd2f77a1bdde2fe8cce64e](https://github.com/fungify-dao/taki-contracts/pull/9/commits/524828510aa6519749bd2f77a1bdde2fe8cce64e).",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/BaseJumpRateModelV2.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./InterestRateModel.sol\";\n\n/**\n  * @title Logic for Compound's JumpRateModel Contract V2.\n  * @author Compound (modified by Dharma Labs, refactored by Arr00)\n  * @notice Version 2 modifies Version 1 by enabling updateable parameters.\n  */\nabstract contract BaseJumpRateModelV2 is InterestRateModel {\n    event NewInterestParams(uint baseRatePerBlock, uint multiplierPerBlock, uint jumpMultiplierPerBlock, uint kink);\n\n    uint256 private constant BASE = 1e18;\n\n    /**\n     * @notice The address of the owner, i.e. the Timelock contract, which can update parameters directly\n     */\n    address public owner;\n\n    /**\n     * @notice The approximate number of blocks per year that is assumed by the interest rate model\n     */\n    uint public constant blocksPerYear = 2102400;\n\n    /**\n     * @notice The multiplier of utilization rate that gives the slope of the interest rate\n     */\n    uint public multiplierPerBlock;\n\n    /**\n     * @notice The base interest rate which is the y-intercept when utilization rate is 0\n     */\n    uint public baseRatePerBlock;\n\n    /**\n     * @notice The multiplierPerBlock after hitting a specified utilization point\n     */\n    uint public jumpMultiplierPerBlock;\n\n    /**\n     * @notice The utilization point at which the jump multiplier is applied\n     */\n    uint public kink;\n\n    /**\n     * @notice Construct an interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     * @param owner_ The address of the owner, i.e. the Timelock contract (which has the ability to update parameters directly)\n     */\n    constructor(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_, address owner_) internal {\n        owner = owner_;\n\n        updateJumpRateModelInternal(baseRatePerYear,  multiplierPerYear, jumpMultiplierPerYear, kink_);\n    }\n\n    /**\n     * @notice Update the parameters of the interest rate model (only callable by owner, i.e. Timelock)\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     */\n    function updateJumpRateModel(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_) virtual external {\n        require(msg.sender == owner, \"only the owner may call this function.\");\n\n        updateJumpRateModelInternal(baseRatePerYear, multiplierPerYear, jumpMultiplierPerYear, kink_);\n    }\n\n    /**\n     * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market (currently unused)\n     * @return The utilization rate as a mantissa between [0, BASE]\n     */\n    function utilizationRate(uint cash, uint borrows, uint reserves) public pure returns (uint) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n\n        return borrows * BASE / (cash + borrows - reserves);\n    }\n\n    /**\n     * @notice Calculates the current borrow rate per block, with the error code expected by the market\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @return The borrow rate percentage per block as a mantissa (scaled by BASE)\n     */\n    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {\n        uint util = utilizationRate(cash, borrows, reserves);\n\n        if (util <= kink) {\n            return ((util * multiplierPerBlock) / BASE) + baseRatePerBlock;\n        } else {\n            uint normalRate = ((kink * multiplierPerBlock) / BASE) + baseRatePerBlock;\n            uint excessUtil = util - kink;\n            return ((excessUtil * jumpMultiplierPerBlock) / BASE) + normalRate;\n        }\n    }\n\n    /**\n     * @notice Calculates the current supply rate per block\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @param reserveFactorMantissa The current reserve factor for the market\n     * @return The supply rate percentage per block as a mantissa (scaled by BASE)\n     */\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) virtual override public view returns (uint) {\n        uint oneMinusReserveFactor = BASE - reserveFactorMantissa;\n        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);\n        uint rateToPool = borrowRate * oneMinusReserveFactor / BASE;\n        return utilizationRate(cash, borrows, reserves) * rateToPool / BASE;\n    }\n\n    /**\n     * @notice Internal function to update the parameters of the interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     */\n    function updateJumpRateModelInternal(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_) internal {\n        baseRatePerBlock = baseRatePerYear / blocksPerYear;\n        multiplierPerBlock = (multiplierPerYear * BASE) / (blocksPerYear * kink_);\n        jumpMultiplierPerBlock = jumpMultiplierPerYear / blocksPerYear;\n        kink = kink_;\n\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\n    }\n}"
    }
  ]
}