{
  "Title": "[M-05] Inconsistent Order Book Accounting When Working With Transfer-On-Fee or Deflationary Tokens",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L557\n\n\n# Vulnerability details\n\n## Background\n\nA transfer-on-fee token or a deflationary/rebasing token, causing the received amount to be less than the accounted amount. For instance, a deflationary tokens might charge a certain fee for every transfer() or transferFrom()\n\nRubicon Finance supports the trading of any ERC20 token, and anyone can liquidity pool for a new token. Thus, it is possible that such a transfer-on-fee token or a deflationary/rebasing token be used in the protocol.\n\nBased on the source code and comment of `BathToken._deposit()`, it appears that the team is aware of this issue, and proactively implemented control (before & after balance checks) to deal with deflationary tokens.\n\n[https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L557](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L557)\n\n```solidity\nfunction _deposit(uint256 assets, address receiver)\n    internal\n    returns (uint256 shares)\n{\n    uint256 _pool = underlyingBalance();\n    uint256 _before = underlyingToken.balanceOf(address(this));\n\n    // **Assume caller is depositor**\n    underlyingToken.transferFrom(msg.sender, address(this), assets);\n    uint256 _after = underlyingToken.balanceOf(address(this));\n    assets = _after.sub(_before); // Additional check for deflationary tokens\n\n    (totalSupply == 0) ? shares = assets : shares = (\n        assets.mul(totalSupply)\n    ).div(_pool);\n\n    // Send shares to designated target\n    _mint(receiver, shares);\n    ..SNIP..\n}\n```\n\nHowever, such control was not consistently applied across the protocol, and might cause the internal accounting of the orderbook to be incorrect.\n\n## Proof-of-Concept\n\nIf the `pay_gem` token is an deflationary token, the `info.pay_amt` and the actual amount of `pay_gem` tokens received will not be in sync. \n\nFor instance, assume that  XYZ token is a deflation token that charges 10% fee for every transfer. If an `offer(100, XYZ, 100, DAI)` is executed, an order with 100 XYZ (pay) and 100 DAI (buy) will be added to the orderbook. However, the orderbook will only received 90 XYZ, thus only 90 XYZ is ecrowed in the orderbook. This discrepancy would break the internal accounting system of the order book.\n\n[https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L392](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L392)\n\n```solidity\n/// @notice Key function to make a new offer. Takes funds from the caller into market escrow.\nfunction offer(\n    uint256 pay_amt,\n    ERC20 pay_gem,\n    uint256 buy_amt,\n    ERC20 buy_gem\n) public virtual can_offer synchronized returns (uint256 id) {\n    ..SNIP..\n    OfferInfo memory info;\n    info.pay_amt = pay_amt;\n    info.pay_gem = pay_gem;\n    info.buy_amt = buy_amt;\n    info.buy_gem = buy_gem;\n    info.owner = msg.sender;\n    info.timestamp = uint64(block.timestamp);\n    id = _next_id();\n    offers[id] = info;\n\n    require(pay_gem.transferFrom(msg.sender, address(this), pay_amt));\n    ..SNIP..\n}\n```\n\n## Impact\n\nThe internal accounting system of the order book would be inaccurate or break, affecting the protocol operation.\n\n## Recommended Mitigation Steps\n\nIn the `offer` function, get the actual received amount by calculating the difference of token balance before and after the transfer, and set the `info.pay_amt` to the actual received amount.\n\nAlternatively, the team might want to consider implementing whitelisting mechanism so that deflationary tokens will not be supported if the risk of allowing permissionless creation of pool with arbitrary token deems to be significant. A DAO may be formed in the future to manage the whitelisting.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-rubicon-contest",
  "Code": [
    {
      "filename": "contracts/rubiconPools/BathToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice This contract represents a single-asset liquidity pool for Rubicon Pools\n/// @notice Any user can deposit assets into this pool and earn yield from successful strategist market making with their liquidity\n/// @notice This contract looks to both BathPairs and the BathHouse as its admin\n\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IBathHouse.sol\";\nimport \"../interfaces/IRubiconMarket.sol\";\nimport \"../interfaces/IBathBuddy.sol\";\n\ncontract BathToken {\n    using SafeMath for uint256;\n\n    /// *** Storage Variables ***\n\n    /// @notice The initialization status of the Bath Token\n    bool public initialized;\n\n    /// @notice  ** ERC-20 **\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n\n    /// @notice The RubiconMarket.sol instance that all pool liquidity is intially directed to as market-making offers\n    address public RubiconMarketAddress;\n\n    /// @notice The Bath House admin of the Bath Token\n    address public bathHouse;\n\n    /// @notice The withdrawal fee recipient, typically the Bath Token itself\n    address public feeTo;\n\n    /// @notice The underlying ERC-20 token which is the core asset of the Bath Token vault\n    IERC20 public underlyingToken;\n\n    /// @notice The basis point fee rate that is paid on withdrawing the underlyingToken and bonusTokens\n    uint256 public feeBPS;\n\n    /// @notice ** ERC-20 **\n    uint256 public totalSupply;\n\n    /// @notice The amount of underlying deposits that are outstanding attempting market-making on the order book for yield\n    /// @dev quantity of underlyingToken that is in the orderbook that the pool still has a claim on\n    /// @dev The underlyingToken is effectively mark-to-marketed when it enters the book and it could be returned at a loss due to poor strategist performance\n    /// @dev outstandingAmount is NOT inclusive of any non-underlyingToken assets sitting on the Bath Tokens that have filled to here and are awaiting rebalancing to the underlyingToken by strategists\n    uint256 public outstandingAmount;\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress ðŸ“ˆ\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    uint256[] deprecatedStorageArray; // Kept in to avoid storage collision bathTokens that are proxy upgraded\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress ðŸ“ˆ\n    mapping(uint256 => uint256) deprecatedMapping; // Kept in to avoid storage collision on bathTokens that are upgraded\n    // *******************************************\n\n    /// @notice  ** ERC-20 **\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /// @notice EIP-2612\n    bytes32 public DOMAIN_SEPARATOR;\n\n    /// @notice EIP-2612\n    /// @dev keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice EIP-2612\n    mapping(address => uint256) public nonces;\n\n    /// @notice Array of Bonus ERC-20 tokens that are given as liquidity incentives to pool withdrawers\n    address[] public bonusTokens;\n\n    /// @notice Address of the OZ Vesting Wallet which acts as means to vest bonusToken incentives to pool HODLers\n    IBathBuddy public rewardsVestingWallet;\n\n    /// *** Events ***\n\n    /// @notice ** ERC-20 **\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /// @notice ** ERC-20 **\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Time of Bath Token instantiation\n    event LogInit(uint256 timeOfInit);\n\n    /// @notice Log details about a pool deposit\n    event LogDeposit(\n        uint256 depositedAmt,\n        IERC20 asset,\n        uint256 sharesReceived,\n        address depositor,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool withdraw\n    event LogWithdraw(\n        uint256 amountWithdrawn,\n        IERC20 asset,\n        uint256 sharesWithdrawn,\n        address withdrawer,\n        uint256 fee,\n        address feeTo,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool rebalance\n    event LogRebalance(\n        IERC20 pool_asset,\n        address destination,\n        IERC20 transferAsset,\n        uint256 rebalAmt,\n        uint256 stratReward,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order canceled in the Rubicon Market book\n    event LogPoolCancel(\n        uint256 orderId,\n        IERC20 pool_asset,\n        uint256 outstandingAmountToCancel,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order placed in the Rubicon Market book\n    event LogPoolOffer(\n        uint256 id,\n        IERC20 pool_asset,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log the credit to outstanding amount for funds that have been filled market-making\n    event LogRemoveFilledTradeAmount(\n        IERC20 pool_asset,\n        uint256 fillAmount,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice * EIP 4626 *\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// @notice * EIP 4626 *\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// *** Constructor ***\n\n    /// @notice Proxy-safe initialization of storage; the constructor\n    function initialize(\n        ERC20 token,\n        address market,\n        address _feeTo\n    ) external {\n        require(!initialized);\n        string memory _symbol = string(\n            abi.encodePacked((\"bath\"), token.symbol())\n        );\n        symbol = _symbol;\n        underlyingToken = token;\n        RubiconMarketAddress = market;\n        bathHouse = msg.sender; //NOTE: assumed admin is creator on BathHouse\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n        name = string(abi.encodePacked(_symbol, (\" v1\")));\n        decimals = token.decimals(); // v1 Change - 4626 Adherence\n\n        // Add infinite approval of Rubicon Market for this asset\n        IERC20(address(token)).approve(RubiconMarketAddress, 2**256 - 1);\n        emit LogInit(block.timestamp);\n\n        feeTo = address(this); //This contract is the fee recipient, rewarding HODLers\n        feeBPS = 3; //Fee set to 3 BPS initially\n\n        // Complete constract instantiation\n        initialized = true;\n    }\n\n    /// *** Modifiers ***\n\n    modifier onlyPair() {\n        require(\n            IBathHouse(bathHouse).isApprovedPair(msg.sender) == true,\n            \"not an approved pair - bathToken\"\n        );\n        _;\n    }\n\n    modifier onlyBathHouse() {\n        require(\n            msg.sender == bathHouse,\n            \"caller is not bathHouse - BathToken.sol\"\n        );\n        _;\n    }\n\n    /// *** External Functions - Only Bath House / Admin ***\n\n    /// @notice Admin-only function to set a Bath Token's market address\n    function setMarket(address newRubiconMarket) external onlyBathHouse {\n        RubiconMarketAddress = newRubiconMarket;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's Bath House admin\n    function setBathHouse(address newBathHouse) external onlyBathHouse {\n        bathHouse = newBathHouse;\n    }\n\n    /// @notice Admin-only function to approve Bath Token's RubiconMarketAddress with the maximum integer value (infinite approval)\n    function approveMarket() external onlyBathHouse {\n        underlyingToken.approve(RubiconMarketAddress, 2**256 - 1);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's feeBPS\n    function setFeeBPS(uint256 _feeBPS) external onlyBathHouse {\n        feeBPS = _feeBPS;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's fee recipient, typically the pool itself\n    function setFeeTo(address _feeTo) external onlyBathHouse {\n        feeTo = _feeTo;\n    }\n\n    /// @notice Admin-only function to add a bonus token to bonusTokens for pool incentives\n    function setBonusToken(address newBonusERC20) external onlyBathHouse {\n        bonusTokens.push(newBonusERC20);\n    }\n\n    /// *** External Functions - Only Approved Bath Pair / Strategist Contract ***\n\n    /// ** Rubicon Market Functions **\n\n    /// @notice The function for a strategist to cancel an outstanding Market Offer\n    function cancel(uint256 id, uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        IRubiconMarket(RubiconMarketAddress).cancel(id);\n\n        emit LogPoolCancel(\n            id,\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice A function called by BathPair to maintain proper accounting of outstandingAmount\n    function removeFilledTradeAmount(uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        emit LogRemoveFilledTradeAmount(\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice The function that places a bid and/or ask in the orderbook for a given pair from this pool\n    function placeOffer(\n        uint256 pay_amt,\n        ERC20 pay_gem,\n        uint256 buy_amt,\n        ERC20 buy_gem\n    ) external onlyPair returns (uint256) {\n        // Place an offer in RubiconMarket\n        // If incomplete offer return 0\n        if (\n            pay_amt == 0 ||\n            pay_gem == ERC20(0) ||\n            buy_amt == 0 ||\n            buy_gem == ERC20(0)\n        ) {\n            return 0;\n        }\n\n        uint256 id = IRubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            pay_gem,\n            buy_amt,\n            buy_gem,\n            0,\n            false\n        );\n        outstandingAmount = outstandingAmount.add(pay_amt);\n\n        emit LogPoolOffer(\n            id,\n            IERC20(underlyingToken),\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        return (id);\n    }\n\n    /// @notice This function returns filled orders to the correct liquidity pool and sends strategist rewards to the Bath Pair\n    /// @dev Sends non-underlyingToken fill elsewhere in the Pools system, typically it's sister asset within a trading pair (e.g. ETH-USDC)\n    /// @dev Strategists presently accrue rewards in the filled asset not underlyingToken\n    function rebalance(\n        address destination,\n        address filledAssetToRebalance, /* sister or fill asset */\n        uint256 stratProportion,\n        uint256 rebalAmt\n    ) external onlyPair {\n        uint256 stratReward = (stratProportion.mul(rebalAmt)).div(10000);\n        IERC20(filledAssetToRebalance).transfer(\n            destination,\n            rebalAmt.sub(stratReward)\n        );\n        IERC20(filledAssetToRebalance).transfer(msg.sender, stratReward);\n\n        emit LogRebalance(\n            IERC20(underlyingToken),\n            destination,\n            IERC20(filledAssetToRebalance),\n            rebalAmt,\n            stratReward,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// *** EIP 4626 Implementation ***\n    // https://eips.ethereum.org/EIPS/eip-4626#specification\n\n    /// @notice Withdraw your bathTokens for the underlyingToken\n    function withdraw(uint256 _shares)\n        external\n        returns (uint256 amountWithdrawn)\n    {\n        return _withdraw(_shares, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function asset() public view returns (address assetTokenAddress) {\n        assetTokenAddress = address(underlyingToken);\n    }\n\n    /// @notice * EIP 4626 *\n    function totalAssets() public view returns (uint256 totalManagedAssets) {\n        return underlyingBalance();\n    }\n\n    /// @notice * EIP 4626 *\n    function convertToShares(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // Note: Inflationary tokens may affect this logic\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(totalAssets());\n    }\n\n    // Note: MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// @notice * EIP 4626 *\n    function convertToAssets(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        assets = (totalAssets().mul(shares)).div(totalSupply);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxDeposit(address receiver)\n        public\n        pure\n        returns (uint256 maxAssets)\n    {\n        maxAssets = 2**256 - 1; // No limit on deposits in current implementation  = Max UINT\n    }\n\n    /// @notice * EIP 4626 *\n    function previewDeposit(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // The exact same logic is used, no deposit fee - only difference is deflationary token check (rare condition and probably redundant)\n        shares = convertToShares(assets);\n    }\n\n    // Single asset override to reflect old functionality\n    function deposit(uint256 assets) public returns (uint256 shares) {\n        // Note: msg.sender is the same throughout the same contract context\n        return _deposit(assets, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function deposit(uint256 assets, address receiver)\n        public\n        returns (uint256 shares)\n    {\n        return _deposit(assets, receiver);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxMint(address receiver) public pure returns (uint256 maxShares) {\n        maxShares = 2**256 - 1; // No limit on shares that could be created via deposit in current implementation - Max UINT\n    }\n\n    // Given I want these shares, how much do I have to deposit\n    /// @notice * EIP 4626 *\n    function previewMint(uint256 shares) public view returns (uint256 assets) {\n        (totalSupply == 0) ? assets = shares : assets = (\n            shares.mul(totalAssets())\n        ).div(totalSupply);\n    }\n\n    // Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n    /// @notice * EIP 4626 *\n    function mint(uint256 shares, address receiver)\n        public\n        returns (uint256 assets)\n    {\n        assets = previewMint(shares);\n        uint256 _shares = _deposit(assets, receiver);\n        require(_shares == shares, \"did not mint expected share count\");\n    }\n\n    // A user can withdraw whatever they hold\n    /// @notice * EIP 4626 *\n    function maxWithdraw(address owner)\n        public\n        view\n        returns (uint256 maxAssets)\n    {\n        if (totalSupply == 0) {\n            maxAssets = 0;\n        } else {\n            uint256 ownerShares = balanceOf[owner];\n            maxAssets = convertToAssets(ownerShares);\n        }\n    }\n\n    /// @notice * EIP 4626 *\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        if (totalSupply == 0) {\n            shares = 0;\n        } else {\n            uint256 amountWithdrawn;\n            uint256 _fee = assets.mul(feeBPS).div(10000);\n            amountWithdrawn = assets.sub(_fee);\n            shares = convertToShares(amountWithdrawn);\n        }\n    }\n\n    /// @notice * EIP 4626 *\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public returns (uint256 shares) {\n        require(\n            owner == msg.sender,\n            \"This implementation does not support non-sender owners from withdrawing user shares\"\n        );\n        uint256 expectedShares = previewWithdraw(assets);\n        uint256 assetsReceived = _withdraw(expectedShares, receiver);\n        require(\n            assetsReceived >= assets,\n            \"You cannot withdraw the amount of assets you expected\"\n        );\n        shares = expectedShares;\n    }\n\n    // Constraint: msg.sender is owner of shares when withdrawing\n    /// @notice * EIP 4626 *\n    function maxRedeem(address owner) public view returns (uint256 maxShares) {\n        return balanceOf[owner];\n    }\n\n    // Constraint: msg.sender is owner of shares when withdrawing\n    /// @notice * EIP 4626 *\n    function previewRedeem(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        uint256 r = (underlyingBalance().mul(shares)).div(totalSupply);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        assets = r.sub(_fee);\n    }\n\n    /// @notice * EIP 4626 *\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public returns (uint256 assets) {\n        require(\n            owner == msg.sender,\n            \"This implementation does not support non-sender owners from withdrawing user shares\"\n        );\n        assets = _withdraw(shares, receiver);\n    }\n\n    /// *** Internal Functions ***\n\n    /// @notice Deposit assets for the user and mint Bath Token shares to receiver\n    function _deposit(uint256 assets, address receiver)\n        internal\n        returns (uint256 shares)\n    {\n        uint256 _pool = underlyingBalance();\n        uint256 _before = underlyingToken.balanceOf(address(this));\n\n        // **Assume caller is depositor**\n        underlyingToken.transferFrom(msg.sender, address(this), assets);\n        uint256 _after = underlyingToken.balanceOf(address(this));\n        assets = _after.sub(_before); // Additional check for deflationary tokens\n\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(_pool);\n\n        // Send shares to designated target\n        _mint(receiver, shares);\n        emit LogDeposit(\n            assets,\n            underlyingToken,\n            shares,\n            msg.sender,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Deposit(msg.sender, msg.sender, assets, shares);\n    }\n\n    /// @notice Withdraw share for the user and send underlyingToken to receiver with any accrued yield and incentive tokens\n    function _withdraw(uint256 _shares, address receiver)\n        internal\n        returns (uint256 amountWithdrawn)\n    {\n        uint256 _initialTotalSupply = totalSupply;\n\n        // Distribute network rewards first in order to handle bonus token == underlying token case; it only releases vested tokens in this call\n        distributeBonusTokenRewards(receiver, _shares, _initialTotalSupply);\n\n        uint256 r = (underlyingBalance().mul(_shares)).div(_initialTotalSupply);\n        _burn(msg.sender, _shares);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        // If FeeTo == address(0) then the fee is effectively accrued by the pool\n        if (feeTo != address(0)) {\n            underlyingToken.transfer(feeTo, _fee);\n        }\n        amountWithdrawn = r.sub(_fee);\n        underlyingToken.transfer(receiver, amountWithdrawn);\n\n        emit LogWithdraw(\n            amountWithdrawn,\n            underlyingToken,\n            _shares,\n            msg.sender,\n            _fee,\n            feeTo,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Withdraw(\n            msg.sender,\n            receiver,\n            msg.sender,\n            amountWithdrawn,\n            _shares\n        );\n    }\n\n    /// @notice Function to distibute non-underlyingToken Bath Token incentives to pool withdrawers\n    /// @dev Note that bonusTokens adhere to the same feeTo and feeBPS pattern. Fees sit on BathBuddy to act as effectively accrued to the pool.\n    function distributeBonusTokenRewards(\n        address receiver,\n        uint256 sharesWithdrawn,\n        uint256 initialTotalSupply\n    ) internal {\n        if (bonusTokens.length > 0) {\n            for (uint256 index = 0; index < bonusTokens.length; index++) {\n                IERC20 token = IERC20(bonusTokens[index]);\n                // Note: Shares already burned in Bath Token _withdraw\n\n                // Pair each bonus token with a lightly adapted OZ Vesting wallet. Each time a user withdraws, they\n                //  are released their relative share of this pool, of vested BathBuddy rewards\n                // The BathBuddy pool should accrue ERC-20 rewards just like OZ VestingWallet and simply just release the withdrawer's relative share of releaseable() tokens\n                if (rewardsVestingWallet != IBathBuddy(0)) {\n                    rewardsVestingWallet.release(\n                        (token),\n                        receiver,\n                        sharesWithdrawn,\n                        initialTotalSupply,\n                        feeBPS\n                    );\n                }\n            }\n        }\n    }\n\n    /// *** ERC - 20 Standard ***\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) {\n        if (allowance[from][msg.sender] != uint256(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(\n                value\n            );\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"bathToken: EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        value,\n                        nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"bathToken: INVALID_SIGNATURE\"\n        );\n        _approve(owner, spender, value);\n    }\n\n    /// *** View Functions ***\n\n    /// @notice The underlying ERC-20 that this bathToken handles\n    function underlyingERC20() external view returns (address) {\n        return address(underlyingToken);\n    }\n\n    /// @notice The best-guess total claim on assets the Bath Token has\n    /// @dev returns the amount of underlying ERC20 tokens in this pool in addition to any tokens that are outstanding in the Rubicon order book seeking market-making yield (outstandingAmount)\n    function underlyingBalance() public view returns (uint256) {\n        uint256 _pool = IERC20(underlyingToken).balanceOf(address(this));\n        return _pool.add(outstandingAmount);\n    }\n}"
    }
  ]
}