{
  "Title": "[G-22] ++i/i++ should be unchecked{++i}/unchecked{i++} when it is not possible for them to overflow, as is the case when used in for- and while-loops",
  "Content": "\nThe unchecked keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are.\n\n6 results - 2 files:\n```solidity\ncontracts\\smart-contract-wallet\\SmartAccount.sol:\n  468:    for (uint i = 0; i < dest.length;) {\n```\n[SmartAccount.sol#L468](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L468)\n\n\n```solidity\ncontracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol:\n  100:    for (uint256 i = 0; i < opasLen; i++) {\n\n  107:    for (uint256 a = 0; a < opasLen; a++) {\n\n  112:    for (uint256 i = 0; i < opslen; i++) {\n\n  128:    for (uint256 a = 0; a < opasLen; a++) {\n\n  134:    for (uint256 i = 0; i < opslen; i++) {\n```\n[EntryPoint.sol#L100](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L100), [EntryPoint.sol#L107](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L107), [EntryPoint.sol#L112](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L112), [EntryPoint.sol#L128](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L128), [EntryPoint.sol#L134](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L134)\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2023-01-biconomy-smart-contract-wallet-contest",
  "Code": [
    {
      "filename": "scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"./libs/LibAddress.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./BaseSmartAccount.sol\";\nimport \"./common/Singleton.sol\";\nimport \"./base/ModuleManager.sol\";\nimport \"./base/FallbackManager.sol\";\nimport \"./common/SignatureDecoder.sol\";\nimport \"./common/SecuredTokenTransfer.sol\";\nimport \"./interfaces/ISignatureValidator.sol\";\nimport \"./interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\ncontract SmartAccount is \n     Singleton,\n     BaseSmartAccount,\n     IERC165,\n     ModuleManager,\n     SignatureDecoder,\n     SecuredTokenTransfer,\n     ISignatureValidatorConstants,\n     FallbackManager,\n     Initializable,\n     ReentrancyGuardUpgradeable\n    {\n    using ECDSA for bytes32;\n    using LibAddress for address;\n\n    // Storage\n\n    // Version\n    string public constant VERSION = \"1.0.2\"; // using AA 0.3.0\n\n    // Domain Seperators\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n    bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // review? if rename wallet to account is must\n    // keccak256(\n    //     \"AccountTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 internal constant ACCOUNT_TX_TYPEHASH = 0xc2595443c361a1f264c73470b9410fd67ac953ebd1a3ae63a2f514f3f014cf07;\n\n    // Owner storage\n    address public owner;\n\n    // uint96 private _nonce; //changed to 2D nonce below\n    // @notice there is no _nonce \n    mapping(uint256 => uint256) public nonces;\n\n    // AA storage\n    // review\n    IEntryPoint private _entryPoint;\n\n    \n    // Events\n    // EOA + Version tracking\n    event ImplementationUpdated(address _scw, string version, address newImplementation);\n    event EntryPointChanged(address oldEntryPoint, address newEntryPoint);\n    event EOAChanged(address indexed _scw, address indexed _oldEOA, address indexed _newEOA);\n    event WalletHandlePayment(bytes32 txHash, uint256 payment);\n    // nice to have\n    // event SmartAccountInitialized(IEntryPoint indexed entryPoint, address indexed owner);\n\n    // modifiers\n    // onlyOwner\n    /**\n     * @notice Throws if the sender is not an the owner.\n     */\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Smart Account:: Sender is not authorized\");\n        _;\n    }\n\n    // onlyOwner OR self\n    modifier mixedAuth {\n        require(msg.sender == owner || msg.sender == address(this),\"Only owner or self\");\n        _;\n   }\n\n   // only from EntryPoint\n   modifier onlyEntryPoint {\n        require(msg.sender == address(entryPoint()), \"wallet: not from EntryPoint\");\n        _; \n   }\n\n   function nonce() public view virtual override returns (uint256) {\n        return nonces[0];\n    }\n\n    function nonce(uint256 _batchId) public view virtual override returns (uint256) {\n        return nonces[_batchId];\n    }\n\n    function entryPoint() public view virtual override returns (IEntryPoint) {\n        return _entryPoint;\n    }\n\n    // @notice authorized modifier (onlySelf) is already inherited\n\n    // Setters\n\n    function setOwner(address _newOwner) external mixedAuth {\n        require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n        address oldOwner = owner;\n        owner = _newOwner;\n        emit EOAChanged(address(this), oldOwner, _newOwner);\n    }\n\n    /**\n     * @notice Updates the implementation of the base wallet\n     * @param _implementation New wallet implementation\n     */\n    function updateImplementation(address _implementation) external mixedAuth {\n        require(_implementation.isContract(), \"INVALID_IMPLEMENTATION\");\n        _setImplementation(_implementation);\n        // EOA + Version tracking\n        emit ImplementationUpdated(address(this), VERSION, _implementation);\n    }\n\n    function updateEntryPoint(address _newEntryPoint) external mixedAuth {\n        require(_newEntryPoint != address(0), \"Smart Account:: new entry point address cannot be zero\");\n        emit EntryPointChanged(address(_entryPoint), _newEntryPoint);\n        _entryPoint = IEntryPoint(payable(_newEntryPoint));\n    }\n\n    // Getters\n\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\n    }\n\n    /// @dev Returns the chain id used by this contract.\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    //@review getNonce specific to EntryPoint requirements\n    /**\n     * @dev returns a value from the nonces 2d mapping\n     * @param batchId : the key of the user's batch being queried\n     * @return nonce : the number of transaction made within said batch\n     */\n    function getNonce(uint256 batchId)\n    public view\n    returns (uint256) {\n        return nonces[batchId];\n    }\n\n\n    // init\n    // Initialize / Setup\n    // Used to setup\n    // i. owner ii. entry point address iii. handler\n    function init(address _owner, address _entryPointAddress, address _handler) public override initializer { \n        require(owner == address(0), \"Already initialized\");\n        require(address(_entryPoint) == address(0), \"Already initialized\");\n        require(_owner != address(0),\"Invalid owner\");\n        require(_entryPointAddress != address(0), \"Invalid Entrypoint\");\n        require(_handler != address(0), \"Invalid Entrypoint\");\n        owner = _owner;\n        _entryPoint =  IEntryPoint(payable(_entryPointAddress));\n        if (_handler != address(0)) internalSetFallbackHandler(_handler);\n        setupModules(address(0), bytes(\"\"));\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    // Gnosis style transaction with optional repay in native tokens OR ERC20 \n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n    /// Note: The fees are always transferred, even if the user transaction fails.\n    /// @param _tx Wallet transaction \n    /// @param batchId batchId key for 2D nonces\n    /// @param refundInfo Required information for gas refunds\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        Transaction memory _tx,\n        uint256 batchId,\n        FeeRefund memory refundInfo,\n        bytes memory signatures\n    ) public payable virtual override returns (bool success) {\n        // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4\n        //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\n        uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n        //console.log(\"init %s\", 21000 + msg.data.length * 8);\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData =\n                encodeTransactionData(\n                    // Transaction info\n                    _tx,\n                    // Payment info\n                    refundInfo,\n                    // Signature info\n                    nonces[batchId]\n                );\n            // Increase nonce and execute transaction.\n            // Default space aka batchId is 0\n            nonces[batchId]++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures);\n        }\n\n\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        require(gasleft() >= max((_tx.targetTxGas * 64) / 63,_tx.targetTxGas + 2500) + 500, \"BSA010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than targetTxGas)\n            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than targetTxGas\n            success = execute(_tx.to, _tx.value, _tx.data, _tx.operation, refundInfo.gasPrice == 0 ? (gasleft() - 2500) : _tx.targetTxGas);\n            // If no targetTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            require(success || _tx.targetTxGas != 0 || refundInfo.gasPrice != 0, \"BSA013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            // uint256 extraGas;\n            if (refundInfo.gasPrice > 0) {\n                //console.log(\"sent %s\", startGas - gasleft());\n                // extraGas = gasleft();\n                payment = handlePayment(startGas - gasleft(), refundInfo.baseGas, refundInfo.gasPrice, refundInfo.tokenGasPriceFactor, refundInfo.gasToken, refundInfo.refundReceiver);\n                emit WalletHandlePayment(txHash, payment);\n            }\n            // extraGas = extraGas - gasleft();\n            //console.log(\"extra gas %s \", extraGas);\n        }\n    }\n\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver\n    ) private nonReentrant returns (uint256 payment) {\n        // uint256 startGas = gasleft();\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool success,) = receiver.call{value: payment}(\"\");\n            require(success, \"BSA011\");\n        } else {\n            payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n            require(transferToken(gasToken, receiver, payment), \"BSA012\");\n        }\n        // uint256 requiredGas = startGas - gasleft();\n        //console.log(\"hp %s\", requiredGas);\n    }\n\n    function handlePaymentRevert(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver\n    ) external returns (uint256 payment) {\n        uint256 startGas = gasleft();\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool success,) = receiver.call{value: payment}(\"\");\n            require(success, \"BSA011\");\n        } else {\n            payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n            require(transferToken(gasToken, receiver, payment), \"BSA012\");\n        }\n        uint256 requiredGas = startGas - gasleft();\n        //console.log(\"hpr %s\", requiredGas);\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures\n    ) public view virtual {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i = 0;\n        address _signer;\n        (v, r, s) = signatureSplit(signatures, i);\n        //review\n        if(v == 0) {\n            // If v is 0 then it is a contract signature\n            // When handling contract signatures the address of the contract is encoded into r\n            _signer = address(uint160(uint256(r)));\n\n            // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                require(uint256(s) >= uint256(1) * 65, \"BSA021\");\n\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n                require(uint256(s) + 32 <= signatures.length, \"BSA022\");\n\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n                uint256 contractSignatureLen;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                }\n                require(uint256(s) + 32 + contractSignatureLen <= signatures.length, \"BSA023\");\n\n                // Check signature\n                bytes memory contractSignature;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n                    contractSignature := add(add(signatures, s), 0x20)\n                }\n                require(ISignatureValidator(_signer).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"BSA024\");\n        }\n        else if(v > 30) {\n            // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n            // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n            _signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            require(_signer == owner, \"INVALID_SIGNATURE\");\n        } else {\n            _signer = ecrecover(dataHash, v, r, s);\n            require(_signer == owner, \"INVALID_SIGNATURE\");\n        }\n    }\n\n    /// @dev Allows to estimate a transaction.\n    ///      This method is only meant for estimation purpose, therefore the call will always revert and encode the result in the revert data.\n    ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of transaction.\n    /// @param data Data payload of transaction.\n    /// @param operation Operation type of transaction.\n    /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\n    function requiredTxGas(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external returns (uint256) {\n        uint256 startGas = gasleft();\n        // We don't provide an error message here, as we use it to return the estimate\n        require(execute(to, value, data, operation, gasleft()));\n        uint256 requiredGas = startGas - gasleft();\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /// @dev Returns hash to be signed by owner.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param targetTxGas Fas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash.\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 targetTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes32) {\n        Transaction memory _tx = Transaction({\n            to: to,\n            value: value,\n            data: data,\n            operation: operation,\n            targetTxGas: targetTxGas\n        });\n        FeeRefund memory refundInfo = FeeRefund({\n            baseGas: baseGas,\n            gasPrice: gasPrice,\n            tokenGasPriceFactor: tokenGasPriceFactor,\n            gasToken: gasToken,\n            refundReceiver: refundReceiver\n        });\n        return keccak256(encodeTransactionData(_tx, refundInfo, _nonce));\n    }\n\n    /// @dev Returns the bytes that are hashed to be signed by owner.\n    /// @param _tx Wallet transaction \n    /// @param refundInfo Required information for gas refunds\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash bytes.\n    function encodeTransactionData(\n        Transaction memory _tx,\n        FeeRefund memory refundInfo,\n        uint256 _nonce\n    ) public view returns (bytes memory) {\n        bytes32 safeTxHash =\n            keccak256(\n                abi.encode(\n                    ACCOUNT_TX_TYPEHASH,\n                    _tx.to,\n                    _tx.value,\n                    keccak256(_tx.data),\n                    _tx.operation,\n                    _tx.targetTxGas,\n                    refundInfo.baseGas,\n                    refundInfo.gasPrice,\n                    refundInfo.gasToken,\n                    refundInfo.refundReceiver,\n                    _nonce\n                )\n            );\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\n    }\n\n    // Extra Utils \n    function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {\n        require(dest != address(0), \"this action will burn your funds\");\n        (bool success,) = dest.call{value:amount}(\"\");\n        require(success,\"transfer failed\");\n    }\n\n    function pullTokens(address token, address dest, uint256 amount) external onlyOwner {\n        IERC20 tokenContract = IERC20(token);\n        SafeERC20.safeTransfer(tokenContract, dest, amount);\n    }\n\n    function execute(address dest, uint value, bytes calldata func) external onlyOwner{\n        _requireFromEntryPointOrOwner();\n        _call(dest, value, func);\n    }\n\n    function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{\n        _requireFromEntryPointOrOwner();\n        require(dest.length == func.length, \"wrong array lengths\");\n        for (uint i = 0; i < dest.length;) {\n            _call(dest[i], 0, func[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // AA implementation\n    function _call(address target, uint256 value, bytes memory data) internal {\n        (bool success, bytes memory result) = target.call{value : value}(data);\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n    }\n    \n    //called by entryPoint, only after validateUserOp succeeded.\n    //@review\n    //Method is updated to instruct delegate call and emit regular events\n    function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {        \n        success = execute(dest, value, func, operation, gasLimit);\n        require(success, \"Userop Failed\");\n    }\n\n    function _requireFromEntryPointOrOwner() internal view {\n        require(msg.sender == address(entryPoint()) || msg.sender == owner, \"account: not Owner or EntryPoint\");\n    }\n\n    /// implement template method of BaseAccount\n    // @notice Nonce space is locked to 0 for AA transactions\n    // userOp could have batchId as well\n    function _validateAndUpdateNonce(UserOperation calldata userOp) internal override {\n        require(nonces[0]++ == userOp.nonce, \"account: invalid nonce\");\n    }\n\n    /// implement template method of BaseAccount\n    function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash, address)\n    internal override virtual returns (uint256 deadline) {\n        bytes32 hash = userOpHash.toEthSignedMessageHash();\n        //ignore signature mismatch of from==ZERO_ADDRESS (for eth_callUserOp validation purposes)\n        // solhint-disable-next-line avoid-tx-origin\n        require(owner == hash.recover(userOp.signature) || tx.origin == address(0), \"account: wrong signature\");\n        return 0;\n    }\n\n    /**\n     * check current account deposit in the entryPoint\n     */\n    function getDeposit() public view returns (uint256) {\n        return entryPoint().balanceOf(address(this));\n    }\n\n    /**\n     * deposit more funds for this account in the entryPoint\n     */\n    function addDeposit() public payable {\n\n        (bool req,) = address(entryPoint()).call{value : msg.value}(\"\");\n        require(req);\n    }\n\n    /**\n     * withdraw value from the account's deposit\n     * @param withdrawAddress target to send to\n     * @param amount to withdraw\n     */\n    function withdrawDepositTo(address payable withdrawAddress, uint256 amount) public onlyOwner {\n        entryPoint().withdrawTo(withdrawAddress, amount);\n    }\n\n    /**\n     * @notice Query if a contract implements an interface\n     * @param interfaceId The interface identifier, as specified in ERC165\n     * @return `true` if the contract implements `_interfaceID`\n    */\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}"
    },
    {
      "filename": "scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol",
      "content": "/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable avoid-tx-origin */\n\nimport \"../interfaces/IAccount.sol\";\nimport \"../interfaces/IPaymaster.sol\";\n\nimport \"../interfaces/IAggregatedAccount.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\nimport \"../utils/Exec.sol\";\nimport \"./StakeManager.sol\";\nimport \"./SenderCreator.sol\";\n\ncontract EntryPoint is IEntryPoint, StakeManager {\n\n    using UserOperationLib for UserOperation;\n\n    SenderCreator private immutable senderCreator = new SenderCreator();\n\n    // internal value used during simulation: need to query aggregator.\n    address private constant SIMULATE_FIND_AGGREGATOR = address(1);\n\n    /**\n     * compensate the caller's beneficiary address with the collected fees of all UserOperations.\n     * @param beneficiary the address to receive the fees\n     * @param amount amount to transfer.\n     */\n    function _compensate(address payable beneficiary, uint256 amount) internal {\n        require(beneficiary != address(0), \"AA90 invalid beneficiary\");\n        (bool success,) = beneficiary.call{value : amount}(\"\");\n        require(success, \"AA91 failed send to beneficiary\");\n    }\n\n    /**\n     * execute a user op\n     * @param opIndex into into the opInfo array\n     * @param userOp the userOp to execute\n     * @param opInfo the opInfo filled by validatePrepayment for this userOp.\n     * @return collected the total amount this userOp paid.\n     */\n    function _executeUserOp(uint256 opIndex, UserOperation calldata userOp, UserOpInfo memory opInfo) private returns (uint256 collected) {\n        uint256 preGas = gasleft();\n        bytes memory context = getMemoryBytesFromOffset(opInfo.contextOffset);\n\n        try this.innerHandleOp(userOp.callData, opInfo, context) returns (uint256 _actualGasCost) {\n            collected = _actualGasCost;\n        } catch {\n            uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n            collected = _handlePostOp(opIndex, IPaymaster.PostOpMode.postOpReverted, opInfo, context, actualGas);\n        }\n    }\n\n    /**\n     * Execute a batch of UserOperation.\n     * no signature aggregator is used.\n     * if any account requires an aggregator (that is, it returned an \"actualAggregator\" when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops the operations to execute\n     * @param beneficiary the address to receive the fees\n     */\n    function handleOps(UserOperation[] calldata ops, address payable beneficiary) public {\n\n        uint256 opslen = ops.length;\n        UserOpInfo[] memory opInfos = new UserOpInfo[](opslen);\n\n    unchecked {\n        for (uint256 i = 0; i < opslen; i++) {\n            _validatePrepayment(i, ops[i], opInfos[i], address(0));\n        }\n\n        uint256 collected = 0;\n\n        for (uint256 i = 0; i < opslen; i++) {\n            collected += _executeUserOp(i, ops[i], opInfos[i]);\n        }\n\n        _compensate(beneficiary, collected);\n    } //unchecked\n    }\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\n     * @param beneficiary the address to receive the fees\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) public {\n\n        uint256 opasLen = opsPerAggregator.length;\n        uint256 totalOps = 0;\n        for (uint256 i = 0; i < opasLen; i++) {\n            totalOps += opsPerAggregator[i].userOps.length;\n        }\n\n        UserOpInfo[] memory opInfos = new UserOpInfo[](totalOps);\n\n        uint256 opIndex = 0;\n        for (uint256 a = 0; a < opasLen; a++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n            UserOperation[] calldata ops = opa.userOps;\n            IAggregator aggregator = opa.aggregator;\n            uint256 opslen = ops.length;\n            for (uint256 i = 0; i < opslen; i++) {\n                _validatePrepayment(opIndex, ops[i], opInfos[opIndex], address(aggregator));\n                opIndex++;\n            }\n\n            if (address(aggregator) != address(0)) {\n                // solhint-disable-next-line no-empty-blocks\n                try aggregator.validateSignatures(ops, opa.signature) {}\n                catch {\n                    revert SignatureValidationFailed(address(aggregator));\n                }\n            }\n        }\n\n        uint256 collected = 0;\n        opIndex = 0;\n        for (uint256 a = 0; a < opasLen; a++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n            emit SignatureAggregatorChanged(address(opa.aggregator));\n            UserOperation[] calldata ops = opa.userOps;\n            uint256 opslen = ops.length;\n\n            for (uint256 i = 0; i < opslen; i++) {\n                collected += _executeUserOp(opIndex, ops[i], opInfos[opIndex]);\n                opIndex++;\n            }\n        }\n        emit SignatureAggregatorChanged(address(0));\n\n        _compensate(beneficiary, collected);\n    }\n\n    //a memory copy of UserOp fields (except that dynamic byte arrays: callData, initCode and signature\n    struct MemoryUserOp {\n        address sender;\n        uint256 nonce;\n        uint256 callGasLimit;\n        uint256 verificationGasLimit;\n        uint256 preVerificationGas;\n        address paymaster;\n        uint256 maxFeePerGas;\n        uint256 maxPriorityFeePerGas;\n    }\n\n    struct UserOpInfo {\n        MemoryUserOp mUserOp;\n        bytes32 userOpHash;\n        uint256 prefund;\n        uint256 contextOffset;\n        uint256 preOpGas;\n    }\n\n    /**\n     * inner function to handle a UserOperation.\n     * Must be declared \"external\" to open a call context, but it can only be called by handleOps.\n     */\n    function innerHandleOp(bytes calldata callData, UserOpInfo memory opInfo, bytes calldata context) external returns (uint256 actualGasCost) {\n        uint256 preGas = gasleft();\n        require(msg.sender == address(this), \"AA92 internal call only\");\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\n\n        IPaymaster.PostOpMode mode = IPaymaster.PostOpMode.opSucceeded;\n        if (callData.length > 0) {\n\n            (bool success,bytes memory result) = address(mUserOp.sender).call{gas : mUserOp.callGasLimit}(callData);\n            if (!success) {\n                if (result.length > 0) {\n                    emit UserOperationRevertReason(opInfo.userOpHash, mUserOp.sender, mUserOp.nonce, result);\n                }\n                mode = IPaymaster.PostOpMode.opReverted;\n            }\n        }\n\n    unchecked {\n        uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n        //note: opIndex is ignored (relevant only if mode==postOpReverted, which is only possible outside of innerHandleOp)\n        return _handlePostOp(0, mode, opInfo, context, actualGas);\n    }\n    }\n\n    /**\n     * generate a request Id - unique identifier for this request.\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\n     */\n    function getUserOpHash(UserOperation calldata userOp) public view returns (bytes32) {\n        return keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\n    }\n\n    /**\n     * copy general fields from userOp into the memory opInfo structure.\n     */\n    function _copyUserOpToMemory(UserOperation calldata userOp, MemoryUserOp memory mUserOp) internal pure {\n        mUserOp.sender = userOp.sender;\n        mUserOp.nonce = userOp.nonce;\n        mUserOp.callGasLimit = userOp.callGasLimit;\n        mUserOp.verificationGasLimit = userOp.verificationGasLimit;\n        mUserOp.preVerificationGas = userOp.preVerificationGas;\n        mUserOp.maxFeePerGas = userOp.maxFeePerGas;\n        mUserOp.maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\n        bytes calldata paymasterAndData = userOp.paymasterAndData;\n        if (paymasterAndData.length > 0) {\n            require(paymasterAndData.length >= 20, \"AA93 invalid paymasterAndData\");\n            mUserOp.paymaster = address(bytes20(paymasterAndData[: 20]));\n        } else {\n            mUserOp.paymaster = address(0);\n        }\n    }\n\n    /**\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\n     * @dev this method always revert. Successful result is SimulationResult error. other errors are failures.\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\n     * @param userOp the user operation to validate.\n     */\n    function simulateValidation(UserOperation calldata userOp) external {\n        uint256 preGas = gasleft();\n\n        UserOpInfo memory outOpInfo;\n\n        (address aggregator, uint256 deadline) = _validatePrepayment(0, userOp, outOpInfo, SIMULATE_FIND_AGGREGATOR);\n        uint256 prefund = outOpInfo.prefund;\n        uint256 preOpGas = preGas - gasleft() + userOp.preVerificationGas;\n        StakeInfo memory paymasterInfo = getStakeInfo(outOpInfo.mUserOp.paymaster);\n        StakeInfo memory senderInfo = getStakeInfo(outOpInfo.mUserOp.sender);\n        bytes c"
    }
  ]
}