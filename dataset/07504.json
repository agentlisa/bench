{
  "Title": "[H-02] `LPDA` price can underflow the price due to bad settings and potentially brick the contract",
  "Content": "\nThe dutch auction in the `LPDA` contract is implemented by configuring a start price and price drop per second.\n\nA bad set of settings can cause an issue where the elapsed duration of the sale multiplied by the drop per second gets bigger than the start price and underflows the current price calculation.\n\n<https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L117>\n\n```solidity\nfunction getPrice() public view returns (uint256) {\n    Sale memory temp = sale;\n    (uint256 start, uint256 end) = (temp.startTime, temp.endTime);\n    if (block.timestamp < start) return type(uint256).max;\n    if (temp.currentId == temp.finalId) return temp.finalPrice;\n\n    uint256 timeElapsed = end > block.timestamp ? block.timestamp - start : end - start;\n    return temp.startPrice - (temp.dropPerSecond * timeElapsed);\n}\n```\n\nThis means that if `temp.dropPerSecond * timeElapsed > temp.startPrice` then the unsigned integer result will become negative and underflow, leading to potentially bricking the contract and an eventual loss of funds.\n\n### Impact\n\nDue to Solidity 0.8 default checked math, the subtraction of the start price and the drop will cause a negative value that will generate an underflow in the unsigned integer type and lead to a transaction revert.\n\nCalls to `getPrice` will revert, and since this function is used in the `buy` to calculate the current NFT price it will also cause the buy process to fail. The price drop will continue to increase as time passes, making it impossible to recover from this situation and effectively bricking the contract.\n\nThis will eventually lead to a loss of funds because currently the only way to end a sale and transfer funds to the sale and fee receiver is to buy the complete set of NFTs in the sale (i.e. buy everything up to the `sale.finalId`) which will be impossible if the `buy` function is bricked.\n\n### Proof of Concept\n\nIn the following test, the start price is 1500 and the duration is 1 hour (3600 seconds) with a drop of 1 per second. At about \\~40% of the elapsed time the price drop will start underflowing the price, reverting the calls to both `getPrice` and `buy`.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"forge-std/Test.sol\";\nimport {FixedPriceFactory} from \"src/minters/FixedPriceFactory.sol\";\nimport {FixedPrice} from \"src/minters/FixedPrice.sol\";\nimport {OpenEditionFactory} from \"src/minters/OpenEditionFactory.sol\";\nimport {OpenEdition} from \"src/minters/OpenEdition.sol\";\nimport {LPDAFactory} from \"src/minters/LPDAFactory.sol\";\nimport {LPDA} from \"src/minters/LPDA.sol\";\nimport {Escher721} from \"src/Escher721.sol\";\n\ncontract AuditTest is Test {\n    address deployer;\n    address creator;\n    address buyer;\n\n    FixedPriceFactory fixedPriceFactory;\n    OpenEditionFactory openEditionFactory;\n    LPDAFactory lpdaFactory;\n\n    function setUp() public {\n        deployer = makeAddr(\"deployer\");\n        creator = makeAddr(\"creator\");\n        buyer = makeAddr(\"buyer\");\n\n        vm.deal(buyer, 1e18);\n\n        vm.startPrank(deployer);\n\n        fixedPriceFactory = new FixedPriceFactory();\n        openEditionFactory = new OpenEditionFactory();\n        lpdaFactory = new LPDAFactory();\n\n        vm.stopPrank();\n    }\n    \n    function test_LPDA_getPrice_NegativePrice() public {\n        // Setup NFT and create sale\n        vm.startPrank(creator);\n\n        Escher721 nft = new Escher721();\n        nft.initialize(creator, address(0), \"Test NFT\", \"TNFT\");\n\n        // Duration is 1 hour (3600 seconds), with a start price of 1500 and a drop of 1, getPrice will revert and brick the contract at about 40% of the elapsed duration\n        uint48 startId = 0;\n        uint48 finalId = 1;\n        uint80 startPrice = 1500;\n        uint80 dropPerSecond = 1;\n        uint96 startTime = uint96(block.timestamp);\n        uint96 endTime = uint96(block.timestamp + 1 hours);\n\n        LPDA.Sale memory sale = LPDA.Sale(\n            startId, // uint48 currentId;\n            finalId, // uint48 finalId;\n            address(nft), // address edition;\n            startPrice, // uint80 startPrice;\n            0, // uint80 finalPrice;\n            dropPerSecond, // uint80 dropPerSecond;\n            endTime, // uint96 endTime;\n            payable(creator), // address payable saleReceiver;\n            startTime // uint96 startTime;\n        );\n        LPDA lpdaSale = LPDA(lpdaFactory.createLPDASale(sale));\n\n        nft.grantRole(nft.MINTER_ROLE(), address(lpdaSale));\n\n        vm.stopPrank();\n\n        // simulate we are in the middle of the sale duration\n        vm.warp(startTime + 0.5 hours);\n\n        vm.startPrank(buyer);\n\n        // getPrice will revert due to the overflow caused by the price becoming negative\n        vm.expectRevert();\n        lpdaSale.getPrice();\n\n        // This will also cause the contract to be bricked, since buy needs getPrice to check that the buyer is sending the correct amount\n        uint256 amount = 1;\n        uint256 price = 1234;\n        vm.expectRevert();\n        lpdaSale.buy{value: price * amount}(amount);\n\n        vm.stopPrank();\n    }\n}\n```\n\n### Recommendation\n\nAdd a validation in the `LPDAFactory.createLPDASale` function to ensure that the given duration and drop per second settings can't underflow the price.\n\n```solidity\nrequire((sale.endTime - sale.startTime) * sale.dropPerSecond <= sale.startPrice, \"MAX DROP IS GREATER THAN START PRICE\");\n```\n\n**[stevennevins (Escher) confirmed](https://github.com/code-423n4/2022-12-escher-findings/issues/392)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-12-escher-contest",
  "Code": [
    {
      "filename": "src/minters/LPDA.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract LPDA is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// we use different uints and some weird ordering to pack variables into 32 bytes\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint80 startPrice;\n        uint80 finalPrice;\n        uint80 dropPerSecond;\n        // slot 3\n        uint96 endTime;\n        address payable saleReceiver;\n        // slot 4\n        uint96 startTime;\n    }\n\n    struct Receipt {\n        uint48 amount;\n        uint80 balance;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n    uint48 public amountSold = 0;\n\n    /// @notice tracked the amount paid by people during the LPDA\n    mapping(address => Receipt) public receipts;\n\n    event Start(Sale _saleInfo);\n    event End(Sale _saleInfo);\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        uint48 x = type(uint48).max;\n        uint80 y = type(uint80).max;\n        uint96 z = type(uint96).max;\n        address payable i = payable(address(0));\n        sale = LPDA.Sale(x, x, i, y, y, y, z, i, z);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        uint48 amount = uint48(_amount);\n        Sale memory temp = sale;\n        IEscher721 nft = IEscher721(temp.edition);\n        require(block.timestamp >= temp.startTime, \"TOO SOON\");\n        uint256 price = getPrice();\n        require(msg.value >= amount * price, \"WRONG PRICE\");\n\n        amountSold += amount;\n        uint48 newId = amount + temp.currentId;\n        require(newId <= temp.finalId, \"TOO MANY\");\n\n        receipts[msg.sender].amount += amount;\n        receipts[msg.sender].balance += uint80(msg.value);\n\n        for (uint256 x = temp.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, amount, msg.value, temp);\n\n        if (newId == temp.finalId) {\n            sale.finalPrice = uint80(price);\n            uint256 totalSale = price * amountSold;\n            uint256 fee = totalSale / 20;\n            ISaleFactory(factory).feeReceiver().transfer(fee);\n            temp.saleReceiver.transfer(totalSale - fee);\n            _end();\n        }\n    }\n\n    /// @notice cancel a fixed price sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        sale.finalId = sale.currentId;\n        _end();\n    }\n\n    /// @notice allow a buyer to get a refund on the current price difference\n    function refund() public {\n        Receipt memory r = receipts[msg.sender];\n        uint80 price = uint80(getPrice()) * r.amount;\n        uint80 owed = r.balance - price;\n        require(owed > 0, \"NOTHING TO REFUND\");\n        receipts[msg.sender].balance = price;\n        payable(msg.sender).transfer(owed);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale calldata _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        Sale memory temp = sale;\n        (uint256 start, uint256 end) = (temp.startTime, temp.endTime);\n        if (block.timestamp < start) return type(uint256).max;\n        if (temp.currentId == temp.finalId) return temp.finalPrice;\n\n        uint256 timeElapsed = end > block.timestamp ? block.timestamp - start : end - start;\n        return temp.startPrice - (temp.dropPerSecond * timeElapsed);\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    /// @notice the number of NFTs still available\n    function available() public view returns (uint256) {\n        return sale.finalId - sale.currentId;\n    }\n\n    function lowestPrice() public view returns (uint256) {\n        return sale.startPrice - (sale.dropPerSecond * (sale.endTime - sale.startTime));\n    }\n\n    function _end() internal {\n        emit End(sale);\n    }\n}"
    }
  ]
}