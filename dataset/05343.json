{
  "Title": "[G-16] Using calldata instead of memory for read-only arguments in external functions saves gas",
  "Content": "When a function with a memory array is called externally, the abi.decode() step has to use a for-loop to copy each index of the calldata to the memory index. Each iteration of this for-loop costs at least 60 gas (i.e. 60 * <mem_array>.length). Using calldata directly, obliviates the need for such a loop in the contract code and runtime execution.\n\n## Please note these instances were not included in the bot report.\n\n### 13 Instances\n\n<details>\n\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/multisigs/GuardCM.sol#L390\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/multisigs/GuardCM.sol#L442\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/multisigs/GuardCM.sol#L443\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/multisigs/GuardCM.sol#L444\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/multisigs/GuardCM.sol#L445\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/multisigs/GuardCM.sol#L496\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/multisigs/GuardCM.sol#L497\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/multisigs/GuardCM.sol#L498\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/GenericRegistry.sol#L78\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/multisigs/GnosisSafeMultisig.sol#L92\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/multisigs/GnosisSafeMultisig.sol#L94\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Dispenser.sol#L89\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol%5D#L257\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-12-autonolas",
  "Code": [
    {
      "filename": "governance/contracts/multisigs/GuardCM.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport {Enum} from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\n\ninterface IGovernor {\n    function state(uint256 proposalId) external returns (ProposalState);\n}\n\n// Governor proposal state\nenum ProposalState {\n    Pending,\n    Active,\n    Canceled,\n    Defeated,\n    Succeeded,\n    Queued,\n    Expired,\n    Executed\n}\n\n/// @dev Only `owner` has a privilege, but the `sender` was provided.\n/// @param sender Sender address.\n/// @param owner Required sender address as an owner.\nerror OwnerOnly(address sender, address owner);\n\n/// @dev Only `manager` has a privilege, but the `sender` was provided.\n/// @param sender Sender address.\n/// @param manager Required sender address as an owner.\nerror ManagerOnly(address sender, address manager);\n\n/// @dev Provided zero address.\nerror ZeroAddress();\n\n/// @dev Provided zero value.\nerror ZeroValue();\n\n/// @dev Wrong length of two arrays.\n/// @param numValues1 Number of values in a first array.\n/// @param numValues2 Numberf of values in a second array.\n/// @param numValues3 Numberf of values in a third array.\n/// @param numValues4 Numberf of values in a fourth array.\nerror WrongArrayLength(uint256 numValues1, uint256 numValues2, uint256 numValues3, uint256 numValues4);\n\n/// @dev Provided bridged mediator is not unique.\n/// @param bridgeMediator Bridge mediator address.\nerror BridgeMediatorNotUnique(address bridgeMediator);\n\n/// @dev Provided incorrect data length.\n/// @param expected Expected minimum data length.\n/// @param provided Provided data length.\nerror IncorrectDataLength(uint256 expected, uint256 provided);\n\n/// @dev No delegatecall is allowed.\nerror NoDelegateCall();\n\n/// @dev No self multisig call is allowed.\nerror NoSelfCall();\n\n/// @dev The combination of target and selector is not authorized.\n/// @param target Target address.\n/// @param selector Function selector.\n/// @param chainId Chain Id.\nerror NotAuthorized(address target, bytes4 selector, uint256 chainId);\n\n/// @dev The proposal is not defeated.\n/// @param proposalId Proposal Id.\n/// @param state Current proposal state.\nerror NotDefeated(uint256 proposalId, ProposalState state);\n\n/// @dev Passed L2 chain Id is not supported.\n/// @param chainId L2 chain Id.\nerror L2ChainIdNotSupported(uint256 chainId);\n\n/// @dev Provided wrong function selector.\n/// @param functionSig Function selector.\n/// @param chainId Chain Id.\nerror WrongSelector(bytes4 functionSig, uint256 chainId);\n\n/// @dev Provided wrong L2 bridge mediator address.\n/// @param provided Provided address.\n/// @param expected Expected address.\nerror WrongL2BridgeMediator(address provided, address expected);\n\n/// @title GuardCM - Smart contract for Gnosis Safe community multisig (CM) guard\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\n/// @author Andrey Lebedev - <andrey.lebedev@valory.xyz>\ncontract GuardCM {\n    event GovernorUpdated(address indexed governor);\n    event SetTargetSelectors(address[] indexed targets, bytes4[] indexed selectors, uint256[] chainIds, bool[] statuses);\n    event SetBridgeMediators(address[] indexed bridgeMediatorL1s, address[] indexed bridgeMediatorL2s, uint256[] chainIds);\n    event GovernorCheckProposalIdChanged(uint256 indexed proposalId);\n    event GuardPaused(address indexed account);\n    event GuardUnpaused();\n\n    // schedule selector\n    bytes4 public constant SCHEDULE = bytes4(keccak256(bytes(\"schedule(address,uint256,bytes,bytes32,bytes32,uint256)\")));\n    // scheduleBatch selector\n    bytes4 public constant SCHEDULE_BATCH = bytes4(keccak256(bytes(\"scheduleBatch(address[],uint256[],bytes[],bytes32,bytes32,uint256)\")));\n    // requireToPassMessage selector (Gnosis chain)\n    bytes4 public constant REQUIRE_TO_PASS_MESSAGE = bytes4(keccak256(bytes(\"requireToPassMessage(address,bytes,uint256)\")));\n    // processMessageFromForeign selector (Gnosis chain)\n    bytes4 public constant PROCESS_MESSAGE_FROM_FOREIGN = bytes4(keccak256(bytes(\"processMessageFromForeign(bytes)\")));\n    // sendMessageToChild selector (Polygon)\n    bytes4 public constant SEND_MESSAGE_TO_CHILD = bytes4(keccak256(bytes(\"sendMessageToChild(address,bytes)\")));\n    // Initial check governance proposal Id\n    // Calculated from the proposalHash function of the GovernorOLAS\n    uint256 public governorCheckProposalId = 88250008686885504216650933897987879122244685460173810624866685274624741477673;\n    // Minimum data length that is encoded for the schedule function,\n    // plus at least 4 bytes or 32 bits for the selector from the payload\n    uint256 public constant MIN_SCHEDULE_DATA_LENGTH = 260;\n    // Minimum data length that contains at least a selector (4 bytes or 32 bits)\n    uint256 public constant SELECTOR_DATA_LENGTH = 4;\n    // Minimum payload length for message on Gnosis accounting for all required encoding and at least one selector\n    uint256 public constant MIN_GNOSIS_PAYLOAD_LENGTH = 292;\n    // Minimum payload length for message on Polygon accounting for all required encoding and at least one selector\n    uint256 public constant MIN_POLYGON_PAYLOAD_LENGTH = 164;\n\n    // Owner address\n    address public immutable owner;\n    // Multisig address\n    address public immutable multisig;\n\n    // Governor address\n    address public governor;\n    // Guard pausing possibility\n    uint8 public paused = 1;\n\n    // Mapping of (target address | bytes4 selector | uint64 chain Id) => enabled / disabled\n    mapping(uint256 => bool) public mapAllowedTargetSelectorChainIds;\n    // Mapping of bridge mediator address L1 => (bridge mediator L2 address | uint64 supported L2 chain Id)\n    mapping(address => uint256) public mapBridgeMediatorL1L2ChainIds;\n\n    /// @dev GuardCM constructor.\n    /// @param _timelock Timelock address.\n    /// @param _multisig Community multisig address.\n    /// @param _governor Governor address.\n    constructor(\n        address _timelock,\n        address _multisig,\n        address _governor\n    ) {\n        // Check for zero addresses\n        if (_timelock == address(0) || _multisig == address(0) || _governor == address(0)) {\n            revert ZeroAddress();\n        }\n        owner = _timelock;\n        multisig = _multisig;\n        governor = _governor;\n    }\n\n    /// @dev Changes the governor.\n    /// @param newGovernor Address of a new governor.\n    function changeGovernor(address newGovernor) external {\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Check for the zero address\n        if (newGovernor == address(0)) {\n            revert ZeroAddress();\n        }\n\n        governor = newGovernor;\n        emit GovernorUpdated(newGovernor);\n    }\n\n    /// @dev Changes the governor check proposal Id.\n    /// @param proposalId Governor check proposal Id.\n    function changeGovernorCheckProposalId(uint256 proposalId) external {\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Check for the zero value\n        if (proposalId == 0) {\n            revert ZeroValue();\n        }\n\n        governorCheckProposalId = proposalId;\n        emit GovernorCheckProposalIdChanged(proposalId);\n    }\n\n    /// @dev Verifies authorized combinations of target and selector.\n    /// @notice The bottom-most internal function is still not \"view\" since some reverts are not explicitly handled\n    /// @param target Target address.\n    /// @param data Payload bytes.\n    /// @param chainId Chain Id.\n    function _verifyData(address target, bytes memory data, uint256 chainId) internal {\n        // Push a pair of key defining variables into one key\n        // target occupies first 160 bits\n        uint256 targetSelectorChainId = uint256(uint160(target));\n        // selector occupies next 32 bits\n        targetSelectorChainId |= uint256(uint32(bytes4(data))) << 160;\n        // chainId occupies next 64 bits\n        targetSelectorChainId |= chainId << 192;\n\n        // Check the authorized combination of target and selector\n        if (!mapAllowedTargetSelectorChainIds[targetSelectorChainId]) {\n            revert NotAuthorized(target, bytes4(data), chainId);\n        }\n    }\n\n    /// @dev Verifies the bridged data for authorized combinations of targets and selectors.\n    /// @notice The processed data is packed as a set of bytes that are assembled using the following parameters:\n    ///         address target, uint96 value, uint32 payloadLength, bytes payload.\n    /// @param data Payload bytes.\n    /// @param chainId L2 chain Id.\n    function _verifyBridgedData(bytes memory data, uint256 chainId) internal {\n        // Unpack and process the data\n        // We need to skip first 12 bytes as those are zeros from encoding\n        for (uint256 i = 0; i < data.length;) {\n            address target;\n            uint32 payloadLength;\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                // First 20 bytes is the address (160 bits)\n                i := add(i, 20)\n                target := mload(add(data, i))\n                // Offset the data by 12 bytes of value (96 bits) and by 4 bytes of payload length (32 bits)\n                i := add(i, 16)\n                payloadLength := mload(add(data, i))\n            }\n\n            // Check for the zero address\n            if (target == address(0)) {\n                revert ZeroAddress();\n            }\n\n            // The payload length must be at least of the a function selector size\n            if (payloadLength < SELECTOR_DATA_LENGTH) {\n                revert IncorrectDataLength(payloadLength, SELECTOR_DATA_LENGTH);\n            }\n\n            // Get the payload\n            bytes memory payload = new bytes(payloadLength);\n            for (uint256 j = 0; j < payloadLength; ++j) {\n                payload[j] = data[i + j];\n            }\n            // Offset the data by the payload number of bytes\n            i += payloadLength;\n\n            // Verify the scope of the data\n            _verifyData(target, payload, chainId);\n        }\n    }\n\n    /// @dev Processes bridged data: checks the header and verifies the payload.\n    /// @param data Full data bytes with the header.\n    /// @param bridgeMediatorL2 Address of a bridged mediator on L2.\n    /// @param chainId L2 chain Id.\n    function _processBridgeData(\n        bytes memory data,\n        address bridgeMediatorL2,\n        uint256 chainId\n    ) internal\n    {\n        // Gnosis chains\n        if (chainId == 100 || chainId == 10200) {\n            // Check the L1 initial selector\n            bytes4 functionSig = bytes4(data);\n            if (functionSig != REQUIRE_TO_PASS_MESSAGE) {\n                revert WrongSelector(functionSig, chainId);\n            }\n\n            // Check if the data length is less than a size of a selector plus the message minimum payload size\n            if (data.length < MIN_GNOSIS_PAYLOAD_LENGTH) {\n                revert IncorrectDataLength(data.length, MIN_GNOSIS_PAYLOAD_LENGTH);\n            }\n\n            // Copy the data without the selector\n            bytes memory payload = new bytes(data.length - SELECTOR_DATA_LENGTH);\n            for (uint256 i = 0; i < payload.length; ++i) {\n                payload[i] = data[i + 4];\n            }\n\n            // Decode the requireToPassMessage payload: homeMediator (L2), mediatorPayload (need decoding), requestGasLimit\n            (address homeMediator, bytes memory mediatorPayload, ) = abi.decode(payload, (address, bytes, uint256));\n            // Check that the home mediator matches the L2 bridge mediator address\n            if (homeMediator != bridgeMediatorL2) {\n                revert WrongL2BridgeMediator(homeMediator, bridgeMediatorL2);\n            }\n\n            // Check the L2 initial selector\n            functionSig = bytes4(mediatorPayload);\n            if (functionSig != PROCESS_MESSAGE_FROM_FOREIGN) {\n                revert WrongSelector(functionSig, chainId);\n            }\n\n            // Copy the data without a selector\n            bytes memory bridgePayload = new bytes(mediatorPayload.length - SELECTOR_DATA_LENGTH);\n            for (uint256 i = 0; i < bridgePayload.length; ++i) {\n                bridgePayload[i] = mediatorPayload[i + SELECTOR_DATA_LENGTH];\n            }\n\n            // Decode the processMessageFromForeign payload: l2Message (executed on L2)\n            (bytes memory l2Message) = abi.decode(bridgePayload, (bytes));\n\n            // Verify processMessageFromForeign payload\n            _verifyBridgedData(l2Message, chainId);\n        }\n\n        // Polygon chains\n        if (chainId == 137 || chainId == 80001) {\n            // Check the L1 initial selector\n            bytes4 functionSig = bytes4(data);\n            if (functionSig != SEND_MESSAGE_TO_CHILD) {\n                revert WrongSelector(functionSig, chainId);\n            }\n\n            // Check if the data length is less than a size of a selector plus the message minimum payload size\n            if (data.length < MIN_POLYGON_PAYLOAD_LENGTH) {\n                revert IncorrectDataLength(data.length, MIN_POLYGON_PAYLOAD_LENGTH);\n            }\n\n            // Copy the data without the selector\n            bytes memory payload = new bytes(data.length - SELECTOR_DATA_LENGTH);\n            for (uint256 i = 0; i < payload.length; ++i) {\n                payload[i] = data[i + SELECTOR_DATA_LENGTH];\n            }\n\n            // Decode sendMessageToChild payload: fxGovernorTunnel (L2), l2Message (executed on L2)\n            (address fxGovernorTunnel, bytes memory l2Message) = abi.decode(payload, (address, bytes));\n            // Check that the fxGovernorTunnel matches the L2 bridge mediator address\n            if (fxGovernorTunnel != bridgeMediatorL2) {\n                revert WrongL2BridgeMediator(fxGovernorTunnel, bridgeMediatorL2);\n            }\n\n            // Verify sendMessageToChild payload\n            _verifyBridgedData(l2Message, chainId);\n        }\n    }\n\n    /// @dev Verifies authorized target and selector in the schedule or scheduleBatch function call.\n    /// @param data Data in bytes.\n    /// @param selector Schedule function selector.\n    function _verifySchedule(bytes memory data, bytes4 selector) internal {\n        // Copy the data without the selector\n        bytes memory payload = new bytes(data.length - SELECTOR_DATA_LENGTH);\n        for (uint256 i = 0; i < payload.length; ++i) {\n            payload[i] = data[i + 4];\n        }\n\n        // Prepare the decoding data sets\n        address[] memory targets;\n        bytes[] memory callDatas;\n        if (selector == SCHEDULE) {\n            targets = new address[](1);\n            callDatas = new bytes[](1);\n            // Decode the data in the schedule function\n            (targets[0], , callDatas[0], , , ) =\n                abi.decode(payload, (address, uint256, bytes, bytes32, bytes32, uint256));\n        } else {\n            // Decode the data in the scheduleBatch function\n            (targets, , callDatas, , , ) =\n            abi.decode(payload, (address[], uint256[], bytes[], bytes32, bytes32, uint256));\n        }\n\n        // Traverse all the schedule targets and selectors extracted from calldatas\n        for (uint i = 0; i < targets.length; ++i) {\n            // Get the bridgeMediatorL2 and L2 chain Id, if any\n            uint256 bridgeMediatorL2ChainId = mapBridgeMediatorL1L2ChainIds[targets[i]];\n            // bridgeMediatorL2 occupies first 160 bits\n            address bridgeMediatorL2 = address(uint160(bridgeMediatorL2ChainId));\n\n            // Check if the data goes across the bridge\n            if (bridgeMediatorL2 != address(0)) {\n                // Get the chain Id\n                // L2 chain Id occupies next 64 bits\n                uint256 chainId = bridgeMediatorL2ChainId >> 160;\n\n                // Process the bridge logic\n                _processBridgeData(callDatas[i], bridgeMediatorL2, chainId);\n            } else {\n                // Verify the data right away as it is not the bridged one\n                _verifyData(targets[i], callDatas[i], block.chainid);\n            }\n        }\n    }\n\n    /// @dev Checks the transaction for authorized arguments.\n    /// @notice Scheduling in timelock is checked against authorized targets and signatures.\n    /// @notice No self-multisig function calls are allowed.\n    /// @param to Destination address of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    function checkTransaction(\n        address to,\n        uint256,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256,\n        uint256,\n        uint256,\n        address,\n        address payable,\n        bytes memory,\n        address\n    ) external {\n        // Just return if paused\n        if (paused == 1) {\n            // Call to the timelock\n            if (to == owner) {\n                // No delegatecall is allowed\n                if (operation == Enum.Operation.DelegateCall) {\n                    revert NoDelegateCall();\n                }\n\n                // Data needs to have enough bytes at least to fit the selector\n                if (data.length < SELECTOR_DATA_LENGTH) {\n                    revert IncorrectDataLength(data.length, SELECTOR_DATA_LENGTH);\n                }\n\n                // Get the function signature\n                bytes4 functionSig = bytes4(data);\n                // Check the schedule or scheduleBatch function authorized parameters\n                // All other functions are not checked for\n                if (functionSig == SCHEDULE || functionSig == SCHEDULE_BATCH) {\n                    // Data length is too short: need to have enough bytes for the schedule() function\n                    // with one selector extracted from the payload\n                    if (data.length < MIN_SCHEDULE_DATA_LENGTH) {\n                        revert IncorrectDataLength(data.length, MIN_SCHEDULE_DATA_LENGTH);\n                    }\n\n                    _verifySchedule(data, functionSig);\n                }\n            } else if (to == multisig) {\n                // No self multisig call is allowed\n                revert NoSelfCall();\n            }\n        }\n    }\n\n    /// @dev Authorizes combinations of targets, selectors and chain Ids.\n    /// @notice It is the contract owner responsibility to set correct L1 chain Ids where the contract is deployed\n    ///         and corresponding supported L2-s, if the contract interacts with them.\n    /// @param targets Array of target addresses.\n    /// @param selectors Array of selectors for targets.\n    /// @param chainIds Chain Ids for authorized functions.\n    /// @param statuses Authorize if true, and restrict otherwise.\n    function setTargetSelectorChainIds(\n        address[] memory targets,\n        bytes4[] memory selectors,\n        uint256[] memory chainIds,\n        bool[] memory statuses\n    ) external {\n        // Check for the ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n        \n        // Check array length\n        if (targets.length != selectors.length || targets.length != statuses.length || targets.length != chainIds.length) {\n            revert WrongArrayLength(targets.length, selectors.length, statuses.length, chainIds.length);\n        }\n\n        // Traverse all the targets and selectors to build their paired values\n        for (uint256 i = 0; i < targets.length; ++i) {\n            // Check for zero address targets\n            if (targets[i] == address(0)) {\n                revert ZeroAddress();\n            }\n\n            // Check selector for zero selector value\n            if (selectors[i] == bytes4(0)) {\n                revert ZeroValue();\n            }\n\n            // Check chain Ids to be greater than zero\n            if (chainIds[i] == 0) {\n                revert ZeroValue();\n            }\n\n            // Push a pair of key defining variables into one key\n            // target occupies first 160 bits\n            uint256 targetSelectorChainId = uint256(uint160(targets[i]));\n            // selector occupies next 32 bits\n            targetSelectorChainId |= uint256(uint32(selectors[i])) << 160;\n            // chainId occupies next 64 bits\n            targetSelectorChainId |= chainIds[i] << 192;\n\n            // Set the status of the target and selector combination\n            mapAllowedTargetSelectorChainIds[targetSelectorChainId] = statuses[i];\n        }\n\n        emit SetTargetSelectors(targets, selectors, chainIds, statuses);\n    }\n\n    /// @dev Sets bridge mediator contracts addresses and L2 chain Ids.\n    /// @notice It is the contract owner responsibility to set correct L1 bridge mediator contracts,\n    ///         corresponding L2 bridge mediator contracts, and supported chain Ids.\n    /// @param bridgeMediatorL1s Bridge mediator contract addresses on L1.\n    /// @param bridgeMediatorL2s Corresponding bridge mediator contract addresses on L2.\n    /// @param chainIds Corresponding L2 chain Ids.\n    function setBridgeMediatorChainIds(\n        address[] memory bridgeMediatorL1s,\n        address[] memory bridgeMediatorL2s,\n        uint256[] memory chainIds\n    ) external {\n        // Check for the ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Check for array correctness\n        if (bridgeMediatorL1s.length != bridgeMediatorL2s.length || bridgeMediatorL1s.length != chainIds.length) {\n            revert WrongArrayLength(bridgeMediatorL1s.length, bridgeMediatorL2s.length, chainIds.length, chainIds.length);\n        }\n\n        // Link L1 and L2 bridge mediators, set L2 chain Ids\n        for (uint256 i = 0; i < chainIds.length; ++i) {\n            // Check for zero addresses\n            if (bridgeMediatorL1s[i] == address(0) || bridgeMediatorL2s[i] == address(0)) {\n                revert ZeroAddress();\n            }\n\n            // Check supported chain Ids on L2\n            uint256 chainId = chainIds[i];\n            if (chainId != 100 && chainId != 137 && chainId != 10200 && chainId != 80001) {\n                revert L2ChainIdNotSupported(chainId);\n            }\n\n            // Push a pair of key defining variables into one key\n            // bridgeMediatorL2 occupies first 160 bits\n            uint256 bridgeMediatorL2ChainId = uint256(uint160(bridgeMediatorL2s[i]));\n            // L2 chain Id occupies next 64 bits\n            bridgeMediatorL2ChainId |= chainId << 160;\n            mapBridgeMediatorL1L2ChainIds[bridgeMediatorL1s[i]] = bridgeMediatorL2ChainId;\n        }\n\n        emit SetBridgeMediators(bridgeMediatorL1s, bridgeMediatorL2s, chainIds);\n    }\n\n    /// @dev Pauses the guard restoring a full CM functionality.\n    /// @notice The timeline is able to pause the guard via the voting.\n    /// @notice The CM can request pausing the guard is there was a proposal to check if the governance is alive.\n    ///         If the proposal is defeated (not enough votes or never voted on),\n    ///         the governance is considered inactive for about a week.\n    function pause() external {\n        if (msg.sender == owner) {\n            // Timelock can release the community multisig right away\n            paused = 2;\n        } else if (msg.sender == multisig) {\n            // Multisig needs to check if the governor check proposal Id state is defeated\n            ProposalState state = IGovernor(governor).state(governorCheckProposalId);\n            if (state == ProposalState.Defeated) {\n                paused = 2;\n            } else {\n                revert NotDefeated(governorCheckProposalId, state);\n            }\n        } else {\n            // msg.sender is not a timelock, nor a multisig\n            revert ManagerOnly(msg.sender, multisig);\n        }\n\n        emit GuardPaused(msg.sender);\n    }\n\n    /// @dev Unpauses the guard restricting the CM functionality back.\n    function unpause() external {\n        // Check for the ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        paused = 1;\n\n        emit GuardUnpaused();\n    }\n\n    /// @dev Guards the multisig call after its execution.\n    function checkAfterExecution(bytes32, bool) external {}\n\n    /// @dev Gets the status of a target-selector-chainId combination.\n    /// @param target Target address.\n    /// @param selector Selector for a target.\n    /// @param chainId Corresponding chain Id.\n    /// @return status True, if the target-selector-chainId combination is authorized.\n    function getTargetSelectorChainId(address target, bytes4 selector, uint256 chainId) external view\n        returns (bool status)\n    {\n        // Push a pair of key defining variables into one key\n        // target occupies first 160 bits\n        uint256 targetSelectorChainId = uint256(uint160(target));\n        // selector occupies next 32 bits\n        targetSelectorChainId |= uint256(uint32(selector)) << 160;\n        // chainId occupies next 64 bits\n        targetSelectorChainId |= chainId << 192;\n\n        status = mapAllowedTargetSelectorChainIds[targetSelectorChainId];\n    }\n\n    /// @dev Gets the address of a bridge mediator contract address on L2 and corresponding L2 chain Id.\n    /// @param bridgeMediatorL1 Bridge mediator contract addresses on L1.\n    /// @return bridgeMediatorL2 Corresponding bridge mediator contract addresses on L2.\n    /// @return chainId Corresponding L2 chain Ids.\n    function getBridgeMediatorChainId(address bridgeMediatorL1) external view\n        returns (address bridgeMediatorL2, uint256 chainId)\n    {\n        // Get the bridgeMediatorL2 and L2 chain Id\n        uint256 bridgeMediatorL2ChainId = mapBridgeMediatorL1L2ChainIds[bridgeMediatorL1];\n        // bridgeMediatorL2 occupies first 160 bits\n        bridgeMediatorL2 = address(uint160(bridgeMediatorL2ChainId));\n        // L2 chain Id occupies next 64 bits\n        chainId = bridgeMediatorL2ChainId >> 160;\n    }\n}"
    },
    {
      "filename": "governance/contracts/multisigs/GuardCM.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport {Enum} from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\n\ninterface IGovernor {\n    function state(uint256 proposalId) external returns (ProposalState);\n}\n\n// Governor proposal state\nenum ProposalState {\n    Pending,\n    Active,\n    Canceled,\n    Defeated,\n    Succeeded,\n    Queued,\n    Expired,\n    Executed\n}\n\n/// @dev Only `owner` has a privilege, but the `sender` was provided.\n/// @param sender Sender address.\n/// @param owner Required sender address as an owner.\nerror OwnerOnly(address sender, address owner);\n\n/// @dev Only `manager` has a privilege, but the `sender` was provided.\n/// @param sender Sender address.\n/// @param manager Required sender address as an owner.\nerror ManagerOnly(address sender, address manager);\n\n/// @dev Provided zero address.\nerror ZeroAddress();\n\n/// @dev Provided zero value.\nerror ZeroValue();\n\n/// @dev Wrong length of two arrays.\n/// @param numValues1 Number of values in a first array.\n/// @param numValues2 Numberf of values in a second array.\n/// @param numValues3 Numberf of values in a third array.\n/// @param numValues4 Numberf of values in a fourth array.\nerror WrongArrayLength(uint256 numValues1, uint256 numValues2, uint256 numValues3, uint256 numValues4);\n\n/// @dev Provided bridged mediator is not unique.\n/// @param bridgeMediator Bridge mediator address.\nerror BridgeMediatorNotUnique(address bridgeMediator);\n\n/// @dev Provided incorrect data length.\n/// @param expected Expected minimum data length.\n/// @param provided Provided data length.\nerror IncorrectDataLength(uint256 expected, uint256 provided);\n\n/// @dev No delegatecall is allowed.\nerror NoDelegateCall();\n\n/// @dev No self multisig call is allowed.\nerror NoSelfCall();\n\n/// @dev The combination of target and selector is not authorized.\n/// @param target Target address.\n/// @param selector Function selector.\n/// @param chainId Chain Id.\nerror NotAuthorized(address target, bytes4 selector, uint256 chainId);\n\n/// @dev The proposal is not defeated.\n/// @param proposalId Proposal Id.\n/// @param state Current proposal state.\nerror NotDefeated(uint256 proposalId, ProposalState state);\n\n/// @dev Passed L2 chain Id is not supported.\n/// @param chainId L2 chain Id.\nerror L2ChainIdNotSupported(uint256 chainId);\n\n/// @dev Provided wrong function selector.\n/// @param functionSig Function selector.\n/// @param chainId Chain Id.\nerror WrongSelector(bytes4 functionSig, uint256 chainId);\n\n/// @dev Provided wrong L2 bridge mediator address.\n/// @param provided Provided address.\n/// @param expected Expected address.\nerror WrongL2BridgeMediator(address provided, address expected);\n\n/// @title GuardCM - Smart contract for Gnosis Safe community multisig (CM) guard\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\n/// @author Andrey Lebedev - <andrey.lebedev@valory.xyz>\ncontract GuardCM {\n    event GovernorUpdated(address indexed governor);\n    event SetTargetSelectors(address[] indexed targets, bytes4[] indexed selectors, uint256[] chainIds, bool[] statuses);\n    event SetBridgeMediators(address[] indexed bridgeMediatorL1s, address[] indexed bridgeMediatorL2s, uint256[] chainIds);\n    event GovernorCheckProposalIdChanged(uint256 indexed proposalId);\n    event GuardPaused(address indexed account);\n    event GuardUnpaused();\n\n    // schedule selector\n    bytes4 public constant SCHEDULE = bytes4(keccak256(bytes(\"schedule(address,uint256,bytes,bytes32,bytes32,uint256)\")));\n    // scheduleBatch selector\n    bytes4 public constant SCHEDULE_BATCH = bytes4(keccak256(bytes(\"scheduleBatch(address[],uint256[],bytes[],bytes32,bytes32,uint256)\")));\n    // requireToPassMessage selector (Gnosis chain)\n    bytes4 public constant REQUIRE_TO_PASS_MESSAGE = bytes4(keccak256(bytes(\"requireToPassMessage(address,bytes,uint256)\")));\n    // processMessageFromForeign selector (Gnosis chain)\n    bytes4 public constant PROCESS_MESSAGE_FROM_FOREIGN = bytes4(keccak256(bytes(\"processMessageFromForeign(bytes)\")));\n    // sendMessageToChild selector (Polygon)\n    bytes4 public constant SEND_MESSAGE_TO_CHILD = bytes4(keccak256(bytes(\"sendMessageToChild(address,bytes)\")));\n    // Initial check governance proposal Id\n    // Calculated from the proposalHash function of the GovernorOLAS\n    uint256 public governorCheckProposalId = 88250008686885504216650933897987879122244685460173810624866685274624741477673;\n    // Minimum data length that is encoded for the schedule function,\n    // plus at least 4 bytes or 32 bits for the selector from the payload\n    uint256 public constant MIN_SCHEDULE_DATA_LENGTH = 260;\n    // Minimum data length that contains at least a selector (4 bytes or 32 bits)\n    uint256 public constant SELECTOR_DATA_LENGTH = 4;\n    // Minimum payload length for message on Gnosis accounting for all required encoding and at least one selector\n    uint256 public constant MIN_GNOSIS_PAYLOAD_LENGTH = 292;\n    // Minimum payload length for message on Polygon accounting for all required encoding and at least one selector\n    uint256 public constant MIN_POLYGON_PAYLOAD_LENGTH = 164;\n\n    // Owner address\n    address public immutable owner;\n    // Multisig address\n    address public immutable multisig;\n\n    // Governor address\n    address public governor;\n    // Guard pausing possibility\n    uint8 public paused = 1;\n\n    // Mapping of (target address | bytes4 selector | uint64 chain Id) => enabled / disabled\n    mapping(uint256 => bool) public mapAllowedTargetSelectorChainIds;\n    // Mapping of bridge mediator address L1 => (bridge mediator L2 address | uint64 supported L2 chain Id)\n    mapping(address => uint256) public mapBridgeMediatorL1L2ChainIds;\n\n    /// @dev GuardCM constructor.\n    /// @param _timelock Timelock address.\n    /// @param _multisig Community multisig address.\n    /// @param _governor Governor address.\n    constructor(\n        address _timelock,\n        address _multisig,\n        address _governor\n    ) {\n        // Check for zero addresses\n        if (_timelock == address(0) || _multisig == address(0) || _governor == address(0)) {\n            revert ZeroAddress();\n        }\n        owner = _timelock;\n        multisig = _multisig;\n        governor = _governor;\n    }\n\n    /// @dev Changes the governor.\n    /// @param newGovernor Address of a new governor.\n    function changeGovernor(address newGovernor) external {\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Check for the zero address\n        if (newGovernor == address(0)) {\n            revert ZeroAddress();\n        }\n\n        governor = newGovernor;\n        emit GovernorUpdated(newGovernor);\n    }\n\n    /// @dev Changes the governor check proposal Id.\n    ///"
    }
  ]
}