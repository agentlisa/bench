{
  "Title": "Non-accessible function of GMX is used",
  "Content": "**Severity:** High\n\n**Context:** [`Helper.sol#L84-89`](https://github.com/getmetafinance/meta/blob/00bbac1613fa69e4c180ff53515451df4df9f69e/contracts/musd/Helper.sol#L84-89)\n\n**Description:**\n`Helper::harvest` calls a GMX router’s `compoundForAccount` function but according to GMX code it’s only callable by governer.\n\n```solidity\nfunction harvest(address _account) external returns (uint256) {\nrouter.compoundForAccount(_account);\ngmxRewards.claimForAccount(_account, _account);\nglpRewards.claimForAccount(_account, _account);\nreturn native.balanceOf(_account);\n}\n```\n\nThe relevant part on [GMX Router](https://github.com/gmx-io/gmx-contracts/blob/e772060cc46d94fc2679445343f40c65290dede3/contracts/staking/RewardRouterV2.sol#L217 \"smartCard-inline\") is implemented as below.\n\n```solidity\nfunction compoundForAccount(address _account) external nonReentrant onlyGov {\n_compound(_account);\n}\n```\n\n**Impact**\nIt is impossible to claim the rewards from the GMX protocol.\n\n**Recommendation:**\nReimplement the harvest mechanism using the correct function of GMX.\n\n**Meta Team:**\n\nFixed in the latest commit. Harvest function can only be called by the address holding the GLP tokesn. Hence the code has been moved to mUSDManager.sol.\n\n```diff\n\n(commit: 007c1b9183cdb65a500928173608ebff0a5197ef)\n\n+    interface IGLPRewardsRouter {\n+        function claimFees() external;\n+    }\n\n+    IGLPRewardsRouter public router;\n\n\n+    function harvest() public {\n+        router.claimFees();\n+    }\n\n```\n\n**Hans:**\nVerified.",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/staking/RewardRouterV2.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/token/SafeERC20.sol\";\nimport \"../libraries/utils/ReentrancyGuard.sol\";\nimport \"../libraries/utils/Address.sol\";\n\nimport \"./interfaces/IRewardTracker.sol\";\nimport \"./interfaces/IRewardRouterV2.sol\";\nimport \"./interfaces/IVester.sol\";\nimport \"../tokens/interfaces/IMintable.sol\";\nimport \"../tokens/interfaces/IWETH.sol\";\nimport \"../core/interfaces/IGlpManager.sol\";\nimport \"../access/Governable.sol\";\n\ncontract RewardRouterV2 is IRewardRouterV2, ReentrancyGuard, Governable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    bool public isInitialized;\n\n    address public weth;\n\n    address public gmx;\n    address public esGmx;\n    address public bnGmx;\n\n    address public glp; // GMX Liquidity Provider token\n\n    address public stakedGmxTracker;\n    address public bonusGmxTracker;\n    address public feeGmxTracker;\n\n    address public override stakedGlpTracker;\n    address public override feeGlpTracker;\n\n    address public glpManager;\n\n    address public gmxVester;\n    address public glpVester;\n\n    mapping (address => address) public pendingReceivers;\n\n    event StakeGmx(address account, address token, uint256 amount);\n    event UnstakeGmx(address account, address token, uint256 amount);\n\n    event StakeGlp(address account, uint256 amount);\n    event UnstakeGlp(address account, uint256 amount);\n\n    receive() external payable {\n        require(msg.sender == weth, \"Router: invalid sender\");\n    }\n\n    function initialize(\n        address _weth,\n        address _gmx,\n        address _esGmx,\n        address _bnGmx,\n        address _glp,\n        address _stakedGmxTracker,\n        address _bonusGmxTracker,\n        address _feeGmxTracker,\n        address _feeGlpTracker,\n        address _stakedGlpTracker,\n        address _glpManager,\n        address _gmxVester,\n        address _glpVester\n    ) external onlyGov {\n        require(!isInitialized, \"RewardRouter: already initialized\");\n        isInitialized = true;\n\n        weth = _weth;\n\n        gmx = _gmx;\n        esGmx = _esGmx;\n        bnGmx = _bnGmx;\n\n        glp = _glp;\n\n        stakedGmxTracker = _stakedGmxTracker;\n        bonusGmxTracker = _bonusGmxTracker;\n        feeGmxTracker = _feeGmxTracker;\n\n        feeGlpTracker = _feeGlpTracker;\n        stakedGlpTracker = _stakedGlpTracker;\n\n        glpManager = _glpManager;\n\n        gmxVester = _gmxVester;\n        glpVester = _glpVester;\n    }\n\n    // to help users who accidentally send their tokens to this contract\n    function withdrawToken(address _token, address _account, uint256 _amount) external onlyGov {\n        IERC20(_token).safeTransfer(_account, _amount);\n    }\n\n    function batchStakeGmxForAccount(address[] memory _accounts, uint256[] memory _amounts) external nonReentrant onlyGov {\n        address _gmx = gmx;\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _stakeGmx(msg.sender, _accounts[i], _gmx, _amounts[i]);\n        }\n    }\n\n    function stakeGmxForAccount(address _account, uint256 _amount) external nonReentrant onlyGov {\n        _stakeGmx(msg.sender, _account, gmx, _amount);\n    }\n\n    function stakeGmx(uint256 _amount) external nonReentrant {\n        _stakeGmx(msg.sender, msg.sender, gmx, _amount);\n    }\n\n    function stakeEsGmx(uint256 _amount) external nonReentrant {\n        _stakeGmx(msg.sender, msg.sender, esGmx, _amount);\n    }\n\n    function unstakeGmx(uint256 _amount) external nonReentrant {\n        _unstakeGmx(msg.sender, gmx, _amount, true);\n    }\n\n    function unstakeEsGmx(uint256 _amount) external nonReentrant {\n        _unstakeGmx(msg.sender, esGmx, _amount, true);\n    }\n\n    function mintAndStakeGlp(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minGlp) external nonReentrant returns (uint256) {\n        require(_amount > 0, \"RewardRouter: invalid _amount\");\n\n        address account = msg.sender;\n        uint256 glpAmount = IGlpManager(glpManager).addLiquidityForAccount(account, account, _token, _amount, _minUsdg, _minGlp);\n        IRewardTracker(feeGlpTracker).stakeForAccount(account, account, glp, glpAmount);\n        IRewardTracker(stakedGlpTracker).stakeForAccount(account, account, feeGlpTracker, glpAmount);\n\n        emit StakeGlp(account, glpAmount);\n\n        return glpAmount;\n    }\n\n    function mintAndStakeGlpETH(uint256 _minUsdg, uint256 _minGlp) external payable nonReentrant returns (uint256) {\n        require(msg.value > 0, \"RewardRouter: invalid msg.value\");\n\n        IWETH(weth).deposit{value: msg.value}();\n        IERC20(weth).approve(glpManager, msg.value);\n\n        address account = msg.sender;\n        uint256 glpAmount = IGlpManager(glpManager).addLiquidityForAccount(address(this), account, weth, msg.value, _minUsdg, _minGlp);\n\n        IRewardTracker(feeGlpTracker).stakeForAccount(account, account, glp, glpAmount);\n        IRewardTracker(stakedGlpTracker).stakeForAccount(account, account, feeGlpTracker, glpAmount);\n\n        emit StakeGlp(account, glpAmount);\n\n        return glpAmount;\n    }\n\n    function unstakeAndRedeemGlp(address _tokenOut, uint256 _glpAmount, uint256 _minOut, address _receiver) external nonReentrant returns (uint256) {\n        require(_glpAmount > 0, \"RewardRouter: invalid _glpAmount\");\n\n        address account = msg.sender;\n        IRewardTracker(stakedGlpTracker).unstakeForAccount(account, feeGlpTracker, _glpAmount, account);\n        IRewardTracker(feeGlpTracker).unstakeForAccount(account, glp, _glpAmount, account);\n        uint256 amountOut = IGlpManager(glpManager).removeLiquidityForAccount(account, _tokenOut, _glpAmount, _minOut, _receiver);\n\n        emit UnstakeGlp(account, _glpAmount);\n\n        return amountOut;\n    }\n\n    function unstakeAndRedeemGlpETH(uint256 _glpAmount, uint256 _minOut, address payable _receiver) external nonReentrant returns (uint256) {\n        require(_glpAmount > 0, \"RewardRouter: invalid _glpAmount\");\n\n        address account = msg.sender;\n        IRewardTracker(stakedGlpTracker).unstakeForAccount(account, feeGlpTracker, _glpAmount, account);\n        IRewardTracker(feeGlpTracker).unstakeForAccount(account, glp, _glpAmount, account);\n        uint256 amountOut = IGlpManager(glpManager).removeLiquidityForAccount(account, weth, _glpAmount, _minOut, address(this));\n\n        IWETH(weth).withdraw(amountOut);\n\n        _receiver.sendValue(amountOut);\n\n        emit UnstakeGlp(account, _glpAmount);\n\n        return amountOut;\n    }\n\n    function claim() external nonReentrant {\n        address account = msg.sender;\n\n        IRewardTracker(feeGmxTracker).claimForAccount(account, account);\n        IRewardTracker(feeGlpTracker).claimForAccount(account, account);\n\n        IRewardTracker(stakedGmxTracker).claimForAccount(account, account);\n        IRewardTracker(stakedGlpTracker).claimForAccount(account, account);\n    }\n\n    function claimEsGmx() external nonReentrant {\n        address account = msg.sender;\n\n        IRewardTracker(stakedGmxTracker).claimForAccount(account, account);\n        IRewardTracker(stakedGlpTracker).claimForAccount(account, account);\n    }\n\n    function claimFees() external nonReentrant {\n        address account = msg.sender;\n\n        IRewardTracker(feeGmxTracker).claimForAccount(account, account);\n        IRewardTracker(feeGlpTracker).claimForAccount(account, account);\n    }\n\n    function compound() external nonReentrant {\n        _compound(msg.sender);\n    }\n\n    function compoundForAccount(address _account) external nonReentrant onlyGov {\n        _compound(_account);\n    }\n\n    function handleRewards(\n        bool _shouldClaimGmx,\n        bool _shouldStakeGmx,\n        bool _shouldClaimEsGmx,\n        bool _shouldStakeEsGmx,\n        bool _shouldStakeMultiplierPoints,\n        bool _shouldClaimWeth,\n        bool _shouldConvertWethToEth\n    ) external nonReentrant {\n        address account = msg.sender;\n\n        uint256 gmxAmount = 0;\n        if (_shouldClaimGmx) {\n            uint256 gmxAmount0 = IVester(gmxVester).claimForAccount(account, account);\n            uint256 gmxAmount1 = IVester(glpVester).claimForAccount(account, account);\n            gmxAmount = gmxAmount0.add(gmxAmount1);\n        }\n\n        if (_shouldStakeGmx && gmxAmount > 0) {\n            _stakeGmx(account, account, gmx, gmxAmount);\n        }\n\n        uint256 esGmxAmount = 0;\n        if (_shouldClaimEsGmx) {\n            uint256 esGmxAmount0 = IRewardTracker(stakedGmxTracker).claimForAccount(account, account);\n            uint256 esGmxAmount1 = IRewardTracker(stakedGlpTracker).claimForAccount(account, account);\n            esGmxAmount = esGmxAmount0.add(esGmxAmount1);\n        }\n\n        if (_shouldStakeEsGmx && esGmxAmount > 0) {\n            _stakeGmx(account, account, esGmx, esGmxAmount);\n        }\n\n        if (_shouldStakeMultiplierPoints) {\n            uint256 bnGmxAmount = IRewardTracker(bonusGmxTracker).claimForAccount(account, account);\n            if (bnGmxAmount > 0) {\n                IRewardTracker(feeGmxTracker).stakeForAccount(account, account, bnGmx, bnGmxAmount);\n            }\n        }\n\n        if (_shouldClaimWeth) {\n            if (_shouldConvertWethToEth) {\n                uint256 weth0 = IRewardTracker(feeGmxTracker).claimForAccount(account, address(this));\n                uint256 weth1 = IRewardTracker(feeGlpTracker).claimForAccount(account, address(this));\n\n                uint256 wethAmount = weth0.add(weth1);\n                IWETH(weth).withdraw(wethAmount);\n\n                payable(account).sendValue(wethAmount);\n            } else {\n                IRewardTracker(feeGmxTracker).claimForAccount(account, account);\n                IRewardTracker(feeGlpTracker).claimForAccount(account, account);\n            }\n        }\n    }\n\n    function batchCompoundForAccounts(address[] memory _accounts) external nonReentrant onlyGov {\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _compound(_accounts[i]);\n        }\n    }\n\n    // the _validateReceiver function checks that the averageStakedAmounts and cumulativeRewards\n    // values of an account are zero, this is to help ensure that vesting calculations can be\n    // done correctly\n    // averageStakedAmounts and cumulativeRewards are updated if the claimable reward for an account\n    // is more than zero\n    // it is possible for multiple transfers to be sent into a single account, using signalTransfer and\n    // acceptTransfer, if those values have not been updated yet\n    // for GLP transfers it is also possible to transfer GLP into an account using the StakedGlp contract\n    function signalTransfer(address _receiver) external nonReentrant {\n        require(IERC20(gmxVester).balanceOf(msg.sender) == 0, \"RewardRouter: sender has vested tokens\");\n        require(IERC20(glpVester).balanceOf(msg.sender) == 0, \"RewardRouter: sender has vested tokens\");\n\n        _validateReceiver(_receiver);\n        pendingReceivers[msg.sender] = _receiver;\n    }\n\n    function acceptTransfer(address _sender) external nonReentrant {\n        require(IERC20(gmxVester).balanceOf(_sender) == 0, \"RewardRouter: sender has vested tokens\");\n        require(IERC20(glpVester).balanceOf(_sender) == 0, \"RewardRouter: sender has vested tokens\");\n\n        address receiver = msg.sender;\n        require(pendingReceivers[_sender] == receiver, \"RewardRouter: transfer not signalled\");\n        delete pendingReceivers[_sender];\n\n        _validateReceiver(receiver);\n        _compound(_sender);\n\n        uint256 stakedGmx = IRewardTracker(stakedGmxTracker).depositBalances(_sender, gmx);\n        if (stakedGmx > 0) {\n            _unstakeGmx(_sender, gmx, stakedGmx, false);\n            _stakeGmx(_sender, receiver, gmx, stakedGmx);\n        }\n\n        uint256 stakedEsGmx = IRewardTracker(stakedGmxTracker).depositBalances(_sender, esGmx);\n        if (stakedEsGmx > 0) {\n            _unstakeGmx(_sender, esGmx, stakedEsGmx, false);\n            _stakeGmx(_sender, receiver, esGmx, stakedEsGmx);\n        }\n\n        uint256 stakedBnGmx = IRewardTracker(feeGmxTracker).depositBalances(_sender, bnGmx);\n        if (stakedBnGmx > 0) {\n            IRewardTracker(feeGmxTracker).unstakeForAccount(_sender, bnGmx, stakedBnGmx, _sender);\n            IRewardTracker(feeGmxTracker).stakeForAccount(_sender, receiver, bnGmx, stakedBnGmx);\n        }\n\n        uint256 esGmxBalance = IERC20(esGmx).balanceOf(_sender);\n        if (esGmxBalance > 0) {\n            IERC20(esGmx).transferFrom(_sender, receiver, esGmxBalance);\n        }\n\n        uint256 glpAmount = IRewardTracker(feeGlpTracker).depositBalances(_sender, glp);\n        if (glpAmount > 0) {\n            IRewardTracker(stakedGlpTracker).unstakeForAccount(_sender, feeGlpTracker, glpAmount, _sender);\n            IRewardTracker(feeGlpTracker).unstakeForAccount(_sender, glp, glpAmount, _sender);\n\n            IRewardTracker(feeGlpTracker).stakeForAccount(_sender, receiver, glp, glpAmount);\n            IRewardTracker(stakedGlpTracker).stakeForAccount(receiver, receiver, feeGlpTracker, glpAmount);\n        }\n\n        IVester(gmxVester).transferStakeValues(_sender, receiver);\n        IVester(glpVester).transferStakeValues(_sender, receiver);\n    }\n\n    function _validateReceiver(address _receiver) private view {\n        require(IRewardTracker(stakedGmxTracker).averageStakedAmounts(_receiver) == 0, \"RewardRouter: stakedGmxTracker.averageStakedAmounts > 0\");\n        require(IRewardTracker(stakedGmxTracker).cumulativeRewards(_receiver) == 0, \"RewardRouter: stakedGmxTracker.cumulativeRewards > 0\");\n\n        require(IRewardTracker(bonusGmxTracker).averageStakedAmounts(_receiver) == 0, \"RewardRouter: bonusGmxTracker.averageStakedAmounts > 0\");\n        require(IRewardTracker(bonusGmxTracker).cumulativeRewards(_receiver) == 0, \"RewardRouter: bonusGmxTracker.cumulativeRewards > 0\");\n\n        require(IRewardTracker(feeGmxTracker).averageStakedAmounts(_receiver) == 0, \"RewardRouter: feeGmxTracker.averageStakedAmounts > 0\");\n        require(IRewardTracker(feeGmxTracker).cumulativeRewards(_receiver) == 0, \"RewardRouter: feeGmxTracker.cumulativeRewards > 0\");\n\n        require(IVester(gmxVester).transferredAverageStakedAmounts(_receiver) == 0, \"RewardRouter: gmxVester.transferredAverageStakedAmounts > 0\");\n        require(IVester(gmxVester).transferredCumulativeRewards(_receiver) == 0, \"RewardRouter: gmxVester.transferredCumulativeRewards > 0\");\n\n        require(IRewardTracker(stakedGlpTracker).averageStakedAmounts(_receiver) == 0, \"RewardRouter: stakedGlpTracker.averageStakedAmounts > 0\");\n        require(IRewardTracker(stakedGlpTracker).cumulativeRewards(_receiver) == 0, \"RewardRouter: stakedGlpTracker.cumulativeRewards > 0\");\n\n        require(IRewardTracker(feeGlpTracker).averageStakedAmounts(_receiver) == 0, \"RewardRouter: feeGlpTracker.averageStakedAmounts > 0\");\n        require(IRewardTracker(feeGlpTracker).cumulativeRewards(_receiver) == 0, \"RewardRouter: feeGlpTracker.cumulativeRewards > 0\");\n\n        require(IVester(glpVester).transferredAverageStakedAmounts(_receiver) == 0, \"RewardRouter: gmxVester.transferredAverageStakedAmounts > 0\");\n        require(IVester(glpVester).transferredCumulativeRewards(_receiver) == 0, \"RewardRouter: gmxVester.transferredCumulativeRewards > 0\");\n\n        require(IERC20(gmxVester).balanceOf(_receiver) == 0, \"RewardRouter: gmxVester.balance > 0\");\n        require(IERC20(glpVester).balanceOf(_receiver) == 0, \"RewardRouter: glpVester.balance > 0\");\n    }\n\n    function _compound(address _account) private {\n        _compoundGmx(_account);\n        _compoundGlp(_account);\n    }\n\n    function _compoundGmx(address _account) private {\n        uint256 esGmxAmount = IRewardTracker(stakedGmxTracker).claimForAccount(_account, _account);\n        if (esGmxAmount > 0) {\n            _stakeGmx(_account, _account, esGmx, esGmxAmount);\n        }\n\n        uint256 bnGmxAmount = IRewardTracker(bonusGmxTracker).claimForAccount(_account, _account);\n        if (bnGmxAmount > 0) {\n            IRewardTracker(feeGmxTracker).stakeForAccount(_account, _account, bnGmx, bnGmxAmount);\n        }\n    }\n\n    function _compoundGlp(address _account) private {\n        uint256 esGmxAmount = IRewardTracker(stakedGlpTracker).claimForAccount(_account, _account);\n        if (esGmxAmount > 0) {\n            _stakeGmx(_account, _account, esGmx, esGmxAmount);\n        }\n    }\n\n    function _stakeGmx(address _fundingAccount, address _account, address _token, uint256 _amount) private {\n        require(_amount > 0, \"RewardRouter: invalid _amount\");\n\n        IRewardTracker(stakedGmxTracker).stakeForAccount(_fundingAccount, _account, _token, _amount);\n        IRewardTracker(bonusGmxTracker).stakeForAccount(_account, _account, stakedGmxTracker, _amount);\n        IRewardTracker(feeGmxTracker).stakeForAccount(_account, _account, bonusGmxTracker, _amount);\n\n        emit StakeGmx(_account, _token, _amount);\n    }\n\n    function _unstakeGmx(address _account, address _token, uint256 _amount, bool _shouldReduceBnGmx) private {\n        require(_amount > 0, \"RewardRouter: invalid _amount\");\n\n        uint256 balance = IRewardTracker(stakedGmxTracker).stakedAmounts(_account);\n\n        IRewardTracker(feeGmxTracker).unstakeForAccount(_account, bonusGmxTracker, _amount, _account);\n        IRewardTracker(bonusGmxTracker).unstakeForAccount(_account, stakedGmxTracker, _amount, _account);\n        IRewardTracker(stakedGmxTracker).unstakeForAccount(_account, _token, _amount, _account);\n\n        if (_shouldReduceBnGmx) {\n            uint256 bnGmxAmount = IRewardTracker(bonusGmxTracker).claimForAccount(_account, _account);\n            if (bnGmxAmount > 0) {\n                IRewardTracker(feeGmxTracker).stakeForAccount(_account, _account, bnGmx, bnGmxAmount);\n            }\n\n            uint256 stakedBnGmx = IRewardTracker(feeGmxTracker).depositBalances(_account, bnGmx);\n            if (stakedBnGmx > 0) {\n                uint256 reductionAmount = stakedBnGmx.mul(_amount).div(balance);\n                IRewardTracker(feeGmxTracker).unstakeForAccount(_account, bnGmx, reductionAmount, _account);\n                IMintable(bnGmx).burn(_account, reductionAmount);\n            }\n        }\n\n        emit UnstakeGmx(_account, _token, _amount);\n    }\n}"
    }
  ]
}