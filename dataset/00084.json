{
  "Title": "Missing Input Validation",
  "Content": "Throughout the [codebase](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src), there are multiple instances of missing input validation:\n\n\n* Missing zero address check for the [`admin_`](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/ProtocolConfig/ProtocolConfig.sol#L56) and [`feeReceiver_`](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/ProtocolConfig/ProtocolConfig.sol#L57) parameters in [`ProtocolConfig`](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/ProtocolConfig/ProtocolConfig.sol#L55-L62)'s contract constructor.\n* Missing zero address check for the [`admin`](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/GenericFactory/GenericFactory.sol#L70) parameter in [`GenericFactory`](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/GenericFactory/GenericFactory.sol#L65-L73)'s contract constructor.\n\n\nConsider implementing input validation for the listed instances to prevent unexpected behavior.\n\n\n***Update:** Resolved in [pull request #142](https://github.com/euler-xyz/euler-vault-kit/pull/142).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/ProtocolConfig/ProtocolConfig.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"./IProtocolConfig.sol\";\n\ncontract ProtocolConfig is IProtocolConfig {\n    error E_OnlyAdmin();\n    error E_InvalidVault();\n    error E_InvalidReceiver();\n    error E_InvalidConfigValue();\n    error E_InvalidAdmin();\n\n    struct InterestFeeRange {\n        bool exists;\n        uint16 minInterestFee;\n        uint16 maxInterestFee;\n    }\n\n    struct ProtocolFeeConfig {\n        bool exists;\n        address feeReceiver;\n        uint16 protocolFeeShare;\n    }\n\n    /// @dev admin address\n    address public admin;\n    /// @dev protocol fee receiver, unless a vault has it configured otherwise\n    address public feeReceiver;\n\n    /// @dev min interest fee, except for vaults configured otherwise\n    uint16 internal minInterestFee;\n    /// @dev max interest fee, except for vaults configured otherwise\n    uint16 internal maxInterestFee;\n    /// @dev protocol fee share, except for vaults configured otherwise\n    uint16 internal protocolFeeShare;\n\n    /// @dev per-vault configuration of min/max interest fee range, takes priority over defaults\n    mapping(address vault => InterestFeeRange) internal _interestFeeRanges;\n    /// @dev per-vault configuration of protocol fee config, takes priority over defaults\n    mapping(address vault => ProtocolFeeConfig) internal _protocolFeeConfig;\n\n    event SetInterestFeeRange(uint16 newMinInterestFee, uint16 newMaxInterestFee);\n    event SetFeeReceiver(address indexed newFeeReceiver);\n    event SetVaultInterestFeeRange(address indexed vault, bool exists, uint16 minInterestFee, uint16 maxInterestFee);\n    event SetFeeConfigSetting(address indexed ault, bool exists, address indexed feeReceiver, uint16 protocolFeeShare);\n    event SetProtocolFeeShare(uint16 protocolFeeShare, uint16 newProtocolFeeShare);\n    event SetAdmin(address indexed newAdmin);\n\n    /**\n     * @dev constructor\n     * @param admin_ admin's address\n     * @param feeReceiver_ the address of the protocol fee receiver\n     */\n    constructor(address admin_, address feeReceiver_) {\n        admin = admin_;\n        feeReceiver = feeReceiver_;\n\n        minInterestFee = 0.1e4;\n        maxInterestFee = 1e4;\n        protocolFeeShare = 0.1e4;\n    }\n\n    /// @inheritdoc IProtocolConfig\n    function isValidInterestFee(address vault, uint16 interestFee) external view returns (bool) {\n        InterestFeeRange memory range = _interestFeeRanges[vault];\n\n        if (range.exists) {\n            return interestFee >= range.minInterestFee && interestFee <= range.maxInterestFee;\n        }\n\n        return interestFee >= minInterestFee && interestFee <= maxInterestFee;\n    }\n\n    /// @inheritdoc IProtocolConfig\n    function protocolFeeConfig(address vault) external view returns (address, uint16) {\n        ProtocolFeeConfig memory config = _protocolFeeConfig[vault];\n\n        if (config.exists) {\n            return (config.feeReceiver, config.protocolFeeShare);\n        }\n\n        return (feeReceiver, protocolFeeShare);\n    }\n\n    /// @inheritdoc IProtocolConfig\n    function interestFeeRange(address vault) external view returns (uint16, uint16) {\n        InterestFeeRange memory ranges = _interestFeeRanges[vault];\n\n        if (ranges.exists) {\n            return (ranges.minInterestFee, ranges.maxInterestFee);\n        }\n\n        return (minInterestFee, maxInterestFee);\n    }\n\n    // Admin functions\n\n    /// @dev modifier to check if sender is admin address\n    modifier onlyAdmin() {\n        if (msg.sender != admin) revert E_OnlyAdmin();\n\n        _;\n    }\n\n    /**\n     * @notice set admin address\n     * @param newAdmin admin's address\n     */\n    function setAdmin(address newAdmin) external onlyAdmin {\n        if (newAdmin == address(0)) revert E_InvalidAdmin();\n\n        admin = newAdmin;\n\n        emit SetAdmin(newAdmin);\n    }\n\n    /**\n     * @notice set protocol fee receiver\n     * @dev can only be called by admin\n     * @param newReceiver new receiver address\n     */\n    function setFeeReceiver(address newReceiver) external onlyAdmin {\n        if (newReceiver == address(0)) revert E_InvalidReceiver();\n\n        feeReceiver = newReceiver;\n\n        emit SetFeeReceiver(newReceiver);\n    }\n\n    /**\n     * @notice set protocol fee share\n     * @dev can only be called by admin\n     * @param newProtocolFeeShare new protocol fee share\n     */\n    function setProtocolFeeShare(uint16 newProtocolFeeShare) external onlyAdmin {\n        if (newProtocolFeeShare > 1e4) revert E_InvalidConfigValue();\n\n        emit SetProtocolFeeShare(protocolFeeShare, newProtocolFeeShare);\n\n        protocolFeeShare = newProtocolFeeShare;\n    }\n\n    /**\n     * @notice set generic min intereset fee\n     * @dev can only be called by admin\n     * @param minInterestFee_ new min interest fee\n     * @param maxInterestFee_ new max interest fee\n     */\n    function setInterestFeeRange(uint16 minInterestFee_, uint16 maxInterestFee_) external onlyAdmin {\n        if (maxInterestFee_ > 1e4 || minInterestFee_ > maxInterestFee_) revert E_InvalidConfigValue();\n\n        minInterestFee = minInterestFee_;\n        maxInterestFee = maxInterestFee_;\n\n        emit SetInterestFeeRange(minInterestFee_, maxInterestFee_);\n    }\n\n    /**\n     * @notice set interest fee range for specific vault\n     * @dev can only be called by admin\n     * @param vault vault's address\n     * @param exists_ a boolean to set or unset the ranges. When false, the generic ranges will be used for the vault\n     * @param minInterestFee_ min interest fee\n     * @param maxInterestFee_ max interest fee\n     */\n    function setVaultInterestFeeRange(address vault, bool exists_, uint16 minInterestFee_, uint16 maxInterestFee_)\n        external\n        onlyAdmin\n    {\n        if (vault == address(0)) revert E_InvalidVault();\n        if (maxInterestFee_ > 1e4 || minInterestFee_ > maxInterestFee_) revert E_InvalidConfigValue();\n\n        _interestFeeRanges[vault] =\n            InterestFeeRange({exists: exists_, minInterestFee: minInterestFee_, maxInterestFee: maxInterestFee_});\n\n        emit SetVaultInterestFeeRange(vault, exists_, minInterestFee_, maxInterestFee_);\n    }\n\n    /**\n     * @notice set protocol fee config for specific vault\n     * @dev can only be called by admin\n     * @param vault vault's address\n     * @param exists_ a boolean to set or unset the config. When false, the generic config will be used for the vault\n     * @param feeReceiver_ fee receiver address\n     * @param protocolFeeShare_ fee share\n     */\n    function setVaultFeeConfig(address vault, bool exists_, address feeReceiver_, uint16 protocolFeeShare_)\n        external\n        onlyAdmin\n    {\n        if (vault == address(0)) revert E_InvalidVault();\n        if (protocolFeeShare_ > 1e4) revert E_InvalidConfigValue();\n\n        _protocolFeeConfig[vault] =\n            ProtocolFeeConfig({exists: exists_, feeReceiver: feeReceiver_, protocolFeeShare: protocolFeeShare_});\n\n        emit SetFeeConfigSetting(vault, exists_, feeReceiver_, protocolFeeShare_);\n    }\n}"
    },
    {
      "filename": "src/GenericFactory/GenericFactory.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {BeaconProxy} from \"./BeaconProxy.sol\";\nimport {MetaProxyDeployer} from \"./MetaProxyDeployer.sol\";\n\ninterface IComponent {\n    function initialize(address creator) external;\n}\n\ncontract GenericFactory is MetaProxyDeployer {\n    // Constants\n\n    uint256 constant REENTRANCYLOCK__UNLOCKED = 1;\n    uint256 constant REENTRANCYLOCK__LOCKED = 2;\n\n    // State\n\n    struct ProxyConfig {\n        bool upgradeable;\n        address implementation; // may be an out-of-date value, if upgradeable (handled by getProxyConfig)\n        bytes trailingData;\n    }\n\n    uint256 private reentrancyLock;\n\n    address public upgradeAdmin;\n    address public implementation;\n    mapping(address proxy => ProxyConfig) internal proxyLookup;\n    address[] public proxyList;\n\n    // Events\n\n    event Genesis();\n\n    event ProxyCreated(address indexed proxy, bool upgradeable, address implementation, bytes trailingData);\n\n    event SetImplementation(address indexed newImplementation);\n    event SetUpgradeAdmin(address indexed newUpgradeAdmin);\n\n    // Errors\n\n    error E_Reentrancy();\n    error E_Unauthorized();\n    error E_Implementation();\n    error E_BadAddress();\n    error E_BadQuery();\n\n    // Modifiers\n\n    modifier nonReentrant() {\n        if (reentrancyLock == REENTRANCYLOCK__LOCKED) revert E_Reentrancy();\n\n        reentrancyLock = REENTRANCYLOCK__LOCKED;\n        _;\n        reentrancyLock = REENTRANCYLOCK__UNLOCKED;\n    }\n\n    modifier adminOnly() {\n        if (msg.sender != upgradeAdmin) revert E_Unauthorized();\n        _;\n    }\n\n    constructor(address admin) {\n        emit Genesis();\n\n        reentrancyLock = REENTRANCYLOCK__UNLOCKED;\n\n        upgradeAdmin = admin;\n\n        emit SetUpgradeAdmin(admin);\n    }\n\n    function createProxy(bool upgradeable, bytes memory trailingData) external nonReentrant returns (address) {\n        if (implementation == address(0)) revert E_Implementation();\n\n        address proxy;\n\n        if (upgradeable) {\n            proxy = address(new BeaconProxy(trailingData));\n        } else {\n            proxy = deployMetaProxy(implementation, trailingData);\n        }\n\n        proxyLookup[proxy] =\n            ProxyConfig({upgradeable: upgradeable, implementation: implementation, trailingData: trailingData});\n\n        proxyList.push(proxy);\n\n        IComponent(proxy).initialize(msg.sender);\n\n        emit ProxyCreated(proxy, upgradeable, implementation, trailingData);\n\n        return proxy;\n    }\n\n    // EVault beacon upgrade\n\n    function setImplementation(address newImplementation) external nonReentrant adminOnly {\n        if (newImplementation == address(0)) revert E_BadAddress();\n        implementation = newImplementation;\n        emit SetImplementation(newImplementation);\n    }\n\n    // Admin role\n\n    function setUpgradeAdmin(address newUpgradeAdmin) external nonReentrant adminOnly {\n        if (newUpgradeAdmin == address(0)) revert E_BadAddress();\n        upgradeAdmin = newUpgradeAdmin;\n        emit SetUpgradeAdmin(newUpgradeAdmin);\n    }\n\n    // Proxy getters\n\n    function getProxyConfig(address proxy) external view returns (ProxyConfig memory config) {\n        config = proxyLookup[proxy];\n        if (config.upgradeable) config.implementation = implementation;\n    }\n\n    function isProxy(address proxy) external view returns (bool) {\n        return proxyLookup[proxy].implementation != address(0);\n    }\n\n    function getProxyListLength() external view returns (uint256) {\n        return proxyList.length;\n    }\n\n    function getProxyListSlice(uint256 start, uint256 end) external view returns (address[] memory list) {\n        if (end == type(uint256).max) end = proxyList.length;\n        if (end < start || end > proxyList.length) revert E_BadQuery();\n\n        list = new address[](end - start);\n        for (uint256 i; i < end - start; ++i) {\n            list[i] = proxyList[start + i];\n        }\n    }\n}"
    }
  ]
}