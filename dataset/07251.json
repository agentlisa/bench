{
  "Title": "[H-03] Improper validations in Clearinghouse, possible to lock collateral NFT in contract",
  "Content": "\nWhen a borrower does not return the borrowed funds on time, a liquidator can trigger a liquidation.<br>\nIn that case the collateral NFT will be listed in an Seaport dutch auction.<br>\nThe auction requests settlementToken and a fake ClearingHouse NFT.<br>\nWhen a buyer bids enough of the settlementToken, openSea auction will accept the offer, transfer the NFT from ClearingHouse to bidder, move settlementToken from bidder to ClearingHouse, and 'transfers' the fake clearinghouse NFT to clearinghouse. This call to [ClearingHouse.safeTransferFrom](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L169-L178) triggers the further processing of the liquidation. It will pay the debt with the funds received from Seaport, and delete data from LienToken and CollateralToken for this collateral NFT.\n\nThe problem is that the `ClearingHouse.safeTransferFrom` can be called by anyone and assumes valid call parameters. One of the parameters `identifier` is used to pass the paymentToken address. This can easily be modified to let the contract accept any ERC20 token as `paymentToken` to payoff the debt.<br>\nThis allows a malicious actor to lock a user's collateral NFT and cancel the auction.<br>\nThis could be misused to completely block any liquidatons.\n\nThe steps to reproduce:\n\n1. Normal flow: borrow funds via requestLienPosition\n2. borrowed funds are not paid back before stack.point.end \n3. liquidator calls AstariaRouter.liquidate(...)\n\nAt this time a Seaport auction is initiated and CollateralToken state for this collateralID is updated to be in auction. \nAll fine so far.\n\n4. An evil actor can now call ClearingHouse.safeTransferFrom with dummy data and a dummy ERC20  token address as paymentToken\n\nAfter this call, the Collateral NFT will still be in de ClearingHouse contract, but references to the NFT are cleaned up from both CollateralToken and LienToken.\nThis results in the NFT being locked in the contract without any way to get it out.\n\n### Technical details\n\nWhen a liquidation is started, [\\_generateValidOrderParameters](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L425) is called to generate the Seaport order params. It sets [settlementToken as the identifierOrCriteria](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L456).\n\nClearingHouse assumes that `safeTransferFrom` will only be called by Seaport after a succesful auction, and assumes the identifier is the `settlementToken` value that was set for the order.<br>\nThe \\_execute function is called, which [converts the identifier parameter to a paymentToken address](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L123) and checks if the received amount of paymentToken is >= the expected auction currentOfferPrice it accepts the call and moves the token balance to the correct addresses.<br>\nIt then calls [LienToken.payDebtViaClearingHouse](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L497-L510), passing the fake `paymentToken` as a parameter.<br>\nLientoken contract also does not verify if the token is ineed the correct settlementToken and pays off the debt with the fake token balance.<br>\nIt then deletes the [collateralStateHash](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L509) for the collateralId, removing the stack state.\n\nAfter that,  `CollateralToken.settleAuction` is called, which [burns the token](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L538) for collateralId and [deletes idToUnderlying](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L537) and [collateralIdToAuction](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L544) for this collateralId.\n\nWe now have a state where the collateral NFT is in the ClearingHouse contract, but all actions are made impossible, because the state in the token contracts are removed.\n`CollateralToken.ownerOf(collateralID)` reverts because the entry in `s.idToUnderlying` was removed.<br>\nThis causes `releaseToAddress()` and `flashAction()` to fail.<br>\n`liquidatorNFTClaim` fails because `s.collateralIdToAuction` was cleared.<br>\nTrying to create a new Lien also fails as that calls `CollateralToken.ownerOf(collateralID)`.\n\n### Proof of concept\n\nTo test the scenario, I have modified the testLiquidationNftTransfer test in AstariaTest.t.sol\n\n```diff\ndiff --git a/src/test/AstariaTest.t.sol b/src/test/AstariaTest.t.sol\nindex c7ce162..bfaeca6 100644\n--- a/src/test/AstariaTest.t.sol\n+++ b/src/test/AstariaTest.t.sol\n@@ -18,6 +18,7 @@ import \"forge-std/Test.sol\";\n import {Authority} from \"solmate/auth/Auth.sol\";\n import {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n import {MockERC721} from \"solmate/test/utils/mocks/MockERC721.sol\";\n+import {MockERC20} from \"solmate/test/utils/mocks/MockERC20.sol\";\n import {\n   MultiRolesAuthority\n } from \"solmate/auth/authorities/MultiRolesAuthority.sol\";\n@@ -1030,8 +1031,19 @@ contract AstariaTest is TestHelpers {\n       uint8(0)\n     );\n     vm.stopPrank();\n-    uint256 bid = 100 ether;\n-    _bid(Bidder(bidder, bidderPK), listedOrder, bid);\n+\n+    uint256 collateralId = tokenContract.computeId(tokenId);\n+    ClearingHouse CH = COLLATERAL_TOKEN.getClearingHouse(collateralId);\n+\n+    // create a worthless token and send it to the clearinghouse\n+    MockERC20 worthlessToken = new MockERC20(\"TestToken\",\"TST\",18);\n+    worthlessToken.mint(address(CH),550 ether);\n+\n+    // call safeTransferFrom on clearinghouse with the worthless token as paymentToken\n+    // thiss will trigger the cleaning up after succesful auction\n+    uint256 tokenAsInt = uint256(uint160(address(worthlessToken)));\n+    bytes memory emptyBytes;\n+    CH.safeTransferFrom(address(0),address(bidder),tokenAsInt,0,emptyBytes);\n\n     // assert the bidder received the NFT\n     assertEq(nft.ownerOf(tokenId), bidder, \"Bidder did not receive NFT\");\n```\n\nAfter this, the [assert the bidder received the NFT](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/test/AstariaTest.t.sol#L1037) test will fail, as the NFT is not moved.\nBut the state of the CollateralToken and LienToken contracts is updated.\n\n### Tools Used\n\nManual audit, forge\n\n### Recommended Mitigation Steps\n\nMinimal fix would be to check either check if the supplied paymentToken matches the expected paymentToken, or ignore the parameter alltogether and use the paymentToken from the contract. Other option is to restrict calls to the function to whitelisted addresses (OpenSea controler and conduit ).\n\nIn the current setup, there is no easy way for the ClearingHouse to access information about the settlementToken.<br>\nIt could be added to the AuctionData struct:\n\n```diff\ndiff --git a/src/interfaces/ILienToken.sol b/src/interfaces/ILienToken.sol\nindex 964caa2..06433c0 100644\n--- a/src/interfaces/ILienToken.sol\n+++ b/src/interfaces/ILienToken.sol\n@@ -238,6 +238,7 @@ interface ILienToken is IERC721 {\n     uint48 startTime;\n     uint48 endTime;\n     address liquidator;\n+    address settlementToken;\n     AuctionStack[] stack;\n   }\n```\n\nand then add it in LienToken\n\n```diff\ndiff --git a/src/LienToken.sol b/src/LienToken.sol\nindex 631ac02..372e197 100644\n--- a/src/LienToken.sol\n+++ b/src/LienToken.sol\n@@ -340,6 +340,8 @@ contract LienToken is ERC721, ILienToken, AuthInitializable {\n       .liquidationInitialAsk\n       .safeCastTo88();\n     auctionData.endAmount = uint88(1000 wei);\n+    auctionData.settlementToken = stack[0].lien.token; \n+\n     s.COLLATERAL_TOKEN.getClearingHouse(collateralId).setAuctionData(\n       auctionData\n     );\n```\n\nIn the ClearingHouse it can be used directly, ignoring the supplied parameter:\n\n```diff\ndiff --git a/src/ClearingHouse.sol b/src/ClearingHouse.sol\nindex 5c2a400..d305ff5 100644\n--- a/src/ClearingHouse.sol\n+++ b/src/ClearingHouse.sol\n@@ -120,7 +120,7 @@ contract ClearingHouse is AmountDeriver, Clone, IERC1155, IERC721Receiver {\n     IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0)); // get the router from the immutable arg\n\n     ClearingHouseStorage storage s = _getStorage();\n-    address paymentToken = bytes32(encodedMetaData).fromLast20Bytes();\n+    address paymentToken = s.auctionStack.settlementToken;\n\n     uint256 currentOfferPrice = _locateCurrentAmount({\n       startAmount: s.auctionStack.startAmount,\n```\n\nor used to check the supplied paramameter\n\n```diff\ndiff --git a/src/ClearingHouse.sol b/src/ClearingHouse.sol\nindex 5c2a400..5a79184 100644\n--- a/src/ClearingHouse.sol\n+++ b/src/ClearingHouse.sol\n@@ -121,6 +121,7 @@ contract ClearingHouse is AmountDeriver, Clone, IERC1155, IERC721Receiver {\n\n     ClearingHouseStorage storage s = _getStorage();\n     address paymentToken = bytes32(encodedMetaData).fromLast20Bytes();\n+    require(paymentToken == s.auctionStack.settlementToken);\n\n     uint256 currentOfferPrice = _locateCurrentAmount({\n       startAmount: s.auctionStack.startAmount,\n```\n\nWith this step added, it would still be possible to lock the NFT in the contract, but this time that will only succeed when the requested auction amount is paid. So in that case it would be more logical to simply bid on OpenSea and also get the NFT instead of paying the tokens just to lock it.\n\n**[SantiagoGregory (Astaria) confirmed via duplicate issue `#564`](https://github.com/code-423n4/2023-01-astaria-findings/issues/564#event-8369713354)**\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-01-astaria",
  "Code": [
    {
      "filename": "src/ClearingHouse.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {WETH} from \"solmate/tokens/WETH.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {Clone} from \"clones-with-immutable-args/Clone.sol\";\nimport {IERC1155} from \"core/interfaces/IERC1155.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {Bytes32AddressLib} from \"solmate/utils/Bytes32AddressLib.sol\";\nimport {\n  ConduitControllerInterface\n} from \"seaport/interfaces/ConduitControllerInterface.sol\";\nimport {AmountDeriver} from \"seaport/lib/AmountDeriver.sol\";\nimport {Order} from \"seaport/lib/ConsiderationStructs.sol\";\nimport {IERC721Receiver} from \"core/interfaces/IERC721Receiver.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\n\ncontract ClearingHouse is AmountDeriver, Clone, IERC1155, IERC721Receiver {\n  using Bytes32AddressLib for bytes32;\n  using SafeTransferLib for ERC20;\n\n  struct ClearingHouseStorage {\n    ILienToken.AuctionData auctionStack;\n  }\n\n  uint256 private constant CLEARING_HOUSE_STORAGE_SLOT =\n    uint256(keccak256(\"xyz.astaria.ClearingHouse.storage.location\")) - 1;\n\n  function ROUTER() public pure returns (IAstariaRouter) {\n    return IAstariaRouter(_getArgAddress(0));\n  }\n\n  function COLLATERAL_ID() public pure returns (uint256) {\n    return _getArgUint256(21);\n  }\n\n  function IMPL_TYPE() public pure returns (uint8) {\n    return _getArgUint8(20);\n  }\n\n  function _getStorage()\n    internal\n    pure\n    returns (ClearingHouseStorage storage s)\n  {\n    uint256 slot = CLEARING_HOUSE_STORAGE_SLOT;\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  function setAuctionData(ILienToken.AuctionData calldata auctionData)\n    external\n  {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0)); // get the router from the immutable arg\n\n    //only execute from the conduit\n    require(msg.sender == address(ASTARIA_ROUTER.LIEN_TOKEN()));\n\n    ClearingHouseStorage storage s = _getStorage();\n    s.auctionStack = auctionData;\n  }\n\n  function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n    return interfaceId == type(IERC1155).interfaceId;\n  }\n\n  function balanceOf(address account, uint256 id)\n    external\n    view\n    returns (uint256)\n  {\n    return type(uint256).max;\n  }\n\n  function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n    external\n    view\n    returns (uint256[] memory output)\n  {\n    output = new uint256[](accounts.length);\n    for (uint256 i; i < accounts.length; ) {\n      output[i] = type(uint256).max;\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function setApprovalForAll(address operator, bool approved) external {}\n\n  function isApprovedForAll(address account, address operator)\n    external\n    view\n    returns (bool)\n  {\n    return true;\n  }\n\n  function _execute(\n    address tokenContract, // collateral token sending the fake nft\n    address to, // buyer\n    uint256 encodedMetaData, //retrieve token address from the encoded data\n    uint256 // space to encode whatever is needed,\n  ) internal {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0)); // get the router from the immutable arg\n\n    ClearingHouseStorage storage s = _getStorage();\n    address paymentToken = bytes32(encodedMetaData).fromLast20Bytes();\n\n    uint256 currentOfferPrice = _locateCurrentAmount({\n      startAmount: s.auctionStack.startAmount,\n      endAmount: s.auctionStack.endAmount,\n      startTime: s.auctionStack.startTime,\n      endTime: s.auctionStack.endTime,\n      roundUp: true //we are a consideration we round up\n    });\n    uint256 payment = ERC20(paymentToken).balanceOf(address(this));\n\n    require(payment >= currentOfferPrice, \"not enough funds received\");\n\n    uint256 collateralId = _getArgUint256(21);\n    // pay liquidator fees here\n\n    ILienToken.AuctionStack[] storage stack = s.auctionStack.stack;\n\n    uint256 liquidatorPayment = ASTARIA_ROUTER.getLiquidatorFee(payment);\n\n    ERC20(paymentToken).safeTransfer(\n      s.auctionStack.liquidator,\n      liquidatorPayment\n    );\n\n    ERC20(paymentToken).safeApprove(\n      address(ASTARIA_ROUTER.TRANSFER_PROXY()),\n      payment - liquidatorPayment\n    );\n\n    ASTARIA_ROUTER.LIEN_TOKEN().payDebtViaClearingHouse(\n      paymentToken,\n      collateralId,\n      payment - liquidatorPayment,\n      s.auctionStack.stack\n    );\n\n    if (ERC20(paymentToken).balanceOf(address(this)) > 0) {\n      ERC20(paymentToken).safeTransfer(\n        ASTARIA_ROUTER.COLLATERAL_TOKEN().ownerOf(collateralId),\n        ERC20(paymentToken).balanceOf(address(this))\n      );\n    }\n    ASTARIA_ROUTER.COLLATERAL_TOKEN().settleAuction(collateralId);\n  }\n\n  function safeTransferFrom(\n    address from, // the from is the offerer\n    address to,\n    uint256 identifier,\n    uint256 amount,\n    bytes calldata data //empty from seaport\n  ) public {\n    //data is empty and useless\n    _execute(from, to, identifier, amount);\n  }\n\n  function safeBatchTransferFrom(\n    address from,\n    address to,\n    uint256[] calldata ids,\n    uint256[] calldata amounts,\n    bytes calldata data\n  ) public {}\n\n  function onERC721Received(\n    address operator_,\n    address from_,\n    uint256 tokenId_,\n    bytes calldata data_\n  ) external override returns (bytes4) {\n    return IERC721Receiver.onERC721Received.selector;\n  }\n\n  function validateOrder(Order memory order) external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    Order[] memory listings = new Order[](1);\n    listings[0] = order;\n\n    ERC721(order.parameters.offer[0].token).approve(\n      ASTARIA_ROUTER.COLLATERAL_TOKEN().getConduit(),\n      order.parameters.offer[0].identifierOrCriteria\n    );\n    ASTARIA_ROUTER.COLLATERAL_TOKEN().SEAPORT().validate(listings);\n  }\n\n  function transferUnderlying(\n    address tokenContract,\n    uint256 tokenId,\n    address target\n  ) external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    ERC721(tokenContract).safeTransferFrom(address(this), target, tokenId);\n  }\n\n  function settleLiquidatorNFTClaim() external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    ClearingHouseStorage storage s = _getStorage();\n    ASTARIA_ROUTER.LIEN_TOKEN().payDebtViaClearingHouse(\n      address(0),\n      COLLATERAL_ID(),\n      0,\n      s.auctionStack.stack\n    );\n  }\n}"
    },
    {
      "filename": "src/CollateralToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\npragma experimental ABIEncoderV2;\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"core/interfaces/ICollateralToken.sol\";\nimport {IERC165} from \"core/interfaces/IERC165.sol\";\nimport {IERC721} from \"core/interfaces/IERC721.sol\";\nimport {IERC721Receiver} from \"core/interfaces/IERC721Receiver.sol\";\nimport {IFlashAction} from \"core/interfaces/IFlashAction.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {ISecurityHook} from \"core/interfaces/ISecurityHook.sol\";\nimport {ITransferProxy} from \"core/interfaces/ITransferProxy.sol\";\nimport {Authority} from \"solmate/auth/Auth.sol\";\nimport {CollateralLookup} from \"core/libraries/CollateralLookup.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC721} from \"gpl/ERC721.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {VaultImplementation} from \"core/VaultImplementation.sol\";\nimport {ZoneInterface} from \"seaport/interfaces/ZoneInterface.sol\";\nimport {Bytes32AddressLib} from \"solmate/utils/Bytes32AddressLib.sol\";\nimport {\n  ClonesWithImmutableArgs\n} from \"clones-with-immutable-args/ClonesWithImmutableArgs.sol\";\n\nimport {\n  ConduitControllerInterface\n} from \"seaport/interfaces/ConduitControllerInterface.sol\";\nimport {\n  ConsiderationInterface\n} from \"seaport/interfaces/ConsiderationInterface.sol\";\nimport {\n  AdvancedOrder,\n  CriteriaResolver,\n  OfferItem,\n  ConsiderationItem,\n  ItemType,\n  OrderParameters,\n  OrderComponents,\n  OrderType,\n  Order\n} from \"seaport/lib/ConsiderationStructs.sol\";\n\nimport {Consideration} from \"seaport/lib/Consideration.sol\";\nimport {SeaportInterface} from \"seaport/interfaces/SeaportInterface.sol\";\nimport {ClearingHouse} from \"core/ClearingHouse.sol\";\nimport {AuthInitializable} from \"core/AuthInitializable.sol\";\n\ncontract CollateralToken is\n  AuthInitializable,\n  ERC721,\n  IERC721Receiver,\n  ICollateralToken,\n  ZoneInterface\n{\n  using SafeTransferLib for ERC20;\n  using CollateralLookup for address;\n  using FixedPointMathLib for uint256;\n  uint256 private constant COLLATERAL_TOKEN_SLOT =\n    uint256(keccak256(\"xyz.astaria.CollateralToken.storage.location\")) - 1;\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(\n    Authority AUTHORITY_,\n    ITransferProxy TRANSFER_PROXY_,\n    ILienToken LIEN_TOKEN_,\n    ConsiderationInterface SEAPORT_\n  ) public initializer {\n    __initAuth(msg.sender, address(AUTHORITY_));\n    __initERC721(\"Astaria Collateral Token\", \"ACT\");\n    CollateralStorage storage s = _loadCollateralSlot();\n    s.TRANSFER_PROXY = TRANSFER_PROXY_;\n    s.LIEN_TOKEN = LIEN_TOKEN_;\n    s.SEAPORT = SEAPORT_;\n    (, , address conduitController) = s.SEAPORT.information();\n    bytes32 CONDUIT_KEY = Bytes32AddressLib.fillLast12Bytes(address(this));\n    s.CONDUIT_KEY = CONDUIT_KEY;\n    s.CONDUIT_CONTROLLER = ConduitControllerInterface(conduitController);\n\n    s.CONDUIT = s.CONDUIT_CONTROLLER.createConduit(CONDUIT_KEY, address(this));\n    s.CONDUIT_CONTROLLER.updateChannel(\n      address(s.CONDUIT),\n      address(SEAPORT_),\n      true\n    );\n  }\n\n  function SEAPORT() public view returns (ConsiderationInterface) {\n    return _loadCollateralSlot().SEAPORT;\n  }\n\n  function liquidatorNFTClaim(OrderParameters memory params) external {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    uint256 collateralId = params.offer[0].token.computeId(\n      params.offer[0].identifierOrCriteria\n    );\n    address liquidator = s.LIEN_TOKEN.getAuctionLiquidator(collateralId);\n    if (\n      s.collateralIdToAuction[collateralId] == bytes32(0) ||\n      liquidator == address(0)\n    ) {\n      //revert no auction\n      revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);\n    }\n    if (\n      s.collateralIdToAuction[collateralId] != keccak256(abi.encode(params))\n    ) {\n      //revert auction params dont match\n      revert InvalidCollateralState(\n        InvalidCollateralStates.INVALID_AUCTION_PARAMS\n      );\n    }\n\n    if (block.timestamp < params.endTime) {\n      //auction hasn't ended yet\n      revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n    }\n\n    Asset memory underlying = s.idToUnderlying[collateralId];\n    address tokenContract = underlying.tokenContract;\n    uint256 tokenId = underlying.tokenId;\n    ClearingHouse CH = ClearingHouse(payable(s.clearingHouse[collateralId]));\n    CH.settleLiquidatorNFTClaim();\n    _releaseToAddress(s, underlying, collateralId, liquidator);\n  }\n\n  function _loadCollateralSlot()\n    internal\n    pure\n    returns (CollateralStorage storage s)\n  {\n    uint256 slot = COLLATERAL_TOKEN_SLOT;\n\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  function isValidOrder(\n    bytes32 orderHash,\n    address caller,\n    address offerer,\n    bytes32 zoneHash\n  ) external view returns (bytes4 validOrderMagicValue) {\n    CollateralStorage storage s = _loadCollateralSlot();\n    return\n      s.collateralIdToAuction[uint256(zoneHash)] == orderHash\n        ? ZoneInterface.isValidOrder.selector\n        : bytes4(0xffffffff);\n  }\n\n  // Called by Consideration whenever any extraData is provided by the caller.\n  function isValidOrderIncludingExtraData(\n    bytes32 orderHash,\n    address caller,\n    AdvancedOrder calldata order,\n    bytes32[] calldata priorOrderHashes,\n    CriteriaResolver[] calldata criteriaResolvers\n  ) external view returns (bytes4 validOrderMagicValue) {\n    CollateralStorage storage s = _loadCollateralSlot();\n    return\n      s.collateralIdToAuction[uint256(order.parameters.zoneHash)] == orderHash\n        ? ZoneInterface.isValidOrder.selector\n        : bytes4(0xffffffff);\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC721, IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(ICollateralToken).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  function fileBatch(File[] calldata files) external requiresAuth {\n    uint256 i;\n    for (; i < files.length; ) {\n      _file(files[i]);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function file(File calldata incoming) public requiresAuth {\n    _file(incoming);\n  }\n\n  function _file(File calldata incoming) internal {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    FileType what = incoming.what;\n    bytes memory data = incoming.data;\n    if (what == FileType.AstariaRouter) {\n      address addr = abi.decode(data, (address));\n      s.ASTARIA_ROUTER = IAstariaRouter(addr);\n    } else if (what == FileType.SecurityHook) {\n      (address target, address hook) = abi.decode(data, (address, address));\n      s.securityHooks[target] = hook;\n    } else if (what == FileType.FlashEnabled) {\n      (address target, bool enabled) = abi.decode(data, (address, bool));\n      s.flashEnabled[target] = enabled;\n    } else if (what == FileType.Seaport) {\n      s.SEAPORT = ConsiderationInterface(abi.decode(data, (address)));\n      (, , address conduitController) = s.SEAPORT.information();\n      if (s.CONDUIT_KEY == bytes32(0)) {\n        s.CONDUIT_KEY = Bytes32AddressLib.fillLast12Bytes(address(this));\n      }\n      s.CONDUIT_CONTROLLER = ConduitControllerInterface(conduitController);\n      (address conduit, bool exists) = s.CONDUIT_CONTROLLER.getConduit(\n        s.CONDUIT_KEY\n      );\n      if (!exists) {\n        s.CONDUIT = s.CONDUIT_CONTROLLER.createConduit(\n          s.CONDUIT_KEY,\n          address(this)\n        );\n      } else {\n        s.CONDUIT = conduit;\n      }\n      s.CONDUIT_CONTROLLER.updateChannel(\n        address(s.CONDUIT),\n        address(s.SEAPORT),\n        true\n      );\n    } else {\n      revert UnsupportedFile();\n    }\n    emit FileUpdated(what, data);\n  }\n\n  modifier releaseCheck(uint256 collateralId) {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    if (s.LIEN_TOKEN.getCollateralState(collateralId) != bytes32(0)) {\n      revert InvalidCollateralState(InvalidCollateralStates.ACTIVE_LIENS);\n    }\n    if (s.collateralIdToAuction[collateralId] != bytes32(0)) {\n      revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n    }\n    _;\n  }\n\n  modifier onlyOwner(uint256 collateralId) {\n    require(ownerOf(collateralId) == msg.sender);\n    _;\n  }\n\n  function flashAction(\n    IFlashAction receiver,\n    uint256 collateralId,\n    bytes calldata data\n  ) external onlyOwner(collateralId) {\n    address addr;\n    uint256 tokenId;\n    CollateralStorage storage s = _loadCollateralSlot();\n    (addr, tokenId) = getUnderlying(collateralId);\n\n    if (!s.flashEnabled[addr]) {\n      revert InvalidCollateralState(InvalidCollateralStates.FLASH_DISABLED);\n    }\n\n    if (\n      s.LIEN_TOKEN.getCollateralState(collateralId) == bytes32(\"ACTIVE_AUCTION\")\n    ) {\n      revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n    }\n\n    bytes32 preTransferState;\n    //look to see if we have a security handler for this asset\n\n    address securityHook = s.securityHooks[addr];\n    if (securityHook != address(0)) {\n      preTransferState = ISecurityHook(securityHook).getState(addr, tokenId);\n    }\n    // transfer the NFT to the destination optimistically\n\n    ClearingHouse(s.clearingHouse[collateralId]).transferUnderlying(\n      addr,\n      tokenId,\n      address(receiver)\n    );\n\n    //trigger the flash action on the receiver\n    if (\n      receiver.onFlashAction(\n        IFlashAction.Underlying(s.clearingHouse[collateralId], addr, tokenId),\n        data\n      ) != keccak256(\"FlashAction.onFlashAction\")\n    ) {\n      revert FlashActionCallbackFailed();\n    }\n\n    if (\n      securityHook != address(0) &&\n      preTransferState != ISecurityHook(securityHook).getState(addr, tokenId)\n    ) {\n      revert FlashActionSecurityCheckFailed();\n    }\n\n    // validate that the NFT returned after the call\n\n    if (\n      IERC721(addr).ownerOf(tokenId) != address(s.clearingHouse[collateralId])\n    ) {\n      revert FlashActionNFTNotReturned();\n    }\n  }\n\n  function releaseToAddress(uint256 collateralId, address releaseTo)\n    public\n    releaseCheck(collateralId)\n    onlyOwner(collateralId)\n  {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    if (msg.sender != ownerOf(collateralId)) {\n      revert InvalidSender();\n    }\n    Asset memory underlying = s.idToUnderlying[collateralId];\n    address tokenContract = underlying.tokenContract;\n    _burn(collateralId);\n    delete s.idToUnderlying[collateralId];\n    _releaseToAddress(s, underlying, collateralId, releaseTo);\n  }\n\n  /**\n   * @dev Transfers locked collateral to a specified address and deletes the reference to the CollateralToken for that NFT.\n   * @param releaseTo The address to send the NFT to.\n   */\n  function _releaseToAddress(\n    CollateralStorage storage s,\n    Asset memory underlyingAsset,\n    uint256 collateralId,\n    address releaseTo\n  ) internal {\n    ClearingHouse(s.clearingHouse[collateralId]).transferUnderlying(\n      underlyingAsset.tokenContract,\n      underlyingAsset.tokenId,\n      releaseTo\n    );\n    emit ReleaseTo(\n      underlyingAsset.tokenContract,\n      underlyingAsset.tokenId,\n      releaseTo\n    );\n  }\n\n  function getConduitKey() public view returns (bytes32) {\n    CollateralStorage storage s = _loadCollateralSlot();\n    return s.CONDUIT_KEY;\n  }\n\n  function getConduit() public view returns (address) {\n    CollateralStorage storage s = _loadCollateralSlot();\n    return s.CONDUIT;\n  }\n\n  /**\n   * @notice Retrieve the address and tokenId of the underlying NFT of a CollateralToken.\n   * @param collateralId The ID of the CollateralToken wrapping the NFT.\n   * @return The address and tokenId of the underlying NFT.\n   */\n  function getUnderlying(uint256 collateralId)\n    public\n    view\n    returns (address, uint256)\n  {\n    Asset memory underlying = _loadCollateralSlot().idToUnderlying[\n      collateralId\n    ];\n    return (underlying.tokenContract, underlying.tokenId);\n  }\n\n  /**\n   * @notice Retrieve the tokenURI for a CollateralToken.\n   * @param collateralId The ID of the CollateralToken.\n   * @return the URI of the CollateralToken.\n   */\n  function tokenURI(uint256 collateralId)\n    public\n    view\n    virtual\n    override(ERC721, IERC721)\n    returns (string memory)\n  {\n    (address underlyingAsset, uint256 assetId) = getUnderlying(collateralId);\n    return ERC721(underlyingAsset).tokenURI(assetId);\n  }\n\n  function securityHooks(address target) public view returns (address) {\n    return _loadCollateralSlot().securityHooks[target];\n  }\n\n  function getClearingHouse(uint256 collateralId)\n    external\n    view\n    returns (ClearingHouse)\n  {\n    return\n      ClearingHouse(payable(_loadCollateralSlot().clearingHouse[collateralId]));\n  }\n\n  function _generateValidOrderParameters(\n    CollateralStorage storage s,\n    address settlementToken,\n    uint256 collateralId,\n    uint256[] memory prices,\n    uint256 maxDuration\n  ) internal returns (OrderParameters memory orderParameters) {\n    OfferItem[] memory offer = new OfferItem[](1);\n\n    Asset memory underlying = s.idToUnderlying[collateralId];\n\n    offer[0] = OfferItem(\n      ItemType.ERC721,\n      underlying.tokenContract,\n      underlying.tokenId,\n      1,\n      1\n    );\n\n    ConsiderationItem[] memory considerationItems = new ConsiderationItem[](2);\n    considerationItems[0] = ConsiderationItem(\n      ItemType.ERC20,\n      settlementToken,\n      uint256(0),\n      prices[0],\n      prices[1],\n      payable(address(s.clearingHouse[collateralId]))\n    );\n    considerationItems[1] = ConsiderationItem(\n      ItemType.ERC1155,\n      s.clearingHouse[collateralId],\n      uint256(uint160(settlementToken)),\n      prices[0],\n      prices[1],\n      payable(s.clearingHouse[collateralId])\n    );\n\n    orderParameters = OrderParameters({\n      offerer: s.clearingHouse[collateralId],\n      zone: address(this), // 0x20\n      offer: offer,\n      consideration: considerationItems,\n      orderType: OrderType.FULL_OPEN,\n      startTime: uint256(block.timestamp),\n      endTime: uint256(block.timestamp + maxDuration),\n      zoneHash: bytes32(collateralId),\n      salt: uint256(blockhash(block.number)),\n      conduitKey: s.CONDUIT_KEY, // 0x120\n      totalOriginalConsiderationItems: considerationItems.length\n    });\n  }\n\n  function auctionVault(AuctionVaultParams calldata params)\n    external\n    requiresAuth\n    returns (OrderParameters memory orderParameters)\n  {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    uint256[] memory prices = new uint256[](2);\n    prices[0] = params.startingPrice;\n    prices[1] = params.endingPrice;\n    orderParameters = _generateValidOrderParameters(\n      s,\n      params.settlementToken,\n      params.collateralId,\n      prices,\n      params.maxDuration\n    );\n\n    _listUnderlyingOnSeaport(\n      s,\n      params.collateralId,\n      Order(orderParameters, new bytes(0))\n    );\n  }\n\n  function _listUnderlyingOnSeaport(\n    CollateralStorage storage s,\n    uint256 collateralId,\n    Order memory listingOrder\n  ) internal {\n    //get total Debt and ensure its being sold for more than that\n\n    if (listingOrder.parameters.conduitKey != s.CONDUIT_KEY) {\n      revert InvalidConduitKey();\n    }\n    if (listingOrder.parameters.zone != address(this)) {\n      revert InvalidZone();\n    }\n\n    ClearingHouse(s.clearingHouse[collateralId]).validateOrder(listingOrder);\n    emit ListedOnSeaport(collateralId, listingOrder);\n\n    s.collateralIdToAuction[collateralId] = keccak256(\n      abi.encode(listingOrder.parameters)\n    );\n  }\n\n  function settleAuction(uint256 collateralId) public {\n    CollateralStorage storage s = _loadCollateralSlot();\n    if (\n      s.collateralIdToAuction[collateralId] == bytes32(0) &&\n      ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(\n        s.idToUnderlying[collateralId].tokenId\n      ) !=\n      s.clearingHouse[collateralId]\n    ) {\n      revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);\n    }\n    require(msg.sender == s.clearingHouse[collateralId]);\n    _settleAuction(s, collateralId);\n    delete s.idToUnderlying[collateralId];\n    _burn(collateralId);\n  }\n\n  function _settleAuction(CollateralStorage storage s, uint256 collateralId)\n    internal\n  {\n    delete s.collateralIdToAuction[collateralId];\n  }\n\n  /**\n   * @dev Mints a new CollateralToken wrapping an NFT.\n   * @param from_ the owner of the collateral deposited\n   * @param tokenId_ The NFT token ID\n   * @return a static return of the receive signature\n   */\n  function onERC721Received(\n    address, /* operator_ */\n    address from_,\n    uint256 tokenId_,\n    bytes calldata // calldata data_\n  ) external override whenNotPaused returns (bytes4) {\n    CollateralStorage storage s = _loadCollateralSlot();\n    uint256 collateralId = msg.sender.computeId(tokenId_);\n\n    Asset memory incomingAsset = s.idToUnderlying[collateralId];\n    if (incomingAsset.tokenContract == address(0)) {\n      require(ERC721(msg.sender).ownerOf(tokenId_) == address(this));\n\n      if (s.clearingHouse[collateralId] == address(0)) {\n        address clearingHouse = ClonesWithImmutableArgs.clone(\n          s.ASTARIA_ROUTER.BEACON_PROXY_IMPLEMENTATION(),\n          abi.encodePacked(\n            address(s.ASTARIA_ROUTER),\n            uint8(IAstariaRouter.ImplementationType.ClearingHouse),\n            collateralId\n          )\n        );\n\n        s.clearingHouse[collateralId] = clearingHouse;\n      }\n      ERC721(msg.sender).safeTransferFrom(\n        address(this),\n        s.clearingHouse[collateralId],\n        tokenId_\n      );\n\n      if (msg.sender == address(this) || msg.sender == address(s.LIEN_TOKEN)) {\n        revert InvalidCollateral();\n      }\n\n      _mint(from_, collateralId);\n\n      s.idToUnderlying[collateralId] = Asset({\n        tokenContract: msg.sender,\n        tokenId: tokenId_\n      });\n\n      emit Deposit721(msg.sender, tokenId_, collateralId, from_);\n      return IERC721Receiver.onERC721Received.selector;\n    } else {\n      revert();\n    }\n  }\n\n  modifier whenNotPaused() {\n    if (_loadCollateralSlot().ASTARIA_ROUTER.paused()) {\n      revert ProtocolPaused();\n    }\n    _;\n  }\n}"
    },
    {
      "filename": "src/ClearingHouse.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {WETH} from \"solmate/tokens/WETH.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {Clone} from \"clones-with-immutable-args/Clone.sol\";\nimport {IERC1155} from \"core/interfaces/IERC1155.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {Bytes32AddressLib} from \"solmate/utils/Bytes32AddressLib.sol\";\nimport {\n  ConduitControllerInterface\n} from \"seaport/interfaces/ConduitControllerInterface.sol\";\nimport {AmountDeriver} from \"seaport/lib/AmountDeriver.sol\";\nimport {Order} from \"seaport/lib/ConsiderationStructs.sol\";\nimport {IERC721Receiver} from \"core/interfaces/IERC721Receiver.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\n\ncontract ClearingHouse is AmountDeriver, Clone, IERC1155, IERC721Receiver {\n  using Bytes32AddressLib for bytes32;\n  using SafeTransferLib for ERC20;\n\n  struct ClearingHouseStorage {\n    ILienToken.AuctionData auctionStack;\n  }\n\n  uint256 private constant CLEARING_HOUSE_STORAGE_SLOT =\n    uint256(keccak256(\"xyz.astaria.ClearingHouse.storage.location\")) - 1;\n\n  function ROUTER() public pure returns (IAstariaRouter) {\n    return IAstariaRouter(_getArgAddress(0));\n  }\n\n  function COLLATERAL_ID() public pure returns (uint256) {\n    return _getArgUint256(21);\n  }\n\n  function IMPL_TYPE() public pure returns (uint8) {\n    return _getArgUint8(20);\n  }\n\n  function _getStorage()\n    internal\n    pure\n    returns (ClearingHouseStorage storage s)\n  {\n    uint256 slot = CLEARING_HOUSE_STORAGE_SLOT;\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  function setAuctionData(ILienToken.AuctionData calldata auctionData)\n    external\n  {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0)); // get the router from the immutable arg\n\n    //only execute from the conduit\n    require(msg.sender == address(ASTARIA_ROUTER.LIEN_TOKEN()));\n\n    ClearingHouseStorage storage s = _getStorage();\n    s.auctionStack = auctionData;\n  }\n\n  function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n    return interfaceId == type(IERC1155).interfaceId;\n  }\n\n  function balanceOf(address account, uint256 id)\n    external\n    view\n    returns (uint256)\n  {\n    return type(uint256).max;\n  }\n\n  function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n    external\n    view\n    returns (uint256[] memory output)\n  {\n    output = new uint256[](accounts.length);\n    for (uint256 i; i < accounts.length; ) {\n      output[i] = type(uint256).max;\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function setApprovalForAll(address operator, bool approved) external {}\n\n  function isApprovedForAll(address account, address operator)\n    external\n    view\n    returns (bool)\n  {\n    return true;\n  }\n\n  function _execute(\n    address tokenContract, // collateral token sending the fake nft\n    address to, // buyer\n    uint256 encodedMetaData, //retrieve token address from the encoded data\n    uint256 // space to encode whatever is needed,\n  ) internal {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0)); // get the router from the immutable arg\n\n    ClearingHouseStorage storage s = _getStorage();\n    address paymentToken = bytes32(encodedMetaData).fromLast20Bytes();\n\n    uint256 currentOfferPrice = _locateCurrentAmount({\n      startAmount: s.auctionStack.startAmount,\n      endAmount: s.auctionStack.endAmount,\n      startTime: s.auctionStack.startTime,\n      endTime: s.auctionStack.endTime,\n      roundUp: true //we are a consideration we round up\n    });\n    uint256 payment = ERC20(paymentToken).balanceOf(address(this));\n\n    require(payment >= currentOfferPrice, \"not enough funds received\");\n\n    uint256 collateralId = _getArgUint256(21);\n    // pay liquidator fees here\n\n    ILienToken.AuctionStack[] storage stack = s.auctionStack.stack;\n\n    uint256 liquidatorPayment = ASTARIA_ROUTER.getLiquidatorFee(payment);\n\n    ERC20(paymentToken).safeTransfer(\n      s.auctionStack.liquidator,\n      liquidatorPayment\n    );\n\n    ERC20(paymentToken).safeApprove(\n      address(ASTARIA_ROUTER.TRANSFER_PROXY()),\n      payment - liquidatorPayment\n    );\n\n    ASTARIA_ROUTER.LIEN_TOKEN().payDebtViaClearingHouse(\n      paymentToken,\n      collateralId,\n      payment - liquidatorPayment,\n      s.auctionStack.stack\n    );\n\n    if (ERC20(paymentToken).balanceOf(address(this)) > 0) {\n      ERC20(paymentToken).safeTransfer(\n        ASTARIA_ROUTER.COLLATERAL_TOKEN().ownerOf(collateralId),\n        ERC20(paymentToken).balanceOf(address(this))\n      );\n    }\n    ASTARIA_ROUTER.COLLATERAL_TOKEN().settleAuction(collateralId);\n  }\n\n  function safeTransferFrom(\n    address from, // the from is the offerer\n    address to,\n    uint256 identifier,\n    uint256 amount,\n    bytes calldata data //empty from seaport\n  ) public {\n    //data is empty and useless\n    _execute(from, to, identifier, amount);\n  }\n\n  function safeBatchTransferFrom(\n    address from,\n    address to,\n    uint256[] calldata ids,\n    uint256[] calldata amounts,\n    bytes calldata data\n  ) public {}\n\n  function onERC721Received(\n    address operator_,\n    address from_,\n    uint256 tokenId_,\n    bytes calldata data_\n  ) external override returns (bytes4) {\n    return IERC721Receiver.onERC721Received.selector;\n  }\n\n  function validateOrder(Order memory order) external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    Order[] memory listings = new Order[](1);\n    listings[0] = order;\n\n    ERC721(order.parameters.offer[0].token).approve(\n      ASTARIA_ROUTER.COLLATERAL_TOKEN().getConduit(),\n      order.parameters.offer[0].identifierOrCriteria\n    );\n    ASTARIA_ROUTER.COLLATERAL_TOKEN().SEAPORT().validate(listings);\n  }\n\n  function transferUnderlying(\n    address tokenContract,\n    uint256 tokenId,\n    address target\n  ) external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    ERC721(tokenContract).safeTransferFrom(address(this), target, tokenId);\n  }\n\n  function settleLiquidatorNFTClaim() external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    ClearingHouseStorage storage s = _getStorage();\n    ASTARIA_ROUTER.LIEN_TOKEN().payDebtViaClearingHouse(\n      address(0),\n      COLLATERAL_ID(),\n      0,\n      s.auctionStack.stack\n    );\n  }\n}"
    },
    {
      "filename": "src/LienToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**"
    }
  ]
}