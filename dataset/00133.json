{
  "Title": "No sanity checks on the grace period setup",
  "Content": "##### Description\nThe grace period can be set to any value without validation:\n- https://github.com/aave-dao/aave-v3-origin/blob/ec60c001358ee6ddf316f79461d21f0a1c3ed7a5/src/core/contracts/protocol/libraries/logic/PoolLogic.sol#L137\n\nA longer grace period setup will leave markets with a worse debt risk. So, the hardcoded limits will allow managing that risk.\n\n##### Recommendation\nWe recommend having an upper limit, e.g., 1 week from the current timestamp.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/core/contracts/protocol/libraries/logic/PoolLogic.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.10;\n\nimport {GPv2SafeERC20} from '../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol';\nimport {Address} from '../../../dependencies/openzeppelin/contracts/Address.sol';\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IAToken} from '../../../interfaces/IAToken.sol';\nimport {ReserveConfiguration} from '../configuration/ReserveConfiguration.sol';\nimport {Errors} from '../helpers/Errors.sol';\nimport {WadRayMath} from '../math/WadRayMath.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\nimport {ReserveLogic} from './ReserveLogic.sol';\nimport {ValidationLogic} from './ValidationLogic.sol';\nimport {GenericLogic} from './GenericLogic.sol';\n\n/**\n * @title PoolLogic library\n * @author Aave\n * @notice Implements the logic for Pool specific functions\n */\nlibrary PoolLogic {\n  using GPv2SafeERC20 for IERC20;\n  using WadRayMath for uint256;\n  using ReserveLogic for DataTypes.ReserveData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n  // See `IPool` for descriptions\n  event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n  /**\n   * @notice Initialize an asset reserve and add the reserve to the list of reserves\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param params Additional parameters needed for initiation\n   * @return true if appended, false if inserted at existing empty spot\n   */\n  function executeInitReserve(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    DataTypes.InitReserveParams memory params\n  ) external returns (bool) {\n    require(Address.isContract(params.asset), Errors.NOT_CONTRACT);\n    reservesData[params.asset].init(\n      params.aTokenAddress,\n      params.stableDebtAddress,\n      params.variableDebtAddress,\n      params.interestRateStrategyAddress\n    );\n\n    bool reserveAlreadyAdded = reservesData[params.asset].id != 0 ||\n      reservesList[0] == params.asset;\n    require(!reserveAlreadyAdded, Errors.RESERVE_ALREADY_ADDED);\n\n    for (uint16 i = 0; i < params.reservesCount; i++) {\n      if (reservesList[i] == address(0)) {\n        reservesData[params.asset].id = i;\n        reservesList[i] = params.asset;\n        return false;\n      }\n    }\n\n    require(params.reservesCount < params.maxNumberReserves, Errors.NO_MORE_RESERVES_ALLOWED);\n    reservesData[params.asset].id = params.reservesCount;\n    reservesList[params.reservesCount] = params.asset;\n    return true;\n  }\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function executeRescueTokens(address token, address to, uint256 amount) external {\n    IERC20(token).safeTransfer(to, amount);\n  }\n\n  /**\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n   * @param reservesData The state of all the reserves\n   * @param assets The list of reserves for which the minting needs to be executed\n   */\n  function executeMintToTreasury(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    address[] calldata assets\n  ) external {\n    for (uint256 i = 0; i < assets.length; i++) {\n      address assetAddress = assets[i];\n\n      DataTypes.ReserveData storage reserve = reservesData[assetAddress];\n\n      // this cover both inactive reserves and invalid reserves since the flag will be 0 for both\n      if (!reserve.configuration.getActive()) {\n        continue;\n      }\n\n      uint256 accruedToTreasury = reserve.accruedToTreasury;\n\n      if (accruedToTreasury != 0) {\n        reserve.accruedToTreasury = 0;\n        uint256 normalizedIncome = reserve.getNormalizedIncome();\n        uint256 amountToMint = accruedToTreasury.rayMul(normalizedIncome);\n        IAToken(reserve.aTokenAddress).mintToTreasury(amountToMint, normalizedIncome);\n\n        emit MintedToTreasury(assetAddress, amountToMint);\n      }\n    }\n  }\n\n  /**\n   * @notice Resets the isolation mode total debt of the given asset to zero\n   * @dev It requires the given asset has zero debt ceiling\n   * @param reservesData The state of all the reserves\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n   */\n  function executeResetIsolationModeTotalDebt(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    address asset\n  ) external {\n    require(reservesData[asset].configuration.getDebtCeiling() == 0, Errors.DEBT_CEILING_NOT_ZERO);\n    reservesData[asset].isolationModeTotalDebt = 0;\n    emit IsolationModeTotalDebtUpdated(asset, 0);\n  }\n\n  /**\n   * @notice Sets the liquidation grace period of the asset\n   * @param reservesData The state of all the reserves\n   * @param asset The address of the underlying asset to set the liquidationGracePeriod\n   * @param until Timestamp when the liquidation grace period will end\n   */\n  function executeSetLiquidationGracePeriod(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    address asset,\n    uint40 until\n  ) external {\n    reservesData[asset].liquidationGracePeriodUntil = until;\n  }\n\n  /**\n   * @notice Drop a reserve\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function executeDropReserve(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    address asset\n  ) external {\n    DataTypes.ReserveData storage reserve = reservesData[asset];\n    ValidationLogic.validateDropReserve(reservesList, reserve, asset);\n    reservesList[reservesData[asset].id] = address(0);\n    delete reservesData[asset];\n  }\n\n  /**\n   * @notice Returns the user account data across all the reserves\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param eModeCategories The configuration of all the efficiency mode categories\n   * @param params Additional params needed for the calculation\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n   * @return currentLiquidationThreshold The liquidation threshold of the user\n   * @return ltv The loan to value of The user\n   * @return healthFactor The current health factor of the user\n   */\n  function executeGetUserAccountData(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n    DataTypes.CalculateUserAccountDataParams memory params\n  )\n    external\n    view\n    returns (\n      uint256 totalCollateralBase,\n      uint256 totalDebtBase,\n      uint256 availableBorrowsBase,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    )\n  {\n    (\n      totalCollateralBase,\n      totalDebtBase,\n      ltv,\n      currentLiquidationThreshold,\n      healthFactor,\n\n    ) = GenericLogic.calculateUserAccountData(reservesData, reservesList, eModeCategories, params);\n\n    availableBorrowsBase = GenericLogic.calculateAvailableBorrows(\n      totalCollateralBase,\n      totalDebtBase,\n      ltv\n    );\n  }\n}"
    }
  ]
}