{
  "Title": "[M-03] The `owner` is a single point of failure and a centralization risk",
  "Content": "_Submitted by [Tera Bot](https://gist.github.com/code423n4/9e80eddfb29953d8b5a424084a54e4ed?permalink_comment_id=4762845#m01-the-owner-is-a-single-point-of-failure-and-a-centralization-risk)_\n\n_Note: this finding was reported via the winning [Automated Findings report](https://gist.github.com/code423n4/9e80eddfb29953d8b5a424084a54e4ed). It was declared out of scope for the audit, but is being included here for completeness._\n\nHaving a single EOA as the only owner of contracts is a large centralization risk and a single point of failure. A single private key may be taken in a hack, or the sole holder of the key may become unable to retrieve the key when necessary. Consider changing to a multi-signature setup, or having a role-based authorization model.\n\n*There are 3 instances of this issue:*\n```solidity\nFile: contracts/Tokens/Prime/PrimeLiquidityProvider.sol\n\n118         function initializeTokens(address[] calldata tokens_) external onlyOwner {\n\n177         function setPrimeToken(address prime_) external onlyOwner {\n\n216         function sweepToken(IERC20Upgradeable token_, address to_, uint256 amount_) external onlyOwner {\n\n```\n*GitHub*: [[118](https://github.com/code-423n4/2023-09-venus/blob/main/contracts/Tokens/Prime/PrimeLiquidityProvider.sol#L118-L118), [177](https://github.com/code-423n4/2023-09-venus/blob/main/contracts/Tokens/Prime/PrimeLiquidityProvider.sol#L177-L177), [216](https://github.com/code-423n4/2023-09-venus/blob/main/contracts/Tokens/Prime/PrimeLiquidityProvider.sol#L216-L216)]\n\n**[chechu (Venus) acknowledged and commented](https://gist.github.com/code423n4/9e80eddfb29953d8b5a424084a54e4ed?permalink_comment_id=4762845#gistcomment-4762845):**\n >Regarding [Mâ€‘03] The owner is a single point of failure and a centralization risk, the owner won't be an EOA, but that cannot be specified in the solidity code. The owner of our contracts is always the Normal Timelock contract deployed at 0x939bD8d64c0A9583A7Dcea9933f7b21697ab6396. This contract is used in the Governance process, so after a voting period of 24 hours, and an extra delay of 48 hours if the vote passed, this contract will execute the commands agreed on the Venus Improvement Proposal.\n\n**[0xDjango (Judge) commented](https://gist.github.com/code423n4/9e80eddfb29953d8b5a424084a54e4ed?permalink_comment_id=4762962#gistcomment-4762962):**\n >Confirming medium severity for centralization risk, though Venus does has safeguards in place to ensure that decentralization is achieved through governance. From a user-perspective, the potentiality of centralization risks must be highlighted.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-09-venus",
  "Code": [
    {
      "filename": "contracts/Tokens/Prime/PrimeLiquidityProvider.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport { SafeERC20Upgradeable, IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { AccessControlledV8 } from \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\ncontract PrimeLiquidityProvider is AccessControlledV8, PausableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice The max token distribution speed\n    uint256 public constant MAX_DISTRIBUTION_SPEED = 1e18;\n\n    /// @notice exp scale\n    uint256 internal constant EXP_SCALE = 1e18;\n\n    /// @notice Address of the Prime contract\n    address public prime;\n\n    /// @notice The rate at which token is distributed (per block)\n    mapping(address => uint256) public tokenDistributionSpeeds;\n\n    /// @notice The rate at which token is distributed to the Prime contract\n    mapping(address => uint256) public lastAccruedBlock;\n\n    /// @notice The token accrued but not yet transferred to prime contract\n    mapping(address => uint256) public tokenAmountAccrued;\n\n    /// @notice Emitted when a token distribution is initialized\n    event TokenDistributionInitialized(address indexed token);\n\n    /// @notice Emitted when a new token distribution speed is set\n    event TokenDistributionSpeedUpdated(address indexed token, uint256 newSpeed);\n\n    /// @notice Emitted when prime token contract address is changed\n    event PrimeTokenUpdated(address oldPrimeToken, address newPrimeToken);\n\n    /// @notice Emitted when distribution state(Index and block) is updated\n    event TokensAccrued(address indexed token, uint256 amount);\n\n    /// @notice Emitted when token is transferred to the prime contract\n    event TokenTransferredToPrime(address indexed token, uint256 amount);\n\n    /// @notice Emitted on sweep token success\n    event SweepToken(address indexed token, address indexed to, uint256 sweepAmount);\n\n    /// @notice Emitted on updation of initial balance for token\n    event TokenInitialBalanceUpdated(address indexed token, uint256 balance);\n\n    /// @notice Emitted when funds transfer is paused\n    event FundsTransferPaused();\n\n    /// @notice Emitted when funds transfer is resumed\n    event FundsTransferResumed();\n\n    /// @notice Thrown when arguments are passed are invalid\n    error InvalidArguments();\n\n    /// @notice Thrown when distribution speed is greater than MAX_DISTRIBUTION_SPEED\n    error InvalidDistributionSpeed(uint256 speed, uint256 maxSpeed);\n\n    /// @notice Thrown when caller is not the desired caller\n    error InvalidCaller();\n\n    /// @notice Thrown when token is initialized\n    error TokenAlreadyInitialized(address token);\n\n    ///@notice Error thrown when PrimeLiquidityProvider's balance is less than sweep amount\n    error InsufficientBalance(uint256 sweepAmount, uint256 balance);\n\n    /// @notice Error thrown when funds transfer is paused\n    error FundsTransferIsPaused();\n\n    /// @notice Error thrown when intrest accrue is called for not initialized token\n    error TokenNotInitialized(address token_);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice PrimeLiquidityProvider initializer\n     * @dev Initializes the deployer to owner\n     * @param accessControlManager_ AccessControlManager contract address\n     * @param tokens_ Array of addresses of the tokens\n     * @param distributionSpeeds_ New distribution speeds for tokens\n     * @custom:error Throw InvalidArguments on different length of tokens and speeds array\n     */\n    function initialize(\n        address accessControlManager_,\n        address[] calldata tokens_,\n        uint256[] calldata distributionSpeeds_\n    ) external initializer {\n        __AccessControlled_init(accessControlManager_);\n        __Pausable_init();\n\n        uint256 numTokens = tokens_.length;\n        if (numTokens != distributionSpeeds_.length) {\n            revert InvalidArguments();\n        }\n\n        for (uint256 i; i < numTokens; ) {\n            _initializeToken(tokens_[i]);\n            _setTokenDistributionSpeed(tokens_[i], distributionSpeeds_[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Initialize the distribution of the token\n     * @param tokens_ Array of addresses of the tokens to be intialized\n     * @custom:access Only Governance\n     */\n    function initializeTokens(address[] calldata tokens_) external onlyOwner {\n        for (uint256 i; i < tokens_.length; ) {\n            _initializeToken(tokens_[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Pause fund transfer of tokens to Prime contract\n     * @custom:access Controlled by ACM\n     */\n    function pauseFundsTransfer() external {\n        _checkAccessAllowed(\"pauseFundsTransfer()\");\n        _pause();\n    }\n\n    /**\n     * @notice Resume fund transfer of tokens to Prime contract\n     * @custom:access Controlled by ACM\n     */\n    function resumeFundsTransfer() external {\n        _checkAccessAllowed(\"resumeFundsTransfer()\");\n        _unpause();\n    }\n\n    /**\n     * @notice Set distribution speed (amount of token distribute per block)\n     * @param tokens_ Array of addresses of the tokens\n     * @param distributionSpeeds_ New distribution speeds for tokens\n     * @custom:access Controlled by ACM\n     * @custom:error Throw InvalidArguments on different length of tokens and speeds array\n     */\n    function setTokensDistributionSpeed(address[] calldata tokens_, uint256[] calldata distributionSpeeds_) external {\n        _checkAccessAllowed(\"setTokensDistributionSpeed(address[],uint256[])\");\n        uint256 numTokens = tokens_.length;\n\n        if (numTokens != distributionSpeeds_.length) {\n            revert InvalidArguments();\n        }\n\n        for (uint256 i; i < numTokens; ) {\n            _ensureTokenInitialized(tokens_[i]);\n            _setTokenDistributionSpeed(tokens_[i], distributionSpeeds_[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Set the prime token contract address\n     * @param prime_ The new address of the prime token contract\n     * @custom:event Emits PrimeTokenUpdated event\n     * @custom:access Only owner\n     */\n    function setPrimeToken(address prime_) external onlyOwner {\n        _ensureZeroAddress(prime_);\n\n        emit PrimeTokenUpdated(prime, prime_);\n        prime = prime_;\n    }\n\n    /**\n     * @notice Claim all the token accrued till last block\n     * @param token_ The token to release to the Prime contract\n     * @custom:event Emits TokenTransferredToPrime event\n     * @custom:error Throw InvalidArguments on Zero address(token)\n     * @custom:error Throw FundsTransferIsPaused is paused\n     * @custom:error Throw InvalidCaller if the sender is not the Prime contract\n     */\n    function releaseFunds(address token_) external {\n        if (msg.sender != prime) revert InvalidCaller();\n        if (paused()) {\n            revert FundsTransferIsPaused();\n        }\n\n        accrueTokens(token_);\n        uint256 accruedAmount = tokenAmountAccrued[token_];\n        tokenAmountAccrued[token_] = 0;\n\n        emit TokenTransferredToPrime(token_, accruedAmount);\n\n        IERC20Upgradeable(token_).safeTransfer(prime, accruedAmount);\n    }\n\n    /**\n     * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to user\n     * @param token_ The address of the ERC-20 token to sweep\n     * @param to_ The address of the recipient\n     * @param amount_ The amount of tokens needs to transfer\n     * @custom:event Emits SweepToken event\n     * @custom:error Throw InsufficientBalance if amount_ is greater than the available balance of the token in the contract\n     * @custom:access Only Governance\n     */\n    function sweepToken(IERC20Upgradeable token_, address to_, uint256 amount_) external onlyOwner {\n        uint256 balance = token_.balanceOf(address(this));\n        if (amount_ > balance) {\n            revert InsufficientBalance(amount_, balance);\n        }\n\n        emit SweepToken(address(token_), to_, amount_);\n\n        token_.safeTransfer(to_, amount_);\n    }\n\n    /**\n     * @notice Get rewards per block for token\n     * @param token_ Address of the token\n     * @return speed returns the per block reward\n     */\n    function getEffectiveDistributionSpeed(address token_) external view returns (uint256) {\n        uint256 distributionSpeed = tokenDistributionSpeeds[token_];\n        uint256 balance = IERC20Upgradeable(token_).balanceOf(address(this));\n        uint256 accrued = tokenAmountAccrued[token_];\n\n        if (balance - accrued > 0) {\n            return distributionSpeed;\n        }\n\n        return 0;\n    }\n\n    /**\n     * @notice Accrue token by updating the distribution state\n     * @param token_ Address of the token\n     * @custom:event Emits TokensAccrued event\n     */\n    function accrueTokens(address token_) public {\n        _ensureZeroAddress(token_);\n\n        _ensureTokenInitialized(token_);\n\n        uint256 blockNumber = getBlockNumber();\n        uint256 deltaBlocks = blockNumber - lastAccruedBlock[token_];\n\n        if (deltaBlocks > 0) {\n            uint256 distributionSpeed = tokenDistributionSpeeds[token_];\n            uint256 balance = IERC20Upgradeable(token_).balanceOf(address(this));\n\n            uint256 balanceDiff = balance - tokenAmountAccrued[token_];\n            if (distributionSpeed > 0 && balanceDiff > 0) {\n                uint256 accruedSinceUpdate = deltaBlocks * distributionSpeed;\n                uint256 tokenAccrued = (balanceDiff <= accruedSinceUpdate ? balanceDiff : accruedSinceUpdate);\n\n                tokenAmountAccrued[token_] += tokenAccrued;\n                emit TokensAccrued(token_, tokenAccrued);\n            }\n\n            lastAccruedBlock[token_] = blockNumber;\n        }\n    }\n\n    /// @notice Get the latest block number\n    /// @return blockNumber returns the block number\n    function getBlockNumber() public view virtual returns (uint256) {\n        return block.number;\n    }\n\n    /**\n     * @notice Initialize the distribution of the token\n     * @param token_ Address of the token to be intialized\n     * @custom:event Emits TokenDistributionInitialized event\n     * @custom:error Throw TokenAlreadyInitialized if token is already initialized\n     */\n    function _initializeToken(address token_) internal {\n        _ensureZeroAddress(token_);\n        uint256 blockNumber = getBlockNumber();\n        uint256 initializedBlock = lastAccruedBlock[token_];\n\n        if (initializedBlock > 0) {\n            revert TokenAlreadyInitialized(token_);\n        }\n\n        /*\n         * Update token state block number\n         */\n        lastAccruedBlock[token_] = blockNumber;\n\n        emit TokenDistributionInitialized(token_);\n    }\n\n    /**\n     * @notice Set distribution speed (amount of token distribute per block)\n     * @param token_ Address of the token\n     * @param distributionSpeed_ New distribution speed for token\n     * @custom:event Emits TokenDistributionSpeedUpdated event\n     * @custom:error Throw InvalidDistributionSpeed if speed is greater than max speed\n     */\n    function _setTokenDistributionSpeed(address token_, uint256 distributionSpeed_) internal {\n        if (distributionSpeed_ > MAX_DISTRIBUTION_SPEED) {\n            revert InvalidDistributionSpeed(distributionSpeed_, MAX_DISTRIBUTION_SPEED);\n        }\n\n        if (tokenDistributionSpeeds[token_] != distributionSpeed_) {\n            // Distribution speed updated so let's update distribution state to ensure that\n            //  1. Token accrued properly for the old speed, and\n            //  2. Token accrued at the new speed starts after this block.\n            accrueTokens(token_);\n\n            // Update speed\n            tokenDistributionSpeeds[token_] = distributionSpeed_;\n\n            emit TokenDistributionSpeedUpdated(token_, distributionSpeed_);\n        }\n    }\n\n    /**\n     * @notice Revert on non initialized token\n     * @param token_ Token Address to be verified for\n     */\n    function _ensureTokenInitialized(address token_) internal view {\n        uint256 lastBlockAccrued = lastAccruedBlock[token_];\n\n        if (lastBlockAccrued == 0) {\n            revert TokenNotInitialized(token_);\n        }\n    }\n\n    /**\n     * @notice Revert on zero address\n     * @param address_ Address to be verified\n     */\n    function _ensureZeroAddress(address address_) internal pure {\n        if (address_ == address(0)) {\n            revert InvalidArguments();\n        }\n    }\n}"
    }
  ]
}