{
  "Title": "[05] Function `generateSentAssetKeys()` can revert",
  "Content": "\nThe function `generateSentAssetKeys()` can revert on `uint128 newArrayLength = oldArrayLength - 1`. This only happens when the data is already corrupt. However, in this case, no useful error/revert message is given.\n\n### Proof of Concept\n[LSP5Utils.sol#L117-L137](https://github.com/lukso-network/lsp-smart-contracts/blob/32ad32f942888398bf99b039e98e238c3146c1b3/contracts/LSP5ReceivedAssets/LSP5Utils.sol#L117-L137)\n```solidity\nfunction generateSentAssetKeys(...) ... {\n    ...\n    uint128 oldArrayLength = uint128(bytes16(lsp5ReceivedAssetsCountValue));\n\n    // Updating the number of the received assets (decrementing by 1\n    uint128 newArrayLength = oldArrayLength - 1;  // could revert (only when data is already corrupt)\n    ...\n}\n```\n\n### Recommended Mitigation Steps\nConsider an extra check, for example, in the following way:\n```diff\nfunction generateSentAssetKeys(...) ... {\n    ...\n    uint128 oldArrayLength = uint128(bytes16(lsp5ReceivedAssetsCountValue));\n+   if (oldArrayLength == 0) revert Invalidlsp5ReceivedAssetsCountValue();\n    // Updating the number of the received assets (decrementing by 1\n    uint128 newArrayLength = oldArrayLength - 1;  // could revert (only when data is already corrupt)\n    ...\n}\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-06-lukso",
  "Code": [
    {
      "filename": "contracts/LSP5ReceivedAssets/LSP5Utils.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\n// interfaces\nimport {\n    IERC725Y\n} from \"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol\";\n\n// libraries\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport {LSP2Utils} from \"../LSP2ERC725YJSONSchema/LSP2Utils.sol\";\n\n// constants\nimport \"../LSP5ReceivedAssets/LSP5Constants.sol\";\nimport \"../LSP7DigitalAsset/LSP7Constants.sol\";\n\n/**\n * @dev reverts when the value stored under the 'LSP5ReceivedAssets[]' data key is not valid.\n *      The value stored under this data key should be exactly 16 bytes long.\n *\n *      Only possible valid values are:\n *      - any valid uint128 values\n *          i.e. 0x00000000000000000000000000000000 (zero), empty array, no assets received.\n *          i.e. 0x00000000000000000000000000000005 (non-zero), 5 array elements, 5 assets received.\n *\n *      - 0x (nothing stored under this data key, equivalent to empty array)\n *\n * @param invalidValueStored the invalid value stored under the LSP5ReceivedAssets[] data key\n * @param invalidValueLength the invalid number of bytes stored under the LSP5ReceivedAssets[] data key (MUST be exactly 16 bytes long)\n */\nerror InvalidLSP5ReceivedAssetsArrayLength(\n    bytes invalidValueStored,\n    uint256 invalidValueLength\n);\n\n/**\n * @dev reverts when the `LSP5ReceivedAssets[]` array reaches its maximum limit (max(uint128))\n * @param notRegisteredAsset the address of the asset that could not be registered\n */\nerror MaxLSP5ReceivedAssetsCountReached(address notRegisteredAsset);\n\n/**\n * @dev reverts when the received assets index is superior to uint128\n * @param index the received assets index\n */\nerror ReceivedAssetsIndexSuperiorToUint128(uint256 index);\n\n/**\n * @title LSP5Utils\n * @author Yamen Merhi <YamenMerhi>, Jean Cavallera <CJ42>\n * @dev LSP5Utils is a library of functions that are used to register and manage assets received by an ERC725Y smart contract\n *      based on the LSP5 - Received Assets standard\n *      https://github.com/lukso-network/LIPs/blob/main/LSPs/LSP-5-ReceivedAssets.md\n */\nlibrary LSP5Utils {\n    /**\n     * @dev Generating the data keys/values to be set on the receiver address after receiving assets\n     * @param receiver The address receiving the asset and where the Keys should be added\n     * @param asset The address of the asset being received\n     * @param assetMapKey The map key of the asset being received containing the interfaceId of the\n     * asset and the index in the array\n     * @param interfaceID The interfaceID of the asset being received\n     */\n    function generateReceivedAssetKeys(\n        address receiver,\n        address asset,\n        bytes32 assetMapKey,\n        bytes4 interfaceID\n    ) internal view returns (bytes32[] memory keys, bytes[] memory values) {\n        keys = new bytes32[](3);\n        values = new bytes[](3);\n\n        IERC725Y account = IERC725Y(receiver);\n        bytes memory encodedArrayLength = getLSP5ReceivedAssetsCount(account);\n\n        // CHECK it's either the first asset received,\n        // or the storage is already set with a valid `uint128` value\n        if (encodedArrayLength.length != 0 && encodedArrayLength.length != 16) {\n            revert InvalidLSP5ReceivedAssetsArrayLength({\n                invalidValueStored: encodedArrayLength,\n                invalidValueLength: encodedArrayLength.length\n            });\n        }\n\n        uint128 oldArrayLength = uint128(bytes16(encodedArrayLength));\n\n        if (oldArrayLength == type(uint128).max) {\n            revert MaxLSP5ReceivedAssetsCountReached({\n                notRegisteredAsset: asset\n            });\n        }\n\n        // store the number of received assets incremented by 1\n        keys[0] = _LSP5_RECEIVED_ASSETS_ARRAY_KEY;\n        values[0] = bytes.concat(bytes16(oldArrayLength + 1));\n\n        // store the address of the asset under the element key in the array\n        keys[1] = LSP2Utils.generateArrayElementKeyAtIndex(\n            _LSP5_RECEIVED_ASSETS_ARRAY_KEY,\n            oldArrayLength\n        );\n        values[1] = bytes.concat(bytes20(asset));\n\n        // store the interfaceId and the location in the array of the asset\n        // under the LSP5ReceivedAssetMap key\n        keys[2] = assetMapKey;\n        values[2] = bytes.concat(interfaceID, bytes16(oldArrayLength));\n    }\n\n    /**\n     * @dev Generating the data keys/values to be set on the sender address after sending assets\n     * @param sender The address sending the asset and where the Keys should be updated\n     * @param assetMapKey The map key of the asset being received containing the interfaceId of the\n     * asset and the index in the array\n     * @param assetIndex The index in the LSP5ReceivedAssets[] array\n     */\n    function generateSentAssetKeys(\n        address sender,\n        bytes32 assetMapKey,\n        uint128 assetIndex\n    ) internal view returns (bytes32[] memory keys, bytes[] memory values) {\n        IERC725Y account = IERC725Y(sender);\n        bytes memory lsp5ReceivedAssetsCountValue = getLSP5ReceivedAssetsCount(\n            account\n        );\n\n        if (lsp5ReceivedAssetsCountValue.length != 16) {\n            revert InvalidLSP5ReceivedAssetsArrayLength({\n                invalidValueStored: lsp5ReceivedAssetsCountValue,\n                invalidValueLength: lsp5ReceivedAssetsCountValue.length\n            });\n        }\n\n        uint128 oldArrayLength = uint128(bytes16(lsp5ReceivedAssetsCountValue));\n\n        // Updating the number of the received assets (decrementing by 1\n        uint128 newArrayLength = oldArrayLength - 1;\n\n        // Generate the element key in the array of the asset\n        bytes32 assetInArrayKey = LSP2Utils.generateArrayElementKeyAtIndex(\n            _LSP5_RECEIVED_ASSETS_ARRAY_KEY,\n            assetIndex\n        );\n\n        // If the asset to remove is the last element in the array\n        if (assetIndex == newArrayLength) {\n            /**\n             * We will be updating/removing 3 keys:\n             * - Keys[0]: [Update] The arrayLengthKey to contain the new number of the received assets\n             * - Keys[1]: [Remove] The element in arrayKey (Remove the address of the asset sent)\n             * - Keys[2]: [Remove] The mapKey (Remove the interfaceId and the index of the asset sent)\n             */\n            keys = new bytes32[](3);\n            values = new bytes[](3);\n\n            // store the number of received assets decremented by 1\n            keys[0] = _LSP5_RECEIVED_ASSETS_ARRAY_KEY;\n            values[0] = bytes.concat(bytes16(newArrayLength));\n\n            // remove the address of the asset from the element key\n            keys[1] = assetInArrayKey;\n            values[1] = \"\";\n\n            // remove the interfaceId and the location in the array of the asset\n            keys[2] = assetMapKey;\n            values[2] = \"\";\n\n            // Swapping last element in ArrayKey with the element in ArrayKey to remove || {Swap and pop} method;\n            // check https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol#L80\n        } else if (assetIndex < newArrayLength) {\n            /**\n             * We will be updating/removing 5 keys:\n             * - Keys[0]: [Update] The arrayLengthKey to contain the new number of the received assets\n             * - Keys[1]: [Remove] The mapKey of the asset to remove (Remove the interfaceId and the index of the asset sent)\n             * - Keys[2]: [Update] The element in arrayKey to remove (Swap with the address of the last element in Array)\n             * - Keys[3]: [Remove] The last element in arrayKey (Remove (pop) the address of the last element as it's already swapped)\n             * - Keys[4]: [Update] The mapKey of the last element in array (Update the new index and the interfaceID)\n             */\n            keys = new bytes32[](5);\n            values = new bytes[](5);\n\n            // store the number of received assets decremented by 1\n            keys[0] = _LSP5_RECEIVED_ASSETS_ARRAY_KEY;\n            values[0] = bytes.concat(bytes16(newArrayLength));\n\n            // remove the interfaceId and the location in the array of the asset\n            keys[1] = assetMapKey;\n            values[1] = \"\";\n\n            if (newArrayLength >= type(uint128).max) {\n                revert ReceivedAssetsIndexSuperiorToUint128(newArrayLength);\n            }\n\n            // Generate all data Keys/values of the last element in Array to swap\n            // with data Keys/values of the asset to remove\n\n            // Generate the element key of the last asset in the array\n            bytes32 lastAssetInArrayKey = LSP2Utils\n                .generateArrayElementKeyAtIndex(\n                    _LSP5_RECEIVED_ASSETS_ARRAY_KEY,\n                    newArrayLength\n                );\n\n            // Get the address of the asset from the element key of the last asset in the array\n            bytes20 lastAssetInArrayAddress = bytes20(\n                account.getData(lastAssetInArrayKey)\n            );\n\n            // Generate the map key of the last asset in the array\n            bytes32 lastAssetInArrayMapKey = LSP2Utils.generateMappingKey(\n                _LSP5_RECEIVED_ASSETS_MAP_KEY_PREFIX,\n                lastAssetInArrayAddress\n            );\n\n            // Get the interfaceId and the location in the array of the last asset\n            bytes memory lastAssetInterfaceIdAndIndex = account.getData(\n                lastAssetInArrayMapKey\n            );\n            bytes memory interfaceID = BytesLib.slice(\n                lastAssetInterfaceIdAndIndex,\n                0,\n                4\n            );\n\n            // Set the address of the last asset instead of the asset to be sent\n            // under the element data key in the array\n            keys[2] = assetInArrayKey;\n            values[2] = bytes.concat(lastAssetInArrayAddress);\n\n            // Remove the address swapped from the last element data key in the array\n            keys[3] = lastAssetInArrayKey;\n            values[3] = \"\";\n\n            // Update the index and the interfaceId of the address swapped (last element in the array)\n            // to point to the new location in the LSP5ReceivedAssets array\n            keys[4] = lastAssetInArrayMapKey;\n            values[4] = bytes.concat(interfaceID, bytes16(assetIndex));\n        } else {\n            // If index is bigger than the array length, out of bounds\n            return (keys, values);\n        }\n    }\n\n    function getLSP5ReceivedAssetsCount(\n        IERC725Y account\n    ) internal view returns (bytes memory) {\n        return account.getData(_LSP5_RECEIVED_ASSETS_ARRAY_KEY);\n    }\n}"
    }
  ]
}