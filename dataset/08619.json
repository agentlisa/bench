{
  "Title": "[M-03] User Could Change The State Of The System While In Pause Mode",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L443\n\n\n# Vulnerability details\n\n## Proof-of-Concept\n\nCalling `NibblVault.updateTWAP` function will change the state of the system. It will cause the TWAP to be updated and buyout to be rejected in certain condition.\n\nWhen the system is in `Pause` mode, the system state should be frozen. However, it was possible someone to call the `NibblVault.updateTWAP` function during the `Pause` mode, thus making changes to the system state.\n\n[https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L443](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L443)\n\n```solidity\n/// @notice Updates the TWAV when in buyout\n/// @dev TWAV can be updated only in buyout state\nfunction updateTWAV() external override {\n    require(status == Status.buyout, \"NibblVault: Status!=Buyout\");\n    uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n    if (_blockTimestamp != lastBlockTimeStamp) {\n        _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n        _rejectBuyout(); //For the case when TWAV goes up when updated externally\n    }\n}\n```\n\n## Recommended Mitigation Steps\n\nEnsure that the `NibblVault.updateVault` function cannot be called when the system is in `Pause` mode.\n\nAdd the `whenNotPaused` modifier to the function.\n\n```solidity\n/// @notice Updates the TWAV when in buyout\n/// @dev TWAV can be updated only in buyout state\nfunction updateTWAV() external override whenNotPaused {\n    require(status == Status.buyout, \"NibblVault: Status!=Buyout\");\n    uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n    if (_blockTimestamp != lastBlockTimeStamp) {\n        _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n        _rejectBuyout(); //For the case when TWAV goes up when updated externally\n    }\n}\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-06-nibbl-contest",
  "Code": [
    {
      "filename": "contracts/NibblVault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\n\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { BancorFormula } from \"./Bancor/BancorFormula.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { NibblVaultFactory } from \"./NibblVaultFactory.sol\";\nimport { Twav } from \"./Twav/Twav.sol\";\nimport { EIP712Base } from \"./Utilities/EIP712Base.sol\";\nimport { INibblVault } from \"./Interfaces/INibblVault.sol\";\n\n/// @title Vault to lock NFTs and fractionalize ERC721 to ERC20.\n/// @dev This contract uses Bancor Formula to create an automated market for fractionalized ERC20s.\n/// @dev This contract creates 2 bonding curves, referred to as primary curve and secondary curve.\n/// @dev The primary curve has fixed specifications and reserveRatio.\n/// @dev The secondary curve is dynamic and has a variable reserveRatio, which depends on initial conditions given by the curator and the fee accumulated by the curve.\ncontract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base {\n\n    /// @notice Scale for calculations to avoid rounding errors\n    uint256 private constant SCALE = 1_000_000; \n\n    /// @notice Reserve ratio of primary curve \n    /// @dev primaryReserveRatio has been multiplied with SCALE\n    /// @dev primaryReserveRatio lies between 0 and 1_000_000, 500_000 is equivalent to 50% reserve ratio\n    uint32 private constant primaryReserveRatio = 200_000; //20%\n    \n    /// @notice The premium percentage above the buyoutBid at which the buyout is rejected\n    /// @dev REJECTION_PREMIUM has been multiplied with SCALE\n    /// @dev REJECTION_PREMIUM lies between 0 and 1_000_000, i.e. 100_000 means 10%\n    /// @dev if REJECTION_PREMIUM is 15% and the buyoutBid is 100, then the buyout is rejected when the valuation reaches 115\n    uint256 private constant REJECTION_PREMIUM = 150_000; //15%\n\n    /// @notice The days until which a buyout bid is valid, if the bid isn't rejected in buyout duration time, its automatically considered boughtOut\n    uint256 private constant BUYOUT_DURATION = 5 days; \n\n    /// @notice The percentage of fee that goes for liquidity in lower curve until its reserve ratio becomes equal to primaryReserveRatio\n    uint256 private constant CURVE_FEE = 4_000;\n\n    /// @notice minimum reserve ratio that the secondary curve can have initially \n    uint256 private constant MIN_SECONDARY_RESERVE_RATIO = 50_000;\n\n    /// @notice minimum curator fee that the curator will get on adding minimal liquidity to the secondary curve\n    uint256 private constant MIN_CURATOR_FEE = 5_000; //0.5%\n\n    /// @notice minimum reserve balance that the secondary curve can have initially \n    uint256 private constant MIN_SECONDARY_RESERVE_BALANCE = 1e9;\n\n    bytes32 private constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n\n    /// @notice The reserve ratio of the secondary curve.\n    /// @dev secondaryReserveRatio has been multiplied with SCALE\n    /// @dev secondary reserve ratio is dynamic and it can be <= primaryReserveRatio\n    uint32 public secondaryReserveRatio;\n\n    /// @notice address of the factory contract\n    address payable public factory;\n\n    /// @notice address of the original NFT owner\n    address public curator; \n\n    /// @notice token address of the NFT being deposited in the vault\n    address public assetAddress;\n\n    /// @notice token ID of the NFT being deposited in the vault  \n    uint256 public assetID;\n\n    /// @notice address which triggered the buyout\n    address public bidder; \n\n    /// @notice initial price of the fractional ERC20 Token set by the curator\n    uint256 public initialTokenPrice;\n\n    /// @notice fictitious primary reserve balance, this is used for calculation purposes of trading on primary bonding curve.\n    /// @dev This variable defines the amount of reserve token that should be in the secondary curve if secondaryReserveRatio == primaryReserveRatio\n    /// @dev This variable also defines the amount of reserve token that should be in the primary curve if the primary curve started from 0 and went till initialTokenSupply \n    uint256 public fictitiousPrimaryReserveBalance;\n\n    /// @notice the valuation at which the buyout is rejected.\n    uint256 public buyoutRejectionValuation; \n    \n    /// @notice deposit made by bidder to initiate buyout \n    /// @dev buyoutValuationDeposit = currentValuation - ((reserveTokens in primary curve) + (reserveTokens in secondary curve))\n    uint256 public buyoutValuationDeposit; \n    \n    /// @notice initial token supply minted by curator\n    uint256 public initialTokenSupply; \n    \n    /// @notice reserve balance of the primary curve\n    uint256 public primaryReserveBalance;\n    \n    /// @notice reserve balance of the secondary curve\n    uint256 public secondaryReserveBalance;\n    \n    /// @notice total value of unclaimed fees accrued to the curator via trading on the bonding curve\n    uint256 public feeAccruedCurator; \n    \n    /// @notice the time at which the current buyout ends\n    uint256 public buyoutEndTime; \n    \n    /// @notice valuation at which the buyout was triggered\n    uint256 public buyoutBid;\n\n    /// @notice percentage of trading fee on the bonding curve that goes to the curator\n    uint256 public curatorFee;\n\n    /// @notice total value of unclaimed buyout bids\n    uint256 public totalUnsettledBids; \n\n    /// @notice minimum time after which buyout can be triggered\n    uint256 public minBuyoutTime;\n\n    /// @notice mapping of buyout bidders and their respective unsettled bids\n    mapping(address => uint256) public unsettledBids; \n    mapping(address => uint256) public nonces; \n    \n    enum Status {initialized, buyout}\n\n    ///@notice current status of vault\n    Status public status;\n\n    ///@notice reenterancy guard\n    uint256 private unlocked = 2;\n\n    modifier lock() {\n        require(unlocked == 1, 'NibblVault: LOCKED');\n        unlocked = 2;\n        _;\n        unlocked = 1;\n    }\n\n\n    /// @notice To check if buyout hasn't succeeded\n    /// @dev Check for the case when buyoutTime has not passed or buyout has been rejected\n    modifier notBoughtOut() {\n        require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out');\n        _;\n    }\n\n    /// @notice To check if buyout has succeeded\n    /// @dev For the case when buyoutTime has passed and buyout has not been rejected\n    modifier boughtOut() {\n        require(status == Status.buyout, \"NibblVault: status != buyout\");\n        require(buyoutEndTime <= block.timestamp, \"NibblVault: buyoutEndTime <= now\");\n        _;\n    }\n\n    /// @notice To check if system isn't paused\n    /// @dev pausablity implemented in factory\n    modifier whenNotPaused() {\n        require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused');\n        _;\n    }\n\n    /// @notice the function to initialize proxy vault parameters\n    /// @param _tokenName name of the fractionalized ERC20 token to be created\n    /// @param _tokenSymbol symbol of the fractionalized ERC20 token\n    /// @param _assetAddress address of the ERC721 being fractionalized\n    /// @param _assetID tokenId of the ERC721 being fractionalized\n    /// @param _curator owner of the asset getting fractionalized\n    /// @param _initialTokenSupply desired initial supply to be minted to curator\n    /// @param _initialTokenPrice desired initial token price set by curator \n    /// @param  _minBuyoutTime minimum time after which buyout can be triggered \n    /// @dev valuation = price * supply\n    /// @dev reserveBalance = valuation * reserveRatio\n    /// @dev Reserve Ratio = Reserve Token Balance / (Continuous Token Supply x Continuous Token Price)\n    /// @dev curatorFee is proportional to initialLiquidity added by user. \n    /// @dev curatorFee can be maximum of 2 * MinimumCuratorFee.\n\n    function initialize(\n        string memory _tokenName, \n        string memory _tokenSymbol, \n        address _assetAddress,\n        uint256 _assetID,\n        address _curator,\n        uint256 _initialTokenSupply,\n        uint256 _initialTokenPrice,\n        uint256 _minBuyoutTime\n    ) external override initializer payable {\n        uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));\n        require(_secondaryReserveRatio <= primaryReserveRatio, \"NibblVault: Excess initial funds\");\n        require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, \"NibblVault: secResRatio too low\");\n        INIT_EIP712(\"NibblVault\", \"1\");\n        __ERC20_init(_tokenName, _tokenSymbol);\n        unlocked = 1;\n        initialTokenPrice=_initialTokenPrice;\n        factory = payable(msg.sender);\n        assetAddress = _assetAddress;\n        assetID = _assetID;\n        curator = _curator;\n        initialTokenSupply = _initialTokenSupply;\n        uint _primaryReserveBalance = (primaryReserveRatio * _initialTokenSupply * _initialTokenPrice) / (SCALE * 1e18);\n        primaryReserveBalance = _primaryReserveBalance;\n        fictitiousPrimaryReserveBalance = _primaryReserveBalance;\n        secondaryReserveBalance = msg.value;\n        secondaryReserveRatio = _secondaryReserveRatio;\n        //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n        curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n        minBuyoutTime = _minBuyoutTime;\n        _mint(_curator, _initialTokenSupply);\n    }\n\n    /// @notice Function used to charge fee on trades\n    /// @dev There are 3 different fees charged - admin, curator and curve\n    /// @dev Admin fee percentage is fetched from the factory contract and the fee charged is transferred to factory contract\n    /// @dev Curator fee is fetched from curatorFee variable and total fee accrued is stored in feeAccruedCurator variable\n    /// @dev Curve fee is fetched from the CURVE_FEE variable and is added to the secondaryReserveBalance variable\n    /// @param _amount amount to charge fee on either a buy or sell order, fee is charged in reserve token\n    /// @return the amount after fee is deducted\n    function _chargeFee(uint256 _amount) private returns(uint256) {\n        address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        uint256 _feeCurve = (_amount * CURVE_FEE) / SCALE ;\n        feeAccruedCurator += _feeCurator;\n        //_maxSecondaryBalanceIncrease: is the max amount of secondary reserve balance that can be added to the vault\n        //_maxSecondaryBalanceIncrease cannot be more than fictitiousPrimaryReserveBalance\n        uint256 _maxSecondaryBalanceIncrease = fictitiousPrimaryReserveBalance - secondaryReserveBalance;\n        // _feeCurve can't be higher than _maxSecondaryBalanceIncrease\n        _feeCurve = _maxSecondaryBalanceIncrease > _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance\n        secondaryReserveBalance += _feeCurve;\n        secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade \n        if(_adminFeeAmt > 0) {\n            safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n        }\n        return _amount - (_feeAdmin + _feeCurator + _feeCurve);\n    }\n\n    /// @notice Function to charge fee in secondary curve\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @param _amount amount to charge fee on trade order, fee is charged in reserve token\n    /// @return amount of tokens after fee is deducted\n    function _chargeFeeSecondaryCurve(uint256 _amount) private returns(uint256) {\n       address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        feeAccruedCurator += _feeCurator;\n        if(_adminFeeAmt > 0) {\n            safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n        }\n        return _amount - (_feeAdmin + _feeCurator);\n    }\n\n    /// @notice Maximum number of reserve tokens that can be held on SecondaryCurve at current secondary reserve ratio\n    /// @dev The max continous tokens on SecondaryCurve is equal to initialTokenSupply\n    /// @dev Reserve Token Balance = Reserve Ratio * (Continuous Token Supply x Continuous Token Price)\n    function getMaxSecondaryCurveBalance() private view returns(uint256){\n            return ((secondaryReserveRatio * initialTokenSupply * initialTokenPrice) / (1e18 * SCALE));\n    }\n\n    /// @notice gives current valuation of the system\n    /// @dev valuation = price * supply\n    /// @dev fictitiousPrimaryReserveBalance doesn't denote any actual reserve balance its just for calculation purpose\n    /// @dev Actual reserve balance in primary curve = primaryReserveBalance - fictitiousPrimaryReserveBalance\n    /// @dev Total reserve balance = Actual reserve balance in primary curve + secondaryReserveBalance\n    /// @dev Total reserve balance = (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance\n    /// @dev Valuation = (Continuous Token Supply x Continuous Token Price) = Reserve Token Balance / Reserve Ratio\n    /// @dev Valuation = If current supply is on seconday curve we use secondaryReserveBalance and secondaryReserveRatio to calculate valuation else we use primary reserve ratio and balance\n    /// @return Current valuation of the system\n    function getCurrentValuation() private view returns(uint256) {\n            return totalSupply() < initialTokenSupply ? (secondaryReserveBalance * SCALE /secondaryReserveRatio) : ((primaryReserveBalance) * SCALE  / primaryReserveRatio);\n    }\n\n    /// @notice function to buy tokens on the primary curve\n    /// @param _amount amount of reserve tokens to buy continous tokens\n    /// @dev This is executed when current supply >= initial supply\n    /// @dev _amount is charged with fee\n    /// @dev _purchaseReturn is minted to _to\n    /// @return _purchaseReturn Purchase return\n    function _buyPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {\n        uint256 _amountIn = _chargeFee(_amount);\n        uint256 _primaryReserveBalance = primaryReserveBalance;\n        _purchaseReturn = _calculatePurchaseReturn(_totalSupply, _primaryReserveBalance, primaryReserveRatio, _amountIn);\n        primaryReserveBalance = _primaryReserveBalance + _amountIn;\n    }\n    /// @notice function to buy tokens on secondary curve\n    /// @param _amount amount of reserve tokens to buy continous tokens\n    /// @dev This is executed when current supply < initial supply\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @dev _purchaseReturn is minted to _to\n    /// @return _purchaseReturn Purchase return\n    function _buySecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {\n        uint256 _amountIn = _chargeFeeSecondaryCurve(_amount);\n        uint _secondaryReserveBalance = secondaryReserveBalance;\n        _purchaseReturn = _calculatePurchaseReturn(_totalSupply, _secondaryReserveBalance, secondaryReserveRatio, _amountIn);\n        secondaryReserveBalance = _secondaryReserveBalance + _amountIn;\n    }\n\n    /// @notice The function to buy fractional tokens for reserveTokens\n    /// @dev TWAV is updated only if buyout is active and only on first buy or sell txs of block.\n    /// @dev It internally calls _buyPrimaryCurve or _buySecondaryCurve or both depending on the buyAmount and current supply\n    /// @dev if current totalSupply < initialTokenSupply AND _amount to buy tokens for is greater than (maxSecondaryCurveBalance - currentSecondaryCurveBalance) then buy happens on secondary curve and primary curve both\n    /// @param _minAmtOut Minimum amount of continuous token user receives, else the tx fails.\n    /// @param _to Address to mint the purchase return to\n    function buy(uint256 _minAmtOut, address _to) external override payable notBoughtOut lock whenNotPaused returns(uint256 _purchaseReturn) {\n        //Make update on the first tx of the block\n        if (status == Status.buyout) {\n            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n            if (_blockTimestamp != lastBlockTimeStamp) {\n                _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n                _rejectBuyout();\n            }\n        }\n        uint256 _initialTokenSupply = initialTokenSupply;\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply >= _initialTokenSupply) {\n            _purchaseReturn = _buyPrimaryCurve(msg.value, _totalSupply);\n        } else {\n            uint256 _lowerCurveDiff = getMaxSecondaryCurveBalance() - secondaryReserveBalance;\n            if (_lowerCurveDiff >= msg.value) {\n                _purchaseReturn = _buySecondaryCurve(msg.value, _totalSupply);\n            } else {\n                //Gas Optimization\n                _purchaseReturn = _initialTokenSupply - _totalSupply;\n                secondaryReserveBalance += _lowerCurveDiff;\n                // _purchaseReturn = _buySecondaryCurve(_to, _lowerCurveDiff);\n                _purchaseReturn += _buyPrimaryCurve(msg.value - _lowerCurveDiff, _totalSupply + _purchaseReturn);\n            } \n        }\n        require(_minAmtOut <= _purchaseReturn, \"NibblVault: Return too low\");\n        _mint(_to, _purchaseReturn);\n        emit Buy(msg.sender, _purchaseReturn, msg.value);\n    }\n\n    /// @notice The function to sell fractional tokens on primary curve\n    /// @dev Executed when currentSupply > initialSupply\n    /// @dev _amount is charged with fee\n    /// @param _amount Amount of tokens to be sold on primary curve\n    /// @return _saleReturn Sale Return\n    function _sellPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn) {\n        uint _primaryReserveBalance = primaryReserveBalance;\n        _saleReturn = _calculateSaleReturn(_totalSupply, _primaryReserveBalance, primaryReserveRatio, _amount);\n        primaryReserveBalance = _primaryReserveBalance - _saleReturn;\n        _saleReturn = _chargeFee(_saleReturn);\n    }\n\n    /// @notice The function to sell fractional tokens on secondary curve\n    /// @dev Executed when current supply <= initial supply\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @param _amount Amount of tokens to be sold on SecondaryCurve\n    ///  @return _saleReturn Sale Return\n    function _sellSecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn){\n        uint _secondaryReserveBalance = secondaryReserveBalance;\n        _saleReturn = _calculateSaleReturn(_totalSupply, _secondaryReserveBalance, secondaryReserveRatio, _amount);\n        secondaryReserveBalance = _secondaryReserveBalance - _saleReturn;\n        require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, \"NibblVault: Excess sell\");\n        _saleReturn = _chargeFeeSecondaryCurve(_saleReturn);\n    }\n\n    /// @notice The function to sell fractional tokens for reserve token\n    /// @dev TWAV is updated only if buyout is active and only on first buy or sell txs of block.\n    /// @dev internally calls _sellPrimaryCurve or _sellSecondaryCurve or both depending on the sellAmount and current supply\n    /// @dev if totalSupply > initialTokenSupply AND _amount to sell is greater than (_amtIn > totalSupply - initialTokenSupply) then sell happens on primary curve and secondary curve both\n    /// @param _amtIn Continous Tokens to be sold\n    /// @param _minAmtOut Minimum amount of reserve token user receives, else the tx fails.\n    /// @param _to Address to recieve the reserve token to\n    function sell(uint256 _amtIn, uint256 _minAmtOut, address payable _to) external override notBoughtOut whenNotPaused returns(uint256 _saleReturn) {\n        //Make update on the first tx of the block\n        if (status == Status.buyout) {\n            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n            if (_blockTimestamp != lastBlockTimeStamp) {\n                _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n                _rejectBuyout(); //For the case when TWAV goes up when updated on sell\n            }\n        }\n        uint256 _initialTokenSupply = initialTokenSupply;\n        uint256 _totalSupply = totalSupply();\n        if(_totalSupply > _initialTokenSupply) {\n            if ((_initialTokenSupply + _amtIn) <= _totalSupply) {\n                _saleReturn = _sellPrimaryCurve(_amtIn, _totalSupply);\n            } else {\n                //Gas Optimization\n                uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply;\n                _saleReturn = primaryReserveBalance - fictitiousPrimaryReserveBalance;\n                primaryReserveBalance -= _saleReturn;\n                _saleReturn = _chargeFee(_saleReturn);\n                // _saleReturn = _sellPrimaryCurve(_tokensPrimaryCurve);\n                _saleReturn += _sellSecondaryCurve(_amtIn - _tokensPrimaryCurve, _initialTokenSupply);\n            } } else {\n                _saleReturn = _sellSecondaryCurve(_amtIn,_totalSupply);\n        }\n        require(_saleReturn >= _minAmtOut, \"NibblVault: Return too low\");\n        _burn(msg.sender, _amtIn);\n        safeTransferETH(_to, _saleReturn); //send _saleReturn to _to\n        emit Sell(msg.sender, _amtIn, _saleReturn);\n    }\n\n    /// @notice Function to initiate buyout of ERC721\n    /// @dev buyoutBid is set to current valuation\n    /// @dev bidder needs to send funds equal to current valuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance) to initiate buyout\n    /// This ensures that the original bidder doesn't need to support the whole valuation and liquidity in reserve can be used as well.\n    /// Buyout is initiated only when total bid amount >= currentValuation but extra funds over currentValuation are sent back to bidder.\n    function initiateBuyout() external override payable whenNotPaused returns(uint256 _buyoutBid) {\n        require(block.timestamp >= minBuyoutTime, \"NibblVault: minBuyoutTime < now\");\n        require(status == Status.initialized, \"NibblVault: Status!=initialized\");\n        _buyoutBid = msg.value + (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance;\n        //_buyoutBid: Bid User has made\n        uint256 _currentValuation = getCurrentValuation();\n        require(_buyoutBid >= _currentValuation, \"NibblVault: Bid too low\");\n        // buyoutValuationDeposit = _currentValuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance); \n        buyoutValuationDeposit = msg.value - (_buyoutBid - _currentValuation);\n        bidder = msg.sender;\n        buyoutBid = _currentValuation;\n        // buyoutBid: Bid can only be placed at current valuation\n        buyoutRejectionValuation = (_currentValuation * (SCALE + REJECTION_PREMIUM)) / SCALE;\n        buyoutEndTime = block.timestamp + BUYOUT_DURATION;\n        status = Status.buyout;\n        _updateTWAV(_currentValuation, uint32(block.timestamp % 2**32));\n        if (_buyoutBid > _currentValuation) {\n            safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation));\n        }\n        emit BuyoutInitiated(msg.sender, _buyoutBid);\n    }\n\n    /// @notice Function to reject buyout\n    /// @dev Triggered when someone buys tokens and curve valuation increases\n    /// @dev If TWAV >= Buyout rejection valuation then the buyout is rejected\n    /// @dev Called only when TWAV is updated\n    function _rejectBuyout() private notBoughtOut {\n        uint256 _twav = _getTwav();\n        if (_twav >= buyoutRejectionValuation) {\n            uint256 _buyoutValuationDeposit = buyoutValuationDeposit;\n            unsettledBids[bidder] += _buyoutValuationDeposit;\n            totalUnsettledBids += _buyoutValuationDeposit;\n            delete buyoutRejectionValuation;\n            delete buyoutEndTime;\n            delete bidder;\n            delete twavObservations;\n            delete twavObservationsIndex;\n            delete lastBlockTimeStamp;\n            status = Status.initialized;\n            emit BuyoutRejected(_twav);\n        }\n    }\n\n    /// @notice Updates the TWAV when in buyout\n    /// @dev TWAV can be updated only in buyout state\n    function updateTWAV() external override {\n        require(status == Status.buyout, \"NibblVault: Status!=Buyout\");\n        uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n        if (_blockTimestamp != lastBlockTimeStamp) {\n            _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n            _rejectBuyout(); //For the case when TWAV goes up when updated externally\n        }\n    }\n\n    /// @notice Function to allow withdrawal of unsettledBids after buyout has been rejected\n    /// @param _to Address to receive the funds\n    function withdrawUnsettledBids(address payable _to) external override {\n        uint _amount = unsettledBids[msg.sender];\n        delete unsettledBids[msg.sender];\n        totalUnsettledBids -= _amount;\n        safeTransferETH(_to, _amount);\n    }\n\n    /// @notice Function for tokenholders to redeem their tokens for reserve token in case of buyout success\n    /// @dev The redeemed reserve token are in proportion to the token supply someone owns\n    /// @dev The amount available for redemption is contract balance - (total unsettled bid and curator fees accrued)\n    function redeem(address payable _to) external override boughtOut returns(uint256 _amtOut){\n        uint256 _balance = balanceOf(msg.sender);\n        _amtOut = ((address(this).balance - feeAccruedCurator - totalUnsettledBids) * _balance) / totalSupply();\n        _burn(msg.sender, _balance);\n        safeTransferETH(_to, _amtOut);\n    }\n\n    /// @notice Function to allow curator to redeem accumulated curator fee.\n    /// @param _to the address where curator fee will be sent\n    /// @dev can only be called by curator\n    function redeemCuratorFee(address payable _to) external override returns(uint256 _feeAccruedCurator) {\n        require(msg.sender == curator,\"NibblVault: Only Curator\");\n        _feeAccruedCurator = feeAccruedCurator;\n        feeAccruedCurator = 0;\n        safeTransferETH(_to, _feeAccruedCurator);\n    }\n\n\n    /// @notice to update the curator address\n    /// @param _newCurator new curator address \n    /// @dev can only be called by curator\n    function updateCurator(address _newCurator) external override {\n        require(msg.sender == curator,\"NibblVault: Only Curator\");\n        curator = _newCurator;\n    }\n\n\n    /// @notice Function for allowing bidder to unlock his ERC721 in case of buyout success\n    /// @param _assetAddress the address of asset to be unlocked\n    /// @param _assetID the ID of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC721(address _assetAddress, uint256 _assetID, address _to) external override boughtOut {\n        require(msg.sender == bidder,\"NibblVault: Only winner\");\n        IERC721(_assetAddress).safeTransferFrom(address(this), _to, _assetID);\n    }\n\n    ///@notice withdraw multiple ERC721s\n    /// @param _assetAddresses the addresses of assets to be unlocked\n    /// @param _assetIDs the IDs of assets to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {\n        require(msg.sender == bidder,\"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assetAddresses.length; i++) {\n            IERC721(_assetAddresses[i]).safeTransferFrom(address(this), _to, _assetIDs[i]);\n        }\n    }\n\n    /// @notice Function for allowing bidder to unlock his ERC20s in case of buyout success\n    /// @notice ERC20s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n    /// @param _asset the address of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC20(address _asset, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        IERC20(_asset).transfer(_to, IERC20(_asset).balanceOf(address(this)));\n    }\n\n    /// @notice withdraw multiple ERC20s\n    /// @param _assets the addresses of assets to be unlocked\n    /// @param _to the address where unlocked NFTs will be sent\n    function withdrawMultipleERC20(address[] memory _assets, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assets.length; i++) {\n            IERC20(_assets[i]).transfer(_to, IERC20(_assets[i]).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice Function for allowing bidder to unlock his ERC1155s in case of buyout success\n    /// @notice ERC1155s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n    /// @param _asset the address of asset to be unlocked\n    /// @param _assetID the ID of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC1155(address _asset, uint256 _assetID, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        uint256 balance = IERC1155(_asset).balanceOf(address(this),  _assetID);\n        IERC1155(_asset).safeTransferFrom(address(this), _to, _assetID, balance, \"0\");\n    }\n\n    /// @notice withdraw multiple ERC1155s\n    /// @param _assets the addresses of assets to be unlocked\n    /// @param _assetIDs the IDs of assets to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assets.length; i++) {\n            uint256 balance = IERC1155(_assets[i]).balanceOf(address(this),  _assetIDs[i]);\n            IERC1155(_assets[i]).safeTransferFrom(address(this), _to, _assetIDs[i], balance, \"0\");\n        }\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(block.timestamp <= deadline, \"NibblVault: expired deadline\");\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n        address signer = ecrecover(toTypedMessageHash(structHash), v, r, s);\n        require(signer == owner, \"NibblVault: invalid signature\");\n        _approve(owner, spender, value);\n    }\n    \n    function safeTransferETH(address payable _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"NibblVault: ETH transfer failed\");\n    }\n\n    function onERC721Received( address, address, uint256, bytes calldata ) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) external pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    receive() external payable {}\n}"
    }
  ]
}