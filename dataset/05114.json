{
  "Title": "[G-08] State variables read in loop in `PendlePowerFarmToken._calculateRewardsClaimedOutside()` function should be avoided.",
  "Content": "\nIn the `PendlePowerFarmToken._calculateRewardsClaimedOutside()` function as shown below the state variables `PENDLE_MARKET` and `PENDLE_POWER_FARM_CONTROLLER` (`PENDLE_POWER_FARM_CONTROLLER` was read multiple times in the loop) were read in a loop. Doing it this way isn't efficient; rather we should cache these state variables before the loop then substitute the cached variables for the state variables in the loop implementing this would help avoid `SLOAD` Gwarmaccess (100 gas units) and replace them with cheaper stack reads. The diff below shows how the function should be refactored:\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L239\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L243\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L244\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L249\n\n<details>\n\n```solidity\nfile: contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n\n218:    function _calculateRewardsClaimedOutside()\n219:        internal\n220:        returns (uint256[] memory)\n221:    {\n222:        address[] memory rewardTokens = PENDLE_CONTROLLER.pendleChildCompoundInfoRewardTokens(\n223:            UNDERLYING_PENDLE_MARKET\n224:        );\n225:\n226:        uint128[] memory lastIndex = PENDLE_CONTROLLER.pendleChildCompoundInfoLastIndex(\n227:            UNDERLYING_PENDLE_MARKET\n228:        );\n229:\n230:        uint256 l = rewardTokens.length;\n231:        uint256[] memory rewardsOutsideArray = new uint256[](l);\n232:\n233:        uint256 i;\n234:        uint128 index;\n235:\n236:        while (i < l) {\n237:            UserReward memory userReward = _getUserReward(\n238:                rewardTokens[i],\n239:                PENDLE_POWER_FARM_CONTROLLER    //@audit state variable read in loop\n240:            );\n241:\n242:            if (userReward.accrued > 0) {\n243:                PENDLE_MARKET.redeemRewards(        //@audit state variable read in loop\n244:                    PENDLE_POWER_FARM_CONTROLLER    //@audit state variable read in loop\n245:                );\n246:\n247:                userReward = _getUserReward(\n248:                    rewardTokens[i],\n249:                    PENDLE_POWER_FARM_CONTROLLER    //@audit state variable read in loop\n250:                );\n251:            }\n252:\n253:            index = userReward.index;\n254:\n255:            if (lastIndex[i] == 0 && index > 0) {\n256:                rewardsOutsideArray[i] = 0;\n257:                _overWriteIndex(\n258:                    i\n259:                );\n260:                unchecked {\n261:                    ++i;\n262:                }\n263:                continue;\n264:            }\n265:\n266:            if (index == lastIndex[i]) {\n267:                rewardsOutsideArray[i] = 0;\n268:                unchecked {\n269:                    ++i;\n270:                }\n271:                continue;\n272:            }\n273:\n274:            uint256 indexDiff = index\n275:                - lastIndex[i];\n276:\n277:            uint256 activeBalance = _getActiveBalance();\n278:            uint256 totalLpAssetsCurrent = totalLpAssets();\n279:            uint256 lpBalanceController = _getBalanceLpBalanceController();\n280:\n281:            bool scaleNecessary = totalLpAssetsCurrent < lpBalanceController;\n282:\n283:            rewardsOutsideArray[i] = scaleNecessary\n284:                ? indexDiff\n285:                    * activeBalance\n286:                    * totalLpAssetsCurrent\n287:                    / lpBalanceController\n288:                    / PRECISION_FACTOR_E18\n289:                : indexDiff\n290:                    * activeBalance\n291:                    / PRECISION_FACTOR_E18;\n292:\n293:            _overWriteIndex(\n294:                i\n295:            );\n296:\n297:            unchecked {\n298:                ++i;\n299:            }\n300:        }\n301:\n302:        return rewardsOutsideArray;\n303:    }\n```\n\n```diff\ndiff --git a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\nindex 9f7bb58..6cb42de 100644\n--- a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n+++ b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n@@ -233,20 +233,22 @@ contract PendlePowerFarmToken is SimpleERC20, TransferHelper {\n         uint256 i;\n         uint128 index;\n\n+        IPendleMarket _PENDLE_MARKET = PENDLE_MARKET;\n+        address _PENDLE_POWER_FARM_CONTROLLER = PENDLE_POWER_FARM_CONTROLLER;\n         while (i < l) {\n             UserReward memory userReward = _getUserReward(\n                 rewardTokens[i],\n-                PENDLE_POWER_FARM_CONTROLLER\n+                _PENDLE_POWER_FARM_CONTROLLER\n             );\n\n             if (userReward.accrued > 0) {\n-                PENDLE_MARKET.redeemRewards(\n-                    PENDLE_POWER_FARM_CONTROLLER\n+                _PENDLE_MARKET.redeemRewards(\n+                    _PENDLE_POWER_FARM_CONTROLLER\n                 );\n\n                 userReward = _getUserReward(\n                     rewardTokens[i],\n-                    PENDLE_POWER_FARM_CONTROLLER\n+                    _PENDLE_POWER_FARM_CONTROLLER\n                 );\n             }\n```\n\n</details>\n\nEstimated gas saved: 388 gas units per iteration.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./SimpleERC20Clone.sol\";\n\nimport \"../../InterfaceHub/IPendle.sol\";\nimport \"../../InterfaceHub/IPendleController.sol\";\n\nimport \"../../TransferHub/TransferHelper.sol\";\n\nerror MarketExpired();\nerror NotController();\nerror ZeroFee();\nerror TooMuchFee();\nerror NotEnoughLpAssetsTransferred();\nerror InsufficientShares();\nerror ZeroAmount();\nerror FeeTooHigh();\nerror NotEnoughShares();\nerror InvalidSharePriceGrowth();\nerror InvalidSharePrice();\nerror AlreadyInitialized();\n\ncontract PendlePowerFarmToken is SimpleERC20, TransferHelper {\n\n    // Pendle - LP token address\n    address public UNDERLYING_PENDLE_MARKET;\n    address public PENDLE_POWER_FARM_CONTROLLER;\n\n    // Total balance of LPs backing at current compound distribution\n    uint256 public underlyingLpAssetsCurrent;\n\n    // Lp assets from compound left to distribute\n    uint256 public totalLpAssetsToDistribute;\n\n    // Interface Object for underlying Market\n    IPendleMarket public PENDLE_MARKET;\n\n    // InterfaceObject for pendle Sy\n    IPendleSy public PENDLE_SY;\n\n    // Interface for Pendle Controller\n    IPendleController public PENDLE_CONTROLLER;\n\n    // Max cardinality of Pendle Market\n    uint16 public MAX_CARDINALITY;\n\n    uint256 public mintFee;\n    uint256 public lastInteraction;\n\n    uint256 private constant ONE_WEEK = 7 days;\n    uint256 internal constant ONE_YEAR = 365 days;\n    uint256 private constant MAX_MINT_FEE = 10000;\n\n    uint256 private constant PRECISION_FACTOR_E6 = 1E6;\n    uint256 private constant PRECISION_FACTOR_E18 = 1E18;\n    uint256 internal constant PRECISION_FACTOR_E36 = PRECISION_FACTOR_E18 * PRECISION_FACTOR_E18;\n    uint256 internal constant PRECISION_FACTOR_YEAR = PRECISION_FACTOR_E18 * ONE_YEAR;\n\n    uint256 private INITIAL_TIME_STAMP;\n\n    uint256 internal constant RESTRICTION_FACTOR = 10\n        * PRECISION_FACTOR_E36\n        / PRECISION_FACTOR_YEAR;\n\n    modifier onlyController() {\n        _onlyController();\n        _;\n    }\n\n    function _onlyController()\n        private\n        view\n    {\n        if (msg.sender != PENDLE_POWER_FARM_CONTROLLER) {\n            revert NotController();\n        }\n    }\n\n    modifier syncSupply()\n    {\n        _triggerIndexUpdate();\n        _overWriteCheck();\n        _syncSupply();\n        _updateRewards();\n        _setLastInteraction();\n        _increaseCardinalityNext();\n        uint256 sharePriceBefore = _getSharePrice();\n        _;\n        _validateSharePriceGrowth(\n            _validateSharePrice(\n                sharePriceBefore\n            )\n        );\n    }\n\n    function _validateSharePrice(\n        uint256 _sharePriceBefore\n    )\n        private\n        view\n        returns (uint256)\n    {\n        uint256 sharePricenNow = _getSharePrice();\n\n        if (sharePricenNow < _sharePriceBefore) {\n            revert InvalidSharePrice();\n        }\n\n        return sharePricenNow;\n    }\n\n    function _validateSharePriceGrowth(\n        uint256 _sharePriceNow\n    )\n        private\n        view\n    {\n        uint256 timeDifference = block.timestamp\n            - INITIAL_TIME_STAMP;\n\n        uint256 maximum = timeDifference\n            * RESTRICTION_FACTOR\n            + PRECISION_FACTOR_E18;\n\n        if (_sharePriceNow > maximum) {\n            revert InvalidSharePriceGrowth();\n        }\n    }\n\n    function _overWriteCheck()\n        internal\n    {\n        _wrapOverWrites(\n            _updateRewardTokens()\n        );\n    }\n\n    function _triggerIndexUpdate()\n        internal\n    {\n        _withdrawLp(\n            UNDERLYING_PENDLE_MARKET,\n            0\n        );\n    }\n\n    function _wrapOverWrites(\n        bool _overWritten\n    )\n        internal\n    {\n        if (_overWritten == true) {\n            _overWriteIndexAll();\n            _overWriteAmounts();\n        }\n    }\n\n    function _updateRewardTokens()\n        private\n        returns (bool)\n    {\n        return PENDLE_CONTROLLER.updateRewardTokens(\n            UNDERLYING_PENDLE_MARKET\n        );\n    }\n\n    function _overWriteIndexAll()\n        private\n    {\n        PENDLE_CONTROLLER.overWriteIndexAll(\n            UNDERLYING_PENDLE_MARKET\n        );\n    }\n\n    function _overWriteIndex(\n        uint256 _index\n    )\n        private\n    {\n        PENDLE_CONTROLLER.overWriteIndex(\n            UNDERLYING_PENDLE_MARKET,\n            _index\n        );\n    }\n\n    function _overWriteAmounts()\n        private\n    {\n        PENDLE_CONTROLLER.overWriteAmounts(\n            UNDERLYING_PENDLE_MARKET\n        );\n    }\n\n    function _updateRewards()\n        private\n    {\n        uint256[] memory rewardsOutsideArray = _calculateRewardsClaimedOutside();\n\n        uint256 i;\n        uint256 l = rewardsOutsideArray.length;\n\n        while (i < l) {\n            if (rewardsOutsideArray[i] > 0) {\n                PENDLE_CONTROLLER.increaseReservedForCompound(\n                    UNDERLYING_PENDLE_MARKET,\n                    rewardsOutsideArray\n                );\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _calculateRewardsClaimedOutside()\n        internal\n        returns (uint256[] memory)\n    {\n        address[] memory rewardTokens = PENDLE_CONTROLLER.pendleChildCompoundInfoRewardTokens(\n            UNDERLYING_PENDLE_MARKET\n        );\n\n        uint128[] memory lastIndex = PENDLE_CONTROLLER.pendleChildCompoundInfoLastIndex(\n            UNDERLYING_PENDLE_MARKET\n        );\n\n        uint256 l = rewardTokens.length;\n        uint256[] memory rewardsOutsideArray = new uint256[](l);\n\n        uint256 i;\n        uint128 index;\n\n        while (i < l) {\n            UserReward memory userReward = _getUserReward(\n                rewardTokens[i],\n                PENDLE_POWER_FARM_CONTROLLER\n            );\n\n            if (userReward.accrued > 0) {\n                PENDLE_MARKET.redeemRewards(\n                    PENDLE_POWER_FARM_CONTROLLER\n                );\n\n                userReward = _getUserReward(\n                    rewardTokens[i],\n                    PENDLE_POWER_FARM_CONTROLLER\n                );\n            }\n\n            index = userReward.index;\n\n            if (lastIndex[i] == 0 && index > 0) {\n                rewardsOutsideArray[i] = 0;\n                _overWriteIndex(\n                    i\n                );\n                unchecked {\n                    ++i;\n                }\n                continue;\n            }\n\n            if (index == lastIndex[i]) {\n                rewardsOutsideArray[i] = 0;\n                unchecked {\n                    ++i;\n                }\n                continue;\n            }\n\n            uint256 indexDiff = index\n                - lastIndex[i];\n\n            uint256 activeBalance = _getActiveBalance();\n            uint256 totalLpAssetsCurrent = totalLpAssets();\n            uint256 lpBalanceController = _getBalanceLpBalanceController();\n\n            bool scaleNecessary = totalLpAssetsCurrent < lpBalanceController;\n\n            rewardsOutsideArray[i] = scaleNecessary\n                ? indexDiff\n                    * activeBalance\n                    * totalLpAssetsCurrent\n                    / lpBalanceController\n                    / PRECISION_FACTOR_E18\n                : indexDiff\n                    * activeBalance\n                    / PRECISION_FACTOR_E18;\n\n            _overWriteIndex(\n                i\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return rewardsOutsideArray;\n    }\n\n    function _getBalanceLpBalanceController()\n        private\n        view\n        returns (uint256)\n    {\n        return PENDLE_MARKET.balanceOf(\n            PENDLE_POWER_FARM_CONTROLLER\n        );\n    }\n\n    function _getActiveBalance()\n        private\n        view\n        returns (uint256)\n    {\n        return PENDLE_MARKET.activeBalance(\n            PENDLE_POWER_FARM_CONTROLLER\n        );\n    }\n\n    function _getSharePrice()\n        private\n        view\n        returns (uint256)\n    {\n        return previewUnderlyingLpAssets() * PRECISION_FACTOR_E18\n            / totalSupply();\n    }\n\n    function _syncSupply()\n        private\n    {\n        uint256 additonalAssets = previewDistribution();\n\n        if (additonalAssets == 0) {\n            return;\n        }\n\n        underlyingLpAssetsCurrent += additonalAssets;\n        totalLpAssetsToDistribute -= additonalAssets;\n    }\n\n    function _increaseCardinalityNext()\n        internal\n    {\n        MarketStorage memory storageMarket = PENDLE_MARKET._storage();\n\n        if (storageMarket.observationCardinalityNext < MAX_CARDINALITY) {\n            PENDLE_MARKET.increaseObservationsCardinalityNext(\n                storageMarket.observationCardinalityNext + 1\n            );\n        }\n    }\n\n    function _withdrawLp(\n        address _to,\n        uint256 _amount\n    )\n        internal\n    {\n        PENDLE_CONTROLLER.withdrawLp(\n            UNDERLYING_PENDLE_MARKET,\n            _to,\n            _amount\n        );\n    }\n\n    function _getUserReward(\n        address _rewardToken,\n        address _user\n    )\n        internal\n        view\n        returns (UserReward memory)\n    {\n        return PENDLE_MARKET.userReward(\n            _rewardToken,\n            _user\n        );\n    }\n\n    function previewDistribution()\n        public\n        view\n        returns (uint256)\n    {\n        if (totalLpAssetsToDistribute == 0) {\n            return 0;\n        }\n\n        if (block.timestamp == lastInteraction) {\n            return 0;\n        }\n\n        if (totalLpAssetsToDistribute < ONE_WEEK) {\n            return totalLpAssetsToDistribute;\n        }\n\n        uint256 currentRate = totalLpAssetsToDistribute\n            / ONE_WEEK;\n\n        uint256 additonalAssets = currentRate\n            * (block.timestamp - lastInteraction);\n\n        if (additonalAssets > totalLpAssetsToDistribute) {\n            return totalLpAssetsToDistribute;\n        }\n\n        return additonalAssets;\n    }\n\n    function _setLastInteraction()\n        private\n    {\n        lastInteraction = block.timestamp;\n    }\n\n    function _applyMintFee(\n        uint256 _amount\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return _amount\n            * (PRECISION_FACTOR_E6 - mintFee)\n            / PRECISION_FACTOR_E6;\n    }\n\n    function totalLpAssets()\n        public\n        view\n        returns (uint256)\n    {\n        return underlyingLpAssetsCurrent\n            + totalLpAssetsToDistribute;\n    }\n\n    function previewUnderlyingLpAssets()\n        public\n        view\n        returns (uint256)\n    {\n        return previewDistribution()\n            + underlyingLpAssetsCurrent;\n    }\n\n    function previewMintShares(\n        uint256 _underlyingAssetAmount,\n        uint256 _underlyingLpAssetsCurrent\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _underlyingAssetAmount\n            * totalSupply()\n            / _underlyingLpAssetsCurrent;\n    }\n\n    function previewAmountWithdrawShares(\n        uint256 _shares,\n        uint256 _underlyingLpAssetsCurrent\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _shares\n            * _underlyingLpAssetsCurrent\n            / totalSupply();\n    }\n\n    function previewBurnShares(\n        uint256 _underlyingAssetAmount,\n        uint256 _underlyingLpAssetsCurrent\n    )\n        public\n        view\n        returns (uint256)\n    {\n        uint256 product = _underlyingAssetAmount\n            * totalSupply();\n\n        return product % _underlyingLpAssetsCurrent == 0\n            ? product / _underlyingLpAssetsCurrent\n            : product / _underlyingLpAssetsCurrent + 1;\n    }\n\n    function manualSync()\n        external\n        syncSupply\n        returns (bool)\n    {\n        return true;\n    }\n\n    function addCompoundRewards(\n        uint256 _amount\n    )\n        external\n        syncSupply\n    {\n        if (_amount == 0) {\n            revert ZeroAmount();\n        }\n\n        totalLpAssetsToDistribute += _amount;\n\n        if (msg.sender == PENDLE_POWER_FARM_CONTROLLER) {\n            return;\n        }\n\n        _safeTransferFrom(\n            UNDERLYING_PENDLE_MARKET,\n            msg.sender,\n            PENDLE_POWER_FARM_CONTROLLER,\n            _amount\n        );\n    }\n\n    /**\n     * @dev External wrapper for mint function.\n     */\n    function depositExactAmount(\n        uint256 _underlyingLpAssetAmount\n    )\n        external\n        syncSupply\n        returns (\n            uint256,\n            uint256\n        )\n    {\n        if (_underlyingLpAssetAmount == 0) {\n            revert ZeroAmount();\n        }\n\n        uint256 shares = previewMintShares(\n            _underlyingLpAssetAmount,\n            underlyingLpAssetsCurrent\n        );\n\n        if (shares == 0) {\n            revert NotEnoughLpAssetsTransferred();\n        }\n\n        uint256 reducedShares = _applyMintFee(\n            shares\n        );\n\n        uint256 feeShares = shares\n            - reducedShares;\n\n        if (feeShares == 0) {\n            revert ZeroFee();\n        }\n\n        if (reducedShares == feeShares) {\n            revert TooMuchFee();\n        }\n\n        _mint(\n            msg.sender,\n            reducedShares\n        );\n\n        _mint(\n            PENDLE_POWER_FARM_CONTROLLER,\n            feeShares\n        );\n\n        underlyingLpAssetsCurrent += _underlyingLpAssetAmount;\n\n        _safeTransferFrom(\n            UNDERLYING_PENDLE_MARKET,\n            msg.sender,\n            PENDLE_POWER_FARM_CONTROLLER,\n            _underlyingLpAssetAmount\n        );\n\n        return (\n            reducedShares,\n            feeShares\n        );\n    }\n\n    function changeMintFee(\n        uint256 _newFee\n    )\n        external\n        onlyController\n    {\n        if (_newFee > MAX_MINT_FEE) {\n            revert FeeTooHigh();\n        }\n\n        mintFee = _newFee;\n    }\n\n    /**\n     * @dev External wrapper for burn function.\n     */\n    function withdrawExactShares(\n        uint256 _shares\n    )\n        external\n        syncSupply\n        returns (uint256)\n    {\n        if (_shares == 0) {\n            revert ZeroAmount();\n        }\n\n        if (_shares > balanceOf(msg.sender)) {\n            revert InsufficientShares();\n        }\n\n        uint256 tokenAmount = previewAmountWithdrawShares(\n            _shares,\n            underlyingLpAssetsCurrent\n        );\n\n        underlyingLpAssetsCurrent -= tokenAmount;\n\n        _burn(\n            msg.sender,\n            _shares\n        );\n\n        if (msg.sender == PENDLE_POWER_FARM_CONTROLLER) {\n            return tokenAmount;\n        }\n\n        _withdrawLp(\n            msg.sender,\n            tokenAmount\n        );\n\n        return tokenAmount;\n    }\n\n    function withdrawExactAmount(\n        uint256 _underlyingLpAssetAmount\n    )\n        external\n        syncSupply\n        returns (uint256)\n    {\n        if (_underlyingLpAssetAmount == 0) {\n            revert ZeroAmount();\n        }\n\n        uint256 shares = previewBurnShares(\n            _underlyingLpAssetAmount,\n            underlyingLpAssetsCurrent\n        );\n\n        if (shares > balanceOf(msg.sender)) {\n            revert NotEnoughShares();\n        }\n\n        _burn(\n            msg.sender,\n            shares\n        );\n\n        underlyingLpAssetsCurrent -= _underlyingLpAssetAmount;\n\n        _withdrawLp(\n            msg.sender,\n            _underlyingLpAssetAmount\n        );\n\n        return shares;\n    }\n\n    function initialize(\n        address _underlyingPendleMarket,\n        address _pendleController,\n        string memory _tokenName,\n        string memory _symbolName,\n        uint16 _maxCardinality\n    )\n        external\n    {\n        if (address(PENDLE_MARKET) != address(0)) {\n            revert AlreadyInitialized();\n        }\n\n        PENDLE_MARKET = IPendleMarket(\n            _underlyingPendleMarket\n        );\n\n        if (PENDLE_MARKET.isExpired() == true) {\n            revert MarketExpired();\n        }\n\n        PENDLE_CONTROLLER = IPendleController(\n            _pendleController\n        );\n\n        MAX_CARDINALITY = _maxCardinality;\n\n        _name = _tokenName;\n        _symbol = _symbolName;\n\n        PENDLE_POWER_FARM_CONTROLLER = _pendleController;\n        UNDERLYING_PENDLE_MARKET = _underlyingPendleMarket;\n\n        (\n            address pendleSyAddress,\n            ,\n        ) = PENDLE_MARKET.readTokens();\n\n        PENDLE_SY = IPendleSy(\n            pendleSyAddress\n        );\n\n        _decimals = PENDLE_SY.decimals();\n\n        lastInteraction = block.timestamp;\n\n        _totalSupply = 1;\n        underlyingLpAssetsCurrent = 1;\n        mintFee = 3000;\n        INITIAL_TIME_STAMP = block.timestamp;\n    }\n}"
    },
    {
      "filename": "contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./SimpleERC20Clone.sol\";\n\nimport \"../../InterfaceHub/IPendle.sol\";\nimport \"../../InterfaceHub/IPendleController.sol\";\n\nimport \"../../TransferHub/TransferHelper.sol\";\n\nerror MarketExpired();\nerror NotController();\nerror ZeroFee();\nerror TooMuchFee();\nerror NotEnoughLpAssetsTransferred();\nerror InsufficientShares();\nerror ZeroAmount();\nerror FeeTooHigh();\nerror NotEnoughShares();\nerror InvalidSharePriceGrowth();\nerror InvalidSharePrice();\nerror AlreadyInitialized();\n\ncontract PendlePowerFarmToken is SimpleERC20, TransferHelper {\n\n    // Pendle - LP token address\n    address public UNDERLYING_PENDLE_MARKET;\n    address public PENDLE_POWER_FARM_CONTROLLER;\n\n    // Total balance of LPs backing at current compound distribution\n    uint256 public underlyingLpAssetsCurrent;\n\n    // Lp assets from compound left to distribute\n    uint256 public totalLpAssetsToDistribute;\n\n    // Interface Object for underlying Market\n    IPendleMarket public PENDLE_MARKET;\n\n    // InterfaceObject for pendle Sy\n    IPendleSy public PENDLE_SY;\n\n    // Interface for Pendle Controller\n    IPendleController public PENDLE_CONTROLLER;\n\n    // Max cardinality of Pendle Market\n    uint16 public MAX_CARDINALITY;\n\n    uint256 public mintFee;\n    uint256 public lastInteraction;\n\n    uint256 private constant ONE_WEEK = 7 days;\n    uint256 internal constant ONE_YEAR = 365 days;\n    uint256 private constant MAX_MINT_FEE = 10000;\n\n    uint256 private constant PRECISION_FACTOR_E6 = 1E6;\n    uint256 private constant PRECISION_FACTOR_E18 = 1E18;\n    uint256 internal constant PRECISION_FACTOR_E36 = PRECISION_FACTOR_E18 * PRECISION_FACTOR_E18;\n    uint256 internal constant PRECISION_FACTOR_YEAR = PRECISION_FACTOR_E18 * ONE_YEAR;\n\n    uint256 private INITIAL_TIME_STAMP;\n\n    uint256 internal constant RESTRICTION_FACTOR = 10\n        * PRECISION_FACTOR_E36\n        / PRECISION_FACTOR_YEAR;\n\n    modifier onlyController() {\n        _onlyController();\n        _;\n    }\n\n    function _onlyController()\n        private\n        view\n    {\n        if (msg.sender != PENDLE_POWER_FARM_CONTROLLER) {\n            revert NotController();\n        }\n    }\n\n    modifier syncSupply()\n    {\n        _triggerIndexUpdate();\n        _overWriteCheck();\n        _syncSupply();\n        _updateRewards();\n        _setLastInteraction();\n        _increaseCardinalityNext();\n        uint256 sharePriceBefore = _getSharePrice();\n        _;\n        _validateSharePriceGrowth(\n            _validateSharePrice(\n                sharePriceBefore\n            )\n        );\n    }\n\n    function _validateSharePrice(\n        uint256 _sharePriceBefore\n    )\n        private\n        view\n        returns (uint256)\n    {\n        uint256 sharePricenNow = _getSharePrice();\n\n        if (sharePricenNow < _sharePriceBefore) {\n            revert InvalidSharePrice();\n        }\n\n        return sharePricenNow;\n    }\n\n    function _validateSharePriceGrowth(\n        uint256 _sharePriceNow\n    )\n        private\n        view\n    {\n        uint256 timeDifference = block.timestamp\n            - INITIAL_TIME_STAMP;\n\n        uint256 maximum = timeDifference\n            * RESTRICTION_FACTOR\n            + PRECISION_FACTOR_E18;\n\n        if (_sharePriceNow > maximum) {\n            revert InvalidSharePriceGrowth();\n        }\n    }\n\n    function _overWriteCheck()\n        internal\n    {\n        _wrapOverWrites(\n            _updateRewardTokens()\n        );\n    }\n\n    function _triggerIndexUpdate()\n        internal\n    {\n        _withdrawLp(\n            UNDERLYING_PENDLE_MARKET,\n            0\n        );\n    }\n\n    function _wrapOverWrites(\n        bool _overWritten\n    )\n        internal\n    {\n        if (_overWritten == true) {\n            _overWriteIndexAll();\n            _overWriteAmounts();\n        }\n    }\n\n    function _updateRewardTokens()\n        private\n        returns (bool)\n    {\n        return PENDLE_CONTROLLER.updateRewardTokens(\n            UNDERLYING_PENDLE_MARKET\n        );\n    }\n\n    function _overWriteIndexAll()\n        private\n    {\n        PENDLE_CONTROLLER.overWriteIndexAll(\n            UNDERLYING_PENDLE_MARKET\n        );\n    }\n\n    function _overWriteIndex(\n        uint256 _index\n    )\n        private\n    {\n        PENDLE_CONTROLLER.overWriteIndex(\n            UNDERLYING_PENDLE_MARKET,\n            _index\n        );\n    }\n\n    function _overWriteAmounts()\n        private\n    {\n        PENDLE_CONTROLLER.overWriteAmounts(\n            UNDERLYING_PENDLE_MARKET\n        );\n    }\n\n    function _updateRewards()\n        private\n    {\n        uint256[] memory rewardsOutsideArray = _calculateRewardsClaimedOutside();\n\n        uint256 i;\n        uint256 l = rewardsOutsideArray.length;\n\n        while (i < l) {\n            if (rewardsOutsideArray[i] > 0) {\n                PENDLE_CONTROLLER.increaseReservedForCompound(\n                    UNDERLYING_PENDLE_MARKET,\n                    rewardsOutsideArray\n                );\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _calculateRewardsClaimedOutside()\n        internal\n        returns (uint256[] memory)\n    {\n        address[] memory rewardTokens = PENDLE_CONTROLLER.pendleChildCompoundInfoRewardTokens(\n            UNDERLYING_PENDLE_MARKET\n        );\n\n        uint128[] memory lastIndex = PENDLE_CONTROLLER.pendleChildCompoundInfoLastIndex(\n            UNDERLYING_PENDLE_MARKET\n        );\n\n        uint256 l = rewardTokens.length;\n        uint256[] memory rewardsOutsideArray = new uint256[](l);\n\n        uint256 i;\n        uint128 index;\n\n        while (i < l) {\n            UserReward memory userReward = _getUserReward(\n                rewardTokens[i],\n                PENDLE_POWER_FARM_CONTROLLER\n            );\n\n            if (userReward.accrued > 0) {\n                PENDLE_MARKET.redeemRewards(\n                    PENDLE_POWER_FARM_CONTROLLER\n                );\n\n                userReward = _getUserReward(\n                    rewardTokens[i],\n                    PENDLE_POWER_FARM_CONTROLLER\n                );\n            }\n\n            index = userReward.index;\n\n            if (lastIndex[i] == 0 && index > 0) {\n                rewardsOutsideArray[i] = 0;\n                _overWriteIndex(\n                    i\n                );\n                unchecked {\n                    ++i;\n                }\n                continue;\n            }\n\n            if (index == lastIndex[i]) {\n                rewardsOutsideArray[i] = 0;\n                unchecked {\n                    ++i;\n                }\n                continue;\n            }\n\n            uint256 indexDiff = index\n                - lastIndex[i];\n\n            uint256 activeBalance = _getActiveBalance();\n            uint256 totalLpAssetsCurrent = totalLpAssets();\n            uint256 lpBalanceController = _getBalanceLpBalanceController();\n\n            bool scaleNecessary = totalLpAssetsCurrent < lpBalanceController;\n\n            rewardsOutsideArray[i] = scaleNecessary\n                ? indexDiff\n                    * activeBalance\n                    * totalLpAssetsCurrent\n                    / lpBalanceController\n                    / PRECISION_FACTOR_E18\n                : indexDiff\n                    * activeBalance\n                    / PRECISION_FACTOR_E18;\n\n            _overWriteIndex(\n                i\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return rewardsOutsideArray;\n    }\n\n    function _getBalanceLpBalanceController()\n        private\n        view\n        returns (uint256)\n    {\n        return PENDLE_MARKET.balanceOf(\n            PENDLE_POWER_FARM_CONTROLLER\n        );\n    }\n\n    function _getActiveBalance()\n        private\n        view\n        returns (uint256)\n    {\n        return PENDLE_MARKET.activeBalance(\n            PENDLE_POWER_FARM_CONTROLLER\n        );\n    }\n\n    function _getSharePrice()\n        private\n        view\n        returns (uint256)\n    {\n        return previewUnderlyingLpAssets() * PRECISION_FACTOR_E18\n            / totalSupply();\n    }\n\n    function _syncSupply()\n        private\n    {\n        uint256 additonalAssets = previewDistribution();\n\n        if (additonalAssets == 0) {\n            return;\n        }\n\n        underlyingLpAssetsCurrent += additonalAssets;\n        totalLpAssetsToDistribute -= additonalAssets;\n    }\n\n    function _increaseCardinalityNext()\n        internal\n    {\n        MarketStorage memory storageMarket = PENDLE_MARKET._storage();\n\n        if (storageMarket.observationCardinalityNext < MAX_CARDINALITY) {\n            PENDLE_MARKET.increaseObservationsCardinalityNext(\n                storageMarket.observationCardinalityNext + 1\n            );\n        }\n    }\n\n    function _withdrawLp(\n        address _to,\n        uint256 _amount\n    )\n        internal\n    {\n        PENDLE_CONTROLLER.withdrawLp(\n            UNDERLYING_PENDLE_MARKET,\n            _to,\n            _amount\n        );\n    }\n\n    function _getUserReward(\n        address _rewardToken,\n        address _user\n    )\n        internal\n        view\n        returns (UserReward memory)\n    {\n        return PENDLE_MARKET.userReward(\n            _rewardToken,\n            _user\n        );\n    }\n\n    function previewDistribution()\n        public\n        view\n        returns (uint256)\n    {\n        if (totalLpAssetsToDistribute == 0) {\n            return 0;\n        }\n\n        if (block.timestamp == lastInteraction) {\n            return 0;\n        }\n\n        if (totalLpAssetsToDistribute < ONE_WEEK) {\n            return totalLpAssetsToDistribute;\n        }\n\n        uint256 currentRate = totalLpAssetsToDistribute\n            / ONE_WEEK;\n\n        uint256 additonalAssets = currentRate\n            * (block.timestamp - lastInteraction);\n\n        if (additonalAssets > totalLpAssetsToDistribute) {\n            return totalLpAssetsToDistribute;\n        }\n\n        return additonalAssets;\n    }\n\n    function _setLastInteraction()\n        private\n    {\n        lastInteraction = block.timestamp;\n    }\n\n    function _applyMintFee(\n        uint256 _amount\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return _amount\n            * (PRECISION_FACTOR_E6 - mintFee)\n            / PRECISION_FACTOR_E6;\n    }\n\n    function totalLpAssets()\n        public\n        view\n        returns (uint256)\n    {\n        return underlyingLpAssetsCurrent\n            + totalLpAssetsToDistribute;\n    }\n\n    function previewUnderlyingLpAssets()\n        public\n        view\n        returns (uint256)\n    {\n        return previewDistribution()\n            + underlyingLpAssetsCurrent;\n    }\n\n    function previewMintShares(\n        uint256 _underlyingAssetAmount,\n        uint256 _underlyingLpAssetsCurrent\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _underlyingAssetAmount\n            * totalSupply()\n            / _underlyingLpAssetsCurrent;\n    }\n\n    function previewAmountWithdrawShares(\n        uint256 _shares,\n        uint256 _underlyingLpAssetsCurrent\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _shares\n            * _underlyingLpAssetsCurrent\n            / totalSupply();\n    }\n\n    function previewBurnShares(\n        uint256 _underlyingAssetAmount,\n        uint256 _underlyingLpAssetsCurrent\n    )\n        public\n        view\n        returns (uint256)\n    {\n        uint256 product = _underlyingAssetAmount\n            * totalSupply();\n\n        return product % _underlyingLpAssetsCurrent == 0\n            ? product / _underlyingLpAssetsCurrent\n            : product / _underlyingLpAssetsCurrent + 1;\n    }\n\n    function manualSync()\n        external\n        syncSupply\n        returns (bool)\n    {\n        return true;\n    }\n\n    function addCompoundRewards(\n        uint256 _amount\n    )\n        external\n        syncSupply\n    {\n        if (_amount == 0) {\n            revert ZeroAmount();\n        }\n\n        totalLpAssetsToDistribute += _amount;\n\n        if (msg.sender == PENDLE_POWER_FARM_CONTROLLER) {\n            return;\n        }\n\n        _safeTransferFrom(\n            UNDERLYING_PENDLE_MARKET,\n            msg.sender,\n            PENDLE_POWER_FARM_CONTROLLER,\n            _amount\n        );\n    }\n\n    /**\n     * @dev External wrapper for mint function.\n     */\n    function depositExactAmount(\n        uint256 _underlyingLpAssetAmount\n    )\n        external\n        syncSupply\n        returns (\n            uint256,\n            uint256\n        )\n    {\n        if (_underlyingLpAssetAmount == 0) {\n            revert ZeroAmount();\n        }\n\n        uint256 shares = previewMintShares(\n            _underlyingLpAssetAmount,\n            underlyingLpAssetsCurrent\n        );\n\n        if (shares == 0) {\n            revert NotEnoughLpAssetsTransferred();\n        }\n\n        uint256 reducedShares = _applyMintFee(\n            shares\n        );\n\n        uint256 feeShares = shares\n            - reducedShares;\n\n        if (feeShares == 0) {\n            revert ZeroFee();\n        }\n\n        if (reducedShares == feeShares) {\n            revert TooMuchFee();\n        }\n\n        _mint(\n            msg.sender,\n            reducedShares\n        );\n\n        _mint(\n            PENDLE_POWER_FARM_CONTROLLER,\n            feeShares\n        );\n\n        underlyingLpAssetsCurrent += _underlyingLpAssetAmount;\n\n        _safeTransferFrom(\n            UNDERLYING_PENDLE_MARKET,\n            msg.sender,\n            PENDLE_POWER_FARM_CONTROLLER,\n            _underlyingLpAssetAmount\n        );\n\n        return (\n            reducedShares,\n            feeShares\n        );\n    }\n\n    function changeMintFee(\n        uint256 _newFee\n    )\n        external\n        onlyController\n    {\n        if (_newFee > MAX_MINT_FEE) {\n            revert FeeTooHigh();\n        }\n\n        mintFee = _newFee;\n    }\n\n    /**\n     * @dev External wrapper for burn function.\n     */\n    function withdrawExactShares(\n        uint256 _shares\n    )\n        external\n        syncSupply\n        returns (uint256)\n    {\n        if (_shares == 0) {\n            revert ZeroAmount();\n        }\n\n        if (_shares > balanceOf(msg.sender)) {\n            revert InsufficientShares();\n        }\n\n        uint256 tokenAmount = previewAmountWithdrawShares(\n            _shares,\n            underlyingLpAssetsCurrent\n        );\n\n        underlyingLpAssetsCurrent -= tokenAmount;\n\n        _burn(\n            msg.sender,\n            _shares\n        );\n\n        if (msg.sender == PENDLE_POWER_FARM_CONTROLLER) {\n            return tokenAmount;\n        }\n\n        _withdrawLp(\n            msg.sender,\n            tokenAmount\n        );\n\n        return tokenAmount;\n    }\n\n    function withdrawExactAmount(\n        uint256 _underlyingLpAssetAmount\n    )\n        external\n        syncSupply\n        returns (uint256)\n    {\n        if (_underlyingLpAssetAmount == 0) {\n            revert ZeroAmount();\n        }\n\n        uint256 shares = previewBurnShares(\n            _underlyingLpAssetAmount,\n            underlyingLpAssetsCurrent\n        );\n\n        if (shares > balanceOf(msg.sender)) {\n            revert NotEnoughShares();\n        }\n\n        _burn(\n            msg.sender,\n            shares\n        );\n\n        underlyingLpAssetsCurrent -= _underlyingLpAssetAmount;\n\n        _withdrawLp(\n            msg.sender,\n            _underlyingLpAssetAmount\n        );\n\n        return shares;\n    }\n\n    function initialize(\n        address _underlyingPendleMarket,\n        address _pendleController,\n        string memory _tokenName,\n        string memory _symbolName,\n        uint16 _maxCardinality\n    )\n        external\n    {\n        if (address(PENDLE_MARKET) != address(0)) {\n            revert AlreadyInitialized();\n        }\n\n        PENDLE_MARKET = IPendleMarket(\n            _underlyingPendleMarket\n        );\n\n        if (PENDLE_MARKET.isExpired() == true) {\n            revert MarketExpired();\n        }\n\n        PENDLE_CONTROLLER = IPendleController(\n            _pendleController"
    }
  ]
}