{
  "Title": "[G-11] Caching a variable that is used once just wastes Gas",
  "Content": "\n### No need to cache `ds.forkEscrow` as it's being used once\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/NounsDAOV3Fork.sol#L141-L160\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/NounsDAOV3Fork.sol\n141:    function joinFork(\n142:        NounsDAOStorageV3.StorageV3 storage ds,\n143:        uint256[] calldata tokenIds,\n144:        uint256[] calldata proposalIds,\n145:        string calldata reason\n146:    ) external {\n147:        if (!isForkPeriodActive(ds)) revert ForkPeriodNotActive();\n\n149:        INounsDAOForkEscrow forkEscrow = ds.forkEscrow;\n150:        address timelock = address(ds.timelock);\n151:        sendProRataTreasury(ds, ds.forkDAOTreasury, tokenIds.length, adjustedTotalSupply(ds));\n\n153:        for (uint256 i = 0; i < tokenIds.length; i++) {\n154:            ds.nouns.transferFrom(msg.sender, timelock, tokenIds[i]);\n155:        }\n\n157:        NounsTokenFork(ds.forkDAOToken).claimDuringForkPeriod(msg.sender, tokenIds);\n\n159:        emit JoinFork(forkEscrow.forkId() - 1, msg.sender, tokenIds, proposalIds, reason);\n160:    }\n```\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/fork/NounsDAOV3Fork.sol b/packages/nouns-contracts/contracts/governance/fork/NounsDAOV3Fork.sol\nindex d87ffc70..4051da05 100644\n--- a/packages/nouns-contracts/contracts/governance/fork/NounsDAOV3Fork.sol\n+++ b/packages/nouns-contracts/contracts/governance/fork/NounsDAOV3Fork.sol\n@@ -146,7 +146,6 @@ library NounsDAOV3Fork {\n     ) external {\n         if (!isForkPeriodActive(ds)) revert ForkPeriodNotActive();\n\n-        INounsDAOForkEscrow forkEscrow = ds.forkEscrow;\n         address timelock = address(ds.timelock);\n         sendProRataTreasury(ds, ds.forkDAOTreasury, tokenIds.length, adjustedTotalSupply(ds));\n\n@@ -156,7 +155,7 @@ library NounsDAOV3Fork {\n\n         NounsTokenFork(ds.forkDAOToken).claimDuringForkPeriod(msg.sender, tokenIds);\n\n-        emit JoinFork(forkEscrow.forkId() - 1, msg.sender, tokenIds, proposalIds, reason);\n+        emit JoinFork(ds.forkEscrow.forkId() - 1, msg.sender, tokenIds, proposalIds, reason);\n     }\n```\n\n### NounsTokenFork.sol.claimDuringForkPeriod(): `_currentNounId` should not be cached\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol#L166-L185\n\nThe variable `currentNounId` is being once, as such no need to cache.\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol\n166:    function claimDuringForkPeriod(address to, uint256[] calldata tokenIds) external {\n167:        uint256 currentNounId = _currentNounId;\n\n184:        if (maxNounId >= currentNounId) _currentNounId = maxNounId + 1;\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-nounsdao",
  "Code": [
    {
      "filename": "packages/nouns-contracts/contracts/governance/fork/NounsDAOV3Fork.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/// @title Library for NounsDAOLogicV3 contract containing the dao fork logic\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\npragma solidity ^0.8.19;\n\nimport { NounsDAOStorageV3, INounsDAOForkEscrow, INounsDAOExecutorV2 } from '../NounsDAOInterfaces.sol';\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { NounsTokenFork } from './newdao/token/NounsTokenFork.sol';\n\nlibrary NounsDAOV3Fork {\n    error ForkThresholdNotMet();\n    error ForkPeriodNotActive();\n    error ForkPeriodActive();\n    error AdminOnly();\n    error UseAlternativeWithdrawFunction();\n\n    /// @notice Emitted when someones adds nouns to the fork escrow\n    event EscrowedToFork(\n        uint32 indexed forkId,\n        address indexed owner,\n        uint256[] tokenIds,\n        uint256[] proposalIds,\n        string reason\n    );\n\n    /// @notice Emitted when the owner withdraws their nouns from the fork escrow\n    event WithdrawFromForkEscrow(uint32 indexed forkId, address indexed owner, uint256[] tokenIds);\n\n    /// @notice Emitted when the fork is executed and the forking period begins\n    event ExecuteFork(\n        uint32 indexed forkId,\n        address forkTreasury,\n        address forkToken,\n        uint256 forkEndTimestamp,\n        uint256 tokensInEscrow\n    );\n\n    /// @notice Emitted when someone joins a fork during the forking period\n    event JoinFork(\n        uint32 indexed forkId,\n        address indexed owner,\n        uint256[] tokenIds,\n        uint256[] proposalIds,\n        string reason\n    );\n\n    /// @notice Emitted when the DAO withdraws nouns from the fork escrow after a fork has been executed\n    event DAOWithdrawNounsFromEscrow(uint256[] tokenIds, address to);\n\n    /// @notice Emitted when withdrawing nouns from escrow increases adjusted total supply\n    event DAONounsSupplyIncreasedFromEscrow(uint256 numTokens, address to);\n\n    /**\n     * @notice Escrow Nouns to contribute to the fork threshold\n     * @dev Requires approving the tokenIds or the entire noun token to the DAO contract\n     * @param tokenIds the tokenIds to escrow. They will be sent to the DAO once the fork threshold is reached and the escrow is closed.\n     * @param proposalIds array of proposal ids which are the reason for wanting to fork. This will only be used to emit event.\n     * @param reason the reason for want to fork. This will only be used to emit event.\n     */\n    function escrowToFork(\n        NounsDAOStorageV3.StorageV3 storage ds,\n        uint256[] calldata tokenIds,\n        uint256[] calldata proposalIds,\n        string calldata reason\n    ) external {\n        if (isForkPeriodActive(ds)) revert ForkPeriodActive();\n        INounsDAOForkEscrow forkEscrow = ds.forkEscrow;\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ds.nouns.safeTransferFrom(msg.sender, address(forkEscrow), tokenIds[i]);\n        }\n\n        emit EscrowedToFork(forkEscrow.forkId(), msg.sender, tokenIds, proposalIds, reason);\n    }\n\n    /**\n     * @notice Withdraw Nouns from the fork escrow. Only possible if the fork has not been executed.\n     * Only allowed to withdraw tokens that the sender has escrowed.\n     * @param tokenIds the tokenIds to withdraw\n     */\n    function withdrawFromForkEscrow(NounsDAOStorageV3.StorageV3 storage ds, uint256[] calldata tokenIds) external {\n        if (isForkPeriodActive(ds)) revert ForkPeriodActive();\n\n        INounsDAOForkEscrow forkEscrow = ds.forkEscrow;\n        forkEscrow.returnTokensToOwner(msg.sender, tokenIds);\n\n        emit WithdrawFromForkEscrow(forkEscrow.forkId(), msg.sender, tokenIds);\n    }\n\n    /**\n     * @notice Execute the fork. Only possible if the fork threshold has been exceeded.\n     * This will deploy a new DAO and send the prorated part of the treasury to the new DAO's treasury.\n     * This will also close the active escrow and all nouns in the escrow will belong to the original DAO.\n     * @return forkTreasury The address of the new DAO's treasury\n     * @return forkToken The address of the new DAO's token\n     */\n    function executeFork(NounsDAOStorageV3.StorageV3 storage ds)\n        external\n        returns (address forkTreasury, address forkToken)\n    {\n        if (isForkPeriodActive(ds)) revert ForkPeriodActive();\n        INounsDAOForkEscrow forkEscrow = ds.forkEscrow;\n\n        uint256 tokensInEscrow = forkEscrow.numTokensInEscrow();\n        if (tokensInEscrow <= forkThreshold(ds)) revert ForkThresholdNotMet();\n\n        uint256 forkEndTimestamp = block.timestamp + ds.forkPeriod;\n\n        (forkTreasury, forkToken) = ds.forkDAODeployer.deployForkDAO(forkEndTimestamp, forkEscrow);\n        sendProRataTreasury(ds, forkTreasury, tokensInEscrow, adjustedTotalSupply(ds));\n        uint32 forkId = forkEscrow.closeEscrow();\n\n        ds.forkDAOTreasury = forkTreasury;\n        ds.forkDAOToken = forkToken;\n        ds.forkEndTimestamp = forkEndTimestamp;\n\n        emit ExecuteFork(forkId, forkTreasury, forkToken, forkEndTimestamp, tokensInEscrow);\n    }\n\n    /**\n     * @notice Joins a fork while a fork is active\n     * Sends the tokens to the timelock contract.\n     * Sends a prorated part of the treasury to the new fork DAO's treasury.\n     * Mints new tokens in the new fork DAO with the same token ids.\n     * @param tokenIds the tokenIds to send to the DAO in exchange for joining the fork\n     */\n    function joinFork(\n        NounsDAOStorageV3.StorageV3 storage ds,\n        uint256[] calldata tokenIds,\n        uint256[] calldata proposalIds,\n        string calldata reason\n    ) external {\n        if (!isForkPeriodActive(ds)) revert ForkPeriodNotActive();\n\n        INounsDAOForkEscrow forkEscrow = ds.forkEscrow;\n        address timelock = address(ds.timelock);\n        sendProRataTreasury(ds, ds.forkDAOTreasury, tokenIds.length, adjustedTotalSupply(ds));\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ds.nouns.transferFrom(msg.sender, timelock, tokenIds[i]);\n        }\n\n        NounsTokenFork(ds.forkDAOToken).claimDuringForkPeriod(msg.sender, tokenIds);\n\n        emit JoinFork(forkEscrow.forkId() - 1, msg.sender, tokenIds, proposalIds, reason);\n    }\n\n    /**\n     * @notice Withdraws nouns from the fork escrow to the treasury after the fork has been executed\n     * @dev Only the DAO can call this function\n     * @param tokenIds the tokenIds to withdraw\n     */\n    function withdrawDAONounsFromEscrowToTreasury(NounsDAOStorageV3.StorageV3 storage ds, uint256[] calldata tokenIds)\n        external\n    {\n        withdrawDAONounsFromEscrow(ds, tokenIds, address(ds.timelock));\n    }\n\n    /**\n     * @notice Withdraws nouns from the fork escrow after the fork has been executed to an address other than the treasury\n     * @dev Only the DAO can call this function\n     * @param tokenIds the tokenIds to withdraw\n     * @param to the address to send the nouns to\n     */\n    function withdrawDAONounsFromEscrowIncreasingTotalSupply(\n        NounsDAOStorageV3.StorageV3 storage ds,\n        uint256[] calldata tokenIds,\n        address to\n    ) external {\n        if (to == address(ds.timelock)) revert UseAlternativeWithdrawFunction();\n\n        withdrawDAONounsFromEscrow(ds, tokenIds, to);\n\n        emit DAONounsSupplyIncreasedFromEscrow(tokenIds.length, to);\n    }\n\n    function withdrawDAONounsFromEscrow(\n        NounsDAOStorageV3.StorageV3 storage ds,\n        uint256[] calldata tokenIds,\n        address to\n    ) private {\n        if (msg.sender != ds.admin) {\n            revert AdminOnly();\n        }\n\n        ds.forkEscrow.withdrawTokens(tokenIds, to);\n\n        emit DAOWithdrawNounsFromEscrow(tokenIds, to);\n    }\n\n    /**\n     * @notice Returns the required number of tokens to escrow to trigger a fork\n     */\n    function forkThreshold(NounsDAOStorageV3.StorageV3 storage ds) public view returns (uint256) {\n        return (adjustedTotalSupply(ds) * ds.forkThresholdBPS) / 10_000;\n    }\n\n    /**\n     * @notice Returns the number of tokens currently in escrow, contributing to the fork threshold\n     */\n    function numTokensInForkEscrow(NounsDAOStorageV3.StorageV3 storage ds) public view returns (uint256) {\n        return ds.forkEscrow.numTokensInEscrow();\n    }\n\n    /**\n     * @notice Returns the number of nouns in supply minus nouns owned by the DAO, i.e. held in the treasury or in an\n     * escrow after it has closed.\n     * This is used when calculating proposal threshold, quorum, fork threshold & treasury split.\n     */\n    function adjustedTotalSupply(NounsDAOStorageV3.StorageV3 storage ds) internal view returns (uint256) {\n        return ds.nouns.totalSupply() - ds.nouns.balanceOf(address(ds.timelock)) - ds.forkEscrow.numTokensOwnedByDAO();\n    }\n\n    /**\n     * @notice Returns true if noun holders can currently join a fork\n     */\n    function isForkPeriodActive(NounsDAOStorageV3.StorageV3 storage ds) internal view returns (bool) {\n        return ds.forkEndTimestamp > block.timestamp;\n    }\n\n    /**\n     * @notice Sends part of the DAO's treasury to the `newDAOTreasury` address.\n     * The amount sent is proportional to the `tokenCount` out of `totalSupply`.\n     * Sends ETH and ERC20 tokens listed in `ds.erc20TokensToIncludeInFork`.\n     */\n    function sendProRataTreasury(\n        NounsDAOStorageV3.StorageV3 storage ds,\n        address newDAOTreasury,\n        uint256 tokenCount,\n        uint256 totalSupply\n    ) internal {\n        INounsDAOExecutorV2 timelock = ds.timelock;\n        uint256 ethToSend = (address(timelock).balance * tokenCount) / totalSupply;\n\n        timelock.sendETH(newDAOTreasury, ethToSend);\n\n        uint256 erc20Count = ds.erc20TokensToIncludeInFork.length;\n        for (uint256 i = 0; i < erc20Count; ++i) {\n            IERC20 erc20token = IERC20(ds.erc20TokensToIncludeInFork[i]);\n            uint256 tokensToSend = (erc20token.balanceOf(address(timelock)) * tokenCount) / totalSupply;\n            if (tokensToSend > 0) {\n                timelock.sendERC20(newDAOTreasury, address(erc20token), tokensToSend);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/// @title The Nouns ERC-721 token, adjusted for forks\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\npragma solidity ^0.8.19;\n\nimport { OwnableUpgradeable } from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport { ERC721CheckpointableUpgradeable } from './base/ERC721CheckpointableUpgradeable.sol';\nimport { INounsDescriptorMinimal } from '../../../../interfaces/INounsDescriptorMinimal.sol';\nimport { INounsSeeder } from '../../../../interfaces/INounsSeeder.sol';\nimport { INounsTokenFork } from './INounsTokenFork.sol';\nimport { IERC721 } from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport { UUPSUpgradeable } from '@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol';\nimport { INounsDAOForkEscrow } from '../../../NounsDAOInterfaces.sol';\n\n/**\n * @dev This contract is a fork of NounsToken, with the following changes:\n * - Added upgradeablity via UUPSUpgradeable.\n * - Inheriting from an unmodified ERC721, so that the double Transfer event emission that\n *   NounsToken performs is gone, in favor of the standard single event.\n * - Added functions to claim tokens from a Nouns Fork escrow, or during the forking period.\n * - Removed the proxyRegistry feature that whitelisted OpenSea.\n * - Removed `noundersDAO` and the founder reward every 10 mints.\n * For additional context see `ERC721CheckpointableUpgradeable`.\n */\ncontract NounsTokenFork is INounsTokenFork, OwnableUpgradeable, ERC721CheckpointableUpgradeable, UUPSUpgradeable {\n    error OnlyOwner();\n    error OnlyTokenOwnerCanClaim();\n    error OnlyOriginalDAO();\n    error NoundersCannotBeAddressZero();\n    error OnlyDuringForkingPeriod();\n\n    string public constant NAME = 'NounsTokenFork';\n\n    /// @notice  An address who has permissions to mint Nouns\n    address public minter;\n\n    /// @notice The Nouns token URI descriptor\n    INounsDescriptorMinimal public descriptor;\n\n    /// @notice The Nouns token seeder\n    INounsSeeder public seeder;\n\n    /// @notice The escrow contract used to verify ownership of the original Nouns in the post-fork claiming process\n    INounsDAOForkEscrow public escrow;\n\n    /// @notice The fork ID, used when querying the escrow for token ownership\n    uint32 public forkId;\n\n    /// @notice How many tokens are still available to be claimed by Nouners who put their original Nouns in escrow\n    uint256 public remainingTokensToClaim;\n\n    /// @notice The forking period expiration timestamp, after which new tokens cannot be claimed by the original DAO\n    uint256 public forkingPeriodEndTimestamp;\n\n    /// @notice Whether the minter can be updated\n    bool public isMinterLocked;\n\n    /// @notice Whether the descriptor can be updated\n    bool public isDescriptorLocked;\n\n    /// @notice Whether the seeder can be updated\n    bool public isSeederLocked;\n\n    /// @notice The noun seeds\n    mapping(uint256 => INounsSeeder.Seed) public seeds;\n\n    /// @notice The internal noun ID tracker\n    uint256 private _currentNounId;\n\n    /// @notice IPFS content hash of contract-level metadata\n    string private _contractURIHash = 'QmZi1n79FqWt2tTLwCqiy6nLM6xLGRsEPQ5JmReJQKNNzX';\n\n    /**\n     * @notice Require that the minter has not been locked.\n     */\n    modifier whenMinterNotLocked() {\n        require(!isMinterLocked, 'Minter is locked');\n        _;\n    }\n\n    /**\n     * @notice Require that the descriptor has not been locked.\n     */\n    modifier whenDescriptorNotLocked() {\n        require(!isDescriptorLocked, 'Descriptor is locked');\n        _;\n    }\n\n    /**\n     * @notice Require that the seeder has not been locked.\n     */\n    modifier whenSeederNotLocked() {\n        require(!isSeederLocked, 'Seeder is locked');\n        _;\n    }\n\n    /**\n     * @notice Require that the sender is the minter.\n     */\n    modifier onlyMinter() {\n        require(msg.sender == minter, 'Sender is not the minter');\n        _;\n    }\n\n    function initialize(\n        address _owner,\n        address _minter,\n        INounsDAOForkEscrow _escrow,\n        uint32 _forkId,\n        uint256 startNounId,\n        uint256 tokensToClaim,\n        uint256 _forkingPeriodEndTimestamp\n    ) external initializer {\n        __ERC721_init('Nouns', 'NOUN');\n        _transferOwnership(_owner);\n        minter = _minter;\n        escrow = _escrow;\n        forkId = _forkId;\n        _currentNounId = startNounId;\n        remainingTokensToClaim = tokensToClaim;\n        forkingPeriodEndTimestamp = _forkingPeriodEndTimestamp;\n\n        NounsTokenFork originalToken = NounsTokenFork(address(escrow.nounsToken()));\n        descriptor = originalToken.descriptor();\n        seeder = originalToken.seeder();\n    }\n\n    /**\n     * @notice Claim new tokens if you escrowed original Nouns and forked into a new DAO governed by holders of this\n     * token.\n     * @dev Reverts if the sender is not the owner of the escrowed token.\n     * @param tokenIds The token IDs to claim\n     */\n    function claimFromEscrow(uint256[] calldata tokenIds) external {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            uint256 nounId = tokenIds[i];\n            if (escrow.ownerOfEscrowedToken(forkId, nounId) != msg.sender) revert OnlyTokenOwnerCanClaim();\n\n            _mintWithOriginalSeed(msg.sender, nounId);\n        }\n\n        remainingTokensToClaim -= tokenIds.length;\n    }\n\n    /**\n     * @notice The original DAO can claim tokens during the forking period, on behalf of Nouners who choose to join\n     * a new fork DAO. Does not allow the original DAO to claim once the forking period has ended.\n     * @dev Assumes the original DAO is honest during the forking period.\n     * @param to The recipient of the tokens\n     * @param tokenIds The token IDs to claim\n     */\n    function claimDuringForkPeriod(address to, uint256[] calldata tokenIds) external {\n        uint256 currentNounId = _currentNounId;\n        uint256 maxNounId = 0;\n        if (msg.sender != escrow.dao()) revert OnlyOriginalDAO();\n        if (block.timestamp >= forkingPeriodEndTimestamp) revert OnlyDuringForkingPeriod();\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            uint256 nounId = tokenIds[i];\n            _mintWithOriginalSeed(to, nounId);\n\n            if (tokenIds[i] > maxNounId) maxNounId = tokenIds[i];\n        }\n\n        // This treats an important case:\n        // During a forking period, people can buy new Nouns on auction, with a higher ID than the auction ID at forking\n        // They can then join the fork with those IDs\n        // If we don't increment currentNounId, unpausing the fork auction house would revert\n        // Since it would attempt to mint a noun with an ID that already exists\n        if (maxNounId >= currentNounId) _currentNounId = maxNounId + 1;\n    }\n\n    /**\n     * @notice The IPFS URI of contract-level metadata.\n     */\n    function contractURI() public view returns (string memory) {\n        return string(abi.encodePacked('ipfs://', _contractURIHash));\n    }\n\n    /**\n     * @notice Set the _contractURIHash.\n     * @dev Only callable by the owner.\n     */\n    function setContractURIHash(string memory newContractURIHash) external onlyOwner {\n        _contractURIHash = newContractURIHash;\n    }\n\n    /**\n     * @notice Mint a Noun to the minter\n     * @dev Call _mintTo with the to address(es).\n     */\n    function mint() public override onlyMinter returns (uint256) {\n        return _mintTo(minter, _currentNounId++);\n    }\n\n    /**\n     * @notice Burn a noun.\n     */\n    function burn(uint256 nounId) public override onlyMinter {\n        _burn(nounId);\n        emit NounBurned(nounId);\n    }\n\n    /**\n     * @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        require(_exists(tokenId), 'NounsToken: URI query for nonexistent token');\n        return descriptor.tokenURI(tokenId, seeds[tokenId]);\n    }\n\n    /**\n     * @notice Similar to `tokenURI`, but always serves a base64 encoded data URI\n     * with the JSON contents directly inlined.\n     */\n    function dataURI(uint256 tokenId) public view override returns (string memory) {\n        require(_exists(tokenId), 'NounsToken: URI query for nonexistent token');\n        return descriptor.dataURI(tokenId, seeds[tokenId]);\n    }\n\n    /**\n     * @notice Set the token minter.\n     * @dev Only callable by the owner when not locked.\n     */\n    function setMinter(address _minter) external override onlyOwner whenMinterNotLocked {\n        minter = _minter;\n\n        emit MinterUpdated(_minter);\n    }\n\n    /**\n     * @notice Lock the minter.\n     * @dev This cannot be reversed and is only callable by the owner when not locked.\n     */\n    function lockMinter() external override onlyOwner whenMinterNotLocked {\n        isMinterLocked = true;\n\n        emit MinterLocked();\n    }\n\n    /**\n     * @notice Set the token URI descriptor.\n     * @dev Only callable by the owner when not locked.\n     */\n    function setDescriptor(INounsDescriptorMinimal _descriptor) external override onlyOwner whenDescriptorNotLocked {\n        descriptor = _descriptor;\n\n        emit DescriptorUpdated(_descriptor);\n    }\n\n    /**\n     * @notice Lock the descriptor.\n     * @dev This cannot be reversed and is only callable by the owner when not locked.\n     */\n    function lockDescriptor() external override onlyOwner whenDescriptorNotLocked {\n        isDescriptorLocked = true;\n\n        emit DescriptorLocked();\n    }\n\n    /**\n     * @notice Set the token seeder.\n     * @dev Only callable by the owner when not locked.\n     */\n    function setSeeder(INounsSeeder _seeder) external override onlyOwner whenSeederNotLocked {\n        seeder = _seeder;\n\n        emit SeederUpdated(_seeder);\n    }\n\n    /**\n     * @notice Lock the seeder.\n     * @dev This cannot be reversed and is only callable by the owner when not locked.\n     */\n    function lockSeeder() external override onlyOwner whenSeederNotLocked {\n        isSeederLocked = true;\n\n        emit SeederLocked();\n    }\n\n    /**\n     * @notice Mint a Noun with `nounId` to the provided `to` address.\n     */\n    function _mintTo(address to, uint256 nounId) internal returns (uint256) {\n        INounsSeeder.Seed memory seed = seeds[nounId] = seeder.generateSeed(nounId, descriptor);\n\n        _mint(to, nounId);\n        emit NounCreated(nounId, seed);\n\n        return nounId;\n    }\n\n    /**\n     * @notice Mint a new token using the original Nouns seed.\n     */\n    function _mintWithOriginalSeed(address to, uint256 nounId) internal {\n        (uint48 background, uint48 body, uint48 accessory, uint48 head, uint48 glasses) = NounsTokenFork(\n            address(escrow.nounsToken())\n        ).seeds(nounId);\n        INounsSeeder.Seed memory seed = INounsSeeder.Seed(background, body, accessory, head, glasses);\n\n        seeds[nounId] = seed;\n        _mint(to, nounId);\n\n        emit NounCreated(nounId, seed);\n    }\n\n    /**\n     * @dev Reverts when `msg.sender` is not the owner of this contract; in the case of Noun DAOs it should be the\n     * DAO's treasury contract.\n     */\n    function _authorizeUpgrade(address) internal view override onlyOwner {}\n}"
    }
  ]
}