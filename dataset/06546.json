{
  "Title": "[19] WORD TYPING TYPO",
  "Content": "The following code comment uses two \"to's\" in \"having to to use\". Please consider changing this phrase to \"having to use\".\n\nhttps://github.com/ethereum-optimism/optimism/blob/536178b0e28f7015e036ad050945ea5633dacf02/packages/contracts-bedrock/contracts/deployment/SystemDictator.sol#L168-L169\n```solidity\n        // Using this shorter variable as an alias for address(0) just prevents us from having to\n        // to use a new line for every single parameter.\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-05-base",
  "Code": [
    {
      "filename": "packages/contracts-bedrock/contracts/deployment/SystemDictator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { OptimismPortal } from \"../L1/OptimismPortal.sol\";\nimport { L1CrossDomainMessenger } from \"../L1/L1CrossDomainMessenger.sol\";\nimport { L1ERC721Bridge } from \"../L1/L1ERC721Bridge.sol\";\nimport { L1StandardBridge } from \"../L1/L1StandardBridge.sol\";\nimport { L1ChugSplashProxy } from \"../legacy/L1ChugSplashProxy.sol\";\nimport { AddressManager } from \"../legacy/AddressManager.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { ProxyAdmin } from \"../universal/ProxyAdmin.sol\";\nimport { OptimismMintableERC20Factory } from \"../universal/OptimismMintableERC20Factory.sol\";\nimport { PortalSender } from \"./PortalSender.sol\";\nimport { SystemConfig } from \"../L1/SystemConfig.sol\";\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\n\n/**\n * @title SystemDictator\n * @notice The SystemDictator is responsible for coordinating the deployment of a full Bedrock\n *         system. The SystemDictator is designed to support both fresh network deployments and\n *         upgrades to existing pre-Bedrock systems.\n */\ncontract SystemDictator is OwnableUpgradeable {\n    /**\n     * @notice Basic system configuration.\n     */\n    struct GlobalConfig {\n        AddressManager addressManager;\n        ProxyAdmin proxyAdmin;\n        address controller;\n        address finalOwner;\n    }\n\n    /**\n     * @notice Set of proxy addresses.\n     */\n    struct ProxyAddressConfig {\n        address l2OutputOracleProxy;\n        address optimismPortalProxy;\n        address l1CrossDomainMessengerProxy;\n        address l1StandardBridgeProxy;\n        address optimismMintableERC20FactoryProxy;\n        address l1ERC721BridgeProxy;\n        address systemConfigProxy;\n    }\n\n    /**\n     * @notice Set of implementation addresses.\n     */\n    struct ImplementationAddressConfig {\n        L2OutputOracle l2OutputOracleImpl;\n        OptimismPortal optimismPortalImpl;\n        L1CrossDomainMessenger l1CrossDomainMessengerImpl;\n        L1StandardBridge l1StandardBridgeImpl;\n        OptimismMintableERC20Factory optimismMintableERC20FactoryImpl;\n        L1ERC721Bridge l1ERC721BridgeImpl;\n        PortalSender portalSenderImpl;\n        SystemConfig systemConfigImpl;\n    }\n\n    /**\n     * @notice Dynamic L2OutputOracle config.\n     */\n    struct L2OutputOracleDynamicConfig {\n        uint256 l2OutputOracleStartingBlockNumber;\n        uint256 l2OutputOracleStartingTimestamp;\n    }\n\n    /**\n     * @notice Values for the system config contract.\n     */\n    struct SystemConfigConfig {\n        address owner;\n        uint256 overhead;\n        uint256 scalar;\n        bytes32 batcherHash;\n        uint64 gasLimit;\n        address unsafeBlockSigner;\n        ResourceMetering.ResourceConfig resourceConfig;\n    }\n\n    /**\n     * @notice Combined system configuration.\n     */\n    struct DeployConfig {\n        GlobalConfig globalConfig;\n        ProxyAddressConfig proxyAddressConfig;\n        ImplementationAddressConfig implementationAddressConfig;\n        SystemConfigConfig systemConfigConfig;\n    }\n\n    /**\n     * @notice Step after which exit 1 can no longer be used.\n     */\n    uint8 public constant EXIT_1_NO_RETURN_STEP = 3;\n\n    /**\n     * @notice Step where proxy ownership is transferred.\n     */\n    uint8 public constant PROXY_TRANSFER_STEP = 4;\n\n    /**\n     * @notice System configuration.\n     */\n    DeployConfig public config;\n\n    /**\n     * @notice Dynamic configuration for the L2OutputOracle.\n     */\n    L2OutputOracleDynamicConfig public l2OutputOracleDynamicConfig;\n\n    /**\n     * @notice Dynamic configuration for the OptimismPortal. Determines\n     *         if the system should be paused when initialized.\n     */\n    bool public optimismPortalDynamicConfig;\n\n    /**\n     * @notice Current step;\n     */\n    uint8 public currentStep;\n\n    /**\n     * @notice Whether or not dynamic config has been set.\n     */\n    bool public dynamicConfigSet;\n\n    /**\n     * @notice Whether or not the deployment is finalized.\n     */\n    bool public finalized;\n\n    /**\n     * @notice Whether or not the deployment has been exited.\n     */\n    bool public exited;\n\n    /**\n     * @notice Address of the old L1CrossDomainMessenger implementation.\n     */\n    address public oldL1CrossDomainMessenger;\n\n    /**\n     * @notice Checks that the current step is the expected step, then bumps the current step.\n     *\n     * @param _step Current step.\n     */\n    modifier step(uint8 _step) {\n        require(!finalized, \"SystemDictator: already finalized\");\n        require(!exited, \"SystemDictator: already exited\");\n        require(currentStep == _step, \"SystemDictator: incorrect step\");\n        _;\n        currentStep++;\n    }\n\n    /**\n     * @notice Constructor required to ensure that the implementation of the SystemDictator is\n     *         initialized upon deployment.\n     */\n    constructor() {\n        ResourceMetering.ResourceConfig memory rcfg = Constants.DEFAULT_RESOURCE_CONFIG();\n\n        // Using this shorter variable as an alias for address(0) just prevents us from having to\n        // to use a new line for every single parameter.\n        address zero = address(0);\n        initialize(\n            DeployConfig(\n                GlobalConfig(AddressManager(zero), ProxyAdmin(zero), zero, zero),\n                ProxyAddressConfig(zero, zero, zero, zero, zero, zero, zero),\n                ImplementationAddressConfig(\n                    L2OutputOracle(zero),\n                    OptimismPortal(payable(zero)),\n                    L1CrossDomainMessenger(zero),\n                    L1StandardBridge(payable(zero)),\n                    OptimismMintableERC20Factory(zero),\n                    L1ERC721Bridge(zero),\n                    PortalSender(zero),\n                    SystemConfig(zero)\n                ),\n                SystemConfigConfig(zero, 0, 0, bytes32(0), 0, zero, rcfg)\n            )\n        );\n    }\n\n    /**\n     * @param _config System configuration.\n     */\n    function initialize(DeployConfig memory _config) public initializer {\n        config = _config;\n        currentStep = 1;\n        __Ownable_init();\n        _transferOwnership(config.globalConfig.controller);\n    }\n\n    /**\n     * @notice Allows the owner to update dynamic config.\n     *\n     * @param _l2OutputOracleDynamicConfig Dynamic L2OutputOracle config.\n     * @param _optimismPortalDynamicConfig Dynamic OptimismPortal config.\n     */\n    function updateDynamicConfig(\n        L2OutputOracleDynamicConfig memory _l2OutputOracleDynamicConfig,\n        bool _optimismPortalDynamicConfig\n    ) external onlyOwner {\n        l2OutputOracleDynamicConfig = _l2OutputOracleDynamicConfig;\n        optimismPortalDynamicConfig = _optimismPortalDynamicConfig;\n        dynamicConfigSet = true;\n    }\n\n    /**\n     * @notice Configures the ProxyAdmin contract.\n     */\n    function step1() public onlyOwner step(1) {\n        // Set the AddressManager in the ProxyAdmin.\n        config.globalConfig.proxyAdmin.setAddressManager(config.globalConfig.addressManager);\n\n        // Set the L1CrossDomainMessenger to the RESOLVED proxy type.\n        config.globalConfig.proxyAdmin.setProxyType(\n            config.proxyAddressConfig.l1CrossDomainMessengerProxy,\n            ProxyAdmin.ProxyType.RESOLVED\n        );\n\n        // Set the implementation name for the L1CrossDomainMessenger.\n        config.globalConfig.proxyAdmin.setImplementationName(\n            config.proxyAddressConfig.l1CrossDomainMessengerProxy,\n            \"OVM_L1CrossDomainMessenger\"\n        );\n\n        // Set the L1StandardBridge to the CHUGSPLASH proxy type.\n        config.globalConfig.proxyAdmin.setProxyType(\n            config.proxyAddressConfig.l1StandardBridgeProxy,\n            ProxyAdmin.ProxyType.CHUGSPLASH\n        );\n\n        // Upgrade and initialize the SystemConfig so the Sequencer can start up.\n        config.globalConfig.proxyAdmin.upgradeAndCall(\n            payable(config.proxyAddressConfig.systemConfigProxy),\n            address(config.implementationAddressConfig.systemConfigImpl),\n            abi.encodeCall(\n                SystemConfig.initialize,\n                (\n                    config.systemConfigConfig.owner,\n                    config.systemConfigConfig.overhead,\n                    config.systemConfigConfig.scalar,\n                    config.systemConfigConfig.batcherHash,\n                    config.systemConfigConfig.gasLimit,\n                    config.systemConfigConfig.unsafeBlockSigner,\n                    config.systemConfigConfig.resourceConfig\n                )\n            )\n        );\n    }\n\n    /**\n     * @notice Pauses the system by shutting down the L1CrossDomainMessenger and setting the\n     *         deposit halt flag to tell the Sequencer's DTL to stop accepting deposits.\n     */\n    function step2() public onlyOwner step(2) {\n        // Store the address of the old L1CrossDomainMessenger implementation. We will need this\n        // address in the case that we have to exit early.\n        oldL1CrossDomainMessenger = config.globalConfig.addressManager.getAddress(\n            \"OVM_L1CrossDomainMessenger\"\n        );\n\n        // Temporarily brick the L1CrossDomainMessenger by setting its implementation address to\n        // address(0) which will cause the ResolvedDelegateProxy to revert. Better than pausing\n        // the L1CrossDomainMessenger via pause() because it can be easily reverted.\n        config.globalConfig.addressManager.setAddress(\"OVM_L1CrossDomainMessenger\", address(0));\n\n        // Set the DTL shutoff block, which will tell the DTL to stop syncing new deposits from the\n        // CanonicalTransactionChain. We do this by setting an address in the AddressManager\n        // because the DTL already has a reference to the AddressManager and this way we don't also\n        // need to give it a reference to the SystemDictator.\n        config.globalConfig.addressManager.setAddress(\n            \"DTL_SHUTOFF_BLOCK\",\n            address(uint160(block.number))\n        );\n    }\n\n    /**\n     * @notice Removes deprecated addresses from the AddressManager.\n     */\n    function step3() public onlyOwner step(EXIT_1_NO_RETURN_STEP) {\n        // Remove all deprecated addresses from the AddressManager\n        string[17] memory deprecated = [\n            \"OVM_CanonicalTransactionChain\",\n            \"OVM_L2CrossDomainMessenger\",\n            \"OVM_DecompressionPrecompileAddress\",\n            \"OVM_Sequencer\",\n            \"OVM_Proposer\",\n            \"OVM_ChainStorageContainer-CTC-batches\",\n            \"OVM_ChainStorageContainer-CTC-queue\",\n            \"OVM_CanonicalTransactionChain\",\n            \"OVM_StateCommitmentChain\",\n            \"OVM_BondManager\",\n            \"OVM_ExecutionManager\",\n            \"OVM_FraudVerifier\",\n            \"OVM_StateManagerFactory\",\n            \"OVM_StateTransitionerFactory\",\n            \"OVM_SafetyChecker\",\n            \"OVM_L1MultiMessageRelayer\",\n            \"BondManager\"\n        ];\n\n        for (uint256 i = 0; i < deprecated.length; i++) {\n            config.globalConfig.addressManager.setAddress(deprecated[i], address(0));\n        }\n    }\n\n    /**\n     * @notice Transfers system ownership to the ProxyAdmin.\n     */\n    function step4() public onlyOwner step(PROXY_TRANSFER_STEP) {\n        // Transfer ownership of the AddressManager to the ProxyAdmin.\n        config.globalConfig.addressManager.transferOwnership(\n            address(config.globalConfig.proxyAdmin)\n        );\n\n        // Transfer ownership of the L1StandardBridge to the ProxyAdmin.\n        L1ChugSplashProxy(payable(config.proxyAddressConfig.l1StandardBridgeProxy)).setOwner(\n            address(config.globalConfig.proxyAdmin)\n        );\n\n        // Transfer ownership of the L1ERC721Bridge to the ProxyAdmin.\n        Proxy(payable(config.proxyAddressConfig.l1ERC721BridgeProxy)).changeAdmin(\n            address(config.globalConfig.proxyAdmin)\n        );\n    }\n\n    /**\n     * @notice Upgrades and initializes proxy contracts.\n     */\n    function step5() public onlyOwner step(5) {\n        // Dynamic config must be set before we can initialize the L2OutputOracle.\n        require(dynamicConfigSet, \"SystemDictator: dynamic oracle config is not yet initialized\");\n\n        // Upgrade and initialize the L2OutputOracle.\n        config.globalConfig.proxyAdmin.upgradeAndCall(\n            payable(config.proxyAddressConfig.l2OutputOracleProxy),\n            address(config.implementationAddressConfig.l2OutputOracleImpl),\n            abi.encodeCall(\n                L2OutputOracle.initialize,\n                (\n                    l2OutputOracleDynamicConfig.l2OutputOracleStartingBlockNumber,\n                    l2OutputOracleDynamicConfig.l2OutputOracleStartingTimestamp\n                )\n            )\n        );\n\n        // Upgrade and initialize the OptimismPortal.\n        config.globalConfig.proxyAdmin.upgradeAndCall(\n            payable(config.proxyAddressConfig.optimismPortalProxy),\n            address(config.implementationAddressConfig.optimismPortalImpl),\n            abi.encodeCall(OptimismPortal.initialize, (optimismPortalDynamicConfig))\n        );\n\n        // Upgrade the L1CrossDomainMessenger.\n        config.globalConfig.proxyAdmin.upgrade(\n            payable(config.proxyAddressConfig.l1CrossDomainMessengerProxy),\n            address(config.implementationAddressConfig.l1CrossDomainMessengerImpl)\n        );\n\n        // Try to initialize the L1CrossDomainMessenger, only fail if it's already been initialized.\n        try\n            L1CrossDomainMessenger(config.proxyAddressConfig.l1CrossDomainMessengerProxy)\n                .initialize()\n        {\n            // L1CrossDomainMessenger is the one annoying edge case difference between existing\n            // networks and fresh networks because in existing networks it'll already be\n            // initialized but in fresh networks it won't be. Try/catch is the easiest and most\n            // consistent way to handle this because initialized() is not exposed publicly.\n        } catch Error(string memory reason) {\n            require(\n                keccak256(abi.encodePacked(reason)) ==\n                    keccak256(\"Initializable: contract is already initialized\"),\n                string.concat(\"SystemDictator: unexpected error initializing L1XDM: \", reason)\n            );\n        } catch {\n            revert(\"SystemDictator: unexpected error initializing L1XDM (no reason)\");\n        }\n\n        // Transfer ETH from the L1StandardBridge to the OptimismPortal.\n        config.globalConfig.proxyAdmin.upgradeAndCall(\n            payable(config.proxyAddressConfig.l1StandardBridgeProxy),\n            address(config.implementationAddressConfig.portalSenderImpl),\n            abi.encodeCall(PortalSender.donate, ())\n        );\n\n        // Upgrade the L1StandardBridge (no initializer).\n        config.globalConfig.proxyAdmin.upgrade(\n            payable(config.proxyAddressConfig.l1StandardBridgeProxy),\n            address(config.implementationAddressConfig.l1StandardBridgeImpl)\n        );\n\n        // Upgrade the OptimismMintableERC20Factory (no initializer).\n        config.globalConfig.proxyAdmin.upgrade(\n            payable(config.proxyAddressConfig.optimismMintableERC20FactoryProxy),\n            address(config.implementationAddressConfig.optimismMintableERC20FactoryImpl)\n        );\n\n        // Upgrade the L1ERC721Bridge (no initializer).\n        config.globalConfig.proxyAdmin.upgrade(\n            payable(config.proxyAddressConfig.l1ERC721BridgeProxy),\n            address(config.implementationAddressConfig.l1ERC721BridgeImpl)\n        );\n    }\n\n    /**\n     * @notice Calls the first 2 steps of the migration process.\n     */\n    function phase1() external onlyOwner {\n        step1();\n        step2();\n    }\n\n    /**\n     * @notice Calls the remaining steps of the migration process, and finalizes.\n     */\n    function phase2() external onlyOwner {\n        step3();\n        step4();\n        step5();\n        finalize();\n    }\n\n    /**\n     * @notice Tranfers admin ownership to the final owner.\n     */\n    function finalize() public onlyOwner {\n        // Transfer ownership of the ProxyAdmin to the final owner.\n        config.globalConfig.proxyAdmin.transferOwnership(config.globalConfig.finalOwner);\n\n        // Optionally also transfer AddressManager and L1StandardBridge if we still own it. Might\n        // happen if we're exiting early.\n        if (currentStep <= PROXY_TRANSFER_STEP) {\n            // Transfer ownership of the AddressManager to the final owner.\n            config.globalConfig.addressManager.transferOwnership(\n                address(config.globalConfig.finalOwner)\n            );\n\n            // Transfer ownership of the L1StandardBridge to the final owner.\n            L1ChugSplashProxy(payable(config.proxyAddressConfig.l1StandardBridgeProxy)).setOwner(\n                address(config.globalConfig.finalOwner)\n            );\n\n            // Transfer ownership of the L1ERC721Bridge to the final owner.\n            Proxy(payable(config.proxyAddressConfig.l1ERC721BridgeProxy)).changeAdmin(\n                address(config.globalConfig.finalOwner)\n            );\n        }\n\n        // Mark the deployment as finalized.\n        finalized = true;\n    }\n\n    /**\n     * @notice First exit point, can only be called before step 3 is executed.\n     */\n    function exit1() external onlyOwner {\n        require(\n            currentStep == EXIT_1_NO_RETURN_STEP,\n            \"SystemDictator: can only exit1 before step 3 is executed\"\n        );\n\n        // Reset the L1CrossDomainMessenger to the old implementation.\n        config.globalConfig.addressManager.setAddress(\n            \"OVM_L1CrossDomainMessenger\",\n            oldL1CrossDomainMessenger\n        );\n\n        // Unset the DTL shutoff block which will allow the DTL to sync again.\n        config.globalConfig.addressManager.setAddress(\"DTL_SHUTOFF_BLOCK\", address(0));\n\n        // Mark the deployment as exited.\n        exited = true;\n    }\n}"
    }
  ]
}