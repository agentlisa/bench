{
  "Title": "H-1: ETH deposited by the user may be stolen.",
  "Content": "# Issue H-1: ETH deposited by the user may be stolen. \n\nSource: https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/1 \n\n## Found by \n0x007, 0x3b, 0xComfyCat, 0xDjango, 0xJuda, 0xSurena, 0xbepresent, 0xdeadbeef, 0xmuxyz, 0xvj, Breeje, Flora, SaharDevep, TangYuanShen, VAD37, asui, berndartmueller, bin2chen, caelumimperium, chaduke, ck, duc, enfrasico, harisnabeel, lemonmon, lodelux, n33k, nobody2018, p0wd3r, pengun, rvierdiiev, saidam017, shogoki, talfao, vagrant, warRoom, xiaoming90\nDue to the fact that the WETH obtained through `_processEthIn` belongs to the contract, and `pullToken` transfers assets from `msg.sender`, it is possible for users to transfer excess WETH to the contract, allowing attackers to steal WETH from within the contract using `sweepToken`.\n\nBoth `mint` and `deposit` in `LMPVaultRouterBase` have this problem.\n## Vulnerability Detail\nIn the `deposit` function, if the user pays with ETH, it will first call `_processEthIn` to wrap it and then call `pullToken` to transfer.\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/LMPVaultRouterBase.sol#L43-L57\n```solidity\n    /// @inheritdoc ILMPVaultRouterBase\n    function deposit(\n        ILMPVault vault,\n        address to,\n        uint256 amount,\n        uint256 minSharesOut\n    ) public payable virtual override returns (uint256 sharesOut) {\n        // handle possible eth\n        _processEthIn(vault);\n\n        IERC20 vaultAsset = IERC20(vault.asset());\n        pullToken(vaultAsset, amount, address(this));\n\n        return _deposit(vault, to, amount, minSharesOut);\n    }\n```\n\n`_processEthIn` will wrap ETH into WETH, and these WETH belong to the contract itself.\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/LMPVaultRouterBase.sol#L111-L122\n```solidity\n    function _processEthIn(ILMPVault vault) internal {\n        // if any eth sent, wrap it first\n        if (msg.value > 0) {\n            // if asset is not weth, revert\n            if (address(vault.asset()) != address(weth9)) {\n                revert InvalidAsset();\n            }\n\n            // wrap eth\n            weth9.deposit{ value: msg.value }();\n        }\n    }\n```\n\nHowever, `pullToken` transfers from `msg.sender` and does not use the WETH obtained in `_processEthIn`.\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/utils/PeripheryPayments.sol#L54-L56\n```solidity\n    function pullToken(IERC20 token, uint256 amount, address recipient) public payable {\n        token.safeTransferFrom(msg.sender, recipient, amount);\n    }\n```\n\nIf the user deposits 10 ETH and approves 10 WETH to the contract, when the deposit amount is 10, all of the user's 20 WETH will be transferred into the contract.\n\nHowever, due to the `amount` being 10, only 10 WETH will be deposited into the vault, and the remaining 10 WETH can be stolen by the attacker using `sweepToken`.\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/utils/PeripheryPayments.sol#L58-L65\n```solidity\n    function sweepToken(IERC20 token, uint256 amountMinimum, address recipient) public payable {\n        uint256 balanceToken = token.balanceOf(address(this));\n        if (balanceToken < amountMinimum) revert InsufficientToken();\n\n        if (balanceToken > 0) {\n            token.safeTransfer(recipient, balanceToken);\n        }\n    }\n```\n\nBoth `mint` and `deposit` in `LMPVaultRouterBase` have this problem.\n\n## Impact\nETH deposited by the user may be stolen.\n## Code Snippet\n- https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/LMPVaultRouterBase.sol#L43-L57\n- https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/utils/PeripheryPayments.sol#L54-L56\n- https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/utils/PeripheryPayments.sol#L58-L65\n## Tool used\n\nManual Review\n\n## Recommendation\nPerform operations based on the size of `msg.value` and `amount`:\n1. `msg.value == amount`: transfer WETH from contract not `msg.sender`\n2. `msg.value > amount`: transfer WETH from contract not `msg.sender` and refund to `msg.sender`\n3. `msg.value < amount`: transfer WETH from contract and transfer remaining from `msg.sender`\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/101",
  "Code": [
    {
      "filename": "v2-core-audit-2023-07-14/src/vault/LMPVaultRouterBase.sol",
      "content": "// forked from https://github.com/fei-protocol/ERC4626/blob/main/src/ERC4626RouterBase.sol\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\nimport { IERC20, SafeERC20, Address } from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ILMPVault, ILMPVaultRouterBase } from \"src/interfaces/vault/ILMPVaultRouterBase.sol\";\n\nimport { SelfPermit } from \"src/utils/SelfPermit.sol\";\nimport { PeripheryPayments } from \"src/utils/PeripheryPayments.sol\";\nimport { Multicall } from \"src/utils/Multicall.sol\";\n\nimport { IWETH9 } from \"src/interfaces/utils/IWETH9.sol\";\n\n/// @title LMPVault Router Base Contract\nabstract contract LMPVaultRouterBase is ILMPVaultRouterBase, SelfPermit, Multicall, PeripheryPayments {\n    using SafeERC20 for IERC20;\n\n    error InvalidAsset();\n\n    constructor(address _weth9) PeripheryPayments(IWETH9(_weth9)) { }\n\n    /// @inheritdoc ILMPVaultRouterBase\n    function mint(\n        ILMPVault vault,\n        address to,\n        uint256 shares,\n        uint256 maxAmountIn\n    ) public payable virtual override returns (uint256 amountIn) {\n        // handle possible eth\n        _processEthIn(vault);\n\n        IERC20 vaultAsset = IERC20(vault.asset());\n        uint256 assets = vault.previewMint(shares);\n        pullToken(vaultAsset, assets, address(this));\n        vaultAsset.safeApprove(address(vault), assets);\n\n        amountIn = vault.mint(shares, to);\n        if (amountIn > maxAmountIn) {\n            revert MaxAmountError();\n        }\n    }\n\n    /// @inheritdoc ILMPVaultRouterBase\n    function deposit(\n        ILMPVault vault,\n        address to,\n        uint256 amount,\n        uint256 minSharesOut\n    ) public payable virtual override returns (uint256 sharesOut) {\n        // handle possible eth\n        _processEthIn(vault);\n\n        IERC20 vaultAsset = IERC20(vault.asset());\n        pullToken(vaultAsset, amount, address(this));\n\n        return _deposit(vault, to, amount, minSharesOut);\n    }\n\n    /// @dev Assumes tokens are already in the router\n    function _deposit(\n        ILMPVault vault,\n        address to,\n        uint256 amount,\n        uint256 minSharesOut\n    ) internal returns (uint256 sharesOut) {\n        approve(IERC20(vault.asset()), address(vault), amount);\n        if ((sharesOut = vault.deposit(amount, to)) < minSharesOut) {\n            revert MinSharesError();\n        }\n    }\n\n    /// @inheritdoc ILMPVaultRouterBase\n    function withdraw(\n        ILMPVault vault,\n        address to,\n        uint256 amount,\n        uint256 maxSharesOut,\n        bool unwrapWETH\n    ) public virtual override returns (uint256 sharesOut) {\n        address destination = unwrapWETH ? address(this) : to;\n\n        sharesOut = vault.withdraw(amount, destination, msg.sender);\n        if (sharesOut > maxSharesOut) {\n            revert MaxSharesError();\n        }\n\n        if (unwrapWETH) {\n            _processWethOut(to);\n        }\n    }\n\n    /// @inheritdoc ILMPVaultRouterBase\n    function redeem(\n        ILMPVault vault,\n        address to,\n        uint256 shares,\n        uint256 minAmountOut,\n        bool unwrapWETH\n    ) public virtual override returns (uint256 amountOut) {\n        address destination = unwrapWETH ? address(this) : to;\n\n        if ((amountOut = vault.redeem(shares, destination, msg.sender)) < minAmountOut) {\n            revert MinAmountError();\n        }\n\n        if (unwrapWETH) {\n            _processWethOut(to);\n        }\n    }\n\n    function _processEthIn(ILMPVault vault) internal {\n        // if any eth sent, wrap it first\n        if (msg.value > 0) {\n            // if asset is not weth, revert\n            if (address(vault.asset()) != address(weth9)) {\n                revert InvalidAsset();\n            }\n\n            // wrap eth\n            weth9.deposit{ value: msg.value }();\n        }\n    }\n\n    function _processWethOut(address to) internal {\n        uint256 balanceWETH9 = weth9.balanceOf(address(this));\n\n        if (balanceWETH9 > 0) {\n            weth9.withdraw(balanceWETH9);\n            Address.sendValue(payable(to), balanceWETH9);\n        }\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/vault/LMPVaultRouterBase.sol",
      "content": "// forked from https://github.com/fei-protocol/ERC4626/blob/main/src/ERC4626RouterBase.sol\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\nimport { IERC20, SafeERC20, Address } from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ILMPVault, ILMPVaultRouterBase } from \"src/interfaces/vault/ILMPVaultRouterBase.sol\";\n\nimport { SelfPermit } from \"src/utils/SelfPermit.sol\";\nimport { PeripheryPayments } from \"src/utils/PeripheryPayments.sol\";\nimport { Multicall } from \"src/utils/Multicall.sol\";\n\nimport { IWETH9 } from \"src/interfaces/utils/IWETH9.sol\";\n\n/// @title LMPVault Router Base Contract\nabstract contract LMPVaultRouterBase is ILMPVaultRouterBase, SelfPermit, Multicall, PeripheryPayments {\n    using SafeERC20 for IERC20;\n\n    error InvalidAsset();\n\n    constructor(address _weth9) PeripheryPayments(IWETH9(_weth9)) { }\n\n    /// @inheritdoc ILMPVaultRouterBase\n    function mint(\n        ILMPVault vault,\n        address to,\n        uint256 shares,\n        uint256 maxAmountIn\n    ) public payable virtual override returns (uint256 amountIn) {\n        // handle possible eth\n        _processEthIn(vault);\n\n        IERC20 vaultAsset = IERC20(vault.asset());\n        uint256 assets = vault.previewMint(shares);\n        pullToken(vaultAsset, assets, address(this));\n        vaultAsset.safeApprove(address(vault), assets);\n\n        amountIn = vault.mint(shares, to);\n        if (amountIn > maxAmountIn) {\n            revert MaxAmountError();\n        }\n    }\n\n    /// @inheritdoc ILMPVaultRouterBase\n    function deposit(\n        ILMPVault vault,\n        address to,\n        uint256 amount,\n        uint256 minSharesOut\n    ) public payable virtual override returns (uint256 sharesOut) {\n        // handle possible eth\n        _processEthIn(vault);\n\n        IERC20 vaultAsset = IERC20(vault.asset());\n        pullToken(vaultAsset, amount, address(this));\n\n        return _deposit(vault, to, amount, minSharesOut);\n    }\n\n    /// @dev Assumes tokens are already in the router\n    function _deposit(\n        ILMPVault vault,\n        address to,\n        uint256 amount,\n        uint256 minSharesOut\n    ) internal returns (uint256 sharesOut) {\n        approve(IERC20(vault.asset()), address(vault), amount);\n        if ((sharesOut = vault.deposit(amount, to)) < minSharesOut) {\n            revert MinSharesError();\n        }\n    }\n\n    /// @inheritdoc ILMPVaultRouterBase\n    function withdraw(\n        ILMPVault vault,\n        address to,\n        uint256 amount,\n        uint256 maxSharesOut,\n        bool unwrapWETH\n    ) public virtual override returns (uint256 sharesOut) {\n        address destination = unwrapWETH ? address(this) : to;\n\n        sharesOut = vault.withdraw(amount, destination, msg.sender);\n        if (sharesOut > maxSharesOut) {\n            revert MaxSharesError();\n        }\n\n        if (unwrapWETH) {\n            _processWethOut(to);\n        }\n    }\n\n    /// @inheritdoc ILMPVaultRouterBase\n    function redeem(\n        ILMPVault vault,\n        address to,\n        uint256 shares,\n        uint256 minAmountOut,\n        bool unwrapWETH\n    ) public virtual override returns (uint256 amountOut) {\n        address destination = unwrapWETH ? address(this) : to;\n\n        if ((amountOut = vault.redeem(shares, destination, msg.sender)) < minAmountOut) {\n            revert MinAmountError();\n        }\n\n        if (unwrapWETH) {\n            _processWethOut(to);\n        }\n    }\n\n    function _processEthIn(ILMPVault vault) internal {\n        // if any eth sent, wrap it first\n        if (msg.value > 0) {\n            // if asset is not weth, revert\n            if (address(vault.asset()) != address(weth9)) {\n                revert InvalidAsset();\n            }\n\n            // wrap eth\n            weth9.deposit{ value: msg.value }();\n        }\n    }\n\n    function _processWethOut(address to) internal {\n        uint256 balanceWETH9 = weth9.balanceOf(address(this));\n\n        if (balanceWETH9 > 0) {\n            weth9.withdraw(balanceWETH9);\n            Address.sendValue(payable(to), balanceWETH9);\n        }\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/utils/PeripheryPayments.sol",
      "content": "// forked from https://github.com/fei-protocol/ERC4626/blob/main/src/external/PeripheryPayments.sol\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 < 0.9.0;\n\nimport { IWETH9 } from \"src/interfaces/utils/IWETH9.sol\";\nimport { IERC20, SafeERC20, Address } from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title Periphery Payments\n *  @notice Immutable state used by periphery contracts\n *  Largely Forked from https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/PeripheryPayments.sol\n *  Changes:\n * no interface\n * no inheritdoc\n * add immutable WETH9 in constructor instead of PeripheryImmutableState\n * receive from any address\n * Solmate interfaces and transfer lib\n * casting\n * add approve, wrapWETH9 and pullToken\n */\nabstract contract PeripheryPayments {\n    using SafeERC20 for IERC20;\n\n    IWETH9 public immutable weth9;\n\n    error InsufficientWETH9();\n    error InsufficientToken();\n\n    constructor(IWETH9 _weth9) {\n        weth9 = _weth9;\n    }\n\n    receive() external payable { }\n\n    function approve(IERC20 token, address to, uint256 amount) public payable {\n        token.safeApprove(to, amount);\n    }\n\n    function unwrapWETH9(uint256 amountMinimum, address recipient) public payable {\n        uint256 balanceWETH9 = weth9.balanceOf(address(this));\n\n        if (balanceWETH9 < amountMinimum) revert InsufficientWETH9();\n\n        if (balanceWETH9 > 0) {\n            weth9.withdraw(balanceWETH9);\n            Address.sendValue(payable(recipient), balanceWETH9);\n        }\n    }\n\n    function wrapWETH9() public payable {\n        if (address(this).balance > 0) weth9.deposit{ value: address(this).balance }(); // wrap everything\n    }\n\n    function pullToken(IERC20 token, uint256 amount, address recipient) public payable {\n        token.safeTransferFrom(msg.sender, recipient, amount);\n    }\n\n    function sweepToken(IERC20 token, uint256 amountMinimum, address recipient) public payable {\n        uint256 balanceToken = token.balanceOf(address(this));\n        if (balanceToken < amountMinimum) revert InsufficientToken();\n\n        if (balanceToken > 0) {\n            token.safeTransfer(recipient, balanceToken);\n        }\n    }\n\n    function refundETH() external payable {\n        if (address(this).balance > 0) Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/utils/PeripheryPayments.sol",
      "content": "// forked from https://github.com/fei-protocol/ERC4626/blob/main/src/external/PeripheryPayments.sol\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 < 0.9.0;\n\nimport { IWETH9 } from \"src/interfaces/utils/IWETH9.sol\";\nimport { IERC20, SafeERC20, Address } from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title Periphery Payments\n *  @notice Immutable state used by periphery contracts\n *  Largely Forked from https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/PeripheryPayments.sol\n *  Changes:\n * no interface\n * no inheritdoc\n * add immutable WETH9 in constructor instead of PeripheryImmutableState\n * receive from any address\n * Solmate interfaces and transfer lib\n * casting\n * add approve, wrapWETH9 and pullToken\n */\nabstract contract PeripheryPayments {\n    using SafeERC20 for IERC20;\n\n    IWETH9 public immutable weth9;\n\n    error InsufficientWETH9();\n    error InsufficientToken();\n\n    constructor(IWETH9 _weth9) {\n        weth9 = _weth9;\n    }\n\n    receive() external payable { }\n\n    function approve(IERC20 token, address to, uint256 amount) public payable {\n        token.safeApprove(to, amount);\n    }\n\n    function unwrapWETH9(uint256 amountMinimum, address recipient) public payable {\n        uint256 balanceWETH9 = weth9.balanceOf(address(this));\n\n        if (balanceWETH9 < amountMinimum) revert InsufficientWETH9();\n\n        if (balanceWETH9 > 0) {\n            weth9.withdraw(balanceWETH9);\n            Address.sendValue(payable(recipient), balanceWETH9);\n        }\n    }\n\n    function wrapWETH9() public payable {\n        if (address(this).balance > 0) weth9.deposit{ value: address(this).balance }(); // wrap everything\n    }\n\n    function pullToken(IERC20 token, uint256 amount, address recipient) public payable {\n        token.safeTransferFrom(msg.sender, recipient, amount);\n    }\n\n    function sweepToken(IERC20 token, uint256 amountMinimum, address recipient) public payable {\n        uint256 balanceToken = token.balanceOf(address(this));\n        if (balanceToken < amountMinimum) revert InsufficientToken();\n\n        if (balanceToken > 0) {\n            token.safeTransfer(recipient, balanceToken);\n        }\n    }\n\n    function refundETH() external payable {\n        if (address(this).balance > 0) Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/vault/LMPVaultRouterBase.sol",
      "content": "// forked from https://github.com/fei-protocol/ERC4626/blob/main/src/ERC4626RouterBase.sol\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\nimport { IERC20, SafeERC20, Address } from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ILMPVault, ILMPVaultRouterBase } from \"src/interfaces/vault/ILMPVaultRouterBase.sol\";\n\nimport { SelfPermit } from \"src/utils/SelfPermit.sol\";\nimport { PeripheryPayments } from \"src/utils/PeripheryPayments.sol\";\nimport { Multicall } from \"src/utils/Multicall.sol\";\n\nimport { IWETH9 } from \"src/interfaces/utils/IWETH9.sol\";\n\n/// @title LMPVault Router Base Contract\nabstract contract LMPVaultRouterBase is ILMPVaultRouterBase, SelfPermit, Multicall, PeripheryPayments {\n    using SafeERC20 for IERC20;\n\n    error InvalidAsset();\n\n    constructor(address _weth9) PeripheryPayments(IWETH9(_weth9)) { }\n\n    /// @inheritdoc ILMPVaultRouterBase\n    function mint(\n        ILMPVault vault,\n        address to,\n        uint256 shares,\n        uint256 maxAmountIn\n    ) public payable virtual override returns (uint256 amountIn) {\n        // handle possible eth\n        _processEthIn(vault);\n\n        IERC20 vaultAsset = IERC20(vault.asset());\n        uint256 assets = vault.previewMint(shares);\n        pullToken(vaultAsset, assets, address(this));\n        vaultAsset.safeApprove(address(vault), assets);\n\n        amountIn = vault.mint(shares, to);\n        if (amountIn > maxAmountIn) {\n            revert MaxAmountError();\n        }\n    }\n\n    /// @inheritdoc ILMPVaultRouterBase\n    function deposit(\n        ILMPVault vault,\n        address to,\n        uint256 amount,\n        uint256 minSharesOut\n    ) public payable virtual override returns (uint256 sharesOut) {\n        // handle possible eth\n        _processEthIn(vault);\n\n        IERC20 vaultAsset = IERC20(vault.asset());\n        pullToken(vaultAsset, amount, address(this));\n\n        return _deposit(vault, to, amount, minSharesOut);\n    }\n\n    /// @dev Assumes tokens are already in the router\n    function _deposit(\n        ILMPVault vault,\n        address to,\n        uint256 amount,\n        uint256 minSharesOut\n    ) internal returns (uint256 sharesOut) {\n        approve(IERC20(vault.asset()), address(vault), amount);\n        if ((sharesOut = vault.deposit(amount, to)) < minSharesOut) {\n            revert MinSharesError();\n        }\n    }\n\n    /// @inheritdoc ILMPVaultRouterBase\n    function withdraw(\n        ILMPVault vault,\n        address to,\n        uint256 amount,\n        uint256 maxSharesOut,\n        bool unwrapWETH\n    ) public virtual override returns (uint256 sharesOut) {\n        address destination = unwrapWETH ? address(this) : to;\n\n        sharesOut = vault.withdraw(amount, destination, msg.sender);\n        if (sharesOut > maxSharesOut) {\n            revert MaxSharesError();\n        }\n\n        if (unwrapWETH) {\n            _processWethOut(to);\n        }\n    }\n\n    /// @inheritdoc ILMPVaultRouterBase\n    function redeem(\n        ILMPVault vault,\n        address to,\n        uint256 shares,\n        uint256 minAmountOut,\n        bool unwrapWETH\n    ) public virtual override returns (uint256 amountOut) {\n        address destination = unwrapWETH ? address(this) : to;\n\n        if ((amountOut = vault.redeem(shares, destination, msg.sender)) < minAmountOut) {\n            revert MinAmountError();\n        }\n\n        if (unwrapWETH) {\n            _processWethOut(to);\n        }\n    }\n\n    function _processEthIn(ILMPVault vault) internal {\n        // if any eth sent, wrap it first\n        if (msg.value > 0) {\n            // if asset is not weth, revert\n            if (address(vault.asset()) != address(weth9)) {\n                revert InvalidAsset();\n            }\n\n            // wrap eth\n            weth9.deposit{ value: msg.value }();\n        }\n    }\n\n    function _processWethOut(address to) internal {\n        uint256 balanceWETH9 = weth9.balanceOf(address(this));\n\n        if (balanceWETH9 > 0) {\n            weth9.withdraw(balanceWETH9);\n            Address.sendValue(payable(to), balanceWETH9);\n        }\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/utils/PeripheryPayments.sol",
      "content": "// forked from https://github.com/fei-protocol/ERC4626/blob/main/src/external/PeripheryPayments.sol\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 < 0.9.0;\n\nimport { IWETH9 } from \"src/interfaces/utils/IWETH9.sol\";\nimport { IERC20, SafeERC20, Address } from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title Periphery Payments\n *  @notice Immutable state used by periphery contracts\n *  Largely Forked from https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/PeripheryPayments.sol\n *  Changes:\n * no interface\n * no inheritdoc\n * add immutable WETH9 in constructor instead of PeripheryImmutableState\n * receive from any address\n * Solmate interfaces and transfer lib\n * casting\n * add approve, wrapWETH9 and pullToken\n */\nabstract contract PeripheryPayments {\n    using SafeERC20 for IERC20;\n\n    IWETH9 public immutable weth9;\n\n    error InsufficientWETH9();\n    error InsufficientToken();\n\n    constructor(IWETH9 _weth9) {\n        weth9 = _weth9;\n    }\n\n    receive() external payable { }\n\n    function approve(IERC20 token, address to, uint256 amount) public payable {\n        token.safeApprove(to, amount);\n    }\n\n    function unwrapWETH9(uint256 amountMinimum, address recipient) public payable {\n        uint256 balanceWETH9 = weth9.balanceOf(address(this));\n\n        if (balanceWETH9 < amountMinimum) revert InsufficientWETH9();\n\n        if (balanceWETH9 > 0) {\n            weth9.withdraw(balanceWETH9);\n            Address.sendValue(payable(recipient), balanceWETH9);\n        }\n    }\n\n    function wrapWETH9() public payable {\n        if (address(this).balance > 0) weth9.deposit{ value: address(this).balance }(); // wrap everything\n    }\n\n    function pullToken(IERC20 token, uint256 amount, address recipient) public payable {\n        token.safeTransferFrom(msg.sender, recipient, amount);\n    }\n\n    function sweepToken(IERC20 token, uint256 amountMinimum, address recipient) public payable {\n        uint256 balanceToken = token.balanceOf(address(this));\n        if (balanceToken < amountMinimum) revert InsufficientToken();\n\n        if (balanceToken > 0) {\n            token.safeTransfer(recipient, balanceToken);\n        }\n    }\n\n    function refundETH() external payable {\n        if (address(this).balance > 0) Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/utils/PeripheryPayments.sol",
      "content": "// forked from https://github.com/fei-protocol/ERC4626/blob/main/src/external/PeripheryPayments.sol\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 < 0.9.0;\n\nimport { IWETH9 } from \"src/interfaces/utils/IWETH9.sol\";\nimport { IERC20, SafeERC20, Address } from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title Periphery Payments\n *  @notice Immutable state used by periphery contracts\n *  Largely Forked from https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/PeripheryPayments.sol\n *  Changes:\n * no interface\n * no inheritdoc\n * add immutable WETH9 in constructor instead of PeripheryImmutableState\n * receive from any address\n * Solmate interfaces and transfer lib\n * casting\n * add approve, wrapWETH9 and pullToken\n */\nabstract contract PeripheryPayments {\n    using SafeERC20 for IERC20;\n\n    IWETH9 public immutable weth9;\n\n    error InsufficientWETH9();\n    error InsufficientToken();\n\n    constructor(IWETH9 _weth9) {\n        weth9 = _weth9;\n    }\n\n    receive() external payable { }\n\n    function approve(IERC20 token, address to, uint256 amount) public payable {\n        token.safeApprove(to, amount);\n    }\n\n    function unwrapWETH9(uint256 amountMinimum, address recipient) public payable {\n        uint256 balanceWETH9 = weth9.balanceOf(address(this));\n\n        if (balanceWETH9 < amountMinimum) revert InsufficientWETH9();\n\n        if (balanceWETH9 > 0) {\n            weth9.withdraw(balanceWETH9);\n            Address.sendValue(payable(recipient), balanceWETH9);\n        }\n    }\n\n    function wrapWETH9() public payable {\n        if (address(this).balance > 0) weth9.deposit{ value: address(this).balance }(); // wrap everything\n    }\n\n    function pullToken(IERC20 token, uint256 amount, address recipient) public payable {\n        token.safeTransferFrom(msg.sender, recipient, amount);\n    }\n\n    function sweepToken(IERC20 token, uint256 amountMinimum, address recipient) public payable {\n        uint256 balanceToken = token.balanceOf(address(this));\n        if (balanceToken < amountMinimum) revert InsufficientToken();\n\n        if (balanceToken > 0) {\n            token.safeTransfer(recipient, balanceToken);\n        }\n    }\n\n    function refundETH() external payable {\n        if (address(this).balance > 0) Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n}"
    }
  ]
}