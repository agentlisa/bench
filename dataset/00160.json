{
  "Title": "M-14: Performing a direct multiplication in `_getPriceFromSqrtX96` will overflow for some uniswap pools",
  "Content": "# Issue M-14: Performing a direct multiplication in `_getPriceFromSqrtX96` will overflow for some uniswap pools \n\nSource: https://github.com/sherlock-audit/2024-04-teller-finance-judging/issues/243 \n\n## Found by \n0x73696d616f, 0xadrii, pkqs90\n## Summary\n\nThe _getPriceFromSqrtX96 will revert for pools that return a _sqrtPriceX96 bigger than type(uint128).max.\n\n## Vulnerability Detail\n\nThe `LenderCommitmentGroup_Smart` uses the price obtained from the uniswap v3 pool in order to compute the amount of collateral that must be deposited in order to perform a borrow. Currently, the prices are fetched via the `_getUniswapV3TokenPairPrice` function:\n\n```solidity\n// LenderCommitmentGroup_Smart.sol\nfunction _getUniswapV3TokenPairPrice(uint32 _twapInterval)\n        internal\n        view\n        returns (uint256)\n    {\n        // represents the square root of the price of token1 in terms of token0\n\n        uint160 sqrtPriceX96 = getSqrtTwapX96(_twapInterval);\n\n        //this output is the price ratio expanded by 1e18\n        return _getPriceFromSqrtX96(sqrtPriceX96);\n    }\n```\n\nThis function will perform two actions:\n\n1. Get the `sqrtPriceX96` from the uniswap pool by querying the pool’s TWAP or the pool’s `slot0` function. It is important to note that the returned `sqrtPriceX96` is a `uint160` value that **can store numbers bigger than 128 bits:**\n    \n    ```solidity\n    // LenderCommitmentGroup_Smart.sol\n    \n    function getSqrtTwapX96(uint32 twapInterval)\n            public\n            view\n            returns (uint160 sqrtPriceX96)\n        {\n            if (twapInterval == 0) {\n                // return the current price if twapInterval == 0\n                (sqrtPriceX96, , , , , , ) = IUniswapV3Pool(UNISWAP_V3_POOL)\n                    .slot0();\n            } else {\n                uint32[] memory secondsAgos = new uint32[](2);\n                secondsAgos[0] = twapInterval; // from (before)\n                secondsAgos[1] = 0; // to (now)\n    \n                (int56[] memory tickCumulatives, ) = IUniswapV3Pool(UNISWAP_V3_POOL)\n                    .observe(secondsAgos);\n    \n                // tick(imprecise as it's an integer) to price\n                sqrtPriceX96 = TickMath.getSqrtRatioAtTick(\n                    int24(\n                        (tickCumulatives[1] - tickCumulatives[0]) /\n                            int32(twapInterval)\n                    )\n                );\n            }\n        }\n    ```\n    \n2. After obtaining the `sqrtPriceX96` , the `priceX96` will be obtained by multiplying `sqrtPriceX96` by itself and dividing it by `(2**96)` :\n    \n    ```solidity\n    // LenderCommitmentGroup_Smart.sol\n    function _getPriceFromSqrtX96(uint160 _sqrtPriceX96)\n            internal\n            pure\n            returns (uint256 price_)\n        {\n           \n            uint256 priceX96 = (uint256(_sqrtPriceX96) * uint256(_sqrtPriceX96)) /\n                (2**96);\n    \n            // sqrtPrice is in X96 format so we scale it down to get the price\n            // Also note that this price is a relative price between the two tokens in the pool\n            // It's not a USD price\n            price_ = priceX96;\n        }\n    ```\n    \n\nThe problem is that the `_getPriceFromSqrtX96` performs a direct multiplication between `_sqrtPriceX96` by itself. As mentioned in step 1, this multiplication can lead to overflow because the `_sqrtPriceX96` value returned by the Uniswap pool **can be a numer larger than 128 bits.**\n\nAs an example, take [Uniswap’s WBTC/SHIBA pool](https://etherscan.io/address/0x1153C8F2B05Fdde2dB507c8D16E49d4C7405c907#readContract)  and query `slot0`. At timestamp **1714392894,** the `slot0` value returned is  380146371870332863053439965317548561928, which is a 129 bit value. When the `_getPriceFromSqrtX96` gets executed for the WBTC/SHIBA pool, an overflow will always occur because a multiplication of two 129-bit integers surpasses 256 bits.\n\nNote how this is also handled in [Uniswap’s official Oracle Library](https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/OracleLibrary.sol#L58)] contract, where a check is performed to ensure that no overflows can occur.\n\n## Impact\n\nMedium. Some uniswap pool’s will be unusable and will DoS in LenderCommitmentGroup_Smart because the uniswap price computations will always overflow.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-04-teller-finance/blob/main/teller-protocol-v2-audit-2024/packages/contracts/contracts/LenderCommitmentForwarder/extensions/LenderCommitmentGroup/LenderCommitmentGroup_Smart.sol#L559\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse [Uniswap’s  Fullmath library](https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol) to perform the multiplication in `_getPriceFromSqrtX96`, which already handles this situation:\n\n```diff\n// LenderCommitmentGroup_Smart.sol\nfunction _getPriceFromSqrtX96(uint160 _sqrtPriceX96)\n        internal\n        pure\n        returns (uint256 price_)\n    {\n       \n-        uint256 priceX96 = (uint256(_sqrtPriceX96) * uint256(_sqrtPriceX96)) /\n-            (2**96);\n+        uint256 priceX96 = FullMath.mulDiv(uint256(_sqrtPriceX96), uint256(_sqrtPriceX96), (2**96);\n\n        // sqrtPrice is in X96 format so we scale it down to get the price\n        // Also note that this price is a relative price between the two tokens in the pool\n        // It's not a USD price\n        price_ = priceX96;\n    }\n```\n\n\n\n\n\n## Discussion\n\n**spacegliderrrr**\n\nEscalate\n\nIn order to overflow we need `sqrtPriceX96 * sqrtPriceX96` to be larger than uint256.max. This means that `tokenPrice * 2^192` must exceed 2^256, or we need `tokenPrice >= 2^64` or `tokenPrice >= ~1e18`. This requires 1 wei of token0 to be worth >1e18 wei of token1, which is absolutely unrealistic edge case scenario. Issue should be low.\n\n**sherlock-admin3**\n\n> Escalate\n> \n> In order to overflow we need `sqrtPriceX96 * sqrtPriceX96` to be larger than uint256.max. This means that `tokenPrice * 2^192` must exceed 2^256, or we need `tokenPrice >= 2^64` or `tokenPrice >= ~1e18`. This requires 1 wei of token0 to be worth >1e18 wei of token1, which is absolutely unrealistic edge case scenario. Issue should be low.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**0x73696d616f**\n\n@spacegliderrrr it also takes the decimal difference between tokens into account, that is why it is likely to happen for some pools.\n\n**nevillehuang**\n\n@spacegliderrrr Any direct arguments for the example provided in the issue above? If not I believe this issue should remain valid\n\n> As an example, take [Uniswap’s WBTC/SHIBA pool](https://etherscan.io/address/0x1153C8F2B05Fdde2dB507c8D16E49d4C7405c907#readContract) and query slot0. At timestamp 1714392894, the slot0 value returned is  380146371870332863053439965317548561928, which is a 129 bit value. When the _getPriceFromSqrtX96 gets executed for the WBTC/SHIBA pool, an overflow will always occur because a multiplication of two 129-bit integers surpasses 256 bits.\n\n**cvetanovv**\n\n@0xadrii has given a good example of how some Uniswap pools may not be usable by the protocol due to overflow. We can also see how Uniswap has handled this. \n\nPlanning to reject the escalation and leave the issue as is.\n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [spacegliderrrr](https://github.com/sherlock-audit/2024-04-teller-finance-judging/issues/243/#issuecomment-2119189730): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/295",
  "Code": [
    {
      "filename": "contracts/libraries/OracleLibrary.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0 <0.8.0;\n\nimport '@uniswap/v3-core/contracts/libraries/FullMath.sol';\nimport '@uniswap/v3-core/contracts/libraries/TickMath.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\n\n/// @title Oracle library\n/// @notice Provides functions to integrate with V3 pool oracle\nlibrary OracleLibrary {\n    /// @notice Calculates time-weighted means of tick and liquidity for a given Uniswap V3 pool\n    /// @param pool Address of the pool that we want to observe\n    /// @param secondsAgo Number of seconds in the past from which to calculate the time-weighted means\n    /// @return arithmeticMeanTick The arithmetic mean tick from (block.timestamp - secondsAgo) to block.timestamp\n    /// @return harmonicMeanLiquidity The harmonic mean liquidity from (block.timestamp - secondsAgo) to block.timestamp\n    function consult(address pool, uint32 secondsAgo)\n        internal\n        view\n        returns (int24 arithmeticMeanTick, uint128 harmonicMeanLiquidity)\n    {\n        require(secondsAgo != 0, 'BP');\n\n        uint32[] memory secondsAgos = new uint32[](2);\n        secondsAgos[0] = secondsAgo;\n        secondsAgos[1] = 0;\n\n        (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) =\n            IUniswapV3Pool(pool).observe(secondsAgos);\n\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n        uint160 secondsPerLiquidityCumulativesDelta =\n            secondsPerLiquidityCumulativeX128s[1] - secondsPerLiquidityCumulativeX128s[0];\n\n        arithmeticMeanTick = int24(tickCumulativesDelta / secondsAgo);\n        // Always round to negative infinity\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % secondsAgo != 0)) arithmeticMeanTick--;\n\n        // We are multiplying here instead of shifting to ensure that harmonicMeanLiquidity doesn't overflow uint128\n        uint192 secondsAgoX160 = uint192(secondsAgo) * type(uint160).max;\n        harmonicMeanLiquidity = uint128(secondsAgoX160 / (uint192(secondsPerLiquidityCumulativesDelta) << 32));\n    }\n\n    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange\n    /// @param tick Tick value used to calculate the quote\n    /// @param baseAmount Amount of token to be converted\n    /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\n    /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\n    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\n    function getQuoteAtTick(\n        int24 tick,\n        uint128 baseAmount,\n        address baseToken,\n        address quoteToken\n    ) internal pure returns (uint256 quoteAmount) {\n        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\n\n        // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself\n        if (sqrtRatioX96 <= type(uint128).max) {\n            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n                : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n        } else {\n            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n                : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n        }\n    }\n\n    /// @notice Given a pool, it returns the number of seconds ago of the oldest stored observation\n    /// @param pool Address of Uniswap V3 pool that we want to observe\n    /// @return secondsAgo The number of seconds ago of the oldest observation stored for the pool\n    function getOldestObservationSecondsAgo(address pool) internal view returns (uint32 secondsAgo) {\n        (, , uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\n        require(observationCardinality > 0, 'NI');\n\n        (uint32 observationTimestamp, , , bool initialized) =\n            IUniswapV3Pool(pool).observations((observationIndex + 1) % observationCardinality);\n\n        // The next index might not be initialized if the cardinality is in the process of increasing\n        // In this case the oldest observation is always in index 0\n        if (!initialized) {\n            (observationTimestamp, , , ) = IUniswapV3Pool(pool).observations(0);\n        }\n\n        secondsAgo = uint32(block.timestamp) - observationTimestamp;\n    }\n\n    /// @notice Given a pool, it returns the tick value as of the start of the current block\n    /// @param pool Address of Uniswap V3 pool\n    /// @return The tick that the pool was in at the start of the current block\n    function getBlockStartingTickAndLiquidity(address pool) internal view returns (int24, uint128) {\n        (, int24 tick, uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\n\n        // 2 observations are needed to reliably calculate the block starting tick\n        require(observationCardinality > 1, 'NEO');\n\n        // If the latest observation occurred in the past, then no tick-changing trades have happened in this block\n        // therefore the tick in `slot0` is the same as at the beginning of the current block.\n        // We don't need to check if this observation is initialized - it is guaranteed to be.\n        (uint32 observationTimestamp, int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128, ) =\n            IUniswapV3Pool(pool).observations(observationIndex);\n        if (observationTimestamp != uint32(block.timestamp)) {\n            return (tick, IUniswapV3Pool(pool).liquidity());\n        }\n\n        uint256 prevIndex = (uint256(observationIndex) + observationCardinality - 1) % observationCardinality;\n        (\n            uint32 prevObservationTimestamp,\n            int56 prevTickCumulative,\n            uint160 prevSecondsPerLiquidityCumulativeX128,\n            bool prevInitialized\n        ) = IUniswapV3Pool(pool).observations(prevIndex);\n\n        require(prevInitialized, 'ONI');\n\n        uint32 delta = observationTimestamp - prevObservationTimestamp;\n        tick = int24((tickCumulative - prevTickCumulative) / delta);\n        uint128 liquidity =\n            uint128(\n                (uint192(delta) * type(uint160).max) /\n                    (uint192(secondsPerLiquidityCumulativeX128 - prevSecondsPerLiquidityCumulativeX128) << 32)\n            );\n        return (tick, liquidity);\n    }\n\n    /// @notice Information for calculating a weighted arithmetic mean tick\n    struct WeightedTickData {\n        int24 tick;\n        uint128 weight;\n    }\n\n    /// @notice Given an array of ticks and weights, calculates the weighted arithmetic mean tick\n    /// @param weightedTickData An array of ticks and weights\n    /// @return weightedArithmeticMeanTick The weighted arithmetic mean tick\n    /// @dev Each entry of `weightedTickData` should represents ticks from pools with the same underlying pool tokens. If they do not,\n    /// extreme care must be taken to ensure that ticks are comparable (including decimal differences).\n    /// @dev Note that the weighted arithmetic mean tick corresponds to the weighted geometric mean price.\n    function getWeightedArithmeticMeanTick(WeightedTickData[] memory weightedTickData)\n        internal\n        pure\n        returns (int24 weightedArithmeticMeanTick)\n    {\n        // Accumulates the sum of products between each tick and its weight\n        int256 numerator;\n\n        // Accumulates the sum of the weights\n        uint256 denominator;\n\n        // Products fit in 152 bits, so it would take an array of length ~2**104 to overflow this logic\n        for (uint256 i; i < weightedTickData.length; i++) {\n            numerator += weightedTickData[i].tick * int256(weightedTickData[i].weight);\n            denominator += weightedTickData[i].weight;\n        }\n\n        weightedArithmeticMeanTick = int24(numerator / int256(denominator));\n        // Always round to negative infinity\n        if (numerator < 0 && (numerator % int256(denominator) != 0)) weightedArithmeticMeanTick--;\n    }\n\n    /// @notice Returns the \"synthetic\" tick which represents the price of the first entry in `tokens` in terms of the last\n    /// @dev Useful for calculating relative prices along routes.\n    /// @dev There must be one tick for each pairwise set of tokens.\n    /// @param tokens The token contract addresses\n    /// @param ticks The ticks, representing the price of each token pair in `tokens`\n    /// @return syntheticTick The synthetic tick, representing the relative price of the outermost tokens in `tokens`\n    function getChainedPrice(address[] memory tokens, int24[] memory ticks)\n        internal\n        pure\n        returns (int256 syntheticTick)\n    {\n        require(tokens.length - 1 == ticks.length, 'DL');\n        for (uint256 i = 1; i <= ticks.length; i++) {\n            // check the tokens for address sort order, then accumulate the\n            // ticks into the running synthetic tick, ensuring that intermediate tokens \"cancel out\"\n            tokens[i - 1] < tokens[i] ? syntheticTick += ticks[i - 1] : syntheticTick -= ticks[i - 1];\n        }\n    }\n}"
    },
    {
      "filename": "teller-protocol-v2-audit-2024/packages/contracts/contracts/LenderCommitmentForwarder/extensions/LenderCommitmentGroup/LenderCommitmentGroup_Smart.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Contracts\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Interfaces\nimport \"../../../interfaces/ITellerV2Context.sol\";\nimport \"../../../interfaces/IProtocolFee.sol\";\nimport \"../../../interfaces/ITellerV2Storage.sol\";\nimport \"../../../interfaces/ITellerV2.sol\";\n\nimport \"../../../interfaces/IFlashRolloverLoan.sol\";\nimport \"../../../libraries/NumbersLib.sol\";\n\nimport \"../../../interfaces/uniswap/IUniswapV3Pool.sol\";\n\nimport \"../../../interfaces/uniswap/IUniswapV3Factory.sol\";\n\nimport \"../../../libraries/uniswap/TickMath.sol\";\nimport \"../../../libraries/uniswap/FixedPoint96.sol\";\nimport \"../../../libraries/uniswap/FullMath.sol\";\n\nimport \"./LenderCommitmentGroupShares.sol\";\n\nimport { MathUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\nimport { CommitmentCollateralType, ISmartCommitment } from \"../../../interfaces/ISmartCommitment.sol\";\nimport { ILoanRepaymentListener } from \"../../../interfaces/ILoanRepaymentListener.sol\";\n\nimport { ILoanRepaymentCallbacks } from \"../../../interfaces/ILoanRepaymentCallbacks.sol\";\n\nimport { ILenderCommitmentGroup } from \"../../../interfaces/ILenderCommitmentGroup.sol\";\nimport { Payment } from \"../../../TellerV2Storage.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/*\n \n\n Each LenderCommitmentGroup SmartContract acts as its own Loan Commitment (for the SmartCommitmentForwarder) and acts as its own Lender in the Teller Protocol.\n\n Lender Users can deposit principal tokens in this contract and this will give them Share Tokens (LP tokens) representing their ownership in the liquidity pool of this contract.\n\n Borrower Users can borrow principal token funds from this contract (via the SCF contract) by providing collateral tokens in the proper amount as specified by the rules of this smart contract.\n These collateral tokens are then owned by this smart contract and are returned to the borrower via the Teller Protocol rules to the borrower if and only if the borrower repays principal and interest of the loan they took.\n\n If the borrower defaults on a loan, for 24 hours a liquidation auction is automatically conducted by this smart contract in order to incentivize a liquidator to take the collateral tokens in exchange for principal tokens.\n\n  \n \n\n*/\n\ncontract LenderCommitmentGroup_Smart is\n    ILenderCommitmentGroup,\n    ISmartCommitment,\n    ILoanRepaymentListener,\n    Initializable,\n    OwnableUpgradeable,\n    PausableUpgradeable\n{\n    using AddressUpgradeable for address;\n    using NumbersLib for uint256;\n\n    uint256 public immutable STANDARD_EXPANSION_FACTOR = 1e18;\n\n    uint256 public immutable UNISWAP_EXPANSION_FACTOR = 2**96;\n\n    uint256 public immutable EXCHANGE_RATE_EXPANSION_FACTOR = 1e36;  \n\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable TELLER_V2;\n    address public immutable SMART_COMMITMENT_FORWARDER;\n    address public immutable UNISWAP_V3_FACTORY;\n    address public UNISWAP_V3_POOL;\n \n    LenderCommitmentGroupShares public poolSharesToken;\n\n    IERC20 public principalToken;\n    IERC20 public collateralToken;\n\n    uint256 marketId;\n\n \n    uint256 public totalPrincipalTokensCommitted; \n    uint256 public totalPrincipalTokensWithdrawn;\n\n    uint256 public totalPrincipalTokensLended;\n    uint256 public totalPrincipalTokensRepaid; //subtract this and the above to find total principal tokens outstanding for loans\n\n    \n \n    uint256 public totalInterestCollected;\n\n    uint16 public liquidityThresholdPercent; //5000 is 50 pct  // enforce max of 10000\n    uint16 public collateralRatio; //the overcollateralization ratio, typically 80 pct\n\n    uint32 public twapInterval;\n    uint32 public maxLoanDuration;\n    uint16 public interestRateLowerBound;\n    uint16 public interestRateUpperBound;\n\n\n    //mapping(address => uint256) public principalTokensCommittedByLender;\n    mapping(uint256 => bool) public activeBids;\n\n    //this excludes interest\n    // maybe it is possible to get rid of this storage slot and calculate it from totalPrincipalTokensRepaid, totalPrincipalTokensLended\n    int256 tokenDifferenceFromLiquidations;\n\n\n   \n\n    modifier onlySmartCommitmentForwarder() {\n        require(\n            msg.sender == address(SMART_COMMITMENT_FORWARDER),\n            \"Can only be called by Smart Commitment Forwarder\"\n        );\n        _;\n    }\n\n    modifier onlyTellerV2() {\n        require(\n            msg.sender == address(TELLER_V2),\n            \"Can only be called by TellerV2\"\n        );\n        _;\n    }\n\n    modifier bidIsActiveForGroup(uint256 _bidId) {\n        require(activeBids[_bidId] == true, \"Bid is not active for group\");\n\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _tellerV2,\n        address _smartCommitmentForwarder,\n        address _uniswapV3Factory\n    ) {\n        TELLER_V2 = _tellerV2;\n        SMART_COMMITMENT_FORWARDER = _smartCommitmentForwarder;\n        UNISWAP_V3_FACTORY = _uniswapV3Factory;\n    }\n\n    /*\n\n\n        \n    */\n    function initialize(\n        address _principalTokenAddress,\n        address _collateralTokenAddress,\n        uint256 _marketId,\n        uint32 _maxLoanDuration,\n        uint16 _interestRateLowerBound,\n        uint16 _interestRateUpperBound,\n        uint16 _liquidityThresholdPercent, // When 100% , the entire pool can be drawn for lending.  When 80%, only 80% of the pool can be drawn for lending. \n        uint16 _collateralRatio, //the required overcollateralization ratio.  10000 is 1:1 baseline , typically this is above 10000\n        uint24 _uniswapPoolFee,\n        uint32 _twapInterval\n    ) external initializer returns (address poolSharesToken_) {\n        // require(!_initialized,\"already initialized\");\n        // _initialized = true;\n\n        __Pausable_init();\n\n        principalToken = IERC20(_principalTokenAddress);\n        collateralToken = IERC20(_collateralTokenAddress);\n\n        UNISWAP_V3_POOL = IUniswapV3Factory(UNISWAP_V3_FACTORY).getPool(\n            _principalTokenAddress,\n            _collateralTokenAddress,\n            _uniswapPoolFee\n        );\n\n        require(UNISWAP_V3_POOL != address(0), \"Invalid uniswap pool address\");\n\n        marketId = _marketId;\n\n        //in order for this to succeed, first, that SmartCommitmentForwarder needs to be THE trusted forwarder for the market\n\n         \n        ITellerV2Context(TELLER_V2).approveMarketForwarder(\n            _marketId,\n            SMART_COMMITMENT_FORWARDER\n        );\n\n        maxLoanDuration = _maxLoanDuration;\n        interestRateLowerBound = _interestRateLowerBound;\n        interestRateUpperBound = _interestRateUpperBound;\n\n\n        \n        \n        require(interestRateLowerBound <= interestRateUpperBound, \"invalid _interestRateLowerBound\");\n\n        require(_liquidityThresholdPercent <= 10000, \"invalid _liquidityThresholdPercent\"); \n\n        liquidityThresholdPercent = _liquidityThresholdPercent;\n        collateralRatio = _collateralRatio;\n        twapInterval = _twapInterval;\n\n        \n        poolSharesToken_ = _deployPoolSharesToken();\n    }\n\n    function _deployPoolSharesToken()\n        internal\n        onlyInitializing\n        returns (address poolSharesToken_)\n    {\n      \n        require(\n            address(poolSharesToken) == address(0),\n            \"Pool shares already deployed\"\n        );\n\n\n        (string memory name, string memory symbol ) = _generateTokenNameAndSymbol(\n            address(principalToken),\n            address(collateralToken)\n        );\n\n        poolSharesToken = new LenderCommitmentGroupShares(\n            name,\n            symbol,\n            18  \n        );\n\n        return address(poolSharesToken);\n    }\n\n    function _generateTokenNameAndSymbol(address principalToken, address collateralToken) \n    internal view \n    returns (string memory name, string memory symbol) {\n        // Read the symbol of the principal token\n        string memory principalSymbol = ERC20(principalToken).symbol();\n        \n        // Read the symbol of the collateral token\n        string memory collateralSymbol = ERC20(collateralToken).symbol();\n        \n        // Combine the symbols to create the name\n        name = string(abi.encodePacked(\"GroupShares-\", principalSymbol, \"-\", collateralSymbol));\n        \n        // Combine the symbols to create the symbol\n        symbol = string(abi.encodePacked(\"SHR-\", principalSymbol, \"-\", collateralSymbol));\n    }\n\n    /**\n     * @notice This determines the number of shares you get for depositing principal tokens and the number of principal tokens you receive for burning shares\n     * @return rate_ The current exchange rate, scaled by the EXCHANGE_RATE_FACTOR.\n     */\n\n    function sharesExchangeRate() public view virtual returns (uint256 rate_) {\n        \n\n        uint256 poolTotalEstimatedValue = getPoolTotalEstimatedValue();\n\n        if (poolSharesToken.totalSupply() == 0) {\n            return EXCHANGE_RATE_EXPANSION_FACTOR; // 1 to 1 for first swap\n        }\n\n        rate_ =\n            (poolTotalEstimatedValue  *\n                EXCHANGE_RATE_EXPANSION_FACTOR) /\n            poolSharesToken.totalSupply();\n    }\n\n    function sharesExchangeRateInverse()\n        public\n        view\n        virtual\n        returns (uint256 rate_)\n    {\n        return\n            (EXCHANGE_RATE_EXPANSION_FACTOR * EXCHANGE_RATE_EXPANSION_FACTOR) /\n            sharesExchangeRate();\n    }\n\n    function getPoolTotalEstimatedValue()\n        public\n        view\n        returns (uint256 poolTotalEstimatedValue_)\n    {\n       \n         int256 poolTotalEstimatedValueSigned = int256(totalPrincipalTokensCommitted) \n         + int256(totalInterestCollected)  + int256(tokenDifferenceFromLiquidations) \n         - int256(totalPrincipalTokensWithdrawn);\n\n        //if the poolTotalEstimatedValue_ is less than 0, we treat it as 0.  \n        poolTotalEstimatedValue_ = poolTotalEstimatedValueSigned > int256(0)\n            ? uint256(poolTotalEstimatedValueSigned)\n            : 0;\n    }\n\n    /*\n    must be initialized for this to work ! \n    */\n    function addPrincipalToCommitmentGroup(\n        uint256 _amount,\n        address _sharesRecipient\n    ) external returns (uint256 sharesAmount_) {\n        //transfers the primary principal token from msg.sender into this contract escrow\n        \n        principalToken.transferFrom(msg.sender, address(this), _amount);\n\n        sharesAmount_ = _valueOfUnderlying(_amount, sharesExchangeRate());\n\n        totalPrincipalTokensCommitted += _amount;\n        //principalTokensCommittedByLender[msg.sender] += _amount;\n\n        //mint shares equal to _amount and give them to the shares recipient !!!\n        poolSharesToken.mint(_sharesRecipient, sharesAmount_);\n    }\n\n    function _valueOfUnderlying(uint256 amount, uint256 rate)\n        internal\n        pure\n        returns (uint256 value_)\n    {\n        if (rate == 0) {\n            return 0;\n        }\n\n        value_ = (amount * EXCHANGE_RATE_EXPANSION_FACTOR) / rate;\n    }\n\n    function acceptFundsForAcceptBid(\n        address _borrower,\n        uint256 _bidId,\n        uint256 _principalAmount,\n        uint256 _collateralAmount,\n        address _collateralTokenAddress,\n        uint256 _collateralTokenId, \n        uint32 _loanDuration,\n        uint16 _interestRate\n    ) external onlySmartCommitmentForwarder whenNotPaused {\n        \n        require(\n            _collateralTokenAddress == address(collateralToken),\n            \"Mismatching collateral token\"\n        );\n        //the interest rate must be at least as high has the commitment demands. The borrower can use a higher interest rate although that would not be beneficial to the borrower.\n        require(_interestRate >= getMinInterestRate(), \"Invalid interest rate\");\n        //the loan duration must be less than the commitment max loan duration. The lender who made the commitment expects the money to be returned before this window.\n        require(_loanDuration <= maxLoanDuration, \"Invalid loan max duration\");\n\n        require(\n            getPrincipalAmountAvailableToBorrow() >= _principalAmount,\n            \"Invalid loan max principal\"\n        );\n \n\n        //this is expanded by 10**18\n        uint256 requiredCollateral = getCollateralRequiredForPrincipalAmount(\n            _principalAmount\n        );\n\n        require(\n            (_collateralAmount * STANDARD_EXPANSION_FACTOR) >=\n                requiredCollateral,\n            \"Insufficient Borrower Collateral\"\n        );\n \n        principalToken.approve(address(TELLER_V2), _principalAmount);\n\n        //do not have to spoof/forward as this contract is the lender !\n        _acceptBidWithRepaymentListener(_bidId);\n\n        totalPrincipalTokensLended += _principalAmount;\n\n        activeBids[_bidId] = true; //bool for now\n        //emit event\n    }\n\n    function _acceptBidWithRepaymentListener(uint256 _bidId) internal {\n        ITellerV2(TELLER_V2).lenderAcceptBid(_bidId); //this gives out the funds to the borrower\n\n        ILoanRepaymentCallbacks(TELLER_V2).setRepaymentListenerForBid(\n            _bidId,\n            address(this)\n        );\n    }\n\n    /*\n       \n    */\n    function burnSharesToWithdrawEarnings(\n        uint256 _amountPoolSharesTokens,\n        address _recipient\n    ) external returns (uint256) {\n       \n\n        \n        poolSharesToken.burn(msg.sender, _amountPoolSharesTokens);\n\n        uint256 principalTokenValueToWithdraw = _valueOfUnderlying(\n            _amountPoolSharesTokens,\n            sharesExchangeRateInverse()\n        );\n\n        totalPrincipalTokensWithdrawn += principalTokenValueToWithdraw;\n\n        principalToken.transfer(_recipient, principalTokenValueToWithdraw);\n\n        return principalTokenValueToWithdraw;\n    }\n\n    /*\n\n\n    */\n\n    function liquidateDefaultedLoanWithIncentive(\n        uint256 _bidId,\n        int256 _tokenAmountDifference\n    ) public bidIsActiveForGroup(_bidId) {\n        uint256 amountDue = getAmountOwedForBid(_bidId, false);\n\n        uint256 loanDefaultedTimeStamp = ITellerV2(TELLER_V2)\n            .getLoanDefaultTimestamp(_bidId);\n\n        int256 minAmountDifference = getMinimumAmountDifferenceToCloseDefaultedLoan(\n                amountDue,\n                loanDefaultedTimeStamp\n            );\n\n        require(\n            _tokenAmountDifference >= minAmountDifference,\n            \"Insufficient tokenAmountDifference\"\n        );\n\n        if (_tokenAmountDifference > 0) {\n            //this is used when the collateral value is higher than the principal (rare)\n            //the loan will be completely made whole and our contract gets extra funds too\n            uint256 tokensToTakeFromSender = abs(_tokenAmountDifference);\n\n            IERC20(principalToken).transferFrom(\n                msg.sender,\n                address(this),\n                amountDue + tokensToTakeFromSender\n            );\n\n            tokenDifferenceFromLiquidations += int256(tokensToTakeFromSender);\n\n            totalPrincipalTokensRepaid += amountDue;\n        } else {\n           \n            uint256 tokensToGiveToSender = abs(_tokenAmountDifference);\n\n            IERC20(principalToken).transferFrom(\n                msg.sender,\n                address(this),\n                amountDue - tokensToGiveToSender\n            );\n\n            tokenDifferenceFromLiquidations -= int256(tokensToGiveToSender);\n\n            totalPrincipalTokensRepaid += amountDue;\n        }\n\n        //this will give collateral to the caller\n        ITellerV2(TELLER_V2).lenderCloseLoanWithRecipient(_bidId, msg.sender);\n    }\n\n    function getAmountOwedForBid(uint256 _bidId, bool _includeInterest)\n        public\n        view\n        virtual\n        returns (uint256 amountOwed_)\n    {\n        Payment memory amountOwedPayment = ITellerV2(TELLER_V2)\n            .calculateAmountOwed(_bidId, block.timestamp);\n\n        amountOwed_ = _includeInterest\n            ? amountOwedPayment.principal + amountOwedPayment.interest\n            : amountOwedPayment.principal;\n    }\n\n    /*\n        This function will calculate the incentive amount (using a uniswap bonus plus a timer)\n        of principal tokens that will be given to incentivize liquidating a loan \n \n    */\n    function getMinimumAmountDifferenceToCloseDefaultedLoan(\n        uint256 _amountOwed,\n        uint256 _loanDefaultedTimestamp\n    ) public view virtual returns (int256 amountDifference_) {\n        require(\n            _loanDefaultedTimestamp > 0,\n            \"Loan defaulted timestamp must be greater than zero\"\n        );\n        require(\n            block.timestamp > _loanDefaultedTimestamp,\n            \"Loan defaulted timestamp must be in the past\"\n        );\n\n        uint256 secondsSinceDefaulted = block.timestamp -\n            _loanDefaultedTimestamp;\n \n        int256 incentiveMultiplier = int256(86400) -\n            int256(secondsSinceDefaulted);\n\n        if (incentiveMultiplier < -10000) {\n            incentiveMultiplier = -10000;\n        }\n\n        amountDifference_ =\n            (int256(_amountOwed) * incentiveMultiplier) /\n            int256(10000);\n    }\n\n    function abs(int x) private pure returns (uint) {\n        return x >= 0 ? uint(x) : uint(-x);\n    }\n \n    function getCollateralRequiredForPrincipalAmount(uint256 _principalAmount)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 baseAmount = _calculateCollateralTokensAmountEquivalentToPrincipalTokens(\n                _principalAmount\n            );\n\n        //this is an amount of collateral\n        return baseAmount.percent(collateralRatio);\n    }\n\n    //this result is expanded by UNISWAP_EXPANSION_FACTOR\n    function _getUniswapV3TokenPairPrice(uint32 _twapInterval)\n        internal\n        view\n        returns (uint256)\n    {\n        // represents the square root of the price of token1 in terms of token0\n\n        uint160 sqrtPriceX96 = getSqrtTwapX96(_twapInterval);\n\n        //this output is the price ratio expanded by 1e18\n        return _getPriceFromSqrtX96(sqrtPriceX96);\n    }\n\n    //this result is expanded by UNISWAP_EXPANSION_FACTOR\n    function _getPriceFromSqrtX96(uint160 _sqrtPriceX96)\n        internal\n        pure\n        returns (uint256 price_)\n    {\n       \n        uint256 priceX96 = (uint256(_sqrtPriceX96) * uint256(_sqrtPriceX96)) /\n            (2**96);\n\n        // sqrtPrice is in X96 format so we scale it down to get the price\n        // Also note that this price is a relative price between the two tokens in the pool\n        // It's not a USD price\n        price_ = priceX96;\n    }\n\n    // ---- TWAP\n\n    function getSqrtTwapX96(uint32 twapInterval)\n        public\n        view\n        returns (uint160 sqrtPriceX96)\n    {\n        if (twapInterval == 0) {\n            // return the current price if twapInterval == 0\n            (sqrtPriceX96, , , , , , ) = IUniswapV3Pool(UNISWAP_V3_POOL)\n                .slot0();\n        } else {\n            uint32[] memory secondsAgos = new uint32[](2);\n            secondsAgos[0] = twapInterval; // from (before)\n            secondsAgos[1] = 0; // to (now)\n\n            (int56[] memory tickCumulatives, ) = IUniswapV3Pool(UNISWAP_V3_POOL)\n                .observe(secondsAgos);\n\n            // tick(imprecise as it's an integer) to price\n            sqrtPriceX96 = TickMath.getSqrtRatioAtTick(\n                int24(\n                    (tickCumulatives[1] - tickCumulatives[0]) /\n                        int32(twapInterval)\n                )\n            );\n        }\n    }\n\n    function _getPoolTokens()\n        internal\n        view\n        virtual\n        returns (address token0, address token1)\n    {\n        token0 = IUniswapV3Pool(UNISWAP_V3_POOL).token0();\n        token1 = IUniswapV3Pool(UNISWAP_V3_POOL).token1();\n    }\n\n    // -----\n\n    //this is expanded by 10e18\n    function _calculateCollateralTokensAmountEquivalentToPrincipalTokens(\n        uint256 principalTokenAmountValue\n    ) internal view returns (uint256 collateralTokensAmountToMatchValue) {\n        //same concept as zeroforone\n        (address token0, ) = _getPoolTokens();\n\n        bool principalTokenIsToken0 = (address(principalToken) == token0);\n\n        uint256 pairPriceWithTwap = _getUniswapV3TokenPairPrice(twapInterval);\n        uint256 pairPriceImmediate = _getUniswapV3TokenPairPrice(0);\n\n        return\n            _getCollateralTokensAmountEquivalentToPrincipalTokens(\n                principalTokenAmountValue,\n                pairPriceWithTwap,\n                pairPriceImmediate,\n                principalTokenIsToken0\n            );\n    }\n\n    /*\n        Dev Note: pairPriceWithTwap and pairPriceImmediate are expanded by UNISWAP_EXPANSION_FACTOR\n\n    */\n    function _getCollateralTokensAmountEquivalentToPrincipalTokens(\n        uint256 principalTokenAmountValue,\n        uint256 pairPriceWithTwap,\n        uint256 pairPriceImmediate,\n        bool principalTokenIsToken0\n    ) internal pure returns (uint256 collateralTokensAmountToMatchValue) {\n        if (principalTokenIsToken0) {\n            //token 1 to token 0 ?\n            uint256 worstCasePairPrice = Math.min(\n                pairPriceWithTwap,\n                pairPriceImmediate\n            );\n\n            collateralTokensAmountToMatchValue = token1ToToken0(\n                principalTokenAmountValue,\n                worstCasePairPrice //if this is lower, collateral tokens amt will be higher\n            );\n        } else {\n            //token 0 to token 1 ?\n            uint256 worstCasePairPrice = Math.max(\n                pairPriceWithTwap,\n                pairPriceImmediate\n            );\n\n            collateralTokensAmountToMatchValue = token0ToToken1(\n                principalTokenAmountValue,\n                worstCasePairPrice //if this is lower, collateral tokens amt will be higher\n            );\n        }\n    }\n\n    //note: the price is still expanded by UNISWAP_EXPANSION_FACTOR\n    function token0ToToken1(uint256 amountToken0, uint256 priceToken1PerToken0)\n        internal\n        pure\n        returns (uint256)\n    {\n        return\n            MathUpgradeable.mulDiv(\n                amountToken0,\n                UNISWAP_EXPANSION_FACTOR,\n                priceToken1PerToken0,\n                MathUpgradeable.Rounding.Up\n            );\n    }\n\n    //note: the price is still expanded by UNISWAP_EXPANSION_FACTOR\n    function token1ToToken0(uint256 amountToken1, uint256 priceToken1PerToken0)\n        internal\n        pure\n        returns (uint256)\n    {\n        return\n            MathUpgradeable.mulDiv(\n                amountToken1,\n                priceToken1PerToken0,\n                UNISWAP_EXPANSION_FACTOR,\n                MathUpgradeable.Rounding.Up\n            );\n    }\n\n    /*\n    This  callback occurs when a TellerV2 repayment happens or when a TellerV2 liquidate happens \n\n    len"
    }
  ]
}