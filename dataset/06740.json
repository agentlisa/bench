{
  "Title": "[G-02] The result of a function call should be cached rather than re-calling the function",
  "Content": "\nExternal calls are expensive. Consider caching the following:\n\nhttps://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Equity.sol#L144-L148\n### Equity.sol.adjustTotalVotes(): Results of anchorTime() should be cached rather than call it twice\n```solidity\nFile: /contracts/Equity.sol\n144:    function adjustTotalVotes(address from, uint256 amount, uint256 roundingLoss) internal {\n145:        uint256 lostVotes = from == address(0x0) ? 0 : (anchorTime() - voteAnchor[from]) * amount;\n146:        totalVotesAtAnchor = uint192(totalVotes() - roundingLoss - lostVotes);\n147:        totalVotesAnchorTime = anchorTime();\n148:    }\n```\n\n```diff\ndiff --git a/contracts/Equity.sol b/contracts/Equity.sol\nindex 7057ed6..6344fef 100644\n--- a/contracts/Equity.sol\n+++ b/contracts/Equity.sol\n@@ -142,9 +142,10 @@ contract Equity is ERC20PermitLight, MathUtil, IReserve {\n      * @param amount    amount to be sent\n      */\n     function adjustTotalVotes(address from, uint256 amount, uint256 roundingLoss) internal {\n-        uint256 lostVotes = from == address(0x0) ? 0 : (anchorTime() - voteAnchor[from]) * amount;\n+        uint64 _anchorTime = anchorTime();\n+        uint256 lostVotes = from == address(0x0) ? 0 : (_anchorTime - voteAnchor[from]) * amount;\n         totalVotesAtAnchor = uint192(totalVotes() - roundingLoss - lostVotes);\n-        totalVotesAnchorTime = anchorTime();\n+        totalVotesAnchorTime = _anchorTime;\n     }\n```\n\nhttps://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Frankencoin.sol#L83-L90\n### Frankencoin.sol.suggestMinter(): Result of totalSupply() should be cached here(sad path)\n```solidity\nFile: /contracts/Frankencoin.sol\n83:   function suggestMinter(address _minter, uint256 _applicationPeriod, uint256 _applicationFee, string calldata _message) override external {\n84:      if (_applicationPeriod < MIN_APPLICATION_PERIOD && totalSupply() > 0) revert PeriodTooShort();\n85:      if (_applicationFee < MIN_FEE  && totalSupply() > 0) revert FeeTooLow();\n86:      if (minters[_minter] != 0) revert AlreadyRegistered();\n87:      _transfer(msg.sender, address(reserve), _applicationFee);\n88:      minters[_minter] = block.timestamp + _applicationPeriod;\n89:      emit MinterApplied(_minter, _applicationPeriod, _applicationFee, _message);\n90:   }\n```\n\n```diff\ndiff --git a/contracts/Frankencoin.sol b/contracts/Frankencoin.sol\nindex e9e87dc..556d882 100644\n--- a/contracts/Frankencoin.sol\n+++ b/contracts/Frankencoin.sol\n@@ -81,8 +81,9 @@ contract Frankencoin is ERC20PermitLight, IFrankencoin {\n     * minter.\n     */\n    function suggestMinter(address _minter, uint256 _applicationPeriod, uint256 _applicationFee, string calldata _message) override external {\n-      if (_applicationPeriod < MIN_APPLICATION_PERIOD && totalSupply() > 0) revert PeriodTooShort();\n-      if (_applicationFee < MIN_FEE  && totalSupply() > 0) revert FeeTooLow();\n+      uint256 _totalSupply = totalSupply();\n+      if (_applicationPeriod < MIN_APPLICATION_PERIOD && _totalSupply > 0) revert PeriodTooShort();\n+      if (_applicationFee < MIN_FEE  && _totalSupply > 0) revert FeeTooLow();\n       if (minters[_minter] != 0) revert AlreadyRegistered();\n       _transfer(msg.sender, address(reserve), _applicationFee);\n       minters[_minter] = block.timestamp + _applicationPeriod;\n```\n\nhttps://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Frankencoin.sol#L204-L213\n### Frankencoin.sol.calculateAssignedReserve(): Results of minterReserve() should be cached \n```solidity\nFile: /contracts/Frankencoin.sol\n204:   function calculateAssignedReserve(uint256 mintedAmount, uint32 _reservePPM) public view returns (uint256) {\n205:      uint256 theoreticalReserve = _reservePPM * mintedAmount / 1000000;\n206:      uint256 currentReserve = balanceOf(address(reserve));\n207:      if (currentReserve < minterReserve()){ //@audit: Initial call\n208:         // not enough reserves, owner has to take a loss\n209:         return theoreticalReserve * currentReserve / minterReserve();//@audit: second call\n210:      } else {\n211:         return theoreticalReserve;\n212:      }\n213:   }\n```\n\n```diff\ndiff --git a/contracts/Frankencoin.sol b/contracts/Frankencoin.sol\nindex e9e87dc..1f0a60e 100644\n--- a/contracts/Frankencoin.sol\n+++ b/contracts/Frankencoin.sol\n@@ -204,9 +204,10 @@ contract Frankencoin is ERC20PermitLight, IFrankencoin {\n    function calculateAssignedReserve(uint256 mintedAmount, uint32 _reservePPM) public view returns (uint256) {\n       uint256 theoreticalReserve = _reservePPM * mintedAmount / 1000000;\n       uint256 currentReserve = balanceOf(address(reserve));\n-      if (currentReserve < minterReserve()){\n+      uint256 _minterReserve = minterReserve();\n+      if (currentReserve < _minterReserve){\n          // not enough reserves, owner has to take a loss\n-         return theoreticalReserve * currentReserve / minterReserve();\n+         return theoreticalReserve * currentReserve / _minterReserve;\n       } else {\n          return theoreticalReserve;\n       }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-04-frankencoin",
  "Code": [
    {
      "filename": "contracts/Equity.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./Frankencoin.sol\";\nimport \"./IERC677Receiver.sol\";\nimport \"./ERC20PermitLight.sol\";\nimport \"./MathUtil.sol\";\nimport \"./IReserve.sol\";\n\n/** \n * If the Frankencoin system was a bank, this contract would represent the equity on its balance sheet.\n * Like with a corporation, the owners of the equity capital are the shareholders, or in this case the holders\n * of Frankencoin Pool Shares (FPS) tokens. Anyone can mint additional FPS tokens by adding Frankencoins to the\n * reserve pool. Also, FPS tokens can be redeemed for Frankencoins again after a minimum holding period.\n * Furthermore, the FPS shares come with some voting power. Anyone that held at least 3% of the holding-period-\n * weighted reserve pool shares gains veto power and can veto new proposals.\n */\ncontract Equity is ERC20PermitLight, MathUtil, IReserve {\n\n    /**\n     * The VALUATION_FACTOR determines the market cap of the reserve pool shares relative to the equity reserves.\n     * The following always holds: Market Cap = Valuation Factor * Equity Reserve = Price * Supply\n     *\n     * In the absence of profits and losses, the variables grow as follows when FPS tokens are minted:\n     *\n     * |   Reserve     |   Market Cap  |     Price     |     Supply   |\n     * |          1000 |          3000 |             3 |         1000 |\n     * |       1000000 |       3000000 |           300 |        10000 |\n     * |    1000000000 |    3000000000 |         30000 |       100000 |\n     * | 1000000000000 | 3000000000000 |       3000000 |      1000000 |\n     *\n     * I.e., the supply is proporational to the cubic root of the reserve and the price is proportional to the\n     * squared cubic root. When profits accumulate or losses materialize, the reserve, the market cap,\n     * and the price are adjusted proportionally, with the supply staying constant. In the absence of an extreme\n     * inflation of the Swiss franc, it is unlikely that there will ever be more than ten million FPS.\n     */\n    uint32 public constant VALUATION_FACTOR = 3;\n\n    uint256 private constant MINIMUM_EQUITY = 1000 * ONE_DEC18;\n\n    /**\n     * The quorum in basis points. 100 is 1%.\n     */\n    uint32 private constant QUORUM = 300;\n\n    /**\n     * The number of digits to store the average holding time of share tokens.\n     */\n    uint8 private constant BLOCK_TIME_RESOLUTION_BITS = 24;\n\n    /**\n     * The minimum holding duration in blocks. You are not allowed to redeem your pool shares if you held them\n     * for less than the minimum holding duration at average. For example, if you have two pool shares on your\n     * address, one acquired 5 days ago and one acquired 105 days ago, you cannot redeem them as the average\n     * holding duration of your shares is only 55 days < 90 days.\n     */\n    uint256 public constant MIN_HOLDING_DURATION = 90*7200 << BLOCK_TIME_RESOLUTION_BITS; // Set to 5 for local testing\n\n    Frankencoin immutable public zchf;\n\n    /**\n     * To track the total number of votes we need to know the number of votes at the anchor time and when the\n     * anchor time was. This is (hopefully) stored in one 256 bit slot, with the anchor time taking 64 Bits and\n     * the total vote count 192 Bits. Given the sub-block time resolution of 24 Bits, the implicit assumption is\n     * that the block number can always be stored in 40 Bits (i.e. it does not exceed a trillion). Further,\n     * given 18 decimals (about 60 Bits), this implies that the total supply cannot exceed \n     *   192 - 60 - 40 - 24 = 68 Bits\n     * Here, we are also save, as 68 Bits would imply more than a trillion outstanding shares. In fact, when\n     * minting, a limit of about 2**30 shares (that's 2**90 Bits when taking into account the decimals) is imposed\n     * when minting. This means that the maximum supply is about a billion shares, which is reached at a market\n     * cap of 3,000,000,000,000,000,000 CHF. This limit could in theory be reached in times of hyper inflaction. \n     */\n    uint192 private totalVotesAtAnchor;  // Total number of votes at the anchor time, see comment on the um\n    uint64 private totalVotesAnchorTime; // 40 Bit for the block number, 24 Bit sub-block time resolution\n\n    /**\n     * Keeping track on who delegated votes to whom.\n     * Note that delegation does not mean you cannot vote / veto any more, it just means that the delegate can\n     * benefit from your votes when invoking a veto. Circular delegations are valid, do not help when voting.\n     */\n    mapping (address => address) public delegates;\n\n    /**\n     * A block number in the past such that: votes = balance * (time passed since anchor was set)\n     */\n    mapping (address => uint64) private voteAnchor; // 40 Bit for the block number, 24 Bit sub-block time resolution\n\n    event Delegation(address indexed from, address indexed to); // indicates a delegation\n    event Trade(address who, int amount, uint totPrice, uint newprice); // amount pos or neg for mint or redemption\n\n    constructor(Frankencoin zchf_) ERC20(18) {\n        zchf = zchf_;\n    }\n\n    function name() override external pure returns (string memory) {\n        return \"Frankencoin Pool Share\";\n    }\n\n    function symbol() override external pure returns (string memory) {\n        return \"FPS\";\n    }\n\n    /**\n     * Returns the price of one FPS in ZCHF with 18 decimals precision.\n     */\n    function price() public view returns (uint256){\n        return VALUATION_FACTOR * zchf.equity() * ONE_DEC18 / totalSupply();\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) override internal {\n        super._beforeTokenTransfer(from, to, amount);\n        if (amount > 0){\n            // No need to adjust the sender votes. When they send out 10% of their shares, they also lose 10% of\n            // their votes so everything falls nicely into place.\n            // Recipient votes should stay the same, but grow faster in the future, requiring an adjustment of the anchor.\n            uint256 roundingLoss = adjustRecipientVoteAnchor(to, amount);\n            // The total also must be adjusted and kept accurate by taking into account the rounding error.\n            adjustTotalVotes(from, amount, roundingLoss);\n        }\n    }\n\n    /**\n     * Returns whether the sender address is allowed to redeem FPS.\n     */\n    function canRedeem() external view returns (bool){\n        return canRedeem(msg.sender);\n    }\n\n    /**\n     * Returns whether the given address is allowed to redeem FPS, which is the\n     * case after their average holding duration is larger than the required minimum.\n     */\n    function canRedeem(address owner) public view returns (bool) {\n        return anchorTime() - voteAnchor[owner] >= MIN_HOLDING_DURATION;\n    }\n\n     /**\n     * @notice Decrease the total votes anchor when tokens lose their voting power due to being moved\n     * @param from      sender\n     * @param amount    amount to be sent\n     */\n    function adjustTotalVotes(address from, uint256 amount, uint256 roundingLoss) internal {\n        uint256 lostVotes = from == address(0x0) ? 0 : (anchorTime() - voteAnchor[from]) * amount;\n        totalVotesAtAnchor = uint192(totalVotes() - roundingLoss - lostVotes);\n        totalVotesAnchorTime = anchorTime();\n    }\n\n    /**\n     * @notice the vote anchor of the recipient is moved forward such that the number of calculated\n     * votes does not change despite the higher balance.\n     * @param to        receiver address\n     * @param amount    amount to be received\n     * @return the number of votes lost due to rounding errors\n     */\n    function adjustRecipientVoteAnchor(address to, uint256 amount) internal returns (uint256){\n        if (to != address(0x0)) {\n            uint256 recipientVotes = votes(to); // for example 21 if 7 shares were held for 3 blocks\n            uint256 newbalance = balanceOf(to) + amount; // for example 11 if 4 shares are added\n            voteAnchor[to] = uint64(anchorTime() - recipientVotes / newbalance); // new example anchor is only 21 / 11 = 1 block in the past\n            return recipientVotes % newbalance; // we have lost 21 % 11 = 10 votes\n        } else {\n            // optimization for burn, vote anchor of null address does not matter\n            return 0;\n        }\n    }\n\n    /**\n     * Block number with some additional Bits for higher resolution.\n     */\n    function anchorTime() internal view returns (uint64){\n        return uint64(block.number << BLOCK_TIME_RESOLUTION_BITS);\n    }\n\n    /**\n     * The votes of the holder, excluding votes from delegates.\n     */\n    function votes(address holder) public view returns (uint256) {\n        return balanceOf(holder) * (anchorTime() - voteAnchor[holder]);\n    }\n\n    /**\n     * Total number of votes in the system.\n     */\n    function totalVotes() public view returns (uint256) {\n        return totalVotesAtAnchor + totalSupply() * (anchorTime() - totalVotesAnchorTime);\n    }\n\n    function votes(address sender, address[] calldata helpers) public view returns (uint256) {\n        uint256 _votes = votes(sender);\n        for (uint i=0; i<helpers.length; i++){\n            address current = helpers[i];\n            require(current != sender);\n            require(canVoteFor(sender, current));\n            for (uint j=i+1; j<helpers.length; j++){\n                require(current != helpers[j]); // ensure helper unique\n            }\n            _votes += votes(current);\n        }\n        return _votes;\n    }\n\n    /**\n     * Checks whether the sender address is qualified given a list of helpers that delegated their votes\n     * directly or indirectly to the sender. It is the responsiblity of the caller to figure out whether\n     * helpes are necessary and to identify them by scanning the blockchain for Delegation events. \n     */\n    function checkQualified(address sender, address[] calldata helpers) public override view {\n        uint256 _votes = votes(sender, helpers);\n        if (_votes * 10000 < QUORUM * totalVotes()) revert NotQualified();\n    }\n\n    error NotQualified();\n\n    /**\n     * Increases the voting power of the delegate by your number of votes without taking away any voting power\n     * from the sender.\n     */\n    function delegateVoteTo(address delegate) external {\n        delegates[msg.sender] = delegate;\n        emit Delegation(msg.sender, delegate);\n    }\n\n    function canVoteFor(address delegate, address owner) internal view returns (bool) {\n        if (owner == delegate){\n            return true;\n        } else if (owner == address(0x0)){\n            return false;\n        } else {\n            return canVoteFor(delegate, delegates[owner]);\n        }\n    }\n\n    /**\n     * In order to mint new FPS tokens, one needs to send ZCHF to this contract using the transferAndCall function\n     * in the ZCHF contract.\n     *\n     * If equity is close to zero or negative, you need to send enough ZCHF to bring equity back to 1000 ZCHF.\n     */\n    function onTokenTransfer(address from, uint256 amount, bytes calldata) external returns (bool) {\n        require(msg.sender == address(zchf), \"caller must be zchf\");\n        uint256 equity = zchf.equity();\n        require(equity >= MINIMUM_EQUITY, \"insuf equity\"); // ensures that the initial deposit is at least 1000 ZCHF\n\n        // Assign 1000 FPS for the initial deposit, calculate the amount otherwise\n        uint256 shares = equity <= amount ? 1000 * ONE_DEC18 : calculateSharesInternal(equity - amount, amount);\n        _mint(from, shares);\n        emit Trade(msg.sender, int(shares), amount, price());\n\n        // limit the total supply to a reasonable amount to guard against overflows with price and vote calculations\n        // the 128 bits are 68 bits for magnitude and 60 bits for precision, as calculated in an above comment\n        require(totalSupply() < 2**128, \"total supply exceeded\");\n        return true;\n    }\n\n    /**\n     * @notice Calculate shares received when depositing ZCHF\n     * @param investment ZCHF invested\n     * @return amount of shares received for the ZCHF invested\n     */\n    function calculateShares(uint256 investment) public view returns (uint256) {\n        return calculateSharesInternal(zchf.equity(), investment);\n    }\n\n    function calculateSharesInternal(uint256 capitalBefore, uint256 investment) internal view returns (uint256) {\n        uint256 totalShares = totalSupply();\n        uint256 newTotalShares = totalShares < 1000 * ONE_DEC18 ? 1000 * ONE_DEC18 : _mulD18(totalShares, _cubicRoot(_divD18(capitalBefore + investment, capitalBefore)));\n        return newTotalShares - totalShares;\n    }\n\n    /**\n     * Redeem the given amount of shares owned by the sender and transfer the proceeds to the target.\n     */\n    function redeem(address target, uint256 shares) public returns (uint256) {\n        require(canRedeem(msg.sender));\n        uint256 proceeds = calculateProceeds(shares);\n        _burn(msg.sender, shares);\n        zchf.transfer(target, proceeds);\n        emit Trade(msg.sender, -int(shares), proceeds, price());\n        return proceeds;\n    }\n\n    /**\n     * @notice Calculate ZCHF received when depositing shares\n     * @param shares number of shares we want to exchange for ZCHF,\n     *               in dec18 format\n     * @return amount of ZCHF received for the shares\n     */\n    function calculateProceeds(uint256 shares) public view returns (uint256) {\n        uint256 totalShares = totalSupply();\n        uint256 capital = zchf.equity();\n        require(shares + ONE_DEC18 < totalShares, \"too many shares\"); // make sure there is always at least one share\n        uint256 newTotalShares = totalShares - shares;\n        uint256 newCapital = _mulD18(capital, _power3(_divD18(newTotalShares, totalShares)));\n        return capital - newCapital;\n    }\n\n    /**\n     * If there is less than 1000 ZCHF in equity left (maybe even negative), the system is at risk\n     * and we should allow qualified FPS holders to restructure the system.\n     *\n     * Example: there was a devastating loss and equity stands at -1'000'000. Most shareholders have lost hope in the\n     * Frankencoin system except for a group of small FPS holders who still believes in it and is willing to provide\n     * 2'000'000 ZCHF to save it. These brave souls are essentially donating 1'000'000 to the minter reserve and it\n     * would be wrong to force them to share the other million with the passive FPS holders. Instead, they will get\n     * the possibility to bootstrap the system again owning 100% of all FPS shares.\n     */\n    function restructureCapTable(address[] calldata helpers, address[] calldata addressesToWipe) public {\n        require(zchf.equity() < MINIMUM_EQUITY);\n        checkQualified(msg.sender, helpers);\n        for (uint256 i = 0; i<addressesToWipe.length; i++){\n            address current = addressesToWipe[0];\n            _burn(current, balanceOf(current));\n        }\n    }\n\n}"
    },
    {
      "filename": "contracts/Frankencoin.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ERC20PermitLight.sol\";\nimport \"./Equity.sol\";\nimport \"./IReserve.sol\";\nimport \"./IFrankencoin.sol\";\n\n/**\n * The Frankencoin (ZCHF) is an ERC-20 token that is designed to track the value of the Swiss franc.\n * It is not upgradable, but open to arbitrary minting plugins. These are automatically accepted if none of the\n * qualified pool share holders casts a veto, leading to a flexible but conservative governance.\n *\n * The underlying assumption is that there is one or more qualified pool share (FPS) holders that watch the proposals\n * and veto if necessary. At the same time, it is also assumed that no one vetoes all of them, thereby starving the\n * system. The system can only function as long as all the qualified shareholders act in the interest of the system\n * or at least do not actively sabotage it. As long as everyone believes that the governance works well, no one will\n * ever make an unsound proposal and it won't be necessary to ever cast a veto, making the system self-governing.\n */\ncontract Frankencoin is ERC20PermitLight, IFrankencoin {\n\n   /**\n    * Minimal fee and application period when suggesting a new minter.\n    */\n   uint256 public constant MIN_FEE = 1000 * (10**18);\n   uint256 public immutable MIN_APPLICATION_PERIOD; // for example 10 days\n\n   /**\n    * The contract that holds the reserve.\n    */\n   IReserve override public immutable reserve;\n\n   /**\n    * How much of the reserve belongs to the minters.\n    * Everything else belongs to the pool share holders.\n    * Stored with 6 additional digits of accuracy so no rounding is necessary\n    * when dealing with parts per million (ppm) in reserve calculations.\n    */\n   uint256 private minterReserveE6;\n\n   /**\n    * Map of minters to approval time stamps. If the time stamp is in the past, the minter contract is allowed\n    * to mint Frankencoins.\n    */\n   mapping (address => uint256) public minters;\n\n   /**\n    * List of positions that are allowed to mint and the minter that registered them.\n    */\n   mapping (address => address) public positions;\n\n   event MinterApplied(address indexed minter, uint256 applicationPeriod, uint256 applicationFee, string message);\n   event MinterDenied(address indexed minter, string message);\n\n   /**\n    * Initiates the Frankencoin with the provided minimum application period for new plugins\n    * in seconds, for example 10 days, i.e. 3600*24*10 = 864000\n    */\n   constructor(uint256 _minApplicationPeriod) ERC20(18){\n      MIN_APPLICATION_PERIOD = _minApplicationPeriod;\n      reserve = new Equity(this);\n   }\n\n   function name() override external pure returns (string memory){\n      return \"Frankencoin\";\n   }\n\n   function symbol() override external pure returns (string memory){\n      return \"ZCHF\";\n   }\n\n   /**\n    * Publicly accessible method to suggest a new way of minting Frankencoins.\n    *\n    * The caller has to pay an application fee that is irrevocably lost even if the new minter is vetoed.\n    *\n    * The caller must assume that someone will veto the new minter unless there is broad consensus that the new minter\n    * adds value to the Frankencoin system. Complex proposals should have application periods and applications fees above\n    * the minimum. It is assumed that over time, informal ways to coordinate on new minters emerge. The message parameter\n    * might be useful for initiating further communication. Maybe it contains a link to a website describing the proposed\n    * minter.\n    */\n   function suggestMinter(address _minter, uint256 _applicationPeriod, uint256 _applicationFee, string calldata _message) override external {\n      if (_applicationPeriod < MIN_APPLICATION_PERIOD && totalSupply() > 0) revert PeriodTooShort();\n      if (_applicationFee < MIN_FEE  && totalSupply() > 0) revert FeeTooLow();\n      if (minters[_minter] != 0) revert AlreadyRegistered();\n      _transfer(msg.sender, address(reserve), _applicationFee);\n      minters[_minter] = block.timestamp + _applicationPeriod;\n      emit MinterApplied(_minter, _applicationPeriod, _applicationFee, _message);\n   }\n\n   error PeriodTooShort();\n   error FeeTooLow();\n   error AlreadyRegistered();\n\n   /**\n    * Make the system more user friendly by skipping the allowance in many cases.\n    *\n    * We trust minters and the positions they have created to mint and burn as they please, so\n    * giving them arbitraty allowances does not pose an additional risk.\n    */\n   function allowanceInternal(address owner, address spender) internal view override returns (uint256) {\n      uint256 explicit = super.allowanceInternal(owner, spender);\n      if (explicit > 0){\n         return explicit; // don't waste gas checking minter\n      } else if (isMinter(spender) || isMinter(isPosition(spender))){\n         return INFINITY;\n      } else {\n         return 0;\n      }\n   }\n\n   /**\n    * The reserve provided by the owners of collateralized positions.\n    * The minter reserve can be used to cover losses after all else failed and the equity holders have already been wiped out.\n    */\n   function minterReserve() public view returns (uint256) {\n      return minterReserveE6 / 1000000;\n   }\n\n   /**\n    * Registers a collateralized debt position, thereby giving it the ability to mint Frankencoins.\n    * It is assumed that the responsible minter that registers the position ensures that the position can be trusted.\n    */\n   function registerPosition(address _position) override external {\n      if (!isMinter(msg.sender)) revert NotMinter();\n      positions[_position] = msg.sender;\n   }\n\n   error NotMinter();\n\n   /**\n    * The amount of equity of the Frankencoin system in ZCHF, owned by the holders of Frankencoin Pool Shares.\n    * Note that the equity contract technically holds both the minter reserve as well as the equity, so the minter\n    * reserve must be subtracted. All fees and other kind of income is added to the Equity contract and essentially\n    * constitutes profits attributable to the pool share holders.\n    */\n   function equity() public view returns (uint256) {\n      uint256 balance = balanceOf(address(reserve));\n      uint256 minReserve = minterReserve();\n      if (balance <= minReserve){\n        return 0;\n      } else {\n        return balance - minReserve;\n      }\n    }\n\n   /**\n    * Qualified pool share holders can deny minters during the application period.\n    * Calling this function is relatively cheap thanks to the deletion of a storage slot.\n    */\n   function denyMinter(address _minter, address[] calldata _helpers, string calldata _message) override external {\n      if (block.timestamp > minters[_minter]) revert TooLate();\n      reserve.checkQualified(msg.sender, _helpers);\n      delete minters[_minter];\n      emit MinterDenied(_minter, _message);\n   }\n\n   error TooLate();\n\n   /**\n    * Mints the provided amount of ZCHF to the target address, automatically forwarding\n    * the minting fee and the reserve to the right place.\n    */\n   function mint(address _target, uint256 _amount, uint32 _reservePPM, uint32 _feesPPM) override external minterOnly {\n      uint256 usableMint = (_amount * (1000_000 - _feesPPM - _reservePPM)) / 1000_000; // rounding down is fine\n      _mint(_target, usableMint);\n      _mint(address(reserve), _amount - usableMint); // rest goes to equity as reserves or as fees\n      minterReserveE6 += _amount * _reservePPM; // minter reserve must be kept accurately in order to ensure we can get back to exactly 0\n   }\n\n   function mint(address _target, uint256 _amount) override external minterOnly {\n      _mint(_target, _amount);\n   }\n\n   /**\n    * Anyone is allowed to burn their ZCHF.\n    */\n   function burn(uint256 _amount) external {\n      _burn(msg.sender, _amount);\n   }\n\n   /**\n    * Burn that amount without reclaiming the reserve, but freeing it up and thereby essentially donating it to the pool\n    * share holders. This can make sense in combination with 'notifyLoss', i.e. when it is the pool share holders that bear the risk\n    * and depending on the outcome they make a profit or a loss.\n    *\n    * Design rule: Minters calling this method are only allowed to so for tokens amounts they previously minted with the same _reservePPM amount.\n    *\n    * For example, if someone minted 50 ZCHF earlier with a 20% reserve requirement (200000 ppm), they got 40 ZCHF and paid\n    * 10 ZCHF into the reserve. Now they want to repay the debt by burning 50 ZCHF. When doing so using this method, 50 ZCHF get\n    * burned and on top of that, 10 ZCHF previously assigned to the minter's reserved are reassigned to the pool share holders.\n    */\n   function burn(uint256 amount, uint32 reservePPM) external override minterOnly {\n      _burn(msg.sender, amount);\n      minterReserveE6 -= amount * reservePPM;\n   }\n\n   /**\n    * Calculates the reserve attributable to someone who minted the given amount with the given reserve requirement.\n    * Under normal circumstances, this is just the reserver requirement multiplied by the amount. However, after a severe loss\n    * of capital that burned into the minter's reserve, this can also be less than that.\n    */\n   function calculateAssignedReserve(uint256 mintedAmount, uint32 _reservePPM) public view returns (uint256) {\n      uint256 theoreticalReserve = _reservePPM * mintedAmount / 1000000;\n      uint256 currentReserve = balanceOf(address(reserve));\n      if (currentReserve < minterReserve()){\n         // not enough reserves, owner has to take a loss\n         return theoreticalReserve * currentReserve / minterReserve();\n      } else {\n         return theoreticalReserve;\n      }\n   }\n\n   /**\n    * Burns the target amount taking the tokens to be burned from the payer and the payer's reserve.\n    * The caller is only allowed to use this method for tokens also minted through the caller with the same _reservePPM amount.\n    *\n    * Example: the calling contract has previously minted 100 ZCHF with a reserve ratio of 20% (i.e. 200000 ppm). To burn half\n    * of that again, the minter calls burnFrom with a target amount of 50 ZCHF. Assuming that reserves are only 90% covered,\n    * this call will deduct 41 ZCHF from the payer's balance and 9 from the reserve, while reducing the minter reserve by 10.\n    */\n   function burnFrom(address payer, uint256 targetTotalBurnAmount, uint32 _reservePPM) external override minterOnly returns (uint256) {\n      uint256 assigned = calculateAssignedReserve(targetTotalBurnAmount, _reservePPM);\n      _transfer(address(reserve), payer, assigned); // send reserve to owner\n      _burn(payer, targetTotalBurnAmount); // and burn the full amount from the owner's address\n      minterReserveE6 -= targetTotalBurnAmount * _reservePPM; // reduce reserve requirements by original ratio\n      return assigned;\n   }\n\n   /**\n    * Calculate the amount that is freed when returning amountExcludingReserve given a reserve ratio of reservePPM, taking\n    * into account potential losses. Example values in the comments.\n    */\n   function calculateFreedAmount(uint256 amountExcludingReserve /* 41 */, uint32 reservePPM /* 20% */) public view returns (uint256){\n      uint256 currentReserve = balanceOf(address(reserve)); // 18, 10% below what we should have\n      uint256 minterReserve_ = minterReserve(); // 20\n      uint256 adjustedReservePPM = currentReserve < minterReserve_ ? reservePPM * currentReserve / minterReserve_ : reservePPM; // 18%\n      return 1000000 * amountExcludingReserve / (1000000 - adjustedReservePPM); // 41 / (1-18%) = 50\n   }\n\n   /**\n    * Burns the provided number of tokens plus whatever reserves are associated with that amount given the reserve requirement.\n    * The caller is only allowed to use this method for tokens also minted through the caller with the same _reservePPM amount.\n    *\n    * Example: the calling contract has previously minted 100 ZCHF with a reserve ratio of 20% (i.e. 200000 ppm). Now they have\n    * 41 ZCHF that they do not need so they decide to repay that amount. Assuming the reserves are only 90% covered,\n    * the call to burnWithReserve will burn the 41 plus 9 from the reserve, reducing the outstanding 'debt' of the caller by\n    * 50 ZCHF in total. This total is returned by the method so the caller knows how much less they owe.\n    */\n   function burnWithReserve(uint256 _amountExcludingReserve, uint32 _reservePPM) external override minterOnly returns (uint256) {\n      uint256 freedAmount = calculateFreedAmount(_amountExcludingReserve, _reservePPM);\n      minterReserveE6 -= freedAmount * _reservePPM; // reduce reserve requirements by original ratio\n      _transfer(address(reserve), msg.sender, freedAmount - _amountExcludingReserve); // collect assigned reserve, maybe less than original reserve\n      _burn(msg.sender, freedAmount); // burn the rest of the freed amount\n      return freedAmount;\n   }\n\n   /**\n    * Burn someone elses ZCHF.\n    */\n   function burn(address _owner, uint256 _amount) override external minterOnly {\n      _burn(_owner, _amount);\n   }\n\n   modifier minterOnly() {\n      if (!isMinter(msg.sender) && !isMinter(positions[msg.sender])) revert NotMinter();\n      _;\n   }\n\n   /**\n    * Notify the Frankencoin that a minter lost economic access to some coins. This does not mean that the coins\n    * are literally lost. It just means that some ZCHF will likely never be repaid and that in order to bring the system\n    * back into balance, the lost amount of ZCHF must be removed from the reserve instead.\n    *\n    * For example, if a minter printed 1 million ZCHF for a mortgage and the mortgage turned out to be unsound with the\n    * house only yielding 800'000 in the subsequent auction, there is a loss of 200'000 that needs to be covered by the \n    * reserve.\n    */\n   function notifyLoss(uint256 _amount) override external minterOnly {\n      uint256 reserveLeft = balanceOf(address(reserve));\n      if (reserveLeft >= _amount){\n         _transfer(address(reserve), msg.sender, _amount);\n      } else {\n         _transfer(address(reserve), msg.sender, reserveLeft);\n         _mint(msg.sender, _amount - reserveLeft);\n      }\n   }\n\n   /**\n    * Returns true if the address is an approved minter.\n    */\n   function isMinter(address _minter) override public view returns (bool){\n      return minters[_minter] != 0 && block.timestamp >= minters[_minter];\n   }\n\n   /**\n    * Returns the address of the minter that created this position or null if the provided address is unknown.\n    */\n   function isPosition(address _position) override public view returns (address){\n      return positions[_position];\n   }\n\n}"
    },
    {
      "filename": "contracts/Frankencoin.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ERC20PermitLight.sol\";\nimport \"./Equity.sol\";\nimport \"./IReserve.sol\";\nimport \"./IFrankencoin.sol\";\n\n/**\n * The Frankencoin (ZCHF) is an ERC-20 token that is designed to track the value of the Swiss franc.\n * It is not upgradable, but open to arbitrary minting plugins. These are automatically accepted if none of the\n * qualified pool share holders casts a veto, leading to a flexible but conservative governance.\n *\n * The underlying assumption is that there is one or more qualified pool share (FPS) holders that watch the proposals\n * and veto if necessary. At the same time, it is also assumed that no one vetoes all of them, thereby starving the\n * system. The system can only function as long as all the qualified shareholders act in the interest of the system\n * or at least do not actively sabotage it. As long as everyone believes that the governance works well, no one will\n * ever make an unsound proposal and it won't be necessary to ever cast a veto, making the system self-governing.\n */\ncontract Frankencoin is ERC20PermitLight, IFrankencoin {\n\n   /**\n    * Minimal fee and application period when suggesting a new minter.\n    */\n   uint256 public constant MIN_FEE = 1000 * (10**18);\n   uint256 public immutable MIN_APPLICATION_PERIOD; // for example 10 days\n\n   /**\n    * The contract that holds the reserve.\n    */\n   IReserve override public immutable reserve;\n\n   /**\n    * How much of the reserve belongs to the minters.\n    * Everything else belongs to the pool share holders.\n    * Stored with 6 additional digits of accuracy so no rounding is necessary\n    * when dealing with parts per million (ppm) in reserve calculations.\n    */\n   uint256 private minterReserveE6;\n\n   /**\n    * Map of minters to approval time stamps. If the time stamp is in the past, the minter contract is allowed\n    * to mint Frankencoins.\n    */\n   mapping (address => uint256) public minters;\n\n   /**\n    * List of positions that are allowed to mint and the minter that registered them.\n    */\n   mapping (address => address) public positions;\n\n   event MinterApplied(address indexed minter, uint256 applicationPeriod, uint256 applicationFee, string message);\n   event MinterDenied(address indexed minter, string message);\n\n   /**\n    * Initiates the Frankencoin with the provided minimum application period for new plugins\n    * in seconds, for example 10 days, i.e. 3600*24*10 = 864000\n    */\n   constructor(uint256 _minApplicationPeriod) ERC20(18){\n      MIN_APPLICATION_PERIOD = _minApplicationPeriod;\n      reserve = new Equity(this);\n   }\n\n   function name() override external pure returns (string memory){\n      return \"Frankencoin\";\n   }\n\n   function symbol() override external pure returns (string memory){\n      return \"ZCHF\";\n   }\n\n   /**\n    * Publicly accessible method to suggest a new way of minting Frankencoins.\n    *\n    * The caller has to pay an application fee that is irrevocably lost even if the new minter is vetoed.\n    *\n    * The caller must assume that someone will veto the new minter unless there is broad consensus that the new minter\n    * adds value to"
    }
  ]
}