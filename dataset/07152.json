{
  "Title": "[M-01] `_currentIndex` is incorrectly updated; breaking the ERC1155 enumerable implementation",
  "Content": "\n<https://github.com/code-423n4/2023-01-timeswap/blob/3be51465583552cce76816a05170fda7da68596a/packages/v2-token/src/base/ERC1155Enumerable.sol#L92-L101> \n\n<https://github.com/code-423n4/2023-01-timeswap/blob/3be51465583552cce76816a05170fda7da68596a/packages/v2-token/src/base/ERC1155Enumerable.sol#L116-L121> \n\n<https://github.com/code-423n4/2023-01-timeswap/blob/3be51465583552cce76816a05170fda7da68596a/packages/v2-token/src/base/ERC1155Enumerable.sol#L136-L149>\n\n### Impact\n\nWhen minting and burning tokens,the ERC1155Enumerable implementation does not correctly update the following states:\n\n*   uint256\\[] private \\_allTokens;\n*   mapping(uint256 => uint256) private \\_allTokensIndex;\n*   mapping(address => uint256) internal \\_currentIndex;\n\nIn particular:\n\n*   the \\_allTokens array length (and therefore the totalSupply()) always increases (never decreases)\n*   the \\_allTokensIndex\\[id] always increases\n*   the \\_curentIndex\\[from] always increases\n\n### Proof of Concept\n\nNOTE: the following test requires some private states of ERC1155Enumerable.sol to be set from private to internal.\n\n```solidity\ncontract HelperERC1155 is ERC1155Enumerable, ERC1155Holder {\n\n    constructor() ERC1155(\"Test\") {\n    }\n\n    function mint(uint256 id, uint256 amount) external {\n        _mint(msg.sender, id, amount, bytes(\"\"));\n    }\n\n    function burn(uint256 id, uint256 amount) external {\n        _burn(msg.sender, id, amount);\n    }\n\n    function currentIndex(address owner) external view returns (uint256) {\n        return _currentIndex[owner];\n    }\n\n    function allTokensIndex(uint256 id) external view returns (uint256) {\n        return _allTokensIndex[id];\n    }\n\n    function allTokens(uint256 idx) external view returns (uint256) {\n        return _allTokens[idx];\n    }\n\n    function idTotalSupply(uint256 id) external view returns (uint256) {\n        return _idTotalSupply[id];\n    }\n}\n\ncontract BugTest is Test, ERC1155Holder {\n\n    function testImplError() public {\n        HelperERC1155 token = new HelperERC1155();\n\n        for(uint i=0; i<10; i++){\n            token.mint(i, 1+i);\n        }\n\n        for(uint i=0; i<10; i++){\n            token.burn(i, 1+i);\n            assertEq(token.idTotalSupply(i), 0); // OK\n            assertEq(token.allTokensIndex(i), i); // NOT OK (should be 0)\n        }\n        \n        assertEq(token.totalSupply(), 10); // NOT OK (should be 0)\n        assertEq(token.currentIndex(address(this)), 10); // NOT OK (should be 0)\n    }\n\n    function testImplFixed() public {\n        HelperERC1155 token = new HelperERC1155();\n\n        for(uint i=0; i<10; i++){\n            token.mint(i, 1+i);\n        }\n\n        for(uint i=0; i<10; i++){\n            token.burn(i, 1+i);\n            assertEq(token.idTotalSupply(i), 0); // OK\n            assertEq(token.allTokensIndex(i), 0); // OK\n        }\n        \n        assertEq(token.totalSupply(), 0); // OK\n        assertEq(token.currentIndex(address(this)), 0); // OK\n    }\n}\n```\n\nBefore fix `forge test --match-contract BugTest -vvv` outputs:\n\n    Running 2 tests for test/Audit2.t.sol:BugTest\n    [PASS] testImplError() (gas: 2490610)\n    [FAIL. Reason: Assertion failed.] testImplFixed() (gas: 2560628)\n    Test result: FAILED. 1 passed; 1 failed; finished in 2.05ms\n\nAfter fix `forge test --match-contract BugTest -vvv` outputs:\n\n    Running 2 tests for test/Audit2.t.sol:BugTest\n    [FAIL. Reason: Assertion failed.] testImplError() (gas: 2558695)\n    [PASS] testImplFixed() (gas: 2489080)\n    Test result: FAILED. 1 passed; 1 failed; finished in 2.22ms\n\n### Recommended Mitigation Steps\n\nCorrect the implementation to update states correctly. Patch provided below for reference.\n\n```solidity\ndiff --git a/packages/v2-token/src/base/ERC1155Enumerable.sol b/packages/v2-token/src/base/ERC1155Enumerable.sol\nindex 4ec23ff..ef67bca 100644\n--- a/packages/v2-token/src/base/ERC1155Enumerable.sol\n+++ b/packages/v2-token/src/base/ERC1155Enumerable.sol\n@@ -91,8 +91,8 @@ abstract contract ERC1155Enumerable is IERC1155Enumerable, ERC1155 {\n     /// @dev Remove token enumeration list if necessary.\n     function _removeTokenEnumeration(address from, address to, uint256 id, uint256 amount) internal {\n         if (to == address(0)) {\n-            if (_idTotalSupply[id] == 0 && _additionalConditionRemoveTokenFromAllTokensEnumeration(id)) _removeTokenFromAllTokensEnumeration(id);\n             _idTotalSupply[id] -= amount;\n+            if (_idTotalSupply[id] == 0 && _additionalConditionRemoveTokenFromAllTokensEnumeration(id)) _removeTokenFromAllTokensEnumeration(id);\n         }\n\n         if (from != address(0) && from != to) {\n@@ -114,8 +114,7 @@ abstract contract ERC1155Enumerable is IERC1155Enumerable, ERC1155 {\n     /// @param to address representing the new owner of the given token ID\n     /// @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n-        _currentIndex[to] += 1;\n-        uint256 length = _currentIndex[to];\n+        uint256 length = _currentIndex[to]++;\n         _ownedTokens[to][length] = tokenId;\n         _ownedTokensIndex[tokenId] = length;\n     }\n@@ -134,7 +133,7 @@ abstract contract ERC1155Enumerable is IERC1155Enumerable, ERC1155 {\n     /// @param from address representing the previous owner of the given token ID\n     /// @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n-        uint256 lastTokenIndex = _currentIndex[from] - 1;\n+        uint256 lastTokenIndex = --_currentIndex[from];\n         uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n         if (tokenIndex != lastTokenIndex) {\n```\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-01-timeswap-findings/issues/272#issuecomment-1427142843):**\n > There are 2 bugs highlighted here:\n> \n>  - the check is incorrectly made before the state update in `_removeTokenEnumeration`\n>  - the order in which `_currentIndex` is updated\n>\n > So splitting this finding in 2. *(Note: issue title has been updated accordingly. Also, see newly created issue [`#300`](https://github.com/code-423n4/2023-01-timeswap-findings/issues/300).)*\n\n**[vhawk19 (Timeswap) confirmed and commented](https://github.com/code-423n4/2023-01-timeswap-findings/issues/272#issuecomment-1434502259):**\n > Updated the [ERC1155Enumerable.sol](https://github.com/Timeswap-Labs/Timeswap-V2-Monorepo/blob/devel/packages/v2-token/contracts/base/ERC1155Enumerable.sol) implementation, which should resolve these issues. \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-01-timeswap",
  "Code": [
    {
      "filename": "packages/v2-token/src/base/ERC1155Enumerable.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport {ERC1155} from \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n\nimport {IERC1155Enumerable} from \"../interfaces/IERC1155Enumerable.sol\";\n\n/// Extension of {ERC1155} that adds\n/// enumerability of all the token ids in the contract as well as all token ids owned by each\n/// account.\nabstract contract ERC1155Enumerable is IERC1155Enumerable, ERC1155 {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens; // An index of all tokens\n\n    mapping(address => uint256) private _currentIndex; // the current index for an address\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    mapping(uint256 => uint256) private _idTotalSupply;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /// @inheritdoc IERC1155Enumerable\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view override returns (uint256) {\n        return _ownedTokens[owner][index];\n    }\n\n    /// @inheritdoc IERC1155Enumerable\n    function totalSupply() public view override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /// @inheritdoc IERC1155Enumerable\n    function tokenByIndex(uint256 index) external view override returns (uint256) {\n        return _allTokens[index];\n    }\n\n    /// @dev Hook that is called before any token transfer. This includes minting\n    /// and burning.\n    function _beforeTokenTransfer(address, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory) internal virtual override {\n        for (uint256 i; i < ids.length; ) {\n            if (amounts[i] != 0) _addTokenEnumeration(from, to, ids[i], amounts[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Add token enumeration list if necessary.\n    function _addTokenEnumeration(address from, address to, uint256 id, uint256 amount) internal {\n        if (from == address(0)) {\n            if (_idTotalSupply[id] == 0 && _additionalConditionAddTokenToAllTokensEnumeration(id)) _addTokenToAllTokensEnumeration(id);\n            _idTotalSupply[id] += amount;\n        }\n\n        if (to != address(0) && to != from) {\n            if (balanceOf(to, id) == 0 && _additionalConditionAddTokenToOwnerEnumeration(to, id)) _addTokenToOwnerEnumeration(to, id);\n        }\n    }\n\n    /// @dev Any additional condition to add token enumeration when overidden.\n    function _additionalConditionAddTokenToAllTokensEnumeration(uint256) internal virtual returns (bool) {\n        return true;\n    }\n\n    /// @dev Any additional condition to add token enumeration when overidden.\n    function _additionalConditionAddTokenToOwnerEnumeration(address, uint256) internal virtual returns (bool) {\n        return true;\n    }\n\n    /// @dev Hook that is called after any token transfer. This includes minting\n    /// and burning.\n    function _afterTokenTransfer(address, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory) internal virtual override {\n        for (uint256 i; i < ids.length; ) {\n            if (amounts[i] != 0) _removeTokenEnumeration(from, to, ids[i], amounts[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Remove token enumeration list if necessary.\n    function _removeTokenEnumeration(address from, address to, uint256 id, uint256 amount) internal {\n        if (to == address(0)) {\n            if (_idTotalSupply[id] == 0 && _additionalConditionRemoveTokenFromAllTokensEnumeration(id)) _removeTokenFromAllTokensEnumeration(id);\n            _idTotalSupply[id] -= amount;\n        }\n\n        if (from != address(0) && from != to) {\n            if (balanceOf(from, id) == 0 && _additionalConditionRemoveTokenFromOwnerEnumeration(from, id)) _removeTokenFromOwnerEnumeration(from, id);\n        }\n    }\n\n    /// @dev Any additional condition to remove token enumeration when overidden.\n    function _additionalConditionRemoveTokenFromAllTokensEnumeration(uint256) internal virtual returns (bool) {\n        return true;\n    }\n\n    /// @dev Any additional condition to remove token enumeration when overidden.\n    function _additionalConditionRemoveTokenFromOwnerEnumeration(address, uint256) internal virtual returns (bool) {\n        return true;\n    }\n\n    /// @dev Private function to add a token to this extension's ownership-tracking data structures.\n    /// @param to address representing the new owner of the given token ID\n    /// @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _currentIndex[to] += 1;\n        uint256 length = _currentIndex[to];\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /// @dev Private function to add a token to this extension's token tracking data structures.\n    /// @param tokenId uint256 ID of the token to be added to the tokens list\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /// @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n    /// while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n    /// gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n    /// This has O(1) time complexity, but alters the order of the _ownedTokens array.\n    /// @param from address representing the previous owner of the given token ID\n    /// @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        uint256 lastTokenIndex = _currentIndex[from] - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId;\n            _ownedTokensIndex[lastTokenId] = tokenIndex;\n        }\n\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /// @dev Private function to remove a token from this extension's token tracking data structures.\n    /// This has O(1) time complexity, but alters the order of the _allTokens array.\n    /// @param tokenId uint256 ID of the token to be removed from the tokens list\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId;\n        _allTokensIndex[lastTokenId] = tokenIndex;\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}"
    },
    {
      "filename": "packages/v2-token/src/base/ERC1155Enumerable.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport {ERC1155} from \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n\nimport {IERC1155Enumerable} from \"../interfaces/IERC1155Enumerable.sol\";\n\n/// Extension of {ERC1155} that adds\n/// enumerability of all the token ids in the contract as well as all token ids owned by each\n/// account.\nabstract contract ERC1155Enumerable is IERC1155Enumerable, ERC1155 {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens; // An index of all tokens\n\n    mapping(address => uint256) private _currentIndex; // the current index for an address\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    mapping(uint256 => uint256) private _idTotalSupply;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /// @inheritdoc IERC1155Enumerable\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view override returns (uint256) {\n        return _ownedTokens[owner][index];\n    }\n\n    /// @inheritdoc IERC1155Enumerable\n    function totalSupply() public view override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /// @inheritdoc IERC1155Enumerable\n    function tokenByIndex(uint256 index) external view override returns (uint256) {\n        return _allTokens[index];\n    }\n\n    /// @dev Hook that is called before any token transfer. This includes minting\n    /// and burning.\n    function _beforeTokenTransfer(address, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory) internal virtual override {\n        for (uint256 i; i < ids.length; ) {\n            if (amounts[i] != 0) _addTokenEnumeration(from, to, ids[i], amounts[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Add token enumeration list if necessary.\n    function _addTokenEnumeration(address from, address to, uint256 id, uint256 amount) internal {\n        if (from == address(0)) {\n            if (_idTotalSupply[id] == 0 && _additionalConditionAddTokenToAllTokensEnumeration(id)) _addTokenToAllTokensEnumeration(id);\n            _idTotalSupply[id] += amount;\n        }\n\n        if (to != address(0) && to != from) {\n            if (balanceOf(to, id) == 0 && _additionalConditionAddTokenToOwnerEnumeration(to, id)) _addTokenToOwnerEnumeration(to, id);\n        }\n    }\n\n    /// @dev Any additional condition to add token enumeration when overidden.\n    function _additionalConditionAddTokenToAllTokensEnumeration(uint256) internal virtual returns (bool) {\n        return true;\n    }\n\n    /// @dev Any additional condition to add token enumeration when overidden.\n    function _additionalConditionAddTokenToOwnerEnumeration(address, uint256) internal virtual returns (bool) {\n        return true;\n    }\n\n    /// @dev Hook that is called after any token transfer. This includes minting\n    /// and burning.\n    function _afterTokenTransfer(address, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory) internal virtual override {\n        for (uint256 i; i < ids.length; ) {\n            if (amounts[i] != 0) _removeTokenEnumeration(from, to, ids[i], amounts[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Remove token enumeration list if necessary.\n    function _removeTokenEnumeration(address from, address to, uint256 id, uint256 amount) internal {\n        if (to == address(0)) {\n            if (_idTotalSupply[id] == 0 && _additionalConditionRemoveTokenFromAllTokensEnumeration(id)) _removeTokenFromAllTokensEnumeration(id);\n            _idTotalSupply[id] -= amount;\n        }\n\n        if (from != address(0) && from != to) {\n            if (balanceOf(from, id) == 0 && _additionalConditionRemoveTokenFromOwnerEnumeration(from, id)) _removeTokenFromOwnerEnumeration(from, id);\n        }\n    }\n\n    /// @dev Any additional condition to remove token enumeration when overidden.\n    function _additionalConditionRemoveTokenFromAllTokensEnumeration(uint256) internal virtual returns (bool) {\n        return true;\n    }\n\n    /// @dev Any additional condition to remove token enumeration when overidden.\n    function _additionalConditionRemoveTokenFromOwnerEnumeration(address, uint256) internal virtual returns (bool) {\n        return true;\n    }\n\n    /// @dev Private function to add a token to this extension's ownership-tracking data structures.\n    /// @param to address representing the new owner of the given token ID\n    /// @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _currentIndex[to] += 1;\n        uint256 length = _currentIndex[to];\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /// @dev Private function to add a token to this extension's token tracking data structures.\n    /// @param tokenId uint256 ID of the token to be added to the tokens list\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /// @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n    /// while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n    /// gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n    /// This has O(1) time complexity, but alters the order of the _ownedTokens array.\n    /// @param from address representing the previous owner of the given token ID\n    /// @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        uint256 lastTokenIndex = _currentIndex[from] - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId;\n            _ownedTokensIndex[lastTokenId] = tokenIndex;\n        }\n\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /// @dev Private function to remove a token from this extension's token tracking data structures.\n    /// This has O(1) time complexity, but alters the order of the _allTokens array.\n    /// @param tokenId uint256 ID of the token to be removed from the tokens list\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId;\n        _allTokensIndex[lastTokenId] = tokenIndex;\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}"
    },
    {
      "filename": "packages/v2-token/src/base/ERC1155Enumerable.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport {ERC1155} from \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n\nimport {IERC1155Enumerable} from \"../interfaces/IERC1155Enumerable.sol\";\n\n/// Extension of {ERC1155} that adds\n/// enumerability of all the token ids in the contract as well as all token ids owned by each\n/// account.\nabstract contract ERC1155Enumerable is IERC1155Enumerable, ERC1155 {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens; // An index of all tokens\n\n    mapping(address => uint256) private _currentIndex; // the current index for an address\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    mapping(uint256 => uint256) private _idTotalSupply;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /// @inheritdoc IERC1155Enumerable\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view override returns (uint256) {\n        return _ownedTokens[owner][index];\n    }\n\n    /// @inheritdoc IERC1155Enumerable\n    function totalSupply() public view override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /// @inheritdoc IERC1155Enumerable\n    function tokenByIndex(uint256 index) external view override returns (uint256) {\n        return _allTokens[index];\n    }\n\n    /// @dev Hook that is called before any token transfer. This includes minting\n    /// and burning.\n    function _beforeTokenTransfer(address, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory) internal virtual override {\n        for (uint256 i; i < ids.length; ) {\n            if (amounts[i] != 0) _addTokenEnumeration(from, to, ids[i], amounts[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Add token enumeration list if necessary.\n    function _addTokenEnumeration(address from, address to, uint256 id, uint256 amount) internal {\n        if (from == address(0)) {\n            if (_idTotalSupply[id] == 0 && _additionalConditionAddTokenToAllTokensEnumeration(id)) _addTokenToAllTokensEnumeration(id);\n            _idTotalSupply[id] += amount;\n        }\n\n        if (to != address(0) && to != from) {\n            if (balanceOf(to, id) == 0 && _additionalConditionAddTokenToOwnerEnumeration(to, id)) _addTokenToOwnerEnumeration(to, id);\n        }\n    }\n\n    /// @dev Any additional condition to add token enumeration when overidden.\n    function _additionalConditionAddTokenToAllTokensEnumeration(uint256) internal virtual returns (bool) {\n        return true;\n    }\n\n    /// @dev Any additional condition to add token enumeration when overidden.\n    function _additionalConditionAddTokenToOwnerEnumeration(address, uint256) internal virtual returns (bool) {\n        return true;\n    }\n\n    /// @dev Hook that is called after any token transfer. This includes minting\n    /// and burning.\n    function _afterTokenTransfer(address, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory) internal virtual override {\n        for (uint256 i; i < ids.length; ) {\n            if (amounts[i] != 0) _removeTokenEnumeration(from, to, ids[i], amounts[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Remove token enumeration list if necessary.\n    function _removeTokenEnumeration(address from, address to, uint256 id, uint256 amount) internal {\n        if (to == address(0)) {\n            if (_idTotalSupply[id] == 0 && _additionalConditionRemoveTokenFromAllTokensEnumeration(id)) _removeTokenFromAllTokensEnumeration(id);\n            _idTotalSupply[id] -= amount;\n        }\n\n        if (from != address(0) && from != to) {\n            if (balanceOf(from, id) == 0 && _additionalConditionRemoveTokenFromOwnerEnumeration(from, id)) _removeTokenFromOwnerEnumeration(from, id);\n        }\n    }\n\n    /// @dev Any additional condition to remove token enumeration when overidden.\n    function _additionalConditionRemoveTokenFromAllTokensEnumeration(uint256) internal virtual returns (bool) {\n        return true;\n    }\n\n    /// @dev Any additional condition to remove token enumeration when overidden.\n    function _additionalConditionRemoveTokenFromOwnerEnumeration(address, uint256) internal virtual returns (bool) {\n        return true;\n    }\n\n    /// @dev Private function to add a token to this extension's ownership-tracking data structures.\n    /// @param to address representing the new owner of the given token ID\n    /// @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _currentIndex[to] += 1;\n        uint256 length = _currentIndex[to];\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /// @dev Private function to add a token to this extension's token tracking data structures.\n    /// @param tokenId uint256 ID of the token to be added to the tokens list\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /// @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n    /// while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n    /// gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n    /// This has O(1) time complexity, but alters the order of the _ownedTokens array.\n    /// @param from address representing the previous owner of the given token ID\n    /// @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        uint256 lastTokenIndex = _currentIndex[from] - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId;\n            _ownedTokensIndex[lastTokenId] = tokenIndex;\n        }\n\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /// @dev Private function to remove a token from this extension's token tracking data structures.\n    /// This has O(1) time complexity, but alters the order of the _allTokens array.\n    /// @param tokenId uint256 ID of the token to be removed from the tokens list\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId;\n        _allTokensIndex[lastTokenId] = tokenIndex;\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}"
    }
  ]
}