{
  "Title": "[G-15] Use a hardcoded address instead of `address(this)`",
  "Content": "\nIt can be more gas-efficient to use a hardcoded address instead of the `address(this)` expression, especially if you need to use the same address multiple times in your contract.\n\nThe reason for this is that using `address(this)` requires an additional `EXTCODESIZE` operation to retrieve the contract's address from its bytecode, which can increase the gas cost of your contract. By pre-calculating and using a hardcoded address, you can avoid this additional operation and reduce the overall gas cost of your contract.\n\nHere's an example of how you can use a hardcoded address instead of `address(this)`:\n\n```\ncontract MyContract {\n    address public myAddress = 0x1234567890123456789012345678901234567890;\n    \n    function doSomething() public {\n        // Use myAddress instead of address(this)\n        require(msg.sender == myAddress, \"Caller is not authorized\");\n        \n        // Do something\n    }\n}\n```\nIn the above example, we have a contract, `MyContract`, with a public address variable `myAddress`. Instead of using `address(this)` to retrieve the contract's address, we have pre-calculated and hardcoded the address in the variable. This can help to reduce the gas cost of our contract and make our code more efficient.\n\n[Reference](https://book.getfoundry.sh/reference/forge-std/compute-create-address)\n\n```solidity\nFile: /ERC725/blob/v5.1.0/implementations/contracts/ERC725XCore.sol\n179   if (address(this).balance < value) {\n\n180   revert ERC725X_InsufficientBalance(address(this).balance, value);\n\n251   if (address(this).balance < value) {\n\n252   revert ERC725X_InsufficientBalance(address(this).balance, value);    \n```\nhttps://github.com/ERC725Alliance/ERC725/blob/v5.1.0/implementations/contracts/ERC725XCore.sol#L179\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-06-lukso",
  "Code": [
    {
      "filename": "implementations/contracts/ERC725XCore.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n// interfaces\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {IERC725X} from \"./interfaces/IERC725X.sol\";\n\n// libraries\nimport {Create2} from \"@openzeppelin/contracts/utils/Create2.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\n// modules\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {OwnableUnset} from \"./custom/OwnableUnset.sol\";\n\n// constants\nimport {\n    _INTERFACEID_ERC725X,\n    OPERATION_0_CALL,\n    OPERATION_1_CREATE,\n    OPERATION_2_CREATE2,\n    OPERATION_3_STATICCALL,\n    OPERATION_4_DELEGATECALL\n} from \"./constants.sol\";\n\nimport \"./errors.sol\";\n\n/**\n * @title Core implementation of ERC725X executor\n * @author Fabian Vogelsteller <fabian@lukso.network>\n * @dev Implementation of a contract module which provides the ability to call arbitrary functions at any other smart contract and itself,\n * including using `delegatecall`, `staticcall` as well creating contracts using `create` and `create2`\n * This is the basis for a smart contract based account system, but could also be used as a proxy account system\n */\nabstract contract ERC725XCore is OwnableUnset, ERC165, IERC725X {\n    /**\n     * @inheritdoc IERC725X\n     */\n    function execute(\n        uint256 operationType,\n        address target,\n        uint256 value,\n        bytes memory data\n    ) public payable virtual override onlyOwner returns (bytes memory) {\n        return _execute(operationType, target, value, data);\n    }\n\n    /**\n     * @inheritdoc IERC725X\n     */\n    function executeBatch(\n        uint256[] memory operationsType,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory datas\n    ) public payable virtual override onlyOwner returns (bytes[] memory) {\n        return _executeBatch(operationsType, targets, values, datas);\n    }\n\n    /**\n     * @inheritdoc ERC165\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(IERC165, ERC165) returns (bool) {\n        return interfaceId == _INTERFACEID_ERC725X || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev check the `operationType` provided and perform the associated low-level opcode.\n     * see `IERC725X.execute(uint256,address,uint256,bytes)`.\n     */\n    function _execute(\n        uint256 operationType,\n        address target,\n        uint256 value,\n        bytes memory data\n    ) internal virtual returns (bytes memory) {\n        // CALL\n        if (operationType == OPERATION_0_CALL) {\n            return _executeCall(target, value, data);\n        }\n\n        // Deploy with CREATE\n        if (operationType == OPERATION_1_CREATE) {\n            if (target != address(0)) revert ERC725X_CreateOperationsRequireEmptyRecipientAddress();\n            return _deployCreate(value, data);\n        }\n\n        // Deploy with CREATE2\n        if (operationType == OPERATION_2_CREATE2) {\n            if (target != address(0)) revert ERC725X_CreateOperationsRequireEmptyRecipientAddress();\n            return _deployCreate2(value, data);\n        }\n\n        // STATICCALL\n        if (operationType == OPERATION_3_STATICCALL) {\n            if (value != 0) revert ERC725X_MsgValueDisallowedInStaticCall();\n            return _executeStaticCall(target, data);\n        }\n\n        // DELEGATECALL\n        //\n        // WARNING! delegatecall is a dangerous operation type! use with EXTRA CAUTION\n        //\n        // delegate allows to call another deployed contract and use its functions\n        // to update the state of the current calling contract.\n        //\n        // this can lead to unexpected behaviour on the contract storage, such as:\n        // - updating any state variables (even if these are protected)\n        // - update the contract owner\n        // - run selfdestruct in the context of this contract\n        //\n        if (operationType == OPERATION_4_DELEGATECALL) {\n            if (value != 0) revert ERC725X_MsgValueDisallowedInDelegateCall();\n            return _executeDelegateCall(target, data);\n        }\n\n        revert ERC725X_UnknownOperationType(operationType);\n    }\n\n    /**\n     * @dev same as `_execute` but for batch execution\n     * see `IERC725X,execute(uint256[],address[],uint256[],bytes[])`\n     */\n    function _executeBatch(\n        uint256[] memory operationsType,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory datas\n    ) internal virtual returns (bytes[] memory) {\n        if (\n            operationsType.length != targets.length ||\n            (targets.length != values.length || values.length != datas.length)\n        ) {\n            revert ERC725X_ExecuteParametersLengthMismatch();\n        }\n\n        if (operationsType.length == 0) {\n            revert ERC725X_ExecuteParametersEmptyArray();\n        }\n\n        bytes[] memory result = new bytes[](operationsType.length);\n\n        for (uint256 i = 0; i < operationsType.length; ) {\n            result[i] = _execute(operationsType[i], targets[i], values[i], datas[i]);\n\n            // Increment the iterator in unchecked block to save gas\n            unchecked {\n                ++i;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev perform low-level call (operation type = 0)\n     * @param target The address on which call is executed\n     * @param value The value to be sent with the call\n     * @param data The data to be sent with the call\n     * @return result The data from the call\n     */\n    function _executeCall(\n        address target,\n        uint256 value,\n        bytes memory data\n    ) internal virtual returns (bytes memory result) {\n        if (address(this).balance < value) {\n            revert ERC725X_InsufficientBalance(address(this).balance, value);\n        }\n\n        emit Executed(OPERATION_0_CALL, target, value, bytes4(data));\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = target.call{value: value}(data);\n        result = Address.verifyCallResult(success, returnData, \"ERC725X: Unknown Error\");\n    }\n\n    /**\n     * @dev perform low-level staticcall (operation type = 3)\n     * @param target The address on which staticcall is executed\n     * @param data The data to be sent with the staticcall\n     * @return result The data returned from the staticcall\n     */\n    function _executeStaticCall(\n        address target,\n        bytes memory data\n    ) internal virtual returns (bytes memory result) {\n        emit Executed(OPERATION_3_STATICCALL, target, 0, bytes4(data));\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = target.staticcall(data);\n        result = Address.verifyCallResult(success, returnData, \"ERC725X: Unknown Error\");\n    }\n\n    /**\n     * @dev perform low-level delegatecall (operation type = 4)\n     * @param target The address on which delegatecall is executed\n     * @param data The data to be sent with the delegatecall\n     * @return result The data returned from the delegatecall\n     */\n    function _executeDelegateCall(\n        address target,\n        bytes memory data\n    ) internal virtual returns (bytes memory result) {\n        emit Executed(OPERATION_4_DELEGATECALL, target, 0, bytes4(data));\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = target.delegatecall(data);\n        result = Address.verifyCallResult(success, returnData, \"ERC725X: Unknown Error\");\n    }\n\n    /**\n     * @dev deploy a contract using the CREATE opcode (operation type = 1)\n     * @param value The value to be sent to the contract created\n     * @param creationCode The contract creation bytecode to deploy appended with the constructor argument(s)\n     * @return newContract The address of the contract created as bytes\n     */\n    function _deployCreate(\n        uint256 value,\n        bytes memory creationCode\n    ) internal virtual returns (bytes memory newContract) {\n        if (address(this).balance < value) {\n            revert ERC725X_InsufficientBalance(address(this).balance, value);\n        }\n\n        if (creationCode.length == 0) {\n            revert ERC725X_NoContractBytecodeProvided();\n        }\n\n        address contractAddress;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            contractAddress := create(value, add(creationCode, 0x20), mload(creationCode))\n        }\n\n        if (contractAddress == address(0)) {\n            revert ERC725X_ContractDeploymentFailed();\n        }\n\n        newContract = abi.encodePacked(contractAddress);\n        emit ContractCreated(OPERATION_1_CREATE, contractAddress, value, bytes32(0));\n    }\n\n    /**\n     * @dev deploy a contract using the CREATE2 opcode (operation type = 2)\n     * @param value The value to be sent to the contract created\n     * @param creationCode The contract creation bytecode to deploy appended with the constructor argument(s) and a bytes32 salt\n     * @return newContract The address of the contract created as bytes\n     */\n    function _deployCreate2(\n        uint256 value,\n        bytes memory creationCode\n    ) internal virtual returns (bytes memory newContract) {\n        if (creationCode.length == 0) {\n            revert ERC725X_NoContractBytecodeProvided();\n        }\n\n        bytes32 salt = BytesLib.toBytes32(creationCode, creationCode.length - 32);\n        bytes memory bytecode = BytesLib.slice(creationCode, 0, creationCode.length - 32);\n        address contractAddress = Create2.deploy(value, salt, bytecode);\n\n        newContract = abi.encodePacked(contractAddress);\n        emit ContractCreated(OPERATION_2_CREATE2, contractAddress, value, salt);\n    }\n}"
    }
  ]
}