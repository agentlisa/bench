{
  "Title": "H-3: Staker can perform rewards withdrawal every overdueBlocks less 1 and have zero frozenCoinAge",
  "Content": "# Issue H-3: Staker can perform rewards withdrawal every overdueBlocks less 1 and have zero frozenCoinAge \n\nSource: https://github.com/sherlock-audit/2023-02-union-judging/issues/25 \n\n## Found by \nhyh\n\n## Summary\n\nTime difference accounted for in _getEffectiveAmounts() that is used for rewards computation is based on the lesser amount of time passed since last reward withdrawal and borrower's last repay. In order to maximize the rewards a staker can withdraw rewards every `uToken.overdueBlocks() - 1`, so that difference is always be less than overdue threshold and none of staker's loans be deemed overdue no matter how long ago their last payments were.\n\n## Vulnerability Detail\n\nEffective amounts are counted to determine the reward multiplier and amount, and the frozen part of these amounts corresponds to the bad debt. However, the time period check for the inclusion of a borrower to the `frozenCoinAge` is performed as `overdueBlocks < repayDiff`, where `repayDiff = block.number - _max(lastRepay, coinAge.lastWithdrawRewards)`, and `lastWithdrawRewards = getLastWithdrawRewards[stakerAddress]` is staker controlled.\n\nSo this `repayDiff` can be always kept below `overdueBlocks` via calling rewards gathering frequent enough, once per `overdueBlocks - 1` or sooner.\n\nAlso notice that _getCoinAge() returned `coinAge.lockedCoinAge` is updated on overdue debt repayment only and is zero when no such repayments were made.\n\nAs an example, a staker can lend to themselves, pay no interest, call withdrawRewards() once per `overdueBlocks - 1`, gathering full rewards without any penalty. Or just observing bad debt start to do it in order to remove its impact on rewards.\n\nIn any case this provides a way to remove `frozenCoinAge` based bad debt penalty altogether.\n\n## Impact\n\nExcess UNION rewards emissions dilute holdings of the honest members who do not time their withdrawRewards() calls to the points of reward multiplier maximization.\n\nThis is monetary loss for all UNION holders (as total emission is increased), and particularly for the stakers who actually use the system (as specifically new emission is increased), i.e. in result the attacker steals from all holders/stakers by inflating UNION emission.\n\nSetting severity to be high as there are no specific preconditions for the attack, it can be carried out by any UNION staker.\n\n## Code Snippet\n\n_getEffectiveAmounts() accumulates `frozenCoinAge` only when `uToken.overdueBlocks() = overdueBlocks < repayDiff = block.number - _max(lastRepay, coinAge.lastWithdrawRewards)`, treating it as zero for that voucher otherwise:\n\nhttps://github.com/sherlock-audit/2023-02-union/blob/main/union-v2-contracts/contracts/user/UserManager.sol#L892-L938\n\n```solidity\n    function _getEffectiveAmounts(address stakerAddress, uint256 pastBlocks)\n    ...\n    {\n        uint256 memberTotalFrozen = 0;\n        CoinAge memory coinAge = _getCoinAge(stakerAddress);\n\n        uint256 overdueBlocks = uToken.overdueBlocks();\n        uint256 voucheesLength = vouchees[stakerAddress].length;\n        // Loop through all of the stakers vouchees sum their total\n        // locked balance and sum their total currDefaultFrozenCoinAge\n        for (uint256 i = 0; i < voucheesLength; i++) {\n            // Get the vouchee record and look up the borrowers voucher record\n            // to get the locked amount and lastUpdated block number\n            Vouchee memory vouchee = vouchees[stakerAddress][i];\n            Vouch memory vouch = vouchers[vouchee.borrower][vouchee.voucherIndex];\n\n            uint256 lastRepay = uToken.getLastRepay(vouchee.borrower);\n            uint256 repayDiff = block.number - _max(lastRepay, coinAge.lastWithdrawRewards);\n            uint256 locked = uint256(vouch.locked);\n\n            if (overdueBlocks < repayDiff && (coinAge.lastWithdrawRewards != 0 || lastRepay != 0)) {\n                memberTotalFrozen += locked;\n                if (pastBlocks >= repayDiff) {\n                    coinAge.frozenCoinAge += (locked * repayDiff);\n                } else {\n                    coinAge.frozenCoinAge += (locked * pastBlocks);\n                }\n            }\n\n            uint256 lastUpdateBlock = _max(coinAge.lastWithdrawRewards, uint256(vouch.lastUpdated));\n            coinAge.lockedCoinAge += (block.number - lastUpdateBlock) * locked;\n        }\n\n        return (\n            // staker's total effective staked = (staked coinage - frozen coinage) / (# of blocks since last reward claiming)\n            coinAge.diff == 0 ? 0 : (coinAge.stakedCoinAge - coinAge.frozenCoinAge) / coinAge.diff,\n            // effective locked amount = (locked coinage - frozen coinage) / (# of blocks since last reward claiming)\n            coinAge.diff == 0 ? 0 : (coinAge.lockedCoinAge - coinAge.frozenCoinAge) / coinAge.diff,\n            memberTotalFrozen\n        );\n    }\n```\n\n_getCoinAge() returns `getLastWithdrawRewards[stakerAddress]` as `lastWithdrawRewards`, i.e. that's staker controlled, and `block.number - _max(lastWithdrawRewards, uint256(staker.lastUpdated))` as `diff`, `frozenCoinAge[stakerAddress]` as `frozenCoinAge`, which serves as a base for frozen accumulator:\n\nhttps://github.com/sherlock-audit/2023-02-union/blob/main/union-v2-contracts/contracts/user/UserManager.sol#L1072-L1087\n\n```solidity\n    function _getCoinAge(address stakerAddress) private view returns (CoinAge memory) {\n        Staker memory staker = stakers[stakerAddress];\n\n        uint256 lastWithdrawRewards = getLastWithdrawRewards[stakerAddress];\n        uint256 diff = block.number - _max(lastWithdrawRewards, uint256(staker.lastUpdated));\n\n        CoinAge memory coinAge = CoinAge({\n            lastWithdrawRewards: lastWithdrawRewards,\n            diff: diff,\n            stakedCoinAge: staker.stakedCoinAge + diff * uint256(staker.stakedAmount),\n            lockedCoinAge: staker.lockedCoinAge,\n            frozenCoinAge: frozenCoinAge[stakerAddress]\n        });\n\n        return coinAge;\n    }\n```\n\nWhile across the protocol `frozenCoinAge[stakerAddress]` is accumulated only on onRepayBorrow():\n\nhttps://github.com/sherlock-audit/2023-02-union/blob/main/union-v2-contracts/contracts/user/UserManager.sol#L995-L1015\n\n```solidity\n    /**\n     * @dev Update the frozen info by the utoken repay\n     * @param borrower Borrower address\n     */\n    function onRepayBorrow(address borrower) external {\n        if (address(uToken) != msg.sender) revert AuthFailed();\n\n        uint256 overdueBlocks = uToken.overdueBlocks();\n\n        uint256 vouchersLength = vouchers[borrower].length;\n        uint256 lastRepay = 0;\n        uint256 diff = 0;\n        for (uint256 i = 0; i < vouchersLength; i++) {\n            Vouch memory vouch = vouchers[borrower][i];\n            lastRepay = uToken.getLastRepay(borrower);\n            diff = block.number - lastRepay;\n            if (overdueBlocks < diff) {\n                frozenCoinAge[vouch.staker] += uint256(vouch.locked) * diff;\n            }\n        }\n    }\n```\n\nonRepayBorrow() is called only by _repayBorrowFresh() and only when the debt is overdue: \n\nhttps://github.com/sherlock-audit/2023-02-union/blob/main/union-v2-contracts/contracts/market/UToken.sol#L601-L638\n\n```solidity\n    function _repayBorrowFresh(address payer, address borrower, uint256 amount, uint256 interest) internal {\n        ...\n\n        if (repayAmount >= interest) {\n            ...\n\n            if (isOverdue) {\n                // For borrowers that are paying back overdue balances we need to update their\n                // frozen balance and the global total frozen balance on the UserManager\n                IUserManager(userManager).onRepayBorrow(borrower);\n            }\n```\n\nhttps://github.com/sherlock-audit/2023-02-union/blob/main/union-v2-contracts/contracts/market/UToken.sol#L389-L395\n\n```solidity\n    function checkIsOverdue(address account) public view override returns (bool isOverdue) {\n        if (getBorrowed(account) != 0) {\n            uint256 lastRepay = getLastRepay(account);\n            uint256 diff = getBlockNumber() - lastRepay;\n            isOverdue = overdueBlocks < diff;\n        }\n    }\n```\n\nI.e. if a staker's borrowers didn't repaid at all, or repaid without overdue for some period and then became bad debt, making no repayments after some date, then `frozenCoinAge[stakerAddress]` is zero as no overdue repayments were ever made.\n\nFurthermore, staker can call withdrawRewards() to update `getLastWithdrawRewards[stakerAddress]` and keep `diff = block.number - _max(lastWithdrawRewards, uint256(staker.lastUpdated))` below current `uToken.overdueBlocks()`, keeping their frozen counter zero.\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAs an example approach, consider introducing lifetime effective staked, locked and frozen accumulators, i.e. do not resetting them on each rewards claim, and using the difference vs the last claim point instead.\n\nThis way total staked, locked, frozen counters will be kept since staker inception, but only the last yet unrewarded period will be used to calculate each next portion of the rewards.\n\nManipulation surface described will not be viable as withdrawRewards() will only determine the reward period and will not be resetting the whole reward accounting.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/44",
  "Code": [
    {
      "filename": "union-v2-contracts/contracts/user/UserManager.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\n\nimport {Controller} from \"../Controller.sol\";\nimport {IAssetManager} from \"../interfaces/IAssetManager.sol\";\nimport {IUserManager} from \"../interfaces/IUserManager.sol\";\nimport {IComptroller} from \"../interfaces/IComptroller.sol\";\nimport {IUnionToken} from \"../interfaces/IUnionToken.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\n\n/**\n * @title UserManager Contract\n * @dev Manages the Union members stake and vouches.\n */\ncontract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeCastUpgradeable for uint256;\n    using SafeCastUpgradeable for uint128;\n\n    /* -------------------------------------------------------------------\n      Storage Types \n    ------------------------------------------------------------------- */\n\n    struct Vouch {\n        // staker recieveing the vouch\n        address staker;\n        // trust amount\n        uint96 trust;\n        // amount of stake locked by this vouch\n        uint96 locked;\n        // block number of last update\n        uint64 lastUpdated;\n    }\n\n    struct Staker {\n        bool isMember;\n        uint96 stakedAmount;\n        uint96 locked;\n        // block number of last stakedAmount update\n        uint64 lastUpdated;\n        uint256 stakedCoinAge;\n        uint256 lockedCoinAge;\n    }\n\n    struct Index {\n        bool isSet;\n        uint128 idx;\n    }\n\n    struct Vouchee {\n        address borrower;\n        uint96 voucherIndex;\n    }\n\n    /* -------------------------------------------------------------------\n      Memory Types \n    ------------------------------------------------------------------- */\n\n    struct CoinAge {\n        uint256 stakedCoinAge;\n        uint256 lockedCoinAge;\n        uint256 frozenCoinAge;\n        uint256 lastWithdrawRewards;\n        uint256 diff;\n    }\n\n    /* -------------------------------------------------------------------\n      Storage \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Max amount that can be staked of the staking token\n     */\n    uint96 public maxStakeAmount;\n\n    /**\n     *  @dev The staking token that is staked in the comptroller\n     */\n    address public stakingToken;\n\n    /**\n     *  @dev Address of the UNION token contract\n     */\n    address public unionToken;\n\n    /**\n     *  @dev Address of the asset manager contract\n     */\n    address public assetManager;\n\n    /**\n     *  @dev uToken contract\n     */\n    IUToken public uToken;\n\n    /**\n     *  @dev Comptroller contract\n     */\n    IComptroller public comptroller;\n\n    /**\n     * @dev Number of vouches needed to become a member\n     */\n    uint256 public effectiveCount;\n\n    /**\n     *  @dev New member fee\n     */\n    uint256 public newMemberFee;\n\n    /**\n     *  @dev Total amount of staked staked token\n     */\n    uint256 public totalStaked;\n\n    /**\n     *  @dev Total amount of stake frozen\n     */\n    uint256 public totalFrozen;\n\n    /**\n     *  @dev Max blocks can be overdue for\n     */\n    uint256 public maxOverdueBlocks;\n\n    /**\n     * @dev Max voucher limit\n     */\n    uint256 public maxVouchers;\n\n    /**\n     * @dev Max vouchees limit\n     */\n    uint256 public maxVouchees;\n\n    /**\n     *  @dev Union Stakers\n     */\n    mapping(address => Staker) public stakers;\n\n    /**\n     *  @dev Borrower (borrower) mapped to received vouches (staker)\n     */\n    mapping(address => Vouch[]) public vouchers;\n\n    /**\n     * @dev Borrower mapped to Staker mapped to index in vouchers array\n     */\n    mapping(address => mapping(address => Index)) public voucherIndexes;\n\n    /**\n     *  @dev Staker (staker) mapped to vouches given (borrower)\n     */\n    mapping(address => Vouchee[]) public vouchees;\n\n    /**\n     * @dev Borrower mapped to Staker mapped to index in vochee array\n     */\n    mapping(address => mapping(address => Index)) public voucheeIndexes;\n\n    /**\n     * @dev Stakers frozen amounts\n     */\n    mapping(address => uint256) public memberFrozen;\n\n    /**\n     * @dev Stakers mapped to frozen coin age\n     */\n    mapping(address => uint256) public frozenCoinAge;\n\n    /**\n     * @dev Staker mapped to last time they withdrew rewards\n     */\n    mapping(address => uint256) public getLastWithdrawRewards;\n\n    /* -------------------------------------------------------------------\n      Errors \n    ------------------------------------------------------------------- */\n\n    error AuthFailed();\n    error ErrorSelfVouching();\n    error TrustAmountLtLocked();\n    error NoExistingMember();\n    error NotEnoughStakers();\n    error StakeLimitReached();\n    error AssetManagerDepositFailed();\n    error AssetManagerWithdrawFailed();\n    error InsufficientBalance();\n    error LockedStakeNonZero();\n    error NotOverdue();\n    error ExceedsLocked();\n    error AmountZero();\n    error LockedRemaining();\n    error VoucherNotFound();\n    error VouchWhenOverdue();\n    error MaxVouchers();\n    error MaxVouchees();\n    error InvalidParams();\n\n    /* -------------------------------------------------------------------\n      Events \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Add new member event\n     *  @param member New member address\n     */\n    event LogAddMember(address member);\n\n    /**\n     *  @dev Update vouch for existing member event\n     *  @param staker Trustee address\n     *  @param borrower The address gets vouched for\n     *  @param trustAmount Vouch amount\n     */\n    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);\n\n    /**\n     *  @dev New member application event\n     *  @param account New member's voucher address\n     *  @param borrower New member address\n     */\n    event LogRegisterMember(address indexed account, address indexed borrower);\n\n    /**\n     *  @dev Cancel vouching for other member event\n     *  @param account New member's voucher address\n     *  @param borrower The address gets vouched for\n     */\n    event LogCancelVouch(address indexed account, address indexed borrower);\n\n    /**\n     *  @dev Stake event\n     *  @param account The staker's address\n     *  @param amount The amount of tokens to stake\n     */\n    event LogStake(address indexed account, uint256 amount);\n\n    /**\n     *  @dev Unstake event\n     *  @param account The staker's address\n     *  @param amount The amount of tokens to unstake\n     */\n    event LogUnstake(address indexed account, uint256 amount);\n\n    /**\n     *  @dev DebtWriteOff event\n     *  @param staker The staker's address\n     *  @param borrower The borrower's address\n     *  @param amount The amount of write off\n     */\n    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);\n\n    /**\n     *  @dev set utoken address\n     *  @param uToken new uToken address\n     */\n    event LogSetUToken(address uToken);\n\n    /**\n     *  @dev set new member fee\n     *  @param oldMemberFee old member fee\n     *  @param newMemberFee new member fee\n     */\n    event LogSetNewMemberFee(uint256 oldMemberFee, uint256 newMemberFee);\n\n    /**\n     *  @dev set max stake amount\n     *  @param oldMaxStakeAmount Old amount\n     *  @param newMaxStakeAmount New amount\n     */\n    event LogSetMaxStakeAmount(uint256 oldMaxStakeAmount, uint256 newMaxStakeAmount);\n\n    /**\n     *  @dev set max overdue blocks\n     *  @param oldMaxOverdueBlocks Old value\n     *  @param newMaxOverdueBlocks New value\n     */\n    event LogSetMaxOverdueBlocks(uint256 oldMaxOverdueBlocks, uint256 newMaxOverdueBlocks);\n\n    /**\n     *  @dev set effective count\n     *  @param oldEffectiveCount Old value\n     *  @param newEffectiveCount New value\n     */\n    event LogSetEffectiveCount(uint256 oldEffectiveCount, uint256 newEffectiveCount);\n\n    /**\n     * @dev Set max voucher\n     * @param maxVouchers new max voucher limit\n     */\n    event LogSetMaxVouchers(uint256 maxVouchers);\n\n    /**\n     * @dev Set max vouchees\n     * @param maxVouchees new max voucher limit\n     */\n    event LogSetMaxVouchees(uint256 maxVouchees);\n\n    /* -------------------------------------------------------------------\n      Constructor/Initializer \n    ------------------------------------------------------------------- */\n\n    function __UserManager_init(\n        address assetManager_,\n        address unionToken_,\n        address stakingToken_,\n        address comptroller_,\n        address admin_,\n        uint256 maxOverdueBlocks_,\n        uint256 effectiveCount_,\n        uint256 maxVouchers_,\n        uint256 maxVouchees_\n    ) public initializer {\n        Controller.__Controller_init(admin_);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        comptroller = IComptroller(comptroller_);\n        assetManager = assetManager_;\n        unionToken = unionToken_;\n        stakingToken = stakingToken_;\n        newMemberFee = 1 ether;\n        maxStakeAmount = 10_000e18;\n        maxOverdueBlocks = maxOverdueBlocks_;\n        effectiveCount = effectiveCount_;\n        maxVouchers = maxVouchers_;\n        maxVouchees = maxVouchees_;\n    }\n\n    /* -------------------------------------------------------------------\n      Modifiers \n    ------------------------------------------------------------------- */\n\n    modifier onlyMember(address account) {\n        if (!checkIsMember(account)) revert AuthFailed();\n        _;\n    }\n\n    modifier onlyMarket() {\n        if (address(uToken) != msg.sender) revert AuthFailed();\n        _;\n    }\n\n    /* -------------------------------------------------------------------\n      Setters \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Set the max amount that a user can stake\n     * Emits {LogSetMaxStakeAmount} event\n     * @param maxStakeAmount_ The max stake amount\n     */\n    function setMaxStakeAmount(uint96 maxStakeAmount_) external onlyAdmin {\n        uint96 oldMaxStakeAmount = maxStakeAmount;\n        maxStakeAmount = maxStakeAmount_;\n        emit LogSetMaxStakeAmount(uint256(oldMaxStakeAmount), uint256(maxStakeAmount));\n    }\n\n    /**\n     * @dev set the UToken contract address\n     * Emits {LogSetUToken} event\n     * @param uToken_ UToken contract address\n     */\n    function setUToken(address uToken_) external onlyAdmin {\n        uToken = IUToken(uToken_);\n        emit LogSetUToken(uToken_);\n    }\n\n    /**\n     * @dev set New Member fee\n     * @dev The amount of UNION an account must burn to become a member\n     * Emits {LogSetNewMemberFee} event\n     * @param amount New member fee amount\n     */\n    function setNewMemberFee(uint256 amount) external onlyAdmin {\n        uint256 oldMemberFee = newMemberFee;\n        newMemberFee = amount;\n        emit LogSetNewMemberFee(oldMemberFee, amount);\n    }\n\n    /**\n     * @dev set New max overdue blocks\n     * Emits {LogSetMaxOverdueBlocks} event\n     * @param _maxOverdueBlocks New maxOverdueBlocks value\n     */\n    function setMaxOverdueBlocks(uint256 _maxOverdueBlocks) external onlyAdmin {\n        uint256 oldMaxOverdueBlocks = maxOverdueBlocks;\n        maxOverdueBlocks = _maxOverdueBlocks;\n        emit LogSetMaxOverdueBlocks(oldMaxOverdueBlocks, _maxOverdueBlocks);\n    }\n\n    /**\n     * @dev set New effective count\n     * @dev this is the number of vouches an account needs in order\n     *      to register as a member\n     * Emits {LogSetEffectiveCount} event\n     * @param _effectiveCount New effectiveCount value\n     */\n    function setEffectiveCount(uint256 _effectiveCount) external onlyAdmin {\n        uint256 oldEffectiveCount = effectiveCount;\n        effectiveCount = _effectiveCount;\n        emit LogSetEffectiveCount(oldEffectiveCount, _effectiveCount);\n    }\n\n    function setMaxVouchers(uint256 _maxVouchers) external onlyAdmin {\n        maxVouchers = _maxVouchers;\n        emit LogSetMaxVouchers(_maxVouchers);\n    }\n\n    function setMaxVouchees(uint256 _maxVouchees) external onlyAdmin {\n        maxVouchees = _maxVouchees;\n        emit LogSetMaxVouchees(_maxVouchees);\n    }\n\n    /* -------------------------------------------------------------------\n      View Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Check if the account is a valid member\n     *  @param account Member address\n     *  @return Address whether is member\n     */\n    function checkIsMember(address account) public view returns (bool) {\n        return stakers[account].isMember;\n    }\n\n    /**\n     *  @dev  Get the member's available credit limit\n     *  @dev  IMPORTANT: This function can take up a tonne of gas as the vouchers[address] array\n     *        grows in size. the maxVoucher limit will ensure this function can always run within a\n     *        single block but it is intended only to be used as a view function called from a UI\n     *  @param borrower Member address\n     *  @return total Credit line amount\n     */\n    function getCreditLimit(address borrower) external view returns (uint256 total) {\n        for (uint256 i = 0; i < vouchers[borrower].length; i++) {\n            Vouch memory vouch = vouchers[borrower][i];\n            Staker memory staker = stakers[vouch.staker];\n            total += _min(staker.stakedAmount - staker.locked, vouch.trust - vouch.locked);\n        }\n    }\n\n    /**\n     *  @dev  Get the count of vouchers\n     *        Vouchers are addresses that this borrower is receiving a vouch from.\n     *  @param borrower Address of borrower\n     */\n    function getVoucherCount(address borrower) external view returns (uint256) {\n        return vouchers[borrower].length;\n    }\n\n    /**\n     *  @dev  Get the count of vouchees\n     *        Vouchers are addresses that this staker is vouching for\n     *  @param staker Address of staker\n     */\n    function getVoucheeCount(address staker) external view returns (uint256) {\n        return vouchees[staker].length;\n    }\n\n    /**\n     *  @dev Get the user's deposited stake amount\n     *  @param account Member address\n     *  @return Deposited stake amount\n     */\n    function getStakerBalance(address account) external view returns (uint256) {\n        return stakers[account].stakedAmount;\n    }\n\n    /**\n     *  @dev Get Total locked stake\n     *  @param staker Staker address\n     */\n    function getTotalLockedStake(address staker) external view returns (uint256) {\n        return stakers[staker].locked;\n    }\n\n    /**\n     *  @dev Get staker locked stake for a borrower\n     *  @param staker Staker address\n     *  @param borrower Borrower address\n     *  @return LockedStake\n     */\n    function getLockedStake(address staker, address borrower) external view returns (uint256) {\n        Index memory index = voucherIndexes[borrower][staker];\n        if (!index.isSet) return 0;\n        return vouchers[borrower][index.idx].locked;\n    }\n\n    /**\n     *  @dev Get vouching amount\n     *  @param _staker Staker address\n     *  @param borrower Borrower address\n     */\n    function getVouchingAmount(address _staker, address borrower) external view returns (uint256) {\n        Index memory index = voucherIndexes[borrower][_staker];\n        Staker memory staker = stakers[_staker];\n        if (!index.isSet) return 0;\n        uint96 trustAmount = vouchers[borrower][index.idx].trust;\n        return trustAmount < staker.stakedAmount ? trustAmount : staker.stakedAmount;\n    }\n\n    /* -------------------------------------------------------------------\n      Core Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Manually add union members and bypass all the requirements of `registerMember`\n     *  Only accepts calls from the admin\n     *  Emit {LogAddMember} event\n     *  @param account Member address\n     */\n    function addMember(address account) external onlyAdmin {\n        stakers[account].isMember = true;\n        emit LogAddMember(account);\n    }\n\n    /**\n     *  @dev  Update the trust amount for existing members.\n     *  @dev  Trust is the amount of the underlying token you would in theory be\n     *        happy to lend to another member. Vouch is derived from trust and stake.\n     *        Vouch is the minimum of trust and staked amount.\n     *  Emits {LogUpdateTrust} event\n     *  @param borrower Account address\n     *  @param trustAmount Trust amount\n     */\n    function updateTrust(address borrower, uint96 trustAmount) external onlyMember(msg.sender) whenNotPaused {\n        address staker = msg.sender;\n        if (borrower == staker) revert ErrorSelfVouching();\n\n        // Check if this staker is already vouching for this borrower\n        // If they are already vouching then update the existing vouch record\n        // If this is a new vouch then insert a new Vouch record\n        Index memory index = voucherIndexes[borrower][staker];\n        if (index.isSet) {\n            // Update existing record checking that the new trust amount is\n            // not less than the amount of stake currently locked by the borrower\n            Vouch storage vouch = vouchers[borrower][index.idx];\n            if (trustAmount < vouch.locked) revert TrustAmountLtLocked();\n            vouch.trust = trustAmount;\n        } else {\n            // If the member is overdue they cannot create new vouches they can\n            // only update existing vouches\n            if (uToken.checkIsOverdue(staker)) revert VouchWhenOverdue();\n\n            // This is a new vouch so we need to check that the\n            // member has not reached the max voucher limit\n            uint256 voucheeIndex = vouchees[staker].length;\n            if (voucheeIndex >= maxVouchees) revert MaxVouchees();\n\n            // Get the new index that this vouch is going to be inserted at\n            // Then update the voucher indexes for this borrower as well as\n            // Adding the Vouch the the vouchers array for this staker\n            uint256 voucherIndex = vouchers[borrower].length;\n            if (voucherIndex >= maxVouchers) revert MaxVouchers();\n            voucherIndexes[borrower][staker] = Index(true, voucherIndex.toUint128());\n            vouchers[borrower].push(Vouch(staker, trustAmount, 0, 0));\n\n            // Add the voucherIndex of this new vouch to the vouchees array for this\n            // staker then update the voucheeIndexes with the voucheeIndex\n            vouchees[staker].push(Vouchee(borrower, voucherIndex.toUint96()));\n            voucheeIndexes[borrower][staker] = Index(true, voucheeIndex.toUint128());\n        }\n\n        emit LogUpdateTrust(staker, borrower, trustAmount);\n    }\n\n    /**\n     *  @dev Remove voucher for member\n     *  Can be called by either the borrower or the staker. It will remove the voucher from\n     *  the voucher array by replacing it with the last item of the array and resting the array\n     *  size to -1 by popping off the last item\n     *  Only callable by a member when the contract is not paused\n     *  Emit {LogCancelVouch} event\n     *  @param staker Staker address\n     *  @param borrower borrower address\n     */\n    function _cancelVouchInternal(address staker, address borrower) internal {\n        Index memory removeVoucherIndex = voucherIndexes[borrower][staker];\n        if (!removeVoucherIndex.isSet) revert VoucherNotFound();\n\n        // Check that the locked amount for this vouch is 0\n        Vouch memory vouch = vouchers[borrower][removeVoucherIndex.idx];\n        if (vouch.locked > 0) revert LockedStakeNonZero();\n\n        // Remove borrower from vouchers array by moving the last item into the position\n        // of the index being removed and then poping the last item off the array\n        {\n            // Cache the last voucher\n            Vouch memory lastVoucher = vouchers[borrower][vouchers[borrower].length - 1];\n            // Move the lastVoucher to the index of the voucher we are removing\n            vouchers[borrower][removeVoucherIndex.idx] = lastVoucher;\n            // Pop the last vouch off the end of the vouchers array\n            vouchers[borrower].pop();\n            // Delete the voucher index for this borrower => staker pair\n            delete voucherIndexes[borrower][staker];\n            // Update the last vouchers coresponsing Vouchee item\n            uint128 voucheeIdx = voucherIndexes[borrower][lastVoucher.staker].idx;\n            vouchees[staker][voucheeIdx].voucherIndex = removeVoucherIndex.idx.toUint96();\n        }\n\n        // Update the vouchee entry for this borrower => staker pair\n        {\n            Index memory removeVoucheeIndex = voucheeIndexes[borrower][staker];\n            // Cache the last vouchee\n            Vouchee memory lastVouchee = vouchees[staker][vouchees[staker].length - 1];\n            // Move the last vouchee to the index of the removed vouchee\n            vouchees[staker][removeVoucheeIndex.idx] = lastVouchee;\n            // Pop the last vouchee off the end of the vouchees array\n            vouchees[staker].pop();\n            // Delete the vouchee index for this borrower => staker pair\n            delete voucheeIndexes[borrower][staker];\n            // Update the vouchee indexes to the new vouchee index\n            voucheeIndexes[lastVouchee.borrower][staker].idx = removeVoucheeIndex.idx;\n        }\n\n        emit LogCancelVouch(staker, borrower);\n    }\n\n    /**\n     *  Cancels a vouch between a staker and a borrower.\n     *  @dev The function can only be called by a member of the stakers list.\n     *  @param staker The address of the staker who made the vouch.\n     *  @param borrower The address of the borrower who received the vouch.\n     */\n    function cancelVouch(address staker, address borrower) public onlyMember(msg.sender) whenNotPaused {\n        if (staker != msg.sender && borrower != msg.sender) revert AuthFailed();\n        _cancelVouchInternal(staker, borrower);\n    }\n\n    /**\n     *  @notice Register a a member using a signed permit\n     *  @dev See registerMember\n     *  @param newMember New member address\n     *  @param value Amount approved by permit\n     *  @param deadline Timestamp for when the permit expires\n     *  @param v secp256k1 signature part\n     *  @param r secp256k1 signature part\n     *  @param s secp256k1 signature part\n     */\n    function registerMemberWithPermit(\n        address newMember,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external whenNotPaused {\n        IUnionToken(unionToken).permit(msg.sender, address(this), value, deadline, v, r, s);\n        registerMember(newMember);\n    }\n\n    /**\n     *  @notice Register a a member, and burn the application fee\n     *  @dev    In order to register as a member an address must be receiving x amount\n     *          of vouches greater than 0 from stakers. x is defined by `effectiveCount`\n     *          Emits {LogRegisterMember} event\n     *  @param newMember New member address\n     */\n    function registerMember(address newMember) public virtual whenNotPaused {\n        _validateNewMember(newMember);\n\n        IUnionToken(unionToken).burnFrom(msg.sender, newMemberFee);\n\n        emit LogRegisterMember(msg.sender, newMember);\n    }\n\n    /**\n     *  @notice Stake staking tokens\n     *  @dev    Stake is used to underwrite loans and becomes locked if a\n     *          member a staker has vouched for borrows against it.\n     *          Stake also earns rewards from the comptroller\n     *  Emits a {LogStake} event.\n     *  @param amount Amount to stake\n     */\n    function stake(uint96 amount) public whenNotPaused nonReentrant {\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        Staker storage staker = stakers[msg.sender];\n\n        if (staker.stakedAmount + amount > maxStakeAmount) revert StakeLimitReached();\n\n        _updateStakedCoinAge(msg.sender, staker);\n        staker.stakedAmount += amount;\n        totalStaked += amount;\n\n        erc20Token.safeTransferFrom(msg.sender, address(this), amount);\n        uint256 currentAllowance = erc20Token.allowance(address(this), assetManager);\n        if (currentAllowance < amount) {\n            erc20Token.safeIncreaseAllowance(assetManager, amount - currentAllowance);\n        }\n\n        if (!IAssetManager(assetManager).deposit(stakingToken, amount)) revert AssetManagerDepositFailed();\n        emit LogStake(msg.sender, amount);\n    }\n\n    /**\n     *  @notice Unstake staking token\n     *  @dev    Tokens can only be unstaked if they are not locked. ie a\n     *          vouchee is not borrowing against them.\n     *  Emits {LogUnstake} event\n     *  @param amount Amount to unstake\n     */\n    function unstake(uint96 amount) external whenNotPaused nonReentrant {\n        Staker storage staker = stakers[msg.sender];\n\n        // Stakers can only unstaked stake balance that is unlocked. Stake balance\n        // becomes locked when it is used to underwrite a borrow.\n        if (staker.stakedAmount - staker.locked < amount) revert InsufficientBalance();\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        uint256 remaining = IAssetManager(assetManager).withdraw(stakingToken, msg.sender, amount);\n        if (uint96(remaining) > amount) {\n            revert AssetManagerWithdrawFailed();\n        }\n        uint96 actualAmount = amount - uint96(remaining);\n\n        _updateStakedCoinAge(msg.sender, staker);\n        staker.stakedAmount -= actualAmount;\n        totalStaked -= actualAmount;\n\n        emit LogUnstake(msg.sender, actualAmount);\n    }\n\n    /**\n     *  @dev collect staker rewards from the comptroller\n     */\n    function withdrawRewards() external whenNotPaused nonReentrant {\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n    }\n\n    /**\n     *  @notice Write off a borrowers debt\n     *  @dev    Used the stakers locked stake to write off the loan, transferring the\n     *          Stake to the AssetManager and adjusting balances in the AssetManager\n     *          and the UToken to repay the principal\n     *  @dev    Emits {LogDebtWriteOff} event\n     *  @param stakerAddress address of staker\n     *  @param borrowerAddress address of borrower\n     *  @param amount amount to writeoff\n     */\n    function debtWriteOff(\n        address stakerAddress,\n        address borrowerAddress,\n        uint96 amount\n    ) external {\n        if (amount == 0) revert AmountZero();\n        uint256 overdueBlocks = uToken.overdueBlocks();\n        uint256 lastRepay = uToken.getLastRepay(borrowerAddress);\n\n        // This function is only callable by the public if the loan is overdue by\n        // overdue blocks + maxOverdueBlocks. This stops the system being left with\n        // debt that is overdue indefinitely and no ability to do anything about it.\n        if (block.number <= lastRepay + overdueBlocks + maxOverdueBlocks) {\n            if (stakerAddress != msg.sender) revert AuthFailed();\n        }\n\n        Index memory index = voucherIndexes[borrowerAddress][stakerAddress];\n        if (!index.isSet) revert VoucherNotFound();\n        Vouch storage vouch = vouchers[borrowerAddress][index.idx];\n\n        if (amount > vouch.locked) revert ExceedsLocked();\n\n        // update staker staked amount\n        Staker storage staker = stakers[stakerAddress];\n        _updateStakedCoinAge(stakerAddress, staker);\n        staker.stakedAmount -= amount;\n        staker.locked -= amount;\n        totalStaked -= amount;\n\n        // update vouch trust amount\n        vouch.trust -= amount;\n        vouch.locked -= amount;\n\n        // Update total frozen and member frozen. We don't want to move th\n        // burden of calling updateFrozenInfo into this function as it is quite\n        // gas intensive. Instead we just want to remove the amount that was\n        // frozen which is now being written off. However, it is possible that\n        // member frozen has not been updated prior to calling debtWriteOff and\n        // the amount being written off could be greater than the amount frozen.\n        // To avoid an underflow here we need to check this condition\n        uint256 stakerFrozen = memberFrozen[stakerAddress];\n        if (amount > stakerFrozen) {\n            // The amount being written off is more than the amount that has\n            // been previously frozen for this staker. Reset their frozen stake\n            // to zero and adjust totalFrozen\n            memberFrozen[stakerAddress] = 0;\n            totalFrozen -= stakerFrozen;\n        } else {\n            totalFrozen -= amount;\n            memberFrozen[stakerAddress] -= amount;\n        }\n\n        if (vouch.trust == 0) {\n            _cancelVouchInternal(stakerAddress, borrowerAddress);\n        }\n\n        // Notify the AssetManager and the UToken market of the debt write off\n        // so they can adjust their balances accordingly\n        IAssetManager(assetManager).debtWriteOff(stakingToken, uint256(amount));\n        uToken.debtWriteOff(borrowerAddress, uint256(amount));\n\n        comptroller.updateTotalStaked(stakingToken, totalStaked - totalFrozen);\n\n        emit LogDebtWriteOff(msg.sender, borrowerAddress, uint256(amount));\n    }\n\n    /**\n     *  @notice Borrowing from the market\n     *  @dev    Locks/Unlocks the borrowers stakers staked amounts in a first in\n     *          First out order. Meaning the members that vouched for this borrower\n     *          first will be the first members to get their stake locked or unlocked\n     *          following a borrow or repayment.\n     *  @param borrower The address of the borrower\n     *  @param amount Lock/Unlock amount\n     *  @param lock If the amount is being locked or unlocked\n     */\n    function updateLocked(\n        address borrower,\n        uint96 amount,\n        bool lock\n    ) external onlyMarket {\n        uint96 remaining = amount;\n\n        uint256 vouchersLength = vouchers[borrower].length;\n        for (uint256 i = 0; i < vouchersLength; i++) {\n            Vouch storage vouch = vouchers[borrower][i];\n            uint96 innerAmount;\n\n            uint256 lastWithdrawRewards = getLastWithdrawRewards[vouch.staker];\n            stakers[vouch.staker].lockedCoinAge +=\n                (block.number - _max(lastWithdrawRewards, uint256(vouch.lastUpdated))) *\n                uint256(vouch.locked);\n            if (lock) {\n                // Look up the staker and determine how much unlock stake they\n                // have available for the borrower to borrow. If there is 0\n                // then continue to the next voucher in the array\n                uint96 stakerLocked = stakers[vouch.staker].locked;\n                uint96 stakerStakedAmount = stakers[vouch.staker].stakedAmount;\n                uint96 availableStake = stakerStakedAmount - stakerLocked;\n                uint96 lockAmount = _min(availableStake, vouch.trust - vouch.locked);\n                if (lockAmount == 0) continue;\n                // Calculate the amount to add to the lock then\n                // add the extra amount to lock to the stakers locked amount\n                // and also update the vouches locked amount and lastUpdated block\n                innerAmount = _min(remaining, lockAmount);\n                stakers[vouch.staker].locked = stakerLocked + innerAmount;\n                vouch.locked += innerAmount;\n                vouch.lastUpdated = uint64(block.number);\n            } else {\n                // Look up how much this vouch has locked. If it is 0 then\n                // continue to the next voucher. Then calculate the amount to\n                // unlock which is the min of the vouches lock and what is\n                // remaining to unlock\n                uint96 locked = vouch.locked;\n                if (locked == 0) continue;\n                innerAmount = _min(locked, remaining);\n                // Update the stored locked values and last updated block\n                stakers[vouch.staker].locked -= innerAmount;\n                vouch.locked -= innerAmount;\n                vouch.lastUpdated = uint64(block.number);\n            }\n\n            remaining -= innerAmount;\n            // If there is no remaining amount to lock/unlock\n            // we can stop looping through vouchers\n            if (remaining <= 0) break;\n        }\n\n        // If we have looped through all the avai"
    }
  ]
}