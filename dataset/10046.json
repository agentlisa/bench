{
  "Title": "[M-08] users might pay enormous amounts of gas",
  "Content": "_Submitted by danb_\n\n<https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/Mint.sol#L141>\n\nwhen a user mints new liquidity, it the pair doesn't already exist, it deploys it.\n\ndeploying a new contract on ethereum is super expensive, especially when it's such a large contract like TimeswapPair, it can cost thousands of dollars.\n\n<https://medium.com/the-capital/how-much-does-it-cost-to-deploy-a-smart-contract-on-ethereum-11bcd64da1>\n\n#### Impact\n\nuser who try to mint liquidity on pair that doesn't exist will end up paying thousands of dollars.\n\n#### Recommended Mitigation Steps\n\nIf the pair doesn't exist, revert instead of deploying it.\ndeploying a new contract should be the user's choice, since it's so expensive.\n\n**[Mathepreneur (Timeswap) acknowledged](https://github.com/code-423n4/2022-01-timeswap-findings/issues/74):**\n > We plan to have a better documentation to show this behavior.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-01-timeswap-findings/issues/74#issuecomment-1021355163):**\n > Downgrading to med risk, this isn't an attack vector and is working as designed.  Funds aren't being lost or compromised in any way.\n> \n> The issue is with the design, which could be potentially improved.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-01-timeswap",
  "Code": [
    {
      "filename": "Timeswap/Timeswap-V1-Convenience/contracts/libraries/Mint.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IConvenience} from '../interfaces/IConvenience.sol';\nimport {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';\nimport {IWETH} from '../interfaces/IWETH.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';\nimport {IMint} from '../interfaces/IMint.sol';\nimport {MintMath} from './MintMath.sol';\nimport {Deploy} from './Deploy.sol';\nimport {MsgValue} from './MsgValue.sol';\nimport {ETH} from './ETH.sol';\n\nlibrary Mint {\n    using MintMath for IPair;\n    using Deploy for IConvenience.Native;\n\n    function newLiquidity(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IConvenience convenience,\n        IFactory factory,\n        IMint.NewLiquidity calldata params\n    )\n        external\n        returns (\n            uint256 liquidityOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        (liquidityOut, id, dueOut) = _newLiquidity(\n            natives,\n            convenience,\n            factory,\n            IMint._NewLiquidity(\n                params.asset,\n                params.collateral,\n                params.maturity,\n                msg.sender,\n                msg.sender,\n                params.liquidityTo,\n                params.dueTo,\n                params.assetIn,\n                params.debtIn,\n                params.collateralIn,\n                params.deadline\n            )\n        );\n    }\n\n    function newLiquidityETHAsset(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IConvenience convenience,\n        IFactory factory,\n        IWETH weth,\n        IMint.NewLiquidityETHAsset calldata params\n    )\n        external\n        returns (\n            uint256 liquidityOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        uint112 assetIn = MsgValue.getUint112();\n\n        (liquidityOut, id, dueOut) = _newLiquidity(\n            natives,\n            convenience,\n            factory,\n            IMint._NewLiquidity(\n                weth,\n                params.collateral,\n                params.maturity,\n                address(this),\n                msg.sender,\n                params.liquidityTo,\n                params.dueTo,\n                assetIn,\n                params.debtIn,\n                params.collateralIn,\n                params.deadline\n            )\n        );\n    }\n\n    function newLiquidityETHCollateral(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IConvenience convenience,\n        IFactory factory,\n        IWETH weth,\n        IMint.NewLiquidityETHCollateral calldata params\n    )\n        external\n        returns (\n            uint256 liquidityOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        uint112 collateralIn = MsgValue.getUint112();\n\n        (liquidityOut, id, dueOut) = _newLiquidity(\n            natives,\n            convenience,\n            factory,\n            IMint._NewLiquidity(\n                params.asset,\n                weth,\n                params.maturity,\n                msg.sender,\n                address(this),\n                params.liquidityTo,\n                params.dueTo,\n                params.assetIn,\n                params.debtIn,\n                collateralIn,\n                params.deadline\n            )\n        );\n    }\n\n    function _newLiquidity(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IConvenience convenience,\n        IFactory factory,\n        IMint._NewLiquidity memory params\n    )\n        private\n        returns (\n            uint256 liquidityOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        require(params.debtIn > params.assetIn, 'E516');\n\n        IPair pair = factory.getPair(params.asset, params.collateral);\n\n        if (address(pair) == address(0)) pair = factory.createPair(params.asset, params.collateral);\n\n        require(pair.totalLiquidity(params.maturity) == 0, 'E506');\n\n        (uint112 yIncrease, uint112 zIncrease) = MintMath.givenNew(\n            params.maturity,\n            params.assetIn,\n            params.debtIn,\n            params.collateralIn\n        );\n        (liquidityOut, id, dueOut) = _mint(\n            natives,\n            convenience,\n            pair,\n            IMint._Mint(\n                params.asset,\n                params.collateral,\n                params.maturity,\n                params.assetFrom,\n                params.collateralFrom,\n                params.liquidityTo,\n                params.dueTo,\n                params.assetIn,\n                yIncrease,\n                zIncrease,\n                params.deadline\n            )\n        );\n    }\n\n    function liquidityGivenAsset(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IConvenience convenience,\n        IFactory factory,\n        IMint.LiquidityGivenAsset calldata params\n    )\n        external\n        returns (\n            uint256 liquidityOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        (liquidityOut, id, dueOut) = _liquidityGivenAsset(\n            natives,\n            convenience,\n            factory,\n            IMint._LiquidityGivenAsset(\n                params.asset,\n                params.collateral,\n                params.maturity,\n                msg.sender,\n                msg.sender,\n                params.liquidityTo,\n                params.dueTo,\n                params.assetIn,\n                params.minLiquidity,\n                params.maxDebt,\n                params.maxCollateral,\n                params.deadline\n            )\n        );\n    }\n\n    function liquidityGivenAssetETHAsset(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IConvenience convenience,\n        IFactory factory,\n        IWETH weth,\n        IMint.LiquidityGivenAssetETHAsset calldata params\n    )\n        external\n        returns (\n            uint256 liquidityOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        uint112 assetIn = MsgValue.getUint112();\n\n        (liquidityOut, id, dueOut) = _liquidityGivenAsset(\n            natives,\n            convenience,\n            factory,\n            IMint._LiquidityGivenAsset(\n                weth,\n                params.collateral,\n                params.maturity,\n                address(this),\n                msg.sender,\n                params.liquidityTo,\n                params.dueTo,\n                assetIn,\n                params.minLiquidity,\n                params.maxDebt,\n                params.maxCollateral,\n                params.deadline\n            )\n        );\n    }\n\n    function liquidityGivenAssetETHCollateral(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IConvenience convenience,\n        IFactory factory,\n        IWETH weth,\n        IMint.LiquidityGivenAssetETHCollateral calldata params\n    )\n        external\n        returns (\n            uint256 liquidityOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        uint112 maxCollateral = MsgValue.getUint112();\n\n        (liquidityOut, id, dueOut) = _liquidityGivenAsset(\n            natives,\n            convenience,\n            factory,\n            IMint._LiquidityGivenAsset(\n                params.asset,\n                weth,\n                params.maturity,\n                msg.sender,\n                address(this),\n                params.liquidityTo,\n                params.dueTo,\n                params.assetIn,\n                params.minLiquidity,\n                params.maxDebt,\n                maxCollateral,\n                params.deadline\n            )\n        );\n\n        if (maxCollateral > dueOut.collateral) ETH.transfer(payable(msg.sender), maxCollateral - dueOut.collateral);\n    }\n\n    function _liquidityGivenAsset(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IConvenience convenience,\n        IFactory factory,\n        IMint._LiquidityGivenAsset memory params\n    )\n        private\n        returns (\n            uint256 liquidityOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        IPair pair = factory.getPair(params.asset, params.collateral);\n        require(address(pair) != address(0), 'E501');\n        require(pair.totalLiquidity(params.maturity) > 0, 'E507');\n\n        (uint112 yIncrease, uint112 zIncrease) = pair.givenAsset(params.maturity, params.assetIn);\n\n        (liquidityOut, id, dueOut) = _mint(\n            natives,\n            convenience,\n            pair,\n            IMint._Mint(\n                params.asset,\n                params.collateral,\n                params.maturity,\n                params.assetFrom,\n                params.collateralFrom,\n                params.liquidityTo,\n                params.dueTo,\n                params.assetIn,\n                yIncrease,\n                zIncrease,\n                params.deadline\n            )\n        );\n\n        require(liquidityOut >= params.minLiquidity, 'E511');\n        require(dueOut.debt <= params.maxDebt, 'E512');\n        require(dueOut.collateral <= params.maxCollateral, 'E513');\n    }\n\n    function liquidityGivenDebt(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IConvenience convenience,\n        IFactory factory,\n        IMint.LiquidityGivenDebt memory params\n    )\n        external\n        returns (\n            uint256 liquidityOut,\n            uint112 assetIn,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        (liquidityOut, assetIn, id, dueOut) = _liquidityGivenDebt(\n            natives,\n            convenience,\n            factory,\n            IMint._LiquidityGivenDebt(\n                params.asset,\n                params.collateral,\n                params.maturity,\n                msg.sender,\n                msg.sender,\n                params.liquidityTo,\n                params.dueTo,\n                params.debtIn,\n                params.minLiquidity,\n                params.maxAsset,\n                params.maxCollateral,\n                params.deadline\n            )\n        );\n    }\n\n    function liquidityGivenDebtETHAsset(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IConvenience convenience,\n        IFactory factory,\n        IWETH weth,\n        IMint.LiquidityGivenDebtETHAsset memory params\n    )\n        external\n        returns (\n            uint256 liquidityOut,\n            uint112 assetIn,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        uint112 maxAsset = MsgValue.getUint112();\n\n        (liquidityOut, assetIn, id, dueOut) = _liquidityGivenDebt(\n            natives,\n            convenience,\n            factory,\n            IMint._LiquidityGivenDebt(\n                weth,\n                params.collateral,\n                params.maturity,\n                msg.sender,\n                msg.sender,\n                params.liquidityTo,\n                params.dueTo,\n                params.debtIn,\n                params.minLiquidity,\n                maxAsset,\n                params.maxCollateral,\n                params.deadline\n            )\n        );\n\n        if (maxAsset > assetIn) ETH.transfer(payable(msg.sender), maxAsset - assetIn);\n    }\n\n    function liquidityGivenDebtETHCollateral(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IConvenience convenience,\n        IFactory factory,\n        IWETH weth,\n        IMint.LiquidityGivenDebtETHCollateral memory params\n    )\n        external\n        returns (\n            uint256 liquidityOut,\n            uint112 assetIn,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        uint112 maxCollateral = MsgValue.getUint112();\n\n        (liquidityOut, assetIn, id, dueOut) = _liquidityGivenDebt(\n            natives,\n            convenience,\n            factory,\n            IMint._LiquidityGivenDebt(\n                params.asset,\n                weth,\n                params.maturity,\n                msg.sender,\n                msg.sender,\n                params.liquidityTo,\n                params.dueTo,\n                params.debtIn,\n                params.minLiquidity,\n                params.maxAsset,\n                maxCollateral,\n                params.deadline\n            )\n        );\n\n        if (maxCollateral > dueOut.collateral) ETH.transfer(payable(msg.sender), maxCollateral - dueOut.collateral);\n    }\n\n    function _liquidityGivenDebt(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IConvenience convenience,\n        IFactory factory,\n        IMint._LiquidityGivenDebt memory params\n    )\n        private\n        returns (\n            uint256 liquidityOut,\n            uint112 assetIn,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        IPair pair = factory.getPair(params.asset, params.collateral);\n        require(address(pair) != address(0), 'E501');\n        require(pair.totalLiquidity(params.maturity) > 0, 'E507');\n\n        (uint112 xIncrease, uint112 yIncrease, uint112 zIncrease) = pair.givenDebt(params.maturity, params.debtIn);\n\n        assetIn = xIncrease;\n\n        (liquidityOut, id, dueOut) = _mint(\n            natives,\n            convenience,\n            pair,\n            IMint._Mint(\n                params.asset,\n                params.collateral,\n                params.maturity,\n                params.assetFrom,\n                params.collateralFrom,\n                params.liquidityTo,\n                params.dueTo,\n                assetIn,\n                yIncrease,\n                zIncrease,\n                params.deadline\n            )\n        );\n\n        require(liquidityOut >= params.minLiquidity, 'E511');\n        require(xIncrease <= params.maxAsset, 'E513');\n        require(dueOut.collateral <= params.maxCollateral, 'E512');\n    }\n\n    function liquidityGivenCollateral(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IConvenience convenience,\n        IFactory factory,\n        IMint.LiquidityGivenCollateral memory params\n    )\n        external\n        returns (\n            uint256 liquidityOut,\n            uint112 assetIn,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        (liquidityOut, assetIn, id, dueOut) = _liquidityGivenCollateral(\n            natives,\n            convenience,\n            factory,\n            IMint._LiquidityGivenCollateral(\n                params.asset,\n                params.collateral,\n                params.maturity,\n                msg.sender,\n                msg.sender,\n                params.liquidityTo,\n                params.dueTo,\n                params.collateralIn,\n                params.minLiquidity,\n                params.maxAsset,\n                params.maxDebt,\n                params.deadline\n            )\n        );\n    }\n\n    function liquidityGivenCollateralETHAsset(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IConvenience convenience,\n        IFactory factory,\n        IWETH weth,\n        IMint.LiquidityGivenCollateralETHAsset memory params\n    )\n        external\n        returns (\n            uint256 liquidityOut,\n            uint112 assetIn,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        uint112 maxAsset = MsgValue.getUint112();\n\n        (liquidityOut, assetIn, id, dueOut) = _liquidityGivenCollateral(\n            natives,\n            convenience,\n            factory,\n            IMint._LiquidityGivenCollateral(\n                weth,\n                params.collateral,\n                params.maturity,\n                msg.sender,\n                msg.sender,\n                params.liquidityTo,\n                params.dueTo,\n                params.collateralIn,\n                params.minLiquidity,\n                maxAsset,\n                params.maxDebt,\n                params.deadline\n            )\n        );\n\n        if (maxAsset > assetIn) ETH.transfer(payable(msg.sender), maxAsset - assetIn);\n    }\n\n    function liquidityGivenCollateralETHCollateral(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IConvenience convenience,\n        IFactory factory,\n        IWETH weth,\n        IMint.LiquidityGivenCollateralETHCollateral memory params\n    )\n        external\n        returns (\n            uint256 liquidityOut,\n            uint112 assetIn,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        uint112 collateralIn = MsgValue.getUint112();\n\n        (liquidityOut, assetIn, id, dueOut) = _liquidityGivenCollateral(\n            natives,\n            convenience,\n            factory,\n            IMint._LiquidityGivenCollateral(\n                params.asset,\n                weth,\n                params.maturity,\n                msg.sender,\n                msg.sender,\n                params.liquidityTo,\n                params.dueTo,\n                collateralIn,\n                params.minLiquidity,\n                params.maxAsset,\n                params.maxDebt,\n                params.deadline\n            )\n        );\n    }\n\n    function _liquidityGivenCollateral(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IConvenience convenience,\n        IFactory factory,\n        IMint._LiquidityGivenCollateral memory params\n    )\n        private\n        returns (\n            uint256 liquidityOut,\n            uint112 assetIn,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        IPair pair = factory.getPair(params.asset, params.collateral);\n        require(address(pair) != address(0), 'E501');\n        require(pair.totalLiquidity(params.maturity) > 0, 'E507');\n\n        (uint112 xIncrease, uint112 yIncrease, uint112 zIncrease) = pair.givenCollateral(\n            params.maturity,\n            params.collateralIn\n        );\n\n        assetIn = xIncrease;\n\n        (liquidityOut, id, dueOut) = _mint(\n            natives,\n            convenience,\n            pair,\n            IMint._Mint(\n                params.asset,\n                params.collateral,\n                params.maturity,\n                params.assetFrom,\n                params.collateralFrom,\n                params.liquidityTo,\n                params.dueTo,\n                assetIn,\n                yIncrease,\n                zIncrease,\n                params.deadline\n            )\n        );\n\n        require(liquidityOut >= params.minLiquidity, 'E511');\n        require(xIncrease <= params.maxAsset, 'E513');\n        require(dueOut.debt <= params.maxDebt, 'E512');\n    }\n\n    function _mint(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IConvenience convenience,\n        IPair pair,\n        IMint._Mint memory params\n    )\n        private\n        returns (\n            uint256 liquidityOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        require(params.deadline >= block.timestamp, 'E504');\n        require(params.maturity > block.timestamp, 'E508');\n\n        IConvenience.Native storage native = natives[params.asset][params.collateral][params.maturity];\n        if (address(native.liquidity) == address(0)) {\n            native.deploy(convenience, pair, params.asset, params.collateral, params.maturity);\n        }\n        (liquidityOut, id, dueOut) = pair.mint(\n            params.maturity,\n            address(native.liquidity),\n            address(native.collateralizedDebt),\n            params.xIncrease,\n            params.yIncrease,\n            params.zIncrease,\n            bytes(abi.encode(params.asset, params.collateral, params.assetFrom, params.collateralFrom))\n        );\n        native.liquidity.mint(params.liquidityTo, liquidityOut);\n        native.collateralizedDebt.mint(params.dueTo, id);\n    }\n}"
    }
  ]
}