{
  "Title": "M-5: If a `lendingPool` is added to the network while in `late` state, can be defaulted instantly",
  "Content": "# Issue M-5: If a `lendingPool` is added to the network while in `late` state, can be defaulted instantly \n\nSource: https://github.com/sherlock-audit/2023-02-carapace-judging/issues/151 \n\n## Found by \nAllarious\n\n## Summary\nIf a lending pool is added to a protection pool, the `defaultStateManager` sets the `currentState` to late without setting the late timestamp. This can enable anyone in the network to be able to call the `_assessState` once more and mark the pool as default.\n\n## Vulnerability Detail\n`defaultStateManager` user `_assessState` function to transfer between states. However, in case an underlying pool is called by `_assessState` for the first time when it is added to the protocol. The `_assessState` function sets the `currentState` to `late` without updating the `lateTimestamp` which will remain zero. The attacker can exploit this to move the pool to the default state where it locks the lending pool and renders it unusable.\n\nWhile it is checked that when pools are added to the `ReferenceLendingPool` inside `_addReferenceLendingPool` that the pools should be in `Active` state, if in the time between the addition of a pool and the first time call of `_assessState` the pool goes from `Active` to `Late`, this attack can be performed by the attacker.\n\nhttps://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/DefaultStateManager.sol#L370-L375\n\n## Impact\nAn attacker can render an underlying lending pool unusable.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nThe `_assessState` should handle the initial setting of the state seperately.\n\n## Discussion\n\n**clems4ev3r**\n\n@vnadoda a lending pool cannot be added without being in the active state per this check:\nhttps://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/pool/ReferenceLendingPools.sol#L284\nthis sounds invalid \n\n**vnadoda**\n\n@clems4ev3r  A reporter has mentioned that, but his main concern is the following:\n\"While it is checked that when pools are added to the ReferenceLendingPool inside _addReferenceLendingPool that the pools should be in Active state, **if in the time between the addition of a pool and the first time call of _assessState the pool goes from Active to Late, this attack can be performed by the attacker.**\"\n\nSo I think this concern is valid, but low priority because the probability of this happening is very low.\n\n**vnadoda**\n\n@clems4ev3r We are planning to call `DefaultStateManager.assessState` just after adding the lending pool in op script. \nBut maybe we should have addLendingPool in DefaultStateManager for onlyOwner, which should call RLP.add and then asset state as well? \nIn any case, this is a low-priority issue, do you agree?\n\n**clems4ev3r**\n\n@vnadoda as discussed on call, given the steps taken during op script, and low probability of the issue this could be lowered in severity to low\n\n**hrishibhat**\n\nConsidering this issue as low based on the comments above. \n\n**Allarious**\n\nEscalate for 75 USDC\n\nThe issue is pointing out that while pools get checked to be active when they are being added to the pool, they are not getting checked first time that they are undergoing the `assessState` call. This is a simple issue in nature which is incorrectly handled by the protocol that can lead to an incorrect lending pool state. Relying so heavily on `assessState` running at the same time each day can not be a good design choice and we see here that for every hour of delay, the pool is risking the default of underlying pools. Therefore, this should definitely be considered for at least medium severity. While the issue is explaining the simple attack well enough, here is a more extensive version of explanation.\n\nThis issue arises from two valid points that happen in the system:\n\n* `assessState` gets called daily.\n* The `defaultStateManager` does not handle `Not Supported -> Late`.\n\nThe protocol expects `addProtocol` and `assessState` to happen together, which might make sense from the developer point of view, but opens up a serious attack vector from security point of view when protocol is running `assessState` once a day.\n\nAlso, naming could be changed to \"If a lendingPool is added to the network while **close to** late state, can be defaulted instantly\". I agree that writing and the naming could be much better but the issue is pointing out a valid problem.\n\n## Step by Step\n(1) A pool in its active state gets added to the pool by calling `_addReferenceLendingPool`\n(2) Lets imagine the case where the daily `assessState` was just called\n(3) The `lendingPool` goes from `Active -> Late` before next `assessState`\n(4) In case where `assessState` is called the next day with any delay, the protocol will pass the grace period and enter the `Late` state. The protocol is not designed to handle this case, if the grace period was any smaller than one day, this issue could have caused much more damage.\n(5) When `assessState` is called, the `defaultStateManager` takes the system from `Not supported -> Late` without setting the `lateTimestamp`.\n(6) Any attacker in the system can call the `assessState` again to wrongfully default the pool\n\n## Justification of this issue being H/M\n* (Considerable Probability) The probability of the pool going from `Active -> Late` within two `assessStates` are very high, however, the protocol is heavily relying on the `assessState` being run at the same time everyday and can be extremely dangerous. If we consider a pool's payment period is 14 days, possibility of a added pool to be instantly defaulted is (number_of_delay_hours/24) * 1/14, where for 6 hours of delay in running `assessState`, puts one out of roughly 50 added pools in danger of default.\n* (No Permission Needed) Anyone in the network can trigger the default, and have time as far as the underlying pool is at `late` state\n* (No Fees) Attacker needs to only pay the gas fee in order to cause the pool to default\n* (Complete DoS) The defaulted pool is unusable and can not be removed from the `referenceLendingPools` and would be marked defaulted, effectively DoSing the buyers of the defaulted pool.\n* (Inevitability) Lets imagine you run the script between 12:00 pm and 01:00 pm each day and therefore you have around 15 minutes delay time on average in 90 days, you will have an overall of 22.5 hours overall delay and if we consider the probability uniform, the change of default of pools is (22.5/24) * 1/active_period_in_days which is very close to 1/active_period_in_days. if `active_period_in_days = 14` then you have one out of 14 default because of this.\n\nThe issue is already showing sufficient data about the exploit, why it happens and how to stop it. Therefore, I think it should be labelled Medium or High.\n\n## Comments provided by LSW and Sponsor\n> @vnadoda a lending pool cannot be added without being in the active state per this check:\nhttps://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/pool/ReferenceLendingPools.sol#L284\nthis sounds invalid\n\nThis issue is talking about when the pool is assessed for the first time while in the `late` state. While I agree that the naming and writing could be better, it is still showing enough data if you read all of the issue carefully.\n\n> So I think this concern is valid, but low priority because the probability of this happening is very low.\n\nThe probability is considerable, as shown above. It is not a good idea to be relying on a script running everyday without no pre-cautions, now that we can see even hours late can cause some pools to default. Handling such cases on-chain would happen easily by correctly implementing `Not Supported -> Late` in `defaultStateManager`, while it is not handled correctly, should be heavily considered by the team.\n\n> We are planning to call DefaultStateManager.assessState just after adding the lending pool in op script.\n\nIf there is a need to handle this in a script/third contract, then it means there is a valid bug here. As stated in the initial scope of the audit, `assessState` gets called daily and `_addReferenceLendingPool` can be called anytime. I believe the issue's severity should be judged based on `assessState` running daily. However, if you want to use an external script/contract to handle this, you need to consider the points mentioned below.\n* Either you are using a third smart contract to call `_addReferenceLendingPool` and `assessState` atomically, which is the safest option.\n* Or you are using an off-chain script to send two transactions `_addReferenceLendingPool` and `assessState` together, where in this case, if the transactions are not included in the certain order of `_addReferenceLendingPool` first and `assessState` second, the `assessState` would be ineffective and attack is again valid.\n\n**sherlock-admin**\n\n > Escalate for 75 USDC\n> \n> The issue is pointing out that while pools get checked to be active when they are being added to the pool, they are not getting checked first time that they are undergoing the `assessState` call. This is a simple issue in nature which is incorrectly handled by the protocol that can lead to an incorrect lending pool state. Relying so heavily on `assessState` running at the same time each day can not be a good design choice and we see here that for every hour of delay, the pool is risking the default of underlying pools. Therefore, this should definitely be considered for at least medium severity. While the issue is explaining the simple attack well enough, here is a more extensive version of explanation.\n> \n> This issue arises from two valid points that happen in the system:\n> \n> * `assessState` gets called daily.\n> * The `defaultStateManager` does not handle `Not Supported -> Late`.\n> \n> The protocol expects `addProtocol` and `assessState` to happen together, which might make sense from the developer point of view, but opens up a serious attack vector from security point of view when protocol is running `assessState` once a day.\n> \n> Also, naming could be changed to \"If a lendingPool is added to the network while **close to** late state, can be defaulted instantly\". I agree that writing and the naming could be much better but the issue is pointing out a valid problem.\n> \n> ## Step by Step\n> (1) A pool in its active state gets added to the pool by calling `_addReferenceLendingPool`\n> (2) Lets imagine the case where the daily `assessState` was just called\n> (3) The `lendingPool` goes from `Active -> Late` before next `assessState`\n> (4) In case where `assessState` is called the next day with any delay, the protocol will pass the grace period and enter the `Late` state. The protocol is not designed to handle this case, if the grace period was any smaller than one day, this issue could have caused much more damage.\n> (5) When `assessState` is called, the `defaultStateManager` takes the system from `Not supported -> Late` without setting the `lateTimestamp`.\n> (6) Any attacker in the system can call the `assessState` again to wrongfully default the pool\n> \n> ## Justification of this issue being H/M\n> * (Considerable Probability) The probability of the pool going from `Active -> Late` within two `assessStates` are very high, however, the protocol is heavily relying on the `assessState` being run at the same time everyday and can be extremely dangerous. If we consider a pool's payment period is 14 days, possibility of a added pool to be instantly defaulted is (number_of_delay_hours/24) * 1/14, where for 6 hours of delay in running `assessState`, puts one out of roughly 50 added pools in danger of default.\n> * (No Permission Needed) Anyone in the network can trigger the default, and have time as far as the underlying pool is at `late` state\n> * (No Fees) Attacker needs to only pay the gas fee in order to cause the pool to default\n> * (Complete DoS) The defaulted pool is unusable and can not be removed from the `referenceLendingPools` and would be marked defaulted, effectively DoSing the buyers of the defaulted pool.\n> * (Inevitability) Lets imagine you run the script between 12:00 pm and 01:00 pm each day and therefore you have around 15 minutes delay time on average in 90 days, you will have an overall of 22.5 hours overall delay and if we consider the probability uniform, the change of default of pools is (22.5/24) * 1/active_period_in_days which is very close to 1/active_period_in_days. if `active_period_in_days = 14` then you have one out of 14 default because of this.\n> \n> The issue is already showing sufficient data about the exploit, why it happens and how to stop it. Therefore, I think it should be labelled Medium or High.\n> \n> ## Comments provided by LSW and Sponsor\n> > @vnadoda a lending pool cannot be added without being in the active state per this check:\n> https://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/pool/ReferenceLendingPools.sol#L284\n> this sounds invalid\n> \n> This issue is talking about when the pool is assessed for the first time while in the `late` state. While I agree that the naming and writing could be better, it is still showing enough data if you read all of the issue carefully.\n> \n> > So I think this concern is valid, but low priority because the probability of this happening is very low.\n> \n> The probability is considerable, as shown above. It is not a good idea to be relying on a script running everyday without no pre-cautions, now that we can see even hours late can cause some pools to default. Handling such cases on-chain would happen easily by correctly implementing `Not Supported -> Late` in `defaultStateManager`, while it is not handled correctly, should be heavily considered by the team.\n> \n> > We are planning to call DefaultStateManager.assessState just after adding the lending pool in op script.\n> \n> If there is a need to handle this in a script/third contract, then it means there is a valid bug here. As stated in the initial scope of the audit, `assessState` gets called daily and `_addReferenceLendingPool` can be called anytime. I believe the issue's severity should be judged based on `assessState` running daily. However, if you want to use an external script/contract to handle this, you need to consider the points mentioned below.\n> * Either you are using a third smart contract to call `_addReferenceLendingPool` and `assessState` atomically, which is the safest option.\n> * Or you are using an off-chain script to send two transactions `_addReferenceLendingPool` and `assessState` together, where in this case, if the transactions are not included in the certain order of `_addReferenceLendingPool` first and `assessState` second, the `assessState` would be ineffective and attack is again valid.\n\nYou've created a valid escalation for 75 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nBased on internal discussions with the Team and the Lead Watson, the protocol calls for `assessstate` as soon as the lending pool is added, but this information was not available during the audit, there is a likely chance the issue could still happen, hence considering this a valid medium. \n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Based on internal discussions with the Team and the Lead Watson, the protocol calls for `assessstate` as soon as the lending pool is added, but this information was not available during the audit, there is a likely chance the issue could still happen, hence considering this a valid medium. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/40",
  "Code": [
    {
      "filename": "contracts/core/DefaultStateManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ERC20SnapshotUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\";\n\nimport {UUPSUpgradeableBase} from \"../UUPSUpgradeableBase.sol\";\nimport {IReferenceLendingPools, LendingPoolStatus} from \"../interfaces/IReferenceLendingPools.sol\";\nimport {ILendingProtocolAdapter} from \"../interfaces/ILendingProtocolAdapter.sol\";\nimport {IProtectionPool} from \"../interfaces/IProtectionPool.sol\";\nimport {IDefaultStateManager, ProtectionPoolState, LockedCapital, LendingPoolStatusDetail} from \"../interfaces/IDefaultStateManager.sol\";\nimport \"../libraries/Constants.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @title DefaultStateManager\n * @author Carapace Finance\n * @notice Contract to assess status updates and the resultant state transitions of all lending pools of all protection pools\n * @dev This contract is upgradeable using the UUPS pattern.\n */\ncontract DefaultStateManager is UUPSUpgradeableBase, IDefaultStateManager {\n  /////////////////////////////////////////////////////\n  ///             STORAGE - START                   ///\n  /////////////////////////////////////////////////////\n  /**\n   * @dev DO NOT CHANGE THE ORDER OF THESE VARIABLES ONCE DEPLOYED\n   */\n\n  /// @notice address of the contract factory which is the only contract allowed to register protection pools.\n  address public contractFactoryAddress;\n\n  /// @dev stores the current state of all protection pools in the system.\n  /// @dev Array is used for enumerating all pools during state assessment.\n  ProtectionPoolState[] private protectionPoolStates;\n\n  /// @notice tracks an index of ProtectionPoolState for each pool in protectionPoolStates array.\n  mapping(address => uint256) private protectionPoolStateIndexes;\n\n  //////////////////////////////////////////////////////\n  ///             STORAGE - END                     ///\n  /////////////////////////////////////////////////////\n\n  /*** modifiers ***/\n\n  /// @dev modifier to restrict access to the contract factory address.\n  modifier onlyContractFactory() {\n    if (msg.sender != contractFactoryAddress) {\n      revert NotContractFactory(msg.sender);\n    }\n    _;\n  }\n\n  /*** initializer ***/\n\n  /**\n   * @notice Initializes the contract.\n   */\n  function initialize() external initializer {\n    __UUPSUpgradeableBase_init();\n\n    /// create a dummy pool state to reserve index 0.\n    /// this is to ensure that protectionPoolStateIndexes[pool] is always greater than 0,\n    /// which is used to check if a pool is registered or not.\n    protectionPoolStates.push();\n  }\n\n  /*** state-changing functions ***/\n\n  /// @inheritdoc IDefaultStateManager\n  /// @dev This function is marked as payable for gas optimization.\n  function setContractFactory(address _contractFactoryAddress)\n    external\n    payable\n    override\n    onlyOwner\n  {\n    if (_contractFactoryAddress == Constants.ZERO_ADDRESS) {\n      revert ZeroContractFactoryAddress();\n    }\n\n    contractFactoryAddress = _contractFactoryAddress;\n    emit ContractFactoryUpdated(_contractFactoryAddress);\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  function registerProtectionPool(address _protectionPoolAddress)\n    external\n    payable\n    override\n    onlyContractFactory\n  {\n    /// if the protection pool is already registered, revert\n    if (\n      protectionPoolStates[protectionPoolStateIndexes[_protectionPoolAddress]]\n        .updatedTimestamp > 0\n    ) {\n      revert ProtectionPoolAlreadyRegistered(_protectionPoolAddress);\n    }\n\n    /// Protection pool will be inserted at the end of the array\n    uint256 newIndex = protectionPoolStates.length;\n\n    /// Insert new empty pool state at the end of the array\n    /// and update the state\n    protectionPoolStates.push();\n    ProtectionPoolState storage poolState = protectionPoolStates[newIndex];\n    poolState.protectionPool = IProtectionPool(_protectionPoolAddress);\n\n    /// Store the index of the pool state in the array\n    protectionPoolStateIndexes[_protectionPoolAddress] = newIndex;\n\n    /// Assess the state of the newly registered protection pool\n    _assessState(poolState);\n\n    emit ProtectionPoolRegistered(_protectionPoolAddress);\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  function assessStates() external override {\n    /// gas optimizations:\n    /// 1. capture length in memory & don't read from storage for each iteration\n    /// 2. uncheck incrementing pool index\n    uint256 _length = protectionPoolStates.length;\n\n    /// assess the state of all registered protection pools except the dummy pool at index 0\n    for (uint256 _poolIndex = 1; _poolIndex < _length; ) {\n      _assessState(protectionPoolStates[_poolIndex]);\n      unchecked {\n        ++_poolIndex;\n      }\n    }\n\n    emit ProtectionPoolStatesAssessed();\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  function assessStateBatch(address[] calldata _pools) external override {\n    uint256 _length = _pools.length;\n    for (uint256 _poolIndex; _poolIndex < _length; ) {\n      /// Get the state of the pool by looking up the index in the mapping from the given pool address\n      ProtectionPoolState storage poolState = protectionPoolStates[\n        protectionPoolStateIndexes[_pools[_poolIndex]]\n      ];\n\n      /// Only assess the state if the protection pool is registered\n      if (poolState.updatedTimestamp > 0) {\n        _assessState(poolState);\n      }\n\n      unchecked {\n        ++_poolIndex;\n      }\n    }\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  /// @dev This method is only callable by a protection pool\n  function calculateAndClaimUnlockedCapital(address _seller)\n    external\n    override\n    returns (uint256 _claimedUnlockedCapital)\n  {\n    /// Get the state of the pool by looking up the index in the mapping from sender address\n    ProtectionPoolState storage poolState = protectionPoolStates[\n      protectionPoolStateIndexes[msg.sender]\n    ];\n\n    /// Only assess the state if the protection pool is registered\n    if (poolState.updatedTimestamp == 0) {\n      revert ProtectionPoolNotRegistered(msg.sender);\n    }\n\n    /// Get the list of all lending pools for the protection pool\n    address[] memory _lendingPools = poolState\n      .protectionPool\n      .getPoolInfo()\n      .referenceLendingPools\n      .getLendingPools();\n\n    /// Iterate through all lending pools for a given protection pool\n    /// and calculate the total claimable amount for the seller\n    uint256 _length = _lendingPools.length;\n    for (uint256 _lendingPoolIndex; _lendingPoolIndex < _length; ) {\n      address _lendingPool = _lendingPools[_lendingPoolIndex];\n\n      /// Calculate the claimable amount across all the locked capital instances for a given protection pool\n      (\n        uint256 _unlockedCapitalPerLendingPool,\n        uint256 _snapshotId\n      ) = _calculateClaimableAmount(poolState, _lendingPool, _seller);\n      _claimedUnlockedCapital += _unlockedCapitalPerLendingPool;\n\n      /// update the last claimed snapshot id for the seller for the given lending pool,\n      /// so that the next time the seller claims, the calculation starts from the last claimed snapshot id\n      poolState.lastClaimedSnapshotIds[_lendingPool][_seller] = _snapshotId;\n\n      unchecked {\n        ++_lendingPoolIndex;\n      }\n    }\n  }\n\n  /** view functions */\n\n  /**\n   * @notice Returns the timestamp of the protection pool state update.\n   */\n  function getPoolStateUpdateTimestamp(address _pool)\n    external\n    view\n    returns (uint256)\n  {\n    return\n      protectionPoolStates[protectionPoolStateIndexes[_pool]].updatedTimestamp;\n  }\n\n  /**\n   * @notice Returns the list of locked capital instances for a given protection pool and lending pool.\n   */\n  function getLockedCapitals(address _protectionPool, address _lendingPool)\n    external\n    view\n    returns (LockedCapital[] memory _lockedCapitals)\n  {\n    ProtectionPoolState storage poolState = protectionPoolStates[\n      protectionPoolStateIndexes[_protectionPool]\n    ];\n    _lockedCapitals = poolState.lockedCapitals[_lendingPool];\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  function calculateClaimableUnlockedAmount(\n    address _protectionPool,\n    address _seller\n  ) external view override returns (uint256 _claimableUnlockedCapital) {\n    ProtectionPoolState storage poolState = protectionPoolStates[\n      protectionPoolStateIndexes[_protectionPool]\n    ];\n\n    /// Calculate the claimable amount only if the protection pool is registered\n    if (poolState.updatedTimestamp > 0) {\n      /// Get the list of all lending pools for the protection pool\n      address[] memory _lendingPools = poolState\n        .protectionPool\n        .getPoolInfo()\n        .referenceLendingPools\n        .getLendingPools();\n\n      /// Iterate through all lending pools for a given protection pool\n      /// and calculate the total claimable amount for the seller\n      uint256 _length = _lendingPools.length;\n      for (uint256 _lendingPoolIndex; _lendingPoolIndex < _length; ) {\n        address _lendingPool = _lendingPools[_lendingPoolIndex];\n\n        /// Calculate the claimable amount across all the locked capital instances for a given protection pool\n        (uint256 _unlockedCapitalPerLendingPool, ) = _calculateClaimableAmount(\n          poolState,\n          _lendingPool,\n          _seller\n        );\n\n        /// add the unlocked/claimable amount for the given lending pool to the total claimable amount\n        _claimableUnlockedCapital += _unlockedCapitalPerLendingPool;\n\n        unchecked {\n          ++_lendingPoolIndex;\n        }\n      }\n    }\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  function getLendingPoolStatus(\n    address _protectionPoolAddress,\n    address _lendingPoolAddress\n  ) external view override returns (LendingPoolStatus) {\n    return\n      protectionPoolStates[protectionPoolStateIndexes[_protectionPoolAddress]]\n        .lendingPoolStateDetails[_lendingPoolAddress]\n        .currentStatus;\n  }\n\n  /** internal functions */\n\n  /**\n   * @dev assess the state of a given protection pool and\n   * update state changes & initiate related actions as needed.\n   */\n  function _assessState(ProtectionPoolState storage poolState) internal {\n    poolState.updatedTimestamp = block.timestamp;\n\n    /// assess the state of all reference lending pools of this protection pool\n    (\n      address[] memory _lendingPools,\n      LendingPoolStatus[] memory _currentStatuses\n    ) = poolState\n        .protectionPool\n        .getPoolInfo()\n        .referenceLendingPools\n        .assessState();\n\n    /// Compare previous and current status of each lending pool and perform the required state transition\n    uint256 _length = _lendingPools.length;\n    for (uint256 _lendingPoolIndex; _lendingPoolIndex < _length; ) {\n      /// Get the lending pool state details\n      address _lendingPool = _lendingPools[_lendingPoolIndex];\n      LendingPoolStatusDetail storage lendingPoolStateDetail = poolState\n        .lendingPoolStateDetails[_lendingPool];\n\n      /// Get the previous and current status of the lending pool\n      LendingPoolStatus _previousStatus = lendingPoolStateDetail.currentStatus;\n      LendingPoolStatus _currentStatus = _currentStatuses[_lendingPoolIndex];\n\n      if (_previousStatus != _currentStatus) {\n        console.log(\n          \"DefaultStateManager: Lending pool %s status is changed from %s to  %s\",\n          _lendingPool,\n          uint256(_previousStatus),\n          uint256(_currentStatus)\n        );\n      }\n\n      /// State transition 1: Active or LateWithinGracePeriod -> Late\n      if (\n        (_previousStatus == LendingPoolStatus.Active ||\n          _previousStatus == LendingPoolStatus.LateWithinGracePeriod) &&\n        _currentStatus == LendingPoolStatus.Late\n      ) {\n        /// Update the current status of the lending pool to Late\n        /// and move the lending pool to the locked state\n        lendingPoolStateDetail.currentStatus = LendingPoolStatus.Late;\n        _moveFromActiveToLockedState(poolState, _lendingPool);\n\n        /// Capture the timestamp when the lending pool became late\n        lendingPoolStateDetail.lateTimestamp = block.timestamp;\n      } else if (_previousStatus == LendingPoolStatus.Late) {\n        /// Once there is a late payment, we wait for 2 payment periods.\n        /// After 2 payment periods are elapsed, either full payment is going to be made or not.\n        /// If all missed payments(full payment) are made, then a pool goes back to active.\n        /// If full payment is not made, then this lending pool is in the default state.\n        if (\n          block.timestamp >\n          (lendingPoolStateDetail.lateTimestamp +\n            _getTwoPaymentPeriodsInSeconds(poolState, _lendingPool))\n        ) {\n          /// State transition 2: Late -> Active\n          if (_currentStatus == LendingPoolStatus.Active) {\n            /// Update the current status of the lending pool to Active\n            /// and move the lending pool to the active state\n            lendingPoolStateDetail.currentStatus = LendingPoolStatus.Active;\n            _moveFromLockedToActiveState(poolState, _lendingPool);\n\n            /// Clear the late timestamp\n            lendingPoolStateDetail.lateTimestamp = 0;\n          }\n          /// State transition 3: Late -> Defaulted\n          else if (_currentStatus == LendingPoolStatus.Late) {\n            /// Update the current status of the lending pool to Active\n            lendingPoolStateDetail.currentStatus = LendingPoolStatus.Defaulted;\n\n            // Default state transition will be implemented in the next version of the protocol\n            // _moveFromLockedToDefaultedState(poolState, _lendingPool);\n          }\n        }\n      } else if (\n        _previousStatus == LendingPoolStatus.Defaulted ||\n        _previousStatus == LendingPoolStatus.Expired\n      ) {\n        /// no state transition for Defaulted or Expired state\n      } else {\n        /// Only update the status in storage if it is changed\n        if (_previousStatus != _currentStatus) {\n          lendingPoolStateDetail.currentStatus = _currentStatus;\n          /// No action required for any other state transition\n        }\n      }\n\n      unchecked {\n        ++_lendingPoolIndex;\n      }\n    }\n  }\n\n  /**\n   * @dev Moves the lending pool from active state to locked state.\n   * Meaning that the capital is locked in the protection pool.\n   * @param poolState The stored state of the protection pool\n   * @param _lendingPool The address of the lending pool\n   */\n  function _moveFromActiveToLockedState(\n    ProtectionPoolState storage poolState,\n    address _lendingPool\n  ) internal {\n    IProtectionPool _protectionPool = poolState.protectionPool;\n\n    /// step 1: calculate & lock the capital amount in the protection pool\n    (uint256 _lockedCapital, uint256 _snapshotId) = _protectionPool.lockCapital(\n      _lendingPool\n    );\n\n    /// step 2: create and store an instance of locked capital for the lending pool\n    poolState.lockedCapitals[_lendingPool].push(\n      LockedCapital({\n        snapshotId: _snapshotId,\n        amount: _lockedCapital,\n        locked: true\n      })\n    );\n\n    emit LendingPoolLocked(\n      _lendingPool,\n      address(_protectionPool),\n      _snapshotId,\n      _lockedCapital\n    );\n  }\n\n  /**\n   * @dev Releases the locked capital, so investors can claim their share of the unlocked capital\n   * The capital is released/unlocked from last locked capital instance.\n   * Because new lock capital instance can not be created until the latest one is active again.\n   * @param poolState The stored state of the protection pool\n   * @param _lendingPool The address of the lending pool\n   */\n  function _moveFromLockedToActiveState(\n    ProtectionPoolState storage poolState,\n    address _lendingPool\n  ) internal {\n    /// For each lending pool, every active -> late state change creates a new instance of the locked capital.\n    /// So last item in the array represents the latest state change.\n    LockedCapital storage lockedCapital = _getLatestLockedCapital(\n      poolState,\n      _lendingPool\n    );\n    lockedCapital.locked = false;\n\n    emit LendingPoolUnlocked(\n      _lendingPool,\n      address(poolState.protectionPool),\n      lockedCapital.amount\n    );\n  }\n\n  /**\n   * @dev Calculates the claimable amount across all locked capital instances for the given seller address for a given lending pool.\n   * locked capital can be only claimed when it is released and has not been claimed before.\n   * @param poolState The stored state of the protection pool\n   * @param _lendingPool The address of the lending pool\n   * @param _seller The address of the seller\n   * @return _claimableUnlockedCapital The claimable amount across all locked capital instances in underlying tokens\n   * @return _latestClaimedSnapshotId The snapshot id of the latest locked capital instance from which the claimable amount is calculated\n   */\n  function _calculateClaimableAmount(\n    ProtectionPoolState storage poolState,\n    address _lendingPool,\n    address _seller\n  )\n    internal\n    view\n    returns (\n      uint256 _claimableUnlockedCapital,\n      uint256 _latestClaimedSnapshotId\n    )\n  {\n    /// Retrieve the last claimed snapshot id for the seller from storage\n    uint256 _lastClaimedSnapshotId = poolState.lastClaimedSnapshotIds[\n      _lendingPool\n    ][_seller];\n\n    /// Retrieve the locked capital instances for the given lending pool\n    LockedCapital[] storage lockedCapitals = poolState.lockedCapitals[\n      _lendingPool\n    ];\n\n    /// Iterate over the locked capital instances and calculate the claimable amount\n    uint256 _length = lockedCapitals.length;\n    for (uint256 _index = 0; _index < _length; ) {\n      LockedCapital storage lockedCapital = lockedCapitals[_index];\n      uint256 _snapshotId = lockedCapital.snapshotId;\n\n      console.log(\n        \"lockedCapital.locked: %s, amt: %s\",\n        lockedCapital.locked,\n        lockedCapital.amount\n      );\n\n      /// Verify that the seller does not claim the same snapshot twice\n      if (!lockedCapital.locked && _snapshotId > _lastClaimedSnapshotId) {\n        ERC20SnapshotUpgradeable _poolSToken = ERC20SnapshotUpgradeable(\n          address(poolState.protectionPool)\n        );\n\n        console.log(\n          \"balance of seller: %s, total supply: %s at snapshot: %s\",\n          _poolSToken.balanceOfAt(_seller, _snapshotId),\n          _poolSToken.totalSupplyAt(_snapshotId),\n          _snapshotId\n        );\n\n        /// The claimable amount for the given seller is proportional to the seller's share of the total supply at the snapshot\n        /// claimable amount = (seller's snapshot balance / total supply at snapshot) * locked capital amount\n        _claimableUnlockedCapital =\n          (_poolSToken.balanceOfAt(_seller, _snapshotId) *\n            lockedCapital.amount) /\n          _poolSToken.totalSupplyAt(_snapshotId);\n\n        /// Update the last claimed snapshot id for the seller\n        _latestClaimedSnapshotId = _snapshotId;\n\n        console.log(\n          \"Claimable amount for seller %s is %s\",\n          _seller,\n          _claimableUnlockedCapital\n        );\n      }\n\n      unchecked {\n        ++_index;\n      }\n    }\n  }\n\n  /**\n   * @dev Returns the latest locked capital instance for a given lending pool.\n   * @param poolState The stored state of the protection pool\n   * @param _lendingPool The address of the lending pool\n   */\n  function _getLatestLockedCapital(\n    ProtectionPoolState storage poolState,\n    address _lendingPool\n  ) internal view returns (LockedCapital storage _lockedCapital) {\n    /// Return the last locked capital instance in the array\n    LockedCapital[] storage lockedCapitals = poolState.lockedCapitals[\n      _lendingPool\n    ];\n    _lockedCapital = lockedCapitals[lockedCapitals.length - 1];\n  }\n\n  /**\n   * @dev Returns the two payment periods in seconds for a given lending pool.\n   * @param poolState The stored state of the protection pool\n   * @param _lendingPool The address of the lending pool\n   * @return The two payment periods in seconds for a given lending pool\n   */\n  function _getTwoPaymentPeriodsInSeconds(\n    ProtectionPoolState storage poolState,\n    address _lendingPool\n  ) internal view returns (uint256) {\n    /// Retrieve the payment period in days for the given lending pool and convert it to seconds\n    return\n      (poolState\n        .protectionPool\n        .getPoolInfo()\n        .referenceLendingPools\n        .getPaymentPeriodInDays(_lendingPool) * 2) *\n      Constants.SECONDS_IN_DAY_UINT;\n  }\n}"
    },
    {
      "filename": "contracts/core/pool/ReferenceLendingPools.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {UUPSUpgradeableBase} from \"../../UUPSUpgradeableBase.sol\";\n\nimport {IReferenceLendingPools, LendingPoolStatus, LendingProtocol, ProtectionPurchaseParams, ReferenceLendingPoolInfo} from \"../../interfaces/IReferenceLendingPools.sol\";\nimport {ILendingProtocolAdapter} from \"../../interfaces/ILendingProtocolAdapter.sol\";\nimport {ILendingProtocolAdapterFactory} from \"../../interfaces/ILendingProtocolAdapterFactory.sol\";\n\nimport \"../../libraries/Constants.sol\";\n\n/**\n * @title ReferenceLendingPools\n * @author Carapace Finance\n * @notice ReferenceLendingPools manages the basket of reference lending pools,\n * against which the carapace protocol can provide the protection.\n *\n * @dev This contract is upgradeable using the UUPS pattern.\n */\ncontract ReferenceLendingPools is UUPSUpgradeableBase, IReferenceLendingPools {\n  /////////////////////////////////////////////////////\n  ///             STORAGE - START                   ///\n  /////////////////////////////////////////////////////\n  /**\n   * @dev DO NOT CHANGE THE ORDER OF THESE VARIABLES ONCE DEPLOYED\n   */\n\n  /// @notice the lending protocol adapter factory\n  ILendingProtocolAdapterFactory private lendingProtocolAdapterFactory;\n\n  /// @notice the mapping of the lending pool address to the lending pool info\n  mapping(address => ReferenceLendingPoolInfo) public referenceLendingPools;\n\n  /// @notice an array of all the added lending pools in this basket\n  address[] private lendingPools;\n\n  //////////////////////////////////////////////////////\n  ///             STORAGE - END                     ///\n  /////////////////////////////////////////////////////\n\n  /** modifiers */\n\n  /// @dev modifier to check if the lending pool is supported,\n  /// i.e. added to this basket and is active\n  modifier whenLendingPoolSupported(address _lendingPoolAddress) {\n    if (!_isReferenceLendingPoolAdded(_lendingPoolAddress)) {\n      revert ReferenceLendingPoolNotSupported(_lendingPoolAddress);\n    }\n    _;\n  }\n\n  /// @inheritdoc IReferenceLendingPools\n  function initialize(\n    address _owner,\n    address[] calldata _lendingPools,\n    LendingProtocol[] calldata _lendingPoolProtocols,\n    uint256[] calldata _protectionPurchaseLimitsInDays,\n    address _lendingProtocolAdapterFactory\n  ) external override initializer {\n    if (\n      _lendingPools.length != _lendingPoolProtocols.length ||\n      _lendingPools.length != _protectionPurchaseLimitsInDays.length\n    ) {\n      revert ReferenceLendingPoolsConstructionError(\n        \"Array inputs length must match\"\n      );\n    }\n\n    if (_owner == Constants.ZERO_ADDRESS) {\n      revert ReferenceLendingPoolsConstructionError(\n        \"Owner address must not be zero\"\n      );\n    }\n\n    /// Initialize the UUPSUpgradeableBase\n    __UUPSUpgradeableBase_init();\n\n    lendingProtocolAdapterFactory = ILendingProtocolAdapterFactory(\n      _lendingProtocolAdapterFactory\n    );\n\n    /// Transfer ownership of this contract to the specified owner address\n    _transferOwnership(_owner);\n\n    /// Add the specified lending pools to the basket\n    uint256 length = _lendingPools.length;\n    for (uint256 i; i < length; ) {\n      _addReferenceLendingPool(\n        _lendingPools[i],\n        _lendingPoolProtocols[i],\n        _protectionPurchaseLimitsInDays[i]\n      );\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /** state changing functions */\n\n  /**\n   * @notice Adds a new reference lending pool to the basket.\n   * @dev This function can only be called by the owner of this contract.\n   * @dev This function is marked as payable for gas optimization.\n   * @param _lendingPoolAddress address of the lending pool\n   * @param _lendingPoolProtocol the protocol of underlying lending pool\n   * @param _protectionPurchaseLimitInDays the protection purchase limit in days.\n   * i.e. 90 days means the protection can be purchased within {_protectionPurchaseLimitInDays} days of\n   * lending pool being added to this contract.\n   */\n  function addReferenceLendingPool(\n    address _lendingPoolAddress,\n    LendingProtocol _lendingPoolProtocol,\n    uint256 _protectionPurchaseLimitInDays\n  ) external payable onlyOwner {\n    _addReferenceLendingPool(\n      _lendingPoolAddress,\n      _lendingPoolProtocol,\n      _protectionPurchaseLimitInDays\n    );\n  }\n\n  /** view functions */\n\n  /// @inheritdoc IReferenceLendingPools\n  function getLendingPools() public view override returns (address[] memory) {\n    return lendingPools;\n  }\n\n  /// @inheritdoc IReferenceLendingPools\n  function canBuyProtection(\n    address _buyer,\n    ProtectionPurchaseParams calldata _purchaseParams,\n    bool _isRenewal\n  )\n    external\n    view\n    override\n    whenLendingPoolSupported(_purchaseParams.lendingPoolAddress)\n    returns (bool)\n  {\n    ReferenceLendingPoolInfo storage lendingPoolInfo = referenceLendingPools[\n      _purchaseParams.lendingPoolAddress\n    ];\n\n    /// When buyer is not renewing the existing protection and\n    /// the protection purchase is NOT within purchase limit duration after\n    /// a lending pool added, the buyer cannot purchase protection.\n    /// i.e. if the purchase limit is 90 days, the buyer cannot purchase protection\n    /// after 90 days of lending pool added to the basket\n    if (\n      !_isRenewal &&\n      block.timestamp > lendingPoolInfo.protectionPurchaseLimitTimestamp\n    ) {\n      return false;\n    }\n\n    /// Verify that protection amount is less than or equal to the remaining principal\n    /// that buyer has lent to the underlying lending pool\n    return\n      _purchaseParams.protectionAmount <=\n      calculateRemainingPrincipal(\n        _purchaseParams.lendingPoolAddress,\n        _buyer,\n        _purchaseParams.nftLpTokenId\n      );\n  }\n\n  /// @inheritdoc IReferenceLendingPools\n  function calculateProtectionBuyerAPR(address _lendingPoolAddress)\n    public\n    view\n    override\n    whenLendingPoolSupported(_lendingPoolAddress)\n    returns (uint256)\n  {\n    return\n      _getLendingProtocolAdapter(_lendingPoolAddress)\n        .calculateProtectionBuyerAPR(_lendingPoolAddress);\n  }\n\n  /// @inheritdoc IReferenceLendingPools\n  function assessState()\n    public\n    view\n    override\n    returns (\n      address[] memory _lendingPools,\n      LendingPoolStatus[] memory _statuses\n    )\n  {\n    uint256 _length = lendingPools.length;\n    _lendingPools = new address[](_length);\n    _statuses = new LendingPoolStatus[](_length);\n\n    /// Iterate through all the lending pools in this basket and get their statuses\n    for (uint256 i; i < _length; ) {\n      _lendingPools[i] = lendingPools[i];\n      _statuses[i] = _getLendingPoolStatus(lendingPools[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /// @inheritdoc IReferenceLendingPools\n  function calculateRemainingPrincipal(\n    address _lendingPool,\n    address _lender,\n    uint256 _nftLpTokenId\n  )\n    public\n    view\n    override\n    whenLendingPoolSupported(_lendingPool)\n    returns (uint256)\n  {\n    return\n      _getLendingProtocolAdapter(_lendingPool).calculateRemainingPrincipal(\n        _lendingPool,\n        _lender,\n        _nftLpTokenId\n      );\n  }\n\n  /// @inheritdoc IReferenceLendingPools\n  function getLatestPaymentTimestamp(address _lendingPool)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    return\n      _getLendingProtocolAdapter(_lendingPool).getLatestPaymentTimestamp(\n        _lendingPool\n      );\n  }\n\n  /// @inheritdoc IReferenceLendingPools\n  function getPaymentPeriodInDays(address _lendingPool)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    return\n      _getLendingProtocolAdapter(_lendingPool).getPaymentPeriodInDays(\n        _lendingPool\n      );\n  }\n\n  /** internal functions */\n\n  /**\n   * @dev Adds a new reference lending pool to the basket if it is not already added.\n   */\n  function _addReferenceLendingPool(\n    address _lendingPoolAddress,\n    LendingProtocol _lendingPoolProtocol,\n    uint256 _protectionPurchaseLimitInDays\n  ) internal {\n    if (_lendingPoolAddress == Constants.ZERO_ADDRESS) {\n      revert ReferenceLendingPoolIsZeroAddress();\n    }\n\n    if (_isReferenceLendingPoolAdded(_lendingPoolAddress)) {\n      revert ReferenceLendingPoolAlreadyAdded(_lendingPoolAddress);\n    }\n\n    uint256 _protectionPurchaseLimitTimestamp = block.timestamp +\n      (_protectionPurchaseLimitInDays * Constants.SECONDS_IN_DAY_UINT);\n\n    /// add the underlying lending pool to this basket\n    referenceLendingPools[_lendingPoolAddress] = ReferenceLendingPoolInfo({\n      protocol: _lendingPoolProtocol,\n      addedTimestamp: block.timestamp,\n      protectionPurchaseLimitTimestamp: _protectionPurchaseLimitTimestamp\n    });\n    lendingPools.push(_lendingPoolAddress);\n\n    LendingPoolStatus _poolStatus = _getLendingPoolStatus(_lendingPoolAddress);\n    if (_poolStatus != LendingPoolStatus.Active) {\n      revert ReferenceLendingPoolIsNotActive(_lendingPoolAddress);\n    }\n\n    emit ReferenceLendingPoolAdded(\n      _lendingPoolAddress,\n      _lendingPoolProtocol,\n      block.timestamp,\n      _protectionPurchaseLimitTimestamp\n    );\n  }\n\n  /// @dev Returns the lending protocol adapter for the given lending pool address\n  function _getLendingProtocolAdapter(address _lendingPoolAddress)\n    internal\n    view\n    returns (ILendingProtocolAdapter)\n  {\n    return\n      lendingProtocolAdapterFactory.getLendingProtocolAdapter(\n        referenceLendingPools[_lendingPoolAddress].protocol\n      );\n  }\n\n  /// @dev Specifies whether the given lending pool is added to the basket or not\n  function _isReferenceLendingPoolAdded(address _lendingPoolAddress)\n    internal\n    view\n    returns (bool)\n  {\n    return referenceLendingPools[_lendingPoolAddress].addedTimestamp != 0;\n  }\n\n  /// @dev Returns the status of the given lending pool\n  function _getLendingPoolStatus(address _lendingPoolAddress)\n    internal\n    view\n    returns (LendingPoolStatus)\n  {\n    if (!_isReferenceLendingPoolAdded(_lendingPoolAddress)) {\n      return LendingPoolStatus.NotSupported;\n    }\n\n    ILendingProtocolAdapter _adapter = _getLendingProtocolAdapter(\n      _lendingPoolAddress\n    );\n\n    if (_adapter.isLendingPoolExpired(_lendingPoolAddress)) {\n      return LendingPoolStatus.Expired;\n    }\n\n    if (\n      _adapter.isLendingPoolLateWithinGracePeriod(\n        _lendingPoolAddress,\n        Constants.LATE_PAYMENT_GRACE_PERIOD_IN_DAYS\n      )\n    ) {\n      return LendingPoolStatus.LateWithinGracePeriod;\n    }\n\n    if (_adapter.isLendingPoolLate(_lendingPoolAddress)) {\n      return LendingPoolStatus.Late;\n    }\n\n    return LendingPoolStatus.Active;\n  }\n}"
    },
    {
      "filename": "contracts/core/pool/ReferenceLendingPools.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {UUPSUpgradeableBase} from \"../../UUPSUpgradeableBase.sol\";\n\nimport {IReferenceLendingPools, LendingPoolStatus, LendingProtocol, ProtectionPurchaseParams, ReferenceLendingPoolInfo} from \"../../interfaces/IReferenceLendingPools.sol\";\nimport {ILendingProtocolAdapter} from \"../../interfaces/ILendingProtocolAdapter.sol\";\nimport {ILendingProtocolAdapterFactory} from \"../../interfaces/ILendingProtocolAdapterFactory.sol\";\n\nimport \"../../libraries/Constants.sol\";\n\n/**\n * @title ReferenceLendingPools\n * @author Carapace Finance\n * @notice ReferenceLendingPools manages the basket of reference lending pools,\n * against which the carapace protocol can provide the protection.\n *\n * @dev This contract is upgradeable using the UUPS pattern.\n */\ncontract ReferenceLendingPools is UUPSUpgradeableBase, IReferenceLendingPools {\n  /////////////////////////////////////////////////////\n  ///             STORAGE - START                   ///\n  /////////////////////////////////////////////////////\n  /**\n   * @dev DO NOT CHANGE THE ORDER OF THESE VARIABLES ONCE DEPLOYED\n   */\n\n  /// @notice the lending protocol adapter factory\n  ILendingProtocolAdapterFactory private lendingProtocolAdapterFactory;\n\n  /// @notice the mapping of the lending pool address to the lending pool info\n  mapping(address => ReferenceLendingPoolInfo) public referenceLendingPools;\n\n  /// @notice an array of all the added lending pools in this basket\n  address[] private lendingPools;\n\n  //////////////////////"
    }
  ]
}