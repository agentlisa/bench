{
  "Title": "[M-02] Coding logic of the contract upgrading renders upgrading contracts impractical",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-12-gogopool/blob/main/contracts/contract/ProtocolDAO.sol#L209-L216\n\n\n# Vulnerability details\n\n\n## Impact\n\n[Link to original code](https://github.com/code-423n4/2022-12-gogopool/blob/main/contracts/contract/ProtocolDAO.sol#L209-L216)\n```solidity\nFile: https://github.com/code-423n4/2022-12-gogopool/blob/main/contracts/contract/ProtocolDAO.sol\n\n205\t/// @notice Upgrade a contract by unregistering the existing address, and registring a new address and name\n\t/// @param newAddr Address of the new contract\n\t/// @param newName Name of the new contract\n\t/// @param existingAddr Address of the existing contract to be deleted\n209\tfunction upgradeExistingContract(\n\t\t\taddress newAddr,\n\t\t\tstring memory newName,\n\t\t\taddress existingAddr\n\t\t) external onlyGuardian {\n\t\t\tregisterContract(newAddr, newName);\n\t\t\tunregisterContract(existingAddr);\n216\t}\n```\n\nFunction `ProtocolDAO.upgradeExistingContract` handles contract upgrading. However, there are multiple implicaitons of the coding logic in the function, which render the contract upgrading impractical.\n\n**Implication 1**:\nThe above function `upgradeExistingContract` registers the upgraded contract first, then unregisters the existing contract. This leads to the requirement that the upgraded contract name **must be different from** the existing contract name. Otherwise the updated contract address returned by `Storage.getAddress(keccak256(abi.encodePacked(\"contract.address\", contractName)))` will be `address(0)` (please refer to the below POC Testcase 1). This is because if the upgraded contract uses the original name (i.e. the contract name is not changed), function call  `unregisterContract(existingAddr)` in the `upgradeExistingContract` will override the registered contract address in `Storage` to address(0) due to the use of the same contract name.\n\nSince using the same name after upgrading will run into trouble with current coding logic, a safeguard should be in place to make sure two names are really different. For example, put this statement in the `upgradeExistingContract` function: \n`require(newName != existingName, \"Name not changed\");`, where `existingName` can be obtained using: \n`string memory existingName = store.getString(keccak256(abi.encodePacked(\"contract.name\", existingAddr)));`.\n\n**Implication 2**:\nIf we really want a different name for an upgraded contract, we then get into more serious troubles: We have to upgrade other contracts that reference the upgraded contract since contract names are referenced mostly hardcoded (for security considerations). This may lead to a very complicated issue because contracts are cross-referenced.\nFor example, contract `ClaimNodeOp` references contracts `RewardsPool`, `ProtocolDAO` and `Staking`. At the same time, contract `ClaimNodeOp` is referenced by contracts `RewardsPool` and `Staking`. This means that:\n1. If contract `ClaimNodeOp` was upgraded, which means the contract name `ClaimNodeOp` was changed;\n2. This requires contracts `RewardsPool` and `Staking` to be upgraded (with new names) in order to correctly reference to newly named `ClaimNodeOp` contract;\n3. This further requires those contracts that reference `RewardsPool` or `Staking` to be upgraded in order to correctly reference them;\n4. and this further requires those contracts that reference the above upgraded contracts to be upgraded ...\n5. This may lead to complicated code management issue and expose new vulnerabilites due to possible incomplete code adaptation.\n6. This may render the contracts upgrading impractical.\n\nI rate this issue as high severity due to the fact that:\nContract upgradability is one of the main features of the whole system design (all other contracts are designed upgradable except for `TokenGGP`, `Storage` and `Vault` ). However, the current `upgradeExistingContract` function's coding logic requires the upgraded contract must change its name (refer to the below Testcase 1). This inturn requires to upgrade all relevant cross-referenced contracts (refer to the below Testcase 2). Thus leading to a quite serous code management issue while upgrading contracts, and renders upgrading contracts impractical. \n\n## Proof of Concept\n\n**Testcase 1**: This testcase demonstrates that current coding logic of upgrading contracts requires: **the upgraded contract must change its name**. Otherwise contract upgrading will run into issue.\nPut the below test case in file `ProtocolDAO.t.sol`. The test case demonstrates that `ProtocolDAO.upgradeExistingContract` does not function properly if the upgraded contract does not change the name. That is: the upgraded contract address returned by `Storage.getAddress(keccak256(abi.encodePacked(\"contract.address\", contractName)))` will be `address(0)` if its name unchanged.\n```solidity\n\tfunction testUpgradeExistingContractWithNameUnchanged() public {\n\t\taddress addr = randAddress();\n\t\tstring memory name = \"existingName\";\n\n\t\taddress existingAddr = randAddress();\n\t\tstring memory existingName = \"existingName\";\n\n\t\tvm.prank(guardian);\n\t\tdao.registerContract(existingAddr, existingName);\n\t\tassertEq(store.getBool(keccak256(abi.encodePacked(\"contract.exists\", existingAddr))), true);\n\t\tassertEq(store.getAddress(keccak256(abi.encodePacked(\"contract.address\", existingName))), existingAddr);\n\t\tassertEq(store.getString(keccak256(abi.encodePacked(\"contract.name\", existingAddr))), existingName);\n\n\t\tvm.prank(guardian);\n\t\t//@audit upgrade contract while name unchanged\n\t\tdao.upgradeExistingContract(addr, name, existingAddr);\n\t\tassertEq(store.getBool(keccak256(abi.encodePacked(\"contract.exists\", addr))), true);\n\t\t//@audit the registered address was deleted by function call `PtotocolDAO.unregisterContract(existingAddr)`\n\t\tassertEq(store.getAddress(keccak256(abi.encodePacked(\"contract.address\", name))), address(0));\n\t\tassertEq(store.getString(keccak256(abi.encodePacked(\"contract.name\", addr))), name);\n\n               //@audit verify that the old contract has been de-registered\n\t\tassertEq(store.getBool(keccak256(abi.encodePacked(\"contract.exists\", existingAddr))), false);\n\t\tassertEq(store.getAddress(keccak256(abi.encodePacked(\"contract.address\", existingName))), address(0));\n\t\tassertEq(store.getString(keccak256(abi.encodePacked(\"contract.name\", existingAddr))), \"\");\n\t}\n```\n\n**Testcase 2**: This testcase demonstrates that current coding logic of upgrading contracts requires: **in order to upgrade a single contract, all cross-referenced contracts have to be upgraded and change their names**. Otherwise, other contracts will run into issues.\nIf the upgraded contract does change its name, contract upgrading will succeed. However, other contracts' functions that reference the upgraded contract will fail due to referencing hardcoded contract name. \nThe below testcase upgrades contract `ClaimNodeOp` to `ClaimNodeOpV2`. Then, contract `Staking` calls `increaseGGPRewards` which references hardcoded contract name `ClaimNodeOp` in its modifier. The call is failed.\n\nTest steps:\n1. Copy contract file `ClaimNodeOp.sol` to `ClaimNodeOpV2.sol`, and rename the contract name from `ClaimNodeOp` to `ClaimNodeOpV2` in file  `ClaimNodeOpV2.sol`;\n2. Put the below test file `UpgradeContractIssue.t.sol` under folder `test/unit/`;\n3. Run the test.\n**Note**: In order to test actual function call after upgrading contract, this testcase upgrades a real contract `ClaimNodeOp`. This is different from the above Testcase 1 which uses a random address to simulate a contract.\n```solidity\n// File: UpgradeContractIssue.t.sol\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport \"./utils/BaseTest.sol\";\nimport {ClaimNodeOpV2} from \"../../contracts/contract/ClaimNodeOpV2.sol\";\nimport {BaseAbstract} from \"../../contracts/contract/BaseAbstract.sol\";\n\ncontract UpgradeContractIssueTest is BaseTest {\n\tusing FixedPointMathLib for uint256;\n\n\taddress private nodeOp1;\n\n\tuint256 internal constant TOTAL_INITIAL_GGP_SUPPLY = 22_500_000 ether;\n\n\tfunction setUp() public override {\n\t\tsuper.setUp();\n\n\t\tnodeOp1 = getActorWithTokens(\"nodeOp1\", MAX_AMT, MAX_AMT);\n\t\tvm.prank(nodeOp1);\n\t\tggp.approve(address(staking), MAX_AMT);\n\t\tfundGGPRewardsPool();\n\t}\n\n\tfunction fundGGPRewardsPool() public {\n\t\t// guardian is minted 100% of the supply\n\t\tvm.startPrank(guardian);\n\t\tuint256 rewardsPoolAmt = TOTAL_INITIAL_GGP_SUPPLY.mulWadDown(.20 ether);\n\t\tggp.approve(address(vault), rewardsPoolAmt);\n\t\tvault.depositToken(\"RewardsPool\", ggp, rewardsPoolAmt);\n\t\tvm.stopPrank();\n\t}\n\n\tfunction testUpgradeExistingContractWithNameChanged() public {\n\t\t\n\t\tvm.prank(nodeOp1);\n\t\tstaking.stakeGGP(10 ether);\n\n                //@audit increase GGPRewards before upgrading contract - succeed\n\t\tvm.prank(address(nopClaim));\n\t\tstaking.increaseGGPRewards(address(nodeOp1), 10 ether);\n\t\tassert(staking.getGGPRewards(address(nodeOp1)) == 10 ether);\n\n\t\t//@audit Start to upgrade contract ClaimNodeOp to ClaimNodeOpV2\n\t\t\n\t\tvm.startPrank(guardian);\n\t\t//@audit upgrad contract\n\t\tClaimNodeOpV2 nopClaimV2 = new ClaimNodeOpV2(store, ggp);\n\t\taddress addr = address(nopClaimV2);\n\t\t//@audit contract name must be changed due to the limitation of `upgradeExistingContract` coding logic\n\t\tstring memory name = \"ClaimNodeOpV2\";\n\n\t\t//@audit get existing contract ClaimNodeOp info\n\t\taddress existingAddr = address(nopClaim);\n\t\tstring memory existingName = \"ClaimNodeOp\";\n\t\t\n\t\t//@audit the existing contract should be already registered. Verify its info.\n\t\tassertEq(store.getBool(keccak256(abi.encodePacked(\"contract.exists\", existingAddr))), true);\n\t\tassertEq(store.getAddress(keccak256(abi.encodePacked(\"contract.address\", existingName))), existingAddr);\n\t\tassertEq(store.getString(keccak256(abi.encodePacked(\"contract.name\", existingAddr))), existingName);\n\n                //@audit Upgrade contract\n\t\tdao.upgradeExistingContract(addr, name, existingAddr);\n\t\t\n\t\t//@audit verify that the upgraded contract has correct contract info registered\n\t\tassertEq(store.getBool(keccak256(abi.encodePacked(\"contract.exists\", addr))), true);\n\t\tassertEq(store.getAddress(keccak256(abi.encodePacked(\"contract.address\", name))), addr);\n\t\tassertEq(store.getString(keccak256(abi.encodePacked(\"contract.name\", addr))), name);\n\n\t\t//@audit verify that the old contract has been de-registered\n\t\tassertEq(store.getBool(keccak256(abi.encodePacked(\"contract.exists\", existingAddr))), false);\n\t\tassertEq(store.getAddress(keccak256(abi.encodePacked(\"contract.address\", existingName))), address(0));\n\t\tassertEq(store.getString(keccak256(abi.encodePacked(\"contract.name\", existingAddr))), \"\");\n\t\tvm.stopPrank();\n\n\t\tvm.prank(nodeOp1);\n\t\tstaking.stakeGGP(10 ether);\n\n                //@audit increase GGPRewards after upgrading contract ClaimNodeOp to ClaimNodeOpV2\n\t\tvm.prank(address(nopClaimV2)); //@audit using the upgraded contract\n\t\tvm.expectRevert(BaseAbstract.InvalidOrOutdatedContract.selector);\n\t\t//@audit revert due to contract Staking using hardcoded contract name \"ClaimNodeOp\" in the modifier\n\t\tstaking.increaseGGPRewards(address(nodeOp1), 10 ether);\n\t}\n}\n\n```\n\n## Tools Used\nManual code review\n\n## Recommended Mitigation Steps\n\n1. Upgrading contract does not have to change contranct names especially in such a complicated system wherein contracts are cross-referenced in a hardcoded way. I would suggest not to change contract names when upgrading contracts.\n2. In function `upgradeExistingContract` definition, swap fucnction call sequence between `registerContract()` and `unregisterContract()` so that contract names can keep unchanged after upgrading. That is, the modified function would be:\n```solidity\nFile: https://github.com/code-423n4/2022-12-gogopool/blob/main/contracts/contract/ProtocolDAO.sol\n\n205\t/// @notice Upgrade a contract by unregistering the existing address, and registring a new address and name\n\t/// @param newAddr Address of the new contract\n\t/// @param newName Name of the new contract\n\t/// @param existingAddr Address of the existing contract to be deleted\n209\tfunction upgradeExistingContract(\n\t\t\taddress newAddr,\n\t\t\tstring memory newName,  //@audit this `newName` parameter can be removed if upgrading don't change contract name\n\t\t\taddress existingAddr\n\t\t) external onlyGuardian {\n  \t\tunregisterContract(existingAddr);  //@audit unregister the existing contract first\n\t\tregisterContract(newAddr, newName);  //@audit then register the upgraded contract\n216\t}\n```\n\n**POC of Mitigation**:\n\nAfter the above recommended mitigation, the below Testcase vefifies that after upgrading contracts, other contract's functions, which reference the hardcoded contract name, can still opetate correctly.\n\n1. Make the above recommended mitigation in function `ProtocolDAO.upgradeExistingContract`;\n2. Put the below test file `UpgradeContractImproved.t.sol` under folder `test/unit/`;\n3. Run the test.\n**Note**: Since we don't change the upgraded contract name, for testing purpose, we just need to create a new contract instance (so that the contract instance address is changed) to simulate the contract upgrading.\n```solidity\n\t// File: UpgradeContractImproved.t.sol\n\t// SPDX-License-Identifier: GPL-3.0-only\n\tpragma solidity 0.8.17;\n\n\timport \"./utils/BaseTest.sol\";\n\timport {ClaimNodeOp} from \"../../contracts/contract/ClaimNodeOp.sol\";\n\timport {BaseAbstract} from \"../../contracts/contract/BaseAbstract.sol\";\n\n\tcontract UpgradeContractImprovedTest is BaseTest {\n\t\tusing FixedPointMathLib for uint256;\n\n\t\taddress private nodeOp1;\n\n\t\tuint256 internal constant TOTAL_INITIAL_GGP_SUPPLY = 22_500_000 ether;\n\n\t\tfunction setUp() public override {\n\t\t\tsuper.setUp();\n\n\t\t\tnodeOp1 = getActorWithTokens(\"nodeOp1\", MAX_AMT, MAX_AMT);\n\t\t\tvm.prank(nodeOp1);\n\t\t\tggp.approve(address(staking), MAX_AMT);\n\t\t\tfundGGPRewardsPool();\n\t\t}\n\n\t\tfunction fundGGPRewardsPool() public {\n\t\t\t// guardian is minted 100% of the supply\n\t\t\tvm.startPrank(guardian);\n\t\t\tuint256 rewardsPoolAmt = TOTAL_INITIAL_GGP_SUPPLY.mulWadDown(.20 ether);\n\t\t\tggp.approve(address(vault), rewardsPoolAmt);\n\t\t\tvault.depositToken(\"RewardsPool\", ggp, rewardsPoolAmt);\n\t\t\tvm.stopPrank();\n\t\t}\n\n\t\tfunction testUpgradeContractCorrectlyWithNameUnChanged() public {\n\t\t\t//@audit increase GGPRewards before upgrading contract - no problem\n\t\t\tvm.prank(nodeOp1);\n\t\t\tstaking.stakeGGP(10 ether);\n\n\t\t\tvm.prank(address(nopClaim));\n\t\t\tstaking.increaseGGPRewards(address(nodeOp1), 10 ether);\n\t\t\tassert(staking.getGGPRewards(address(nodeOp1)) == 10 ether);\n\n\t\t\t//@audit Start to upgrade contract ClaimNodeOp\n\t\t\tvm.startPrank(guardian);\n\t\t\t//@audit upgraded contract by creating a new contract instance\n\t\t\tClaimNodeOp nopClaimV2 = new ClaimNodeOp(store, ggp);\n\t\t\taddress addr = address(nopClaimV2);\n\t\t\t//@audit contract name is not changed!\n\t\t\tstring memory name = \"ClaimNodeOp\";\n\n\t\t\t//@audit get existing contract info\n\t\t\taddress existingAddr = address(nopClaim);\n\t\t\tstring memory existingName = \"ClaimNodeOp\";\n\n\t\t\t//@audit new contract address is different from the old one\n\t\t\tassertFalse(addr == existingAddr);\n\t\t\t\n\t\t\t//@audit the existing contract should be already registered. Verify its info.\n\t\t\tassertEq(store.getBool(keccak256(abi.encodePacked(\"contract.exists\", existingAddr))), true);\n\t\t\tassertEq(store.getAddress(keccak256(abi.encodePacked(\"contract.address\", existingName))), existingAddr);\n\t\t\tassertEq(store.getString(keccak256(abi.encodePacked(\"contract.name\", existingAddr))), existingName);\n\n                        //@audit Upgrade contract\n\t\t\tdao.upgradeExistingContract(addr, name, existingAddr);\n\t\t\t\n\t\t\t//@audit verify the upgraded contract has correct contract info registered\n\t\t\tassertEq(store.getBool(keccak256(abi.encodePacked(\"contract.exists\", addr))), true);\n\t\t\tassertEq(store.getAddress(keccak256(abi.encodePacked(\"contract.address\", name))), addr);\n\t\t\tassertEq(store.getString(keccak256(abi.encodePacked(\"contract.name\", addr))), name);\n\n\t\t\t//@audit verify that the old contract has been de-registered\n\t\t\tassertEq(store.getBool(keccak256(abi.encodePacked(\"contract.exists\", existingAddr))), false);\n\t\t\tassertEq(store.getString(keccak256(abi.encodePacked(\"contract.name\", existingAddr))), \"\");\n\t\t\t//@audit The contract has new address now. Note that: existingName == name\n\t\t\tassertEq(store.getAddress(keccak256(abi.encodePacked(\"contract.address\", existingName))), addr);\n\t\t\tvm.stopPrank();\n\n\t\t\t//@audit increase GGPRewards after upgrading contract ClaimNodeOp to ClaimNodeOpV2\n\t\t\tvm.prank(nodeOp1);\n\t\t\tstaking.stakeGGP(10 ether);\n\n\t\t\tvm.prank(address(nopClaimV2)); //@audit using the new contract\n\t\t\t//@audit Successfully call the below function with hardcoded contract name \"ClaimNodeOp\" in the modifier\n\t\t\tstaking.increaseGGPRewards(address(nodeOp1), 10 ether);\n\t\t\t//@audit Successfully increased!\n\t\t\tassert(staking.getGGPRewards(address(nodeOp1)) == 20 ether);\n\t\t}\n\t}\n\n```\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-gogopool-contest",
  "Code": [
    {
      "filename": "contracts/contract/ProtocolDAO.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport \"./Base.sol\";\nimport {TokenGGP} from \"./tokens/TokenGGP.sol\";\nimport {Storage} from \"./Storage.sol\";\n\n/// @title Settings for the Protocol\ncontract ProtocolDAO is Base {\n\terror ValueNotWithinRange();\n\n\tmodifier valueNotGreaterThanOne(uint256 setterValue) {\n\t\tif (setterValue > 1 ether) {\n\t\t\trevert ValueNotWithinRange();\n\t\t}\n\t\t_;\n\t}\n\n\tconstructor(Storage storageAddress) Base(storageAddress) {\n\t\tversion = 1;\n\t}\n\n\tfunction initialize() external onlyGuardian {\n\t\tif (getBool(keccak256(\"ProtocolDAO.initialized\"))) {\n\t\t\treturn;\n\t\t}\n\t\tsetBool(keccak256(\"ProtocolDAO.initialized\"), true);\n\n\t\t// ClaimNodeOp\n\t\tsetUint(keccak256(\"ProtocolDAO.RewardsEligibilityMinSeconds\"), 14 days);\n\n\t\t// RewardsPool\n\t\tsetUint(keccak256(\"ProtocolDAO.RewardsCycleSeconds\"), 28 days); // The time in which a claim period will span in seconds - 28 days by default\n\t\tsetUint(keccak256(\"ProtocolDAO.TotalGGPCirculatingSupply\"), 18_000_000 ether);\n\t\tsetUint(keccak256(\"ProtocolDAO.ClaimingContractPct.ClaimMultisig\"), 0.20 ether);\n\t\tsetUint(keccak256(\"ProtocolDAO.ClaimingContractPct.ClaimNodeOp\"), 0.70 ether);\n\t\tsetUint(keccak256(\"ProtocolDAO.ClaimingContractPct.ClaimProtocolDAO\"), 0.10 ether);\n\n\t\t// GGP Inflation\n\t\tsetUint(keccak256(\"ProtocolDAO.InflationIntervalSeconds\"), 1 days);\n\t\tsetUint(keccak256(\"ProtocolDAO.InflationIntervalRate\"), 1000133680617113500); // 5% annual calculated on a daily interval - Calculate in js example: let dailyInflation = web3.utils.toBN((1 + 0.05) ** (1 / (365)) * 1e18);\n\n\t\t// TokenGGAVAX\n\t\tsetUint(keccak256(\"ProtocolDAO.TargetGGAVAXReserveRate\"), 0.1 ether); // 10% collateral held in reserve\n\n\t\t// Minipool\n\t\tsetUint(keccak256(\"ProtocolDAO.MinipoolMinAVAXStakingAmt\"), 2_000 ether);\n\t\tsetUint(keccak256(\"ProtocolDAO.MinipoolNodeCommissionFeePct\"), 0.15 ether);\n\t\tsetUint(keccak256(\"ProtocolDAO.MinipoolMaxAVAXAssignment\"), 10_000 ether);\n\t\tsetUint(keccak256(\"ProtocolDAO.MinipoolMinAVAXAssignment\"), 1_000 ether);\n\t\tsetUint(keccak256(\"ProtocolDAO.ExpectedAVAXRewardsRate\"), 0.1 ether); // Annual rate as pct of 1 avax\n\t\tsetUint(keccak256(\"ProtocolDAO.MinipoolCancelMoratoriumSeconds\"), 5 days);\n\n\t\t// Staking\n\t\tsetUint(keccak256(\"ProtocolDAO.MaxCollateralizationRatio\"), 1.5 ether);\n\t\tsetUint(keccak256(\"ProtocolDAO.MinCollateralizationRatio\"), 0.1 ether);\n\t}\n\n\t/// @notice Get if a contract is paused\n\t/// @param contractName The contract that is being checked\n\tfunction getContractPaused(string memory contractName) public view returns (bool) {\n\t\treturn getBool(keccak256(abi.encodePacked(\"contract.paused\", contractName)));\n\t}\n\n\t/// @notice Pause a contract\n\t/// @param contractName The contract whose actions should be paused\n\tfunction pauseContract(string memory contractName) public onlySpecificRegisteredContract(\"Ocyticus\", msg.sender) {\n\t\tsetBool(keccak256(abi.encodePacked(\"contract.paused\", contractName)), true);\n\t}\n\n\t/// @notice Unpause a contract\n\t/// @param contractName The contract whose actions should be resumed\n\tfunction resumeContract(string memory contractName) public onlySpecificRegisteredContract(\"Ocyticus\", msg.sender) {\n\t\tsetBool(keccak256(abi.encodePacked(\"contract.paused\", contractName)), false);\n\t}\n\n\t// *** Rewards Pool ***\n\n\t/// @notice Get how many seconds a node must be registered for rewards to be eligible for the rewards cycle\n\t/// @return uint256 The min number of seconds to be considered eligible\n\tfunction getRewardsEligibilityMinSeconds() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"ProtocolDAO.RewardsEligibilityMinSeconds\"));\n\t}\n\n\t/// @notice Get how many seconds in a rewards cycle\n\tfunction getRewardsCycleSeconds() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"ProtocolDAO.RewardsCycleSeconds\"));\n\t}\n\n\t/// @notice The total amount of GGP that is in circulation\n\tfunction getTotalGGPCirculatingSupply() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"ProtocolDAO.TotalGGPCirculatingSupply\"));\n\t}\n\n\t/// @notice Set the amount of GGP that is in circulation\n\tfunction setTotalGGPCirculatingSupply(uint256 amount) public onlySpecificRegisteredContract(\"RewardsPool\", msg.sender) {\n\t\treturn setUint(keccak256(\"ProtocolDAO.TotalGGPCirculatingSupply\"), amount);\n\t}\n\n\t/// @notice The percentage a contract is owed for a rewards cycle\n\t/// @return uint256 Rewards percentage a contract will receive this cycle\n\tfunction getClaimingContractPct(string memory claimingContract) public view returns (uint256) {\n\t\treturn getUint(keccak256(abi.encodePacked(\"ProtocolDAO.ClaimingContractPct.\", claimingContract)));\n\t}\n\n\t/// @notice Set the percentage a contract is owed for a rewards cycle\n\tfunction setClaimingContractPct(string memory claimingContract, uint256 decimal) public onlyGuardian valueNotGreaterThanOne(decimal) {\n\t\tsetUint(keccak256(abi.encodePacked(\"ProtocolDAO.ClaimingContractPct.\", claimingContract)), decimal);\n\t}\n\n\t// *** GGP Inflation ***\n\n\t/// @notice The current inflation rate per interval (eg 1000133680617113500 = 5% annual)\n\t/// @return uint256 The current inflation rate per interval (can never be < 1 ether)\n\tfunction getInflationIntervalRate() external view returns (uint256) {\n\t\t// Inflation rate controlled by the DAO\n\t\tuint256 rate = getUint(keccak256(\"ProtocolDAO.InflationIntervalRate\"));\n\t\treturn rate < 1 ether ? 1 ether : rate;\n\t}\n\n\t/// @notice How many seconds to calculate inflation at\n\t/// @return uint256 how many seconds to calculate inflation at\n\tfunction getInflationIntervalSeconds() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"ProtocolDAO.InflationIntervalSeconds\"));\n\t}\n\n\t// *** Minipool Settings ***\n\n\t/// @notice The min AVAX staking amount that is required for creating a minipool\n\tfunction getMinipoolMinAVAXStakingAmt() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"ProtocolDAO.MinipoolMinAVAXStakingAmt\"));\n\t}\n\n\t/// @notice The node commision fee for running the hardware for the minipool\n\tfunction getMinipoolNodeCommissionFeePct() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"ProtocolDAO.MinipoolNodeCommissionFeePct\"));\n\t}\n\n\t/// @notice Maximum AVAX a Node Operator can be assigned from liquid staking funds\n\tfunction getMinipoolMaxAVAXAssignment() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"ProtocolDAO.MinipoolMaxAVAXAssignment\"));\n\t}\n\n\t/// @notice Minimum AVAX a Node Operator can be assigned from liquid staking funds\n\tfunction getMinipoolMinAVAXAssignment() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"ProtocolDAO.MinipoolMinAVAXAssignment\"));\n\t}\n\n\t/// @notice The user must wait this amount of time before they can cancel their minipool\n\tfunction getMinipoolCancelMoratoriumSeconds() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"ProtocolDAO.MinipoolCancelMoratoriumSeconds\"));\n\t}\n\n\t/// @notice Set the rewards rate for validating Avalanche's p-chain\n\t/// @dev Used for testing\n\tfunction setExpectedAVAXRewardsRate(uint256 rate) public onlyMultisig valueNotGreaterThanOne(rate) {\n\t\tsetUint(keccak256(\"ProtocolDAO.ExpectedAVAXRewardsRate\"), rate);\n\t}\n\n\t/// @notice The expected rewards rate for validating Avalanche's P-chain\n\tfunction getExpectedAVAXRewardsRate() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"ProtocolDAO.ExpectedAVAXRewardsRate\"));\n\t}\n\n\t//*** Staking ***\n\n\t/// @notice The max collateralization ratio of GGP to Assigned AVAX eligible for rewards\n\tfunction getMaxCollateralizationRatio() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"ProtocolDAO.MaxCollateralizationRatio\"));\n\t}\n\n\t/// @notice The min collateralization ratio of GGP to Assigned AVAX eligible for rewards or minipool creation\n\tfunction getMinCollateralizationRatio() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"ProtocolDAO.MinCollateralizationRatio\"));\n\t}\n\n\t/// @notice The target percentage of ggAVAX to hold in TokenggAVAX contract\n\t/// \t1 ether = 100%\n\t/// \t0.1 ether = 10%\n\t/// @return uint256 The current target reserve rate\n\tfunction getTargetGGAVAXReserveRate() external view returns (uint256) {\n\t\treturn getUint(keccak256(\"ProtocolDAO.TargetGGAVAXReserveRate\"));\n\t}\n\n\t//*** Contract Registration ***\n\n\t/// @notice Register a new contract with Storage\n\t/// @param addr Contract address to register\n\t/// @param name Contract name to register\n\tfunction registerContract(address addr, string memory name) public onlyGuardian {\n\t\tsetBool(keccak256(abi.encodePacked(\"contract.exists\", addr)), true);\n\t\tsetAddress(keccak256(abi.encodePacked(\"contract.address\", name)), addr);\n\t\tsetString(keccak256(abi.encodePacked(\"contract.name\", addr)), name);\n\t}\n\n\t/// @notice Unregister a contract with Storage\n\t/// @param addr Contract address to unregister\n\tfunction unregisterContract(address addr) public onlyGuardian {\n\t\tstring memory name = getContractName(addr);\n\t\tdeleteBool(keccak256(abi.encodePacked(\"contract.exists\", addr)));\n\t\tdeleteAddress(keccak256(abi.encodePacked(\"contract.address\", name)));\n\t\tdeleteString(keccak256(abi.encodePacked(\"contract.name\", addr)));\n\t}\n\n\t/// @notice Upgrade a contract by unregistering the existing address, and registring a new address and name\n\t/// @param newAddr Address of the new contract\n\t/// @param newName Name of the new contract\n\t/// @param existingAddr Address of the existing contract to be deleted\n\tfunction upgradeExistingContract(\n\t\taddress newAddr,\n\t\tstring memory newName,\n\t\taddress existingAddr\n\t) external onlyGuardian {\n\t\tregisterContract(newAddr, newName);\n\t\tunregisterContract(existingAddr);\n\t}\n}"
    }
  ]
}