{
  "Title": "3S-LENFT-N17 protocol/Lending/LoanCenter.sol: missing natspec comments & variable naming",
  "Content": "#### Description\nNatspec comments for [`createLoan()`](https://github.com/leNFT/contracts/blob/9ff315b6bcb384089252d02e4b91be73ec158c37/contracts/protocol/Lending/LoanCenter.sol#L78-L95) function is missing comment for `owner` argument\n\n#### Recommendation\n- Add comment describing `owner` argument\n- Additionally, change argument name, since `owner` can be confused with the contract owner of the `LoanCenter` (since the contract is Ownable and has a callable function `owner()` )",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/protocol/Lending/LoanCenter.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nimport {ILoanCenter} from \"../../interfaces/ILoanCenter.sol\";\nimport {PercentageMath} from \"../../libraries/utils/PercentageMath.sol\";\nimport {DataTypes} from \"../../libraries/types/DataTypes.sol\";\nimport {LoanLogic} from \"../../libraries/logic/LoanLogic.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IAddressProvider} from \"../../interfaces/IAddressProvider.sol\";\nimport {Trustus} from \"../../protocol/Trustus/Trustus.sol\";\nimport {SafeCast} from \"../../libraries/utils/SafeCast.sol\";\nimport {ILendingPool} from \"../../interfaces/ILendingPool.sol\";\n\n/// @title LoanCenter contract\n/// @author leNFT\n/// @notice Manages loans\n/// @dev Keeps the list of loans, their states and their liquidation data\ncontract LoanCenter is ILoanCenter, OwnableUpgradeable {\n    // NFT address + NFT ID to loan ID mapping\n    mapping(address => mapping(uint256 => uint256)) private _nftToLoanId;\n\n    // Loan ID to loan info mapping\n    mapping(uint256 => DataTypes.LoanData) private _loans;\n\n    // Loan id to liquidation data\n    mapping(uint256 => DataTypes.LoanLiquidationData)\n        private _loansLiquidationData;\n\n    uint256 private _loansCount;\n    IAddressProvider private _addressProvider;\n\n    // Collection to liquidation threshold\n    mapping(address => DataTypes.CollectionRiskParameters)\n        private _collectionsRiskParameters;\n\n    DataTypes.CollectionRiskParameters\n        private _defaultCollectionsRiskParameters;\n\n    // Mapping from address to active loans\n    mapping(address => uint256[]) private _activeLoans;\n\n    using LoanLogic for DataTypes.LoanData;\n\n    modifier onlyMarket() {\n        _requireOnlyMarket();\n        _;\n    }\n\n    modifier loanExists(uint256 loanId) {\n        _requireLoanExists(loanId);\n        _;\n    }\n\n    modifier loanAuctioned(uint256 loanId) {\n        _requireLoanAuctioned(loanId);\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract\n    /// @param addressProvider The address of the addressProvider contract\n    /// @param defaultCollectionsRiskParameters The default collection Risk Parameters\n    function initialize(\n        IAddressProvider addressProvider,\n        DataTypes.CollectionRiskParameters\n            calldata defaultCollectionsRiskParameters\n    ) external initializer {\n        __Ownable_init();\n        _addressProvider = addressProvider;\n        _defaultCollectionsRiskParameters = defaultCollectionsRiskParameters;\n    }\n\n    /// @notice Create a new loan with the specified parameters and add it to the loans list\n    /// @dev Only the market contract can call this function\n    /// @param pool The address of the lending pool\n    /// @param amount The amount of the lending pool token to be borrowed\n    /// @param genesisNFTId The ID of the genesis NFT\n    /// @param nftAddress The address of the NFT contract\n    /// @param nftTokenIds An array of NFT token IDs that will be used as collateral\n    /// @param borrowRate The interest rate for the loan\n    /// @return The ID of the newly created loan\n    function createLoan(\n        address owner,\n        address pool,\n        uint256 amount,\n        uint256 genesisNFTId,\n        address nftAddress,\n        uint256[] calldata nftTokenIds,\n        uint256 borrowRate\n    ) public override onlyMarket returns (uint256) {\n        // Create the loan and add it to the list\n        _loans[_loansCount].init(\n            owner,\n            pool,\n            amount,\n            genesisNFTId,\n            nftAddress,\n            nftTokenIds,\n            borrowRate\n        );\n\n        // Add NFT to loanId mapping\n        for (uint256 i = 0; i < nftTokenIds.length; i++) {\n            _nftToLoanId[nftAddress][nftTokenIds[i]] = _loansCount;\n        }\n\n        // Add loan to active loans\n        _activeLoans[owner].push(_loansCount);\n\n        // Increment the loans count and then return it\n        return _loansCount++;\n    }\n\n    /// @notice Activate a loan by setting its state to Active\n    /// @dev Only the market contract can call this function\n    /// @param loanId The ID of the loan to be activated\n    function activateLoan(uint256 loanId) external override onlyMarket {\n        // Update loan state\n        _loans[loanId].state = DataTypes.LoanState.Active;\n    }\n\n    /// @notice Repay a loan by setting its state to Repaid\n    /// @dev Only the market contract can call this function\n    /// @param loanId The ID of the loan to be repaid\n    function repayLoan(uint256 loanId) external override onlyMarket {\n        // Update loan state\n        _loans[loanId].state = DataTypes.LoanState.Repaid;\n\n        // Close the loan\n        _closeLoan(loanId);\n    }\n\n    /// @notice Liquidate a loan by setting its state to Liquidated and freeing up the NFT collateral pointers\n    /// @dev Only the market contract can call this function\n    /// @param loanId The ID of the loan to be liquidated\n    function liquidateLoan(uint256 loanId) external override onlyMarket {\n        // Update loan state\n        _loans[loanId].state = DataTypes.LoanState.Liquidated;\n\n        // Close the loan\n        _closeLoan(loanId);\n    }\n\n    /// @notice Auxiliary function to close the loan\n    /// @param loanId The ID of the loan to close\n    function _closeLoan(uint256 loanId) internal {\n        // Cache loan NFTs array\n        uint256[] memory loanTokenIds = _loans[loanId].nftTokenIds;\n        // Get loans nft mapping\n        address loanCollection = _loans[loanId].nftAsset;\n\n        // Remove nft to loan id mapping\n        for (uint256 i = 0; i < loanTokenIds.length; i++) {\n            delete _nftToLoanId[loanCollection][loanTokenIds[i]];\n        }\n\n        // Remove loan from user active loans\n        uint256[] memory userActiveLoans = _activeLoans[_loans[loanId].owner];\n        for (uint256 i = 0; i < userActiveLoans.length; i++) {\n            if (userActiveLoans[i] == loanId) {\n                _activeLoans[_loans[loanId].owner][i] = userActiveLoans[\n                    userActiveLoans.length - 1\n                ];\n                _activeLoans[_loans[loanId].owner].pop();\n                break;\n            }\n        }\n    }\n\n    /// @notice Start an auction for a loan\n    /// @dev Sets its state to Auctioned and creates the liquidation data\n    /// @dev Only the market contract can call this function\n    /// @param loanId The ID of the loan to be auctioned\n    /// @param user The address of the user who started the auction\n    /// @param bid The initial bid for the auction\n    function auctionLoan(\n        uint256 loanId,\n        address user,\n        uint256 bid\n    ) external override onlyMarket {\n        // Update state\n        _loans[loanId].state = DataTypes.LoanState.Auctioned;\n\n        // Create the liquidation data\n        _loansLiquidationData[loanId] = DataTypes.LoanLiquidationData({\n            auctioneer: user,\n            liquidator: user,\n            auctionStartTimestamp: SafeCast.toUint40(block.timestamp),\n            auctionMaxBid: bid\n        });\n    }\n\n    /// @notice Update the auction data for a loan\n    /// @dev Only the market contract can call this function\n    /// @param loanId The ID of the loan to be updated\n    /// @param user The address of the user who updated the auction\n    /// @param bid The new bid for the auction\n    function updateLoanAuctionBid(\n        uint256 loanId,\n        address user,\n        uint256 bid\n    ) external override onlyMarket {\n        // Update the liquidation data\n        _loansLiquidationData[loanId].liquidator = user;\n        _loansLiquidationData[loanId].auctionMaxBid = bid;\n    }\n\n    /// @notice Get the number of loans in the loans list\n    /// @return The number of loans\n    function getLoansCount() external view override returns (uint256) {\n        return _loansCount;\n    }\n\n    /// @notice Get the active loans for a user\n    /// @param user The address of the user\n    /// @return An array of loan IDs\n    function getUserActiveLoans(\n        address user\n    ) external view returns (uint256[] memory) {\n        return _activeLoans[user];\n    }\n\n    /// @notice Get a loan by its ID\n    /// @param loanId The ID of the loan to be retrieved\n    /// @return The loan data\n    function getLoan(\n        uint256 loanId\n    )\n        external\n        view\n        override\n        loanExists(loanId)\n        returns (DataTypes.LoanData memory)\n    {\n        return _loans[loanId];\n    }\n\n    /// @notice Get the liquidation data for a loan\n    /// @param loanId The loan ID associated with the liquidation data to be retrieved\n    function getLoanLiquidationData(\n        uint256 loanId\n    )\n        external\n        view\n        override\n        loanExists(loanId)\n        loanAuctioned(loanId)\n        returns (DataTypes.LoanLiquidationData memory)\n    {\n        return _loansLiquidationData[loanId];\n    }\n\n    /// @notice Get the maximum debt a loan can reach before entering the liquidation zone\n    /// @param loanId The ID of the loan to be queried\n    /// @param tokensPrice The price of the tokens collateralizing the loan\n    /// @return The maximum debt quoted in the same asset as the price of the collateral tokens\n    function getLoanMaxDebt(\n        uint256 loanId,\n        uint256 tokensPrice\n    ) external view override loanExists(loanId) returns (uint256) {\n        return\n            PercentageMath.percentMul(\n                tokensPrice,\n                getCollectionLiquidationThreshold(_loans[loanId].nftAsset)\n            );\n    }\n\n    /// @notice Get the loan ID associated with the specified NFT\n    /// @param nftAddress The address of the NFT contract\n    /// @param nftTokenId The ID of the NFT\n    /// @return The ID of the loan associated with the NFT\n    function getNFTLoanId(\n        address nftAddress,\n        uint256 nftTokenId\n    ) external view override returns (uint256) {\n        return _nftToLoanId[nftAddress][nftTokenId];\n    }\n\n    /// @notice Internal function to get the debt owed on a loan\n    /// @param loanId The ID of the loan\n    /// @return The total amount of debt owed on the loan\n    function _getLoanDebt(uint256 loanId) internal view returns (uint256) {\n        return\n            _loans[loanId].getInterest(block.timestamp) + _loans[loanId].amount;\n    }\n\n    /// @notice Get the debt owed on a loan\n    /// @param loanId The ID of the loan\n    /// @return The total amount of debt owed on the loan quoted in the same asset of the loan's lending pool\n    function getLoanDebt(\n        uint256 loanId\n    ) public view override loanExists(loanId) returns (uint256) {\n        return _getLoanDebt(loanId);\n    }\n\n    /// @notice Get the interest owed on a loan\n    /// @param loanId The ID of the loan\n    /// @return The amount of interest owed on the loan\n    function getLoanInterest(\n        uint256 loanId\n    ) external view override loanExists(loanId) returns (uint256) {\n        return _loans[loanId].getInterest(block.timestamp);\n    }\n\n    /// @notice Get the NFT token IDs associated with a loan\n    /// @param loanId The ID of the loan\n    /// @return An array of the NFT token IDs associated with the loan\n    function getLoanTokenIds(\n        uint256 loanId\n    ) external view override loanExists(loanId) returns (uint256[] memory) {\n        return _loans[loanId].nftTokenIds;\n    }\n\n    /// @notice Get the NFT contract address associated with a loan\n    /// @param loanId The ID of the loan\n    /// @return The address of the NFT contract associated with the loan\n    function getLoanCollectionAddress(\n        uint256 loanId\n    ) external view override loanExists(loanId) returns (address) {\n        return _loans[loanId].nftAsset;\n    }\n\n    /// @notice Get the lending pool address associated with a loan\n    /// @param loanId The ID of the loan\n    /// @return The address of the lending pool associated with the loan\n    function getLoanLendingPool(\n        uint256 loanId\n    ) external view override loanExists(loanId) returns (address) {\n        return _loans[loanId].pool;\n    }\n\n    /// @notice Get the state of a loan\n    /// @param loanId The ID of the loan\n    /// @return The state of the loan\n    function getLoanState(\n        uint256 loanId\n    ) external view override returns (DataTypes.LoanState) {\n        return _loans[loanId].state;\n    }\n\n    /// @notice Get auctioner fee for a repayment of an auctioned loan\n    /// @param loanId The ID of the loan\n    /// @return The auctioner fee\n    function getLoanAuctioneerFee(\n        uint256 loanId\n    ) external view loanExists(loanId) loanAuctioned(loanId) returns (uint256) {\n        return\n            PercentageMath.percentMul(\n                getLoanDebt(loanId),\n                ILendingPool(_loans[loanId].pool).getPoolConfig().auctioneerFee\n            );\n    }\n\n    /// @notice Get the owner of a loan\n    /// @param loanId The ID of the loan\n    /// @return The address of the owner of the loan\n    function getLoanOwner(\n        uint256 loanId\n    ) external view loanExists(loanId) returns (address) {\n        return _loans[loanId].owner;\n    }\n\n    /// @notice Updates the debt timestamp of a loan.\n    /// @param loanId The ID of the loan to update.\n    /// @param newDebtTimestamp The new debt timestamp to set.\n    function updateLoanDebtTimestamp(\n        uint256 loanId,\n        uint256 newDebtTimestamp\n    ) external override onlyMarket {\n        _loans[loanId].debtTimestamp = uint40(newDebtTimestamp);\n    }\n\n    /// @notice Updates the amount of a loan.\n    /// @param loanId The ID of the loan to update.\n    /// @param newAmount The new amount to set.\n    function updateLoanAmount(\n        uint256 loanId,\n        uint256 newAmount\n    ) external override onlyMarket {\n        _loans[loanId].amount = newAmount;\n    }\n\n    /// @notice Gets the Liquidation Threshold for a collection.\n    /// @param collection The address of the collection to get the max collaterization price for.\n    /// @return The Liquidation Threshold for the collection (10000 = 100%).\n    function getCollectionLiquidationThreshold(\n        address collection\n    ) public view override returns (uint256) {\n        if (_collectionsRiskParameters[collection].maxLTV == 0) {\n            return _defaultCollectionsRiskParameters.liquidationThreshold;\n        }\n        return _collectionsRiskParameters[collection].liquidationThreshold;\n    }\n\n    /// @notice Gets the Max LTV for a collection, this is the maximum amount of debt that can be taken out against a collection in a borrow operation.\n    /// @param collection The address of the collection to get the max collaterization price for.\n    /// @return The Max LTV for the collection (10000 = 100%).\n    function getCollectionMaxLTV(\n        address collection\n    ) external view override returns (uint256) {\n        if (_collectionsRiskParameters[collection].maxLTV == 0) {\n            return _defaultCollectionsRiskParameters.maxLTV;\n        }\n        return _collectionsRiskParameters[collection].maxLTV;\n    }\n\n    /// @notice Changes the Risk Parameters for a collection.\n    /// @param collection The address of the collection to change the max collaterization price for.\n    /// @param maxLTV The new max LTV to set (10000 = 100%).\n    /// @param liquidationThreshold The new liquidation Threshold to set (10000 = 100%).\n    function setCollectionRiskParameters(\n        address collection,\n        uint256 maxLTV,\n        uint256 liquidationThreshold\n    ) external onlyOwner {\n        //Set the max collaterization\n        _collectionsRiskParameters[collection] = DataTypes\n            .CollectionRiskParameters({\n                maxLTV: SafeCast.toUint16(maxLTV),\n                liquidationThreshold: SafeCast.toUint16(liquidationThreshold)\n            });\n    }\n\n    function _requireOnlyMarket() internal view {\n        require(\n            msg.sender == _addressProvider.getLendingMarket(),\n            \"LC:NOT_MARKET\"\n        );\n    }\n\n    function _requireLoanExists(uint256 loanId) internal view {\n        require(\n            _loans[loanId].state != DataTypes.LoanState.None,\n            \"LC:UNEXISTENT_LOAN\"\n        );\n    }\n\n    function _requireLoanAuctioned(uint256 loanId) internal view {\n        require(\n            _loans[loanId].state == DataTypes.LoanState.Auctioned,\n            \"LC:NOT_AUCTIONED\"\n        );\n    }\n}"
    }
  ]
}