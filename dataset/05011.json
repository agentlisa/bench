{
  "Title": "[06] `RouterSwapParams` lacks a deadlining logic and could lead to unfavourable swaps",
  "Content": "\n*Note: At the judgeâ€™s request [here](https://github.com/code-423n4/2024-03-revert-lend-findings/issues/128#issuecomment-2050761513), this downgraded issue from the same warden has been included in this report for completeness.*\n\nThe `RouterSwapParams` struct and the `_routerSwap` function currently do not include any parameters or logic to enforce a deadline for swap completion. This means there is no built-in mechanism to prevent a swap from occurring if the market conditions change unfavourably after the swap was initiated but before it was executed.\n\nSee [here](https://github.com/code-423n4/2024-03-revert-lend/blob/457230945a49878eefdc1001796b10638c1e7584/src/utils/Swapper.sol#L59-L77):\n\n```solidity\nstruct RouterSwapParams {\n    IERC20 tokenIn;\n    IERC20 tokenOut;\n    uint256 amountIn;\n    uint256 amountOutMin;\n    bytes swapData;\n}\n\nfunction _routerSwap(RouterSwapParams memory params)\n    internal\n    returns (uint256 amountInDelta, uint256 amountOutDelta)\n{\n    // Swap logic without deadline enforcement\n}\n```\n\nSwaps are executed without considering the time sensitivity of the operation, which is critical in a highly volatile market environment. The absence of a deadline parameter means that once initiated, a swap could theoretically be executed at any point in the future, regardless of how market conditions may have changed. Also note that whereas the slippage logic is already present to protect from returning less than the accepted minimum users could still get affected, take a look at this scenario:\n\nA swap is placed, `amountOutMin` is `100XYZ` tokens, as at the price of `1XYZ = $1`, swap stays for long in the mempool (during this period the price of `1XYZ` drops to `$0.8`), so now swap gets finalized, user received `100XYZ` tokens, but in reality they've lost 20% of their \"acceptable\" minimum value in dollars.\n\n### Impact\n\nThe lack of a deadline mechanism in the `RouterSwapParams` structure can lead to unfavourable outcomes for users, since having a `deadline` lets the caller specify a deadline parameter that enforces a time limit by which the transaction must be executed. Without a deadline parameter, the transaction may sit in the mempool and be executed at a much later time potentially resulting in a worse price for the user.\n\n### Recommended Mitigation Steps\n\nIntroduce a deadline parameter to the `RouterSwapParams` struct and apply it to swaps.\n\n## Assessed type\n\nContext\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2024-03-revert-lend-findings/issues/129).*\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-revert-lend",
  "Code": [
    {
      "filename": "src/utils/Swapper.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"v3-core/interfaces/callback/IUniswapV3SwapCallback.sol\";\nimport \"v3-core/interfaces/IUniswapV3Pool.sol\";\nimport \"v3-core/libraries/TickMath.sol\";\n\nimport \"v3-periphery/interfaces/INonfungiblePositionManager.sol\";\n\nimport \"../../lib/IWETH9.sol\";\nimport \"../../lib/IUniversalRouter.sol\";\nimport \"../interfaces/IErrors.sol\";\n\n// base functionality to do swaps with different routing protocols\nabstract contract Swapper is IUniswapV3SwapCallback, IErrors {\n    event Swap(address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut);\n\n    /// @notice Wrapped native token address\n    IWETH9 public immutable weth;\n\n    address public immutable factory;\n\n    /// @notice Uniswap v3 position manager\n    INonfungiblePositionManager public immutable nonfungiblePositionManager;\n\n    /// @notice 0x Exchange Proxy\n    address public immutable zeroxRouter;\n\n    /// @notice Uniswap Universal Router\n    address public immutable universalRouter;\n\n    /// @notice Constructor\n    /// @param _nonfungiblePositionManager Uniswap v3 position manager\n    /// @param _zeroxRouter 0x Exchange Proxy\n    constructor(\n        INonfungiblePositionManager _nonfungiblePositionManager,\n        address _zeroxRouter,\n        address _universalRouter\n    ) {\n        weth = IWETH9(_nonfungiblePositionManager.WETH9());\n        factory = _nonfungiblePositionManager.factory();\n        nonfungiblePositionManager = _nonfungiblePositionManager;\n        zeroxRouter = _zeroxRouter;\n        universalRouter = _universalRouter;\n    }\n\n    // swap data for 0x\n    struct ZeroxRouterData {\n        address allowanceTarget;\n        bytes data;\n    }\n\n    // swap data for uni - must include sweep for input token\n    struct UniversalRouterData {\n        bytes commands;\n        bytes[] inputs;\n        uint256 deadline;\n    }\n\n    struct RouterSwapParams {\n        IERC20 tokenIn;\n        IERC20 tokenOut;\n        uint256 amountIn;\n        uint256 amountOutMin;\n        bytes swapData;\n    }\n\n    // general swap function which uses external router with off-chain calculated swap instructions\n    // does slippage check with amountOutMin param\n    // returns token amounts deltas after swap\n    function _routerSwap(RouterSwapParams memory params)\n        internal\n        returns (uint256 amountInDelta, uint256 amountOutDelta)\n    {\n        if (params.amountIn != 0 && params.swapData.length != 0 && address(params.tokenOut) != address(0)) {\n            uint256 balanceInBefore = params.tokenIn.balanceOf(address(this));\n            uint256 balanceOutBefore = params.tokenOut.balanceOf(address(this));\n\n            // get router specific swap data\n            (address router, bytes memory routerData) = abi.decode(params.swapData, (address, bytes));\n\n            if (router == zeroxRouter) {\n                ZeroxRouterData memory data = abi.decode(routerData, (ZeroxRouterData));\n                // approve needed amount\n                SafeERC20.safeApprove(params.tokenIn, data.allowanceTarget, params.amountIn);\n                // execute swap\n                (bool success,) = zeroxRouter.call(data.data);\n                if (!success) {\n                    revert SwapFailed();\n                }\n                // reset approval\n                SafeERC20.safeApprove(params.tokenIn, data.allowanceTarget, 0);\n            } else if (router == universalRouter) {\n                UniversalRouterData memory data = abi.decode(routerData, (UniversalRouterData));\n                // tokens are transfered to Universalrouter directly (data.commands must include sweep action!)\n                SafeERC20.safeTransfer(params.tokenIn, universalRouter, params.amountIn);\n                IUniversalRouter(universalRouter).execute(data.commands, data.inputs, data.deadline);\n            } else {\n                revert WrongContract();\n            }\n\n            uint256 balanceInAfter = params.tokenIn.balanceOf(address(this));\n            uint256 balanceOutAfter = params.tokenOut.balanceOf(address(this));\n\n            amountInDelta = balanceInBefore - balanceInAfter;\n            amountOutDelta = balanceOutAfter - balanceOutBefore;\n\n            // amountMin slippage check\n            if (amountOutDelta < params.amountOutMin) {\n                revert SlippageError();\n            }\n\n            // event for any swap with exact swapped value\n            emit Swap(address(params.tokenIn), address(params.tokenOut), amountInDelta, amountOutDelta);\n        }\n    }\n\n    struct PoolSwapParams {\n        IUniswapV3Pool pool;\n        IERC20 token0;\n        IERC20 token1;\n        uint24 fee;\n        bool swap0For1;\n        uint256 amountIn;\n        uint256 amountOutMin;\n    }\n\n    // execute swap directly on specified pool\n    // amounts must be available on the contract for both tokens\n    function _poolSwap(PoolSwapParams memory params) internal returns (uint256 amountInDelta, uint256 amountOutDelta) {\n        if (params.amountIn > 0) {\n            (int256 amount0Delta, int256 amount1Delta) = params.pool.swap(\n                address(this),\n                params.swap0For1,\n                int256(params.amountIn),\n                (params.swap0For1 ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1),\n                abi.encode(\n                    params.swap0For1 ? params.token0 : params.token1,\n                    params.swap0For1 ? params.token1 : params.token0,\n                    params.fee\n                )\n            );\n            amountInDelta = params.swap0For1 ? uint256(amount0Delta) : uint256(amount1Delta);\n            amountOutDelta = params.swap0For1 ? uint256(-amount1Delta) : uint256(-amount0Delta);\n\n            // amountMin slippage check\n            if (amountOutDelta < params.amountOutMin) {\n                revert SlippageError();\n            }\n        }\n    }\n\n    // swap callback function where amount for swap is payed\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n\n        // check if really called from pool\n        (address tokenIn, address tokenOut, uint24 fee) = abi.decode(data, (address, address, uint24));\n        if (address(_getPool(tokenIn, tokenOut, fee)) != msg.sender) {\n            revert Unauthorized();\n        }\n\n        // transfer needed amount of tokenIn\n        uint256 amountToPay = amount0Delta > 0 ? uint256(amount0Delta) : uint256(amount1Delta);\n        SafeERC20.safeTransfer(IERC20(tokenIn), msg.sender, amountToPay);\n    }\n\n    // get pool for token\n    function _getPool(address tokenA, address tokenB, uint24 fee) internal view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(address(factory), PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n}"
    }
  ]
}