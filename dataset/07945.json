{
  "Title": "[M-08] Withheld ETH shoud not be sent back to the frxETHMinter contract itself",
  "Content": "_Submitted by ronnyx2017, also found by ayeslick and rvierdiiev_\n\n<https://github.com/code-423n4/2022-09-frax/blob/main/src/frxETHMinter.sol#L166-L174>\n\n<https://github.com/code-423n4/2022-09-frax/blob/main/src/frxETHMinter.sol#L191-L196>\n\n<https://github.com/code-423n4/2022-09-frax/blob/main/src/frxETHMinter.sol#L114-L116>\n\n### Impact\n\nIt will lead to duplicating accounting for the Eths which have been already converted to the frxETH tokens. It means Eth:frxEth will not be 1:1, and eventually leads to decoupling.\n\n### Proof of Concept\n\nThe function `moveWithheldETH` will send the `amount` of the Withheld ETH in the contract to the address `to`. It doesnt check if the `to` address is the frxETHMinter contract itself.\n\nAnd the frxETHMinter has the receive function which will submit any eth received to the frxETH.\n\n    /// @notice Fallback to minting frxETH to the sender\n        receive() external payable {\n            _submit(msg.sender);\n        }\n\nBut these parts of Eths (WithheldETH) also have been converted to the frxETH normally when they were sent to the contract at the first time.\n\n        function _submit(address recipient) internal nonReentrant {\n            // Initial pause and value checks\n            ...\n            // Give the sender frxETH\n            frxETHToken.minter_mint(recipient, msg.value);\n\nSo these Eths will be accounted, Twice, even more. It means Eth:frxEth will not be 1:1 anymore.\n\nThe function `recoverEther` has the same problem. Although these two functions can only be called by owner or DAO gov. It seriously affects financial stability.\n\n### Recommended Mitigation Steps\n\nFurthermore, due to the logic `receive() -> submit()`, any kind of transaction that withdraws ETH from the contract and then sends it back will cause the same problem.\n\nA non-feedback paybale empty function that does not use `_submit()` should be added to receive special ETH without increasing the frxeth supply.\n\n**[FortisFortuna (Frax) commented](https://github.com/code-423n4/2022-09-frax-findings/issues/221#issuecomment-1257282940):**\n > We are well aware of the permission structure. The owner will most likely be a large multisig. We mentioned the Frax Multisig in the scope too. If moving funds, it is assumed someone in the multisig would catch an invalid or malicious address.\n> \n> \n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-09-frax-findings/issues/221#issuecomment-1275330530):**\n > Wardens have demonstrated a mechanism which breaks core assumptions of the contract's accounting.  While I am usually very apprehensive to call input sanitization a M issue, a simple require statement here mitigates a risk of accidentally breaking a core tenet of the asset backed token.  \n> \n> Going to award this as Medium for now, may come back to it to revise later.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-09-frax",
  "Code": [
    {
      "filename": "src/frxETHMinter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ============================ frxETHMinter ==========================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author(s)\n// Jack Corddry: https://github.com/corddry\n// Justin Moore: https://github.com/0xJM\n\n// Reviewer(s) / Contributor(s)\n// Travis Moore: https://github.com/FortisFortuna\n// Dennis: https://github.com/denett\n// Jamie Turley: https://github.com/jyturley\n\nimport { frxETH } from \"./frxETH.sol\";\nimport { IsfrxETH } from \"./IsfrxETH.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { IDepositContract } from \"./DepositContract.sol\";\nimport \"./OperatorRegistry.sol\";\n\n/// @title Authorized minter contract for frxETH\n/// @notice Accepts user-supplied ETH and converts it to frxETH (submit()), and also optionally inline stakes it for sfrxETH (submitAndDeposit())\n/** @dev Has permission to mint frxETH. \n    Once +32 ETH has accumulated, adds it to a validator, which then deposits it for ETH 2.0 staking (depositEther())\n    Withhold ratio refers to what percentage of ETH this contract keeps whenever a user makes a deposit. 0% is kept initially */\ncontract frxETHMinter is OperatorRegistry, ReentrancyGuard {    \n    uint256 public constant DEPOSIT_SIZE = 32 ether; // ETH 2.0 minimum deposit size\n    uint256 public constant RATIO_PRECISION = 1e6; // 1,000,000 \n\n    uint256 public withholdRatio; // What we keep and don't deposit whenever someone submit()'s ETH\n    uint256 public currentWithheldETH; // Needed for internal tracking\n    mapping(bytes => bool) public activeValidators; // Tracks validators (via their pubkeys) that already have 32 ETH in them\n\n    IDepositContract public immutable depositContract; // ETH 2.0 deposit contract\n    frxETH public immutable frxETHToken;\n    IsfrxETH public immutable sfrxETHToken;\n\n    bool public submitPaused;\n    bool public depositEtherPaused;\n\n    constructor(\n        address depositContractAddress, \n        address frxETHAddress, \n        address sfrxETHAddress, \n        address _owner, \n        address _timelock_address,\n        bytes memory _withdrawalCredential\n    ) OperatorRegistry(_owner, _timelock_address, _withdrawalCredential) {\n        depositContract = IDepositContract(depositContractAddress);\n        frxETHToken = frxETH(frxETHAddress);\n        sfrxETHToken = IsfrxETH(sfrxETHAddress);\n        withholdRatio = 0; // No ETH is withheld initially\n        currentWithheldETH = 0;\n    }\n\n    /// @notice Mint frxETH and deposit it to receive sfrxETH in one transaction\n    /** @dev Could try using EIP-712 / EIP-2612 here in the future if you replace this contract,\n        but you might run into msg.sender vs tx.origin issues with the ERC4626 */\n    function submitAndDeposit(address recipient) external payable returns (uint256 shares) {\n        // Give the frxETH to this contract after it is generated\n        _submit(address(this));\n\n        // Approve frxETH to sfrxETH for staking\n        frxETHToken.approve(address(sfrxETHToken), msg.value);\n\n        // Deposit the frxETH and give the generated sfrxETH to the final recipient\n        uint256 sfrxeth_recieved = sfrxETHToken.deposit(msg.value, recipient);\n        require(sfrxeth_recieved > 0, 'No sfrxETH was returned');\n\n        return sfrxeth_recieved;\n    }\n\n    /// @notice Mint frxETH to the recipient using sender's funds. Internal portion\n    function _submit(address recipient) internal nonReentrant {\n        // Initial pause and value checks\n        require(!submitPaused, \"Submit is paused\");\n        require(msg.value != 0, \"Cannot submit 0\");\n\n        // Give the sender frxETH\n        frxETHToken.minter_mint(recipient, msg.value);\n\n        // Track the amount of ETH that we are keeping\n        uint256 withheld_amt = 0;\n        if (withholdRatio != 0) {\n            withheld_amt = (msg.value * withholdRatio) / RATIO_PRECISION;\n            currentWithheldETH += withheld_amt;\n        }\n\n        emit ETHSubmitted(msg.sender, recipient, msg.value, withheld_amt);\n    }\n\n    /// @notice Mint frxETH to the sender depending on the ETH value sent\n    function submit() external payable {\n        _submit(msg.sender);\n    }\n\n    /// @notice Mint frxETH to the recipient using sender's funds\n    function submitAndGive(address recipient) external payable {\n        _submit(recipient);\n    }\n\n    /// @notice Fallback to minting frxETH to the sender\n    receive() external payable {\n        _submit(msg.sender);\n    }\n\n    /// @notice Deposit batches of ETH to the ETH 2.0 deposit contract\n    /// @dev Usually a bot will call this periodically\n    function depositEther() external nonReentrant {\n        // Initial pause check\n        require(!depositEtherPaused, \"Depositing ETH is paused\");\n\n        // See how many deposits can be made. Truncation desired.\n        uint256 numDeposits = (address(this).balance - currentWithheldETH) / DEPOSIT_SIZE;\n        require(numDeposits > 0, \"Not enough ETH in contract\");\n\n        // Give each deposit chunk to an empty validator\n        for (uint256 i = 0; i < numDeposits; ++i) {\n            // Get validator information\n            (\n                bytes memory pubKey,\n                bytes memory withdrawalCredential,\n                bytes memory signature,\n                bytes32 depositDataRoot\n            ) = getNextValidator(); // Will revert if there are not enough free validators\n\n            // Make sure the validator hasn't been deposited into already, to prevent stranding an extra 32 eth\n            // until withdrawals are allowed\n            require(!activeValidators[pubKey], \"Validator already has 32 ETH\");\n\n            // Deposit the ether in the ETH 2.0 deposit contract\n            depositContract.deposit{value: DEPOSIT_SIZE}(\n                pubKey,\n                withdrawalCredential,\n                signature,\n                depositDataRoot\n            );\n\n            // Set the validator as used so it won't get an extra 32 ETH\n            activeValidators[pubKey] = true;\n\n            emit DepositSent(pubKey, withdrawalCredential);\n        }\n    }\n\n    /// @param newRatio of ETH that is sent to deposit contract vs withheld, 1e6 precision\n    /// @notice An input of 1e6 results in 100% of Eth deposited, 0% withheld\n    function setWithholdRatio(uint256 newRatio) external onlyByOwnGov {\n        require (newRatio <= RATIO_PRECISION, \"Ratio cannot surpass 100%\");\n        withholdRatio = newRatio;\n        emit WithholdRatioSet(newRatio);\n    }\n\n    /// @notice Give the withheld ETH to the \"to\" address\n    function moveWithheldETH(address payable to, uint256 amount) external onlyByOwnGov {\n        require(amount <= currentWithheldETH, \"Not enough withheld ETH in contract\");\n        currentWithheldETH -= amount;\n\n        (bool success,) = payable(to).call{ value: amount }(\"\");\n        require(success, \"Invalid transfer\");\n\n        emit WithheldETHMoved(to, amount);\n    }\n\n    /// @notice Toggle allowing submites\n    function togglePauseSubmits() external onlyByOwnGov {\n        submitPaused = !submitPaused;\n\n        emit SubmitPaused(submitPaused);\n    }\n\n    /// @notice Toggle allowing depositing ETH to validators\n    function togglePauseDepositEther() external onlyByOwnGov {\n        depositEtherPaused = !depositEtherPaused;\n\n        emit DepositEtherPaused(depositEtherPaused);\n    }\n\n    /// @notice For emergencies if something gets stuck\n    function recoverEther(uint256 amount) external onlyByOwnGov {\n        (bool success,) = address(owner).call{ value: amount }(\"\");\n        require(success, \"Invalid transfer\");\n\n        emit EmergencyEtherRecovered(amount);\n    }\n\n    /// @notice For emergencies if someone accidentally sent some ERC20 tokens here\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyByOwnGov {\n        require(IERC20(tokenAddress).transfer(owner, tokenAmount), \"recoverERC20: Transfer failed\");\n\n        emit EmergencyERC20Recovered(tokenAddress, tokenAmount);\n    }\n\n    event EmergencyEtherRecovered(uint256 amount);\n    event EmergencyERC20Recovered(address tokenAddress, uint256 tokenAmount);\n    event ETHSubmitted(address indexed sender, address indexed recipient, uint256 sent_amount, uint256 withheld_amt);\n    event DepositEtherPaused(bool new_status);\n    event DepositSent(bytes indexed pubKey, bytes withdrawalCredential);\n    event SubmitPaused(bool new_status);\n    event WithheldETHMoved(address indexed to, uint256 amount);\n    event WithholdRatioSet(uint256 newRatio);\n}"
    },
    {
      "filename": "src/frxETHMinter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ============================ frxETHMinter ==========================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author(s)\n// Jack Corddry: https://github.com/corddry\n// Justin Moore: https://github.com/0xJM\n\n// Reviewer(s) / Contributor(s)\n// Travis Moore: https://github.com/FortisFortuna\n// Dennis: https://github.com/denett\n// Jamie Turley: https://github.com/jyturley\n\nimport { frxETH } from \"./frxETH.sol\";\nimport { IsfrxETH } from \"./IsfrxETH.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { IDepositContract } from \"./DepositContract.sol\";\nimport \"./OperatorRegistry.sol\";\n\n/// @title Authorized minter contract for frxETH\n/// @notice Accepts user-supplied ETH and converts it to frxETH (submit()), and also optionally inline stakes it for sfrxETH (submitAndDeposit())\n/** @dev Has permission to mint frxETH. \n    Once +32 ETH has accumulated, adds it to a validator, which then deposits it for ETH 2.0 staking (depositEther())\n    Withhold ratio refers to what percentage of ETH this contract keeps whenever a user makes a deposit. 0% is kept initially */\ncontract frxETHMinter is OperatorRegistry, ReentrancyGuard {    \n    uint256 public constant DEPOSIT_SIZE = 32 ether; // ETH 2.0 minimum deposit size\n    uint256 public constant RATIO_PRECISION = 1e6; // 1,000,000 \n\n    uint256 public withholdRatio; // What we keep and don't deposit whenever someone submit()'s ETH\n    uint256 public currentWithheldETH; // Needed for internal tracking\n    mapping(bytes => bool) public activeValidators; // Tracks validators (via their pubkeys) that already have 32 ETH in them\n\n    IDepositContract public immutable depositContract; // ETH 2.0 deposit contract\n    frxETH public immutable frxETHToken;\n    IsfrxETH public immutable sfrxETHToken;\n\n    bool public submitPaused;\n    bool public depositEtherPaused;\n\n    constructor(\n        address depositContractAddress, \n        address frxETHAddress, \n        address sfrxETHAddress, \n        address _owner, \n        address _timelock_address,\n        bytes memory _withdrawalCredential\n    ) OperatorRegistry(_owner, _timelock_address, _withdrawalCredential) {\n        depositContract = IDepositContract(depositContractAddress);\n        frxETHToken = frxETH(frxETHAddress);\n        sfrxETHToken = IsfrxETH(sfrxETHAddress);\n        withholdRatio = 0; // No ETH is withheld initially\n        currentWithheldETH = 0;\n    }\n\n    /// @notice Mint frxETH and deposit it to receive sfrxETH in one transaction\n    /** @dev Could try using EIP-712 / EIP-2612 here in the future if you replace this contract,\n        but you might run into msg.sender vs tx.origin issues with the ERC4626 */\n    function submitAndDeposit(address recipient) external payable returns (uint256 shares) {\n        // Give the frxETH to this contract after it is generated\n        _submit(address(this));\n\n        // Approve frxETH to sfrxETH for staking\n        frxETHToken.approve(address(sfrxETHToken), msg.value);\n\n        // Deposit the frxETH and give the generated sfrxETH to the final recipient\n        uint256 sfrxeth_recieved = sfrxETHToken.deposit(msg.value, recipient);\n        require(sfrxeth_recieved > 0, 'No sfrxETH was returned');\n\n        return sfrxeth_recieved;\n    }\n\n    /// @notice Mint frxETH to the recipient using sender's funds. Internal portion\n    function _submit(address recipient) internal nonReentrant {\n        // Initial pause and value checks\n        require(!submitPaused, \"Submit is paused\");\n        require(msg.value != 0, \"Cannot submit 0\");\n\n        // Give the sender frxETH\n        frxETHToken.minter_mint(recipient, msg.value);\n\n        // Track the amount of ETH that we are keeping\n        uint256 withheld_amt = 0;\n        if (withholdRatio != 0) {\n            withheld_amt = (msg.value * withholdRatio) / RATIO_PRECISION;\n            currentWithheldETH += withheld_amt;\n        }\n\n        emit ETHSubmitted(msg.sender, recipient, msg.value, withheld_amt);\n    }\n\n    /// @notice Mint frxETH to the sender depending on the ETH value sent\n    function submit() external payable {\n        _submit(msg.sender);\n    }\n\n    /// @notice Mint frxETH to the recipient using sender's funds\n    function submitAndGive(address recipient) external payable {\n        _submit(recipient);\n    }\n\n    /// @notice Fallback to minting frxETH to the sender\n    receive() external payable {\n        _submit(msg.sender);\n    }\n\n    /// @notice Deposit batches of ETH to the ETH 2.0 deposit contract\n    /// @dev Usually a bot will call this periodically\n    function depositEther() external nonReentrant {\n        // Initial pause check\n        require(!depositEtherPaused, \"Depositing ETH is paused\");\n\n        // See how many deposits can be made. Truncation desired.\n        uint256 numDeposits = (address(this).balance - currentWithheldETH) / DEPOSIT_SIZE;\n        require(numDeposits > 0, \"Not enough ETH in contract\");\n\n        // Give each deposit chunk to an empty validator\n        for (uint256 i = 0; i < numDeposits; ++i) {\n            // Get validator information\n            (\n                bytes memory pubKey,\n                bytes memory withdrawalCredential,\n                bytes memory signature,\n                bytes32 depositDataRoot\n            ) = getNextValidator(); // Will revert if there are not enough free validators\n\n            // Make sure the validator hasn't been deposited into already, to prevent stranding an extra 32 eth\n            // until withdrawals are allowed\n            require(!activeValidators[pubKey], \"Validator already has 32 ETH\");\n\n            // Deposit the ether in the ETH 2.0 deposit contract\n            depositContract.deposit{value: DEPOSIT_SIZE}(\n                pubKey,\n                withdrawalCredential,\n                signature,\n                depositDataRoot\n            );\n\n            // Set the validator as used so it won't get an extra 32 ETH\n            activeValidators[pubKey] = true;\n\n            emit DepositSent(pubKey, withdrawalCredential);\n        }\n    }\n\n    /// @param newRatio of ETH that is sent to deposit contract vs withheld, 1e6 precision\n    /// @notice An input of 1e6 results in 100% of Eth deposited, 0% withheld\n    function setWithholdRatio(uint256 newRatio) external onlyByOwnGov {\n        require (newRatio <= RATIO_PRECISION, \"Ratio cannot surpass 100%\");\n        withholdRatio = newRatio;\n        emit WithholdRatioSet(newRatio);\n    }\n\n    /// @notice Give the withheld ETH to the \"to\" address\n    function moveWithheldETH(address payable to, uint256 amount) external onlyByOwnGov {\n        require(amount <= currentWithheldETH, \"Not enough withheld ETH in contract\");\n        currentWithheldETH -= amount;\n\n        (bool success,) = payable(to).call{ value: amount }(\"\");\n        require(success, \"Invalid transfer\");\n\n        emit WithheldETHMoved(to, amount);\n    }\n\n    /// @notice Toggle allowing submites\n    function togglePauseSubmits() external onlyByOwnGov {\n        submitPaused = !submitPaused;\n\n        emit SubmitPaused(submitPaused);\n    }\n\n    /// @notice Toggle allowing depositing ETH to validators\n    function togglePauseDepositEther() external onlyByOwnGov {\n        depositEtherPaused = !depositEtherPaused;\n\n        emit DepositEtherPaused(depositEtherPaused);\n    }\n\n    /// @notice For emergencies if something gets stuck\n    function recoverEther(uint256 amount) external onlyByOwnGov {\n        (bool success,) = address(owner).call{ value: amount }(\"\");\n        require(success, \"Invalid transfer\");\n\n        emit EmergencyEtherRecovered(amount);\n    }\n\n    /// @notice For emergencies if someone accidentally sent some ERC20 tokens here\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyByOwnGov {\n        require(IERC20(tokenAddress).transfer(owner, tokenAmount), \"recoverERC20: Transfer failed\");\n\n        emit EmergencyERC20Recovered(tokenAddress, tokenAmount);\n    }\n\n    event EmergencyEtherRecovered(uint256 amount);\n    event EmergencyERC20Recovered(address tokenAddress, uint256 tokenAmount);\n    event ETHSubmitted(address indexed sender, address indexed recipient, uint256 sent_amount, uint256 withheld_amt);\n    event DepositEtherPaused(bool new_status);\n    event DepositSent(bytes indexed pubKey, bytes withdrawalCredential);\n    event SubmitPaused(bool new_status);\n    event WithheldETHMoved(address indexed to, uint256 amount);\n    event WithholdRatioSet(uint256 newRatio);\n}"
    },
    {
      "filename": "src/frxETHMinter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ============================ frxETHMinter ==========================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author(s)\n// Jack Corddry: https://github.com/corddry\n// Justin Moore: https://github.com/0xJM\n\n// Reviewer(s) / Contributor(s)\n// Travis Moore: https://github.com/FortisFortuna\n// Dennis: https://github.com/denett\n// Jamie Turley: https://github.com/jyturley\n\nimport { frxETH } from \"./frxETH.sol\";\nimport { IsfrxETH } from \"./IsfrxETH.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { IDepositContract } from \"./DepositContract.sol\";\nimport \"./OperatorRegistry.sol\";\n\n/// @title Authorized minter contract for frxETH\n/// @notice Accepts user-supplied ETH and converts it to frxETH (submit()), and also optionally inline stakes it for sfrxETH (submitAndDeposit())\n/** @dev Has permission to mint frxETH. \n    Once +32 ETH has accumulated, adds it to a validator, which then deposits it for ETH 2.0 staking (depositEther())\n    Withhold ratio refers to what percentage of ETH this contract keeps whenever a user makes a deposit. 0% is kept initially */\ncontract frxETHMinter is OperatorRegistry, ReentrancyGuard {    \n    uint256 public constant DEPOSIT_SIZE = 32 ether; // ETH 2.0 minimum deposit size\n    uint256 public constant RATIO_PRECISION = 1e6; // 1,000,000 \n\n    uint256 public withholdRatio; // What we keep and don't deposit whenever someone submit()'s ETH\n    uint256 public currentWithheldETH; // Needed for internal tracking\n    mapping(bytes => bool) public activeValidators; // Tracks validators (via their pubkeys) that already have 32 ETH in them\n\n    IDepositContract public immutable depositContract; // ETH 2.0 deposit contract\n    frxETH public immutable frxETHToken;\n    IsfrxETH public immutable sfrxETHToken;\n\n    bool public submitPaused;\n    bool public depositEtherPaused;\n\n    constructor(\n        address depositContractAddress, \n        address frxETHAddress, \n        address sfrxETHAddress, \n        address _owner, \n        address _timelock_address,\n        bytes memory _withdrawalCredential\n    ) OperatorRegistry(_owner, _timelock_address, _withdrawalCredential) {\n        depositContract = IDepositContract(depositContractAddress);\n        frxETHToken = frxETH(frxETHAddress);\n        sfrxETHToken = IsfrxETH(sfrxETHAddress);\n        withholdRatio = 0; // No ETH is withheld initially\n        currentWithheldETH = 0;\n    }\n\n    /// @notice Mint frxETH and deposit it to receive sfrxETH in one transaction\n    /** @dev Could try using EIP-712 / EIP-2612 here in the future if you replace this contract,\n        but you might run into msg.sender vs tx.origin issues with the ERC4626 */\n    function submitAndDeposit(address recipient) external payable returns (uint256 shares) {\n        // Give the frxETH to this contract after it is generated\n        _submit(address(this));\n\n        // Approve frxETH to sfrxETH for staking\n        frxETHToken.approve(address(sfrxETHToken), msg.value);\n\n        // Deposit the frxETH and give the generated sfrxETH to the final recipient\n        uint256 sfrxeth_recieved = sfrxETHToken.deposit(msg.value, recipient);\n        require(sfrxeth_recieved > 0, 'No sfrxETH was returned');\n\n        return sfrxeth_recieved;\n    }\n\n    /// @notice Mint frxETH to the recipient using sender's funds. Internal portion\n    function _submit(address recipient) internal nonReentrant {\n        // Initial pause and value checks\n        require(!submitPaused, \"Submit is paused\");\n        require(msg.value != 0, \"Cannot submit 0\");\n\n        // Give the sender frxETH\n        frxETHToken.minter_mint(recipient, msg.value);\n\n        // Track the amount of ETH that we are keeping\n        uint256 withheld_amt = 0;\n        if (withholdRatio != 0) {\n            withheld_amt = (msg.value * withholdRatio) / RATIO_PRECISION;\n            currentWithheldETH += withheld_amt;\n        }\n\n        emit ETHSubmitted(msg.sender, recipient, msg.value, withheld_amt);\n    }\n\n    /// @notice Mint frxETH to the sender depending on the ETH value sent\n    function submit() external payable {\n        _submit(msg.sender);\n    }\n\n    /// @notice Mint frxETH to the recipient using sender's funds\n    function submitAndGive(address recipient) external payable {\n        _submit(recipient);\n    }\n\n    /// @notice Fallback to minting frxETH to the sender\n    receive() external payable {\n        _submit(msg.sender);\n    }\n\n    /// @notice Deposit batches of ETH to the ETH 2.0 deposit contract\n    /// @dev Usually a bot will call this periodically\n    function depositEther() external nonReentrant {\n        // Initial pause check\n        require(!depositEtherPaused, \"Depositing ETH is paused\");\n\n        // See how many deposits can be made. Truncation desired.\n        uint256 numDeposits = (address(this).balance - currentWithheldETH) / DEPOSIT_SIZE;\n        require(numDeposits > 0, \"Not enough ETH in contract\");\n\n        // Give each deposit chunk to an empty validator\n        for (uint256 i = 0; i < numDeposits; ++i) {\n            // Get validator information\n            (\n                bytes memory pubKey,\n                bytes memory withdrawalCredential,\n                bytes memory signature,\n                bytes32 depositDataRoot\n            ) = getNextValidator(); // Will revert if there are not enough free validators\n\n            // Make sure the validator hasn't been deposited into already, to prevent stranding an extra 32 eth\n            // until withdrawals are allowed\n            require(!activeValidators[pubKey], \"Validator already has 32 ETH\");\n\n            // Deposit the ether in the ETH 2.0 deposit contract\n            depositContract.deposit{value: DEPOSIT_SIZE}(\n                pubKey,\n                withdrawalCredential,\n                signature,\n                depositDataRoot\n            );\n\n            // Set the validator as used so it won't get an extra 32 ETH\n            activeValidators[pubKey] = true;\n\n            emit DepositSent(pubKey, withdrawalCredential);\n        }\n    }\n\n    /// @param newRatio of ETH that is sent to deposit contract vs withheld, 1e6 precision\n    /// @notice An input of 1e6 results in 100% of Eth deposited, 0% withheld\n    function setWithholdRatio(uint256 newRatio) external onlyByOwnGov {\n        require (newRatio <= RATIO_PRECISION, \"Ratio cannot surpass 100%\");\n        withholdRatio = newRatio;\n        emit WithholdRatioSet(newRatio);\n    }\n\n    /// @notice Give the withheld ETH to the \"to\" address\n    function moveWithheldETH(address payable to, uint256 amount) external onlyByOwnGov {\n        require(amount <= currentWithheldETH, \"Not enough withheld ETH in contract\");\n        currentWithheldETH -= amount;\n\n        (bool success,) = payable(to).call{ value: amount }(\"\");\n        require(success, \"Invalid transfer\");\n\n        emit WithheldETHMoved(to, amount);\n    }\n\n    /// @notice Toggle allowing submites\n    function togglePauseSubmits() external onlyByOwnGov {\n        submitPaused = !submitPaused;\n\n        emit SubmitPaused(submitPaused);\n    }\n\n    /// @notice Toggle allowing depositing ETH to validators\n    function togglePauseDepositEther() external onlyByOwnGov {\n        depositEtherPaused = !depositEtherPaused;\n\n        emit DepositEtherPaused(depositEtherPaused);\n    }\n\n    /// @notice For emergencies if something gets stuck\n    function recoverEther(uint256 amount) external onlyByOwnGov {\n        (bool success,) = address(owner).call{ value: amount }(\"\");\n        require(success, \"Invalid transfer\");\n\n        emit EmergencyEtherRecovered(amount);\n    }\n\n    /// @notice For emergencies if someone accidentally sent some ERC20 tokens here\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyByOwnGov {\n        require(IERC20(tokenAddress).transfer(owner, tokenAmount), \"recoverERC20: Transfer failed\");\n\n        emit EmergencyERC20Recovered(tokenAddress, tokenAmount);\n    }\n\n    event EmergencyEtherRecovered(uint256 amount);\n    event EmergencyERC20Recovered(address tokenAddress, uint256 tokenAmount);\n    event ETHSubmitted(address indexed sender, address indexed recipient, uint256 sent_amount, uint256 withheld_amt);\n    event DepositEtherPaused(bool new_status);\n    event DepositSent(bytes indexed pubKey, bytes withdrawalCredential);\n    event SubmitPaused(bool new_status);\n    event WithheldETHMoved(address indexed to, uint256 amount);\n    event WithholdRatioSet(uint256 newRatio);\n}"
    }
  ]
}