{
  "Title": "[N-12]  Numeric values having to do with time should use time units for readability",
  "Content": "There are [units](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#time-units) for seconds, minutes, hours, days, and weeks, and since they're defined, they should be used\n\n*There are 5 instances of this issue:*\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n/// @audit 600000\n48:       uint256 constant dailyEmission = 600000 * 10**18;\n\n/// @audit 60\n/// @audit 60\n57:       uint256 constant secsInDay = 24 * 60 * 60;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L48\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n/// @audit 86400\n296:      uint256 internal constant MAXTIME = 4 * 365 * 86400;\n\n/// @audit 86400\n297:      int128 internal constant iMAXTIME = 4 * 365 * 86400;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L296\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-07-golom",
  "Code": [
    {
      "filename": "contracts/rewards/RewardDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\n// stores daily trades\n// is minter of token, first interaction mints tokens and distributes tokens\n// gives prorata tokens to traders and exchange daily\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport 'hardhat/console.sol';\n\ninterface ERC20 {\n    function totalSupply() external returns (uint256);\n\n    function balanceOf(address account) external returns (uint256);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function mint(address account, uint256 amount) external;\n\n    function balanceOfNFTAt(uint256 _tokenId, uint256 _t) external view returns (uint256);\n\n    function deposit() external payable;\n}\n\ninterface VE {\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function totalSupplyAtT(uint256 t) external view returns (uint256);\n\n    function balanceOfNFTAt(uint256 _tokenId, uint256 _t) external view returns (uint256);\n\n    function totalSupplyAt(uint256 _block) external view returns (uint256);\n\n    function balanceOfAtNFT(uint256 _tokenId, uint256 _block) external view returns (uint256);\n}\n\ncontract RewardDistributor is Ownable {\n    address public trader;\n    uint256 public epoch = 0;\n    uint256 public startTime; // timestamp at which the contracts need to be activated\n\n    uint256 constant dailyEmission = 600000 * 10**18;\n\n    address public pendingTrader;\n    uint256 public traderEnableDate;\n\n    address public pendingVoteEscrow;\n    uint256 public voteEscrowEnableDate;\n    VE public ve;\n\n    uint256 constant secsInDay = 24 * 60 * 60;\n    mapping(address => mapping(uint256 => uint256)) public feesTrader; // fees accumulated by address of trader per epoch\n    mapping(address => mapping(uint256 => uint256)) public feesExchange; // fees accumulated by exchange of trader per epoch\n    mapping(uint256 => uint256) public epochTotalFee; // total fee of epoch\n    mapping(uint256 => uint256) public rewardTrader; // reward minted each epoc for trader\n    mapping(uint256 => uint256) public rewardExchange; // reward minted each epoc for exhange\n    mapping(uint256 => uint256) public rewardLP; // reward minted each epoc for LP\n    mapping(uint256 => uint256) public rewardStaker; // reward minted each epoc for stakers\n    mapping(uint256 => uint256) public epochBeginTime; // what time previous epoch ended\n    mapping(uint256 => uint256) public claimedUpto; // epoch upto which tokenid has claimed\n    mapping(uint256 => mapping(uint256 => uint256)) public claimed; // epoch upto which tokenid has claimed\n    ERC20 public rewardToken;\n    ERC20 public weth;\n    event NewEpoch(uint256 indexed epochNo, uint256 tokenMinted, uint256 rewardStaker, uint256 previousEpochFee);\n\n    // epochs,trader, token\n\n    constructor(\n        address _weth,\n        address _trader,\n        address _token,\n        address _governance\n    ) {\n        weth = ERC20(_weth);\n        trader = _trader;\n        rewardToken = ERC20(_token);\n        _transferOwnership(_governance); // set the new owner\n        startTime = 1659211200;\n    }\n\n    modifier onlyTrader() {\n        require(msg.sender == trader);\n        _;\n    }\n\n    // at starttime epoch 1 starts , first trade changes epoch from 0 to 1 , emits tokens stores the rewards for epoch 1 ,\n    // after 1 day , first trade changes epoch from 1 to 2, changes eth in contract to weth and stores rewardstakedeth , emits tokens stores the rewards for epoch 2\n\n    /// @dev Add fees contributed by the Seller of nft and the exchange/frontend that facilated the trade\n    /// @param addr the address that contributed in fees\n    /// @param fee the fee contributed by these addresses\n    function addFee(address[2] memory addr, uint256 fee) public onlyTrader {\n        //console.log(block.timestamp,epoch,fee);\n        if (rewardToken.totalSupply() > 1000000000 * 10**18) {\n            // if supply is greater then a billion dont mint anything, dont add trades\n            return;\n        }\n\n        // if 24 hours have passed since last epoch change\n        if (block.timestamp > startTime + (epoch) * secsInDay) {\n            // this assumes atleast 1 trade is done daily??????\n            // logic to decide how much token to emit\n            // emission = daily * (1 - (balance of locker/ total supply))  full if 0 locked and 0 if all locked\n            // uint256 tokenToEmit = dailyEmission * rewardToken.balanceOf()/\n            // emissions is decided by epoch begiining locked/circulating , and amount each nft gets also decided at epoch begining\n            uint256 tokenToEmit = (dailyEmission * (rewardToken.totalSupply() - rewardToken.balanceOf(address(ve)))) /\n                rewardToken.totalSupply();\n            uint256 stakerReward = (tokenToEmit * rewardToken.balanceOf(address(ve))) / rewardToken.totalSupply();\n            // deposit previous epoch fee to weth for distribution to stakers\n\n            uint256 previousEpochFee = epochTotalFee[epoch];\n            epoch = epoch + 1;\n            rewardStaker[epoch] = stakerReward;\n            rewardTrader[epoch] = ((tokenToEmit - stakerReward) * 67) / 100;\n            rewardExchange[epoch] = ((tokenToEmit - stakerReward) * 33) / 100;\n            rewardToken.mint(address(this), tokenToEmit);\n            epochBeginTime[epoch] = block.number;\n            if (previousEpochFee > 0) {\n                if (epoch == 1){\n                    epochTotalFee[0] =  address(this).balance; // staking and trading rewards start at epoch 1, for epoch 0 all contract ETH balance is converted to staker rewards rewards.\n                    weth.deposit{value: address(this).balance}();  \n                }else{\n                    weth.deposit{value: previousEpochFee}();\n                }\n            }\n            emit NewEpoch(epoch, tokenToEmit, stakerReward, previousEpochFee);\n        }\n        feesTrader[addr[0]][epoch] = feesTrader[addr[0]][epoch] + fee;\n        feesExchange[addr[1]][epoch] = feesExchange[addr[1]][epoch] + fee;\n        epochTotalFee[epoch] = epochTotalFee[epoch] + fee;\n        return;\n    }\n\n    // allows sellers of nft to claim there previous epoch rewards\n    function traderClaim(address addr, uint256[] memory epochs) public {\n        uint256 reward = 0;\n        for (uint256 index = 0; index < epochs.length; index++) {\n            require(epochs[index] < epoch);\n            reward =\n                reward +\n                (rewardTrader[epochs[index]] * feesTrader[addr][epochs[index]]) /\n                epochTotalFee[epochs[index]];\n            feesTrader[addr][epochs[index]] = 0;\n        }\n        rewardToken.transfer(addr, reward);\n    }\n\n    // allows exchange that facilated the nft trades to claim there previous epoch rewards\n    function exchangeClaim(address addr, uint256[] memory epochs) public {\n        uint256 reward = 0;\n        for (uint256 index = 0; index < epochs.length; index++) {\n            require(epochs[index] < epoch);\n            reward =\n                reward +\n                (rewardExchange[epochs[index]] * feesExchange[addr][epochs[index]]) /\n                epochTotalFee[epochs[index]];\n            feesExchange[addr][epochs[index]] = 0;\n        }\n        rewardToken.transfer(addr, reward);\n    }\n\n    /// @dev allows VeNFT holders to claim there token and eth rewards\n    ///      all tokenids must have a common owner\n    /// @param tokenids the nft ids to claim rewards for all ids in the list must belong to 1 address\n    /// @param epochs the list of epochs to claim rewards\n    function multiStakerClaim(uint256[] memory tokenids, uint256[] memory epochs) public {\n        require(address(ve) != address(0), ' VE not added yet');\n\n        uint256 reward = 0;\n        uint256 rewardEth = 0;\n        address tokenowner = ve.ownerOf(tokenids[0]);\n\n        // for each tokenid\n        for (uint256 tindex = 0; tindex < tokenids.length; tindex++) {\n            require(tokenowner == ve.ownerOf(tokenids[tindex]), 'Can only claim for a single Address together');\n            // for each epoch\n            for (uint256 index = 0; index < epochs.length; index++) {\n                require(epochs[index] < epoch, 'cant claim for future epochs');\n                require(claimed[tokenids[tindex]][epochs[index]] == 0, 'cant claim if already claimed');\n                claimed[tokenids[tindex]][epochs[index]] = 1;\n                if (epochs[index] == 0){\n                    rewardEth =\n                        rewardEth +\n                        (epochTotalFee[0] *\n                            ve.balanceOfAtNFT(tokenids[tindex], epochBeginTime[1])) /\n                        ve.totalSupplyAt(epochBeginTime[1]);\n\n                }else{\n                    reward =\n                        reward +\n                        (rewardStaker[epochs[index]] * ve.balanceOfAtNFT(tokenids[tindex], epochBeginTime[epochs[index]])) /\n                        ve.totalSupplyAt(epochBeginTime[epochs[index]]);\n                    rewardEth =\n                        rewardEth +\n                        (epochTotalFee[epochs[index]] *\n                            ve.balanceOfAtNFT(tokenids[tindex], epochBeginTime[epochs[index]])) /\n                        ve.totalSupplyAt(epochBeginTime[epochs[index]]);\n                }\n\n            }\n        }\n        rewardToken.transfer(tokenowner, reward);\n        weth.transfer(tokenowner, rewardEth);\n    }\n\n\n    /// @dev returns unclaimed rewards of an NFT, returns (unclaimed golom rewards, unclaimed eth rewards, unclaimed epochs)\n    /// @param tokenid the nft id to claim rewards for all ids in the list must belong to 1 address\n    function stakerRewards(uint256 tokenid) public view returns (\n            uint256,\n            uint256,\n            uint256[] memory\n        ){\n        require(address(ve) != address(0), ' VE not added yet');\n\n        uint256 reward = 0;\n        uint256 rewardEth = 0;\n        uint256[] memory unclaimedepochs = new uint256[](epoch);\n        // for each epoch\n        for (uint256 index = 0; index < epoch; index++) {\n            unclaimedepochs[index]=claimed[tokenid][index];\n            if (claimed[tokenid][index] == 0){\n                if (index == 0){\n                    rewardEth =\n                        rewardEth +\n                        (epochTotalFee[0] *\n                            ve.balanceOfAtNFT(tokenid, epochBeginTime[1])) /\n                        ve.totalSupplyAt(epochBeginTime[1]);\n\n                }else{\n                    reward =\n                        reward +\n                        (rewardStaker[index] * ve.balanceOfAtNFT(tokenid, epochBeginTime[index])) /\n                        ve.totalSupplyAt(epochBeginTime[index]);\n                    rewardEth =\n                        rewardEth +\n                        (epochTotalFee[index] *\n                            ve.balanceOfAtNFT(tokenid, epochBeginTime[index])) /\n                        ve.totalSupplyAt(epochBeginTime[index]);\n                }\n            }\n        }\n        return (reward, rewardEth, unclaimedepochs);\n    }\n\n    /// @dev returns unclaimed rewards of an NFT, returns (unclaimed golom rewards, unclaimed eth rewards, unclaimed epochs)\n    /// @param addr the nft id to claim rewards for all ids in the list must belong to 1 address\n    function traderRewards(address addr) public view returns (\n            uint256        \n            ){\n        uint256 reward = 0;\n        for (uint256 index = 0; index < epoch; index++) {\n            reward =\n                reward +\n                (rewardTrader[index] * feesTrader[addr][index]) /\n                epochTotalFee[index];\n        }\n        return (reward);\n    }\n\n    /// @dev returns unclaimed golom rewards of a trader\n    /// @param addr the nft id to claim rewards for all ids in the list must belong to 1 address\n    function exchangeRewards(address addr) public view returns (\n            uint256\n        ){\n        uint256 reward = 0;\n        for (uint256 index = 0; index < epoch; index++) {\n            reward =\n                reward +\n                (rewardExchange[index] * feesExchange[addr][index]) /\n                epochTotalFee[index];\n        }\n        return (reward);\n    }\n\n    /// @notice Changes the trader address with timelock\n    /// @dev executeChangeTrader needs to be called after 1 days\n    /// @param _trader New trader address\n    function changeTrader(address _trader) external onlyOwner {\n        traderEnableDate = block.timestamp + 1 days;\n        pendingTrader = _trader;\n    }\n\n    /// @notice Execute's the change trader function\n    function executeChangeTrader() external onlyOwner {\n        require(traderEnableDate <= block.timestamp, 'RewardDistributor: time not over yet');\n        trader = pendingTrader;\n    }\n\n    /// @notice Adds vote escrow contract for multi staker claim\n    /// @param _voteEscrow Address of the voteEscrow contract\n    function addVoteEscrow(address _voteEscrow) external onlyOwner {\n        if (address(ve) == address(0)) {\n            ve = VE(pendingVoteEscrow);\n        } else {\n            voteEscrowEnableDate = block.timestamp + 1 days;\n            pendingVoteEscrow = _voteEscrow;\n        }\n    }\n\n    /// @notice Adds vote escrow contract for multi staker claim\n    function executeAddVoteEscrow() external onlyOwner {\n        require(voteEscrowEnableDate <= block.timestamp, 'RewardDistributor: time not over yet');\n        ve = VE(pendingVoteEscrow);\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/vote-escrow/VoteEscrowCore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport './TokenUriHelper.sol';\n\n/**\n@title Voting Escrow\n@author Curve Finance\n@license MIT\n@notice Votes have a weight depending on time, so that users are\ncommitted to the future of (whatever they are voting for)\n@dev Vote weight decays linearly over time. Lock time cannot be\nmore than `MAXTIME` (4 years).\n\n# Voting escrow to have time-weighted votes\n# Votes have a weight depending on time, so that users are committed\n# to the future of (whatever they are voting for).\n# The weight in this implementation is linear, and lock cannot be more than maxtime:\n# w ^\n# 1 +        /\n#   |      /\n#   |    /\n#   |  /\n#   |/\n# 0 +--------+------> time\n#       maxtime (4 years?)\n*/\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n\nstruct Point {\n    int128 bias;\n    int128 slope; // # -dweight / dt\n    uint256 ts;\n    uint256 blk; // block\n}\n/* We cannot really do block numbers per se b/c slope is per time, not per block\n * and per block could be fairly bad b/c Ethereum changes blocktimes.\n * What we can do is to extrapolate ***At functions */\n\nstruct LockedBalance {\n    int128 amount;\n    uint256 end;\n}\n\ncontract VoteEscrowCore is IERC721, IERC721Metadata {\n    enum DepositType {\n        DEPOSIT_FOR_TYPE,\n        CREATE_LOCK_TYPE,\n        INCREASE_LOCK_AMOUNT,\n        INCREASE_UNLOCK_TIME,\n        MERGE_TYPE\n    }\n\n    event Deposit(\n        address indexed provider,\n        uint256 tokenId,\n        uint256 value,\n        uint256 indexed locktime,\n        DepositType deposit_type,\n        uint256 ts\n    );\n    event Withdraw(address indexed provider, uint256 tokenId, uint256 value, uint256 ts);\n    event Supply(uint256 prevSupply, uint256 supply);\n\n    uint256 internal constant WEEK = 1 weeks;\n    uint256 internal constant MAXTIME = 4 * 365 * 86400;\n    int128 internal constant iMAXTIME = 4 * 365 * 86400;\n    uint256 internal constant MULTIPLIER = 1 ether;\n\n    address public token;\n    uint256 public supply;\n    mapping(uint256 => LockedBalance) public locked;\n\n    mapping(uint256 => uint256) public ownership_change;\n\n    uint256 public epoch;\n    mapping(uint256 => Point) public point_history; // epoch -> unsigned point\n    mapping(uint256 => Point[1000000000]) public user_point_history; // user -> Point[user_epoch]\n\n    mapping(uint256 => uint256) public user_point_epoch;\n    mapping(uint256 => int128) public slope_changes; // time -> signed slope change\n\n    mapping(uint256 => uint256) public attachments;\n    mapping(uint256 => bool) public voted;\n    address public voter;\n\n    string public constant name = 'veNFT';\n    string public constant symbol = 'veNFT';\n    string public constant version = '1.0.0';\n    uint8 public constant decimals = 18;\n\n    /// @dev Current count of token\n    uint256 internal tokenId;\n\n    /// @dev Mapping from NFT ID to the address that owns it.\n    mapping(uint256 => address) internal idToOwner;\n\n    /// @dev Mapping from NFT ID to approved address.\n    mapping(uint256 => address) internal idToApprovals;\n\n    /// @dev Mapping from owner address to count of his tokens.\n    mapping(address => uint256) internal ownerToNFTokenCount;\n\n    /// @dev Mapping from owner address to mapping of index to tokenIds\n    mapping(address => mapping(uint256 => uint256)) internal ownerToNFTokenIdList;\n\n    /// @dev Mapping from NFT ID to index of owner\n    mapping(uint256 => uint256) internal tokenToOwnerIndex;\n\n    /// @dev Mapping from owner address to mapping of operator addresses.\n    mapping(address => mapping(address => bool)) internal ownerToOperators;\n\n    /// @dev Mapping of interface id to bool about whether or not it's supported\n    mapping(bytes4 => bool) internal supportedInterfaces;\n\n    /// @dev ERC165 interface ID of ERC165\n    bytes4 internal constant ERC165_INTERFACE_ID = 0x01ffc9a7;\n\n    /// @dev ERC165 interface ID of ERC721\n    bytes4 internal constant ERC721_INTERFACE_ID = 0x80ac58cd;\n\n    /// @dev ERC165 interface ID of ERC721Metadata\n    bytes4 internal constant ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\n\n    /// @dev reentrancy guard\n    uint8 internal constant _not_entered = 1;\n    uint8 internal constant _entered = 2;\n    uint8 internal _entered_state = 1;\n    modifier nonreentrant() {\n        require(_entered_state == _not_entered);\n        _entered_state = _entered;\n        _;\n        _entered_state = _not_entered;\n    }\n\n    /// @dev Interface identification is specified in ERC-165.\n    /// @param _interfaceID Id of the interface\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\n        return supportedInterfaces[_interfaceID];\n    }\n\n    /// @notice Get the most recently recorded rate of voting power decrease for `_tokenId`\n    /// @param _tokenId token of the NFT\n    /// @return Value of the slope\n    function get_last_user_slope(uint256 _tokenId) external view returns (int128) {\n        uint256 uepoch = user_point_epoch[_tokenId];\n        return user_point_history[_tokenId][uepoch].slope;\n    }\n\n    /// @notice Get the timestamp for checkpoint `_idx` for `_tokenId`\n    /// @param _tokenId token of the NFT\n    /// @param _idx User epoch number\n    /// @return Epoch time of the checkpoint\n    function user_point_history__ts(uint256 _tokenId, uint256 _idx) external view returns (uint256) {\n        return user_point_history[_tokenId][_idx].ts;\n    }\n\n    /// @notice Get timestamp when `_tokenId`'s lock finishes\n    /// @param _tokenId User NFT\n    /// @return Epoch time of the lock end\n    function locked__end(uint256 _tokenId) external view returns (uint256) {\n        return locked[_tokenId].end;\n    }\n\n    /// @dev Returns the number of NFTs owned by `_owner`.\n    ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n    /// @param _owner Address for whom to query the balance.\n    function _balance(address _owner) internal view returns (uint256) {\n        return ownerToNFTokenCount[_owner];\n    }\n\n    /// @dev Returns the number of NFTs owned by `_owner`.\n    ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n    /// @param _owner Address for whom to query the balance.\n    function balanceOf(address _owner) external view returns (uint256) {\n        return _balance(_owner);\n    }\n\n    /// @dev Returns the address of the owner of the NFT.\n    /// @param _tokenId The identifier for an NFT.\n    function ownerOf(uint256 _tokenId) public view returns (address) {\n        return idToOwner[_tokenId];\n    }\n\n    /// @dev Get the approved address for a single NFT.\n    /// @param _tokenId ID of the NFT to query the approval of.\n    function getApproved(uint256 _tokenId) external view returns (address) {\n        return idToApprovals[_tokenId];\n    }\n\n    /// @dev Checks if `_operator` is an approved operator for `_owner`.\n    /// @param _owner The address that owns the NFTs.\n    /// @param _operator The address that acts on behalf of the owner.\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n        return (ownerToOperators[_owner])[_operator];\n    }\n\n    /// @dev  Get token by index\n    function tokenOfOwnerByIndex(address _owner, uint256 _tokenIndex) external view returns (uint256) {\n        return ownerToNFTokenIdList[_owner][_tokenIndex];\n    }\n\n    /// @dev Returns whether the given spender can transfer a given token ID\n    /// @param _spender address of the spender to query\n    /// @param _tokenId uint ID of the token to be transferred\n    /// @return bool whether the msg.sender is approved for the given token ID, is an operator of the owner, or is the owner of the token\n    function _isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) {\n        address owner = idToOwner[_tokenId];\n        bool spenderIsOwner = owner == _spender;\n        bool spenderIsApproved = _spender == idToApprovals[_tokenId];\n        bool spenderIsApprovedForAll = (ownerToOperators[owner])[_spender];\n        return spenderIsOwner || spenderIsApproved || spenderIsApprovedForAll;\n    }\n\n    function isApprovedOrOwner(address _spender, uint256 _tokenId) external view returns (bool) {\n        return _isApprovedOrOwner(_spender, _tokenId);\n    }\n\n    /// @dev Add a NFT to an index mapping to a given address\n    /// @param _to address of the receiver\n    /// @param _tokenId uint ID Of the token to be added\n    function _addTokenToOwnerList(address _to, uint256 _tokenId) internal {\n        uint256 current_count = _balance(_to);\n\n        ownerToNFTokenIdList[_to][current_count] = _tokenId;\n        tokenToOwnerIndex[_tokenId] = current_count;\n    }\n\n    /// @dev Remove a NFT from an index mapping to a given address\n    /// @param _from address of the sender\n    /// @param _tokenId uint ID Of the token to be removed\n    function _removeTokenFromOwnerList(address _from, uint256 _tokenId) internal {\n        // Delete\n        uint256 current_count = _balance(_from) - 1;\n        uint256 current_index = tokenToOwnerIndex[_tokenId];\n\n        if (current_count == current_index) {\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][current_count] = 0;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[_tokenId] = 0;\n        } else {\n            uint256 lastTokenId = ownerToNFTokenIdList[_from][current_count];\n\n            // Add\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][current_index] = lastTokenId;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[lastTokenId] = current_index;\n\n            // Delete\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][current_count] = 0;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[_tokenId] = 0;\n        }\n    }\n\n    /// @dev Add a NFT to a given address\n    ///      Throws if `_tokenId` is owned by someone.\n    function _addTokenTo(address _to, uint256 _tokenId) internal {\n        // Throws if `_tokenId` is owned by someone\n        assert(idToOwner[_tokenId] == address(0));\n        // Change the owner\n        idToOwner[_tokenId] = _to;\n        // Update owner token index tracking\n        _addTokenToOwnerList(_to, _tokenId);\n        // Change count tracking\n        ownerToNFTokenCount[_to] += 1;\n    }\n\n    /// @dev Remove a NFT from a given address\n    ///      Throws if `_from` is not the current owner.\n    function _removeTokenFrom(address _from, uint256 _tokenId) internal {\n        // Throws if `_from` is not the current owner\n        assert(idToOwner[_tokenId] == _from);\n        // Change the owner\n        idToOwner[_tokenId] = address(0);\n        // Update owner token index tracking\n        _removeTokenFromOwnerList(_from, _tokenId);\n        // Change count tracking\n        ownerToNFTokenCount[_from] -= 1;\n    }\n\n    /// @dev Clear an approval of a given address\n    ///      Throws if `_owner` is not the current owner.\n    function _clearApproval(address _owner, uint256 _tokenId) internal {\n        // Throws if `_owner` is not the current owner\n        assert(idToOwner[_tokenId] == _owner);\n        if (idToApprovals[_tokenId] != address(0)) {\n            // Reset approvals\n            idToApprovals[_tokenId] = address(0);\n        }\n    }\n\n    /// @dev Exeute transfer of a NFT.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n    ///      address for this NFT. (NOTE: `msg.sender` not allowed in internal function so pass `_sender`.)"
    }
  ]
}