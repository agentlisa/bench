{
  "Title": "[02] Withdraw should revert with non-supported `delegationType`",
  "Content": "\nThere seems to be no way to create a DelegateToken that is not ERC721/ERC20/ERC1155, but due to the fact that `DelegationType` supports also `ALL` and `CONTRACT`:\n\n```solidity\nenum DelegationType {\n    NONE,\n    ALL,\n    CONTRACT,\n    ERC721,\n    ERC20,\n    ERC1155\n}\n```\n\nAnd there are multiple ways to create DelegateToken (e.g. `DelegateToken.create` and `CreateOfferer.transferFrom`, but more contracts could be created in the future), it would be safer to revert the transaction on withdraw to avoid burning unsupported tokens:\n\n```solidity\nfunction withdraw(uint256 delegateTokenId) external nonReentrant {\n    ...\n    } else if (delegationType == IDelegateRegistry.DelegationType.ERC1155) {\n        uint256 erc1155UnderlyingAmount = StorageHelpers.readUnderlyingAmount(delegateTokenInfo, delegateTokenId);\n        StorageHelpers.writeUnderlyingAmount(delegateTokenInfo, delegateTokenId, 0); // Deletes amount\n        uint256 erc11551UnderlyingTokenId = RegistryHelpers.loadTokenId(delegateRegistry, registryHash);\n        RegistryHelpers.decrementERC1155(\n            delegateRegistry, registryHash, delegateTokenHolder, underlyingContract, erc11551UnderlyingTokenId, erc1155UnderlyingAmount, underlyingRights\n        );\n        StorageHelpers.burnPrincipal(principalToken, principalBurnAuthorization, delegateTokenId);\n        IERC1155(underlyingContract).safeTransferFrom(address(this), msg.sender, erc11551UnderlyingTokenId, erc1155UnderlyingAmount, \"\");\n    }\n/* @audit Should revert here to avoid burning a not supported delegate token\n    else {\n        revert Errors.InvalidTokenType(delegationType);\n    }\n*/\n}\n```\n\nhttps://github.com/code-423n4/2023-09-delegate/blob/main/src/DelegateToken.sol#L353-L386\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-09-delegate",
  "Code": [
    {
      "filename": "src/DelegateToken.sol",
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.21;\n\nimport {IDelegateToken, IERC721Metadata, IERC721Receiver, IERC1155Receiver} from \"./interfaces/IDelegateToken.sol\";\nimport {MarketMetadata} from \"src/MarketMetadata.sol\";\nimport {PrincipalToken} from \"src/PrincipalToken.sol\";\n\nimport {ReentrancyGuard} from \"openzeppelin/security/ReentrancyGuard.sol\";\n\nimport {IDelegateRegistry, DelegateTokenErrors as Errors, DelegateTokenStructs as Structs, DelegateTokenHelpers as Helpers} from \"src/libraries/DelegateTokenLib.sol\";\nimport {DelegateTokenStorageHelpers as StorageHelpers} from \"src/libraries/DelegateTokenStorageHelpers.sol\";\nimport {DelegateTokenRegistryHelpers as RegistryHelpers, RegistryHashes} from \"src/libraries/DelegateTokenRegistryHelpers.sol\";\nimport {DelegateTokenTransferHelpers as TransferHelpers, SafeERC20, IERC721, IERC20, IERC1155} from \"src/libraries/DelegateTokenTransferHelpers.sol\";\n\ncontract DelegateToken is ReentrancyGuard, IDelegateToken {\n    /*//////////////////////////////////////////////////////////////\n    /                           Immutables                         /\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IDelegateToken\n    address public immutable override delegateRegistry;\n\n    /// @inheritdoc IDelegateToken\n    address public immutable override principalToken;\n\n    address public immutable marketMetadata;\n\n    /*//////////////////////////////////////////////////////////////\n    /                            Storage                           /\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev delegateId, a hash of (msg.sender, salt), points a unique id to the StoragePosition\n    mapping(uint256 delegateTokenId => uint256[3] info) internal delegateTokenInfo;\n\n    /// @notice mapping for ERC721 balances\n    mapping(address delegateTokenHolder => uint256 balance) internal balances;\n\n    /// @notice approve for all mapping\n    mapping(address account => mapping(address operator => bool enabled)) internal accountOperator;\n\n    /// @notice internal variables for Principle Token callbacks\n    Structs.Uint256 internal principalMintAuthorization = Structs.Uint256(StorageHelpers.MINT_NOT_AUTHORIZED);\n    Structs.Uint256 internal principalBurnAuthorization = Structs.Uint256(StorageHelpers.BURN_NOT_AUTHORIZED);\n\n    /// @notice internal variable 11155 callbacks\n    Structs.Uint256 internal erc1155PullAuthorization = Structs.Uint256(TransferHelpers.ERC1155_NOT_PULLED);\n\n    /*//////////////////////////////////////////////////////////////\n    /                      Constructor                             /\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(Structs.DelegateTokenParameters memory parameters) {\n        if (parameters.delegateRegistry == address(0)) revert Errors.DelegateRegistryZero();\n        if (parameters.principalToken == address(0)) revert Errors.PrincipalTokenZero();\n        if (parameters.marketMetadata == address(0)) revert Errors.MarketMetadataZero();\n        delegateRegistry = parameters.delegateRegistry;\n        principalToken = parameters.principalToken;\n        marketMetadata = parameters.marketMetadata;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n    /                    Supported Interfaces                      /\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return interfaceId == 0x2a55205a // ERC165 Interface ID for ERC2981\n            || interfaceId == 0x01ffc9a7 // ERC165 Interface ID for ERC165\n            || interfaceId == 0x80ac58cd // ERC165 Interface ID for ERC721\n            || interfaceId == 0x5b5e139f // ERC165 Interface ID for ERC721Metadata\n            || interfaceId == 0x4e2312e0; // ERC165 Interface ID for ERC1155 Token receiver\n    }\n\n    /*//////////////////////////////////////////////////////////////\n    /                    Token Receiver methods                    /\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC1155Receiver\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) external pure returns (bytes4) {\n        revert Errors.BatchERC1155TransferUnsupported();\n    }\n\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(address operator, address, uint256, bytes calldata) external view returns (bytes4) {\n        if (address(this) == operator) return IERC721Receiver.onERC721Received.selector;\n        revert Errors.InvalidERC721TransferOperator();\n    }\n\n    /// @inheritdoc IERC1155Receiver\n    function onERC1155Received(address operator, address, uint256, uint256, bytes calldata) external returns (bytes4) {\n        TransferHelpers.revertInvalidERC1155PullCheck(erc1155PullAuthorization, operator);\n        return IERC1155Receiver.onERC1155Received.selector;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n    /                 ERC721 Method Implementations                /\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721\n    function balanceOf(address delegateTokenHolder) external view returns (uint256) {\n        if (delegateTokenHolder == address(0)) revert Errors.DelegateTokenHolderZero();\n        return balances[delegateTokenHolder];\n    }\n\n    /// @inheritdoc IERC721\n    function ownerOf(uint256 delegateTokenId) external view returns (address delegateTokenHolder) {\n        delegateTokenHolder = RegistryHelpers.loadTokenHolder(delegateRegistry, StorageHelpers.readRegistryHash(delegateTokenInfo, delegateTokenId));\n        if (delegateTokenHolder == address(0)) revert Errors.DelegateTokenHolderZero();\n    }\n\n    /// @inheritdoc IERC721\n    function getApproved(uint256 delegateTokenId) external view returns (address) {\n        StorageHelpers.revertNotMinted(delegateTokenInfo, delegateTokenId);\n        return StorageHelpers.readApproved(delegateTokenInfo, delegateTokenId);\n    }\n\n    /// @inheritdoc IERC721\n    function isApprovedForAll(address account, address operator) external view returns (bool) {\n        return accountOperator[account][operator];\n    }\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(address from, address to, uint256 delegateTokenId, bytes calldata data) external {\n        transferFrom(from, to, delegateTokenId);\n        Helpers.revertOnInvalidERC721ReceiverCallback(from, to, delegateTokenId, data);\n    }\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(address from, address to, uint256 delegateTokenId) external {\n        transferFrom(from, to, delegateTokenId);\n        Helpers.revertOnInvalidERC721ReceiverCallback(from, to, delegateTokenId);\n    }\n\n    /// @inheritdoc IERC721\n    function approve(address spender, uint256 delegateTokenId) external {\n        bytes32 registryHash = StorageHelpers.readRegistryHash(delegateTokenInfo, delegateTokenId);\n        StorageHelpers.revertNotMinted(registryHash, delegateTokenId);\n        address delegateTokenHolder = RegistryHelpers.loadTokenHolder(delegateRegistry, registryHash);\n        StorageHelpers.revertNotOperator(accountOperator, delegateTokenHolder);\n        StorageHelpers.writeApproved(delegateTokenInfo, delegateTokenId, spender);\n        emit Approval(delegateTokenHolder, spender, delegateTokenId);\n    }\n\n    /// @inheritdoc IERC721\n    function setApprovalForAll(address operator, bool approved) external {\n        accountOperator[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /// @inheritdoc IERC721\n    /// @dev should revert if msg.sender does not meet one of the following:\n    ///         - msg.sender is from address\n    ///         - from has approved msg.sender for all\n    ///         - msg.sender is approved for the delegateTokenId\n    /// @dev balances should be incremented / decremented for from / to\n    /// @dev approved for the delegateTokenId should be deleted (reset)\n    /// @dev must emit the ERC721 Transfer(from, to, delegateTokenId) event\n    /// @dev toAmount stored in the related registry delegation must be retrieved directly from registry storage and\n    ///      not via the CheckDelegate method to avoid invariants with \"[specific rights]\" and \"\" classes\n    /// @dev registryHash for the DelegateTokenId must point to the new registry delegation associated with the to\n    /// address\n    function transferFrom(address from, address to, uint256 delegateTokenId) public {\n        if (to == address(0)) revert Errors.ToIsZero();\n        bytes32 registryHash = StorageHelpers.readRegistryHash(delegateTokenInfo, delegateTokenId);\n        StorageHelpers.revertNotMinted(registryHash, delegateTokenId);\n        (address delegateTokenHolder, address underlyingContract) = RegistryHelpers.loadTokenHolderAndContract(delegateRegistry, registryHash);\n        if (from != delegateTokenHolder) revert Errors.FromNotDelegateTokenHolder();\n        // We can use `from` here instead of delegateTokenHolder since we've just verified that from == delegateTokenHolder\n        StorageHelpers.revertNotApprovedOrOperator(accountOperator, delegateTokenInfo, from, delegateTokenId);\n        StorageHelpers.incrementBalance(balances, to);\n        StorageHelpers.decrementBalance(balances, from);\n        StorageHelpers.writeApproved(delegateTokenInfo, delegateTokenId, address(0));\n        emit Transfer(from, to, delegateTokenId);\n        IDelegateRegistry.DelegationType underlyingType = RegistryHashes.decodeType(registryHash);\n        bytes32 underlyingRights = RegistryHelpers.loadRights(delegateRegistry, registryHash);\n        bytes32 newRegistryHash = 0;\n        if (underlyingType == IDelegateRegistry.DelegationType.ERC721) {\n            uint256 underlyingTokenId = RegistryHelpers.loadTokenId(delegateRegistry, registryHash);\n            newRegistryHash = RegistryHashes.erc721Hash(address(this), underlyingRights, to, underlyingTokenId, underlyingContract);\n            StorageHelpers.writeRegistryHash(delegateTokenInfo, delegateTokenId, newRegistryHash);\n            RegistryHelpers.transferERC721(delegateRegistry, registryHash, from, newRegistryHash, to, underlyingRights, underlyingContract, underlyingTokenId);\n        } else if (underlyingType == IDelegateRegistry.DelegationType.ERC20) {\n            newRegistryHash = RegistryHashes.erc20Hash(address(this), underlyingRights, to, underlyingContract);\n            StorageHelpers.writeRegistryHash(delegateTokenInfo, delegateTokenId, newRegistryHash);\n            RegistryHelpers.transferERC20(\n                delegateRegistry,\n                registryHash,\n                from,\n                newRegistryHash,\n                to,\n                StorageHelpers.readUnderlyingAmount(delegateTokenInfo, delegateTokenId),\n                underlyingRights,\n                underlyingContract\n            );\n        } else if (underlyingType == IDelegateRegistry.DelegationType.ERC1155) {\n            uint256 underlyingTokenId = RegistryHelpers.loadTokenId(delegateRegistry, registryHash);\n            newRegistryHash = RegistryHashes.erc1155Hash(address(this), underlyingRights, to, underlyingTokenId, underlyingContract);\n            StorageHelpers.writeRegistryHash(delegateTokenInfo, delegateTokenId, newRegistryHash);\n            RegistryHelpers.transferERC1155(\n                delegateRegistry,\n                registryHash,\n                from,\n                newRegistryHash,\n                to,\n                StorageHelpers.readUnderlyingAmount(delegateTokenInfo, delegateTokenId),\n                underlyingRights,\n                underlyingContract,\n                underlyingTokenId\n            );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n    /                EXTENDED ERC721 METHODS                       /\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721Metadata\n    function name() external pure returns (string memory) {\n        return \"Delegate Token\";\n    }\n\n    /// @inheritdoc IERC721Metadata\n    function symbol() external pure returns (string memory) {\n        return \"DT\";\n    }\n\n    /// @inheritdoc IERC721Metadata\n    function tokenURI(uint256 delegateTokenId) external view returns (string memory) {\n        bytes32 registryHash = StorageHelpers.readRegistryHash(delegateTokenInfo, delegateTokenId);\n        StorageHelpers.revertNotMinted(registryHash, delegateTokenId);\n        return MarketMetadata(marketMetadata).delegateTokenURI(\n            RegistryHelpers.loadContract(delegateRegistry, registryHash),\n            RegistryHelpers.loadTokenId(delegateRegistry, registryHash),\n            StorageHelpers.readExpiry(delegateTokenInfo, delegateTokenId),\n            IERC721(principalToken).ownerOf(delegateTokenId)\n        );\n    }\n\n    /// @inheritdoc IDelegateToken\n    function isApprovedOrOwner(address spender, uint256 delegateTokenId) external view returns (bool) {\n        bytes32 registryHash = StorageHelpers.readRegistryHash(delegateTokenInfo, delegateTokenId);\n        StorageHelpers.revertNotMinted(registryHash, delegateTokenId);\n        address delegateTokenHolder = RegistryHelpers.loadTokenHolder(delegateRegistry, registryHash);\n        return spender == delegateTokenHolder || accountOperator[delegateTokenHolder][spender] || StorageHelpers.readApproved(delegateTokenInfo, delegateTokenId) == spender;\n    }\n\n    /// @inheritdoc IDelegateToken\n    function baseURI() external view returns (string memory) {\n        return MarketMetadata(marketMetadata).delegateTokenBaseURI();\n    }\n\n    /// @inheritdoc IDelegateToken\n    function contractURI() external view returns (string memory) {\n        return MarketMetadata(marketMetadata).delegateTokenContractURI();\n    }\n\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address receiver, uint256 royaltyAmount) {\n        (receiver, royaltyAmount) = MarketMetadata(marketMetadata).royaltyInfo(tokenId, salePrice);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n    /            LIQUID DELEGATE TOKEN METHODS                     /\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IDelegateToken\n    function getDelegateInfo(uint256 delegateTokenId) external view returns (Structs.DelegateInfo memory delegateInfo) {\n        bytes32 registryHash = StorageHelpers.readRegistryHash(delegateTokenInfo, delegateTokenId);\n        StorageHelpers.revertNotMinted(registryHash, delegateTokenId);\n        delegateInfo.tokenType = RegistryHashes.decodeType(registryHash);\n        (delegateInfo.delegateHolder, delegateInfo.tokenContract) = RegistryHelpers.loadTokenHolderAndContract(delegateRegistry, registryHash);\n        delegateInfo.rights = RegistryHelpers.loadRights(delegateRegistry, registryHash);\n        delegateInfo.principalHolder = IERC721(principalToken).ownerOf(delegateTokenId);\n        delegateInfo.expiry = StorageHelpers.readExpiry(delegateTokenInfo, delegateTokenId);\n        if (delegateInfo.tokenType == IDelegateRegistry.DelegationType.ERC20) delegateInfo.tokenId = 0;\n        else delegateInfo.tokenId = RegistryHelpers.loadTokenId(delegateRegistry, registryHash);\n        if (delegateInfo.tokenType == IDelegateRegistry.DelegationType.ERC721) delegateInfo.amount = 0;\n        else delegateInfo.amount = StorageHelpers.readUnderlyingAmount(delegateTokenInfo, delegateTokenId);\n    }\n\n    /// @inheritdoc IDelegateToken\n    function getDelegateId(address caller, uint256 salt) external view returns (uint256 delegateTokenId) {\n        delegateTokenId = Helpers.delegateIdNoRevert(caller, salt);\n        StorageHelpers.revertAlreadyExisted(delegateTokenInfo, delegateTokenId);\n    }\n\n    /// @inheritdoc IDelegateToken\n    function burnAuthorizedCallback() external view {\n        StorageHelpers.checkBurnAuthorized(principalToken, principalBurnAuthorization);\n    }\n\n    /// @inheritdoc IDelegateToken\n    function mintAuthorizedCallback() external view {\n        StorageHelpers.checkMintAuthorized(principalToken, principalMintAuthorization);\n    }\n\n    /// @inheritdoc IDelegateToken\n    function create(Structs.DelegateInfo calldata delegateInfo, uint256 salt) external nonReentrant returns (uint256 delegateTokenId) {\n        TransferHelpers.checkAndPullByType(erc1155PullAuthorization, delegateInfo);\n        Helpers.revertOldExpiry(delegateInfo.expiry);\n        if (delegateInfo.delegateHolder == address(0)) revert Errors.ToIsZero();\n        delegateTokenId = Helpers.delegateIdNoRevert(msg.sender, salt);\n        StorageHelpers.revertAlreadyExisted(delegateTokenInfo, delegateTokenId);\n        StorageHelpers.incrementBalance(balances, delegateInfo.delegateHolder);\n        StorageHelpers.writeExpiry(delegateTokenInfo, delegateTokenId, delegateInfo.expiry);\n        emit Transfer(address(0), delegateInfo.delegateHolder, delegateTokenId);\n        bytes32 newRegistryHash = 0;\n        if (delegateInfo.tokenType == IDelegateRegistry.DelegationType.ERC721) {\n            newRegistryHash = RegistryHashes.erc721Hash(address(this), delegateInfo.rights, delegateInfo.delegateHolder, delegateInfo.tokenId, delegateInfo.tokenContract);\n            StorageHelpers.writeRegistryHash(delegateTokenInfo, delegateTokenId, newRegistryHash);\n            RegistryHelpers.delegateERC721(delegateRegistry, newRegistryHash, delegateInfo);\n        } else if (delegateInfo.tokenType == IDelegateRegistry.DelegationType.ERC20) {\n            StorageHelpers.writeUnderlyingAmount(delegateTokenInfo, delegateTokenId, delegateInfo.amount);\n            newRegistryHash = RegistryHashes.erc20Hash(address(this), delegateInfo.rights, delegateInfo.delegateHolder, delegateInfo.tokenContract);\n            StorageHelpers.writeRegistryHash(delegateTokenInfo, delegateTokenId, newRegistryHash);\n            RegistryHelpers.incrementERC20(delegateRegistry, newRegistryHash, delegateInfo);\n        } else if (delegateInfo.tokenType == IDelegateRegistry.DelegationType.ERC1155) {\n            StorageHelpers.writeUnderlyingAmount(delegateTokenInfo, delegateTokenId, delegateInfo.amount);\n            newRegistryHash = RegistryHashes.erc1155Hash(address(this), delegateInfo.rights, delegateInfo.delegateHolder, delegateInfo.tokenId, delegateInfo.tokenContract);\n            StorageHelpers.writeRegistryHash(delegateTokenInfo, delegateTokenId, newRegistryHash);\n            RegistryHelpers.incrementERC1155(delegateRegistry, newRegistryHash, delegateInfo);\n        }\n        StorageHelpers.mintPrincipal(principalToken, principalMintAuthorization, delegateInfo.principalHolder, delegateTokenId);\n    }\n\n    /// @inheritdoc IDelegateToken\n    function extend(uint256 delegateTokenId, uint256 newExpiry) external {\n        StorageHelpers.revertNotMinted(delegateTokenInfo, delegateTokenId);\n        Helpers.revertOldExpiry(newExpiry);\n        uint256 previousExpiry = StorageHelpers.readExpiry(delegateTokenInfo, delegateTokenId);\n        if (newExpiry <= previousExpiry) revert Errors.ExpiryTooSmall();\n        if (PrincipalToken(principalToken).isApprovedOrOwner(msg.sender, delegateTokenId)) {\n            StorageHelpers.writeExpiry(delegateTokenInfo, delegateTokenId, newExpiry);\n            emit ExpiryExtended(delegateTokenId, previousExpiry, newExpiry);\n            return;\n        }\n        revert Errors.NotApproved(msg.sender, delegateTokenId);\n    }\n\n    /// @inheritdoc IDelegateToken\n    function rescind(uint256 delegateTokenId) external {\n        //slither-disable-next-line timestamp\n        if (StorageHelpers.readExpiry(delegateTokenInfo, delegateTokenId) < block.timestamp) {\n            StorageHelpers.writeApproved(delegateTokenInfo, delegateTokenId, msg.sender);\n            // approve gets reset in transferFrom or this write gets undone if this function call reverts\n        }\n        transferFrom(\n            RegistryHelpers.loadTokenHolder(delegateRegistry, StorageHelpers.readRegistryHash(delegateTokenInfo, delegateTokenId)),\n            IERC721(principalToken).ownerOf(delegateTokenId),\n            delegateTokenId\n        );\n    }\n\n    /// @inheritdoc IDelegateToken\n    function withdraw(uint256 delegateTokenId) external nonReentrant {\n        bytes32 registryHash = StorageHelpers.readRegistryHash(delegateTokenInfo, delegateTokenId);\n        StorageHelpers.writeRegistryHash(delegateTokenInfo, delegateTokenId, bytes32(StorageHelpers.ID_USED));\n        // Sets registry pointer to used flag\n        StorageHelpers.revertNotMinted(registryHash, delegateTokenId);\n        (address delegateTokenHolder, address underlyingContract) = RegistryHelpers.loadTokenHolderAndContract(delegateRegistry, registryHash);\n        StorageHelpers.revertInvalidWithdrawalConditions(delegateTokenInfo, accountOperator, delegateTokenId, delegateTokenHolder);\n        StorageHelpers.decrementBalance(balances, delegateTokenHolder);\n        delete delegateTokenInfo[delegateTokenId][StorageHelpers.PACKED_INFO_POSITION]; // Deletes both expiry and approved\n        emit Transfer(delegateTokenHolder, address(0), delegateTokenId);\n        IDelegateRegistry.DelegationType delegationType = RegistryHashes.decodeType(registryHash);\n        bytes32 underlyingRights = RegistryHelpers.loadRights(delegateRegistry, registryHash);\n        if (delegationType == IDelegateRegistry.DelegationType.ERC721) {\n            uint256 erc721UnderlyingTokenId = RegistryHelpers.loadTokenId(delegateRegistry, registryHash);\n            RegistryHelpers.revokeERC721(delegateRegistry, registryHash, delegateTokenHolder, underlyingContract, erc721UnderlyingTokenId, underlyingRights);\n            StorageHelpers.burnPrincipal(principalToken, principalBurnAuthorization, delegateTokenId);\n            IERC721(underlyingContract).transferFrom(address(this), msg.sender, erc721UnderlyingTokenId);\n        } else if (delegationType == IDelegateRegistry.DelegationType.ERC20) {\n            uint256 erc20UnderlyingAmount = StorageHelpers.readUnderlyingAmount(delegateTokenInfo, delegateTokenId);\n            StorageHelpers.writeUnderlyingAmount(delegateTokenInfo, delegateTokenId, 0); // Deletes amount\n            RegistryHelpers.decrementERC20(delegateRegistry, registryHash, delegateTokenHolder, underlyingContract, erc20UnderlyingAmount, underlyingRights);\n            StorageHelpers.burnPrincipal(principalToken, principalBurnAuthorization, delegateTokenId);\n            SafeERC20.safeTransfer(IERC20(underlyingContract), msg.sender, erc20UnderlyingAmount);\n        } else if (delegationType == IDelegateRegistry.DelegationType.ERC1155) {\n            uint256 erc1155UnderlyingAmount = StorageHelpers.readUnderlyingAmount(delegateTokenInfo, delegateTokenId);\n            StorageHelpers.writeUnderlyingAmount(delegateTokenInfo, delegateTokenId, 0); // Deletes amount\n            uint256 erc11551UnderlyingTokenId = RegistryHelpers.loadTokenId(delegateRegistry, registryHash);\n            RegistryHelpers.decrementERC1155(\n                delegateRegistry, registryHash, delegateTokenHolder, underlyingContract, erc11551UnderlyingTokenId, erc1155UnderlyingAmount, underlyingRights\n            );\n            StorageHelpers.burnPrincipal(principalToken, principalBurnAuthorization, delegateTokenId);\n            IERC1155(underlyingContract).safeTransferFrom(address(this), msg.sender, erc11551UnderlyingTokenId, erc1155UnderlyingAmount, \"\");\n        }\n    }\n\n    /// @inheritdoc IDelegateToken\n    function flashloan(Structs.FlashInfo calldata info) external payable nonReentrant {\n        StorageHelpers.revertNotOperator(accountOperator, info.delegateHolder);\n        if (info.tokenType == IDelegateRegistry.DelegationType.ERC721) {\n            RegistryHelpers.revertERC721FlashUnavailable(delegateRegistry, info);\n            IERC721(info.tokenContract).transferFrom(address(this), info.receiver, info.tokenId);\n            Helpers.revertOnCallingInvalidFlashloan(info);\n            TransferHelpers.checkERC721BeforePull(info.amount, info.tokenContract, info.tokenId);\n            TransferHelpers.pullERC721AfterCheck(info.tokenContract, info.tokenId);\n        } else if (info.tokenType == IDelegateRegistry.DelegationType.ERC20) {\n            RegistryHelpers.revertERC20FlashAmountUnavailable(delegateRegistry, info);\n            SafeERC20.safeTransfer(IERC20(info.tokenContract), info.receiver, info.amount);\n            Helpers.revertOnCallingInvalidFlashloan(info);\n            TransferHelpers.checkERC20BeforePull(info.amount, info.tokenContract, info.tokenId);\n            TransferHelpers.pullERC20AfterCheck(info.tokenContract, info.amount);\n        } else if (info.tokenType == IDelegateRegistry.DelegationType.ERC1155) {\n            RegistryHelpers.revertERC1155FlashAmountUnavailable(delegateRegistry, info);\n            TransferHelpers.checkERC1155BeforePull(erc1155PullAuthorization, info.amount);\n            IERC1155(info.tokenContract).safeTransferFrom(address(this), info.receiver, info.tokenId, info.amount, \"\");\n            Helpers.revertOnCallingInvalidFlashloan(info);\n            TransferHelpers.pullERC1155AfterCheck(erc1155PullAuthorization, info.amount, info.tokenContract, info.tokenId);\n        }\n    }\n}"
    }
  ]
}