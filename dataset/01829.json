{
  "Title": "Possible reverts due to using stricter requirements in inner swap",
  "Content": "**Description:**\n`VeryFastRouter::swap` relies on the internal functions `VeryFastRouter::_findMaxFillableAmtForSell` and `VeryFastRouter::_findMaxFillableAmtForBuy` to find the maximum possible amount of tokens to be swapped.\nThe output is supposed to be the _actual_ cost of the swap, and it is used as the [`minExpectedTokenOutput`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/erc721/LSSVMPairERC721.sol#L92) parameter for selling logic and the [`maxExpectedTokenInput`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/erc721/LSSVMPairERC721.sol#L32) parameter for buying logic; however, this is problematic and can lead to protocol unintended protocol behavior because the actual cost of the swap can differ from the output of these functions. We pointed out the issue with linearity assumptions in another finding, but we are raising this separately because the actual pair's swap function is being called with stricter requirements.\n\n```solidity\nVeryFastRouter.sol\n326:                 uint256 numItemsToFill;\n327:                 uint256 priceToFillAt;\n328:\n329:                 {\n330:                     // Grab royalty for calc in _findMaxFillableAmtForSell\n331:                     (,, uint256 royaltyAmount) = order.pair.calculateRoyaltiesView(\n332:                         order.isERC721 ? order.nftIds[0] : LSSVMPairERC1155(address(order.pair)).nftId(), BASE\n333:                     );\n334:\n335:                     // Calculate the max number of items we can sell\n336:                     (numItemsToFill, priceToFillAt) = _findMaxFillableAmtForSell(//@audit-info priceToFillAt >= order.minExpectedOutputPerNumNFTs\n337:                         order.pair,\n338:                         pairSpotPrice,\n339:                         order.minExpectedOutputPerNumNFTs,\n340:                         protocolFeeMultiplier,\n341:                         royaltyAmount\n342:                     );\n343:                 }\n344:\n345:                 // If we can sell at least 1 item...\n346:                 if (numItemsToFill != 0) {\n347:                     // If property checking is needed, do the property check swap\n348:                     if (order.doPropertyCheck) {\n349:                         outputAmount = ILSSVMPairERC721(address(order.pair)).swapNFTsForToken(\n350:                             order.nftIds[:numItemsToFill],\n351:                             priceToFillAt,//@audit-info min expected output, different from the one specified by the user\n352:                             swapOrder.tokenRecipient,\n353:                             true,\n354:                             msg.sender,\n355:                             order.propertyCheckParams\n356:                         );\n357:                     }\n358:                     // Otherwise do a normal sell swap\n359:                     else {\n360:                         // Get subarray if ERC721\n361:                         if (order.isERC721) {\n362:                             outputAmount = order.pair.swapNFTsForToken(\n363:                                 order.nftIds[:numItemsToFill], priceToFillAt, swapOrder.tokenRecipient, true, msg.sender//@audit-info min expected output, different from the one specified by the user\n364:                             );\n365:                         }\n366:                         // For 1155 swaps, wrap as number\n367:                         else {\n368:                             outputAmount = order.pair.swapNFTsForToken(\n369:                                 _wrapUintAsArray(numItemsToFill),\n370:                                 priceToFillAt,\n371:                                 swapOrder.tokenRecipient,\n372:                                 true,\n373:                                 msg.sender\n374:                             );\n375:                         }\n376:                     }\n377:                 }\n\n```\n\nIf the actual sale of the swap is lower than the output of `VeryFastRouter::_findMaxFillableAmtForSell` and `VeryFastRouter::_findMaxFillableAmtForBuy`, the swap will fail, but it could have passed if the original `minExpectedOutputPerNumNFTs` and `maxCostPerNumNFTs` were used instead.\nIf it can be guaranteed that the output of `VeryFastRouter::_findMaxFillableAmtForSell` and `VeryFastRouter::_findMaxFillableAmtForBuy` will always represent the exact sale/cost, this may be fine, but it is not clear why the original `minExpectedOutputPerNumNFTs` and `maxCostPerNumNFTs` are not used.\n\n**Impact:**\nAlthough this does not lead to direct loss of funds, we are evaluating the severity of MEDIUM because it can lead to unintended protocol behavior.\n\n**Recommended Mitigation:**\nWe recommend using `minExpectedOutputPerNumNFTs` and `maxCostPerNumNFTs` instead of the output of `VeryFastRouter::_findMaxFillableAmtForSell` and `VeryFastRouter::_findMaxFillableAmtForBuy` as arguments to the actual swap functions.\n\n**Sudoswap:**\nAcknowledged. Given that the input values are expected to be returned from the Bonding Curve, this is likely to be an extremely rare occurance.\n\n**Cyfrin:**\nAcknowledged.",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/erc721/LSSVMPairERC721.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\n\nimport {LSSVMPair} from \"../LSSVMPair.sol\";\nimport {LSSVMRouter} from \"../LSSVMRouter.sol\";\nimport {ICurve} from \"../bonding-curves/ICurve.sol\";\nimport {ILSSVMPairFactoryLike} from \"../ILSSVMPairFactoryLike.sol\";\nimport {IPropertyChecker} from \"../property-checking/IPropertyChecker.sol\";\n\n/// @title LSSVMPairERC721\n/// @author boredGenius and 0xmons\n/// @notice An NFT/Token pair for an ERC721 NFT\nabstract contract LSSVMPairERC721 is LSSVMPair {\n    error LSSVMPairERC721__PropertyCheckFailed();\n    error LSSVMPairERC721__NeedPropertyChecking();\n\n    /**\n     * External state-changing functions\n     */\n\n    /**\n     * @inheritdoc LSSVMPair\n     */\n    function swapTokenForSpecificNFTs(\n        uint256[] calldata nftIds,\n        uint256 maxExpectedTokenInput,\n        address nftRecipient,\n        bool isRouter,\n        address routerCaller\n    ) external payable virtual override returns (uint256) {\n        // Store locally to remove extra calls\n        factory().openLock();\n\n        // Input validation\n        {\n            PoolType _poolType = poolType();\n            if (_poolType == PoolType.TOKEN) revert LSSVMPair__WrongPoolType();\n            if (nftIds.length == 0) revert LSSVMPair__ZeroSwapAmount();\n        }\n\n        // Call bonding curve for pricing information\n        uint256 protocolFee;\n        uint256 tradeFee;\n        uint256 inputAmountExcludingRoyalty;\n        (tradeFee, protocolFee, inputAmountExcludingRoyalty) =\n            _calculateBuyInfoAndUpdatePoolParams(nftIds.length, bondingCurve(), factory());\n\n        // Calculate royalties\n        (address payable[] memory royaltyRecipients, uint256[] memory royaltyAmounts, uint256 royaltyTotal) =\n            _calculateRoyalties(nftIds[0], inputAmountExcludingRoyalty - protocolFee - tradeFee);\n\n        // Revert if the input amount is too large\n        if (royaltyTotal + inputAmountExcludingRoyalty > maxExpectedTokenInput) {\n            revert LSSVMPair__DemandedInputTooLarge();\n        }\n\n        _pullTokenInputs({\n            inputAmountExcludingRoyalty: inputAmountExcludingRoyalty,\n            royaltyAmounts: royaltyAmounts,\n            royaltyRecipients: royaltyRecipients,\n            royaltyTotal: royaltyTotal,\n            tradeFeeAmount: 2 * tradeFee,\n            isRouter: isRouter,\n            routerCaller: routerCaller,\n            protocolFee: protocolFee\n        });\n\n        {\n            _sendSpecificNFTsToRecipient(IERC721(nft()), nftRecipient, nftIds);\n        }\n\n        _refundTokenToSender(royaltyTotal + inputAmountExcludingRoyalty);\n\n        factory().closeLock();\n\n        emit SwapNFTOutPair(royaltyTotal + inputAmountExcludingRoyalty, nftIds);\n\n        return (royaltyTotal + inputAmountExcludingRoyalty);\n    }\n\n    /**\n     * @inheritdoc LSSVMPair\n     */\n    function swapNFTsForToken(\n        uint256[] calldata nftIds,\n        uint256 minExpectedTokenOutput,\n        address payable tokenRecipient,\n        bool isRouter,\n        address routerCaller\n    ) external virtual override returns (uint256 outputAmount) {\n        {\n            if (propertyChecker() != address(0)) revert LSSVMPairERC721__NeedPropertyChecking();\n        }\n\n        return _swapNFTsForToken(nftIds, minExpectedTokenOutput, tokenRecipient, isRouter, routerCaller);\n    }\n\n    /**\n     * @notice Sends a set of NFTs to the pair in exchange for token\n     *     @dev To compute the amount of token to that will be received, call bondingCurve.getSellInfo.\n     *     @param nftIds The list of IDs of the NFTs to sell to the pair\n     *     @param minExpectedTokenOutput The minimum acceptable token received by the sender. If the actual\n     *     amount is less than this value, the transaction will be reverted.\n     *     @param tokenRecipient The recipient of the token output\n     *     @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for\n     *     ETH pairs.\n     *     @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for\n     *     ETH pairs.\n     *     @param propertyCheckerParams Parameters to pass into the pair's underlying property checker\n     *     @return outputAmount The amount of token received\n     */\n    function swapNFTsForToken(\n        uint256[] calldata nftIds,\n        uint256 minExpectedTokenOutput,\n        address payable tokenRecipient,\n        bool isRouter,\n        address routerCaller,\n        bytes calldata propertyCheckerParams\n    ) external virtual returns (uint256 outputAmount) {\n        if (!IPropertyChecker(propertyChecker()).hasProperties(nftIds, propertyCheckerParams)) {\n            revert LSSVMPairERC721__PropertyCheckFailed();\n        }\n\n        return _swapNFTsForToken(nftIds, minExpectedTokenOutput, tokenRecipient, isRouter, routerCaller);\n    }\n\n    /**\n     * View functions\n     */\n\n    /**\n     * @notice Returns the property checker address\n     */\n    function propertyChecker() public pure returns (address _propertyChecker) {\n        uint256 paramsLength = _immutableParamsLength();\n        assembly {\n            _propertyChecker := shr(0x60, calldataload(add(sub(calldatasize(), paramsLength), 61)))\n        }\n    }\n\n    /**\n     * Internal functions\n     */\n\n    function _swapNFTsForToken(\n        uint256[] calldata nftIds,\n        uint256 minExpectedTokenOutput,\n        address payable tokenRecipient,\n        bool isRouter,\n        address routerCaller\n    ) internal virtual returns (uint256 outputAmount) {\n        // Store locally to remove extra calls\n        ILSSVMPairFactoryLike _factory = factory();\n\n        _factory.openLock();\n\n        // Input validation\n        {\n            PoolType _poolType = poolType();\n            if (_poolType == PoolType.NFT) revert LSSVMPair__WrongPoolType();\n            if (nftIds.length == 0) revert LSSVMPair__ZeroSwapAmount();\n        }\n\n        // Call bonding curve for pricing information\n        uint256 protocolFee;\n        (protocolFee, outputAmount) = _calculateSellInfoAndUpdatePoolParams(nftIds.length, bondingCurve(), _factory);\n\n        // Compute royalties\n        (address payable[] memory royaltyRecipients, uint256[] memory royaltyAmounts, uint256 royaltyTotal) =\n            _calculateRoyalties(nftIds[0], outputAmount);\n\n        // Deduct royalties from outputAmount\n        unchecked {\n            // Safe because we already require outputAmount >= royaltyTotal in calculateRoyalties()\n            outputAmount -= royaltyTotal;\n        }\n\n        if (outputAmount < minExpectedTokenOutput) revert LSSVMPair__OutputTooSmall();\n\n        _takeNFTsFromSender(IERC721(nft()), nftIds, _factory, isRouter, routerCaller);\n\n        _sendTokenOutput(tokenRecipient, outputAmount);\n        for (uint256 i; i < royaltyRecipients.length;) {\n            _sendTokenOutput(royaltyRecipients[i], royaltyAmounts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        _sendTokenOutput(payable(address(_factory)), protocolFee);\n\n        _factory.closeLock();\n\n        emit SwapNFTInPair(outputAmount, nftIds);\n    }\n\n    /**\n     * @notice Sends specific NFTs to a recipient address\n     *     @dev Even though we specify the NFT address here, this internal function is only\n     *     used to send NFTs associated with this specific pool.\n     *     @param _nft The address of the NFT to send\n     *     @param nftRecipient The receiving address for the NFTs\n     *     @param nftIds The specific IDs of NFTs to send\n     */\n    function _sendSpecificNFTsToRecipient(IERC721 _nft, address nftRecipient, uint256[] calldata nftIds)\n        internal\n        virtual\n    {\n        // Send NFTs to recipient\n        uint256 numNFTs = nftIds.length;\n        for (uint256 i; i < numNFTs;) {\n            _nft.transferFrom(address(this), nftRecipient, nftIds[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Takes NFTs from the caller and sends them into the pair's asset recipient\n     *     @dev This is used by the LSSVMPair's swapNFTForToken function.\n     *     @param _nft The NFT collection to take from\n     *     @param nftIds The specific NFT IDs to take\n     *     @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for\n     *     ETH pairs.\n     *     @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for\n     *     ETH pairs.\n     */\n    function _takeNFTsFromSender(\n        IERC721 _nft,\n        uint256[] calldata nftIds,\n        ILSSVMPairFactoryLike _factory,\n        bool isRouter,\n        address routerCaller\n    ) internal virtual {\n        {\n            address _assetRecipient = getAssetRecipient();\n            uint256 numNFTs = nftIds.length;\n\n            if (isRouter) {\n                // Verify if router is allowed\n                LSSVMRouter router = LSSVMRouter(payable(msg.sender));\n                (bool routerAllowed,) = _factory.routerStatus(router);\n                if (!routerAllowed) revert LSSVMPair__NotRouter();\n\n                // Call router to pull NFTs\n                // If more than 1 NFT is being transfered, and there is no property checker, we can do a balance check instead of an ownership check, as pools are indifferent between NFTs from the same collection\n                if ((numNFTs > 1) && (propertyChecker() == address(0))) {\n                    uint256 beforeBalance = _nft.balanceOf(_assetRecipient);\n                    for (uint256 i = 0; i < numNFTs;) {\n                        router.pairTransferNFTFrom(_nft, routerCaller, _assetRecipient, nftIds[i]);\n\n                        unchecked {\n                            ++i;\n                        }\n                    }\n                    if (_nft.balanceOf(_assetRecipient) - beforeBalance != numNFTs) {\n                        revert LSSVMPair__NftNotTransferred();\n                    }\n                }\n                // Otherwise we need to pull each asset 1 at a time and verify ownership\n                else {\n                    for (uint256 i; i < numNFTs;) {\n                        router.pairTransferNFTFrom(_nft, routerCaller, _assetRecipient, nftIds[i]);\n                        if (_nft.ownerOf(nftIds[i]) != _assetRecipient) revert LSSVMPair__NftNotTransferred();\n                        unchecked {\n                            ++i;\n                        }\n                    }\n                }\n            } else {\n                // Pull NFTs directly from sender\n                for (uint256 i; i < numNFTs;) {\n                    _nft.transferFrom(msg.sender, _assetRecipient, nftIds[i]);\n                    unchecked {\n                        ++i;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Owner functions\n     */\n\n    /**\n     * @notice Rescues a specified set of NFTs owned by the pair to the owner address. (onlyOwner modifier is in the implemented function)\n     *     @param a The NFT to transfer\n     *     @param nftIds The list of IDs of the NFTs to send to the owner\n     */\n    function withdrawERC721(IERC721 a, uint256[] calldata nftIds) external virtual override onlyOwner {\n        uint256 numNFTs = nftIds.length;\n        for (uint256 i; i < numNFTs;) {\n            a.safeTransferFrom(address(this), msg.sender, nftIds[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (a == IERC721(nft())) {\n            emit NFTWithdrawal(nftIds);\n        }\n    }\n\n    /**\n     * @notice Rescues ERC1155 tokens from the pair to the owner. Only callable by the owner.\n     *     @param a The NFT to transfer\n     *     @param ids The NFT ids to transfer\n     *     @param amounts The amounts of each id to transfer\n     */\n    function withdrawERC1155(IERC1155 a, uint256[] calldata ids, uint256[] calldata amounts)\n        external\n        virtual\n        override\n        onlyOwner\n    {\n        a.safeBatchTransferFrom(address(this), msg.sender, ids, amounts, \"\");\n    }\n}"
    }
  ]
}