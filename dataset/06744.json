{
  "Title": "[G-06] Unnecessary casting as variable is already of the same type",
  "Content": "https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/MintingHub.sol#L124-L132\n### MintingHub.sol.clonePosition(): pos should not be  cast to address as it's declared as an address\n```solidity\nFile: /contracts/MintingHub.sol\n124:    function clonePosition(address position, uint256 _initialCollateral, uint256 _initialMint) public validPos(position) returns (address) {\n125:        IPosition existing = IPosition(position);\n126:        uint256 limit = existing.reduceLimitForClone(_initialMint);\n127:        address pos = POSITION_FACTORY.clonePosition(position);\n128:        zchf.registerPosition(pos);\n129:        existing.collateral().transferFrom(msg.sender, address(pos), _initialCollateral);\n130:        IPosition(pos).initializeClone(msg.sender, existing.price(), limit, _initialCollateral, _initialMint);\n131:        return address(pos);\n132:    }\n```\n\n```diff\ndiff --git a/contracts/MintingHub.sol b/contracts/MintingHub.sol\nindex 663b205..c69c0c2 100644\n--- a/contracts/MintingHub.sol\n+++ b/contracts/MintingHub.sol\n@@ -126,9 +126,9 @@ contract MintingHub {\n         uint256 limit = existing.reduceLimitForClone(_initialMint);\n         address pos = POSITION_FACTORY.clonePosition(position);\n         zchf.registerPosition(pos);\n-        existing.collateral().transferFrom(msg.sender, address(pos), _initialCollateral);\n+        existing.collateral().transferFrom(msg.sender, pos, _initialCollateral);\n         IPosition(pos).initializeClone(msg.sender, existing.price(), limit, _initialCollateral, _initialMint);\n-        return address(pos);\n+        return pos;\n     }\n```\n\n\n## Note: The following have some caveats, we can reduce the deployment size and deployment cost at the expense of execution cost\n\n### Shorthand if (We can rewrite the following )\nhttps://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Frankencoin.sol#L204-L213\n```solidity\nFile: /contracts/Frankencoin.sol\n204:   function calculateAssignedReserve(uint256 mintedAmount, uint32 _reservePPM) public view returns (uint256) {\n205:      uint256 theoreticalReserve = _reservePPM * mintedAmount / 1000000;\n206:      uint256 currentReserve = balanceOf(address(reserve));\n207:      if (currentReserve < minterReserve()){\n208:         // not enough reserves, owner has to take a loss\n209:         return theoreticalReserve * currentReserve / minterReserve();\n210:      } else {\n211:         return theoreticalReserve;\n212:      }\n213:   }\n```\n\n```diff\ndiff --git a/contracts/Frankencoin.sol b/contracts/Frankencoin.sol\nindex e9e87dc..600b805 100644\n--- a/contracts/Frankencoin.sol\n+++ b/contracts/Frankencoin.sol\n@@ -204,12 +204,7 @@ contract Frankencoin is ERC20PermitLight, IFrankencoin {\n    function calculateAssignedReserve(uint256 mintedAmount, uint32 _reservePPM) public view returns (uint256) {\n       uint256 theoreticalReserve = _reservePPM * mintedAmount / 1000000;\n       uint256 currentReserve = balanceOf(address(reserve));\n-      if (currentReserve < minterReserve()){\n-         // not enough reserves, owner has to take a loss\n-         return theoreticalReserve * currentReserve / minterReserve();\n-      } else {\n-         return theoreticalReserve;\n-      }\n+      return currentReserve < minterReserve() ? theoreticalReserve * currentReserve / minterReserve() : theoreticalReserve;\n    }\n```\n\n\nhttps://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Frankencoin.sol#L138-L146\n```solidity\nFile: /contracts/Frankencoin.sol\n138:   function equity() public view returns (uint256) {\n139:      uint256 balance = balanceOf(address(reserve));\n140:      uint256 minReserve = minterReserve();\n141:      if (balance <= minReserve){\n142:        return 0;\n143:      } else {\n144:        return balance - minReserve;\n145:      }\n146:    }\n```\n\n```diff\ndiff --git a/contracts/Frankencoin.sol b/contracts/Frankencoin.sol\nindex e9e87dc..f9fef16 100644\n--- a/contracts/Frankencoin.sol\n+++ b/contracts/Frankencoin.sol\n@@ -138,11 +138,7 @@ contract Frankencoin is ERC20PermitLight, IFrankencoin {\n    function equity() public view returns (uint256) {\n       uint256 balance = balanceOf(address(reserve));\n       uint256 minReserve = minterReserve();\n-      if (balance <= minReserve){\n-        return 0;\n-      } else {\n-        return balance - minReserve;\n-      }\n+      return balance <= minReserve ? 0 : balance - minReserve;\n     }\n```\n\nhttps://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Position.sol#L120-L126\n```solidity\nFile: /contracts/Position.sol\n120:    function getUsableMint(uint256 totalMint, bool afterFees) public view returns (uint256){\n121:        if (afterFees){\n122:            return totalMint * (1000_000 - reserveContribution - calculateCurrentFee()) / 1000_000;\n123:        } else {\n124:            return totalMint * (1000_000 - reserveContribution) / 1000_000;\n125:        }\n126:    }\n```\n\n```diff\ndiff --git a/contracts/Position.sol b/contracts/Position.sol\nindex 3e18534..15183e9 100644\n--- a/contracts/Position.sol\n+++ b/contracts/Position.sol\n@@ -118,11 +118,7 @@ contract Position is Ownable, IPosition, MathUtil {\n      * to buy reserve pool shares.\n      */\n     function getUsableMint(uint256 totalMint, bool afterFees) public view returns (uint256){\n-        if (afterFees){\n-            return totalMint * (1000_000 - reserveContribution - calculateCurrentFee()) / 1000_000;\n-        } else {\n-            return totalMint * (1000_000 - reserveContribution) / 1000_000;\n-        }\n+        return afterFees? totalMint * (1000_000 - reserveContribution - calculateCurrentFee()) / 1000_000 : totalMint * (1000_000 - reserveContribution) / 1000_000;\n     }\n```\n\nhttps://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Position.sol#L181-L189\n```solidity\nFile: /contracts/Position.sol\n181:    function calculateCurrentFee() public view returns (uint32) {\n\n184:        if (time >= exp){\n185:            return 0;\n186:        } else {\n187:            return uint32(mintingFeePPM - mintingFeePPM * (time - start) / (exp - start));\n188:        }\n189:    }\n```\n\n```diff\ndiff --git a/contracts/Position.sol b/contracts/Position.sol\nindex 3e18534..9adc148 100644\n--- a/contracts/Position.sol\n+++ b/contracts/Position.sol\n@@ -181,11 +181,7 @@ contract Position is Ownable, IPosition, MathUtil {\n     function calculateCurrentFee() public view returns (uint32) {\n         uint256 exp = expiration;\n         uint256 time = block.timestamp;\n-        if (time >= exp){\n-            return 0;\n-        } else {\n-            return uint32(mintingFeePPM - mintingFeePPM * (time - start) / (exp - start));\n-        }\n+        return time >= exp ? 0 : uint32(mintingFeePPM - mintingFeePPM * (time - start) / (exp - start));\n     }\n```\n\n**[luziusmeisser (Frankencoin) confirmed and commented](https://github.com/code-423n4/2023-04-frankencoin-findings/issues/956#issuecomment-1528891079):**\n > Went through all of the issues and implemented the recommendations.\n> \n> Exceptions:\n> - **\"Frankencoin.sol.suggestMinter(): Result of totalSupply() should be cached here(sad path)\":** Here, totalSupply() is never called during normal operations as the && operator does not evaluate the second part if the first part is already false. So the recommendation would actually increase gas costs.\n> - **\"Frankencoin.sol.suggestMinter(): minters[\\_minter] should be cached in local storage\":** Second access is not an read, but a write.\n> - **\"Using unchecked blocks to save gas\":** I do not like this optimization as I value concise code higher than saving a little gas here.\n> - **\"shorthand if\":** I usually prefer the longer version to increase readability.\n\n***\n\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-04-frankencoin",
  "Code": [
    {
      "filename": "contracts/MintingHub.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IReserve.sol\";\nimport \"./IFrankencoin.sol\";\nimport \"./Ownable.sol\";\nimport \"./IPosition.sol\";\n\n/**\n * The central hub for creating, cloning and challenging collateralized Frankencoin positions.\n * Only one instance of this contract is required, whereas every new position comes with a new position\n * contract. Pending challenges are stored as structs in an array.\n */\ncontract MintingHub {\n\n    /**\n     * Irrevocable fee in ZCHF when proposing a new position (but not when cloning an existing one).\n     */\n    uint256 public constant OPENING_FEE = 1000 * 10**18;\n\n    /**\n     * The challenger reward in parts per million (ppm) relative to the challenged amount, whereas\n     * challenged amount if defined as the challenged collateral amount times the liquidation price.\n     */\n    uint32 public constant CHALLENGER_REWARD = 20000; // 2%\n\n    IPositionFactory private immutable POSITION_FACTORY; // position contract to clone\n\n    IFrankencoin public immutable zchf; // currency\n    Challenge[] public challenges; // list of open challenges\n\n    /**\n     * Map to remember pending postponed collateral returns.\n     * It maps collateral => beneficiary => amount.\n     */\n    mapping (address /** col */ => mapping (address => uint256)) public pendingReturns;\n\n    struct Challenge {\n        address challenger; // the address from which the challenge was initiated\n        IPosition position; // the position that was challenged\n        uint256 size;       // how much collateral the challenger provided\n        uint256 end;        // the deadline of the challenge (block.timestamp)\n        address bidder;     // the address from which the highest bid was made, if any\n        uint256 bid;        // the highest bid in ZCHF (total amount, not price per unit)\n    }\n\n    event ChallengeStarted(address indexed challenger, address indexed position, uint256 size, uint256 number);\n    event ChallengeAverted(address indexed position, uint256 number);\n    event ChallengeSucceeded(address indexed position, uint256 bid, uint256 number);\n    event NewBid(uint256 challengedId, uint256 bidAmount, address bidder);\n    event PostPonedReturn(address collateral, address indexed beneficiary, uint256 amount);\n\n    constructor(address _zchf, address factory) {\n        zchf = IFrankencoin(_zchf);\n        POSITION_FACTORY = IPositionFactory(factory);\n    }\n\n    function openPosition(\n        address _collateralAddress, uint256 _minCollateral, uint256 _initialCollateral,\n        uint256 _mintingMaximum, uint256 _expirationSeconds, uint256 _challengeSeconds,\n        uint32 _mintingFeePPM, uint256 _liqPrice, uint32 _reservePPM) public returns (address) {\n            return openPosition(_collateralAddress, _minCollateral, _initialCollateral, _mintingMaximum,\n            7 days, _expirationSeconds, _challengeSeconds, _mintingFeePPM, _liqPrice, _reservePPM);\n    }\n\n    /**\n     * Open a collateralized loan position. See also https://docs.frankencoin.com/positions/open .\n     * For a successful call, you must set allowances for both ZCHF and the collateral token, allowing\n     * the minting hub to transfer the initial collateral amount to the newly created position and to\n     * withdraw the fees.\n     *\n     * Together, the expiration and the minting fee imply an interest rate.\n     * TODO: in future versions, it might be better to fix the interest and not the fee\n     *\n     * @param _collateralAddress        address of collateral token\n     * @param _minCollateral     minimum collateral required to prevent dust amounts\n     * @param _initialCollateral amount of initial collateral to be deposited\n     * @param _mintingMaximum    maximal amount of ZCHF that can be minted by the position owner\n     * @param _expirationSeconds position tenor in unit of timestamp (seconds) from 'now'\n     * @param _challengeSeconds  challenge period. Longer for less liquid collateral.\n     * @param _mintingFeePPM     ppm of minted amount that is paid as fee to the equity contract\n     * @param _liqPrice          Liquidation price with (36 - token decimals) decimals,\n     *                           e.g. 18 decimals for an 18 decimal collateral, 36 decimals for a 0 decimal collateral.\n     * @param _reservePPM        ppm of minted amount that is locked as borrower's reserve, e.g. 20%\n     * @return address           address of created position\n     */\n    function openPosition(\n        address _collateralAddress, uint256 _minCollateral, uint256 _initialCollateral,\n        uint256 _mintingMaximum, uint256 _initPeriodSeconds, uint256 _expirationSeconds, uint256 _challengeSeconds,\n        uint32 _mintingFeePPM, uint256 _liqPrice, uint32 _reservePPM) public returns (address) {\n        IPosition pos = IPosition(\n            POSITION_FACTORY.createNewPosition(\n                msg.sender,\n                address(zchf),\n                _collateralAddress,\n                _minCollateral,\n                _mintingMaximum,\n                _initPeriodSeconds,\n                _expirationSeconds,\n                _challengeSeconds,\n                _mintingFeePPM,\n                _liqPrice,\n                _reservePPM\n            )\n        );\n        zchf.registerPosition(address(pos));\n        zchf.transferFrom(msg.sender, address(zchf.reserve()), OPENING_FEE);\n        require(_initialCollateral >= _minCollateral, \"must start with min col\");\n        IERC20(_collateralAddress).transferFrom(msg.sender, address(pos), _initialCollateral);\n\n        return address(pos);\n    }\n\n    modifier validPos(address position) {\n        require(zchf.isPosition(position) == address(this), \"not our pos\");\n        _;\n    }\n\n    /**\n     * Clones an existing position and immediately tries to mint the specified amount using the given amount of collateral.\n     * This requires an allowance to be set on the collateral contract such that the minting hub can withdraw the collateral.\n     */\n    function clonePosition(address position, uint256 _initialCollateral, uint256 _initialMint) public validPos(position) returns (address) {\n        IPosition existing = IPosition(position);\n        uint256 limit = existing.reduceLimitForClone(_initialMint);\n        address pos = POSITION_FACTORY.clonePosition(position);\n        zchf.registerPosition(pos);\n        existing.collateral().transferFrom(msg.sender, address(pos), _initialCollateral);\n        IPosition(pos).initializeClone(msg.sender, existing.price(), limit, _initialCollateral, _initialMint);\n        return address(pos);\n    }\n\n    /**\n     * Launch a challenge on a position\n     * @param _positionAddr      address of the position we want to challenge\n     * @param _collateralAmount  size of the collateral we want to challenge (dec 18)\n     * @return index of the challenge in challenge-array\n     */\n    function launchChallenge(address _positionAddr, uint256 _collateralAmount) external validPos(_positionAddr) returns (uint256) {\n        IPosition position = IPosition(_positionAddr);\n        IERC20(position.collateral()).transferFrom(msg.sender, address(this), _collateralAmount);\n        uint256 pos = challenges.length;\n        challenges.push(Challenge(msg.sender, position, _collateralAmount, block.timestamp + position.challengePeriod(), address(0x0), 0));\n        position.notifyChallengeStarted(_collateralAmount);\n        emit ChallengeStarted(msg.sender, address(position), _collateralAmount, pos);\n        return pos;\n    }\n\n    /**\n     * Splits a challenge into two smaller challenges.\n     * This can be useful to guard an attack, where a challenger launches a challenge so big that most bidders do not\n     * have the liquidity available to bid a sufficient amount. With this function, the can split of smaller slices of\n     * the challenge and avert it piece by piece.\n     */\n    function splitChallenge(uint256 _challengeNumber, uint256 splitOffAmount) external returns (uint256) {\n        Challenge storage challenge = challenges[_challengeNumber];\n        require(challenge.challenger != address(0x0));\n        Challenge memory copy = Challenge(\n            challenge.challenger,\n            challenge.position,\n            splitOffAmount,\n            challenge.end,\n            challenge.bidder,\n            (challenge.bid * splitOffAmount) / challenge.size\n        );\n        challenge.bid -= copy.bid;\n        challenge.size -= copy.size;\n\n        uint256 min = IPosition(challenge.position).minimumCollateral();\n        require(challenge.size >= min);\n        require(copy.size >= min);\n\n        uint256 pos = challenges.length;\n        challenges.push(copy);\n        emit ChallengeStarted(challenge.challenger, address(challenge.position), challenge.size, _challengeNumber);\n        emit ChallengeStarted(copy.challenger, address(copy.position), copy.size, pos);\n        return pos;\n    }\n\n    function minBid(uint256 challenge) public view returns (uint256) {\n        return minBid(challenges[challenge]);\n    }\n\n    /**\n     * The minimum bid size for the next bid. It must be 0.5% higher than the previous bid.\n     */\n    function minBid(Challenge storage challenge) internal view returns (uint256) {\n        return (challenge.bid * 1005) / 1000;\n    }\n\n    /**\n     * Post a bid in ZCHF given an open challenge. Requires a ZCHF allowance from the caller to the minting hub.\n     *\n     * @param _challengeNumber   index of the challenge as broadcast in the event\n     * @param _bidAmountZCHF     how much to bid for the collateral of this challenge (dec 18)\n     * @param expectedSize       size verification to guard against frontrunners doing a split-challenge-attack\n     */\n    function bid(uint256 _challengeNumber, uint256 _bidAmountZCHF, uint256 expectedSize) external {\n        Challenge storage challenge = challenges[_challengeNumber];\n        if (block.timestamp >= challenge.end) revert TooLate();\n        if (expectedSize != challenge.size) revert UnexpectedSize();\n        if (challenge.bid > 0) {\n            zchf.transfer(challenge.bidder, challenge.bid); // return old bid\n        }\n        emit NewBid(_challengeNumber, _bidAmountZCHF, msg.sender);\n        // ask position if the bid was high enough to avert the challenge\n        if (challenge.position.tryAvertChallenge(challenge.size, _bidAmountZCHF)) {\n            // bid was high enough, let bidder buy collateral from challenger\n            zchf.transferFrom(msg.sender, challenge.challenger, _bidAmountZCHF);\n            challenge.position.collateral().transfer(msg.sender, challenge.size);\n            emit ChallengeAverted(address(challenge.position), _challengeNumber);\n            delete challenges[_challengeNumber];\n        } else {\n            // challenge is not averted, update bid\n            if (_bidAmountZCHF < minBid(challenge)) revert BidTooLow(_bidAmountZCHF, minBid(challenge));\n            uint256 earliestEnd = block.timestamp + 30 minutes;\n            if (earliestEnd >= challenge.end) {\n                // bump remaining time like ebay does when last minute bids come in\n                // An attacker trying to postpone the challenge forever must increase the bid by 0.5%\n                // every 30 minutes, or double it every three days, making the attack hard to sustain\n                // for a prolonged period of time.\n                challenge.end = earliestEnd;\n            }\n            zchf.transferFrom(msg.sender, address(this), _bidAmountZCHF);\n            challenge.bid = _bidAmountZCHF;\n            challenge.bidder = msg.sender;\n        }\n    }\n\n    error TooLate();\n    error UnexpectedSize();\n    error BidTooLow(uint256 bid, uint256 min);\n\n    function end(uint256 _challengeNumber) external {\n        end(_challengeNumber, false);\n    }\n\n    function isChallengeOpen(uint256 _challengeNumber) external view returns (bool) {\n        return challenges[_challengeNumber].end > block.timestamp;\n    }\n\n    /**\n     * Ends a challenge successfully after the auction period ended, whereas successfully means that the challenger\n     * could show that the price of the collateral is too low to make the position well-collateralized.\n     *\n     * In case that the collateral cannot be transfered back to the challenger (i.e. because the collateral token has a blacklist and the\n     * challenger is on it), it is possible to postpone the return of the collateral.\n     *\n     * @param postponeCollateralReturn Can be used to postpone the return of the collateral to the challenger. Usually false. \n     */\n    function end(uint256 _challengeNumber, bool postponeCollateralReturn) public {\n        Challenge storage challenge = challenges[_challengeNumber];\n        require(challenge.challenger != address(0x0));\n        require(block.timestamp >= challenge.end, \"period has not ended\");\n        // challenge must have been successful, because otherwise it would have immediately ended on placing the winning bid\n        returnCollateral(challenge, postponeCollateralReturn);\n        // notify the position that will send the collateral to the bidder. If there is no bid, send the collateral to msg.sender\n        address recipient = challenge.bidder == address(0x0) ? msg.sender : challenge.bidder;\n        (address owner, uint256 effectiveBid, uint256 volume, uint256 repayment, uint32 reservePPM) = challenge.position.notifyChallengeSucceeded(recipient, challenge.bid, challenge.size);\n        if (effectiveBid < challenge.bid) {\n            // overbid, return excess amount\n            IERC20(zchf).transfer(challenge.bidder, challenge.bid - effectiveBid);\n        }\n        uint256 reward = (volume * CHALLENGER_REWARD) / 1000_000;\n        uint256 fundsNeeded = reward + repayment;\n        if (effectiveBid > fundsNeeded){\n            zchf.transfer(owner, effectiveBid - fundsNeeded);\n        } else if (effectiveBid < fundsNeeded){\n            zchf.notifyLoss(fundsNeeded - effectiveBid); // ensure we have enough to pay everything\n        }\n        zchf.transfer(challenge.challenger, reward); // pay out the challenger reward\n        zchf.burn(repayment, reservePPM); // Repay the challenged part\n        emit ChallengeSucceeded(address(challenge.position), challenge.bid, _challengeNumber);\n        delete challenges[_challengeNumber];\n    }\n\n    /**\n     * Challengers can call this method to withdraw collateral whose return was postponed.\n     */\n    function returnPostponedCollateral(address collateral, address target) external {\n        uint256 amount = pendingReturns[collateral][msg.sender];\n        delete pendingReturns[collateral][msg.sender];\n        IERC20(collateral).transfer(target, amount);\n    }\n\n    function returnCollateral(Challenge storage challenge, bool postpone) internal {\n        if (postpone){\n            // Postponing helps in case the challenger was blacklisted on the collateral token or otherwise cannot receive it at the moment.\n            address collateral = address(challenge.position.collateral());\n            pendingReturns[collateral][challenge.challenger] += challenge.size;\n            emit PostPonedReturn(collateral, challenge.challenger, challenge.size);\n        } else {\n            challenge.position.collateral().transfer(challenge.challenger, challenge.size); // return the challenger's collateral\n        }\n    }\n}\n\ninterface IPositionFactory {\n    function createNewPosition(\n        address _owner,\n        address _zchf,\n        address _collateral,\n        uint256 _minCollateral,\n        uint256 _initialLimit,\n        uint256 _initPeriodSeconds,\n        uint256 _duration,\n        uint256 _challengePeriod,\n        uint32 _mintingFeePPM,\n        uint256 _liqPrice,\n        uint32 _reserve\n    ) external returns (address);\n\n    function clonePosition(address _existing) external returns (address);\n}"
    },
    {
      "filename": "contracts/Frankencoin.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ERC20PermitLight.sol\";\nimport \"./Equity.sol\";\nimport \"./IReserve.sol\";\nimport \"./IFrankencoin.sol\";\n\n/**\n * The Frankencoin (ZCHF) is an ERC-20 token that is designed to track the value of the Swiss franc.\n * It is not upgradable, but open to arbitrary minting plugins. These are automatically accepted if none of the\n * qualified pool share holders casts a veto, leading to a flexible but conservative governance.\n *\n * The underlying assumption is that there is one or more qualified pool share (FPS) holders that watch the proposals\n * and veto if necessary. At the same time, it is also assumed that no one vetoes all of them, thereby starving the\n * system. The system can only function as long as all the qualified shareholders act in the interest of the system\n * or at least do not actively sabotage it. As long as everyone believes that the governance works well, no one will\n * ever make an unsound proposal and it won't be necessary to ever cast a veto, making the system self-governing.\n */\ncontract Frankencoin is ERC20PermitLight, IFrankencoin {\n\n   /**\n    * Minimal fee and application period when suggesting a new minter.\n    */\n   uint256 public constant MIN_FEE = 1000 * (10**18);\n   uint256 public immutable MIN_APPLICATION_PERIOD; // for example 10 days\n\n   /**\n    * The contract that holds the reserve.\n    */\n   IReserve override public immutable reserve;\n\n   /**\n    * How much of the reserve belongs to the minters.\n    * Everything else belongs to the pool share holders.\n    * Stored with 6 additional digits of accuracy so no rounding is necessary\n    * when dealing with parts per million (ppm) in reserve calculations.\n    */\n   uint256 private minterReserveE6;\n\n   /**\n    * Map of minters to approval time stamps. If the time stamp is in the past, the minter contract is allowed\n    * to mint Frankencoins.\n    */\n   mapping (address => uint256) public minters;\n\n   /**\n    * List of positions that are allowed to mint and the minter that registered them.\n    */\n   mapping (address => address) public positions;\n\n   event MinterApplied(address indexed minter, uint256 applicationPeriod, uint256 applicationFee, string message);\n   event MinterDenied(address indexed minter, string message);\n\n   /**\n    * Initiates the Frankencoin with the provided minimum application period for new plugins\n    * in seconds, for example 10 days, i.e. 3600*24*10 = 864000\n    */\n   constructor(uint256 _minApplicationPeriod) ERC20(18){\n      MIN_APPLICATION_PERIOD = _minApplicationPeriod;\n      reserve = new Equity(this);\n   }\n\n   function name() override external pure returns (string memory){\n      return \"Frankencoin\";\n   }\n\n   function symbol() override external pure returns (string memory){\n      return \"ZCHF\";\n   }\n\n   /**\n    * Publicly accessible method to suggest a new way of minting Frankencoins.\n    *\n    * The caller has to pay an application fee that is irrevocably lost even if the new minter is vetoed.\n    *\n    * The caller must assume that someone will veto the new minter unless there is broad consensus that the new minter\n    * adds value to the Frankencoin system. Complex proposals should have application periods and applications fees above\n    * the minimum. It is assumed that over time, informal ways to coordinate on new minters emerge. The message parameter\n    * might be useful for initiating further communication. Maybe it contains a link to a website describing the proposed\n    * minter.\n    */\n   function suggestMinter(address _minter, uint256 _applicationPeriod, uint256 _applicationFee, string calldata _message) override external {\n      if (_applicationPeriod < MIN_APPLICATION_PERIOD && totalSupply() > 0) revert PeriodTooShort();\n      if (_applicationFee < MIN_FEE  && totalSupply() > 0) revert FeeTooLow();\n      if (minters[_minter] != 0) revert AlreadyRegistered();\n      _transfer(msg.sender, address(reserve), _applicationFee);\n      minters[_minter] = block.timestamp + _applicationPeriod;\n      emit MinterApplied(_minter, _applicationPeriod, _applicationFee, _message);\n   }\n\n   error PeriodTooShort();\n   error FeeTooLow();\n   error AlreadyRegistered();\n\n   /**\n    * Make the system more user friendly by skipping the allowance in many cases.\n    *\n    * We trust minters and the positions they have created to mint and burn as they please, so\n    * giving them arbitraty allowances does not pose an additional risk.\n    */\n   function allowanceInternal(address owner, address spender) internal view override returns (uint256) {\n      uint256 explicit = super.allowanceInternal(owner, spender);\n      if (explicit > 0){\n         return explicit; // don't waste gas checking minter\n      } else if (isMinter(spender) || isMinter(isPosition(spender))){\n         return INFINITY;\n      } else {\n         return 0;\n      }\n   }\n\n   /**\n    * The reserve provided by the owners of collateralized positions.\n    * The minter reserve can be used to cover losses after all else failed and the equity holders have already been wiped out.\n    */\n   function minterReserve() public view returns (uint256) {\n      return minterReserveE6 / 1000000;\n   }\n\n   /**\n    * Registers a collateralized debt position, thereby giving it the ability to mint Frankencoins.\n    * It is assumed that the responsible minter that registers the position ensures that the position can be trusted.\n    */\n   function registerPosition(address _position) override external {\n      if (!isMinter(msg.sender)) revert NotMinter();\n      positions[_position] = msg.sender;\n   }\n\n   error NotMinter();\n\n   /**\n    * The amount of equity of the Frankencoin system in ZCHF, owned by the holders of Frankencoin Pool Shares.\n    * Note that the equity contract technically holds both the minter reserve as well as the equity, so the minter\n    * reserve must be subtracted. All fees and other kind of income is added to the Equity contract and essentially\n    * constitutes profits attributable to the pool share holders.\n    */\n   function equity() public view returns (uint256) {\n      uint256 balance = balanceOf(address(reserve));\n      uint256 minReserve = minterReserve();\n      if (balance <= minReserve){\n        return 0;\n      } else {\n        return balance - minReserve;\n      }\n    }\n\n   /**\n    * Qualified pool share holders can deny minters during the application period.\n    * Calling this function is relatively cheap thanks to the deletion of a storage slot.\n    */\n   function denyMinter(address _minter, address[] calldata _helpers, string calldata _message) override external {\n      if (block.timestamp > minters[_minter]) revert TooLate();\n      reserve.checkQualified(msg.sender, _helpers);\n      delete minters[_minter];\n      emit MinterDenied(_minter, _message);\n   }\n\n   error TooLate();\n\n   /**\n    * Mints the provided amount of ZCHF to the target address, automatically forwarding\n    * the minting fee and the reserve to the right place.\n    */\n   function mint(address _target, uint256 _amount, uint32 _reservePPM, uint32 _feesPPM) override external minterOnly {\n      uint256 usableMint = (_amount * (1000_000 - _feesPPM - _reservePPM)) / 1000_000; // rounding down is fine\n      _mint(_target, usableMint);\n      _mint(address(reserve), _amount - usableMint); // rest goes to equity as reserves or as fees\n      minterReserveE6 += _amount * _reservePPM; // minter reserve must be kept accurately in order to ensure we can get back to exactly 0\n   }\n\n   function mint(address _target, uint256 _amount) override external minterOnly {\n      _mint(_target, _amount);\n   }\n\n   /**\n    * Anyone is allowed to burn their ZCHF.\n    */\n   function burn(uint256 _amount) external {\n      _burn(msg.sender, _amount);\n   }\n\n   /**\n    * Burn that amount without reclaiming the reserve, but freeing it up and thereby essentially donating it to the pool\n    * share holders. This can make sense in combination with 'notifyLoss', i.e. when it is the pool share holders that bear the risk\n    * and depending on the outcome they make a profit or a loss.\n    *\n    * Design rule: Minters calling this method are only allowed to so for tokens amounts they previously minted with the same _reservePPM amount.\n    *\n    * For example, if someone minted 50 ZCHF earlier with a 20% reserve requirement (200000 ppm), they got 40 ZCHF and paid\n    * 10 ZCHF into the reserve. Now they want to repay the debt by burning 50 ZCHF. When doing so using this method, 50 ZCHF get\n    * burned and on top of that, 10 ZCHF previously assigned to the minter's reserved are reassigned to the pool share holders.\n    */\n   function burn(uint256 amount, uint32 reservePPM) external override minterOnly {\n      _burn(msg.sender, amount);\n      minterReserveE6 -= amount * reservePPM;\n   }\n\n   /**\n    * Calculates the reserve attributable to someone who minted the given amount with the given reserve requirement.\n    * Under normal circumstances, this is just the reserver requirement multiplied by the amount. However, after a severe loss\n    * of capital that burned into the minter's reserve, this can also be less than that.\n    */\n   function calculateAssignedReserve(uint256 mintedAmount, uint32 _reservePPM) public view returns (uint256) {\n      uint256 theoreticalReserve = _reservePPM * mintedAmount / 1000000;\n      uint256 currentReserve = balanceOf(address(reserve));\n      if (currentReserve < minterReserve()){\n         // not enough reserves, owner has to take a loss\n         return theoreticalReserve * currentReserve / minterReserve();\n      } else {\n         return theoreticalReserve;\n      }\n   }\n\n   /**\n    * Burns the target amount taking the tokens to be burned from the payer and the payer's reserve.\n    * The caller is only allowed to use this method for tokens also minted through the caller with the same _reservePPM amount.\n    *\n    * Example: the calling contract has previously minted 100 ZCHF with a reserve ratio of 20% (i.e. 200000 ppm). To burn half\n    * of that again, the minter calls burnFrom with a target amount of 50 ZCHF. Assuming that reserves are only 90% covered,\n    * this call will deduct 41 ZCHF from the payer's balance and 9 from the reserve, while reducing the minter reserve by 10.\n    */\n   function burnFrom(address payer, uint256 targetTotalBurnAmount, uint32 _reservePPM) external override minterOnly returns (uint256) {\n      uint256 assigned = calculateAssignedReserve(targetTotalBurnAmount, _reservePPM);\n      _transfer(address(reserve), payer, assigned); // send reserve to owner\n      _burn(payer, targetTotalBurnAmount); // and burn the full amount from the owner's address\n      minterReserveE6 -= targetTotalBurnAmount * _reservePPM; // reduce reserve requirements by original ratio\n      return assigned;\n   }\n\n   /**\n    * Calculate the amount that is freed when returning amountExcludingReserve given a reserve ratio of reservePPM, taking\n    * into account potential losses. Example values in the comments.\n    */\n   function calculateFreedAmount(uint256 amountExcludingReserve /* 41 */, uint32 reservePPM /* 20% */) public view returns (uint256){\n      uint256 currentReserve = balanceOf(address(reserve)); // 18, 10% below what we should have\n      uint256 minterReserve_ = minterReserve(); // 20\n      uint256 adjustedReservePPM = currentReserve < minterReserve_ ? reservePPM * currentReserve / minterReserve_ : reservePPM; // 18%\n      return 1000000 * amountExcludingReserve / (1000000 - adjustedReservePPM); // 41 / (1-18%) = 50\n   }\n\n   /**\n    * Burns the provided number of tokens plus whatever reserves are associated with that amount given the reserve requirement.\n    * The caller is only allowed to use this method for tokens also minted through the caller with the same _reservePPM amount.\n    *\n    * Example: the calling contract has previously minted 100 ZCHF with a reserve ratio of 20% (i.e. 200000 ppm). Now they have\n    * 41 ZCHF that they do not need so they decide to repay that amount. Assuming the reserves are only 90% covered,\n    * the call to burnWithReserve will burn the 41 plus 9 from the reserve, reducing the outstanding 'debt' of the caller by\n    * 50 ZCHF in total. This total is returned by the method so the caller knows how much less they owe.\n    */\n   function burnWithReserve(uint256 _amountExcludingReserve, uint32 _reservePPM) external override minterOnly returns (uint256) {\n      uint256 freedAmount = calculateFreedAmount(_amountExcludingReserve, _reservePPM);\n      minterReserveE6 -= freedAmount * _reservePPM; // reduce reserve requirements by original ratio\n      _transfer(address(reserve), msg.sender, freedAmount - _amountExcludingReserve); // collect assigned reserve, maybe less than original reserve\n      _burn(msg.sender, freedAmount); // burn the rest of the freed amount\n      return freedAmount;\n   }\n\n   /**\n    * Burn someone elses ZCHF.\n    */\n   function burn(address _owner, uint256 _amount) override external minterOnly {\n      _burn(_owner, _amount);\n   }\n\n   modifier minterOnly() {\n      if (!isMinter(msg.sender) && !isMinter(positions[msg.sender])) revert NotMinter();\n      _;\n   }\n\n   /**\n    * Notify the Frankencoin that a minter lost economic access to some coins. This does not mean that the coins\n    * are literally lost. It just means that some ZCHF will likely never be repaid and that in order to bring the system\n    * back into balance, the lost amount of ZCHF must be removed from the reserve instead.\n    *\n    * For example, if a minter printed 1 million ZCHF for a mortgage and the mortgage turned out to be unsound with the\n    * house only yielding 800'000 in the subsequent auction, there is a loss of 200'000 that needs to be covered by the \n    * reserve.\n    */\n   function notifyLoss(uint256 _amount) override external minterOnly {\n      uint256 reserveLeft = balanceOf(address(reserve));\n      if (reserveLeft >= _amount){\n         _transfer(address(reserve), msg.sender, _amount);\n      } else {\n         _transfer(address(reserve), msg.sender, reserveLeft);\n         _mint(msg.sender, _amount - reserveLeft);\n      }\n   }\n\n   /**\n    * Returns true if the address is an approved minter.\n    */\n   function isMinter(address _minter) override public view returns (bool){\n      return minters[_minter] != 0 && block.timestamp >= minters[_minter];\n   }\n\n   /**\n    * Returns the address of the minter that created this position or null if the provided address is unknown.\n    */\n   function isPosition(address _position) override public view returns (address){\n      return positions[_position];\n   }\n\n}"
    },
    {
      "filename": "contracts/Frankencoin.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ERC20PermitLight.sol\";\nimport \"./Equity.sol\";\nimport \"./IReserve.sol\";\nimport \"./IFrankencoin.sol\";\n\n/**\n * The Frankencoin (ZCHF) is an ERC-20 token that is designed to track the value of the Swiss franc.\n * It is not upgradable, but open to arbitrary minting plugins. These are automatically accepted if none of the\n * qualified pool share holders casts a veto, leading to a flexible but conservative governance.\n *\n * The underlying assumption is that there is one or more qualified pool share (FPS) holders that watch the proposals\n * and veto if necessary. At the same time, it is also assumed that no one vetoes all of them, thereby starving the\n * system. The system can only function as long as all the qualified shareholders act in the interest of the system\n * or at least do not actively sabotage it. As long as everyone believes that the governance works well, no one will\n * ever make an unsound proposal and it won't be necessary to ever cast a veto, making the system self-governing.\n */\ncontract Frankencoin is ERC20PermitLight, IFrankencoin {\n\n   /**\n    * Minimal fee and application period when suggesting a new minter.\n    */\n   uint256 public constant MIN_FEE = 1000 * (10**18);\n   uint256 public immutable MIN_APPLICATION_PERIOD; // for example 10 days\n\n   /**\n    * The contract that holds the reserve.\n    */\n   IReserve override public immutable reserve;\n\n   /**\n    * How much of the reserve belongs to the minters.\n    * Everything else belongs to the pool share holders.\n    * Stored with 6 additional digits of accuracy so no rounding is necessary\n    * when dealing with parts per million (ppm) in reserve calculations.\n    */\n   uint256 private minterReserveE6;\n\n   /**\n    * Map of minters to approval time stamps. If the time stamp is in the past, the minter contract is allowed\n    * to mint Frankencoins.\n    */\n   mapping (address => uint256) public minters;\n\n   /**\n    * List of positions that are allowed to mint and the minter that registered them.\n    */\n   mapping (address => address) public positions;\n\n   event MinterApplied(address indexed minter, uint256 applicationPeriod, uint256 applicationFee, string message);\n   event MinterDenied(address indexed minter, string message);\n\n   /**\n    * Initiates the F"
    }
  ]
}