{
  "Title": "[G-03] Multiple accesses of a mapping/array should use a storage pointer",
  "Content": "Caching a mapping's value in a storage pointer when the value is accessed multiple times saves ~40 gas per access due to not having to perform the same offset calculation every time. Help the Optimizer by saving a storage variable's reference instead of repeatedly fetching it.\n\nTo achieve this, declare a storage pointer for the variable and use it instead of repeatedly fetching the reference in a map or an array. As an example, instead of repeatedly calling `proposals[_proposalId]`, save its reference via a storage pointer: `Proposal storage proposal_ = proposals[_proposalId]` and use the pointer instead.\n\nTotal instances: 4\n\nGas savings: `2 * 40 + 147 (from 2 benchmarked instances) = 227`\n\nhttps://github.com/code-423n4/2023-03-aragon/blob/main/packages/contracts/src/plugins/governance/multisig/Multisig.sol#L348-L359\n\n### Gas Savings for `execute()`, obtained via protocol's tests: Avg 147 gas | Use storage pointer `proposal_` instead of re-accessing the mapping.\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  70489  |  72989  |  71991 |    10     |\n| After  |  70342  |  72842  |  71844 |    10     |\n```solidity\nFile: src/plugins/governance/multisig/Multisig.sol\n348:    function _execute(uint256 _proposalId) internal {\n349:        Proposal storage proposal_ = proposals[_proposalId];\n350:\n351:        proposal_.executed = true;\n352:\n353:        _executeProposal(\n354:            dao(),\n355:            _proposalId,\n356:            proposals[_proposalId].actions, // @audit: use storage pointer\n357:            proposals[_proposalId].allowFailureMap // @audit: use storage pointer\n358:        );\n359:    }\n```\n```diff\ndiff --git a/src/plugins/governance/multisig/Multisig.sol b/src/plugins/governance/multisig/Multisig.sol\nindex d2dd072..eba5457 100644\n--- a/src/plugins/governance/multisig/Multisig.sol\n+++ b/src/plugins/governance/multisig/Multisig.sol\n@@ -353,8 +353,8 @@ contract Multisig is\n         _executeProposal(\n             dao(),\n             _proposalId,\n-            proposals[_proposalId].actions,\n-            proposals[_proposalId].allowFailureMap\n+            proposal_.actions,\n+            proposal_.allowFailureMap\n         );\n     }\n```\n\nhttps://github.com/code-423n4/2023-03-aragon/blob/main/packages/contracts/src/plugins/governance/majority-voting/MajorityVotingBase.sol#L457-L466\n\n### `proposals[_proposalId]` can be cached as a storage pointer\n```solidity\nFile: src/plugins/governance/majority-voting/MajorityVotingBase.sol\n457:    function _execute(uint256 _proposalId) internal virtual {\n458:        proposals[_proposalId].executed = true;\n459:\n460:        _executeProposal(\n461:            dao(),\n462:            _proposalId,\n463:            proposals[_proposalId].actions,\n464:            proposals[_proposalId].allowFailureMap\n465:        );\n466:    }\n```\n```diff\ndiff --git a/src/plugins/governance/majority-voting/MajorityVotingBase.sol b/src/plugins/governance/majority-voting/MajorityVotingBase.sol\nindex 58ba2fe..3985b7b 100644\n--- a/src/plugins/governance/majority-voting/MajorityVotingBase.sol\n+++ b/src/plugins/governance/majority-voting/MajorityVotingBase.sol\n@@ -455,13 +455,14 @@ abstract contract MajorityVotingBase is\n     /// @notice Internal function to execute a vote. It assumes the queried proposal exists.\n     /// @param _proposalId The ID of the proposal.\n     function _execute(uint256 _proposalId) internal virtual {\n-        proposals[_proposalId].executed = true;\n+        Proposal storage proposal_ = proposals[_proposalId];\n+        proposal_.executed = true;\n\n         _executeProposal(\n             dao(),\n             _proposalId,\n-            proposals[_proposalId].actions,\n-            proposals[_proposalId].allowFailureMap\n+            proposal_.actions,\n+            proposal_.allowFailureMap\n         );\n     }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-03-aragon",
  "Code": [
    {
      "filename": "packages/contracts/src/plugins/governance/multisig/Multisig.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\n\nimport {IDAO} from \"../../../core/dao/IDAO.sol\";\nimport {IMembership} from \"../../../core/plugin/membership/IMembership.sol\";\nimport {PluginUUPSUpgradeable} from \"../../../core/plugin/PluginUUPSUpgradeable.sol\";\n\nimport {ProposalUpgradeable} from \"../../../core/plugin/proposal/ProposalUpgradeable.sol\";\nimport {Addresslist} from \"../../utils/Addresslist.sol\";\nimport {IMultisig} from \"./IMultisig.sol\";\n\n/// @title Multisig\n/// @author Aragon Association - 2022-2023\n/// @notice The on-chain multisig governance plugin in which a proposal passes if X out of Y approvals are met.\ncontract Multisig is\n    IMultisig,\n    IMembership,\n    PluginUUPSUpgradeable,\n    ProposalUpgradeable,\n    Addresslist\n{\n    using SafeCastUpgradeable for uint256;\n\n    /// @notice A container for proposal-related information.\n    /// @param executed Whether the proposal is executed or not.\n    /// @param approvals The number of approvals casted.\n    /// @param parameters The proposal-specific approve settings at the time of the proposal creation.\n    /// @param approvers The approves casted by the approvers.\n    /// @param actions The actions to be executed when the proposal passes.\n    /// @param _allowFailureMap A bitmap allowing the proposal to succeed, even if individual actions might revert. If the bit at index `i` is 1, the proposal succeeds even if the `i`th action reverts. A failure map value of 0 requires every action to not revert.\n    struct Proposal {\n        bool executed;\n        uint16 approvals;\n        ProposalParameters parameters;\n        mapping(address => bool) approvers;\n        IDAO.Action[] actions;\n        uint256 allowFailureMap;\n    }\n\n    /// @notice A container for the proposal parameters.\n    /// @param minApprovals The number of approvals required.\n    /// @param snapshotBlock The number of the block prior to the proposal creation.\n    /// @param startDate The timestamp when the proposal starts.\n    /// @param endDate The timestamp when the proposal expires.\n    struct ProposalParameters {\n        uint16 minApprovals;\n        uint64 snapshotBlock;\n        uint64 startDate;\n        uint64 endDate;\n    }\n\n    /// @notice A container for the plugin settings.\n    /// @param onlyListed Whether only listed addresses can create a proposal.\n    /// @param minApprovals The minimum approvals parameter.\n    struct MultisigSettings {\n        bool onlyListed;\n        uint16 minApprovals;\n    }\n\n    /// @notice The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID of the contract.\n    bytes4 internal constant MULTISIG_INTERFACE_ID =\n        this.initialize.selector ^\n            this.updateMultisigSettings.selector ^\n            this.createProposal.selector ^\n            this.getProposal.selector;\n\n    /// @notice The ID of the permission required to call the `addAddresses` and `removeAddresses` functions.\n    bytes32 public constant UPDATE_MULTISIG_SETTINGS_PERMISSION_ID =\n        keccak256(\"UPDATE_MULTISIG_SETTINGS_PERMISSION\");\n\n    /// @notice A mapping between proposal IDs and proposal information.\n    mapping(uint256 => Proposal) internal proposals;\n\n    /// @notice The current plugin settings.\n    MultisigSettings public multisigSettings;\n\n    /// @notice Thrown when a sender is not allowed to create a proposal.\n    /// @param sender The sender address.\n    error ProposalCreationForbidden(address sender);\n\n    /// @notice Thrown if a approver is not allowed to cast an approve. This can be because the proposal\n    /// - is not open,\n    /// - was executed, or\n    /// - the approver is not on the address list\n    /// @param proposalId The ID of the proposal.\n    /// @param sender The address of the sender.\n    error ApprovalCastForbidden(uint256 proposalId, address sender);\n\n    /// @notice Thrown if the proposal execution is forbidden.\n    /// @param proposalId The ID of the proposal.\n    error ProposalExecutionForbidden(uint256 proposalId);\n\n    /// @notice Thrown if the minimal approvals value is out of bounds (less than 1 or greater than the number of members in the address list).\n    /// @param limit The maximal value.\n    /// @param actual The actual value.\n    error MinApprovalsOutOfBounds(uint16 limit, uint16 actual);\n\n    /// @notice Thrown if the addresslist length is out of bounds.\n    /// @param limit The limit value.\n    /// @param actual The actual value.\n    error AddresslistLengthOutOfBounds(uint16 limit, uint256 actual);\n\n    /// @notice Thrown if a date is out of bounds.\n    /// @param limit The limit value.\n    /// @param actual The actual value.\n    error DateOutOfBounds(uint64 limit, uint64 actual);\n\n    /// @notice Emitted when an proposal is approve by an approver.\n    /// @param proposalId The ID of the proposal.\n    /// @param approver The approver casting the approve.\n    event Approved(uint256 indexed proposalId, address indexed approver);\n\n    /// @notice Emitted when the plugin settings are set.\n    /// @param onlyListed Whether only listed addresses can create a proposal.\n    /// @param minApprovals The minimum amount of approvals needed to pass a proposal.\n    event MultisigSettingsUpdated(bool onlyListed, uint16 indexed minApprovals);\n\n    /// @notice Initializes the component.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _dao The IDAO interface of the associated DAO.\n    /// @param _multisigSettings The multisig settings.\n    function initialize(\n        IDAO _dao,\n        address[] calldata _members,\n        MultisigSettings calldata _multisigSettings\n    ) external initializer {\n        __PluginUUPSUpgradeable_init(_dao);\n\n        _addAddresses(_members);\n        emit MembersAdded({members: _members});\n\n        _updateMultisigSettings(_multisigSettings);\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(\n        bytes4 _interfaceId\n    ) public view virtual override(PluginUUPSUpgradeable, ProposalUpgradeable) returns (bool) {\n        return\n            _interfaceId == MULTISIG_INTERFACE_ID ||\n            _interfaceId == type(IMultisig).interfaceId ||\n            _interfaceId == type(Addresslist).interfaceId ||\n            _interfaceId == type(IMembership).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    /// @inheritdoc IMultisig\n    function addAddresses(\n        address[] calldata _members\n    ) external auth(UPDATE_MULTISIG_SETTINGS_PERMISSION_ID) {\n        uint256 newAddresslistLength = addresslistLength() + _members.length;\n\n        // Check if the new address list length would be greater than `type(uint16).max`, the maximal number of approvals.\n        if (newAddresslistLength > type(uint16).max) {\n            revert AddresslistLengthOutOfBounds({\n                limit: type(uint16).max,\n                actual: newAddresslistLength\n            });\n        }\n\n        _addAddresses(_members);\n\n        emit MembersAdded({members: _members});\n    }\n\n    /// @inheritdoc IMultisig\n    function removeAddresses(\n        address[] calldata _members\n    ) external auth(UPDATE_MULTISIG_SETTINGS_PERMISSION_ID) {\n        uint16 newAddresslistLength = uint16(addresslistLength() - _members.length);\n\n        // Check if the new address list length would become less than the current minimum number of approvals required.\n        if (newAddresslistLength < multisigSettings.minApprovals) {\n            revert MinApprovalsOutOfBounds({\n                limit: newAddresslistLength,\n                actual: multisigSettings.minApprovals\n            });\n        }\n\n        _removeAddresses(_members);\n\n        emit MembersRemoved({members: _members});\n    }\n\n    /// @notice Updates the plugin settings.\n    /// @param _multisigSettings The new settings.\n    function updateMultisigSettings(\n        MultisigSettings calldata _multisigSettings\n    ) external auth(UPDATE_MULTISIG_SETTINGS_PERMISSION_ID) {\n        _updateMultisigSettings(_multisigSettings);\n    }\n\n    /// @notice Creates a new majority voting proposal.\n    /// @param _metadata The metadata of the proposal.\n    /// @param _actions The actions that will be executed after the proposal passes.\n    /// @param _allowFailureMap A bitmap allowing the proposal to succeed, even if individual actions might revert. If the bit at index `i` is 1, the proposal succeeds even if the `i`th action reverts. A failure map value of 0 requires every action to not revert.\n    /// @param _approveProposal If `true`, the sender will approve the proposal.\n    /// @param _tryExecution If `true`, execution is tried after the vote cast. The call does not revert if early execution is not possible.\n    /// @return proposalId The ID of the proposal.\n    function createProposal(\n        bytes calldata _metadata,\n        IDAO.Action[] calldata _actions,\n        uint256 _allowFailureMap,\n        bool _approveProposal,\n        bool _tryExecution,\n        uint64 _startDate,\n        uint64 _endDate\n    ) external returns (uint256 proposalId) {\n        uint64 snapshotBlock = block.number.toUint64() - 1;\n\n        if (multisigSettings.onlyListed && !isListedAtBlock(_msgSender(), snapshotBlock)) {\n            revert ProposalCreationForbidden(_msgSender());\n        }\n\n        if (_startDate == 0) {\n            _startDate = block.timestamp.toUint64();\n        } else if (_startDate < block.timestamp.toUint64()) {\n            revert DateOutOfBounds({limit: block.timestamp.toUint64(), actual: _startDate});\n        }\n\n        if (_endDate < _startDate) {\n            revert DateOutOfBounds({limit: _startDate, actual: _endDate});\n        }\n\n        proposalId = _createProposal({\n            _creator: _msgSender(),\n            _metadata: _metadata,\n            _startDate: _startDate,\n            _endDate: _endDate,\n            _actions: _actions,\n            _allowFailureMap: _allowFailureMap\n        });\n\n        // Create the proposal\n        Proposal storage proposal_ = proposals[proposalId];\n\n        proposal_.parameters.snapshotBlock = snapshotBlock;\n        proposal_.parameters.startDate = _startDate;\n        proposal_.parameters.endDate = _endDate;\n        proposal_.parameters.minApprovals = multisigSettings.minApprovals;\n\n        // Reduce costs\n        if (_allowFailureMap != 0) {\n            proposal_.allowFailureMap = _allowFailureMap;\n        }\n\n        for (uint256 i; i < _actions.length; ) {\n            proposal_.actions.push(_actions[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (_approveProposal) {\n            approve(proposalId, _tryExecution);\n        }\n    }\n\n    /// @inheritdoc IMultisig\n    function approve(uint256 _proposalId, bool _tryExecution) public {\n        address approver = _msgSender();\n        if (!_canApprove(_proposalId, approver)) {\n            revert ApprovalCastForbidden(_proposalId, approver);\n        }\n\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        // As the list can never become more than type(uint16).max(due to addAddresses check)\n        // It's safe to use unchecked as it would never overflow.\n        unchecked {\n            proposal_.approvals += 1;\n        }\n\n        proposal_.approvers[approver] = true;\n\n        emit Approved({proposalId: _proposalId, approver: approver});\n\n        if (_tryExecution && _canExecute(_proposalId)) {\n            _execute(_proposalId);\n        }\n    }\n\n    /// @inheritdoc IMultisig\n    function canApprove(uint256 _proposalId, address _account) external view returns (bool) {\n        return _canApprove(_proposalId, _account);\n    }\n\n    /// @inheritdoc IMultisig\n    function canExecute(uint256 _proposalId) external view returns (bool) {\n        return _canExecute(_proposalId);\n    }\n\n    /// @notice Returns all information for a proposal vote by its ID.\n    /// @param _proposalId The ID of the proposal.\n    /// @return executed Whether the proposal is executed or not.\n    /// @return approvals The number of approvals casted.\n    /// @return parameters The parameters of the proposal vote.\n    /// @return actions The actions to be executed in the associated DAO after the proposal has passed.\n    /// @param allowFailureMap A bitmap allowing the proposal to succeed, even if individual actions might revert. If the bit at index `i` is 1, the proposal succeeds even if the `i`th action reverts. A failure map value of 0 requires every action to not revert.\n    function getProposal(\n        uint256 _proposalId\n    )\n        public\n        view\n        returns (\n            bool executed,\n            uint16 approvals,\n            ProposalParameters memory parameters,\n            IDAO.Action[] memory actions,\n            uint256 allowFailureMap\n        )\n    {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        executed = proposal_.executed;\n        approvals = proposal_.approvals;\n        parameters = proposal_.parameters;\n        actions = proposal_.actions;\n        allowFailureMap = proposal_.allowFailureMap;\n    }\n\n    /// @inheritdoc IMultisig\n    function hasApproved(uint256 _proposalId, address _account) public view returns (bool) {\n        return proposals[_proposalId].approvers[_account];\n    }\n\n    /// @inheritdoc IMultisig\n    function execute(uint256 _proposalId) public {\n        if (!_canExecute(_proposalId)) {\n            revert ProposalExecutionForbidden(_proposalId);\n        }\n\n        _execute(_proposalId);\n    }\n\n    /// @inheritdoc IMembership\n    function isMember(address _account) external view returns (bool) {\n        return isListed(_account);\n    }\n\n    /// @notice Internal function to execute a vote. It assumes the queried proposal exists.\n    /// @param _proposalId The ID of the proposal.\n    function _execute(uint256 _proposalId) internal {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        proposal_.executed = true;\n\n        _executeProposal(\n            dao(),\n            _proposalId,\n            proposals[_proposalId].actions,\n            proposals[_proposalId].allowFailureMap\n        );\n    }\n\n    /// @notice Internal function to check if an account can approve. It assumes the queried proposal exists.\n    /// @param _proposalId The ID of the proposal.\n    /// @param _account The account to check.\n    /// @return Returns `true` if the given account can approve on a certain proposal and `false` otherwise.\n    function _canApprove(uint256 _proposalId, address _account) internal view returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        if (!_isProposalOpen(proposal_)) {\n            // The proposal was executed already\n            return false;\n        }\n\n        if (!isListedAtBlock(_account, proposal_.parameters.snapshotBlock)) {\n            // The approver has no voting power.\n            return false;\n        }\n\n        if (proposal_.approvers[_account]) {\n            // The approver has already approved\n            return false;\n        }\n\n        return true;\n    }\n\n    /// @notice Internal function to check if a proposal can be executed. It assumes the queried proposal exists.\n    /// @param _proposalId The ID of the proposal.\n    /// @return Returns `true` if the proposal can be executed and `false` otherwise.\n    function _canExecute(uint256 _proposalId) internal view returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        // Verify that the proposal has not been executed or expired.\n        if (!_isProposalOpen(proposal_)) {\n            return false;\n        }\n\n        return proposal_.approvals >= proposal_.parameters.minApprovals;\n    }\n\n    /// @notice Internal function to check if a proposal vote is still open.\n    /// @param proposal_ The proposal struct.\n    /// @return True if the proposal vote is open, false otherwise.\n    function _isProposalOpen(Proposal storage proposal_) internal view returns (bool) {\n        uint64 currentTimestamp64 = block.timestamp.toUint64();\n        return\n            !proposal_.executed &&\n            proposal_.parameters.startDate <= currentTimestamp64 &&\n            proposal_.parameters.endDate >= currentTimestamp64;\n    }\n\n    /// @notice Internal function to update the plugin settings.\n    /// @param _multisigSettings The new settings.\n    function _updateMultisigSettings(MultisigSettings calldata _multisigSettings) internal {\n        uint16 addresslistLength_ = uint16(addresslistLength());\n\n        if (_multisigSettings.minApprovals > addresslistLength_) {\n            revert MinApprovalsOutOfBounds({\n                limit: addresslistLength_,\n                actual: _multisigSettings.minApprovals\n            });\n        }\n\n        if (_multisigSettings.minApprovals < 1) {\n            revert MinApprovalsOutOfBounds({limit: 1, actual: _multisigSettings.minApprovals});\n        }\n\n        multisigSettings = _multisigSettings;\n\n        emit MultisigSettingsUpdated({\n            onlyListed: _multisigSettings.onlyListed,\n            minApprovals: _multisigSettings.minApprovals\n        });\n    }\n\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    /// variables without shifting down storage in the inheritance chain.\n    /// https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n    uint256[48] private __gap;\n}"
    },
    {
      "filename": "packages/contracts/src/plugins/governance/majority-voting/MajorityVotingBase.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\n\nimport {IProposal} from \"../../../core/plugin/proposal/IProposal.sol\";\nimport {ProposalUpgradeable} from \"../../../core/plugin/proposal/ProposalUpgradeable.sol\";\nimport {PluginUUPSUpgradeable} from \"../../../core/plugin/PluginUUPSUpgradeable.sol\";\nimport {IDAO} from \"../../../core/dao/IDAO.sol\";\nimport {RATIO_BASE, RatioOutOfBounds} from \"../../utils/Ratio.sol\";\nimport {IMajorityVoting} from \"./IMajorityVoting.sol\";\n\n/// @title MajorityVotingBase\n/// @author Aragon Association - 2022-2023\n\n/// @notice The abstract implementation of majority voting plugins.\n///\n/// #### Parameterization\n///\n/// We define two parameters\n/// $$\\texttt{support} = \\frac{N_\\text{yes}}{N_\\text{yes} + N_\\text{no}} \\in [0,1]$$\n/// and\n/// $$\\texttt{participation} = \\frac{N_\\text{yes} + N_\\text{no} + N_\\text{abstain}}{N_\\text{total}} \\in [0,1],$$\n/// where $N_\\text{yes}$, $N_\\text{no}$, and $N_\\text{abstain}$ are the yes, no, and abstain votes that have been cast and $N_\\text{total}$ is the total voting power available at /// proposal creation time.\n///\n/// ##### Limit Values: Support Threshold & Minimum Participation\n///\n/// Two limit values are associated with these parameters and decide if a proposal execution should be possible: $\\texttt{supportThreshold} \\in [0,1]$ and $\\texttt{minParticipation} \\in /// [0,1]$.\n///\n/// For threshold values, $>$ comparison is used. This **does not** include the threshold value. E.g., for $\\texttt{supportThreshold} = 50\\%$, the criterion is fulfilled if there is at /// least one more yes than no votes ($N_\\text{yes} = N_\\text{no} + 1 $).\n/// For minimum values, $\\ge$ comparison is used. This **does** include the minimum participation value. E.g., for $\\texttt{minParticipation} = 40\\%$ and $N_\\text{total} = 10$, the /// criterion is fulfilled if 4 out of 10 votes were casted.\n///\n/// Majority voting implies that the support threshold is set with\n/// $$\\texttt{supportThreshold} \\ge 50\\% .$$\n/// However, this is not enforced by the contract code and developers can make unsafe parameters and only the frontend will warn about bad parameter settings.\n///\n/// #### Execution Criteria\n///\n/// After the vote is closed, two criteria decide if the proposal passes.\n///\n/// ##### The Support Criterion\n///\n/// For a proposal to pass, the required ratio of yes and no votes must be met:\n/// $$(1- \\texttt{supportThreshold}) \\cdot N_\\text{yes} > \\texttt{supportThreshold} \\cdot N_\\text{no}.$$\n/// Note, that the inequality yields the simple majority voting condition for $\\texttt{supportThreshold}=\\frac{1}{2}$.\n///\n/// ##### The Participation Criterion\n///\n/// For a proposal to pass, the minimum voting power must have been cast:\n/// $$N_\\text{yes} + N_\\text{no} + N_\\text{abstain} \\ge \\texttt{minVotingPower},$$\n/// where $\\texttt{minVotingPower} = \\texttt{minParticipation} \\cdot N_\\text{total}$.\n///\n/// #### Vote Replacement Execution\n///\n/// The contract allows votes to be replaced. Voters can vote multiple times and only the latest voteOption is tallied.\n///\n/// #### Early Execution\n///\n/// This contract allows a proposal to be executed early, iff the vote outcome cannot change anymore by more people voting. Accordingly, vote replacement and early execution are /// mutually exclusive options.\n/// The outcome cannot change anymore iff the support threshold is met even if all remaining votes are no votes. We call this number the worst-case number of no votes and define it as\n///\n/// $$N_\\text{no, worst-case} = N_\\text{no, worst-case} + \\texttt{remainingVotes}$$\n///\n/// where\n///\n/// $$\\texttt{remainingVotes} = N_\\text{total}-\\underbrace{(N_\\text{yes}+N_\\text{no}+N_\\text{abstain})}_{\\text{turnout}}.$$\n///\n/// We can use this quantity to calculate the worst-case support that would be obtained if all remaining votes are casted with no:\n///\n/// $$\n/// \\begin{align*}\n///   \\texttt{worstCaseSupport}\n///   &= \\frac{N_\\text{yes}}{N_\\text{yes} + (N_\\text{no, worst-case})} \\\\[3mm]\n///   &= \\frac{N_\\text{yes}}{N_\\text{yes} + (N_\\text{no} + \\texttt{remainingVotes})} \\\\[3mm]\n///   &= \\frac{N_\\text{yes}}{N_\\text{yes} +  N_\\text{no} + N_\\text{total} - (N_\\text{yes} + N_\\text{no} + N_\\text{abstain})} \\\\[3mm]\n///   &= \\frac{N_\\text{yes}}{N_\\text{total} - N_\\text{abstain}}\n/// \\end{align*}\n/// $$\n///\n/// In analogy, we can modify [the support criterion](#the-support-criterion) from above to allow for early execution:\n///\n/// $$\n/// \\begin{align*}\n///   (1 - \\texttt{supportThreshold}) \\cdot N_\\text{yes}\n///   &> \\texttt{supportThreshold} \\cdot  N_\\text{no, worst-case} \\\\[3mm]\n///   &> \\texttt{supportThreshold} \\cdot (N_\\text{no} + \\texttt{remainingVotes}) \\\\[3mm]\n///   &> \\texttt{supportThreshold} \\cdot (N_\\text{no} + N_\\text{total}-(N_\\text{yes}+N_\\text{no}+N_\\text{abstain})) \\\\[3mm]\n///   &> \\texttt{supportThreshold} \\cdot (N_\\text{total} - N_\\text{yes} - N_\\text{abstain})\n/// \\end{align*}\n/// $$\n///\n/// Accordingly, early execution is possible when the vote is open, the modified support criterion, and the particicpation criterion are met.\n/// @dev This contract implements the `IMajorityVoting` interface.\nabstract contract MajorityVotingBase is\n    IMajorityVoting,\n    Initializable,\n    ERC165Upgradeable,\n    PluginUUPSUpgradeable,\n    ProposalUpgradeable\n{\n    using SafeCastUpgradeable for uint256;\n\n    /// @notice The different voting modes available.\n    /// @param Standard In standard mode, early execution and vote replacement are disabled.\n    /// @param EarlyExecution In early execution mode, a proposal can be executed early before the end date if the vote outcome cannot mathematically change by more voters voting.\n    /// @param VoteReplacment In vote replacement mode, voters can change their vote multiple times and only the latest vote option is tallied.\n    enum VotingMode {\n        Standard,\n        EarlyExecution,\n        VoteReplacement\n    }\n\n    /// @notice A container for the majority voting settings that will be applied as parameters on proposal creation.\n    /// @param votingMode A parameter to select the vote mode.\n    /// @param supportThreshold The support threshold value. Its value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\n    /// @param minParticipation The minimum participation value. Its value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\n    /// @param minDuration The minimum duration of the proposal vote in seconds.\n    /// @param minProposerVotingPower The minimum voting power required to create a proposal.\n    struct VotingSettings {\n        VotingMode votingMode;\n        uint32 supportThreshold;\n        uint32 minParticipation;\n        uint64 minDuration;\n        uint256 minProposerVotingPower;\n    }\n\n    /// @notice A container for proposal-related information.\n    /// @param executed Whether the proposal is executed or not.\n    /// @param parameters The proposal parameters at the time of the proposal creation.\n    /// @param tally The vote tally of the proposal.\n    /// @param voters The votes casted by the voters.\n    /// @param actions The actions to be executed when the proposal passes.\n    /// @param allowFailureMap A bitmap allowing the proposal to succeed, even if individual actions might revert. If the bit at index `i` is 1, the proposal succeeds even if the `i`th action reverts. A failure map value of 0 requires every action to not revert.\n    struct Proposal {\n        bool executed;\n        ProposalParameters parameters;\n        Tally tally;\n        mapping(address => IMajorityVoting.VoteOption) voters;\n        IDAO.Action[] actions;\n        uint256 allowFailureMap;\n    }\n\n    /// @notice A container for the proposal parameters at the time of proposal creation.\n    /// @param votingMode A parameter to select the vote mode.\n    /// @param supportThreshold The support threshold value. The value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\n    /// @param startDate The start date of the proposal vote.\n    /// @param endDate The end date of the proposal vote.\n    /// @param snapshotBlock The number of the block prior to the proposal creation.\n    /// @param minVotingPower The minimum voting power needed.\n    struct ProposalParameters {\n        VotingMode votingMode;\n        uint32 supportThreshold;\n        uint64 startDate;\n        uint64 endDate;\n        uint64 snapshotBlock;\n        uint256 minVotingPower;\n    }\n\n    /// @notice A container for the proposal vote tally.\n    /// @param abstain The number of abstain votes casted.\n    /// @param yes The number of yes votes casted.\n    /// @param no The number of no votes casted.\n    struct Tally {\n        uint256 abstain;\n        uint256 yes;\n        uint256 no;\n    }\n\n    /// @notice The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID of the contract.\n    bytes4 internal constant MAJORITY_VOTING_BASE_INTERFACE_ID =\n        this.minDuration.selector ^\n            this.minProposerVotingPower.selector ^\n            this.votingMode.selector ^\n            this.totalVotingPower.selector ^\n            this.getProposal.selector ^\n            this.updateVotingSettings.selector ^\n            this.createProposal.selector;\n\n    /// @notice The ID of the permission required to call the `updateVotingSettings` function.\n    bytes32 public constant UPDATE_VOTING_SETTINGS_PERMISSION_ID =\n        keccak256(\"UPDATE_VOTING_SETTINGS_PERMISSION\");\n\n    /// @notice A mapping between proposal IDs and proposal information.\n    mapping(uint256 => Proposal) internal proposals;\n\n    /// @notice The struct storing the voting settings.\n    VotingSettings private votingSettings;\n\n    /// @notice Thrown if a date is out of bounds.\n    /// @param limit The limit value.\n    /// @param actual The actual value.\n    error DateOutOfBounds(uint64 limit, uint64 actual);\n\n    /// @notice Thrown if the minimal duration value is out of bounds (less than one hour or greater than 1 year).\n    /// @param limit The limit value.\n    /// @param actual The actual value.\n    error MinDurationOutOfBounds(uint64 limit, uint64 actual);\n\n    /// @notice Thrown when a sender is not allowed to create a proposal.\n    /// @param sender The sender address.\n    error ProposalCreationForbidden(address sender);\n\n    /// @notice Thrown if an account is not allowed to cast a vote. This can be because the vote\n    /// - has not started,\n    /// - has ended,\n    /// - was executed, or\n    /// - the account doesn't have voting powers.\n    /// @param proposalId The ID of the proposal.\n    /// @param account The address of the _account.\n    /// @param voteOption The chosen vote option.\n    error VoteCastForbidden(uint256 proposalId, address account, VoteOption voteOption);\n\n    /// @notice Thrown if the proposal execution is forbidden.\n    /// @param proposalId The ID of the proposal.\n    error ProposalExecutionForbidden(uint256 proposalId);\n\n    /// @notice Emitted when the voting settings are updated.\n    /// @param votingMode A parameter to select the vote mode.\n    /// @param supportThreshold The support threshold value.\n    /// @param minParticipation The minimum participation value.\n    /// @param minDuration The minimum duration of the proposal vote in seconds.\n    /// @param minProposerVotingPower The minimum voting power required to create a proposal.\n    event VotingSettingsUpdated(\n        VotingMode votingMode,\n        uint32 supportThreshold,\n        uint32 minParticipation,\n        uint64 minDuration,\n        uint256 minProposerVotingPower\n    );\n\n    /// @notice Initializes the component to be used by inheriting contracts.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _dao The IDAO interface of the associated DAO.\n    /// @param _votingSettings The voting settings.\n    function __MajorityVotingBase_init(\n        IDAO _dao,\n        VotingSettings calldata _votingSettings\n    ) internal onlyInitializing {\n        __PluginUUPSUpgradeable_init(_dao);\n        _updateVotingSettings(_votingSettings);\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(\n        bytes4 _interfaceId\n    )\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, PluginUUPSUpgradeable, ProposalUpgradeable)\n        returns (bool)\n    {\n        return\n            _interfaceId == MAJORITY_VOTING_BASE_INTERFACE_ID ||\n            _interfaceId == type(IMajorityVoting).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function vote(\n        uint256 _proposalId,\n        VoteOption _voteOption,\n        bool _tryEarlyExecution\n    ) public virtual {\n        address account = _msgSender();\n\n        if (!_canVote(_proposalId, account, _voteOption)) {\n            revert VoteCastForbidden({\n                proposalId: _proposalId,\n                account: account,\n                voteOption: _voteOption\n            });\n        }\n        _vote(_proposalId, _voteOption, account, _tryEarlyExecution);\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function execute(uint256 _proposalId) public virtual {\n        if (!_canExecute(_proposalId)) {\n            revert ProposalExecutionForbidden(_proposalId);\n        }\n        _execute(_proposalId);\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function getVoteOption(\n        uint256 _proposalId,\n        address _voter\n    ) public view virtual returns (VoteOption) {\n        return proposals[_proposalId].voters[_voter];\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function canVote(\n        uint256 _proposalId,\n        address _voter,\n        VoteOption _voteOption\n    ) public view virtual returns (bool) {\n        return _canVote(_proposalId, _voter, _voteOption);\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function canExecute(uint256 _proposalId) public view virtual returns (bool) {\n        return _canExecute(_proposalId);\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function isSupportThresholdReached(uint256 _proposalId) public view virtual returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        // The code below implements the formula of the support criterion explained in the top of this file.\n        // `(1 - supportThreshold) * N_yes > supportThreshold *  N_no`\n        return\n            (RATIO_BASE - proposal_.parameters.supportThreshold) * proposal_.tally.yes >\n            proposal_.parameters.supportThreshold * proposal_.tally.no;\n    }\n\n    /// @inheritdoc IMajorityVoting\n    functio"
    }
  ]
}