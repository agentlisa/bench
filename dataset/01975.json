{
  "Title": "M-3: The protocol  will not be able to add liquidity on the curve with another token with a balance.",
  "Content": "# Issue M-3: The protocol  will not be able to add liquidity on the curve with another token with a balance. \n\nSource: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/47 \n\n## Found by \nBauer, nobody2018\n## Summary\nThe `CurveSpell` protocol only ensure approve curve pool to spend its borrow token. Hence, it will not be able to add liquidity on the curve with another token with a balance.\n\n## Vulnerability Detail\nThe  `openPositionFarm()` function enables user to open a leveraged position in a yield farming strategy by borrowing funds and using them to add liquidity to a Curve pool, while also taking into account certain risk management parameters such as maximum LTV and position size. When add liquidity on curve ,the protocol use the borrowed token and the collateral token, it checks the number of tokens in the pool and creates an array of the supplied token amounts to be passed to the add_liquidity function. Then the curve will transfer the tokens from the protocol and mint lp tokens to the protocol. However, the protocol only ensure approve curve pool to spend its borrow token. Hence, it will not be able to add liquidity on the curve with another token with a balance.\n```solidity\n // 3. Add liquidity on curve\n        _ensureApprove(param.borrowToken, pool, borrowBalance);\n        if (tokens.length == 2) {\n            uint256[2] memory suppliedAmts;\n            for (uint256 i = 0; i < 2; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 3) {\n            uint256[3] memory suppliedAmts;\n            for (uint256 i = 0; i < 3; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 4) {\n            uint256[4] memory suppliedAmts;\n            for (uint256 i = 0; i < 4; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        }\n\n```\n\n## Impact\nThe protocol  will not be able to add liquidity on the curve with another token with a balance.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/CurveSpell.sol#L90-L115\n## Tool used\n\nManual Review\n\n## Recommendation\nAllow the curve pool to spend tokens that have a balance in the protocol to add liquidity\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/69",
  "Code": [
    {
      "filename": "blueberry-core/contracts/spell/CurveSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./BasicSpell.sol\";\nimport \"../interfaces/ICurveOracle.sol\";\nimport \"../interfaces/IWCurveGauge.sol\";\nimport \"../interfaces/curve/ICurvePool.sol\";\nimport \"../interfaces/uniswap/IUniswapV2Router02.sol\";\n\n/**\n * @title CurveSpell\n * @author BlueberryProtocol\n * @notice CurveSpell is the factory contract that\n * defines how Blueberry Protocol interacts with Curve pools\n */\ncontract CurveSpell is BasicSpell {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @dev address of Wrapped Curve Gauge\n    IWCurveGauge public wCurveGauge;\n    /// @dev address of CurveOracle\n    ICurveOracle public crvOracle;\n    /// @dev address of CRV token\n    address public CRV;\n\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address wCurveGauge_,\n        address crvOracle_\n    ) external initializer {\n        __BasicSpell_init(bank_, werc20_, weth_);\n        if (wCurveGauge_ == address(0) || crvOracle_ == address(0))\n            revert Errors.ZERO_ADDRESS();\n\n        wCurveGauge = IWCurveGauge(wCurveGauge_);\n        CRV = address(wCurveGauge.CRV());\n        crvOracle = ICurveOracle(crvOracle_);\n        IWCurveGauge(wCurveGauge_).setApprovalForAll(address(bank_), true);\n    }\n\n    /**\n     * @notice Add strategy to the spell\n     * @param crvLp Address of crv lp token for given strategy\n     * @param maxPosSize, USD price of maximum position size for given strategy, based 1e18\n     */\n    function addStrategy(address crvLp, uint256 maxPosSize) external onlyOwner {\n        _addStrategy(crvLp, maxPosSize);\n    }\n\n    /**\n     * @notice Add liquidity to Curve pool with 2 underlying tokens, with staking to Curve gauge\n     * @param minLPMint Desired LP token amount (slippage control)\n     */\n    function openPositionFarm(\n        OpenPosParam calldata param,\n        uint256 minLPMint\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        address lp = strategies[param.strategyId].vault;\n        if (wCurveGauge.getLpFromGaugeId(param.farmingPoolId) != lp)\n            revert Errors.INCORRECT_LP(lp);\n        (address pool, address[] memory tokens, ) = crvOracle.getPoolInfo(lp);\n\n        // 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        // 2. Borrow specific amounts\n        uint256 borrowBalance = _doBorrow(\n            param.borrowToken,\n            param.borrowAmount\n        );\n\n        // 3. Add liquidity on curve\n        _ensureApprove(param.borrowToken, pool, borrowBalance);\n        if (tokens.length == 2) {\n            uint256[2] memory suppliedAmts;\n            for (uint256 i = 0; i < 2; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 3) {\n            uint256[3] memory suppliedAmts;\n            for (uint256 i = 0; i < 3; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 4) {\n            uint256[4] memory suppliedAmts;\n            for (uint256 i = 0; i < 4; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        }\n\n        // 4. Validate MAX LTV\n        _validateMaxLTV(param.strategyId);\n\n        // 5. Validate Max Pos Size\n        _validateMaxPosSize(param.strategyId);\n\n        // 6. Take out collateral and burn\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 decodedGid, ) = wCurveGauge.decodeId(pos.collId);\n            if (param.farmingPoolId != decodedGid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wCurveGauge))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            wCurveGauge.burn(pos.collId, pos.collateralSize);\n            _doRefundRewards(CRV);\n        }\n\n        // 7. Deposit on Curve Gauge, Put wrapped collateral tokens on Blueberry Bank\n        uint256 lpAmount = IERC20Upgradeable(lp).balanceOf(address(this));\n        _ensureApprove(lp, address(wCurveGauge), lpAmount);\n        uint256 id = wCurveGauge.mint(param.farmingPoolId, lpAmount);\n        bank.putCollateral(address(wCurveGauge), id, lpAmount);\n    }\n\n    function closePositionFarm(\n        ClosePosParam calldata param,\n        IUniswapV2Router02 swapRouter,\n        address[] calldata swapPath\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        address crvLp = strategies[param.strategyId].vault;\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collToken != address(wCurveGauge))\n            revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n        if (wCurveGauge.getUnderlyingToken(pos.collId) != crvLp)\n            revert Errors.INCORRECT_UNDERLYING(crvLp);\n\n        // 1. Take out collateral - Burn wrapped tokens, receive crv lp tokens and harvest CRV\n        bank.takeCollateral(param.amountPosRemove);\n        wCurveGauge.burn(pos.collId, param.amountPosRemove);\n\n        {\n            // 2. Swap rewards tokens to debt token\n            uint256 rewards = _doCutRewardsFee(CRV);\n            _ensureApprove(CRV, address(swapRouter), rewards);\n            swapRouter.swapExactTokensForTokens(\n                rewards,\n                0,\n                swapPath,\n                address(this),\n                type(uint256).max\n            );\n        }\n\n        {\n            (address pool, address[] memory tokens, ) = crvOracle.getPoolInfo(\n                crvLp\n            );\n            // 3. Calculate actual amount to remove\n            uint256 amountPosRemove = param.amountPosRemove;\n            if (amountPosRemove == type(uint256).max) {\n                amountPosRemove = IERC20Upgradeable(crvLp).balanceOf(\n                    address(this)\n                );\n            }\n\n            // 4. Remove liquidity\n            int128 tokenIndex;\n            for (uint256 i = 0; i < tokens.length; i++) {\n                if (tokens[i] == pos.debtToken) {\n                    tokenIndex = int128(uint128(i));\n                    break;\n                }\n            }\n\n            ICurvePool(pool).remove_liquidity_one_coin(\n                amountPosRemove,\n                int128(tokenIndex),\n                0\n            );\n        }\n\n        // 5. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        // 6. Repay\n        {\n            // Compute repay amount if MAX_INT is supplied (max debt)\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(bank.POSITION_ID());\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        _validateMaxLTV(param.strategyId);\n\n        // 7. Refund\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n        _doRefund(CRV);\n    }\n}"
    }
  ]
}