{
  "Title": "ERC-721 Tokens Can Be Locked on the Token Bridge",
  "Content": "The `TokenBridge` contract allows tokens to be bridged across layers with the [`bridgeToken`](https://github.com/Consensys/linea-contracts/blob/f08c1906855198e2dc0413a47dcb38291b7087e5/contracts/tokenBridge/TokenBridge.sol#L118) function. When a native token is bridged, the token bridge will call [`safeTransferFrom`](https://github.com/Consensys/linea-contracts/blob/f08c1906855198e2dc0413a47dcb38291b7087e5/contracts/tokenBridge/TokenBridge.sol#L149) to move the token from the caller to itself. This `safeTransferFrom` function is defined in OpenZeppelin's [`SafeERC20Upgradeable`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.9.3/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol#L34-L36) contract.\n\n\nWhile this definition of `safeTransferFrom` is intended to be used solely with ERC-20 tokens, it is possible to move ERC-721 tokens with it. Inside the function call, the low-level [`transferFrom`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.9.3/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol#L35) function is actually used to transfer the token. The ERC-721 standard [contains this function signature](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.3/contracts/token/ERC721/ERC721.sol#L150) and uses it to transfer tokens.\n\n\nIf a user attempts to bridge an ERC-721 token with the token bridge, the first half of the bridging, where the tokens are collected onto the bridge, will succeed. However, the bridge uses [`safeTransfer`](https://github.com/Consensys/linea-contracts/blob/f08c1906855198e2dc0413a47dcb38291b7087e5/contracts/tokenBridge/TokenBridge.sol#L213) when bridging native tokens out, which uses the low-level [`transfer`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.9.3/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol#L27) function. Unfortunately, `transfer` is not supported by the ERC-721 standard, resulting in the ERC-721 being locked on the token bridge, with an upgrade being the only way to recover it.\n\n\nConsider blocking the bridging of ERC-721 tokens, for example by removing the [default decimal fallback](https://github.com/Consensys/linea-contracts/blob/f08c1906855198e2dc0413a47dcb38291b7087e5/contracts/tokenBridge/TokenBridge.sol#L395) during metadata collection. By reverting when a contract does not properly support the decimals function selector, all standard ERC-721 contracts would revert before sending any tokens to the contract.\n\n\n***Update:** Acknowledged, will resolve. The Linea team stated:*\n\n\n\n> *This will be a future addition.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/tokenBridge/TokenBridge.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\nimport { ITokenBridge } from \"./interfaces/ITokenBridge.sol\";\nimport { IMessageService } from \"../interfaces/IMessageService.sol\";\n\nimport { IERC20PermitUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol\";\nimport { IERC20MetadataUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { SafeERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { BeaconProxy } from \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\n\nimport { BridgedToken } from \"./BridgedToken.sol\";\nimport { MessageServiceBase } from \"../messageService/MessageServiceBase.sol\";\n\n/**\n * @title Linea Canonical Token Bridge\n * @notice Contract to manage cross-chain ERC20 bridging.\n * @author ConsenSys Software Inc.\n */\ncontract TokenBridge is ITokenBridge, PausableUpgradeable, Ownable2StepUpgradeable, MessageServiceBase {\n  // solhint-disable-next-line var-name-mixedcase\n  bytes4 internal constant _PERMIT_SELECTOR =\n    bytes4(keccak256(bytes(\"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)\")));\n\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  address public tokenBeacon;\n  mapping(address => address) public nativeToBridgedToken;\n  mapping(address => address) public bridgedToNativeToken;\n\n  // Special addresses used in the mappings to mark specific states for tokens.\n  /// @notice EMPTY means a token is not present in the mapping.\n  address internal constant EMPTY = address(0x0);\n  /// @notice RESERVED means a token is reserved and cannot be bridged.\n  address internal constant RESERVED_STATUS = address(0x111);\n  /// @notice NATIVE means a token is native to the current local chain.\n  address internal constant NATIVE_STATUS = address(0x222);\n  /// @notice DEPLOYED means the bridged token contract has been deployed on the remote chain.\n  address internal constant DEPLOYED_STATUS = address(0x333);\n\n  /// @dev Keep free storage slots for future implementation updates to avoid storage collision.\n  uint256[50] private __gap;\n\n  /// @dev Ensures the token has not been bridged before.\n  modifier isNewToken(address _token) {\n    if (nativeToBridgedToken[_token] != EMPTY || bridgedToNativeToken[_token] != EMPTY)\n      revert AlreadyBridgedToken(_token);\n    _;\n  }\n\n  /**\n   * @dev Ensures the address is not address(0).\n   * @param _addr Address to check.\n   */\n  modifier nonZeroAddress(address _addr) {\n    if (_addr == EMPTY) revert ZeroAddressNotAllowed();\n    _;\n  }\n  /**\n   * @dev Ensures the amount is not 0.\n   * @param _amount amount to check.\n   */\n  modifier nonZeroAmount(uint256 _amount) {\n    if (_amount == 0) revert ZeroAmountNotAllowed(_amount);\n    _;\n  }\n\n  /// @dev Disable constructor for safety\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @dev Contract will be used as proxy implementation.\n   * @param _messageService The address of the MessageService contract.\n   * @param _tokenBeacon The address of the tokenBeacon.\n   * @param _reservedTokens The list of reserved tokens to be set\n   */\n  function initialize(\n    address _securityCouncil,\n    address _messageService,\n    address _tokenBeacon,\n    address[] calldata _reservedTokens\n  ) external nonZeroAddress(_securityCouncil) nonZeroAddress(_messageService) nonZeroAddress(_tokenBeacon) initializer {\n    __Pausable_init();\n    __Ownable2Step_init();\n    __MessageServiceBase_init(_messageService);\n    tokenBeacon = _tokenBeacon;\n    for (uint256 i = 0; i < _reservedTokens.length; i++) {\n      if (_reservedTokens[i] == EMPTY) revert ZeroAddressNotAllowed();\n      setReserved(_reservedTokens[i]);\n    }\n    _transferOwnership(_securityCouncil);\n  }\n\n  /**\n   * @notice This function is the single entry point to bridge tokens to the\n   *   other chain, both for native and already bridged tokens. You can use it\n   *   to bridge any ERC20. If the token is bridged for the first time an ERC20\n   *   (BridgedToken.sol) will be automatically deployed on the target chain.\n   * @dev User should first allow the bridge to transfer tokens on his behalf.\n   *   Alternatively, you can use BridgeTokenWithPermit to do so in a single\n   *   transaction. If you want the transfer to be automatically executed on the\n   *   destination chain. You should send enough ETH to pay the postman fees.\n   *   Note that Linea can reserved some tokens (which use a dedicated bridge).\n   *   In this case, the token cannot be bridged. Linea can only reserved tokens\n   *   that are not been bridged yet.\n   *   Linea can pause the bridge for security reason. In this case new bridge\n   *   transaction would revert.\n   * @param _token The address of the token to be bridged.\n   * @param _amount The amount of the token to be bridged.\n   * @param _recipient The address that will receive the tokens on the other chain.\n   */\n  function bridgeToken(\n    address _token,\n    uint256 _amount,\n    address _recipient\n  ) public payable nonZeroAddress(_token) nonZeroAmount(_amount) whenNotPaused {\n    address nativeMappingValue = nativeToBridgedToken[_token];\n\n    if (nativeMappingValue == RESERVED_STATUS) {\n      // Token is reserved\n      revert ReservedToken(_token);\n    }\n\n    address bridgedMappingValue = bridgedToNativeToken[_token];\n    address nativeToken;\n    bytes memory tokenMetadata;\n    if (bridgedMappingValue != EMPTY) {\n      // Token is bridged\n      BridgedToken(_token).burn(msg.sender, _amount);\n      nativeToken = bridgedMappingValue;\n    } else {\n      // Token is native\n\n      // Make sure that this token has not been bridged as a native token from the other layer\n      // If this is the case nativeMappingValue should be EMPTY or DEPLOYED or NATIVE if not we revert\n      if (nativeMappingValue != EMPTY && nativeMappingValue != DEPLOYED_STATUS && nativeMappingValue != NATIVE_STATUS) {\n        revert TokenNativeOnOtherLayer(_token);\n      }\n\n      // For tokens with special fee logic, ensure that only the amount received\n      // by the bridge will be minted on the target chain.\n      uint256 balanceBefore = IERC20Upgradeable(_token).balanceOf(address(this));\n      IERC20Upgradeable(_token).safeTransferFrom(msg.sender, address(this), _amount);\n      _amount = IERC20Upgradeable(_token).balanceOf(address(this)) - balanceBefore;\n      nativeToken = _token;\n      if (nativeMappingValue == EMPTY) {\n        // New token\n        nativeToBridgedToken[_token] = NATIVE_STATUS;\n        emit NewToken(_token);\n      }\n\n      // Send Metadata only when the token has not been deployed on the other chain yet\n      if (nativeMappingValue != DEPLOYED_STATUS) {\n        tokenMetadata = abi.encode(_safeName(_token), _safeSymbol(_token), _safeDecimals(_token));\n      }\n    }\n\n    messageService.sendMessage{ value: msg.value }(\n      remoteSender,\n      msg.value, // fees\n      abi.encodeCall(ITokenBridge.completeBridging, (nativeToken, _amount, _recipient, tokenMetadata))\n    );\n    emit BridgingInitiated(msg.sender, _recipient, _token, _amount);\n  }\n\n  /**\n   * @notice Similar to `bridgeToken` function but allows to pass additional\n   *   permit data to do the ERC20 approval in a single transaction.\n   * @param _token The address of the token to be bridged.\n   * @param _amount The amount of the token to be bridged.\n   * @param _recipient The address that will receive the tokens on the other chain.\n   * @param _permitData The permit data for the token, if applicable.\n   */\n  function bridgeTokenWithPermit(\n    address _token,\n    uint256 _amount,\n    address _recipient,\n    bytes calldata _permitData\n  ) external payable nonZeroAddress(_token) nonZeroAmount(_amount) whenNotPaused {\n    if (_permitData.length != 0) {\n      _permit(_token, _permitData);\n    }\n    bridgeToken(_token, _amount, _recipient);\n  }\n\n  /**\n   * @dev It can only be called from the Message Service. To finalize the bridging\n   *   process, a user or postman needs to use the `claimMessage` function of the\n   *   Message Service to trigger the transaction.\n   * @param _nativeToken The address of the token on its native chain.\n   * @param _amount The amount of the token to be received.\n   * @param _recipient The address that will receive the tokens.\n   * @param _tokenMetadata Additional data used to deploy the bridged token if it\n   *   doesn't exist already.\n   */\n  function completeBridging(\n    address _nativeToken,\n    uint256 _amount,\n    address _recipient,\n    bytes calldata _tokenMetadata\n  ) external onlyMessagingService onlyAuthorizedRemoteSender {\n    address nativeMappingValue = nativeToBridgedToken[_nativeToken];\n    address bridgedToken;\n\n    if (nativeMappingValue == NATIVE_STATUS || nativeMappingValue == DEPLOYED_STATUS) {\n      // Token is native on the local chain\n      IERC20Upgradeable(_nativeToken).safeTransfer(_recipient, _amount);\n    } else {\n      bridgedToken = nativeMappingValue;\n      if (nativeMappingValue == EMPTY) {\n        // New token\n        bridgedToken = deployBridgedToken(_nativeToken, _tokenMetadata);\n        bridgedToNativeToken[bridgedToken] = _nativeToken;\n        nativeToBridgedToken[_nativeToken] = bridgedToken;\n      }\n      BridgedToken(bridgedToken).mint(_recipient, _amount);\n    }\n    emit BridgingFinalized(_nativeToken, bridgedToken, _amount, _recipient);\n  }\n\n  /**\n   * @dev Change the address of the Message Service.\n   * @param _messageService The address of the new Message Service.\n   */\n  function setMessageService(address _messageService) public onlyOwner {\n    address oldMessageService = address(messageService);\n    messageService = IMessageService(_messageService);\n    emit MessageServiceUpdated(_messageService, oldMessageService);\n  }\n\n  /**\n   * @dev Change the status to DEPLOYED to the tokens passed in parameter\n   *    Will call the method setDeployed on the other chain using the message Service\n   * @param _tokens Array of bridged tokens that have been deployed.\n   */\n  function confirmDeployment(address[] memory _tokens) external payable {\n    // Check that the tokens have actually been deployed\n    for (uint256 i; i < _tokens.length; i++) {\n      address nativeToken = bridgedToNativeToken[_tokens[i]];\n      if (nativeToken == EMPTY) {\n        revert TokenNotDeployed(_tokens[i]);\n      }\n      _tokens[i] = nativeToken;\n    }\n\n    messageService.sendMessage{ value: msg.value }(\n      remoteSender,\n      msg.value, // fees\n      abi.encodeCall(ITokenBridge.setDeployed, (_tokens))\n    );\n\n    emit DeploymentConfirmed(_tokens);\n  }\n\n  /**\n   * @dev Change the status of tokens to DEPLOYED. New bridge transaction will not\n   *   contain token metadata, which save gas.\n   *   Can only be called from the Message Service. A user or postman needs to use\n   *   the `claimMessage` function of the Message Service to trigger the transaction.\n   * @param _nativeTokens Array of native tokens for which the DEPLOYED status must be set.\n   */\n  function setDeployed(address[] memory _nativeTokens) external onlyMessagingService onlyAuthorizedRemoteSender {\n    address nativeToken;\n    for (uint256 i; i < _nativeTokens.length; i++) {\n      nativeToken = _nativeTokens[i];\n      nativeToBridgedToken[_nativeTokens[i]] = DEPLOYED_STATUS;\n      emit TokenDeployed(_nativeTokens[i]);\n    }\n  }\n\n  /**\n   * @dev Sets the address of the remote token bridge. Can only be called once.\n   * @param _remoteTokenBridge The address of the remote token bridge to be set.\n   */\n  function setRemoteTokenBridge(address _remoteTokenBridge) external onlyOwner {\n    if (remoteSender != EMPTY) revert RemoteTokenBridgeAlreadySet(remoteSender);\n    _setRemoteSender(_remoteTokenBridge);\n    emit RemoteTokenBridgeSet(_remoteTokenBridge);\n  }\n\n  /**\n   * @dev Deploy a new EC20 contract for bridged token using a beacon proxy pattern.\n   *   To adapt to future requirements, Linea can update the implementation of\n   *   all (existing and future) contracts by updating the beacon. This update is\n   *   subject to a by a time lock.\n   *   Contracts are deployed using CREATE2 so deployment address is deterministic.\n   * @param _nativeToken The address of the native token on the source chain.\n   * @param _tokenMetadata The encoded metadata for the token.\n   * @return The address of the newly deployed BridgedToken contract.\n   */\n  function deployBridgedToken(address _nativeToken, bytes calldata _tokenMetadata) internal returns (address) {\n    bytes32 _salt;\n    assembly {\n      _salt := _nativeToken\n    }\n    BeaconProxy bridgedToken = new BeaconProxy{ salt: _salt }(tokenBeacon, \"\");\n    address bridgedTokenAddress = address(bridgedToken);\n\n    (string memory name, string memory symbol, uint8 decimals) = abi.decode(_tokenMetadata, (string, string, uint8));\n    BridgedToken(bridgedTokenAddress).initialize(name, symbol, decimals);\n    emit NewTokenDeployed(bridgedTokenAddress);\n    return bridgedTokenAddress;\n  }\n\n  /**\n   * @dev Linea can reserved tokens. In this case, the token cannot be bridged.\n   *   Linea can only reserved tokens that are not been bridged before.\n   * @param _token The address of the token to be set as reserved.\n   */\n  function setReserved(address _token) public onlyOwner isNewToken(_token) nonZeroAddress(_token) {\n    nativeToBridgedToken[_token] = RESERVED_STATUS;\n    emit TokenReserved(_token);\n  }\n\n  /**\n   * @dev Removes a token from the reserved list.\n   * @param _token The address of the token to be removed from the reserved list.\n   */\n  function removeReserved(address _token) external onlyOwner {\n    if (nativeToBridgedToken[_token] != RESERVED_STATUS) revert NotReserved(_token);\n    nativeToBridgedToken[_token] = EMPTY;\n  }\n\n  /**\n   * @dev Linea can set a custom ERC20 contract for specific ERC20.\n   *   For security purpose, Linea can only call this function if the token has\n   *   not been bridged yet.\n   * @param _nativeToken The address of the token on the source chain.\n   * @param _targetContract The address of the custom contract.\n   */\n  function setCustomContract(\n    address _nativeToken,\n    address _targetContract\n  ) external onlyOwner isNewToken(_nativeToken) {\n    if (bridgedToNativeToken[_targetContract] != EMPTY) {\n      revert AlreadyBrigedToNativeTokenSet(_targetContract);\n    }\n    if (_targetContract == NATIVE_STATUS || _targetContract == DEPLOYED_STATUS || _targetContract == RESERVED_STATUS) {\n      revert StatusAddressNotAllowed(_targetContract);\n    }\n    nativeToBridgedToken[_nativeToken] = _targetContract;\n    bridgedToNativeToken[_targetContract] = _nativeToken;\n    emit CustomContractSet(_nativeToken, _targetContract);\n  }\n\n  /**\n   * @dev Pause the contract, can only be called by the owner.\n   */\n  function pause() external onlyOwner {\n    _pause();\n  }\n\n  /**\n   * @dev Unpause the contract, can only be called by the owner.\n   */\n  function unpause() external onlyOwner {\n    _unpause();\n  }\n\n  // Helpers to safely get the metadata from a token, inspired by\n  // https://github.com/traderjoe-xyz/joe-core/blob/main/contracts/MasterChefJoeV3.sol#L55-L95\n\n  /**\n   * @dev Provides a safe ERC20.name version which returns 'NO_NAME' as fallback string.\n   * @param _token The address of the ERC-20 token contract\n   * @param _token The address of the ERC-20 token contract.\n   */\n  function _safeName(address _token) internal view returns (string memory) {\n    (bool success, bytes memory data) = _token.staticcall(abi.encodeCall(IERC20MetadataUpgradeable.name, ()));\n    return success ? _returnDataToString(data) : \"NO_NAME\";\n  }\n\n  /**\n   * @dev Provides a safe ERC20.symbol version which returns 'NO_SYMBOL' as fallback string\n   * @param _token The address of the ERC-20 token contract\n   */\n  function _safeSymbol(address _token) internal view returns (string memory) {\n    (bool success, bytes memory data) = _token.staticcall(abi.encodeCall(IERC20MetadataUpgradeable.symbol, ()));\n    return success ? _returnDataToString(data) : \"NO_SYMBOL\";\n  }\n\n  /**\n   * @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\n   *   Note Tokens with (decimals > 255) are not supported\n   * @param _token The address of the ERC-20 token contract\n   */\n  function _safeDecimals(address _token) internal view returns (uint8) {\n    (bool success, bytes memory data) = _token.staticcall(abi.encodeCall(IERC20MetadataUpgradeable.decimals, ()));\n    return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n  }\n\n  /**\n   * @dev Converts returned data to string. Returns 'NOT_VALID_ENCODING' as fallback value.\n   * @param _data returned data\n   */\n  function _returnDataToString(bytes memory _data) internal pure returns (string memory) {\n    if (_data.length >= 64) {\n      return abi.decode(_data, (string));\n    } else if (_data.length != 32) {\n      return \"UNKNOWN\";\n    }\n\n    // Since the strings on bytes32 are encoded left-right, check the first zero in the data\n    uint256 nonZeroBytes;\n    unchecked {\n      while (nonZeroBytes < 32 && _data[nonZeroBytes] != 0) {\n        nonZeroBytes++;\n      }\n    }\n\n    // If the first one is 0, we do not handle the encoding\n    if (nonZeroBytes == 0) {\n      return \"UNKNOWN\";\n    }\n    // Create a byte array with nonZeroBytes length\n    bytes memory bytesArray = new bytes(nonZeroBytes);\n    unchecked {\n      for (uint256 i = 0; i < nonZeroBytes; i++) {\n        bytesArray[i] = _data[i];\n      }\n    }\n    return string(bytesArray);\n  }\n\n  /**\n   * @notice Call the token permit method of extended ERC20\n   * @param _token ERC20 token address\n   * @param _permitData Raw data of the call `permit` of the token\n   */\n  function _permit(address _token, bytes calldata _permitData) internal {\n    if (bytes4(_permitData[:4]) != _PERMIT_SELECTOR)\n      revert InvalidPermitData(bytes4(_permitData[:4]), _PERMIT_SELECTOR);\n    // Decode the permit data\n    // The parameters are:\n    // 1. owner: The address of the wallet holding the tokens\n    // 2. spender: The address of the entity permitted to spend the tokens\n    // 3. value: The maximum amount of tokens the spender is allowed to spend\n    // 4. deadline: The time until which the permit is valid\n    // 5. v: Part of the signature (along with r and s), these three values form the signature of the permit\n    // 6. r: Part of the signature\n    // 7. s: Part of the signature\n    (address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) = abi.decode(\n      _permitData[4:],\n      (address, address, uint256, uint256, uint8, bytes32, bytes32)\n    );\n    if (owner != msg.sender) revert PermitNotFromSender(owner);\n    if (spender != address(this)) revert PermitNotAllowingBridge(spender);\n    IERC20PermitUpgradeable(_token).permit(msg.sender, address(this), amount, deadline, v, r, s);\n  }\n}"
    },
    {
      "filename": "contracts/token/ERC20/utils/SafeERC20Upgradeable.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}"
    },
    {
      "filename": "contracts/tokenBridge/TokenBridge.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\nimport { ITokenBridge } from \"./interfaces/ITokenBridge.sol\";\nimport { IMessageService } from \"../interfaces/IMessageService.sol\";\n\nimport { IERC20PermitUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol\";\nimport { IERC20MetadataUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { SafeERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { BeaconProxy } from \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\n\nimport { BridgedToken } from \"./BridgedToken.sol\";\nimport { MessageServiceBase } from \"../messageService/MessageServiceBase.sol\";\n\n/**\n * @title Linea Canonical Token Bridge\n * @notice Contract to manage cross-chain ERC20 bridging.\n * @author ConsenSys Software Inc.\n */\ncontract TokenBridge is ITokenBridge, PausableUpgradeable, Ownable2StepUpgradeable, MessageServiceBase {\n  // solhint-disable-next-line var-name-mixedcase\n  bytes4 internal constant _PERMIT_SELECTOR =\n    bytes4(keccak256(bytes(\"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)\")));\n\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  address public tokenBeacon;\n  mapping(address => address) public nativeToBridgedToken;\n  mapping(address => address) public bridgedToNativeToken;\n\n  // Special addresses used in the mappings to mark specific states for tokens.\n  /// @notice EMPTY means a token is not present in the mapping.\n  address internal constant EMPTY = address(0x0);\n  /// @notice RESERVED means a token is reserved and cannot be bridged.\n  address internal constant RESERVED_STATUS = address(0x111);\n  /// @notice NATIVE means a token is native to the current local chain.\n  address internal constant NATIVE_STATUS = address(0x222);\n  /// @notice DEPLOYED means the bridged token contract has been deployed on the remote chain.\n  address internal constant DEPLOYED_STATUS = address(0x333);\n\n  /// @dev Keep free storage slots for future implementation updates to avoid storage collision.\n  uint256[50] private __gap;\n\n  /// @dev Ensures the token has not been bridged before.\n  modifier isNewToken(address _token) {\n    if (nativeToBridgedToken[_token] != EMPTY || bridgedToNativeToken[_token] != EMPTY)\n      revert AlreadyBridgedToken(_token);\n    _;\n  }\n\n  /**\n   * @dev Ensures the address is not address(0).\n   * @param _addr Address to check.\n   */\n  modifier nonZeroAddress(address _addr) {\n    if (_addr == EMPTY) revert ZeroAddressNotAllowed();\n    _;\n  }\n  /**\n   * @dev Ensures the amount is not 0.\n   * @param _amount amount to check.\n   */\n  modifier nonZeroAmount(uint256 _amount) {\n    if (_amount == 0) revert ZeroAmountNotAllowed(_amount);\n    _;\n  }\n\n  /// @dev Disable constructor for safety\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @dev Contract will be used as proxy implementation.\n   * @param _messageService The address of the MessageService contract.\n   * @param _tokenBeacon The address of the tokenBeacon.\n   * @param _reservedTokens The list of reserved tokens to be set\n   */\n  function initialize(\n    address _securityCouncil,\n    address _messageService,\n    address _tokenBeacon,\n    address[] calldata _reservedTokens\n  ) external nonZeroAddress(_securityCouncil) nonZeroAddress(_messageService) nonZeroAddress(_tokenBeacon) initializer {\n    __Pausable_init();\n    __Ownable2Step_init();\n    __MessageServiceBase_init(_messageService);\n    tokenBeacon = _tokenBeacon;\n    for (uint256 i = 0; i < _reservedTokens.length; i++) {\n      if (_reservedTokens[i] == EMPTY) revert ZeroAddressNotAllowed();\n      setReserved(_reservedTokens[i]);\n    }\n    _transferOwnership(_securityCouncil);\n  }\n\n  /**\n   * @notice This function is the single entry point to bridge tokens to the\n   *   other chain, both for native and already bridged tokens. You can use it\n   *   to bridge any ERC20. If the token is bridged for the first time an ERC20\n   *   (BridgedToken.sol) will be automatically deployed on the target chain.\n   * @dev User should first allow the bridge to transfer tokens on his behalf.\n   *   Alternatively, you can use BridgeTokenWithPermit to do so in a single\n   *   transaction. If you want the transfer to be automatically executed on the\n   *   destination chain. You should send enough ETH to pay the postman fees.\n   *   Note that Linea can reserved some tokens (which use a dedicated bridge).\n   *   In this case, the token cannot be bridged. Linea can only reserved tokens\n   *   that are not been bridged yet.\n   *   Linea can pause the bridge for security reason. In this case new bridge\n   *   transaction would revert.\n   * @param _token The address of the token to be bridged.\n   * @param _amount The amount of the token to be bridged.\n   * @param _recipient The address that will receive the tokens on the other chain.\n   */\n  function bridgeToken(\n    address _token,\n    uint256 _amount,\n    address _recipient\n  ) public payable nonZeroAddress(_token) nonZeroAmount(_amount) whenNotPaused {\n    address nativeMappingValue = nativeToBridgedToken[_token];\n\n    if (nativeMappingValue == RESERVED_STATUS) {\n      // Token is reserved\n      revert ReservedToken(_token);\n    }\n\n    address bridgedMappingValue = bridgedToNativeToken[_token];\n    address nativeToken;\n    bytes memory tokenMetadata;\n    if (bridgedMappingValue != EMPTY) {\n      // Token is bridged\n      BridgedToken(_token).burn(msg.sender, _amount);\n      nativeToken = bridgedMappingValue;\n    } else {\n      // Token is native\n\n      // Make sure that this token has not been bridged as a native token from the other layer\n      // If this is the case nativeMappingValue should be EMPTY or DEPLOYED or NATIVE if not we revert\n      if (nativeMappingValue != EMPTY && nativeMappingValue != DEPLOYED_STATUS && nativeMappingValue !"
    }
  ]
}