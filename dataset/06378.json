{
  "Title": "[G-02] State variables only set during construction should be declared constant",
  "Content": "The solidity compiler will directly embed the values of constant variables into your contract bytecode, and therefore, will save you from incurring a `Gsset (20000 gas)` when you set storage variables during construction; a `Gcoldsload (2100 gas)` when you access storage variables for the first time in a transaction, and a `Gwarmaccess (100 gas)` for each subsequent access to that storage slot.\n\nTotal Instances: `2`\n\nEstimated Gas Saved: `2 * 2100 = 4200`\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/token/LBR.sol#L15\n\n```solidity\nFile: contracts/lybra/token/LBR.sol\n15:    uint256 maxSupply = 100_000_000 * 1e18; // @audit: only set during construction\n```\n```diff\ndiff --git a/lybra/token/LBR.sol b/lybra/token/LBR.sol\nindex 26fe9d0..a2a802f 100644\n--- a/lybra/token/LBR.sol\n+++ b/lybra/token/LBR.sol\n@@ -12,7 +12,7 @@ import \"../../OFT/BaseOFTV2.sol\";\n\n contract LBR is BaseOFTV2, ERC20 {\n     Iconfigurator public immutable configurator;\n-    uint256 maxSupply = 100_000_000 * 1e18;\n+    uint256 constant maxSupply = 100_000_000 * 1e18;\n     uint internal immutable ld2sdRatio;\n```\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/token/esLBR.sol#L20\n\n```solidity\nFile: contracts/lybra/token/esLBR.sol\n20:    uint256 maxSupply = 100_000_000 * 1e18; // @audit: only set during construction\n```\n```diff\ndiff --git a/lybra/token/esLBR.sol b/lybra/token/esLBR.sol \nindex ca08201..da5d08d 100644\n--- a/lybra/token/esLBR.sol \n+++ b/lybra/token/esLBR.sol \n@@ -17,7 +17,7 @@ interface IProtocolRewardsPool {\n contract esLBR is ERC20Votes {\n     Iconfigurator public immutable configurator;\n\n-    uint256 maxSupply = 100_000_000 * 1e18;\n+    uint256 constant maxSupply = 100_000_000 * 1e18;\n\n     constructor(address _config) ERC20Permit(\"esLBR\") ERC20(\"esLBR\", \"esLBR\") {\n         configurator = Iconfigurator(_config);\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-06-lybra",
  "Code": [
    {
      "filename": "contracts/lybra/token/LBR.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n/**\n * @title LBR is an ERC20-compliant token.\n * - LBR can only be exchanged to esLBR in the lybraFund contract.\n * - Apart from the initial production, LBR can only be produced by destroying esLBR in the fund contract.\n */\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../interfaces/Iconfigurator.sol\";\nimport \"../../OFT/BaseOFTV2.sol\";\n\ncontract LBR is BaseOFTV2, ERC20 {\n    Iconfigurator public immutable configurator;\n    uint256 maxSupply = 100_000_000 * 1e18;\n    uint internal immutable ld2sdRatio;\n\n    constructor(address _config, uint8 _sharedDecimals, address _lzEndpoint) ERC20(\"LBR\", \"LBR\") BaseOFTV2(_sharedDecimals, _lzEndpoint) {\n        configurator = Iconfigurator(_config);\n        uint8 decimals = decimals();\n        require(_sharedDecimals <= decimals, \"OFT: sharedDecimals must be <= decimals\");\n        ld2sdRatio = 10 ** (decimals - _sharedDecimals);\n    }\n\n    function mint(address user, uint256 amount) external returns (bool) {\n        require(configurator.tokenMiner(msg.sender), \"not authorized\");\n        require(totalSupply() + amount <= maxSupply, \"exceeding the maximum supply quantity.\");\n        _mint(user, amount);\n        return true;\n    }\n\n    function burn(address user, uint256 amount) external returns (bool) {\n        require(configurator.tokenMiner(msg.sender), \"not authorized\");\n        _burn(user, amount);\n        return true;\n    }\n\n    function circulatingSupply() public view virtual override returns (uint) {\n        return totalSupply();\n    }\n\n    function token() public view virtual override returns (address) {\n        return address(this);\n    }\n\n    /************************************************************************\n     * internal functions\n     ************************************************************************/\n    function _debitFrom(address _from, uint16, bytes32, uint _amount) internal virtual override returns (uint) {\n        address spender = _msgSender();\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\n        _burn(_from, _amount);\n        return _amount;\n    }\n\n    function _creditTo(uint16, address _toAddress, uint _amount) internal virtual override returns (uint) {\n        _mint(_toAddress, _amount);\n        return _amount;\n    }\n\n    function _transferFrom(address _from, address _to, uint _amount) internal virtual override returns (uint) {\n        address spender = _msgSender();\n        // if transfer from this contract, no need to check allowance\n        if (_from != address(this) && _from != spender)\n            _spendAllowance(_from, spender, _amount);\n        _transfer(_from, _to, _amount);\n        return _amount;\n    }\n\n    function _ld2sdRatio() internal view virtual override returns (uint) {\n        return ld2sdRatio;\n    }\n}"
    },
    {
      "filename": "contracts/lybra/token/esLBR.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n/**\n * @title esLBR is an ERC20-compliant token, but cannot be transferred and can only be minted through the esLBRMinter contract or redeemed for LBR by destruction.\n * - The maximum amount that can be minted through the esLBRMinter contract is 55 million.\n * - esLBR can be used for community governance voting.\n */\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport \"../interfaces/Iconfigurator.sol\";\n\ninterface IProtocolRewardsPool {\n    function refreshReward(address user) external;\n}\n\ncontract esLBR is ERC20Votes {\n    Iconfigurator public immutable configurator;\n\n    uint256 maxSupply = 100_000_000 * 1e18;\n\n    constructor(address _config) ERC20Permit(\"esLBR\") ERC20(\"esLBR\", \"esLBR\") {\n        configurator = Iconfigurator(_config);\n    }\n\n    function _transfer(address, address, uint256) internal virtual override {\n        revert(\"not authorized\");\n    }\n\n    function mint(address user, uint256 amount) external returns (bool) {\n        require(configurator.tokenMiner(msg.sender), \"not authorized\");\n        require(totalSupply() + amount <= maxSupply, \"exceeding the maximum supply quantity.\");\n        try IProtocolRewardsPool(configurator.getProtocolRewardsPool()).refreshReward(user) {} catch {}\n        _mint(user, amount);\n        return true;\n    }\n\n    function burn(address user, uint256 amount) external returns (bool) {\n        require(configurator.tokenMiner(msg.sender), \"not authorized\");\n        try IProtocolRewardsPool(configurator.getProtocolRewardsPool()).refreshReward(user) {} catch {}\n        _burn(user, amount);\n        return true;\n    }\n}"
    }
  ]
}