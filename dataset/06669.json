{
  "Title": "[L-03] `merkleizeSha256` doesn't work as expected",
  "Content": "\nhttps://github.com/code-423n4/2023-04-eigenlayer/blob/398cc428541b91948f717482ec973583c9e76232/src/contracts/libraries/Merkle.sol#L129\n\n### Proof of Concept\n\nWhenever `merkleizeSha256` is being used in the code, there is always a check that array length is power of 2. E.x.:\n```solidity\nbytes32[] memory paddedHeaderFields = new bytes32[](2**BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT);\n```\n[contracts/libraries/BeaconChainProofs.sol#L131](https://github.com/code-423n4/2023-04-eigenlayer/blob/398cc428541b91948f717482ec973583c9e76232/src/contracts/libraries/BeaconChainProofs.sol#L131)\n\nBut inside the function `merkleizeSha256`, there is no check that incoming array is power of 2. \n```solidity\n   /**\n     @notice this function returns the merkle root of a tree created from a set of leaves using sha256 as its hash function\n     @param leaves the leaves of the merkle tree\n\n     @notice requires the leaves.length is a power of 2\n     */ \n    function merkleizeSha256(\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32) {\n        //there are half as many nodes in the layer above the leaves\n        uint256 numNodesInLayer = leaves.length / 2;\n        //create a layer to store the internal nodes\n        bytes32[] memory layer = new bytes32[](numNodesInLayer);\n        //fill the layer with the pairwise hashes of the leaves\n        for (uint i = 0; i < numNodesInLayer; i++) {\n            layer[i] = sha256(abi.encodePacked(leaves[2*i], leaves[2*i+1]));\n        }\n        //the next layer above has half as many nodes\n        numNodesInLayer /= 2;\n        //while we haven't computed the root\n        while (numNodesInLayer != 0) {\n            //overwrite the first numNodesInLayer nodes in layer with the pairwise hashes of their children\n            for (uint i = 0; i < numNodesInLayer; i++) {\n                layer[i] = sha256(abi.encodePacked(layer[2*i], layer[2*i+1]));\n            }\n            //the next layer above has half as many nodes\n            numNodesInLayer /= 2;\n        }\n        //the first node in the layer is the root\n        return layer[0];\n    }\n```\n\nThere is a `@notice` that doesn't hold.\n>  @notice requires the leaves.length is a power of 2\n\nBut whenever there is a `require` in natspec inside the project, it always holds. E.x.:\n```\n    /**\n     * @notice Delegates from `staker` to `operator`.\n     * @dev requires that:\n     * 1) if `staker` is an EOA, then `signature` is valid ECSDA signature from `staker`, indicating their intention for this action\n     * 2) if `staker` is a contract, then `signature` must will be checked according to EIP-1271\n     */\n```\n[src/contracts/core/DelegationManager.sol#L89](https://github.com/code-423n4/2023-04-eigenlayer/blob/398cc428541b91948f717482ec973583c9e76232/src/contracts/core/DelegationManager.sol#L89)\n```solidity\n     * WARNING: In order to mitigate against inflation/donation attacks in the context of ERC_4626, this contract requires the \n     *          minimum amount of shares be either 0 or 1e9. A consequence of this is that in the worst case a user will not \n     *          be able to withdraw for 1e9-1 or less shares. \n     * \n```\n[/src/contracts/strategies/StrategyBase.sol#L72](https://github.com/code-423n4/2023-04-eigenlayer/blob/398cc428541b91948f717482ec973583c9e76232/src/contracts/strategies/StrategyBase.sol#L72)\n### Tools Used\nYou can insert this into remix to check:\n```solidity\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"hardhat/console.sol\";\n\ncontract Owner {\n\n    mapping(address => bool) internal frozenStatus;\n    constructor() {\n    }\n\n    function dod() external returns (bytes32){\n        bytes32[] memory leaves = new bytes32[](7);\n        for (uint256 i = 0; i < 7; ++i) {\n            leaves[i] = bytes32(i);\n        }\n        return merkleizeSha256(leaves);\n    }\n\n    function merkleizeSha256(\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32) {\n        //there are half as many nodes in the layer above the leaves\n        uint256 numNodesInLayer = leaves.length / 2;\n        //create a layer to store the internal nodes\n        bytes32[] memory layer = new bytes32[](numNodesInLayer);\n        //fill the layer with the pairwise hashes of the leaves\n        for (uint i = 0; i < numNodesInLayer; i++) {\n            layer[i] = sha256(abi.encodePacked(leaves[2*i], leaves[2*i+1]));\n        }\n        //the next layer above has half as many nodes\n        numNodesInLayer /= 2;\n        //while we haven't computed the root\n        while (numNodesInLayer != 0) {\n            //overwrite the first numNodesInLayer nodes in layer with the pairwise hashes of their children\n            for (uint i = 0; i < numNodesInLayer; i++) {\n                layer[i] = sha256(abi.encodePacked(layer[2*i], layer[2*i+1]));\n            }\n            //the next layer above has half as many nodes\n            numNodesInLayer /= 2;\n        }\n        //the first node in the layer is the root\n        return layer[0];\n    }\n} \n```\n### Recommended Mitigation Steps\nEither remove `@notice` or add this code for more security because sometimes you can just forget to check array size before calling that function:\n```diff\n    function merkleizeSha256(\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32) {\n+        uint256 len = leaves.length;\n+        while (len > 1 && len % 2 == 0) {\n+            len /= 2;\n+        }\n+        require(len==1, \"requires the leaves.length is a power of 2\");\n        //there are half as many nodes in the layer above the leaves\n        uint256 numNodesInLayer = leaves.length / 2;\n        //create a layer to store the internal nodes\n        bytes32[] memory layer = new bytes32[](numNodesInLayer);\n        //fill the layer with the pairwise hashes of the leaves\n        for (uint i = 0; i < numNodesInLayer; i++) {\n            layer[i] = sha256(abi.encodePacked(leaves[2*i], leaves[2*i+1]));\n        }\n        //the next layer above has half as many nodes\n        numNodesInLayer /= 2;\n        //while we haven't computed the root\n        while (numNodesInLayer != 0) {\n            //overwrite the first numNodesInLayer nodes in layer with the pairwise hashes of their children\n            for (uint i = 0; i < numNodesInLayer; i++) {\n                layer[i] = sha256(abi.encodePacked(layer[2*i], layer[2*i+1]));\n            }\n            //the next layer above has half as many nodes\n            numNodesInLayer /= 2;\n        }\n        //the first node in the layer is the root\n        return layer[0];\n    }\n\n```\nRemix:\n```solidity\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"hardhat/console.sol\";\n\ncontract Owner {\n\n    mapping(address => bool) internal frozenStatus;\n    constructor() {\n    }\n\n    function dod(uint len) external returns (bytes32){\n        bytes32[] memory leaves = new bytes32[](len);\n        for (uint256 i = 0; i < len; ++i) {\n            leaves[i] = bytes32(i);\n        }\n        return merkleizeSha256(leaves);\n    }\n    function merkleizeSha256(\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32) {\n        uint256 len = leaves.length;\n        while (len > 1 && len % 2 == 0) {\n            len /= 2;\n        }\n        require(len==1, \"requires the leaves.length is a power of 2\");\n        //there are half as many nodes in the layer above the leaves\n        uint256 numNodesInLayer = leaves.length / 2;\n        //create a layer to store the internal nodes\n        bytes32[] memory layer = new bytes32[](numNodesInLayer);\n        //fill the layer with the pairwise hashes of the leaves\n        for (uint i = 0; i < numNodesInLayer; i++) {\n            layer[i] = sha256(abi.encodePacked(leaves[2*i], leaves[2*i+1]));\n        }\n        //the next layer above has half as many nodes\n        numNodesInLayer /= 2;\n        //while we haven't computed the root\n        while (numNodesInLayer != 0) {\n            //overwrite the first numNodesInLayer nodes in layer with the pairwise hashes of their children\n            for (uint i = 0; i < numNodesInLayer; i++) {\n                layer[i] = sha256(abi.encodePacked(layer[2*i], layer[2*i+1]));\n            }\n            //the next layer above has half as many nodes\n            numNodesInLayer /= 2;\n        }\n        //the first node in the layer is the root\n        return layer[0];\n    }\n\n\n} \n```\n\n**[Sidu28 (EigenLayer) disputed, disagreed with severity and commented](https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/23#issuecomment-1545180159):**\n>The comment is ambiguous, but is intended to actually state a precondition on the input. The comment will be changed.\n\n**[Alex the Entreprenerd (judge) decreased severity to QA and commented](https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/23#issuecomment-1566173588):**\n>Every instance in the in-scope codebase does check, meaning that the finding cannot be considered a vulnerability.\n>\n>I can agree with the Warden that a valid refactoring would bring the check in the function to simplify the code.\n>\n>For this reason, am downgrading to QA - Refactoring (R)\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-04-eigenlayer",
  "Code": [
    {
      "filename": "src/contracts/libraries/Merkle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Adapted from OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity =0.8.12;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary Merkle {\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is \n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     * \n     * Note this is for a Merkle tree using the keccak/sha3 hash function\n     */\n    function verifyInclusionKeccak(\n        bytes memory proof,\n        bytes32 root,\n        bytes32 leaf,\n        uint256 index\n    ) internal pure returns (bool) {\n        return processInclusionProofKeccak(proof, leaf, index) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is \n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     * \n     * _Available since v4.4._\n     * \n     * Note this is for a Merkle tree using the keccak/sha3 hash function\n     */\n    function processInclusionProofKeccak(bytes memory proof, bytes32 leaf, uint256 index) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 32; i <= proof.length; i+=32) {\n            if(index % 2 == 0) {\n                // if ith bit of index is 0, then computedHash is a left sibling\n                assembly {\n                    mstore(0x00, computedHash)\n                    mstore(0x20, mload(add(proof, i)))\n                    computedHash := keccak256(0x00, 0x40)\n                    index := div(index, 2)\n                }\n            } else {\n                // if ith bit of index is 1, then computedHash is a right sibling\n                assembly {\n                    mstore(0x00, mload(add(proof, i)))\n                    mstore(0x20, computedHash)\n                    computedHash := keccak256(0x00, 0x40)\n                    index := div(index, 2)\n                }            \n            }\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is \n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     * \n     * Note this is for a Merkle tree using the sha256 hash function\n     */\n    function verifyInclusionSha256(\n        bytes memory proof,\n        bytes32 root,\n        bytes32 leaf,\n        uint256 index\n    ) internal view returns (bool) {\n        return processInclusionProofSha256(proof, leaf, index) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is \n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     *\n     * _Available since v4.4._\n     * \n     * Note this is for a Merkle tree using the sha256 hash function\n     */\n    function processInclusionProofSha256(bytes memory proof, bytes32 leaf, uint256 index) internal view returns (bytes32) {\n        bytes32[1] memory computedHash = [leaf];\n        for (uint256 i = 32; i <= proof.length; i+=32) {\n            if(index % 2 == 0) {\n                // if ith bit of index is 0, then computedHash is a left sibling\n                assembly {\n                    mstore(0x00, mload(computedHash))\n                    mstore(0x20, mload(add(proof, i)))\n                    if iszero(staticcall(sub(gas(), 2000), 2, 0x00, 0x40, computedHash, 0x20)) {revert(0, 0)}\n                    index := div(index, 2)\n                }\n            } else {\n                // if ith bit of index is 1, then computedHash is a right sibling\n                assembly {\n                    mstore(0x00, mload(add(proof, i)))\n                    mstore(0x20, mload(computedHash))\n                    if iszero(staticcall(sub(gas(), 2000), 2, 0x00, 0x40, computedHash, 0x20)) {revert(0, 0)}\n                    index := div(index, 2)\n                }            \n            }\n        }\n        return computedHash[0];\n    }\n\n    /**\n     @notice this function returns the merkle root of a tree created from a set of leaves using sha256 as its hash function\n     @param leaves the leaves of the merkle tree\n\n     @notice requires the leaves.length is a power of 2\n     */ \n    function merkleizeSha256(\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32) {\n        //there are half as many nodes in the layer above the leaves\n        uint256 numNodesInLayer = leaves.length / 2;\n        //create a layer to store the internal nodes\n        bytes32[] memory layer = new bytes32[](numNodesInLayer);\n        //fill the layer with the pairwise hashes of the leaves\n        for (uint i = 0; i < numNodesInLayer; i++) {\n            layer[i] = sha256(abi.encodePacked(leaves[2*i], leaves[2*i+1]));\n        }\n        //the next layer above has half as many nodes\n        numNodesInLayer /= 2;\n        //while we haven't computed the root\n        while (numNodesInLayer != 0) {\n            //overwrite the first numNodesInLayer nodes in layer with the pairwise hashes of their children\n            for (uint i = 0; i < numNodesInLayer; i++) {\n                layer[i] = sha256(abi.encodePacked(layer[2*i], layer[2*i+1]));\n            }\n            //the next layer above has half as many nodes\n            numNodesInLayer /= 2;\n        }\n        //the first node in the layer is the root\n        return layer[0];\n    }\n}"
    },
    {
      "filename": "src/contracts/libraries/BeaconChainProofs.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity =0.8.12;\n\nimport \"./Merkle.sol\";\nimport \"../libraries/Endian.sol\";\n\n//Utility library for parsing and PHASE0 beacon chain block headers\n//SSZ Spec: https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#merkleization\n//BeaconBlockHeader Spec: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#beaconblockheader\n//BeaconState Spec: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#beaconstate\nlibrary BeaconChainProofs {\n    // constants are the number of fields and the heights of the different merkle trees used in merkleizing beacon chain containers\n    uint256 internal constant NUM_BEACON_BLOCK_HEADER_FIELDS = 5;\n    uint256 internal constant BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT = 3;\n\n    uint256 internal constant NUM_BEACON_BLOCK_BODY_FIELDS = 11;\n    uint256 internal constant BEACON_BLOCK_BODY_FIELD_TREE_HEIGHT = 4;\n\n    uint256 internal constant NUM_BEACON_STATE_FIELDS = 21;\n    uint256 internal constant BEACON_STATE_FIELD_TREE_HEIGHT = 5;\n\n    uint256 internal constant NUM_ETH1_DATA_FIELDS = 3;\n    uint256 internal constant ETH1_DATA_FIELD_TREE_HEIGHT = 2;\n\n    uint256 internal constant NUM_VALIDATOR_FIELDS = 8;\n    uint256 internal constant VALIDATOR_FIELD_TREE_HEIGHT = 3;\n\n    uint256 internal constant NUM_EXECUTION_PAYLOAD_HEADER_FIELDS = 15;\n    uint256 internal constant EXECUTION_PAYLOAD_HEADER_FIELD_TREE_HEIGHT = 4;\n\n\n    uint256 internal constant NUM_EXECUTION_PAYLOAD_FIELDS = 15;\n    uint256 internal constant EXECUTION_PAYLOAD_FIELD_TREE_HEIGHT = 4;\n\n\n    // HISTORICAL_ROOTS_LIMIT\t = 2**24, so tree height is 24\n    uint256 internal constant HISTORICAL_ROOTS_TREE_HEIGHT = 24;\n\n    // HISTORICAL_BATCH is root of state_roots and block_root, so number of leaves =  2^1\n    uint256 internal constant HISTORICAL_BATCH_TREE_HEIGHT = 1;\n\n    // SLOTS_PER_HISTORICAL_ROOT = 2**13, so tree height is 13\n    uint256 internal constant STATE_ROOTS_TREE_HEIGHT = 13;\n    uint256 internal constant BLOCK_ROOTS_TREE_HEIGHT = 13;\n\n\n    uint256 internal constant NUM_WITHDRAWAL_FIELDS = 4;\n    // tree height for hash tree of an individual withdrawal container\n    uint256 internal constant WITHDRAWAL_FIELD_TREE_HEIGHT = 2;\n\n    uint256 internal constant VALIDATOR_TREE_HEIGHT = 40;\n    //refer to the eigenlayer-cli proof library.  Despite being the same dimensions as the validator tree, the balance tree is merkleized differently\n    uint256 internal constant BALANCE_TREE_HEIGHT = 38;\n\n    // MAX_WITHDRAWALS_PER_PAYLOAD = 2**4, making tree height = 4\n    uint256 internal constant WITHDRAWALS_TREE_HEIGHT = 4;\n\n    //in beacon block body\n    uint256 internal constant EXECUTION_PAYLOAD_INDEX = 9;\n\n    // in beacon block header\n    uint256 internal constant STATE_ROOT_INDEX = 3;\n    uint256 internal constant PROPOSER_INDEX_INDEX = 1;\n    uint256 internal constant SLOT_INDEX = 0;\n    uint256 internal constant BODY_ROOT_INDEX = 4;\n    // in beacon state\n    uint256 internal constant STATE_ROOTS_INDEX = 6;\n    uint256 internal constant BLOCK_ROOTS_INDEX = 5;\n    uint256 internal constant HISTORICAL_ROOTS_INDEX = 7;\n    uint256 internal constant ETH_1_ROOT_INDEX = 8;\n    uint256 internal constant VALIDATOR_TREE_ROOT_INDEX = 11;\n    uint256 internal constant BALANCE_INDEX = 12;\n    uint256 internal constant EXECUTION_PAYLOAD_HEADER_INDEX = 24;\n    uint256 internal constant HISTORICAL_BATCH_STATE_ROOT_INDEX = 1;\n\n    // in validator\n    uint256 internal constant VALIDATOR_WITHDRAWAL_CREDENTIALS_INDEX = 1;\n    uint256 internal constant VALIDATOR_BALANCE_INDEX = 2;\n    uint256 internal constant VALIDATOR_SLASHED_INDEX = 3;\n    uint256 internal constant VALIDATOR_WITHDRAWABLE_EPOCH_INDEX = 7;\n    \n    // in exection payload header\n    uint256 internal constant BLOCK_NUMBER_INDEX = 6;\n    uint256 internal constant WITHDRAWALS_ROOT_INDEX = 14;\n\n    //in execution payload\n    uint256 internal constant WITHDRAWALS_INDEX = 14;\n\n    // in withdrawal\n    uint256 internal constant WITHDRAWAL_VALIDATOR_INDEX_INDEX = 1;\n    uint256 internal constant WITHDRAWAL_VALIDATOR_AMOUNT_INDEX = 3;\n\n    //In historicalBatch\n    uint256 internal constant HISTORICALBATCH_STATEROOTS_INDEX = 1;\n\n    //Misc Constants\n    uint256 internal constant SLOTS_PER_EPOCH = 32;\n\n    bytes8 internal constant UINT64_MASK = 0xffffffffffffffff;\n\n\n\n    struct WithdrawalProofs {\n        bytes blockHeaderProof;\n        bytes withdrawalProof;\n        bytes slotProof;\n        bytes executionPayloadProof;\n        bytes blockNumberProof;\n        uint64 blockHeaderRootIndex;\n        uint64 withdrawalIndex;\n        bytes32 blockHeaderRoot;\n        bytes32 blockBodyRoot;\n        bytes32 slotRoot;\n        bytes32 blockNumberRoot;\n        bytes32 executionPayloadRoot;\n    }\n\n    struct ValidatorFieldsAndBalanceProofs {\n        bytes validatorFieldsProof;\n        bytes validatorBalanceProof;\n        bytes32 balanceRoot;\n    }\n\n    struct ValidatorFieldsProof {\n        bytes validatorProof;\n        uint40 validatorIndex;\n    }\n\n    function computePhase0BeaconBlockHeaderRoot(bytes32[NUM_BEACON_BLOCK_HEADER_FIELDS] calldata blockHeaderFields) internal pure returns(bytes32) {\n        bytes32[] memory paddedHeaderFields = new bytes32[](2**BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT);\n        \n        for (uint256 i = 0; i < NUM_BEACON_BLOCK_HEADER_FIELDS; ++i) {\n            paddedHeaderFields[i] = blockHeaderFields[i];\n        }\n\n        return Merkle.merkleizeSha256(paddedHeaderFields);\n    }\n\n    function computePhase0BeaconStateRoot(bytes32[NUM_BEACON_STATE_FIELDS] calldata beaconStateFields) internal pure returns(bytes32) {\n        bytes32[] memory paddedBeaconStateFields = new bytes32[](2**BEACON_STATE_FIELD_TREE_HEIGHT);\n        \n        for (uint256 i = 0; i < NUM_BEACON_STATE_FIELDS; ++i) {\n            paddedBeaconStateFields[i] = beaconStateFields[i];\n        }\n        \n        return Merkle.merkleizeSha256(paddedBeaconStateFields);\n    }\n\n    function computePhase0ValidatorRoot(bytes32[NUM_VALIDATOR_FIELDS] calldata validatorFields) internal pure returns(bytes32) {  \n        bytes32[] memory paddedValidatorFields = new bytes32[](2**VALIDATOR_FIELD_TREE_HEIGHT);\n        \n        for (uint256 i = 0; i < NUM_VALIDATOR_FIELDS; ++i) {\n            paddedValidatorFields[i] = validatorFields[i];\n        }\n\n        return Merkle.merkleizeSha256(paddedValidatorFields);\n    }\n\n    function computePhase0Eth1DataRoot(bytes32[NUM_ETH1_DATA_FIELDS] calldata eth1DataFields) internal pure returns(bytes32) {  \n        bytes32[] memory paddedEth1DataFields = new bytes32[](2**ETH1_DATA_FIELD_TREE_HEIGHT);\n        \n        for (uint256 i = 0; i < ETH1_DATA_FIELD_TREE_HEIGHT; ++i) {\n            paddedEth1DataFields[i] = eth1DataFields[i];\n        }\n\n        return Merkle.merkleizeSha256(paddedEth1DataFields);\n    }\n\n    /**\n     * \n     * @notice This function is parses the balanceRoot to get the uint64 balance of a validator.  During merkleization of the\n     * beacon state balance tree, four uint64 values (making 32 bytes) are grouped together and treated as a single leaf in the merkle tree. Thus the\n     * validatorIndex mod 4 is used to determine which of the four uint64 values to extract from the balanceRoot.\n     * @param validatorIndex is the index of the validator being proven for.\n     * @param balanceRoot is the combination of 4 validator balances being proven for.\n     */\n   function getBalanceFromBalanceRoot(uint40 validatorIndex, bytes32 balanceRoot) internal pure returns (uint64) {\n        uint256 bitShiftAmount = (validatorIndex % 4) * 64;\n        bytes32 validatorBalanceLittleEndian = bytes32((uint256(balanceRoot) << bitShiftAmount));\n        uint64 validatorBalance = Endian.fromLittleEndianUint64(validatorBalanceLittleEndian);\n        return validatorBalance;\n    }\n\n    /**\n     * @notice This function verifies merkle proofs of the fields of a certain validator against a beacon chain state root\n     * @param validatorIndex the index of the proven validator\n     * @param beaconStateRoot is the beacon chain state root to be proven against.\n     * @param proof is the data used in proving the validator's fields\n     * @param validatorFields the claimed fields of the validator\n     */\n    function verifyValidatorFields(\n        uint40 validatorIndex,\n        bytes32 beaconStateRoot,\n        bytes calldata proof, \n        bytes32[] calldata validatorFields\n    ) internal view {\n        \n        require(validatorFields.length == 2**VALIDATOR_FIELD_TREE_HEIGHT, \"BeaconChainProofs.verifyValidatorFields: Validator fields has incorrect length\");\n\n        /**\n         * Note: the length of the validator merkle proof is BeaconChainProofs.VALIDATOR_TREE_HEIGHT + 1.\n         * There is an additional layer added by hashing the root with the length of the validator list\n         */\n        require(proof.length == 32 * ((VALIDATOR_TREE_HEIGHT + 1) + BEACON_STATE_FIELD_TREE_HEIGHT), \"BeaconChainProofs.verifyValidatorFields: Proof has incorrect length\");\n        uint256 index = (VALIDATOR_TREE_ROOT_INDEX << (VALIDATOR_TREE_HEIGHT + 1)) | uint256(validatorIndex);\n        // merkleize the validatorFields to get the leaf to prove\n        bytes32 validatorRoot = Merkle.merkleizeSha256(validatorFields);\n\n        // verify the proof of the validatorRoot against the beaconStateRoot\n        require(Merkle.verifyInclusionSha256(proof, beaconStateRoot, validatorRoot, index), \"BeaconChainProofs.verifyValidatorFields: Invalid merkle proof\");\n    }\n\n    /**\n     * @notice This function verifies merkle proofs of the balance of a certain validator against a beacon chain state root\n     * @param validatorIndex the index of the proven validator\n     * @param beaconStateRoot is the beacon chain state root to be proven against.\n     * @param proof is the proof of the balance against the beacon chain state root\n     * @param balanceRoot is the serialized balance used to prove the balance of the validator (refer to `getBalanceFromBalanceRoot` above for detailed explanation)\n     */\n    function verifyValidatorBalance(\n        uint40 validatorIndex,\n        bytes32 beaconStateRoot,\n        bytes calldata proof,\n        bytes32 balanceRoot\n    ) internal view {\n        require(proof.length == 32 * ((BALANCE_TREE_HEIGHT + 1) + BEACON_STATE_FIELD_TREE_HEIGHT), \"BeaconChainProofs.verifyValidatorBalance: Proof has incorrect length\");\n\n        /**\n        * the beacon state's balance list is a list of uint64 values, and these are grouped together in 4s when merkleized.  \n        * Therefore, the index of the balance of a validator is validatorIndex/4\n        */\n        uint256 balanceIndex = uint256(validatorIndex/4);\n        balanceIndex = (BALANCE_INDEX << (BALANCE_TREE_HEIGHT + 1)) | balanceIndex;\n\n        require(Merkle.verifyInclusionSha256(proof, beaconStateRoot, balanceRoot, balanceIndex), \"BeaconChainProofs.verifyValidatorBalance: Invalid merkle proof\");\n    }\n\n    /**\n     * @notice This function verifies the slot and the withdrawal fields for a given withdrawal\n     * @param beaconStateRoot is the beacon chain state root to be proven against.\n     * @param proofs is the provided set of merkle proofs\n     * @param withdrawalFields is the serialized withdrawal container to be proven\n     */\n    function verifyWithdrawalProofs(\n        bytes32 beaconStateRoot,\n        WithdrawalProofs calldata proofs,\n        bytes32[] calldata withdrawalFields\n    ) internal view {\n        require(withdrawalFields.length == 2**WITHDRAWAL_FIELD_TREE_HEIGHT, \"BeaconChainProofs.verifyWithdrawalProofs: withdrawalFields has incorrect length\");\n\n        require(proofs.blockHeaderRootIndex < 2**BLOCK_ROOTS_TREE_HEIGHT, \"BeaconChainProofs.verifyWithdrawalProofs: blockRootIndex is too large\");\n        require(proofs.withdrawalIndex < 2**WITHDRAWALS_TREE_HEIGHT, \"BeaconChainProofs.verifyWithdrawalProofs: withdrawalIndex is too large\");\n       \n        // verify the block header proof length\n        require(proofs.blockHeaderProof.length == 32 * (BEACON_STATE_FIELD_TREE_HEIGHT + BLOCK_ROOTS_TREE_HEIGHT),\n            \"BeaconChainProofs.verifyWithdrawalProofs: blockHeaderProof has incorrect length\");\n        require(proofs.withdrawalProof.length == 32 * (EXECUTION_PAYLOAD_HEADER_FIELD_TREE_HEIGHT + WITHDRAWALS_TREE_HEIGHT + 1),\n            \"BeaconChainProofs.verifyWithdrawalProofs: withdrawalProof has incorrect length\");\n        require(proofs.executionPayloadProof.length == 32 * (BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT + BEACON_BLOCK_BODY_FIELD_TREE_HEIGHT),\n            \"BeaconChainProofs.verifyWithdrawalProofs: executionPayloadProof has incorrect length\");\n\n        /**\n         * Computes the block_header_index relative to the beaconStateRoot.  It concatenates the indexes of all the\n         * intermediate root indexes from the bottom of the sub trees (the block header container) to the top of the tree\n         */\n        uint256 blockHeaderIndex = BLOCK_ROOTS_INDEX << (BLOCK_ROOTS_TREE_HEIGHT)  | uint256(proofs.blockHeaderRootIndex);\n        // Verify the blockHeaderRoot against the beaconStateRoot\n        require(Merkle.verifyInclusionSha256(proofs.blockHeaderProof, beaconStateRoot, proofs.blockHeaderRoot, blockHeaderIndex),\n            \"BeaconChainProofs.verifyWithdrawalProofs: Invalid block header merkle proof\");\n\n        //Next we verify the slot against the blockHeaderRoot\n        require(Merkle.verifyInclusionSha256(proofs.slotProof, proofs.blockHeaderRoot, proofs.slotRoot, SLOT_INDEX), \"BeaconChainProofs.verifyWithdrawalProofs: Invalid slot merkle proof\");\n\n        // Next we verify the executionPayloadRoot against the blockHeaderRoot\n        uint256 executionPayloadIndex = BODY_ROOT_INDEX << (BEACON_BLOCK_BODY_FIELD_TREE_HEIGHT)| EXECUTION_PAYLOAD_INDEX ;\n        require(Merkle.verifyInclusionSha256(proofs.executionPayloadProof, proofs.blockHeaderRoot, proofs.executionPayloadRoot, executionPayloadIndex),\n            \"BeaconChainProofs.verifyWithdrawalProofs: Invalid executionPayload merkle proof\");\n\n        // Next we verify the blockNumberRoot against the executionPayload root\n        require(Merkle.verifyInclusionSha256(proofs.blockNumberProof, proofs.executionPayloadRoot, proofs.blockNumberRoot, BLOCK_NUMBER_INDEX),\n            \"BeaconChainProofs.verifyWithdrawalProofs: Invalid blockNumber merkle proof\");\n\n        /**\n         * Next we verify the withdrawal fields against the blockHeaderRoot:\n         * First we compute the withdrawal_index relative to the blockHeaderRoot by concatenating the indexes of all the \n         * intermediate root indexes from the bottom of the sub trees (the withdrawal container) to the top, the blockHeaderRoot.\n         * Then we calculate merkleize the withdrawalFields container to calculate the the withdrawalRoot.\n         * Finally we verify the withdrawalRoot against the executionPayloadRoot.\n         */\n        uint256 withdrawalIndex = WITHDRAWALS_INDEX << (WITHDRAWALS_TREE_HEIGHT + 1) | uint256(proofs.withdrawalIndex);\n        bytes32 withdrawalRoot = Merkle.merkleizeSha256(withdrawalFields);\n        require(Merkle.verifyInclusionSha256(proofs.withdrawalProof, proofs.executionPayloadRoot, withdrawalRoot, withdrawalIndex),\n            \"BeaconChainProofs.verifyWithdrawalProofs: Invalid withdrawal merkle proof\");\n    }\n\n}"
    },
    {
      "filename": "src/contracts/core/DelegationManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin-upgrades/contracts/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin-upgrades/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"./DelegationManagerStorage.sol\";\nimport \"../permissions/Pausable.sol\";\nimport \"./Slasher.sol\";\n\n/**\n * @title The primary delegation contract for EigenLayer.\n * @author Layr Labs, Inc.\n * @notice  This is the contract for delegation in EigenLayer. The main functionalities of this contract are\n * - enabling anyone to register as an operator in EigenLayer\n * - allowing new operators to provide a DelegationTerms-type contract, which may mediate their interactions with stakers who delegate to them\n * - enabling any staker to delegate its stake to the operator of its choice\n * - enabling a staker to undelegate its assets from an operator (performed as part of the withdrawal process, initiated through the StrategyManager)\n */\ncontract DelegationManager is Initializable, OwnableUpgradeable, Pausable, DelegationManagerStorage {\n    // index for flag that pauses new delegations when set\n    uint8 internal constant PAUSED_NEW_DELEGATION = 0;\n    // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n    bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;\n\n    // chain id at the time of contract deployment\n    uint256 immutable ORIGINAL_CHAIN_ID;\n\n\n    /// @notice Simple permission for functions that are only callable by the StrategyManager contract.\n    modifier onlyStrategyManager() {\n        require(msg.sender == address(strategyManager), \"onlyStrategyManager\");\n        _;\n    }\n\n    // INITIALIZING FUNCTIONS\n    constructor(IStrategyManager _strategyManager, ISlasher _slasher) \n        DelegationManagerStorage(_strategyManager, _slasher)\n    {\n        _disableInitializers();\n        ORIGINAL_CHAIN_ID = block.chainid;\n    }\n\n    /// @dev Emitted when a low-level call to `delegationTerms.onDelegationReceived` fails, returning `returnData`\n    event OnDelegationReceivedCallFailure(IDelegationTerms indexed delegationTerms, bytes32 returnData);\n\n    /// @dev Emitted when a low-level call to `delegationTerms.onDelegationWithdrawn` fails, returning `returnData`\n    event OnDelegationWithdrawnCallFailure(IDelegationTerms indexed delegationTerms, bytes32 returnData);\n\n    function initialize(address initialOwner, IPauserRegistry _pauserRegistry, uint256 initialPausedStatus)\n        external\n        initializer\n    {\n        _initializePauser(_pauserRegistry, initialPausedStatus);\n        DOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\"EigenLayer\")), ORIGINAL_CHAIN_ID, address(this)));\n        _transferOwnership(initialOwner);\n    }\n\n    // EXTERNAL FUNCTIONS\n    /**\n     * @notice This will be called by an operator to register itself as an operator that stakers can choose to delegate to.\n     * @param dt is the `DelegationTerms` contract that the operator has for those who delegate to them.\n     * @dev An operator can set `dt` equal to their own address (or another EOA address), in the event that they want to split payments\n     * in a more 'trustful' manner.\n     * @dev In the present design, once set, there is no way for an operator to ever modify the address of their DelegationTerms contract.\n     */\n    function registerAsOperator(IDelegationTerms dt) external {\n        require(\n            address(delegationTerms[msg.sender]) == address(0),\n            \"DelegationManager.registerAsOperator: operator has already registered\"\n        );\n        // store the address of the delegation contract that the operator is providing.\n        delegationTerms[msg.sender] = dt;\n        _delegate(msg.sender, msg.sender);\n    }\n\n    /**\n     *  @notice This will be called by a staker to delegate its assets to some operator.\n     *  @param operator is the operator to whom staker (msg.sender) is delegating its assets\n     */\n    function delegateTo(address operator) external {\n        _delegate(msg.sender, operator);\n    }\n\n    /**\n     * @notice Delegates from `staker` to `operator`.\n     * @dev requires that:\n     * 1) if `staker` is an EOA, then `signature` is valid ECSDA signature from `staker`, indicating their intention for this action\n     * 2) if `staker` is a contract, then `signature` must will be checked according to EIP-1271\n     */\n    function delegateToBySignature(address staker, address operator, uint256 expiry, bytes memory signature)\n        external\n    {\n        require(expiry >= block.timestamp, \"DelegationManager.delegateToBySignature: delegation signature expired\");\n\n        // calculate struct hash, then increment `staker`'s nonce\n        uint256 nonce = nonces[staker];\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, staker, operator, nonce, expiry));\n        unchecked {\n            nonces[staker] = nonce + 1;\n        }\n\n        bytes32 digestHash;\n        if (block.chainid != ORIGINAL_CHAIN_ID) {\n            bytes32 domain_separator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\"EigenLayer\")), block.chainid, address(this)));\n            digestHash = keccak256(abi.encodePacked(\"\\x19\\x01\", domain_separator, structHash));\n        } else{\n            digestHash = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, structHash));\n        }\n\n        /**\n         * check validity of signature:\n         * 1) if `staker` is an EOA, then `signature` must be a valid ECSDA signature from `staker`,\n         * indicating their intention for this action\n         * 2) if `staker` is a contract, then `signature` must will be checked according to EIP-1271\n         */\n        if (Address.isContract(staker)) {\n            require(IERC1271(staker).isValidSignature(digestHash, signature) == ERC1271_MAGICVALUE,\n                \"DelegationManager.delegateToBySignature: ERC1271 signature verification failed\");\n        } else {\n            require(ECDSA.recover(digestHash, signature) == staker,\n                \"DelegationManager.delegateToBySignature: sig not from staker\");\n        }\n\n        _delegate(staker, operator);\n    }\n\n    /**\n     * @notice Undelegates `staker` from the operator who they are delegated to.\n     * @notice Callable only by the StrategyManager\n     * @dev Should only ever be called in the event that the `staker` has no active deposits in EigenLayer.\n     */\n    function undelegate(address staker) external onlyStrategyManager {\n        require(!isOperator(staker), \"DelegationManager.undelegate: operators cannot undelegate from themselves\");\n        delegatedTo[staker] = address(0);\n    }\n\n    /**\n     * @notice Increases the `staker`'s delegated shares in `strategy` by `shares, typically called when the staker has further deposits into EigenLayer\n     * @dev Callable only by the StrategyManager\n     */\n    function increaseDelegatedShares(address staker, IStrategy strategy, uint256 shares)\n        external\n        onlyStrategyManager\n    {\n        //if the staker is delegated to an operator\n        if (isDelegated(staker)) {\n            address operator = delegatedTo[staker];\n\n            // add strategy shares to delegate's shares\n            operatorShares[operator][strategy] += shares;\n\n            //Calls into operator's delegationTerms contract to update weights of individual staker\n            IStrategy[] memory stakerStrategyList = new IStrategy[](1);\n            uint256[] memory stakerShares = new uint[](1);\n            stakerStrategyList[0] = strategy;\n            stakerShares[0] = shares;\n\n            // call into hook in delegationTerms contract\n            IDelegationTerms dt = delegationTerms[operator];\n            _delegationReceivedHook(dt, staker, stakerStrategyList, stakerShares);\n        }\n    }\n\n    /**\n     * @notice Decreases the `staker`'s delegated shares in each entry of `strategies` by its respective `shares[i]`, typically called when the staker withdraws from EigenLayer\n     * @dev Callable only by the StrategyManager\n     */\n    function decreaseDelegatedShares(\n        address staker,\n        IStrategy[] calldata strategies,\n        uint256[] calldata shares\n    )\n        external\n        onlyStrategyManager\n    {\n        if (isDelegated(staker)) {\n            address operator = delegatedTo[staker];\n\n            // subtract strategy shares from delegate's shares\n            uint256 stratsLength = strategies.length;\n            for (uint256 i = 0; i < stratsLength;) {\n                operatorShares[operator][strategies[i]] -= shares[i];\n                unchecked {\n                    ++i;\n                }\n            }\n\n            // call into hook in delegationTerms contract\n            IDelegationTerms dt = delegationTerms[operator];\n            _delegationWithdrawnHook(dt, staker, strategies, shares);\n        }\n    }\n\n    // INTERNAL FUNCTIONS\n\n    /** \n     * @notice Makes a low-level call to `dt.onDelegationReceived(staker, strategies, shares)`, ignoring reverts and with a gas budget \n     * equal to `LOW_LEVEL_GAS_BUDGET` (a constant defined in this contract).\n     * @dev *If* the low-level call fails, then this function emits the event `OnDelegationReceivedCallFailure(dt, returnData)`, where\n     * `returnData` is *only the first 32 bytes* returned by the call to `dt`.\n     */\n    function _delegationReceivedHook(\n        IDelegationTerms dt,\n        address staker,\n        IStrategy[] memory strategies,\n        uint256[] memory shares\n    )\n        internal\n    {\n        /**\n         * We use low-level call functionality here to ensure that an operator cannot maliciously make this function fail in order to prevent undelegation.\n         * In particular, in-line assembly is also used to prevent the copying of uncapped return data which is also a potential DoS vector.\n         */\n        // format calldata\n        bytes memory lowLevelCalldata = abi.encodeWithSelector(IDelegationTerms.onDelegationReceived.selector, staker, strategies, shares);\n        // Prepare memory for low-level call return data. We accept a max return data length of 32 bytes\n        bool success;\n        bytes32[1] memory returnData;\n        // actually make the call\n        assembly {\n            success := call(\n                // gas provided to this context\n                LOW_LEVEL_GAS_BUDGET,\n                // address to call\n                dt,\n                // value in wei for call\n                0,\n                // memory location to copy for calldata\n                add(lowLevelCalldata, 32"
    }
  ]
}