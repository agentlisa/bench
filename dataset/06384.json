{
  "Title": "[G-08] Refactor functions to avoid excessive storage reads",
  "Content": "The functions below read storage slots that are previously read in the functions that invoke them. We can refactor the functions so we could pass cached storage variables as stack variables and avoid the extra storage reads that would otherwise take place in the public/internal functions.\n\nTotal Instances: `4`\n\nEstimated Gas Saved: `900`\n\n<details>\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/EUSDMiningIncentives.sol#L72-L74\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/EUSDMiningIncentives.sol#L163-L168\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/EUSDMiningIncentives.sol#L159-L161\n\n### Cache return value from `lastTimRewardApplicable()` and pass it into `rewardPerToken` to save 1 SLOAD\n```solidity\nFile: contracts/lybra/miner/EUSDMiningIncentives.sol\n72:    modifier updateReward(address _account) {\n73:        rewardPerTokenStored = rewardPerToken(); // @audit: invokes `lastTimeRewardApplicable()`, which reads `finishAt`\n74:        updatedAt = lastTimeRewardApplicable(); // @audit: 2nd sload for `finishAt`\n\n159:    function lastTimeRewardApplicable() public view returns (uint256) {\n160:        return _min(finishAt, block.timestamp); // @audit: sload for `finishAt`\n161:    }\n\n163:    function rewardPerToken() public view returns (uint256) {\n164:        if (totalStaked() == 0) {\n165:            return rewardPerTokenStored;\n166:        }\n167:\n168:        return rewardPerTokenStored + (rewardRatio * (lastTimeRewardApplicable() - updatedAt) * 1e18) / totalStaked(); // @audit: sload for `finishAt`\n```\n```diff\ndiff --git a/lybra/miner/EUSDMiningIncentives.sol b/lybra/miner/EUSDMiningIncentives.sol\nindex e6c57c8..fe5160f 100644\n--- a/lybra/miner/EUSDMiningIncentives.sol\n+++ b/lybra/miner/EUSDMiningIncentives.sol\n@@ -70,8 +70,9 @@ contract EUSDMiningIncentives is Ownable {\n     }\n\n     modifier updateReward(address _account) {\n-        rewardPerTokenStored = rewardPerToken();\n-        updatedAt = lastTimeRewardApplicable();\n+        uint256 _updatedAt = lastTimeRewardApplicable();\n+        updatedAt = _updatedAt;\n+        rewardPerTokenStored = _rewardPerToken(_updatedAt);\n\n         if (_account != address(0)) {\n             rewards[_account] = earned(_account);\n@@ -161,11 +162,15 @@ contract EUSDMiningIncentives is Ownable {\n     }\n\n     function rewardPerToken() public view returns (uint256) {\n+        return _rewardPerToken(lastTimeRewardApplicable());\n+    }\n+\n+    function _rewardPerToken(uint256 _updatedAt) internal view returns (uint256) {\n         if (totalStaked() == 0) {\n             return rewardPerTokenStored;\n         }\n\n-        return rewardPerTokenStored + (rewardRatio * (lastTimeRewardApplicable() - updatedAt) * 1e18) / totalStaked();\n+        return rewardPerTokenStored + (rewardRatio * (_updatedAt - updatedAt) * 1e18) / totalStaked();\n     }\n```\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/EUSDMiningIncentives.sol#L72-L77\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/EUSDMiningIncentives.sol#L184-L186\n\n### Cache return value from `rewardPerToken()` and pass it into `earned` to save 2 External Calls (~200 gas) and 2 SLOADs\n```solidity\nFile: contracts/lybra/miner/EUSDMiningIncentives.sol\n72:    modifier updateReward(address _account) {\n73:        rewardPerTokenStored = rewardPerToken(); // @audit: function performs two function calls (via `totalStaked()`) and 2 SLOADs for state variables that stay the same (i.e. `rewardRatio` and `finishAt`)\n74:        updatedAt = lastTimeRewardApplicable();\n75:\n76:        if (_account != address(0)) {\n77:            rewards[_account] = earned(_account); // @audit: function invokes `rewardPerToken()` again incurring the same costs as above for a second time\n\n184:    function earned(address _account) public view returns (uint256) {\n185:        return ((stakedOf(_account) * getBoost(_account) * (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e38) + rewards[_account]; // @audit: performs same two function calls and 2 SLOADs as mentioned above\n186:    }\n```\n```diff\ndiff --git a/lybra/miner/EUSDMiningIncentives.sol b/lybra/miner/EUSDMiningIncentives.sol\nindex e6c57c8..fb7624e 100644\n--- a/lybra/miner/EUSDMiningIncentives.sol\n+++ b/lybra/miner/EUSDMiningIncentives.sol\n@@ -70,11 +70,12 @@ contract EUSDMiningIncentives is Ownable {\n     }\n\n     modifier updateReward(address _account) {\n-        rewardPerTokenStored = rewardPerToken();\n+        uint256 _rewardPerTokenStored = rewardPerToken();\n+        rewardPerTokenStored = _rewardPerTokenStored;\n         updatedAt = lastTimeRewardApplicable();\n\n         if (_account != address(0)) {\n-            rewards[_account] = earned(_account);\n+            rewards[_account] = _earned(_rewardPerTokenStored, _account);\n             userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n             userUpdatedAt[_account] = block.timestamp;\n         }\n@@ -182,7 +183,11 @@ contract EUSDMiningIncentives is Ownable {\n     }\n\n     function earned(address _account) public view returns (uint256) {\n-        return ((stakedOf(_account) * getBoost(_account) * (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e38) + rewards[_account];\n+        return _earned(rewardPerToken(), _account);\n+    }\n+\n+    function _earned(uint256 _rewardPerTokenStored, address _account) internal view returns (uint256) {\n+        return ((stakedOf(_account) * getBoost(_account) * (_rewardPerTokenStored - userRewardPerTokenPaid[_account])) / 1e38) + rewards[_account];\n     }\n```\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/token/EUSD.sol#L414-L425\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/token/EUSD.sol#L299-L306\n\n### Cache `_totalSupply` and `_totalShares` and pass cached values into `getSharesByMintedEUSD` to save 2 SLOADs\n```solidity\nFile: contracts/lybra/token/EUSD.sol\n299:    function getSharesByMintedEUSD(uint256 _EUSDAmount) public view returns (uint256) {\n300:        uint256 totalMintedEUSD = _totalSupply; // @audit: 1st sload\n301:        if (totalMintedEUSD == 0) {\n302:            return 0;\n303:        } else {\n304:            return _EUSDAmount.mul(_totalShares).div(totalMintedEUSD); // @audit: 1st sload\n305:        }\n306:    }\n\n414:        uint256 sharesAmount = getSharesByMintedEUSD(_mintAmount); // @audit: reads `_totalShares` and `_totalSupply`\n415:        if (sharesAmount == 0) {\n416:            //EUSD totalSupply is 0: assume that shares correspond to EUSD 1-to-1\n417:            sharesAmount = _mintAmount;\n418:        }\n419:\n420:        newTotalShares = _totalShares.add(sharesAmount); // @audit: 2nd sload\n421:        _totalShares = newTotalShares;\n422:\n423:        shares[_recipient] = shares[_recipient].add(sharesAmount);\n424:\n425:        _totalSupply += _mintAmount; // @audit: 2nd sload\n\n```\n```diff\ndiff --git a/lybra/token/EUSD.sol b/lybra/token/EUSD.sol\nindex cca5cee..58f8f6f 100644\n--- a/lybra/token/EUSD.sol\n+++ b/lybra/token/EUSD.sol\n@@ -297,11 +297,14 @@ contract EUSD is IERC20, Context {\n      * @return the amount of shares that corresponds to `_EUSDAmount` protocol-supplied EUSD.\n      */\n     function getSharesByMintedEUSD(uint256 _EUSDAmount) public view returns (uint256) {\n-        uint256 totalMintedEUSD = _totalSupply;\n-        if (totalMintedEUSD == 0) {\n+        return _getSharesByMintedEUSD(_totalSupply, _totalShares, _EUSDAmount);\n+    }\n+\n+    function _getSharesByMintedEUSD(uint256 _cachedTotalySupply, uint256 _cachedTotalShares, uint256 _EUSDAmount) internal view returns (uint256) {\n+        if (_cachedTotalySupply == 0) {\n             return 0;\n-        } else {\n-            return _EUSDAmount.mul(_totalShares).div(totalMintedEUSD);\n+            } else {\n+            return _EUSDAmount.mul(_cachedTotalShares).div(_cachedTotalySupply);\n         }\n     }\n\n@@ -410,19 +413,21 @@ contract EUSD is IERC20, Context {\n      */\n     function mint(address _recipient, uint256 _mintAmount) external onlyMintVault MintPaused returns (uint256 newTotalShares) {\n         require(_recipient != address(0), \"MINT_TO_THE_ZERO_ADDRESS\");\n-\n-        uint256 sharesAmount = getSharesByMintedEUSD(_mintAmount);\n+\n+        uint256 _cachedTotalySupply = _totalSupply;\n+        uint256 _cachedTotalShares = _totalShares;\n+        uint256 sharesAmount = _getSharesByMintedEUSD(_cachedTotalySupply, _cachedTotalShares, _mintAmount);\n         if (sharesAmount == 0) {\n             //EUSD totalSupply is 0: assume that shares correspond to EUSD 1-to-1\n             sharesAmount = _mintAmount;\n         }\n\n-        newTotalShares = _totalShares.add(sharesAmount);\n+        newTotalShares = _cachedTotalShares.add(sharesAmount);\n         _totalShares = newTotalShares;\n\n         shares[_recipient] = shares[_recipient].add(sharesAmount);\n\n-        _totalSupply += _mintAmount;\n+        _totalSupply = _cachedTotalySupply + _mintAmount;\n\n         emit Transfer(address(0), _recipient, _mintAmount);\n     }\n```\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/ProtocolRewardsPool.sol#L141-L142\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/ProtocolRewardsPool.sol#L161-L165\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/ProtocolRewardsPool.sol#L155-L159\n\n### Cache `time2FullRedemption[msg.sender]` and pass the cached value into `getReservedLBRForVesting` and `getClaimAbleLBR` to save 2 SLOADs\n```solidity\nFile: contracts/lybra/miner/ProtocolRewardsPool.sol\n141:    function reStake() external {\n142:        uint256 amount = getReservedLBRForVesting(msg.sender) + getClaimAbleLBR(msg.sender);\n\n155:    function getClaimAbleLBR(address user) public view returns (uint256 amount) {\n156:        if (time2fullRedemption[user] > lastWithdrawTime[user]) {\n157:            amount = block.timestamp > time2fullRedemption[user] ? unstakeRatio[user] * (time2fullRedemption[user] - lastWithdrawTime[user]) : unstakeRatio[user] * (block.timestamp - lastWithdrawTime[user]);\n158:        }\n159:    }\n\n161:    function getReservedLBRForVesting(address user) public view returns (uint256 amount) {\n162:        if (time2fullRedemption[user] > block.timestamp) { // @audit: 1st sload\n163:            amount = unstakeRatio[user] * (time2fullRedemption[user] - block.timestamp); // @audit: potential 2nd sload\n164:        }\n165:    }\n```\n```diff\ndiff --git a/lybra/miner/ProtocolRewardsPool.sol b/lybra/miner/ProtocolRewardsPool.sol\nindex 8fc83d6..14b139e 100644\n--- a/lybra/miner/ProtocolRewardsPool.sol\n+++ b/lybra/miner/ProtocolRewardsPool.sol\n@@ -139,7 +139,8 @@ contract ProtocolRewardsPool is Ownable {\n      * @dev Convert unredeemed and converting ESLBR tokens back to LBR.\n      */\n     function reStake() external {\n-        uint256 amount = getReservedLBRForVesting(msg.sender) + getClaimAbleLBR(msg.sender);\n+        uint256 _time2fullRedemption = time2fullRedemption[msg.sender];\n+        uint256 amount = _getReservedLBRForVesting(_time2fullRedemption, msg.sender) + _getClaimAbleLBR(_time2fullRedemption, msg.sender);\n         esLBR.mint(msg.sender, amount);\n         unstakeRatio[msg.sender] = 0;\n         time2fullRedemption[msg.sender] = 0;\n@@ -152,15 +153,23 @@ contract ProtocolRewardsPool is Ownable {\n         amount = (a * (75e18 - ((time2fullRedemption[user] - block.timestamp) * 70e18) / (exitCycle / 1 days - 3) / 1 days)) / 100e18;\n     }\n\n-    function getClaimAbleLBR(address user) public view returns (uint256 amount) {\n-        if (time2fullRedemption[user] > lastWithdrawTime[user]) {\n-            amount = block.timestamp > time2fullRedemption[user] ? unstakeRatio[user] * (time2fullRedemption[user] - lastWithdrawTime[user]) : unstakeRatio[user] * (block.timestamp - lastWithdrawTime[user]);\n+    function getClaimAbleLBR(address user) public view returns (uint256) {\n+        return _getClaimAbleLBR(time2fullRedemption[user], user);\n+    }\n+\n+    function _getClaimAbleLBR(uint256 _time2fullRedemption, address user) internal view returns (uint256 amount) {\n+        if (_time2fullRedemption > lastWithdrawTime[user]) {\n+            amount = block.timestamp > _time2fullRedemption ? unstakeRatio[user] * (_time2fullRedemption - lastWithdrawTime[user]) : unstakeRatio[user] * (block.timestamp - lastWithdrawTime[user]);\n         }\n     }\n\n-    function getReservedLBRForVesting(address user) public view returns (uint256 amount) {\n-        if (time2fullRedemption[user] > block.timestamp) {\n-            amount = unstakeRatio[user] * (time2fullRedemption[user] - block.timestamp);\n+    function getReservedLBRForVesting(address user) public view returns (uint256) {\n+        return _getReservedLBRForVesting(time2fullRedemption[user], user);\n+    }\n+\n+    function _getReservedLBRForVesting(uint256 _time2fullRedemption, address user) internal view returns (uint256 amount) {\n+        if (_time2fullRedemption > block.timestamp) {\n+            amount = unstakeRatio[user] * (_time2fullRedemption - block.timestamp);\n         }\n     }\n```\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-06-lybra",
  "Code": [
    {
      "filename": "contracts/lybra/miner/EUSDMiningIncentives.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n/**\n * @title tokenMiner is a stripped down version of Synthetix StakingRewards.sol, to reward esLBR to EUSD minters.\n * Differences from the original contract,\n * - Get `totalStaked` from totalSupply() in contract EUSD.\n * - Get `stakedOf(user)` from getBorrowedOf(user) in contract EUSD.\n * - When an address borrowed EUSD amount changes, call the refreshReward method to update rewards to be claimed.\n */\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IesLBR.sol\";\nimport \"../interfaces/IEUSD.sol\";\nimport \"../interfaces/ILybra.sol\";\nimport \"../interfaces/Iconfigurator.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ninterface IesLBRBoost {\n    function getUserBoost(\n        address user,\n        uint256 userUpdatedAt,\n        uint256 finishAt\n    ) external view returns (uint256);\n}\n\ncontract EUSDMiningIncentives is Ownable {\n    Iconfigurator public immutable configurator;\n    IesLBRBoost public esLBRBoost;\n    IEUSD public immutable EUSD;\n    address public esLBR;\n    address public LBR;\n    address[] public pools;\n\n    // Duration of rewards to be paid out (in seconds)\n    uint256 public duration = 2_592_000;\n    // Timestamp of when the rewards finish\n    uint256 public finishAt;\n    // Minimum of last updated time and reward finish time\n    uint256 public updatedAt;\n    // Reward to be paid out per second\n    uint256 public rewardRatio;\n    // Sum of (reward ratio * dt * 1e18 / total supply)\n    uint256 public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) public userUpdatedAt;\n    uint256 public extraRatio = 50 * 1e18;\n    uint256 public peUSDExtraRatio = 10 * 1e18;\n    uint256 public biddingFeeRatio = 3000;\n    address public ethlbrStakePool;\n    address public ethlbrLpToken;\n    AggregatorV3Interface internal etherPriceFeed;\n    AggregatorV3Interface internal lbrPriceFeed;\n    bool public isEUSDBuyoutAllowed = true;\n\n    event ClaimReward(address indexed user, uint256 amount, uint256 time);\n    event ClaimedOtherEarnings(address indexed user, address indexed Victim, uint256 buyAmount, uint256 biddingFee, bool useEUSD, uint256 time);\n    event NotifyRewardChanged(uint256 addAmount, uint256 time);\n\n    //etherOracle = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\n    constructor(address _config, address _boost, address _etherOracle, address _lbrOracle) {\n        configurator = Iconfigurator(_config);\n        esLBRBoost = IesLBRBoost(_boost);\n        EUSD = IEUSD(configurator.getEUSDAddress());\n        etherPriceFeed = AggregatorV3Interface(_etherOracle);\n        lbrPriceFeed = AggregatorV3Interface(_lbrOracle);\n    }\n\n    modifier updateReward(address _account) {\n        rewardPerTokenStored = rewardPerToken();\n        updatedAt = lastTimeRewardApplicable();\n\n        if (_account != address(0)) {\n            rewards[_account] = earned(_account);\n            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n            userUpdatedAt[_account] = block.timestamp;\n        }\n        _;\n    }\n\n    function setToken(address _lbr, address _eslbr) external onlyOwner {\n        LBR = _lbr;\n        esLBR = _eslbr;\n    }\n\n    function setLBROracle(address _lbrOracle) external onlyOwner {\n        lbrPriceFeed = AggregatorV3Interface(_lbrOracle);\n    }\n\n    function setPools(address[] memory _pools) external onlyOwner {\n        for (uint i = 0; i < _pools.length; i++) {\n            require(configurator.mintVault(_pools[i]), \"NOT_VAULT\");\n        }\n        pools = _pools;\n    }\n\n    function setBiddingCost(uint256 _biddingRatio) external onlyOwner {\n        require(_biddingRatio <= 8000, \"BCE\");\n        biddingFeeRatio = _biddingRatio;\n    }\n\n    function setExtraRatio(uint256 ratio) external onlyOwner {\n        require(ratio <= 1e20, \"BCE\");\n        extraRatio = ratio;\n    }\n\n    function setPeUSDExtraRatio(uint256 ratio) external onlyOwner {\n        require(ratio <= 1e20, \"BCE\");\n        peUSDExtraRatio = ratio;\n    }\n\n    function setBoost(address _boost) external onlyOwner {\n        esLBRBoost = IesLBRBoost(_boost);\n    }\n\n    function setRewardsDuration(uint256 _duration) external onlyOwner {\n        require(finishAt < block.timestamp, \"reward duration not finished\");\n        duration = _duration;\n    }\n\n    function setEthlbrStakeInfo(address _pool, address _lp) external onlyOwner {\n        ethlbrStakePool = _pool;\n        ethlbrLpToken = _lp;\n    }\n    function setEUSDBuyoutAllowed(bool _bool) external onlyOwner {\n        isEUSDBuyoutAllowed = _bool;\n    }\n\n    function totalStaked() internal view returns (uint256) {\n        return EUSD.totalSupply();\n    }\n\n    function stakedOf(address user) public view returns (uint256) {\n        uint256 amount;\n        for (uint i = 0; i < pools.length; i++) {\n            ILybra pool = ILybra(pools[i]);\n            uint borrowed = pool.getBorrowedOf(user);\n            if (pool.getVaultType() == 1) {\n                borrowed = borrowed * (1e20 + peUSDExtraRatio) / 1e20;\n            }\n            amount += borrowed;\n        }\n        return amount;\n    }\n\n    function stakedLBRLpValue(address user) public view returns (uint256) {\n        uint256 totalLp = IEUSD(ethlbrLpToken).totalSupply();\n        (, int etherPrice, , , ) = etherPriceFeed.latestRoundData();\n        (, int lbrPrice, , , ) = lbrPriceFeed.latestRoundData();\n        uint256 etherInLp = (IEUSD(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).balanceOf(ethlbrLpToken) * uint(etherPrice)) / 1e8;\n        uint256 lbrInLp = (IEUSD(LBR).balanceOf(ethlbrLpToken) * uint(lbrPrice)) / 1e8;\n        uint256 userStaked = IEUSD(ethlbrStakePool).balanceOf(user);\n        return (userStaked * (lbrInLp + etherInLp)) / totalLp;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return _min(finishAt, block.timestamp);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalStaked() == 0) {\n            return rewardPerTokenStored;\n        }\n\n        return rewardPerTokenStored + (rewardRatio * (lastTimeRewardApplicable() - updatedAt) * 1e18) / totalStaked();\n    }\n\n    /**\n     * @notice Update user's claimable reward data and record the timestamp.\n     */\n    function refreshReward(address _account) external updateReward(_account) {}\n\n    function getBoost(address _account) public view returns (uint256) {\n        uint256 redemptionBoost;\n        if (configurator.isRedemptionProvider(_account)) {\n            redemptionBoost = extraRatio;\n        }\n        return 100 * 1e18 + redemptionBoost + esLBRBoost.getUserBoost(_account, userUpdatedAt[_account], finishAt);\n    }\n\n    function earned(address _account) public view returns (uint256) {\n        return ((stakedOf(_account) * getBoost(_account) * (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e38) + rewards[_account];\n    }\n\n    function isOtherEarningsClaimable(address user) public view returns (bool) {\n        return (stakedLBRLpValue(user) * 10000) / stakedOf(user) < 500;\n    }\n\n    function getReward() external updateReward(msg.sender) {\n        require(!isOtherEarningsClaimable(msg.sender), \"Insufficient DLP, unable to claim rewards\");\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            IesLBR(esLBR).mint(msg.sender, reward);\n            emit ClaimReward(msg.sender, reward, block.timestamp);\n        }\n    }\n\n    function purchaseOtherEarnings(address user, bool useEUSD) external updateReward(user) {\n        require(isOtherEarningsClaimable(user), \"The rewards of the user cannot be bought out\");\n        if(useEUSD) {\n            require(isEUSDBuyoutAllowed, \"The purchase using EUSD is not permitted.\");\n        }\n        uint256 reward = rewards[user];\n        if (reward > 0) {\n            rewards[user] = 0;\n            uint256 biddingFee = (reward * biddingFeeRatio) / 10000;\n            if(useEUSD) {\n                (, int lbrPrice, , , ) = lbrPriceFeed.latestRoundData();\n                biddingFee = biddingFee * uint256(lbrPrice) / 1e8;\n                bool success = EUSD.transferFrom(msg.sender, address(configurator), biddingFee);\n                require(success, \"TF\");\n                try configurator.distributeRewards() {} catch {}\n            } else {\n                IesLBR(LBR).burn(msg.sender, biddingFee);\n            }\n            IesLBR(esLBR).mint(msg.sender, reward);\n\n            emit ClaimedOtherEarnings(msg.sender, user, reward, biddingFee, useEUSD, block.timestamp);\n        }\n    }\n\n    function notifyRewardAmount(\n        uint256 amount\n    ) external onlyOwner updateReward(address(0)) {\n        require(amount > 0, \"amount = 0\");\n        if (block.timestamp >= finishAt) {\n            rewardRatio = amount / duration;\n        } else {\n            uint256 remainingRewards = (finishAt - block.timestamp) * rewardRatio;\n            rewardRatio = (amount + remainingRewards) / duration;\n        }\n\n        require(rewardRatio > 0, \"reward ratio = 0\");\n\n        finishAt = block.timestamp + duration;\n        updatedAt = block.timestamp;\n        emit NotifyRewardChanged(amount, block.timestamp);\n    }\n\n    function _min(uint256 x, uint256 y) private pure returns (uint256) {\n        return x <= y ? x : y;\n    }\n}"
    },
    {
      "filename": "contracts/lybra/miner/EUSDMiningIncentives.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n/**\n * @title tokenMiner is a stripped down version of Synthetix StakingRewards.sol, to reward esLBR to EUSD minters.\n * Differences from the original contract,\n * - Get `totalStaked` from totalSupply() in contract EUSD.\n * - Get `stakedOf(user)` from getBorrowedOf(user) in contract EUSD.\n * - When an address borrowed EUSD amount changes, call the refreshReward method to update rewards to be claimed.\n */\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IesLBR.sol\";\nimport \"../interfaces/IEUSD.sol\";\nimport \"../interfaces/ILybra.sol\";\nimport \"../interfaces/Iconfigurator.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ninterface IesLBRBoost {\n    function getUserBoost(\n        address user,\n        uint256 userUpdatedAt,\n        uint256 finishAt\n    ) external view returns (uint256);\n}\n\ncontract EUSDMiningIncentives is Ownable {\n    Iconfigurator public immutable configurator;\n    IesLBRBoost public esLBRBoost;\n    IEUSD public immutable EUSD;\n    address public esLBR;\n    address public LBR;\n    address[] public pools;\n\n    // Duration of rewards to be paid out (in seconds)\n    uint256 public duration = 2_592_000;\n    // Timestamp of when the rewards finish\n    uint256 public finishAt;\n    // Minimum of last updated time and reward finish time\n    uint256 public updatedAt;\n    // Reward to be paid out per second\n    uint256 public rewardRatio;\n    // Sum of (reward ratio * dt * 1e18 / total supply)\n    uint256 public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) public userUpdatedAt;\n    uint256 public extraRatio = 50 * 1e18;\n    uint256 public peUSDExtraRatio = 10 * 1e18;\n    uint256 public biddingFeeRatio = 3000;\n    address public ethlbrStakePool;\n    address public ethlbrLpToken;\n    AggregatorV3Interface internal etherPriceFeed;\n    AggregatorV3Interface internal lbrPriceFeed;\n    bool public isEUSDBuyoutAllowed = true;\n\n    event ClaimReward(address indexed user, uint256 amount, uint256 time);\n    event ClaimedOtherEarnings(address indexed user, address indexed Victim, uint256 buyAmount, uint256 biddingFee, bool useEUSD, uint256 time);\n    event NotifyRewardChanged(uint256 addAmount, uint256 time);\n\n    //etherOracle = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\n    constructor(address _config, address _boost, address _etherOracle, address _lbrOracle) {\n        configurator = Iconfigurator(_config);\n        esLBRBoost = IesLBRBoost(_boost);\n        EUSD = IEUSD(configurator.getEUSDAddress());\n        etherPriceFeed = AggregatorV3Interface(_etherOracle);\n        lbrPriceFeed = AggregatorV3Interface(_lbrOracle);\n    }\n\n    modifier updateReward(address _account) {\n        rewardPerTokenStored = rewardPerToken();\n        updatedAt = lastTimeRewardApplicable();\n\n        if (_account != address(0)) {\n            rewards[_account] = earned(_account);\n            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n            userUpdatedAt[_account] = block.timestamp;\n        }\n        _;\n    }\n\n    function setToken(address _lbr, address _eslbr) external onlyOwner {\n        LBR = _lbr;\n        esLBR = _eslbr;\n    }\n\n    function setLBROracle(address _lbrOracle) external onlyOwner {\n        lbrPriceFeed = AggregatorV3Interface(_lbrOracle);\n    }\n\n    function setPools(address[] memory _pools) external onlyOwner {\n        for (uint i = 0; i < _pools.length; i++) {\n            require(configurator.mintVault(_pools[i]), \"NOT_VAULT\");\n        }\n        pools = _pools;\n    }\n\n    function setBiddingCost(uint256 _biddingRatio) external onlyOwner {\n        require(_biddingRatio <= 8000, \"BCE\");\n        biddingFeeRatio = _biddingRatio;\n    }\n\n    function setExtraRatio(uint256 ratio) external onlyOwner {\n        require(ratio <= 1e20, \"BCE\");\n        extraRatio = ratio;\n    }\n\n    function setPeUSDExtraRatio(uint256 ratio) external onlyOwner {\n        require(ratio <= 1e20, \"BCE\");\n        peUSDExtraRatio = ratio;\n    }\n\n    function setBoost(address _boost) external onlyOwner {\n        esLBRBoost = IesLBRBoost(_boost);\n    }\n\n    function setRewardsDuration(uint256 _duration) external onlyOwner {\n        require(finishAt < block.timestamp, \"reward duration not finished\");\n        duration = _duration;\n    }\n\n    function setEthlbrStakeInfo(address _pool, address _lp) external onlyOwner {\n        ethlbrStakePool = _pool;\n        ethlbrLpToken = _lp;\n    }\n    function setEUSDBuyoutAllowed(bool _bool) external onlyOwner {\n        isEUSDBuyoutAllowed = _bool;\n    }\n\n    function totalStaked() internal view returns (uint256) {\n        return EUSD.totalSupply();\n    }\n\n    function stakedOf(address user) public view returns (uint256) {\n        uint256 amount;\n        for (uint i = 0; i < pools.length; i++) {\n            ILybra pool = ILybra(pools[i]);\n            uint borrowed = pool.getBorrowedOf(user);\n            if (pool.getVaultType() == 1) {\n                borrowed = borrowed * (1e20 + peUSDExtraRatio) / 1e20;\n            }\n            amount += borrowed;\n        }\n        return amount;\n    }\n\n    function stakedLBRLpValue(address user) public view returns (uint256) {\n        uint256 totalLp = IEUSD(ethlbrLpToken).totalSupply();\n        (, int etherPrice, , , ) = etherPriceFeed.latestRoundData();\n        (, int lbrPrice, , , ) = lbrPriceFeed.latestRoundData();\n        uint256 etherInLp = (IEUSD(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).balanceOf(ethlbrLpToken) * uint(etherPrice)) / 1e8;\n        uint256 lbrInLp = (IEUSD(LBR).balanceOf(ethlbrLpToken) * uint(lbrPrice)) / 1e8;\n        uint256 userStaked = IEUSD(ethlbrStakePool).balanceOf(user);\n        return (userStaked * (lbrInLp + etherInLp)) / totalLp;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return _min(finishAt, block.timestamp);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalStaked() == 0) {\n            return rewardPerTokenStored;\n        }\n\n        return rewardPerTokenStored + (rewardRatio * (lastTimeRewardApplicable() - updatedAt) * 1e18) / totalStaked();\n    }\n\n    /**\n     * @notice Update user's claimable reward data and record the timestamp.\n     */\n    function refreshReward(address _account) external updateReward(_account) {}\n\n    function getBoost(address _account) public view returns (uint256) {\n        uint256 redemptionBoost;\n        if (configurator.isRedemptionProvider(_account)) {\n            redemptionBoost = extraRatio;\n        }\n        return 100 * 1e18 + redemptionBoost + esLBRBoost.getUserBoost(_account, userUpdatedAt[_account], finishAt);\n    }\n\n    function earned(address _account) public view returns (uint256) {\n        return ((stakedOf(_account) * getBoost(_account) * (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e38) + rewards[_account];\n    }\n\n    function isOtherEarningsClaimable(address user) public view returns (bool) {\n        return (stakedLBRLpValue(user) * 10000) / stakedOf(user) < 500;\n    }\n\n    function getReward() external updateReward(msg.sender) {\n        require(!isOtherEarningsClaimable(msg.sender), \"Insufficient DLP, unable to claim rewards\");\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            IesLBR(esLBR).mint(msg.sender, reward);\n            emit ClaimReward(msg.sender, reward, block.timestamp);\n        }\n    }\n\n    function purchaseOtherEarnings(address user, bool useEUSD) external updateReward(user) {\n        require(isOtherEarningsClaimable(user), \"The rewards of the user cannot be bought out\");\n        if(useEUSD) {\n            require(isEUSDBuyoutAllowed, \"The purchase using EUSD is not permitted.\");\n        }\n        uint256 reward = rewards[user];\n        if (reward > 0) {\n            rewards[user] = 0;\n            uint256 biddingFee = (reward * biddingFeeRatio) / 10000;\n            if(useEUSD) {\n                (, int lbrPrice, , , ) = lbrPriceFeed.latestRoundData();\n                biddingFee = biddingFee * uint256(lbrPrice) / 1e8;\n                bool success = EUSD.transferFrom(msg.sender, address(configurator), biddingFee);\n                require(success, \"TF\");\n                try configurator.distributeRewards() {} catch {}\n            } else {\n                IesLBR(LBR).burn(msg.sender, biddingFee);\n            }\n            IesLBR(esLBR).mint(msg.sender, reward);\n\n            emit ClaimedOtherEarnings(msg.sender, user, reward, biddingFee, useEUSD, block.timestamp);\n        }\n    }\n\n    function notifyRewardAmount(\n        uint256 amount\n    ) external onlyOwner updateReward(address(0)) {\n        require(amount > 0, \"amount = 0\");\n        if (block.timestamp >= finishAt) {\n            rewardRatio = amount / duration;\n        } else {\n            uint256 remainingRewards = (finishAt - block.timestamp) * rewardRatio;\n            rewardRatio = (amount + remainingRewards) / duration;\n        }\n\n        require(rewardRatio > 0, \"reward ratio = 0\");\n\n        finishAt = block.timestamp + duration;\n        updatedAt = block.timestamp;\n        emit NotifyRewardChanged(amount, block.timestamp);\n    }\n\n    function _min(uint256 x, uint256 y) private pure returns (uint256) {\n        return x <= y ? x : y;\n    }\n}"
    },
    {
      "filename": "contracts/lybra/miner/EUSDMiningIncentives.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n/**\n * @title tokenMiner is a stripped down version of Synthetix StakingRewards.sol, to reward esLBR to EUSD minters.\n * Differences from the original contract,\n * - Get `totalStaked` from totalSupply() in contract EUSD.\n * - Get `stakedOf(user)` from getBorrowedOf(user) in contract EUSD.\n * - When an address borrowed EUSD amount changes, call the refreshReward method to update rewards to be claimed.\n */\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IesLBR.sol\";\nimport \"../interfaces/IEUSD.sol\";\nimport \"../interfaces/ILybra.sol\";\nimport \"../interfaces/Iconfigurator.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ninterface IesLBRBoost {\n    function getUserBoost(\n        address user,\n        uint256 userUpdatedAt,\n        uint256 finishAt\n    ) external view returns (uint256);\n}\n\ncontract EUSDMiningIncentives is Ownable {\n    Iconfigurator public immutable configurator;\n    IesLBRBoost public esLBRBoost;\n    IEUSD public immutable EUSD;\n    address public esLBR;\n    address public LBR;\n    address[] public pools;\n\n    // Duration of rewards to be paid out (in seconds)\n    uint256 public duration = 2_592_000;\n    // Timestamp of when the rewards finish\n    uint256 public finishAt;\n    // Minimum of last updated time and reward finish time\n    uint256 public updatedAt;\n    // Reward to be paid out per second\n    uint256 public rewardRatio;\n    // Sum of (reward ratio * dt * 1e18 / total supply)\n    uint256 public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) public userUpdatedAt;\n    uint256 public extraRatio = 50 * 1e18;\n    uint256 public peUSDExtraRatio = 10 * 1e18;\n    uint256 public biddingFeeRatio = 3000;\n    address public ethlbrStakePool;\n    address public ethlbrLpToken;\n    AggregatorV3Interface internal etherPriceFeed;\n    AggregatorV3Interface internal lbrPriceFeed;\n    bool public isEUSDBuyoutAllowed = true;\n\n    event ClaimReward(address indexed user, uint256 amount, uint256 time);\n    event ClaimedOtherEarnings(address indexed user, address indexed Victim, uint256 buyAmount, uint256 biddingFee, bool useEUSD, uint256 time);\n    event NotifyRewardChanged(uint256 addAmount, uint256 time);\n\n    //etherOracle = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\n    constructor(address _config, address _boost, address _etherOracle, address _lbrOracle) {\n        configurator = Iconfigurator(_config);\n        esLBRBoost = IesLBRBoost(_boost);\n        EUSD = IEUSD(configurator.getEUSDAddress());\n        etherPriceFeed = AggregatorV3Interface(_etherOracle);\n        lbrPriceFeed = AggregatorV3Interface(_lbrOracle);\n    }\n\n    modifier updateReward(address _account) {\n        rewardPerTokenStored = rewardPerToken();\n        updatedAt = lastTimeRewardApplicable();\n\n        if (_account != address(0)) {\n            rewards[_account] = earned(_account);\n            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n            userUpdatedAt[_account] = block.timestamp;\n        }\n        _;\n    }\n\n    function setToken(address _lbr, address _eslbr) external onlyOwner {\n        LBR = _lbr;\n        esLBR = _eslbr;\n    }\n\n    function setLBROracle(address _lbrOracle) external onlyOwner {\n        lbrPriceFeed = AggregatorV3Interface(_lbrOracle);\n    }\n\n    function setPools(address[] memory _pools) external onlyOwner {\n        for (uint i = 0; i < _pools.length; i++) {\n            require(configurator.mintVault(_pools[i]), \"NOT_VAULT\");\n        }\n        pools = _pools;\n    }\n\n    function setBiddingCost(uint256 _biddingRatio) external onlyOwner {\n        require(_biddingRatio <= 8000, \"BCE\");\n        biddingFeeRatio = _biddingRatio;\n    }\n\n    function setExtraRatio(uint256 ratio) external onlyOwner {\n        require(ratio <= 1e20, \"BCE\");\n        extraRatio = ratio;\n    }\n\n    function setPeUSDExtraRatio(uint256 ratio) external onlyOwner {\n        require(ratio <= 1e20, \"BCE\");\n        peUSDExtraRatio = ratio;\n    }\n\n    function setBoost(address _boost) external onlyOwner {\n        esLBRBoost = IesLBRBoost(_boost);\n    }\n\n    function setRewardsDuration(uint256 _duration) external onlyOwner {\n        require(finishAt < block.timestamp, \"reward duration not finished\");\n        duration = _duration;\n    }\n\n    function setEthlbrStakeInfo(address _pool, address _lp) external onlyOwner {\n        ethlbrStakePool = _pool;\n        ethlbrLpToken = _lp;\n    }\n    function setEUSDBuyoutAllowed(bool _bool) external onlyOwner {\n        isEUSDBuyoutAllowed = _bool;\n    }\n\n    function totalStaked() internal view returns (uint256) {\n        return EUSD.totalSupply();\n    }\n\n    function stakedOf(address user) public view returns (uint256) {\n        uint256 amount;\n        for (uint i = 0; i < pools.length; i++) {\n            ILybra pool = ILybra(pools[i]);\n            uint borrowed = pool.getBorrowedOf(user);\n            if (pool.getVaultType() == 1) {\n                borrowed = borrowed * (1e20 + peUSDExtraRatio) / 1e20;\n            }\n            amount += borrowed;\n        }\n        return amount;\n    }\n\n    function stakedLBRLpValue(address user) public view returns (uint256) {\n        uint256 totalLp = IEUSD(ethlbrLpToken).totalSupply();\n        (, int etherPrice, , , ) = etherPriceFeed.latestRoundData();\n        (, int lbrPrice, , , ) = lbrPriceFeed.latestRoundData();\n        uint256 etherInLp = (IEUSD(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).balanceOf(ethlbrLpToken) * uint(etherPrice)) / 1e8;\n        uint256 lbrInLp = (IEUSD(LBR).balanceOf(ethlbrLpToken) * uint(lbrPrice)) / 1e8;\n        uint256 userStaked = IEUSD(ethlbrStakePool).balanceOf(user);\n        return (userStaked * (lbrInLp + etherInLp)) / totalLp;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return _min(finishAt, block.timestamp);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalStaked() == 0) {\n            return rewardPerTokenStored;\n        }\n\n        return rewardPerTokenStored + (rewardRatio * (lastTimeRewardApplicable() - updatedAt) * 1e18) / totalStaked();\n    }\n\n    /**\n     * @notice Update user's claimable reward data and record the timestamp.\n     */\n    function refreshReward(address _account) external updateReward(_account) {}\n\n    function getBoost(address _account) public view returns (uint256) {\n        uint256 redemptionBoost;\n        if (configurator.isRedemptionProvider(_account)) {\n            redemptionBoost = extraRatio;\n        }\n        return 100 * 1e18 + redemptionBoost + esLBRBoost.getUserBoost(_account, userUpdatedAt[_account], finishAt);\n    }\n\n    function earned(address _account) public view returns (uint256) {\n        return ((stakedOf(_account) * getBoost(_account) * (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e38) + rewards[_account];\n    }\n\n    function isOtherEarningsClaimable(address user) public view returns (bool) {\n        return (stakedLBRLpValue(user) * 10000) / stakedOf(user) < 500;\n    }\n\n    function getReward() external updateReward(msg.sender) {\n        require(!isOtherEarningsClaimable(msg.sender), \"Insufficient DLP, unable to claim rewards\");\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            IesLBR(esLBR).mint(msg.sender, reward);\n            emit ClaimReward(msg.sender, reward, block.timestamp);\n        }\n    }\n\n    function purchaseOtherEarnings(address user, bool useEUSD) external updateReward(user) {\n        require(isOtherEarningsClaimable(user), \"The rewards of the user cannot be bought out\");\n        if(useEUSD) {\n            require(isEUSDBuyoutAllowed, \"The purchase using EUSD is not permitted.\");\n        }\n        uint256 reward = rewards[user];\n        if (reward > 0) {\n            rewards[user] = 0;\n            uint256 biddingFee = (reward * biddingFeeRatio) / 10000;\n            if(useEUSD) {\n                (, int lbrPrice, , , ) = lbrPriceFeed.latestRoundData();\n                biddingFee = biddingFee * uint256(lbrPrice) / 1e8;\n                bool success = EUSD.transferFrom(msg.sender, address(configurator), biddingFee);\n                require(success, \"TF\");\n                try configurator.distributeRewards() {} catch {}\n            } else {\n                IesLBR(LBR).burn(msg.sender, biddingFee);\n            }\n            IesLBR(esLBR).mint(msg.sender, reward);\n\n            emit ClaimedOtherEarnings(msg.sender, user, reward, biddingFee, useEUSD, block.timestamp);\n        }\n    }\n\n    function notifyRewardAmount(\n        uint256 amount\n    ) external onlyOwner updateReward(address(0)) {\n        require(amount > 0, \"amount = 0\");\n        if (block.timestamp >= finishAt) {\n            rewardRatio = amount / duration;\n        } else {\n            uint256 remainingRewards = (finishAt - block.timestamp) * rewardRatio;\n            rewardRatio = (amount + remainingRewards) / duration;\n        }\n\n        require(rewardRatio > 0, \"reward ratio = 0\");\n\n        finishAt = block.timestamp + duration;\n        updatedAt = block.timestamp;\n        emit NotifyRewardChanged(amount, block.timestamp);\n    }\n\n    function _min(uint256 x, uint256 y) private pure returns (uint256) {\n        return x <= y ? x : y;\n    }\n}"
    },
    {
      "filename": "contracts/lybra/miner/EUSDMiningIncentives.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n/**\n * @title tokenMiner is a stripped down version of Synthetix StakingRewards.sol, to reward esLBR to EUSD minters.\n * Differences from the original contract,\n * - Get `totalStaked` from totalSupply() in contract EUSD.\n * - Get `stakedOf(user)` from getBorrowedOf(user) in contract EUSD.\n * - When an address borrowed EUSD amount changes, call the refreshReward method to update rewards to be claimed.\n */\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IesLBR.sol\";\nimport \"../interfaces/IEUSD.sol\";\nimport \"../interfaces/ILybra.sol\";\nimport \"../interfaces/Iconfigurator.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ninterface IesLBRBoost {\n    function getUserBoost(\n        address user,\n        uint256 userUpdatedAt,\n        uint256 finishAt\n    ) external view returns (uint256);\n}\n\ncontract EUSDMiningIncentives is Ownable {\n    Iconfigurator public immutable configurator;\n    IesLBRBoost public esLBRBoost;\n    IEUSD public immutable EUSD;\n    address public esLBR;\n    address public LBR;\n    address[] public pools;\n\n    // Duration of rewards to be paid out (in seconds)\n    uint256 public duration = 2_592_000;\n    // Timestamp of when the rewards finish\n    uint256 public finishAt;\n    // Minimum of last updated time and reward finish time\n    uint256 public updatedAt;\n    // Reward to be paid out per second\n    uint256 public rewardRatio;\n    // Sum of (reward ratio * dt * 1e18 / total supply)\n    uint256 public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) public userUpdatedAt;\n    uint256 public extraRatio = 50 * 1e18;\n    uint256 public peUSDExtraRatio = 10 * 1e18;\n    uint256 public biddingFeeRatio = 3000;\n    address public ethlbrStakePool;\n    address public ethlbrLpToken;\n    AggregatorV3Interface internal etherPriceFeed;\n    AggregatorV3Interface internal lbrPriceFeed;\n    bool public isEUSDBuyoutAllowed = true;\n\n    event ClaimReward(address indexed user, uint256 amount, uint256 time);\n    event ClaimedOtherEarnings(address indexed user, address indexed Victim, uint256 buyAmount, uint256 biddingFee, bool useEUSD, uint256 time);\n    event NotifyRewardChanged(uint256 addAmount, uint256 time);\n\n    //etherOracle = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\n    constructor(address _config, address _boost, address _etherOracle, address _lbrOracle) {\n        configurator = Iconfigurator(_config);\n        esLBRBoost = IesLBRBoost(_boost);\n        EUSD = IEUSD(configurator.getEUSDAddress());\n        etherPriceFeed = AggregatorV3Interface(_etherOracle);\n        lbrPriceFeed = AggregatorV3Interface(_lbrOracle);\n    }\n\n    modifier updateReward(address _account) {\n        rewardPerTokenStored = rewardPerToken();\n        updatedAt = lastTimeRewardApplicable();\n\n        if (_account != address(0)) {\n            rewards[_account] = earned(_account);\n            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n            userUpdatedAt[_account] = block.timestamp;\n        }\n        _;\n    }\n\n    function setToken(address _lbr, address _eslbr) external onlyOwner {\n        LBR = _lbr;\n        esLBR = _eslbr;\n    }\n\n    function setLBROracle(address _lbrOracle) external onlyOwner {\n        lbrPriceFeed = AggregatorV3Interface(_lbrOracle);\n    }\n\n    function setPools(address[] memory _pools) external onlyOwner {\n        for (uint i = 0; i < _pools.length; i++) {\n            require(configurator.mintVault(_pools[i]), \"NOT_VAULT\");\n        }\n        pools = _pools;\n    }\n\n    function setBiddingCost(uint256 _biddingRatio) external onlyOwner {\n        require(_biddingRatio <= 8000, \"BCE\");\n        biddingFeeRatio = _biddingRatio;\n    }\n\n    function setExtraRatio(uint256 ratio) external onlyOwner {\n        require(ratio <= 1e20, \"BCE\");\n        extraRatio = ratio;\n    }\n\n    fun"
    }
  ]
}