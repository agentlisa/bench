{
  "Title": "[L-01] No oracle price staleness checks",
  "Content": "\nBoth `ousgInstantManager` and `rOUSG` uses an oracle to determine the price of `OUSG`.\n\n[`rOUSG::getOUSGPrice`](https://github.com/code-423n4/2024-03-ondo-finance/blob/main/contracts/ousg/rOUSG.sol#L378-L380):\n\n```solidity\nFile: contracts/ousg/rOUSG.sol\n\n378:  function getOUSGPrice() public view returns (uint256 price) {\n379:    (price, ) = oracle.getPriceData();\n380:  }\n```\n\nVery similar in [`ousgInstantManager::getOUSGPrice`](https://github.com/code-423n4/2024-03-ondo-finance/blob/main/contracts/ousg/ousgInstantManager.sol#L479-L485) but with a \"lowest\" price check.\n\nHere only the first parameter, `price` is used. However, the second parameter returned is the [`priceTimestamp`](https://github.com/code-423n4/2024-03-ondo-finance/blob/main/contracts/rwaOracles/RWAOracleExternalComparisonCheck.sol#L127), which is the timestamp at which the price was updated. If this is old it can lead to incorrect `OUSG` prices used for `rOUSG` or instant `minting`/`redeeming`.\n\n### Recommendation\n\nConsider adding a check to confirm the price used isn't stale.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-ondo-finance",
  "Code": [
    {
      "filename": "contracts/ousg/rOUSG.sol",
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/external/openzeppelin/contracts/token/IERC20.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/IERC20MetadataUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"contracts/kyc/KYCRegistryClientUpgradeable.sol\";\nimport \"contracts/rwaOracles/IRWAOracle.sol\";\n\n/**\n * @title Interest-bearing ERC20-like token for OUSG.\n *\n * rOUSG balances are dynamic and represent the holder's share of the underlying OUSG\n * controlled by the protocol. To calculate each account's balance, we do\n *\n *   shares[account] * ousgPrice\n *\n * For example, assume that we have:\n *\n *   ousgPrice = 100.505\n *   sharesOf(user1) -> 100\n *   sharesOf(user2) -> 400\n *\n * Therefore:\n *\n *   balanceOf(user1) -> 105 tokens which corresponds 105 rOUSG\n *   balanceOf(user2) -> 420 tokens which corresponds 420 rOUSG\n *\n * Since balances of all token holders change when the price of OUSG changes, this\n * token cannot fully implement ERC20 standard: it only emits `Transfer` events\n * upon explicit transfer between holders. In contrast, when total amount of pooled\n * Cash increases, no `Transfer` events are generated: doing so would require emitting\n * an event for each token holder and thus running an unbounded loop.\n *\n */\n\ncontract ROUSG is\n  Initializable,\n  ContextUpgradeable,\n  PausableUpgradeable,\n  AccessControlEnumerableUpgradeable,\n  KYCRegistryClientUpgradeable,\n  IERC20Upgradeable,\n  IERC20MetadataUpgradeable\n{\n  /**\n   * @dev rOUSG balances are dynamic and are calculated based on the accounts' shares (OUSG)\n   * and the the price of OUSG. Account shares aren't\n   * normalized, so the contract also stores the sum of all shares to calculate\n   * each account's token balance which equals to:\n   *\n   *   shares[account] * ousgPrice\n   */\n  mapping(address => uint256) private shares;\n\n  /// @dev Allowances are nominated in tokens, not token shares.\n  mapping(address => mapping(address => uint256)) private allowances;\n\n  // Total shares in existence\n  uint256 private totalShares;\n\n  // Address of the oracle that provides the `ousgPrice`\n  IRWAOracle public oracle;\n\n  // Address of the OUSG token\n  IERC20 public ousg;\n\n  // Used to scale up ousg amount -> shares\n  uint256 public constant OUSG_TO_ROUSG_SHARES_MULTIPLIER = 10_000;\n\n  // Error when redeeming shares < `OUSG_TO_ROUSG_SHARES_MULTIPLIER`\n  error UnwrapTooSmall();\n\n  /// @dev Role based access control roles\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n  bytes32 public constant BURNER_ROLE = keccak256(\"BURN_ROLE\");\n  bytes32 public constant CONFIGURER_ROLE = keccak256(\"CONFIGURER_ROLE\");\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(\n    address _kycRegistry,\n    uint256 requirementGroup,\n    address _ousg,\n    address guardian,\n    address _oracle\n  ) public virtual initializer {\n    __rOUSG_init(_kycRegistry, requirementGroup, _ousg, guardian, _oracle);\n  }\n\n  function __rOUSG_init(\n    address _kycRegistry,\n    uint256 requirementGroup,\n    address _ousg,\n    address guardian,\n    address _oracle\n  ) internal onlyInitializing {\n    __rOUSG_init_unchained(\n      _kycRegistry,\n      requirementGroup,\n      _ousg,\n      guardian,\n      _oracle\n    );\n  }\n\n  function __rOUSG_init_unchained(\n    address _kycRegistry,\n    uint256 _requirementGroup,\n    address _ousg,\n    address guardian,\n    address _oracle\n  ) internal onlyInitializing {\n    __KYCRegistryClientInitializable_init(_kycRegistry, _requirementGroup);\n    ousg = IERC20(_ousg);\n    oracle = IRWAOracle(_oracle);\n    _grantRole(DEFAULT_ADMIN_ROLE, guardian);\n    _grantRole(PAUSER_ROLE, guardian);\n    _grantRole(BURNER_ROLE, guardian);\n    _grantRole(CONFIGURER_ROLE, guardian);\n  }\n\n  /**\n   * @notice An executed shares transfer from `sender` to `recipient`.\n   *\n   * @dev emitted in pair with an ERC20-defined `Transfer` event.\n   */\n  event TransferShares(\n    address indexed from,\n    address indexed to,\n    uint256 sharesValue\n  );\n\n  /**\n   * @notice Emitted when the oracle address is set\n   *\n   * @param oldOracle The address of the old oracle\n   * @param newOracle The address of the new oracle\n   */\n  event OracleSet(address indexed oldOracle, address indexed newOracle);\n\n  /**\n   * @return the name of the token.\n   */\n  function name() public pure returns (string memory) {\n    return \"Rebasing OUSG\";\n  }\n\n  /**\n   * @return the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  function symbol() public pure returns (string memory) {\n    return \"rOUSG\";\n  }\n\n  /**\n   * @return the number of decimals for getting user representation of a token amount.\n   */\n  function decimals() public pure returns (uint8) {\n    return 18;\n  }\n\n  /**\n   * @return the amount of tokens in existence.\n   */\n  function totalSupply() public view returns (uint256) {\n    return\n      (totalShares * getOUSGPrice()) / (1e18 * OUSG_TO_ROUSG_SHARES_MULTIPLIER);\n  }\n\n  /**\n   * @return the amount of tokens owned by the `_account`.\n   *\n   * @dev Balances are dynamic and equal the `_account`'s OUSG shares multiplied\n   *      by the price of OUSG\n   */\n  function balanceOf(address _account) public view returns (uint256) {\n    return\n      (_sharesOf(_account) * getOUSGPrice()) /\n      (1e18 * OUSG_TO_ROUSG_SHARES_MULTIPLIER);\n  }\n\n  /**\n   * @notice Moves `_amount` tokens from the caller's account to the `_recipient` account.\n   *\n   * @return a boolean value indicating whether the operation succeeded.\n   * Emits a `Transfer` event.\n   * Emits a `TransferShares` event.\n   *\n   * Requirements:\n   *\n   * - `_recipient` cannot be the zero address.\n   * - the caller must have a balance of at least `_amount`.\n   * - the contract must not be paused.\n   *\n   * @dev The `_amount` argument is the amount of tokens, not shares.\n   */\n  function transfer(address _recipient, uint256 _amount) public returns (bool) {\n    _transfer(msg.sender, _recipient, _amount);\n    return true;\n  }\n\n  /**\n   * @return the remaining number of tokens that `_spender` is allowed to spend\n   * on behalf of `_owner` through `transferFrom`. This is zero by default.\n   *\n   * @dev This value changes when `approve` or `transferFrom` is called.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n  ) public view returns (uint256) {\n    return allowances[_owner][_spender];\n  }\n\n  /**\n   * @notice Sets `_amount` as the allowance of `_spender` over the caller's tokens.\n   *\n   * @return a boolean value indicating whether the operation succeeded.\n   * Emits an `Approval` event.\n   *\n   * Requirements:\n   *\n   * - `_spender` cannot be the zero address.\n   * - the contract must not be paused.\n   *\n   * @dev The `_amount` argument is the amount of tokens, not shares.\n   */\n  function approve(address _spender, uint256 _amount) public returns (bool) {\n    _approve(msg.sender, _spender, _amount);\n    return true;\n  }\n\n  /**\n   * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n   * allowance mechanism. `_amount` is then deducted from the caller's\n   * allowance.\n   *\n   * @return a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a `Transfer` event.\n   * Emits a `TransferShares` event.\n   * Emits an `Approval` event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `_sender` and `_recipient` cannot be the zero addresses.\n   * - `_sender` must have a balance of at least `_amount`.\n   * - the caller must have allowance for `_sender`'s tokens of at least `_amount`.\n   * - the contract must not be paused.\n   *\n   * @dev The `_amount` argument is the amount of tokens, not shares.\n   */\n  function transferFrom(\n    address _sender,\n    address _recipient,\n    uint256 _amount\n  ) public returns (bool) {\n    uint256 currentAllowance = allowances[_sender][msg.sender];\n    require(currentAllowance >= _amount, \"TRANSFER_AMOUNT_EXCEEDS_ALLOWANCE\");\n\n    _transfer(_sender, _recipient, _amount);\n    _approve(_sender, msg.sender, currentAllowance - _amount);\n    return true;\n  }\n\n  /**\n   * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n   *\n   * This is an alternative to `approve` that can be used as a mitigation for\n   * problems described in:\n   * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42\n   * Emits an `Approval` event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `_spender` cannot be the the zero address.\n   * - the contract must not be paused.\n   */\n  function increaseAllowance(\n    address _spender,\n    uint256 _addedValue\n  ) public returns (bool) {\n    _approve(\n      msg.sender,\n      _spender,\n      allowances[msg.sender][_spender] + _addedValue\n    );\n    return true;\n  }\n\n  /**\n   * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n   *\n   * This is an alternative to `approve` that can be used as a mitigation for\n   * problems described in:\n   * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42\n   * Emits an `Approval` event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `_spender` cannot be the zero address.\n   * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n   * - the contract must not be paused.\n   */\n  function decreaseAllowance(\n    address _spender,\n    uint256 _subtractedValue\n  ) public returns (bool) {\n    uint256 currentAllowance = allowances[msg.sender][_spender];\n    require(\n      currentAllowance >= _subtractedValue,\n      \"DECREASED_ALLOWANCE_BELOW_ZERO\"\n    );\n    _approve(msg.sender, _spender, currentAllowance - _subtractedValue);\n    return true;\n  }\n\n  /**\n   * @return the total amount of shares in existence.\n   *\n   * @dev The sum of all accounts' shares can be an arbitrary number, therefore\n   * it is necessary to store it in order to calculate each account's relative share.\n   */\n  function getTotalShares() public view returns (uint256) {\n    return totalShares;\n  }\n\n  /**\n   * @return the amount of shares owned by `_account`.\n   *\n   * @dev This is the equivalent to the amount of OUSG wrapped by `_account`.\n   */\n  function sharesOf(address _account) public view returns (uint256) {\n    return _sharesOf(_account);\n  }\n\n  /**\n   * @return the amount of shares that corresponds to `_rOUSGAmount` of rOUSG\n   */\n  function getSharesByROUSG(\n    uint256 _rOUSGAmount\n  ) public view returns (uint256) {\n    return\n      (_rOUSGAmount * 1e18 * OUSG_TO_ROUSG_SHARES_MULTIPLIER) / getOUSGPrice();\n  }\n\n  /**\n   * @return the amount of rOUSG that corresponds to `_shares` of OUSG.\n   */\n  function getROUSGByShares(uint256 _shares) public view returns (uint256) {\n    return\n      (_shares * getOUSGPrice()) / (1e18 * OUSG_TO_ROUSG_SHARES_MULTIPLIER);\n  }\n\n  function getOUSGPrice() public view returns (uint256 price) {\n    (price, ) = oracle.getPriceData();\n  }\n\n  /**\n   * @notice Moves `_sharesAmount` token shares from the caller's account to the `_recipient` account.\n   *\n   * @return amount of transferred tokens.\n   * Emits a `TransferShares` event.\n   * Emits a `Transfer` event.\n   *\n   * Requirements:\n   *\n   * - `_recipient` cannot be the zero address.\n   * - the caller must have at least `_sharesAmount` shares.\n   * - the contract must not be paused.\n   *\n   * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n   */\n  function transferShares(\n    address _recipient,\n    uint256 _sharesAmount\n  ) public returns (uint256) {\n    _transferShares(msg.sender, _recipient, _sharesAmount);\n    emit TransferShares(msg.sender, _recipient, _sharesAmount);\n    uint256 tokensAmount = getROUSGByShares(_sharesAmount);\n    emit Transfer(msg.sender, _recipient, tokensAmount);\n    return tokensAmount;\n  }\n\n  /**\n   * @notice Function called by users to wrap their OUSG tokens\n   *\n   * @param _OUSGAmount The amount of OUSG Tokens to wrap\n   *\n   * @dev KYC checks implicit in OUSG Transfer\n   */\n  function wrap(uint256 _OUSGAmount) external whenNotPaused {\n    require(_OUSGAmount > 0, \"rOUSG: can't wrap zero OUSG tokens\");\n    uint256 ousgSharesAmount = _OUSGAmount * OUSG_TO_ROUSG_SHARES_MULTIPLIER;\n    _mintShares(msg.sender, ousgSharesAmount);\n    ousg.transferFrom(msg.sender, address(this), _OUSGAmount);\n    emit Transfer(address(0), msg.sender, getROUSGByShares(ousgSharesAmount));\n    emit TransferShares(address(0), msg.sender, ousgSharesAmount);\n  }\n\n  /**\n   * @notice Function called by users to unwrap their rOUSG tokens\n   *\n   * @param _rOUSGAmount The amount of rOUSG to unwrap\n   *\n   * @dev KYC checks implicit in OUSG Transfer\n   */\n  function unwrap(uint256 _rOUSGAmount) external whenNotPaused {\n    require(_rOUSGAmount > 0, \"rOUSG: can't unwrap zero rOUSG tokens\");\n    uint256 ousgSharesAmount = getSharesByROUSG(_rOUSGAmount);\n    if (ousgSharesAmount < OUSG_TO_ROUSG_SHARES_MULTIPLIER)\n      revert UnwrapTooSmall();\n    _burnShares(msg.sender, ousgSharesAmount);\n    ousg.transfer(\n      msg.sender,\n      ousgSharesAmount / OUSG_TO_ROUSG_SHARES_MULTIPLIER\n    );\n    emit Transfer(msg.sender, address(0), _rOUSGAmount);\n    emit TransferShares(msg.sender, address(0), ousgSharesAmount);\n  }\n\n  /**\n   * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n   * Emits a `Transfer` event.\n   * Emits a `TransferShares` event.\n   */\n  function _transfer(\n    address _sender,\n    address _recipient,\n    uint256 _amount\n  ) internal {\n    uint256 _sharesToTransfer = getSharesByROUSG(_amount);\n    _transferShares(_sender, _recipient, _sharesToTransfer);\n    emit Transfer(_sender, _recipient, _amount);\n    emit TransferShares(_sender, _recipient, _sharesToTransfer);\n  }\n\n  /**\n   * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n   *\n   * Emits an `Approval` event.\n   *\n   * Requirements:\n   *\n   * - `_owner` cannot be the zero address.\n   * - `_spender` cannot be the zero address.\n   * - the contract must not be paused.\n   */\n  function _approve(\n    address _owner,\n    address _spender,\n    uint256 _amount\n  ) internal whenNotPaused {\n    require(_owner != address(0), \"APPROVE_FROM_ZERO_ADDRESS\");\n    require(_spender != address(0), \"APPROVE_TO_ZERO_ADDRESS\");\n\n    allowances[_owner][_spender] = _amount;\n    emit Approval(_owner, _spender, _amount);\n  }\n\n  /**\n   * @return the amount of shares owned by `_account`.\n   */\n  function _sharesOf(address _account) internal view returns (uint256) {\n    return shares[_account];\n  }\n\n  /**\n   * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n   *\n   * Requirements:\n   *\n   * - `_sender` cannot be the zero address.\n   * - `_recipient` cannot be the zero address.\n   * - `_sender` must hold at least `_sharesAmount` shares.\n   * - the contract must not be paused.\n   */\n  function _transferShares(\n    address _sender,\n    address _recipient,\n    uint256 _sharesAmount\n  ) internal whenNotPaused {\n    require(_sender != address(0), \"TRANSFER_FROM_THE_ZERO_ADDRESS\");\n    require(_recipient != address(0), \"TRANSFER_TO_THE_ZERO_ADDRESS\");\n\n    _beforeTokenTransfer(_sender, _recipient, _sharesAmount);\n\n    uint256 currentSenderShares = shares[_sender];\n    require(\n      _sharesAmount <= currentSenderShares,\n      \"TRANSFER_AMOUNT_EXCEEDS_BALANCE\"\n    );\n\n    shares[_sender] = currentSenderShares - _sharesAmount;\n    shares[_recipient] = shares[_recipient] + _sharesAmount;\n  }\n\n  /**\n   * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n   *\n   * Requirements:\n   *\n   * - `_recipient` cannot be the zero address.\n   * - the contract must not be paused.\n   */\n  function _mintShares(\n    address _recipient,\n    uint256 _sharesAmount\n  ) internal whenNotPaused returns (uint256) {\n    require(_recipient != address(0), \"MINT_TO_THE_ZERO_ADDRESS\");\n\n    _beforeTokenTransfer(address(0), _recipient, _sharesAmount);\n\n    totalShares += _sharesAmount;\n\n    shares[_recipient] = shares[_recipient] + _sharesAmount;\n\n    return totalShares;\n  }\n\n  /**\n   * @notice Destroys `_sharesAmount` shares from `_account`'s holdings, decreasing the total amount of shares.\n   * @dev This doesn't decrease the token total supply.\n   *\n   * Requirements:\n   *\n   * - `_account` cannot be the zero address.\n   * - `_account` must hold at least `_sharesAmount` shares.\n   * - the contract must not be paused.\n   */\n  function _burnShares(\n    address _account,\n    uint256 _sharesAmount\n  ) internal whenNotPaused returns (uint256) {\n    require(_account != address(0), \"BURN_FROM_THE_ZERO_ADDRESS\");\n\n    _beforeTokenTransfer(_account, address(0), _sharesAmount);\n\n    uint256 accountShares = shares[_account];\n    require(_sharesAmount <= accountShares, \"BURN_AMOUNT_EXCEEDS_BALANCE\");\n\n    totalShares -= _sharesAmount;\n\n    shares[_account] = accountShares - _sharesAmount;\n\n    return totalShares;\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * will be transferred to `to`.\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256\n  ) internal view {\n    // Check constraints when `transferFrom` is called to facliitate\n    // a transfer between two parties that are not `from` or `to`.\n    if (from != msg.sender && to != msg.sender) {\n      require(_getKYCStatus(msg.sender), \"rOUSG: 'sender' address not KYC'd\");\n    }\n\n    if (from != address(0)) {\n      // If not minting\n      require(_getKYCStatus(from), \"rOUSG: 'from' address not KYC'd\");\n    }\n\n    if (to != address(0)) {\n      // If not burning\n      require(_getKYCStatus(to), \"rOUSG: 'to' address not KYC'd\");\n    }\n  }\n\n  /**\n   * @notice Sets the Oracle address\n   * @dev The new oracle must comply with the IRWAOracle interface\n   * @param _oracle Address of the new oracle\n   */\n  function setOracle(address _oracle) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    emit OracleSet(address(oracle), _oracle);\n    oracle = IRWAOracle(_oracle);\n  }\n\n  /**\n   * @notice Admin burn function to burn rOUSG tokens from any account\n   * @param _account The account to burn tokens from\n   * @param _amount  The amount of rOUSG tokens to burn\n   * @dev Transfers burned shares (OUSG) to `msg.sender`\n   */\n  function burn(\n    address _account,\n    uint256 _amount\n  ) external onlyRole(BURNER_ROLE) {\n    uint256 ousgSharesAmount = getSharesByROUSG(_amount);\n    if (ousgSharesAmount < OUSG_TO_ROUSG_SHARES_MULTIPLIER)\n      revert UnwrapTooSmall();\n\n    _burnShares(_account, ousgSharesAmount);\n\n    ousg.transfer(\n      msg.sender,\n      ousgSharesAmount / OUSG_TO_ROUSG_SHARES_MULTIPLIER\n    );\n    emit Transfer(address(0), msg.sender, getROUSGByShares(ousgSharesAmount));\n    emit TransferShares(_account, address(0), ousgSharesAmount);\n  }\n\n  function pause() external onlyRole(PAUSER_ROLE) {\n    _pause();\n  }\n\n  function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _unpause();\n  }\n\n  function setKYCRegistry(\n    address registry\n  ) external override onlyRole(CONFIGURER_ROLE) {\n    _setKYCRegistry(registry);\n  }\n\n  function setKYCRequirementGroup(\n    uint256 group\n  ) external override onlyRole(CONFIGURER_ROLE) {\n    _setKYCRequirementGroup(group);\n  }\n}"
    },
    {
      "filename": "contracts/ousg/ousgInstantManager.sol",
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"contracts/external/openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"contracts/external/openzeppelin/contracts/token/IERC20Metadata.sol\";\nimport \"contracts/ousg/rOUSG.sol\";\nimport \"contracts/interfaces/IRWALike.sol\";\nimport \"contracts/interfaces/IBUIDLRedeemer.sol\";\nimport \"contracts/InstantMintTimeBasedRateLimiter.sol\";\nimport \"contracts/interfaces/IOUSGInstantManager.sol\";\nimport \"contracts/interfaces/IMulticall.sol\";\nimport \"contracts/interfaces/IInvestorBasedRateLimiter.sol\";\n\n/**\n * @title OUSGInstantManager\n * @author Ondo Finance\n * @notice This contract is responsible for minting\n *         and redeeming OUSG and rOUSG against USDC. Addresses\n *         with the DEFAULT_ADMIN_ROLE able to set optional mint and\n *         redeem fees. It is implemented in terms of a\n *         InstantMintTimeBasedRateLimiter, which imposes mint and redeem limits within\n *         specified intervals. Additionally, addresses with the PAUSER role in\n *         the registry can pause mints and redemptions, while addresses with\n *         the DEFAULT_ADMIN role can unpause mints or redemptions.\n *\n * @dev Please be aware of the differences of decimals representations between\n *      OUSG, rOUSG, USDC, and BUIDL. This contract multiplies\n *      or divides quantities by a scaling factor (see `decimalsMultiplier`) to\n *      account for this. Due to the way the difference in decimals is\n *      calculated, the decimals value of the usdc token MUST be less\n *      than or equal to OUSG's decimals value or else contract deployment\n *      will fail.\n */\ncontract OUSGInstantManager is\n  ReentrancyGuard,\n  InstantMintTimeBasedRateLimiter,\n  AccessControlEnumerable,\n  IOUSGInstantManager,\n  IMulticall\n{\n  // Role to configure the contract\n  bytes32 public constant CONFIGURER_ROLE = keccak256(\"CONFIGURER_ROLE\");\n\n  // Role to pause minting and redemptions\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n  // Safety circuit breaker in case of Oracle malfunction\n  uint256 public constant MINIMUM_OUSG_PRICE = 105e18;\n\n  // Helper constant that allows us to precisely specify fees in basis points\n  uint256 public constant FEE_GRANULARITY = 10_000;\n\n  // Helper constant that allows us to convert between OUSG and rOUSG shares\n  uint256 public constant OUSG_TO_ROUSG_SHARES_MULTIPLIER = 10_000;\n\n  // USDC contract\n  IERC20 public immutable usdc; // 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\n  // OUSG contract\n  IRWALike public immutable ousg;\n\n  // Rebasing OUSG Contract\n  ROUSG public immutable rousg;\n\n  // BUIDL token contract\n  IERC20 public immutable buidl;\n\n  // Redeemer contract used for instant redemptions of BUIDL\n  IBUIDLRedeemer public immutable buidlRedeemer;\n\n  // Scaling factor to account for differences in decimals between OUSG/rOUSG and BUIDL/USDC\n  uint256 public immutable decimalsMultiplier;\n\n  // The address that receives USDC for subscriptions\n  address public immutable usdcReceiver;\n\n  // Address of the oracle that provides the `ousgPrice`\n  IRWAOracle public oracle;\n\n  // The address in which USDC should be sent to as a fee for minting and redeeming\n  address public feeReceiver;\n\n  // Fee collected when minting OUSG (in basis points)\n  uint256 public mintFee = 0;\n\n  // Fee collected when redeeming OUSG (in basis points)\n  uint256 public redeemFee = 0;\n\n  // Minimum amount of USDC that must be deposited to mint OUSG or rOUSG\n  // Denoted in 6 decimals for USDC\n  uint256 public minimumDepositAmount = 100_000e6;\n\n  // Minimum amount of USDC that must be redeemed for to redeem OUSG or rOUSG\n  // Denoted in 6 decimals for USDC\n  uint256 public minimumRedemptionAmount = 50_000e6;\n\n  // Whether minting is paused for this contract\n  bool public mintPaused;\n\n  // Whether redemptions are paused for this contract\n  bool public redeemPaused;\n\n  // The minimum amount of BUIDL that must be redeemed in a single redemption\n  // with the BUIDLRedeemer contract\n  uint256 public minBUIDLRedeemAmount = 250_000e6;\n\n  // Optional investor-based rate limiting contract reference\n  IInvestorBasedRateLimiter public investorBasedRateLimiter;\n\n  /**\n   * @notice Constructor.\n   *\n   * @param defaultAdmin        Address that receives all roles during init DEFAULT_ADMIN_ROLE\n   * @param _usdc               USDC's token contract address\n   * @param _usdcReciever       Address that receives USDC during minting\n   * @param _feeReceiver        Address that receives mint and redemption fees\n   * @param _ousgOracle         OUSG's oracle contract address\n   * @param _ousg               OUSG's token contract address\n   * @param _rousg              rOUSG's token contract address\n   * @param _buidl              BUIDL token contract address\n   * @param _buidlRedeemer      Contract address used for instant redemptions of BUIDL\n   * @param rateLimiterConfig   See IOUSGInstantManager.sol & InstantMintTimeBasedRateLimiter.sol\n   *\n   * @dev We calculate `decimalsMultiplier` by subtracting OUSG's decimals by\n   *      the `usdc` contract's decimals and performing 10 ^ difference.\n   *      Deployment will fail if the difference is a negative number via\n   *      runtime underflow protections provided by our solidity version.\n   */\n  constructor(\n    address defaultAdmin,\n    address _usdc,\n    address _usdcReciever,\n    address _feeReceiver,\n    address _ousgOracle,\n    address _ousg,\n    address _rousg,\n    address _buidl,\n    address _buidlRedeemer,\n    RateLimiterConfig memory rateLimiterConfig\n  )\n    InstantMintTimeBasedRateLimiter(\n      rateLimiterConfig.mintLimitDuration,\n      rateLimiterConfig.redeemLimitDuration,\n      rateLimiterConfig.mintLimit,\n      rateLimiterConfig.redeemLimit\n    )\n  {\n    require(\n      address(_usdc) != address(0),\n      \"OUSGInstantManager: USDC cannot be 0x0\"\n    );\n    require(\n      address(_usdcReciever) != address(0),\n      \"OUSGInstantManager: USDC Receiver cannot be 0x0\"\n    );\n    require(\n      address(_feeReceiver) != address(0),\n      \"OUSGInstantManager: feeReceiver cannot be 0x0\"\n    );\n    require(\n      address(_ousgOracle) != address(0),\n      \"OUSGInstantManager: OUSG Oracle cannot be 0x0\"\n    );\n    require(_ousg != address(0), \"OUSGInstantManager: OUSG cannot be 0x0\");\n    require(_rousg != address(0), \"OUSGInstantManager: rOUSG cannot be 0x0\");\n    require(_buidl != address(0), \"OUSGInstantManager: BUIDL cannot be 0x0\");\n    require(\n      address(_buidlRedeemer) != address(0),\n      \"OUSGInstantManager: BUIDL Redeemer cannot be 0x0\"\n    );\n    require(\n      IERC20Metadata(_ousg).decimals() == IERC20Metadata(_rousg).decimals(),\n      \"OUSGInstantManager: OUSG decimals must be equal to USDC decimals\"\n    );\n    require(\n      IERC20Metadata(_usdc).decimals() == IERC20Metadata(_buidl).decimals(),\n      \"OUSGInstantManager: USDC decimals must be equal to BUIDL decimals\"\n    );\n    usdc = IERC20(_usdc);\n    usdcReceiver = _usdcReciever;\n    feeReceiver = _feeReceiver;\n    oracle = IRWAOracle(_ousgOracle);\n    ousg = IRWALike(_ousg);\n    rousg = ROUSG(_rousg);\n    buidl = IERC20(_buidl);\n    buidlRedeemer = IBUIDLRedeemer(_buidlRedeemer);\n    decimalsMultiplier =\n      10 **\n        (IERC20Metadata(_ousg).decimals() - IERC20Metadata(_usdc).decimals());\n    require(\n      OUSG_TO_ROUSG_SHARES_MULTIPLIER ==\n        rousg.OUSG_TO_ROUSG_SHARES_MULTIPLIER(),\n      \"OUSGInstantManager: OUSG to rOUSG shares multiplier must be equal to rOUSG's\"\n    );\n\n    _grantRole(DEFAULT_ADMIN_ROLE, defaultAdmin);\n    _grantRole(CONFIGURER_ROLE, defaultAdmin);\n    _grantRole(PAUSER_ROLE, defaultAdmin);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            Mint/Redeem\n  //////////////////////////////////////////////////////////////*/\n  /**\n   * @notice Calculates fees and triggers minting OUSG for a given amount of USDC\n   *\n   * @dev Please note that the fees are accumulated in `feeReceiver`\n   *\n   * @param usdcAmountIn amount of USDC exchanged for OUSG (in whatever decimals\n   *                     specifed by usdc token contract)\n   *\n   * @return ousgAmountOut The quantity of OUSG minted for the user\n   *                       (18 decimals per OUSG contract)\n   */\n  function mint(\n    uint256 usdcAmountIn\n  )\n    external\n    override\n    nonReentrant\n    whenMintNotPaused\n    returns (uint256 ousgAmountOut)\n  {\n    ousgAmountOut = _mint(usdcAmountIn, msg.sender);\n    emit InstantMintOUSG(msg.sender, usdcAmountIn, ousgAmountOut);\n  }\n\n  /**\n   * @notice Calculates fees and triggers minting rOUSG for a given amount of USDC\n   *\n   * @dev Please note that the fees are accumulated in `feeReceiver`\n   *\n   * @param usdcAmountIn amount of USDC exchanged for rOUSG (in whatever decimals\n   *                     specifed by usdc token contract)\n   *\n   * @return rousgAmountOut The quantity of rOUSG minted for the user\n   *                        (18 decimals per rOUSG contract)\n   */\n  function mintRebasingOUSG(\n    uint256 usdcAmountIn\n  )\n    external\n    override\n    nonReentrant\n    whenMintNotPaused\n    returns (uint256 rousgAmountOut)\n  {\n    uint256 ousgAmountOut = _mint(usdcAmountIn, address(this));\n    ousg.approve(address(rousg), ousgAmountOut);\n    rousg.wrap(ousgAmountOut);\n    rousgAmountOut = rousg.getROUSGByShares(\n      ousgAmountOut * OUSG_TO_ROUSG_SHARES_MULTIPLIER\n    );\n    rousg.transfer(msg.sender, rousgAmountOut);\n    emit InstantMintRebasingOUSG(\n      msg.sender,\n      usdcAmountIn,\n      ousgAmountOut,\n      rousgAmountOut\n    );\n  }\n\n  function _mint(\n    uint256 usdcAmountIn,\n    address to\n  ) internal returns (uint256 ousgAmountOut) {\n    require(\n      IERC20Metadata(address(usdc)).decimals() == 6,\n      \"OUSGInstantManager::_mint: USDC decimals must be 6\"\n    );\n    require(\n      usdcAmountIn >= minimumDepositAmount,\n      \"OUSGInstantManager::_mint: Deposit amount too small\"\n    );\n    _checkAndUpdateInstantMintLimit(usdcAmountIn);\n    if (address(investorBasedRateLimiter) != address(0)) {\n      investorBasedRateLimiter.checkAndUpdateMintLimit(\n        msg.sender,\n        usdcAmountIn\n      );\n    }\n\n    require(\n      usdc.allowance(msg.sender, address(this)) >= usdcAmountIn,\n      \"OUSGInstantManager::_mint: Allowance must be given to OUSGInstantManager\"\n    );\n\n    uint256 usdcfees = _getInstantMintFees(usdcAmountIn);\n    uint256 usdcAmountAfterFee = usdcAmountIn - usdcfees;\n\n    // Calculate the mint amount based on mint fees and usdc quantity\n    uint256 ousgPrice = getOUSGPrice();\n    ousgAmountOut = _getMintAmount(usdcAmountAfterFee, ousgPrice);\n\n    require(\n      ousgAmountOut > 0,\n      \"OUSGInstantManager::_mint: net mint amount can't be zero\"\n    );\n\n    // Transfer USDC\n    if (usdcfees > 0) {\n      usdc.transferFrom(msg.sender, feeReceiver, usdcfees);\n    }\n    usdc.transferFrom(msg.sender, usdcReceiver, usdcAmountAfterFee);\n\n    emit MintFeesDeducted(msg.sender, feeReceiver, usdcfees, usdcAmountIn);\n\n    ousg.mint(to, ousgAmountOut);\n  }\n\n  /**\n   * @notice Calculates fees and triggers a"
    }
  ]
}