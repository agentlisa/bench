{
  "Title": "[M-16] When users sign a credit loan for bidding on an item, they are forever committed to the loan even if the NFT value drops massively",
  "Content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/types/DataTypes.sol#L296>\n\nIn ParaSpace marketplace, taker may pass maker's signature and fulfil their bid with taker's NFT. The maker can use credit loan to purchase the NFT provided the health factor is positive in the end.\n\nIn validateAcceptBidWithCredit, verifyCreditSignature  is called to verify maker signed the credit structure.\n\n    function verifyCreditSignature(\n        DataTypes.Credit memory credit,\n        address signer,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) private view returns (bool) {\n        return\n            SignatureChecker.verify(\n                hashCredit(credit),\n                signer,\n                v,\n                r,\n                s,\n                getDomainSeparator()\n            );\n    }\n\nThe issue is that the credit structure does not have a deadline:\n\n    struct Credit {\n        address token;\n        uint256 amount;\n        bytes orderId;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\nAs a result, attacker may simply wait and if the price of the NFT goes down abuse their previous signature to take a larger amount than they would like to pay for the NFT. Additionaly, there is no revocation mechanism, so user has completely committed to loan to get the NFT until the end of time.\n\n### Impact\n\nWhen users sign a credit loan for bidding on an item, they are forever committed to the loan even if the NFT value drops massively.\n\n### Recommended Mitigation Steps\n\nAdd a deadline timestamp to the signed credit structure.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-paraspace-contest",
  "Code": [
    {
      "filename": "paraspace-core/contracts/protocol/libraries/types/DataTypes.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {OfferItem, ConsiderationItem} from \"../../../dependencies/seaport/contracts/lib/ConsiderationStructs.sol\";\n\nlibrary DataTypes {\n    enum AssetType {\n        ERC20,\n        ERC721\n    }\n\n    address public constant SApeAddress = address(0x1);\n    uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1e18;\n\n    struct ReserveData {\n        //stores the reserve configuration\n        ReserveConfigurationMap configuration;\n        //the liquidity index. Expressed in ray\n        uint128 liquidityIndex;\n        //the current supply rate. Expressed in ray\n        uint128 currentLiquidityRate;\n        //variable borrow index. Expressed in ray\n        uint128 variableBorrowIndex;\n        //the current variable borrow rate. Expressed in ray\n        uint128 currentVariableBorrowRate;\n        //timestamp of last update\n        uint40 lastUpdateTimestamp;\n        //the id of the reserve. Represents the position in the list of the active reserves\n        uint16 id;\n        //xToken address\n        address xTokenAddress;\n        //variableDebtToken address\n        address variableDebtTokenAddress;\n        //address of the interest rate strategy\n        address interestRateStrategyAddress;\n        //address of the auction strategy\n        address auctionStrategyAddress;\n        //the current treasury balance, scaled\n        uint128 accruedToTreasury;\n    }\n\n    struct ReserveConfigurationMap {\n        //bit 0-15: LTV\n        //bit 16-31: Liq. threshold\n        //bit 32-47: Liq. bonus\n        //bit 48-55: Decimals\n        //bit 56: reserve is active\n        //bit 57: reserve is frozen\n        //bit 58: borrowing is enabled\n        //bit 59: stable rate borrowing enabled\n        //bit 60: asset is paused\n        //bit 61: borrowing in isolation mode is enabled\n        //bit 62-63: reserved\n        //bit 64-79: reserve factor\n        //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\n        //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\n        //bit 152-167 liquidation protocol fee\n        //bit 168-175 eMode category\n        //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n        //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n        //bit 252-255 unused\n\n        uint256 data;\n    }\n\n    struct UserConfigurationMap {\n        /**\n         * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n         * The first bit indicates if an asset is used as collateral by the user, the second whether an\n         * asset is borrowed by the user.\n         */\n        uint256 data;\n        // auction validity time for closing invalid auctions in one tx.\n        uint256 auctionValidityTime;\n    }\n\n    struct ERC721SupplyParams {\n        uint256 tokenId;\n        bool useAsCollateral;\n    }\n\n    struct NTokenData {\n        uint256 tokenId;\n        bool useAsCollateral;\n        bool isAuctioned;\n    }\n\n    struct ReserveCache {\n        uint256 currScaledVariableDebt;\n        uint256 nextScaledVariableDebt;\n        uint256 currLiquidityIndex;\n        uint256 nextLiquidityIndex;\n        uint256 currVariableBorrowIndex;\n        uint256 nextVariableBorrowIndex;\n        uint256 currLiquidityRate;\n        uint256 currVariableBorrowRate;\n        uint256 reserveFactor;\n        ReserveConfigurationMap reserveConfiguration;\n        address xTokenAddress;\n        address variableDebtTokenAddress;\n        uint40 reserveLastUpdateTimestamp;\n    }\n\n    struct ExecuteLiquidateParams {\n        uint256 reservesCount;\n        uint256 liquidationAmount;\n        uint256 collateralTokenId;\n        uint256 auctionRecoveryHealthFactor;\n        address weth;\n        address collateralAsset;\n        address liquidationAsset;\n        address borrower;\n        address liquidator;\n        bool receiveXToken;\n        address priceOracle;\n        address priceOracleSentinel;\n    }\n\n    struct ExecuteAuctionParams {\n        uint256 reservesCount;\n        uint256 auctionRecoveryHealthFactor;\n        uint256 collateralTokenId;\n        address collateralAsset;\n        address user;\n        address priceOracle;\n    }\n\n    struct ExecuteSupplyParams {\n        address asset;\n        uint256 amount;\n        address onBehalfOf;\n        address payer;\n        uint16 referralCode;\n    }\n\n    struct ExecuteSupplyERC721Params {\n        address asset;\n        DataTypes.ERC721SupplyParams[] tokenData;\n        address onBehalfOf;\n        address payer;\n        uint16 referralCode;\n    }\n\n    struct ExecuteBorrowParams {\n        address asset;\n        address user;\n        address onBehalfOf;\n        uint256 amount;\n        uint16 referralCode;\n        bool releaseUnderlying;\n        uint256 reservesCount;\n        address oracle;\n        address priceOracleSentinel;\n    }\n\n    struct ExecuteRepayParams {\n        address asset;\n        uint256 amount;\n        address onBehalfOf;\n        bool usePTokens;\n    }\n\n    struct ExecuteWithdrawParams {\n        address asset;\n        uint256 amount;\n        address to;\n        uint256 reservesCount;\n        address oracle;\n    }\n\n    struct ExecuteWithdrawERC721Params {\n        address asset;\n        uint256[] tokenIds;\n        address to;\n        uint256 reservesCount;\n        address oracle;\n    }\n\n    struct ExecuteDecreaseUniswapV3LiquidityParams {\n        address user;\n        address asset;\n        uint256 tokenId;\n        uint256 reservesCount;\n        uint128 liquidityDecrease;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        bool receiveEthAsWeth;\n        address oracle;\n    }\n\n    struct FinalizeTransferParams {\n        address asset;\n        address from;\n        address to;\n        bool usedAsCollateral;\n        uint256 amount;\n        uint256 balanceFromBefore;\n        uint256 balanceToBefore;\n        uint256 reservesCount;\n        address oracle;\n    }\n\n    struct FinalizeTransferERC721Params {\n        address asset;\n        address from;\n        address to;\n        bool usedAsCollateral;\n        uint256 tokenId;\n        uint256 balanceFromBefore;\n        uint256 balanceToBefore;\n        uint256 reservesCount;\n        address oracle;\n    }\n\n    struct CalculateUserAccountDataParams {\n        UserConfigurationMap userConfig;\n        uint256 reservesCount;\n        address user;\n        address oracle;\n    }\n\n    struct ValidateBorrowParams {\n        ReserveCache reserveCache;\n        UserConfigurationMap userConfig;\n        address asset;\n        address userAddress;\n        uint256 amount;\n        uint256 reservesCount;\n        address oracle;\n        address priceOracleSentinel;\n    }\n\n    struct ValidateLiquidateERC20Params {\n        ReserveCache liquidationAssetReserveCache;\n        address liquidationAsset;\n        address weth;\n        uint256 totalDebt;\n        uint256 healthFactor;\n        uint256 liquidationAmount;\n        uint256 actualLiquidationAmount;\n        address priceOracleSentinel;\n    }\n\n    struct ValidateLiquidateERC721Params {\n        ReserveCache liquidationAssetReserveCache;\n        address liquidator;\n        address borrower;\n        uint256 globalDebt;\n        uint256 healthFactor;\n        address collateralAsset;\n        uint256 tokenId;\n        uint256 actualLiquidationAmount;\n        uint256 maxLiquidationAmount;\n        uint256 auctionRecoveryHealthFactor;\n        address priceOracleSentinel;\n        address xTokenAddress;\n        bool auctionEnabled;\n    }\n\n    struct ValidateAuctionParams {\n        address user;\n        uint256 auctionRecoveryHealthFactor;\n        uint256 erc721HealthFactor;\n        address collateralAsset;\n        uint256 tokenId;\n        address xTokenAddress;\n    }\n\n    struct CalculateInterestRatesParams {\n        uint256 liquidityAdded;\n        uint256 liquidityTaken;\n        uint256 totalVariableDebt;\n        uint256 reserveFactor;\n        address reserve;\n        address xToken;\n    }\n\n    struct InitReserveParams {\n        address asset;\n        address xTokenAddress;\n        address variableDebtAddress;\n        address interestRateStrategyAddress;\n        address auctionStrategyAddress;\n        uint16 reservesCount;\n        uint16 maxNumberReserves;\n    }\n\n    struct ExecuteFlashClaimParams {\n        address receiverAddress;\n        address nftAsset;\n        uint256[] nftTokenIds;\n        bytes params;\n        address oracle;\n    }\n\n    struct Credit {\n        address token;\n        uint256 amount;\n        bytes orderId;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct ExecuteMarketplaceParams {\n        bytes32 marketplaceId;\n        bytes payload;\n        Credit credit;\n        uint256 ethLeft;\n        DataTypes.Marketplace marketplace;\n        OrderInfo orderInfo;\n        address weth;\n        uint16 referralCode;\n        uint256 reservesCount;\n        address oracle;\n        address priceOracleSentinel;\n    }\n\n    struct OrderInfo {\n        address maker;\n        address taker;\n        bytes id;\n        OfferItem[] offer;\n        ConsiderationItem[] consideration;\n    }\n\n    struct Marketplace {\n        address marketplace;\n        address adapter;\n        address operator;\n        bool paused;\n    }\n\n    struct Auction {\n        uint256 startTime;\n    }\n\n    struct AuctionData {\n        address asset;\n        uint256 tokenId;\n        uint256 startTime;\n        uint256 currentPriceMultiplier;\n        uint256 maxPriceMultiplier;\n        uint256 minExpPriceMultiplier;\n        uint256 minPriceMultiplier;\n        uint256 stepLinear;\n        uint256 stepExp;\n        uint256 tickLength;\n    }\n\n    struct TokenData {\n        string symbol;\n        address tokenAddress;\n    }\n\n    struct PoolStorage {\n        // Map of reserves and their data (underlyingAssetOfReserve => reserveData)\n        mapping(address => ReserveData) _reserves;\n        // Map of users address and their configuration data (userAddress => userConfiguration)\n        mapping(address => UserConfigurationMap) _usersConfig;\n        // List of reserves as a map (reserveId => reserve).\n        // It is structured as a mapping for gas savings reasons, using the reserve id as index\n        mapping(uint256 => address) _reservesList;\n        // Maximum number of active reserves there have been in the protocol. It is the upper bound of the reserves list\n        uint16 _reservesCount;\n        // Auction recovery health factor\n        uint64 _auctionRecoveryHealthFactor;\n    }\n\n    struct ReserveConfigData {\n        uint256 decimals;\n        uint256 ltv;\n        uint256 liquidationThreshold;\n        uint256 liquidationBonus;\n        uint256 reserveFactor;\n        bool usageAsCollateralEnabled;\n        bool borrowingEnabled;\n        bool isActive;\n        bool isFrozen;\n        bool isPaused;\n    }\n}"
    }
  ]
}