{
  "Title": "The YieldOracle Contract Returns Stale Data After Price Decrease",
  "Content": "The `_updateAll` function of the `YieldOracle` contract [assumes that the exchange rates are monotonically increasing](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/YieldOracle.sol#L120). Thus, if there is ever a decrease in the exchange rate of one of the tokens (e.g., due to slashing), the `YieldOracle` will continue to return the `exchangeRate` and `apys` values which were there before the exchange rate decrease happened, and will keep doing so until the exchange rate has moved above the last value that was recorded prior to the price decrease. Given the magnitude of expected price decreases due to events such as slashing, and the expected annualized yield of LSTs, it could take a significant amount of time for the `YieldOracle` to begin returning new data.\n\n\nConsider implementing a mechanism to return appropriate exchange rates and `apys` immediately after a price decrease and enable the `YieldOracle` to begin returning accurate data once the 1-week look-back window has passed.\n\n\n***Update:** Resolved in [pull request #31](https://github.com/Ion-Protocol/ion-protocol/pull/31).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/YieldOracle.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport { IonPool } from \"src/IonPool.sol\";\nimport { IWstEth, IStaderStakePoolsManager, ISwEth } from \"src/interfaces/ProviderInterfaces.sol\";\n\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { IYieldOracle } from \"./interfaces/IYieldOracle.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n// historicalExchangeRates can be thought of as a matrix of past exchange rates by collateral types. With a uint64 type\n// storing exchange rates, 4 can be stored in one storage slot. So each day will consume ceil(ILK_COUNT / 4) storage\n// slots.\n//\n//  look back days  | storage slot  ||                             data\n//\n//                  |                  256             172             128              64              0\n//                  |               ||  |     ilk_4     |     ilk_3     |     ilk_2     |     ilk_1     |\n//        1         |     n + 0     ||  |               |               |               |               |\n//        2         |     n + 1     ||  |               |               |               |               |\n//       ...        |    n + ...    ||  |               |               |               |               |\n//        n         |     n + n     ||  |               |               |               |               |\n//\n// A uint64 has the capacity to store up to around ~18e18 which is more than enough to fit an exchange rate that only\n// ever hovers around 1e18.\n\nuint8 constant APY_PRECISION = 8;\nuint8 constant PROVIDER_PRECISION = 18;\n\nuint32 constant LOOK_BACK = 7;\nuint256 constant PERIODS = 365 * (10 ** APY_PRECISION) / LOOK_BACK; // 52.142... eAPY_PRECISION\nuint32 constant ILK_COUNT = 3;\n// Seconds in 23.5 hours. This will allow for updates around the same time of day\nuint256 constant UPDATE_LOCK_LENGTH = 84_600;\n\n/**\n * @dev This contract stores a history of the exchange rates of each collateral\n * for the past `LOOK_BACK` days. Every time, that `updateAll()` is called, it\n * will update the value at `currentIndex` in the `historicalExchangeRates` with the\n * current exchange rate and it will also calculate the APY for each collateral\n * type based on the data currently in the buffer. The APY is calculated by\n * taking the difference between the new element being added and the element\n * being replaced. This provides a growth amount of `LOOK_BACK` days. This value\n * is then projected out to a year.\n */\ncontract YieldOracle is IYieldOracle, Ownable2Step {\n    using Math for uint256;\n    using SafeCast for uint256;\n\n    // --- Errors ---\n\n    error InvalidExchangeRate(uint256 ilkIndex);\n    error AlreadyUpdated();\n\n    // --- Events ---\n\n    event ApyUpdate(uint256 indexed ilkIndex, uint256 newApy);\n\n    uint32[ILK_COUNT] public apys;\n\n    uint64[ILK_COUNT][LOOK_BACK] public historicalExchangeRates;\n    address public immutable ADDRESS0;\n    address public immutable ADDRESS1;\n    address public immutable ADDRESS2;\n\n    IonPool public ionPool;\n\n    uint32 public currentIndex;\n    uint48 public lastUpdated;\n\n    constructor(\n        uint64[ILK_COUNT][LOOK_BACK] memory _historicalExchangeRates,\n        address _wstEth,\n        address _stader,\n        address _swell,\n        address owner\n    )\n        Ownable(owner)\n    {\n        historicalExchangeRates = _historicalExchangeRates;\n\n        ADDRESS0 = _wstEth;\n        ADDRESS1 = _stader;\n        ADDRESS2 = _swell;\n\n        _updateAll();\n    }\n\n    /**\n     * @param _ionPool pool instance\n     */\n    function updateIonPool(IonPool _ionPool) external onlyOwner {\n        ionPool = _ionPool;\n    }\n\n    /**\n     * @dev Every update should also accrue interest on `IonPool`. This is\n     * because an update to the apy changes interest rates which means the\n     * previous interest rate must be accrued, or else its effect will be lost.\n     */\n    function updateAll() external {\n        ionPool.accrueInterest();\n        _updateAll();\n    }\n\n    function _updateAll() internal {\n        if (lastUpdated + UPDATE_LOCK_LENGTH > block.timestamp) revert AlreadyUpdated();\n\n        uint256 _currentIndex = currentIndex;\n        uint64[ILK_COUNT] storage previousExchangeRates = historicalExchangeRates[_currentIndex];\n\n        for (uint8 i = 0; i < ILK_COUNT;) {\n            uint64 newExchangeRate = _getExchangeRate(i);\n            uint64 previousExchangeRate = previousExchangeRates[i];\n\n            // Enforce that the exchange rate is not 0 and that it is greater\n            // than the previous exchange rate\n            if (newExchangeRate == 0 || newExchangeRate < previousExchangeRate) revert InvalidExchangeRate(i);\n\n            uint256 exchangeRateIncrease = newExchangeRate - previousExchangeRate;\n\n            // It should be noted that if this exchange rate increase were too\n            // large, it could overflow the uint32.\n            // [WAD] * [APY_PRECISION] / [WAD] = [APY_PRECISION]\n            uint32 newApy = exchangeRateIncrease.mulDiv(PERIODS, previousExchangeRate).toUint32();\n            apys[i] = newApy;\n\n            // Replace previous exchange rates with new exchange rates\n            previousExchangeRates[i] = newExchangeRate;\n\n            emit ApyUpdate(i, newApy);\n\n            // forgefmt: disable-next-line\n            unchecked { ++i; }\n        }\n\n        // update Apy, history with new exchangeRates, and currentIndex\n        currentIndex = (currentIndex + 1) % LOOK_BACK;\n        // Unsafe cast OK\n        lastUpdated = uint48(block.timestamp);\n    }\n\n    function _getExchangeRate(uint256 ilkIndex) internal view returns (uint64 exchangeRate) {\n        if (ilkIndex == 0) {\n            IWstEth wstEth = IWstEth(ADDRESS0);\n            exchangeRate = wstEth.stEthPerToken().toUint64();\n        } else if (ilkIndex == 1) {\n            IStaderStakePoolsManager stader = IStaderStakePoolsManager(ADDRESS1);\n            exchangeRate = stader.getExchangeRate().toUint64();\n        } else {\n            ISwEth swell = ISwEth(ADDRESS2);\n            exchangeRate = swell.swETHToETHRate().toUint64();\n        }\n    }\n}"
    }
  ]
}