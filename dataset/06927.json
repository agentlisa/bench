{
  "Title": "[1]",
  "Content": "Function `DefaultAccount._validateTransaction()` shouln't check `trx.value` for required balance, maybe user wanted the transaction to fail. also maybe paymaster is going to transfer required balance later.\n```\n        // The fact there is are enough balance for the account\n        // should be checked explicitly to prevent user paying for fee for a\n        // transaction that wouldn't be included on Ethereum.\n        uint256 totalRequiredBalance = _transaction.totalRequiredBalance();\n        require(totalRequiredBalance <= address(this).balance, \"Not enough balance for fee + value\");\n```\nhttps://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/DefaultAccount.sol#L102-L103\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-03-zksync",
  "Code": [
    {
      "filename": "contracts/DefaultAccount.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IAccount.sol\";\nimport \"./libraries/TransactionHelper.sol\";\nimport \"./libraries/SystemContractHelper.sol\";\nimport \"./libraries/EfficientCall.sol\";\nimport {BOOTLOADER_FORMAL_ADDRESS, NONCE_HOLDER_SYSTEM_CONTRACT, DEPLOYER_SYSTEM_CONTRACT, INonceHolder} from \"./Constants.sol\";\n\n/**\n * @author Matter Labs\n * @notice The default implementation of account.\n * @dev The bytecode of the contract is set by default for all addresses for which no other bytecodes are deployed.\n * @notice If the caller is not a bootloader always returns empty data on call, just like EOA does.\n * @notice If it is delegate called always returns empty data, just like EOA does.\n */\ncontract DefaultAccount is IAccount {\n    using TransactionHelper for *;\n\n    /**\n     * @dev Simulate the behavior of the EOA if the caller is not the bootloader.\n     * Essentially, for all non-bootloader callers halt the execution with empty return data.\n     * If all functions will use this modifier AND the contract will implement an empty payable fallback()\n     * then the contract will be indistinguishable from the EOA when called.\n     */\n    modifier ignoreNonBootloader() {\n        if (msg.sender != BOOTLOADER_FORMAL_ADDRESS) {\n            // If function was called outside of the bootloader, behave like an EOA.\n            assembly {\n                return(0, 0)\n            }\n        }\n        // Continue execution if called from the bootloader.\n        _;\n    }\n\n    /**\n     * @dev Simulate the behavior of the EOA if it is called via `delegatecall`.\n     * Thus, the default account on a delegate call behaves the same as EOA on Ethereum.\n     * If all functions will use this modifier AND the contract will implement an empty payable fallback()\n     * then the contract will be indistinguishable from the EOA when called.\n     */\n    modifier ignoreInDelegateCall() {\n        address codeAddress = SystemContractHelper.getCodeAddress();\n        if (codeAddress != address(this)) {\n            // If the function was delegate called, behave like an EOA.\n            assembly {\n                return(0, 0)\n            }\n        }\n\n        // Continue execution if not delegate called.\n        _;\n    }\n\n    /// @notice Validates the transaction & increments nonce.\n    /// @dev The transaction is considered accepted by the account if\n    /// the call to this function by the bootloader does not revert\n    /// and the nonce has been set as used.\n    /// @param _suggestedSignedHash The suggested hash of the transaction to be signed by the user.\n    /// This is the hash that is signed by the EOA by default.\n    /// @param _transaction The transaction structure itself.\n    /// @dev Besides the params above, it also accepts unused first paramter \"_txHash\", which\n    /// is the unique (canonical) hash of the transaction.\n    function validateTransaction(\n        bytes32, // _txHash\n        bytes32 _suggestedSignedHash,\n        Transaction calldata _transaction\n    ) external payable override ignoreNonBootloader ignoreInDelegateCall returns (bytes4 magic) {\n        magic = _validateTransaction(_suggestedSignedHash, _transaction);\n    }\n\n    /// @notice Inner method for validating transaction and increasing the nonce\n    /// @param _suggestedSignedHash The hash of the transaction signed by the EOA\n    /// @param _transaction The transaction.\n    function _validateTransaction(\n        bytes32 _suggestedSignedHash,\n        Transaction calldata _transaction\n    ) internal returns (bytes4 magic) {\n        // Note, that nonce holder can only be called with \"isSystem\" flag.\n        SystemContractsCaller.systemCallWithPropagatedRevert(\n            uint32(gasleft()),\n            address(NONCE_HOLDER_SYSTEM_CONTRACT),\n            0,\n            abi.encodeCall(INonceHolder.incrementMinNonceIfEquals, (_transaction.nonce))\n        );\n\n        // Even though for the transaction types present in the system right now,\n        // we always provide the suggested signed hash, this should not be\n        // always expected. In case the bootloader has no clue what the default hash\n        // is, the bytes32(0) will be supplied.\n        bytes32 txHash = _suggestedSignedHash != bytes32(0) ? _suggestedSignedHash : _transaction.encodeHash();\n\n        if (_transaction.to == uint256(uint160(address(DEPLOYER_SYSTEM_CONTRACT)))) {\n            require(_transaction.data.length >= 4, \"Invalid call to ContractDeployer\");\n        }\n\n        // The fact there is are enough balance for the account\n        // should be checked explicitly to prevent user paying for fee for a\n        // transaction that wouldn't be included on Ethereum.\n        uint256 totalRequiredBalance = _transaction.totalRequiredBalance();\n        require(totalRequiredBalance <= address(this).balance, \"Not enough balance for fee + value\");\n\n        if (_isValidSignature(txHash, _transaction.signature)) {\n            magic = ACCOUNT_VALIDATION_SUCCESS_MAGIC;\n        } else {\n            magic = bytes4(0);\n        }\n    }\n\n    /// @notice Method called by the bootloader to execute the transaction.\n    /// @param _transaction The transaction to execute.\n    /// @dev It also accepts unused _txHash and _suggestedSignedHash parameters:\n    /// the unique (canonical) hash of the transaction and the suggested signed\n    /// hash of the transaction.\n    function executeTransaction(\n        bytes32, // _txHash\n        bytes32, // _suggestedSignedHash\n        Transaction calldata _transaction\n    ) external payable override ignoreNonBootloader ignoreInDelegateCall {\n        _execute(_transaction);\n    }\n\n    /// @notice Method that should be used to initiate a transaction from this account\n    /// by an external call. This is not mandatory but should be implemented so that\n    /// it is always possible to execute transactions from L1 for this account.\n    /// @dev This method is basically validate + execute.\n    /// @param _transaction The transaction to execute.\n    function executeTransactionFromOutside(\n        Transaction calldata _transaction\n    ) external payable override ignoreNonBootloader ignoreInDelegateCall {\n        // The account recalculate the hash on its own\n        _validateTransaction(bytes32(0), _transaction);\n        _execute(_transaction);\n    }\n\n    /// @notice Inner method for executing a transaction.\n    /// @param _transaction The transaction to execute.\n    function _execute(Transaction calldata _transaction) internal {\n        address to = address(uint160(_transaction.to));\n        uint128 value = Utils.safeCastToU128(_transaction.value);\n        bytes calldata data = _transaction.data;\n        uint32 gas = Utils.safeCastToU32(gasleft());\n\n        if (to == address(DEPLOYER_SYSTEM_CONTRACT)) {\n            // Note, that the deployer contract can only be called\n            // with a \"systemCall\" flag.\n            SystemContractsCaller.systemCallWithPropagatedRevert(gas, to, value, data);\n        } else {\n            bool success = EfficientCall.rawCall(gas, to, value, data);\n            if (!success) {\n                EfficientCall.propagateRevert();\n            }\n        }\n    }\n\n    /// @notice Validation that the ECDSA signature of the transaction is correct.\n    /// @param _hash The hash of the transaction to be signed.\n    /// @param _signature The signature of the transaction.\n    /// @return EIP1271_SUCCESS_RETURN_VALUE if the signaure is correct. It reverts otherwise.\n    function _isValidSignature(bytes32 _hash, bytes memory _signature) internal view returns (bool) {\n        require(_signature.length == 65, \"Signature length is incorrect\");\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        // Signature loading code\n        // we jump 32 (0x20) as the first slot of bytes contains the length\n        // we jump 65 (0x41) per signature\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\n        assembly {\n            r := mload(add(_signature, 0x20))\n            s := mload(add(_signature, 0x40))\n            v := and(mload(add(_signature, 0x41)), 0xff)\n        }\n        require(v == 27 || v == 28, \"v is neither 27 nor 28\");\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Invalid s\");\n\n        address recoveredAddress = ecrecover(_hash, v, r, s);\n\n        return recoveredAddress == address(this) && recoveredAddress != address(0);\n    }\n\n    /// @notice Method for paying the bootloader for the transaction.\n    /// @param _transaction The transaction for which the fee is paid.\n    /// @dev It also accepts unused _txHash and _suggestedSignedHash parameters:\n    /// the unique (canonical) hash of the transaction and the suggested signed\n    /// hash of the transaction.\n    function payForTransaction(\n        bytes32, // _txHash\n        bytes32, // _suggestedSignedHash\n        Transaction calldata _transaction\n    ) external payable ignoreNonBootloader ignoreInDelegateCall {\n        bool success = _transaction.payToTheBootloader();\n        require(success, \"Failed to pay the fee to the operator\");\n    }\n\n    /// @notice Method, where the user should prepare for the transaction to be\n    /// paid for by a paymaster.\n    /// @dev Here, the account should set the allowance for the smart contracts\n    /// @param _transaction The transaction.\n    /// @dev It also accepts unused _txHash and _suggestedSignedHash parameters:\n    /// the unique (canonical) hash of the transaction and the suggested signed\n    /// hash of the transaction.\n    function prepareForPaymaster(\n        bytes32, // _txHash\n        bytes32, // _suggestedSignedHash\n        Transaction calldata _transaction\n    ) external payable ignoreNonBootloader ignoreInDelegateCall {\n        _transaction.processPaymasterInput();\n    }\n\n    fallback() external {\n        // fallback of default account shouldn't be called by bootloader under no circumstances\n        assert(msg.sender != BOOTLOADER_FORMAL_ADDRESS);\n\n        // If the contract is called directly, behave like an EOA\n    }\n\n    receive() external payable {\n        // If the contract is called directly, behave like an EOA\n    }\n}"
    }
  ]
}