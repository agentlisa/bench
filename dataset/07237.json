{
  "Title": "[O-06] Commented out code",
  "Content": "Commented code in the protocol.\n\nInstances:<br>\n[L373-L384](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BasketHandler.sol#L373-L384)<br>\n[L457-L510](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BasketHandler.sol#L457-L510)<br>\n[L339-L372](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L339-L372)<br>\n\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-01-reserve",
  "Code": [
    {
      "filename": "contracts/p1/BasketHandler.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../interfaces/IAssetRegistry.sol\";\nimport \"../interfaces/IBasketHandler.sol\";\nimport \"../interfaces/IMain.sol\";\nimport \"../libraries/Array.sol\";\nimport \"../libraries/Fixed.sol\";\nimport \"./mixins/Component.sol\";\n\n// A \"valid collateral array\" is a an IERC20[] value without rtoken, rsr, or any duplicate values\n\n// A BackupConfig value is valid if erc20s is a valid collateral array\nstruct BackupConfig {\n    uint256 max; // Maximum number of backup collateral erc20s to use in a basket\n    IERC20[] erc20s; // Ordered list of backup collateral ERC20s\n}\n\n// What does a BasketConfig value mean?\n//\n// erc20s, targetAmts, and targetNames should be interpreted together.\n// targetAmts[erc20] is the quantity of target units of erc20 that one BU should hold\n// targetNames[erc20] is the name of erc20's target unit\n// and then backups[tgt] is the BackupConfig to use for the target unit named tgt\n//\n// For any valid BasketConfig value:\n//     erc20s == keys(targetAmts) == keys(targetNames)\n//     if name is in values(targetNames), then backups[name] is a valid BackupConfig\n//     erc20s is a valid collateral array\n//\n// In the meantime, treat erc20s as the canonical set of keys for the target* maps\nstruct BasketConfig {\n    // The collateral erc20s in the prime (explicitly governance-set) basket\n    IERC20[] erc20s;\n    // Amount of target units per basket for each prime collateral token. {target/BU}\n    mapping(IERC20 => uint192) targetAmts;\n    // Cached view of the target unit for each erc20 upon setup\n    mapping(IERC20 => bytes32) targetNames;\n    // Backup configurations, per target name.\n    mapping(bytes32 => BackupConfig) backups;\n}\n\n/// The type of BasketHandler.basket.\n/// Defines a basket unit (BU) in terms of reference amounts of underlying tokens\n// Logically, basket is just a mapping of erc20 addresses to ref-unit amounts.\n// In the analytical comments I'll just refer to it that way.\n//\n// A Basket is valid if erc20s is a valid collateral array and erc20s == keys(refAmts)\nstruct Basket {\n    IERC20[] erc20s; // enumerated keys for refAmts\n    mapping(IERC20 => uint192) refAmts; // {ref/BU}\n}\n\n/*\n * @title BasketLibP1\n */\nlibrary BasketLibP1 {\n    using BasketLibP1 for Basket;\n    using FixLib for uint192;\n\n    /// Set self to a fresh, empty basket\n    // self'.erc20s = [] (empty list)\n    // self'.refAmts = {} (empty map)\n    function empty(Basket storage self) internal {\n        uint256 length = self.erc20s.length;\n        for (uint256 i = 0; i < length; ++i) self.refAmts[self.erc20s[i]] = FIX_ZERO;\n        delete self.erc20s;\n    }\n\n    /// Set `self` equal to `other`\n    function setFrom(Basket storage self, Basket storage other) internal {\n        empty(self);\n        uint256 length = other.erc20s.length;\n        for (uint256 i = 0; i < length; ++i) {\n            self.erc20s.push(other.erc20s[i]);\n            self.refAmts[other.erc20s[i]] = other.refAmts[other.erc20s[i]];\n        }\n    }\n\n    /// Add `weight` to the refAmount of collateral token `tok` in the basket `self`\n    // self'.refAmts[tok] = self.refAmts[tok] + weight\n    // self'.erc20s is keys(self'.refAmts)\n    function add(\n        Basket storage self,\n        IERC20 tok,\n        uint192 weight\n    ) internal {\n        // untestable:\n        //      Both calls to .add() use a weight that has been CEIL rounded in the\n        //      Fixed library div function, so weight will never be 0 here.\n        //      Additionally, setPrimeBasket() enforces prime-basket tokens must have a weight > 0.\n        if (weight == FIX_ZERO) return;\n        if (self.refAmts[tok].eq(FIX_ZERO)) {\n            self.erc20s.push(tok);\n            self.refAmts[tok] = weight;\n        } else {\n            self.refAmts[tok] = self.refAmts[tok].plus(weight);\n        }\n    }\n}\n\n/**\n * @title BasketHandler\n * @notice Handles the basket configuration, definition, and evolution over time.\n */\ncontract BasketHandlerP1 is ComponentP1, IBasketHandler {\n    using BasketLibP1 for Basket;\n    using CollateralStatusComparator for CollateralStatus;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using FixLib for uint192;\n\n    uint192 public constant MAX_TARGET_AMT = 1e3 * FIX_ONE; // {target/BU} max basket weight\n\n    // Peer components\n    IAssetRegistry private assetRegistry;\n    IBackingManager private backingManager;\n    IERC20 private rsr;\n    IRToken private rToken;\n    IStRSR private stRSR;\n\n    // config is the basket configuration, from which basket will be computed in a basket-switch\n    // event. config is only modified by governance through setPrimeBakset and setBackupConfig\n    BasketConfig private config;\n\n    // basket, disabled, nonce, and timestamp are only ever set by `_switchBasket()`\n    // basket is the current basket.\n    Basket private basket;\n\n    uint48 public override nonce; // A unique identifier for this basket instance\n    uint48 public override timestamp; // The timestamp when this basket was last set\n\n    // If disabled is true, status() is DISABLED, the basket is invalid,\n    // and everything except redemption should be paused.\n    bool private disabled;\n\n    // ==== Invariants ====\n    // basket is a valid Basket:\n    //   basket.erc20s is a valid collateral array and basket.erc20s == keys(basket.refAmts)\n    // config is a valid BasketConfig:\n    //   erc20s == keys(targetAmts) == keys(targetNames)\n    //   erc20s is a valid collateral array\n    //   for b in vals(backups), b.erc20s is a valid collateral array.\n    // if basket.erc20s is empty then disabled == true\n\n    // BasketHandler.init() just leaves the BasketHandler state zeroed\n    function init(IMain main_) external initializer {\n        __Component_init(main_);\n\n        assetRegistry = main_.assetRegistry();\n        backingManager = main_.backingManager();\n        rsr = main_.rsr();\n        rToken = main_.rToken();\n        stRSR = main_.stRSR();\n\n        disabled = true;\n    }\n\n    /// Disable the basket in order to schedule a basket refresh\n    /// @custom:protected\n    // checks: caller is assetRegistry\n    // effects: disabled' = true\n    function disableBasket() external {\n        require(_msgSender() == address(assetRegistry), \"asset registry only\");\n        uint192[] memory refAmts = new uint192[](basket.erc20s.length);\n        emit BasketSet(nonce, basket.erc20s, refAmts, true);\n        disabled = true;\n    }\n\n    /// Switch the basket, only callable directly by governance\n    /// @custom:interaction OR @custom:governance\n    // checks: either caller has OWNER,\n    //         or (basket is disabled after refresh and we're unpaused and unfrozen)\n    // actions: calls assetRegistry.refresh(), then _switchBasket()\n    // effects:\n    //   Either: (basket' is a valid nonempty basket, without DISABLED collateral,\n    //            that satisfies basketConfig) and disabled' = false\n    //   Or no such basket exists and disabled' = true\n    function refreshBasket() external {\n        assetRegistry.refresh();\n\n        require(\n            main.hasRole(OWNER, _msgSender()) ||\n                (status() == CollateralStatus.DISABLED && !main.pausedOrFrozen()),\n            \"basket unrefreshable\"\n        );\n        _switchBasket();\n    }\n\n    /// Set the prime basket in the basket configuration, in terms of erc20s and target amounts\n    /// @param erc20s The collateral for the new prime basket\n    /// @param targetAmts The target amounts (in) {target/BU} for the new prime basket\n    /// @custom:governance\n    // checks:\n    //   caller is OWNER\n    //   len(erc20s) == len(targetAmts)\n    //   erc20s is a valid collateral array\n    //   for all i, erc20[i] is in AssetRegistry as collateral\n    //   for all i, 0 < targetAmts[i] <= MAX_TARGET_AMT == 1000\n    //\n    // effects:\n    //   config'.erc20s = erc20s\n    //   config'.targetAmts[erc20s[i]] = targetAmts[i], for i from 0 to erc20s.length-1\n    //   config'.targetNames[e] = assetRegistry.toColl(e).targetName, for e in erc20s\n    function setPrimeBasket(IERC20[] calldata erc20s, uint192[] calldata targetAmts)\n        external\n        governance\n    {\n        require(erc20s.length > 0, \"cannot empty basket\");\n        require(erc20s.length == targetAmts.length, \"must be same length\");\n        requireValidCollArray(erc20s);\n\n        // Clean up previous basket config\n        for (uint256 i = 0; i < config.erc20s.length; ++i) {\n            delete config.targetAmts[config.erc20s[i]];\n            delete config.targetNames[config.erc20s[i]];\n        }\n        delete config.erc20s;\n\n        // Set up new config basket\n        bytes32[] memory names = new bytes32[](erc20s.length);\n\n        for (uint256 i = 0; i < erc20s.length; ++i) {\n            // This is a nice catch to have, but in general it is possible for\n            // an ERC20 in the prime basket to have its asset unregistered.\n            require(assetRegistry.toAsset(erc20s[i]).isCollateral(), \"token is not collateral\");\n            require(0 < targetAmts[i], \"invalid target amount; must be nonzero\");\n            require(targetAmts[i] <= MAX_TARGET_AMT, \"invalid target amount; too large\");\n\n            config.erc20s.push(erc20s[i]);\n            config.targetAmts[erc20s[i]] = targetAmts[i];\n            names[i] = assetRegistry.toColl(erc20s[i]).targetName();\n            config.targetNames[erc20s[i]] = names[i];\n        }\n\n        emit PrimeBasketSet(erc20s, targetAmts, names);\n    }\n\n    /// Set the backup configuration for some target name\n    /// @custom:governance\n    // checks:\n    //   caller is OWNER\n    //   erc20s is a valid collateral array\n    //   for all i, erc20[i] is in AssetRegistry as collateral\n    //\n    // effects:\n    //   config'.backups[targetName] = {max: max, erc20s: erc20s}\n    function setBackupConfig(\n        bytes32 targetName,\n        uint256 max,\n        IERC20[] calldata erc20s\n    ) external governance {\n        requireValidCollArray(erc20s);\n        BackupConfig storage conf = config.backups[targetName];\n        conf.max = max;\n        delete conf.erc20s;\n\n        for (uint256 i = 0; i < erc20s.length; ++i) {\n            // This is a nice catch to have, but in general it is possible for\n            // an ERC20 in the backup config to have its asset altered.\n            require(assetRegistry.toAsset(erc20s[i]).isCollateral(), \"token is not collateral\");\n            conf.erc20s.push(erc20s[i]);\n        }\n        emit BackupConfigSet(targetName, max, erc20s);\n    }\n\n    /// @return Whether this contract owns enough collateral to cover rToken.basketsNeeded() BUs\n    /// ie, whether the protocol is currently fully collateralized\n    function fullyCollateralized() external view returns (bool) {\n        return basketsHeldBy(address(backingManager)) >= rToken.basketsNeeded();\n    }\n\n    /// @return status_ The status of the basket\n    // returns DISABLED if disabled == true, and worst(status(coll)) otherwise\n    function status() public view returns (CollateralStatus status_) {\n        uint256 size = basket.erc20s.length;\n\n        // untestable:\n        //      disabled is only set in _switchBasket, and only if size > 0.\n        if (disabled || size == 0) return CollateralStatus.DISABLED;\n\n        for (uint256 i = 0; i < size; ++i) {\n            CollateralStatus s = assetRegistry.toColl(basket.erc20s[i]).status();\n            if (s.worseThan(status_)) status_ = s;\n        }\n    }\n\n    /// @return {tok/BU} The token-quantity of an ERC20 token in the basket.\n    // Returns 0 if erc20 is not registered, disabled, or not in the basket\n    // Returns FIX_MAX (in lieu of +infinity) if Collateral.refPerTok() is 0.\n    // Otherwise returns (token's basket.refAmts / token's Collateral.refPerTok())\n    function quantity(IERC20 erc20) public view returns (uint192) {\n        try assetRegistry.toColl(erc20) returns (ICollateral coll) {\n            if (coll.status() == CollateralStatus.DISABLED) return FIX_ZERO;\n\n            uint192 refPerTok = coll.refPerTok(); // {ref/tok}\n            if (refPerTok > 0) {\n                // {tok/BU} = {ref/BU} / {ref/tok}\n                return basket.refAmts[erc20].div(refPerTok, CEIL);\n            } else {\n                return FIX_MAX;\n            }\n        } catch {\n            return FIX_ZERO;\n        }\n    }\n\n    /// Should not revert\n    /// @return low {UoA/tok} The lower end of the price estimate\n    /// @return high {UoA/tok} The upper end of the price estimate\n    // returns sum(quantity(erc20) * price(erc20) for erc20 in basket.erc20s)\n    function price() external view returns (uint192 low, uint192 high) {\n        return _price(false);\n    }\n\n    /// Should not revert\n    /// lowLow should be nonzero when the asset might be worth selling\n    /// @return lotLow {UoA/tok} The lower end of the lot price estimate\n    /// @return lotHigh {UoA/tok} The upper end of the lot price estimate\n    // returns sum(quantity(erc20) * lotPrice(erc20) for erc20 in basket.erc20s)\n    function lotPrice() external view returns (uint192 lotLow, uint192 lotHigh) {\n        return _price(true);\n    }\n\n    /// Returns the price of a BU, using the lot prices if `useLotPrice` is true\n    /// @return low {UoA/tok} The lower end of the lot price estimate\n    /// @return high {UoA/tok} The upper end of the lot price estimate\n    function _price(bool useLotPrice) internal view returns (uint192 low, uint192 high) {\n        uint256 low256;\n        uint256 high256;\n\n        uint256 len = basket.erc20s.length;\n        for (uint256 i = 0; i < len; ++i) {\n            uint192 qty = quantity(basket.erc20s[i]);\n            if (qty == 0) continue;\n\n            (uint192 lowP, uint192 highP) = useLotPrice\n                ? assetRegistry.toAsset(basket.erc20s[i]).lotPrice()\n                : assetRegistry.toAsset(basket.erc20s[i]).price();\n\n            low256 += quantityMulPrice(qty, lowP);\n            high256 += quantityMulPrice(qty, highP);\n        }\n\n        low = low256 >= FIX_MAX ? FIX_MAX : uint192(low256);\n        high = high256 >= FIX_MAX ? FIX_MAX : uint192(high256);\n    }\n\n    /// Multiply quantity by price, rounding up to FIX_MAX and down to 0\n    /// @param qty {tok/BU}\n    /// @param p {UoA/tok}\n    function quantityMulPrice(uint192 qty, uint192 p) internal pure returns (uint192) {\n        // untestable:\n        //      qty will never = 0 here because of the check in _price()\n        if (qty == 0 || p == 0) return 0;\n        // untestable:\n        //      qty = FIX_MAX iff p = 0\n        if (qty == FIX_MAX || p == FIX_MAX) return FIX_MAX;\n\n        // return FIX_MAX instead of throwing overflow errors.\n        unchecked {\n            // p and mul *are* Fix values, so have 18 decimals (D18)\n            uint256 rawDelta = uint256(p) * qty; // {D36} = {D18} * {D18}\n            // if we overflowed *, then return FIX_MAX\n            if (rawDelta / p != qty) return FIX_MAX;\n\n            // add in FIX_HALF for rounding\n            uint256 shiftDelta = rawDelta + (FIX_ONE / 2);\n            // untestable (here there be dragons):\n            //          A)  shiftDelta = rawDelta + (FIX_ONE / 2)\n            //      shiftDelta overflows if:\n            //          B)  shiftDelta = MAX_UINT256 - FIX_ONE/2 + 1\n            //              rawDelta + (FIX_ONE/2) = MAX_UINT256 - FIX_ONE/2 + 1\n            //              p * qty = MAX_UINT256 - FIX_ONE + 1\n            //      therefore shiftDelta overflows if:\n            //          C)  p = (MAX_UINT256 - FIX_ONE + 1) / qty\n            //      MAX_UINT256 ~= 1e77 , FIX_MAX ~= 6e57 (6e20 difference in magnitude)\n            //      qty <= 1e21 (MAX_TARGET_AMT)\n            //      qty must be between 1e19 & 1e20 in order for p in (C) to be uint192,\n            //      but qty would have to be < 1e18 in order for (A) to overflow\n            if (shiftDelta < rawDelta) return FIX_MAX;\n\n            // return _div(rawDelta, FIX_ONE, ROUND)\n            return uint192(shiftDelta / FIX_ONE); // {D18} = {D36} / {D18}\n        }\n    }\n\n    /// Return the current reference basket\n    /// @return erc20s The erc20s in the reference basket\n    function basketTokens() external view returns (IERC20[] memory erc20s) {\n        uint256 len = basket.erc20s.length;\n        erc20s = new IERC20[](len);\n        for (uint256 i = 0; i < len; ++i) {\n            erc20s[i] = basket.erc20s[i];\n        }\n    }\n\n    /// Return the current issuance/redemption value of `amount` BUs\n    /// @param amount {BU}\n    /// @return erc20s The backing collateral erc20s\n    /// @return quantities {qTok} ERC20 token quantities equal to `amount` BUs\n    // Returns (erc20s, [quantity(e) * amount {as qTok} for e in erc20s])\n    function quote(uint192 amount, RoundingMode rounding)\n        external\n        view\n        returns (address[] memory erc20s, uint256[] memory quantities)\n    {\n        uint256 length = basket.erc20s.length;\n        erc20s = new address[](length);\n        quantities = new uint256[](length);\n\n        for (uint256 i = 0; i < length; ++i) {\n            erc20s[i] = address(basket.erc20s[i]);\n\n            // {qTok} = {tok/BU} * {BU} * {tok} * {qTok/tok}\n            quantities[i] = quantity(basket.erc20s[i]).mul(amount, rounding).shiftl_toUint(\n                int8(IERC20Metadata(address(basket.erc20s[i])).decimals()),\n                rounding\n            );\n        }\n    }\n\n    /// @return baskets {BU} The balance of basket units held by `account`\n    /// @dev Returns FIX_ZERO for an empty basket\n    // Returns:\n    //    0, if (basket.erc20s is empty) or (disabled is true) or (status() is DISABLED)\n    //    min(e.balanceOf(account) / quantity(e) for e in basket.erc20s if quantity(e) > 0),\n    function basketsHeldBy(address account) public view returns (uint192 baskets) {\n        uint256 length = basket.erc20s.length;\n        if (length == 0 || disabled) return FIX_ZERO;\n        baskets = FIX_MAX;\n\n        for (uint256 i = 0; i < length; ++i) {\n            ICollateral coll = assetRegistry.toColl(basket.erc20s[i]);\n            if (coll.status() == CollateralStatus.DISABLED) return FIX_ZERO;\n\n            uint192 refPerTok = coll.refPerTok();\n            // If refPerTok is 0, then we have zero of coll's reference unit.\n            // We know that basket.refAmts[basket.erc20s[i]] > 0, so we have no baskets.\n            if (refPerTok == 0) return FIX_ZERO;\n\n            // {tok}\n            uint192 bal = coll.bal(account);\n\n            // {tok/BU} = {ref/BU} / {ref/tok}.  0-division averted by condition above.\n            uint192 q = basket.refAmts[basket.erc20s[i]].div(refPerTok, CEIL);\n\n            // {BU} = {tok} / {tok/BU}.  q > 0 because q = (n).div(_, CEIL) and n > 0\n            baskets = fixMin(baskets, bal.div(q));\n        }\n    }\n\n    /* _switchBasket computes basket' from three inputs:\n       - the basket configuration (config: BasketConfig)\n       - the function (isGood: erc20 -> bool), implemented here by goodCollateral()\n       - the function (targetPerRef: erc20 -> Fix) implemented by the Collateral plugin\n\n       ==== Definitions ====\n\n       We use e:IERC20 to mean any erc20 token address, and tgt:bytes32 to mean any target name\n\n       // targetWeight(b, e) is the target-unit weight of token e in basket b\n       Let targetWeight(b, e) = b.refAmt[e] * targetPerRef(e)\n\n       // backups(tgt) is the list of sound backup tokens we plan to use for target `tgt`.\n       Let backups(tgt) = config.backups[tgt].erc20s\n                          .filter(isGood)\n                          .takeUpTo(config.backups[tgt].max)\n\n       Let primeWt(e) = if e in config.erc20s and isGood(e)\n                        then config.targetAmts[e]\n                        else 0\n       Let backupWt(e) = if e in backups(tgt)\n                         then unsoundPrimeWt(tgt) / len(Backups(tgt))\n                         else 0\n       Let unsoundPrimeWt(tgt) = sum(config.targetAmts[e]\n                                     for e in config.erc20s\n                                     where config.targetNames[e] == tgt and !isGood(e))\n\n       ==== The correctness condition ====\n\n       If unsoundPrimeWt(tgt) > 0 and len(backups(tgt)) == 0 for some tgt, then disabled' == true.\n       Else, disabled' == false and targetWeight(basket', e) == primeWt(e) + backupWt(e) for all e.\n\n       ==== Higher-level desideratum ====\n\n       The resulting total target weights should equal the configured target weight. Formally:\n\n       let configTargetWeight(tgt) = sum(config.targetAmts[e]\n                                         for e in config.erc20s\n                                         where _targetNames[e] == tgt)\n\n       let targetWeightSum(b, tgt) = sum(targetWeight(b, e)\n                                         for e in config.erc20s\n                                         where _targetNames[e] == tgt)\n\n       Given all that, if disabled' == false, then for all tgt,\n           targetWeightSum(basket', tgt) == configTargetWeight(tgt)\n\n       ==== Usual specs ====\n\n       Then, finally, given all that, the effects of _switchBasket() are:\n         basket' = _newBasket, as defined above\n         nonce' = nonce + 1\n         timestamp' = now\n    */\n\n    // These are effectively local variables of _switchBasket.\n    // Nothing should use their values from previous transactions.\n    EnumerableSet.Bytes32Set private _targetNames;\n    Basket private _newBasket; // Always empty\n\n    /// Select and save the next basket, based on the BasketConfig and Collateral statuses\n    /// (The mutator that actually does all the work in this contract.)\n    function _switchBasket() private {\n        disabled = false;\n\n        // _targetNames := {}\n        while (_targetNames.length() > 0) _targetNames.remove(_targetNames.at(0));\n        // _newBasket := {}\n        _newBasket.empty();\n\n        // _targetNames = set(values(config.targetNames))\n        // (and this stays true; _targetNames is not touched again in this function)\n        uint256 basketLength = config.erc20s.length;\n        for (uint256 i = 0; i < basketLength; ++i) {\n            _targetNames.add(config.targetNames[config.erc20s[i]]);\n        }\n        uint256 targetsLength = _targetNames.length();\n\n        // \"good\" collateral is collateral with any status() other than DISABLED\n        // goodWeights and totalWeights are in index-correspondence with _targetNames\n        // As such, they're each interepreted as a map from target name -> target weight\n\n        // {target/BU} total target weight of good, prime collateral with target i\n        // goodWeights := {}\n        uint192[] memory goodWeights = new uint192[](targetsLength);\n\n        // {target/BU} total target weight of all prime collateral with target i\n        // totalWeights := {}\n        uint192[] memory totalWeights = new uint192[](targetsLength);\n\n        // For each prime collateral token:\n        for (uint256 i = 0; i < basketLength; ++i) {\n            IERC20 erc20 = config.erc20s[i];\n\n            // Find collateral's targetName index\n            uint256 targetIndex;\n            for (targetIndex = 0; targetIndex < targetsLength; ++targetIndex) {\n                if (_targetNames.at(targetIndex) == config.targetNames[erc20]) break;\n            }\n            assert(targetIndex < targetsLength);\n            // now, _targetNames[targetIndex] == config.targetNames[config.erc20s[i]]\n\n            // Set basket weights for good, prime collateral,\n            // and accumulate the values of goodWeights and targetWeights\n            uint192 targetWeight = config.targetAmts[erc20];\n            totalWeights[targetIndex] = totalWeights[targetIndex].plus(targetWeight);\n\n            if (goodCollateral(config.targetNames[erc20], erc20) && targetWeight.gt(FIX_ZERO)) {\n                goodWeights[targetIndex] = goodWeights[targetIndex].plus(targetWeight);\n                _newBasket.add(\n                    erc20,\n                    targetWeight.div(assetRegistry.toColl(erc20).targetPerRef(), CEIL)\n                );\n                // this div is safe: targetPerRef() > 0: goodCollateral check\n            }\n        }\n\n        // Analysis: at this point:\n        // for all tgt in target names,\n        //   totalWeights(tgt)\n        //   = sum(config.targetAmts[e] for e in config.erc20s where _targetNames[e] == tgt), and\n        //   goodWeights(tgt)\n        //   = sum(primeWt(e) for e in config.erc20s where _targetNames[e] == tgt)\n        // for all e in config.erc20s,\n        //   targetWeight(_newBasket, e)\n        //   = sum(primeWt(e) if goodCollateral(e), else 0)\n\n        // For each tgt in target names, if we still need more weight for tgt then try to add the\n        // backup basket for tgt to make up that weight:\n        for (uint256 i = 0; i < targetsLength; ++i) {\n            if (totalWeights[i].lte(goodWeights[i])) continue; // Don't need any backup weight\n\n            // \"tgt\" = _targetNames[i]\n            // Now, unsoundPrimeWt(tgt) > 0\n\n            uint256 size = 0; // backup basket size\n            BackupConfig storage backup = config.backups[_targetNames.at(i)];\n\n            // Find the backup basket size: min(backup.max, # of good backup collateral)\n            uint256 backupLength = backup.erc20s.length;\n            for (uint256 j = 0; j < backupLength && size < backup.max; ++j) {\n                if (goodCollateral(_targetNames.at(i), backup.erc20s[j])) size++;\n            }\n\n            // Now, size = len(backups(tgt)). Do the disable check:\n            // Remove bad collateral and mark basket disabled. Pause most protocol functions\n            if (size == 0) disabled = true;\n\n            // Set backup basket weights...\n            uint256 assigned = 0;\n            // needed = unsoundPrimeWt(tgt)\n            uint192 needed = totalWeights[i].minus(goodWeights[i]);\n\n            // Loop: for erc20 in backups(tgt)...\n            for (uint256 j = 0; j < backupLength && assigned < size; ++j) {\n                IERC20 erc20 = backup.erc20s[j];\n                if (goodCollateral(_targetNames.at(i), erc20)) {\n                    // Across this .add(), targetWeight(_newBasket',erc20)\n                    // = targetWeight(_newBasket,erc20) + unsoundPrimeWt(tgt) / len(backups(tgt))\n                    _newBasket.add(\n                        erc20,\n                        needed.div(assetRegistry.toColl(erc20).targetPerRef().mulu(size), CEIL)\n                        // this div is safe: targetPerRef > 0: goodCollateral check\n                    );\n                    assigned++;\n                }\n            }\n            // Here, targetWeight(_newBasket, e) = primeWt(e) + backupWt(e) for all e targeting tgt\n        }\n        // Now we've looped through all values of tgt, so for all e,\n        //   targetWeight(_newBasket, e) = primeWt(e) + backupWt(e)\n\n        // Notice if basket is actually empty\n        uint256 newBasketLength = _newBasket.erc20s.length;\n        if (newBasketLength == 0) disabled = true;\n\n        // Update the basket if it's not disabled\n        if (!disabled) {\n            basket.setFrom(_newBasket);\n            nonce += 1;\n            timestamp = uint48(block.timestamp);\n        }\n\n        // Keep records, emit event\n        basketLength = basket.erc20s.length;\n        uint192[] memory refAmts = new uint192[](basketLength);\n        for (uint256 i = 0; i < basketLength; ++i) {\n            refAmts[i] = basket.refAmts[basket.erc20s[i]];\n        }\n        emit BasketSet(nonce, basket.erc20s, refAmts, disabled);\n    }\n\n    /// Require that erc20s is a valid collateral array\n    function requireValidCollArray(IERC20[] calldata erc20s) internal view {\n        IERC20 zero = IERC20(address(0));\n\n        for (uint256 i = 0; i < erc20s.length; i++) {\n            require(erc20s[i] != rsr, \"RSR is not valid collateral\");\n            require(erc20s[i] != IERC20(address(rToken)), \"RToken is not valid collateral\");\n            require(erc20s[i] != IERC20(address(stRSR)), \"stRSR is not valid collateral\");\n            require(erc20s[i] != zero, \"address zero is not valid collateral\");\n        }\n\n        require(ArrayLib.allUnique(erc20s), \"contains duplicates\");\n    }\n\n    /// Good collateral is registered, collateral, not DISABLED, has the expected targetName,\n    /// has nonzero targetPerRef() and refPerTok(), and is not a system token or 0 addr\n    function goodCollateral(bytes32 targetName, IERC20 erc20) private view returns (bool) {\n        // untestable:\n        //      All calls to goodCollateral pass an erc20 from the config or the backup.\n        //      Both setPrimeBasket and setBackupConfig must pass a call to requireValidCollArray,\n        //      which runs the 4 checks below.\n        if (erc20 == IERC20(address(0))) return false;\n        if (erc20 == rsr) return false;\n        if (erc20 == IERC20(address(rToken))) return false;\n        if (erc20 == IERC20(address(stRSR))) return false;\n\n        try assetRegistry.toColl(erc20) returns (ICollateral coll) {\n            return\n                targetName == coll.targetName() &&\n                coll.status() != CollateralStatus.DISABLED &&\n                coll.refPerTok() > 0 &&\n                coll.targetPerRef() > 0;\n        } catch {\n            return false;\n        }\n    }\n\n    // ==== FacadeRead views ====\n    // Not used in-protocol\n\n    /// Getter pt1 for `config` struct variable\n    /// @dev Indices are shared across return values\n    /// @return erc20s The erc20s in the prime basket\n    /// @return targetNames The bytes32 name identifier of the target unit, per ERC20\n    /// @return targetAmts {target/BU} The amount of the target unit in the basket, per ERC20\n    function getPrimeBasket()\n        external\n        view\n        returns (\n            IERC20[] memory erc20s,\n            bytes32[] memory targetNames,\n            uint192[] memory targetAmts\n        )\n    {\n        erc20s = new IERC20[](basket.erc20s.length);\n        targetNames = new bytes32[](erc20s.length);\n        targetAmts = new uint192[](erc20s.length);\n\n        for (uint256 i = 0; i < erc20s.length; ++i) {\n            erc20s[i] = config.erc20s[i];\n            targetNames[i] = config.targetNames[erc20s[i]];\n            targetAmts[i] = config.targetAmts[erc20s[i]];\n        }\n    }\n\n    /// Getter pt2 for `config` struct variable\n    /// @param targetName The name of the target unit to lookup the backup for\n    /// @return erc20s The backup erc20s for the target unit, in order of most to least desirable\n    /// @return max The maximum number of tokens from the array to use at a single time\n    function getBackupConfig(bytes32 targetName)\n        external\n        view\n        returns (IERC20[] memory erc20s, uint256 max)\n    {\n        BackupConfig storage backup = config.backups[targetName];\n        erc20s = new IERC20[](backup.erc20s.length);\n        for (uint256 i = 0; i < erc20s.length; ++i) {\n            erc20s[i] = backup.erc20s[i];\n        }\n        max = backup.max;\n    }\n\n    // ==== Storage Gap ====\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[42] private __gap;\n}"
    },
    {
      "filename": "contracts/p1/BasketHandler.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../interfaces/IAssetRegistry.sol\";\nimport \"../interfaces/IBasketHandler.sol\";\nimport \"../interfaces/IMain.sol\";\nimport \"../libraries/Array.sol\";\nimport \"../libraries/Fixed.sol\";\nimport \"./mixins/Component.sol\";\n\n// A \"valid collateral array\" is a an IERC20[] value without rtoken, rsr, or any duplicate values\n\n// A BackupConfig value is valid if erc20s is a valid collateral array\nstruct BackupConfig {\n    uint256 max; // Maximum number of backup collateral erc20s to use in a basket\n    IERC20[] erc20s; // Ordered list of backup collateral ERC20s\n}\n\n// What does a BasketConfig value mean?\n//\n// erc20s, targetAmts, and targetNames should be interpreted together.\n// targetAmts[erc20] is the quantity of target units of erc20 that one BU should hold\n// targetNames[erc20] is the name of erc20's target unit\n// and then backups[tgt] is the BackupConfig to use for the target unit named tgt\n//\n// For any valid BasketConfig value:\n//     erc20s == ke"
    }
  ]
}