{
  "Title": "Interest Not Accrued Prior to Withdrawing or Depositing Collateral",
  "Content": "Within the `IonPool` contract, the [`depositCollateral`](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/IonPool.sol#L626-L636) and [`withdrawCollateral`](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/IonPool.sol#L604-L612) functions allow users to deposit or withdraw collateral from a vault. These functions do not accrue interest prior to modifying the collateral balance within the vault. This would allow a user to withdraw collateral from a vault that would have been unhealthy had interest been accrued prior to the withdrawal. Additionally, it would prevent a user from depositing collateral into their vault if their debt position is dusty but would no longer be dusty after accruing interest.\n\n\nConsider accruing interest prior to all operations that affect the collateral and debt in vaults.\n\n\n***Update:** Resolved in [pull request #27](https://github.com/Ion-Protocol/ion-protocol/pull/27).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/IonPool.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport { Whitelist } from \"src/Whitelist.sol\";\nimport { SpotOracle } from \"src/oracles/spot/SpotOracle.sol\";\nimport { RewardModule } from \"src/reward/RewardModule.sol\";\nimport { InterestRate } from \"src/InterestRate.sol\";\nimport { WadRayMath, RAY } from \"src/libraries/math/WadRayMath.sol\";\nimport { IonPausableUpgradeable } from \"src/admin/IonPausableUpgradeable.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\ncontract IonPool is IonPausableUpgradeable, RewardModule {\n    using SafeERC20 for IERC20;\n    using SafeCast for *;\n    using WadRayMath for *;\n    using Math for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // --- Errors ---\n    error CeilingExceeded(uint256 newDebt, uint256 debtCeiling);\n    error UnsafePositionChange(uint256 newTotalDebtInVault, uint256 collateral, uint256 spot);\n    error UnsafePositionChangeWithoutConsent(uint8 ilkIndex, address user, address unconsentedOperator);\n    error GemTransferWithoutConsent(uint8 ilkIndex, address user, address unconsentedOperator);\n    error UseOfCollateralWithoutConsent(uint8 ilkIndex, address depositor, address unconsentedOperator);\n    error TakingWethWithoutConsent(address payer, address unconsentedOperator);\n    error VaultCannotBeDusty(uint256 amountLeft, uint256 dust);\n    error ArithmeticError();\n    error SpotUpdaterNotAuthorized();\n    error IlkAlreadyAdded(address ilkAddress);\n    error IlkNotInitialized(uint256 ilkIndex);\n    error DepositSurpassesSupplyCap(uint256 depositAmount, uint256 supplyCap);\n\n    error InvalidIlkAddress();\n    error InvalidInterestRateModule(InterestRate invalidInterestRateModule);\n    error InvalidWhitelist(Whitelist invalidWhitelist);\n\n    // --- Events ---\n    event IlkInitialized(uint8 indexed ilkIndex, address indexed ilkAddress);\n    event IlkSpotUpdated(address newSpot);\n    event IlkDebtCeilingUpdated(uint256 newDebtCeiling);\n    event IlkDustUpdated(uint256 newDust);\n    event SupplyCapUpdated(uint256 newSupplyCap);\n    event InterestRateModuleUpdated(address newModule);\n    event WhitelistUpdated(address newWhitelist);\n\n    event AddOperator(address indexed from, address indexed to);\n    event RemoveOperator(address indexed from, address indexed to);\n    event MintAndBurnGem(uint8 indexed ilkIndex, address indexed usr, int256 wad);\n    event TransferGem(uint8 indexed ilkIndex, address indexed src, address indexed dst, uint256 wad);\n\n    event Supply(\n        address indexed user, address indexed underlyingFrom, uint256 amount, uint256 supplyFactor, uint256 newDebt\n    );\n\n    event Withdraw(address indexed user, address indexed target, uint256 amount, uint256 supplyFactor, uint256 newDebt);\n\n    event WithdrawCollateral(uint8 indexed ilkIndex, address indexed user, address indexed recipient, uint256 amount);\n    event DepositCollateral(uint8 indexed ilkIndex, address indexed user, address indexed depositor, uint256 amount);\n    event Borrow(\n        uint8 indexed ilkIndex,\n        address indexed user,\n        address indexed recipient,\n        uint256 amountOfNormalizedDebt,\n        uint256 ilkRate,\n        uint256 totalDebt\n    );\n    event Repay(\n        uint8 indexed ilkIndex,\n        address indexed user,\n        address indexed payer,\n        uint256 amountOfNormalizedDebt,\n        uint256 ilkRate,\n        uint256 totalDebt\n    );\n\n    event RepayBadDebt(address indexed user, address indexed payer, uint256 rad);\n    event ConfiscateVault(\n        uint8 indexed ilkIndex,\n        address indexed u,\n        address v,\n        address indexed w,\n        int256 changeInCollateral,\n        int256 changeInNormalizedDebt\n    );\n\n    bytes32 public constant GEM_JOIN_ROLE = keccak256(\"GEM_JOIN_ROLE\");\n    bytes32 public constant LIQUIDATOR_ROLE = keccak256(\"LIQUIDATOR_ROLE\");\n\n    address private immutable ADDRESS_THIS = address(this);\n\n    // --- Modifiers ---\n    modifier onlyWhitelistedBorrowers(uint8 ilkIndex, bytes32[] memory proof) {\n        IonPoolStorage storage $ = _getIonPoolStorage();\n        $.whitelist.isWhitelistedBorrower(ilkIndex, _msgSender(), proof);\n        _;\n    }\n\n    modifier onlyWhitelistedLenders(bytes32[] memory proof) {\n        IonPoolStorage storage $ = _getIonPoolStorage();\n        $.whitelist.isWhitelistedLender(_msgSender(), proof);\n        _;\n    }\n\n    // --- Data ---\n    struct Ilk {\n        uint104 totalNormalizedDebt; // Total Normalised Debt     [WAD]\n        uint104 rate; // Accumulated Rates         [RAY]\n        uint48 lastRateUpdate; // block.timestamp of last update; overflows in 800_000 years\n        SpotOracle spot; // Oracle that provides price with safety margin\n        uint256 debtCeiling; // Debt Ceiling              [RAD]\n        uint256 dust; // Vault Debt Floor            [RAD]\n    }\n\n    struct Vault {\n        uint256 collateral; // Locked Collateral  [WAD]\n        uint256 normalizedDebt; // Normalised Debt    [WAD]\n    }\n\n    struct IonPoolStorage {\n        Ilk[] ilks;\n        // remove() should never be called, it will mess up the ordering\n        EnumerableSet.AddressSet ilkAddresses;\n        mapping(uint256 ilkIndex => mapping(address user => Vault)) vaults;\n        mapping(uint256 ilkIndex => mapping(address user => uint256)) gem; // [WAD]\n        mapping(address => uint256) unbackedDebt; // [RAD]\n        mapping(address => mapping(address => uint256)) isOperator;\n        uint256 debt; // Total Debt [RAD]\n        uint256 weth; // liquidity in pool [WAD]\n        uint256 wethSupplyCap; // [WAD]\n        uint256 totalUnbackedDebt; // Total Unbacked Dai  [RAD]\n        InterestRate interestRateModule;\n        Whitelist whitelist;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"ion.storage.IonPool\")) - 1)) & ~bytes32(uint256(0xff))\n    // solhint-disable-next-line\n    bytes32 private constant IonPoolStorageLocation = 0xceba3d526b4d5afd91d1b752bf1fd37917c20a6daf576bcb41dd1c57c1f67e00;\n\n    function _getIonPoolStorage() internal pure returns (IonPoolStorage storage $) {\n        assembly {\n            $.slot := IonPoolStorageLocation\n        }\n    }\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _underlying,\n        address _treasury,\n        uint8 decimals_,\n        string memory name_,\n        string memory symbol_,\n        address initialDefaultAdmin,\n        InterestRate _interestRateModule,\n        Whitelist _whitelist\n    )\n        external\n        initializer\n    {\n        __AccessControlDefaultAdminRules_init(0, initialDefaultAdmin);\n        RewardModule._initialize(_underlying, _treasury, decimals_, name_, symbol_);\n\n        _grantRole(ION, initialDefaultAdmin);\n\n        IonPoolStorage storage $ = _getIonPoolStorage();\n\n        $.interestRateModule = _interestRateModule;\n        $.whitelist = _whitelist;\n\n        emit InterestRateModuleUpdated(address(_interestRateModule));\n        emit WhitelistUpdated(address(_whitelist));\n    }\n\n    // --- Administration ---\n\n    /**\n     * @notice Initializes a market with a new collateral type.\n     * @dev This function and the entire protocol as a whole operates under the\n     * assumption that there will never be more than 256 collaterals.\n     * @param ilkAddress address of the ERC-20 collateral.\n     */\n    function initializeIlk(address ilkAddress) external onlyRole(ION) {\n        IonPoolStorage storage $ = _getIonPoolStorage();\n\n        if (ilkAddress == address(0)) revert InvalidIlkAddress();\n        if (!$.ilkAddresses.add(ilkAddress)) revert IlkAlreadyAdded(ilkAddress);\n\n        // Unsafe cast OK since we don't plan on having more than 256\n        // collaterals\n        uint8 ilkIndex = uint8($.ilks.length);\n        Ilk memory newIlk;\n        $.ilks.push(newIlk);\n        Ilk storage ilk = $.ilks[ilkIndex];\n\n        ilk.rate = 10 ** 27;\n        // Unsafe cast OK\n        ilk.lastRateUpdate = uint48(block.timestamp);\n\n        emit IlkInitialized(ilkIndex, ilkAddress);\n    }\n\n    /**\n     * @dev Updates the spot oracle for a given collateral.\n     * @param ilkIndex index of the collateral.\n     * @param newSpot address of the new spot oracle.\n     */\n    function updateIlkSpot(uint8 ilkIndex, SpotOracle newSpot) external onlyRole(ION) {\n        IonPoolStorage storage $ = _getIonPoolStorage();\n\n        $.ilks[ilkIndex].spot = newSpot;\n\n        emit IlkSpotUpdated(address(newSpot));\n    }\n\n    /**\n     * @notice A market can be sunset by setting the debt ceiling to 0. It would\n     * still be possible to repay debt but creating new debt would not be\n     * possible.\n     * @dev Updates the debt ceiling for a given collateral.\n     * @param ilkIndex index of the collateral.\n     * @param newCeiling new debt ceiling.\n     */\n    function updateIlkDebtCeiling(uint8 ilkIndex, uint256 newCeiling) external onlyRole(ION) {\n        IonPoolStorage storage $ = _getIonPoolStorage();\n\n        $.ilks[ilkIndex].debtCeiling = newCeiling;\n\n        emit IlkDebtCeilingUpdated(newCeiling);\n    }\n\n    /**\n     * @notice When increasing the `dust`, it is possible that some vaults will\n     * be dusty after the update. However, changes to the vault position from\n     * there will require that the vault be non-dusty (either by repaying all\n     * debt or increasing debt beyond the `dust`).\n     * @dev Updates the dust amount for a given collateral.\n     * @param ilkIndex index of the collateral.\n     * @param newDust new dust\n     */\n    function updateIlkDust(uint8 ilkIndex, uint256 newDust) external onlyRole(ION) {\n        IonPoolStorage storage $ = _getIonPoolStorage();\n\n        $.ilks[ilkIndex].dust = newDust;\n\n        emit IlkDustUpdated(newDust);\n    }\n\n    /**\n     * @notice Reducing the supply cap will not affect existing deposits.\n     * However, if it is below the `totalSupply`, then no new deposits will be\n     * allowed until the `totalSupply` is below the new `supplyCap`.\n     * @dev Updates the supply cap.\n     * @param newSupplyCap new supply cap.\n     */\n    function updateSupplyCap(uint256 newSupplyCap) external onlyRole(ION) {\n        IonPoolStorage storage $ = _getIonPoolStorage();\n\n        $.wethSupplyCap = newSupplyCap;\n\n        emit SupplyCapUpdated(newSupplyCap);\n    }\n\n    /**\n     * @dev Updates the interest rate module. There is a check to ensure that\n     * `collateralCount()` on the new interest rate module match the current\n     * number of collaterals in the pool.\n     * @param _interestRateModule new interest rate module.\n     */\n    function updateInterestRateModule(InterestRate _interestRateModule) external onlyRole(ION) {\n        if (address(_interestRateModule) == address(0)) revert InvalidInterestRateModule(_interestRateModule);\n\n        IonPoolStorage storage $ = _getIonPoolStorage();\n\n        // Sanity check\n        if (_interestRateModule.COLLATERAL_COUNT() != $.ilks.length) {\n            revert InvalidInterestRateModule(_interestRateModule);\n        }\n        $.interestRateModule = _interestRateModule;\n\n        emit InterestRateModuleUpdated(address(_interestRateModule));\n    }\n\n    /**\n     * @dev Updates the whitelist.\n     * @param _whitelist new whitelist address.\n     */\n    function updateWhitelist(Whitelist _whitelist) external onlyRole(ION) {\n        if (address(_whitelist) == address(0)) revert InvalidWhitelist(_whitelist);\n\n        IonPoolStorage storage $ = _getIonPoolStorage();\n\n        $.whitelist = _whitelist;\n\n        emit WhitelistUpdated(address(_whitelist));\n    }\n\n    /**\n     * @dev Pause actions that put the protocol into a further unsafe state.\n     * These are actions that take liquidity out of the system (e.g. borrowing,\n     * withdrawing base)\n     */\n    function pauseUnsafeActions() external onlyRole(ION) {\n        _pause(Pauses.UNSAFE);\n    }\n\n    /**\n     * @dev Unpause actions that put the protocol into a further unsafe state.\n     */\n    function unpauseUnsafeActions() external onlyRole(ION) {\n        _unpause(Pauses.UNSAFE);\n    }\n\n    /**\n     * @dev Pause actions that put the protocol into a further safe state.\n     * These are actions that put liquidity into the system (e.g. repaying,\n     * depositing base)\n     *\n     * Pausing accrual is also necessary with this since disabling repaying\n     * should not continue to accrue interest.\n     *\n     * Also accrues interest before the pause to update all debt at the time the\n     * pause takes place.\n     */\n    function pauseSafeActions() external onlyRole(ION) {\n        _pause(Pauses.SAFE);\n        _accrueInterest();\n    }\n\n    /**\n     * @dev Unpause actions that put the protocol into a further safe state.\n     *\n     * Will also update the `lastRateUpdate` to the unpause transaction\n     * timestamp. This essentially allows for a pausing and unpausing of the\n     * accrual of interest.\n     */\n    function unpauseSafeActions() external onlyRole(ION) {\n        _unpause(Pauses.SAFE);\n        IonPoolStorage storage $ = _getIonPoolStorage();\n\n        uint256 ilksLength = $.ilks.length;\n        for (uint256 i = 0; i < ilksLength;) {\n            // Unsafe cast OK\n            $.ilks[i].lastRateUpdate = uint48(block.timestamp);\n\n            // forgefmt: disable-next-line\n            unchecked { ++i; }\n        }\n    }\n\n    // --- Interest Calculations ---\n\n    /**\n     * @dev Updates accumulators for all `ilk`s based on current interest rates.\n     * @return newTotalDebt the new total debt after interest accrual\n     */\n    function accrueInterest() external whenNotPaused(Pauses.SAFE) returns (uint256 newTotalDebt) {\n        return _accrueInterest();\n    }\n\n    function _accrueInterest() internal returns (uint256 newTotalDebt) {\n        IonPoolStorage storage $ = _getIonPoolStorage();\n\n        // Safe actions should really only be paused in conjunction with unsafe\n        // actions. However, if for some reason only safe actions were paused,\n        // it would still be possible to accrue interest by withdrawing and/or\n        // borrowing... so we prevent this outcome; but without reverting the tx\n        // altogether.\n        if (paused(Pauses.SAFE)) return ($.debt);\n        uint256 totalEthSupply = totalSupply();\n\n        uint256 totalSupplyFactorIncrease;\n        uint256 totalTreasuryMintAmount;\n        uint256 totalDebtIncrease;\n\n        uint256 ilksLength = $.ilks.length;\n        for (uint8 i = 0; i < ilksLength;) {\n            (\n                uint256 supplyFactorIncrease,\n                uint256 treasuryMintAmount,\n                uint104 newRateIncrease,\n                uint256 newDebtIncrease,\n                uint48 timestampIncrease\n            ) = _calculateRewardAndDebtDistribution(i, totalEthSupply);\n\n            if (timestampIncrease > 0) {\n                Ilk storage ilk = $.ilks[i];\n                ilk.rate += newRateIncrease;\n                ilk.lastRateUpdate += timestampIncrease;\n                totalDebtIncrease += newDebtIncrease;\n\n                totalSupplyFactorIncrease += supplyFactorIncrease;\n                totalTreasuryMintAmount += treasuryMintAmount;\n            }\n\n            // forgefmt: disable-next-line\n            unchecked { ++i; }\n        }\n\n        newTotalDebt = $.debt + totalDebtIncrease;\n        $.debt = newTotalDebt;\n        _setSupplyFactor(supplyFactor() + totalSupplyFactorIncrease);\n        _mintToTreasury(totalTreasuryMintAmount);\n    }\n\n    function _accrueInterestForIlk(uint8 ilkIndex) internal {\n        (\n            uint256 supplyFactorIncrease,\n            uint256 treasuryMintAmount,\n            uint104 newRateIncrease,\n            uint256 newDebtIncrease,\n            uint48 timestampIncrease\n        ) = _calculateRewardAndDebtDistribution(ilkIndex, totalSupply());\n\n        IonPoolStorage storage $ = _getIonPoolStorage();\n\n        if (timestampIncrease > 0) {\n            Ilk storage ilk = $.ilks[ilkIndex];\n            ilk.rate += newRateIncrease;\n            ilk.lastRateUpdate += timestampIncrease;\n            $.debt += newDebtIncrease;\n\n            _setSupplyFactor(supplyFactor() + supplyFactorIncrease);\n            _mintToTreasury(treasuryMintAmount);\n        }\n    }\n\n    function _calculateRewardAndDebtDistribution(\n        uint8 ilkIndex,\n        uint256 totalEthSupply\n    )\n        internal\n        view\n        returns (\n            uint256 supplyFactorIncrease,\n            uint256 treasuryMintAmount,\n            uint104 newRateIncrease,\n            uint256 newDebtIncrease,\n            uint48 timestampIncrease\n        )\n    {\n        IonPoolStorage storage $ = _getIonPoolStorage();\n        Ilk storage ilk = $.ilks[ilkIndex];\n\n        uint256 _totalNormalizedDebt = ilk.totalNormalizedDebt;\n        // Unsafe cast OK\n        if (_totalNormalizedDebt == 0 || block.timestamp == ilk.lastRateUpdate) {\n            return (0, 0, 0, 0, 0);\n        }\n        uint256 totalDebt = _totalNormalizedDebt * ilk.rate; // [WAD] * [RAY] = [RAD]\n\n        (uint256 borrowRate, uint256 reserveFactor) =\n            $.interestRateModule.calculateInterestRate(ilkIndex, totalDebt, totalEthSupply);\n\n        if (borrowRate == 0) return (0, 0, 0, 0, 0);\n\n        // Calculates borrowRate ^ (time) and returns the result with RAY precision\n        uint256 borrowRateExpT = _rpow(borrowRate + RAY, block.timestamp - ilk.lastRateUpdate, RAY);\n\n        // Unsafe cast OK\n        timestampIncrease = uint48(block.timestamp) - ilk.lastRateUpdate;\n\n        // Debt distribution\n        // This form of rate accrual is much safer than distributing the new\n        // debt increase to the total debt since low debt amounts won't cause\n        // rounding errors to sky rocket the rate. This form of accrual is still\n        // subject to rate inflation, however, it would only be from an\n        // extremely high borrow rate rather than being a function of the\n        // current total debt in the system. This is very relevant for\n        // sunsetting markets, where the goal will be to reduce the total debt\n        // to 0.\n        newRateIncrease = ilk.rate.rayMulUp(borrowRateExpT - RAY).toUint104(); // [RAY]\n\n        newDebtIncrease = _totalNormalizedDebt * newRateIncrease; // [RAD]\n\n        // Income distribution\n        uint256 _normalizedTotalSupply = normalizedTotalSupply(); // [WAD]\n\n        // If there is no supply, then nothing is being lent out.\n        supplyFactorIncrease = _normalizedTotalSupply == 0\n            ? 0\n            : newDebtIncrease.mulDiv(RAY - reserveFactor, _normalizedTotalSupply.scaleUpToRad(18)); // [RAD] * [RAY] / [RAD]\n            // = [RAY]\n\n        treasuryMintAmount = newDebtIncrease.mulDiv(reserveFactor, 1e54); // [RAD] * [RAY] / 1e54 = [WAD]\n    }\n\n    // --- Lender Operations ---\n\n    /**\n     * @dev Allows lenders to redeem their interest-bearing position for the\n     * underlying asset. It is possible that dust amounts more of the position\n     * are burned than the underlying received due to rounding.\n     * @param receiverOfUnderlying the address to which the redeemed underlying\n     * asset should be sent to.\n     * @param amount of underlying to reedeem for.\n     */\n    function withdraw(address receiverOfUnderlying, uint256 amount) external whenNotPaused(Pauses.UNSAFE) {\n        uint256 newTotalDebt = _accrueInterest();\n        IonPoolStorage storage $ = _getIonPoolStorage();\n\n        $.weth -= amount;\n\n        uint256 _supplyFactor =\n            _burn({ user: _msgSender(), receiverOfUnderlying: receiverOfUnderlying, amount: amount });\n\n        emit Withdraw(_msgSender(), receiverOfUnderlying, amount, _supplyFactor, newTotalDebt);\n    }\n\n    /**\n     * @dev Allows lenders to deposit their underlying asset into the pool and\n     * earn interest on it.\n     * @param user the address to receive credit for the position.\n     * @param amount of underlying asset to use to create the position.\n     * @param proof merkle proof that the user is whitelisted.\n     */\n    function supply(\n        address user,\n        uint256 amount,\n        bytes32[] calldata proof\n    )\n        external\n        whenNotPaused(Pauses.SAFE)\n        onlyWhitelistedLenders(proof)\n    {\n        uint256 newTotalDebt = _accrueInterest();\n        IonPoolStorage storage $ = _getIonPoolStorage();\n\n        $.weth += amount;\n\n        uint256 _supplyFactor = _mint({ user: user, senderOfUnderlying: _msgSender(), amount: amount });\n\n        uint256 _supplyCap = $.wethSupplyCap;\n        if (totalSupply() > _supplyCap) revert DepositSurpassesSupplyCap(amount, _supplyCap);\n\n        emit Supply(user, _msgSender(), amount, _supplyFactor, newTotalDebt);\n    }\n\n    // --- Borrower Operations ---\n\n    /**\n     * @dev Allows a borrower to create debt in a position.\n     * @param ilkIndex index of the collateral.\n     * @param user to create the position for.\n     * @param recipient to receive the borrowed funds\n     * @param amountOfNormalizedDebt to create.\n     * @param proof merkle proof that the user is whitelist.\n     */\n    function borrow(\n        uint8 ilkIndex,\n        address user,\n        address recipient,\n        uint256 amountOfNormalizedDebt,\n        bytes32[] calldata proof\n    )\n        external\n        whenNotPaused(Pauses.UNSAFE)\n        onlyWhitelistedBorrowers(ilkIndex, proof)\n    {\n        _accrueInterestForIlk(ilkIndex);\n        (uint104 ilkRate, uint256 newDebt) =\n            _modifyPosition(ilkIndex, user, address(0), recipient, 0, amountOfNormalizedDebt.toInt256());\n\n        emit Borrow(ilkIndex, user, recipient, amountOfNormalizedDebt, ilkRate, newDebt);\n    }\n\n    /**\n     * @dev Allows a borrower to repay debt in a position.\n     * @param ilkIndex index of the collateral.\n     * @param user to repay the debt for.\n     * @param payer to source the funds from.\n     * @param amountOfNormalizedDebt to repay.\n     */\n    function repay(\n        uint8 ilkIndex,\n        address user,\n        address payer,\n        uint256 amountOfNormalizedDebt\n    )\n        external\n        whenNotPaused(Pauses.SAFE)\n    {\n        _accrueInterestForIlk(ilkIndex);\n        (uint104 ilkRate, uint256 newDebt) =\n            _modifyPosition(ilkIndex, user, address(0), payer, 0, -(amountOfNormalizedDebt.toInt256()));\n\n        emit Repay(ilkIndex, user, payer, amountOfNormalizedDebt, ilkRate, newDebt);\n    }\n\n    /**\n     * @dev Moves collateral from internal `vault.collateral` balances to `gem`\n     * @param ilkIndex index of the collateral.\n     * @param user to withdraw the collateral for.\n     * @param recipient to receive the collateral.\n     * @param amount to withdraw.\n     */\n    function withdrawCollateral(\n        uint8 ilkIndex,\n        address user,\n        address recipient,\n        uint256 amount\n    )\n        external\n        whenNotPaused(Pauses.UNSAFE)\n    {\n        _modifyPosition(ilkIndex, user, recipient, address(0), -(amount.toInt256()), 0);\n\n        emit WithdrawCollateral(ilkIndex, user, recipient, amount);\n    }\n\n    /**\n     * @dev Moves collateral from `gem` balances to internal `vault.collateral`\n     * @param ilkIndex index of the collateral.\n     * @param user to deposit the collateral for.\n     * @param depositor to deposit the collateral from.\n     * @param amount to deposit.\n     * @param proof merkle proof that the user is whitelisted.\n     */\n    function depositCollateral(\n        uint8 ilkIndex,\n        address user,\n        address depositor,\n        uint256 amount,\n        bytes32[] calldata proof\n    )\n        external\n        whenNotPaused(Pauses.SAFE)\n        onlyWhitelistedBorrowers(ilkIndex, proof)\n    {\n        _modifyPosition(ilkIndex, user, depositor, address(0), amount.toInt256(), 0);\n\n        emit DepositCollateral(ilkIndex, user, depositor, amount);\n    }\n\n    // --- CDP Manipulation ---\n\n    function _modifyPosition(\n        uint8 ilkIndex,\n        address u,\n        address v,\n        address w,\n        int256 changeInCollateral,\n        int256 changeInNormalizedDebt\n    )\n        internal\n        returns (uint104 ilkRate, uint256 newTotalDebt)\n    {\n        IonPoolStorage storage $ = _getIonPoolStorage();\n\n        ilkRate = $.ilks[ilkIndex].rate;\n        // ilk has been initialised\n        if (ilkRate == 0) revert IlkNotInitialized(ilkIndex);\n\n        Vault memory _vault = $.vaults[ilkIndex][u];\n        _vault.collateral = _add(_vault.collateral, changeInCollateral);\n        _vault.normalizedDebt = _add(_vault.normalizedDebt, changeInNormalizedDebt);\n\n        uint104 _totalNormalizedDebt = _add($.ilks[ilkIndex].totalNormalizedDebt, changeInNormalizedDebt).toUint104();\n\n        // Prevent stack too deep\n        {\n            uint256 newTotalDebtInVault = ilkRate * _vault.normalizedDebt;\n            // either debt has decreased, or debt ceilings are not exceeded\n            if (\n                both(\n                    changeInNormalizedDebt > 0,\n                    uint256(_totalNormalizedDebt) * uint256(ilkRate) > $.ilks[ilkIndex].debtCeiling\n                )\n            ) {\n                revert CeilingExceeded(uint256(_totalNormalizedDebt) * uint256(ilkRate), $.ilks[ilkIndex].debtCeiling);\n            }\n            uint256 ilkSpot = $.ilks[ilkIndex].spot.getSpot();\n            // vault is either less risky than before, or it is safe\n            if (\n                both(\n                    either(changeInNormalizedDebt > 0, changeInCollateral < 0),\n                    newTotalDebtInVault > _vault.collateral * ilkSpot\n                )\n            ) revert UnsafePositionChange(newTotalDebtInVault, _vault.collateral, ilkSpot);\n\n            // vault is either more safe, or the owner consents\n            if (both(either(changeInNormalizedDebt > 0, changeInCollateral < 0), !isAllowed(u, _msgSender()))) {\n                revert UnsafePositionChangeWithoutConsent(ilkIndex, u, _msgSender());\n            }\n\n            // collateral src consents\n            if (both(changeInCollateral > 0, !isAllowed(v, _msgSender()))) {\n                revert UseOfCollateralWithoutConsent(ilkIndex, v, _msgSender());\n            }\n            // debt dst consents\n            // Since changeInDebt is no longer being deducted in the form of\n            // internal accounting but rather directly in the erc20 WETH form, this\n            // contract must also have an approved role for the debt dst address on\n            // th erc20 WETH contract. Or else, the transfer will fail.\n            if (both(changeInNormalizedDebt < 0, !isAllowed(w, _msgSender()))) {\n                revert TakingWethWithoutConsent(w, _msgSender());\n            }\n\n            // vault has no debt, or a non-dusty amount\n            if (both(_vault.normalizedDebt != 0, newTotalDebtInVault < $.ilks[ilkIndex].dust)) {\n                revert VaultCannotBeDusty(newTotalDebtInVault, $.ilks[ilkIndex].dust);\n            }\n        }\n\n        int256 changeInDebt = ilkRate.toInt256() * changeInNormalizedDebt;\n\n        $.gem[ilkIndex][v] = _sub($.gem[ilkIndex][v], changeInCollateral);\n        $.vaults[ilkIndex][u] = _vault;\n        $.ilks[ilkIndex].totalNormalizedDebt = _totalNormalizedDebt;\n        newTotalDebt = _add($.debt, changeInDebt);\n        $.debt = newTotalDebt;\n\n        // If changeInDebt < 0, it is a repayment and WETH is being transferred\n        // into the protocol\n        _transferWeth(w, changeInDebt);\n    }\n\n    // --- Settlement ---\n\n    /**\n     * @dev To be used by protocol to settle bad debt using reserves\n     * NOTE: Can pay another user's bad debt with the sender's asset\n     * @param user the address that owns the bad debt being paid off\n     * @param rad amount of debt to be repaid (45 decimals)\n     */\n    function repayBadDebt(address user, uint256 rad) external whenNotPaused(Pauses.SAFE) {\n        IonPoolStorage storage $ = _getIonPoolStorage();\n\n        $.unbackedDebt[user] -= rad;\n        $.totalUnbackedDebt -= rad;\n        $.debt -= rad;\n\n        // Must be negative since it is a repayment\n        _transferWeth(_msgSender(), -(rad.toInt256()));\n\n        emit RepayBadDebt(user, _msgSender(), rad);\n    }\n\n    // --- Helpers ---\n\n    /**\n     * @dev Helper function to deal with borrowing and repaying debt. A positive\n     * amount is a borrow while negative amount is a repayment\n     * @param user receiver if transfer to, or sender if transfer from\n     * @param amount amount to transfer [RAD]\n     */\n    function _transferWeth(address user, int256 amount) internal {\n        if (amount == 0) return;\n        IonPoolStorage storage $ = _getIonPoolStorage();\n\n        if (amount < 0) {\n            uint256 amountUint = uint256(-amount);\n            uint256 amountWad = amountUint / RAY;\n            if (amountUint % RAY > 0) ++amountWad;\n\n            $.weth += amountWad;\n            underlying().safeTransferFrom(user, address(this), amountWad);\n        } else {\n            // Round down in protocol's favor\n            uint256 amountWad = uint256(amount) / RAY;\n\n            $.weth -= amountWad;\n\n            underlying().safeTransfer(user, amountWad);\n        }\n    }\n\n    // --- CDP Confiscation ---\n\n    /**\n     * @dev This function foregoes pausability for pausability at the\n     * liquidation module layer\n     * @param ilkIndex index of the collateral.\n     * @param u user to confiscate the vault from.\n     * @param v address to either credit `gem` to or deduct `gem` from\n     * @param changeInCollateral collateral to add or remove from the vault\n     * @param changeInNormalizedDebt debt to add or remove from the vault\n     */\n    function confiscateVault(\n        uint8 ilkIndex,\n        address u,\n        address v,\n        address w,\n        int256 changeInCollateral,\n        int256 changeInNormalizedDebt\n    )\n        external\n        onlyRole(LIQUIDATOR_ROLE)\n    {\n        _accrueInterestForIlk(ilkIndex); \n\n        IonPoolStorage storage $ = _getIonPoolStorage();\n\n        Vault storage _vault = $.vaults[ilkIndex][u];\n        Ilk storage ilk = $.ilks[ilkIndex];\n        uint104 ilkRate = ilk.rate;\n\n        _vault.collateral = _add(_vault.collateral, changeInCollateral);\n        _vault.normalizedDebt = _add(_vault.normalizedDebt, changeInNormalizedDebt);\n        ilk.totalNormalizedDebt = _add(uint256(ilk.totalNormalizedDebt), changeInNormalizedDebt).toUint104();\n\n        // Unsafe cast OK since we know that ilkRate is less than 2^104\n        int256 changeInDebt = int256(uint256(ilkRate)) * changeInNormalizedDebt;\n\n        $.gem[ilkIndex][v] = _sub($.gem[ilkIndex][v], changeInCollateral);\n        $.unbackedDebt[w] = _sub($.unbackedDebt[w], changeInDebt);\n        $.totalUnbackedDebt = _sub($.totalUnbackedDebt, changeInDebt);\n\n        emit ConfiscateVault(ilkIndex, u, v, w, changeInCollateral, changeInNormalizedDebt);\n    }\n\n    // --- Fungibility ---\n\n    /**\n     * @dev To be called by GemJoin contracts. After a user deposits collateral, credit the user with collateral\n     * internally\n     * @param ilkIndex collateral\n     * @param usr user\n     * @param wad amount to add or remove\n     */\n    function mintAndBurnGem(\n        uint8 ilkIndex,\n        address usr,\n        int256 wad\n    )\n        external\n        onlyRole(GEM_JOIN_ROLE)\n    {\n        IonPoolStorage storage $ = _getIonPoolStorage();\n\n        $.gem[ilkIndex][usr] = _add($.gem[ilkIndex][usr], wad);\n\n        emit MintAndBurnGem(ilkIndex, usr, wad);\n    }\n\n    /**\n     * @dev Transfer gem across the internal accounting of the pool\n     * @param ilkIndex index of the collateral\n     * @param src source of the gem\n     * @param dst destination of the gem\n     * @param wad amount of gem\n     */\n    function transferGem(uint8 ilkIndex, address src, address dst, uint256 wad) external whenNotPaused(Pauses.UNSAFE) {\n        if (!isAllowed(src, _msgSender())) revert GemTransferWithoutConsent(ilkIndex, src, _msgSender());\n\n        IonPoolStorage storage $ = _getIonPoolStorage();\n\n        $.gem[ilkIndex][src] -= wad;\n        $.gem[ilkIndex][dst] += wad;\n        emit TransferGem(ilkIndex, src, dst, wad);\n    }\n\n    // --- Getters ---\n\n    /**\n     * @return The total amount of collateral in the pool.\n     */\n    function ilkCount() public view returns (uint256) {\n        IonPoolStorage storage $ = _getIonPoolStorage();\n        return $.ilks.length;\n    }\n\n    /**\n     * @return The index of the collateral with `ilkAddress`.\n     */\n    function getIlkIndex(address ilkAddress) public view returns (uint8) {\n        IonPoolStorage storage $ = _getIonPoolStorage();\n        bytes32 addressInBytes32 = bytes32(uint256(uint160(ilkAddress)));\n\n        // Since there should never be"
    }
  ]
}