{
  "Title": "M-14: LMPVault.updateDebtReporting could underflow because of subtraction before addition",
  "Content": "# Issue M-14: LMPVault.updateDebtReporting could underflow because of subtraction before addition \n\nSource: https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/675 \n\n## Found by \n0x007\n`debt = totalDebt - prevNTotalDebt + afterNTotalDebt` in [LMPVault._updateDebtReporting](https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/LMPVault.sol#L781-L792) could underflow and breaking a core functionality of the protocol.\n\n## Vulnerability Detail\n`debt = totalDebt - prevNTotalDebt + afterNTotalDebt` where prevNTotalDebt equals `(destInfo.currentDebt * originalShares) / Math.max(destInfo.ownedShares, 1)` and the key to finding a scenario for underflow starts by noting that each value deducted from totalDebt is calculated as `cachedCurrentDebt.mulDiv(sharesToBurn, cachedDvShares, Math.Rounding.Up)`\n\nLMPDebt\n```solidity\n...\nL292    totalDebtBurn = cachedCurrentDebt.mulDiv(sharesToBurn, cachedDvShares, Math.Rounding.Up);\n...\nL440    uint256 currentDebt = (destInfo.currentDebt * originalShares) / Math.max(destInfo.ownedShares, 1);\nL448    totalDebtDecrease = currentDebt;\n```\n\nLet:\n`totalDebt = destInfo.currentDebt = destInfo.debtBasis = cachedCurrentDebt = cachedDebtBasis = 11`\n`totalSupply = destInfo.ownedShares = cachedDvShares = 10`\n\nThat way:\n`cachedCurrentDebt * 1 / cachedDvShares = 1.1` but totalDebtBurn would be rounded up to 2\n\n`sharesToBurn` could easily be 1 if there was a loss that changes the ratio from `1:1.1` to `1:1`. Therefore `currentDvDebtValue = 10 * 1 = 10`\n\n```solidity\nif (currentDvDebtValue < updatedDebtBasis) {\n    // We are currently sitting at a loss. Limit the value we can pull from\n    // the destination vault\n    currentDvDebtValue = currentDvDebtValue.mulDiv(userShares, totalVaultShares, Math.Rounding.Down);\n    currentDvShares = currentDvShares.mulDiv(userShares, totalVaultShares, Math.Rounding.Down);\n}\n\n// Shouldn't pull more than we want\n// Or, we're not in profit so we limit the pull\nif (currentDvDebtValue < maxAssetsToPull) {\n    maxAssetsToPull = currentDvDebtValue;\n}\n\n// Calculate the portion of shares to burn based on the assets we need to pull\n// and the current total debt value. These are destination vault shares.\nsharesToBurn = currentDvShares.mulDiv(maxAssetsToPull, currentDvDebtValue, Math.Rounding.Up);\n```\n\n### Steps\n* call redeem 1 share and previewRedeem request 1 `maxAssetsToPull`\n* 2 debt would be burn\n* Therefore totalDebt = 11-2 = 9\n* call another redeem 1 share and request another 1 `maxAssetsToPull`\n* 2 debts would be burn again and \n* totalDebt would be 7, but prevNTotalDebt = 11 * 8 // 10 = 8\n\nUsing 1, 10 and 11 are for illustration and the underflow could occur in several other ways. E.g if we had used `100,001`, `1,000,010` and `1,000,011` respectively.\n\n## Impact\n_updateDebtReporting could underflow and break a very important core functionality of the protocol. updateDebtReporting is so critical that funds could be lost if it doesn't work. Funds could be lost both when the vault is in profit or at loss.\n\nIf in profit, users would want to call updateDebtReporting so that they get more asset for their shares (based on the profit).\n\nIf in loss, the whole vault asset is locked and withdrawals won't be successful because the Net Asset Value is not supposed to reduce by such action (noNavDecrease modifier). Net Asset Value has reduced because the loss would reduce totalDebt, but the only way to update the totalDebt record is by calling updateDebtReporting. And those impacted the most are those with large funds. The bigger the fund, the more NAV would decrease by withdrawals.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/LMPVault.sol#L781-L792\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/libs/LMPDebt.sol#L440-L449\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/libs/LMPDebt.sol#L295\n\n## Tool used\n\nManual Review\n\n## Recommendation\nAdd before subtracting. ETH in circulation is not enough to cause an overflow.\n\n```solidity\n- debt = totalDebt - prevNTotalDebt + afterNTotalDebt\n+ debt = totalDebt + afterNTotalDebt - prevNTotalDebt\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**Trumpero** commented:\n> invalid, let get through each step in the description: \n> 0, we have, totalSupply = 10, totalDebt = 11\n> 1, redeem 1 share --> totalSupply = 10 - 1 = 9\n> 2, 2 debts will be burn -> totalDebt = 11 - 2 = 9 \n> --> invalid here because the withdraw function contains the noNAVDecrease, but as we can see here is newNav = 9 / 9 = 1 < oldNav = 11 / 10 = 1.1 \n\n\n\n**bizzyvinci**\n\nEscalate\n\nThis issue is valid.\n\nUsing 10 and 11 is just for illustration and there are many possibilities as pointed out in the report as well.\n> Using 1, 10 and 11 are for illustration and the underflow could occur in several other ways. E.g if we had used 100,001, 1,000,010 and 1,000,011 respectively.\n\nAnd here's a PoC that could be added to [LMPVaultMintingTests](https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/test/vault/LMPVault-Withdraw.t.sol#L245) which would revert due to arithmetic underflow in updateDebtReporting\n\n```solidity\nfunction test_675() public {\n        uint num0 = 1_000_000;\n        uint num1 = 1_000_001;\n        uint num2 = 1_000_002;\n\n        // Mock root price of underlyerOne to 1,000,001 (ether-like)\n        // test debtvalue is correct and where you want it\n        _mockRootPrice(address(_underlyerOne), num1 * 1e12);\n        assertEq(num1, _destVaultOne.debtValue(num0));\n\n        // deposit\n        // rebalance\n        _accessController.grantRole(Roles.SOLVER_ROLE, address(this));\n        _accessController.grantRole(Roles.LMP_FEE_SETTER_ROLE, address(this));\n\n        // User is going to deposit 1,000,010 asset\n        _asset.mint(address(this), num0);\n        _asset.approve(address(_lmpVault), num0);\n        _lmpVault.deposit(num0, address(this));\n\n        // Deployed all asset to DV1\n        _underlyerOne.mint(address(this), num1);\n        _underlyerOne.approve(address(_lmpVault), num1);\n        _lmpVault.rebalance(\n            address(_destVaultOne),\n            address(_underlyerOne), // tokenIn\n            num1,\n            address(0), // destinationOut, none when sending out baseAsset\n            address(_asset), // baseAsset, tokenOut\n            num0\n        );\n\n        // totalDebt should equal num2 now\n        assertEq(num2, _lmpVault.totalDebt());\n        assertEq(num2, _lmpVault.totalAssets());\n\n        // also get mock price back where we want it\n        _mockRootPrice(address(_underlyerOne), 1 ether);\n        assertEq(num0, _destVaultOne.debtValue(num0));\n\n        // start attack\n        _lmpVault.redeem(1, address(this), address(this));\n        assertEq(num2 - 2, _lmpVault.totalDebt());\n        assertEq(num2 - 2, _lmpVault.totalAssets());\n        \n        _lmpVault.redeem(1, address(this), address(this));\n        assertEq(num2 - 4, _lmpVault.totalDebt());\n        assertEq(num2 - 4, _lmpVault.totalAssets());\n\n        _lmpVault.updateDebtReporting(_destinations);\n    }\n\n```\n\nIn this case I used 1,000,000 against 1 wei, therefore it's **within NAV change tolerance**. And it illustrates the root cause I'm trying to point out.\n\n```solidity\ndebt = totalDebt - prevNTotalDebt + afterNTotalDebt\n```\n\n**`totalDebt` could be less than `prevNTotalDebt`.**\n\nprevNTotalDebt is [currentDebt](https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/libs/LMPDebt.sol#L440) which is debt during rebalance scaled to reflect current supply.\n```solidity\nuint256 currentDebt = (destInfo.currentDebt * originalShares) / Math.max(destInfo.ownedShares, 1);\n```\n\nHowever, a value that is rounded up is subtracted from `totalDebt`.\n```solidity\n// https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/libs/LMPDebt.sol#L295C9-L295C98\ntotalDebtBurn = cachedCurrentDebt.mulDiv(sharesToBurn, cachedDvShares, Math.Rounding.Up);\n\n// https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/LMPVault.sol#L489\ninfo.debtDecrease += totalDebtBurn;\n\n// https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/LMPVault.sol#L518C13-L518C44\ntotalDebt -= info.debtDecrease;\n```\n\nSo, the goal is to get rounding up against totalDebt that is less than the rounding down in prevNTotalDebt.\n\nThe PoC achieves that by getting a double rounding up against totalDebt, which would result in just 1 rounding down in prevNTotalDebt. If you notice the attack section, each redemption of 1 share would burn 2 debts (instead of burning 1.000_001 debt because of rounding up).\n\nP.S: Big Kudos to @Trumpero for taking the time to comment on invalid issues ðŸ«¡\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This issue is valid.\n> \n> Using 10 and 11 is just for illustration and there are many possibilities as pointed out in the report as well.\n> > Using 1, 10 and 11 are for illustration and the underflow could occur in several other ways. E.g if we had used 100,001, 1,000,010 and 1,000,011 respectively.\n> \n> And here's a PoC that could be added to [LMPVaultMintingTests](https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/test/vault/LMPVault-Withdraw.t.sol#L245) which would revert due to arithmetic underflow in updateDebtReporting\n> \n> ```solidity\n> function test_675() public {\n>         uint num0 = 1_000_000;\n>         uint num1 = 1_000_001;\n>         uint num2 = 1_000_002;\n> \n>         // Mock root price of underlyerOne to 1,000,001 (ether-like)\n>         // test debtvalue is correct and where you want it\n>         _mockRootPrice(address(_underlyerOne), num1 * 1e12);\n>         assertEq(num1, _destVaultOne.debtValue(num0));\n> \n>         // deposit\n>         // rebalance\n>         _accessController.grantRole(Roles.SOLVER_ROLE, address(this));\n>         _accessController.grantRole(Roles.LMP_FEE_SETTER_ROLE, address(this));\n> \n>         // User is going to deposit 1,000,010 asset\n>         _asset.mint(address(this), num0);\n>         _asset.approve(address(_lmpVault), num0);\n>         _lmpVault.deposit(num0, address(this));\n> \n>         // Deployed all asset to DV1\n>         _underlyerOne.mint(address(this), num1);\n>         _underlyerOne.approve(address(_lmpVault), num1);\n>         _lmpVault.rebalance(\n>             address(_destVaultOne),\n>             address(_underlyerOne), // tokenIn\n>             num1,\n>             address(0), // destinationOut, none when sending out baseAsset\n>             address(_asset), // baseAsset, tokenOut\n>             num0\n>         );\n> \n>         // totalDebt should equal num2 now\n>         assertEq(num2, _lmpVault.totalDebt());\n>         assertEq(num2, _lmpVault.totalAssets());\n> \n>         // also get mock price back where we want it\n>         _mockRootPrice(address(_underlyerOne), 1 ether);\n>         assertEq(num0, _destVaultOne.debtValue(num0));\n> \n>         // start attack\n>         _lmpVault.redeem(1, address(this), address(this));\n>         assertEq(num2 - 2, _lmpVault.totalDebt());\n>         assertEq(num2 - 2, _lmpVault.totalAssets());\n>         \n>         _lmpVault.redeem(1, address(this), address(this));\n>         assertEq(num2 - 4, _lmpVault.totalDebt());\n>         assertEq(num2 - 4, _lmpVault.totalAssets());\n> \n>         _lmpVault.updateDebtReporting(_destinations);\n>     }\n> \n> ```\n> \n> In this case I used 1,000,000 against 1 wei, therefore it's **within NAV change tolerance**. And it illustrates the root cause I'm trying to point out.\n> \n> ```solidity\n> debt = totalDebt - prevNTotalDebt + afterNTotalDebt\n> ```\n> \n> **`totalDebt` could be less than `prevNTotalDebt`.**\n> \n> prevNTotalDebt is [currentDebt](https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/libs/LMPDebt.sol#L440) which is debt during rebalance scaled to reflect current supply.\n> ```solidity\n> uint256 currentDebt = (destInfo.currentDebt * originalShares) / Math.max(destInfo.ownedShares, 1);\n> ```\n> \n> However, a value that is rounded up is subtracted from `totalDebt`.\n> ```solidity\n> // https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/libs/LMPDebt.sol#L295C9-L295C98\n> totalDebtBurn = cachedCurrentDebt.mulDiv(sharesToBurn, cachedDvShares, Math.Rounding.Up);\n> \n> // https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/LMPVault.sol#L489\n> info.debtDecrease += totalDebtBurn;\n> \n> // https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/LMPVault.sol#L518C13-L518C44\n> totalDebt -= info.debtDecrease;\n> ```\n> \n> So, the goal is to get rounding up against totalDebt that is less than the rounding down in prevNTotalDebt.\n> \n> The PoC achieves that by getting a double rounding up against totalDebt, which would result in just 1 rounding down in prevNTotalDebt. If you notice the attack section, each redemption of 1 share would burn 2 debts (instead of burning 1.000_001 debt because of rounding up).\n> \n> P.S: Big Kudos to @Trumpero for taking the time to comment on invalid issues ðŸ«¡\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Trumpero**\n\nThe POC looks good to me. Could you please review this issue, @codenutt?\n\n**codenutt**\n\nYup I'd agree @Trumpero , looks valid. Thanks @bizzyvinci !\n\n**Evert0x**\n\nPlanning to accept escalation and make issue valid.\n\n**Evert0x**\n\n@Trumpero do you think this deserves the high severity label? \n\n**Trumpero**\n\nI think it should be medium since this case just happens in some specific cases \n\n**Evert0x**\n\nResult:\nMedium\nUnique \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [bizzyvinci](https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/675/#issuecomment-1748545702): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/101",
  "Code": [
    {
      "filename": "v2-core-audit-2023-07-14/src/vault/LMPVault.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\npragma solidity 0.8.17;\n\n// solhint-disable max-states-count\n\nimport { Roles } from \"src/libs/Roles.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\nimport { LMPDebt } from \"src/vault/libs/LMPDebt.sol\";\nimport { Pausable } from \"src/security/Pausable.sol\";\nimport { VaultTypes } from \"src/vault/VaultTypes.sol\";\nimport { NonReentrant } from \"src/utils/NonReentrant.sol\";\nimport { SystemComponent } from \"src/SystemComponent.sol\";\nimport { LMPStrategy } from \"src/strategy/LMPStrategy.sol\";\nimport { SecurityBase } from \"src/security/SecurityBase.sol\";\nimport { ILMPVault } from \"src/interfaces/vault/ILMPVault.sol\";\nimport { IStrategy } from \"src/interfaces/strategy/IStrategy.sol\";\nimport { Math } from \"openzeppelin-contracts/utils/math/Math.sol\";\nimport { LMPDestinations } from \"src/vault/libs/LMPDestinations.sol\";\nimport { ERC20 } from \"openzeppelin-contracts/token/ERC20/ERC20.sol\";\nimport { IERC4626 } from \"openzeppelin-contracts/interfaces/IERC4626.sol\";\nimport { IMainRewarder } from \"src/interfaces/rewarders/IMainRewarder.sol\";\nimport { IDestinationVault } from \"src/interfaces/vault/IDestinationVault.sol\";\nimport { SafeERC20 } from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Initializable } from \"openzeppelin-contracts/proxy/utils/Initializable.sol\";\nimport { EnumerableSet } from \"openzeppelin-contracts/utils/structs/EnumerableSet.sol\";\nimport { ISystemRegistry, IDestinationVaultRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { ERC20Permit } from \"openzeppelin-contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport { IERC3156FlashBorrower } from \"openzeppelin-contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport { IERC20Metadata as IERC20 } from \"openzeppelin-contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n// Cross functional reentrancy was identified between updateDebtReporting and the\n// destinationInfo. Have nonReentrant and read-only nonReentrant modifier on them both\n// but slither was still complaining\n//slither-disable-start reentrancy-no-eth,reentrancy-benign\n\ncontract LMPVault is\n    SystemComponent,\n    Initializable,\n    ILMPVault,\n    IStrategy,\n    ERC20Permit,\n    SecurityBase,\n    Pausable,\n    NonReentrant\n{\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Math for uint256;\n    using SafeERC20 for ERC20;\n    using SafeERC20 for IERC20;\n\n    /// @dev In memory struct only for managing vars in _withdraw\n    struct WithdrawInfo {\n        uint256 currentIdle;\n        uint256 assetsFromIdle;\n        uint256 totalAssetsToPull;\n        uint256 totalAssetsPulled;\n        uint256 idleIncrease;\n        uint256 debtDecrease;\n    }\n\n    /// @notice Max fee. 100% == 10000\n    uint256 public constant MAX_FEE_BPS = 10_000;\n\n    uint256 public constant NAV_CHANGE_ROUNDING_BUFFER = 100;\n\n    /// @notice Factory contract that created this vault\n    address public factory;\n\n    /// @notice Overarching baseAsset type\n    bytes32 public immutable vaultType = VaultTypes.LST;\n\n    /// @dev The asset that is deposited into the vault\n    IERC20 internal immutable _baseAsset;\n\n    /// @notice Decimals of the base asset. Used as the decimals for the vault itself\n    uint8 internal immutable _baseAssetDecimals;\n\n    /// @dev Full list of possible destinations that could be deployed to\n    EnumerableSet.AddressSet internal destinations;\n\n    /// @dev Destinations that queued for removal\n    EnumerableSet.AddressSet internal removalQueue;\n\n    /// @dev destinationVaultAddress -> Info .. Debt reporting snapshot info\n    mapping(address => LMPDebt.DestinationInfo) internal destinationInfo;\n\n    /// @dev whether or not the vault has been shutdown\n    bool internal _shutdown;\n\n    /// @notice The amount of baseAsset deposited into the contract pending deployment\n    uint256 public totalIdle = 0;\n\n    /// @notice The current (though cached) value of assets we've deployed\n    uint256 public totalDebt = 0;\n\n    /// @notice The destinations, in order, in which withdrawals will be attempted from\n    IDestinationVault[] public withdrawalQueue;\n\n    /// @notice Main rewarder for this contract\n    IMainRewarder public rewarder;\n\n    /// @notice Current performance fee taken on profit. 100% == 10000\n    uint256 public performanceFeeBps;\n\n    /// @notice Where claimed fees are sent\n    address public feeSink;\n\n    /// @notice The last nav/share height we took fees at\n    uint256 public navPerShareHighMark = MAX_FEE_BPS;\n\n    /// @notice The last timestamp we took fees at\n    uint256 public navPerShareHighMarkTimestamp;\n\n    /// @notice The max total supply of shares we'll allow to be minted\n    uint256 public totalSupplyLimit;\n\n    /// @notice The max shares a single wallet is allowed to hold\n    uint256 public perWalletLimit;\n\n    string private _desc;\n    string private _symbol;\n\n    error TooFewAssets(uint256 requested, uint256 actual);\n    error WithdrawShareCalcInvalid(uint256 currentShares, uint256 cachedShares);\n    error InvalidFee(uint256 newFee);\n    error RewarderAlreadySet();\n    error RebalanceDestinationsMatch(address destinationVault);\n    error InvalidDestination(address destination);\n    error NavChanged(uint256 oldNav, uint256 newNav);\n    error NavOpsInProgress();\n    error OverWalletLimit(address to);\n    error VaultShutdown();\n\n    event PerformanceFeeSet(uint256 newFee);\n    event FeeSinkSet(address newFeeSink);\n    event NewNavHighWatermark(uint256 navPerShare, uint256 timestamp);\n    event TotalSupplyLimitSet(uint256 limit);\n    event PerWalletLimitSet(uint256 limit);\n\n    modifier noNavChange() {\n        (uint256 oldNav, uint256 startingTotalSupply) = _snapStartNav();\n        _;\n        _ensureNoNavChange(oldNav, startingTotalSupply);\n    }\n\n    modifier noNavDecrease() {\n        (uint256 oldNav, uint256 startingTotalSupply) = _snapStartNav();\n        _;\n        _ensureNoNavDecrease(oldNav, startingTotalSupply);\n    }\n\n    modifier ensureNoNavOps() {\n        if (systemRegistry.systemSecurity().navOpsInProgress() > 0) {\n            revert NavOpsInProgress();\n        }\n        _;\n    }\n\n    modifier trackNavOps() {\n        systemRegistry.systemSecurity().enterNavOperation();\n        _;\n        systemRegistry.systemSecurity().exitNavOperation();\n    }\n\n    constructor(\n        ISystemRegistry _systemRegistry,\n        address _vaultAsset\n    )\n        SystemComponent(_systemRegistry)\n        ERC20(\n            string(abi.encodePacked(ERC20(_vaultAsset).name(), \" Pool Token\")),\n            string(abi.encodePacked(\"lmp\", ERC20(_vaultAsset).symbol()))\n        )\n        ERC20Permit(string(abi.encodePacked(\"lmp\", ERC20(_vaultAsset).symbol())))\n        SecurityBase(address(_systemRegistry.accessController()))\n        Pausable(_systemRegistry)\n    {\n        _baseAsset = IERC20(_vaultAsset);\n        _baseAssetDecimals = IERC20(_vaultAsset).decimals();\n\n        _symbol = ERC20(_vaultAsset).symbol();\n        _desc = ERC20(_vaultAsset).name();\n\n        _disableInitializers();\n    }\n\n    function initialize(\n        uint256 supplyLimit,\n        uint256 walletLimit,\n        string memory symbolSuffix,\n        string memory descPrefix,\n        bytes memory\n    ) public virtual initializer {\n        Errors.verifyNotEmpty(symbolSuffix, \"symbolSuffix\");\n        Errors.verifyNotEmpty(descPrefix, \"descPrefix\");\n\n        // init withdrawal queue to empty (slither issue)\n        withdrawalQueue = new IDestinationVault[](0);\n\n        navPerShareHighMarkTimestamp = block.timestamp;\n\n        _setTotalSupplyLimit(supplyLimit);\n        _setPerWalletLimit(walletLimit);\n\n        factory = msg.sender;\n\n        _symbol = symbolSuffix;\n        _desc = descPrefix;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override(ERC20, IERC20) returns (string memory) {\n        return string(abi.encodePacked(_desc, \" Pool Token\"));\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override(ERC20, IERC20) returns (string memory) {\n        return string(abi.encodePacked(\"lmp\", _symbol));\n    }\n\n    /// @inheritdoc IERC20\n    function decimals() public view virtual override(ERC20, IERC20) returns (uint8) {\n        return _baseAssetDecimals;\n    }\n\n    /// @notice Set the global share limit\n    /// @dev Zero is allowed here and used as a way to stop deposits but allow withdrawals\n    /// @param newSupplyLimit new total amount of shares allowed to be minted\n    function setTotalSupplyLimit(uint256 newSupplyLimit) external onlyOwner {\n        _setTotalSupplyLimit(newSupplyLimit);\n    }\n\n    /// @notice Set the per-wallet share limit\n    /// @param newWalletLimit new total shares a wallet is allowed to hold\n    function setPerWalletLimit(uint256 newWalletLimit) external onlyOwner {\n        _setPerWalletLimit(newWalletLimit);\n    }\n\n    /// @notice Set the fee that will be taken when profit is realized\n    /// @dev Resets the high water to current value\n    /// @param fee Percent. 100% == 10000\n    function setPerformanceFeeBps(uint256 fee) external nonReentrant hasRole(Roles.LMP_FEE_SETTER_ROLE) {\n        if (fee >= MAX_FEE_BPS) {\n            revert InvalidFee(fee);\n        }\n\n        performanceFeeBps = fee;\n\n        // Set the high mark when we change the fee so we aren't able to go farther back in\n        // time than one debt reporting and claim fee's against past profits\n        uint256 supply = totalSupply();\n        if (supply > 0) {\n            navPerShareHighMark = (totalAssets() * MAX_FEE_BPS) / supply;\n        } else {\n            // The default high mark is 1:1. We don't want to be able to take\n            // fee's before the first debt reporting\n            // Before a rebalance, everything will be in idle and we don't want to take\n            // fee's on pure idle\n            navPerShareHighMark = MAX_FEE_BPS;\n        }\n\n        emit PerformanceFeeSet(fee);\n    }\n\n    /// @notice Set the address that will receive fees\n    /// @param newFeeSink Address that will receive fees\n    function setFeeSink(address newFeeSink) external onlyOwner {\n        emit FeeSinkSet(newFeeSink);\n\n        // Zero is valid. One way to disable taking fees\n        // slither-disable-next-line missing-zero-check\n        feeSink = newFeeSink;\n    }\n\n    /// @notice Set the rewarder contract used by the vault\n    /// @dev Must be set immediately on initialization/creation and only once\n    function setRewarder(address _rewarder) external {\n        if (msg.sender != factory) {\n            revert Errors.AccessDenied();\n        }\n\n        Errors.verifyNotZero(_rewarder, \"rewarder\");\n\n        if (address(rewarder) != address(0)) {\n            revert RewarderAlreadySet();\n        }\n\n        rewarder = IMainRewarder(_rewarder);\n\n        emit RewarderSet(_rewarder);\n    }\n\n    /// @dev See {IERC4626-asset}.\n    function asset() public view virtual override returns (address) {\n        return address(_baseAsset);\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        return totalIdle + totalDebt;\n    }\n\n    /// @dev See {IERC4626-convertToShares}.\n    function convertToShares(uint256 assets) public view virtual returns (uint256 shares) {\n        shares = _convertToShares(assets, Math.Rounding.Down);\n    }\n\n    /// @dev See {IERC4626-convertToAssets}.\n    function convertToAssets(uint256 shares) public view virtual returns (uint256 assets) {\n        assets = _convertToAssets(shares, Math.Rounding.Down);\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    //\t\t\t\t\t\t\t\tDeposit\t\t\t\t\t\t\t\t//\n    //////////////////////////////////////////////////////////////////////\n\n    /// @dev See {IERC4626-maxDeposit}.\n    function maxDeposit(address wallet) public view virtual override returns (uint256 maxAssets) {\n        maxAssets = convertToAssets(_maxMint(wallet));\n    }\n\n    /// @dev See {IERC4626-previewDeposit}.\n    function previewDeposit(uint256 assets) public view virtual returns (uint256 shares) {\n        shares = _convertToShares(assets, Math.Rounding.Down);\n    }\n\n    function deposit(\n        uint256 assets,\n        address receiver\n    ) public virtual override nonReentrant noNavChange ensureNoNavOps returns (uint256 shares) {\n        Errors.verifyNotZero(assets, \"assets\");\n        if (assets > maxDeposit(receiver)) {\n            revert ERC4626DepositExceedsMax(assets, maxDeposit(receiver));\n        }\n\n        shares = previewDeposit(assets);\n\n        _transferAndMint(assets, shares, receiver);\n    }\n\n    /// @dev See {IERC4626-maxMint}.\n    function maxMint(address wallet) public view virtual override returns (uint256 maxShares) {\n        maxShares = _maxMint(wallet);\n    }\n\n    /// @dev See {IERC4626-maxWithdraw}.\n    function maxWithdraw(address owner) public view virtual returns (uint256 maxAssets) {\n        maxAssets = paused() ? 0 : previewRedeem(balanceOf(owner));\n    }\n\n    /// @dev See {IERC4626-maxRedeem}.\n    function maxRedeem(address owner) public view virtual returns (uint256 maxShares) {\n        maxShares = _maxRedeem(owner);\n    }\n\n    /// @dev See {IERC4626-previewMint}.\n    function previewMint(uint256 shares) public view virtual returns (uint256 assets) {\n        assets = _convertToAssets(shares, Math.Rounding.Up);\n    }\n\n    /// @dev See {IERC4626-previewWithdraw}.\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256 shares) {\n        shares = _convertToShares(assets, Math.Rounding.Up);\n    }\n\n    /// @dev See {IERC4626-previewRedeem}.\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Down);\n    }\n\n    /**\n     * @dev See {IERC4626-mint}.\n     *\n     * As opposed to {deposit}, minting is allowed even if the vault is in a state where the price of a share is zero.\n     * In this case, the shares will be minted without requiring any assets to be deposited.\n     */\n    function mint(\n        uint256 shares,\n        address receiver\n    ) public virtual override nonReentrant noNavChange ensureNoNavOps returns (uint256 assets) {\n        if (shares > maxMint(receiver)) {\n            revert ERC4626MintExceedsMax(shares, maxMint(receiver));\n        }\n\n        assets = previewMint(shares);\n\n        _transferAndMint(assets, shares, receiver);\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    //\t\t\t\t\t\t\t\tWithdraw\t\t\t\t\t\t\t//\n    //////////////////////////////////////////////////////////////////////\n\n    /// @dev See {IERC4626-withdraw}.\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override nonReentrant noNavDecrease ensureNoNavOps returns (uint256 shares) {\n        Errors.verifyNotZero(assets, \"assets\");\n        uint256 maxAssets = maxWithdraw(owner);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxWithdraw(owner, assets, maxAssets);\n        }\n\n        // query number of shares these assets match\n        shares = previewWithdraw(assets);\n\n        uint256 actualAssets = _withdraw(assets, shares, receiver, owner);\n\n        if (actualAssets < assets) {\n            revert TooFewAssets(assets, actualAssets);\n        }\n    }\n\n    /// @dev See {IERC4626-redeem}.\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override nonReentrant noNavDecrease ensureNoNavOps returns (uint256 assets) {\n        uint256 maxShares = maxRedeem(owner);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxRedeem(owner, shares, maxShares);\n        }\n        uint256 possibleAssets = previewRedeem(shares);\n\n        assets = _withdraw(possibleAssets, shares, receiver, owner);\n    }\n\n    function _calcUserWithdrawSharesToBurn(\n        IDestinationVault destVault,\n        uint256 userShares,\n        uint256 maxAssetsToPull,\n        uint256 totalVaultShares\n    ) internal returns (uint256 sharesToBurn, uint256 totalDebtBurn) {\n        (sharesToBurn, totalDebtBurn) = LMPDebt._calcUserWithdrawSharesToBurn(\n            destinationInfo[address(destVault)], destVault, userShares, maxAssetsToPull, totalVaultShares\n        );\n    }\n\n    // slither-disable-next-line cyclomatic-complexity\n    function _withdraw(\n        uint256 assets,\n        uint256 shares,\n        address receiver,\n        address owner\n    ) internal virtual returns (uint256) {\n        uint256 idle = totalIdle;\n        WithdrawInfo memory info = WithdrawInfo({\n            currentIdle: idle,\n            assetsFromIdle: assets >= idle ? idle : assets,\n            totalAssetsToPull: assets - (assets >= idle ? idle : assets),\n            totalAssetsPulled: 0,\n            idleIncrease: 0,\n            debtDecrease: 0\n        });\n\n        // If not enough funds in idle, then pull what we need from destinations\n        if (info.totalAssetsToPull > 0) {\n            uint256 totalVaultShares = totalSupply();\n\n            // Using pre-set withdrawalQueue for withdrawal order to help minimize user gas\n            uint256 withdrawalQueueLength = withdrawalQueue.length;\n            for (uint256 i = 0; i < withdrawalQueueLength; ++i) {\n                IDestinationVault destVault = IDestinationVault(withdrawalQueue[i]);\n                (uint256 sharesToBurn, uint256 totalDebtBurn) = _calcUserWithdrawSharesToBurn(\n                    destVault,\n                    shares,\n                    info.totalAssetsToPull - Math.max(info.debtDecrease, info.totalAssetsPulled),\n                    totalVaultShares\n                );\n                if (sharesToBurn == 0) {\n                    continue;\n                }\n\n                uint256 assetPreBal = _baseAsset.balanceOf(address(this));\n                uint256 assetPulled = destVault.withdrawBaseAsset(sharesToBurn, address(this));\n\n                // Destination Vault rewards will be transferred to us as part of burning out shares\n                // Back into what that amount is and make sure it gets into idle\n                info.idleIncrease += _baseAsset.balanceOf(address(this)) - assetPreBal - assetPulled;\n                info.totalAssetsPulled += assetPulled;\n                info.debtDecrease += totalDebtBurn;\n\n                // It's possible we'll get back more assets than we anticipate from a swap\n                // so if we do, throw it in idle and stop processing. You don't get more than we've calculated\n                if (info.totalAssetsPulled > info.totalAssetsToPull) {\n                    info.idleIncrease = info.totalAssetsPulled - info.totalAssetsToPull;\n                    info.totalAssetsPulled = info.totalAssetsToPull;\n                    break;\n                }\n\n                // No need to keep going if we have the amount we're looking for\n                // Any overage is accounted for above. Anything lower and we need to keep going\n                // slither-disable-next-line incorrect-equality\n                if (info.totalAssetsPulled == info.totalAssetsToPull) {\n                    break;\n                }\n            }\n        }\n\n        // At this point should have all the funds we need sitting in in the vault\n        uint256 returnedAssets = info.assetsFromIdle + info.totalAssetsPulled;\n\n        // subtract what's taken out of idle from totalIdle\n        // slither-disable-next-line events-maths\n        totalIdle = info.currentIdle + info.idleIncrease - info.assetsFromIdle;\n\n        if (info.debtDecrease > totalDebt) {\n            totalDebt = 0;\n        } else {\n            totalDebt -= info.debtDecrease;\n        }\n\n        // do the actual withdrawal (going off of total # requested)\n        uint256 allowed = allowance(owner, msg.sender);\n        if (msg.sender != owner && allowed != type(uint256).max) {\n            if (shares > allowed) revert AmountExceedsAllowance(shares, allowed);\n\n            unchecked {\n                _approve(owner, msg.sender, allowed - shares);\n            }\n        }\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, returnedAssets, shares);\n\n        _baseAsset.safeTransfer(receiver, returnedAssets);\n\n        return returnedAssets;\n    }\n\n    function claimRewards() public whenNotPaused {\n        rewarder.getReward(msg.sender, true);\n    }\n\n    /// @notice Transfer out non-tracked tokens\n    function recover(\n        address[] calldata tokens,\n        uint256[] calldata amounts,\n        address[] calldata _destinations\n    ) external virtual override hasRole(Roles.TOKEN_RECOVERY_ROLE) {\n        // Makes sure our params are valid\n        uint256 len = tokens.length;\n        if (len == 0) {\n            revert Errors.InvalidParams();\n        }\n        Errors.verifyArrayLengths(len, amounts.length, \"tokens+amounts\");\n        Errors.verifyArrayLengths(len, _destinations.length, \"tokens+_destinations\");\n\n        emit TokensRecovered(tokens, amounts, _destinations);\n\n        for (uint256 i = 0; i < len; ++i) {\n            (address tokenAddress, uint256 amount, address destination) = (tokens[i], amounts[i], _destinations[i]);\n\n            // Ensure this isn't an asset we care about\n            if (_isTrackedAsset(tokenAddress)) {\n                revert Errors.AssetNotAllowed(tokenAddress);\n            }\n\n            IERC20(tokenAddress).safeTransfer(destination, amount);\n        }\n    }\n\n    /// @inheritdoc ILMPVault\n    function shutdown() external onlyOwner {\n        _shutdown = true;\n\n        emit Shutdown();\n    }\n\n    /// @inheritdoc ILMPVault\n    function isShutdown() external view returns (bool) {\n        return _shutdown;\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\n     */\n    function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256 shares) {\n        uint256 supply = totalSupply();\n\n        // slither-disable-next-line incorrect-equality\n        shares = (assets == 0 || supply == 0) ? assets : assets.mulDiv(supply, totalAssets(), rounding);\n    }\n\n    /// @dev Internal conversion function (from shares to assets) with support for rounding direction.\n    function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        assets = (supply == 0) ? shares : shares.mulDiv(totalAssets(), supply, rounding);\n    }\n\n    function _maxRedeem(address owner) internal view virtual returns (uint256 maxShares) {\n        maxShares = paused() ? 0 : balanceOf(owner);\n    }\n\n    function _transferAndMint(uint256 assets, uint256 shares, address receiver) internal virtual {\n        // From OZ documentation:\n        // ----------------------\n        // If _asset is ERC777, `transferFrom` can trigger a reentrancy BEFORE the transfer happens through the\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\n        // assets are transferred and before the shares are minted, which is a valid state.\n        // slither-disable-next-line reentrancy-no-eth\n        _baseAsset.safeTransferFrom(msg.sender, address(this), assets);\n\n        totalIdle += assets;\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    ///@dev Checks if vault is \"healthy\" in the sense of having assets backing the circulating shares.\n    function _isVaultCollateralized() internal view returns (bool) {\n        return totalAssets() > 0 || totalSupply() == 0;\n    }\n\n    function updateDebtReporting(address[] calldata _destinations) external nonReentrant trackNavOps {\n        _updateDebtReporting(_destinations);\n    }\n\n    //////////////////////////////////////////////////////////////////////////\n    //\t\t\t\t\t\t\t  Destinations     \t\t\t\t\t\t\t//\n    //////////////////////////////////////////////////////////////////////////\n\n    function getDestinations() public view override returns (address[] memory) {\n        return destinations.values();\n    }\n\n    function isDestinationRegistered(address destination) external view returns (bool) {\n        return destinations.contains(destination);\n    }\n\n    function addDestinations(address[] calldata _destinations) public hasRole(Roles.DESTINATION_VAULTS_UPDATER) {\n        LMPDestinations.addDestinations(removalQueue, destinations, _destinations, systemRegistry);\n    }\n\n    function removeDestinations(address[] calldata _destinations) public hasRole(Roles.DESTINATION_VAULTS_UPDATER) {\n        LMPDestinations.removeDestinations(removalQueue, destinations, _destinations);\n    }\n\n    function getRemovalQueue() public view override returns (address[] memory) {\n        return removalQueue.values();\n    }\n\n    function removeFromRemovalQueue(address vaultToRemove) public override hasRole(Roles.REBALANCER_ROLE) {\n        LMPDestinations.removeFromRemovalQueue(removalQueue, vaultToRemove);\n    }\n\n    /// @dev Order is set as list of interfaces to minimize gas for our users\n    function setWithdrawalQueue(address[] calldata _destinations)\n        public\n        override\n        hasRole(Roles.SET_WITHDRAWAL_QUEUE_ROLE)\n    {\n        LMPDestinations.setWithdrawalQueue(withdrawalQueue, _destinations, systemRegistry);\n    }\n\n    /// @notice Get the current withdrawal queue\n    function getWithdrawalQueue() public view override returns (IDestinationVault[] memory withdrawalDestinations) {\n        return withdrawalQueue;\n    }\n\n    /// @notice Get the current snapshot debt info for a destination\n    function getDestinationInfo(address destVault)\n        external\n        view\n        nonReentrantReadOnly\n        returns (LMPDebt.DestinationInfo memory)\n    {\n        return destinationInfo[destVault];\n    }\n\n    //////////////////////////////////////////////////////////////////////////\n    //                                                                      //\n    //\t\t\t\t\t\t\tStrategy Related   \t\t\t\t\t\t\t//\n    //                                                                      //\n    //////////////////////////////////////////////////////////////////////////\n\n    /// @inheritdoc IStrategy\n    function rebalance(RebalanceParams memory params) public nonReentrant hasRole(Roles.SOLVER_ROLE) trackNavOps {\n        (uint256 idle, uint256 debt) = LMPDebt.rebalance(\n            destinationInfo[params.destinationOut],\n            destinationInfo[params.destinationIn],\n            params,\n            _baseAsset,\n            _shutdown,\n            totalIdle,\n            totalDebt\n        );\n        totalIdle = idle;\n        totalDebt = debt;\n        _collectFees(idle, debt, totalSupply());\n    }\n\n    /// @inheritdoc IStrategy\n    function flashRebalance(\n        IERC3156FlashBorrower receiver,\n        RebalanceParams memory rebalanceParams,\n        bytes calldata data\n    ) public nonReentrant hasRole(Roles.SOLVER_ROLE) trackNavOps {\n        (uint256 idle, uint256 debt) = LMPDebt.flashRebalance(\n            destinationInfo[rebalanceParams.destinationOut],\n            destinationInfo[rebalanceParams.destinationIn],\n            receiver,\n            rebalanceParams,\n            LMPDebt.FlashRebalanceParams({\n                totalIdle: totalIdle,\n                totalDebt: totalDebt,\n                baseAsset: _baseAsset,\n                shutdown: _shutdown\n            }),\n            data\n        );\n        totalIdle = idle;\n        totalDebt = debt;\n        _collectFees(idle, debt, totalSupply());\n    }\n\n    /// @inheritdoc IStrategy\n    function verifyRebalance(\n        address destinationIn,\n        address tokenIn,\n        uint256 amountIn,\n        address destinationOut,\n        address tokenOut,\n        uint256 amountOut\n    ) public view virtual returns (bool success, string memory message) {\n        (success, message) = LMPStrategy.verifyRebalance(\n            IStrategy.RebalanceParams({\n                destinationIn: destinationIn,\n                tokenIn: tokenIn,\n                amountIn: amountIn,\n                destinationOut: destinationOut,\n                tokenOut: tokenOut,\n                amountOut: amountOut\n            })\n        );\n    }\n\n    /// @notice Process the destinations calculating current value and snapshotting for safe deposit/mint'ing\n    function _updateDebtReporting(address[] memory _destinations) private {\n        uint256 nDest = _destinations.length;\n\n        uint256 idleIncrease = 0;\n        uint256 prevNTotalDebt = 0;\n        uint256 afterNTotalDebt = 0;\n\n        for (uint256 i = 0; i < nDest; ++i) {\n            IDestinationVault destVault = IDestinationVault(_destinations[i]);\n\n            if (!destinations.contains(address(destVault))) {\n                revert InvalidDestination(address(destVault));\n            }\n\n            // Get the reward value we've earned. DV rewards are always in terms of base asset\n            // We track the gas used purely for off-chain stats purposes\n            // Main rewarder on DV's store the earned and liquidated rewards\n            // Extra rewarders are disabled at the DV level\n            uint256 claimGasUsed = gasleft();\n            uint256 beforeBaseAsset = _baseAsset.balanceOf(address(this));\n            // We don't want any extras, those would likely not be baseAsset\n            IMainRewarder(destVault.rewarder()).getReward(address(this), false);\n            uint256 claimedRewardValue = _baseAsset.balanceOf(address(this)) - beforeBaseAsset;\n            claimGasUsed -= gasleft();\n            idleIncrease += claimedRewardValue;\n\n            // Recalculate the debt info figuring out the change in\n            // total debt value we can roll up later\n            uint256 currentShareBalance = destVault.balanceOf(address(this));\n            (uint256 totalDebtDecrease, uint256 totalDebtIncrease) = LMPDebt.recalculateDestInfo(\n                destinationInfo[address(destVault)], destVault, currentShareBalance, currentShareBalance, false\n            );\n            prevNTotalDebt += totalDebtDecrease;\n            afterNTotalDebt += totalDebtIncrease;\n\n            emit DestinationDebtReporting(address(destVault), totalDebtIncrease, claimedRewardValue, claimGasUsed);\n        }\n\n        // Persist our change in idle and debt\n        uint256 idle = totalIdle + idleIncrease;\n        uint256 debt = totalDebt - prevNTotalDebt + afterNTotalDebt;\n\n        totalIdle = idle;\n        totalDebt = debt;\n\n        _collectFees(idle, debt, totalSupply());\n    }\n\n    function _collectFees(uint256 idle, uint256 debt, uint256 totalSupply) internal {\n        address sink = feeSink;\n        uint256 fees = 0;\n        uint256 shares = 0;\n        uint256 profit = 0;\n\n        // If there's no supply then there should be no assets and so nothing\n        // to actually take fees on\n        if (totalSupply == 0) {\n            return;\n        }\n\n        uint256 currentNavPerShare = ((idle + debt) * MAX_FEE_BPS) / totalSupply;\n        uint256 effectiveNavPerShareHighMark = navPerShareHighMark;\n\n        if (currentNavPerShare > effectiveNavPerShareHighMark) {\n            // Even if we aren't going to take the fee (haven't set a sink)\n            // We still want to calculate so we can emit for off-chain analysis\n            profit = (currentNavPerShare - effectiveNavPerShareHighMark) * totalSupply;\n            fees = profit.mulDiv(performanceFeeBps, (MAX_FEE_BPS ** 2), Math.Rounding.Up);\n            if (fees > 0 && sink != address(0)) {\n                // Calculated separate from other mints as normal share mint is round down\n                shares = _convertToShares(fees, Math.Rounding.Up);\n                _mint(sink, shares);\n                emit Deposit(address(this), sink, fees, shares);\n            }\n            // Set our new high water mark, the last nav/share height we took fees\n            navPerShareHighMark = currentNavPerShare;\n            navPerShareHighMarkTimestamp = block.timestamp;\n            emit NewNavHighWatermark(currentNavPerShare, block.timestamp);\n        }\n        emit FeeCollected(fees, sink, shares, profit, idle, debt);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override whenNotPaused {\n        // Nothing to do really do here\n        if (from == to) {\n            return;\n        }\n\n        // If this isn't a mint of new tokens, then they are being transferred\n        // from someone who is \"staked\" in the rewarder. Make sure the"
    }
  ]
}