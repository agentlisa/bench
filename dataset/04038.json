{
  "Title": "[L08] Misleading comments",
  "Content": "The following comments are not accurate:\n\n\n* In the [constructor of the `ConfigStore` contract](https://github.com/UMAprotocol/protocol/blob/1631ef7ad29aaeba756ef3b9a01c667e1343df85/packages/core/contracts/financial-templates/perpetual-multiparty/ConfigStore.sol#L58), the comment says “New settings go into effect after a liveness period passes.” This could be confusing because the constructor directly sets the initial configuration, and the liveness period only applies to the following configuration changes.\n* In the [`_updateConfig` function of the same contract](https://github.com/UMAprotocol/protocol/blob/1631ef7ad29aaeba756ef3b9a01c667e1343df85/packages/core/contracts/financial-templates/perpetual-multiparty/ConfigStore.sol#L119), the comment says “If liveness has passed, publish new reward rate.” but the `proposerBondPct` and `timelockLiveness` might also have changed.\n* In the `setBond` functions of the [`OptimisticOracleInterface`](https://github.com/UMAprotocol/protocol/blob/1631ef7ad29aaeba756ef3b9a01c667e1343df85/packages/core/contracts/oracle/interfaces/OptimisticOracleInterface.sol#L60) and the [`OptimisticOracle` contract](https://github.com/UMAprotocol/protocol/blob/1631ef7ad29aaeba756ef3b9a01c667e1343df85/packages/core/contracts/oracle/implementation/OptimisticOracle.sol#L187), the comments say “Requests a new price.”, which is not what these functions do.\n* In the [`applyFundingRate` function of the `FundingRateApplier` contract](https://github.com/UMAprotocol/protocol/blob/1631ef7ad29aaeba756ef3b9a01c667e1343df85/packages/core/contracts/financial-templates/common/FundingRateApplier.sol#L127), the comment says “This method takes 4 distinct actions”, but then it only describes 3 actions.\n* In the [`transformPriceIdentifier` function of the `FinancialProductLibrary` contract](https://github.com/UMAprotocol/protocol/blob/1631ef7ad29aaeba756ef3b9a01c667e1343df85/packages/core/contracts/financial-templates/common/financial-product-libraries/FinancialProductLibrary.sol#L49), the comment refers to a `transformedCollateralRequirement` return value, but what is returned is the `priceIdentifier`.\n* In the [`fromUnscaledUint` function of the `FixedPoint` library](https://github.com/UMAprotocol/protocol/blob/6f8705782998f58e6120ed34e451c78292c7ac20/packages/core/contracts/common/implementation/FixedPoint.sol#L25), the comment says “`b=5` gets stored internally as `5**18`“, but it is stored as `5*(10**18)`.\n* In the [`transformPriceIdentifier` function of the `PreExpirationIdentifierTransformationFinancialProductLibrary` contract](https://github.com/UMAprotocol/protocol/blob/db64d02ec8a59bb9a16067fe8fce9fbb688d24fa/packages/core/contracts/financial-templates/common/financial-product-libraries/PreExpirationIdentifierTransformationFinancialProductLibrary.sol#L64), the comment says “Else, return the transformed price identifier.”, but what is returned is the untransformed price identifier.\n* In the [`repay` function of the `PerpetualPositionManager` contract](https://github.com/UMAprotocol/protocol/blob/1631ef7ad29aaeba756ef3b9a01c667e1343df85/packages/core/contracts/financial-templates/perpetual-multiparty/PerpetualPositionManager.sol#L423-L423), the comment says “numTokens is the number of tokens to be burnt for a commensurate amount of collateral” but the collateral is not refunded.\n\n\nThese comments could cause mistakes for developers relying on them instead of the implementation.\n\n\nConsider updating the misleading comments.\n\n\n**Update**: *Fixed in [PR#2308](https://github.com/UMAprotocol/protocol/pull/2308).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts/financial-templates/perpetual-multiparty/ConfigStore.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./ConfigStoreInterface.sol\";\nimport \"../../common/implementation/Testable.sol\";\nimport \"../../common/implementation/Lockable.sol\";\nimport \"../../common/implementation/FixedPoint.sol\";\n\n/**\n * @notice ConfigStore stores configuration settings for a perpetual contract and provides and interface for it\n * to query settings such as reward rates, proposal bond sizes, etc. The configuration settings can be upgraded\n * by a privileged account and the upgraded changes are timelocked.\n */\ncontract ConfigStore is ConfigStoreInterface, Testable, Lockable, Ownable {\n    using SafeMath for uint256;\n    using FixedPoint for FixedPoint.Unsigned;\n\n    /****************************************\n     *        STORE DATA STRUCTURES         *\n     ****************************************/\n\n    // Make currentConfig private to force user to call getCurrentConfig, which returns the pendingConfig\n    // if its liveness has expired.\n    ConfigStoreInterface.ConfigSettings private currentConfig;\n\n    // Beginning on `pendingPassedTimestamp`, the `pendingConfig` can be published as the current config.\n    ConfigStoreInterface.ConfigSettings public pendingConfig;\n    uint256 public pendingPassedTimestamp;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event ProposedNewConfigSettings(\n        address indexed proposer,\n        uint256 rewardRate,\n        uint256 proposerBond,\n        uint256 timelockLiveness,\n        uint256 proposalPassedTimestamp\n    );\n    event ChangedConfigSettings(uint256 rewardRate, uint256 proposerBond, uint256 timelockLiveness);\n\n    /****************************************\n     *                MODIFIERS             *\n     ****************************************/\n\n    // Update config settings if possible.\n    modifier updateConfig() {\n        _updateConfig();\n        _;\n    }\n\n    /**\n     * @notice Propose new configuration settings. New settings go into effect\n     * after a liveness period passes.\n     * @param _initialConfig Configuration settings to initialize `currentConfig` with.\n     * @param _timerAddress Address of testable Timer contract.\n     */\n    constructor(ConfigSettings memory _initialConfig, address _timerAddress) public Testable(_timerAddress) {\n        _validateConfig(_initialConfig);\n        currentConfig = _initialConfig;\n    }\n\n    /**\n     * @notice Returns current config or pending config if pending liveness has expired.\n     * @return ConfigSettings config settings that calling financial contract should view as \"live\".\n     */\n    function getCurrentConfig()\n        external\n        view\n        override\n        nonReentrantView()\n        returns (ConfigStoreInterface.ConfigSettings memory)\n    {\n        if (_pendingProposalPassed()) {\n            return pendingConfig;\n        } else {\n            return currentConfig;\n        }\n    }\n\n    /**\n     * @notice Propose new configuration settings. New settings go into effect\n     * after a liveness period passes.\n     * @param newConfig Configuration settings to publish after `currentConfig.timelockLiveness` passes from now.\n     * @dev Callable only by owner. Calling this while there is already a pending proposal\n     * will overwrite the pending proposal.\n     */\n    function proposeNewConfig(ConfigSettings memory newConfig) external onlyOwner() nonReentrant() updateConfig() {\n        _validateConfig(newConfig);\n\n        // Warning: This overwrites a pending proposal!\n        pendingConfig = newConfig;\n\n        // Use current config's liveness period to timelock this proposal.\n        pendingPassedTimestamp = getCurrentTime().add(currentConfig.timelockLiveness);\n\n        emit ProposedNewConfigSettings(\n            msg.sender,\n            newConfig.rewardRatePerSecond.rawValue,\n            newConfig.proposerBondPct.rawValue,\n            newConfig.timelockLiveness,\n            pendingPassedTimestamp\n        );\n    }\n\n    function publishPendingConfig() external nonReentrant() updateConfig() {}\n\n    /****************************************\n     *         INTERNAL FUNCTIONS           *\n     ****************************************/\n\n    // Check if pending proposal can overwrite the current config.\n    function _updateConfig() internal {\n        // If liveness has passed, publish new reward rate.\n        if (_pendingProposalPassed()) {\n            currentConfig = pendingConfig;\n\n            _deletePendingConfig();\n\n            emit ChangedConfigSettings(\n                currentConfig.rewardRatePerSecond.rawValue,\n                currentConfig.proposerBondPct.rawValue,\n                currentConfig.timelockLiveness\n            );\n        }\n    }\n\n    function _deletePendingConfig() internal {\n        delete pendingConfig;\n        pendingPassedTimestamp = 0;\n    }\n\n    function _pendingProposalPassed() internal view returns (bool) {\n        return (pendingPassedTimestamp != 0 && pendingPassedTimestamp <= getCurrentTime());\n    }\n\n    // Use this method to constrain values with which you can set ConfigSettings.\n    function _validateConfig(ConfigStoreInterface.ConfigSettings memory config) internal pure {\n        // Make sure timelockLiveness is not too long, otherwise contract can might not be able to fix itself\n        // before a vulnerability drains its collateral.\n        require(config.timelockLiveness <= 7 days && config.timelockLiveness >= 1 days, \"Invalid timelockLiveness\");\n\n        // Upper limits for the reward and bond rates are estimated based on offline discussions,\n        // and it is expected that these hard-coded limits can change in future deployments.\n        // For a discussion thread, go [here](https://github.com/UMAprotocol/protocol/pull/2223#discussion_r530692149).\n\n        // Proposer bond of 0.04% is based on a maximum expected funding rate error of 200%/year.\n        FixedPoint.Unsigned memory maxProposerBond = FixedPoint.fromUnscaledUint(4).div(1e4);\n        require(config.proposerBondPct.isLessThan(maxProposerBond), \"Invalid proposerBondPct\");\n\n        // Reward rate should be less than 100% a year => 100% / 360 days / 24 hours / 60 mins / 60 secs\n        // = 0.0000033\n        FixedPoint.Unsigned memory maxRewardRatePerSecond = FixedPoint.fromUnscaledUint(33).div(1e7);\n        require(config.rewardRatePerSecond.isLessThan(maxRewardRatePerSecond), \"Invalid rewardRatePerSecond\");\n    }\n}"
    },
    {
      "filename": "packages/core/contracts/financial-templates/perpetual-multiparty/ConfigStore.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./ConfigStoreInterface.sol\";\nimport \"../../common/implementation/Testable.sol\";\nimport \"../../common/implementation/Lockable.sol\";\nimport \"../../common/implementation/FixedPoint.sol\";\n\n/**\n * @notice ConfigStore stores configuration settings for a perpetual contract and provides and interface for it\n * to query settings such as reward rates, proposal bond sizes, etc. The configuration settings can be upgraded\n * by a privileged account and the upgraded changes are timelocked.\n */\ncontract ConfigStore is ConfigStoreInterface, Testable, Lockable, Ownable {\n    using SafeMath for uint256;\n    using FixedPoint for FixedPoint.Unsigned;\n\n    /****************************************\n     *        STORE DATA STRUCTURES         *\n     ****************************************/\n\n    // Make currentConfig private to force user to call getCurrentConfig, which returns the pendingConfig\n    // if its liveness has expired.\n    ConfigStoreInterface.ConfigSettings private currentConfig;\n\n    // Beginning on `pendingPassedTimestamp`, the `pendingConfig` can be published as the current config.\n    ConfigStoreInterface.ConfigSettings public pendingConfig;\n    uint256 public pendingPassedTimestamp;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event ProposedNewConfigSettings(\n        address indexed proposer,\n        uint256 rewardRate,\n        uint256 proposerBond,\n        uint256 timelockLiveness,\n        uint256 proposalPassedTimestamp\n    );\n    event ChangedConfigSettings(uint256 rewardRate, uint256 proposerBond, uint256 timelockLiveness);\n\n    /****************************************\n     *                MODIFIERS             *\n     ****************************************/\n\n    // Update config settings if possible.\n    modifier updateConfig() {\n        _updateConfig();\n        _;\n    }\n\n    /**\n     * @notice Propose new configuration settings. New settings go into effect\n     * after a liveness period passes.\n     * @param _initialConfig Configuration settings to initialize `currentConfig` with.\n     * @param _timerAddress Address of testable Timer contract.\n     */\n    constructor(ConfigSettings memory _initialConfig, address _timerAddress) public Testable(_timerAddress) {\n        _validateConfig(_initialConfig);\n        currentConfig = _initialConfig;\n    }\n\n    /**\n     * @notice Returns current config or pending config if pending liveness has expired.\n     * @return ConfigSettings config settings that calling financial contract should view as \"live\".\n     */\n    function getCurrentConfig()\n        external\n        view\n        override\n        nonReentrantView()\n        returns (ConfigStoreInterface.ConfigSettings memory)\n    {\n        if (_pendingProposalPassed()) {\n            return pendingConfig;\n        } else {\n            return currentConfig;\n        }\n    }\n\n    /**\n     * @notice Propose new configuration settings. New settings go into effect\n     * after a liveness period passes.\n     * @param newConfig Configuration settings to publish after `currentConfig.timelockLiveness` passes from now.\n     * @dev Callable only by owner. Calling this while there is already a pending proposal\n     * will overwrite the pending proposal.\n     */\n    function proposeNewConfig(ConfigSettings memory newConfig) external onlyOwner() nonReentrant() updateConfig() {\n        _validateConfig(newConfig);\n\n        // Warning: This overwrites a pending proposal!\n        pendingConfig = newConfig;\n\n        // Use current config's liveness period to timelock this proposal.\n        pendingPassedTimestamp = getCurrentTime().add(currentConfig.timelockLiveness);\n\n        emit ProposedNewConfigSettings(\n            msg.sender,\n            newConfig.rewardRatePerSecond.rawValue,\n            newConfig.proposerBondPct.rawValue,\n            newConfig.timelockLiveness,\n            pendingPassedTimestamp\n        );\n    }\n\n    function publishPendingConfig() external nonReentrant() updateConfig() {}\n\n    /****************************************\n     *         INTERNAL FUNCTIONS           *\n     ****************************************/\n\n    // Check if pending proposal can overwrite the current config.\n    function _updateConfig() internal {\n        // If liveness has passed, publish new reward rate.\n        if (_pendingProposalPassed()) {\n            currentConfig = pendingConfig;\n\n            _deletePendingConfig();\n\n            emit ChangedConfigSettings(\n                currentConfig.rewardRatePerSecond.rawValue,\n                currentConfig.proposerBondPct.rawValue,\n                currentConfig.timelockLiveness\n            );\n        }\n    }\n\n    function _deletePendingConfig() internal {\n        delete pendingConfig;\n        pendingPassedTimestamp = 0;\n    }\n\n    function _pendingProposalPassed() internal view returns (bool) {\n        return (pendingPassedTimestamp != 0 && pendingPassedTimestamp <= getCurrentTime());\n    }\n\n    // Use this method to constrain values with which you can set ConfigSettings.\n    function _validateConfig(ConfigStoreInterface.ConfigSettings memory config) internal pure {\n        // Make sure timelockLiveness is not too long, otherwise contract can might not be able to fix itself\n        // before a vulnerability drains its collateral.\n        require(config.timelockLiveness <= 7 days && config.timelockLiveness >= 1 days, \"Invalid timelockLiveness\");\n\n        // Upper limits for the reward and bond rates are estimated based on offline discussions,\n        // and it is expected that these hard-coded limits can change in future deployments.\n        // For a discussion thread, go [here](https://github.com/UMAprotocol/protocol/pull/2223#discussion_r530692149).\n\n        // Proposer bond of 0.04% is based on a maximum expected funding rate error of 200%/year.\n        FixedPoint.Unsigned memory maxProposerBond = FixedPoint.fromUnscaledUint(4).div(1e4);\n        require(config.proposerBondPct.isLessThan(maxProposerBond), \"Invalid proposerBondPct\");\n\n        // Reward rate should be less than 100% a year => 100% / 360 days / 24 hours / 60 mins / 60 secs\n        // = 0.0000033\n        FixedPoint.Unsigned memory maxRewardRatePerSecond = FixedPoint.fromUnscaledUint(33).div(1e7);\n        require(config.rewardRatePerSecond.isLessThan(maxRewardRatePerSecond), \"Invalid rewardRatePerSecond\");\n    }\n}"
    },
    {
      "filename": "packages/core/contracts/oracle/interfaces/OptimisticOracleInterface.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Financial contract facing Oracle interface.\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\n */\nabstract contract OptimisticOracleInterface {\n    // Struct representing the state of a price request.\n    enum State {\n        Invalid, // Never requested.\n        Requested, // Requested, no other actions taken.\n        Proposed, // Proposed, but not expired or disputed yet.\n        Expired, // Proposed, not disputed, past liveness.\n        Disputed, // Disputed, but no DVM price returned yet.\n        Resolved, // Disputed and DVM price is available.\n        Settled // Final price has been set in the contract (can get here from Expired or Resolved).\n    }\n\n    // Struct representing a price request.\n    struct Request {\n        address proposer; // Address of the proposer.\n        address disputer; // Address of the disputer.\n        IERC20 currency; // ERC20 token used to pay rewards and fees.\n        bool settled; // True if the request is settled.\n        bool refundOnDispute; // True if the requester should be refunded their reward on dispute.\n        int256 proposedPrice; // Price that the proposer submitted.\n        int256 resolvedPrice; // Price resolved once the request is settled.\n        uint256 expirationTime; // Time at which the request auto-settles without a dispute.\n        uint256 reward; // Amount of the currency to pay to the proposer on settlement.\n        uint256 finalFee; // Final fee to pay to the Store upon request to the DVM.\n        uint256 bond; // Bond that the proposer and disputer must pay on top of the final fee.\n        uint256 customLiveness; // Custom liveness value set by the requester.\n    }\n\n    /**\n     * @notice Requests a new price.\n     * @param identifier price identifier being requested.\n     * @param timestamp timestamp of the price being requested.\n     * @param ancillaryData ancillary data representing additional args being passed with the price request.\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\n     *               which could make sense if the contract requests and proposes the value in the same call or\n     *               provides its own reward system.\n     * @return totalBond default bond (final fee) + final fee that the proposer and disputer will be required to pay.\n     * This can be changed with a subsequent call to setBond().\n     */\n    function requestPrice(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        IERC20 currency,\n        uint256 reward\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Requests a new price.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identifiy the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param bond custom bond amount to set.\n     * @return totalBond new bond + final fee that the proposer and disputer will be required to pay. This can be\n     * changed again with a subsequent call to setBond().\n     */\n    function setBond(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        uint256 bond\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Sets the request to refund the reward if the proposal is disputed. This can help to \"hedge\" the caller\n     * in the event of a dispute-caused delay. Note: in the event of a dispute, the winner still receives the others'\n     * bond, so there is still profit to be made even if the reward is refunded.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identifiy the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     */\n    function setRefundOnDispute(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external virtual;\n\n    /**\n     * @notice Sets a custom liveness value for the request. Liveness is the amount of time a proposal must wait before\n     * being auto-resolved.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identifiy the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param customLiveness new custom liveness.\n     */\n    function setCustomLiveness(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        uint256 customLiveness\n    ) external virtual;\n\n    /**\n     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\n     * from this proposal. However, any bonds are pulled from the caller.\n     * @param proposer address to set as the proposer.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identifiy the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n    function proposePriceFor(\n        address proposer,\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        int256 proposedPrice\n    ) public virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Proposes a price value for an existing price request.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identifiy the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the proposer's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n    function proposePrice(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        int256 proposedPrice\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\n     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\n     * @param disputer address to set as the disputer.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identifiy the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the disputer once settled if the dispute was value (the proposal was incorrect).\n     */\n    function disputePriceFor(\n        address disputer,\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Disputes a price value for an existing price request with an active proposal.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identifiy the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return totalBond the amount that's pulled from the disputer's wallet as a bond. The bond will be returned to\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\n     */\n    function disputePrice(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Retrieves a price that was previously requested by a caller. Reverts if the request is not settled\n     * or settleable. Note: this method is not view so that this call may actually settle the price request if it\n     * hasn't been settled.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identifiy the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return resolved price.\n     */\n    function getPrice(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external virtual returns (int256);\n\n    /**\n     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identifiy the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\n     * the returned bonds as well as additional rewards.\n     */\n    function settle(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external virtual returns (uint256 payout);\n\n    /**\n     * @notice Gets the current data structure containing all information about a price request.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identifiy the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return the Request data structure.\n     */\n    function getRequest(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public view virtual returns (Request memory);\n\n    function getState(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public view virtual returns (State);\n\n    /**\n     * @notice Checks if a given request has resolved or been settled (i.e the optimistic oracle has a price).\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identifiy the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return the State.\n     */\n    function hasPrice(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public view virtual returns (bool);\n}"
    },
    {
      "filename": "packages/core/contracts/financial-templates/common/FundingRateApplier.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../../common/implementation/Lockable.sol\";\nimport \"../../common/implementation/FixedPoint.sol\";\nimport \"../../common/implementation/Testable.sol\";\n\nimport \"../../oracle/interfaces/StoreInterface.sol\";\nimport \"../../oracle/interfaces/FinderInterface.sol\";\nimport \"../../oracle/implementation/Constants.sol\";\n\n// TODO: point this at an interface instead.\nimport \"../../oracle/implementation/OptimisticOracle.sol\";\nimport \"../perpetual-multiparty/ConfigStoreInterface.sol\";\n\nimport \"./FeePayer.sol\";\n\n/**\n * @title FundingRateApplier contract.\n * @notice Provides funding rate payment functionality for the Perpetual contract.\n */\n\nabstract contract FundingRateApplier is FeePayer {\n    using FixedPoint for FixedPoint.Unsigned;\n    using FixedPoint for FixedPoint.Signed;\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /****************************************\n     * FUNDING RATE APPLIER DATA STRUCTURES *\n     ****************************************/\n\n    struct FundingRate {\n        // Current funding rate value.\n        FixedPoint.Signed rate;\n        // Identifier to retrieve the funding rate.\n        bytes32 identifier;\n        // Tracks the cumulative funding payments that have been paid to the sponsors.\n        // The multiplier starts at 1, and is updated by computing cumulativeFundingRateMultiplier * (1 + effectivePayment).\n        // Put another way, the cumulativeFeeMultiplier is (1 + effectivePayment1) * (1 + effectivePayment2) ...\n        // For example:\n        // The cumulativeFundingRateMultiplier should start at 1.\n        // If a 1% funding payment is paid to sponsors, the multiplier should update to 1.01.\n        // If another 1% fee is charged, the multiplier should be 1.01^2 (1.0201).\n        FixedPoint.Unsigned cumulativeMultiplier;\n        // Most recent time that the funding rate was updated.\n        uint256 updateTime;\n        // Most recent time that the funding rate was applied and changed the cumulative multiplier.\n        uint256 applicationTime;\n        // The time for the active (if it exists) funding rate proposal. 0 otherwise.\n        uint256 proposalTime;\n    }\n\n    FundingRate public fundingRate;\n\n    // Timestamp used in case of emergency shutdown. 0 if no shutdown has been triggered.\n    uint256 public emergencyShutdownTimestamp;\n\n    // Remote config store managed an owner.\n    ConfigStoreInterface public configStore;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event NewFundingRateMultiplier(\n        uint256 indexed newMultiplier,\n        uint256 lastApplicationTime,\n        uint256 applicationTime,\n        uint256 indexed paymentPeriod,\n        int256 indexed latestFundingRate,\n        int256 periodRate\n    );\n\n    /****************************************\n     *              MODIFIERS               *\n     ****************************************/\n\n    // This is overridden to both pay fees (which is done by applyFundingRate()) and apply the funding rate.\n    modifier fees override {\n        applyFundingRate();\n        _;\n    }\n\n    // Note: this modifier is intended to be used if the caller intends to _only_ pay regular fees.\n    modifier regularFees {\n        payRegularFees();\n        _;\n    }\n\n    /**\n     * @notice Constructs the FundingRateApplier contract. Called by child contracts.\n     * @param _fundingRateIdentifier identifier that tracks the funding rate of this contract.\n     * @param _collateralAddress address of the collateral token.\n     * @param _finderAddress Finder used to discover financial-product-related contracts.\n     * @param _configStoreAddress address of the remote configuration store managed by an external owner.\n     * @param _tokenScaling initial scaling to apply to the token value (i.e. scales the tracking index).\n     * @param _timerAddress address of the timer contract in test envs, otherwise 0x0.\n     */\n    constructor(\n        bytes32 _fundingRateIdentifier,\n        address _collateralAddress,\n        address _finderAddress,\n        address _configStoreAddress,\n        FixedPoint.Unsigned memory _tokenScaling,\n        address _timerAddress\n    ) public FeePayer(_collateralAddress, _finderAddress, _timerAddress) {\n        uint256 currentTime = getCurrentTime();\n        fundingRate.updateTime = currentTime;\n        fundingRate.applicationTime = currentTime;\n\n        // Seed the cumulative multiplier with the token scaling, from which it will be scaled as funding rates are\n        // applied over time.\n        fundingRate.cumulativeMultiplier = _tokenScaling;\n        emergencyShutdownTimestamp = 0;\n\n        fundingRate.identifier = _fundingRateIdentifier;\n        configStore = ConfigStoreInterface(_configStoreAddress);\n    }\n\n    /**\n     * @notice This method takes 4 distinct actions:\n     *\n     * 1. Pays out regular fees.\n     *\n     * 2. If possible, resolves the outstanding funding rate proposal, pulling the result in and paying out the\n     *    rewards.\n     *\n     * 3. Applies the prevailing funding rate over the most recent period.\n     */\n    function applyFundingRate() public regularFees() nonReentrant() {\n        _applyEffectiveFundingRate();\n    }\n\n    /**\n     * @notice Proposes a new funding rate. Proposer receives a reward if correct.\n     * @param rate funding rate to being proposed.\n     * @param timestamp time at which the funding rate was computed.\n     */\n    function proposeNewRate(FixedPoint.Signed memory rate, uint256 timestamp)\n        external\n        fees()\n        nonReentrant()\n        returns (FixedPoint.Unsigned memory totalBond)\n    {\n        require(fundingRate.proposalTime == 0, \"Proposal in progress\");\n\n        // Timestamp must be after the last funding rate update time, within the last 30 minutes, and it cannot be more\n        // than 90 seconds ahead of the block timestamp.\n        uint256 currentTime = getCurrentTime();\n        uint256 updateTime = fundingRate.updateTime;\n        require(\n            timestamp > updateTime && timestamp >= currentTime.sub(30 minutes) && timestamp <= currentTime.add(90),\n            \"Invalid proposal time\"\n        );\n\n        // Set the proposal time in order to allow this contract to track this request.\n        fundingRate.proposalTime = timestamp;\n\n        OptimisticOracle optimisticOracle = _getOptimisticOracle();\n\n        // Set up optimistic oracle.\n        bytes32 identifier = fundingRate.identifier;\n        bytes memory ancillaryData = _getAncillaryData();\n        optimisticOracle.requestPrice(identifier, timestamp, ancillaryData, collateralCurrency, 0);\n        totalBond = FixedPoint.Unsigned(\n            optimisticOracle.setBond(\n                identifier,\n                timestamp,\n                ancillaryData,\n                _pfc().mul(_getConfig().proposerBondPct).rawValue\n            )\n        );\n\n        // Pull bond from caller and send to optimistic oracle.\n        if (totalBond.isGreaterThan(0)) {\n            collateralCurrency.safeTransferFrom(msg.sender, address(this), totalBond.rawValue);\n            collateralCurrency.safeIncreaseAllowance(address(optimisticOracle), totalBond.rawValue);\n        }\n\n        optimisticOracle.proposePriceFor(\n            msg.sender,\n            address(this),\n            identifier,\n            timestamp,\n            ancillaryData,\n            rate.rawValue\n        );\n    }\n\n    // Returns a token amount scaled by the curre"
    }
  ]
}