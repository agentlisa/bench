{
  "Title": "M-2: In case if trading fee will be changed then refund will be done with wrong amount",
  "Content": "# Issue M-2: In case if trading fee will be changed then refund will be done with wrong amount \n\nSource: https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/92 \n\n## Found by \n0xcrunch, Jiamin, Juntao, Lilyjjo, circlelooper, libratus, mstpr-brainbot, nobody2018, rvierdiiev, xiaoming90\n## Summary\nIn case if trading fee will be changed then refund will be done with wrong amount \n## Vulnerability Detail\nWhen user creates quote, then he [pays trading fees](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol#L119). Amount that should be paid is calculated [inside `LibQuote.getTradingFee` function](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/libraries/LibQuote.sol#L144).\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/libraries/LibQuote.sol#L122-L133\n```soldity\n    function getTradingFee(uint256 quoteId) internal view returns (uint256 fee) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        Symbol storage symbol = SymbolStorage.layout().symbols[quote.symbolId];\n        if (quote.orderType == OrderType.LIMIT) {\n            fee =\n                (LibQuote.quoteOpenAmount(quote) * quote.requestedOpenPrice * symbol.tradingFee) /\n                1e36;\n        } else {\n            fee = (LibQuote.quoteOpenAmount(quote) * quote.marketPrice * symbol.tradingFee) / 1e36;\n        }\n    }\n```\n\nAs you can see `symbol.tradingFee` is used to determine fee amount. This fee [can be changed any time](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/control/ControlFacet.sol#L164-L172).\n\nWhen order is canceled, then [fee should be returned to user](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol#L136). This function also uses [`LibQuote.getTradingFee` function](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/libraries/LibQuote.sol#L137) to calculate fee to return.\n\nSo in case if order was created before fee changes, then returned amount will be not same, when it is canceled after fee changes.\n## Impact\nUser or protocol losses portion of funds.\n## Code Snippet\nProvided above\n## Tool used\n\nManual Review\n\n## Recommendation\nYou can store fee paid by user inside quote struct. And when canceled return that amount.\n\n\n\n## Discussion\n\n**MoonKnightDev**\n\nFixed code PR link:\nhttps://github.com/SYMM-IO/symmio-core/pull/8\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/85",
  "Code": [
    {
      "filename": "symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibSolvency.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary PartyAFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function sendQuote(\n        address[] memory partyBsWhiteList,\n        uint256 symbolId,\n        PositionType positionType,\n        OrderType orderType,\n        uint256 price,\n        uint256 quantity,\n        uint256 cva,\n        uint256 mm,\n        uint256 lf,\n        uint256 maxInterestRate,\n        uint256 deadline,\n        SingleUpnlAndPriceSig memory upnlSig\n    ) internal returns (uint256 currentId) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n\n        require(\n            quoteLayout.partyAPendingQuotes[msg.sender].length < maLayout.pendingQuotesValidLength,\n            \"PartyAFacet: Number of pending quotes out of range\"\n        );\n        require(symbolLayout.symbols[symbolId].isValid, \"PartyAFacet: Symbol is not valid\");\n        require(deadline >= block.timestamp, \"PartyAFacet: Low deadline\");\n\n        LockedValues memory lockedValues = LockedValues(cva, mm, lf);\n        uint256 tradingPrice = orderType == OrderType.LIMIT ? price : upnlSig.price;\n        uint256 notionalValue = (quantity * tradingPrice) / 1e18;\n        require(\n            lockedValues.total() <= notionalValue,\n            \"PartyAFacet: Leverage can't be lower than one\"\n        );\n\n        require(\n            lockedValues.lf >=\n                (symbolLayout.symbols[symbolId].minAcceptablePortionLF * lockedValues.total()) /\n                    1e18,\n            \"PartyAFacet: LF is not enough\"\n        );\n\n        require(\n            lockedValues.total() >= symbolLayout.symbols[symbolId].minAcceptableQuoteValue,\n            \"PartyAFacet: Quote value is low\"\n        );\n        for (uint8 i = 0; i < partyBsWhiteList.length; i++) {\n            require(\n                partyBsWhiteList[i] != msg.sender,\n                \"PartyAFacet: Sender isn't allowed in partyBWhiteList\"\n            );\n        }\n\n        LibMuon.verifyPartyAUpnlAndPrice(upnlSig, msg.sender, symbolId);\n\n        int256 availableBalance = LibAccount.partyAAvailableForQuote(upnlSig.upnl, msg.sender);\n        require(availableBalance > 0, \"PartyAFacet: Available balance is lower than zero\");\n        require(\n            uint256(availableBalance) >=\n                lockedValues.total() +\n                    ((quantity * tradingPrice * symbolLayout.symbols[symbolId].tradingFee) / 1e36),\n            \"PartyAFacet: insufficient available balance\"\n        );\n\n        // lock funds the in middle of way\n        accountLayout.pendingLockedBalances[msg.sender].add(lockedValues);\n        currentId = ++quoteLayout.lastId;\n        accountLayout.partyANonces[msg.sender] += 1;\n\n        // create quote.\n        Quote memory quote = Quote({\n            id: currentId,\n            partyBsWhiteList: partyBsWhiteList,\n            symbolId: symbolId,\n            positionType: positionType,\n            orderType: orderType,\n            openedPrice: 0,\n            requestedOpenPrice: price,\n            marketPrice: upnlSig.price,\n            quantity: quantity,\n            closedAmount: 0,\n            lockedValues: lockedValues,\n            initialLockedValues: lockedValues,\n            maxInterestRate: maxInterestRate,\n            partyA: msg.sender,\n            partyB: address(0),\n            quoteStatus: QuoteStatus.PENDING,\n            avgClosedPrice: 0,\n            requestedClosePrice: 0,\n            parentId: 0,\n            createTimestamp: block.timestamp,\n            modifyTimestamp: block.timestamp,\n            quantityToClose: 0,\n            deadline: deadline\n        });\n        quoteLayout.quoteIdsOf[msg.sender].push(currentId);\n        quoteLayout.partyAPendingQuotes[msg.sender].push(currentId);\n        quoteLayout.quotes[currentId] = quote;\n\n        LibQuote.receiveTradingFee(currentId);\n    }\n\n    function requestToCancelQuote(uint256 quoteId) internal returns (QuoteStatus result) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(\n            quote.quoteStatus == QuoteStatus.PENDING || quote.quoteStatus == QuoteStatus.LOCKED,\n            \"PartyAFacet: Invalid state\"\n        );\n        accountLayout.partyANonces[quote.partyA] += 1;\n\n        if (block.timestamp > quote.deadline) {\n            result = LibQuote.expireQuote(quoteId);\n        } else if (quote.quoteStatus == QuoteStatus.PENDING) {\n            quote.quoteStatus = QuoteStatus.CANCELED;\n            LibQuote.returnTradingFee(quoteId);\n            accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n            LibQuote.removeFromPartyAPendingQuotes(quote);\n            result = QuoteStatus.CANCELED;\n        } else {\n            // Quote is locked\n            quote.quoteStatus = QuoteStatus.CANCEL_PENDING;\n            result = QuoteStatus.CANCEL_PENDING;\n        }\n        quote.modifyTimestamp = block.timestamp;\n    }\n\n    function requestToClosePosition(\n        uint256 quoteId,\n        uint256 closePrice,\n        uint256 quantityToClose,\n        OrderType orderType,\n        uint256 deadline,\n        SingleUpnlAndPriceSig memory upnlSig\n    ) internal {\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(quote.quoteStatus == QuoteStatus.OPENED, \"PartyAFacet: Invalid state\");\n        require(deadline >= block.timestamp, \"PartyAFacet: Low deadline\");\n        require(\n            LibQuote.quoteOpenAmount(quote) >= quantityToClose,\n            \"PartyAFacet: Invalid quantityToClose\"\n        );\n        LibMuon.verifyPartyAUpnlAndPrice(upnlSig, quote.partyA, quote.symbolId);\n        LibSolvency.isSolventAfterRequestToClosePosition(\n            quoteId,\n            closePrice,\n            quantityToClose,\n            upnlSig\n        );\n\n        // check that remaining position is not too small\n        if (LibQuote.quoteOpenAmount(quote) > quantityToClose) {\n            require(\n                ((LibQuote.quoteOpenAmount(quote) - quantityToClose) * quote.lockedValues.total()) /\n                    LibQuote.quoteOpenAmount(quote) >=\n                    symbolLayout.symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"PartyAFacet: Remaining quote value is low\"\n            );\n        }\n\n        accountLayout.partyANonces[quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.CLOSE_PENDING;\n        quote.requestedClosePrice = closePrice;\n        quote.quantityToClose = quantityToClose;\n        quote.orderType = orderType;\n        quote.deadline = deadline;\n    }\n\n    function requestToCancelCloseRequest(uint256 quoteId) internal returns (QuoteStatus) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(quote.quoteStatus == QuoteStatus.CLOSE_PENDING, \"PartyAFacet: Invalid state\");\n        if (block.timestamp > quote.deadline) {\n            LibQuote.expireQuote(quoteId);\n            return QuoteStatus.OPENED;\n        } else {\n            accountLayout.partyANonces[quote.partyA] += 1;\n            quote.modifyTimestamp = block.timestamp;\n            quote.quoteStatus = QuoteStatus.CANCEL_CLOSE_PENDING;\n            return QuoteStatus.CANCEL_CLOSE_PENDING;\n        }\n    }\n\n    function forceCancelQuote(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(quote.quoteStatus == QuoteStatus.CANCEL_PENDING, \"PartyAFacet: Invalid state\");\n        require(\n            block.timestamp > quote.modifyTimestamp + maLayout.forceCancelCooldown,\n            \"PartyAFacet: Cooldown not reached\"\n        );\n        accountLayout.partyANonces[quote.partyA] += 1;\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.CANCELED;\n        accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n        accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n\n        // send trading Fee back to partyA\n        LibQuote.returnTradingFee(quoteId);\n\n        LibQuote.removeFromPendingQuotes(quote);\n    }\n\n    function forceCancelCloseRequest(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"PartyAFacet: Invalid state\"\n        );\n        require(\n            block.timestamp > quote.modifyTimestamp + maLayout.forceCancelCloseCooldown,\n            \"PartyAFacet: Cooldown not reached\"\n        );\n\n        accountLayout.partyANonces[quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.OPENED;\n        quote.requestedClosePrice = 0;\n        quote.quantityToClose = 0;\n    }\n\n    function forceClosePosition(uint256 quoteId, PairUpnlAndPriceSig memory upnlSig) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        uint256 filledAmount = quote.quantityToClose;\n        require(quote.quoteStatus == QuoteStatus.CLOSE_PENDING, \"PartyAFacet: Invalid state\");\n        require(\n            block.timestamp > quote.modifyTimestamp + maLayout.forceCloseCooldown,\n            \"PartyAFacet: Cooldown not reached\"\n        );\n        require(block.timestamp <= quote.deadline, \"PartyBFacet: Quote is expired\");\n        require(\n            quote.orderType == OrderType.LIMIT,\n            \"PartyBFacet: Quote's order type should be LIMIT\"\n        );\n        if (quote.positionType == PositionType.LONG) {\n            require(\n                upnlSig.price >=\n                    quote.requestedClosePrice +\n                        (quote.requestedClosePrice * maLayout.forceCloseGapRatio) /\n                        1e18,\n                \"PartyAFacet: Requested close price not reached\"\n            );\n        } else {\n            require(\n                upnlSig.price <=\n                    quote.requestedClosePrice -\n                        (quote.requestedClosePrice * maLayout.forceCloseGapRatio) /\n                        1e18,\n                \"PartyAFacet: Requested close price not reached\"\n            );\n        }\n\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n        LibSolvency.isSolventAfterClosePosition(\n            quoteId,\n            filledAmount,\n            quote.requestedClosePrice,\n            upnlSig\n        );\n        accountLayout.partyANonces[quote.partyA] += 1;\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        LibQuote.closeQuote(quote, filledAmount, quote.requestedClosePrice);\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/libraries/LibQuote.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"./LibLockedValues.sol\";\nimport \"../storages/QuoteStorage.sol\";\nimport \"../storages/AccountStorage.sol\";\nimport \"../storages/GlobalAppStorage.sol\";\nimport \"../storages/SymbolStorage.sol\";\nimport \"../storages/MAStorage.sol\";\n\nlibrary LibQuote {\n    using LockedValuesOps for LockedValues;\n\n    function getAmountToLockOfQuote(Quote storage quote) internal view returns (uint256) {\n        return quote.lockedValues.total();\n    }\n\n    function quoteOpenAmount(Quote storage quote) internal view returns (uint256) {\n        return quote.quantity - quote.closedAmount;\n    }\n\n    function getIndexOfItem(\n        uint256[] storage array_,\n        uint256 item\n    ) internal view returns (uint256) {\n        for (uint256 index = 0; index < array_.length; index++) {\n            if (array_[index] == item) return index;\n        }\n        return type(uint256).max;\n    }\n\n    function removeFromArray(uint256[] storage array_, uint256 item) internal {\n        uint256 index = getIndexOfItem(array_, item);\n        require(index != type(uint256).max, \"LibQuote: Item not Found\");\n        array_[index] = array_[array_.length - 1];\n        array_.pop();\n    }\n\n    function removeFromPartyAPendingQuotes(Quote storage quote) internal {\n        removeFromArray(QuoteStorage.layout().partyAPendingQuotes[quote.partyA], quote.id);\n    }\n\n    function removeFromPartyBPendingQuotes(Quote storage quote) internal {\n        removeFromArray(\n            QuoteStorage.layout().partyBPendingQuotes[quote.partyB][quote.partyA],\n            quote.id\n        );\n    }\n\n    function removeFromPendingQuotes(Quote storage quote) internal {\n        removeFromPartyAPendingQuotes(quote);\n        removeFromPartyBPendingQuotes(quote);\n    }\n\n    function addToOpenPositions(uint256 quoteId) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n\n        quoteLayout.partyAOpenPositions[quote.partyA].push(quote.id);\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA].push(quote.id);\n\n        quoteLayout.partyAPositionsIndex[quote.id] = quoteLayout.partyAPositionsCount[quote.partyA];\n        quoteLayout.partyBPositionsIndex[quote.id] = quoteLayout.partyBPositionsCount[quote.partyB][\n            quote.partyA\n        ];\n\n        quoteLayout.partyAPositionsCount[quote.partyA] += 1;\n        quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] += 1;\n    }\n\n    function removeFromOpenPositions(uint256 quoteId) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        uint256 indexOfPartyAPosition = quoteLayout.partyAPositionsIndex[quote.id];\n        uint256 indexOfPartyBPosition = quoteLayout.partyBPositionsIndex[quote.id];\n        uint256 lastOpenPositionIndex = quoteLayout.partyAPositionsCount[quote.partyA] - 1;\n        quoteLayout.partyAOpenPositions[quote.partyA][indexOfPartyAPosition] = quoteLayout\n            .partyAOpenPositions[quote.partyA][lastOpenPositionIndex];\n        quoteLayout.partyAPositionsIndex[\n            quoteLayout.partyAOpenPositions[quote.partyA][lastOpenPositionIndex]\n        ] = indexOfPartyAPosition;\n        quoteLayout.partyAOpenPositions[quote.partyA].pop();\n\n        lastOpenPositionIndex = quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] - 1;\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][\n            indexOfPartyBPosition\n        ] = quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][lastOpenPositionIndex];\n        quoteLayout.partyBPositionsIndex[\n            quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][lastOpenPositionIndex]\n        ] = indexOfPartyBPosition;\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA].pop();\n\n        quoteLayout.partyAPositionsIndex[quote.id] = 0;\n        quoteLayout.partyBPositionsIndex[quote.id] = 0;\n    }\n\n    function getValueOfQuoteForPartyA(\n        uint256 currentPrice,\n        uint256 filledAmount,\n        Quote storage quote\n    ) internal view returns (bool hasMadeProfit, uint256 pnl) {\n        if (currentPrice > quote.openedPrice) {\n            if (quote.positionType == PositionType.LONG) {\n                hasMadeProfit = true;\n            } else {\n                hasMadeProfit = false;\n            }\n            pnl = ((currentPrice - quote.openedPrice) * filledAmount) / 1e18;\n        } else {\n            if (quote.positionType == PositionType.LONG) {\n                hasMadeProfit = false;\n            } else {\n                hasMadeProfit = true;\n            }\n            pnl = ((quote.openedPrice - currentPrice) * filledAmount) / 1e18;\n        }\n    }\n\n    function getTradingFee(uint256 quoteId) internal view returns (uint256 fee) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        Symbol storage symbol = SymbolStorage.layout().symbols[quote.symbolId];\n        if (quote.orderType == OrderType.LIMIT) {\n            fee =\n                (LibQuote.quoteOpenAmount(quote) * quote.requestedOpenPrice * symbol.tradingFee) /\n                1e36;\n        } else {\n            fee = (LibQuote.quoteOpenAmount(quote) * quote.marketPrice * symbol.tradingFee) / 1e36;\n        }\n    }\n\n    function returnTradingFee(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        uint256 tradingFee = LibQuote.getTradingFee(quoteId);\n        accountLayout.allocatedBalances[QuoteStorage.layout().quotes[quoteId].partyA] += tradingFee;\n        accountLayout.balances[GlobalAppStorage.layout().feeCollector] -= tradingFee;\n    }\n\n    function receiveTradingFee(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        uint256 tradingFee = LibQuote.getTradingFee(quoteId);\n        accountLayout.allocatedBalances[QuoteStorage.layout().quotes[quoteId].partyA] -= tradingFee;\n        accountLayout.balances[GlobalAppStorage.layout().feeCollector] += tradingFee;\n    }\n\n    function closeQuote(Quote storage quote, uint256 filledAmount, uint256 closedPrice) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        quote.modifyTimestamp = block.timestamp;\n\n        LockedValues memory lockedValues = LockedValues(\n            quote.lockedValues.cva -\n                ((quote.lockedValues.cva * filledAmount) / (LibQuote.quoteOpenAmount(quote))),\n            quote.lockedValues.mm -\n                ((quote.lockedValues.mm * filledAmount) / (LibQuote.quoteOpenAmount(quote))),\n            quote.lockedValues.lf -\n                ((quote.lockedValues.lf * filledAmount) / (LibQuote.quoteOpenAmount(quote)))\n        );\n        accountLayout.lockedBalances[quote.partyA].subQuote(quote).add(lockedValues);\n        accountLayout.partyBLockedBalances[quote.partyB][quote.partyA].subQuote(quote).add(\n            lockedValues\n        );\n        quote.lockedValues = lockedValues;\n\n        (bool hasMadeProfit, uint256 pnl) = LibQuote.getValueOfQuoteForPartyA(\n            closedPrice,\n            filledAmount,\n            quote\n        );\n        if (hasMadeProfit) {\n            accountLayout.allocatedBalances[quote.partyA] += pnl;\n            accountLayout.partyBAllocatedBalances[quote.partyB][quote.partyA] -= pnl;\n        } else {\n            accountLayout.allocatedBalances[quote.partyA] -= pnl;\n            accountLayout.partyBAllocatedBalances[quote.partyB][quote.partyA] += pnl;\n        }\n\n        quote.avgClosedPrice =\n            (quote.avgClosedPrice * quote.closedAmount + filledAmount * closedPrice) /\n            (quote.closedAmount + filledAmount);\n\n        quote.closedAmount += filledAmount;\n        quote.quantityToClose -= filledAmount;\n\n        if (quote.closedAmount == quote.quantity) {\n            quote.quoteStatus = QuoteStatus.CLOSED;\n            quote.requestedClosePrice = 0;\n            removeFromOpenPositions(quote.id);\n            quoteLayout.partyAPositionsCount[quote.partyA] -= 1;\n            quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] -= 1;\n        } else if (\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING || quote.quantityToClose == 0\n        ) {\n            quote.quoteStatus = QuoteStatus.OPENED;\n            quote.requestedClosePrice = 0;\n            quote.quantityToClose = 0; // for CANCEL_CLOSE_PENDING status\n        } else {\n            require(\n                quote.lockedValues.total() >=\n                    SymbolStorage.layout().symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"LibQuote: Remaining quote value is low\"\n            );\n        }\n    }\n\n    function expireQuote(uint256 quoteId) internal returns (QuoteStatus result) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        require(block.timestamp > quote.deadline, \"LibQuote: Quote isn't expired\");\n        require(\n            quote.quoteStatus == QuoteStatus.PENDING ||\n                quote.quoteStatus == QuoteStatus.CANCEL_PENDING ||\n                quote.quoteStatus == QuoteStatus.LOCKED ||\n                quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n                quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"LibQuote: Invalid state\"\n        );\n        require(\n            !MAStorage.layout().liquidationStatus[quote.partyA],\n            \"LibQuote: PartyA isn't solvent\"\n        );\n        require(\n            !MAStorage.layout().partyBLiquidationStatus[quote.partyB][quote.partyA],\n            \"LibQuote: PartyB isn't solvent\"\n        );\n        if (\n            quote.quoteStatus == QuoteStatus.PENDING ||\n            quote.quoteStatus == QuoteStatus.LOCKED ||\n            quote.quoteStatus == QuoteStatus.CANCEL_PENDING\n        ) {\n            quote.modifyTimestamp = block.timestamp;\n            accountLayout.partyANonces[quote.partyA] += 1;\n            accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n            // send trading Fee back to partyA\n            LibQuote.returnTradingFee(quoteId);\n            removeFromPartyAPendingQuotes(quote);\n            if (\n                quote.quoteStatus == QuoteStatus.LOCKED ||\n                quote.quoteStatus == QuoteStatus.CANCEL_PENDING\n            ) {\n                accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n                accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(\n                    quote\n                );\n                removeFromPartyBPendingQuotes(quote);\n            }\n            quote.quoteStatus = QuoteStatus.EXPIRED;\n            result = QuoteStatus.EXPIRED;\n        } else if (\n            quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING\n        ) {\n            quote.modifyTimestamp = block.timestamp;\n            accountLayout.partyANonces[quote.partyA] += 1;\n            accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n            quote.requestedClosePrice = 0;\n            quote.quantityToClose = 0;\n            quote.quoteStatus = QuoteStatus.OPENED;\n            result = QuoteStatus.OPENED;\n        }\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/facets/control/ControlFacet.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../utils/Ownable.sol\";\nimport \"../../utils/Accessibility.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/GlobalAppStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\nimport \"./IControlEvents.sol\";\n\ncontract ControlFacet is Accessibility, Ownable, IControlEvents {\n    // Just For Testnet\n    function init(address user, address collateral, address feeCollector) external onlyOwner {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        GlobalAppStorage.Layout storage appLayout = GlobalAppStorage.layout();\n\n        appLayout.collateral = collateral;\n        appLayout.balanceLimitPerUser = 500e18;\n        appLayout.feeCollector = feeCollector;\n        maLayout.deallocateCooldown = 300;\n        maLayout.forceCancelCooldown = 3000000000000000;\n        maLayout.forceCloseCooldown = 3000000000000000;\n        maLayout.forceCancelCloseCooldown = 3000000000000000;\n        maLayout.pendingQuotesValidLength = 15;\n        maLayout.liquidatorShare = 80e16;\n        maLayout.liquidationTimeout = 600;\n        appLayout.hasRole[user][LibAccessibility.DEFAULT_ADMIN_ROLE] = true;\n        appLayout.hasRole[user][LibAccessibility.SYMBOL_MANAGER_ROLE] = true;\n        appLayout.hasRole[user][LibAccessibility.MUON_SETTER_ROLE] = true;\n        appLayout.hasRole[user][LibAccessibility.SETTER_ROLE] = true;\n        appLayout.hasRole[user][LibAccessibility.PARTY_B_MANAGER_ROLE] = true;\n    }\n\n    function setAdmin(address user) external onlyOwner {\n        GlobalAppStorage.layout().hasRole[user][LibAccessibility.DEFAULT_ADMIN_ROLE] = true;\n        emit RoleGranted(LibAccessibility.DEFAULT_ADMIN_ROLE, user);\n    }\n\n    function grantRole(\n        address user,\n        bytes32 role\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        GlobalAppStorage.layout().hasRole[user][role] = true;\n        emit RoleGranted(role, user);\n    }\n\n    function revokeRole(\n        address user,\n        bytes32 role\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        GlobalAppStorage.layout().hasRole[user][role] = false;\n        emit RoleRevoked(role, user);\n    }\n\n    function registerPartyB(\n        address partyB\n    ) external onlyRole(LibAccessibility.PARTY_B_MANAGER_ROLE) {\n        require(\n            !MAStorage.layout().partyBStatus[partyB],\n            \"ControlFacet: Address is already registered\"\n        );\n        MAStorage.layout().partyBStatus[partyB] = true;\n        MAStorage.layout().partyBList.push(partyB);\n        emit RegisterPartyB(partyB);\n    }\n\n    function setMuonConfig(\n        uint256 upnlValidTime,\n        uint256 priceValidTime,\n        uint256 priceQuantityValidTime\n    ) external onlyRole(LibAccessibility.MUON_SETTER_ROLE) {\n        emit SetMuonConfig(upnlValidTime, priceValidTime, priceQuantityValidTime);\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n        muonLayout.upnlValidTime = upnlValidTime;\n        muonLayout.priceValidTime = priceValidTime;\n        muonLayout.priceQuantityValidTime = priceQuantityValidTime;\n    }\n\n    function setMuonIds(\n        uint256 muonAppId,\n        address validGateway,\n        PublicKey memory publicKey\n    ) external onlyRole(LibAccessibility.MUON_SETTER_ROLE) {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n        muonLayout.muonAppId = muonAppId;\n        muonLayout.validGateway = validGateway;\n        muonLayout.muonPublicKey = publicKey;\n        emit SetMuonIds(muonAppId, validGateway, publicKey.x, publicKey.parity);\n    }\n\n    function setCollateral(\n        address collateral\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        GlobalAppStorage.layout().collateral = collateral;\n        emit SetCollateral(collateral);\n    }\n\n    // Symbol State\n\n    function addSymbol(\n        string memory name,\n        uint256 minAcceptableQuoteValue,\n        uint256 minAcceptablePortionLF,\n        uint256 tradingFee\n    ) public onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\n        uint256 lastId = ++SymbolStorage.layout().lastId;\n        Symbol memory symbol = Symbol(\n            lastId,\n            name,\n            true,\n            minAcceptableQuoteValue,\n            minAcceptablePortionLF,\n            tradingFee\n        );\n        SymbolStorage.layout().symbols[lastId] = symbol;\n        emit AddSymbol(lastId, name, minAcceptableQuoteValue, minAcceptablePortionLF, tradingFee);\n    }\n\n    function addSymbols(\n        Symbol[] memory symbols\n    ) external onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\n        for (uint8 i; i < symbols.length; i++) {\n            addSymbol(\n                symbols[i].name,\n                symbols[i].minAcceptableQuoteValue,\n                symbols[i].minAcceptablePortionLF,\n                symbols[i].tradingFee\n            );\n        }\n    }\n\n    function setSymbolValidationState(\n        uint256 symbolId,\n        bool isValid\n    ) external onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n        require(symbolId >= 1 && symbolId <= symbolLayout.lastId, \"ControlFacet: Invalid id\");\n        emit SetSymbolValidationState(symbolId, symbolLayout.symbols[symbolId].isValid, isValid);\n        symbolLayout.symbols[symbolId].isValid = isValid;\n    }\n\n    function setSymbolAcceptableValues(\n        uint256 symbolId,\n        uint256 minAcceptableQuoteValue,\n        uint256 minAcceptablePortionLF\n    ) external onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n        require(symbolId >= 1 && symbolId <= symbolLayout.lastId, \"ControlFacet: Invalid id\");\n        emit SetSymbolAcceptableValues(\n            symbolId,\n            symbolLayout.symbols[symbolId].minAcceptableQuoteValue,\n            symbolLayout.symbols[symbolId].minAcceptablePortionLF,\n            minAcceptableQuoteValue,\n            minAcceptablePortionLF\n        );\n        symbolLayout.symbols[symbolId].minAcceptableQuoteValue = minAcceptableQuoteValue;\n        symbolLayout.symbols[symbolId].minAcceptablePortionLF = minAcceptablePortionLF;\n    }\n\n    function setSymbolTradingFee(\n        uint256 symbolId,\n        uint256 tradingFee\n    ) external onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n        require(symbolId >= 1 && symbolId <= symbolLayout.lastId, \"ControlFacet: Invalid id\");\n        emit SetSymbolTradingFee(symbolId, symbolLayout.symbols[symbolId].tradingFee, tradingFee);\n        symbolLayout.symbols[symbolId].tradingFee = tradingFee;\n    }\n\n    /////////////////////////////////////\n\n    // CoolDowns\n\n    function setDeallocateCooldown(\n        uint256 deallocateCooldown\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetDeallocateCooldown(MAStorage.layout().deallocateCooldown, deallocateCooldown);\n        MAStorage.layout().deallocateCooldown = deallocateCooldown;\n    }\n\n    function setForceCancelCooldown(\n        uint256 forceCancelCooldown\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetForceCancelCooldown(MAStorage.layout().forceCancelCooldown, forceCancelCooldown);\n        MAStorage.layout().forceCancelCooldown = forceCancelCooldown;\n    }\n\n    function setForceCloseCooldown(\n        uint256 forceCloseCooldown\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetForceCloseCooldown(MAStorage.layout().forceCloseCooldown, forceCloseCooldown);\n        MAStorage.layout().forceCloseCooldown = forceCloseCooldown;\n    }\n\n    function setForceCancelCloseCooldown(\n        uint256 forceCancelCloseCooldown\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetForceCancelCloseCooldown(\n            MAStorage.layout().forceCancelCloseCooldown,\n            forceCancelCloseCooldown\n        );\n        MAStorage.layout().forceCancelCloseCooldown = forceCancelCloseCooldown;\n    }\n\n    function setLiquidatorShare(\n        uint256 liquidatorShare\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetLiquidatorShare(MAStorage.layout().liquidatorShare, liquidatorShare);\n        MAStorage.layout().liquid"
    }
  ]
}