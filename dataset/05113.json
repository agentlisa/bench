{
  "Title": "[G-07] Unchecked Divisions",
  "Content": "\nDivisions which do not divide by `-X` cannot overflow or overflow so such operations can be unchecked to save gas.\n\n**Instance 1:**\n\nUnchecked uint divisions in `WiseSecurity.overallLendingAPY()` function to reduce its gas cost.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol#L491-#L492\n\n```solidity\nfile: contracts/WiseSecurity/WiseSecurity.sol\n\n442:    function overallLendingAPY(\n443:        uint256 _nftId\n444:    )\n445:        external\n446:        view\n447:        returns (uint256)\n448:    {\n449:        uint256 len = WISE_LENDING.getPositionLendingTokenLength(\n450:            _nftId\n451:        );\n.\n.\n.\n491:        return weightedRate     //@audit can be unchecked\n492:            / overallETH;\n493:    }\n```\n\n```diff\ndiff --git a/contracts/WiseSecurity/WiseSecurity.sol b/contracts/WiseSecurity/WiseSecurity.sol\nindex d2cfb24..a101048 100644\n--- a/contracts/WiseSecurity/WiseSecurity.sol\n+++ b/contracts/WiseSecurity/WiseSecurity.sol\n@@ -487,9 +487,11 @@ contract WiseSecurity is WiseSecurityHelper, ApprovalHelper {\n                 ++i;\n             }\n         }\n-\n-        return weightedRate\n+        unchecked {\n+            return weightedRate\n             / overallETH;\n+        }\n+\n     }\n```\n\nEstimated gas saved: 45 gas units.\n\n**Instance 2:**\n\nUnchecked uint divisions in `WiseSecurity.overallBorrowAPY()` function to reduce its gas cost.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol#L548-#L549\n\n```solidity\nfile: WiseSecurity/WiseSecurity.sol\n\n499:    function overallBorrowAPY(\n500:        uint256 _nftId\n501:    )\n502:        external\n503:        view\n504:        returns (uint256)\n505:    {\n506:        uint256 len = WISE_LENDING.getPositionBorrowTokenLength(\n507:            _nftId\n508:        );\n.\n.\n.\n548:        return weightedRate     // @audit can be unchecked\n549:            / overallETH;\n550:    }\n```\n\n```diff\ndiff --git a/contracts/WiseSecurity/WiseSecurity.sol b/contracts/WiseSecurity/WiseSecurity.sol\nindex d2cfb24..568e44c 100644\n--- a/contracts/WiseSecurity/WiseSecurity.sol\n+++ b/contracts/WiseSecurity/WiseSecurity.sol\n@@ -545,8 +545,10 @@ contract WiseSecurity is WiseSecurityHelper, ApprovalHelper {\n             }\n         }\n\n-        return weightedRate\n+        unchecked {\n+            return weightedRate\n             / overallETH;\n+        }\n     }\n```\n\nEstimated gas saved: 45 gas units.\n\n**Instance 3:**\n\nUnchecked uint divisions in `MainHelper._updatePseudoTotalAmounts()` function to reduce its gas cost.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/MainHelper.sol#L525-#L526\n\n```solidity\nfile: contracts/MainHelper.sol\n\n500:    function _updatePseudoTotalAmounts(\n501:        address _poolToken\n502:    )\n503:        private\n504:    {\n505:        uint256 currentTime = block.timestamp;\n.\n.\n.\n525:        uint256 amountInterest = bareIncrease   //@audit can be unchecked\n526:            / PRECISION_FACTOR_YEAR;\n527:\n528:        uint256 feeAmount = amountInterest\n529:            * globalPoolData[_poolToken].poolFee\n530:            / PRECISION_FACTOR_E18;\n.\n.\n.\n577:    }\n```\n\n```diff\ndiff --git a/contracts/MainHelper.sol b/contracts/MainHelper.sol\nindex 46854bc..de070c3 100644\n--- a/contracts/MainHelper.sol\n+++ b/contracts/MainHelper.sol\n@@ -521,9 +521,11 @@ abstract contract MainHelper is WiseLowLevelHelper {\n         }\n\n         delete bufferIncrease[_poolToken];\n-\n-        uint256 amountInterest = bareIncrease\n-            / PRECISION_FACTOR_YEAR;\n+        uint256 amountInterest;\n+        unchecked {\n+            amountInterest = bareIncrease / PRECISION_FACTOR_YEAR;\n+        }\n+\n```\n\nEstimated gas saved: 45 gas units.\n\n**Instance 4:**\n\nUnchecked uint divisions in `MainHelper._updatePseudoTotalAmounts()` function to reduce its gas cost.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L403-#L404\n\n```solidity\nfile: contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n\n386:    function previewDistribution()\n387:        public\n388:        view\n389:        returns (uint256)\n390:    {\n391:        if (totalLpAssetsToDistribute == 0) {\n392:            return 0;\n393:        }\n394:\n395:        if (block.timestamp == lastInteraction) {\n396:            return 0;\n397:        }\n398:\n399:        if (totalLpAssetsToDistribute < ONE_WEEK) {\n400:            return totalLpAssetsToDistribute;\n401:        }\n402:\n403:        uint256 currentRate = totalLpAssetsToDistribute     // @audit can be unchecked\n404:            / ONE_WEEK;\n405:\n406:        uint256 additonalAssets = currentRate\n407:            * (block.timestamp - lastInteraction);\n408:\n409:        if (additonalAssets > totalLpAssetsToDistribute) {\n410:            return totalLpAssetsToDistribute;\n411:        }\n412:\n413:        return additonalAssets;\n414:    }\n```\n\n```diff\ndiff --git a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\nindex 9f7bb58..c39ed9c 100644\n--- a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n+++ b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n@@ -400,8 +400,11 @@ contract PendlePowerFarmToken is SimpleERC20, TransferHelper {\n             return totalLpAssetsToDistribute;\n         }\n\n-        uint256 currentRate = totalLpAssetsToDistribute\n-            / ONE_WEEK;\n+        uint256 currentRate;\n+        unchecked {\n+            currentRate = totalLpAssetsToDistribute / ONE_WEEK;\n+        }\n+\n\n         uint256 additonalAssets = currentRate\n             * (block.timestamp - lastInteraction);\n```\n\nEstimated gas saved: 45 gas units.\n\n**Instance 5:**\n\nUnchecked uint divisions in `AaveHelper._underlyingAsset()` function to reduce its gas cost.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WrapperHub/AaveHelper.sol#L322-#L323\n\n```solidity\nfile: contracts/WrapperHub/AaveHelper.sol\n\n315:    function getAavePoolAPY(\n316:        address _underlyingAsset\n317:    )\n318:        public\n319:        view\n320:        returns (uint256)\n321:    {\n322:        return AAVE.getReserveData(_underlyingAsset).currentLiquidityRate   //@audit can be unchecked\n323:            / PRECISION_FACTOR_E9;\n324    }\n```\n\n```diff\ndiff --git a/contracts/WrapperHub/AaveHelper.sol b/contracts/WrapperHub/AaveHelper.sol\nindex eca55d1..a4633bc 100644\n--- a/contracts/WrapperHub/AaveHelper.sol\n+++ b/contracts/WrapperHub/AaveHelper.sol\n@@ -319,7 +319,9 @@ abstract contract AaveHelper is Declarations {\n         view\n         returns (uint256)\n     {\n-        return AAVE.getReserveData(_underlyingAsset).currentLiquidityRate\n+        unchecked {\n+            return AAVE.getReserveData(_underlyingAsset).currentLiquidityRate\n             / PRECISION_FACTOR_E9;\n+        }\n     }\n }\n```\n\nEstimated gas saved: 45 gas units.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/WiseSecurity/WiseSecurity.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\n/**\n * @author Christoph Krpoun\n * @author René Hochmuth\n * @author Vitally Marinchenko\n */\n\nimport \"./WiseSecurityHelper.sol\";\nimport \"../TransferHub/ApprovalHelper.sol\";\n\n/**\n * @dev WiseSecurity is a core contract for wiseLending including most of\n * the performed security checks for withdraws, borrows, paybacks and liquidations.\n * It also has several read only functions providing UI data for a better user\n * experiencne.\n *\n */\n\nerror NotWiseLendingSecurity();\n\ncontract WiseSecurity is WiseSecurityHelper, ApprovalHelper {\n\n    modifier onlyWiseLending() {\n        _onlyWiseLending();\n        _;\n    }\n\n    function _onlyWiseLending()\n        private\n        view\n    {\n        if (msg.sender == address(WISE_LENDING)) {\n            return;\n        }\n\n        revert NotWiseLendingSecurity();\n    }\n\n    constructor(\n        address _master,\n        address _wiseLendingAddress,\n        address _aaveHubAddress\n    )\n        WiseSecurityDeclarations(\n            _master,\n            _wiseLendingAddress,\n            _aaveHubAddress\n        )\n    {}\n\n    /**\n     * @dev View functions returning current\n     * debt ratio of a postion in normal mode.\n     * 1% <=> 1E16\n     */\n    function getLiveDebtRatio(\n        uint256 _nftId\n    )\n        external\n        view\n        returns (uint256)\n    {\n        uint256 overallCollateral = overallETHCollateralsWeighted(\n            _nftId\n        );\n\n        if (overallCollateral == 0) {\n            return 0;\n        }\n\n        return overallETHBorrow(_nftId)\n            * PRECISION_FACTOR_E18\n            / overallCollateral;\n    }\n\n    /**\n     * @dev Set Liquidation incentives and boundaries\n     * for liquidation. Only callable by the master.\n     * Assures liquidation cascade cannot be self imposed\n     * by limiting incentives.\n     */\n    function setLiquidationSettings(\n        uint256 _baseReward,\n        uint256 _baseRewardFarm,\n        uint256 _newMaxFeeETH,\n        uint256 _newMaxFeeFarmETH\n    )\n        external\n        onlyMaster\n    {\n        _setLiquidationSettings(\n            _baseReward,\n            _baseRewardFarm,\n            _newMaxFeeETH,\n            _newMaxFeeFarmETH\n        );\n    }\n\n    /**\n     * @dev Checks for liquidation logic.\n     */\n    function checksLiquidation(\n        uint256 _nftIdLiquidate,\n        address _tokenToPayback,\n        uint256 _shareAmountToPay\n    )\n        external\n        view\n    {\n        (\n            uint256 weightedCollateralETH,\n            uint256 unweightedCollateralETH\n\n        ) = overallETHCollateralsBoth(\n            _nftIdLiquidate\n        );\n\n        uint256 borrowETHTotal = overallETHBorrowHeartbeat(\n            _nftIdLiquidate\n        );\n\n        canLiquidate(\n            borrowETHTotal,\n            weightedCollateralETH\n        );\n\n        checkMaxShares(\n            _nftIdLiquidate,\n            _tokenToPayback,\n            borrowETHTotal,\n            unweightedCollateralETH,\n            _shareAmountToPay\n        );\n    }\n\n    /**\n     * @dev Set function for preparing curve pools.\n     */\n    function prepareCurvePools(\n        address _poolToken,\n        CurveSwapStructData calldata _curveSwapStructData,\n        CurveSwapStructToken calldata _curveSwapStructToken\n    )\n        external\n        onlyWiseLending\n    {\n        curveSwapInfoData[_poolToken] = _curveSwapStructData;\n        curveSwapInfoToken[_poolToken] = _curveSwapStructToken;\n\n        address curvePool = curveSwapInfoData[_poolToken].curvePool;\n        uint256 tokenIndexForApprove = _curveSwapStructToken.curvePoolTokenIndexFrom;\n\n        _safeApprove(\n            ICurve(curvePool).coins(tokenIndexForApprove),\n            curvePool,\n            0\n        );\n\n        _safeApprove(\n            ICurve(curvePool).coins(tokenIndexForApprove),\n            curvePool,\n            UINT256_MAX\n        );\n\n        address curveMetaPool = curveSwapInfoData[_poolToken].curveMetaPool;\n\n        if (curveMetaPool == ZERO_ADDRESS) {\n            return;\n        }\n\n        tokenIndexForApprove = _curveSwapStructToken.curveMetaPoolTokenIndexFrom;\n\n        _safeApprove(\n            ICurve(curveMetaPool).coins(tokenIndexForApprove),\n            curveMetaPool,\n            0\n        );\n\n        _safeApprove(\n            ICurve(curveMetaPool).coins(tokenIndexForApprove),\n            curveMetaPool,\n            UINT256_MAX\n        );\n    }\n\n    /**\n     * @dev Reentrency guard for curve pools. Forces\n     * a swap to update internal curve values.\n     */\n    function curveSecurityCheck(\n        address _poolToken\n    )\n        external\n        onlyWiseLending\n    {\n        address curvePool = curveSwapInfoData[_poolToken].curvePool;\n\n        if (curvePool == ZERO_ADDRESS) {\n            return;\n        }\n\n        (\n            bool success\n            ,\n        ) = curvePool.call{value: 0} (\n            curveSwapInfoData[_poolToken].swapBytesPool\n        );\n\n        _checkSuccess(\n            success\n        );\n\n        address curveMeta = curveSwapInfoData[_poolToken].curveMetaPool;\n\n        if (curveMeta == ZERO_ADDRESS) {\n            return;\n        }\n\n        (\n            success\n            ,\n        ) = curveMeta.call{value: 0} (\n            curveSwapInfoData[_poolToken].swapBytesMeta\n        );\n\n        _checkSuccess(\n            success\n        );\n    }\n\n    /**\n     * @dev Checks for withdraw logic.\n     */\n    function checksWithdraw(\n        uint256 _nftId,\n        address _caller,\n        address _poolToken\n    )\n        external\n        view\n        returns (bool specialCase)\n    {\n        if (_checkBlacklisted(_poolToken) == true) {\n\n            if (overallETHBorrowBare(_nftId) > 0) {\n                revert OpenBorrowPosition();\n            }\n\n            return true;\n        }\n\n        if (WISE_LENDING.verifiedIsolationPool(_caller) == true) {\n            return true;\n        }\n\n        if (WISE_LENDING.positionLocked(_nftId) == true) {\n            return true;\n        }\n\n        if (_isUncollateralized(_nftId, _poolToken) == true) {\n            return true;\n        }\n\n        if (WISE_LENDING.getPositionBorrowTokenLength(_nftId) == 0) {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Checks for solely withdraw logic.\n     */\n    function checksSolelyWithdraw(\n        uint256 _nftId,\n        address _caller,\n        address _poolToken\n    )\n        external\n        view\n        returns (bool specialCase)\n    {\n        if (_checkBlacklisted(_poolToken) == true) {\n\n            if (overallETHBorrowBare(_nftId) > 0) {\n                revert OpenBorrowPosition();\n            }\n\n            return true;\n        }\n\n        if (WISE_LENDING.verifiedIsolationPool(_caller) == true) {\n            return true;\n        }\n\n        if (WISE_LENDING.positionLocked(_nftId) == true) {\n            return true;\n        }\n\n    }\n\n    /**\n     * @dev Checks for borrow logic.\n     */\n    function checksBorrow(\n        uint256 _nftId,\n        address _caller,\n        address _poolToken\n    )\n        external\n        view\n        returns (bool specialCase)\n    {\n        _checkPoolCondition(\n            _poolToken\n        );\n\n        checkTokenAllowed(\n            _poolToken\n        );\n\n        if (WISE_LENDING.verifiedIsolationPool(_caller) == true) {\n            return true;\n        }\n\n        if (WISE_LENDING.positionLocked(_nftId) == true) {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Checks for collateralize deposit logic.\n     */\n    function checksCollateralizeDeposit(\n        uint256 _nftId,\n        address _caller,\n        address _poolAddress\n    )\n        external\n        view\n    {\n        if (checkHeartbeat(_poolAddress) == false) {\n            revert ChainlinkDead();\n        }\n\n        _checkPoolCondition(\n            _poolAddress\n        );\n\n        checkOwnerPosition(\n            _nftId,\n            _caller\n        );\n    }\n\n    /**\n     * @dev Checks for uncollateralized deposit logic.\n     */\n    function checkUncollateralizedDeposit(\n        uint256 _nftId,\n        address _poolToken\n    )\n        external\n        view\n    {\n        if (_checkBlacklisted(_poolToken) == true) {\n\n            if (overallETHBorrowBare(_nftId) > 0) {\n                revert OpenBorrowPosition();\n            }\n\n            return;\n        }\n\n        _checkHealthState(\n            {\n                _nftId: _nftId,\n                _powerFarm: false\n            }\n        );\n    }\n\n    /**\n     * @dev Checks if user has healthy position.\n     */\n\n    function checkHealthState(\n        uint256 _nftId,\n        bool _isPowerFarm\n    )\n        external\n        view\n    {\n        _checkHealthState(\n            _nftId,\n            _isPowerFarm\n        );\n    }\n\n    /**\n     * @dev Checks for bad debt logic. Compares\n     * total ETH of borrow and collateral.\n     */\n    function checkBadDebtLiquidation(\n        uint256 _nftId\n    )\n        external\n        onlyWiseLending\n    {\n        uint256 bareCollateral = overallETHCollateralsBare(\n            _nftId\n        );\n\n        uint256 totalBorrow = overallETHBorrowBare(\n            _nftId\n        );\n\n        if (totalBorrow < bareCollateral) {\n            return;\n        }\n\n        unchecked {\n            uint256 diff = totalBorrow\n                - bareCollateral;\n\n            FEE_MANAGER.increaseTotalBadDebtLiquidation(\n                diff\n            );\n\n            FEE_MANAGER.setBadDebtUserLiquidation(\n                _nftId,\n                diff\n            );\n        }\n    }\n\n    /**\n     * @dev View function returning weighted\n     * supply APY of a postion. 1% <=> 1E16\n     */\n    function overallLendingAPY(\n        uint256 _nftId\n    )\n        external\n        view\n        returns (uint256)\n    {\n        uint256 len = WISE_LENDING.getPositionLendingTokenLength(\n            _nftId\n        );\n\n        if (len == 0) {\n            return 0;\n        }\n\n        uint256 i;\n        address token;\n        uint256 amount;\n        uint256 ethValue;\n        uint256 overallETH;\n        uint256 weightedRate;\n\n        while (i < len) {\n\n            token = WISE_LENDING.getPositionLendingTokenByIndex(\n                _nftId,\n                i\n            );\n\n            amount = getPositionLendingAmount(\n                _nftId,\n                token\n            );\n\n            ethValue = WISE_ORACLE.getTokensInETH(\n                token,\n                amount\n            );\n\n            weightedRate += ethValue\n                * getLendingRate(token);\n\n            overallETH += ethValue;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return weightedRate\n            / overallETH;\n    }\n\n    /**\n     * @dev View function returning weighted\n     * borrow APY of a postion. 1% <=> 1E16\n     */\n    function overallBorrowAPY(\n        uint256 _nftId\n    )\n        external\n        view\n        returns (uint256)\n    {\n        uint256 len = WISE_LENDING.getPositionBorrowTokenLength(\n            _nftId\n        );\n\n        if (len == 0) {\n            return 0;\n        }\n\n        uint256 i;\n        address token;\n        uint256 amount;\n        uint256 ethValue;\n        uint256 overallETH;\n        uint256 weightedRate;\n\n        while (i < len) {\n\n            token = WISE_LENDING.getPositionBorrowTokenByIndex(\n                _nftId,\n                i\n            );\n\n            amount = getPositionBorrowAmount(\n                _nftId,\n                token\n            );\n\n            ethValue = WISE_ORACLE.getTokensInETH(\n                token,\n                amount\n            );\n\n            weightedRate += ethValue\n                * getBorrowRate(token);\n\n            overallETH += ethValue;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return weightedRate\n            / overallETH;\n    }\n\n    /**\n     * @dev View function returning the total\n     * net APY of a postion. 1% <=> 1E16\n     */\n    function overallNetAPY(\n        uint256 _nftId\n    )\n        external\n        view\n        returns (uint256, bool)\n    {\n        uint256 i;\n        address token;\n        uint256 ethValue;\n        uint256 ethValueDebt;\n        uint256 ethValueGain;\n        uint256 totalETHSupply;\n\n        uint256 netAPY;\n\n        uint256 lenBorrow = WISE_LENDING.getPositionBorrowTokenLength(\n            _nftId\n        );\n\n        uint256 lenDeposit = WISE_LENDING.getPositionLendingTokenLength(\n            _nftId\n        );\n\n        while (i < lenBorrow) {\n\n            token = WISE_LENDING.getPositionBorrowTokenByIndex(\n                _nftId,\n                i\n            );\n\n            ethValue = getETHBorrow(\n                _nftId,\n                token\n            );\n\n            ethValueDebt += ethValue\n                * getBorrowRate(token);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        i = 0;\n\n        while (i < lenDeposit) {\n\n            token = WISE_LENDING.getPositionLendingTokenByIndex(\n                _nftId,\n                i\n            );\n\n            ethValue = getETHCollateral(\n                _nftId,\n                token\n            );\n\n            totalETHSupply += ethValue;\n            ethValueGain += ethValue\n                * getLendingRate(token);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (ethValueGain >= ethValueDebt) {\n\n            netAPY = (ethValueGain - ethValueDebt)\n                / totalETHSupply;\n\n            return (netAPY, false);\n        }\n\n        netAPY = (ethValueDebt - ethValueGain)\n                / totalETHSupply;\n\n        return (netAPY, true);\n    }\n\n    /**\n     * @dev View function claculating the open\n     * amount a postion is allowed to borrow.\n     */\n    function safeLimitPosition(\n        uint256 _nftId\n    )\n        external\n        view\n        returns (uint256)\n    {\n        uint256 len = WISE_LENDING.getPositionLendingTokenLength(\n            _nftId\n        );\n\n        if (len == 0) {\n            return 0;\n        }\n\n        uint256 i;\n        address token;\n        uint256 buffer;\n\n        while (i < len) {\n\n            token = WISE_LENDING.getPositionLendingTokenByIndex(\n                _nftId,\n                i\n            );\n\n            unchecked {\n                ++i;\n            }\n\n            if (checkHeartbeat(token) == false) {\n                continue;\n            }\n\n            if (wasBlacklisted[token] == true) {\n                continue;\n            }\n\n            buffer += WISE_LENDING.lendingPoolData(token).collateralFactor\n                * getFullCollateralETH(\n                    _nftId,\n                    token\n                ) / PRECISION_FACTOR_E18;\n        }\n\n        return buffer\n            * BORROW_PERCENTAGE_CAP\n            / PRECISION_FACTOR_E18;\n    }\n\n    /**\n     * @dev View function checking if the postion is\n     * locked due to blacklisted token.\n     */\n    function positionBlackListToken(\n        uint256 _nftId\n    )\n        external\n        view\n        returns (bool, address)\n    {\n        uint256 lenDeposit = WISE_LENDING.getPositionLendingTokenLength(\n            _nftId\n        );\n\n        uint256 i;\n        address token;\n\n        while (i < lenDeposit) {\n\n            token = WISE_LENDING.getPositionLendingTokenByIndex(\n                _nftId,\n                i\n            );\n\n            if (_checkBlacklisted(token) == true) {\n                return (\n                    true,\n                    token\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        uint256 lenBorrow = WISE_LENDING.getPositionBorrowTokenLength(\n            _nftId\n        );\n\n        i = 0;\n\n        while (i < lenBorrow) {\n\n            token = WISE_LENDING.getPositionBorrowTokenByIndex(\n                _nftId,\n                i\n            );\n\n            if (_checkBlacklisted(token) == true) {\n                return (\n                    true,\n                    token\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (\n            false,\n            ZERO_ADDRESS\n        );\n    }\n\n    /**\n     * @dev View function extrapolating the\n     * possible withdraw amount of a postion\n     * for a specific _poolToken.\n     */\n    function maximumWithdrawToken(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _interval,\n        uint256 _solelyWithdrawAmount\n    )\n        external\n        view\n        returns (uint256)\n    {\n        uint256 withdrawAmount;\n\n        uint256 expectedMaxAmount = getExpectedLendingAmount(\n            _nftId,\n            _poolToken,\n            _interval\n        );\n\n        uint256 maxAmountPool = WISE_LENDING.getTotalPool(\n            _poolToken\n        );\n\n        withdrawAmount = expectedMaxAmount;\n\n        if (expectedMaxAmount > maxAmountPool) {\n            withdrawAmount = maxAmountPool;\n        }\n\n        if (_isUncollateralized(_nftId, _poolToken) == true) {\n            return withdrawAmount;\n        }\n\n        uint256 possibelWithdraw = _getPossibleWithdrawAmount(\n            _nftId,\n            _poolToken,\n            _interval\n        );\n\n        withdrawAmount = possibelWithdraw;\n\n        if (possibelWithdraw > expectedMaxAmount) {\n            withdrawAmount = expectedMaxAmount;\n        }\n\n        if (_solelyWithdrawAmount >= withdrawAmount) {\n            return 0;\n        }\n\n        withdrawAmount = withdrawAmount - _solelyWithdrawAmount;\n\n        if (withdrawAmount > maxAmountPool) {\n            return maxAmountPool;\n        }\n\n        return withdrawAmount;\n    }\n\n    /**\n     * @dev View function extrapolating the\n     * possible withdraw amount of a private\n     * postion for a specific _poolToken.\n     */\n    function maximumWithdrawTokenSolely(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _interval,\n        uint256 _poolWithdrawAmount\n    )\n        external\n        view\n        returns (uint256)\n    {\n        uint256 tokenAmount = _getPossibleWithdrawAmount(\n            _nftId,\n            _poolToken,\n            _interval\n        );\n\n        if (_isUncollateralized(_nftId, _poolToken) == false) {\n\n            if (_poolWithdrawAmount >= tokenAmount) {\n                return 0;\n            }\n\n            tokenAmount = tokenAmount - _poolWithdrawAmount;\n        }\n\n        uint256 maxSolelyAmount = WISE_LENDING.getPureCollateralAmount(\n            _nftId,\n            _poolToken\n        );\n\n        if (tokenAmount > maxSolelyAmount) {\n            return maxSolelyAmount;\n        }\n\n        return tokenAmount;\n    }\n\n    /**\n     * @dev View function extrapolating the\n     * possible borrow amount of postion for\n     * a specific _poolToken.\n     */\n    function maximumBorrowToken(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _interval\n    )\n        external\n        view\n        returns (uint256 tokenAmount)\n    {\n        uint256 term = _overallETHCollateralsWeighted(_nftId, _interval)\n            * BORROW_PERCENTAGE_CAP\n            / PRECISION_FACTOR_E18;\n\n        uint256 borrowETH = term\n            - _overallETHBorrow(\n                _nftId,\n                _interval\n            );\n\n        tokenAmount = WISE_ORACLE.getTokensFromETH(\n            _poolToken,\n            borrowETH\n        );\n\n        uint256 maxPoolAmount = WISE_LENDING.getTotalPool(\n            _poolToken\n        );\n\n        if (tokenAmount > maxPoolAmount) {\n            tokenAmount = maxPoolAmount;\n        }\n    }\n\n    /**\n     * @dev View function extrapolating the\n     * possible payback amount of a position\n     * for a specific _poolToken.\n     */\n    function getExpectedPaybackAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _interval\n    )\n        external\n        view\n        returns (uint256)\n    {\n        uint256 borrowShares = WISE_LENDING.getPositionBorrowShares(\n            _nftId,\n            _poolToken\n        );\n\n        uint256 currentTotalBorrowShares = WISE_LENDING.getTotalBorrowShares(\n            _poolToken\n        );\n\n        if (currentTotalBorrowShares == 0) {\n            return 0;\n        }\n\n        uint256 updatedPseudo = _getUpdatedPseudoBorrow(\n            _poolToken,\n            _interval\n        );\n\n        return borrowShares\n            * updatedPseudo\n            / currentTotalBorrowShares;\n    }\n\n    /**\n     * @dev View function extrapolating the\n     * possible lending amount of a position\n     * for a specific _poolToken.\n     */\n    function getExpectedLendingAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _interval\n    )\n        public\n        view\n        returns (uint256)\n    {\n        uint256 lendingShares = WISE_LENDING.getPositionLendingShares(\n            _nftId,\n            _poolToken\n        );\n\n        uint256 currentTotalLendingShares = WISE_LENDING.getTotalDepositShares(\n            _poolToken\n        );\n\n        if (currentTotalLendingShares == 0) {\n            return 0;\n        }\n\n        uint256 updatedPseudo = _getUpdatedPseudoPool(\n            _poolToken,\n            _interval\n        );\n\n        return lendingShares\n            * updatedPseudo\n            / currentTotalLendingShares;\n    }\n\n    /**\n     * @dev Set function for blacklisting token.\n     * Those token can not be borrowed or used as\n     * collateral anymore. Only callable by master.\n     */\n    function setBlacklistToken(\n        address _tokenAddress,\n        bool _state\n    )\n        external\n        onlyMaster()\n    {\n        wasBlacklisted[_tokenAddress] = _state;\n    }\n\n    /**\n     * @dev Set function for adding or removing\n     * workers to perform a security shutdown.\n     * Only callable by the master.\n     */\n    function setSecurityWorker(\n        address _entitiy,\n        bool _state\n    )\n        external\n        onlyMaster\n    {\n        securityWorker[_entitiy] = _state;\n    }\n\n    /**\n     * Safety function to perform a security\n     * shutdown of all active pools. Can be\n     * called by the security worker, a\n     * special role set by the master.\n     */\n    function securityShutdown()\n        external\n    {\n        if (securityWorker[msg.sender] == false) {\n            revert NotAllowedEntity();\n        }\n\n        _setPoolState(\n            true\n        );\n\n        emit SecurityShutdown(\n            msg.sender,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Master function to revoke all locks,\n     * only callable by the master.\n     */\n    function revokeShutdown()\n        external\n        onlyMaster\n    {\n        _setPoolState(\n            false\n        );\n    }\n\n    /**\n     * @dev External wrapper for pool condition\n     * check.\n     */\n    function checkPoolCondition(\n        address _token\n    )\n        external\n        view\n    {\n        _checkPoolCondition(\n            _token\n        );\n    }\n\n    /**\n     * @dev External wrapper for pool condition\n     * check.\n     */\n    function checkPoolWithMinDeposit(\n        address _token,\n        uint256 _amount\n    )\n        external\n        view\n        returns (bool)\n    {\n        _checkPoolCondition(\n            _token\n        );\n\n        return _checkMinDepositValue(\n            _token,\n            _amount\n        );\n    }\n\n    function checkMinDepositValue(\n        address _token,\n        uint256 _amount\n    )\n        external\n        view\n        returns (bool)\n    {\n        return _checkMinDepositValue(\n            _token,\n            _amount\n        );\n    }\n\n    function _checkMinDepositValue(\n        address _token,\n        uint256 _amount\n    )\n        private\n        view\n        returns (bool)\n    {\n        if (minDepositEthValue == ONE_WEI) {\n            return true;\n        }\n\n        if (_getTokensInEth(_token, _amount) < minDepositEthValue) {\n            revert DepositAmountTooSmall();\n        }\n\n        return true;\n    }\n\n    function changeMinDepositValue(\n        uint256 _newMinDepositValue\n    )\n        external\n        onlyMaster\n    {\n        if (_newMinDepositValue == 0) {\n            revert NoValue();\n        }\n\n        minDepositEthValue = _newMinDepositValue;\n    }\n}"
    },
    {
      "filename": "contracts/WiseSecurity/WiseSecurity.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\n/**\n * @author Christoph Krpoun\n * @author René Hochmuth\n * @author Vitally Marinchenko\n */\n\nimport \"./WiseSecurityHelper.sol\";\nimport \"../TransferHub/ApprovalHelper.sol\";\n\n/**\n * @dev WiseSecurity is a core contract for wiseLending including most of\n * the performed security checks for withdraws, borrows, paybacks and liquidations.\n * It also has several read only functions providing UI data for a better user\n * experiencne.\n *\n */\n\nerror NotWiseLendingSecurity();\n\ncontract WiseSecurity is WiseSecurityHelper, ApprovalHelper {\n\n    modifier onlyWiseLending() {\n        _onlyWiseLending();\n        _;\n    }\n\n    function _onlyWiseLending()\n        private\n        view\n    {\n        if (msg.sender == address(WISE_LENDING)) {\n            return;\n        }\n\n        revert NotWiseLendingSecurity();\n    }\n\n    constructor(\n        address _master,\n        address _wiseLendingAddress,\n        address _aaveHubAddress\n    )\n        WiseSecurityDeclarations(\n            _master,\n            _wiseLendingAddress,\n            _aaveHubAddress\n        )\n    {}\n\n    /**\n     * @dev View functions returning current\n     * debt ratio of a postion in normal mode.\n     * 1% <=> 1E16\n     */\n    function getLiveDebtRatio(\n        uint256 _nftId\n    )\n        external\n        view\n        returns (uint256)\n    {\n        uint256 overallCollateral = overallETHCollateralsWeighted(\n            _nftId\n        );\n\n        if (overallCollateral == 0) {\n            return 0;\n        }\n\n        return overallETHBorrow(_nftId)\n            * PRECISION_FACTOR_E18\n            / overallCollateral;\n    }\n\n    /**\n     * @dev Set Liquidation incentives and boundaries\n     * for liquidation. Only callable by the master.\n     * Assures liquidation cascade cannot be self imposed\n     * by limiting incentives.\n     */\n    function setLiquidationSettings(\n        uint256 _baseReward,\n        uint256 _baseRewardFarm,\n        uint256 _newMaxFeeETH,\n        uint256 _newMaxFeeFarmETH\n    )\n        external\n        onlyMaster\n    {\n        _setLiquidationSettings(\n            _baseReward,\n            _baseRewardFarm,\n            _newMaxFeeETH,\n            _newMaxFeeFarmETH\n        );\n    }\n\n    /**\n     * @dev Checks for liquidation logic.\n     */\n    function checksLiquidation(\n        uint256 _nftIdLiquidate,\n        address _tokenToPayback,\n        uint256 _shareAmountToPay\n    )\n        external\n        view\n    {\n        (\n            uint256 weightedCollateralETH,\n            uint256 unweightedCollateralETH\n\n        ) = overallETHCollateralsBoth(\n            _nftIdLiquidate\n        );\n\n        uint256 borrowETHTotal = overallETHBorrowHeartbeat(\n            _nftIdLiquidate\n        );\n\n        canLiquidate(\n            borrowETHTotal,\n            weightedCollateralETH\n        );\n\n        checkMaxShares(\n            _nftIdLiquidate,\n            _tokenToPayback,\n            borrowETHTotal,\n            unweightedCollateralETH,\n            _shareAmountToPay\n        );\n    }\n\n    /**\n     * @dev Set function for preparing curve pools.\n     */\n    function prepareCurvePools(\n        address _poolToken,\n        CurveSwapStructData calldata _curveSwapStructData,\n        CurveSwapStructToken calldata _curveSwapStructToken\n    )\n        external\n        onlyWiseLending\n    {\n        curveSwapInfoData[_poolToken] = _curveSwapStructData;\n        curveSwapInfoToken[_poolToken] = _curveSwapStructToken;\n\n        address curvePool = curveSwapInfoData[_poolToken].curvePool;\n        uint256 tokenIndexForApprove = _curveSwapStructToken.curvePoolTokenIndexFrom;\n\n        _safeApprove(\n            ICurve(curvePool).coins(tokenIndexForApprove),\n            curvePool,\n            0\n        );\n\n        _safeApprove(\n            ICurve(curvePool).coins(tokenIndexForApprove),\n            curvePool,\n            UINT256_MAX\n        );\n\n        address curveMetaPool = curveSwapInfoData[_poolToken].curveMetaPool;\n\n        if (curveMetaPool == ZERO_ADDRESS) {\n            return;\n        }\n\n        tokenIndexForApprove = _curveSwapStructToken.curveMetaPoolTokenIndexFrom;\n\n        _safeApprove(\n            ICurve(curveMetaPool).coins(tokenIndexForApprove),\n            curveMetaPool,\n            0\n        );\n\n        _safeApprove(\n            ICurve(curveMetaPool).coins(tokenIndexForApprove),\n            curveMetaPool,\n            UINT256_MAX\n        );\n    }\n\n    /**\n     * @dev Reentrency guard for curve pools. Forces\n     * a swap to update internal curve values.\n     */\n    function curveSecurityCheck(\n        address _poolToken\n    )\n        external\n        onlyWiseLending\n    {\n        address curvePool = curveSwapInfoData[_poolToken].curvePool;\n\n        if (curvePool == ZERO_ADDRESS) {\n            return;\n        }\n\n        (\n            bool success\n            ,\n        ) = curvePool.call{value: 0} (\n            curveSwapInfoData[_poolToken].swapBytesPool\n        );\n\n        _checkSuccess(\n            success\n        );\n\n        address curveMeta = curveSwapInfoData[_poolToken].curveMetaPool;\n\n        if (curveMeta == ZERO_ADDRESS) {\n            return;\n        }\n\n        (\n            success\n            ,\n        ) = curveMeta.call{value: 0} (\n            curveSwapInfoData[_poolToken].swapBytesMeta\n        );\n\n        _checkSuccess(\n            success\n        );\n    }\n\n    /**\n     * @dev Checks for withdraw logic.\n     */\n    function checksWithdraw(\n        uint256 _nftId,\n        address _caller,\n        address _poolToken\n    )\n        external\n        view\n        returns (bool specialCase)\n    {\n        if (_checkBlacklisted(_poolToken) == true) {\n\n            if (overallETHBorrowBare(_nftId) > 0) {\n                revert OpenBorrowPosition();\n            }\n\n            return true;\n        }\n\n        if (WISE_LENDING.verifiedIsolationPool(_caller) == true) {\n            return true;\n        }\n\n        if (WISE_LENDING.positionLocked(_nftId) == true) {\n            return true;\n        }\n\n        if (_isUncollateralized(_nftId, _poolToken) == true) {\n            return true;\n        }\n\n        if (WISE_LENDING.getPositionBorrowTokenLength(_nftId) == 0) {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Checks for solely withdraw logic.\n     */\n    function checksSolelyWithdraw(\n        uint256 _nftId,\n        address _caller,\n        address _poolToken\n    )\n        external\n        view\n        returns (bool specialCase)\n    {\n        if (_checkBlacklisted(_poolToken) == true) {\n\n            if (overallETHBorrowBare(_nftId) > 0) {\n                revert OpenBorrowPosition();\n            }\n\n            return true;\n        }\n\n        if (WISE_LENDING.verifiedIsolationPool(_caller) == true) {\n            return true;\n        }\n\n        if (WISE_LENDING.positionLocked(_nftId) == true) {\n            return true;\n        }\n\n    }\n\n    /**\n     * @dev Checks for borrow logic.\n     */\n    function checksBorrow(\n        uint256 _nftId,\n        address _caller,\n        address _poolToken\n    )\n        external\n        view\n        returns (bool specialCase)\n    {\n        _checkPoolCondition(\n            _poolToken\n        );\n\n        checkTokenAllowed(\n            _poolToken\n        );\n\n        if (WISE_LENDING.verifiedIsolationPool(_caller) == true) {\n            return true;\n        }\n\n        if (WISE_LENDING.positionLocked(_nftId) == true) {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Checks for collateralize deposit logic.\n     */\n    function checksCollateralizeDeposit(\n        uint256 _nftId,\n        address _caller,\n        address _poolAddress\n    )\n        external\n        view\n    {\n        if (checkHeartbeat(_poolAddress) == false) {\n            revert ChainlinkDead();\n        }\n\n        _checkPoolCondition(\n            _poolAddress\n        );\n\n        checkOwnerPosition(\n            _nftId,\n            _caller\n        );\n    }\n\n    /**\n     * @dev Checks for uncollateralized deposit logic.\n     */\n    function checkUncollateralizedDeposit(\n        uint256 _nftId,\n        address _poolToken\n    )\n        external\n        view\n    {\n        if (_checkBlacklisted(_poolToken) == true) {\n\n            if (overallETHBorrowBare(_nftId) > 0) {\n                revert OpenBorrowPosition();\n            }\n\n            return;\n        }\n\n        _checkHealthState(\n            {\n                _nftId: _nftId,\n                _powerFarm: false\n            }\n        );\n    }\n\n    /**\n     * @dev Checks if user has healthy position.\n     */\n\n    func"
    }
  ]
}