{
  "Title": "H-3: Malicious operators can `undelegate` theirselves to manipulate the LRT exchange rate",
  "Content": "# Issue H-3: Malicious operators can `undelegate` theirselves to manipulate the LRT exchange rate \n\nSource: https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/53 \n\n## Found by \ng, giraffe, hash, mstpr-brainbot, zzykxx\n## Summary\nIf a malicious operator undelegates itself in EigenLayer delegation manager contract, the exchange rate of LRT can significantly decrease, and ETH/LST can become stuck, unable to be claimed by the Rio Delegator Approver contract.\n## Vulnerability Detail\nOperators' delegator contracts delegate their balance to the operators. Operators can \"undelegate\" themselves from any delegation forwarded to them by triggering this function:\n[DelegationManager.sol#L211-L258](https://github.com/Layr-Labs/eigenlayer-contracts/blob/6de01c6c16d6df44af15f0b06809dc160eac0ebf/src/contracts/core/DelegationManager.sol#L211-L258).\n\nIf the operator `undelegate` the delegator approver, then according to the strategy, there can be two things that happen:\n\n1- Strategy shares:\nWhen the operator undelegates, the strategy shares delegated to the operator will be queued for withdrawal to the stakee address. In this case, the `staker` is the RIO operator delegator contract, which has no implementation to withdraw the queued withdrawal request since the withdrawer must be the \"msg.sender.\" Therefore, the operator delegator must implement that functionality in such cases. The only downside to this is that the accounting of strategy shares to operators is tracked internally and not relied upon the StrategyManager's actual shares in the EigenLayer contract.\n\n2- EigenPod shares:\nWhen EigenPod shares are `undelegate`, the EigenPod shares are removed. Unlike the strategy shares, the EigenPod shares are used to account for how much ETH is held by each operator. If an operator `undelegate`, then the entire EigenPod balance will be \"0,\" and the RIO contracts are not prepared for this. This will erase a large amount of ETH TVL held by the Beacon Chain strategy, hence the LRT token exchange rate will change dramatically. Also, as with the above strategy shares issue, the `staker` is the operator delegator; hence, the operator delegator must implement the withdrawal functionality to be able to withdraw the ETH balance from the EigenPod.\n## Impact\nHigh because of the \"EigenPod shares\" issue can unexpectedly decrease the TVL, leading to a decrease in the LRT exchange rate without warning which would affect the deposits/withdrawals of the LRT in different assets aswell. \n\n**Coded PoC:**\n```solidity\n// forge test --match-contract RioLRTOperatorRegistryTest --match-test test_UndelegateRemovesEigenPodShares -vv\n    function test_UndelegateRemovesEigenPodShares() public {\n        uint8 operatorId =\n            addOperatorDelegator(reETH.operatorRegistry, address(reETH.rewardDistributor), emptyStrategyShareCaps, 10);\n        \n        // @review make a deposit\n        reETH.coordinator.depositETH{value: 32 * 5 ether}();\n\n        // Push funds into EigenLayer.\n        vm.prank(EOA, EOA);\n        reETH.coordinator.rebalance(ETH_ADDRESS);\n\n        // Verify validator withdrawal credentials.\n        uint40[] memory validatorIndices = verifyCredentialsForValidators(reETH.operatorRegistry, operatorId, 5);\n\n        // @review get the addresses \n        address operatorDelegator = reETH.operatorRegistry.getOperatorDetails(operatorId).delegator;\n        RioLRTOperatorDelegator delegatorContract = RioLRTOperatorDelegator(payable(operatorDelegator));\n\n        // @review all ether is in eigen pod shares \n        assertEq(uint256(delegatorContract.getEigenPodShares()), 32 * 5 * 1e18);\n        // @review the TVL is the 32*5 ether and the initial deposit\n        assertEq(reETH.assetRegistry.getTVLForAsset(ETH_ADDRESS), 160010000000000000000);\n\n        // @review undelegate from the operator \n        vm.prank(address(uint160(0 + 1)));\n        delegationManager.undelegate(operatorDelegator);\n\n        // @review eigenpod shares are removed fully\n        assertEq(uint256(delegatorContract.getEigenPodShares()), 0);\n        // @review the TVL is only the initial deposit\n        assertEq(reETH.assetRegistry.getTVLForAsset(ETH_ADDRESS), 10000000000000000);\n    }\n```\n## Code Snippet\nhttps://github.com/Layr-Labs/eigenlayer-contracts/blob/6de01c6c16d6df44af15f0b06809dc160eac0ebf/src/contracts/core/DelegationManager.sol#L211-L258\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n\n\n## Discussion\n\n**solimander**\n\nValid, but feels like it should be medium given precondition that you must be voted into the active operator set.\n\n**nevillehuang**\n\nSince operators are not trusted in the context of rio-protocol, I believe high severity to be appropriate since this allows direct manipulation of exchange rates and can cause stuck funds within rio contracts\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/176",
  "Code": [
    {
      "filename": "src/contracts/core/DelegationManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.12;\n\nimport \"@openzeppelin-upgrades/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin-upgrades/contracts/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin-upgrades/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport \"../permissions/Pausable.sol\";\nimport \"../libraries/EIP1271SignatureUtils.sol\";\nimport \"./DelegationManagerStorage.sol\";\n\n/**\n * @title DelegationManager\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice  This is the contract for delegation in EigenLayer. The main functionalities of this contract are\n * - enabling anyone to register as an operator in EigenLayer\n * - allowing operators to specify parameters related to stakers who delegate to them\n * - enabling any staker to delegate its stake to the operator of its choice (a given staker can only delegate to a single operator at a time)\n * - enabling a staker to undelegate its assets from the operator it is delegated to (performed as part of the withdrawal process, initiated through the StrategyManager)\n */\ncontract DelegationManager is Initializable, OwnableUpgradeable, Pausable, DelegationManagerStorage, ReentrancyGuardUpgradeable {\n    // @dev Index for flag that pauses new delegations when set\n    uint8 internal constant PAUSED_NEW_DELEGATION = 0;\n\n    // @dev Index for flag that pauses queuing new withdrawals when set.\n    uint8 internal constant PAUSED_ENTER_WITHDRAWAL_QUEUE = 1;\n\n    // @dev Index for flag that pauses completing existing withdrawals when set.\n    uint8 internal constant PAUSED_EXIT_WITHDRAWAL_QUEUE = 2;\n\n    // @dev Chain ID at the time of contract deployment\n    uint256 internal immutable ORIGINAL_CHAIN_ID;\n\n    // @dev Maximum Value for `stakerOptOutWindowBlocks`. Approximately equivalent to 6 months in blocks.\n    uint256 public constant MAX_STAKER_OPT_OUT_WINDOW_BLOCKS = (180 days) / 12;\n\n    /// @notice Canonical, virtual beacon chain ETH strategy\n    IStrategy public constant beaconChainETHStrategy = IStrategy(0xbeaC0eeEeeeeEEeEeEEEEeeEEeEeeeEeeEEBEaC0);\n\n    // @notice Simple permission for functions that are only callable by the StrategyManager contract OR by the EigenPodManagerContract\n    modifier onlyStrategyManagerOrEigenPodManager() {\n        require(\n            msg.sender == address(strategyManager) || msg.sender == address(eigenPodManager),\n            \"DelegationManager: onlyStrategyManagerOrEigenPodManager\"\n        );\n        _;\n    }\n\n    /*******************************************************************************\n                            INITIALIZING FUNCTIONS\n    *******************************************************************************/\n\n    /**\n     * @dev Initializes the immutable addresses of the strategy mananger and slasher.\n     */\n    constructor(\n        IStrategyManager _strategyManager,\n        ISlasher _slasher,\n        IEigenPodManager _eigenPodManager\n    ) DelegationManagerStorage(_strategyManager, _slasher, _eigenPodManager) {\n        _disableInitializers();\n        ORIGINAL_CHAIN_ID = block.chainid;\n    }\n\n    /**\n     * @dev Initializes the addresses of the initial owner, pauser registry, and paused status.\n     * minWithdrawalDelayBlocks is set only once here\n     */\n    function initialize(\n        address initialOwner,\n        IPauserRegistry _pauserRegistry,\n        uint256 initialPausedStatus,\n        uint256 _minWithdrawalDelayBlocks,\n        IStrategy[] calldata _strategies,\n        uint256[] calldata _withdrawalDelayBlocks\n    ) external initializer {\n        _initializePauser(_pauserRegistry, initialPausedStatus);\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator();\n        _transferOwnership(initialOwner);\n        _initializeMinWithdrawalDelayBlocks(_minWithdrawalDelayBlocks);\n        _setStrategyWithdrawalDelayBlocks(_strategies, _withdrawalDelayBlocks);\n    }\n\n    /*******************************************************************************\n                            EXTERNAL FUNCTIONS \n    *******************************************************************************/\n\n    /**\n     * @notice Registers the caller as an operator in EigenLayer.\n     * @param registeringOperatorDetails is the `OperatorDetails` for the operator.\n     * @param metadataURI is a URI for the operator's metadata, i.e. a link providing more details on the operator.\n     *\n     * @dev Once an operator is registered, they cannot 'deregister' as an operator, and they will forever be considered \"delegated to themself\".\n     * @dev This function will revert if the caller attempts to set their `earningsReceiver` to address(0).\n     * @dev Note that the `metadataURI` is *never stored * and is only emitted in the `OperatorMetadataURIUpdated` event\n     */\n    function registerAsOperator(\n        OperatorDetails calldata registeringOperatorDetails,\n        string calldata metadataURI\n    ) external {\n        require(\n            _operatorDetails[msg.sender].earningsReceiver == address(0),\n            \"DelegationManager.registerAsOperator: operator has already registered\"\n        );\n        _setOperatorDetails(msg.sender, registeringOperatorDetails);\n        SignatureWithExpiry memory emptySignatureAndExpiry;\n        // delegate from the operator to themselves\n        _delegate(msg.sender, msg.sender, emptySignatureAndExpiry, bytes32(0));\n        // emit events\n        emit OperatorRegistered(msg.sender, registeringOperatorDetails);\n        emit OperatorMetadataURIUpdated(msg.sender, metadataURI);\n    }\n\n    /**\n     * @notice Updates an operator's stored `OperatorDetails`.\n     * @param newOperatorDetails is the updated `OperatorDetails` for the operator, to replace their current OperatorDetails`.\n     *\n     * @dev The caller must have previously registered as an operator in EigenLayer.\n     * @dev This function will revert if the caller attempts to set their `earningsReceiver` to address(0).\n     */\n    function modifyOperatorDetails(OperatorDetails calldata newOperatorDetails) external {\n        require(isOperator(msg.sender), \"DelegationManager.modifyOperatorDetails: caller must be an operator\");\n        _setOperatorDetails(msg.sender, newOperatorDetails);\n    }\n\n    /**\n     * @notice Called by an operator to emit an `OperatorMetadataURIUpdated` event indicating the information has updated.\n     * @param metadataURI The URI for metadata associated with an operator\n     */\n    function updateOperatorMetadataURI(string calldata metadataURI) external {\n        require(isOperator(msg.sender), \"DelegationManager.updateOperatorMetadataURI: caller must be an operator\");\n        emit OperatorMetadataURIUpdated(msg.sender, metadataURI);\n    }\n\n    /**\n     * @notice Caller delegates their stake to an operator.\n     * @param operator The account (`msg.sender`) is delegating its assets to for use in serving applications built on EigenLayer.\n     * @param approverSignatureAndExpiry Verifies the operator approves of this delegation\n     * @param approverSalt A unique single use value tied to an individual signature.\n     * @dev The approverSignatureAndExpiry is used in the event that:\n     *          1) the operator's `delegationApprover` address is set to a non-zero value.\n     *                  AND\n     *          2) neither the operator nor their `delegationApprover` is the `msg.sender`, since in the event that the operator\n     *             or their delegationApprover is the `msg.sender`, then approval is assumed.\n     * @dev In the event that `approverSignatureAndExpiry` is not checked, its content is ignored entirely; it's recommended to use an empty input\n     * in this case to save on complexity + gas costs\n     */\n    function delegateTo(\n        address operator,\n        SignatureWithExpiry memory approverSignatureAndExpiry,\n        bytes32 approverSalt\n    ) external {\n        // go through the internal delegation flow, checking the `approverSignatureAndExpiry` if applicable\n        _delegate(msg.sender, operator, approverSignatureAndExpiry, approverSalt);\n    }\n\n    /**\n     * @notice Caller delegates a staker's stake to an operator with valid signatures from both parties.\n     * @param staker The account delegating stake to an `operator` account\n     * @param operator The account (`staker`) is delegating its assets to for use in serving applications built on EigenLayer.\n     * @param stakerSignatureAndExpiry Signed data from the staker authorizing delegating stake to an operator\n     * @param approverSignatureAndExpiry is a parameter that will be used for verifying that the operator approves of this delegation action in the event that:\n     * @param approverSalt Is a salt used to help guarantee signature uniqueness. Each salt can only be used once by a given approver.\n     *\n     * @dev If `staker` is an EOA, then `stakerSignature` is verified to be a valid ECDSA stakerSignature from `staker`, indicating their intention for this action.\n     * @dev If `staker` is a contract, then `stakerSignature` will be checked according to EIP-1271.\n     * @dev the operator's `delegationApprover` address is set to a non-zero value.\n     * @dev neither the operator nor their `delegationApprover` is the `msg.sender`, since in the event that the operator or their delegationApprover\n     * is the `msg.sender`, then approval is assumed.\n     * @dev This function will revert if the current `block.timestamp` is equal to or exceeds the expiry\n     * @dev In the case that `approverSignatureAndExpiry` is not checked, its content is ignored entirely; it's recommended to use an empty input\n     * in this case to save on complexity + gas costs\n     */\n    function delegateToBySignature(\n        address staker,\n        address operator,\n        SignatureWithExpiry memory stakerSignatureAndExpiry,\n        SignatureWithExpiry memory approverSignatureAndExpiry,\n        bytes32 approverSalt\n    ) external {\n        // check the signature expiry\n        require(\n            stakerSignatureAndExpiry.expiry >= block.timestamp,\n            \"DelegationManager.delegateToBySignature: staker signature expired\"\n        );\n\n        // calculate the digest hash, then increment `staker`'s nonce\n        uint256 currentStakerNonce = stakerNonce[staker];\n        bytes32 stakerDigestHash = calculateStakerDelegationDigestHash(\n            staker,\n            currentStakerNonce,\n            operator,\n            stakerSignatureAndExpiry.expiry\n        );\n        unchecked {\n            stakerNonce[staker] = currentStakerNonce + 1;\n        }\n\n        // actually check that the signature is valid\n        EIP1271SignatureUtils.checkSignature_EIP1271(staker, stakerDigestHash, stakerSignatureAndExpiry.signature);\n\n        // go through the internal delegation flow, checking the `approverSignatureAndExpiry` if applicable\n        _delegate(staker, operator, approverSignatureAndExpiry, approverSalt);\n    }\n\n    /**\n     * Allows the staker, the staker's operator, or that operator's delegationApprover to undelegate\n     * a staker from their operator. Undelegation immediately removes ALL active shares/strategies from\n     * both the staker and operator, and places the shares and strategies in the withdrawal queue\n     */\n    function undelegate(address staker) external onlyWhenNotPaused(PAUSED_ENTER_WITHDRAWAL_QUEUE) returns (bytes32[] memory withdrawalRoots) {\n        require(isDelegated(staker), \"DelegationManager.undelegate: staker must be delegated to undelegate\");\n        require(!isOperator(staker), \"DelegationManager.undelegate: operators cannot be undelegated\");\n        require(staker != address(0), \"DelegationManager.undelegate: cannot undelegate zero address\");\n        address operator = delegatedTo[staker];\n        require(\n            msg.sender == staker ||\n                msg.sender == operator ||\n                msg.sender == _operatorDetails[operator].delegationApprover,\n            \"DelegationManager.undelegate: caller cannot undelegate staker\"\n        );\n\n        // Gather strategies and shares to remove from staker/operator during undelegation\n        // Undelegation removes ALL currently-active strategies and shares\n        (IStrategy[] memory strategies, uint256[] memory shares) = getDelegatableShares(staker);\n\n        // emit an event if this action was not initiated by the staker themselves\n        if (msg.sender != staker) {\n            emit StakerForceUndelegated(staker, operator);\n        }\n\n        // undelegate the staker\n        emit StakerUndelegated(staker, operator);\n        delegatedTo[staker] = address(0);\n\n        // if no delegatable shares, return an empty array, and don't queue a withdrawal\n        if (strategies.length == 0) {\n            withdrawalRoots = new bytes32[](0);\n        } else {\n            withdrawalRoots = new bytes32[](strategies.length);\n            for (uint256 i = 0; i < strategies.length; i++) {\n                IStrategy[] memory singleStrategy = new IStrategy[](1);\n                uint256[] memory singleShare = new uint256[](1);\n                singleStrategy[0] = strategies[i];\n                singleShare[0] = shares[i];\n\n                withdrawalRoots[i] = _removeSharesAndQueueWithdrawal({\n                    staker: staker,\n                    operator: operator,\n                    withdrawer: staker,\n                    strategies: singleStrategy,\n                    shares: singleShare\n                });\n            }\n        }\n\n        return withdrawalRoots;\n    }\n\n    /**\n     * Allows a staker to withdraw some shares. Withdrawn shares/strategies are immediately removed\n     * from the staker. If the staker is delegated, withdrawn shares/strategies are also removed from\n     * their operator.\n     *\n     * All withdrawn shares/strategies are placed in a queue and can be fully withdrawn after a delay.\n     */\n    function queueWithdrawals(\n        QueuedWithdrawalParams[] calldata queuedWithdrawalParams\n    ) external onlyWhenNotPaused(PAUSED_ENTER_WITHDRAWAL_QUEUE) returns (bytes32[] memory) {\n        bytes32[] memory withdrawalRoots = new bytes32[](queuedWithdrawalParams.length);\n        address operator = delegatedTo[msg.sender];\n\n        for (uint256 i = 0; i < queuedWithdrawalParams.length; i++) {\n            require(queuedWithdrawalParams[i].strategies.length == queuedWithdrawalParams[i].shares.length, \"DelegationManager.queueWithdrawal: input length mismatch\");\n            require(queuedWithdrawalParams[i].withdrawer != address(0), \"DelegationManager.queueWithdrawal: must provide valid withdrawal address\");\n\n            // Remove shares from staker's strategies and place strategies/shares in queue.\n            // If the staker is delegated to an operator, the operator's delegated shares are also reduced\n            // NOTE: This will fail if the staker doesn't have the shares implied by the input parameters\n            withdrawalRoots[i] = _removeSharesAndQueueWithdrawal({\n                staker: msg.sender,\n                operator: operator,\n                withdrawer: queuedWithdrawalParams[i].withdrawer,\n                strategies: queuedWithdrawalParams[i].strategies,\n                shares: queuedWithdrawalParams[i].shares\n            });\n        }\n        return withdrawalRoots;\n    }\n\n    /**\n     * @notice Used to complete the specified `withdrawal`. The caller must match `withdrawal.withdrawer`\n     * @param withdrawal The Withdrawal to complete.\n     * @param tokens Array in which the i-th entry specifies the `token` input to the 'withdraw' function of the i-th Strategy in the `withdrawal.strategies` array.\n     * This input can be provided with zero length if `receiveAsTokens` is set to 'false' (since in that case, this input will be unused)\n     * @param middlewareTimesIndex is the index in the operator that the staker who triggered the withdrawal was delegated to's middleware times array\n     * @param receiveAsTokens If true, the shares specified in the withdrawal will be withdrawn from the specified strategies themselves\n     * and sent to the caller, through calls to `withdrawal.strategies[i].withdraw`. If false, then the shares in the specified strategies\n     * will simply be transferred to the caller directly.\n     * @dev middlewareTimesIndex is unused, but will be used in the Slasher eventually\n     * @dev beaconChainETHStrategy shares are non-transferrable, so if `receiveAsTokens = false` and `withdrawal.withdrawer != withdrawal.staker`, note that\n     * any beaconChainETHStrategy shares in the `withdrawal` will be _returned to the staker_, rather than transferred to the withdrawer, unlike shares in\n     * any other strategies, which will be transferred to the withdrawer.\n     */\n    function completeQueuedWithdrawal(\n        Withdrawal calldata withdrawal,\n        IERC20[] calldata tokens,\n        uint256 middlewareTimesIndex,\n        bool receiveAsTokens\n    ) external onlyWhenNotPaused(PAUSED_EXIT_WITHDRAWAL_QUEUE) nonReentrant {\n        _completeQueuedWithdrawal(withdrawal, tokens, middlewareTimesIndex, receiveAsTokens);\n    }\n\n    /**\n     * @notice Array-ified version of `completeQueuedWithdrawal`.\n     * Used to complete the specified `withdrawals`. The function caller must match `withdrawals[...].withdrawer`\n     * @param withdrawals The Withdrawals to complete.\n     * @param tokens Array of tokens for each Withdrawal. See `completeQueuedWithdrawal` for the usage of a single array.\n     * @param middlewareTimesIndexes One index to reference per Withdrawal. See `completeQueuedWithdrawal` for the usage of a single index.\n     * @param receiveAsTokens Whether or not to complete each withdrawal as tokens. See `completeQueuedWithdrawal` for the usage of a single boolean.\n     * @dev See `completeQueuedWithdrawal` for relevant dev tags\n     */\n    function completeQueuedWithdrawals(\n        Withdrawal[] calldata withdrawals,\n        IERC20[][] calldata tokens,\n        uint256[] calldata middlewareTimesIndexes,\n        bool[] calldata receiveAsTokens\n    ) external onlyWhenNotPaused(PAUSED_EXIT_WITHDRAWAL_QUEUE) nonReentrant {\n        for (uint256 i = 0; i < withdrawals.length; ++i) {\n            _completeQueuedWithdrawal(withdrawals[i], tokens[i], middlewareTimesIndexes[i], receiveAsTokens[i]);\n        }\n    }\n\n    /// @notice Migrates an array of queued withdrawals from the StrategyManager contract to this contract.\n    /// @dev This function is expected to be removed in the next upgrade, after all queued withdrawals have been migrated.\n    function migrateQueuedWithdrawals(IStrategyManager.DeprecatedStruct_QueuedWithdrawal[] memory withdrawalsToMigrate) external {\n        for(uint256 i = 0; i < withdrawalsToMigrate.length;) {\n            IStrategyManager.DeprecatedStruct_QueuedWithdrawal memory withdrawalToMigrate = withdrawalsToMigrate[i];\n            // Delete withdrawal root from strateyManager\n            (bool isDeleted, bytes32 oldWithdrawalRoot) = strategyManager.migrateQueuedWithdrawal(withdrawalToMigrate);\n            // If old storage is deleted from strategyManager\n            if (isDeleted) {\n                address staker = withdrawalToMigrate.staker;\n                // Create queue entry and increment withdrawal nonce\n                uint256 nonce = cumulativeWithdrawalsQueued[staker];\n                cumulativeWithdrawalsQueued[staker]++;\n\n                Withdrawal memory migratedWithdrawal = Withdrawal({\n                    staker: staker,\n                    delegatedTo: withdrawalToMigrate.delegatedAddress,\n                    withdrawer: withdrawalToMigrate.withdrawerAndNonce.withdrawer,\n                    nonce: nonce,\n                    startBlock: withdrawalToMigrate.withdrawalStartBlock,\n                    strategies: withdrawalToMigrate.strategies,\n                    shares: withdrawalToMigrate.shares\n                });\n\n                // create the new storage\n                bytes32 newRoot = calculateWithdrawalRoot(migratedWithdrawal);\n                // safety check to ensure that root doesn't exist already -- this should *never* be hit\n                require(!pendingWithdrawals[newRoot], \"DelegationManager.migrateQueuedWithdrawals: withdrawal already exists\");\n                pendingWithdrawals[newRoot] = true;\n\n                emit WithdrawalQueued(newRoot, migratedWithdrawal);\n\n                emit WithdrawalMigrated(oldWithdrawalRoot, newRoot);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        \n    }\n\n    /**\n     * @notice Increases a staker's delegated share balance in a strategy.\n     * @param staker The address to increase the delegated shares for their operator.\n     * @param strategy The strategy in which to increase the delegated shares.\n     * @param shares The number of shares to increase.\n     *\n     * @dev *If the staker is actively delegated*, then increases the `staker`'s delegated shares in `strategy` by `shares`. Otherwise does nothing.\n     * @dev Callable only by the StrategyManager or EigenPodManager.\n     */\n    function increaseDelegatedShares(\n        address staker,\n        IStrategy strategy,\n        uint256 shares\n    ) external onlyStrategyManagerOrEigenPodManager {\n        // if the staker is delegated to an operator\n        if (isDelegated(staker)) {\n            address operator = delegatedTo[staker];\n\n            // add strategy shares to delegate's shares\n            _increaseOperatorShares({operator: operator, staker: staker, strategy: strategy, shares: shares});\n        }\n    }\n\n    /**\n     * @notice Decreases a staker's delegated share balance in a strategy.\n     * @param staker The address to increase the delegated shares for their operator.\n     * @param strategy The strategy in which to decrease the delegated shares.\n     * @param shares The number of shares to decrease.\n     *\n     * @dev *If the staker is actively delegated*, then decreases the `staker`'s delegated shares in `strategy` by `shares`. Otherwise does nothing.\n     * @dev Callable only by the StrategyManager or EigenPodManager.\n     */\n    function decreaseDelegatedShares(\n        address staker,\n        IStrategy strategy,\n        uint256 shares\n    ) external onlyStrategyManagerOrEigenPodManager {\n        // if the staker is delegated to an operator\n        if (isDelegated(staker)) {\n            address operator = delegatedTo[staker];\n\n            // subtract strategy shares from delegate's shares\n            _decreaseOperatorShares({\n                operator: operator,\n                staker: staker,\n                strategy: strategy,\n                shares: shares\n            });\n        }\n    }\n\n    /**\n     * @notice Called by owner to set the minimum withdrawal delay blocks for each passed in strategy\n     * Note that the min number of blocks to complete a withdrawal of a strategy is \n     * MAX(minWithdrawalDelayBlocks, strategyWithdrawalDelayBlocks[strategy])\n     * @param strategies The strategies to set the minimum withdrawal delay blocks for\n     * @param withdrawalDelayBlocks The minimum withdrawal delay blocks to set for each strategy\n     */\n    function setStrategyWithdrawalDelayBlocks(\n        IStrategy[] calldata strategies,\n        uint256[] calldata withdrawalDelayBlocks\n    ) external onlyOwner {\n        _setStrategyWithdrawalDelayBlocks(strategies, withdrawalDelayBlocks);\n    }\n\n    /*******************************************************************************\n                            INTERNAL FUNCTIONS\n    *******************************************************************************/\n\n    /**\n     * @notice Sets operator parameters in the `_operatorDetails` mapping.\n     * @param operator The account registered as an operator updating their operatorDetails\n     * @param newOperatorDetails The new parameters for the operator\n     *\n     * @dev This function will revert if the operator attempts to set their `earningsReceiver` to address(0).\n     */\n    function _setOperatorDetails(address operator, OperatorDetails calldata newOperatorDetails) internal {\n        require(\n            newOperatorDetails.earningsReceiver != address(0),\n            \"DelegationManager._setOperatorDetails: cannot set `earningsReceiver` to zero address\"\n        );\n        require(\n            newOperatorDetails.stakerOptOutWindowBlocks <= MAX_STAKER_OPT_OUT_WINDOW_BLOCKS,\n            \"DelegationManager._setOperatorDetails: stakerOptOutWindowBlocks cannot be > MAX_STAKER_OPT_OUT_WINDOW_BLOCKS\"\n        );\n        require(\n            newOperatorDetails.stakerOptOutWindowBlocks >= _operatorDetails[operator].stakerOptOutWindowBlocks,\n            \"DelegationManager._setOperatorDetails: stakerOptOutWindowBlocks cannot be decreased\"\n        );\n        _operatorDetails[operator] = newOperatorDetails;\n        emit OperatorDetailsModified(msg.sender, newOperatorDetails);\n    }\n\n    /**\n     * @notice Delegates *from* a `staker` *to* an `operator`.\n     * @param staker The address to delegate *from* -- this address is delegating control of its own assets.\n     * @param operator The address to delegate *to* -- this address is being given power to place the `staker`'s assets at risk on services\n     * @param approverSignatureAndExpiry Verifies the operator approves of this delegation\n     * @param approverSalt Is a salt used to help guarantee signature uniqueness. Each salt can only be used once by a given approver.\n     * @dev Ensures that:\n     *          1) the `staker` is not already delegated to an operator\n     *          2) the `operator` has indeed registered as an operator in EigenLayer\n     *          3) if applicable, that the approver signature is valid and non-expired\n     */\n    function _delegate(\n        address staker,\n        address operator,\n        SignatureWithExpiry memory approverSignatureAndExpiry,\n        bytes32 approverSalt\n    ) internal onlyWhenNotPaused(PAUSED_NEW_DELEGATION) {\n        require(!isDelegated(staker), \"DelegationManager._delegate: staker is already actively delegated\");\n        require(isOperator(operator), \"DelegationManager._delegate: operator is not registered in EigenLayer\");\n\n        // fetch the operator's `delegationApprover` address and store it in memory in case we need to use it multiple times\n        address _delegationApprover = _operatorDetails[operator].delegationApprover;\n        /**\n         * Check the `_delegationApprover`'s signature, if applicable.\n         * If the `_delegationApprover` is the zero address, then the operator allows all stakers to delegate to them and this verification is skipped.\n         * If the `_delegationApprover` or the `operator` themselves is the caller, then approval is assumed and signature verification is skipped as well.\n         */\n        if (_delegationApprover != address(0) && msg.sender != _delegationApprover && msg.sender != operator) {\n            // check the signature expiry\n            require(\n                approverSignatureAndExpiry.expiry >= block.timestamp,\n                \"DelegationManager._delegate: approver signature expired\"\n            );\n            // check that the salt hasn't been used previously, then mark the salt as spent\n            require(\n                !delegationApproverSaltIsSpent[_delegationApprover][approverSalt],\n                \"DelegationManager._delegate: approverSalt already spent\"\n            );\n            delegationApproverSaltIsSpent[_delegationApprover][approverSalt] = true;\n\n            // calculate the digest hash\n            bytes32 approverDigestHash = calculateDelegationApprovalDigestHash(\n                staker,\n                operator,\n                _delegationApprover,\n                approverSalt,\n                approverSignatureAndExpiry.expiry\n            );\n\n            // actually check that the signature is valid\n            EIP1271SignatureUtils.checkSignature_EIP1271(\n                _delegationApprover,\n                approverDigestHash,\n                approverSignatureAndExpiry.signature\n            );\n        }\n\n        // record the delegation relation between the staker and operator, and emit an event\n        delegatedTo[staker] = operator;\n        emit StakerDelegated(staker, operator);\n\n        (IStrategy[] memory strategies, uint256[] memory shares)\n            = getDelegatableShares(staker);\n\n        for (uint256 i = 0; i < strategies.length;) {\n            _increaseOperatorShares({\n                operator: operator,\n                staker: staker,\n                strategy: strategies[i],\n                shares: shares[i]\n            });\n\n            unchecked { ++i; }\n        }\n    }\n\n    /**\n     * @dev commented-out param (middlewareTimesIndex) is the index in the operator that the staker who triggered the withdrawal was delegated to's middleware times array\n     * This param is intended to be passed on to the Slasher contract, but is unused in the M2 release of these contracts, and is thus commented-out.\n     */\n    function _completeQueuedWithdrawal(\n        Withdrawal calldata withdrawal,\n        IERC20[] calldata tokens,\n        uint256 /*middlewareTimesIndex*/,\n        bool receiveAsTokens\n    ) internal {\n        bytes32 withdrawalRoot = calculateWithdrawalRoot(withdrawal);\n\n        require(\n            pendingWithdrawals[withdrawalRoot], \n            \"DelegationManager._completeQueuedWithdrawal: action is not in queue\"\n        );\n\n        require(\n            withdrawal.startBlock + minWithdrawalDelayBlocks <= block.number, \n            \"DelegationManager._completeQueuedWithdrawal: minWithdrawalDelayBlocks period has not yet passed\"\n        );\n\n        require(\n            msg.sender == withdrawal.withdrawer, \n            \"DelegationManager._completeQueuedWithdrawal: only withdrawer can complete action\"\n        );\n\n        if (receiveAsTokens) {\n            require(\n                tokens.length == withdrawal.strategies.length, \n                \"DelegationManager._completeQueuedWithdrawal: input length mismatch\"\n            );\n        }\n\n        // Remove `withdrawalRoot` from pending roots\n        delete pendingWithdrawals[withdrawalRoot];\n\n        // Finalize action by converting shares to tokens for each strategy, or\n        // by re-awarding shares in each strategy.\n        if (receiveAsTokens) {\n            for (uint256 i = 0; i < withdrawal.strategies.length; ) {\n                require(\n                    withdrawal.startBlock + strategyWithdrawalDelayBlocks[withdrawal.strategies[i]] <= block.number,\n                    \"DelegationManager._completeQueuedWithdrawal: withdrawalDelayBlocks period has not yet passed for this strategy\"\n                );\n\n                _withdrawSharesAsTokens({\n                    staker: withdrawal.staker,\n                    withdrawer: msg.sender,\n                    strategy: withdrawal.strategies[i],\n                    shares: withdrawal.shares[i],\n                    token: tokens[i]\n                });\n                unchecked { ++i; }\n            }\n        // Award shares back in StrategyManager/EigenPodManager. If withdrawer is delegated, increase the shares delegated to the operator\n        } else {\n            address currentOperator = delegatedTo[msg.sender];\n            for (uint256 i = 0; i < withdrawal.strategies.length; ) {\n                require(\n                    withdrawal.startBlock + strategyWithdrawalDelayBlocks[withdrawal.strategies[i]] <= block.number, \n                    \"DelegationManager._completeQueuedWithdrawal: withdrawalDelayBlocks period has not yet passed for this strategy\"\n                );\n\n                /** When awarding podOwnerShares in EigenPodManager, we need to be sure to only give them back to the original podOwner.\n                 * Other strategy shares can + will be awarded to the withdrawer.\n                 */\n                if (withdrawal.strategies[i] == beaconChainETHStrategy) {\n                    address staker = withdrawal.staker;\n                    /**\n                    * Update shares amount depending upon the returned value.\n                    * The return value will be lower than the input value in the case where the staker has an existing share deficit\n                    */\n                    uint256 increaseInDelegateableShares = eigenPodManager.addShares({\n                        podOwner: staker,\n                        shares: withdrawal.shares[i]\n                    });\n                    address podOwnerOperator = delegatedTo[staker];\n                    // Similar to `isDelegated` logic\n                    if (podOwnerOperator != address(0)) {\n                        _increaseOperatorShares({\n                            operator: podOwnerOperator,\n                            // the 'staker' h"
    }
  ]
}