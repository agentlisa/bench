{
  "Title": "[G-17] Sort Solidity operations using short-circuit mode",
  "Content": "\nShort-circuiting is a solidity contract development model that uses ```OR/AND``` logic to sequence different cost operations. It puts low gas cost operations in the front and high gas cost operations in the back, so that if the front is low If the cost operation is feasible, you can skip (short-circuit) the subsequent high-cost Ethereum virtual machine operation.\n\n```\n//f(x) is a low gas cost operation \n//g(y) is a high gas cost operation \n\n//Sort operations with different gas costs as follows \nf(x) || g(y) \nf(x) && g(y)\n```\n4 results - 3 files:\n```solidity\ncanto-bio-protocol\\src\\Bio.sol:\n\n  60:    if ((i > 0 && (i + 1) % 40 == 0) || prevByteWasContinuation || i == lengthInBytes - 1) {\n\n 123:    if (bytes(_bio).length == 0 || bytes(_bio).length > 200) revert InvalidBioLength(bytes(_bio).length);\n\n```\nhttps://github.com/code-423n4/2023-03-canto-identity/blob/main/canto-bio-protocol/src/Bio.sol#L60\n\n\n```solidity\ncanto-namespace-protocol\\src\\Namespace.sol:\n\n  112:   if (numCharacters > 13 || numCharacters == 0) revert InvalidNumberOfCharacters(numCharacters);\n\n```\nhttps://github.com/code-423n4/2023-03-canto-identity/blob/main/canto-namespace-protocol/src/Namespace.sol#L112\n\n\n```solidity\ncanto-pfp-protocol\\src\\ProfilePicture.sol:\n\n  101:   if (cidNFTID == 0 || addressRegistry.getAddress(cidNFTID) != ERC721(nftContract).ownerOf(nftID)) {\n\n```\nhttps://github.com/code-423n4/2023-03-canto-identity/blob/main/canto-pfp-protocol/src/ProfilePicture.sol#L101\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2023-03-canto-identity-subprotocols-contest",
  "Code": [
    {
      "filename": "canto-bio-protocol/src/Bio.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {LibString} from \"solmate/utils/LibString.sol\";\nimport {Base64} from \"solady/utils/Base64.sol\";\nimport \"../interface/Turnstile.sol\";\n\ncontract Bio is ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Number of tokens minted\n    uint256 public numMinted;\n\n    /// @notice Stores the bio value per NFT\n    mapping(uint256 => string) public bio;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event BioAdded(address indexed minter, uint256 indexed nftID, string indexed bio);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error TokenNotMinted(uint256 tokenID);\n    error InvalidBioLength(uint256 length);\n\n    /// @notice Initiates CSR on mainnet\n    constructor() ERC721(\"Biography\", \"Bio\") {\n        if (block.chainid == 7700) {\n            // Register CSR on Canto mainnnet\n            Turnstile turnstile = Turnstile(0xEcf044C5B4b867CFda001101c617eCd347095B44);\n            turnstile.register(tx.origin);\n        }\n    }\n\n    /// @notice Get the token URI for the specified _id\n    /// @dev Generates an on-chain SVG with a new line after 40 bytes. Line splitting generally supports UTF-8 multibyte characters and emojis, but is not tested for arbitrary UTF-8 characters\n    /// @param _id ID to query for\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        if (_ownerOf[_id] == address(0)) revert TokenNotMinted(_id);\n        string memory bioText = bio[_id];\n        bytes memory bioTextBytes = bytes(bioText);\n        uint lengthInBytes = bioTextBytes.length;\n        // Insert a new line after 40 characters, taking into account unicode character\n        uint lines = (lengthInBytes - 1) / 40 + 1;\n        string[] memory strLines = new string[](lines);\n        bool prevByteWasContinuation;\n        uint256 insertedLines;\n        // Because we do not split on zero-width joiners, line in bytes can technically be much longer. Will be shortened to the needed length afterwards\n        bytes memory bytesLines = new bytes(80);\n        uint bytesOffset;\n        for (uint i; i < lengthInBytes; ++i) {\n            bytes1 character = bioTextBytes[i];\n            bytesLines[bytesOffset] = character;\n            bytesOffset++;\n            if ((i > 0 && (i + 1) % 40 == 0) || prevByteWasContinuation || i == lengthInBytes - 1) {\n                bytes1 nextCharacter;\n                if (i != lengthInBytes - 1) {\n                    nextCharacter = bioTextBytes[i + 1];\n                }\n                if (nextCharacter & 0xC0 == 0x80) {\n                    // Unicode continuation byte, top two bits are 10\n                    prevByteWasContinuation = true;\n                } else {\n                    // Do not split when the prev. or next character is a zero width joiner. Otherwise, üë®‚Äçüëß‚Äçüë¶ could become üë®>‚Äçüëß‚Äçüë¶\n                    // Furthermore, do not split when next character is skin tone modifier to avoid ü§¶‚Äç‚ôÇÔ∏è\\nüèª\n                    if (\n                        // Note that we do not need to check i < lengthInBytes - 4, because we assume that it's a valid UTF8 string and these prefixes imply that another byte follows\n                        (nextCharacter == 0xE2 && bioTextBytes[i + 2] == 0x80 && bioTextBytes[i + 3] == 0x8D) ||\n                        (nextCharacter == 0xF0 &&\n                            bioTextBytes[i + 2] == 0x9F &&\n                            bioTextBytes[i + 3] == 0x8F &&\n                            uint8(bioTextBytes[i + 4]) >= 187 &&\n                            uint8(bioTextBytes[i + 4]) <= 191) ||\n                        (i >= 2 &&\n                            bioTextBytes[i - 2] == 0xE2 &&\n                            bioTextBytes[i - 1] == 0x80 &&\n                            bioTextBytes[i] == 0x8D)\n                    ) {\n                        prevByteWasContinuation = true;\n                        continue;\n                    }\n                    assembly {\n                        mstore(bytesLines, bytesOffset)\n                    }\n                    strLines[insertedLines++] = string(bytesLines);\n                    bytesLines = new bytes(80);\n                    prevByteWasContinuation = false;\n                    bytesOffset = 0;\n                }\n            }\n        }\n        string\n            memory svg = '<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 400 100\"><style>text { font-family: sans-serif; font-size: 12px; }</style>';\n        string memory text = '<text x=\"50%\" y=\"50%\" dominant-baseline=\"middle\" text-anchor=\"middle\">';\n        for (uint i; i < lines; ++i) {\n            text = string.concat(text, '<tspan x=\"50%\" dy=\"20\">', strLines[i], \"</tspan>\");\n        }\n        string memory json = Base64.encode(\n            bytes(\n                string.concat(\n                    '{\"name\": \"Bio #',\n                    LibString.toString(_id),\n                    '\", \"description\": \"',\n                    bioText,\n                    '\", \"image\": \"data:image/svg+xml;base64,',\n                    Base64.encode(bytes(string.concat(svg, text, \"</text></svg>\"))),\n                    '\"}'\n                )\n            )\n        );\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\n    }\n\n    /// @notice Mint a new Bio NFT\n    /// @param _bio The text to add\n    function mint(string calldata _bio) external {\n        // We check the length in bytes, so will be higher for UTF-8 characters. But sufficient for this check\n        if (bytes(_bio).length == 0 || bytes(_bio).length > 200) revert InvalidBioLength(bytes(_bio).length);\n        uint256 tokenId = ++numMinted;\n        bio[tokenId] = _bio;\n        _mint(msg.sender, tokenId);\n        emit BioAdded(msg.sender, tokenId, _bio);\n    }\n}"
    },
    {
      "filename": "canto-namespace-protocol/src/Namespace.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {Base64} from \"solady/utils/Base64.sol\";\nimport \"./Tray.sol\";\nimport \"./Utils.sol\";\nimport \"../interface/Turnstile.sol\";\n\ncontract Namespace is ERC721, Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Reference to the Tray NFT\n    Tray public immutable tray;\n\n    /// @notice Reference to the $NOTE TOKEN\n    ERC20 public note;\n\n    /// @notice Wallet that receives the revenue\n    address private revenueAddress;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice References the tile for fusing by specifying the tray ID and the index within the tray\n    struct CharacterData {\n        /// @notice ID of the Tray NFT\n        uint256 trayID;\n        /// @notice Offset of the tile within the tray. Valid values 0..TILES_PER_TRAY - 1\n        uint8 tileOffset;\n        /// @notice Emoji modifier for the skin tone. Can have values of 0 (yellow) and 1 - 5 (light to dark). Only supported by some emojis\n        uint8 skinToneModifier;\n    }\n\n    /// @notice Next Namespace ID to mint. We start with minting at ID 1\n    uint256 public nextNamespaceIDToMint;\n\n    /// @notice Maps names to NFT IDs\n    mapping(string => uint256) public nameToToken;\n\n    /// @notice Maps NFT IDs to (ASCII) names\n    mapping(uint256 => string) public tokenToName;\n\n    /// @notice Stores the character data of an NFT\n    mapping(uint256 => Tray.TileData[]) private nftCharacters;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event NamespaceFused(address indexed fuser, uint256 indexed namespaceId, string indexed name);\n    event RevenueAddressUpdated(address indexed oldRevenueAddress, address indexed newRevenueAddress);\n    event NoteAddressUpdate(address indexed oldNoteAddress, address indexed newNoteAddress);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error CallerNotAllowedToFuse();\n    error CallerNotAllowedToBurn();\n    error InvalidNumberOfCharacters(uint256 numCharacters);\n    error FusingDuplicateCharactersNotAllowed();\n    error NameAlreadyRegistered(uint256 nftID);\n    error TokenNotMinted(uint256 tokenID);\n    error CannotFuseCharacterWithSkinTone();\n\n    /// @notice Sets the reference to the tray\n    /// @param _tray Address of the tray contract\n    /// @param _note Address of the $NOTE token\n    /// @param _revenueAddress Adress to send the revenue to\n    constructor(\n        address _tray,\n        address _note,\n        address _revenueAddress\n    ) ERC721(\"Namespace\", \"NS\") Owned(msg.sender) {\n        tray = Tray(_tray);\n        note = ERC20(_note);\n        revenueAddress = _revenueAddress;\n        if (block.chainid == 7700) {\n            // Register CSR on Canto mainnnet\n            Turnstile turnstile = Turnstile(0xEcf044C5B4b867CFda001101c617eCd347095B44);\n            turnstile.register(tx.origin);\n        }\n    }\n\n    /// @notice Get the token URI for the specified _id\n    /// @param _id ID to query for\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        if (_ownerOf[_id] == address(0)) revert TokenNotMinted(_id);\n        string memory json = Base64.encode(\n            bytes(\n                string(\n                    abi.encodePacked(\n                        '{\"name\": \"',\n                        tokenToName[_id],\n                        '\", \"image\": \"data:image/svg+xml;base64,',\n                        Base64.encode(bytes(Utils.generateSVG(nftCharacters[_id], false))),\n                        '\"}'\n                    )\n                )\n            )\n        );\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\n    }\n\n    /// @notice Fuse a new Namespace NFT with the referenced tiles\n    /// @param _characterList The tiles to use for the fusing\n    function fuse(CharacterData[] calldata _characterList) external {\n        uint256 numCharacters = _characterList.length;\n        if (numCharacters > 13 || numCharacters == 0) revert InvalidNumberOfCharacters(numCharacters);\n        uint256 fusingCosts = 2**(13 - numCharacters) * 1e18;\n        SafeTransferLib.safeTransferFrom(note, msg.sender, revenueAddress, fusingCosts);\n        uint256 namespaceIDToMint = ++nextNamespaceIDToMint;\n        Tray.TileData[] storage nftToMintCharacters = nftCharacters[namespaceIDToMint];\n        bytes memory bName = new bytes(numCharacters * 33); // Used to convert into a string. Can be 33 times longer than the string at most (longest zalgo characters is 33 bytes)\n        uint256 numBytes;\n        // Extract unique trays for burning them later on\n        uint256 numUniqueTrays;\n        uint256[] memory uniqueTrays = new uint256[](_characterList.length);\n        for (uint256 i; i < numCharacters; ++i) {\n            bool isLastTrayEntry = true;\n            uint256 trayID = _characterList[i].trayID;\n            uint8 tileOffset = _characterList[i].tileOffset;\n            // Check for duplicate characters in the provided list. 1/2 * n^2 loop iterations, but n is bounded to 13 and we do not perform any storage operations\n            for (uint256 j = i + 1; j < numCharacters; ++j) {\n                if (_characterList[j].trayID == trayID) {\n                    isLastTrayEntry = false;\n                    if (_characterList[j].tileOffset == tileOffset) revert FusingDuplicateCharactersNotAllowed();\n                }\n            }\n            Tray.TileData memory tileData = tray.getTile(trayID, tileOffset); // Will revert if tileOffset is too high\n            uint8 characterModifier = tileData.characterModifier;\n\n            if (tileData.fontClass != 0 && _characterList[i].skinToneModifier != 0) {\n                revert CannotFuseCharacterWithSkinTone();\n            }\n            \n            if (tileData.fontClass == 0) {\n                // Emoji\n                characterModifier = _characterList[i].skinToneModifier;\n            }\n            bytes memory charAsBytes = Utils.characterToUnicodeBytes(0, tileData.characterIndex, characterModifier);\n            tileData.characterModifier = characterModifier;\n            uint256 numBytesChar = charAsBytes.length;\n            for (uint256 j; j < numBytesChar; ++j) {\n                bName[numBytes + j] = charAsBytes[j];\n            }\n            numBytes += numBytesChar;\n            nftToMintCharacters.push(tileData);\n            // We keep track of the unique trays NFTs (for burning them) and only check the owner once for the last occurence of the tray\n            if (isLastTrayEntry) {\n                uniqueTrays[numUniqueTrays++] = trayID;\n                // Verify address is allowed to fuse\n                address trayOwner = tray.ownerOf(trayID);\n                if (\n                    trayOwner != msg.sender &&\n                    tray.getApproved(trayID) != msg.sender &&\n                    !tray.isApprovedForAll(trayOwner, msg.sender)\n                ) revert CallerNotAllowedToFuse();\n            }\n        }\n        // Set array to the real length (in bytes) to avoid zero bytes in the end when doing the string conversion\n        assembly {\n            mstore(bName, numBytes)\n        }\n        string memory nameToRegister = string(bName);\n        uint256 currentRegisteredID = nameToToken[nameToRegister];\n        if (currentRegisteredID != 0) revert NameAlreadyRegistered(currentRegisteredID);\n        nameToToken[nameToRegister] = namespaceIDToMint;\n        tokenToName[namespaceIDToMint] = nameToRegister;\n\n        for (uint256 i; i < numUniqueTrays; ++i) {\n            tray.burn(uniqueTrays[i]);\n        }\n        _mint(msg.sender, namespaceIDToMint);\n        // Although _mint already emits an event, we additionally emit one because of the name\n        emit NamespaceFused(msg.sender, namespaceIDToMint, nameToRegister);\n    }\n\n    /// @notice Burn a specified Namespace NFT\n    /// @param _id Namespace NFT ID\n    function burn(uint256 _id) external {\n        address nftOwner = ownerOf(_id);\n        if (nftOwner != msg.sender && getApproved[_id] != msg.sender && !isApprovedForAll[nftOwner][msg.sender])\n            revert CallerNotAllowedToBurn();\n        string memory associatedName = tokenToName[_id];\n        delete tokenToName[_id];\n        delete nameToToken[associatedName];\n        _burn(_id);\n    }\n\n    /// @notice Change the address of the $NOTE token\n    /// @param _newNoteAddress New address to use\n    function changeNoteAddress(address _newNoteAddress) external onlyOwner {\n        address currentNoteAddress = address(note);\n        note = ERC20(_newNoteAddress);\n        emit NoteAddressUpdate(currentNoteAddress, _newNoteAddress);\n    }\n\n    /// @notice Change the revenue address\n    /// @param _newRevenueAddress New address to use\n    function changeRevenueAddress(address _newRevenueAddress) external onlyOwner {\n        address currentRevenueAddress = revenueAddress;\n        revenueAddress = _newRevenueAddress;\n        emit RevenueAddressUpdated(currentRevenueAddress, _newRevenueAddress);\n    }\n}"
    },
    {
      "filename": "canto-pfp-protocol/src/ProfilePicture.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport \"../interface/Turnstile.sol\";\nimport \"../interface/ICidNFT.sol\";\n\ncontract ProfilePicture is ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Reference to the CID NFT\n    ICidNFT private immutable cidNFT;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Data that is stored per PFP\n    struct ProfilePictureData {\n        /// @notice Reference to the NFT contract\n        address nftContract;\n        /// @notice Referenced nft ID\n        uint256 nftID;\n    }\n\n    /// @notice Number of tokens minted\n    uint256 public numMinted;\n\n    /// @notice Stores the pfp data per NFT\n    mapping(uint256 => ProfilePictureData) private pfp;\n\n    /// @notice Name with which the subprotocol is registered\n    string public subprotocolName;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event PfpAdded(\n        address indexed minter,\n        uint256 indexed pfpNftID,\n        address indexed referencedContract,\n        uint256 referencedNftId\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error TokenNotMinted(uint256 tokenID);\n    error PFPNoLongerOwnedByOriginalOwner(uint256 tokenID);\n    error PFPNotOwnedByCaller(address caller, address nftContract, uint256 nftID);\n\n    /// @notice Initiates CSR on mainnet\n    /// @param _cidNFT Address of the CID NFT\n    /// @param _subprotocolName Name with which the subprotocol is / will be registered in the registry. Registration will not be performed automatically\n    constructor(address _cidNFT, string memory _subprotocolName) ERC721(\"Profile Picture\", \"PFP\") {\n        cidNFT = ICidNFT(_cidNFT);\n        subprotocolName = _subprotocolName;\n        if (block.chainid == 7700) {\n            // Register CSR on Canto mainnnet\n            Turnstile turnstile = Turnstile(0xEcf044C5B4b867CFda001101c617eCd347095B44);\n            turnstile.register(tx.origin);\n        }\n    }\n\n    /// @notice Get the token URI for the specified _id\n    /// @param _id ID to query for\n    /// @dev Reverts if PFP is no longer owned by owner of associated CID NFT\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        (address nftContract, uint256 nftID) = getPFP(_id);\n        if (nftContract == address(0)) revert PFPNoLongerOwnedByOriginalOwner(_id);\n        return ERC721(nftContract).tokenURI(nftID);\n    }\n\n    /// @notice Mint a new PFP NFT\n    /// @param _nftContract The nft contract address to reference\n    /// @param _nftID The nft ID to reference\n    function mint(address _nftContract, uint256 _nftID) external {\n        uint256 tokenId = ++numMinted;\n        if (ERC721(_nftContract).ownerOf(_nftID) != msg.sender)\n            revert PFPNotOwnedByCaller(msg.sender, _nftContract, _nftID);\n        ProfilePictureData storage pictureData = pfp[tokenId];\n        pictureData.nftContract = _nftContract;\n        pictureData.nftID = _nftID;\n        _mint(msg.sender, tokenId);\n        emit PfpAdded(msg.sender, tokenId, _nftContract, _nftID);\n    }\n\n    /// @notice Query the referenced profile picture\n    /// @dev Checks if the PFP is still owned by the owner of the CID NFT\n    /// @param _pfpID Profile picture NFT ID to query\n    /// @return nftContract The referenced NFT contract (address(0) if no longer owned), nftID The referenced NFT ID\n    function getPFP(uint256 _pfpID) public view returns (address nftContract, uint256 nftID) {\n        if (_ownerOf[_pfpID] == address(0)) revert TokenNotMinted(_pfpID);\n        ProfilePictureData storage pictureData = pfp[_pfpID];\n        nftContract = pictureData.nftContract;\n        nftID = pictureData.nftID;\n        uint256 cidNFTID = cidNFT.getPrimaryCIDNFT(subprotocolName, _pfpID);\n        IAddressRegistry addressRegistry = cidNFT.addressRegistry();\n        if (cidNFTID == 0 || addressRegistry.getAddress(cidNFTID) != ERC721(nftContract).ownerOf(nftID)) {\n            nftContract = address(0);\n            nftID = 0; // Strictly not needed because nftContract has to be always checked, but reset nevertheless to 0\n        }\n    }\n}"
    }
  ]
}