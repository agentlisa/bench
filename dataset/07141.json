{
  "Title": "[G-01] Make for loop unchecked",
  "Content": "The risk of for loops getting overflowed is extremely low. Because it always increments by 1 and is limited to the arrays length. Even if the arrays are extremely long, it will take a massive amount of time and gas to let the for loop overflow.\n\n- [Caller.sol#L196-L199](https://github.com/code-423n4/2023-01-drips/blob/main/src/Caller.sol#L196-L199): `callBatched()` gas saved: 76\n- [ImmutableSplitsDriver.sol#L61-L63](https://github.com/code-423n4/2023-01-drips/blob/main/src/ImmutableSplitsDriver.sol#L61-L63): `createSplits()` gas saved: 92\n- [Drips.sol#L247-L249](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L247-L249): `DripsHub: receiveDrips()` gas saved: 58 \n- [Drips.sol#L287-L291](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L287-L291): `DripsHub: receiveDripsResult()` gas saved: 54\n- [Drips.sol#L357-L364](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L357-L364): `DripsHub: squeezeDrips()` gas saved: 32\n- [Drips.sol#L450-L459](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L450-L459): `DripsHub: squeezeDripsResult()` gas saved: 71\n- [Drips.sol#L490-L497](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L490-L497): `DripsHub: squeezeDripsResult()` gas saved: 29\n- [Drips.sol#L563-L573](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L563-L573): `DripsHub: balanceAt()` gas saved: 59\n- [Drips.sol#L662-L668](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L662-L668): `DripsHub: setDrips()` gas saved: 31\n- [DripsHub.sol#L613-L616](https://github.com/code-423n4/2023-01-drips/blob/main/src/DripsHub.sol#L613-L616): `emitUserMetadata()` gas saved: 59\n- [Splits.sol#L127-L129](https://github.com/code-423n4/2023-01-drips/blob/main/src/Splits.sol#L127-L129): `DripsHub: splitResult()` gas saved: 10\n- [Splits.sol#L158-L166](https://github.com/code-423n4/2023-01-drips/blob/main/src/Splits.sol#L158-L166): `DripsHub: split()` gas saved: 10\n- [Splits.sol#L231-L243](https://github.com/code-423n4/2023-01-drips/blob/main/src/Splits.sol#L231-L243): `DripsHub: setSplits()` gas saved: 63\n\nThere are 2 ways to make a for loop unchecked in a safe way:\n\n```diff\n-       for (uint256 i = 0; i < calls.length; i++) {\n-       for (uint256 i = 0; i < calls.length;) {\n            Call memory call = calls[i];\n            returnData[i] = _call(sender, call.to, call.data, call.value);\n+           unchecked{\n+              i++\n+           } \n        }\n```\n```diff\n+       function unchecked_inc(uint256 x) private pure returns (uint256) {\n+          unchecked {\n+             return x + 1;\n+          }\n+       }\n\n-       for (uint256 i = 0; i < calls.length; i++) {\n+       for (uint256 i = 0; i < calls.length;  i = unchecked_inc(i)) {\n            Call memory call = calls[i];\n            returnData[i] = _call(sender, call.to, call.data, call.value);\n        }\n```\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2023-01-drips-protocol-contest",
  "Code": [
    {
      "filename": "src/Caller.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.17;\n\nimport {Address} from \"openzeppelin-contracts/utils/Address.sol\";\nimport {ECDSA, EIP712} from \"openzeppelin-contracts/utils/cryptography/draft-EIP712.sol\";\nimport {ERC2771Context} from \"openzeppelin-contracts/metatx/ERC2771Context.sol\";\nimport {EnumerableSet} from \"openzeppelin-contracts/utils/structs/EnumerableSet.sol\";\n\nusing EnumerableSet for EnumerableSet.AddressSet;\n\n/// @notice Description of a call.\n/// @param to The called address.\n/// @param data The calldata to be used for the call.\n/// @param value The value of the call.\nstruct Call {\n    address to;\n    bytes data;\n    uint256 value;\n}\n\n/// @notice A generic call executor increasing flexibility of other smart contracts' APIs.\n/// It offers 3 main features, which can be mixed and matched for even more flexibility:\n/// - Authorizing addresses to act on behalf of other addresses\n/// - Support for EIP-712 messages\n/// - Batching calls\n///\n/// `Caller` adds these features to the APIs of all smart contracts reading the message\n/// sender passed as per ERC-2771 and accepting this contract as a trusted forwarder.\n/// To all other contracts `Caller` adds a feature of batching calls\n/// for all functions tolerating `msg.sender` being an instance of `Caller`.\n///\n/// Usage examples:\n/// - Batching sequences of calls to a contract.\n/// The contract API may consist of many functions which need to be called in sequence,\n/// but it may not offer a composite functions performing exactly that sequence.\n/// It's expensive, slow and unreliable to create a separate transaction for each step.\n/// To solve that problem create a batch of calls and submit it to `callBatched`.\n/// - Batching sequences of calls to multiple contracts.\n/// It's a common pattern to submit an ERC-2612 permit to approve a smart contract\n/// to spend the user's ERC-20 tokens before running that contract's logic.\n/// Unfortunately unless the contract's API accepts signed messages for the token it requires\n/// creating two separate transactions making it as inconvenient as a regular approval.\n/// The solution is again to use `callBatched` because it can call multiple contracts.\n/// Just create a batch first calling the ERC-20 contract and then the contract needing the tokens.\n/// - Setting up a proxy address.\n/// Sometimes a secure but inconvenient to use address like a cold wallet\n/// or a multisig needs to have a proxy or an operator.\n/// That operator is temporarily trusted, but later it must be revoked or rotated.\n/// To achieve this first `authorize` the proxy using the safe address and then use that proxy\n/// to act on behalf of the secure address using `callAs`.\n/// Later, when the proxy address needs to be revoked, either the secure address or the proxy itself\n/// can `unauthorize` the proxy address and maybe `authorize` another address.\n/// - Setting up operations callable by others.\n/// Some operations may benefit from being callable either by trusted addresses or by anybody.\n/// To achieve this deploy a smart contract executing these operations\n/// via `callAs` and, if you need that too, implementing a custom authorization.\n/// Finally, `authorize` this smart contract to act on behalf of your address.\n/// - Batching dynamic sequences of calls.\n/// Some operations need to react dynamically to the state of the blockchain.\n/// For example an unknown amount of funds is retrieved from a smart contract,\n/// which then needs to be dynamically split and used for different purposes.\n/// To do this, first deploy a smart contract performing that logic.\n/// Next, call `callBatched` which first calls `authorize` on the `Caller` itself authorizing\n/// the new contract to perform `callAs`, then calls that contract and finally `unauthorize`s it.\n/// This way the contract can perform any logic it needs on behalf of your address, but only once.\n/// - Gasless transactions.\n/// It's an increasingly common pattern to use smart contracts without necessarily spending Ether.\n/// This is achieved with gasless transactions where the wallet signs an ERC-712 message\n/// and somebody else submits the actual transaction executing what the message requests.\n/// It may be executed by another wallet or by an operator\n/// expecting to be repaid for the spent Ether in other assets.\n/// You can achieve this with `callSigned`, which allows anybody\n/// to execute a call on behalf of the signer of a message.\n/// `Caller` doesn't deal with gas, so if you're using a gasless network,\n/// it may require you to specify the gas needed for the entire call execution.\n/// - Executing batched calls with authorization or signature.\n/// You can use both `callAs` and `callSigned` to call `Caller` itself,\n/// which in turn can execute batched calls on behalf of the authorizing or signing address.\n/// It also applies to `authorize` and `unauthorize`, they too can be called using\n/// `callAs`, `callSigned` or `callBatched`.\ncontract Caller is EIP712(\"Caller\", \"1\"), ERC2771Context(address(this)) {\n    string internal constant CALL_SIGNED_TYPE_NAME = \"CallSigned(\"\n        \"address sender,address to,bytes data,uint256 value,uint256 nonce,uint256 deadline)\";\n    bytes32 internal immutable callSignedTypeHash = keccak256(bytes(CALL_SIGNED_TYPE_NAME));\n\n    /// @notice Each sender's set of address authorized to make calls on its behalf.\n    // slither-disable-next-line naming-convention\n    mapping(address => EnumerableSet.AddressSet) internal _authorized;\n    /// @notice The nonce which needs to be used in the next EIP-712 message signed by the address.\n    mapping(address => uint256) public nonce;\n\n    /// @notice Emitted when granting the authorization\n    /// of an address to make calls on behalf of the `sender`.\n    /// @param sender The authorizing address.\n    /// @param authorized The authorized address.\n    event Authorized(address indexed sender, address indexed authorized);\n\n    /// @notice Emitted when revoking the authorization\n    /// of an address to make calls on behalf of the `sender`.\n    /// @param sender The authorizing address.\n    /// @param unauthorized The authorized address.\n    event Unauthorized(address indexed sender, address indexed unauthorized);\n\n    /// @notice Grants the authorization of an address to make calls on behalf of the sender.\n    /// @param user The authorized address.\n    function authorize(address user) public {\n        address sender = _msgSender();\n        require(_authorized[sender].add(user), \"Address already is authorized\");\n        emit Authorized(sender, user);\n    }\n\n    /// @notice Revokes the authorization of an address to make calls on behalf of the sender.\n    /// @param user The unauthorized address.\n    function unauthorize(address user) public {\n        address sender = _msgSender();\n        require(_authorized[sender].remove(user), \"Address is not authorized\");\n        emit Unauthorized(sender, user);\n    }\n\n    /// @notice Checks if an address is authorized to make calls on behalf of a sender.\n    /// @param sender The authorizing address.\n    /// @param user The potentially authorized address.\n    /// @return authorized True if `user` is authorized.\n    function isAuthorized(address sender, address user) public view returns (bool authorized) {\n        return _authorized[sender].contains(user);\n    }\n\n    /// @notice Returns all the addresses authorized to make calls on behalf of a sender.\n    /// @param sender The authorizing address.\n    /// @return authorized The list of all the authorized addresses, ordered arbitrarily.\n    /// The list's order may change when sender authorizes or unauthorizes addresses.\n    function allAuthorized(address sender) public view returns (address[] memory authorized) {\n        return _authorized[sender].values();\n    }\n\n    /// @notice Makes a call on behalf of the `sender`.\n    /// Callable only by an address currently `authorize`d by the `sender`.\n    /// Reverts if the call reverts or the called address is not a smart contract.\n    /// This function is payable, any Ether sent to it will be passed in the call.\n    /// @param sender The sender to be set as the message sender of the call as per ERC-2771.\n    /// @param to The called address.\n    /// @param data The calldata to be used for the call.\n    /// @return returnData The data returned by the call.\n    function callAs(address sender, address to, bytes memory data)\n        public\n        payable\n        returns (bytes memory returnData)\n    {\n        require(isAuthorized(sender, _msgSender()), \"Not authorized\");\n        return _call(sender, to, data, msg.value);\n    }\n\n    /// @notice Makes a call on behalf of the `sender`.\n    /// Requires a `sender`'s signature of an ERC-721 message approving the call.\n    /// Reverts if the call reverts or the called address is not a smart contract.\n    /// This function is payable, any Ether sent to it will be passed in the call.\n    /// @param sender The sender to be set as the message sender of the call as per ERC-2771.\n    /// @param to The called address.\n    /// @param data The calldata to be used for the call.\n    /// @param deadline The timestamp until which the message signature is valid.\n    /// @param r The `r` part of the compact message signature as per EIP-2098.\n    /// @param sv The `sv` part of the compact message signature as per EIP-2098.\n    /// @return returnData The data returned by the call.\n    function callSigned(\n        address sender,\n        address to,\n        bytes memory data,\n        uint256 deadline,\n        bytes32 r,\n        bytes32 sv\n    ) public payable returns (bytes memory returnData) {\n        // slither-disable-next-line timestamp\n        require(block.timestamp <= deadline, \"Execution deadline expired\");\n        uint256 currNonce = nonce[sender]++;\n        bytes32 executeHash = keccak256(\n            abi.encode(\n                callSignedTypeHash, sender, to, keccak256(data), msg.value, currNonce, deadline\n            )\n        );\n        address signer = ECDSA.recover(_hashTypedDataV4(executeHash), r, sv);\n        require(signer == sender, \"Invalid signature\");\n        return _call(sender, to, data, msg.value);\n    }\n\n    /// @notice Executes a batch of calls.\n    /// The caller will be set as the message sender of all the calls as per ERC-2771.\n    /// Reverts if any of the calls reverts or any of the called addresses is not a smart contract.\n    /// This function is payable, any Ether sent to it can be used in the batched calls.\n    /// Any unused Ether will stay in this contract,\n    /// anybody will be able to use it in future calls to `callBatched`.\n    /// @param calls The calls to perform.\n    /// @return returnData The data returned by each of the calls.\n    function callBatched(Call[] memory calls) public payable returns (bytes[] memory returnData) {\n        returnData = new bytes[](calls.length);\n        address sender = _msgSender();\n        for (uint256 i = 0; i < calls.length; i++) {\n            Call memory call = calls[i];\n            returnData[i] = _call(sender, call.to, call.data, call.value);\n        }\n    }\n\n    function _call(address sender, address to, bytes memory data, uint256 value)\n        internal\n        returns (bytes memory returnData)\n    {\n        // Encode the message sender as per ERC-2771\n        return Address.functionCallWithValue(to, abi.encodePacked(data, sender), value);\n    }\n}"
    },
    {
      "filename": "src/ImmutableSplitsDriver.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.17;\n\nimport {DripsHub, SplitsReceiver, UserMetadata} from \"./DripsHub.sol\";\nimport {Managed} from \"./Managed.sol\";\nimport {StorageSlot} from \"openzeppelin-contracts/utils/StorageSlot.sol\";\n\n/// @notice A DripsHub driver implementing immutable splits configurations.\n/// Anybody can create a new user ID and configure its splits configuration,\n/// but nobody can update its configuration afterwards, it's immutable.\ncontract ImmutableSplitsDriver is Managed {\n    /// @notice The DripsHub address used by this driver.\n    DripsHub public immutable dripsHub;\n    /// @notice The driver ID which this driver uses when calling DripsHub.\n    uint32 public immutable driverId;\n    /// @notice The required total splits weight of each splits configuration\n    uint32 public immutable totalSplitsWeight;\n    /// @notice The ERC-1967 storage slot holding a single `uint256` counter of created identities.\n    bytes32 private immutable _counterSlot = _erc1967Slot(\"eip1967.immutableSplitsDriver.storage\");\n\n    /// @notice Emitted when an immutable splits configuration is created.\n    /// @param userId The user ID\n    /// @param receiversHash The splits receivers list hash\n    event CreatedSplits(uint256 indexed userId, bytes32 indexed receiversHash);\n\n    /// @param _dripsHub The drips hub to use.\n    /// @param _driverId The driver ID to use when calling DripsHub.\n    constructor(DripsHub _dripsHub, uint32 _driverId) {\n        dripsHub = _dripsHub;\n        driverId = _driverId;\n        totalSplitsWeight = _dripsHub.TOTAL_SPLITS_WEIGHT();\n    }\n\n    /// @notice The ID of the next user to be created.\n    /// @return userId The user ID.\n    function nextUserId() public view returns (uint256 userId) {\n        return (uint256(driverId) << 224) + StorageSlot.getUint256Slot(_counterSlot).value;\n    }\n\n    /// @notice Creates a new user ID, configures its splits configuration and emits its metadata.\n    /// The configuration is immutable and nobody can control the user ID after its creation.\n    /// Calling this function is the only way and the only chance to emit metadata for that user.\n    /// @param receivers The list of the user's splits receivers to be set.\n    /// Must be sorted by the splits receivers' addresses, deduplicated and without 0 weights.\n    /// Each splits receiver will be getting `weight / totalSplitsWeight`\n    /// share of the funds collected by the user.\n    /// The sum of the receivers' weights must be equal to `totalSplitsWeight`,\n    /// or in other words the configuration must be splitting 100% of received funds.\n    /// @param userMetadata The list of user metadata to emit for the created user.\n    /// The keys and the values are not standardized by the protocol, it's up to the user\n    /// to establish and follow conventions to ensure compatibility with the consumers.\n    /// @return userId The new user ID with `receivers` configured.\n    function createSplits(SplitsReceiver[] calldata receivers, UserMetadata[] calldata userMetadata)\n        public\n        whenNotPaused\n        returns (uint256 userId)\n    {\n        userId = nextUserId();\n        StorageSlot.getUint256Slot(_counterSlot).value++;\n        uint256 weightSum = 0;\n        for (uint256 i = 0; i < receivers.length; i++) {\n            weightSum += receivers[i].weight;\n        }\n        require(weightSum == totalSplitsWeight, \"Invalid total receivers weight\");\n        emit CreatedSplits(userId, dripsHub.hashSplits(receivers));\n        dripsHub.setSplits(userId, receivers);\n        if (userMetadata.length > 0) dripsHub.emitUserMetadata(userId, userMetadata);\n    }\n}"
    },
    {
      "filename": "src/Drips.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.17;\n\n/// @notice A drips receiver\nstruct DripsReceiver {\n    /// @notice The user ID.\n    uint256 userId;\n    /// @notice The drips configuration.\n    DripsConfig config;\n}\n\n/// @notice The sender drips history entry, used when squeezing drips.\nstruct DripsHistory {\n    /// @notice Drips receivers list hash, see `_hashDrips`.\n    /// If it's non-zero, `receivers` must be empty.\n    bytes32 dripsHash;\n    /// @notice The drips receivers. If it's non-empty, `dripsHash` must be `0`.\n    /// If it's empty, this history entry will be skipped when squeezing drips\n    /// and `dripsHash` will be used when verifying the drips history validity.\n    /// Skipping a history entry allows cutting gas usage on analysis\n    /// of parts of the drips history which are not worth squeezing.\n    /// The hash of an empty receivers list is `0`, so when the sender updates\n    /// their receivers list to be empty, the new `DripsHistory` entry will have\n    /// both the `dripsHash` equal to `0` and the `receivers` empty making it always skipped.\n    /// This is fine, because there can't be any funds to squeeze from that entry anyway.\n    DripsReceiver[] receivers;\n    /// @notice The time when drips have been configured\n    uint32 updateTime;\n    /// @notice The maximum end time of drips\n    uint32 maxEnd;\n}\n\n/// @notice Describes a drips configuration.\n/// It's constructed from `dripId`, `amtPerSec`, `start` and `duration` as\n/// `dripId << 224 | amtPerSec << 64 | start << 32 | duration`.\n/// `dripId` is an arbitrary number used to identify a drip.\n/// It's a part of the configuration but the protocol doesn't use it.\n/// `amtPerSec` is the amount per second being dripped. Must never be zero.\n/// It must have additional `Drips._AMT_PER_SEC_EXTRA_DECIMALS` decimals and can have fractions.\n/// To achieve that its value must be multiplied by `Drips._AMT_PER_SEC_MULTIPLIER`.\n/// `start` is the timestamp when dripping should start.\n/// If zero, use the timestamp when drips are configured.\n/// `duration` is the duration of dripping.\n/// If zero, drip until balance runs out.\ntype DripsConfig is uint256;\n\nusing DripsConfigImpl for DripsConfig global;\n\nlibrary DripsConfigImpl {\n    /// @notice Create a new DripsConfig.\n    /// @param dripId_ An arbitrary number used to identify a drip.\n    /// It's a part of the configuration but the protocol doesn't use it.\n    /// @param amtPerSec_ The amount per second being dripped. Must never be zero.\n    /// It must have additional `Drips._AMT_PER_SEC_EXTRA_DECIMALS` decimals and can have fractions.\n    /// To achieve that the passed value must be multiplied by `Drips._AMT_PER_SEC_MULTIPLIER`.\n    /// @param start_ The timestamp when dripping should start.\n    /// If zero, use the timestamp when drips are configured.\n    /// @param duration_ The duration of dripping.\n    /// If zero, drip until balance runs out.\n    function create(uint32 dripId_, uint160 amtPerSec_, uint32 start_, uint32 duration_)\n        internal\n        pure\n        returns (DripsConfig)\n    {\n        uint256 config = dripId_;\n        config = (config << 160) | amtPerSec_;\n        config = (config << 32) | start_;\n        config = (config << 32) | duration_;\n        return DripsConfig.wrap(config);\n    }\n\n    /// @notice Extracts dripId from a `DripsConfig`\n    function dripId(DripsConfig config) internal pure returns (uint32) {\n        return uint32(DripsConfig.unwrap(config) >> 224);\n    }\n\n    /// @notice Extracts amtPerSec from a `DripsConfig`\n    function amtPerSec(DripsConfig config) internal pure returns (uint160) {\n        return uint160(DripsConfig.unwrap(config) >> 64);\n    }\n\n    /// @notice Extracts start from a `DripsConfig`\n    function start(DripsConfig config) internal pure returns (uint32) {\n        return uint32(DripsConfig.unwrap(config) >> 32);\n    }\n\n    /// @notice Extracts duration from a `DripsConfig`\n    function duration(DripsConfig config) internal pure returns (uint32) {\n        return uint32(DripsConfig.unwrap(config));\n    }\n\n    /// @notice Compares two `DripsConfig`s.\n    /// First compares their `amtPerSec`s, then their `start`s and then their `duration`s.\n    function lt(DripsConfig config, DripsConfig otherConfig) internal pure returns (bool) {\n        return DripsConfig.unwrap(config) < DripsConfig.unwrap(otherConfig);\n    }\n}\n\n/// @notice Drips can keep track of at most `type(int128).max`\n/// which is `2 ^ 127 - 1` units of each asset.\n/// It's up to the caller to guarantee that this limit is never exceeded,\n/// failing to do so may result in a total protocol collapse.\nabstract contract Drips {\n    /// @notice Maximum number of drips receivers of a single user.\n    /// Limits cost of changes in drips configuration.\n    uint256 internal constant _MAX_DRIPS_RECEIVERS = 100;\n    /// @notice The additional decimals for all amtPerSec values.\n    uint8 internal constant _AMT_PER_SEC_EXTRA_DECIMALS = 9;\n    /// @notice The multiplier for all amtPerSec values. It's `10 ** _AMT_PER_SEC_EXTRA_DECIMALS`.\n    uint256 internal constant _AMT_PER_SEC_MULTIPLIER = 1_000_000_000;\n    /// @notice The total amount the contract can keep track of each asset.\n    uint256 internal constant _MAX_TOTAL_DRIPS_BALANCE = uint128(type(int128).max);\n    /// @notice On every timestamp `T`, which is a multiple of `cycleSecs`, the receivers\n    /// gain access to drips received during `T - cycleSecs` to `T - 1`.\n    /// Always higher than 1.\n    // slither-disable-next-line naming-convention\n    uint32 internal immutable _cycleSecs;\n    /// @notice The storage slot holding a single `DripsStorage` structure.\n    bytes32 private immutable _dripsStorageSlot;\n\n    /// @notice Emitted when the drips configuration of a user is updated.\n    /// @param userId The user ID.\n    /// @param assetId The used asset ID\n    /// @param receiversHash The drips receivers list hash\n    /// @param dripsHistoryHash The drips history hash which was valid right before the update.\n    /// @param balance The new drips balance. These funds will be dripped to the receivers.\n    /// @param maxEnd The maximum end time of drips, when funds run out.\n    /// If funds run out after the timestamp `type(uint32).max`, it's set to `type(uint32).max`.\n    /// If the balance is 0 or there are no receivers, it's set to the current timestamp.\n    event DripsSet(\n        uint256 indexed userId,\n        uint256 indexed assetId,\n        bytes32 indexed receiversHash,\n        bytes32 dripsHistoryHash,\n        uint128 balance,\n        uint32 maxEnd\n    );\n\n    /// @notice Emitted when a user is seen in a drips receivers list.\n    /// @param receiversHash The drips receivers list hash\n    /// @param userId The user ID.\n    /// @param config The drips configuration.\n    event DripsReceiverSeen(\n        bytes32 indexed receiversHash, uint256 indexed userId, DripsConfig config\n    );\n\n    /// @notice Emitted when drips are received.\n    /// @param userId The user ID\n    /// @param assetId The used asset ID\n    /// @param amt The received amount.\n    /// @param receivableCycles The number of cycles which still can be received.\n    event ReceivedDrips(\n        uint256 indexed userId, uint256 indexed assetId, uint128 amt, uint32 receivableCycles\n    );\n\n    /// @notice Emitted when drips are squeezed.\n    /// @param userId The squeezing user ID.\n    /// @param assetId The used asset ID.\n    /// @param senderId The ID of the user sending drips which are squeezed.\n    /// @param amt The squeezed amount.\n    /// @param dripsHistoryHashes The history hashes of all squeezed drips history entries.\n    /// Each history hash matches `dripsHistoryHash` emitted in its `DripsSet`\n    /// when the squeezed drips configuration was set.\n    /// Sorted in the oldest drips configuration to the newest.\n    event SqueezedDrips(\n        uint256 indexed userId,\n        uint256 indexed assetId,\n        uint256 indexed senderId,\n        uint128 amt,\n        bytes32[] dripsHistoryHashes\n    );\n\n    struct DripsStorage {\n        /// @notice User drips states.\n        /// The keys are the asset ID and the user ID.\n        mapping(uint256 => mapping(uint256 => DripsState)) states;\n    }\n\n    struct DripsState {\n        /// @notice The drips history hash, see `_hashDripsHistory`.\n        bytes32 dripsHistoryHash;\n        /// @notice The next squeezable timestamps. The key is the sender's user ID.\n        /// Each `N`th element of the array is the next squeezable timestamp\n        /// of the `N`th sender's drips configuration in effect in the current cycle.\n        mapping(uint256 => uint32[2 ** 32]) nextSqueezed;\n        /// @notice The drips receivers list hash, see `_hashDrips`.\n        bytes32 dripsHash;\n        /// @notice The next cycle to be received\n        uint32 nextReceivableCycle;\n        /// @notice The time when drips have been configured for the last time\n        uint32 updateTime;\n        /// @notice The maximum end time of drips\n        uint32 maxEnd;\n        /// @notice The balance when drips have been configured for the last time\n        uint128 balance;\n        /// @notice The number of drips configurations seen in the current cycle\n        uint32 currCycleConfigs;\n        /// @notice The changes of received amounts on specific cycle.\n        /// The keys are cycles, each cycle `C` becomes receivable on timestamp `C * cycleSecs`.\n        /// Values for cycles before `nextReceivableCycle` are guaranteed to be zeroed.\n        /// This means that the value of `amtDeltas[nextReceivableCycle].thisCycle` is always\n        /// relative to 0 or in other words it's an absolute value independent from other cycles.\n        mapping(uint32 => AmtDelta) amtDeltas;\n    }\n\n    struct AmtDelta {\n        /// @notice Amount delta applied on this cycle\n        int128 thisCycle;\n        /// @notice Amount delta applied on the next cycle\n        int128 nextCycle;\n    }\n\n    /// @param cycleSecs The length of cycleSecs to be used in the contract instance.\n    /// Low value makes funds more available by shortening the average time of funds being frozen\n    /// between being taken from the users' drips balances and being receivable by their receivers.\n    /// High value makes receiving cheaper by making it process less cycles for a given time range.\n    /// Must be higher than 1.\n    /// @param dripsStorageSlot The storage slot to holding a single `DripsStorage` structure.\n    constructor(uint32 cycleSecs, bytes32 dripsStorageSlot) {\n        require(cycleSecs > 1, \"Cycle length too low\");\n        _cycleSecs = cycleSecs;\n        _dripsStorageSlot = dripsStorageSlot;\n    }\n\n    /// @notice Receive drips from unreceived cycles of the user.\n    /// Received drips cycles won't need to be analyzed ever again.\n    /// @param userId The user ID\n    /// @param assetId The used asset ID\n    /// @param maxCycles The maximum number of received drips cycles.\n    /// If too low, receiving will be cheap, but may not cover many cycles.\n    /// If too high, receiving may become too expensive to fit in a single transaction.\n    /// @return receivedAmt The received amount\n    function _receiveDrips(uint256 userId, uint256 assetId, uint32 maxCycles)\n        internal\n        returns (uint128 receivedAmt)\n    {\n        uint32 receivableCycles;\n        uint32 fromCycle;\n        uint32 toCycle;\n        int128 finalAmtPerCycle;\n        (receivedAmt, receivableCycles, fromCycle, toCycle, finalAmtPerCycle) =\n            _receiveDripsResult(userId, assetId, maxCycles);\n        if (fromCycle != toCycle) {\n            DripsState storage state = _dripsStorage().states[assetId][userId];\n            state.nextReceivableCycle = toCycle;\n            mapping(uint32 => AmtDelta) storage amtDeltas = state.amtDeltas;\n            for (uint32 cycle = fromCycle; cycle < toCycle; cycle++) {\n                delete amtDeltas[cycle];\n            }\n            // The next cycle delta must be relative to the last received cycle, which got zeroed.\n            // In other words the next cycle delta must be an absolute value.\n            if (finalAmtPerCycle != 0) {\n                amtDeltas[toCycle].thisCycle += finalAmtPerCycle;\n            }\n        }\n        emit ReceivedDrips(userId, assetId, receivedAmt, receivableCycles);\n    }\n\n    /// @notice Calculate effects of calling `_receiveDrips` with the given parameters.\n    /// @param userId The user ID\n    /// @param assetId The used asset ID\n    /// @param maxCycles The maximum number of received drips cycles.\n    /// If too low, receiving will be cheap, but may not cover many cycles.\n    /// If too high, receiving may become too expensive to fit in a single transaction.\n    /// @return receivedAmt The amount which would be received\n    /// @return receivableCycles The number of cycles which would still be receivable after the call\n    /// @return fromCycle The cycle from which funds would be received\n    /// @return toCycle The cycle to which funds would be received\n    /// @return amtPerCycle The amount per cycle when `toCycle` starts.\n    function _receiveDripsResult(uint256 userId, uint256 assetId, uint32 maxCycles)\n        internal\n        view\n        returns (\n            uint128 receivedAmt,\n            uint32 receivableCycles,\n            uint32 fromCycle,\n            uint32 toCycle,\n            int128 amtPerCycle\n        )\n    {\n        (fromCycle, toCycle) = _receivableDripsCyclesRange(userId, assetId);\n        if (toCycle - fromCycle > maxCycles) {\n            receivableCycles = toCycle - fromCycle - maxCycles;\n            toCycle -= receivableCycles;\n        }\n        DripsState storage state = _dripsStorage().states[assetId][userId];\n        for (uint32 cycle = fromCycle; cycle < toCycle; cycle++) {\n            amtPerCycle += state.amtDeltas[cycle].thisCycle;\n            receivedAmt += uint128(amtPerCycle);\n            amtPerCycle += state.amtDeltas[cycle].nextCycle;\n        }\n    }\n\n    /// @notice Counts cycles from which drips can be received.\n    /// This function can be used to detect that there are\n    /// too many cycles to analyze in a single transaction.\n    /// @param userId The user ID\n    /// @param assetId The used asset ID\n    /// @return cycles The number of cycles which can be flushed\n    function _receivableDripsCycles(uint256 userId, uint256 assetId)\n        internal\n        view\n        returns (uint32 cycles)\n    {\n        (uint32 fromCycle, uint32 toCycle) = _receivableDripsCyclesRange(userId, assetId);\n        return toCycle - fromCycle;\n    }\n\n    /// @notice Calculates the cycles range from which drips can be received.\n    /// @param userId The user ID\n    /// @param assetId The used asset ID\n    /// @return fromCycle The cycle from which funds can be received\n    /// @return toCycle The cycle to which funds can be received\n    function _receivableDripsCyclesRange(uint256 userId, uint256 assetId)\n        private\n        view\n        returns (uint32 fromCycle, uint32 toCycle)\n    {\n        fromCycle = _dripsStorage().states[assetId][userId].nextReceivableCycle;\n        toCycle = _cycleOf(_currTimestamp());\n        // slither-disable-next-line timestamp\n        if (fromCycle == 0 || toCycle < fromCycle) {\n            toCycle = fromCycle;\n        }\n    }\n\n    /// @notice Receive drips from the currently running cycle from a single sender.\n    /// It doesn't receive drips from the previous, finished cycles, to do that use `_receiveDrips`.\n    /// Squeezed funds won't be received in the next calls to `_squeezeDrips` or `_receiveDrips`.\n    /// Only funds dripped before `block.timestamp` can be squeezed.\n    /// @param userId The ID of the user receiving drips to squeeze funds for.\n    /// @param assetId The used asset ID.\n    /// @param senderId The ID of the user sending drips to squeeze funds from.\n    /// @param historyHash The sender's history hash which was valid right before\n    /// they set up the sequence of configurations described by `dripsHistory`.\n    /// @param dripsHistory The sequence of the sender's drips configurations.\n    /// It can start at an arbitrary past configuration, but must describe all the configurations\n    /// which have been used since then including the current one, in the chronological order.\n    /// Only drips described by `dripsHistory` will be squeezed.\n    /// If `dripsHistory` entries have no receivers, they won't be squeezed.\n    /// @return amt The squeezed amount.\n    function _squeezeDrips(\n        uint256 userId,\n        uint256 assetId,\n        uint256 senderId,\n        bytes32 historyHash,\n        DripsHistory[] memory dripsHistory\n    ) internal returns (uint128 amt) {\n        uint256 squeezedNum;\n        uint256[] memory squeezedRevIdxs;\n        bytes32[] memory historyHashes;\n        uint256 currCycleConfigs;\n        (amt, squeezedNum, squeezedRevIdxs, historyHashes, currCycleConfigs) =\n            _squeezeDripsResult(userId, assetId, senderId, historyHash, dripsHistory);\n        bytes32[] memory squeezedHistoryHashes = new bytes32[](squeezedNum);\n        DripsState storage state = _dripsStorage().states[assetId][userId];\n        uint32[2 ** 32] storage nextSqueezed = state.nextSqueezed[senderId];\n        for (uint256 i = 0; i < squeezedNum; i++) {\n            // `squeezedRevIdxs` are sorted from the newest configuration to the oldest,\n            // but we need to consume them from the oldest to the newest.\n            uint256 revIdx = squeezedRevIdxs[squeezedNum - i - 1];\n            squeezedHistoryHashes[i] = historyHashes[historyHashes.length - revIdx];\n            nextSqueezed[currCycleConfigs - revIdx] = _currTimestamp();\n        }\n        uint32 cycleSta"
    }
  ]
}