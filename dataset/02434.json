{
  "Title": "H-1: amount_claimable_per_share accounting is broken and will result in vault insolvency",
  "Content": "# Issue H-1: amount_claimable_per_share accounting is broken and will result in vault insolvency \n\nSource: https://github.com/sherlock-audit/2023-02-fair-funding-judging/issues/44 \n\n## Found by \n0x52, jkoppel, oxcm\n\n## Summary\n\nClaim accounting is incorrect if there is a deposit when amount_claimable_per_share !=0, because position.amount_claimed isn't initialized when the deposit is created.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-02-fair-funding/blob/main/fair-funding/contracts/Vault.vy#L430-L440\n\nWhen calculating the amount of WETH to claim for a user, the contract simply multiplies the share count by the current amount_claimable_per_share and then subtracts the amount that has already been paid out to that token holder. This is problematic for deposits that happen when amount_claimable_per_share != 0 because they will be eligible to claim WETH immediately as if they had been part of the vault since amount_claimable_per_share != 0.\n\nExample;\nUser A deposits 1 ETH and receives 1 share. Over time the loan pays itself back and claim is able to withdraw 0.1 WETH. This causes amount_claimable_per_share = 0.1. Now User B deposits 1 ETH and receives 1 share. They can immediately call claim which yields them 0.1 WETH (1 * 0.1 - 0). This causes the contract to over-commit the amount of WETH to payout since it now owes a total of 0.2 WETH (0.1 ETH to each depositor) but only has 0.1 WETH.\n\n## Impact\n\nContract will become insolvent\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-fair-funding/blob/main/fair-funding/contracts/Vault.vy#L200-L232\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nposition.amountClaimed needs to be initialized when a deposit is made:\n      \n        # deposit WETH to Alchemix\n        shares_issued: uint256 = self._deposit_to_alchemist(_amount)\n        position.shares_owned += shares_issued\n    +   position.amount_claimed += shares_issued * amount_claimable_per_share\n        self.total_shares += shares_issued\n        \n        self.positions[_token_id] = position\n        \n\n## Discussion\n\n**HickupHH3**\n\nDup of #114\n\n**0x00052**\n\nEscalate for 1 USDC\n\nNot a dupe of #114. That focuses on depositing twice to the same token (which can't happen outside of admin abuse). The issue is that it generally applies to all deposits. Please re-read my example as to why this is an issue and how it leads to gross over-commitment of rewards.\n\nTwo reasons I disagree with this being low:\n1) The argument that this will only be used for a short period and so \"it doesn't have much impact\" is a poor argument. This is meant as a general utility that anyone can use and they should be able to make a funding period as long as they want\n2) This is a serious issue that will lead to rewards being over-committed and the vault WILL go insolvent as a result. The extra fees being paid will be taken from other users and will GUARANTEED cause loss of funds to other users.\n\nWould like to add that this and #113 are the same issue and escalations should be resolved together.\n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> Not a dupe of #114. That focuses on depositing twice to the same token (which can't happen outside of admin abuse). The issue is that it generally applies to all deposits. Please re-read my example as to why this is an issue and how it leads to gross over-commitment of rewards.\n> \n> Two reasons I disagree with this being low:\n> 1) The argument that this will only be used for a short period and so \"it doesn't have much impact\" is a poor argument. This is meant as a general utility that anyone can use and they should be able to make a funding period as long as they want\n> 2) This is a serious issue that will lead to rewards being over-committed and the vault WILL go insolvent as a result. The extra fees being paid will be taken from other users and will GUARANTEED cause loss of funds to other users.\n> \n> Would like to add that this and #113 are the same issue and escalations should be resolved together.\n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Unstoppable-DeFi**\n\nAgree, duplicate of #113 and will fix.\n\n**hrishibhat**\n\nEscalation accepted\n\nConsidering this & its duplicate #113  as valid issues\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Considering this & its duplicate #113  as valid issues\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n**Unstoppable-DeFi**\n\nhttps://github.com/Unstoppable-DeFi/fair-funding/pull/8\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/42",
  "Code": [
    {
      "filename": "fair-funding/contracts/Vault.vy",
      "content": "# @version 0.3.7\n\n\"\"\"\n@title Fair Funding Alchemix Vault\n@license GNU AGPLv3\n@author unstoppable.ooo\n\n@custom:security-contact team@unstoppable.com\n\n@notice\n    This vault manages a position on Alchemix.\n    Newly deposited WETH will be put into Alchemix and a corresponding\n    loan will be taken out and sent to the fund_receiver.\n\n    The Alchemix positions are governed by the referenced ERC721 tokens.\n\n    The owner of the token can at any point liquidate the underlying \n    Alchemix position and receive the remainder of their deposited funds\n    back.\n\n    Paid off debt on Alchemix (either manually repaid externally or by the\n    self-repaying feature of Alchemix) allows to withdraw parts of the \n    underlying collateral WETH as it becomes available.\n    This withdrawn ETH is marked as claimable and each token owner who \n    contributed to the position can claim his share of the unlocked WETH \n    up to the total amount that was initially deposited with this token.\n\n    Over time 100% of the initial collateral will become unlocked at \n    Alchemix and can be permissionlessly withdrawn by anyone to make it\n    claimable by the token holders.\n\n    Note:\n    We assume the LTV of Alchemix will not change and all positions can\n    be considered as having the same collateralisation / LTV.\n    In the unlikely case it does change, this contract will be re-deployed \n    with the updated collateralization value for new deposits.\n\n\"\"\"\n\nfrom vyper.interfaces import ERC721\nfrom vyper.interfaces import ERC20\n\ninterface IAlchemist:\n    def depositUnderlying(\n        _yield_token: address,\n        _amount: uint256,\n        _recipient: address,\n        _min_amount_out: uint256\n    ) -> uint256: nonpayable\n    def mint(\n        _amount: uint256,\n        _recipient: address\n    ): nonpayable\n    def withdrawUnderlying(\n        _yield_token: address,\n        _shares: uint256,\n        _recipient: address,\n        _min_amount_out: uint256\n    ) -> uint256: nonpayable\n    def liquidate(\n        _yield_token: address,\n        _shares: uint256,\n        _min_amount_out: uint256\n    ) -> uint256: nonpayable\n    def getUnderlyingTokensPerShare(\n        _yield_token: address\n    ) -> uint256: view\n    def totalValue(_owner: address) -> uint256: view\n    def minimumCollateralization() -> uint256: view\n    def accounts(_owner: address) -> (int256, DynArray[address, 8]): view\n    def positions(_owner: address, _yield_token: address) -> (uint256, uint256): view\n    def normalizeUnderlyingTokensToDebt(\n        _underlying_token: address, \n        _amount: uint256\n    ) -> uint256: view\n    def convertUnderlyingTokensToShares(\n        _yield_token: address, \n        _amount: uint256\n    ) -> uint256: view\n    def convertSharesToUnderlyingTokens(\n        _yield_token: address, \n        _shares: uint256\n    ) -> uint256: view\n\n\ninterface Migrator:\n    def migrate(): nonpayable\n\n\nPRECISION: constant(uint256) = 10**6\nDECIMALS: constant(uint256) = 10**18\n\nALCX_YVWETH: constant(address) = 0xa258C4606Ca8206D8aA700cE2143D7db854D168c\nWETH: constant(address) = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n\nNFT: public(immutable(address))\n\nalchemist: public(address)\nfund_receiver: public(address)\n\nstruct Position:\n    token_id: uint256\n    amount_deposited: uint256\n    amount_claimed: uint256\n    shares_owned: uint256\n    is_liquidated: bool\n\npositions: public(HashMap[uint256, Position])\ntotal_shares: public(uint256)\namount_claimable_per_share: public(uint256)\n\nis_operator: public(HashMap[address, bool])\nis_depositor: public(HashMap[address, bool])\n\n\nMIGRATION_TIMELOCK: constant(uint256) = 30 * 60 * 60 * 24  # 30 days in seconds\nmigration_admin: public(address)\nsuggested_migration_admin: public(address)\nmigration_active: public(uint256)\nmigrator: public(address)\nmigration_executed: public(bool)\n\nevent Deposit:\n    token_owner: indexed(address)\n    token_id: uint256\n    amount: uint256\n\nevent Funded:\n    receiver: indexed(address)\n    amount: uint256\n\nevent Liquidated:\n    token_id: uint256\n    token_owner: indexed(address)\n    amount: uint256\n\nevent Claimable:\n    amount: uint256\n\nevent Claimed:\n    token_id: uint256\n    token_owner: indexed(address)\n    amount: uint256\n\nevent AlchemistUpdated:\n    updater: indexed(address)\n    new_alchemist: indexed(address)\n\nevent FundReceiverUpdated:\n    updater: indexed(address)\n    new_fund_receiver: indexed(address)\n\nevent NewOperator:\n    new_operator: indexed(address)\n    promoted_by: indexed(address)\n\nevent OperatorRemoved:\n    removed: indexed(address)\n    removed_by: indexed(address)\n\nevent NewDepositor:\n    new_depositor: indexed(address)\n    promoted_by: indexed(address)\n\nevent DepositorRemoved:\n    removed: indexed(address)\n    removed_by: indexed(address)\n\nevent MigrationAdminTransferred:\n    new_admin: indexed(address)\n    promoted_by: indexed(address)\n\nevent NewMigrationAdminSuggested:\n    new_admin: indexed(address)\n    suggested_by: indexed(address)\n\nevent MigrationActivated:\n    migrator_address: address\n    active_at: uint256\n\nevent MigrationDeactivated: pass\n\n\n@external\ndef __init__(\n    _nft_address: address,\n):\n    assert _nft_address != empty(address), \"invalid nft address\"\n    NFT = _nft_address\n\n    self.is_operator[msg.sender] = True\n    self.fund_receiver = msg.sender\n\n    self.migration_active = max_value(uint256)\n    self.migration_admin = msg.sender\n\n\n@nonreentrant(\"lock\")\n@external\ndef register_deposit(_token_id: uint256, _amount: uint256):\n    \"\"\"\n    @notice\n        Registers a new deposit of _amount for _token_id.\n        _amount WETH is deposited into Alchemix and a corresponding\n        loan is taken out and sent to fund_receiver.\n    \"\"\"\n    assert self.is_depositor[msg.sender], \"not allowed\"\n    assert self._is_valid_token_id(_token_id)\n\n    position: Position = self.positions[_token_id]\n    assert position.is_liquidated == False, \"position already liquidated\"\n\n    position.token_id = _token_id\n    position.amount_deposited += _amount\n\n    # transfer WETH to self\n    ERC20(WETH).transferFrom(msg.sender, self, _amount)\n\n    # deposit WETH to Alchemix\n    shares_issued: uint256 = self._deposit_to_alchemist(_amount)\n    position.shares_owned += shares_issued\n    self.total_shares += shares_issued\n    \n    self.positions[_token_id] = position\n\n    # mint alchemix debt to fund_receiver\n    amount_to_mint: uint256 = self._calculate_amount_to_mint(shares_issued)\n    assert amount_to_mint > 0, \"cannot mint new Alchemix debt\"\n\n    self._mint_from_alchemix(amount_to_mint, self.fund_receiver)\n\n    log Deposit(msg.sender, _token_id, _amount)\n\n\n@internal\n@view\ndef _calculate_amount_to_mint(_amount_shares: uint256) -> uint256:\n    return min(self._calculate_mintable_amount(_amount_shares), self._calculate_max_mintable_amount())\n\n\n@internal\n@view\ndef _calculate_mintable_amount(_amount_shares: uint256) -> uint256:\n    \"\"\"\n    @notice\n        Calculate the mintable amount of debt tokens given _amount_shares new\n        shares as collateral.\n        This function does not account for existing debts on Alchemix.\n    \"\"\"\n    min_collateralization: uint256 = IAlchemist(self.alchemist).minimumCollateralization()\n    amount_shares_collateralized: uint256 = _amount_shares * DECIMALS / min_collateralization\n    amount_underlying: uint256 = IAlchemist(self.alchemist).convertSharesToUnderlyingTokens(ALCX_YVWETH, amount_shares_collateralized)\n    mintable_debt: uint256 = IAlchemist(self.alchemist).normalizeUnderlyingTokensToDebt(WETH, amount_underlying)\n    if mintable_debt > 0:\n        mintable_debt -= 1 # to pass \"<\" collateralisation check on Alchemix\n    return mintable_debt\n\n\n\n@internal\n@view\ndef _calculate_max_mintable_amount() -> uint256:\n    \"\"\"\n    @notice\n        Calculate the maximum mintable amount of debt tokens given the current\n        collateral and existing debt on Alchemix.\n    \"\"\"\n    # Alchemist._validate(): uint256 collateralization = totalValue(owner) * 1e18 / uint256(debt);\n    current_debt: uint256 = convert(IAlchemist(self.alchemist).accounts(self)[0], uint256)\n    total_value: uint256 = IAlchemist(self.alchemist).totalValue(self)\n    min_collateralization: uint256 = IAlchemist(self.alchemist).minimumCollateralization()\n\n    max_mintable_debt: uint256 = total_value * DECIMALS / min_collateralization - current_debt\n\n    if max_mintable_debt > 0:\n        max_mintable_debt = max_mintable_debt - 1 # minus 1 for collat < min_collat check @ alchemist._validate\n    \n    return max_mintable_debt\n\n\n\n\n@internal\ndef _deposit_to_alchemist(_amount: uint256) -> uint256:\n    \"\"\"\n    @notice\n        Deposits _amount WETH from this contract into the Alchemix ALCX_YVWETH\n        vault. \n    \"\"\"\n    assert self.alchemist != empty(address), \"invalid state, alchemist not set\"\n    \n    ERC20(WETH).approve(self.alchemist, _amount)\n    shares_issued: uint256 = IAlchemist(self.alchemist).depositUnderlying(\n        ALCX_YVWETH,     # yield_token\n        _amount,         # amount\n        self,            # recipient\n        1                # min_amount_out - cannot be frontrun in a significant way\n                         #                  so to reduce complexity we go with 1\n    )\n    return shares_issued\n\n\n@internal \ndef _mint_from_alchemix(_amount: uint256, _recipient: address):\n    \"\"\"\n    @notice\n        Takes on _amount of debt (in alETH) on Alchemix and transfers it to \n        _recipient.\n    \"\"\"\n    IAlchemist(self.alchemist).mint(\n        _amount,    # amount\n        _recipient  # recipient\n    )\n\n    log Funded(_recipient, _amount)\n\n\n@nonreentrant(\"lock\")\n@external\ndef liquidate(_token_id: uint256, _min_weth_out: uint256) -> uint256:\n    \"\"\"\n    @notice\n        Liquidates the underlying debt of position[_token_id] by burning\n        a corresponding amount of shares.\n        Withdraws remaining value of shares as WETH to token_owner.\n        Reverts if owner would receive less than _min_weth_out.\n    \"\"\"\n    token_owner: address = ERC721(NFT).ownerOf(_token_id)\n    assert token_owner == msg.sender, \"only token owner can liquidate\"\n\n    position: Position = self.positions[_token_id]\n    assert position.is_liquidated == False, \"position already liquidated\"\n    \n    position.is_liquidated = True\n    self.positions[_token_id] = position\n    self.total_shares -= position.shares_owned\n\n    collateralisation: uint256 = self._latest_collateralisation()\n    shares_to_liquidate: uint256 = position.shares_owned * DECIMALS / collateralisation\n\n    amount_shares_liquidated: uint256 = IAlchemist(self.alchemist).liquidate(\n        ALCX_YVWETH,                 # _yield_token: address,\n        shares_to_liquidate,         # _shares: uint256,\n        1                            # _min_amount_out: uint256 -> covered by _min_weth_out\n    )\n\n    amount_to_withdraw: uint256 = position.shares_owned - amount_shares_liquidated\n    # _withdraw_underlying_from_alchemix reverts on < _min_weth_out\n    amount_withdrawn: uint256 = self._withdraw_underlying_from_alchemix(amount_to_withdraw, token_owner, _min_weth_out)\n\n    log Liquidated(_token_id, token_owner, amount_withdrawn)\n    return amount_withdrawn\n\n\n@internal\ndef _latest_collateralisation() -> uint256:\n    \"\"\"\n    @notice\n        Calculates the current collateral to debt ratio on Alchemix.\n        Reverts when there is no debt and collateralisation would be\n        infinite.\n    \"\"\"\n    # Alchemist._validate(): \n    # uint256 collateralization = totalValue(owner) * FIXED_POINT_SCALAR / uint256(debt);\n    current_debt: int256 = IAlchemist(self.alchemist).accounts(self)[0]\n    assert current_debt > 0, \"zero debt\"\n    \n    total_value: uint256 = IAlchemist(self.alchemist).totalValue(self)\n    debt: uint256 = convert(current_debt, uint256)\n    return total_value * DECIMALS / debt\n\n\n@internal\ndef _withdraw_underlying_from_alchemix(\n    _amount_shares: uint256, \n    _receiver: address,\n    _min_weth_out: uint256\n) -> uint256:\n    \"\"\"\n    @notice\n        Withdraws _amount_shares to _receiver expecting at least _min_weth_out\n    \"\"\"\n    amount_withdrawn: uint256 = IAlchemist(self.alchemist).withdrawUnderlying(\n        ALCX_YVWETH,    # _yield_token: address,\n        _amount_shares, # _shares: uint256,\n        _receiver,      # _recipient: address,\n        _min_weth_out   # _min_amount_out: uint256 \n    )\n    assert amount_withdrawn >= _min_weth_out, \"insufficient weth out\"\n    return amount_withdrawn\n\n\n@external\ndef withdraw_underlying_to_claim(_amount_shares: uint256, _min_weth_out: uint256):\n    \"\"\"\n    @notice\n        Withdraws _amount_shares and _min_weth_out from Alchemix to be distributed\n        to token holders.\n        The WETH is held in this contract until it is `claim`ed.\n    \"\"\"\n    amount_withdrawn: uint256 = self._withdraw_underlying_from_alchemix(_amount_shares, self, _min_weth_out)\n    self._mark_as_claimable(amount_withdrawn)\n\n    log Claimable(amount_withdrawn)\n\n\n@internal\ndef _mark_as_claimable(_amount: uint256):\n    \"\"\"\n    @notice\n        Marks _amount of WETH as claimable by token holders and\n        calculates the amount_claimable_per_share.\n    \"\"\"\n    if _amount == 0 or self.total_shares == 0:\n        return\n\n    assert ERC20(WETH).balanceOf(self) >= _amount\n\n    self.amount_claimable_per_share += _amount * PRECISION / self.total_shares\n    \n\n@view\n@external\ndef claimable_for_token(_token_id: uint256) -> uint256:\n    return self._claimable_for_token(_token_id)\n\n\n@view\n@internal\ndef _claimable_for_token(_token_id: uint256) -> uint256:\n    \"\"\"\n    @notice\n        Calculates the pending WETH for a given token_id.\n    \"\"\"\n    position: Position = self.positions[_token_id]\n    if position.is_liquidated:\n        return 0\n    \n    total_claimable_for_position: uint256 = position.shares_owned * self.amount_claimable_per_share / PRECISION\n    return total_claimable_for_position - position.amount_claimed\n\n\n@external\ndef claim(_token_id: uint256) -> uint256:\n    \"\"\"\n    @notice\n        Allows a token holder to claim his share of pending WETH.\n    \"\"\"\n    token_owner: address = ERC721(NFT).ownerOf(_token_id)\n    assert msg.sender == token_owner, \"only token owner can claim\"\n\n    amount: uint256 = self._claimable_for_token(_token_id)\n    assert amount > 0, \"nothing to claim\"\n\n    position: Position = self.positions[_token_id]\n    position.amount_claimed += amount\n    self.positions[_token_id] = position\n    \n    ERC20(WETH).transfer(token_owner, amount)\n\n    log Claimed(_token_id, token_owner, amount)\n    return amount\n\n\n@internal\ndef _is_valid_token_id(_token_id: uint256) -> bool:\n    \"\"\"\n    @notice\n        Checks if the given _token_id exists.\n        Reverts if token isn't minted.\n    \"\"\"\n    ERC721(NFT).ownerOf(_token_id) # reverts for invalid token_id according to spec\n    return True\n\n\n#######################\n#\n#        ADMIN\n#\n#######################\n\n@external\ndef set_alchemist(_addr: address):\n    \"\"\"\n    @notice\n        Sets the Alchemix Alchemist contract\n    \"\"\"\n    assert self.is_operator[msg.sender], \"unauthorized\"\n    assert _addr != empty(address), \"invalid alchemist address\"\n    assert _addr != self.alchemist, \"same as current\"\n\n    self.alchemist = _addr\n\n    log AlchemistUpdated(msg.sender, _addr)\n\n\n@external\ndef set_fund_receiver(_addr: address):\n    \"\"\"\n    @notice\n        Sets the fund_receiver address that will receive newly minted\n        alETH.\n    \"\"\"\n    assert self.is_operator[msg.sender], \"unauthorized\"\n    assert _addr != empty(address), \"invalid fund_receiver address\"\n    assert _addr != self.fund_receiver, \"same as current\"\n\n    self.fund_receiver = _addr\n\n    log FundReceiverUpdated(msg.sender, _addr)\n\n\n@external\ndef activate_migration(_migrator_addr: address):\n    \"\"\"\n    @notice\n        Sets a migration contract and starts the 30 day timelock before\n        migration can be performed.\n        Can only be called by the migration_admin.\n    \"\"\"\n    assert msg.sender == self.migration_admin, \"unauthorized\"\n    assert self.migrator == empty(address), \"cannot override active migration\"\n    assert _migrator_addr != empty(address), \"cannot set migrator to zero address\"\n\n    self.migrator = _migrator_addr\n    self.migration_active = block.timestamp + MIGRATION_TIMELOCK\n    self.migration_executed = False\n\n    log MigrationActivated(_migrator_addr, self.migration_active)\n\n\n@external\ndef deactivate_migration():\n    \"\"\"\n    @notice\n        Stops an activated migration and resets the migration values.\n    \"\"\"\n    assert msg.sender == self.migration_admin, \"unauthorized\"\n    self.migration_active = max_value(uint256)\n    self.migrator = empty(address)\n    \n    log MigrationDeactivated()\n\n\n@external\ndef migrate():\n    \"\"\"\n    @notice\n        Calls migrate function on the set migrator contract.\n        This is just in case there are severe changes in Alchemix that\n        require a full migration of the existing position.\n    \"\"\"\n    assert self.migration_active <= block.timestamp, \"migration not active\"\n    assert self.migration_executed == False, \"migration already executed\"\n    self.migration_executed = True\n    Migrator(self.migrator).migrate()\n\n\n@external\ndef suggest_migration_admin(_new_admin: address):\n    \"\"\"\n    @notice\n        Step 1 of the 2 step process to transfer migration admin.\n        Current owner suggests a new owner.\n        Requires the new admin to accept ownership in step 2.\n    @param _new_admin\n        The address of the new migration admin.\n    \"\"\"\n    assert msg.sender == self.migration_admin, \"unauthorized\"\n    assert _new_admin != empty(address), \"cannot set migration_admin to zero address\"\n    self.suggested_migration_admin = _new_admin\n    log NewMigrationAdminSuggested(_new_admin, msg.sender)\n\n\n@external\ndef accept_migration_admin():\n    \"\"\"\n    @notice\n        Step 2 of the 2 step process to transfer migration admin.\n        The suggested admin accepts the transfer and becomes the\n        new migration admin.\n    \"\"\"\n    assert msg.sender == self.suggested_migration_admin, \"unauthorized\"\n    prev_admin: address = self.migration_admin\n    self.migration_admin = self.suggested_migration_admin\n    log MigrationAdminTransferred(self.migration_admin, prev_admin)\n\n\n@external\ndef add_operator(_new_operator: address):\n    \"\"\"\n    @notice\n        Add a new address to the priviledged operators.\n    \"\"\"\n    assert self.is_operator[msg.sender], \"unauthorized\"\n    assert self.is_operator[_new_operator] == False, \"already operator\"\n\n    self.is_operator[_new_operator] = True\n\n    log NewOperator(_new_operator, msg.sender)\n\n\n@external\ndef remove_operator(_to_remove: address):\n    \"\"\"\n    @notice\n        Remove an existing operator from the priviledged addresses.\n    \"\"\"\n    assert self.is_operator[msg.sender], \"unauthorized\"\n    assert self.is_operator[_to_remove], \"not an operator\"\n\n    self.is_operator[_to_remove] = False\n\n    log OperatorRemoved(_to_remove, msg.sender)\n\n\n@external\ndef add_depositor(_new_depositor: address):\n    \"\"\"\n    @notice\n        Add a new address to the priviledged depositors.\n    \"\"\"\n    assert self.is_operator[msg.sender], \"unauthorized\"\n    assert self.is_depositor[_new_depositor] == False, \"already depositor\"\n\n    self.is_depositor[_new_depositor] = True\n\n    log NewDepositor(_new_depositor, msg.sender)\n\n\n@external\ndef remove_depositor(_to_remove: address):\n    \"\"\"\n    @notice\n        Remove an existing depositor from the priviledged addresses.\n    \"\"\"\n    assert self.is_operator[msg.sender], \"unauthorized\"\n    assert self.is_depositor[_to_remove], \"not an depositor\"\n\n    self.is_depositor[_to_remove] = False\n\n    log DepositorRemoved(_to_remove, msg.sender)"
    },
    {
      "filename": "fair-funding/contracts/Vault.vy",
      "content": "# @version 0.3.7\n\n\"\"\"\n@title Fair Funding Alchemix Vault\n@license GNU AGPLv3\n@author unstoppable.ooo\n\n@custom:security-contact team@unstoppable.com\n\n@notice\n    This vault manages a position on Alchemix.\n    Newly deposited WETH will be put into Alchemix and a corresponding\n    loan will be taken out and sent to the fund_receiver.\n\n    The Alchemix positions are governed by the referenced ERC721 tokens.\n\n    The owner of the token can at any point liquidate the underlying \n    Alchemix position and receive the remainder of their deposited funds\n    back.\n\n    Paid off debt on Alchemix (either manually repaid externally or by the\n    self-repaying feature of Alchemix) allows to withdraw parts of the \n    underlying collateral WETH as it becomes available.\n    This withdrawn ETH is marked as claimable and each token owner who \n    contributed to the position can claim his share of the unlocked WETH \n    up to the total amount that was initially deposited with this token.\n\n    Over time 100% of the initial collateral will become unlocked at \n    Alchemix and can be permissionlessly withdrawn by anyone to make it\n    claimable by the token holders.\n\n    Note:\n    We assume the LTV of Alchemix will not change and all positions can\n    be considered as having the same collateralisation / LTV.\n    In the unlikely case it does change, this contract will be re-deployed \n    with the updated collateralization value for new deposits.\n\n\"\"\"\n\nfrom vyper.interfaces import ERC721\nfrom vyper.interfaces import ERC20\n\ninterface IAlchemist:\n    def depositUnderlying(\n        _yield_token: address,\n        _amount: uint256,\n        _recipient: address,\n        _min_amount_out: uint256\n    ) -> uint256: nonpayable\n    def mint(\n        _amount: uint256,\n        _recipient: address\n    ): nonpayable\n    def withdrawUnderlying(\n        _yield_token: address,\n        _shares: uint256,\n        _recipient: address,\n        _min_amount_out: uint256\n    ) -> uint256: nonpayable\n    def liquidate(\n        _yield_token: address,\n        _shares: uint256,\n        _min_amount_out: uint256\n    ) -> uint256: nonpayable\n    def getUnderlyingTokensPerShare(\n        _yield_token: address\n    ) -> uint256: view\n    def totalValue(_owner: address) -> uint256: view\n    def minimumCollateralization() -> uint256: view\n    def accounts(_owner: address) -> (int256, DynArray[address, 8]): view\n    def positions(_owner: address, _yield_token: address) -> (uint256, uint256): view\n    def normalizeUnderlyingTokensToDebt(\n        _underlying_token: address, \n        _amount: uint256\n    ) -> uint256: view\n    def convertUnderlyingTokensToShares(\n        _yield_token: address, \n        _amount: uint256\n    ) -> uint256: view\n    def convertSharesToUnderlyingTokens(\n        _yield_token: address, \n        _shares: uint256\n    ) -> uint256: view\n\n\ninterface Migrator:\n    def migrate(): nonpayable\n\n\nPRECISION: constant(uint256) = 10**6\nDECIMALS: constant(uint256) = 10**18\n\nALCX_YVWETH: constant(address) = 0xa258C4606Ca8206D8aA700cE2143D7db854D168c\nWETH: constant(address) = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n\nNFT: public(immutable(address))\n\nalchemist: public(address)\nfund_receiver: public(address)\n\nstruct Position:\n    token_id: uint256\n    amount_deposited: uint256\n    amount_claimed: uint256\n    shares_owned: uint256\n    is_liquidated: bool\n\npositions: public(HashMap[uint256, Position])\ntotal_shares: public(uint256)\namount_claimable_per_share: public(uint256)\n\nis_operator: public(HashMap[address, bool])\nis_depositor: public(HashMap[address, bool])\n\n\nMIGRATION_TIMELOCK: constant(uint256) = 30 * 60 * 60 * 24  # 30 days in seconds\nmigration_admin: public(address)\nsuggested_migration_admin: public(address)\nmigration_active: public(uint256)\nmigrator: public(address)\nmigration_executed: public(bool)\n\nevent Deposit:\n    token_owner: indexed(address)\n    token_id: uint256\n    amount: uint256\n\nevent Funded:\n    receiver: indexed(address)\n    amount: uint256\n\nevent Liquidated:\n    token_id: uint256\n    token_owner: indexed(address)\n    amount: uint256\n\nevent Claimable:\n    amount: uint256\n\nevent Claimed:\n    token_id: uint256\n    token_owner: indexed(address)\n    amount: uint256\n\nevent AlchemistUpdated:\n    updater: indexed(address)\n    new_alchemist: indexed(address)\n\nevent FundReceiverUpdated:\n    updater: indexed(address)\n    new_fund_receiver: indexed(address)\n\nevent NewOperator:\n    new_operator: indexed(address)\n    promoted_by: indexed(address)\n\nevent OperatorRemoved:\n    removed: indexed(address)\n    removed_by: indexed(address)\n\nevent NewDepositor:\n    new_depositor: indexed(address)\n    promoted_by: indexed(address)\n\nevent DepositorRemoved:\n    removed: indexed(address)\n    removed_by: indexed(address)\n\nevent MigrationAdminTransferred:\n    new_admin: indexed(address)\n    promoted_by: indexed(address)\n\nevent NewMigrationAdminSuggested:\n    new_admin: indexed(address)\n    suggested_by: indexed(address)\n\nevent MigrationActivated:\n    migrator_address: address\n    active_at: uint256\n\nevent MigrationDeactivated: pass\n\n\n@external\ndef __init__(\n    _nft_address: address,\n):\n    assert _nft_address != empty(address), \"invalid nft address\"\n    NFT = _nft_address\n\n    self.is_operator[msg.sender] = True\n    self.fund_receiver = msg.sender\n\n    self.migration_active = max_value(uint256)\n    self.migration_admin = msg.sender\n\n\n@nonreentrant(\"lock\")\n@external\ndef register_deposit(_token_id: uint256, _amount: uint256):\n    \"\"\"\n    @notice\n        Registers a new deposit of _amount for _token_id.\n        _amount WETH is deposited into Alchemix and a corresponding\n        loan is taken out and sent to fund_receiver.\n    \"\"\"\n    assert self.is_depositor[msg.sender], \"not allowed\"\n    assert self._is_valid_token_id(_token_id)\n\n    position: Position = self.positions[_token_id]\n    assert position.is_liquidated == False, \"position already liquidated\"\n\n    position.token_id = _token_id\n    position.amount_deposited += _amount\n\n    # transfer WETH to self\n    ERC20(WETH).transferFrom(msg.sender, self, _amount)\n\n    # deposit WETH to Alchemix\n    shares_issued: uint256 = self._deposit_to_alchemist(_amount)\n    position.shares_owned += shares_issued\n    self.total_shares += shares_issued\n    \n    self.positions[_token_id] = position\n\n    # mint alchemix debt to fund_receiver\n    amount_to_mint: uint256 = self._calculate_amount_to_mint(shares_issued)\n    assert amount_to_mint > 0, \"cannot mint new Alchemix debt\"\n\n    self._mint_from_alchemix(amount_to_mint, self.fund_receiver)\n\n    log Deposit(msg.sender, _token_id, _amount)\n\n\n@internal\n@view\ndef _calculate_amount_to_mint(_amount_shares: uint256) -> uint256:\n    return min(self._calculate_mintable_amount(_amount_shares), self._calculate_max_mintable_amount())\n\n\n@internal\n@view\ndef _calculate_mintable_amount(_amount_shares: uint256) -> uint256:\n    \"\"\"\n    @notice\n        Calculate the mintable amount of debt tokens given _amount_shares new\n        shares as collateral.\n        This function does not account for existing debts on Alchemix.\n    \"\"\"\n    min_collateralization: uint256 = IAlchemist(self.alchemist).minimumCollateralization()\n    amount_shares_collateralized: uint256 = _amount_shares * DECIMALS / min_collateralization\n    amount_underlying: uint256 = IAlchemist(self.alchemist).convertSharesToUnderlyingTokens(ALCX_YVWETH, amount_shares_collateralized)\n    mintable_debt: uint256 = IAlchemist(self.alchemist).normalizeUnderlyingTokensToDebt(WETH, amount_underlying)\n    if mintable_debt > 0:\n        mintable_debt -= 1 # to pass \"<\" collateralisation check on Alchemix\n    return mintable_debt\n\n\n\n@internal\n@view\ndef _calculate_max_mintable_amount() -> uint256:\n    \"\"\"\n    @notice\n        Calculate the maximum mintable amount of debt tokens given the current\n        collateral and existing debt on Alchemix.\n    \"\"\"\n    # Alchemist._validate(): uint256 collateralization = totalValue(owner) * 1e18 / uint256(debt);\n    current_debt: uint256 = convert(IAlchemist(self.alchemist).accounts(self)[0], uint256)\n    total_value: uint256 = IAlchemist(self.alchemist).totalValue(self)\n    min_collateralization: uint256 = IAlchemist(self.alchemist).minimumCollateralization()\n\n    max_mintable_debt: uint256 = total_value * DECIMALS / min_collateralization - current_debt\n\n    if max_mintable_debt > 0:\n        max_mintable_debt = max_mintable_debt - 1 # minus 1 for collat < min_collat check @ alchemist._validate\n    \n    return max_mintable_debt\n\n\n\n\n@internal\ndef _deposit_to_alchemist(_amount: uint256) -> uint256:\n    \"\"\"\n    @notice\n        Deposits _amount WETH from this contract into the Alchemix ALCX_YVWETH\n        vault. \n    \"\"\"\n    assert self.alchemist != empty(address), \"invalid state, alchemist not set\"\n    \n    ERC20(WETH).approve(self.alchemist, _amount)\n    shares_issued: uint256 = IAlchemist(self.alchemist).depositUnderlying(\n        ALCX_YVWETH,     # yield_token\n        _amount,         # amount\n        self,            # recipient\n        1                # min_amount_out - cannot be frontrun in a significant way\n                         #                  so to reduce complexity we go with 1\n    )\n    return shares_issued\n\n\n@internal \ndef _mint_from_alchemix(_amount: uint256, _recipient: address):\n    \"\"\"\n    @notice\n        Takes on _amount of debt (in alETH) on Alchemix and transfers it to \n        _recipient.\n    \"\"\"\n    IAlchemist(self.alchemist).mint(\n        _amount,    # amount\n        _recipient  # recipient\n    )\n\n    log Funded(_recipient, _amount)\n\n\n@nonreentrant(\"lock\")\n@external\ndef liquidate(_token_id: uint256, _min_weth_out: uint256) -> uint256:\n    \"\"\"\n    @notice\n        Liquidates the underlying debt of position[_token_id] by burning\n        a corresponding amount of shares.\n        Withdraws remaining value of shares as WETH to token_owner.\n        Reverts if owner would receive less than _min_weth_out.\n    \"\"\"\n    token_owner: address = ERC721(NFT).ownerOf(_token_id)\n    assert token_owner == msg.sender, \"only token owner can liquidate\"\n\n    position: Position = self.positions[_token_id]\n    assert position.is_liquidated == False, \"position already liquidated\"\n    \n    position.is_liquidated = True\n    self.positions[_token_id] = position\n    self.total_shares -= position.shares_owned\n\n    collateralisation: uint256 = self._latest_collateralisation()\n    shares_to_liquidate: uint256 = position.shares_owned * DECIMALS / collateralisation\n\n    amount_shares_liquidated: uint256 = IAlchemist(self.alchemist).liquidate(\n        ALCX_YVWETH,                 # _yield_token: address,\n        shares_to_liquidate,         # _shares: uint256,\n        1                            # _min_amount_out: uint256 -> covered by _min_weth_out\n    )\n\n    amount_to_withdraw: uint256 = position.shares_owned - amount_shares_liquidated\n    # _withdraw_underlying_from_alchemix reverts on < _min_weth_out\n    amount_withdrawn: uint256 = self._withdraw_underlying_from_alchemix(amount_to_withdraw, token_owner, _min_weth_out)\n\n    log Liquidated(_token_id, token_owner, amount_withdrawn)\n    return amount_withdrawn\n\n\n@internal\ndef _latest_collateralisation() -> uint256:\n    \"\"\"\n    @notice\n        Calculates the current collateral to debt ratio on Alchemix.\n        Reverts when there is no debt and collateralisation would be\n        infinite.\n    \"\"\"\n    # Alchemist._validate(): \n    # uint256 collateralization = totalValue(owner) * FIXED_POINT_SCALAR / uint256(debt);\n    current_debt: int256 = IAlchemist(self.alchemist).accounts(self)[0]\n    assert current_debt > 0, \"zero debt\"\n    \n    total_value: uint256 = IAlchemist(self.alchemist).totalValue(self)\n    debt: uint256 = convert(current_debt, uint256)\n    return total_value * DECIMALS / debt\n\n\n@internal\ndef _withdraw_underlying_from_alchemix(\n    _amount_shares: uint256, \n    _receiver: address,\n    _min_weth_out: uint256\n) -> uint256:\n    \"\"\"\n    @notice\n        Withdraws _amount_shares to _receiver expecting at least _min_weth_out\n    \"\"\"\n    amount_withdrawn: uint256 = IAlchemist(self.alchemist).withdrawUnderlying(\n        ALCX_YVWETH,    # _yield_token: address,\n        _amount_shares, # _shares: uint256,\n        _receiver,      # _recipient: address,\n        _min_weth_out   # _min_amount_out: uint256 \n    )\n    assert amount_withdrawn >= _min_weth_out, \"insufficient weth out\"\n    return amount_withdrawn\n\n\n@external\ndef withdraw_underlying_to_claim(_amount_shares: uint256, _min_weth_out: uint256):\n    \"\"\"\n    @notice\n        Withdraws _amount_shares and _min_weth_out from Alchemix to be distributed\n        to token holders.\n        The WETH is held in this contract until it is `claim`ed.\n    \"\"\"\n    amount_withdrawn: uint256 = self._withdraw_underlying_from_alchemix(_amount_shares, self, _min_weth_out)\n    self._mark_as_claimable(amount_withdrawn)\n\n    log Claimable(amount_withdrawn)\n\n\n@internal\ndef _mark_as_claimable(_amount: uint256):\n    \"\"\"\n    @notice\n        Marks _amount of WETH as claimable by token holders and\n        calculates the amount_claimable_per_share.\n    \"\"\"\n    if _amount == 0 or self.total_shares == 0:\n        return\n\n    assert ERC20(WET"
    }
  ]
}