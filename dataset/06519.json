{
  "Title": "[H-01] The distribution logic will be broken after calling `rageQuit()`",
  "Content": "\nMalicious users might receive more distributed funds than they should with higher `distributionShare`.\n\n### Proof of Concept\n\nIn `PartyGovernanceNFT.sol`, there is a `getDistributionShareOf()` function to calculate the distribution share of party NFT.\n\n```solidity\n    function getDistributionShareOf(uint256 tokenId) public view returns (uint256) {\n        uint256 totalVotingPower = _governanceValues.totalVotingPower;\n\n        if (totalVotingPower == 0) {\n            return 0;\n        } else {\n            return (votingPowerByTokenId[tokenId] * 1e18) / totalVotingPower;\n        }\n    }\n```\n\nThis function is used to calculate the claimable amount in [getClaimAmount()](https://github.com/code-423n4/2023-05-party/blob/f6f80dde81d86e397ba4f3dedb561e23d58ec884/contracts/distribution/TokenDistributor.sol#L234).\n\n```solidity\n    function getClaimAmount(\n        ITokenDistributorParty party,\n        uint256 memberSupply,\n        uint256 partyTokenId\n    ) public view returns (uint128) {\n        // getDistributionShareOf() is the fraction of the memberSupply partyTokenId\n        // is entitled to, scaled by 1e18.\n        // We round up here to prevent dust amounts getting trapped in this contract.\n        return\n            ((uint256(party.getDistributionShareOf(partyTokenId)) * memberSupply + (1e18 - 1)) /\n                1e18).safeCastUint256ToUint128();\n    }\n```\n\nSo after the party distributed funds by executing the distribution proposal, users can claim relevant amounts of funds using their party NFTs.\n\nAfter the update, `rageQuit()` was added so that users can burn their party NFTs while taking their share of the party's funds.\n\nSo the below scenario would be possible.\n\n1.  Let's assume `totalVotingPower = 300` and the party has 3 party NFTs of 100 voting power. And `Alice` has 2 NFTs and `Bob` has 1 NFT.\n2.  They proposed a distribution proposal and executed it. Let's assume the party transferred 3 ether to the distributor.\n3.  They can claim the funds by calling [TokenDistributor.claim()](https://github.com/code-423n4/2023-05-party/blob/f6f80dde81d86e397ba4f3dedb561e23d58ec884/contracts/distribution/TokenDistributor.sol#L138) and `Alice` should receive 2 ether and 1 ether for `Bob`.(We ignore the distribution fee.)\n4.  But `Alice` decided to steal `Bob`'s funds so she claimed the distributed funds(3 / 3 = 1 ether) with the first NFT and called `rageQuit()` to take her share of the party's remaining funds.\n5.  After that, `Alice` calls `claim()` with the second NFT, and `getDistributionShareOf()` will return 50% as the total voting power was decreased to 200. So `Alice` will receive `3 * 50% = 1.5 ether` and `Bob` will receive only 0.5 ether because of this [validation](https://github.com/code-423n4/2023-05-party/blob/f6f80dde81d86e397ba4f3dedb561e23d58ec884/contracts/distribution/TokenDistributor.sol#L167)\n6.  After all, `Alice` received 2.5 ether instead of 2 ether.\n\nEven if `rageQuit` is disabled, `Alice` can burn, using `burn()`, her NFT directly if her share of the party's remaining funds are less than the stolen funds from `Bob`.\n\nHere is a simple POC showing the distribution shares after `rageQuit()`.\n\n```solidity\n    function testWrongDistributionSharesAfterRageQuit() external {\n        (Party party, , ) = partyAdmin.createParty(\n            partyImpl,\n            PartyAdmin.PartyCreationMinimalOptions({\n                host1: address(this),\n                host2: address(0),\n                passThresholdBps: 5100,\n                totalVotingPower: 300,\n                preciousTokenAddress: address(toadz),\n                preciousTokenId: 1,\n                rageQuitTimestamp: 0,\n                feeBps: 0,\n                feeRecipient: payable(0)\n            })\n        );\n\n        vm.prank(address(this));\n        party.setRageQuit(uint40(block.timestamp) + 1);\n\n        address user1 = _randomAddress();\n        address user2 = _randomAddress();\n        address user3 = _randomAddress();\n\n        //3 users have the same voting power\n        vm.prank(address(partyAdmin));\n        uint256 tokenId1 = party.mint(user1, 100, user1);\n\n        vm.prank(address(partyAdmin));\n        uint256 tokenId2 = party.mint(user2, 100, user2);\n\n        vm.prank(address(partyAdmin));\n        uint256 tokenId3 = party.mint(user3, 100, user3);\n\n        vm.deal(address(party), 1 ether);\n\n        // Before calling rageQuit(), each user has the same 33.3333% shares\n        uint256 expectedShareBeforeRageQuit = uint256(100) * 1e18 / 300;\n        assertEq(party.getDistributionShareOf(tokenId1), expectedShareBeforeRageQuit);\n        assertEq(party.getDistributionShareOf(tokenId2), expectedShareBeforeRageQuit);\n        assertEq(party.getDistributionShareOf(tokenId3), expectedShareBeforeRageQuit);\n\n        IERC20[] memory tokens = new IERC20[](1);\n        tokens[0] = IERC20(ETH_ADDRESS);\n        uint256[] memory tokenIds = new uint256[](1);\n        tokenIds[0] = tokenId1;\n\n        vm.prank(user1);\n        party.rageQuit(tokenIds, tokens, user1);\n\n        // After calling rageQuit() by one user, the second user has 50% shares and can claim more distribution\n        uint256 expectedShareAfterRageQuit = uint256(100) * 1e18 / 200;\n        assertEq(party.getDistributionShareOf(tokenId2), expectedShareAfterRageQuit);\n    }\n```\n### Recommended Mitigation Steps\n\nI think we shouldn't use `getDistributionShareOf()` for distribution shares.\n\nInstead, we should remember `totalVotingPower` for each distribution separately in [\\_createDistribution()](https://github.com/code-423n4/2023-05-party/blob/f6f80dde81d86e397ba4f3dedb561e23d58ec884/contracts/distribution/TokenDistributor.sol#L310) so that each user can receive correct funds even after some NFTs are burnt.\n\n### Assessed type\n\nGovernance\n\n**[0xble (Party) confirmed](https://github.com/code-423n4/2023-05-party-findings/issues/6#issuecomment-1572311569)**\n\n***\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-05-party",
  "Code": [
    {
      "filename": "contracts/distribution/TokenDistributor.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport \"../globals/IGlobals.sol\";\nimport \"../globals/LibGlobals.sol\";\nimport \"../tokens/IERC20.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibERC20Compat.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\n\nimport \"./ITokenDistributor.sol\";\n\n/// @notice Creates token distributions for parties (or any contract that\n///         implements `ITokenDistributorParty`).\ncontract TokenDistributor is ITokenDistributor {\n    using LibAddress for address payable;\n    using LibERC20Compat for IERC20;\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n\n    struct DistributionState {\n        // The hash of the `DistributionInfo`.\n        bytes32 distributionHash;\n        // The remaining member supply.\n        uint128 remainingMemberSupply;\n        // Whether the distribution's feeRecipient has claimed its fee.\n        bool wasFeeClaimed;\n        // Whether a governance token has claimed its distribution share.\n        mapping(uint256 => bool) hasPartyTokenClaimed;\n    }\n\n    // Arguments for `_createDistribution()`.\n    struct CreateDistributionArgs {\n        ITokenDistributorParty party;\n        TokenType tokenType;\n        address token;\n        uint256 currentTokenBalance;\n        address payable feeRecipient;\n        uint16 feeBps;\n    }\n\n    event EmergencyExecute(address target, bytes data);\n\n    error OnlyPartyDaoError(address notDao, address partyDao);\n    error InvalidDistributionInfoError(DistributionInfo info);\n    error DistributionAlreadyClaimedByPartyTokenError(uint256 distributionId, uint256 partyTokenId);\n    error DistributionFeeAlreadyClaimedError(uint256 distributionId);\n    error MustOwnTokenError(address sender, address expectedOwner, uint256 partyTokenId);\n    error EmergencyActionsNotAllowedError();\n    error InvalidDistributionSupplyError(uint128 supply);\n    error OnlyFeeRecipientError(address caller, address feeRecipient);\n    error InvalidFeeBpsError(uint16 feeBps);\n\n    // Token address used to indicate a native distribution (i.e. distribution of ETH).\n    address private constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice The `Globals` contract storing global configuration values. This contract\n    ///         is immutable and it’s address will never change.\n    IGlobals public immutable GLOBALS;\n    /// @notice Timestamp when the DAO is no longer allowed to call emergency functions.\n    uint40 public immutable EMERGENCY_DISABLED_TIMESTAMP;\n\n    /// @notice Last distribution ID for a party.\n    mapping(ITokenDistributorParty => uint256) public lastDistributionIdPerParty;\n    /// Last known balance of a token, identified by an ID derived from the token.\n    /// Gets lazily updated when creating and claiming a distribution (transfers).\n    /// Allows one to simply transfer and call `createDistribution()` without\n    /// fussing with allowances.\n    mapping(bytes32 => uint256) private _storedBalances;\n    // tokenDistributorParty => distributionId => DistributionState\n    mapping(ITokenDistributorParty => mapping(uint256 => DistributionState))\n        private _distributionStates;\n\n    // msg.sender == DAO\n    modifier onlyPartyDao() {\n        {\n            address partyDao = GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\n            if (msg.sender != partyDao) {\n                revert OnlyPartyDaoError(msg.sender, partyDao);\n            }\n        }\n        _;\n    }\n\n    // emergencyActionsDisabled == false\n    modifier onlyIfEmergencyActionsAllowed() {\n        if (block.timestamp > EMERGENCY_DISABLED_TIMESTAMP) {\n            revert EmergencyActionsNotAllowedError();\n        }\n        _;\n    }\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals, uint40 emergencyDisabledTimestamp) {\n        GLOBALS = globals;\n        EMERGENCY_DISABLED_TIMESTAMP = emergencyDisabledTimestamp;\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function createNativeDistribution(\n        ITokenDistributorParty party,\n        address payable feeRecipient,\n        uint16 feeBps\n    ) external payable returns (DistributionInfo memory info) {\n        info = _createDistribution(\n            CreateDistributionArgs({\n                party: party,\n                tokenType: TokenType.Native,\n                token: NATIVE_TOKEN_ADDRESS,\n                currentTokenBalance: address(this).balance,\n                feeRecipient: feeRecipient,\n                feeBps: feeBps\n            })\n        );\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function createErc20Distribution(\n        IERC20 token,\n        ITokenDistributorParty party,\n        address payable feeRecipient,\n        uint16 feeBps\n    ) external returns (DistributionInfo memory info) {\n        info = _createDistribution(\n            CreateDistributionArgs({\n                party: party,\n                tokenType: TokenType.Erc20,\n                token: address(token),\n                currentTokenBalance: token.balanceOf(address(this)),\n                feeRecipient: feeRecipient,\n                feeBps: feeBps\n            })\n        );\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function claim(\n        DistributionInfo calldata info,\n        uint256 partyTokenId\n    ) public returns (uint128 amountClaimed) {\n        // Caller must own the party token.\n        {\n            address ownerOfPartyToken = info.party.ownerOf(partyTokenId);\n            if (msg.sender != ownerOfPartyToken) {\n                revert MustOwnTokenError(msg.sender, ownerOfPartyToken, partyTokenId);\n            }\n        }\n        // DistributionInfo must be correct for this distribution ID.\n        DistributionState storage state = _distributionStates[info.party][info.distributionId];\n        if (state.distributionHash != _getDistributionHash(info)) {\n            revert InvalidDistributionInfoError(info);\n        }\n        // The partyTokenId must not have claimed its distribution yet.\n        if (state.hasPartyTokenClaimed[partyTokenId]) {\n            revert DistributionAlreadyClaimedByPartyTokenError(info.distributionId, partyTokenId);\n        }\n        // Mark the partyTokenId as having claimed their distribution.\n        state.hasPartyTokenClaimed[partyTokenId] = true;\n\n        // Compute amount owed to partyTokenId.\n        amountClaimed = getClaimAmount(info.party, info.memberSupply, partyTokenId);\n\n        // Cap at the remaining member supply. Otherwise a malicious\n        // party could drain more than the distribution supply.\n        uint128 remainingMemberSupply = state.remainingMemberSupply;\n        amountClaimed = amountClaimed > remainingMemberSupply\n            ? remainingMemberSupply\n            : amountClaimed;\n        state.remainingMemberSupply = remainingMemberSupply - amountClaimed;\n\n        // Transfer tokens owed.\n        _transfer(info.tokenType, info.token, payable(msg.sender), amountClaimed);\n        emit DistributionClaimedByPartyToken(\n            info.party,\n            partyTokenId,\n            msg.sender,\n            info.tokenType,\n            info.token,\n            amountClaimed\n        );\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function claimFee(DistributionInfo calldata info, address payable recipient) public {\n        // DistributionInfo must be correct for this distribution ID.\n        DistributionState storage state = _distributionStates[info.party][info.distributionId];\n        if (state.distributionHash != _getDistributionHash(info)) {\n            revert InvalidDistributionInfoError(info);\n        }\n        // Caller must be the fee recipient.\n        if (info.feeRecipient != msg.sender) {\n            revert OnlyFeeRecipientError(msg.sender, info.feeRecipient);\n        }\n        // Must not have claimed the fee yet.\n        if (state.wasFeeClaimed) {\n            revert DistributionFeeAlreadyClaimedError(info.distributionId);\n        }\n        // Mark the fee as claimed.\n        state.wasFeeClaimed = true;\n        // Transfer the tokens owed.\n        _transfer(info.tokenType, info.token, recipient, info.fee);\n        emit DistributionFeeClaimed(\n            info.party,\n            info.feeRecipient,\n            info.tokenType,\n            info.token,\n            info.fee\n        );\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function batchClaim(\n        DistributionInfo[] calldata infos,\n        uint256[] calldata partyTokenIds\n    ) external returns (uint128[] memory amountsClaimed) {\n        amountsClaimed = new uint128[](infos.length);\n        for (uint256 i = 0; i < infos.length; ++i) {\n            amountsClaimed[i] = claim(infos[i], partyTokenIds[i]);\n        }\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function batchClaimFee(\n        DistributionInfo[] calldata infos,\n        address payable[] calldata recipients\n    ) external {\n        for (uint256 i = 0; i < infos.length; ++i) {\n            claimFee(infos[i], recipients[i]);\n        }\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function getClaimAmount(\n        ITokenDistributorParty party,\n        uint256 memberSupply,\n        uint256 partyTokenId\n    ) public view returns (uint128) {\n        // getDistributionShareOf() is the fraction of the memberSupply partyTokenId\n        // is entitled to, scaled by 1e18.\n        // We round up here to prevent dust amounts getting trapped in this contract.\n        return\n            ((uint256(party.getDistributionShareOf(partyTokenId)) * memberSupply + (1e18 - 1)) /\n                1e18).safeCastUint256ToUint128();\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function wasFeeClaimed(\n        ITokenDistributorParty party,\n        uint256 distributionId\n    ) external view returns (bool) {\n        return _distributionStates[party][distributionId].wasFeeClaimed;\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function hasPartyTokenIdClaimed(\n        ITokenDistributorParty party,\n        uint256 partyTokenId,\n        uint256 distributionId\n    ) external view returns (bool) {\n        return _distributionStates[party][distributionId].hasPartyTokenClaimed[partyTokenId];\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function getRemainingMemberSupply(\n        ITokenDistributorParty party,\n        uint256 distributionId\n    ) external view returns (uint128) {\n        return _distributionStates[party][distributionId].remainingMemberSupply;\n    }\n\n    /// @notice As the DAO, execute an arbitrary delegatecall from this contract.\n    /// @dev Emergency actions must not be revoked for this to work.\n    /// @param targetAddress The contract to delegatecall into.\n    /// @param targetCallData The data to pass to the call.\n    function emergencyExecute(\n        address targetAddress,\n        bytes calldata targetCallData\n    ) external onlyPartyDao onlyIfEmergencyActionsAllowed {\n        (bool success, bytes memory res) = targetAddress.delegatecall(targetCallData);\n        if (!success) {\n            res.rawRevert();\n        }\n        emit EmergencyExecute(targetAddress, targetCallData);\n    }\n\n    function _createDistribution(\n        CreateDistributionArgs memory args\n    ) private returns (DistributionInfo memory info) {\n        if (args.feeBps > 1e4) {\n            revert InvalidFeeBpsError(args.feeBps);\n        }\n        uint128 supply;\n        {\n            bytes32 balanceId = _getBalanceId(args.tokenType, args.token);\n            supply = (args.currentTokenBalance - _storedBalances[balanceId])\n                .safeCastUint256ToUint128();\n            // Supply must be nonzero.\n            if (supply == 0) {\n                revert InvalidDistributionSupplyError(supply);\n            }\n            // Update stored balance.\n            _storedBalances[balanceId] = args.currentTokenBalance;\n        }\n\n        // Create a distribution.\n        uint128 fee = (supply * args.feeBps) / 1e4;\n        uint128 memberSupply = supply - fee;\n\n        info = DistributionInfo({\n            tokenType: args.tokenType,\n            distributionId: ++lastDistributionIdPerParty[args.party],\n            token: args.token,\n            party: args.party,\n            memberSupply: memberSupply,\n            feeRecipient: args.feeRecipient,\n            fee: fee\n        });\n        (\n            _distributionStates[args.party][info.distributionId].distributionHash,\n            _distributionStates[args.party][info.distributionId].remainingMemberSupply\n        ) = (_getDistributionHash(info), memberSupply);\n        emit DistributionCreated(args.party, info);\n    }\n\n    function _transfer(\n        TokenType tokenType,\n        address token,\n        address payable recipient,\n        uint256 amount\n    ) private {\n        bytes32 balanceId = _getBalanceId(tokenType, token);\n        // Reduce stored token balance.\n        uint256 storedBalance = _storedBalances[balanceId] - amount;\n        // Temporarily set to max as a reentrancy guard. An interesing attack\n        // could occur if we didn't do this where an attacker could `claim()` and\n        // reenter upon transfer (e.g. in the `tokensToSend` hook of an ERC777) to\n        // `createERC20Distribution()`. Since the `balanceOf(address(this))`\n        // would not of been updated yet, the supply would be miscalculated and\n        // the attacker would create a distribution that essentially steals from\n        // the last distribution they were claiming from. Here, we prevent that\n        // by causing an arithmetic underflow with the supply calculation if\n        // this were to be attempted.\n        _storedBalances[balanceId] = type(uint256).max;\n        if (tokenType == TokenType.Native) {\n            recipient.transferEth(amount);\n        } else {\n            assert(tokenType == TokenType.Erc20);\n            IERC20(token).compatTransfer(recipient, amount);\n        }\n        _storedBalances[balanceId] = storedBalance;\n    }\n\n    function _getDistributionHash(\n        DistributionInfo memory info\n    ) internal pure returns (bytes32 hash) {\n        assembly {\n            hash := keccak256(info, 0xe0)\n        }\n    }\n\n    function _getBalanceId(\n        TokenType tokenType,\n        address token\n    ) private pure returns (bytes32 balanceId) {\n        if (tokenType == TokenType.Native) {\n            return bytes32(uint256(uint160(NATIVE_TOKEN_ADDRESS)));\n        }\n        assert(tokenType == TokenType.Erc20);\n        return bytes32(uint256(uint160(token)));\n    }\n}"
    },
    {
      "filename": "contracts/distribution/TokenDistributor.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport \"../globals/IGlobals.sol\";\nimport \"../globals/LibGlobals.sol\";\nimport \"../tokens/IERC20.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibERC20Compat.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\n\nimport \"./ITokenDistributor.sol\";\n\n/// @notice Creates token distributions for parties (or any contract that\n///         implements `ITokenDistributorParty`).\ncontract TokenDistributor is ITokenDistributor {\n    using LibAddress for address payable;\n    using LibERC20Compat for IERC20;\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n\n    struct DistributionState {\n        // The hash of the `DistributionInfo`.\n        bytes32 distributionHash;\n        // The remaining member supply.\n        uint128 remainingMemberSupply;\n        // Whether the distribution's feeRecipient has claimed its fee.\n        bool wasFeeClaimed;\n        // Whether a governance token has claimed its distribution share.\n        mapping(uint256 => bool) hasPartyTokenClaimed;\n    }\n\n    // Arguments for `_createDistribution()`.\n    struct CreateDistributionArgs {\n        ITokenDistributorParty party;\n        TokenType tokenType;\n        address token;\n        uint256 currentTokenBalance;\n        address payable feeRecipient;\n        uint16 feeBps;\n    }\n\n    event EmergencyExecute(address target, bytes data);\n\n    error OnlyPartyDaoError(address notDao, address partyDao);\n    error InvalidDistributionInfoError(DistributionInfo info);\n    error DistributionAlreadyClaimedByPartyTokenError(uint256 distributionId, uint256 partyTokenId);\n    error DistributionFeeAlreadyClaimedError(uint256 distributionId);\n    error MustOwnTokenError(address sender, address expectedOwner, uint256 partyTokenId);\n    error EmergencyActionsNotAllowedError();\n    error InvalidDistributionSupplyError(uint128 supply);\n    error OnlyFeeRecipientError(address caller, address feeRecipient);\n    error InvalidFeeBpsError(uint16 feeBps);\n\n    // Token address used to indicate a native distribution (i.e. distribution of ETH).\n    address private constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice The `Globals` contract storing global configuration values. This contract\n    ///         is immutable and it’s address will never change.\n    IGlobals public immutable GLOBALS;\n    /// @notice Timestamp when the DAO is no longer allowed to call emergency functions.\n    uint40 public immutable EMERGENCY_DISABLED_TIMESTAMP;\n\n    /// @notice Last distribution ID for a party.\n    mapping(ITokenDistributorParty => uint256) public lastDistributionIdPerParty;\n    /// Last known balance of a token, identified by an ID derived from the token.\n    /// Gets lazily updated when creating and claiming a distribution (transfers).\n    /// Allows one to simply transfer and call `createDistribution()` without\n    /// fussing with allowances.\n    mapping(bytes32 => uint256) private _storedBalances;\n    // tokenDistributorParty => distributionId => DistributionState\n    mapping(ITokenDistributorParty => mapping(uint256 => DistributionState))\n        private _distributionStates;\n\n    // msg.sender == DAO\n    modifier onlyPartyDao() {\n        {\n            address partyDao = GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\n            if (msg.sender != partyDao) {\n                revert OnlyPartyDaoError(msg.sender, partyDao);\n            }\n        }\n        _;\n    }\n\n    // emergencyActionsDisabled == false\n    modifier onlyIfEmergencyActionsAllowed() {\n        if (block.timestamp > EMERGENCY_DISABLED_TIMESTAMP) {\n            revert EmergencyActionsNotAllowedError();\n        }\n        _;\n    }\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals, uint40 emergencyDisabledTimestamp) {\n        GLOBALS = globals;\n        EMERGENCY_DISABLED_TIMESTAMP = emergencyDisabledTimestamp;\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function createNativeDistribution(\n        ITokenDistributorParty party,\n        address payable feeRecipient,\n        uint16 feeBps\n    ) external payable returns (DistributionInfo memory info) {\n        info = _createDistribution(\n            CreateDistributionArgs({\n                party: party,\n                tokenType: TokenType.Native,\n                token: NATIVE_TOKEN_ADDRESS,\n                currentTokenBalance: address(this).balance,\n                feeRecipient: feeRecipient,\n                feeBps: feeBps\n            })\n        );\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function createErc20Distribution(\n        IERC20 token,\n        ITokenDistributorParty party,\n        address payable feeRecipient,\n        uint16 feeBps\n    ) external returns (DistributionInfo memory info) {\n        info = _createDistribution(\n            CreateDistributionArgs({\n                party: party,\n                tokenType: TokenType.Erc20,\n                token: address(token),\n                currentTokenBalance: token.balanceOf(address(this)),\n                feeRecipient: feeRecipient,\n                feeBps: feeBps\n            })\n        );\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function claim(\n        DistributionInfo calldata info,\n        uint256 partyTokenId\n    ) public returns (uint128 amountClaimed) {\n        // Caller must own the party token.\n        {\n            address ownerOfPartyToken = info.party.ownerOf(partyTokenId);\n            if (msg.sender != ownerOfPartyToken) {\n                revert MustOwnTokenError(msg.sender, ownerOfPartyToken, partyTokenId);\n            }\n        }\n        // DistributionInfo must be correct for this distribution ID.\n        DistributionState storage state = _distributionStates[info.party][info.distributionId];\n        if (state.distributionHash != _getDistributionHash(info)) {\n            revert InvalidDistributionInfoError(info);\n        }\n        // The partyTokenId must not have claimed its distribution yet.\n        if (state.hasPartyTokenClaimed[partyTokenId]) {\n            revert DistributionAlreadyClaimedByPartyTokenError(info.distributionId, partyTokenId);\n        }\n        // Mark the partyTokenId as having claimed their distribution.\n        state.hasPartyTokenClaimed[partyTokenId] = true;\n\n        // Compute amount owed to partyTokenId.\n        amountClaimed = getClaimAmount(info.party, info.memberSupply, partyTokenId);\n\n        // Cap at the remaining member supply. Otherwise a malicious\n        // party could drain more than the distribution supply.\n        uint128 remainingMemberSupply = state.remainingMemberSupply;\n        amountClaimed = amountClaimed > remainingMemberSupply\n            ? remainingMemberSupply\n            : amountClaimed;\n        state.remainingMemberSupply = remainingMemberSupply - amountClaimed;\n\n        // Transfer tokens owed.\n        _transfer(info.tokenType, info.token, payable(msg.sender), amountClaimed);\n        emit DistributionClaimedByPartyToken(\n            info.party,\n            partyTokenId,\n            msg.sender,\n            info.tokenType,\n            info.token,\n            amountClaimed\n        );\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function claimFee(DistributionInfo calldata info, address payable recipient) public {\n        // DistributionInfo must be correct for this distribution ID.\n        DistributionState storage state = _distributionStates[info.party][info.distributionId];\n        if (state.distributionHash != _getDistributionHash(info)) {\n            revert InvalidDistributionInfoError(info);\n        }\n        // Caller must be the fee recipient.\n        if (info.feeRecipient != msg.sender) {\n            revert OnlyFeeRecipientError(msg.sender, info.feeRecipient);\n        }\n        // Must not have claimed the fee yet.\n        if (state.wasFeeClaimed) {\n            revert DistributionFeeAlreadyClaimedError(info.distributionId);\n        }\n        // Mark the fee as claimed.\n        state.wasFeeClaimed = true;\n        // Transfer the tokens owed.\n        _transfer(info.tokenType, info.token, recipient, info.fee);\n        emit DistributionFeeClaimed(\n            info.party,\n            info.feeRecipient,\n            info.tokenType,\n            info.token,\n            info.fee\n        );\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function batchClaim(\n        DistributionInfo[] calldata infos,\n        uint256[] calldata partyTokenIds\n    ) external returns (uint128[] memory amountsClaimed) {\n        amountsClaimed = new uint128[](infos.length);\n        for (uint256 i = 0; i < infos.length; ++i) {\n            amountsClaimed[i] = claim(infos[i], partyTokenIds[i]);\n        }\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function batchClaimFee(\n        DistributionInfo[] calldata infos,\n        address payable[] calldata recipients\n    ) external {\n        for (uint256 i = 0; i < infos.length; ++i) {\n            claimFee(infos[i], recipients[i]);\n        }\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function getClaimAmount(\n        ITokenDistributorParty party,\n        uint256 memberSupply,\n        uint256 partyTokenId\n    ) public view returns (uint128) {\n        // getDistributionShareOf() is the fraction of the memberSupply partyTokenId\n        // is entitled to, scaled by 1e18.\n        // We round up here to prevent dust amounts getting trapped in this contract.\n        return\n            ((uint256(party.getDistributionShareOf(partyTokenId)) * memberSupply + (1e18 - 1)) /\n                1e18).safeCastUint256ToUint128();\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function wasFeeClaimed(\n        ITokenDistributorParty party,\n        uint256 distributionId\n    ) external view returns (bool) {\n        return _distributionStates[party][distributionId].wasFeeClaimed;\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function hasPartyTokenIdClaimed(\n        ITokenDistributorParty party,\n        uint256 partyTokenId,\n        uint256 distributionId\n    ) external view returns (bool) {\n        return _distributionStates[party][distributionId].hasPartyTokenClaimed[partyTokenId];\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function getRemainingMemberSupply(\n        ITokenDistributorParty party,\n        uint256 distributionId\n    ) external view returns (uint128) {\n        return _distributionStates[party][distributionId].remainingMemberSupply;\n    }\n\n    /// @notice As the DAO, execute an arbitrary delegatecall from this contract.\n    /// @dev Emergency actions must not be revoked for this to work.\n    /// @param targetAddress The contract to delegatecall into.\n    /// @param targetCallData The data to pass to the call.\n    function emergencyExecute(\n        address targetAddress,\n        bytes calldata targetCallData\n    ) external onlyPartyDao onlyIfEmergencyActionsAllowed {\n        (bool success, bytes memory res) = targetAddress.delegatecall(targetCallData);\n        if (!success) {\n            res.rawRevert();\n        }\n        emit EmergencyExecute(targetAddress, targetCallData);\n    }\n\n    function _createDistribution(\n        CreateDistributionArgs memory args\n    ) private returns (DistributionInfo memory info) {\n        if (args.feeBps > 1e4) {\n            revert InvalidFeeBpsError(args.feeBps);\n        }\n        uint128 supply;\n        {\n            bytes32 balanceId = _getBalanceId(args.tokenType, args.token);\n            supply = (args.currentTokenBalance - _storedBalances[balanceId])\n                .safeCastUint256ToUint128();\n            // Supply must be nonzero.\n            if (supply == 0) {\n                revert InvalidDistributionSupplyError(supply);\n            }\n            // Update stored balance.\n            _storedBalances[balanceId] = args.currentTokenBalance;\n        }\n\n        // Create a distribution.\n        uint128 fee = (supply * args.feeBps) / 1e4;\n        uint128 memberSupply = supply - fee;\n\n        info = DistributionInfo({\n            tokenType: args.tokenType,\n            distributionId: ++lastDistributionIdPerParty[args.party],\n            token: args.token,\n            party: args.party,\n            memberSupply: memberSupply,\n            feeRecipient: args.feeRecipient,\n            fee: fee\n        });\n        (\n            _distributionStates[args.party][info.distributionId].distributionHash,\n            _distributionStates[args.party][info.distributionId].remainingMemberSupply\n        ) = (_getDistributionHash(info), memberSupply);\n        emit DistributionCreated(args.party, info);\n    }\n\n    function _transfer(\n        TokenType tokenType,\n        address token,\n        address payable recipient,\n        uint256 amount\n    ) private {\n        bytes32 balanceId = _getBalanceId(tokenType, token);\n        // Reduce stored token balance.\n        uint256 storedBalance = _storedBalances[balanceId] - amount;\n        // Temporarily set to max as a reentrancy guard. An interesing attack\n        // could occur if we didn't do this where an attacker could `claim()` and\n        // reenter upon transfer (e.g. in the `tokensToSend` hook of an ERC777) to\n        // `createERC20Distribution()`. Since the `balanceOf(address(this))`\n        // would not of been updated yet, the supply would be miscalculated and\n        // the attacker would create a distribution that essentially steals from\n        // the last distribution they were claiming from. Here, we prevent that\n        // by causing an arithmetic underflow with the supply calculation if\n        // this were to be attempted.\n        _storedBalances[balanceId] = type(uint256).max;\n        if (tokenType == TokenType.Native) {\n            recipient.transferEth(amount);\n        } else {\n            assert(tokenType == TokenType.Erc20);\n            IERC20(token).compatTransfer(recipient, amount);\n        }\n        _storedBalances[balanceId] = storedBalance;\n    }\n\n    function _getDistributionHash(\n        DistributionInfo memory info\n    ) internal pure returns (bytes32 hash) {\n        assembly {\n            hash := keccak256(info, 0xe0)\n        }\n    }\n\n    function _getBalanceId(\n        TokenType tokenType,\n        address token\n    ) private pure returns (bytes32 balanceId) {\n        if (tokenType == TokenType.Native) {\n            return bytes32(uint256(uint160(NATIVE_TOKEN_ADDRESS)));\n        }\n        assert(tokenType == TokenType.Erc20);\n        return bytes32(uint256(uint160(token)));\n    }\n}"
    },
    {
      "filename": "contracts/distribution/TokenDistributor.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport \"../globals/IGlobals.sol\";\nimport \"../globals/LibGlobals.sol\";\nimport \"../tokens/IERC20.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibERC20Compat.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\n\nimport \"./ITokenDistributor.sol\";\n\n/// @notice Creates token distributions for parties (or any contract that\n///         implements `ITokenDistributorParty`).\ncontract TokenDistributor is ITokenDistributor {\n    using LibAddress for address payable;\n    using LibERC20Compat for IERC20;\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n\n    struct DistributionState {\n        // The hash of the `DistributionInfo`.\n        bytes32 distributionHash;\n        // The remaining member supply.\n        uint128 remainingMemberSupply;\n        // Whether the distribution's feeRecipient has claimed its fee.\n        bool wasFeeClaimed;\n        // Whether a governance token has claimed its distribution share.\n        mapping(uint256 => bool) hasPartyTokenClaimed;\n    }\n\n    // Arguments for `_createDistribution()`.\n    struct CreateDistributionArgs {\n        ITokenDistributorParty party;\n        TokenType tokenType;\n        address token;\n        uint256 currentTokenBalance;\n        address payable feeRecipient;\n        uint16 feeBps;\n    }\n\n    event EmergencyExecute(address target, bytes data);\n\n    error OnlyPartyDaoError(address notDao, address partyDao);\n    error InvalidDistributionInfoError(DistributionInfo info);\n    error DistributionAlreadyClaimedByPartyTokenError(uint256 distributionId, uint256 partyTokenId);\n    error DistributionFeeAlreadyClaimedError(uint256 distributionId);\n    error MustOwnTokenError(address sender, address expectedOwner, uint256 partyTokenId);\n    error EmergencyActionsNotAllowedError();\n    error InvalidDistributionSupplyError(uint128 supply);\n    error OnlyFeeRecipientError(address caller, address feeRecipient);\n    error InvalidFeeBpsError(uint16 feeBps);\n\n    // Token address used to indicate a native distribution (i.e. distribution of ETH).\n    address private constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice The `Globals` contract storing global configuration values. This contract\n    ///         is immutable and it’s address will never change.\n    IGlobals public immutable GLOBALS;\n    /// @notice Timestamp when the DAO is no longer allowed to call emergency functions.\n    uint40 public immutable EMERGENCY_DISABLED_TIMESTAMP;\n\n    /// @notice Last distribution ID for a party.\n    mapping(ITokenDistributorParty => uint256) public lastDistributionIdPerParty;\n    /// Last known balance of a token, identified by an ID derived from the token.\n    /// Gets lazily updated when creating and claiming a distribution (transfers).\n    /// Allows one to simply transfer and call `createDistribution()` without\n    /// fussing with allowances.\n    mapping(bytes32 => uint256) private _storedBalances;\n    // tokenDistributorParty => distributionId => DistributionState\n    mapping(ITokenDistributorParty => mapping(uint256 => DistributionState))\n        private _distributionStates;\n\n    // msg.sender == DAO\n    modifier onlyPartyDao() {\n        {\n            address partyDao = GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\n            if (msg.sender != partyDao) {\n                revert OnlyPartyDaoError(msg.sender, partyDao);\n            }\n        }\n        _;\n    }\n\n    // emergencyActionsDisabled == false\n    modifier onlyIfEmergencyActionsAllowed() {\n        if (block.timestamp > EMERGENCY_DISABLED_TIMESTAMP) {\n            revert EmergencyActionsNotAllowedError();\n        }\n        _;\n    }\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globa"
    }
  ]
}