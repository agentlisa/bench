{
  "Title": "[H-05] It is possible to DoS all the functions related to some gauge in `GaugeController`",
  "Content": "\n<https://github.com/code-423n4/2023-08-verwa/blob/a693b4db05b9e202816346a6f9cada94f28a2698/src/GaugeController.sol#L91-L114> \n\n<https://github.com/code-423n4/2023-08-verwa/blob/a693b4db05b9e202816346a6f9cada94f28a2698/src/GaugeController.sol#L142> \n\n<https://github.com/code-423n4/2023-08-verwa/blob/a693b4db05b9e202816346a6f9cada94f28a2698/src/GaugeController.sol#L180> \n\n<https://github.com/code-423n4/2023-08-verwa/blob/a693b4db05b9e202816346a6f9cada94f28a2698/src/GaugeController.sol#L189> \n\n<https://github.com/code-423n4/2023-08-verwa/blob/a693b4db05b9e202816346a6f9cada94f28a2698/src/GaugeController.sol#L247>\n\n`_get_weight` function is used in order to return the total gauge's weight and it also updates past values of the `points_weight` mapping, if `time_weight[_gauge_addr]` is less or equal to the `block.timestamp`. It contains the following loop:\n\n```solidity\n            for (uint256 i; i < 500; ++i) {\n                if (t > block.timestamp) break;\n                t += WEEK;\n                uint256 d_bias = pt.slope * WEEK;\n                if (pt.bias > d_bias) {\n                    pt.bias -= d_bias;\n                    uint256 d_slope = changes_weight[_gauge_addr][t];\n                    pt.slope -= d_slope;\n                } else {\n                    pt.bias = 0;\n                    pt.slope = 0;\n                }\n                points_weight[_gauge_addr][t] = pt;\n                if (t > block.timestamp) time_weight[_gauge_addr] = t;\n            }\n```\n\nThere are two possible scenarios:\n\n*   `pt.bias > d_bias`\n*   `pt.bias <= d_bias`\n\nThe first scenario will always happen naturally, since `pt.bias` will be the total voting power allocated for some point and since slope is a sum of all users' slopes and slopes are calculated in such a way that `<SLOPE> * <TIME_TO_END_OF_STAKING_PERIOD> = <INITIAL_BIAS>`.\n\nHowever, it is possible to artificially change `points_weight[_gauge_addr][t].bias` by calling `change_gauge_weight` (which can be only called by the governance). It important to notice here, that `change_gauge_weight` **doesn't modify** `points_weight[_gauge_addr][t].slope`\n\n`change_gauge_weight` does permit to change the weight to a smaller number than its current value, so it's both perfectly legal and possible that governance does this at some point (it could be changing the weight to `0` or any other value smaller than the current one).\n\nThen, at some point when `_get_weight` is called, we will enter the `else` block because `pt.bias` will be less than the sum of all user's biases (since originally these values were equal, but `pt.bias` was lowered by the governance). It will set `pt.bias` and `pt.slope` to `0`.\n\nAfter some time, the governance may realise that the gauge's weight is `0`, but should be bigger and may change it to some bigger value.\n\nWe will have the situation where `points_weight[_gauge_addr][t].slope = 0` and `points_weight[_gauge_addr][t].bias > 0`.\n\nIf this happens and there is any nonzero `changes_weight[_gauge_addr]` not yet taken into account (for instance in the week after the governance update), then all the functions related to the gauge at `_gauge_addr` will not work.\n\nIt's because, the following functions:\n\n*   `checkpoint_gauge`\n*   `gauge_relative_weight_write`\n*   `gauge_relative_weight`\n*   `_change_gauge_weight`\n*   `change_gauge_weight`\n*   `vote_for_gauge_weights`\n*   `remove_gauge`\n\ncall `_get_weight` at some point.\n\nLet's see what will happen in `_get_weight` when it's called:\n\n```solidity\n                uint256 d_bias = pt.slope * WEEK;\n                if (pt.bias > d_bias) {\n                    pt.bias -= d_bias;\n                    uint256 d_slope = changes_weight[_gauge_addr][t];\n                    pt.slope -= d_slope;\n                } else {\n```\n\nWe will enter the `if` statement, because `pt.bias` will be `> 0` and `pt.slope` will be `0` (or some small value, if users give their voting power to gauge in the meantime), since it was previously set to `0` in the `else` statement and wasn't touched when gauge's weight was changed by the governance. We will:\n\n*   Subtract `d_bias` from `pt.bias` which will succeed\n*   Attempt to subtract `changes_weight[_gauge_addr][t]` from `d_slope`\n\nHowever, there could be a user (or users) whose voting power allocation finishes at `t` for some `t` not yet handled. It means that `changes_weight[_gauge_addr][t] > 0` (and if `pt.slope` is not `0`, then `changes_weight[_gauge_addr][t]` still may be greater than it).\n\nIf this happens, then the integer underflow will happen in `pt.slope -= d_slope;`. It will now happen in **every** call to `_get_weight` and it won't be possible to recover, because:\n\n*   `vote_for_gauge_weights` will revert\n*   `change_gauge_weight` will revert\n\nas they call `_get_weight` internally. So, it won't be possible to modify `pt.slope` and `pt.bias` for any point in time, so the `revert` will always happen for that gauge. It won't even be possible to remove that gauge.\n\nSo, in short, the scenario is as follows:\n\n1.  Users allocate their voting power to a gauge `X`.\n2.  Governance at some point decreases the weight of `X`.\n3.  Users withdraw their voting power as the time passes, and finally the weight of `X` drops to `0`.\n4.  Governance realises this and increases weight of `X` since it wants to incentivise users to provide liquidity in `X`.\n5.  Voting power delegation of some user(s) ends some time after that and `_get_weight` attempts to subtract `changes_weight[_gauge_addr][t]` from the current slope (which is either `0` or some small value) and it results in integer underflow.\n6.  `X` is unusable and it's impossible to withdraw voting power from (so users cannot give their voting power somewhere else). The weight of `X` cannot be changed anymore and `X` cannot be even removed.\n\n**Note that it is also possible to frontrun the call to `change_gauge_weight` when the weight is set to a lower value** - user with a lot of capital can watch the mempool and if weight is lowered to some value `x`, he can give a voting power of `x` to that gauge. Then, right after weight is changed by the governance, he can withdraw his voting power, leaving the gauge with weight = `0`. Then, governance will manually increase the weight to recover and DoS will happen as described. **So it is only needed that governance decreases gauge's weight at some point**.\n\n### Impact\n\nAs stated, above the impact is that the entire gauge is useless, voting powers are permanently locked there and its weight is impossible to change, so the impact is high.\n\nIn order for this situation to succeed, governance has to decrease weight of some gauge, but I think it's very likely, because:\n\n1.  `_get_weight` checks that `if (pt.bias > d_bias)` and it handles the opposite situation, so it is anticipated that it may genuinely happen.\n2.  It is definitely possible to decrease gauge's weight and it's even possible to zero it out (as in the `remove_gauge`).\n3.  The situation where `old_bias` is greater than `old_sum_bias + new_bias` is handled in `vote_for_gauge_weights`, but it may only happen when gauge's weight was decreased by the governance.\n4.  The situation where `old_slope.slope` is greater than `old_sum_slope + new_slope.slope` is also handled there, but it may only happen if we enter the `else` statement in `_get_weight`.\n\nSo, it is predicted that gauge's weight may be lowered and the protocol does its best to handle it properly, but as I showed, it fails to do so. Hence, I believe that this finding is of High severity, because although it requires governance to perform some action (decrease weight of some gauge), I believe that it's likely that governance decides to decrease weight, especially that it is anticipated in the code and edge cases are handled there (and they wouldn't be if we assumed that governance would never allowed them to happen).\n\n### Proof of Concept\n\nPlease run the test below. The test shows slightly simplified situation where governance just sets weight to `0` for `gauge1`, but as I've described above, it suffices that it's just changed to a smaller value and it may drop to `0` naturally as users withdraw their voting power. The following import will also have to be added: `import {Test, stdError} from \"forge-std/Test.sol\";`.\n\n<details>\n\n```solidity\nfunction testPoC1() public\n    {\n        // gauge is being set up\n        vm.startPrank(gov);\n        gc.add_gauge(gauge1);\n        gc.change_gauge_weight(gauge1, 0);\n        vm.stopPrank();\n\n        // `user1` pays some money and adds his power to `gauge1`\n        vm.startPrank(user1);\n        ve.createLock{value: 1 ether}(1 ether);\n        gc.vote_for_gauge_weights(gauge1, 10000);\n        vm.warp(block.timestamp + 10 weeks);\n        gc.checkpoint_gauge(gauge1);\n        vm.stopPrank();\n\n        // `user2` does the same\n        vm.startPrank(user2);\n        ve.createLock{value: 1 ether}(1 ether);\n        gc.vote_for_gauge_weights(gauge1, 10000);\n        vm.warp(block.timestamp + 1 weeks);\n        gc.checkpoint_gauge(gauge1);\n        vm.stopPrank();\n\n        vm.warp(block.timestamp + 1825 days - 14 weeks);\n        vm.startPrank(gov);\n        // weight is changed to `0`, just to simplify\n        // normally, weight would just be decreased here and then subsequently decreased by users when their\n        // locking period is over until it finally drops to `0`\n        // alternatively, some whale can frontrun a call to `change_gauge_weight` as described and then\n        // withdraw his voting power leaving the gauge with `0` slope and `0` bias\n        gc.change_gauge_weight(gauge1, 0);\n        vm.warp(block.timestamp + 1 weeks);\n        \n        // now, weight is changed to some bigger value\n        gc.change_gauge_weight(gauge1, 1 ether);\n        vm.stopPrank();\n        // some time passes so that user1's locking period ends\n        vm.warp(block.timestamp + 5 weeks);\n        \n        // `user2` cannot change his weight although his `locked.end` is big enough\n        vm.prank(user2);\n        vm.expectRevert(stdError.arithmeticError);\n        gc.vote_for_gauge_weights(gauge1, 0);\n\n        // governance cannot change weight\n        vm.startPrank(gov);\n        vm.expectRevert(stdError.arithmeticError);\n        gc.change_gauge_weight(gauge1, 2 ether);\n        \n        // governance cannot even remove the gauge\n        // it's now impossible to do anything on gauge1\n        vm.expectRevert(stdError.arithmeticError);\n        gc.remove_gauge(gauge1);\n        vm.stopPrank();\n    }\n```\n\n</details>\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nPerform `pt.slope -= d_slope` in `_get_weight` only when `pt.slope >= d.slope` and otherwise zero it out.\n\n**[\\_\\_141345\\_\\_ (Lookout) commented](https://github.com/code-423n4/2023-08-verwa-findings/issues/206#issuecomment-1678343307):**\n > `pt.slope -= d_slope` underflow, DoS gauge operation.\n \n**[OpenCoreCH (veRWA) confirmed](https://github.com/code-423n4/2023-08-verwa-findings/issues/206#issuecomment-1681957273)**\n\n**[alcueca (Judge) commented](https://github.com/code-423n4/2023-08-verwa-findings/issues/206#issuecomment-1693869666):**\n > This finding does a great job at describing the vulnerability and its impact from a computational point of view, including an executable PoC. Its duplicate [#386](https://github.com/code-423n4/2023-08-verwa-findings/issues/386) is also worthy of note since it explains the root cause from a mathematical point of view. Although this finding was selected as best, both findings should be read for their complementary points of view.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-08-verwa",
  "Code": [
    {
      "filename": "src/GaugeController.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport {VotingEscrow} from \"./VotingEscrow.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title  GaugeController\n/// @author Curve Finance (MIT) - original concept and implementation in Vyper\n///         mkt.market - Porting to Solidity with some modifications (this version)\n/// @notice Allows users to vote on distribution of CANTO that the contract receives from governance. Modifications from Curve:\n///         - Gauge types removed (resulting in the removal of the differentiation between tracking of total / sum)\n///         - Different whitelisting of gauge addresses because of removed types\n///         - Removal of gauges\ncontract GaugeController {\n    // Constants\n    uint256 public constant WEEK = 7 days;\n    uint256 public constant MULTIPLIER = 10**18;\n\n    // Events\n    event NewGauge(address indexed gauge_address);\n    event GaugeRemoved(address indexed gauge_address);\n\n    // State\n    VotingEscrow public votingEscrow;\n    address public governance;\n    mapping(address => bool) public isValidGauge;\n    mapping(address => mapping(address => VotedSlope)) public vote_user_slopes;\n    mapping(address => uint256) public vote_user_power;\n    mapping(address => mapping(address => uint256)) public last_user_vote;\n\n    mapping(address => mapping(uint256 => Point)) public points_weight;\n    mapping(address => mapping(uint256 => uint256)) public changes_weight;\n    mapping(address => uint256) time_weight;\n\n    mapping(uint256 => Point) points_sum;\n    mapping(uint256 => uint256) changes_sum;\n    uint256 public time_sum;\n\n    struct Point {\n        uint256 bias;\n        uint256 slope;\n    }\n\n    struct VotedSlope {\n        uint256 slope;\n        uint256 power;\n        uint256 end;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance);\n        _;\n    }\n\n    /// @notice Initializes state\n    /// @param _votingEscrow The voting escrow address\n    constructor(address _votingEscrow, address _governance) {\n        votingEscrow = VotingEscrow(_votingEscrow);\n        governance = _governance; // TODO: Maybe change to Oracle\n        uint256 last_epoch = (block.timestamp / WEEK) * WEEK;\n        time_sum = last_epoch;\n    }\n\n    /// @notice Fill historic gauge weights week-over-week for missed checkins and return the sum for the future week\n    /// @return Sum of weights\n    function _get_sum() internal returns (uint256) {\n        uint256 t = time_sum;\n        Point memory pt = points_sum[t];\n        for (uint256 i; i < 500; ++i) {\n            if (t > block.timestamp) break;\n            t += WEEK;\n            uint256 d_bias = pt.slope * WEEK;\n            if (pt.bias > d_bias) {\n                pt.bias -= d_bias;\n                uint256 d_slope = changes_sum[t];\n                pt.slope -= d_slope;\n            } else {\n                pt.bias = 0;\n                pt.slope = 0;\n            }\n            points_sum[t] = pt;\n            if (t > block.timestamp) time_sum = t;\n        }\n        return pt.bias;\n    }\n\n    /// @notice Fill historic gauge weights week-over-week for missed checkins\n    /// and return the total for the future week\n    /// @param _gauge_addr Address of the gauge\n    /// @return Gauge weight\n    function _get_weight(address _gauge_addr) private returns (uint256) {\n        uint256 t = time_weight[_gauge_addr];\n        if (t > 0) {\n            Point memory pt = points_weight[_gauge_addr][t];\n            for (uint256 i; i < 500; ++i) {\n                if (t > block.timestamp) break;\n                t += WEEK;\n                uint256 d_bias = pt.slope * WEEK;\n                if (pt.bias > d_bias) {\n                    pt.bias -= d_bias;\n                    uint256 d_slope = changes_weight[_gauge_addr][t];\n                    pt.slope -= d_slope;\n                } else {\n                    pt.bias = 0;\n                    pt.slope = 0;\n                }\n                points_weight[_gauge_addr][t] = pt;\n                if (t > block.timestamp) time_weight[_gauge_addr] = t;\n            }\n            return pt.bias;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Add a new gauge, only callable by governance\n    /// @param _gauge The gauge address\n    function add_gauge(address _gauge) external onlyGovernance {\n        require(!isValidGauge[_gauge], \"Gauge already exists\");\n        isValidGauge[_gauge] = true;\n        emit NewGauge(_gauge);\n    }\n\n    /// @notice Remove a gauge, only callable by governance\n    /// @dev Sets the gauge weight to 0\n    /// @param _gauge The gauge address\n    function remove_gauge(address _gauge) external onlyGovernance {\n        require(isValidGauge[_gauge], \"Invalid gauge address\");\n        isValidGauge[_gauge] = false;\n        _change_gauge_weight(_gauge, 0);\n        emit GaugeRemoved(_gauge);\n    }\n\n    /// @notice Checkpoint to fill data common for all gauges\n    function checkpoint() external {\n        _get_sum();\n    }\n\n    /// @notice Checkpoint to fill data for both a specific gauge and common for all gauges\n    /// @param _gauge The gauge address\n    function checkpoint_gauge(address _gauge) external {\n        _get_weight(_gauge);\n        _get_sum();\n    }\n\n    /// @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\n    ///     (e.g. 1.0 == 1e18). Inflation which will be received by it is\n    ///     inflation_rate * relative_weight / 1e18\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function _gauge_relative_weight(address _gauge, uint256 _time) private view returns (uint256) {\n        uint256 t = (_time / WEEK) * WEEK;\n        uint256 total_weight = points_sum[t].bias;\n        if (total_weight > 0) {\n            uint256 gauge_weight = points_weight[_gauge][t].bias;\n            return (MULTIPLIER * gauge_weight) / total_weight;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\n    ///     (e.g. 1.0 == 1e18). Inflation which will be received by it is\n    ///     inflation_rate * relative_weight / 1e18\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function gauge_relative_weight(address _gauge, uint256 _time) external view returns (uint256) {\n        return _gauge_relative_weight(_gauge, _time);\n    }\n\n    /// @notice Get gauge weight normalized to 1e18 and also fill all the unfilled\n    ///     values for type and gauge records\n    /// @dev Any address can call, however nothing is recorded if the values are filled already\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function gauge_relative_weight_write(address _gauge, uint256 _time) external returns (uint256) {\n        _get_weight(_gauge);\n        _get_sum();\n        return _gauge_relative_weight(_gauge, _time);\n    }\n\n    /// @notice Overwrite gauge weight\n    /// @param _gauge Gauge address\n    /// @param _weight New weight\n    function _change_gauge_weight(address _gauge, uint256 _weight) internal {\n        uint256 old_gauge_weight = _get_weight(_gauge);\n        uint256 old_sum = _get_sum();\n        uint256 next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;\n\n        points_weight[_gauge][next_time].bias = _weight;\n        time_weight[_gauge] = next_time;\n\n        uint256 new_sum = old_sum + _weight - old_gauge_weight;\n        points_sum[next_time].bias = new_sum;\n        time_sum = next_time;\n    }\n\n    /// @notice Allows governance to overwrite gauge weights\n    /// @param _gauge Gauge address\n    /// @param _weight New weight\n    function change_gauge_weight(address _gauge, uint256 _weight) public onlyGovernance {\n        _change_gauge_weight(_gauge, _weight);\n    }\n\n    /// @notice Allocate voting power for changing pool weights\n    /// @param _gauge_addr Gauge which `msg.sender` votes for\n    /// @param _user_weight Weight for a gauge in bps (units of 0.01%). Minimal is 0.01%. Ignored if 0\n    function vote_for_gauge_weights(address _gauge_addr, uint256 _user_weight) external {\n        require(_user_weight >= 0 && _user_weight <= 10_000, \"Invalid user weight\");\n        require(isValidGauge[_gauge_addr], \"Invalid gauge address\");\n        VotingEscrow ve = votingEscrow;\n        (\n            ,\n            /*int128 bias*/\n            int128 slope_, /*uint256 ts*/\n\n        ) = ve.getLastUserPoint(msg.sender);\n        require(slope_ >= 0, \"Invalid slope\");\n        uint256 slope = uint256(uint128(slope_));\n        uint256 lock_end = ve.lockEnd(msg.sender);\n        uint256 next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;\n        require(lock_end > next_time, \"Lock expires too soon\");\n        VotedSlope memory old_slope = vote_user_slopes[msg.sender][_gauge_addr];\n        uint256 old_dt = 0;\n        if (old_slope.end > next_time) old_dt = old_slope.end - next_time;\n        uint256 old_bias = old_slope.slope * old_dt;\n        VotedSlope memory new_slope = VotedSlope({\n            slope: (slope * _user_weight) / 10_000,\n            end: lock_end,\n            power: _user_weight\n        });\n        uint256 new_dt = lock_end - next_time;\n        uint256 new_bias = new_slope.slope * new_dt;\n\n        // Check and update powers (weights) used\n        uint256 power_used = vote_user_power[msg.sender];\n        power_used = power_used + new_slope.power - old_slope.power;\n        require(power_used >= 0 && power_used <= 10_000, \"Used too much power\");\n        vote_user_power[msg.sender] = power_used;\n\n        // Remove old and schedule new slope changes\n        // Remove slope changes for old slopes\n        // Schedule recording of initial slope for next_time\n        uint256 old_weight_bias = _get_weight(_gauge_addr);\n        uint256 old_weight_slope = points_weight[_gauge_addr][next_time].slope;\n        uint256 old_sum_bias = _get_sum();\n        uint256 old_sum_slope = points_sum[next_time].slope;\n\n        points_weight[_gauge_addr][next_time].bias = Math.max(old_weight_bias + new_bias, old_bias) - old_bias;\n        points_sum[next_time].bias = Math.max(old_sum_bias + new_bias, old_bias) - old_bias;\n        if (old_slope.end > next_time) {\n            points_weight[_gauge_addr][next_time].slope =\n                Math.max(old_weight_slope + new_slope.slope, old_slope.slope) -\n                old_slope.slope;\n            points_sum[next_time].slope = Math.max(old_sum_slope + new_slope.slope, old_slope.slope) - old_slope.slope;\n        } else {\n            points_weight[_gauge_addr][next_time].slope += new_slope.slope;\n            points_sum[next_time].slope += new_slope.slope;\n        }\n        if (old_slope.end > block.timestamp) {\n            // Cancel old slope changes if they still didn't happen\n            changes_weight[_gauge_addr][old_slope.end] -= old_slope.slope;\n            changes_sum[old_slope.end] -= old_slope.slope;\n        }\n        // Add slope changes for new slopes\n        changes_weight[_gauge_addr][new_slope.end] += new_slope.slope;\n        changes_sum[new_slope.end] += new_slope.slope;\n\n        _get_sum();\n\n        vote_user_slopes[msg.sender][_gauge_addr] = new_slope;\n\n        // Record last action time\n        last_user_vote[msg.sender][_gauge_addr] = block.timestamp;\n    }\n\n    /// @notice Get current gauge weight\n    /// @param _gauge Gauge address\n    /// @return Gauge weight\n    function get_gauge_weight(address _gauge) external view returns (uint256) {\n        return points_weight[_gauge][time_weight[_gauge]].bias;\n    }\n\n    /// @notice Get total weight\n    /// @return Total weight\n    function get_total_weight() external view returns (uint256) {\n        return points_sum[time_sum].bias;\n    }\n}"
    },
    {
      "filename": "src/GaugeController.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport {VotingEscrow} from \"./VotingEscrow.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title  GaugeController\n/// @author Curve Finance (MIT) - original concept and implementation in Vyper\n///         mkt.market - Porting to Solidity with some modifications (this version)\n/// @notice Allows users to vote on distribution of CANTO that the contract receives from governance. Modifications from Curve:\n///         - Gauge types removed (resulting in the removal of the differentiation between tracking of total / sum)\n///         - Different whitelisting of gauge addresses because of removed types\n///         - Removal of gauges\ncontract GaugeController {\n    // Constants\n    uint256 public constant WEEK = 7 days;\n    uint256 public constant MULTIPLIER = 10**18;\n\n    // Events\n    event NewGauge(address indexed gauge_address);\n    event GaugeRemoved(address indexed gauge_address);\n\n    // State\n    VotingEscrow public votingEscrow;\n    address public governance;\n    mapping(address => bool) public isValidGauge;\n    mapping(address => mapping(address => VotedSlope)) public vote_user_slopes;\n    mapping(address => uint256) public vote_user_power;\n    mapping(address => mapping(address => uint256)) public last_user_vote;\n\n    mapping(address => mapping(uint256 => Point)) public points_weight;\n    mapping(address => mapping(uint256 => uint256)) public changes_weight;\n    mapping(address => uint256) time_weight;\n\n    mapping(uint256 => Point) points_sum;\n    mapping(uint256 => uint256) changes_sum;\n    uint256 public time_sum;\n\n    struct Point {\n        uint256 bias;\n        uint256 slope;\n    }\n\n    struct VotedSlope {\n        uint256 slope;\n        uint256 power;\n        uint256 end;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance);\n        _;\n    }\n\n    /// @notice Initializes state\n    /// @param _votingEscrow The voting escrow address\n    constructor(address _votingEscrow, address _governance) {\n        votingEscrow = VotingEscrow(_votingEscrow);\n        governance = _governance; // TODO: Maybe change to Oracle\n        uint256 last_epoch = (block.timestamp / WEEK) * WEEK;\n        time_sum = last_epoch;\n    }\n\n    /// @notice Fill historic gauge weights week-over-week for missed checkins and return the sum for the future week\n    /// @return Sum of weights\n    function _get_sum() internal returns (uint256) {\n        uint256 t = time_sum;\n        Point memory pt = points_sum[t];\n        for (uint256 i; i < 500; ++i) {\n            if (t > block.timestamp) break;\n            t += WEEK;\n            uint256 d_bias = pt.slope * WEEK;\n            if (pt.bias > d_bias) {\n                pt.bias -= d_bias;\n                uint256 d_slope = changes_sum[t];\n                pt.slope -= d_slope;\n            } else {\n                pt.bias = 0;\n                pt.slope = 0;\n            }\n            points_sum[t] = pt;\n            if (t > block.timestamp) time_sum = t;\n        }\n        return pt.bias;\n    }\n\n    /// @notice Fill historic gauge weights week-over-week for missed checkins\n    /// and return the total for the future week\n    /// @param _gauge_addr Address of the gauge\n    /// @return Gauge weight\n    function _get_weight(address _gauge_addr) private returns (uint256) {\n        uint256 t = time_weight[_gauge_addr];\n        if (t > 0) {\n            Point memory pt = points_weight[_gauge_addr][t];\n            for (uint256 i; i < 500; ++i) {\n                if (t > block.timestamp) break;\n                t += WEEK;\n                uint256 d_bias = pt.slope * WEEK;\n                if (pt.bias > d_bias) {\n                    pt.bias -= d_bias;\n                    uint256 d_slope = changes_weight[_gauge_addr][t];\n                    pt.slope -= d_slope;\n                } else {\n                    pt.bias = 0;\n                    pt.slope = 0;\n                }\n                points_weight[_gauge_addr][t] = pt;\n                if (t > block.timestamp) time_weight[_gauge_addr] = t;\n            }\n            return pt.bias;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Add a new gauge, only callable by governance\n    /// @param _gauge The gauge address\n    function add_gauge(address _gauge) external onlyGovernance {\n        require(!isValidGauge[_gauge], \"Gauge already exists\");\n        isValidGauge[_gauge] = true;\n        emit NewGauge(_gauge);\n    }\n\n    /// @notice Remove a gauge, only callable by governance\n    /// @dev Sets the gauge weight to 0\n    /// @param _gauge The gauge address\n    function remove_gauge(address _gauge) external onlyGovernance {\n        require(isValidGauge[_gauge], \"Invalid gauge address\");\n        isValidGauge[_gauge] = false;\n        _change_gauge_weight(_gauge, 0);\n        emit GaugeRemoved(_gauge);\n    }\n\n    /// @notice Checkpoint to fill data common for all gauges\n    function checkpoint() external {\n        _get_sum();\n    }\n\n    /// @notice Checkpoint to fill data for both a specific gauge and common for all gauges\n    /// @param _gauge The gauge address\n    function checkpoint_gauge(address _gauge) external {\n        _get_weight(_gauge);\n        _get_sum();\n    }\n\n    /// @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\n    ///     (e.g. 1.0 == 1e18). Inflation which will be received by it is\n    ///     inflation_rate * relative_weight / 1e18\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function _gauge_relative_weight(address _gauge, uint256 _time) private view returns (uint256) {\n        uint256 t = (_time / WEEK) * WEEK;\n        uint256 total_weight = points_sum[t].bias;\n        if (total_weight > 0) {\n            uint256 gauge_weight = points_weight[_gauge][t].bias;\n            return (MULTIPLIER * gauge_weight) / total_weight;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\n    ///     (e.g. 1.0 == 1e18). Inflation which will be received by it is\n    ///     inflation_rate * relative_weight / 1e18\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function gauge_relative_weight(address _gauge, uint256 _time) external view returns (uint256) {\n        return _gauge_relative_weight(_gauge, _time);\n    }\n\n    /// @notice Get gauge weight normalized to 1e18 and also fill all the unfilled\n    ///     values for type and gauge records\n    /// @dev Any address can call, however nothing is recorded if the values are filled already\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function gauge_relative_weight_write(address _gauge, uint256 _time) external returns (uint256) {\n        _get_weight(_gauge);\n        _get_sum();\n        return _gauge_relative_weight(_gauge, _time);\n    }\n\n    /// @notice Overwrite gauge weight\n    /// @param _gauge Gauge address\n    /// @param _weight New weight\n    function _change_gauge_weight(address _gauge, uint256 _weight) internal {\n        uint256 old_gauge_weight = _get_weight(_gauge);\n        uint256 old_sum = _get_sum();\n        uint256 next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;\n\n        points_weight[_gauge][next_time].bias = _weight;\n        time_weight[_gauge] = next_time;\n\n        uint256 new_sum = old_sum + _weight - old_gauge_weight;\n        points_sum[next_time].bias = new_sum;\n        time_sum = next_time;\n    }\n\n    /// @notice Allows governance to overwrite gauge weights\n    /// @param _gauge Gauge address\n    /// @param _weight New weight\n    function change_gauge_weight(address _gauge, uint256 _weight) public onlyGovernance {\n        _change_gauge_weight(_gauge, _weight);\n    }\n\n    /// @notice Allocate voting power for changing pool weights\n    /// @param _gauge_addr Gauge which `msg.sender` votes for\n    /// @param _user_weight Weight for a gauge in bps (units of 0.01%). Minimal is 0.01%. Ignored if 0\n    function vote_for_gauge_weights(address _gauge_addr, uint256 _user_weight) external {\n        require(_user_weight >= 0 && _user_weight <= 10_000, \"Invalid user weight\");\n        require(isValidGauge[_gauge_addr], \"Invalid gauge address\");\n        VotingEscrow ve = votingEscrow;\n        (\n            ,\n            /*int128 bias*/\n            int128 slope_, /*uint256 ts*/\n\n        ) = ve.getLastUserPoint(msg.sender);\n        require(slope_ >= 0, \"Invalid slope\");\n        uint256 slope = uint256(uint128(slope_));\n        uint256 lock_end = ve.lockEnd(msg.sender);\n        uint256 next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;\n        require(lock_end > next_time, \"Lock expires too soon\");\n        VotedSlope memory old_slope = vote_user_slopes[msg.sender][_gauge_addr];\n        uint256 old_dt = 0;\n        if (old_slope.end > next_time) old_dt = old_slope.end - next_time;\n        uint256 old_bias = old_slope.slope * old_dt;\n        VotedSlope memory new_slope = VotedSlope({\n            slope: (slope * _user_weight) / 10_000,\n            end: lock_end,\n            power: _user_weight\n        });\n        uint256 new_dt = lock_end - next_time;\n        uint256 new_bias = new_slope.slope * new_dt;\n\n        // Check and update powers (weights) used\n        uint256 power_used = vote_user_power[msg.sender];\n        power_used = power_used + new_slope.power - old_slope.power;\n        require(power_used >= 0 && power_used <= 10_000, \"Used too much power\");\n        vote_user_power[msg.sender] = power_used;\n\n        // Remove old and schedule new slope changes\n        // Remove slope changes for old slopes\n        // Schedule recording of initial slope for next_time\n        uint256 old_weight_bias = _get_weight(_gauge_addr);\n        uint256 old_weight_slope = points_weight[_gauge_addr][next_time].slope;\n        uint256 old_sum_bias = _get_sum();\n        uint256 old_sum_slope = points_sum[next_time].slope;\n\n        points_weight[_gauge_addr][next_time].bias = Math.max(old_weight_bias + new_bias, old_bias) - old_bias;\n        points_sum[next_time].bias = Math.max(old_sum_bias + new_bias, old_bias) - old_bias;\n        if (old_slope.end > next_time) {\n            points_weight[_gauge_addr][next_time].slope =\n                Math.max(old_weight_slope + new_slope.slope, old_slope.slope) -\n                old_slope.slope;\n            points_sum[next_time].slope = Math.max(old_sum_slope + new_slope.slope, old_slope.slope) - old_slope.slope;\n        } else {\n            points_weight[_gauge_addr][next_time].slope += new_slope.slope;\n            points_sum[next_time].slope += new_slope.slope;\n        }\n        if (old_slope.end > block.timestamp) {\n            // Cancel old slope changes if they still didn't happen\n            changes_weight[_gauge_addr][old_slope.end] -= old_slope.slope;\n            changes_sum[old_slope.end] -= old_slope.slope;\n        }\n        // Add slope changes for new slopes\n        changes_weight[_gauge_addr][new_slope.end] += new_slope.slope;\n        changes_sum[new_slope.end] += new_slope.slope;\n\n        _get_sum();\n\n        vote_user_slopes[msg.sender][_gauge_addr] = new_slope;\n\n        // Record last action time\n        last_user_vote[msg.sender][_gauge_addr] = block.timestamp;\n    }\n\n    /// @notice Get current gauge weight\n    /// @param _gauge Gauge address\n    /// @return Gauge weight\n    function get_gauge_weight(address _gauge) external view returns (uint256) {\n        return points_weight[_gauge][time_weight[_gauge]].bias;\n    }\n\n    /// @notice Get total weight\n    /// @return Total weight\n    function get_total_weight() external view returns (uint256) {\n        return points_sum[time_sum].bias;\n    }\n}"
    },
    {
      "filename": "src/GaugeController.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport {VotingEscrow} from \"./VotingEscrow.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title  GaugeController\n/// @author Curve Finance (MIT) - original concept and implementation in Vyper\n///         mkt.market - Porting to Solidity with some modifications (this version)\n/// @notice Allows users to vote on distribution of CANTO that the contract receives from governance. Modifications from Curve:\n///         - Gauge types removed (resulting in the removal of the differentiation between tracking of total / sum)\n///         - Different whitelisting of gauge addresses because of removed types\n///         - Removal of gauges\ncontract GaugeController {\n    // Constants\n    uint256 public constant WEEK = 7 days;\n    uint256 public constant MULTIPLIER = 10**18;\n\n    // Events\n    event NewGauge(address indexed gauge_address);\n    event GaugeRemoved(address indexed gauge_address);\n\n    // State\n    VotingEscrow public votingEscrow;\n    address public governance;\n    mapping(address => bool) public isValidGauge;\n    mapping(address => mapping(address => VotedSlope)) public vote_user_slopes;\n    mapping(address => uint256) public vote_user_power;\n    mapping(address => mapping(address => uint256)) public last_user_vote;\n\n    mapping(address => mapping(uint256 => Point)) public points_weight;\n    mapping(address => mapping(uint256 => uint256)) public changes_weight;\n    mapping(address => uint256) time_weight;\n\n    mapping(uint256 => Point) points_sum;\n    mapping(uint256 => uint256) changes_sum;\n    uint256 public time_sum;\n\n    struct Point {\n        uint256 bias;\n        uint256 slope;\n    }\n\n    struct VotedSlope {\n        uint256 slope;\n        uint256 power;\n        uint256 end;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance);\n        _;\n    }\n\n    /// @notice Initializes state\n    /// @param _votingEscrow The voting escrow address\n    constructor(address _votingEscrow, address _governance) {\n        votingEscrow = VotingEscrow(_votingEscrow);\n        governance = _governance; // TODO: Maybe change to Oracle\n        uint256 last_epoch = (block.timestamp / WEEK) * WEEK;\n        time_sum = last_epoch;\n    }\n\n    /// @notice Fill historic gauge weights week-over-week for missed checkins and return the sum for the future week\n    /// @return Sum of weights\n    function _get_sum() internal returns (uint256) {\n        uint256 t = time_sum;\n        Point memory pt = points_sum[t];\n        for (uint256 i; i < 500; ++i) {\n            if (t > block.timestamp) break;\n            t += WEEK;\n            uint256 d_bias = pt.slope * WEEK;\n            if (pt.bias > d_bias) {\n                pt.bias -= d_bias;\n                uint256 d_slope = changes_sum[t];\n                pt.slope -= d_slope;\n            } else {\n                pt.bias = 0;\n                pt.slope = 0;\n            }\n            points_sum[t] = pt;\n            if (t > block.timestamp) time_sum = t;\n        }\n        return pt.bias;\n    }\n\n    /// @notice Fill historic gauge weights week-over-week for missed checkins\n    /// and return the total for the future week\n    /// @param _gauge_addr Address of the gauge\n    /// @return Gauge weight\n    function _get_weight(address _gauge_addr) private returns (uint256) {\n        uint256 t = time_weight[_gauge_addr];\n        if (t > 0) {\n            Point memory pt = points_weight[_gauge_addr][t];\n            for (uint256 i; i < 500; ++i) {\n                if (t > block.timestamp) break;\n                t += WEEK;\n                uint256 d_bias = pt.slope * WEEK;\n                if (pt.bias > d_bias) {\n                    pt.bias -= d_bias;\n                    uint256 d_slope = changes_weight[_gauge_addr][t];\n                    pt.slope -= d_slope;\n                } else {\n                    pt.bias = 0;\n                    pt.slope = 0;\n                }\n                points_weight[_gauge_addr][t] = pt;\n                if (t > block.timestamp) time_weight[_gauge_addr] = t;\n            }\n            return pt.bias;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Add a new gauge, only callable by governance\n    /// @param _gauge The gauge address\n    function add_gauge(address _gauge) external onlyGovernance {\n        require(!isValidGauge[_gauge], \"Gauge already exists\");\n        isValidGauge[_gauge] = true;\n        emit NewGauge(_gauge);\n    }\n\n    /// @notice Remove a gauge, only callable by governance\n    /// @dev Sets the gauge weight to 0\n    /// @param _gauge The gauge address\n    function remove_gauge(address _gauge) external onlyGovernance {\n        require(isValidGauge[_gauge], \"Invalid gauge address\");\n        isValidGauge[_gauge] = false;\n        _change_gauge_weight(_gauge, 0);\n        emit GaugeRemoved(_gauge);\n    }\n\n    /// @notice Checkpoint to fill data common for all gauges\n    function checkpoint() external {\n        _get_sum();\n    }\n\n    /// @notice Checkpoint to fill data for both a specific gauge and common for all gauges\n    /// @param _gauge The gauge address\n    function checkpoint_gauge(address _gauge) external {\n        _get_weight(_gauge);\n        _get_sum();\n    }\n\n    /// @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\n    ///     (e.g. 1.0 == 1e18). Inflation which will be received by it is\n    ///     inflation_rate * relative_weight / 1e18\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function _gauge_relative_weight(address _gauge, uint256 _time) private view returns (uint256) {\n        uint256 t = (_time / WEEK) * WEEK;\n        uint256 total_weight = points_sum[t].bias;\n        if (total_weight > 0) {\n            uint256 gauge_weight = points_weight[_gauge][t].bias;\n            return (MULTIPLIER * gauge_weight) / total_weight;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\n    ///     (e.g. 1.0 == 1e18). Inflation which will be received by it is\n    ///     inflation_rate * relative_weight / 1e18\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function gauge_relative_weight(address _gauge, uint256 _time) external view returns (uint256) {\n        return _gauge_relative_weight(_gauge, _time);\n    }\n\n    /// @notice Get gauge weight normalized to 1e18 and also fill all the unfilled\n    ///     values for type and gauge records\n    /// @dev Any address can call, however nothing is recorded if the values are filled already\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function gauge_relative_weight_write(address _gauge, uint256 _time) external returns (uint256) {\n        _get_weight(_gauge);\n        _get_sum();\n        return _gauge_relative_weight(_gauge, _time);\n    }\n\n    /// @notice Overwrite gauge weight\n    /// @param _gauge Gauge address\n    /// @param _weight New weight\n    function _change_gauge_weight(address _gauge, uint256 _weight) internal {\n        uint256 old_gauge_weight = _get_weight(_gauge);\n        uint256 old_sum = _get_sum();\n        uint256 next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;\n\n        points_weight[_gauge][next_time].bias = _weight;\n        time_weight[_gauge] = next_time;\n\n        uint256 new_sum = old_sum + _weight - old_gauge_weight;\n        points_sum[next_time].bias = new_sum;\n        time_sum = next_time;\n    }\n\n    /// @notice Allows governance to overwrite gauge weights\n    /// @param _gauge Gauge address\n    /// @param _weight New weight\n    function change_gauge_weight(address _gauge, uint256 _weight) public onlyGovernance {\n        _change_gauge_weight(_gauge, _weight);\n    }\n\n    /// @notice Allocate voting power for changing pool weights\n    /// @param _gauge_addr Gauge which `msg.sender` votes for\n    /// @param _user_weight Weight for a gauge in bps (units of 0.01%). Minimal is 0.01%. Ignored if 0\n    function vote_for_gauge_weights(address _gauge_addr, uint256 _user_weight) external {\n        require(_user_weight >= 0 && _user_weight <= 10_000, \"Invalid user weight\");\n        require(isValidGauge[_gauge_addr], \"Invalid gauge address\");\n        VotingEscrow ve = votingEscrow;\n        (\n            ,\n            /*int1"
    }
  ]
}