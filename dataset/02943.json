{
  "Title": "Unable to unstake after finalization",
  "Content": "Reporters on the winning camp can [unstake their tokens](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/governance/resolution/Unstakable.sol#L42-L46) even after the incident has been [finalized](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/governance/resolution/Resolvable.sol#L130-L131), albeit with no reward. However, the [resolution deadline](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/governance/resolution/Resolvable.sol#L142) is not specific to a particular incident and is [reset to 0](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/governance/resolution/Finalization.sol#L92) during finalization. Since the [deadline is checked](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/ValidationLibV1.sol#L400) during unstaking, the operation will fail. This means that some successful NPM stakers will be unable to retrieve their funds.\n\n\nIn this scenario, a recovery agent could still [retrieve](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/Recoverable.sol#L49) the funds from the `Resolution` contract and distribute them as desired.\n\n\nConsider recording the resolution deadline with the incident date so it does not need to be cleared during finalization.\n\n\n**Update:** *Fixed as of commit `6cb6b6064eca18cccee8114cbcefd2455c286ce9` in [pull request #132](https://github.com/neptune-mutual-blue/protocol/pull/132) and commit `4b929c274100a981107e35d40fbf5b57fabc9be4` in [pull request #196](https://github.com/neptune-mutual-blue/protocol/pull/196).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/core/governance/resolution/Unstakable.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"./Resolvable.sol\";\nimport \"../../../interfaces/IResolution.sol\";\nimport \"../../../interfaces/IUnstakable.sol\";\nimport \"../../../libraries/GovernanceUtilV1.sol\";\nimport \"../../../libraries/ValidationLibV1.sol\";\nimport \"../../../libraries/NTransferUtilV2.sol\";\n\n/**\n * @title Unstakable Contract\n * @dev Enables voters to unstake their NPM tokens after\n * resolution is achieved on any cover product.\n */\nabstract contract Unstakable is Resolvable, IUnstakable {\n  using GovernanceUtilV1 for IStore;\n  using ProtoUtilV1 for IStore;\n  using CoverUtilV1 for IStore;\n  using StoreKeyUtil for IStore;\n  using ValidationLibV1 for IStore;\n  using RoutineInvokerLibV1 for IStore;\n  using ValidationLibV1 for bytes32;\n  using NTransferUtilV2 for IERC20;\n\n  /**\n   * @dev Reporters on the valid camp can unstake their tokens even after the claim period is over.\n   * Unlike `unstakeWithClaim`, stakers can unstake but do not receive any reward if they choose to\n   * use this function.\n   *\n   * @custom:warning Warning:\n   *\n   * You should instead use `unstakeWithClaim` throughout the claim period.\n   *\n   * @custom:suppress-acl This is a publicly accessible feature\n   * @custom:suppress-pausable\n   *\n   * @param coverKey Enter the cover key\n   * @param productKey Enter the product key\n   * @param incidentDate Enter the incident date\n   */\n  function unstake(\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 incidentDate\n  ) external override nonReentrant {\n    require(incidentDate > 0, \"Please specify incident date\");\n\n    // Incident date is reset (when cover is finalized) and\n    // therefore shouldn't be validated otherwise \"valid\" reporters\n    // will never be able to unstake\n\n    // s.mustBeValidIncidentDate(coverKey, productKey, incidentDate);\n    s.validateUnstakeWithoutClaim(coverKey, productKey, incidentDate);\n\n    (, , uint256 myStakeInWinningCamp) = s.getResolutionInfoForInternal(msg.sender, coverKey, productKey, incidentDate);\n\n    // Set the unstake details\n    s.updateUnstakeDetailsInternal(msg.sender, coverKey, productKey, incidentDate, myStakeInWinningCamp, 0, 0, 0);\n\n    s.npmToken().ensureTransfer(msg.sender, myStakeInWinningCamp);\n    s.updateStateAndLiquidity(coverKey);\n\n    emit Unstaken(coverKey, productKey, msg.sender, myStakeInWinningCamp, 0);\n  }\n\n  /**\n   * @dev Reporters on the valid camp can unstake their token with a `claim` to receive\n   * back their original stake with a portion of the invalid camp's stake\n   * as an additional reward.\n   *\n   * During each `unstake with claim` processing, the protocol distributes reward to\n   * the final reporter and also burns some NPM tokens, as described in the documentation.\n   *\n   * @custom:suppress-acl This is a publicly accessible feature\n   * @custom:suppress-pausable Already checked inside `validateUnstakeWithClaim`\n   *\n   *\n   * @param coverKey Enter the cover key\n   * @param productKey Enter the product key\n   * @param incidentDate Enter the incident date\n   */\n  function unstakeWithClaim(\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 incidentDate\n  ) external override nonReentrant {\n    require(incidentDate > 0, \"Please specify incident date\");\n    s.validateUnstakeWithClaim(coverKey, productKey, incidentDate);\n\n    address finalReporter = s.getReporterInternal(coverKey, productKey, incidentDate);\n    address burner = s.getBurnAddress();\n\n    (, , uint256 myStakeInWinningCamp, uint256 toBurn, uint256 toReporter, uint256 myReward, ) = s.getUnstakeInfoForInternal(msg.sender, coverKey, productKey, incidentDate);\n\n    // Set the unstake details\n    s.updateUnstakeDetailsInternal(msg.sender, coverKey, productKey, incidentDate, myStakeInWinningCamp, myReward, toBurn, toReporter);\n\n    uint256 myStakeWithReward = myReward + myStakeInWinningCamp;\n\n    s.npmToken().ensureTransfer(msg.sender, myStakeWithReward);\n\n    if (toReporter > 0) {\n      s.npmToken().ensureTransfer(finalReporter, toReporter);\n    }\n\n    if (toBurn > 0) {\n      s.npmToken().ensureTransfer(burner, toBurn);\n    }\n\n    s.updateStateAndLiquidity(coverKey);\n\n    emit Unstaken(coverKey, productKey, msg.sender, myStakeInWinningCamp, myReward);\n    emit ReporterRewardDistributed(coverKey, productKey, msg.sender, finalReporter, myReward, toReporter);\n    emit GovernanceBurned(coverKey, productKey, msg.sender, burner, myReward, toBurn);\n  }\n\n  /**\n   * @dev Gets the unstake information for the supplied account\n   *\n   * Warning: this function does not validate the input arguments.\n   *\n   * @param account Enter account to get the unstake information of\n   * @param coverKey Enter the cover key\n   * @param incidentDate Enter the incident date\n   * @param totalStakeInWinningCamp Returns the sum total of the stakes contributed by the winning camp\n   * @param totalStakeInLosingCamp Returns the sum total of the stakes contributed by the losing camp\n   * @param myStakeInWinningCamp Returns the sum total of the supplied account's stakes in the winning camp\n   * @param toBurn Returns the amount of tokens that will be booked as protocol revenue and immediately burned\n   * @param toReporter Returns the amount of tokens that will be sent to the final reporter as the `first reporter` reward\n   * @param myReward Returns the amount of tokens that the supplied account will receive as `reporting reward`\n   */\n  function getUnstakeInfoFor(\n    address account,\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 incidentDate\n  )\n    external\n    view\n    override\n    returns (\n      uint256 totalStakeInWinningCamp,\n      uint256 totalStakeInLosingCamp,\n      uint256 myStakeInWinningCamp,\n      uint256 toBurn,\n      uint256 toReporter,\n      uint256 myReward,\n      uint256 unstaken\n    )\n  {\n    return s.getUnstakeInfoForInternal(account, coverKey, productKey, incidentDate);\n  }\n}"
    },
    {
      "filename": "contracts/core/Recoverable.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"openzeppelin-solidity/contracts/security/ReentrancyGuard.sol\";\nimport \"../interfaces/IRecoverable.sol\";\nimport \"../libraries/BaseLibV1.sol\";\nimport \"../libraries/ValidationLibV1.sol\";\n\n/**\n *\n * @title Recoverable Contract\n * @dev The recoverable contract enables \"Recovery Agents\" to recover\n * Ether and ERC-20 tokens sent to this address.\n *\n * To learn more about our recovery policy, please refer to the following doc:\n * https://docs.neptunemutual.com/usage/recovering-cryptocurrencies\n *\n */\nabstract contract Recoverable is ReentrancyGuard, IRecoverable {\n  using ValidationLibV1 for IStore;\n  IStore public override s;\n\n  constructor(IStore store) {\n    require(address(store) != address(0), \"Invalid Store\");\n    s = store;\n  }\n\n  /**\n   * @dev Recover all Ether held by the contract.\n   * On success, no event is emitted because the recovery feature does\n   * not have any significance in the SDK or the UI.\n   */\n  function recoverEther(address sendTo) external override nonReentrant {\n    s.mustNotBePaused();\n    AccessControlLibV1.mustBeRecoveryAgent(s);\n    BaseLibV1.recoverEtherInternal(sendTo);\n  }\n\n  /**\n   * @dev Recover all ERC-20 compatible tokens sent to this address.\n   * On success, no event is emitted because the recovery feature does\n   * not have any significance in the SDK or the UI.\n   *\n   * @custom:suppress-malicious-erc The malicious ERC-20 `token` should only be invoked via `NTransferUtil`.\n   * @custom:suppress-address-trust-issue Although the token can't be trusted, the recovery agent has to check the token code manually.\n   *\n   * @param token ERC-20 The address of the token contract\n   */\n  function recoverToken(address token, address sendTo) external override nonReentrant {\n    s.mustNotBePaused();\n    AccessControlLibV1.mustBeRecoveryAgent(s);\n    BaseLibV1.recoverTokenInternal(token, sendTo);\n  }\n}"
    }
  ]
}