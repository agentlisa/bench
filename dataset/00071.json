{
  "Title": "Arbitrary unitOfAccount Asset Could Cause Liquidations or Erroneous Value Conversions",
  "Content": "The `Liquidation` contract implements the functionality to calculate and liquidate debt positions a user might have. To do so, each vault proxy defines at deployment the [`unitOfAccount` asset](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/shared/Cache.sol#L47) to be used as the reference. This allows converting two different assets (of [supply](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/modules/Liquidation.sol#L137) and [borrow](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/modules/Liquidation.sol#L149)) against a third asset to get the value of such positions.\n\n\nHowever, the selection of this third asset is arbitrary and meant to be done by the Vault's admin when creating the new vault which, depending on the selection, might have a real impact on the liquidity or the liability of the positions. In particular:\n\n\n* Assets that might have a popular adoption in the market could get hacked, lose their peg (in the case of stablecoins), or face unexpected behavior that could end up resulting in strong price changes. If these changes ever come closer to zero, the precision could affect the calculations of the protocol, which would translate into wrong conversions between assets and shares, an imprecise health score on accounts, and a higher risk of positions' liquidations (even if in reality those are properly backed with collateral in real value terms).\n* The asset used might act as a wrapper for another asset or be a token that has malicious unknown behavior. In such a case, if this asset is used to carry out an underlying attack, or if its intrinsic value drops on purpose to leverage the price pair (e.g., the LP token of a protocol is used, but its behavior can drain the pool, changing its price) then the Vaults attached to that asset will again be subject to the value calculation effect.\n\n\nSince the `unitOfAccount` asset is not meant to be replaced after the Vault's creation, there is no mitigation for affected vaults to allow positions to migrate unaffected once the `unitOfAccount` asset starts showing the price fluctuations. Moreover, contracts such as the `BaseProductLine` and the `Core` contracts do not perform any checks on the parameters then parsed to the `GenericFactory` contract.\n\n\nConsider only allowing the usage of trusted and backed-by-industry tokens as the reference token and allowing the protocol to freeze operations and change it if a vault suffers from its effects.\n\n\n***Update:** Acknowledged, not resolved. The Euler team stated:*\n\n\n\n> *We acknowledge the issue. We agree that the choice of the `unitOfAccount` asset is a crucial security decision, but we think it is a part of the risk management framework and not something that should be enforced in the code. We also agree with the recommendation to only allow trusted tokens as reference assets, but think this filtering should happen at a different level than the vault code, which is un-opinionated and is built on purpose to accept a wide range of configurations. As for making the unit of account configurable, we expect only the most stable assets to pass through the aforementioned filters, in which case the gas costs of reading the configuration from storage, in every operation involving debt, would not be justified.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/EVault/shared/Cache.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {Storage} from \"./Storage.sol\";\nimport {Errors} from \"./Errors.sol\";\nimport {RPow} from \"./lib/RPow.sol\";\nimport {SafeERC20Lib} from \"./lib/SafeERC20Lib.sol\";\nimport {ProxyUtils} from \"./lib/ProxyUtils.sol\";\n\nimport \"./types/Types.sol\";\n\n/// @title Cache\n/// @author Euler Labs (https://www.eulerlabs.com/)\n/// @notice Utilities for loading vault storage and updating it with interest accrued\ncontract Cache is Storage, Errors {\n    using TypesLib for uint256;\n    using SafeERC20Lib for IERC20;\n\n    // Returns an updated VaultCache\n    // If different from VaultStorage, updates VaultStorage\n    function updateVault() internal virtual returns (VaultCache memory vaultCache) {\n        if (initVaultCache(vaultCache)) {\n            vaultStorage.lastInterestAccumulatorUpdate = vaultCache.lastInterestAccumulatorUpdate;\n            vaultStorage.accumulatedFees = vaultCache.accumulatedFees;\n\n            vaultStorage.totalShares = vaultCache.totalShares;\n            vaultStorage.totalBorrows = vaultCache.totalBorrows;\n\n            vaultStorage.interestAccumulator = vaultCache.interestAccumulator;\n        }\n    }\n\n    // Returns an updated VaultCache\n    function loadVault() internal view virtual returns (VaultCache memory vaultCache) {\n        initVaultCache(vaultCache);\n    }\n\n    // Takes a VaultCache struct, overwrites it with VaultStorage data and, if time has passed since MarkeStorage\n    // was last updated, updates MarkeStorage.\n    // Returns a boolean if the cache is different from storage. VaultCache param is updated to this block.\n    function initVaultCache(VaultCache memory vaultCache) private view returns (bool dirty) {\n        dirty = false;\n\n        // Proxy metadata\n\n        (vaultCache.asset, vaultCache.oracle, vaultCache.unitOfAccount) = ProxyUtils.metadata();\n\n        // Storage loads\n\n        vaultCache.lastInterestAccumulatorUpdate = vaultStorage.lastInterestAccumulatorUpdate;\n        vaultCache.cash = vaultStorage.cash;\n        vaultCache.supplyCap = vaultStorage.supplyCap.resolve();\n        vaultCache.borrowCap = vaultStorage.borrowCap.resolve();\n        vaultCache.hookedOps = vaultStorage.hookedOps;\n        vaultCache.snapshotInitialized = vaultStorage.snapshotInitialized;\n\n        vaultCache.totalShares = vaultStorage.totalShares;\n        vaultCache.totalBorrows = vaultStorage.totalBorrows;\n\n        vaultCache.accumulatedFees = vaultStorage.accumulatedFees;\n        vaultCache.configFlags = vaultStorage.configFlags;\n\n        vaultCache.interestAccumulator = vaultStorage.interestAccumulator;\n\n        // Update interest accumulator and fees balance\n\n        uint256 deltaT = block.timestamp - vaultCache.lastInterestAccumulatorUpdate;\n        if (deltaT > 0) {\n            dirty = true;\n\n            // Compute new cache values. Use full precision for intermediate results.\n\n            ConfigAmount interestFee = vaultStorage.interestFee;\n            uint256 interestRate = vaultStorage.interestRate;\n\n            uint256 newInterestAccumulator = vaultCache.interestAccumulator;\n\n            unchecked {\n                (uint256 multiplier, bool overflow) = RPow.rpow(interestRate + 1e27, deltaT, 1e27);\n\n                // if exponentiation or accumulator update overflows, keep the old accumulator\n                if (!overflow) {\n                    uint256 intermediate = newInterestAccumulator * multiplier;\n                    if (newInterestAccumulator == intermediate / multiplier) {\n                        newInterestAccumulator = intermediate / 1e27;\n                    }\n                }\n            }\n\n            uint256 newTotalBorrows =\n                vaultCache.totalBorrows.toUint() * newInterestAccumulator / vaultCache.interestAccumulator;\n            uint256 newAccumulatedFees = vaultCache.accumulatedFees.toUint();\n            uint256 newTotalShares = vaultCache.totalShares.toUint();\n            uint256 feeAssets = (newTotalBorrows - vaultCache.totalBorrows.toUint()) * interestFee.toUint16()\n                / (1e4 << INTERNAL_DEBT_PRECISION_SHIFT);\n\n            if (feeAssets != 0) {\n                uint256 newTotalAssets = vaultCache.cash.toUint() + (newTotalBorrows >> INTERNAL_DEBT_PRECISION_SHIFT);\n                newTotalShares = newTotalAssets * newTotalShares / (newTotalAssets - feeAssets);\n                newAccumulatedFees += newTotalShares - vaultCache.totalShares.toUint();\n            }\n\n            // Store new values in vaultCache, only if no overflows will occur. Fees are not larger than total shares, since they are included in them.\n\n            if (newTotalShares <= MAX_SANE_AMOUNT && newTotalBorrows <= MAX_SANE_DEBT_AMOUNT) {\n                vaultCache.totalBorrows = newTotalBorrows.toOwed();\n                vaultCache.interestAccumulator = newInterestAccumulator;\n                vaultCache.lastInterestAccumulatorUpdate = uint48(block.timestamp);\n\n                if (newTotalShares != Shares.unwrap(vaultCache.totalShares)) {\n                    vaultCache.accumulatedFees = newAccumulatedFees.toShares();\n                    vaultCache.totalShares = newTotalShares.toShares();\n                }\n            }\n        }\n    }\n\n    function totalAssetsInternal(VaultCache memory vaultCache) internal pure virtual returns (uint256) {\n        // total assets can exceed Assets max amount (MAX_SANE_AMOUNT)\n        return vaultCache.cash.toUint() + vaultCache.totalBorrows.toAssetsUp().toUint();\n    }\n}"
    }
  ]
}