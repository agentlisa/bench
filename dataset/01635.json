{
  "Title": "M-24: Liquidators can prevent users from making their positions healthy during an unpause",
  "Content": "# Issue M-24: Liquidators can prevent users from making their positions healthy during an unpause \n\nSource: https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/336 \n\n## Found by \nAkshaySrivastav, Kose\n## Summary\nThe Symmetrical protocol has various paused states in which different operations are paused. The protocol operations can be unpaused by privileged accounts. But when this unpause happens the liquidators can frontrun and liquidate user positions before those users get a chance to make their positions healthy.\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/control/ControlFacet.sol#L242-L295\n\n## Vulnerability Detail\n\nThe privileged addresses can pause the symmetrical protocol fully/partially using the pausability functions in ControlFacet. Once the protocol is paused all these operations cannot be done by users:\n\n- deposit\n- withdraw\n- allocate\n- deallocate\n- sendQuote\n- lockQuote\n- openPositions\n- liquidations\n- etc\n\nThough, real prices from oracles will surely move up or down during this paused period. If the oracle prices go down, the users won't be allowed to allocate more collateral to their positions or close their positions. Hence their positions will get under-collateralized (based upon real prices).\n\nOnce the protocol is unpaused the liquidators can front-run most users and liquidate their positions. Most users will not get a chance to make their position healthy.\n\nThis results in loss of funds for the users.\n\nRef: https://github.com/sherlock-audit/2023-03-notional-judging/issues/203\n\n## Impact\nBy front-running any collateral allocation or position closure of a legitimate user which became under-collateralized during the paused state, the liquidator can unfairly liquidate user positions and collect liquidation profit as soon as the protocol is unpaused. This causes loss of funds to the user.\n\nAlso, on unpause, it is unlikely that any human users will be able to secure their positions before MEV/liquidation bots capture the available profit. Hence the loss is certain.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/control/ControlFacet.sol#L242-L295\n\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider adding a grace period after unpausing during which liquidation remains blocked to allow users to avoid unfair liquidation by closing their positions or allocating additional collateral.\nThe protocol team can also think of any other way which mitigates the unfair liquidations of users.\n\n\n\n## Discussion\n\n**MoonKnightDev**\n\nThese pauses are designed for emergency scenarios. When we do initiate a pause, we should formulate specific policies before it's unpaused. As per your example, one strategy could be to temporarily pause liquidations, providing users with an opportunity to distance themselves from a potential liquidation event. This is just one example; any policy can be considered. Therefore, we don't view this as a bug, rather it is an integral part of our system.\n\n**akshaysrivastav**\n\nEscalate for 10 USDC\n\nI think this issue should be considered as valid. As per the sponsor comment above it is evident that the current protocol implementation does not contain any safeguard mechanism against this issue and an additional code change (temporary policies) will be needed to prevent users from the loss of funds due to the issue. \n\nThe report clearly shows how a protocol owner action (pause) will result in unfair liquidations causing loss of funds to users. \n\nFor reference, similar issues were considered valid in the recent [Notional V3](https://github.com/sherlock-audit/2023-03-notional-judging/issues/203) and [Blueberry](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/290) contests and was accepted by Sherlock. Maintaining a consistent valid/invalid classification standard will be ideal here.\n\n**sherlock-admin2**\n\n > Escalate for 10 USDC\n> \n> I think this issue should be considered as valid. As per the sponsor comment above it is evident that the current protocol implementation does not contain any safeguard mechanism against this issue and an additional code change (temporary policies) will be needed to prevent users from the loss of funds due to the issue. \n> \n> The report clearly shows how a protocol owner action (pause) will result in unfair liquidations causing loss of funds to users. \n> \n> For reference, similar issues were considered valid in the recent [Notional V3](https://github.com/sherlock-audit/2023-03-notional-judging/issues/203) and [Blueberry](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/290) contests and was accepted by Sherlock. Maintaining a consistent valid/invalid classification standard will be ideal here.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\n> These pauses are designed for emergency scenarios. When we do initiate a pause, we should formulate specific policies before it's unpaused. As per your example, one strategy could be to temporarily pause liquidations, providing users with an opportunity to distance themselves from a potential liquidation event. This is just one example; any policy can be considered. Therefore, we don't view this as a bug, rather it is an integral part of our system.\n\nI have to side with sponsor on this one\n\nthere is no way to prevent frontrunning pause or unpause even adding grace period..\n\nIn fact, there are a lot of similar finding in recent contest about unpause / pause,\n\nthey just end up \"won't fix\"\n\nhttps://github.com/sherlock-audit/2023-03-notional-judging/issues/203\n\nThe blueberry issue talks about repay is paused when liquidation is active, which is not the same as frontrunning pause or unpause\n\n**akshaysrivastav**\n\nHey @ctf-sec I totally respect your decision but just want to state my points in a much clearer way as there seems to be a misunderstanding.\n\n- The issue is not about frontrunning the admin's pause/unpause txn,\n- The issue is about, when admin pauses the operations the users are prevented from changing their positions, these positions can become unheathy during paused state, and as soon as admin unpauses the protocol, mev actors can liquidate the users before those users get a chance to save their positions. In short, a protocol owner action (pause) will result in unfair liquidations for users causing loss of funds.\n- As the sponsors already [confirmed](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/336#issuecomment-1640329084) that they will need to introduce temporary policies to mitigate this issue. This confirms two things:\n    - The bug is real, loss of funds is real, and new code changes will be needed for mitigation.\n    - Since sponsors will be forced to implement new policies, this issue will not technically end up in the \"won't fix\" category.\n- Agree on blueberry, actual similar issues to this one are [NotionalV3:203](https://github.com/sherlock-audit/2023-03-notional-judging/issues/203) and [Perennial:190](https://github.com/sherlock-audit/2023-05-perennial-judging/issues/190), both were considered as valid by Sherlock.\n\n**ctf-sec**\n\nHi Akshay,\n\nI think you are trying to refer to this issue?\n\nhttps://github.com/sherlock-audit/2023-04-blueberry-judging/issues/117\n\nlooks like exact the same issue,\n\nI think a valid medium is ok\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nConsidering this a valid medium based on historical decisions and the issue is still valid from smart contract POV.\n\nAlso, however, given that this clearly can be design decision for some protocols, agree that there should be a better rule around these protocol-pausing situations. \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [akshaysrivastav](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/336/#issuecomment-1653923071): accepted\n\n**hrishibhat**\n\nAdditionally, #281 can be a valid duplicate of this issue\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/85",
  "Code": [
    {
      "filename": "symmio-core/contracts/facets/control/ControlFacet.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../utils/Ownable.sol\";\nimport \"../../utils/Accessibility.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/GlobalAppStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\nimport \"./IControlEvents.sol\";\n\ncontract ControlFacet is Accessibility, Ownable, IControlEvents {\n    // Just For Testnet\n    function init(address user, address collateral, address feeCollector) external onlyOwner {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        GlobalAppStorage.Layout storage appLayout = GlobalAppStorage.layout();\n\n        appLayout.collateral = collateral;\n        appLayout.balanceLimitPerUser = 500e18;\n        appLayout.feeCollector = feeCollector;\n        maLayout.deallocateCooldown = 300;\n        maLayout.forceCancelCooldown = 3000000000000000;\n        maLayout.forceCloseCooldown = 3000000000000000;\n        maLayout.forceCancelCloseCooldown = 3000000000000000;\n        maLayout.pendingQuotesValidLength = 15;\n        maLayout.liquidatorShare = 80e16;\n        maLayout.liquidationTimeout = 600;\n        appLayout.hasRole[user][LibAccessibility.DEFAULT_ADMIN_ROLE] = true;\n        appLayout.hasRole[user][LibAccessibility.SYMBOL_MANAGER_ROLE] = true;\n        appLayout.hasRole[user][LibAccessibility.MUON_SETTER_ROLE] = true;\n        appLayout.hasRole[user][LibAccessibility.SETTER_ROLE] = true;\n        appLayout.hasRole[user][LibAccessibility.PARTY_B_MANAGER_ROLE] = true;\n    }\n\n    function setAdmin(address user) external onlyOwner {\n        GlobalAppStorage.layout().hasRole[user][LibAccessibility.DEFAULT_ADMIN_ROLE] = true;\n        emit RoleGranted(LibAccessibility.DEFAULT_ADMIN_ROLE, user);\n    }\n\n    function grantRole(\n        address user,\n        bytes32 role\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        GlobalAppStorage.layout().hasRole[user][role] = true;\n        emit RoleGranted(role, user);\n    }\n\n    function revokeRole(\n        address user,\n        bytes32 role\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        GlobalAppStorage.layout().hasRole[user][role] = false;\n        emit RoleRevoked(role, user);\n    }\n\n    function registerPartyB(\n        address partyB\n    ) external onlyRole(LibAccessibility.PARTY_B_MANAGER_ROLE) {\n        require(\n            !MAStorage.layout().partyBStatus[partyB],\n            \"ControlFacet: Address is already registered\"\n        );\n        MAStorage.layout().partyBStatus[partyB] = true;\n        MAStorage.layout().partyBList.push(partyB);\n        emit RegisterPartyB(partyB);\n    }\n\n    function setMuonConfig(\n        uint256 upnlValidTime,\n        uint256 priceValidTime,\n        uint256 priceQuantityValidTime\n    ) external onlyRole(LibAccessibility.MUON_SETTER_ROLE) {\n        emit SetMuonConfig(upnlValidTime, priceValidTime, priceQuantityValidTime);\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n        muonLayout.upnlValidTime = upnlValidTime;\n        muonLayout.priceValidTime = priceValidTime;\n        muonLayout.priceQuantityValidTime = priceQuantityValidTime;\n    }\n\n    function setMuonIds(\n        uint256 muonAppId,\n        address validGateway,\n        PublicKey memory publicKey\n    ) external onlyRole(LibAccessibility.MUON_SETTER_ROLE) {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n        muonLayout.muonAppId = muonAppId;\n        muonLayout.validGateway = validGateway;\n        muonLayout.muonPublicKey = publicKey;\n        emit SetMuonIds(muonAppId, validGateway, publicKey.x, publicKey.parity);\n    }\n\n    function setCollateral(\n        address collateral\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        GlobalAppStorage.layout().collateral = collateral;\n        emit SetCollateral(collateral);\n    }\n\n    // Symbol State\n\n    function addSymbol(\n        string memory name,\n        uint256 minAcceptableQuoteValue,\n        uint256 minAcceptablePortionLF,\n        uint256 tradingFee\n    ) public onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\n        uint256 lastId = ++SymbolStorage.layout().lastId;\n        Symbol memory symbol = Symbol(\n            lastId,\n            name,\n            true,\n            minAcceptableQuoteValue,\n            minAcceptablePortionLF,\n            tradingFee\n        );\n        SymbolStorage.layout().symbols[lastId] = symbol;\n        emit AddSymbol(lastId, name, minAcceptableQuoteValue, minAcceptablePortionLF, tradingFee);\n    }\n\n    function addSymbols(\n        Symbol[] memory symbols\n    ) external onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\n        for (uint8 i; i < symbols.length; i++) {\n            addSymbol(\n                symbols[i].name,\n                symbols[i].minAcceptableQuoteValue,\n                symbols[i].minAcceptablePortionLF,\n                symbols[i].tradingFee\n            );\n        }\n    }\n\n    function setSymbolValidationState(\n        uint256 symbolId,\n        bool isValid\n    ) external onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n        require(symbolId >= 1 && symbolId <= symbolLayout.lastId, \"ControlFacet: Invalid id\");\n        emit SetSymbolValidationState(symbolId, symbolLayout.symbols[symbolId].isValid, isValid);\n        symbolLayout.symbols[symbolId].isValid = isValid;\n    }\n\n    function setSymbolAcceptableValues(\n        uint256 symbolId,\n        uint256 minAcceptableQuoteValue,\n        uint256 minAcceptablePortionLF\n    ) external onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n        require(symbolId >= 1 && symbolId <= symbolLayout.lastId, \"ControlFacet: Invalid id\");\n        emit SetSymbolAcceptableValues(\n            symbolId,\n            symbolLayout.symbols[symbolId].minAcceptableQuoteValue,\n            symbolLayout.symbols[symbolId].minAcceptablePortionLF,\n            minAcceptableQuoteValue,\n            minAcceptablePortionLF\n        );\n        symbolLayout.symbols[symbolId].minAcceptableQuoteValue = minAcceptableQuoteValue;\n        symbolLayout.symbols[symbolId].minAcceptablePortionLF = minAcceptablePortionLF;\n    }\n\n    function setSymbolTradingFee(\n        uint256 symbolId,\n        uint256 tradingFee\n    ) external onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n        require(symbolId >= 1 && symbolId <= symbolLayout.lastId, \"ControlFacet: Invalid id\");\n        emit SetSymbolTradingFee(symbolId, symbolLayout.symbols[symbolId].tradingFee, tradingFee);\n        symbolLayout.symbols[symbolId].tradingFee = tradingFee;\n    }\n\n    /////////////////////////////////////\n\n    // CoolDowns\n\n    function setDeallocateCooldown(\n        uint256 deallocateCooldown\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetDeallocateCooldown(MAStorage.layout().deallocateCooldown, deallocateCooldown);\n        MAStorage.layout().deallocateCooldown = deallocateCooldown;\n    }\n\n    function setForceCancelCooldown(\n        uint256 forceCancelCooldown\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetForceCancelCooldown(MAStorage.layout().forceCancelCooldown, forceCancelCooldown);\n        MAStorage.layout().forceCancelCooldown = forceCancelCooldown;\n    }\n\n    function setForceCloseCooldown(\n        uint256 forceCloseCooldown\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetForceCloseCooldown(MAStorage.layout().forceCloseCooldown, forceCloseCooldown);\n        MAStorage.layout().forceCloseCooldown = forceCloseCooldown;\n    }\n\n    function setForceCancelCloseCooldown(\n        uint256 forceCancelCloseCooldown\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetForceCancelCloseCooldown(\n            MAStorage.layout().forceCancelCloseCooldown,\n            forceCancelCloseCooldown\n        );\n        MAStorage.layout().forceCancelCloseCooldown = forceCancelCloseCooldown;\n    }\n\n    function setLiquidatorShare(\n        uint256 liquidatorShare\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetLiquidatorShare(MAStorage.layout().liquidatorShare, liquidatorShare);\n        MAStorage.layout().liquidatorShare = liquidatorShare;\n    }\n\n    function setForceCloseGapRatio(\n        uint256 forceCloseGapRatio\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetForceCloseGapRatio(MAStorage.layout().forceCloseGapRatio, forceCloseGapRatio);\n        MAStorage.layout().forceCloseGapRatio = forceCloseGapRatio;\n    }\n\n    function setPendingQuotesValidLength(\n        uint256 pendingQuotesValidLength\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetPendingQuotesValidLength(\n            MAStorage.layout().pendingQuotesValidLength,\n            pendingQuotesValidLength\n        );\n        MAStorage.layout().pendingQuotesValidLength = pendingQuotesValidLength;\n    }\n\n    // Pause State\n\n    function setFeeCollector(\n        address feeCollector\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        emit SetFeeCollector(GlobalAppStorage.layout().feeCollector, feeCollector);\n        GlobalAppStorage.layout().feeCollector = feeCollector;\n    }\n\n    function pauseGlobal() external onlyRole(LibAccessibility.PAUSER_ROLE) {\n        GlobalAppStorage.layout().globalPaused = true;\n        emit PauseGlobal();\n    }\n\n    function pauseLiquidation() external onlyRole(LibAccessibility.PAUSER_ROLE) {\n        GlobalAppStorage.layout().liquidationPaused = true;\n        emit PauseLiquidation();\n    }\n\n    function pauseAccounting() external onlyRole(LibAccessibility.PAUSER_ROLE) {\n        GlobalAppStorage.layout().accountingPaused = true;\n        emit PauseAccounting();\n    }\n\n    function pausePartyAActions() external onlyRole(LibAccessibility.PAUSER_ROLE) {\n        GlobalAppStorage.layout().partyAActionsPaused = true;\n        emit PausePartyAActions();\n    }\n\n    function pausePartyBActions() external onlyRole(LibAccessibility.PAUSER_ROLE) {\n        GlobalAppStorage.layout().partyBActionsPaused = true;\n        emit PausePartyBActions();\n    }\n\n    function activeEmergencyMode() external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        GlobalAppStorage.layout().emergencyMode = true;\n        emit ActiveEmergencyMode();\n    }\n\n    function unpauseGlobal() external onlyRole(LibAccessibility.UNPAUSER_ROLE) {\n        GlobalAppStorage.layout().globalPaused = false;\n        emit UnpauseGlobal();\n    }\n\n    function unpauseLiquidation() external onlyRole(LibAccessibility.UNPAUSER_ROLE) {\n        GlobalAppStorage.layout().liquidationPaused = false;\n        emit UnpauseLiquidation();\n    }\n\n    function unpauseAccounting() external onlyRole(LibAccessibility.UNPAUSER_ROLE) {\n        GlobalAppStorage.layout().accountingPaused = false;\n        emit UnpauseAccounting();\n    }\n\n    function unpausePartyAActions() external onlyRole(LibAccessibility.UNPAUSER_ROLE) {\n        GlobalAppStorage.layout().partyAActionsPaused = false;\n        emit UnpausePartyAActions();\n    }\n\n    function unpausePartyBActions() external onlyRole(LibAccessibility.UNPAUSER_ROLE) {\n        GlobalAppStorage.layout().partyBActionsPaused = false;\n        emit UnpausePartyBActions();\n    }\n\n    function setLiquidationTimeout(\n        uint256 liquidationTimeout\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetLiquidationTimeout(MAStorage.layout().liquidationTimeout, liquidationTimeout);\n        MAStorage.layout().liquidationTimeout = liquidationTimeout;\n    }\n\n    function setSuspendedAddress(\n        address user,\n        bool isSuspended\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetSuspendedAddress(user, isSuspended);\n        AccountStorage.layout().suspendedAddresses[user] = isSuspended;\n    }\n\n    function deactiveEmergencyMode() external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        GlobalAppStorage.layout().emergencyMode = false;\n        emit DeactiveEmergencyMode();\n    }\n\n    function setBalanceLimitPerUser(\n        uint256 balanceLimitPerUser\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        emit SetBalanceLimitPerUser(balanceLimitPerUser);\n        GlobalAppStorage.layout().balanceLimitPerUser = balanceLimitPerUser;\n    }\n\n    function setPartyBEmergencyStatus(\n        address[] memory partyBs,\n        bool status\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        for (uint8 i; i < partyBs.length; i++) {\n            GlobalAppStorage.layout().partyBEmergencyStatus[partyBs[i]] = status;\n            emit SetPartyBEmergencyStatus(partyBs[i], status);\n        }\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/facets/control/ControlFacet.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../utils/Ownable.sol\";\nimport \"../../utils/Accessibility.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/GlobalAppStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\nimport \"./IControlEvents.sol\";\n\ncontract ControlFacet is Accessibility, Ownable, IControlEvents {\n    // Just For Testnet\n    function init(address user, address collateral, address feeCollector) external onlyOwner {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        GlobalAppStorage.Layout storage appLayout = GlobalAppStorage.layout();\n\n        appLayout.collateral = collateral;\n        appLayout.balanceLimitPerUser = 500e18;\n        appLayout.feeCollector = feeCollector;\n        maLayout.deallocateCooldown = 300;\n        maLayout.forceCancelCooldown = 3000000000000000;\n        maLayout.forceCloseCooldown = 3000000000000000;\n        maLayout.forceCancelCloseCooldown = 3000000000000000;\n        maLayout.pendingQuotesValidLength = 15;\n        maLayout.liquidatorShare = 80e16;\n        maLayout.liquidationTimeout = 600;\n        appLayout.hasRole[user][LibAccessibility.DEFAULT_ADMIN_ROLE] = true;\n        appLayout.hasRole[user][LibAccessibility.SYMBOL_MANAGER_ROLE] = true;\n        appLayout.hasRole[user][LibAccessibility.MUON_SETTER_ROLE] = true;\n        appLayout.hasRole[user][LibAccessibility.SETTER_ROLE] = true;\n        appLayout.hasRole[user][LibAccessibility.PARTY_B_MANAGER_ROLE] = true;\n    }\n\n    function setAdmin(address user) external onlyOwner {\n        GlobalAppStorage.layout().hasRole[user][LibAccessibility.DEFAULT_ADMIN_ROLE] = true;\n        emit RoleGranted(LibAccessibility.DEFAULT_ADMIN_ROLE, user);\n    }\n\n    function grantRole(\n        address user,\n        bytes32 role\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        GlobalAppStorage.layout().hasRole[user][role] = true;\n        emit RoleGranted(role, user);\n    }\n\n    function revokeRole(\n        address user,\n        bytes32 role\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        GlobalAppStorage.layout().hasRole[user][role] = false;\n        emit RoleRevoked(role, user);\n    }\n\n    function registerPartyB(\n        address partyB\n    ) external onlyRole(LibAccessibility.PARTY_B_MANAGER_ROLE) {\n        require(\n            !MAStorage.layout().partyBStatus[partyB],\n            \"ControlFacet: Address is already registered\"\n        );\n        MAStorage.layout().partyBStatus[partyB] = true;\n        MAStorage.layout().partyBList.push(partyB);\n        emit RegisterPartyB(partyB);\n    }\n\n    function setMuonConfig(\n        uint256 upnlValidTime,\n        uint256 priceValidTime,\n        uint256 priceQuantityValidTime\n    ) external onlyRole(LibAccessibility.MUON_SETTER_ROLE) {\n        emit SetMuonConfig(upnlValidTime, priceValidTime, priceQuantityValidTime);\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n        muonLayout.upnlValidTime = upnlValidTime;\n        muonLayout.priceValidTime = priceValidTime;\n        muonLayout.priceQuantityValidTime = priceQuantityValidTime;\n    }\n\n    function setMuonIds(\n        uint256 muonAppId,\n        address validGateway,\n        PublicKey memory publicKey\n    ) external onlyRole(LibAccessibility.MUON_SETTER_ROLE) {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n        muonLayout.muonAppId = muonAppId;\n        muonLayout.validGateway = validGateway;\n        muonLayout.muonPublicKey = publicKey;\n        emit SetMuonIds(muonAppId, validGateway, publicKey.x, publicKey.parity);\n    }\n\n    function setCollateral(\n        address collateral\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        GlobalAppStorage.layout().collateral = collateral;\n        emit SetCollateral(collateral);\n    }\n\n    // Symbol State\n\n    function addSymbol(\n        string memory name,\n        uint256 minAcceptableQuoteValue,\n        uint256 minAcceptablePortionLF,\n        uint256 tradingFee\n    ) public onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\n        uint256 lastId = ++SymbolStorage.layout().lastId;\n        Symbol memory symbol = Symbol(\n            lastId,\n            name,\n            true,\n            minAcceptableQuoteValue,\n            minAcceptablePortionLF,\n            tradingFee\n        );\n        SymbolStorage.layout().symbols[lastId] = symbol;\n        emit AddSymbol(lastId, name, minAcceptableQuoteValue, minAcceptablePortionLF, tradingFee);\n    }\n\n    function addSymbols(\n        Symbol[] memory symbols\n    ) external onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\n        for (uint8 i; i < symbols.length; i++) {\n            addSymbol(\n                symbols[i].name,\n                symbols[i].minAcceptableQuoteValue,\n                symbols[i].minAcceptablePortionLF,\n                symbols[i].tradingFee\n            );\n        }\n    }\n\n    function setSymbolValidationState(\n        uint256 symbolId,\n        bool isValid\n    ) external onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n        require(symbolId >= 1 && symbolId <= symbolLayout.lastId, \"ControlFacet: Invalid id\");\n        emit SetSymbolValidationState(symbolId, symbolLayout.symbols[symbolId].isValid, isValid);\n        symbolLayout.symbols[symbolId].isValid = isValid;\n    }\n\n    function setSymbolAcceptableValues(\n        uint256 symbolId,\n        uint256 minAcceptableQuoteValue,\n        uint256 minAcceptablePortionLF\n    ) external onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n        require(symbolId >= 1 && symbolId <= symbolLayout.lastId, \"ControlFacet: Invalid id\");\n        emit SetSymbolAcceptableValues(\n            symbolId,\n            symbolLayout.symbols[symbolId].minAcceptableQuoteValue,\n            symbolLayout.symbols[symbolId].minAcceptablePortionLF,\n            minAcceptableQuoteValue,\n            minAcceptablePortionLF\n        );\n        symbolLayout.symbols[symbolId].minAcceptableQuoteValue = minAcceptableQuoteValue;\n        symbolLayout.symbols[symbolId].minAcceptablePortionLF = minAcceptablePortionLF;\n    }\n\n    function setSymbolTradingFee(\n        uint256 symbolId,\n        uint256 tradingFee\n    ) external onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n        require(symbolId >= 1 && symbolId <= symbolLayout.lastId, \"ControlFacet: Invalid id\");\n        emit SetSymbolTradingFee(symbolId, symbolLayout.symbols[symbolId].tradingFee, tradingFee);\n        symbolLayout.symbols[symbolId].tradingFee = tradingFee;\n    }\n\n    /////////////////////////////////////\n\n    // CoolDowns\n\n    function setDeallocateCooldown(\n        uint256 deallocateCooldown\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetDeallocateCooldown(MAStorage.layout().deallocateCooldown, deallocateCooldown);\n        MAStorage.layout().deallocateCooldown = deallocateCooldown;\n    }\n\n    function setForceCancelCooldown(\n        uint256 forceCancelCooldown\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetForceCancelCooldown(MAStorage.layout().forceCancelCooldown, forceCancelCooldown);\n        MAStorage.layout().forceCancelCooldown = forceCancelCooldown;\n    }\n\n    function setForceCloseCooldown(\n        uint256 forceCloseCooldown\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetForceCloseCooldown(MAStorage.layout().forceCloseCooldown, forceCloseCooldown);\n        MAStorage.layout().forceCloseCooldown = forceCloseCooldown;\n    }\n\n    function setForceCancelCloseCooldown(\n        uint256 forceCancelCloseCooldown\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetForceCancelCloseCooldown(\n            MAStorage.layout().forceCancelCloseCooldown,\n            forceCancelCloseCooldown\n        );\n        MAStorage.layout().forceCancelCloseCooldown = forceCancelCloseCooldown;\n    }\n\n    function setLiquidatorShare(\n        uint256 liquidatorShare\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetLiquidatorShare(MAStorage.layout().liquidatorShare, liquidatorShare);\n        MAStorage.layout().liquidatorShare = liquidatorShare;\n    }\n\n    function setForceCloseGapRatio(\n        uint256 forceCloseGapRatio\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetForceCloseGapRatio(MAStorage.layout().forceCloseGapRatio, forceCloseGapRatio);\n        MAStorage.layout().forceCloseGapRatio = forceCloseGapRatio;\n    }\n\n    function setPendingQuotesValidLength(\n        uint256 pendingQuotesValidLength\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetPendingQuotesValidLength(\n            MAStorage.layout().pendingQuotesValidLength,\n            pendingQuotesValidLength\n        );\n        MAStorage.layout().pendingQuotesValidLength = pendingQuotesValidLength;\n    }\n\n    // Pause State\n\n    function setFeeCollector(\n        address feeCollector\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        emit SetFeeCollector(GlobalAppStorage.layout().feeCollector, feeCollector);\n        GlobalAppStorage.layout().feeCollector = feeCollector;\n    }\n\n    function pauseGlobal() external onlyRole(LibAccessibility.PAUSER_ROLE) {\n        GlobalAppStorage.layout().globalPaused = true;\n        emit PauseGlobal();\n    }\n\n    function pauseLiquidation() external onlyRole(LibAccessibility.PAUSER_ROLE) {\n        GlobalAppStorage.layout().liquidationPaused = true;\n        emit PauseLiquidation();\n    }\n\n    function pauseAccounting() external onlyRole(LibAccessibility.PAUSER_ROLE) {\n        GlobalAppStorage.layout().accountingPaused = true;\n        emit PauseAccounting();\n    }\n\n    function pausePartyAActions() external onlyRole(LibAccessibility.PAUSER_ROLE) {\n        GlobalAppStorage.layout().partyAActionsPaused = true;\n        emit PausePartyAActions();\n    }\n\n    function pausePartyBActions() external onlyRole(LibAccessibility.PAUSER_ROLE) {\n        GlobalAppStorage.layout().partyBActionsPaused = true;\n        emit PausePartyBActions();\n    }\n\n    function activeEmergencyMode() external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        GlobalAppStorage.layout().emergencyMode = true;\n        emit ActiveEmergencyMode();\n    }\n\n    function unpauseGlobal() external onlyRole(LibAccessibility.UNPAUSER_ROLE) {\n        GlobalAppStorage.layout().globalPaused = false;\n        emit UnpauseGlobal();\n    }\n\n    function unpauseLiquidation() external onlyRole(LibAccessibility.UNPAUSER_ROLE) {\n        GlobalAppStorage.layout().liquidationPaused = false;\n        emit UnpauseLiquidation();\n    }\n\n    function unpauseAccounting() external onlyRole(LibAccessibility.UNPAUSER_ROLE) {\n        GlobalAppStorage.layout().accountingPaused = false;\n        emit UnpauseAccounting();\n    }\n\n    function unpausePartyAActions() external onlyRole(LibAccessibility.UNPAUSER_ROLE) {\n        GlobalAppStorage.layout().partyAActionsPaused = false;\n        emit UnpausePartyAActions();\n    }\n\n    function unpausePartyBActions() external onlyRole(LibAccessibility.UNPAUSER_ROLE) {\n        GlobalAppStorage.layout().partyBActionsPaused = false;\n        emit UnpausePartyBActions();\n    }\n\n    function setLiquidationTimeout(\n        uint256 liquidationTimeout\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetLiquidationTimeout(MAStorage.layout().liquidationTimeout, liquidationTimeout);\n        MAStorage.layout().liquidationTimeout = liquidationTimeout;\n    }\n\n    function setSuspendedAddress(\n        address user,\n        bool isSuspended\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetSuspendedAddress(user, isSuspended);\n        AccountStorage.layout().suspendedAddresses[user] = isSuspended;\n    }\n\n    function deactiveEmergencyMode() external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        GlobalAppStorage.layout().emergencyMode = false;\n        emit DeactiveEmergencyMode();\n    }\n\n    function setBalanceLimitPerUser(\n        uint256 balanceLimitPerUser\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        emit SetBalanceLimitPerUser(balanceLimitPerUser);\n        GlobalAppStorage.layout().balanceLimitPerUser = balanceLimitPerUser;\n    }\n\n    function setPartyBEmergencyStatus(\n        address[] memory partyBs,\n        bool status\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        for (uint8 i; i < partyBs.length; i++) {\n            GlobalAppStorage.layout().partyBEmergencyStatus[partyBs[i]] = status;\n            emit SetPartyBEmergencyStatus(partyBs[i], status);\n        }\n    }\n}"
    }
  ]
}