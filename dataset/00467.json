{
  "Title": "H-2: Setting the strategy cap to \"0\" does not update the total shares held or the withdrawal queue",
  "Content": "# Issue H-2: Setting the strategy cap to \"0\" does not update the total shares held or the withdrawal queue \n\nSource: https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/10 \n\n## Found by \nAymen0909, KupiaSec, g, hash, kennedy1030, mstpr-brainbot\n## Summary\nRemoving or setting the strategy cap to 0 will not decrease the shares held in the system. Additionally, it will not update the withdrawal queue, which means users can request withdrawals, and the withdrawals will exceed the allocated amount when rebalance occurs.\n## Vulnerability Detail\nLet's go over the issue with an example:\n\nAssume there is 1 strategy and 2 operators active in an LSR with total strategy shares holding is 1000 * 1e18 where both operators shares 500-500 the assets. \n\nWhen the owner decides to inactivate or just simply sets one of the operators cap to \"0\" the operator will withdraw all its assets as follows:\n```solidity\nfunction setOperatorStrategyCap(\n        RioLRTOperatorRegistryStorageV1.StorageV1 storage s,\n        uint8 operatorId,\n        IRioLRTOperatorRegistry.StrategyShareCap memory newShareCap\n    ) internal {\n        . \n        // @review this \"if\" will be executed\n        -> if (currentShareDetails.cap > 0 && newShareCap.cap == 0) {\n            // If the operator has allocations, queue them for exit.\n            if (currentShareDetails.allocation > 0) {\n                -> operatorDetails.queueOperatorStrategyExit(operatorId, newShareCap.strategy);\n            }\n            // Remove the operator from the utilization heap.\n            utilizationHeap.removeByID(operatorId);\n        } else if (currentShareDetails.cap == 0 && newShareCap.cap > 0) {\n            // If the current cap is 0 and the new cap is greater than 0, insert the operator into the heap.\n            utilizationHeap.insert(OperatorUtilizationHeap.Operator(operatorId, 0));\n        } else {\n            // Otherwise, update the operator's utilization in the heap.\n            utilizationHeap.updateUtilizationByID(operatorId, currentShareDetails.allocation.divWad(newShareCap.cap));\n        }\n        .\n    }\n```\n```solidity\nfunction queueOperatorStrategyExit(IRioLRTOperatorRegistry.OperatorDetails storage operator, uint8 operatorId, address strategy) internal {\n        .\n        // @review asks delegator to exit\n        -> bytes32 withdrawalRoot = delegator.queueWithdrawalForOperatorExit(strategy, sharesToExit);\n        emit IRioLRTOperatorRegistry.OperatorStrategyExitQueued(operatorId, strategy, sharesToExit, withdrawalRoot);\n    }\n```\n\nThen the operator delegator contract calls the EigenLayer to withdraw all its balance as follows:\n```solidity\nfunction _queueWithdrawalForOperatorExitOrScrape(address strategy, uint256 shares) internal returns (bytes32 root) {\n       . // @review jumps to internal function\n        -> root = _queueWithdrawal(strategy, shares, address(depositPool()));\n    }\n\nfunction _queueWithdrawal(address strategy, uint256 shares, address withdrawer) internal returns (bytes32 root) {\n        IDelegationManager.QueuedWithdrawalParams[] memory withdrawalParams = new IDelegationManager.QueuedWithdrawalParams[](1);\n        withdrawalParams[0] = IDelegationManager.QueuedWithdrawalParams({\n            strategies: strategy.toArray(),\n            shares: shares.toArray(),\n            withdrawer: withdrawer\n        });\n        // @review calls Eigen layer to queue all the balance and returns the root\n        -> root = delegationManager.queueWithdrawals(withdrawalParams)[0];\n    }\n```\n\nWhich we can observe from the above snippet the EigenLayer is called for the withdrawal and then the entire function execution ends. The problem is `assetRegistry` still thinks there are 1000 * 1e18 EigenLayer shares in the operators. Also, the `withdrawalQueue` is not aware of this withdrawal request which means that users can call `requestWithdrawal` to withdraw up to 1000 * 1e18 EigenLayer shares worth LRT but in reality the 500 * 1e18 portion of it already queued in withdrawal by the owner of operator registry.\n\n**Coded PoC:**\n```solidity\nfunction test_SettingStrategyCapZero_WithdrawalsAreDoubleCountable() public {\n        IRioLRTOperatorRegistry.StrategyShareCap[] memory zeroStrategyShareCaps =\n            new IRioLRTOperatorRegistry.StrategyShareCap[](2);\n        zeroStrategyShareCaps[0] = IRioLRTOperatorRegistry.StrategyShareCap({strategy: RETH_STRATEGY, cap: 0});\n        zeroStrategyShareCaps[1] = IRioLRTOperatorRegistry.StrategyShareCap({strategy: CBETH_STRATEGY, cap: 0});\n\n        uint8 operatorId = addOperatorDelegator(reLST.operatorRegistry, address(reLST.rewardDistributor));\n\n        uint256 AMOUNT = 111e18;\n\n        // Allocate to cbETH strategy.\n        cbETH.approve(address(reLST.coordinator), type(uint256).max);\n        uint256 lrtAmount = reLST.coordinator.deposit(CBETH_ADDRESS, AMOUNT);\n\n        // Push funds into EigenLayer.\n        vm.prank(EOA, EOA);\n        reLST.coordinator.rebalance(CBETH_ADDRESS);\n\n        vm.recordLogs();\n        reLST.operatorRegistry.setOperatorStrategyShareCaps(operatorId, zeroStrategyShareCaps);\n\n        Vm.Log[] memory entries = vm.getRecordedLogs();\n        assertGt(entries.length, 0);\n\n        for (uint256 i = 0; i < entries.length; i++) {\n            if (entries[i].topics[0] == keccak256('OperatorStrategyExitQueued(uint8,address,uint256,bytes32)')) {\n                uint8 emittedOperatorId = abi.decode(abi.encodePacked(entries[i].topics[1]), (uint8));\n                (address strategy, uint256 sharesToExit, bytes32 withdrawalRoot) =\n                    abi.decode(entries[i].data, (address, uint256, bytes32));\n\n                assertEq(emittedOperatorId, operatorId);\n                assertEq(strategy, CBETH_STRATEGY);\n                assertEq(sharesToExit, AMOUNT);\n                assertNotEq(withdrawalRoot, bytes32(0));\n\n                break;\n            }\n            if (i == entries.length - 1) fail('Event not found');\n        }\n\n        // @review add these\n        // @review all the eigen layer shares are already queued as we checked above, now user requestWithdrawal\n        // of the same amount of EigenLayer share worth of LRT which there will be double counting when epoch is settled.\n        uint256 queuedShares = reLST.coordinator.requestWithdrawal(address(cbETH), lrtAmount);\n        console.log(\"Queued shares\", queuedShares);\n    }\n```\n## Impact\nHigh, because the users withdrawals will never go through in rebalancing because of double counting of the same share withdrawals.\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/utils/OperatorRegistryV1Admin.sol#L231-L270\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/utils/OperatorRegistryV1Admin.sol#L144-L165\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTOperatorDelegator.sol#L225-L227\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTOperatorDelegator.sol#L253-L258\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTOperatorDelegator.sol#L265-L273\n## Tool used\n\nManual Review\n\n## Recommendation\nUpdate the withdrawal queue when the operator registry admin changes the EigenLayer shares amount by either removing an operator or setting its strategy cap to \"0\".\n\n\n\n## Discussion\n\n**solimander**\n\nLargely sounds like a duplicate of https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/361.\n\n**solimander**\n\nWhile the duplicates linked in this issue all look valid, but are related to the failure to zero out the strategy allocation after setting the strategy cap to 0.\n\n**solimander**\n\nThis PR fixes the linked duplicates: https://github.com/rio-org/rio-sherlock-audit/pull/14\n\n**solimander**\n\n@nevillehuang This issue seems to be a duplicate of https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/361, while all linked duplicates point to a slightly different issue where allocation is not zeroed out when force exiting an operator.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/176",
  "Code": [
    {
      "filename": "rio-sherlock-audit/contracts/utils/OperatorRegistryV1Admin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {LibMap} from '@solady/utils/LibMap.sol';\nimport {CREATE3} from '@solady/utils/CREATE3.sol';\nimport {FixedPointMathLib} from '@solady/utils/FixedPointMathLib.sol';\nimport {BeaconProxy} from '@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol';\nimport {RioLRTOperatorRegistryStorageV1} from 'contracts/restaking/storage/RioLRTOperatorRegistryStorageV1.sol';\nimport {IRioLRTOperatorDelegator} from 'contracts/interfaces/IRioLRTOperatorDelegator.sol';\nimport {IRioLRTOperatorRegistry} from 'contracts/interfaces/IRioLRTOperatorRegistry.sol';\nimport {OperatorUtilizationHeap} from 'contracts/utils/OperatorUtilizationHeap.sol';\nimport {IRioLRTAssetRegistry} from 'contracts/interfaces/IRioLRTAssetRegistry.sol';\nimport {BEACON_CHAIN_STRATEGY} from 'contracts/utils/Constants.sol';\nimport {Array} from 'contracts/utils/Array.sol';\nimport {Asset} from 'contracts/utils/Asset.sol';\n\n/// @title Administrative functions for the operator registry.\nlibrary OperatorRegistryV1Admin {\n    using OperatorRegistryV1Admin for RioLRTOperatorRegistryStorageV1.StorageV1;\n    using OperatorRegistryV1Admin for IRioLRTOperatorRegistry.OperatorDetails;\n    using OperatorUtilizationHeap for OperatorUtilizationHeap.Data;\n    using FixedPointMathLib for *;\n    using LibMap for *;\n    using Array for *;\n    using Asset for *;\n\n    /// @notice The maximum number of operators allowed in the registry.\n    uint8 public constant MAX_OPERATOR_COUNT = 254;\n\n    /// @notice The maximum number of active operators allowed.\n    uint8 public constant MAX_ACTIVE_OPERATOR_COUNT = 64;\n\n    /// @notice Adds a new operator to the registry, deploying a delegator contract and\n    /// delegating to the provided `operator`.\n    /// @param s The operator registry v1 storage accessor.\n    /// @param token The address of the liquid restaking token.\n    /// @param operatorDelegatorBeacon The operator delegator beacon address.\n    /// @param config The new operator's configuration.\n    function addOperator(\n        RioLRTOperatorRegistryStorageV1.StorageV1 storage s,\n        address token,\n        address operatorDelegatorBeacon,\n        IRioLRTOperatorRegistry.OperatorConfig memory config\n    ) external returns (uint8 operatorId, address delegator) {\n        if (config.operator == address(0)) revert IRioLRTOperatorRegistry.INVALID_OPERATOR();\n        if (config.initialManager == address(0)) revert IRioLRTOperatorRegistry.INVALID_MANAGER();\n        if (config.initialEarningsReceiver == address(0)) revert IRioLRTOperatorRegistry.INVALID_EARNINGS_RECEIVER();\n\n        if (s.operatorCount == MAX_OPERATOR_COUNT) revert IRioLRTOperatorRegistry.MAX_OPERATOR_COUNT_EXCEEDED();\n        if (s.activeOperatorCount == MAX_ACTIVE_OPERATOR_COUNT) {\n            revert IRioLRTOperatorRegistry.MAX_ACTIVE_OPERATOR_COUNT_EXCEEDED();\n        }\n\n        // Increment the operator count before assignment (First operator ID is 1)\n        operatorId = ++s.operatorCount;\n        s.activeOperatorCount += 1;\n\n        // Create the operator with the provided salt and initialize it.\n        delegator = CREATE3.deploy(\n            computeOperatorSalt(operatorId),\n            abi.encodePacked(type(BeaconProxy).creationCode, abi.encode(operatorDelegatorBeacon, '')),\n            0\n        );\n        IRioLRTOperatorDelegator(delegator).initialize(token, config.operator);\n\n        IRioLRTOperatorRegistry.OperatorDetails storage _operator = s.operatorDetails[operatorId];\n        _operator.active = true;\n        _operator.manager = config.initialManager;\n        _operator.earningsReceiver = config.initialEarningsReceiver;\n        _operator.delegator = delegator;\n\n        emit IRioLRTOperatorRegistry.OperatorAdded(\n            operatorId,\n            config.operator,\n            delegator,\n            config.initialManager,\n            config.initialEarningsReceiver,\n            config.initialMetadataURI\n        );\n\n        // Populate the strategy share allocation caps for the operator.\n        for (uint256 i = 0; i < config.strategyShareCaps.length; ++i) {\n            s.setOperatorStrategyCap(operatorId, config.strategyShareCaps[i]);\n        }\n\n        // Populate the validator cap for the operator, if applicable.\n        if (config.validatorCap > 0) {\n            s.setOperatorValidatorCap(operatorId, config.validatorCap);\n        }\n    }\n\n    /// @notice Activates an operator.\n    /// @param s The operator registry v1 storage accessor.\n    /// @param operatorId The operator's ID.\n    function activateOperator(RioLRTOperatorRegistryStorageV1.StorageV1 storage s, uint8 operatorId) external {\n        IRioLRTOperatorRegistry.OperatorDetails storage operator = s.operatorDetails[operatorId];\n\n        if (operator.delegator == address(0)) revert IRioLRTOperatorRegistry.INVALID_OPERATOR_DELEGATOR();\n        if (operator.active) revert IRioLRTOperatorRegistry.OPERATOR_ALREADY_ACTIVE();\n\n        operator.active = true;\n        s.activeOperatorCount += 1;\n\n        emit IRioLRTOperatorRegistry.OperatorActivated(operatorId);\n    }\n\n    /// Deactivates an operator, exiting all remaining stake to the\n    /// asset manager.\n    /// @param s The operator registry v1 storage accessor.\n    /// @param assetRegistry The asset registry contract.\n    /// @param operatorId The operator's ID.\n    function deactivateOperator(\n        RioLRTOperatorRegistryStorageV1.StorageV1 storage s,\n        IRioLRTAssetRegistry assetRegistry,\n        uint8 operatorId\n    ) external {\n        IRioLRTOperatorRegistry.OperatorDetails storage operator = s.operatorDetails[operatorId];\n\n        if (operator.delegator == address(0)) revert IRioLRTOperatorRegistry.INVALID_OPERATOR_DELEGATOR();\n        if (!operator.active) revert IRioLRTOperatorRegistry.OPERATOR_ALREADY_INACTIVE();\n\n        // Queue exits for all strategies with non-zero allocations.\n        address[] memory strategies = assetRegistry.getAssetStrategies();\n        for (uint256 i = 0; i < strategies.length; ++i) {\n            s.setOperatorStrategyCap(\n                operatorId, IRioLRTOperatorRegistry.StrategyShareCap({strategy: strategies[i], cap: 0})\n            );\n        }\n        if (operator.validatorDetails.cap > 0) {\n            s.setOperatorValidatorCap(operatorId, 0);\n        }\n\n        operator.active = false;\n        s.activeOperatorCount -= 1;\n\n        emit IRioLRTOperatorRegistry.OperatorDeactivated(operatorId);\n    }\n\n    // forgefmt: disable-next-item\n    /// Queues a complete exit from the specified strategy for the provided operator.\n    /// @param operator The storage accessor for the operator that's exiting.\n    /// @param operatorId The operator's ID.\n    /// @param strategy The strategy to exit.\n    function queueOperatorStrategyExit(IRioLRTOperatorRegistry.OperatorDetails storage operator, uint8 operatorId, address strategy) internal {\n        IRioLRTOperatorDelegator delegator = IRioLRTOperatorDelegator(operator.delegator);\n\n        uint256 sharesToExit;\n        if (strategy == BEACON_CHAIN_STRATEGY) {\n            // Queues an exit for verified validators only. Unverified validators must by exited once verified,\n            // and ETH must be scraped into the deposit pool. Exits are rounded to the nearest Gwei. It is not\n            // possible to exit ETH with precision less than 1 Gwei. We do not populate `sharesToExit` if the\n            // Eigen Pod shares are not greater than 0.\n            int256 eigenPodShares = delegator.getEigenPodShares();\n            if (eigenPodShares > 0) {\n                sharesToExit = uint256(eigenPodShares).reducePrecisionToGwei();\n            }\n        } else {\n            sharesToExit = operator.shareDetails[strategy].allocation;\n        }\n        if (sharesToExit == 0) revert IRioLRTOperatorRegistry.CANNOT_EXIT_ZERO_SHARES();\n\n        // Queues a withdrawal to the deposit pool.\n        bytes32 withdrawalRoot = delegator.queueWithdrawalForOperatorExit(strategy, sharesToExit);\n        emit IRioLRTOperatorRegistry.OperatorStrategyExitQueued(operatorId, strategy, sharesToExit, withdrawalRoot);\n    }\n\n    /// @notice Sets the operator's strategy share allocation caps.\n    /// @param s The operator registry v1 storage accessor.\n    /// @param operatorId The operator's ID.\n    /// @param newStrategyShareCaps The new strategy share allocation caps.\n    function setOperatorStrategyShareCaps(\n        RioLRTOperatorRegistryStorageV1.StorageV1 storage s,\n        uint8 operatorId,\n        IRioLRTOperatorRegistry.StrategyShareCap[] calldata newStrategyShareCaps\n    ) external {\n        for (uint256 i = 0; i < newStrategyShareCaps.length; ++i) {\n            s.setOperatorStrategyCap(operatorId, newStrategyShareCaps[i]);\n        }\n    }\n\n    /// @notice Sets the security daemon to a new account (`newSecurityDaemon`).\n    /// @param s The operator registry v1 storage accessor.\n    /// @param newSecurityDaemon The new security daemon address.\n    function setSecurityDaemon(RioLRTOperatorRegistryStorageV1.StorageV1 storage s, address newSecurityDaemon)\n        external\n    {\n        s.securityDaemon = newSecurityDaemon;\n\n        emit IRioLRTOperatorRegistry.SecurityDaemonSet(newSecurityDaemon);\n    }\n\n    /// @notice Sets the proof uploader to a new account (`newProofUploader`).\n    /// @param s The operator registry v1 storage accessor.\n    /// @param newProofUploader The new proof uploader address.\n    function setProofUploader(RioLRTOperatorRegistryStorageV1.StorageV1 storage s, address newProofUploader) external {\n        s.proofUploader = newProofUploader;\n\n        emit IRioLRTOperatorRegistry.ProofUploaderSet(newProofUploader);\n    }\n\n    /// @notice Sets the minimum acceptable delay between an operator signaling intent to register\n    // for an AVS and completing registration.\n    /// @param s The operator registry v1 storage accessor.\n    /// @param newMinStakerOptOutBlocks The new min staker opt out blocks.\n    function setMinStakerOptOutBlocks(\n        RioLRTOperatorRegistryStorageV1.StorageV1 storage s,\n        uint24 newMinStakerOptOutBlocks\n    ) external {\n        s.minStakerOptOutBlocks = newMinStakerOptOutBlocks;\n\n        emit IRioLRTOperatorRegistry.MinStakerOptOutBlocksSet(newMinStakerOptOutBlocks);\n    }\n\n    /// @dev Sets the amount of time (in seconds) before uploaded validator keys are considered \"vetted\".\n    /// @param s The operator registry v1 storage accessor.\n    /// @param newValidatorKeyReviewPeriod The new validator key review period.\n    function setValidatorKeyReviewPeriod(\n        RioLRTOperatorRegistryStorageV1.StorageV1 storage s,\n        uint24 newValidatorKeyReviewPeriod\n    ) external {\n        s.validatorKeyReviewPeriod = newValidatorKeyReviewPeriod;\n\n        emit IRioLRTOperatorRegistry.ValidatorKeyReviewPeriodSet(newValidatorKeyReviewPeriod);\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Sets the strategy share cap for a given operator.\n    /// @param s The operator registry v1 storage accessor.\n    /// @param operatorId The unique identifier of the operator.\n    /// @param newShareCap The new share cap details including the strategy and cap.\n    function setOperatorStrategyCap(\n        RioLRTOperatorRegistryStorageV1.StorageV1 storage s,\n        uint8 operatorId,\n        IRioLRTOperatorRegistry.StrategyShareCap memory newShareCap\n    ) internal {\n        IRioLRTOperatorRegistry.OperatorDetails storage operatorDetails = s.operatorDetails[operatorId];\n        if (operatorDetails.delegator == address(0)) revert IRioLRTOperatorRegistry.INVALID_OPERATOR_DELEGATOR();\n\n        IRioLRTOperatorRegistry.OperatorShareDetails memory currentShareDetails = operatorDetails.shareDetails[newShareCap.strategy];\n\n        // If the new cap is the same as the current, no update is necessary.\n        if (currentShareDetails.cap == newShareCap.cap) {\n            return;\n        }\n        OperatorUtilizationHeap.Data memory utilizationHeap = s.getOperatorUtilizationHeapForStrategy(newShareCap.strategy);\n\n        // If the current cap is greater than 0 and the new cap is 0, remove the operator from the strategy.\n        if (currentShareDetails.cap > 0 && newShareCap.cap == 0) {\n            // If the operator has allocations, queue them for exit.\n            if (currentShareDetails.allocation > 0) {\n                operatorDetails.queueOperatorStrategyExit(operatorId, newShareCap.strategy);\n            }\n            // Remove the operator from the utilization heap.\n            utilizationHeap.removeByID(operatorId);\n        } else if (currentShareDetails.cap == 0 && newShareCap.cap > 0) {\n            // If the current cap is 0 and the new cap is greater than 0, insert the operator into the heap.\n            utilizationHeap.insert(OperatorUtilizationHeap.Operator(operatorId, 0));\n        } else {\n            // Otherwise, update the operator's utilization in the heap.\n            utilizationHeap.updateUtilizationByID(operatorId, currentShareDetails.allocation.divWad(newShareCap.cap));\n        }\n\n        // Persist the updated heap to the active operators tracking.\n        utilizationHeap.store(s.activeOperatorsByStrategyShareUtilization[newShareCap.strategy]);\n\n        // Update the share cap in the operator details.\n        operatorDetails.shareDetails[newShareCap.strategy].cap = newShareCap.cap;\n\n        emit IRioLRTOperatorRegistry.OperatorStrategyShareCapSet(operatorId, newShareCap.strategy, newShareCap.cap);\n    }\n\n    /// @notice Sets the operator's maximum active validator cap.\n    /// @param s The operator registry v1 storage accessor.\n    /// @param operatorId The unique identifier of the operator.\n    /// @param newValidatorCap The new maximum active validator cap.\n    function setOperatorValidatorCap(\n        RioLRTOperatorRegistryStorageV1.StorageV1 storage s,\n        uint8 operatorId,\n        uint40 newValidatorCap\n    ) internal {\n        IRioLRTOperatorRegistry.OperatorDetails storage operatorDetails = s.operatorDetails[operatorId];\n        if (operatorDetails.delegator == address(0)) revert IRioLRTOperatorRegistry.INVALID_OPERATOR_DELEGATOR();\n\n        IRioLRTOperatorRegistry.OperatorValidatorDetails memory validatorDetails = operatorDetails.validatorDetails;\n\n        // If the new validator cap is the same as the current, no update is necessary.\n        if (validatorDetails.cap == newValidatorCap) {\n            return;\n        }\n\n        // Calculate the active deposits (deposited minus exited).\n        uint40 activeDeposits = validatorDetails.deposited - validatorDetails.exited;\n        OperatorUtilizationHeap.Data memory utilizationHeap = s.getOperatorUtilizationHeapForETH();\n\n        // If the current cap is greater than 0 and the new cap is 0, remove the operator from ETH deposit tracking.\n        if (validatorDetails.cap > 0 && newValidatorCap == 0) {\n            // If there are active deposits, queue the operator for strategy exit.\n            if (activeDeposits > 0) {\n                operatorDetails.queueOperatorStrategyExit(operatorId, BEACON_CHAIN_STRATEGY);\n                s.operatorDetails[operatorId].validatorDetails.exited += activeDeposits;\n            }\n            // Remove the operator from the utilization heap.\n            utilizationHeap.removeByID(operatorId);\n        } else if (validatorDetails.cap == 0 && newValidatorCap > 0) {\n            // If the current cap is 0 and the new cap is greater than 0, insert the operator into the heap.\n            utilizationHeap.insert(OperatorUtilizationHeap.Operator(operatorId, 0));\n        } else {\n            // Otherwise, update the operator's utilization in the heap.\n            utilizationHeap.updateUtilizationByID(operatorId, activeDeposits.divWad(newValidatorCap));\n        }\n\n        // Persist the updated heap to the active operators tracking for ETH deposits.\n        utilizationHeap.store(s.activeOperatorsByETHDepositUtilization);\n\n        // Update the validator cap in the operator details.\n        operatorDetails.validatorDetails.cap = newValidatorCap;\n\n        emit IRioLRTOperatorRegistry.OperatorValidatorCapSet(operatorId, newValidatorCap);\n    }\n\n    // forgefmt: disable-next-item\n    /// @dev Returns the operator utilization heap for the specified strategy.\n    /// Utilization is calculated as the operator's current allocation divided by their cap,\n    /// unless the cap is 0, in which case the operator is considered to have max utilization.\n    /// @param s The operator registry v1 storage accessor.\n    /// @param strategy The strategy to get the heap for.\n    function getOperatorUtilizationHeapForStrategy(RioLRTOperatorRegistryStorageV1.StorageV1 storage s, address strategy) internal view returns (OperatorUtilizationHeap.Data memory heap) {\n        uint8 numActiveOperators = s.activeOperatorCount;\n        if (numActiveOperators == 0) return OperatorUtilizationHeap.Data(new OperatorUtilizationHeap.Operator[](0), 0);\n        \n        heap = OperatorUtilizationHeap.initialize(MAX_ACTIVE_OPERATOR_COUNT);\n        LibMap.Uint8Map storage operators = s.activeOperatorsByStrategyShareUtilization[strategy];\n\n        IRioLRTOperatorRegistry.OperatorShareDetails memory operatorShares;\n        unchecked {\n            uint8 i;\n            for (i = 0; i < numActiveOperators; ++i) {\n                uint8 operatorId = operators.get(i);\n\n                // Non-existent operator ID. We've reached the end of the heap.\n                if (operatorId == 0) break;\n\n                operatorShares = s.operatorDetails[operatorId].shareDetails[strategy];\n                heap.operators[i + 1] = OperatorUtilizationHeap.Operator({\n                    id: operatorId,\n                    utilization: operatorShares.allocation.divWad(operatorShares.cap)\n                });\n            }\n            heap.count = i;\n        }\n    }\n\n    /// @dev Returns the ETH deposit operator utilization heap.\n    /// Utilization is calculated as the operator's active deposit count divided by their cap,\n    /// unless the cap is 0, in which case the operator is considered to have max utilization.\n    /// @param s The operator registry v1 storage accessor.\n    function getOperatorUtilizationHeapForETH(RioLRTOperatorRegistryStorageV1.StorageV1 storage s)\n        internal\n        view\n        returns (OperatorUtilizationHeap.Data memory heap)\n    {\n        uint8 numActiveOperators = s.activeOperatorCount;\n        if (numActiveOperators == 0) return OperatorUtilizationHeap.Data(new OperatorUtilizationHeap.Operator[](0), 0);\n\n        heap = OperatorUtilizationHeap.initialize(MAX_ACTIVE_OPERATOR_COUNT);\n\n        uint256 activeDeposits;\n        IRioLRTOperatorRegistry.OperatorValidatorDetails memory validators;\n        unchecked {\n            uint8 i;\n            for (i = 0; i < numActiveOperators; ++i) {\n                uint8 operatorId = s.activeOperatorsByETHDepositUtilization.get(i);\n\n                // Non-existent operator ID. We've reached the end of the heap.\n                if (operatorId == 0) break;\n\n                validators = s.operatorDetails[operatorId].validatorDetails;\n                activeDeposits = validators.deposited - validators.exited;\n                heap.operators[i + 1] = OperatorUtilizationHeap.Operator({\n                    id: operatorId,\n                    utilization: activeDeposits.divWad(validators.cap)\n                });\n            }\n            heap.count = i;\n        }\n    }\n\n    /// @notice Computes the salt for an operator delegator, which is the\n    /// operator ID converted to `bytes32`.\n    /// @param operatorId The operator's ID.\n    function computeOperatorSalt(uint8 operatorId) internal pure returns (bytes32) {\n        return bytes32(uint256(operatorId));\n    }\n}"
    },
    {
      "filename": "rio-sherlock-audit/contracts/utils/OperatorRegistryV1Admin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {LibMap} from '@solady/utils/LibMap.sol';\nimport {CREATE3} from '@solady/utils/CREATE3.sol';\nimport {FixedPointMathLib} from '@solady/utils/FixedPointMathLib.sol';\nimport {BeaconProxy} from '@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol';\nimport {RioLRTOperatorRegistryStorageV1} from 'contracts/restaking/storage/RioLRTOperatorRegistryStorageV1.sol';\nimport {IRioLRTOperatorDelegator} from 'contracts/interfaces/IRioLRTOperatorDelegator.sol';\nimport {IRioLRTOperatorRegistry} from 'contracts/interfaces/IRioLRTOperatorRegistry.sol';\nimport {OperatorUtilizationHeap} from 'contracts/utils/OperatorUtilizationHeap.sol';\nimport {IRioLRTAssetRegistry} from 'contracts/interfaces/IRioLRTAssetRegistry.sol';\nimport {BEACON_CHAIN_STRATEGY} from 'contracts/utils/Constants.sol';\nimport {Array} from 'contracts/utils/Array.sol';\nimport {Asset} from 'contracts/utils/Asset.sol';\n\n/// @title Administrative functions for the operator registry.\nlibrary OperatorRegistryV1Admin {\n    using OperatorRegistryV1Admin for RioLRTOperatorRegistryStorageV1.StorageV1;\n    using OperatorRegistryV1Admin for IRioLRTOperatorRegistry.OperatorDetails;\n    using OperatorUtilizationHeap for OperatorUtilizationHeap.Data;\n    using FixedPointMathLib for *;\n    using LibMap for *;\n    using Array for *;\n    using Asset for *;\n\n    /// @notice The maximum number of operators allowed in the registry.\n    uint8 public constant MAX_OPERATOR_COUNT = 254;\n\n    /// @notice The maximum number of active operators allowed.\n    uint8 public constant MAX_ACTIVE_OPERATOR_COUNT = 64;\n\n    /// @notice Adds a new operator to the registry, deploying a delegator contract and\n    /// delegating to the provided `operator`.\n    /// @param s The operator registry v1 storage accessor.\n    /// @param token The address of the liquid restaking token.\n    /// @param operatorDelegatorBeacon The operator delegator beacon address.\n    /// @param config The new operator's configuration.\n    function addOperator(\n        RioLRTOperatorRegistryStorageV1.StorageV1 storage s,\n        address token,\n        address operatorDelegatorBeacon,\n        IRioLRTOperatorRegistry.OperatorConfig memory config\n    ) external returns (uint8 operatorId, address delegator) {\n        if (config.operator == address(0)) revert IRioLRTOperatorRegistry.INVALID_OPERATOR();\n        if (config.initialManager == address(0)) revert IRioLRTOperatorRegistry.INVALID_MANAGER();\n        if (config.initialEarningsReceiver == address(0)) revert IRioLRTOperatorRegistry.INVALID_EARNINGS_RECEIVER();\n\n        if (s.operatorCount == MAX_OPERATOR_COUNT) revert IRioLRTOperatorRegistry.MAX_OPERATOR_COUNT_EXCEEDED();\n        if (s.activeOperatorCount == MAX_ACTIVE_OPERATOR_COUNT) {\n            revert IRioLRTOperatorRegistry.MAX_ACTIVE_OPERATOR_COUNT_EXCEEDED();\n        }\n\n        // Increment the operator count before assignment (First operator ID is 1)\n        operatorId = ++s.operatorCount;\n        s.activeOperatorCount += 1;\n\n        // Create the operator with the provided salt and initialize it.\n        delegator = CREATE3.deploy(\n            computeOperatorSalt(operatorId),\n            abi.encodePacked(type(BeaconProxy).creationCode, abi.encode(operatorDelegatorBeacon, '')),\n            0\n        );\n        IRioLRTOperatorDelegator(delegator).initialize(token, config.operator);\n\n        IRioLRTOperatorRegistry.OperatorDetails storage _operator = s.operatorDetails[operatorId];\n        _operator.active = true;\n        _operator.manager = config.initialManager;\n        _operator.earningsReceiver = config.initialEarningsReceiver;\n        _operator.delegator = delegator;\n\n        emit IRioLRTOperatorRegistry.OperatorAdded(\n            operatorId,\n            config.operator,\n            delegator,\n            config.initialManager,\n            config.initialEarningsReceiver,\n            config.initialMetadataURI\n        );\n\n        // Populate the strategy share allocation caps for the operator.\n        for (uint256 i = 0; i < config.strategyShareCaps.length; ++i) {\n            s.setOperatorStrategyCap(operatorId, config.strategyShareCaps[i]);\n        }\n\n        // Populate the validator cap for the operator, if applicable.\n        if (config.validatorCap > 0) {\n            s.setOperatorValidatorCap(operatorId, config.validatorCap);\n        }\n    }\n\n    /// @notice Activates an operator.\n    /// @param s The operator registry v1 storage accessor.\n    /// @param operatorId The operator's ID.\n    function activateOperator(RioLRTOperatorRegistryStorageV1.StorageV1 storage s, uint8 operatorId) external {\n        IRioLRTOperatorRegistry.OperatorDetails storage operator = s.operatorDetails[operatorId];\n\n        if (operator.delegator == address(0)) revert IRioLRTOperatorRegistry.INVALID_OPERATOR_DELEGATOR();\n        if (operator.active) revert IRioLRTOperatorRegistry.OPERATOR_ALREADY_ACTIVE();\n\n        operator.active = true;\n        s.activeOperatorCount += 1;\n\n        emit IRioLRTOperatorRegistry.OperatorActivated(operatorId);\n    }\n\n    /// Deactivates an operator, exiting all remaining stake to the\n    /// asset manager.\n    /// @param s The operator registry v1 storage accessor.\n    /// @param assetRegistry The asset registry contract.\n    /// @param operatorId The operator's ID.\n    function deactivateOperator(\n        RioLRTOperatorRegistryStorageV1.StorageV1 storage s,\n        IRioLRTAssetRegistry assetRegistry,\n        uint8 operatorId\n    ) external {\n        IRioLRTOperatorRegistry.OperatorDetails storage operator = s.operatorDetails[operatorId];\n\n        if (operator.delegator == address(0)) revert IRioLRTOperatorRegistry.INVALID_OPERATOR_DELEGATOR();\n        if (!operator.active) revert IRioLRTOperatorRegistry.OPERATOR_ALREADY_INACTIVE();\n\n        // Queue exits for all strategies with non-zero allocations.\n        address[] memory strategies = assetRegistry.getAssetStrategies();\n        for (uint256 i = 0; i < strategies.length; ++i) {\n            s.setOperatorStrategyCap(\n                operatorId, IRioLRTOperatorRegistry.StrategyShareCap({strategy: strategies[i], cap: 0})\n            );\n        }\n        if (operator.validatorDetails.cap > 0) {\n            s.setOperatorValidatorCap(operatorId, 0);\n        }\n\n        operator.active = false;\n        s.activeOperatorCount -= 1;\n\n        emit IRioLRTOperatorRegistry.OperatorDeactivated(operatorId);\n    }\n\n    // forgefmt: disable-next-item\n    /// Queues a complete exit from the specified strategy for the provided operator.\n    /// @param operator The storage accessor for the operator that's exiting.\n    /// @param operatorId The operator's ID.\n    /// @param strategy The strategy to exit.\n    function queueOperatorStrategyExit(IRioLRTOperatorRegistry.OperatorDetails storage operator, uint8 operatorId, address strategy) internal {\n        IRioLRTOperatorDelegator delegator = IRioLRTOperatorDelegator(operator.delegator);\n\n        uint256 sharesToExit;\n        if (strategy == BEACON_CHAIN_STRATEGY) {\n            // Queues an exit for verified validators only. Unverified validators must by exited once verified,\n            // and ETH must be scraped into the deposit pool. Exits are rounded to the nearest Gwei. It is not\n            // possible to exit ETH with precision less than 1 Gwei. We do not populate `sharesToExit` if the\n            // Eigen Pod shares are not greater than 0.\n            int256 eigenPodShares = delegator.getEigenPodShares();\n            if (eigenPodShares > 0) {\n                sharesToExit = uint256(eigenPodShares).reducePrecisionToGwei();\n            }\n        } else {\n            sharesToExit = operator.shareDetails[strategy].allocation;\n        }\n        if (sharesToExit == 0) revert IRioLRTOperatorRegistry.CANNOT_EXIT_ZERO_SHARES();\n\n        // Queues a withdrawal to the deposit pool.\n        bytes32 withdrawalRoot = delegator.queueWithdrawalForOperatorExit(strategy, sharesToExit);\n        emit IRioLRTOperatorRegistry.OperatorStrategyExitQueued(operatorId, strategy, sharesToExit, withdrawalRoot);\n    }\n\n    /// @notice Sets the operator's strategy share allocation caps.\n    /// @param s The operator registry v1 storage accessor.\n    /// @param operatorId The operator's ID.\n    /// @param newStrategyShareCaps The new strategy share allocation caps.\n    function setOperatorStrategyShareCaps(\n        RioLRTOperatorRegistryStorageV1.StorageV1 storage s,\n        uint8 operatorId,\n        IRioLRTOperatorRegistry.StrategyShareCap[] calldata newStrategyShareCaps\n    ) external {\n        for (uint256 i = 0; i < newStrategyShareCaps.length; ++i) {\n            s.setOperatorStrategyCap(operatorId, newStrategyShareCaps[i]);\n        }\n    }\n\n    /// @notice Sets the security daemon to a new account (`newSecurityDaemon`).\n    /// @param s The operator registry v1 storage accessor.\n    /// @param newSecurityDaemon The new security daemon address.\n    function setSecurityDaemon(RioLRTOperatorRegistryStorageV1.StorageV1 storage s, address newSecurityDaemon)\n        external\n    {\n        s.securityDaemon = newSecurityDaemon;\n\n        emit IRioLRTOperatorRegistry.SecurityDaemonSet(newSecurityDaemon);\n    }\n\n    /// @notice Sets the proof uploader to a new account (`newProofUploader`).\n    /// @param s The operator registry v1 storage accessor.\n    /// @param newProofUploader The new proof uploader address.\n    function setProofUploader(RioLRTOperatorRegistryStorageV1.StorageV1 storage s, address newProofUploader) external {\n        s.proofUploader = newProofUploader;\n\n        emit IRioLRTOperatorRegistry.ProofUploaderSet(newProofUploader);\n    }\n\n    /// @notice Sets the minimum acceptable delay between an operator signaling intent to register\n    // for an AVS and completing registration.\n    /// @param s The operator registry v1 storage accessor.\n    /// @param newMinStakerOptOutBlocks The new min staker opt out blocks.\n    function setMinStakerOptOutBlocks(\n        RioLRTOperatorRegistryStorageV1.StorageV1 storage s,\n        uint24 newMinStakerOptOutBlocks\n    ) external {\n        s.minStakerOptOutBlocks = newMinStakerOptOutBlocks;\n\n        emit IRioLRTOperatorRegistry.MinStakerOptOutBlocksSet(newMinStakerOptOutBlocks);\n    }\n\n    /// @dev Sets the amount of time (in seconds) before uploaded validator keys are considered \"vetted\".\n    /// @param s The operator registry v1 storage accessor.\n    /// @param newValidatorKeyReviewPeriod The new validator key review period.\n    function setValidatorKeyReviewPeriod(\n        RioLRTOperatorRegistryStorageV1.StorageV1 storage s,\n        uint24 newValidatorKeyReviewPeriod\n    ) external {\n        s.validatorKeyReviewPeriod = newValidatorKeyReviewPeriod;\n\n        emit IRioLRTOperatorRegistry.ValidatorKeyReviewPeriodSet(newValidatorKeyReviewPeriod);\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Sets the strategy share cap for a given operator.\n    /// @param s The operator registry v1 storage accessor.\n    /// @param operatorId The unique identifier of the operator.\n    /// @param newShareCap The new share cap details including the strategy and cap.\n    function setOperatorStrategyCap(\n        RioLRTOperatorRegistryStorageV1.StorageV1 storage s,\n        uint8 operatorId,\n        IRioLRTOperatorRegistry.StrategyShareCap memory newShareCap\n    ) internal {\n        IRioLRTOperatorRegistry.OperatorDetails storage operatorDetails = s.operatorDetails[operatorId];\n        if (operatorDetails.delegator == address(0)) revert IRioLRTOperatorRegistry.INVALID_OPERATOR_DELEGATOR();\n\n        IRioLRTOperatorRegistry.OperatorShareDetails memory currentShareDetails = operatorDetails.shareDetails[newShareCap.strategy];\n\n        // If the new cap is the same as the current, no update is necessary.\n        if (currentShareDetails.cap == newShareCap.cap) {\n            return;\n        }\n        OperatorUtilizationHeap.Data memory utilizationHeap = s.getOperatorUtilizationHeapForStrategy(newShareCap.strategy);\n\n        // If the current cap is greater than 0 and the new cap is 0, remove the operator from the strategy.\n        if (currentShareDetails.cap > 0 && newShareCap.cap == 0) {\n            // If the operator has allocations, queue them for exit.\n            if (currentShareDetails.allocation > 0) {\n                operatorDetails.queueOperatorStrategyExit(operatorId, newShareCap.strategy);\n            }\n            // Remove the operator from the utilization heap.\n            utilizationHeap.removeByID(operatorId);\n        } else if (currentShareDetails.cap == 0 && newShareCap.cap > 0) {\n            // If the current cap is 0 and the new cap is greater than 0, insert the operator into the heap.\n            utilizationHeap.insert(OperatorUtilizationHeap.Operator(operatorId, 0));\n        } else {\n            // Otherwise, update the operator's utilization in the heap.\n            utilizationHeap.updateUtilizationByID(operatorId, currentShareDeta"
    }
  ]
}