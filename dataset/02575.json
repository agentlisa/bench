{
  "Title": "H-8: Users redeem strategy tokens but receives no assets in return",
  "Content": "# Issue H-8: Users redeem strategy tokens but receives no assets in return \n\nSource: https://github.com/sherlock-audit/2022-12-notional-judging/issues/10 \n\n## Found by \nxiaoming90\n\n## Summary\n\nDue to a rounding error in Solidity, it is possible that a user burns their strategy tokens, but receives no assets in return due to issues in the following functions:\n\n- StrategyUtils._convertStrategyTokensToBPTClaim\n- Boosted3TokenPoolUtils._redeem\n- TwoTokenPoolUtils._redeem\n\n## Vulnerability Detail\n\n> This affects both the TwoToken and Boosted3Token vaults\n\n```solidity\nint256 internal constant INTERNAL_TOKEN_PRECISION = 1e8;\nuint256 internal constant BALANCER_PRECISION = 1e18;\n```\n\nWithin the `StrategyUtils._convertStrategyTokensToBPTClaim` function, it was observed that if the numerator is smaller than the denominator, the `bptClaim` will be zero.\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/strategy/StrategyUtils.sol#L18\n\n```solidity\nFile: StrategyUtils.sol\n18:     function _convertStrategyTokensToBPTClaim(StrategyContext memory context, uint256 strategyTokenAmount)\n19:         internal pure returns (uint256 bptClaim) {\n20:         require(strategyTokenAmount <= context.vaultState.totalStrategyTokenGlobal);\n21:         if (context.vaultState.totalStrategyTokenGlobal > 0) {\n22:             bptClaim = (strategyTokenAmount * context.vaultState.totalBPTHeld) / context.vaultState.totalStrategyTokenGlobal;\n23:         }\n24:     }\n```\n\nWhen the `bptClaim` is zero, the function returns zero instead of reverting. Therefore, it is possible that a user redeems (\"burns\") their strategy tokens, but receives no assets in return because the number of strategy tokens redeemed by the user is too small.\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/pool/Boosted3TokenPoolUtils.sol#L432\n\n```solidity\nFile: Boosted3TokenPoolUtils.sol\n432:     function _redeem(\n433:         ThreeTokenPoolContext memory poolContext,\n434:         StrategyContext memory strategyContext,\n435:         AuraStakingContext memory stakingContext,\n436:         uint256 strategyTokens,\n437:         uint256 minPrimary\n438:     ) internal returns (uint256 finalPrimaryBalance) {\n439:         uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokens);\n440: \n441:         if (bptClaim == 0) return 0;\n442: \n443:         finalPrimaryBalance = _unstakeAndExitPool({\n444:             stakingContext: stakingContext,\n445:             poolContext: poolContext,\n446:             bptClaim: bptClaim,\n447:             minPrimary: minPrimary\n448:         });\n449: \n450:         strategyContext.vaultState.totalBPTHeld -= bptClaim;\n451:         strategyContext.vaultState.totalStrategyTokenGlobal -= strategyTokens.toUint80();\n452:         strategyContext.vaultState.setStrategyVaultState(); \n453:     }\n```\n\n## Impact\n\nLoss of assets for the users as they burn their strategy tokens, but receive no assets in return.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/pool/Boosted3TokenPoolUtils.sol#L432\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol#L209\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider reverting if the assets (bptClaim) received is zero. This check has been implemented in many well-known vault designs as this is a commonly known issue (e.g. [Solmate](https://github.com/transmissions11/solmate/blob/3998897acb502fa7b480f505138a6ae1842e8d10/src/mixins/ERC4626.sol#L107))\n\n```diff\nfunction _redeem(\n    ThreeTokenPoolContext memory poolContext,\n    StrategyContext memory strategyContext,\n    AuraStakingContext memory stakingContext,\n    uint256 strategyTokens,\n    uint256 minPrimary\n) internal returns (uint256 finalPrimaryBalance) {\n    uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokens);\n\n-   if (bptClaim == 0) return 0;\n+\trequire(bptClaim > 0, \"zero asset\")\n\n    finalPrimaryBalance = _unstakeAndExitPool({\n        stakingContext: stakingContext,\n        poolContext: poolContext,\n        bptClaim: bptClaim,\n        minPrimary: minPrimary\n    });\n\n    strategyContext.vaultState.totalBPTHeld -= bptClaim;\n    strategyContext.vaultState.totalStrategyTokenGlobal -= strategyTokens.toUint80();\n    strategyContext.vaultState.setStrategyVaultState(); \n}\n```\n\n## Discussion\n\n**weitianjie2000**\n\nvalid, will fix\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/31",
  "Code": [
    {
      "filename": "contracts/vaults/balancer/internal/strategy/StrategyUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport { StrategyContext, TradeParams } from \"../../BalancerVaultTypes.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\nimport {TradeHandler} from \"../../../../trading/TradeHandler.sol\";\nimport {BalancerUtils} from \"../pool/BalancerUtils.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {Constants} from \"../../../../global/Constants.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {ITradingModule, Trade, TradeType} from \"../../../../../interfaces/trading/ITradingModule.sol\";\n\nlibrary StrategyUtils {\n    using TradeHandler for Trade;\n    using TokenUtils for IERC20;\n\n    /// @notice Converts strategy tokens to BPT\n    function _convertStrategyTokensToBPTClaim(StrategyContext memory context, uint256 strategyTokenAmount)\n        internal pure returns (uint256 bptClaim) {\n        require(strategyTokenAmount <= context.vaultState.totalStrategyTokenGlobal);\n        if (context.vaultState.totalStrategyTokenGlobal > 0) {\n            bptClaim = (strategyTokenAmount * context.vaultState.totalBPTHeld) / context.vaultState.totalStrategyTokenGlobal;\n        }\n    }\n\n    /// @notice Converts BPT to strategy tokens\n    function _convertBPTClaimToStrategyTokens(StrategyContext memory context, uint256 bptClaim)\n        internal pure returns (uint256 strategyTokenAmount) {\n        if (context.vaultState.totalBPTHeld == 0) {\n            // Strategy tokens are in 8 decimal precision, BPT is in 18. Scale the minted amount down.\n            return (bptClaim * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / \n                BalancerConstants.BALANCER_PRECISION;\n        }\n\n        // BPT held in maturity is calculated before the new BPT tokens are minted, so this calculation\n        // is the tokens minted that will give the account a corresponding share of the new bpt balance held.\n        // The precision here will be the same as strategy token supply.\n        strategyTokenAmount = (bptClaim * context.vaultState.totalStrategyTokenGlobal) / context.vaultState.totalBPTHeld;\n    }\n\n    function _executeTradeExactIn(\n        TradeParams memory params,\n        ITradingModule tradingModule,\n        address sellToken,\n        address buyToken,\n        uint256 amount,\n        bool useDynamicSlippage\n    ) internal returns (uint256 amountSold, uint256 amountBought) {\n        require(\n            params.tradeType == TradeType.EXACT_IN_SINGLE || params.tradeType == TradeType.EXACT_IN_BATCH\n        );\n        if (useDynamicSlippage) {\n            require(params.oracleSlippagePercentOrLimit <= Constants.SLIPPAGE_LIMIT_PRECISION);\n        }\n\n        // Sell residual secondary balance\n        Trade memory trade = Trade(\n            params.tradeType,\n            sellToken,\n            buyToken,\n            amount,\n            useDynamicSlippage ? 0 : params.oracleSlippagePercentOrLimit,\n            block.timestamp, // deadline\n            params.exchangeData\n        );\n\n        // stETH generally has deeper liquidity than wstETH, setting tradeUnwrapped\n        // to lets the contract trade in stETH instead of wstETH\n        if (params.tradeUnwrapped) {\n            if (sellToken == address(Deployments.WRAPPED_STETH)) {\n                trade.sellToken = Deployments.WRAPPED_STETH.stETH();\n                uint256 amountBeforeUnwrap = IERC20(trade.sellToken).balanceOf(address(this));\n                // NOTE: the amount returned by unwrap is not always accurate for some reason\n                Deployments.WRAPPED_STETH.unwrap(trade.amount);\n                trade.amount = IERC20(trade.sellToken).balanceOf(address(this)) - amountBeforeUnwrap;\n            }\n            if (buyToken == address(Deployments.WRAPPED_STETH)) {\n                trade.buyToken = Deployments.WRAPPED_STETH.stETH();\n            }\n        }\n\n        if (useDynamicSlippage) {\n            /// @dev params.oracleSlippagePercentOrLimit checked above\n            (amountSold, amountBought) = trade._executeTradeWithDynamicSlippage(\n                params.dexId, tradingModule, uint32(params.oracleSlippagePercentOrLimit)\n            );\n        } else {\n            (amountSold, amountBought) = trade._executeTrade(\n                params.dexId, tradingModule\n            );\n        }\n\n        if (params.tradeUnwrapped) {\n            if (sellToken == address(Deployments.WRAPPED_STETH)) {\n                // Setting amountSold to the original wstETH amount because _executeTradeWithDynamicSlippage\n                // returns the amount of stETH sold in this case\n                /// @notice amountSold == amount because this function only supports EXACT_IN trades\n                amountSold = amount;\n            }\n            if (buyToken == address(Deployments.WRAPPED_STETH) && amountBought > 0) {\n                // trade.buyToken == stETH here\n                IERC20(trade.buyToken).checkApprove(address(Deployments.WRAPPED_STETH), amountBought);\n                uint256 amountBeforeWrap = Deployments.WRAPPED_STETH.balanceOf(address(this));\n                /// @notice the amount returned by wrap is not always accurate for some reason\n                Deployments.WRAPPED_STETH.wrap(amountBought);\n                amountBought = Deployments.WRAPPED_STETH.balanceOf(address(this)) - amountBeforeWrap;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/vaults/balancer/internal/pool/Boosted3TokenPoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {\n    ThreeTokenPoolContext,\n    TwoTokenPoolContext,\n    BoostedOracleContext,\n    UnderlyingPoolContext,\n    AuraStakingContext,\n    StrategyContext,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../../BalancerVaultTypes.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {BalancerUtils} from \"../pool/BalancerUtils.sol\";\nimport {Boosted3TokenPoolUtils} from \"../pool/Boosted3TokenPoolUtils.sol\";\nimport {StableMath} from \"../math/StableMath.sol\";\nimport {LinearMath} from \"../math/LinearMath.sol\";\nimport {AuraStakingUtils} from \"../staking/AuraStakingUtils.sol\";\nimport {StrategyUtils} from \"../strategy/StrategyUtils.sol\";\nimport {BalancerVaultStorage} from \"../BalancerVaultStorage.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\nimport {ILinearPool} from \"../../../../../interfaces/balancer/IBalancerPool.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\nimport {TwoTokenPoolUtils} from \"./TwoTokenPoolUtils.sol\";\nimport {FixedPoint} from \"../math/FixedPoint.sol\";\n\nlibrary Boosted3TokenPoolUtils {\n    using TypeConvert for uint256;\n    using FixedPoint for uint256;\n    using TypeConvert for int256;\n    using TokenUtils for IERC20;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using Boosted3TokenPoolUtils for ThreeTokenPoolContext;\n    using AuraStakingUtils for AuraStakingContext;\n    using StrategyUtils for StrategyContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n    using BalancerVaultStorage for StrategyVaultState;\n\n    // Preminted BPT is sometimes called Phantom BPT, as the preminted BPT (which is deposited in the Vault as balance of\n    // the Pool) doesn't belong to any entity until transferred out of the Pool. The Pool's arithmetic behaves as if it\n    // didn't exist, and the BPT total supply is not a useful value: we rely on the 'virtual supply' (how much BPT is\n    // actually owned by some entity) instead.\n    uint256 private constant _MAX_TOKEN_BALANCE = 2**(112) - 1;\n\n    function _getScaleFactor(\n        ThreeTokenPoolContext memory poolContext,\n        uint8 tokenIndex\n    ) private pure returns(uint256 scaleFactor) {\n        if (tokenIndex == 0) {\n            scaleFactor = poolContext.basePool.primaryScaleFactor;\n        } else if (tokenIndex == 1) {\n            scaleFactor = poolContext.basePool.secondaryScaleFactor;\n        } else if (tokenIndex == 2) {\n            scaleFactor = poolContext.tertiaryScaleFactor;\n        }\n    }\n\n    function _getPrecision(\n        ThreeTokenPoolContext memory poolContext,\n        uint8 tokenIndex\n    ) private pure returns(uint256 precision) {\n        if (tokenIndex == 0) {\n            precision = 10**poolContext.basePool.primaryDecimals;\n        } else if (tokenIndex == 1) {\n            precision = 10**poolContext.basePool.secondaryDecimals;\n        } else if (tokenIndex == 2) {\n            precision = 10**poolContext.tertiaryDecimals;\n        }\n    }\n\n    /// @notice Spot price is always expressed in terms of the primary currency\n    function _getSpotPrice(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext,\n        uint8 tokenIndex\n    ) internal pure returns (uint256 spotPrice) {\n        require(tokenIndex < 3);  /// @dev invalid token index\n\n        // Exchange rate of primary currency = 1\n        if (tokenIndex == 0) {\n            return BalancerConstants.BALANCER_PRECISION;\n        }\n\n        uint256[] memory balances = _getScaledBalances(poolContext);\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, balances, true // roundUp = true\n        );\n        spotPrice = _getSpotPriceWithInvariant({\n            poolContext: poolContext,\n            oracleContext: oracleContext,\n            balances: balances, \n            invariant: invariant,\n            tokenIndex: tokenIndex\n        });\n    }\n\n    function _getUnderlyingBPTOut(\n        UnderlyingPoolContext memory pool,\n        uint256 mainIn\n    ) private pure returns (uint256) {\n        uint256 scaledMainBalance = pool.mainBalance * pool.mainScaleFactor /\n            BalancerConstants.BALANCER_PRECISION;\n        uint256 scaledWrappedBalance = pool.wrappedBalance * pool.wrappedScaleFactor /\n            BalancerConstants.BALANCER_PRECISION;\n\n        // Convert from linear pool BPT to primary Amount\n        return LinearMath._calcBptOutPerMainIn({\n            mainIn: mainIn,\n            mainBalance: scaledMainBalance,\n            wrappedBalance: scaledWrappedBalance,\n            bptSupply: pool.virtualSupply,\n            params: LinearMath.Params({\n                fee: pool.fee,\n                lowerTarget: pool.lowerTarget,\n                upperTarget: pool.upperTarget\n            }) \n        });\n    }\n\n    function _getUnderlyingMainOut(\n        UnderlyingPoolContext memory pool,\n        uint256 bptIn\n    ) private pure returns (uint256) {\n        uint256 scaledMainBalance = pool.mainBalance * pool.mainScaleFactor /\n            BalancerConstants.BALANCER_PRECISION;\n        uint256 scaledWrappedBalance = pool.wrappedBalance * pool.wrappedScaleFactor /\n            BalancerConstants.BALANCER_PRECISION;\n\n        // Convert from linear pool BPT to primary Amount\n        return LinearMath._calcMainOutPerBptIn({\n            bptIn: bptIn,\n            mainBalance: scaledMainBalance,\n            wrappedBalance: scaledWrappedBalance,\n            bptSupply: pool.virtualSupply,\n            params: LinearMath.Params({\n                fee: pool.fee,\n                lowerTarget: pool.lowerTarget,\n                upperTarget: pool.upperTarget\n            }) \n        });\n    }\n\n    /// @notice Spot price is always expressed in terms of the primary currency\n    function _getSpotPriceWithInvariant(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext,\n        uint256[] memory balances,\n        uint256 invariant,\n        uint8 tokenIndex\n    ) private pure returns (uint256 spotPrice) {\n        // Trade 1 unit of tokenIn for tokenOut to get the spot price\n        // AmountIn needs to be in underlying precision because mainScaleFactor\n        // will convert it to 1e18\n        uint256 amountIn = _getPrecision(poolContext, tokenIndex);\n\n        UnderlyingPoolContext memory inPool = oracleContext.underlyingPools[tokenIndex];\n        amountIn = amountIn * inPool.mainScaleFactor / BalancerConstants.BALANCER_PRECISION;\n        uint256 linearBPTIn = _getUnderlyingBPTOut(inPool, amountIn);\n\n        linearBPTIn = linearBPTIn * _getScaleFactor(poolContext, tokenIndex) / BalancerConstants.BALANCER_PRECISION;\n\n        uint256 linearBPTOut = StableMath._calcOutGivenIn({\n            amplificationParameter: oracleContext.ampParam,\n            balances: balances,\n            tokenIndexIn: tokenIndex,\n            tokenIndexOut: 0, // Primary index\n            tokenAmountIn: linearBPTIn,\n            invariant: invariant\n        });\n\n        linearBPTOut = linearBPTOut * BalancerConstants.BALANCER_PRECISION / _getScaleFactor(poolContext, 0);\n\n        UnderlyingPoolContext memory outPool = oracleContext.underlyingPools[0];\n        spotPrice = _getUnderlyingMainOut(outPool, linearBPTOut);\n        spotPrice = spotPrice * BalancerConstants.BALANCER_PRECISION / outPool.mainScaleFactor;\n\n        // Convert precision back to 1e18 after downscaling by mainScaleFactor\n        // primary currency = index 0\n        spotPrice = spotPrice * BalancerConstants.BALANCER_PRECISION / _getPrecision(poolContext, 0);\n    }\n\n    function _validateSpotPrice(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext,\n        StrategyContext memory context,\n        address tokenIn,\n        address tokenOut,\n        uint8 tokenIndex,\n        uint256[] memory balances,\n        uint256 invariant\n    ) private view {\n        (int256 answer, int256 decimals) = context.tradingModule.getOraclePrice(tokenOut, tokenIn);\n        require(decimals == int256(BalancerConstants.BALANCER_PRECISION));\n        \n        uint256 spotPrice = _getSpotPriceWithInvariant({\n            poolContext: poolContext,\n            oracleContext: oracleContext,\n            balances: balances, \n            invariant: invariant,\n            tokenIndex: tokenIndex\n        });\n\n        uint256 oraclePrice = answer.toUint();\n        uint256 lowerLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS - context.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS + context.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n\n        // Check spot price against oracle price to make sure it hasn't been manipulated\n        if (spotPrice < lowerLimit || upperLimit < spotPrice) {\n            revert Errors.InvalidPrice(oraclePrice, spotPrice);\n        }\n    }\n\n    function _validateTokenPrices(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext,\n        StrategyContext memory strategyContext,\n        uint256[] memory balances,\n        uint256 invariant\n    ) private view {\n        address primaryUnderlying = ILinearPool(address(poolContext.basePool.primaryToken)).getMainToken();\n        address secondaryUnderlying = ILinearPool(address(poolContext.basePool.secondaryToken)).getMainToken();\n        address tertiaryUnderlying = ILinearPool(address(poolContext.tertiaryToken)).getMainToken();\n\n        _validateSpotPrice({\n            poolContext: poolContext,\n            oracleContext: oracleContext,\n            context: strategyContext,\n            tokenIn: primaryUnderlying,\n            tokenOut: secondaryUnderlying,\n            tokenIndex: 1, // secondary index\n            balances: balances,\n            invariant: invariant\n        });\n\n        _validateSpotPrice({\n            poolContext: poolContext,\n            oracleContext: oracleContext,\n            context: strategyContext,\n            tokenIn: primaryUnderlying,\n            tokenOut: tertiaryUnderlying,\n            tokenIndex: 2, // tertiary index\n            balances: balances,\n            invariant: invariant\n        });\n    }\n\n    function _getVirtualSupply(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext\n    ) internal view returns (uint256 virtualSupply) {\n        // The initial amount of BPT pre-minted is _PREMINTED_TOKEN_BALANCE, and it goes entirely to the pool balance in\n        // the vault. So the virtualSupply (the amount of BPT supply in circulation) is defined as:\n        // virtualSupply = totalSupply() - _balances[_bptIndex]\n        virtualSupply = poolContext.basePool.basePool.pool.totalSupply() - oracleContext.bptBalance;\n    }\n\n    function _getScaledBalances(ThreeTokenPoolContext memory poolContext) \n        private pure returns (uint256[] memory amountsWithoutBpt) {\n        amountsWithoutBpt = new uint256[](3);\n        amountsWithoutBpt[0] = poolContext.basePool.primaryBalance * poolContext.basePool.primaryScaleFactor \n            / BalancerConstants.BALANCER_PRECISION;\n        amountsWithoutBpt[1] = poolContext.basePool.secondaryBalance * poolContext.basePool.secondaryScaleFactor\n            / BalancerConstants.BALANCER_PRECISION;\n        amountsWithoutBpt[2] = poolContext.tertiaryBalance * poolContext.tertiaryScaleFactor\n            / BalancerConstants.BALANCER_PRECISION;        \n    }\n\n    function _getVirtualSupplyAndBalances(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext\n    ) private view returns (uint256 virtualSupply, uint256[] memory amountsWithoutBpt) {\n        virtualSupply = _getVirtualSupply(poolContext, oracleContext);\n        amountsWithoutBpt = _getScaledBalances(poolContext);\n    }\n\n    function _getValidatedPoolData(\n        ThreeTokenPoolContext memory poolContext,\n        BoostedOracleContext memory oracleContext,\n        StrategyContext memory strategyContext\n    ) internal view returns (uint256 virtualSupply, uint256[] memory balances, uint256 invariant) {\n        (virtualSupply, balances) = \n            _getVirtualSupplyAndBalances(poolContext, oracleContext);\n\n        // Get the current and new invariants. Since we need a bigger new invariant, we round the current one up.\n        invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, balances, true // roundUp = true\n        );\n\n        // validate spot prices against oracle prices\n        _validateTokenPrices({\n            poolContext: poolContext,\n            oracleContext: oracleContext,\n            strategyContext: strategyContext,\n            balances: balances,\n            invariant: invariant\n        });\n    }\n\n    /// @notice Gets the time-weighted primary token balance for a given bptAmount\n    /// @dev Boosted pool can't use the Balancer oracle, using Chainlink instead\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param bptAmount amount of balancer pool lp tokens\n    /// @return primaryAmount primary token balance\n    function _getTimeWeightedPrimaryBalance(\n        ThreeTokenPoolContext memory poolContext,\n        BoostedOracleContext memory oracleContext,\n        StrategyContext memory strategyContext,\n        uint256 bptAmount\n    ) internal view returns (uint256 primaryAmount) {\n        (\n           uint256 virtualSupply, \n           uint256[] memory balances, \n           uint256 invariant\n        ) = _getValidatedPoolData(poolContext, oracleContext, strategyContext);\n\n        // NOTE: For Boosted 3 token pools, the LP token (BPT) is just another\n        // token in the pool. So, we first use _calcTokenOutGivenExactBptIn\n        // to calculate the value of 1 BPT. Then, we scale it to the BPT\n        // amount to get the value in terms of the primary currency.\n        // Use virtual total supply and zero swap fees for joins\n        uint256 linearBPTAmount = StableMath._calcTokenOutGivenExactBptIn({\n            amp: oracleContext.ampParam, \n            balances: balances, \n            tokenIndex: 0, // Primary index\n            bptAmountIn: BalancerConstants.BALANCER_PRECISION, // 1 BPT \n            bptTotalSupply: virtualSupply, \n            swapFeePercentage: oracleContext.swapFeePercentage, \n            currentInvariant: invariant\n        });\n\n        // Downscale BPT out\n        linearBPTAmount = linearBPTAmount * BalancerConstants.BALANCER_PRECISION / poolContext.basePool.primaryScaleFactor;\n\n        // Primary underlying pool = index 0\n        primaryAmount = _getUnderlyingMainOut(oracleContext.underlyingPools[0], linearBPTAmount);\n\n        uint256 primaryPrecision = 10 ** poolContext.basePool.primaryDecimals;\n        primaryAmount = (primaryAmount * bptAmount * primaryPrecision) / BalancerConstants.BALANCER_PRECISION_SQUARED;\n    }\n\n    function _approveBalancerTokens(ThreeTokenPoolContext memory poolContext, address bptSpender) internal {\n        poolContext.basePool._approveBalancerTokens(bptSpender);\n\n        IERC20(poolContext.tertiaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n\n        // For boosted pools, the tokens inside pool context are AaveLinearPool tokens.\n        // So, we need to approve the _underlyingToken (primary borrow currency) for trading.\n        ILinearPool underlyingPool = ILinearPool(poolContext.basePool.primaryToken);\n        address primaryUnderlyingAddress = BalancerUtils.getTokenAddress(underlyingPool.getMainToken());\n        IERC20(primaryUnderlyingAddress).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n    }\n\n    function _joinPoolExactTokensIn(ThreeTokenPoolContext memory context, uint256 primaryAmount, uint256 minBPT)\n        private returns (uint256 bptAmount) {\n        ILinearPool underlyingPool = ILinearPool(address(context.basePool.primaryToken));\n\n        // Swap underlyingToken for LinearPool BPT\n        uint256 linearPoolBPT = BalancerUtils._swapGivenIn({\n            poolId: underlyingPool.getPoolId(),\n            tokenIn: underlyingPool.getMainToken(),\n            tokenOut: address(underlyingPool),\n            amountIn: primaryAmount,\n            limit: 0 // slippage checked on the second swap\n        });\n\n        // Swap LinearPool BPT for Boosted BPT\n        bptAmount = BalancerUtils._swapGivenIn({\n            poolId: context.basePool.basePool.poolId,\n            tokenIn: address(underlyingPool),\n            tokenOut: address(context.basePool.basePool.pool), // Boosted pool\n            amountIn: linearPoolBPT,\n            limit: minBPT\n        });\n    }\n\n    function _exitPoolExactBPTIn(ThreeTokenPoolContext memory context, uint256 bptExitAmount, uint256 minPrimary)\n        private returns (uint256 primaryBalance) {\n        ILinearPool underlyingPool = ILinearPool(address(context.basePool.primaryToken));\n\n        // Swap Boosted BPT for LinearPool BPT\n        uint256 linearPoolBPT = BalancerUtils._swapGivenIn({\n            poolId: context.basePool.basePool.poolId,\n            tokenIn: address(context.basePool.basePool.pool), // Boosted pool\n            tokenOut: address(underlyingPool),\n            amountIn: bptExitAmount,\n            limit: 0 // slippage checked on the second swap\n        });\n\n        // Swap LinearPool BPT for underlyingToken\n        primaryBalance = BalancerUtils._swapGivenIn({\n            poolId: underlyingPool.getPoolId(),\n            tokenIn: address(underlyingPool),\n            tokenOut: underlyingPool.getMainToken(),\n            amountIn: linearPoolBPT,\n            limit: minPrimary\n        }); \n    }\n\n    function _deposit(\n        ThreeTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        BoostedOracleContext memory oracleContext,\n        uint256 deposit,\n        uint256 minBPT\n    ) internal returns (uint256 strategyTokensMinted) {\n        uint256 bptMinted = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: stakingContext,\n            oracleContext: oracleContext,\n            deposit: deposit,\n            minBPT: minBPT\n        });\n\n        strategyTokensMinted = strategyContext._convertBPTClaimToStrategyTokens(bptMinted);\n\n        strategyContext.vaultState.totalBPTHeld += bptMinted;\n        // Update global supply count\n        strategyContext.vaultState.totalStrategyTokenGlobal += strategyTokensMinted.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _redeem(\n        ThreeTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        uint256 strategyTokens,\n        uint256 minPrimary\n    ) internal returns (uint256 finalPrimaryBalance) {\n        uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokens);\n\n        if (bptClaim == 0) return 0;\n\n        finalPrimaryBalance = _unstakeAndExitPool({\n            stakingContext: stakingContext,\n            poolContext: poolContext,\n            bptClaim: bptClaim,\n            minPrimary: minPrimary\n        });\n\n        strategyContext.vaultState.totalBPTHeld -= bptClaim;\n        strategyContext.vaultState.totalStrategyTokenGlobal -= strategyTokens.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _joinPoolAndStake(\n        ThreeTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        BoostedOracleContext memory oracleContext,\n        uint256 deposit,\n        uint256 minBPT\n    ) internal returns (uint256 bptMinted) {\n        bptMinted = _joinPoolExactTokensIn(poolContext, deposit, minBPT);\n\n        // Check BPT threshold to make sure our share of the pool is\n        // below maxBalancerPoolShare\n        uint256 bptThreshold = strategyContext.vaultSettings._bptThreshold(\n            poolContext._getVirtualSupply(oracleContext)\n        );\n        uint256 bptHeldAfterJoin = strategyContext.vaultState.totalBPTHeld + bptMinted;\n        if (bptHeldAfterJoin > bptThreshold)\n            revert Errors.BalancerPoolShareTooHigh(bptHeldAfterJoin, bptThreshold);\n\n        // Transfer token to Aura protocol for boosted staking\n        bool success = stakingContext.auraBooster.deposit(stakingContext.auraPoolId, bptMinted, true); // stake = true\n        if (!success) revert Errors.StakeFailed();\n    }\n\n    function _unstakeAndExitPool(\n        ThreeTokenPoolContext memory poolContext,\n        AuraStakingContext memory stakingContext,\n        uint256 bptClaim,\n        uint256 minPrimary\n    ) internal returns (uint256 primaryBalance) {\n        // Withdraw BPT tokens back to the vault for redemption\n        bool success = stakingContext.auraRewardPool.withdrawAndUnwrap(bptClaim, false); // claimRewards = false\n        if (!success) revert Errors.UnstakeFailed();\n\n        primaryBalance = _exitPoolExactBPTIn(poolContext, bptClaim, minPrimary); \n    }\n\n    /// @notice We value strategy tokens in terms of the primary balance. The time weighted\n    /// primary balance is used in order to prevent pool manipulation.\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param strategyTokenAmount amount of strategy tokens\n    /// @return underlyingValue underlying value of strategy tokens\n    function _convertStrategyToUnderlying(\n        ThreeTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        BoostedOracleContext memory oracleContext,\n        uint256 strategyTokenAmount\n    ) internal view returns (int256 underlyingValue) {\n        uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokenAmount);\n        \n        underlyingValue = poolContext._getTimeWeightedPrimaryBalance(\n            oracleContext, strategyContext, bptClaim\n        ).toInt();\n    }\n}"
    },
    {
      "filename": "contracts/vaults/balancer/internal/pool/Boosted3TokenPoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {\n    ThreeTokenPoolContext,\n    TwoTokenPoolContext,\n    BoostedOracleContext,\n    UnderlyingPoolContext,\n    AuraStakingContext,\n    StrategyContext,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../../BalancerVaultTypes.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {BalancerUtils} from \"../pool/BalancerUtils.sol\";\nimport {Boosted3TokenPoolUtils} from \"../pool/Boosted3TokenPoolUtils.sol\";\nimport {StableMath} from \"../math/StableMath.sol\";\nimport {LinearMath} from \"../math/LinearMath.sol\";\nimport {AuraStakingUtils} from \"../staking/AuraStakingUtils.sol\";\nimport {StrategyUtils} from \"../strategy/StrategyUtils.sol\";\nimport {BalancerVaultStorage} from \"../BalancerVaultStorage.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\nimport {ILinearPool} from \"../../../../../interfaces/balancer/IBalancerPool.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\nimport {TwoTokenPoolUtils} from \"./TwoTokenPoolUtils.sol\";\nimport {FixedPoint} from \"../math/FixedPoint.sol\";\n\nlibrary Boosted3TokenPoolUtils {\n    using TypeConvert for uint256;\n    using FixedPoint for uint256;\n    using TypeConvert for int256;\n    using TokenUtils for IERC20;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using Boosted3TokenPoolUtils for ThreeTokenPoolContext;\n    using AuraStakingUtils for AuraStakingContext;\n    using StrategyUtils for StrategyContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n    using BalancerVaultStorage for StrategyVaultState;\n\n    // Preminted BPT is sometimes called Phantom BPT, as the preminted BPT (which is deposited in the Vault as balance of\n    // the Pool) doesn't belong to any entity until transferred out of the Pool. The Pool's arithmetic behaves as if it\n    // didn't exist, and the BPT total supply is not a useful value: we rely on the 'virtual supply' (how much BPT is\n    // actually owned by some entity) instead.\n    uint256 private constant _MAX_TOKEN_BALANCE = 2**(112) - 1;\n\n    function _getScaleFactor(\n        ThreeTokenPoolContext memory poolContext,\n        uint8 tokenIndex\n    ) private pure returns(uint256 scaleFactor) {\n        if (tokenIndex == 0) {\n            scaleFactor = poolContext.basePool.primaryScaleFactor;\n        } else if (tokenIndex == 1) {\n            scaleFactor = poolContext.basePool.secondaryScaleFactor;\n        } else if (tokenIndex == 2) {\n            scaleFactor = poolContext.tertiaryScaleFactor;\n        }\n    }\n\n    function _getPrecision(\n        ThreeTokenPoolContext memory poolContext,\n        uint8 tokenIndex\n    ) private pure returns(uint256 precision) {\n        if (tokenIndex == 0) {\n            precision = 10**poolContext.basePool.primaryDecimals;\n        } else if (tokenIndex == 1) {\n            precision = 10**poolContext.basePool.secondaryDecimals;\n        } else if (tokenIndex == 2) {\n            precision = 10**poolContext.tertiaryDecimals;\n        }\n    }\n\n    /// @notice Spot price is always expressed in terms of the primary currency\n    function _getSpotPrice(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext,\n        uint8 tokenIndex\n    ) internal pure returns (uint256 spotPrice) {\n        require(tokenIndex < 3);  /// @dev invalid token index\n\n        // Exchange rate of primary currency = 1\n        if (tokenIndex == 0) {\n            return BalancerConstants.BALANCER_PRECISION;\n        }\n\n        uint256[] memory balances = _getScaledBalances(poolContext);\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, balances, true // roundUp = true\n        );\n        spotPrice = _getSpotPriceWithInvariant({\n            poolContext: poolContext,\n            oracleContext: oracleContext,\n            balances: balances, \n            invariant: invariant,\n            tokenIndex: tokenIndex\n        });\n    }\n\n    function _getUnderlyingBPTOut(\n        UnderlyingPoolContext memory pool,\n        uint256 mainIn\n    ) private pure returns (uint256) {\n        uint256 scaledMainBalance = pool.mainBalance * pool.mainScaleFactor /\n            BalancerConstants.BALANCER_PRECISION;\n        uint256 scaledWrappedBalance = pool.wrappedBalance * pool.wrappedScaleFactor /\n            BalancerConstants.BALANCER_PRECISION;\n\n        // Convert from linear pool BPT to primary Amount\n        return LinearMath._calcBptOutPerMainIn({\n            mainIn: mainIn,"
    }
  ]
}