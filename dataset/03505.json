{
  "Title": "[L17] Lookup key strings are not centrally defined",
  "Content": "Known, legitimate contracts are tracked in the [`addresses` mapping](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/resolver/Lib_AddressManager.sol#L26) of the `Lib_AddressManager` contract. New entries can be added by a privileged address via the [`setAddress` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/resolver/Lib_AddressManager.sol#L38), and the [`getAddress` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/resolver/Lib_AddressManager.sol#L58) function acts as a public getter to query the registry providing a string-type key. While this registry is used by several different contracts to get the addresses of registered contracts, the strings used as keys to query the registry are not centrally defined. The identified strings are:\n\n\n* `\"OVM_L2MessageRelayer\"`\n* `\"OVM_L2BatchMessageRelayer\"`\n* `\"OVM_StateCommitmentChain\"`\n* `\"OVM_L2CrossDomainMessenger\"`\n* `\"OVM_CanonicalTransactionChain\"`\n* `\"Proxy__OVM_L1CrossDomainMessenger\"`\n* `\"OVM_L1MessageSender\"`\n* `\"OVM_L1CrossDomainMessenger\"`\n* `\"OVM_L2ToL1MessagePasser\"`\n* `\"OVM_ChainStorageContainer:CTC:batches\"`\n* `\"OVM_ChainStorageContainer:CTC:queue\"`\n* `\"OVM_Sequencer\"`\n* `\"OVM_ExecutionManager\"`\n* `\"OVM_DecompressionPrecompileAddress\"`\n* `\"OVM_ChainStorageContainer:SCC:batches\"`\n* `\"OVM_BondManager\"`\n* `\"OVM_StateCommitmentChain\"`\n* `\"OVM_CanonicalTransactionChain\"`\n* `\"OVM_FraudVerifier\"`\n* `\"OVM_Proposer\"`\n* `\"OVM_SafetyChecker\"`\n* `\"OVM_StateTransitionerFactory\"`\n\n\nWhile this issue does not pose an immediate security risk, the approach taken can be considered error-prone and difficult to maintain. Moreover, it is worth noting that the current code base has a number of inconsistencies in how these keys are referenced, as described in **“[N06] Inconsistent name resolution”**.\n\n\nConsider factoring out all mentioned constant strings to a single library, which can be then imported as needed. This will ease maintenance and make the code more resilient to future changes.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/optimistic-ethereum/libraries/resolver/Lib_AddressManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/* Contract Imports */\nimport { Ownable } from \"./Lib_Ownable.sol\";\n\n/**\n * @title Lib_AddressManager\n */\ncontract Lib_AddressManager is Ownable {\n\n    /**********\n     * Events *\n     **********/\n\n    event AddressSet(\n        string _name,\n        address _newAddress\n    );\n\n\n    /*************\n     * Variables *\n     *************/\n\n    mapping (bytes32 => address) private addresses;\n\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Changes the address associated with a particular name.\n     * @param _name String name to associate an address with.\n     * @param _address Address to associate with the name.\n     */\n    function setAddress(\n        string memory _name,\n        address _address\n    )\n        public\n        onlyOwner\n    {\n        addresses[_getNameHash(_name)] = _address;\n\n        emit AddressSet(\n            _name,\n            _address\n        );\n    }\n\n    /**\n     * Retrieves the address associated with a given name.\n     * @param _name Name to retrieve an address for.\n     * @return Address associated with the given name.\n     */\n    function getAddress(\n        string memory _name\n    )\n        public\n        view\n        returns (\n            address\n        )\n    {\n        return addresses[_getNameHash(_name)];\n    }\n\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Computes the hash of a name.\n     * @param _name Name to compute a hash for.\n     * @return Hash of the given name.\n     */\n    function _getNameHash(\n        string memory _name\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        return keccak256(abi.encodePacked(_name));\n    }\n}"
    }
  ]
}