{
  "Title": "[L-11] Lack of Input Validation",
  "Content": "\nFor defence-in-depth purpose, it is recommended to perform additional validation against the amount that the user is attempting to deposit, mint, withdraw and redeem to ensure that the submitted amount is valid.\n\n[OpenZeppelinTokenizedVault.sol#L9](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/7c75b8aa89073376fb67d78a40f6d69331092c94/contracts/token/ERC20/extensions/ERC20TokenizedVault.sol#L95)\n\n\n```diff\nsrc/PirexGmx.sol:\n  429       */\n  430:     function depositGmx(uint256 amount, address receiver)\n  431:         external\n  432:         whenNotPaused\n  433:         nonReentrant\n  434:         returns (\n  435:             uint256,\n  436:             uint256,\n  437:             uint256\n  438:         )\n  439:     {\n+\t         require(amount <= maxDeposit(receiver), \"deposit more than max\");\n```\n\n```diff\nsrc/vaults/PirexERC4626.sol:\n  79  \n  80:     function mint(uint256 shares, address receiver)\n  81:         public\n  82:         virtual\n  83:         returns (uint256 assets)\n  84:     {\n+ \t       require(shares <= maxMint(receiver), \"mint more than max\");\n\n```\n\n```diff\nsrc/vaults/AutoPxGlp.sol:\n  438:     function withdraw(\n  439:         uint256 assets,\n  440:         address receiver,\n  441:         address owner\n  442:     ) public override returns (uint256 shares) {\n+                require(assets <= maxWithdraw(owner), \"withdraw more than max\");\n\nsrc/vaults/AutoPxGmx.sol:\n  317:     function withdraw(\n  318:         uint256 assets,\n  319:         address receiver,\n  320:         address owner\n  321:     ) public override returns (uint256 shares) {\n+               require(assets <= maxWithdraw(owner), \"withdraw more than max\");\n```\n\n\n```diff\nsrc/vaults/AutoPxGlp.sol:\n  450       */\n  451:     function redeem(\n  452:         uint256 shares,\n  453:         address receiver,\n  454:         address owner\n  455:     ) public override returns (uint256 assets) {\n+               require(shares <= maxRedeem(owner), \"redeem more than max\");\n\nsrc/vaults/AutoPxGmx.sol:\n  340  \n  341:     function redeem(\n  342:         uint256 shares,\n  343:         address receiver,\n  344:         address owner\n  345:     ) public override returns (uint256 assets) {\n+                require(shares <= maxRedeem(owner), \"redeem more than max\");\n```\n\n## Non-Critical Issues Summary\n| Number |Issues Details|Context|\n|:--:|:-------|:--:|\n| [N-01] |Insufficient coverage|1|\n| [N-02] |Not using the named return variables anywhere in the function is confusing  |1 |\n| [N-03] |Same Constant redefined elsewhere| 4 |\n| [N-04] |Omissions in Events| 8 | \n| [N-05] |Add parameter to Event-Emit | 1 |\n| [N-06] |NatSpec is missing  | 1 |\n| [N-07] |Use `require` instead of `assert` | 1 |\n| [N-08] |Implement some type of version counter that will be incremented automatically for contract upgrades | 1 |\n| [N-09] |Constant values such as a call to keccak256(), should used to immutable rather than constant | 2 |\n| [N-10] |For functions, follow Solidity standard naming conventions | 4  |\n| [N-11] |Mark visibility of initialize(...) functions as ``external``| 1 |\n| [N-12] |No same value input control | 8 |\n| [N-13] |Include ``return parameters`` in _NatSpec comments_ | All |\n| [N-14] |`0 address` check for ` asset ` | 1 |\n| [N-15] |Use a single file for all system-wide constants| 6 |\n| [N-16] |`Function writing` that does not comply with the `Solidity Style Guide`| All |\n| [N-17] |Missing Upgrade Path for `PirexRewards` Implementation| 1 |\n| [N-18] | No need `assert` check in `_computeAssetAmounts()` | 1 |\n| [N-19] | Lack of event emission after critical `initialize()` functions | 1 |\n| [N-20] | Add a timelock to critical functions | 11 |\n\nTotal 19 issues\n\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-11-redacted-cartel-contest",
  "Code": [
    {
      "filename": "contracts/token/ERC20/extensions/ERC20TokenizedVault.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../utils/SafeERC20.sol\";\nimport \"../../../interfaces/IERC4626.sol\";\nimport \"../../../utils/math/Math.sol\";\n\n/**\n * @dev Implementation of the ERC4626 \"Tokenized Vault Standard\" as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[EIP-4626].\n *\n * This extension allows the minting and burning of \"shares\" (represented using the ERC20 inheritance) in exchange for\n * underlying \"assets\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\n * the ERC20 standard. Any additional extensions included along it would affect the \"shares\" token represented by this\n * contract and not the \"assets\" token which is an independent contract.\n *\n * _Available since v4.7._\n */\nabstract contract ERC20TokenizedVault is ERC20, IERC4626 {\n    using Math for uint256;\n\n    IERC20Metadata private immutable _asset;\n\n    /**\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC20 or ERC777).\n     */\n    constructor(IERC20Metadata asset_) {\n        _asset = asset_;\n    }\n\n    /** @dev See {IERC4262-asset} */\n    function asset() public view virtual override returns (address) {\n        return address(_asset);\n    }\n\n    /** @dev See {IERC4262-totalAssets} */\n    function totalAssets() public view virtual override returns (uint256) {\n        return _asset.balanceOf(address(this));\n    }\n\n    /** @dev See {IERC4262-convertToShares} */\n    function convertToShares(uint256 assets) public view virtual override returns (uint256 shares) {\n        return _convertToShares(assets, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4262-convertToAssets} */\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256 assets) {\n        return _convertToAssets(shares, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4262-maxDeposit} */\n    function maxDeposit(address) public view virtual override returns (uint256) {\n        return _isVaultCollateralized() ? type(uint256).max : 0;\n    }\n\n    /** @dev See {IERC4262-maxMint} */\n    function maxMint(address) public view virtual override returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4262-maxWithdraw} */\n    function maxWithdraw(address owner) public view virtual override returns (uint256) {\n        return _convertToAssets(balanceOf(owner), Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4262-maxRedeem} */\n    function maxRedeem(address owner) public view virtual override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4262-previewDeposit} */\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4262-previewMint} */\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Up);\n    }\n\n    /** @dev See {IERC4262-previewWithdraw} */\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Up);\n    }\n\n    /** @dev See {IERC4262-previewRedeem} */\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4262-deposit} */\n    function deposit(uint256 assets, address receiver) public virtual override returns (uint256) {\n        require(assets <= maxDeposit(receiver), \"ERC20TokenizedVault: deposit more than max\");\n\n        uint256 shares = previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4262-mint} */\n    function mint(uint256 shares, address receiver) public virtual override returns (uint256) {\n        require(shares <= maxMint(receiver), \"ERC20TokenizedVault: mint more than max\");\n\n        uint256 assets = previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }\n\n    /** @dev See {IERC4262-withdraw} */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        require(assets <= maxWithdraw(owner), \"ERC20TokenizedVault: withdraw more than max\");\n\n        uint256 shares = previewWithdraw(assets);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4262-redeem} */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        require(shares <= maxRedeem(owner), \"ERC20TokenizedVault: redeem more than max\");\n\n        uint256 assets = previewRedeem(shares);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @dev Internal convertion function (from assets to shares) with support for rounding direction\n     *\n     * Will revert if assets > 0, totalSupply > 0 and totalAssets = 0. That corresponds to a case where any asset\n     * would represent an infinite amout of shares.\n     */\n    function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        return\n            (assets == 0 || supply == 0)\n                ? assets.mulDiv(10**decimals(), 10**_asset.decimals(), rounding)\n                : assets.mulDiv(supply, totalAssets(), rounding);\n    }\n\n    /**\n     * @dev Internal convertion function (from shares to assets) with support for rounding direction\n     */\n    function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        return\n            (supply == 0)\n                ? shares.mulDiv(10**_asset.decimals(), 10**decimals(), rounding)\n                : shares.mulDiv(totalAssets(), supply, rounding);\n    }\n\n    /**\n     * @dev Deposit/mint common workflow\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) private {\n        // If _asset is ERC777, `transferFrom` can trigger a reenterancy BEFORE the transfer happens through the\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\n        // assets are transfered and before the shares are minted, which is a valid state.\n        // slither-disable-next-line reentrancy-no-eth\n        SafeERC20.safeTransferFrom(_asset, caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Withdraw/redeem common workflow\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) private {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // If _asset is ERC777, `transfer` can trigger trigger a reentrancy AFTER the transfer happens through the\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\n        // shares are burned and after the assets are transfered, which is a valid state.\n        _burn(owner, shares);\n        SafeERC20.safeTransfer(_asset, receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }\n\n    function _isVaultCollateralized() private view returns (bool) {\n        return totalAssets() > 0 || totalSupply() == 0;\n    }\n}"
    }
  ]
}