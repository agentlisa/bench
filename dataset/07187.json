{
  "Title": "[M-01] Incorrect Encoding of Order Hashes",
  "Content": "\n[contracts/lib/ConsiderationEncoder.sol#L569-L574](https://github.com/ProjectOpenSea/seaport/blob/5de7302bc773d9821ba4759e47fc981680911ea0/contracts/lib/ConsiderationEncoder.sol#L569-L574)\n\nThe order hashes are incorrectly encoded during the `_encodeOrderHashes` mechanism, causing functions such as `_encodeRatifyOrder` and `_encodeValidateOrder` to misbehave.\n\n### Proof of Concept\n\nThe order hashes encoding mechanism appears to be incorrect as the instructions `srcLength.next().offset(headAndTailSize)` will cause the pointer to move to the end of the array (i.e. `next()` skips the array's `length` bitwise entry and `offset(headAndTailSize)` causes the pointer to point right after the last element). In turn, this will cause the `0x04` precompile within `MemoryPointerLib::copy` to handle the data incorrectly and attempt to copy data from the `srcLength.next().offset(headAndTailSize)` pointer onwards which will be un-allocated space and thus lead to incorrect bytes being copied.\n\n### Tools Used\n\nManual inspection of the codebase, documentation of the ETH precompiles, and the Solidity compiler documentation.\n\n### Recommended Mitigation Steps\n\nWe advise the `offset` instruction to be omitted as the current implementation will copy from unsafe memory space, causing data corruption in the worst-case scenario and incorrect order hashes being specified in the encoded payload. As an additional point, the `_encodeOrderHashes` will fail execution if the array of order hashes is empty as a `headAndTailSize` of `0` will cause the `MemoryPointerLib::copy` function to fail as the precompile would yield a `returndatasize()` of `0`.\n\n**[0age (OpenSea) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-01-opensea-findings/issues/61#issuecomment-1402842707):**\n > This is a confirmed issue (though categorizing it as high-risk seems unfair. At worst, it just means that zones and contract offerers wouldn't be able to rely on the orderHashes array) and has been fixed here: https://github.com/ProjectOpenSea/seaport/pull/918\n\n**[hickuphh3 (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-01-opensea-findings/issues/61#issuecomment-1403148862):**\n > Agree that high severity is overstated. Given that it would affect upstream functions (`_encodeRatifyOrder` and `_encodeValidateOrder` is called by a few other functions like `_assertRestrictedAdvancedOrderValidity()`), medium severity would be more appropriate.\n> \n> > 2 â€” Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-opensea-seaport-12-contest",
  "Code": [
    {
      "filename": "contracts/lib/ConsiderationEncoder.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./ConsiderationConstants.sol\";\n\nimport {\n    BasicOrderParameters,\n    Order,\n    CriteriaResolver,\n    AdvancedOrder,\n    FulfillmentComponent,\n    Execution,\n    Fulfillment,\n    OrderComponents,\n    OrderParameters,\n    SpentItem,\n    ReceivedItem\n} from \"./ConsiderationStructs.sol\";\n\nimport \"../helpers/PointerLibraries.sol\";\n\ncontract ConsiderationEncoder {\n    /**\n     * @dev Takes a bytes array and casts it to a memory pointer.\n     *\n     * @param obj A bytes array in memory.\n     *\n     * @return ptr A memory pointer to the start of the bytes array in memory.\n     */\n    function toMemoryPointer(\n        bytes memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Takes an array of bytes32 types and casts it to a memory pointer.\n     *\n     * @param obj An array of bytes32 types in memory.\n     *\n     * @return ptr A memory pointer to the start of the array of bytes32 types\n     *             in memory.\n     */\n    function toMemoryPointer(\n        bytes32[] memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Takes a bytes array in memory and copies it to a new location in\n     *      memory.\n     *\n     * @param src A memory pointer referencing the bytes array to be copied (and\n     *            pointing to the length of the bytes array).\n     * @param src A memory pointer referencing the location in memory to copy\n     *            the bytes array to (and pointing to the length of the copied\n     *            bytes array).\n     *\n     * @return size The size of the bytes array.\n     */\n    function _encodeBytes(\n        MemoryPointer src,\n        MemoryPointer dst\n    ) internal view returns (uint256 size) {\n        unchecked {\n            // Mask the length of the bytes array to protect against overflow\n            // and round up to the nearest word.\n            size = (src.readUint256() + AlmostTwoWords) & OnlyFullWordMask;\n\n            // Copy the bytes array to the new memory location.\n            src.copy(dst, size);\n        }\n    }\n\n    /**\n     * @dev Takes an OrderParameters struct and a context bytes array in memory\n     *      and encodes it as `generateOrder` calldata.\n     *\n     * @param orderParameters The OrderParameters struct used to construct the\n     *                        encoded `generateOrder` calldata.\n     * @param context         The context bytes array used to construct the\n     *                        encoded `generateOrder` calldata.\n     *\n     * @return dst  A memory pointer referencing the encoded `generateOrder`\n     *              calldata.\n     * @return size The size of the bytes array.\n     */\n    function _encodeGenerateOrder(\n        OrderParameters memory orderParameters,\n        bytes memory context\n    ) internal view returns (MemoryPointer dst, uint256 size) {\n        // Get the memory pointer for the OrderParameters struct.\n        MemoryPointer src = orderParameters.toMemoryPointer();\n\n        // Get free memory pointer to write calldata to.\n        dst = getFreeMemoryPointer();\n\n        // Write generateOrder selector and get pointer to start of calldata.\n        dst.write(generateOrder_selector);\n        dst = dst.offset(generateOrder_selector_offset);\n\n        // Get pointer to the beginning of the encoded data.\n        MemoryPointer dstHead = dst.offset(generateOrder_head_offset);\n\n        // Write `fulfiller` to calldata.\n        dstHead.write(msg.sender);\n\n        // Initialize tail offset, used to populate the minimumReceived array.\n        uint256 tailOffset = generateOrder_base_tail_offset;\n\n        // Write offset to minimumReceived.\n        dstHead.offset(generateOrder_minimumReceived_head_offset).write(\n            tailOffset\n        );\n\n        // Get memory pointer to `orderParameters.offer.length`.\n        MemoryPointer srcOfferPointer = src\n            .offset(OrderParameters_offer_head_offset)\n            .readMemoryPointer();\n\n        // Encode the offer array as a `SpentItem[]`.\n        uint256 minimumReceivedSize = _encodeSpentItems(\n            srcOfferPointer,\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment tail offset, now used to populate maximumSpent array.\n            tailOffset += minimumReceivedSize;\n        }\n\n        // Write offset to maximumSpent.\n        dstHead.offset(generateOrder_maximumSpent_head_offset).write(\n            tailOffset\n        );\n\n        // Get memory pointer to `orderParameters.consideration.length`.\n        MemoryPointer srcConsiderationPointer = src\n            .offset(OrderParameters_consideration_head_offset)\n            .readMemoryPointer();\n\n        // Encode the consideration array as a `SpentItem[]`.\n        uint256 maximumSpentSize = _encodeSpentItems(\n            srcConsiderationPointer,\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment tail offset, now used to populate context array.\n            tailOffset += maximumSpentSize;\n        }\n\n        // Write offset to context.\n        dstHead.offset(generateOrder_context_head_offset).write(tailOffset);\n\n        // Get memory pointer to context.\n        MemoryPointer srcContext = toMemoryPointer(context);\n\n        // Encode context as a bytes array.\n        uint256 contextSize = _encodeBytes(\n            srcContext,\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment the tail offset, now used to determine final size.\n            tailOffset += contextSize;\n\n            // Derive the final size by including the selector.\n            size = Selector_length + tailOffset;\n        }\n    }\n\n    /**\n     * @dev Takes an order hash (e.g. offerer + contract nonce in the case of\n     *      contract orders), OrderParameters struct, context bytes array, and\n     *      array of order hashes for each order included as part of the current\n     *      fulfillment and encodes it as `ratifyOrder` calldata.\n     *\n     * @param orderHash       The order hash (e.g. offerer + contract nonce).\n     * @param orderParameters The OrderParameters struct used to construct the\n     *                        encoded `ratifyOrder` calldata.\n     * @param context         The context bytes array used to construct the\n     *                        encoded `ratifyOrder` calldata.\n     * @param orderHashes     An array of bytes32 values representing the order\n     *                        hashes of all orders included as part of the\n     *                        current fulfillment.\n     *\n     * @return dst  A memory pointer referencing the encoded `ratifyOrder`\n     *              calldata.\n     * @return size The size of the bytes array.\n     */\n    function _encodeRatifyOrder(\n        bytes32 orderHash, // e.g. offerer + contract nonce\n        OrderParameters memory orderParameters,\n        bytes memory context, // encoded based on the schemaID\n        bytes32[] memory orderHashes\n    ) internal view returns (MemoryPointer dst, uint256 size) {\n        // Get free memory pointer to write calldata to. This isn't allocated as\n        // it is only used for a single function call.\n        dst = getFreeMemoryPointer();\n\n        // Write ratifyOrder selector and get pointer to start of calldata.\n        dst.write(ratifyOrder_selector);\n        dst = dst.offset(ratifyOrder_selector_offset);\n\n        // Get pointer to the beginning of the encoded data.\n        MemoryPointer dstHead = dst.offset(ratifyOrder_head_offset);\n\n        // Write contractNonce to calldata.\n        dstHead.offset(ratifyOrder_contractNonce_offset).write(\n            uint96(uint256(orderHash))\n        );\n\n        // Initialize tail offset, used to populate the offer array.\n        uint256 tailOffset = ratifyOrder_base_tail_offset;\n        MemoryPointer src = orderParameters.toMemoryPointer();\n\n        // Write offset to `offer`.\n        dstHead.write(tailOffset);\n\n        // Get memory pointer to `orderParameters.offer.length`.\n        MemoryPointer srcOfferPointer = src\n            .offset(OrderParameters_offer_head_offset)\n            .readMemoryPointer();\n\n        // Encode the offer array as a `SpentItem[]`.\n        uint256 offerSize = _encodeSpentItems(\n            srcOfferPointer,\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment tail offset, now used to populate consideration array.\n            tailOffset += offerSize;\n        }\n\n        // Write offset to consideration.\n        dstHead.offset(ratifyOrder_consideration_head_offset).write(tailOffset);\n\n        // Get pointer to `orderParameters.consideration.length`.\n        MemoryPointer srcConsiderationPointer = src\n            .offset(OrderParameters_consideration_head_offset)\n            .readMemoryPointer();\n\n        // Encode the consideration array as a `ReceivedItem[]`.\n        uint256 considerationSize = _encodeConsiderationAsReceivedItems(\n            srcConsiderationPointer,\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment tail offset, now used to populate context array.\n            tailOffset += considerationSize;\n        }\n\n        // Write offset to context.\n        dstHead.offset(ratifyOrder_context_head_offset).write(tailOffset);\n\n        // Encode context.\n        uint256 contextSize = _encodeBytes(\n            toMemoryPointer(context),\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment tail offset, now used to populate orderHashes array.\n            tailOffset += contextSize;\n        }\n\n        // Write offset to orderHashes.\n        dstHead.offset(ratifyOrder_orderHashes_head_offset).write(tailOffset);\n\n        // Encode orderHashes.\n        uint256 orderHashesSize = _encodeOrderHashes(\n            toMemoryPointer(orderHashes),\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment the tail offset, now used to determine final size.\n            tailOffset += orderHashesSize;\n\n            // Derive the final size by including the selector.\n            size = Selector_length + tailOffset;\n        }\n    }\n\n    /**\n     * @dev Takes an order hash, OrderParameters struct, extraData bytes array,\n     *      and array of order hashes for each order included as part of the\n     *      current fulfillment and encodes it as `validateOrder` calldata.\n     *      Note that future, new versions of this contract may end up writing\n     *      to a memory region that might have been potentially dirtied by the\n     *      accumulator. Since the book-keeping for the accumulator does not\n     *      update the free memory pointer, it will be necessary to ensure that\n     *      all bytes in the memory in the range [dst, dst+size) are fully\n     *      updated/written to in this function.\n     *\n     * @param orderHash       The order hash.\n     * @param orderParameters The OrderParameters struct used to construct the\n     *                        encoded `validateOrder` calldata.\n     * @param extraData       The extraData bytes array used to construct the\n     *                        encoded `validateOrder` calldata.\n     * @param orderHashes     An array of bytes32 values representing the order\n     *                        hashes of all orders included as part of the\n     *                        current fulfillment.\n     *\n     * @return dst  A memory pointer referencing the encoded `validateOrder`\n     *              calldata.\n     * @return size The size of the bytes array.\n     */\n    function _encodeValidateOrder(\n        bytes32 orderHash,\n        OrderParameters memory orderParameters,\n        bytes memory extraData,\n        bytes32[] memory orderHashes\n    ) internal view returns (MemoryPointer dst, uint256 size) {\n        // Get free memory pointer to write calldata to. This isn't allocated as\n        // it is only used for a single function call.\n        dst = getFreeMemoryPointer();\n\n        // Write validateOrder selector and get pointer to start of calldata.\n        dst.write(validateOrder_selector);\n        dst = dst.offset(validateOrder_selector_offset);\n\n        // Get pointer to the beginning of the encoded data.\n        MemoryPointer dstHead = dst.offset(validateOrder_head_offset);\n\n        // Write offset to zoneParameters to start of calldata.\n        dstHead.write(validateOrder_zoneParameters_offset);\n\n        // Reuse `dstHead` as pointer to zoneParameters.\n        dstHead = dstHead.offset(validateOrder_zoneParameters_offset);\n\n        // Write orderHash and fulfiller to zoneParameters.\n        dstHead.writeBytes32(orderHash);\n        dstHead.offset(ZoneParameters_fulfiller_offset).write(msg.sender);\n\n        // Get the memory pointer to the order paramaters struct.\n        MemoryPointer src = orderParameters.toMemoryPointer();\n\n        // Copy offerer, startTime, endTime and zoneHash to zoneParameters.\n        dstHead.offset(ZoneParameters_offerer_offset).write(src.readUint256());\n        dstHead.offset(ZoneParameters_startTime_offset).write(\n            src.offset(OrderParameters_startTime_offset).readUint256()\n        );\n        dstHead.offset(ZoneParameters_endTime_offset).write(\n            src.offset(OrderParameters_endTime_offset).readUint256()\n        );\n        dstHead.offset(ZoneParameters_zoneHash_offset).write(\n            src.offset(OrderParameters_zoneHash_offset).readUint256()\n        );\n\n        // Initialize tail offset, used to populate the offer array.\n        uint256 tailOffset = ZoneParameters_base_tail_offset;\n\n        // Write offset to `offer`.\n        dstHead.offset(ZoneParameters_offer_head_offset).write(tailOffset);\n\n        // Get pointer to `orderParameters.offer.length`.\n        MemoryPointer srcOfferPointer = src\n            .offset(OrderParameters_offer_head_offset)\n            .readMemoryPointer();\n\n        // Encode the offer array as a `SpentItem[]`.\n        uint256 offerSize = _encodeSpentItems(\n            srcOfferPointer,\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment tail offset, now used to populate consideration array.\n            tailOffset += offerSize;\n        }\n\n        // Write offset to consideration.\n        dstHead.offset(ZoneParameters_consideration_head_offset).write(\n            tailOffset\n        );\n\n        // Get pointer to `orderParameters.consideration.length`.\n        MemoryPointer srcConsiderationPointer = src\n            .offset(OrderParameters_consideration_head_offset)\n            .readMemoryPointer();\n\n        // Encode the consideration array as a `ReceivedItem[]`.\n        uint256 considerationSize = _encodeConsiderationAsReceivedItems(\n            srcConsiderationPointer,\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment tail offset, now used to populate extraData array.\n            tailOffset += considerationSize;\n        }\n\n        // Write offset to extraData.\n        dstHead.offset(ZoneParameters_extraData_head_offset).write(tailOffset);\n        // Copy extraData.\n        uint256 extraDataSize = _encodeBytes(\n            toMemoryPointer(extraData),\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment tail offset, now used to populate orderHashes array.\n            tailOffset += extraDataSize;\n        }\n\n        // Write offset to orderHashes.\n        dstHead.offset(ZoneParameters_orderHashes_head_offset).write(\n            tailOffset\n        );\n\n        // Encode the order hashes array.\n        uint256 orderHashesSize = _encodeOrderHashes(\n            toMemoryPointer(orderHashes),\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment the tail offset, now used to determine final size.\n            tailOffset += orderHashesSize;\n\n            // Derive final size including selector and ZoneParameters pointer.\n            size = ZoneParameters_selectorAndPointer_length + tailOffset;\n        }\n    }\n\n    /**\n     * @dev Takes an order hash and BasicOrderParameters struct (from calldata)\n     *      and encodes it as `validateOrder` calldata.\n     *\n     * @param orderHash  The order hash.\n     * @param parameters The BasicOrderParameters struct used to construct the\n     *                   encoded `validateOrder` calldata.\n     *\n     * @return dst  A memory pointer referencing the encoded `validateOrder`\n     *              calldata.\n     * @return size The size of the bytes array.\n     */\n    function _encodeValidateBasicOrder(\n        bytes32 orderHash,\n        BasicOrderParameters calldata parameters\n    ) internal view returns (MemoryPointer dst, uint256 size) {\n        // Get free memory pointer to write calldata to. This isn't allocated as\n        // it is only used for a single function call.\n        dst = getFreeMemoryPointer();\n\n        // Write validateOrder selector and get pointer to start of calldata.\n        dst.write(validateOrder_selector);\n        dst = dst.offset(validateOrder_selector_offset);\n\n        // Get pointer to the beginning of the encoded data.\n        MemoryPointer dstHead = dst.offset(validateOrder_head_offset);\n\n        // Write offset to zoneParameters to start of calldata.\n        dstHead.write(validateOrder_zoneParameters_offset);\n\n        // Reuse `dstHead` as pointer to zoneParameters.\n        dstHead = dstHead.offset(validateOrder_zoneParameters_offset);\n\n        // Write offerer, orderHash and fulfiller to zoneParameters.\n        dstHead.writeBytes32(orderHash);\n        dstHead.offset(ZoneParameters_fulfiller_offset).write(msg.sender);\n        dstHead.offset(ZoneParameters_offerer_offset).write(parameters.offerer);\n\n        // Copy startTime, endTime and zoneHash to zoneParameters.\n        CalldataPointer.wrap(BasicOrder_startTime_cdPtr).copy(\n            dstHead.offset(ZoneParameters_startTime_offset),\n            BasicOrder_startTimeThroughZoneHash_size\n        );\n\n        // Initialize tail offset, used for the offer + consideration arrays.\n        uint256 tailOffset = ZoneParameters_base_tail_offset;\n\n        // Write offset to offer from event data into target calldata.\n        dstHead.offset(ZoneParameters_offer_head_offset).write(tailOffset);\n\n        unchecked {\n            // Write consideration offset next (located 5 words after offer).\n            dstHead.offset(ZoneParameters_consideration_head_offset).write(\n                tailOffset + BasicOrder_common_params_size\n            );\n\n            // Retrieve the offset to the length of additional recipients.\n            uint256 additionalRecipientsLength = CalldataPointer\n                .wrap(BasicOrder_additionalRecipients_length_cdPtr)\n                .readUint256();\n\n            // Derive offset to event data using base offset & total recipients.\n            uint256 offerDataOffset = OrderFulfilled_offer_length_baseOffset +\n                additionalRecipientsLength *\n                OneWord;\n\n            // Derive size of offer and consideration data.\n            // 2 words (lengths) + 4 (offer data) + 5 (consideration 1) + 5 * ar\n            uint256 offerAndConsiderationSize = OrderFulfilled_baseDataSize +\n                (additionalRecipientsLength * ReceivedItem_size);\n\n            // Copy offer and consideration data from event data to calldata.\n            MemoryPointer.wrap(offerDataOffset).copy(\n                dstHead.offset(tailOffset),\n                offerAndConsiderationSize\n            );\n\n            // Increment tail offset, now used to populate extraData array.\n            tailOffset += offerAndConsiderationSize;\n        }\n\n        // Write empty bytes for extraData.\n        dstHead.offset(ZoneParameters_extraData_head_offset).write(tailOffset);\n        dstHead.offset(tailOffset).write(0);\n\n        unchecked {\n            // Increment tail offset, now used to populate orderHashes array.\n            tailOffset += OneWord;\n        }\n\n        // Write offset to orderHashes.\n        dstHead.offset(ZoneParameters_orderHashes_head_offset).write(\n            tailOffset\n        );\n\n        // Write length = 1 to the orderHashes array.\n        dstHead.offset(tailOffset).write(1);\n\n        unchecked {\n            // Write the single order hash to the orderHashes array.\n            dstHead.offset(tailOffset + OneWord).writeBytes32(orderHash);\n\n            // Final size: selector, ZoneParameters pointer, orderHashes & tail.\n            size = ZoneParameters_basicOrderFixedElements_length + tailOffset;\n        }\n    }\n\n    /**\n     * @dev Takes a memory pointer to an array of bytes32 values representing\n     *      the order hashes included as part of the fulfillment and a memory\n     *      pointer to a location to copy it to, and copies the source data to\n     *      the destination in memory.\n     *\n     * @param srcLength A memory pointer referencing the order hashes array to\n     *                  be copied (and pointing to the length of the array).\n     * @param dstLength A memory pointer referencing the location in memory to\n     *                  copy the orderHashes array to (and pointing to the\n     *                  length of the copied array).\n     *\n     * @return size The size of the order hashes array (including the length).\n     */\n    function _encodeOrderHashes(\n        MemoryPointer srcLength,\n        MemoryPointer dstLength\n    ) internal view returns (uint256 size) {\n        // Read length of the array from source and write to destination.\n        uint256 length = srcLength.readUint256();\n        dstLength.write(length);\n\n        unchecked {\n            // Determine head & tail size as one word per element in the array.\n            uint256 headAndTailSize = length * OneWord;\n\n            // Copy the tail starting from the next element of the source to the\n            // next element of the destination.\n            srcLength.next().offset(headAndTailSize).copy(\n                dstLength.next(),\n                headAndTailSize\n            );\n\n            // Set size to the length of the tail plus one word for length.\n            size = headAndTailSize + OneWord;\n        }\n    }\n\n    /**\n     * @dev Takes a memory pointer to an offer or consideration array and a\n     *      memory pointer to a location to copy it to, and copies the source\n     *      data to the destination in memory as a SpentItem array.\n     *\n     * @param srcLength A memory pointer referencing the offer or consideration\n     *                  array to be copied as a SpentItem array (and pointing to\n     *                  the length of the original array).\n     * @param dstLength A memory pointer referencing the location in memory to\n     *                  copy the offer array to (and pointing to the length of\n     *                  the copied array).\n     *\n     * @return size The size of the SpentItem array (including the length).\n     */\n    function _encodeSpentItems(\n        MemoryPointer srcLength,\n        MemoryPointer dstLength\n    ) internal pure returns (uint256 size) {\n        assembly {\n            // Read length of the array from source and write to destination.\n            let length := mload(srcLength)\n            mstore(dstLength, length)\n\n            // Get pointer to first item's head position in the array,\n            // containing the item's pointer in memory. The head pointer will be\n            // incremented until it reaches the tail position (start of the\n            // array data).\n            let mPtrHead := add(srcLength, OneWord)\n\n            // Position in memory to write next item for calldata. Since\n            // SpentItem has a fixed length, the array elements do not contain\n            // head elements in calldata, they are concatenated together after\n            // the array length.\n            let cdPtrData := add(dstLength, OneWord)\n\n            // Pointer to end of array head in memory.\n            let mPtrHeadEnd := add(mPtrHead, shl(OneWordShift, length))\n\n            for {\n\n            } lt(mPtrHead, mPtrHeadEnd) {\n\n            } {\n                // Read pointer to data for array element from head position.\n                let mPtrTail := mload(mPtrHead)\n\n                // Copy itemType, token, identifier, amount to calldata.\n                mstore(cdPtrData, mload(mPtrTail))\n                mstore(\n                    add(cdPtrData, Common_token_offset),\n                    mload(add(mPtrTail, Common_token_offset))\n                )\n                mstore(\n                    add(cdPtrData, Common_identifier_offset),\n                    mload(add(mPtrTail, Common_identifier_offset))\n                )\n                mstore(\n                    add(cdPtrData, Common_amount_offset),\n                    mload(add(mPtrTail, Common_amount_offset))\n                )\n\n                mPtrHead := add(mPtrHead, OneWord)\n                cdPtrData := add(cdPtrData, SpentItem_size)\n            }\n\n            size := add(OneWord, shl(SpentItem_size_shift, length))\n        }\n    }\n\n    /**\n     * @dev Takes a memory pointer to an consideration array and a memory\n     *      pointer to a location to copy it to, and copies the source data to\n     *      the destination in memory as a ReceivedItem array.\n     *\n     * @param srcLength A memory pointer referencing the consideration array to\n     *                  be copied as a ReceivedItem array (and pointing to the\n     *                  length of the original array).\n     * @param dstLength A memory pointer referencing the location in memory to\n     *                  copy the consideration array to as a ReceivedItem array\n     *                  (and pointing to the length of the new array).\n     *\n     * @return size The size of the ReceivedItem array (including the length).\n     */\n    function _encodeConsiderationAsReceivedItems(\n        MemoryPointer srcLength,\n        MemoryPointer dstLength\n    ) internal view returns (uint256 size) {\n        unchecked {\n            // Read length of the array from source and write to destination.\n            uint256 length = srcLength.readUint256();\n            dstLength.write(length);\n\n            // Get pointer to first item's head position in the array,\n            // containing the item's pointer in memory. The head pointer will be\n            // incremented until it reaches the tail position (start of the\n            // array data).\n            MemoryPointer srcHead = srcLength.next();\n            MemoryPointer srcHeadEnd = srcHead.offset(length * OneWord);\n\n            // Position in memory to write next item for calldata. Since\n            // ReceivedItem has a fixed length, the array elements do not\n            // contain offsets in calldata, they are concatenated together after\n            // the array length.\n            MemoryPointer dstHead = dstLength.next();\n            while (srcHead.lt(srcHeadEnd)) {\n                MemoryPointer srcTail = srcHead.pptr();\n                srcTail.copy(dstHead, ReceivedItem_size);\n                srcHead = srcHead.next();\n                dstHead = dstHead.offset(ReceivedItem_size);\n            }\n\n            size = OneWord + (length * ReceivedItem_size);\n        }\n    }\n}"
    }
  ]
}