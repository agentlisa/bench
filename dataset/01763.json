{
  "Title": "M-3: [M-1] Price Oracle contract does not work in Arbitrum and Optimism",
  "Content": "# Issue M-3: [M-1] Price Oracle contract does not work in Arbitrum and Optimism \n\nSource: https://github.com/sherlock-audit/2023-05-ironbank-judging/issues/191 \n\n## Found by \nast3ros, n1punp, sashik\\_eth, sufi, tnquanghuy0512\n## Summary\n\nThe PriceOracle contract relies on the Chainlink Oracle FeedRegistry to get the price of tokens. However, the FeedRegistry is not available in L2 networks such as Arbitrum and Optimism. This means that the PriceOracle contract will fail to return the price of tokens in these networks.\n\n## Vulnerability Detail\n\nThe PriceOracle contract uses the Chainlink Oracle FeedRegistry to get the latest round data for a pair of tokens.\n\n        (, int256 price,,,) = registry.latestRoundData(base, quote);\n\nhttps://github.com/sherlock-audit/2023-05-ironbank/blob/main/ib-v2/src/protocol/oracle/PriceOracle.sol#L67\n\n\nThe Iron Bank is deployed in mainnet, Arbitrum and Optimism. However, according to the Chainlink documentation, the FeedRegistry is only available in mainnet and not in Arbitrum and Optimism. \n\nhttps://docs.chain.link/data-feeds/feed-registry#contract-addresses\n\nThis means that the PriceOracle contract will not be able to get the price of tokens in these L2 networks. This will affect the functionalities of the protocol that depend on the token price, such as liquidation.\n\nhttps://github.com/sherlock-audit/2023-05-ironbank/blob/main/ib-v2/src/protocol/pool/IronBank.sol#L827-L828\n\n## Impact\n\nThe PriceOracle contract will not function properly in L2 networks. This will break the protocol functions that rely on the token price.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-ironbank/blob/main/ib-v2/src/protocol/oracle/PriceOracle.sol#L67\nhttps://github.com/sherlock-audit/2023-05-ironbank/blob/main/ib-v2/src/protocol/pool/IronBank.sol#L827-L828\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nReimplement the PriceOracle contract by reading the price feed from AggregatorV3Interface instead of FeedRegistry. Example:\nhttps://docs.chain.link/data-feeds/l2-sequencer-feeds#example-code\n\n\n\n\n## Discussion\n\n**thangtranth**\n\nEscalate for 10 USDC\n\nPlease help me to review. This is not a duplication of #440. \n\n- #440 is about checking If Arbitrum sequencer is down. \n- This issue is about the current PriceOracle contract is wrongly implemented because the FeedRegistry is not existed in Arbitrum and Optimism.\n\nThey are two different issues with two different root causes.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> Please help me to review. This is not a duplication of #440. \n> \n> - #440 is about checking If Arbitrum sequencer is down. \n> - This issue is about the current PriceOracle contract is wrongly implemented because the FeedRegistry is not existed in Arbitrum and Optimism.\n> \n> They are two different issues with two different root causes.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ib-tycho**\n\nRegarding the mistake in the contest details mentioned in the README, we apologize for any confusion caused. When we stated that we would deploy on Arbitrum and Optimism, we meant that we would make the necessary modifications before deployment. This is our standard practice of maintaining contracts with different branches, same as what we did in v1: https://github.com/ibdotxyz/compound-protocol/branches\n\nWe are aware of the absence of a registry on OP and Arb, as pointed out by some individuals. We would like to inquire if it is possible to offer the minimum reward for an oracle issue on L2. Thank you.\n\n**0xffff11**\n\nEven though the issue is valid, there will be no deployment on L2s as stated by sponsor. Unfortunately, it is invalid due to a miss-understanding from the docs. As watson said, it is not a duplicate of #440 so it should be de-duplicated and closed.\n\n**thangtranth**\n\nHi everyone, \n\nI totally understand the reasoning and I don’t mean to push this issue. However, I’m concerned that it will set a precedent when Watsons do not know what the scope is and where the source of truth is for each contest.\n\nThere are some duplication of this issue such as #18 and #239 which I believe those Watsons also pay attention to every line of codes and check Oracle registries in each L2 to ensure that the code is safely deployed in stated L2 in Readme.\n\nIn my opinion, if this issue is invalid, then all other issues related to L2 such as Sequencer should also be marked as invalid since the code is not used in L2.\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nAlthough there was an error in the Readme, this would have been easily handled during deployment. \nHowever, this is still a valid issue from the contest POV. \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [thangtranth](https://github.com/sherlock-audit/2023-05-ironbank-judging/issues/191/#issuecomment-1606130613): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/84",
  "Code": [
    {
      "filename": "ib-v2/src/protocol/oracle/PriceOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol\";\nimport \"chainlink/contracts/src/v0.8/Denominations.sol\";\nimport \"openzeppelin-contracts/contracts/access/Ownable2Step.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../extensions/interfaces/WstEthInterface.sol\";\nimport \"../../interfaces/PriceOracleInterface.sol\";\n\ncontract PriceOracle is Ownable2Step, PriceOracleInterface {\n    /// @notice The Chainlink feed registry\n    FeedRegistryInterface public immutable registry;\n\n    /// @notice The address of Lido staked ETH\n    address public immutable steth;\n\n    /// @notice The address of Lido wrapped staked ETH\n    address public immutable wsteth;\n\n    struct AggregatorInfo {\n        address base;\n        address quote;\n    }\n\n    /// @notice The mapping from asset to aggregator\n    mapping(address => AggregatorInfo) public aggregators;\n\n    constructor(address registry_, address steth_, address wsteth_) {\n        registry = FeedRegistryInterface(registry_);\n        steth = steth_;\n        wsteth = wsteth_;\n    }\n\n    /**\n     * @notice Get the price of an asset in USD.\n     * @dev The price returned will be normalized by asset's decimals.\n     * @param asset The asset to get the price of\n     * @return The price of the asset in USD\n     */\n    function getPrice(address asset) external view returns (uint256) {\n        if (asset == wsteth) {\n            uint256 stEthPrice = getPriceFromChainlink(steth, Denominations.USD);\n            uint256 stEthPerToken = WstEthInterface(wsteth).stEthPerToken();\n            uint256 wstEthPrice = (stEthPrice * stEthPerToken) / 1e18;\n            return getNormalizedPrice(wstEthPrice, asset);\n        }\n\n        AggregatorInfo memory aggregatorInfo = aggregators[asset];\n        uint256 price = getPriceFromChainlink(aggregatorInfo.base, aggregatorInfo.quote);\n        if (aggregatorInfo.quote == Denominations.ETH) {\n            // Convert the price to USD based if it's ETH based.\n            uint256 ethUsdPrice = getPriceFromChainlink(Denominations.ETH, Denominations.USD);\n            price = (price * ethUsdPrice) / 1e18;\n        }\n        return getNormalizedPrice(price, asset);\n    }\n\n    /**\n     * @notice Get price from Chainlink.\n     * @param base The base asset\n     * @param quote The quote asset\n     * @return The price\n     */\n    function getPriceFromChainlink(address base, address quote) internal view returns (uint256) {\n        (, int256 price,,,) = registry.latestRoundData(base, quote);\n        require(price > 0, \"invalid price\");\n\n        // Extend the decimals to 1e18.\n        return uint256(price) * 10 ** (18 - uint256(registry.decimals(base, quote)));\n    }\n\n    /**\n     * @dev Get the normalized price.\n     * @param price The price\n     * @param asset The asset\n     * @return The normalized price\n     */\n    function getNormalizedPrice(uint256 price, address asset) internal view returns (uint256) {\n        uint8 decimals = IERC20Metadata(asset).decimals();\n        return price * 10 ** (18 - decimals);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    struct Aggregator {\n        address asset;\n        address base;\n        address quote;\n    }\n\n    /**\n     * @notice Set the aggregators.\n     * @param aggrs The aggregators\n     */\n    function _setAggregators(Aggregator[] calldata aggrs) external onlyOwner {\n        uint256 length = aggrs.length;\n        for (uint256 i = 0; i < length;) {\n            if (aggrs[i].base != address(0)) {\n                require(aggrs[i].quote == Denominations.ETH || aggrs[i].quote == Denominations.USD, \"unsupported quote\");\n\n                // Make sure the aggregator works.\n                address aggregator = address(registry.getFeed(aggrs[i].base, aggrs[i].quote));\n                require(registry.isFeedEnabled(aggregator), \"aggregator not enabled\");\n\n                (, int256 price,,,) = registry.latestRoundData(aggrs[i].base, aggrs[i].quote);\n                require(price > 0, \"invalid price\");\n            }\n            aggregators[aggrs[i].asset] = AggregatorInfo({base: aggrs[i].base, quote: aggrs[i].quote});\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "ib-v2/src/protocol/pool/IronBank.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport \"./IronBankStorage.sol\";\nimport \"../../interfaces/DeferLiquidityCheckInterface.sol\";\nimport \"../../interfaces/IBTokenInterface.sol\";\nimport \"../../interfaces/InterestRateModelInterface.sol\";\nimport \"../../interfaces/IronBankInterface.sol\";\nimport \"../../interfaces/PriceOracleInterface.sol\";\nimport \"../../libraries/Arrays.sol\";\nimport \"../../libraries/DataTypes.sol\";\nimport \"../../libraries/PauseFlags.sol\";\n\ncontract IronBank is\n    Initializable,\n    UUPSUpgradeable,\n    Ownable2StepUpgradeable,\n    ReentrancyGuard,\n    IronBankStorage,\n    IronBankInterface\n{\n    using SafeERC20 for IERC20;\n    using Arrays for address[];\n    using PauseFlags for DataTypes.MarketConfig;\n\n    /**\n     * @notice Initialize the contract.\n     */\n    function initialize(address _admin) public initializer {\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n\n        transferOwnership(_admin);\n    }\n\n    /**\n     * @notice Check if the caller is the market configurator.\n     */\n    modifier onlyMarketConfigurator() {\n        _checkMarketConfigurator();\n        _;\n    }\n\n    /**\n     * @notice Check if the caller is the reserve manager.\n     */\n    modifier onlyReserveManager() {\n        _checkReserveManager();\n        _;\n    }\n\n    /**\n     * @notice Check if the caller is the credit limit manager.\n     */\n    modifier onlyCreditLimitManager() {\n        require(msg.sender == creditLimitManager, \"!manager\");\n        _;\n    }\n\n    /**\n     * @notice Check if the user has authorized the caller.\n     */\n    modifier isAuthorized(address from) {\n        _checkAuthorized(from, msg.sender);\n        _;\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * @notice Get all markets.\n     * @return The list of all markets\n     */\n    function getAllMarkets() public view returns (address[] memory) {\n        return allMarkets;\n    }\n\n    /**\n     * @notice Whether or not a market is listed.\n     * @param market The address of the market to check\n     * @return true if the market is listed, false otherwise\n     */\n    function isMarketListed(address market) public view returns (bool) {\n        DataTypes.Market storage m = markets[market];\n        return m.config.isListed;\n    }\n\n    /**\n     * @notice Get the exchange rate of a market.\n     * @param market The address of the market\n     * @return The exchange rate\n     */\n    function getExchangeRate(address market) public view returns (uint256) {\n        DataTypes.Market storage m = markets[market];\n        return _getExchangeRate(m);\n    }\n\n    /**\n     * @notice Get the total supply of a market.\n     * @param market The address of the market\n     * @return The total supply\n     */\n    function getTotalSupply(address market) public view returns (uint256) {\n        DataTypes.Market storage m = markets[market];\n        return m.totalSupply;\n    }\n\n    /**\n     * @notice Get the total borrow of a market.\n     * @param market The address of the market\n     * @return The total borrow\n     */\n    function getTotalBorrow(address market) public view returns (uint256) {\n        DataTypes.Market storage m = markets[market];\n        return m.totalBorrow;\n    }\n\n    /**\n     * @notice Get the total cash of a market.\n     * @param market The address of the market\n     * @return The total cash\n     */\n    function getTotalCash(address market) public view returns (uint256) {\n        DataTypes.Market storage m = markets[market];\n        return m.totalCash;\n    }\n\n    /**\n     * @notice Get the total reserves of a market.\n     * @param market The address of the market\n     * @return The total reserves\n     */\n    function getTotalReserves(address market) public view returns (uint256) {\n        DataTypes.Market storage m = markets[market];\n        return m.totalReserves;\n    }\n\n    /**\n     * @notice Get the borrow balance of a user in a market.\n     * @param user The address of the user\n     * @param market The address of the market\n     * @return The borrow balance\n     */\n    function getBorrowBalance(address user, address market) public view returns (uint256) {\n        DataTypes.Market storage m = markets[market];\n        return _getBorrowBalance(m, user);\n    }\n\n    /**\n     * @notice Get the IBToken balance of a user in a market.\n     * @param user The address of the user\n     * @param market The address of the market\n     * @return The IBToken balance\n     */\n    function getIBTokenBalance(address user, address market) public view returns (uint256) {\n        DataTypes.Market storage m = markets[market];\n        return m.userSupplies[user];\n    }\n\n    /**\n     * @notice Get the supply balance of a user in a market.\n     * @param user The address of the user\n     * @param market The address of the market\n     * @return The supply balance\n     */\n    function getSupplyBalance(address user, address market) public view returns (uint256) {\n        DataTypes.Market storage m = markets[market];\n        return (m.userSupplies[user] * _getExchangeRate(m)) / 1e18;\n    }\n\n    /**\n     * @notice Get the account liquidity of a user.\n     * @param user The address of the user\n     * @return The account collateral value and borrow value\n     */\n    function getAccountLiquidity(address user) public view returns (uint256, uint256) {\n        return _getAccountLiquidity(user);\n    }\n\n    /**\n     * @notice Get the user's entered markets.\n     * @param user The address of the user\n     * @return The list of entered markets\n     */\n    function getUserEnteredMarkets(address user) public view returns (address[] memory) {\n        return allEnteredMarkets[user];\n    }\n\n    /**\n     * @notice Get the user's allowed extensions.\n     * @param user The address of the user\n     * @return The list of allowed extensions\n     */\n    function getUserAllowedExtensions(address user) public view returns (address[] memory) {\n        return allAllowedExtensions[user];\n    }\n\n    /**\n     * @notice Whether or not a user has allowed an extension.\n     * @param user The address of the user\n     * @param extension The address of the extension\n     * @return true if the user has allowed the extension, false otherwise\n     */\n    function isAllowedExtension(address user, address extension) public view returns (bool) {\n        return allowedExtensions[user][extension];\n    }\n\n    /**\n     * @notice Get the credit limit of a user in a market.\n     * @param user The address of the user\n     * @param market The address of the market\n     * @return The credit limit\n     */\n    function getCreditLimit(address user, address market) public view returns (uint256) {\n        return creditLimits[user][market];\n    }\n\n    /**\n     * @notice Get the list of all credit markets for a user.\n     * @param user The address of the user\n     * @return The list of all credit markets\n     */\n    function getUserCreditMarkets(address user) public view returns (address[] memory) {\n        return allCreditMarkets[user];\n    }\n\n    /**\n     * @notice Whether or not an account is a credit account.\n     * @param user The address of the user\n     * @return true if the account is a credit account, false otherwise\n     */\n    function isCreditAccount(address user) public view returns (bool) {\n        return allCreditMarkets[user].length > 0;\n    }\n\n    /**\n     * @notice Get the configuration of a market.\n     * @param market The address of the market\n     * @return The market configuration\n     */\n    function getMarketConfiguration(address market) public view returns (DataTypes.MarketConfig memory) {\n        return markets[market].config;\n    }\n\n    /**\n     * @notice Check if an account is liquidatable.\n     * @param user The address of the account to check\n     * @return true if the account is liquidatable, false otherwise\n     */\n    function isUserLiquidatable(address user) public view returns (bool) {\n        return _isLiquidatable(user);\n    }\n\n    /**\n     * @notice Calculate the amount of ibToken that can be seized in a liquidation.\n     * @param marketBorrow The address of the market being borrowed from\n     * @param marketCollateral The address of the market being used as collateral\n     * @param repayAmount The amount of the borrowed asset being repaid\n     * @return The amount of ibToken that can be seized\n     */\n    function calculateLiquidationOpportunity(address marketBorrow, address marketCollateral, uint256 repayAmount)\n        public\n        view\n        returns (uint256)\n    {\n        DataTypes.Market storage mCollateral = markets[marketCollateral];\n\n        return _getLiquidationSeizeAmount(marketBorrow, marketCollateral, mCollateral, repayAmount);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @notice Accrue the interest of a market.\n     * @param market The address of the market\n     */\n    function accrueInterest(address market) external {\n        DataTypes.Market storage m = markets[market];\n        require(m.config.isListed, \"not listed\");\n\n        _accrueInterest(market, m);\n    }\n\n    /**\n     * @notice Check the account liquidity of a user.\n     * @param user The address of the user\n     */\n    function checkAccountLiquidity(address user) public {\n        _checkAccountLiquidity(user);\n    }\n\n    /**\n     * @notice Supply an amount of asset to Iron Bank.\n     * @param from The address which will supply the asset\n     * @param to The address which will hold the balance\n     * @param market The address of the market\n     * @param amount The amount of asset to supply\n     */\n    function supply(address from, address to, address market, uint256 amount)\n        external\n        nonReentrant\n        isAuthorized(from)\n    {\n        DataTypes.Market storage m = markets[market];\n        require(m.config.isListed, \"not listed\");\n        require(!m.config.isSupplyPaused(), \"supply paused\");\n        require(!isCreditAccount(to), \"cannot supply to credit account\");\n\n        _accrueInterest(market, m);\n\n        if (m.config.supplyCap != 0) {\n            uint256 totalSupplyUnderlying = m.totalSupply * _getExchangeRate(m) / 1e18;\n            require(totalSupplyUnderlying + amount <= m.config.supplyCap, \"supply cap reached\");\n        }\n\n        uint256 ibTokenAmount = (amount * 1e18) / _getExchangeRate(m);\n\n        // Update storage.\n        m.totalCash += amount;\n        m.totalSupply += ibTokenAmount;\n        unchecked {\n            // Overflow not possible: supplyBalance + ibTokenAmount is at most totalSupply + ibTokenAmount, which is checked above.\n            m.userSupplies[to] += ibTokenAmount;\n        }\n\n        // Enter the market.\n        if (amount > 0) {\n            _enterMarket(market, to);\n        }\n\n        IBTokenInterface(m.config.ibTokenAddress).mint(to, ibTokenAmount); // Only emits Transfer event.\n        IERC20(market).safeTransferFrom(from, address(this), amount);\n\n        emit Supply(market, from, to, amount, ibTokenAmount);\n    }\n\n    /**\n     * @notice Borrow an amount of asset from Iron Bank.\n     * @param from The address which will borrow the asset\n     * @param to The address which will receive the token\n     * @param market The address of the market\n     * @param amount The amount of asset to borrow\n     */\n    function borrow(address from, address to, address market, uint256 amount)\n        external\n        nonReentrant\n        isAuthorized(from)\n    {\n        DataTypes.Market storage m = markets[market];\n        require(m.config.isListed, \"not listed\");\n        require(!m.config.isBorrowPaused(), \"borrow paused\");\n        require(m.totalCash >= amount, \"insufficient cash\");\n\n        _accrueInterest(market, m);\n\n        uint256 newTotalBorrow = m.totalBorrow + amount;\n        uint256 newUserBorrowBalance;\n        unchecked {\n            // Overflow not possible: borrowBalance + amount is at most totalBorrow + amount, which is checked above.\n            newUserBorrowBalance = _getBorrowBalance(m, from) + amount;\n        }\n\n        if (m.config.borrowCap != 0) {\n            require(newTotalBorrow <= m.config.borrowCap, \"borrow cap reached\");\n        }\n\n        // Update storage.\n        unchecked {\n            m.totalCash -= amount;\n        }\n        m.totalBorrow = newTotalBorrow;\n        m.userBorrows[from].borrowBalance = newUserBorrowBalance;\n        m.userBorrows[from].borrowIndex = m.borrowIndex;\n\n        // Enter the market.\n        if (amount > 0) {\n            _enterMarket(market, from);\n        }\n\n        IERC20(market).safeTransfer(to, amount);\n\n        if (isCreditAccount(from)) {\n            require(from == to, \"credit account can only borrow to itself\");\n            require(creditLimits[from][market] >= newUserBorrowBalance, \"insufficient credit limit\");\n        } else {\n            _checkAccountLiquidity(from);\n        }\n\n        emit Borrow(market, from, to, amount, newUserBorrowBalance, newTotalBorrow);\n    }\n\n    /**\n     * @notice Redeem an amount of asset from Iron Bank.\n     * @param from The address which will redeem the asset\n     * @param to The address which will receive the token\n     * @param market The address of the market\n     * @param amount The amount of asset to redeem, or type(uint256).max for max\n     */\n    function redeem(address from, address to, address market, uint256 amount)\n        external\n        nonReentrant\n        isAuthorized(from)\n    {\n        DataTypes.Market storage m = markets[market];\n        require(m.config.isListed, \"not listed\");\n\n        _accrueInterest(market, m);\n\n        uint256 userSupply = m.userSupplies[from];\n        uint256 totalCash = m.totalCash;\n\n        uint256 ibTokenAmount;\n        bool isRedeemFull;\n        if (amount == type(uint256).max) {\n            ibTokenAmount = userSupply;\n            amount = (ibTokenAmount * _getExchangeRate(m)) / 1e18;\n            isRedeemFull = true;\n        } else {\n            ibTokenAmount = (amount * 1e18) / _getExchangeRate(m);\n        }\n\n        require(userSupply >= ibTokenAmount, \"insufficient balance\");\n        require(totalCash >= amount, \"insufficient cash\");\n\n        // Update storage.\n        unchecked {\n            m.userSupplies[from] = userSupply - ibTokenAmount;\n            m.totalCash = totalCash - amount;\n            // Underflow not possible: ibTokenAmount <= userSupply <= totalSupply.\n            m.totalSupply -= ibTokenAmount;\n        }\n\n        // Check if need to exit the market.\n        if (isRedeemFull && _getBorrowBalance(m, from) == 0) {\n            _exitMarket(market, from);\n        }\n\n        IBTokenInterface(m.config.ibTokenAddress).burn(from, ibTokenAmount); // Only emits Transfer event.\n        IERC20(market).safeTransfer(to, amount);\n\n        _checkAccountLiquidity(from);\n\n        emit Redeem(market, from, to, amount, ibTokenAmount);\n    }\n\n    /**\n     * @notice Repay an amount of asset to Iron Bank.\n     * @param from The address which will repay the asset\n     * @param to The address which will hold the balance\n     * @param market The address of the market\n     * @param amount The amount of asset to repay, or type(uint256).max for max\n     */\n    function repay(address from, address to, address market, uint256 amount) external nonReentrant isAuthorized(from) {\n        DataTypes.Market storage m = markets[market];\n        require(m.config.isListed, \"not listed\");\n        if (isCreditAccount(to)) {\n            require(from == to, \"credit account can only repay for itself\");\n        }\n\n        _accrueInterest(market, m);\n\n        _repay(m, from, to, market, amount);\n    }\n\n    /**\n     * @notice Liquidate an undercollateralized borrower.\n     * @param liquidator The address which will liquidate the borrower\n     * @param borrower The address of the borrower\n     * @param marketBorrow The address of the borrow market\n     * @param marketCollateral The address of the collateral market\n     * @param repayAmount The amount of asset to repay, or type(uint256).max for max\n     */\n    function liquidate(\n        address liquidator,\n        address borrower,\n        address marketBorrow,\n        address marketCollateral,\n        uint256 repayAmount\n    ) external nonReentrant isAuthorized(liquidator) {\n        DataTypes.Market storage mBorrow = markets[marketBorrow];\n        DataTypes.Market storage mCollateral = markets[marketCollateral];\n        require(mBorrow.config.isListed, \"borrow market not listed\");\n        require(mCollateral.config.isListed, \"collateral market not listed\");\n        require(isMarketSeizable(mCollateral), \"collateral market cannot be seized\");\n        require(!isCreditAccount(borrower), \"cannot liquidate credit account\");\n        require(liquidator != borrower, \"cannot self liquidate\");\n\n        _accrueInterest(marketBorrow, mBorrow);\n        _accrueInterest(marketCollateral, mCollateral);\n\n        // Check if the borrower is actually liquidatable.\n        require(_isLiquidatable(borrower), \"borrower not liquidatable\");\n\n        // Repay the debt.\n        repayAmount = _repay(mBorrow, liquidator, borrower, marketBorrow, repayAmount);\n\n        // Seize the collateral.\n        uint256 ibTokenAmount = _getLiquidationSeizeAmount(marketBorrow, marketCollateral, mCollateral, repayAmount);\n        _transferIBToken(marketCollateral, mCollateral, borrower, liquidator, ibTokenAmount);\n        IBTokenInterface(mCollateral.config.ibTokenAddress).seize(borrower, liquidator, ibTokenAmount); // Only emits Transfer event.\n\n        emit Liquidate(liquidator, borrower, marketBorrow, marketCollateral, repayAmount, ibTokenAmount);\n    }\n\n    /**\n     * @notice Defer the liquidity check to a user.\n     * @dev The message sender must implement the DeferLiquidityCheckInterface.\n     * @param user The address of the user\n     * @param data The data to pass to the callback\n     */\n    function deferLiquidityCheck(address user, bytes memory data) external {\n        require(!isCreditAccount(user), \"credit account cannot defer liquidity check\");\n        require(liquidityCheckStatus[user] == LIQUIDITY_CHECK_NORMAL, \"reentry defer liquidity check\");\n        liquidityCheckStatus[user] = LIQUIDITY_CHECK_DEFERRED;\n\n        DeferLiquidityCheckInterface(msg.sender).onDeferredLiquidityCheck(data);\n\n        uint8 status = liquidityCheckStatus[user];\n        liquidityCheckStatus[user] = LIQUIDITY_CHECK_NORMAL;\n\n        if (status == LIQUIDITY_CHECK_DIRTY) {\n            _checkAccountLiquidity(user);\n        }\n    }\n\n    /**\n     * @notice User enables or disables an extension.\n     * @param extension The address of the extension\n     * @param allowed Whether to allow or disallow the extension\n     */\n    function setUserExtension(address extension, bool allowed) external {\n        if (allowed && !allowedExtensions[msg.sender][extension]) {\n            allowedExtensions[msg.sender][extension] = true;\n            allAllowedExtensions[msg.sender].push(extension);\n\n            emit ExtensionAdded(msg.sender, extension);\n        } else if (!allowed && allowedExtensions[msg.sender][extension]) {\n            allowedExtensions[msg.sender][extension] = false;\n            allAllowedExtensions[msg.sender].deleteElement(extension);\n\n            emit ExtensionRemoved(msg.sender, extension);\n        }\n    }\n\n    /**\n     * @notice Transfer IBToken from one account to another.\n     * @dev This function is callable by the IBToken contract only.\n     * @param market The address of the market\n     * @param from The address to transfer from\n     * @param to The address to transfer to\n     * @param amount The amount to transfer\n     */\n    function transferIBToken(address market, address from, address to, uint256 amount) external {\n        DataTypes.Market storage m = markets[market];\n        require(m.config.isListed, \"not listed\");\n        require(msg.sender == m.config.ibTokenAddress, \"!authorized\");\n        require(!m.config.isTransferPaused(), \"transfer paused\");\n        require(from != to, \"cannot self transfer\");\n        require(!isCreditAccount(to), \"cannot transfer to credit account\");\n\n        _accrueInterest(market, m);\n        _transferIBToken(market, m, from, to, amount);\n\n        _checkAccountLiquidity(from);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /**\n     * @notice List a market.\n     * @dev This function is callable by the market configurator only.\n     * @param market The address of the market\n     * @param config The market configuration\n     */\n    function listMarket(address market, DataTypes.MarketConfig calldata config) external onlyMarketConfigurator {\n        DataTypes.Market storage m = markets[market];\n        require(!m.config.isListed, \"already listed\");\n\n        m.lastUpdateTimestamp = _getNow();\n        m.borrowIndex = INITIAL_BORROW_INDEX;\n        m.config = config;\n        allMarkets.push(market);\n\n        emit MarketListed(market, m.lastUpdateTimestamp, m.config);\n    }\n\n    /**\n     * @notice Delist a market.\n     * @dev This function is callable by the market configurator only.\n     * @param market The address of the market\n     */\n    function delistMarket(address market) external onlyMarketConfigurator {\n        DataTypes.Market storage m = markets[market];\n        require(m.config.isListed, \"not listed\");\n\n        delete markets[market];\n        allMarkets.deleteElement(market);\n\n        emit MarketDelisted(market);\n    }\n\n    /**\n     * @notice Set the market configuration.\n     * @dev This function is callable by the market configurator only.\n     * @param market The address of the market\n     * @param config The market configuration\n     */\n    function setMarketConfiguration(address market, DataTypes.MarketConfig calldata config)\n        external\n        onlyMarketConfigurator\n    {\n        DataTypes.Market storage m = markets[market];\n        require(m.config.isListed, \"not listed\");\n\n        m.config = config;\n\n        emit MarketConfigurationChanged(market, config);\n    }\n\n    /**\n     * @notice Set the credit limit for a user in a market.\n     * @dev This function is callable by the credit limit manager only.\n     * @param user The address of the user\n     * @param market The address of the market\n     * @param credit The credit limit\n     */\n    function setCreditLimit(address user, address market, uint256 credit) external onlyCreditLimitManager {\n        DataTypes.Market storage m = markets[market];\n        require(m.config.isListed, \"not listed\");\n\n        if (credit == 0 && creditLimits[user][market] != 0) {\n            allCreditMarkets[user].deleteElement(market);\n        } else if (credit != 0 && creditLimits[user][market] == 0) {\n            allCreditMarkets[user].push(market);\n        }\n\n        creditLimits[user][market] = credit;\n        emit CreditLimitChanged(user, market, credit);\n    }\n\n    /**\n     * @notice Increase reserves by absorbing the surplus cash.\n     * @dev This function is callable by the reserve manager only.\n     * @param market The address of the market\n     */\n    function absorbToReserves(address market) external onlyReserveManager {\n        DataTypes.Market storage m = markets[market];\n        require(m.config.isListed, \"not listed\");\n\n        _accrueInterest(market, m);\n\n        uint256 amount = IERC20(market).balanceOf(address(this)) - m.totalCash;\n\n        if (amount > 0) {\n            uint256 ibTokenAmount = (amount * 1e18) / _getExchangeRate(m);\n\n            // Update internal cash, and total reserves.\n            m.totalCash += amount;\n            m.totalReserves += ibTokenAmount;\n\n            emit ReservesIncreased(market, ibTokenAmount, amount);\n        }\n    }\n\n    /**\n     * @notice Reduce reserves by withdrawing the requested amount.\n     * @dev This function is callable by the reserve manager only.\n     * @param market The address of the market\n     * @param ibTokenAmount The amount of ibToken to withdraw\n     * @param recipient The address which will receive the underlying asset\n     */\n    function reduceReserves(address market, uint256 ibTokenAmount, address recipient) external onlyReserveManager {\n        DataTypes.Market storage m = markets[market];\n        require(m.config.isListed, \"not listed\");\n\n        _accrueInterest(market, m);\n\n        uint256 amount = (ibTokenAmount * _getExchangeRate(m)) / 1e18;\n\n        require(m.totalCash >= amount, \"insufficient cash\");\n        require(m.totalReserves >= ibTokenAmount, \"insufficient reserves\");\n\n        // Update internal cash, and total reserves.\n        unchecked {\n            m.totalCash -= amount;\n            m.totalReserves -= ibTokenAmount;\n        }\n\n        IERC20(market).safeTransfer(recipient, amount);\n\n        emit ReservesDecreased(market, recipient, ibTokenAmount, amount);\n    }\n\n    /**\n     * @notice Set the price oracle.\n     * @param oracle The address of the price oracle\n     */\n    function setPriceOracle(address oracle) external onlyOwner {\n        priceOracle = oracle;\n\n        emit PriceOracleSet(oracle);\n    }\n\n    /**\n     * @notice Set the market configurator.\n     * @param configurator The address of the market configurator\n     */\n    function setMarketConfigurator(address configurator) external onlyOwner {\n        marketConfigurator = configurator;\n\n        emit MarketConfiguratorSet(configurator);\n    }\n\n    /**\n     * @notice Set the credit limit manager.\n     * @param manager The address of the credit limit manager\n     */\n    function setCreditLimitManager(address manager) external onlyOwner {\n        creditLimitManager = manager;\n\n        emit CreditLimitManagerSet(manager);\n    }\n\n    /**\n     * @notice Set the reserve manager.\n     * @param manager The address of the reserve manager\n     */\n    function setReserveManager(address manager) external onlyOwner {\n        reserveManager = manager;\n\n        emit ReserveManagerSet(manager);\n    }\n\n    /**\n     * @notice Seize the unlisted token.\n     * @param token The address of the token\n     * @param recipient The address which will receive the token\n     */\n    function seize(address token, address recipient) external onlyOwner {\n        DataTypes.Market storage m = markets[token];\n        require(!m.config.isListed, \"cannot seize listed market\");\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance > 0) {\n            IERC20(token).safeTransfer(recipient, balance);\n\n            emit TokenSeized(token, recipient, balance);\n        }\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /**\n     * @dev _authorizeUpgrade is used by UUPSUpgradeable to determine if it's allowed to upgrade a proxy implementation.\n     * @param newImplementation The new implementation\n     *\n     * Ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/utils/UUPSUpgradeable.sol\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    /**\n     * @dev Get the current timestamp.\n     * @return The current timestamp, casted to uint40\n     */\n    function _getNow() internal view virtual returns (uint40) {\n        require(block.timestamp < 2 ** 40, \"timestamp too large\");\n        return uint40(block.timestamp);\n    }\n\n    /**\n     * @dev Check if the operator is authorized.\n     * @param from The address of the user\n     * @param operator The address of the operator\n     */\n    function _checkAuthorized(address from, address operator) internal view {\n        require(from == operator || (!isCreditAccount(from) && isAllowedExtension(from, operator)), \"!authorized\");\n    }\n\n    /**\n     * @dev Check if the message sender is the market configurator.\n     */\n    function _checkMarketConfigurator() internal view {\n        require(msg.sender == marketConfigurator, \"!configurator\");\n    }\n\n    /**\n     * @dev Check if the message sender is the credit limit manager.\n     */\n    function _checkReserveManager() internal view {\n        require(msg.sender == reserveManager, \"!reserveManager\");\n    }\n\n    /**\n     * @dev Get the exchange rate.\n     * @param m T"
    }
  ]
}