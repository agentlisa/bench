{
  "Title": "`emergencyClose()` may fail to repay any debt",
  "Content": "# `emergencyClose()` may fail to repay any debt\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXEmergency.sol#L111\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXEmergency.sol#L111</a>\n\n\n## Summary\n\n- the [`emergencyClose()`](https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXEmergency.sol#L111) function may become ineffective, preventing the contract from repaying any outstanding debt, leading to potential financial losses.\n\n## Vulnerability Details\n\n- When the contract is _paused_, all the liquidity from GMX is withdrawn (in term of `tokenA` and `tokenB`).\n- The `emergencyClose()` function is called after the contract is paused due some reasons, possibly when the strategy incurs bad debts or when the contract gets hacked, High volatility, and so on...\n- This function is responsible for repaying all the amounts of `tokenA` and `tokenB` borrowed from the `lendingVault` contract. It then sets the contract's status to `closed`. After that, users who hold `svToken` shares can withdraw the remaining assets from the contract.\n- The issue with this function lies in its _assumptions_, which are not accurate. It assumes that the withdrawn amounts from **GMX** are always sufficient to cover the whole debt.\n\n```solidity\n   function emergencyClose(GMXTypes.Store storage self, uint256 deadline) external {\n        // Revert if the status is Paused.\n        GMXChecks.beforeEmergencyCloseChecks(self);\n\n        // Repay all borrowed assets; 1e18 == 100% shareRatio to repay\n        GMXTypes.RepayParams memory _rp;\n>>        (_rp.repayTokenAAmt, _rp.repayTokenBAmt) = GMXManager.calcRepay(self, 1e18);\n\n        (bool _swapNeeded, address _tokenFrom, address _tokenTo, uint256 _tokenToAmt) =\n            GMXManager.calcSwapForRepay(self, _rp);\n\n        if (_swapNeeded) {\n            ISwap.SwapParams memory _sp;\n\n            _sp.tokenIn = _tokenFrom;\n            _sp.tokenOut = _tokenTo;\n            _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n            _sp.amountOut = _tokenToAmt;\n            _sp.slippage = self.minSlippage;\n            _sp.deadline = deadline;\n\n            GMXManager.swapTokensForExactTokens(self, _sp);\n        }\n        GMXManager.repay(self, _rp.repayTokenAAmt, _rp.repayTokenBAmt);\n\n        self.status = GMXTypes.Status.Closed;\n\n        emit EmergencyClose(_rp.repayTokenAAmt, _rp.repayTokenBAmt);\n    }\n  }\n\n```\n\n- Please note that `_rp.repayTokenAAmt` and `_rp.repayTokenBAmt` represent the entire debt, and these values remain the same even if a swap is needed.\n- The function checks if a swap is needed to cover its debt, and here's how it determines whether a swap is required:\n\n```solidity\n  function calcSwapForRepay(GMXTypes.Store storage self, GMXTypes.RepayParams memory rp)\n        external\n        view\n        returns (bool, address, address, uint256)\n    {\n        address _tokenFrom;\n        address _tokenTo;\n        uint256 _tokenToAmt;\n        if (rp.repayTokenAAmt > self.tokenA.balanceOf(address(this))) {\n            // If more tokenA is needed for repayment\n            _tokenToAmt = rp.repayTokenAAmt - self.tokenA.balanceOf(address(this));\n            _tokenFrom = address(self.tokenB);\n            _tokenTo = address(self.tokenA);\n\n            return (true, _tokenFrom, _tokenTo, _tokenToAmt);\n        } else if (rp.repayTokenBAmt > self.tokenB.balanceOf(address(this))) {\n            // If more tokenB is needed for repayment\n            _tokenToAmt = rp.repayTokenBAmt - self.tokenB.balanceOf(address(this));\n            _tokenFrom = address(self.tokenA);\n            _tokenTo = address(self.tokenB);\n\n            return (true, _tokenFrom, _tokenTo, _tokenToAmt);\n        } else {\n            // If there is enough to repay both tokens\n            return (false, address(0), address(0), 0);\n        }\n    }\n\n```\n\n- In plain English, this function in this case assumes:  *if the contract's balance of one of the tokens (e.g., `tokenA`) is insufficient to cover `tokenA` debt, it means that the contract balance of the other token (`tokenB`) should be greater than the debt of `tokenB`, and the **value** of the remaining balance of `tokenB` after paying off the `tokenB` debt should be **equal** or **greater** than the required **value** to cover the debt of `tokenA`* </br>\n\nThe two main issues with this assumption are:\n\n1.  If the contract balance of `tokenFrom` is not enough to be swapped for `_tokenToAmt` of `tokenTo`, the swap will revert, causing the function to revert each time it is called when the balance of `tokenFrom` is insufficient.(in most cases in delta long strategy since it's only borrow one token), This is highly likely since emergency closures occur when something detrimental has happened, (such as bad debts).\n2.  The second issue arises when the balance of `tokenFrom`(EX: `tokenA`) becomes less than `_rp.repayTokenAAmt` after a swap. In this case, the `repay` call will revert when the `lendingVault` contract attempts to `transferFrom` the strategy contract for an amount greater than its balance. ex :\n    - tokenA balance = 100, debtA = 80.\n    - tokenB balance = 50 , debtB = 70.\n    - after swap tokenA for 20 tokenB .\n    - tokenA balance = 75 , debtA = 80 : in this case repay will keep revert .\n\n- so if the contract accumulates bad debts(`in value`), the `emergencyClose()` function will always revert, preventing any debt repayment.\n- Another critical factor to consider is the time between the `pause` action and the emergency `close` action. During periods of high volatility, the pause action temporarily halts the contract, but the prices of the two assets may continue to decline. The emergency close function can only be triggered by the owner, who operates a time-lock wallet. In the time between the pause and close actions, the prices may drop significantly and this condition will met since the `swap` is needed in almost all cases.\n\n## Impact\n\n- `emergencyClose()` function will consistently fail to repay any debt.\n- lenders may lose all their funds\n\n## Tools Used\n\nvs code\nmanual review\n\n## Recommendations\n\n- the debt need to be repayed in the `pause` action. and in case of `resume` just re-borrow again.",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXEmergency.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\n\n/**\n  * @title GMXEmergency\n  * @author Steadefi\n  * @notice Re-usable library functions for emergency operations for Steadefi leveraged vaults\n*/\nlibrary GMXEmergency {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n  uint256 public constant DUST_AMOUNT = 1e17;\n\n  /* ======================== EVENTS ========================= */\n\n  event EmergencyPause();\n  event EmergencyResume();\n  event EmergencyClose(\n    uint256 repayTokenAAmt,\n    uint256 repayTokenBAmt\n  );\n  event EmergencyWithdraw(\n    address indexed user,\n    uint256 sharesAmt,\n    address assetA,\n    uint256 assetAAmt,\n    address assetB,\n    uint256 assetBAmt\n  );\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyPause(\n    GMXTypes.Store storage self\n  ) external {\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // Remove all of the vault's LP tokens\n    _rlp.lpAmt = self.lpToken.balanceOf(address(this));\n    _rlp.executionFee = msg.value;\n\n    GMXManager.removeLiquidity(\n      self,\n      _rlp\n    );\n\n    self.status = GMXTypes.Status.Paused;\n\n    emit EmergencyPause();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyResume(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeEmergencyResumeChecks(self);\n\n    self.status = GMXTypes.Status.Resume;\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n    _alp.executionFee = msg.value;\n\n    GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processEmergencyResume(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessEmergencyResumeChecks(self);\n\n    self.status = GMXTypes.Status.Open;\n\n    emit EmergencyResume();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyClose(\n    GMXTypes.Store storage self,\n    uint256 deadline\n  ) external {\n    GMXChecks.beforeEmergencyCloseChecks(self);\n\n    // Repay all borrowed assets; 1e18 == 100% shareRatio to repay\n    GMXTypes.RepayParams memory _rp;\n    (\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    ) = GMXManager.calcRepay(self, 1e18);\n\n    (\n      bool _swapNeeded,\n      address _tokenFrom,\n      address _tokenTo,\n      uint256 _tokenToAmt\n    ) = GMXManager.calcSwapForRepay(self, _rp);\n\n    if (_swapNeeded) {\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = _tokenFrom;\n      _sp.tokenOut = _tokenTo;\n      _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n      _sp.amountOut = _tokenToAmt;\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = deadline;\n\n      GMXManager.swapTokensForExactTokens(self, _sp);\n    }\n\n    GMXManager.repay(\n      self,\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    );\n\n    self.status = GMXTypes.Status.Closed;\n\n    emit EmergencyClose(\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyWithdraw(\n    GMXTypes.Store storage self,\n    uint256 shareAmt\n  ) external {\n    // check to ensure shares withdrawn does not exceed user's balance\n    uint256 _userShareBalance = IERC20(address(self.vault)).balanceOf(msg.sender);\n\n    // to avoid leaving dust behind\n    unchecked {\n      if (_userShareBalance - shareAmt < DUST_AMOUNT) {\n        shareAmt = _userShareBalance;\n      }\n    }\n\n    GMXChecks.beforeEmergencyWithdrawChecks(self, shareAmt);\n\n    // share ratio calculation must be before burn()\n    uint256 _shareRatio = shareAmt * SAFE_MULTIPLIER\n                          / IERC20(address(self.vault)).totalSupply();\n\n    self.vault.burn(msg.sender, shareAmt);\n\n    uint256 _withdrawAmtTokenA = _shareRatio\n                                 * self.tokenA.balanceOf(address(this))\n                                 / SAFE_MULTIPLIER;\n    uint256 _withdrawAmtTokenB = _shareRatio\n                                 * self.tokenB.balanceOf(address(this))\n                                 / SAFE_MULTIPLIER;\n\n    self.tokenA.safeTransfer(msg.sender, _withdrawAmtTokenA);\n    self.tokenB.safeTransfer(msg.sender, _withdrawAmtTokenB);\n\n    emit EmergencyWithdraw(\n      msg.sender,\n      shareAmt,\n      address(self.tokenA),\n      _withdrawAmtTokenA,\n      address(self.tokenB),\n      _withdrawAmtTokenB\n    );\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXEmergency.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\n\n/**\n  * @title GMXEmergency\n  * @author Steadefi\n  * @notice Re-usable library functions for emergency operations for Steadefi leveraged vaults\n*/\nlibrary GMXEmergency {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n  uint256 public constant DUST_AMOUNT = 1e17;\n\n  /* ======================== EVENTS ========================= */\n\n  event EmergencyPause();\n  event EmergencyResume();\n  event EmergencyClose(\n    uint256 repayTokenAAmt,\n    uint256 repayTokenBAmt\n  );\n  event EmergencyWithdraw(\n    address indexed user,\n    uint256 sharesAmt,\n    address assetA,\n    uint256 assetAAmt,\n    address assetB,\n    uint256 assetBAmt\n  );\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyPause(\n    GMXTypes.Store storage self\n  ) external {\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // Remove all of the vault's LP tokens\n    _rlp.lpAmt = self.lpToken.balanceOf(address(this));\n    _rlp.executionFee = msg.value;\n\n    GMXManager.removeLiquidity(\n      self,\n      _rlp\n    );\n\n    self.status = GMXTypes.Status.Paused;\n\n    emit EmergencyPause();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyResume(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeEmergencyResumeChecks(self);\n\n    self.status = GMXTypes.Status.Resume;\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n    _alp.executionFee = msg.value;\n\n    GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processEmergencyResume(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessEmergencyResumeChecks(self);\n\n    self.status = GMXTypes.Status.Open;\n\n    emit EmergencyResume();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyClose(\n    GMXTypes.Store storage self,\n    uint256 deadline\n  ) external {\n    GMXChecks.beforeEmergencyCloseChecks(self);\n\n    // Repay all borrowed assets; 1e18 == 100% shareRatio to repay\n    GMXTypes.RepayParams memory _rp;\n    (\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    ) = GMXManager.calcRepay(self, 1e18);\n\n    (\n      bool _swapNeeded,\n      address _tokenFrom,\n      address _tokenTo,\n      uint256 _tokenToAmt\n    ) = GMXManager.calcSwapForRepay(self, _rp);\n\n    if (_swapNeeded) {\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = _tokenFrom;\n      _sp.tokenOut = _tokenTo;\n      _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n      _sp.amountOut = _tokenToAmt;\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = deadline;\n\n      GMXManager.swapTokensForExactTokens(self, _sp);\n    }\n\n    GMXManager.repay(\n      self,\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    );\n\n    self.status = GMXTypes.Status.Closed;\n\n    emit EmergencyClose(\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyWithdraw(\n    GMXTypes.Store storage self,\n    uint256 shareAmt\n  ) external {\n    // check to ensure shares withdrawn does not exceed user's balance\n    uint256 _userShareBalance = IERC20(address(self.vault)).balanceOf(msg.sender);\n\n    // to avoid leaving dust behind\n    unchecked {\n      if (_userShareBalance - shareAmt < DUST_AMOUNT) {\n        shareAmt = _userShareBalance;\n      }\n    }\n\n    GMXChecks.beforeEmergencyWithdrawChecks(self, shareAmt);\n\n    // share ratio calculation must be before burn()\n    uint256 _shareRatio = shareAmt * SAFE_MULTIPLIER\n                          / IERC20(address(self.vault)).totalSupply();\n\n    self.vault.burn(msg.sender, shareAmt);\n\n    uint256 _withdrawAmtTokenA = _shareRatio\n                                 * self.tokenA.balanceOf(address(this))\n                                 / SAFE_MULTIPLIER;\n    uint256 _withdrawAmtTokenB = _shareRatio\n                                 * self.tokenB.balanceOf(address(this))\n                                 / SAFE_MULTIPLIER;\n\n    self.tokenA.safeTransfer(msg.sender, _withdrawAmtTokenA);\n    self.tokenB.safeTransfer(msg.sender, _withdrawAmtTokenB);\n\n    emit EmergencyWithdraw(\n      msg.sender,\n      shareAmt,\n      address(self.tokenA),\n      _withdrawAmtTokenA,\n      address(self.tokenB),\n      _withdrawAmtTokenB\n    );\n  }\n}"
    }
  ]
}