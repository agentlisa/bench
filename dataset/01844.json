{
  "Title": "Callback verification can be made more secure",
  "Content": "##### Description\nThe current callback verification is safe enough, but to increase the security of the protocol we would recommend saving the address of the pool that is used in the `_createLimitOrder` function to the storage variable to check that callback is called by the specific pool.\nhttps://github.com/cryptoalgebra/Algebra/blob/bddd6487c86e0d6afef39638159dc403a91ba433/src/periphery/contracts/base/LimitOrderManagement.sol#L24\n##### Recommendation\nWe recommend increasing the security of the callback validation.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/periphery/contracts/base/LimitOrderManagement.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.17;\npragma abicoder v2;\n\nimport '@cryptoalgebra/core/contracts/interfaces/callback/IAlgebraMintCallback.sol';\n\nimport '../libraries/PoolAddress.sol';\nimport '../libraries/CallbackValidation.sol';\n\nimport './PeripheryPayments.sol';\nimport './PeripheryImmutableState.sol';\n\n/// @title Limit orders management functions\n/// @notice Internal functions for safely managing limit orders in Algebra V2\nabstract contract LimitOrderManagement is IAlgebraMintCallback, PeripheryImmutableState, PeripheryPayments {\n    struct MintCallbackData {\n        PoolAddress.PoolKey poolKey;\n        address payer;\n    }\n\n    /// @inheritdoc IAlgebraMintCallback\n    function algebraMintCallback(uint256 amount0Owed, uint256 amount1Owed, bytes calldata data) external override {\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        CallbackValidation.verifyCallback(poolDeployer, decoded.poolKey);\n\n        if (amount0Owed > 0) pay(decoded.poolKey.token0, decoded.payer, msg.sender, amount0Owed);\n        if (amount1Owed > 0) pay(decoded.poolKey.token1, decoded.payer, msg.sender, amount1Owed);\n    }\n\n    /// @notice Add liquidity to an initialized pool\n    function _createLimitOrder(\n        address token0,\n        address token1,\n        int24 tick,\n        uint128 amount\n    ) internal returns (IAlgebraPool pool, bool depositedToken) {\n        PoolAddress.PoolKey memory poolKey = PoolAddress.PoolKey({token0: token0, token1: token1});\n\n        pool = IAlgebraPool(PoolAddress.computeAddress(poolDeployer, poolKey));\n\n        (, uint256 amount1, ) = pool.mint(\n            msg.sender,\n            address(this),\n            tick,\n            tick,\n            amount,\n            abi.encode(MintCallbackData({poolKey: poolKey, payer: msg.sender}))\n        );\n        depositedToken = amount1 > 0;\n    }\n}"
    }
  ]
}