{
  "Title": "[01] Abbot allows to open empty troves inflating the `troves_count`",
  "Content": "\nThe [`abbot::open_trove`(...)](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/abbot.cairo#L131-L161) method allows to open **empty** troves (with `0` collateral).  \n\n### Impact\n- Unnecessary increase of [`troves_count: u64`](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/abbot.cairo#L137) (very unlikely: DoS due to `u64_add Overflow`).\n- Unnecessary network stress since no funds (except fees) are required.\n\n### PoC\n\nThe test case below demonstrates that an empty trove can be opened. Add the test case to `src/tests/abbot/test_abbot.cairo` and run it with `snforge test test_open_empty_trove_pass`:\n\n```cairo\n#[test]\nfn test_open_empty_trove_pass() {\n    let (shrine, _, abbot, yangs, gates) = abbot_utils::abbot_deploy(\n        Option::None, Option::None, Option::None, Option::None, Option::None\n    );\n\n    let mut spy = spy_events(SpyOn::One(abbot.contract_address));\n\n    // Deploying the first trove\n    let trove_owner: ContractAddress = common::trove1_owner_addr();\n    let forge_amt: Wad = 0_u128.into();\n    //common::fund_user(trove_owner, yangs, abbot_utils::initial_asset_amts());\n    let asset_amts: Array<u128> = array![0_u128, 0_u128];\n    let deposited_amts: Span<u128> = asset_amts.span();\n    let trove_id: u64 = common::open_trove_helper(abbot, trove_owner, yangs, deposited_amts, gates, forge_amt);\n\n    // Check trove ID\n    let expected_trove_id: u64 = 1;\n    assert(trove_id == expected_trove_id, 'wrong trove ID');\n    assert(\n        abbot.get_trove_owner(expected_trove_id).expect('should not be zero') == trove_owner, 'wrong trove owner'\n    );\n    assert(abbot.get_troves_count() == expected_trove_id, 'wrong troves count');\n\n    let mut expected_user_trove_ids: Array<u64> = array![expected_trove_id];\n    assert(abbot.get_user_trove_ids(trove_owner) == expected_user_trove_ids.span(), 'wrong user trove ids');\n}\n```\n\n### Recommendation  \nRequire a minimum deposit value when opening a trove.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-01-opus",
  "Code": [
    {
      "filename": "src/core/abbot.cairo",
      "content": "#[starknet::contract]\nmod abbot {\n    use opus::interfaces::IAbbot::IAbbot;\n    use opus::interfaces::ISentinel::{ISentinelDispatcher, ISentinelDispatcherTrait};\n    use opus::interfaces::IShrine::{IShrineDispatcher, IShrineDispatcherTrait};\n    use opus::types::AssetBalance;\n    use opus::utils::reentrancy_guard::reentrancy_guard_component;\n    use starknet::{ContractAddress, get_caller_address};\n    use wadray::{BoundedWad, Wad};\n\n    // \n    // Components \n    // \n\n    component!(path: reentrancy_guard_component, storage: reentrancy_guard, event: ReentrancyGuardEvent);\n\n    impl ReentrancyGuardHelpers = reentrancy_guard_component::ReentrancyGuardHelpers<ContractState>;\n\n    #[storage]\n    struct Storage {\n        // components\n        #[substorage(v0)]\n        reentrancy_guard: reentrancy_guard_component::Storage,\n        // Shrine associated with this Abbot\n        shrine: IShrineDispatcher,\n        // Sentinel associated with this Abbot\n        sentinel: ISentinelDispatcher,\n        // total number of troves in a Shrine; monotonically increasing\n        // also used to calculate the next ID (count+1) when opening a new trove\n        // in essence, it serves as an index / primary key in a SQL table\n        troves_count: u64,\n        // the total number of troves of a particular address;\n        // used to build the tuple key of `user_troves` variable\n        // (user) -> (number of troves opened)\n        user_troves_count: LegacyMap<ContractAddress, u64>,\n        // a mapping of an address and index to a trove ID\n        // belonging to this address; the index is a number from 0\n        // up to `user_troves_count` for that address\n        // (user, idx) -> (trove ID)\n        user_troves: LegacyMap<(ContractAddress, u64), u64>,\n        // a mapping of a trove ID to the contract address which\n        // was used to open the trove\n        // (trove ID) -> (owner)\n        trove_owner: LegacyMap<u64, ContractAddress>,\n    }\n\n    //\n    // Events\n    //\n\n    #[event]\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    enum Event {\n        TroveOpened: TroveOpened,\n        TroveClosed: TroveClosed,\n        // Component events\n        ReentrancyGuardEvent: reentrancy_guard_component::Event\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct TroveOpened {\n        #[key]\n        user: ContractAddress,\n        #[key]\n        trove_id: u64\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct TroveClosed {\n        #[key]\n        trove_id: u64\n    }\n\n    //\n    // Constructor\n    //\n\n    #[constructor]\n    fn constructor(ref self: ContractState, shrine: ContractAddress, sentinel: ContractAddress) {\n        self.shrine.write(IShrineDispatcher { contract_address: shrine });\n        self.sentinel.write(ISentinelDispatcher { contract_address: sentinel });\n    }\n\n    //\n    // External Abbot functions\n    //\n\n    #[abi(embed_v0)]\n    impl IAbbotImpl of IAbbot<ContractState> {\n        //\n        // Getters\n        //\n\n        fn get_trove_owner(self: @ContractState, trove_id: u64) -> Option<ContractAddress> {\n            let owner = self.trove_owner.read(trove_id);\n            if owner.is_zero() {\n                Option::None\n            } else {\n                Option::Some(owner)\n            }\n        }\n\n        fn get_user_trove_ids(self: @ContractState, user: ContractAddress) -> Span<u64> {\n            let mut trove_ids: Array<u64> = ArrayTrait::new();\n            let user_troves_count: u64 = self.user_troves_count.read(user);\n            let mut idx: u64 = 0;\n\n            loop {\n                if idx == user_troves_count {\n                    break trove_ids.span();\n                }\n                trove_ids.append(self.user_troves.read((user, idx)));\n                idx += 1;\n            }\n        }\n\n        fn get_troves_count(self: @ContractState) -> u64 {\n            self.troves_count.read()\n        }\n\n        fn get_trove_asset_balance(self: @ContractState, trove_id: u64, yang: ContractAddress) -> u128 {\n            self.sentinel.read().convert_to_assets(yang, self.shrine.read().get_deposit(yang, trove_id))\n        }\n\n        //\n        // Core functions\n        //\n\n        // create a new trove in the system with Yang deposits,\n        // optionally forging Yin in the same operation (if `forge_amount` is 0, no Yin is created)\n        fn open_trove(\n            ref self: ContractState, mut yang_assets: Span<AssetBalance>, forge_amount: Wad, max_forge_fee_pct: Wad\n        ) -> u64 {\n            assert(yang_assets.len().is_non_zero(), 'ABB: No yangs');\n\n            let troves_count: u64 = self.troves_count.read();\n            self.troves_count.write(troves_count + 1);\n\n            let user = get_caller_address();\n            let user_troves_count: u64 = self.user_troves_count.read(user);\n            self.user_troves_count.write(user, user_troves_count + 1);\n\n            let new_trove_id: u64 = troves_count + 1;\n            self.user_troves.write((user, user_troves_count), new_trove_id);\n            self.trove_owner.write(new_trove_id, user);\n\n            // deposit all requested Yangs into the system\n            loop {\n                match yang_assets.pop_front() {\n                    Option::Some(yang_asset) => { self.deposit_helper(new_trove_id, user, *yang_asset); },\n                    Option::None => { break; }\n                };\n            };\n\n            // forge Yin\n            self.shrine.read().forge(user, new_trove_id, forge_amount, max_forge_fee_pct);\n\n            self.emit(TroveOpened { user, trove_id: new_trove_id });\n\n            new_trove_id\n        }\n\n        // close a trove, repaying its debt in full and withdrawing all the Yangs\n        fn close_trove(ref self: ContractState, trove_id: u64) {\n            let user = get_caller_address();\n            self.assert_trove_owner(user, trove_id);\n\n            let shrine = self.shrine.read();\n            // melting \"max Wad\" to instruct Shrine to melt *all* of trove's debt\n            shrine.melt(user, trove_id, BoundedWad::max());\n\n            let mut yangs: Span<ContractAddress> = self.sentinel.read().get_yang_addresses();\n            // withdraw each and every Yang belonging to the trove from the system\n            loop {\n                match yangs.pop_front() {\n                    Option::Some(yang) => {\n                        let yang_amount: Wad = shrine.get_deposit(*yang, trove_id);\n                        if yang_amount.is_zero() {\n                            continue;\n                        }\n                        self.withdraw_helper(trove_id, user, *yang, yang_amount);\n                    },\n                    Option::None => { break; }\n                };\n            };\n\n            self.emit(TroveClosed { trove_id });\n        }\n\n        // add Yang (an asset) to a trove\n        fn deposit(ref self: ContractState, trove_id: u64, yang_asset: AssetBalance) {\n            // There is no need to check the yang address is non-zero because the\n            // Sentinel does not allow a zero address yang to be added.\n\n            assert(trove_id != 0, 'ABB: Trove ID cannot be 0');\n            assert(trove_id <= self.troves_count.read(), 'ABB: Non-existent trove');\n            // note that caller does not need to be the trove's owner to deposit\n\n            self.deposit_helper(trove_id, get_caller_address(), yang_asset);\n        }\n\n        // remove Yang (an asset) from a trove\n        fn withdraw(ref self: ContractState, trove_id: u64, yang_asset: AssetBalance) {\n            // There is no need to check the yang address is non-zero because the\n            // Sentinel does not allow a zero address yang to be added.\n\n            let user = get_caller_address();\n            self.assert_trove_owner(user, trove_id);\n\n            let yang_amt: Wad = self.sentinel.read().convert_to_yang(yang_asset.address, yang_asset.amount);\n            self.withdraw_helper(trove_id, user, yang_asset.address, yang_amt);\n        }\n\n        // create Yin in a trove\n        fn forge(ref self: ContractState, trove_id: u64, amount: Wad, max_forge_fee_pct: Wad) {\n            let user = get_caller_address();\n            self.assert_trove_owner(user, trove_id);\n            self.shrine.read().forge(user, trove_id, amount, max_forge_fee_pct);\n        }\n\n        // destroy Yin from a trove\n        fn melt(ref self: ContractState, trove_id: u64, amount: Wad) {\n            // note that caller does not need to be the trove's owner to melt\n            self.shrine.read().melt(get_caller_address(), trove_id, amount);\n        }\n    }\n\n    //\n    // Internal Abbot functions\n    //\n\n    #[generate_trait]\n    impl AbbotHelpers of AbbotHelpersTrait {\n        #[inline(always)]\n        fn assert_trove_owner(self: @ContractState, user: ContractAddress, trove_id: u64) {\n            assert(user == self.trove_owner.read(trove_id), 'ABB: Not trove owner')\n        }\n\n        #[inline(always)]\n        fn deposit_helper(ref self: ContractState, trove_id: u64, user: ContractAddress, yang_asset: AssetBalance) {\n            // reentrancy guard is used as a precaution\n            self.reentrancy_guard.start();\n\n            let yang_amt: Wad = self.sentinel.read().enter(yang_asset.address, user, trove_id, yang_asset.amount);\n            self.shrine.read().deposit(yang_asset.address, trove_id, yang_amt);\n\n            self.reentrancy_guard.end();\n        }\n\n        #[inline(always)]\n        fn withdraw_helper(\n            ref self: ContractState, trove_id: u64, user: ContractAddress, yang: ContractAddress, yang_amt: Wad\n        ) {\n            // reentrancy guard is used as a precaution\n            self.reentrancy_guard.start();\n\n            self.sentinel.read().exit(yang, user, trove_id, yang_amt);\n            self.shrine.read().withdraw(yang, trove_id, yang_amt);\n\n            self.reentrancy_guard.end();\n        }\n    }\n}"
    },
    {
      "filename": "src/core/abbot.cairo",
      "content": "#[starknet::contract]\nmod abbot {\n    use opus::interfaces::IAbbot::IAbbot;\n    use opus::interfaces::ISentinel::{ISentinelDispatcher, ISentinelDispatcherTrait};\n    use opus::interfaces::IShrine::{IShrineDispatcher, IShrineDispatcherTrait};\n    use opus::types::AssetBalance;\n    use opus::utils::reentrancy_guard::reentrancy_guard_component;\n    use starknet::{ContractAddress, get_caller_address};\n    use wadray::{BoundedWad, Wad};\n\n    // \n    // Components \n    // \n\n    component!(path: reentrancy_guard_component, storage: reentrancy_guard, event: ReentrancyGuardEvent);\n\n    impl ReentrancyGuardHelpers = reentrancy_guard_component::ReentrancyGuardHelpers<ContractState>;\n\n    #[storage]\n    struct Storage {\n        // components\n        #[substorage(v0)]\n        reentrancy_guard: reentrancy_guard_component::Storage,\n        // Shrine associated with this Abbot\n        shrine: IShrineDispatcher,\n        // Sentinel associated with this Abbot\n        sentinel: ISentinelDispatcher,\n        // total number of troves in a Shrine; monotonically increasing\n        // also used to calculate the next ID (count+1) when opening a new trove\n        // in essence, it serves as an index / primary key in a SQL table\n        troves_count: u64,\n        // the total number of troves of a particular address;\n        // used to build the tuple key of `user_troves` variable\n        // (user) -> (number of troves opened)\n        user_troves_count: LegacyMap<ContractAddress, u64>,\n        // a mapping of an address and index to a trove ID\n        // belonging to this address; the index is a number from 0\n        // up to `user_troves_count` for that address\n        // (user, idx) -> (trove ID)\n        user_troves: LegacyMap<(ContractAddress, u64), u64>,\n        // a mapping of a trove ID to the contract address which\n        // was used to open the trove\n        // (trove ID) -> (owner)\n        trove_owner: LegacyMap<u64, ContractAddress>,\n    }\n\n    //\n    // Events\n    //\n\n    #[event]\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    enum Event {\n        TroveOpened: TroveOpened,\n        TroveClosed: TroveClosed,\n        // Component events\n        ReentrancyGuardEvent: reentrancy_guard_component::Event\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct TroveOpened {\n        #[key]\n        user: ContractAddress,\n        #[key]\n        trove_id: u64\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct TroveClosed {\n        #[key]\n        trove_id: u64\n    }\n\n    //\n    // Constructor\n    //\n\n    #[constructor]\n    fn constructor(ref self: ContractState, shrine: ContractAddress, sentinel: ContractAddress) {\n        self.shrine.write(IShrineDispatcher { contract_address: shrine });\n        self.sentinel.write(ISentinelDispatcher { contract_address: sentinel });\n    }\n\n    //\n    // External Abbot functions\n    //\n\n    #[abi(embed_v0)]\n    impl IAbbotImpl of IAbbot<ContractState> {\n        //\n        // Getters\n        //\n\n        fn get_trove_owner(self: @ContractState, trove_id: u64) -> Option<ContractAddress> {\n            let owner = self.trove_owner.read(trove_id);\n            if owner.is_zero() {\n                Option::None\n            } else {\n                Option::Some(owner)\n            }\n        }\n\n        fn get_user_trove_ids(self: @ContractState, user: ContractAddress) -> Span<u64> {\n            let mut trove_ids: Array<u64> = ArrayTrait::new();\n            let user_troves_count: u64 = self.user_troves_count.read(user);\n            let mut idx: u64 = 0;\n\n            loop {\n                if idx == user_troves_count {\n                    break trove_ids.span();\n                }\n                trove_ids.append(self.user_troves.read((user, idx)));\n                idx += 1;\n            }\n        }\n\n        fn get_troves_count(self: @ContractState) -> u64 {\n            self.troves_count.read()\n        }\n\n        fn get_trove_asset_balance(self: @ContractState, trove_id: u64, yang: ContractAddress) -> u128 {\n            self.sentinel.read().convert_to_assets(yang, self.shrine.read().get_deposit(yang, trove_id))\n        }\n\n        //\n        // Core functions\n        //\n\n        // create a new trove in the system with Yang deposits,\n        // optionally forging Yin in the same operation (if `forge_amount` is 0, no Yin is created)\n        fn open_trove(\n            ref self: ContractState, mut yang_assets: Span<AssetBalance>, forge_amount: Wad, max_forge_fee_pct: Wad\n        ) -> u64 {\n            assert(yang_assets.len().is_non_zero(), 'ABB: No yangs');\n\n            let troves_count: u64 = self.troves_count.read();\n            self.troves_count.write(troves_count + 1);\n\n            let user = get_caller_address();\n            let user_troves_count: u64 = self.user_troves_count.read(user);\n            self.user_troves_count.write(user, user_troves_count + 1);\n\n            let new_trove_id: u64 = troves_count + 1;\n            self.user_troves.write((user, user_troves_count), new_trove_id);\n            self.trove_owner.write(new_trove_id, user);\n\n            // deposit all requested Yangs into the system\n            loop {\n                match yang_assets.pop_front() {\n                    Option::Some(yang_asset) => { self.deposit_helper(new_trove_id, user, *yang_asset); },\n                    Option::None => { break; }\n                };\n            };\n\n            // forge Yin\n            self.shrine.read().forge(user, new_trove_id, forge_amount, max_forge_fee_pct);\n\n            self.emit(TroveOpened { user, trove_id: new_trove_id });\n\n            new_trove_id\n        }\n\n        // close a trove, repaying its debt in full and withdrawing all the Yangs\n        fn close_trove(ref self: ContractState, trove_id: u64) {\n            let user = get_caller_address();\n            self.assert_trove_owner(user, trove_id);\n\n            let shrine = self.shrine.read();\n            // melting \"max Wad\" to instruct Shrine to melt *all* of trove's debt\n            shrine.melt(user, trove_id, BoundedWad::max());\n\n            let mut yangs: Span<ContractAddress> = self.sentinel.read().get_yang_addresses();\n            // withdraw each and every Yang belonging to the trove from the system\n            loop {\n                match yangs.pop_front() {\n                    Option::Some(yang) => {\n                        let yang_amount: Wad = shrine.get_deposit(*yang, trove_id);\n                        if yang_amount.is_zero() {\n                            continue;\n                        }\n                        self.withdraw_helper(trove_id, user, *yang, yang_amount);\n                    },\n                    Option::None => { break; }\n                };\n            };\n\n            self.emit(TroveClosed { trove_id });\n        }\n\n        // add Yang (an asset) to a trove\n        fn deposit(ref self: ContractState, trove_id: u64, yang_asset: AssetBalance) {\n            // There is no need to check the yang address is non-zero because the\n            // Sentinel does not allow a zero address yang to be added.\n\n            assert(trove_id != 0, 'ABB: Trove ID cannot be 0');\n            assert(trove_id <= self.troves_count.read(), 'ABB: Non-existent trove');\n            // note that caller does not need to be the trove's owner to deposit\n\n            self.deposit_helper(trove_id, get_caller_address(), yang_asset);\n        }\n\n        // remove Yang (an asset) from a trove\n        fn withdraw(ref self: ContractState, trove_id: u64, yang_asset: AssetBalance) {\n            // There is no need to check the yang address is non-zero because the\n            // Sentinel does not allow a zero address yang to be added.\n\n            let user = get_caller_address();\n            self.assert_trove_owner(user, trove_id);\n\n            let yang_amt: Wad = self.sentinel.read().convert_to_yang(yang_asset.address, yang_asset.amount);\n            self.withdraw_helper(trove_id, user, yang_asset.address, yang_amt);\n        }\n\n        // create Yin in a trove\n        fn forge(ref self: ContractState, trove_id: u64, amount: Wad, max_forge_fee_pct: Wad) {\n            let user = get_caller_address();\n            self.assert_trove_owner(user, trove_id);\n            self.shrine.read().forge(user, trove_id, amount, max_forge_fee_pct);\n        }\n\n        // destroy Yin from a trove\n        fn melt(ref self: ContractState, trove_id: u64, amount: Wad) {\n            // note that caller does not need to be the trove's owner to melt\n            self.shrine.read().melt(get_caller_address(), trove_id, amount);\n        }\n    }\n\n    //\n    // Internal Abbot functions\n    //\n\n    #[generate_trait]\n    impl AbbotHelpers of AbbotHelpersTrait {\n        #[inline(always)]\n        fn assert_trove_owner(self: @ContractState, user: ContractAddress, trove_id: u64) {\n            assert(user == self.trove_owner.read(trove_id), 'ABB: Not trove owner')\n        }\n\n        #[inline(always)]\n        fn deposit_helper(ref self: ContractState, trove_id: u64, user: ContractAddress, yang_asset: AssetBalance) {\n            // reentrancy guard is used as a precaution\n            self.reentrancy_guard.start();\n\n            let yang_amt: Wad = self.sentinel.read().enter(yang_asset.address, user, trove_id, yang_asset.amount);\n            self.shrine.read().deposit(yang_asset.address, trove_id, yang_amt);\n\n            self.reentrancy_guard.end();\n        }\n\n        #[inline(always)]\n        fn withdraw_helper(\n            ref self: ContractState, trove_id: u64, user: ContractAddress, yang: ContractAddress, yang_amt: Wad\n        ) {\n            // reentrancy guard is used as a precaution\n            self.reentrancy_guard.start();\n\n            self.sentinel.read().exit(yang, user, trove_id, yang_amt);\n            self.shrine.read().withdraw(yang, trove_id, yang_amt);\n\n            self.reentrancy_guard.end();\n        }\n    }\n}"
    }
  ]
}