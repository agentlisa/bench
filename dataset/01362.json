{
  "Title": "Execution of `LibLegacyTokenSilo:: balanceOfGrownStalkUpToStemsDeployment` can end earlier when `lastUpdate == stemStartSeason`",
  "Content": "Currently, `LibLegacyTokenSilo:: balanceOfGrownStalkUpToStemsDeployment` [returns zero](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Silo/LibLegacyTokenSilo.sol#L188) if the last update season is greater than the Stems deployment season, given this implies the account has already been credited the grown Stalk it was owed. This optimization can also be made when the last update season is equal to the Stems deployment season, as the [multiplication](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Silo/LibLegacyTokenSilo.sol#L220) of the account's Seeds by a season difference of zero yields zero outstanding grown Stalk.\n\n```diff\n- if (lastUpdate > stemStartSeason) return 0;\n+ if (lastUpdate >= stemStartSeason) return 0;\n```",
  "Impact": "GAS",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/libraries/Silo/LibLegacyTokenSilo.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"../../C.sol\";\nimport \"./LibSilo.sol\";\nimport \"./LibUnripeSilo.sol\";\nimport \"../LibAppStorage.sol\";\nimport {LibSafeMathSigned128} from \"contracts/libraries/LibSafeMathSigned128.sol\";\nimport {LibSafeMath32} from \"contracts/libraries/LibSafeMath32.sol\";\nimport {LibSafeMath128} from \"contracts/libraries/LibSafeMath128.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport {LibBytes} from \"contracts/libraries/LibBytes.sol\";\nimport \"@openzeppelin/contracts/cryptography/MerkleProof.sol\";\n\n/**\n * @title LibLegacyTokenSilo\n * @author Publius, pizzaman1337\n * @notice Contains legacy silo logic, used for migrating to the\n * new SiloV3 stems-based system, and for claiming in-flight withdrawals\n * from the old silo system.\n * \n * After all Silos are migrated to V3 and all deposits are claimed, this \n * library should no longer be necessary.\n */\nlibrary LibLegacyTokenSilo {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using LibSafeMathSigned128 for int128;\n    using LibSafeMathSigned96 for int96;\n    using LibSafeMath32 for uint32;\n    using LibSafeMath128 for uint128;\n\n    //to get the new root, run `node scripts/silov3-merkle/stems_merkle.js`\n    bytes32 constant DISCREPANCY_MERKLE_ROOT = 0xa84dc86252c556839dff46b290f0c401088a65584aa38a163b6b3f7dd7a5b0e8;\n    uint32 constant ENROOT_FIX_SEASON = 12793; //season in which enroot ebip-8 fix was deployed\n\n\n    //this is the legacy seasons-based remove deposits event, emitted on migration\n    event RemoveDeposit(\n        address indexed account,\n        address indexed token,\n        uint32 season,\n        uint256 amount\n    );\n\n    //legacy seeds balanced changed event, used upon migration\n    event SeedsBalanceChanged(\n        address indexed account,\n        int256 delta\n    );\n\n    //legacy stalk balanced changed event, used upon migration\n    event StalkBalanceChanged(\n        address indexed account,\n        int256 delta,\n        int256 deltaRoots\n    );\n\n    /// @dev these events are grandfathered for claiming deposits. \n    event RemoveWithdrawals(\n        address indexed account,\n        address indexed token,\n        uint32[] seasons,\n        uint256 amount\n    );\n    event RemoveWithdrawal(\n        address indexed account,\n        address indexed token,\n        uint32 season,\n        uint256 amount\n    );\n\n    struct MigrateData {\n        uint128 totalSeeds;\n        uint128 totalGrownStalk;\n    }\n\n    struct PerDepositData {\n        uint32 season;\n        uint128 amount;\n        uint128 grownStalk;\n    }\n\n    struct PerTokenData {\n        address token;\n        int96 stemTip;\n    }\n\n    //////////////////////// REMOVE DEPOSIT ////////////////////////\n\n    /**\n     * @dev Remove `amount` of `token` from a user's Deposit in `season`.\n     *\n     * A \"Crate\" refers to the existing Deposit in storage at:\n     *  `s.a[account].legacyDeposits[token][season]`\n     *\n     * Partially removing a Deposit should scale its BDV proportionally. For ex.\n     * removing 80% of the tokens from a Deposit should reduce its BDV by 80%.\n     *\n     * During an update, `amount` & `bdv` are cast uint256 -> uint128 to\n     * optimize storage cost, since both values can be packed into one slot.\n     *\n     * This function DOES **NOT** EMIT a {RemoveDeposit} event. This\n     * asymmetry occurs because {removeDepositFromAccount} is called in a loop\n     * in places where multiple deposits are removed simultaneously, including\n     * {TokenSilo-removeDepositsFromAccount} and {TokenSilo-_transferDeposits}.\n     */\n    function removeDepositFromAccount(\n        address account,\n        address token,\n        uint32 season,\n        uint256 amount\n    ) internal returns (uint256 crateBDV) {\n        \n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        uint256 crateAmount;\n        (crateAmount, crateBDV) = (\n            s.a[account].legacyDeposits[token][season].amount,\n            s.a[account].legacyDeposits[token][season].bdv\n        );\n\n        // If amount to remove is greater than the amount in the Deposit, migrate legacy Deposit to new Deposit\n        if (amount > crateAmount) {\n            // If Unripe Deposit, fetch whole Deposit balance and delete legacy deposit references.\n            if (LibUnripeSilo.isUnripeBean(token)) {\n                (crateAmount, crateBDV) = LibUnripeSilo.unripeBeanDeposit(account, season);\n                LibUnripeSilo.removeLegacyUnripeBeanDeposit(account, season);\n            } else if (LibUnripeSilo.isUnripeLP(token)) {\n                (crateAmount, crateBDV) = LibUnripeSilo.unripeLPDeposit(account, season);\n                LibUnripeSilo.removeLegacyUnripeLPDeposit(account, season);\n            }\n            require(crateAmount >= amount, \"Silo: Crate balance too low.\");\n        }\n\n        // Partial Withdraw\n        if (amount < crateAmount) {\n            uint256 removedBDV = amount.mul(crateBDV).div(crateAmount);\n            uint256 updatedBDV = crateBDV.sub(removedBDV);\n            uint256 updatedAmount = crateAmount.sub(amount);\n            require(\n                updatedBDV <= uint128(-1) && updatedAmount <= uint128(-1),\n                \"Silo: uint128 overflow.\"\n            );\n\n            s.a[account].legacyDeposits[token][season].amount = uint128(\n                updatedAmount\n            );\n            s.a[account].legacyDeposits[token][season].bdv = uint128(\n                updatedBDV\n            );\n\n            return removedBDV;\n        }\n\n        // Full Remove\n        delete s.a[account].legacyDeposits[token][season];\n    }\n\n    //////////////////////// GETTERS ////////////////////////\n\n\n    /**\n     * @notice Returns the balance of Grown Stalk for `account` up until the\n     * Stems deployment season.\n     * @dev The balance of Grown Stalk for an account can be calculated as:\n     *\n     * ```\n     * elapsedSeasons = currentSeason - lastUpdatedSeason\n     * grownStalk = balanceOfSeeds * elapsedSeasons\n     * ```\n     */\n    function balanceOfGrownStalkUpToStemsDeployment(address account)\n        internal\n        view\n        returns (uint256)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        uint32 stemStartSeason = uint32(s.season.stemStartSeason);\n        uint32 lastUpdate = s.a[account].lastUpdate;\n\n        if (lastUpdate > stemStartSeason) return 0; \n        return\n            stalkReward(\n                s.a[account].s.seeds,\n                stemStartSeason.sub(lastUpdate)\n            );\n    }\n\n    /**\n     * @param seeds The number of Seeds held.\n     * @param seasons The number of Seasons that have elapsed.\n     *\n     * @dev Calculates the Stalk that has Grown from a given number of Seeds\n     * over a given number of Seasons.\n     *\n     * Each Seed yields 1E-4 (0.0001, or 1 / 10_000) Stalk per Season.\n     *\n     * Seasons is measured to 0 decimals. There are no fractional Seasons.\n     * Seeds are measured to 6 decimals.\n     * Stalk is measured to 10 decimals.\n     * \n     * Example:\n     *  - `seeds = 1E6` (1 Seed)\n     *  - `seasons = 1` (1 Season)\n     *  - The result is `1E6 * 1 = 1E6`. Since Stalk is measured to 10 decimals,\n     *    this is `1E6/1E10 = 1E-4` Stalk.\n     */\n    function stalkReward(uint256 seeds, uint32 seasons)\n        internal\n        pure\n        returns (uint256)\n    {\n        return seeds.mul(seasons);\n    }\n\n    /** \n     * @notice Calculates stem based on input season\n     * @param seedsPerBdv Seeds per bdv for the token you want to find the corresponding stem for\n     * @param season The season you want to find the corresponding stem for\n     *\n     * @dev Used by the mowAndMigrate function to convert seasons to stems, to know which\n     * stem to deposit in for the new Silo storage system.\n     */\n    function seasonToStem(uint256 seedsPerBdv, uint32 season)\n        internal\n        view\n        returns (int96 stem)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        \n        require(seedsPerBdv > 0, \"Silo: Token not supported\");\n\n        //need to go back in time, calculate the delta between the current season and that old deposit season,\n        //and that's how many seasons back we need to go. Then, multiply that by seedsPerBdv, and that's our\n        //negative grown stalk index.\n\n        //find the difference between the input season and the Silo v3 epoch season\n        stem = (int96(season).sub(int96(s.season.stemStartSeason))).mul(int96(seedsPerBdv));\n    }\n\n    /** \n     * @notice Migrates farmer's deposits from old (seasons based) to new silo (stems based).\n     * @param account Address of the account to migrate\n     *\n     * @dev If a user's lastUpdate was set, which means they previously had deposits in the silo.\n     * if they currently do not have any deposits to migrate, then this function \n     * can be used to migrate their account to the new silo cheaply.\n     */\n   function _migrateNoDeposits(address account) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(s.a[account].s.seeds == 0, \"only for zero seeds\");\n        \n        require(LibSilo.migrationNeeded(account), \"no migration needed\");\n\n        s.a[account].lastUpdate = s.season.stemStartSeason;\n    }\n\n    /** \n     * @notice Migrates farmer's deposits from old (seasons based) to new silo (stems based).\n     * @param account Address of the account to migrate\n     * @param tokens Array of tokens to migrate\n     * @param seasons The seasons in which the deposits were made\n     * @param amounts The amounts of those deposits which are to be migrated\n     *\n     * @dev When migrating an account, you must submit all of the account's deposits,\n     * or the migration will not pass because the seed check will fail. The seed check\n     * adds up the BDV of all submitted deposits, and multiples by the corresponding\n     * seed amount for each token type, then compares that to the total seeds stored for that user.\n     * If everything matches, we know all deposits were submitted, and the migration is valid.\n     *\n     * Deposits are migrated to the stem storage system on a 1:1 basis. Accounts with\n     * lots of deposits may take a considerable amount of gas to migrate.\n     * \n     * Returns seeds diff compared to stored amount, for verification in merkle check.\n     */\n    function _mowAndMigrate(\n        address account, \n        address[] calldata tokens, \n        uint32[][] calldata seasons,\n        uint256[][] calldata amounts\n    ) internal returns (uint256) {\n        //The balanceOfSeeds(account) > 0 check is necessary if someone updates their Silo\n        //in the same Season as BIP execution. Such that s.a[account].lastUpdate == s.season.stemStartSeason,\n        //but they have not migrated yet\n        require((LibSilo.migrationNeeded(account) || balanceOfSeeds(account) > 0), \"no migration needed\");\n\n\n        //do a legacy mow using the old silo seasons deposits\n        LibSilo.mintGrownStalk(account, balanceOfGrownStalkUpToStemsDeployment(account)); //should only mint stalk up to stemStartSeason\n        updateLastUpdateToNow(account);\n        //at this point we've completed the guts of the old mow function, now we need to do the migration\n \n        MigrateData memory migrateData;\n \n        // use of PerTokenData and PerDepositData structs to save on stack depth\n        for (uint256 i = 0; i < tokens.length; i++) {\n            PerTokenData memory perTokenData;\n            perTokenData.token = tokens[i];\n            perTokenData.stemTip = LibTokenSilo.stemTipForToken(perTokenData.token);\n \n            for (uint256 j = 0; j < seasons[i].length; j++) {\n                PerDepositData memory perDepositData;\n                perDepositData.season = seasons[i][j];\n                perDepositData.amount = amounts[i][j].toUint128();\n \n                if (perDepositData.amount == 0) {\n                    // skip deposit calculations if amount deposited in deposit is 0\n                    continue;\n                }\n \n                // withdraw this deposit\n                uint256 crateBDV = removeDepositFromAccount(\n                                    account,\n                                    perTokenData.token,\n                                    perDepositData.season,\n                                    perDepositData.amount\n                                );\n \n                //calculate how much stalk has grown for this deposit\n                perDepositData.grownStalk = _calcGrownStalkForDeposit(\n                    crateBDV.mul(getSeedsPerToken(address(perTokenData.token))),\n                    perDepositData.season\n                );\n \n                // also need to calculate how much stalk has grown since the migration\n                uint128 stalkGrownSinceStemStartSeason = LibSilo.stalkReward(0, perTokenData.stemTip, crateBDV.toUint128()).toUint128();\n                perDepositData.grownStalk = perDepositData.grownStalk.add(stalkGrownSinceStemStartSeason);\n                migrateData.totalGrownStalk = migrateData.totalGrownStalk.add(stalkGrownSinceStemStartSeason);\n \n                // add to new silo\n                LibTokenSilo.addDepositToAccount(\n                    account, \n                    perTokenData.token, \n                    LibTokenSilo.grownStalkAndBdvToStem(\n                        perTokenData.token, \n                        perDepositData.grownStalk,\n                        crateBDV\n                    ), \n                    perDepositData.amount, \n                    crateBDV,\n                    LibTokenSilo.Transfer.emitTransferSingle\n                );\n\n                // Include Deposit in the total Deposited BDV.\n                LibTokenSilo.incrementTotalDepositedBdv(perTokenData.token, crateBDV);\n \n                // add to running total of seeds\n                migrateData.totalSeeds = migrateData.totalSeeds.add(crateBDV.mul(getSeedsPerToken(address(perTokenData.token))).toUint128());\n\n                // emit legacy RemoveDeposit event\n                emit RemoveDeposit(account, perTokenData.token, perDepositData.season, perDepositData.amount);\n            }\n \n            // init mow status for this token\n            setMowStatus(account, perTokenData.token, perTokenData.stemTip);\n        }\n \n        // user deserves stalk grown between stemStartSeason and now\n        LibSilo.mintGrownStalk(account, migrateData.totalGrownStalk);\n\n        //return seeds diff for checking in the \"part 2\" of this function (stack depth kept it from all fitting in one)\n        return balanceOfSeeds(account).sub(migrateData.totalSeeds);\n    }\n\n    function _mowAndMigrateMerkleCheck(\n        address account,\n        uint256 stalkDiff,\n        uint256 seedsDiff,\n        bytes32[] calldata proof,\n        uint256 seedsVariance\n    ) internal {\n        if (seedsDiff > 0) {\n            //verify merkle tree to determine stalk/seeds diff drift from convert issue\n            bytes32 leaf = keccak256(abi.encode(account, stalkDiff, seedsDiff));\n            \n            require(\n                MerkleProof.verify(proof, DISCREPANCY_MERKLE_ROOT, leaf),\n                \"UnripeClaim: invalid proof\"\n            );\n        }\n\n        //make sure seedsVariance equals seedsDiff input\n        require(seedsVariance == seedsDiff, \"seeds misalignment, double check submitted deposits\");\n\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        //emit that all their seeds are gone, note need to take into account seedsDiff\n        emit SeedsBalanceChanged(account, -int256(s.a[account].s.seeds));\n\n        //and wipe out old seed balances (all your seeds are belong to stem)\n        setBalanceOfSeeds(account, 0);\n\n        //stalk diff was calculated based on ENROOT_FIX_SEASON, so we need to calculate\n        //the amount of stalk that has grown since then\n        if (seedsDiff > 0) {\n            uint256 currentStalkDiff = (uint256(s.season.current).sub(ENROOT_FIX_SEASON)).mul(seedsDiff).add(stalkDiff);\n\n            //emit the stalk variance\n            if (currentStalkDiff > 0) {\n                LibSilo.burnStalk(account, currentStalkDiff);\n            }\n        }\n    }\n\n    /**\n     * @dev Updates the lastStem of a given token for an account to the latest Tip.\n     */\n    function setMowStatus(address account, address token, int96 stemTip) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.a[account].mowStatuses[token].lastStem = stemTip;\n    }\n\n    /**\n     * @dev Season getter.\n     */\n    function _season() internal view returns (uint32) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.season.current;\n    }\n\n    /**\n     * @notice DEPRECATED: Seeds do not exist in the new system, but will remain as a\n     * user facing concept for the time being.\n     * \n     * @dev Legacy Seed balance getter.\n     * \n     */\n    function balanceOfSeeds(address account) internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.a[account].s.seeds;\n    }\n\n    /**\n     * @notice DEPRECATED: Seeds do not exist in the new system,\n     * but will remain as a user facing concept for the time being.\n     * \n     * @dev sets the seed for an given account.\n     * \n     */\n    function setBalanceOfSeeds(address account, uint256 seeds) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.a[account].s.seeds = seeds;\n    }\n\n    /**\n     * @dev Updates `lastUpdate` of an account to the current season.\n     */\n    function updateLastUpdateToNow(address account) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.a[account].lastUpdate = _season();\n    }\n\n    /**\n     * @dev Calculates the amount of stalk thats been grown for a given deposit.\n     */\n    function _calcGrownStalkForDeposit(\n        uint256 seedsForDeposit,\n        uint32 season\n    ) internal view returns (uint128 grownStalk) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint32 stemStartSeason = uint32(s.season.stemStartSeason);\n        return uint128(stalkReward(seedsForDeposit, stemStartSeason - season));\n    }\n\n    /**\n     * @dev Legacy Seed balance getter.\n     * \n     * constants are used in favor of reading from storage for gas savings.\n     */\n    function getSeedsPerToken(address token) internal pure returns (uint256) {\n        if (token == C.BEAN) {\n            return 2;\n        } else if (token == C.UNRIPE_BEAN) {\n            return 2;\n        } else if (token == C.UNRIPE_LP) {\n            return 4;\n        } else if (token == C.CURVE_BEAN_METAPOOL) {\n            return 4;\n        }\n        return 0;\n    }\n\n    ////////////////////////// CLAIM ///////////////////////////////\n\n    /** \n     * @notice DEPRECATED. Internal logic for claiming a singular deposit.\n     * \n     * @dev The Zero Withdraw update removed the two-step withdraw & claim process. \n     * These internal functions are left for backwards compatibility, to allow pending \n     * withdrawals from before the update to be claimed.\n     */\n    function _claimWithdrawal(\n        address account,\n        address token,\n        uint32 season\n    ) internal returns (uint256) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 amount = _removeTokenWithdrawal(account, token, season);\n        s.siloBalances[token].withdrawn = s.siloBalances[token].withdrawn.sub(\n            amount\n        );\n        emit RemoveWithdrawal(msg.sender, token, season, amount);\n        return amount;\n    }\n\n    /** \n     * @notice DEPRECATED. Internal logic for claiming multiple deposits.\n     * \n     * @dev The Zero Withdraw update removed the two-step withdraw & claim process. \n     * These internal functions are left for backwards compatibility, to allow pending \n     * withdrawals from before the update to be claimed.\n     */\n    function _claimWithdrawals(\n        address account,\n        address token,\n        uint32[] calldata seasons\n    ) internal returns (uint256 amount) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        \n        for (uint256 i; i < seasons.length; ++i) {\n            amount = amount.add(\n                _removeTokenWithdrawal(account, token, seasons[i])\n            );\n        }\n        s.siloBalances[token].withdrawn = s.siloBalances[token].withdrawn.sub(\n            amount\n        );\n        emit RemoveWithdrawals(msg.sender, token, seasons, amount);\n        return amount;\n    }\n\n    /** \n     * @notice DEPRECATED. Internal logic for removing the claim multiple deposits.\n     * \n     * @dev The Zero Withdraw update removed the two-step withdraw & claim process. \n     * These internal functions are left for backwards compatibility, to allow pending \n     * withdrawals from before the update to be claimed.\n     */\n    function _removeTokenWithdrawal(\n        address account,\n        address token,\n        uint32 season\n    ) private returns (uint256) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        require(\n            season <= s.season.current,\n            \"Claim: Withdrawal not receivable\"\n        );\n        uint256 amount = s.a[account].withdrawals[token][season];\n        delete s.a[account].withdrawals[token][season];\n        return amount;\n    }\n}"
    }
  ]
}