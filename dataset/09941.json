{
  "Title": "[M-03] Profile creation can be frontrun",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-02-aave-lens/blob/aaf6c116345f3647e11a35010f28e3b90e7b4862/contracts/libraries/PublishingLogic.sol#L50\n\n\n# Vulnerability details\n\n## Impact\nThe `LensHub/PublishingLogic.createProfile` function can be frontrun by other whitelisted profile creators.\nAn attacker can observe pending `createProfile` transactions and frontrun them, own that handle, and demand ransom from the original transaction creator.\n\n## Recommended Mitigation Steps\nEveryone needs to use flashbots / private transactions but it might not be available on the deployed chain.\nA commit/reveal scheme for the handle and the entire profile creation could mitigate this issue.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-aave-lens-contest",
  "Code": [
    {
      "filename": "contracts/libraries/PublishingLogic.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {Helpers} from './Helpers.sol';\nimport {DataTypes} from './DataTypes.sol';\nimport {Errors} from './Errors.sol';\nimport {Events} from './Events.sol';\nimport {Constants} from './Constants.sol';\nimport {IFollowModule} from '../interfaces/IFollowModule.sol';\nimport {ICollectModule} from '../interfaces/ICollectModule.sol';\nimport {IReferenceModule} from '../interfaces/IReferenceModule.sol';\n\n/**\n * @title PublishingLogic\n * @author Lens Protocol\n *\n * @notice This is the library that contains the logic for profile creation & publication.\n *\n * @dev The functions are external, so they are called from the hub via `delegateCall` under the hood. Furthermore,\n * expected events are emitted from this library instead of from the hub to alleviate code size concerns.\n */\nlibrary PublishingLogic {\n    /**\n     * @notice Executes the logic to create a profile with the given parameters to the given address.\n     *\n     * @param vars The CreateProfileData struct containing the following parameters:\n     *      to: The address receiving the profile.\n     *      handle: The handle to set for the profile, must be unique and non-empty.\n     *      imageURI: The URI to set for the profile image.\n     *      followModule: The follow module to use, can be the zero address.\n     *      followModuleData: The follow module initialization data, if any\n     *      followNFTURI: The URI to set for the follow NFT.\n     * @param profileId The profile ID to associate with this profile NFT (token ID).\n     * @param _profileIdByHandleHash The storage reference to the mapping of profile IDs by handle hash.\n     * @param _profileById The storage reference to the mapping of profile structs by IDs.\n     * @param _followModuleWhitelisted The storage reference to the mapping of whitelist status by follow module address.\n     */\n    function createProfile(\n        DataTypes.CreateProfileData calldata vars,\n        uint256 profileId,\n        mapping(bytes32 => uint256) storage _profileIdByHandleHash,\n        mapping(uint256 => DataTypes.ProfileStruct) storage _profileById,\n        mapping(address => bool) storage _followModuleWhitelisted\n    ) external {\n        _validateHandle(vars.handle);\n\n        bytes32 handleHash = keccak256(bytes(vars.handle));\n\n        if (_profileIdByHandleHash[handleHash] != 0) revert Errors.HandleTaken();\n        _profileIdByHandleHash[handleHash] = profileId;\n\n        _profileById[profileId].handle = vars.handle;\n        _profileById[profileId].imageURI = vars.imageURI;\n        _profileById[profileId].followNFTURI = vars.followNFTURI;\n\n        if (vars.followModule != address(0)) {\n            _profileById[profileId].followModule = vars.followModule;\n        }\n\n        bytes memory followModuleReturnData = _initFollowModule(\n            profileId,\n            vars.followModule,\n            vars.followModuleData,\n            _followModuleWhitelisted\n        );\n\n        _emitProfileCreated(profileId, vars, followModuleReturnData);\n    }\n\n    /**\n     * @notice Sets the follow module for a given profile.\n     *\n     * @param profileId The profile ID to set the follow module for.\n     * @param followModule The follow module to set for the given profile, if any.\n     * @param followModuleData The data to pass to the follow module for profile initialization.\n     * @param _profile The storage reference to the profile struct associated with the given profile ID.\n     * @param _followModuleWhitelisted The storage reference to the mapping of whitelist status by follow module address.\n     */\n    function setFollowModule(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleData,\n        DataTypes.ProfileStruct storage _profile,\n        mapping(address => bool) storage _followModuleWhitelisted\n    ) external {\n        address prevFollowModule = _profile.followModule;\n        if (followModule != prevFollowModule) {\n            _profile.followModule = followModule;\n        }\n\n        bytes memory followModuleReturnData = _initFollowModule(\n            profileId,\n            followModule,\n            followModuleData,\n            _followModuleWhitelisted\n        );\n        emit Events.FollowModuleSet(\n            profileId,\n            followModule,\n            followModuleReturnData,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Creates a post publication mapped to the given profile.\n     *\n     * @dev To avoid a stack too deep error, reference parameters are passed in memory rather than calldata.\n     *\n     * @param profileId The profile ID to associate this publication to.\n     * @param contentURI The URI to set for this publication.\n     * @param collectModule The collect module to set for this publication.\n     * @param collectModuleData The data to pass to the collect module for publication initialization.\n     * @param referenceModule The reference module to set for this publication, if any.\n     * @param referenceModuleData The data to pass to the reference module for publication initialization.\n     * @param pubId The publication ID to associate with this publication.\n     * @param _pubByIdByProfile The storage reference to the mapping of publications by publication ID by profile ID.\n     * @param _collectModuleWhitelisted The storage reference to the mapping of whitelist status by collect module address.\n     * @param _referenceModuleWhitelisted The storage reference to the mapping of whitelist status by reference module address.\n     */\n    function createPost(\n        uint256 profileId,\n        string memory contentURI,\n        address collectModule,\n        bytes memory collectModuleData,\n        address referenceModule,\n        bytes memory referenceModuleData,\n        uint256 pubId,\n        mapping(uint256 => mapping(uint256 => DataTypes.PublicationStruct))\n            storage _pubByIdByProfile,\n        mapping(address => bool) storage _collectModuleWhitelisted,\n        mapping(address => bool) storage _referenceModuleWhitelisted\n    ) external {\n        _pubByIdByProfile[profileId][pubId].contentURI = contentURI;\n\n        // Collect module initialization\n        bytes memory collectModuleReturnData = _initPubCollectModule(\n            profileId,\n            pubId,\n            collectModule,\n            collectModuleData,\n            _pubByIdByProfile,\n            _collectModuleWhitelisted\n        );\n\n        // Reference module initialization\n        bytes memory referenceModuleReturnData = _initPubReferenceModule(\n            profileId,\n            pubId,\n            referenceModule,\n            referenceModuleData,\n            _pubByIdByProfile,\n            _referenceModuleWhitelisted\n        );\n\n        emit Events.PostCreated(\n            profileId,\n            pubId,\n            contentURI,\n            collectModule,\n            collectModuleReturnData,\n            referenceModule,\n            referenceModuleReturnData,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Creates a comment publication mapped to the given profile.\n     *\n     * @dev This function is unique in that it requires many variables, so, unlike the other publishing functions,\n     * we need to pass the full CommentData struct in memory to avoid a stack too deep error.\n     *\n     * @param vars The CommentData struct to use to create the comment.\n     * @param pubId The publication ID to associate with this publication.\n     * @param _profileById The storage reference to the mapping of profile structs by IDs.\n     * @param _pubByIdByProfile The storage reference to the mapping of publications by publication ID by profile ID.\n     * @param _collectModuleWhitelisted The storage reference to the mapping of whitelist status by collect module address.\n     * @param _referenceModuleWhitelisted The storage reference to the mapping of whitelist status by reference module address.\n     */\n    function createComment(\n        DataTypes.CommentData memory vars,\n        uint256 pubId,\n        mapping(uint256 => DataTypes.ProfileStruct) storage _profileById,\n        mapping(uint256 => mapping(uint256 => DataTypes.PublicationStruct))\n            storage _pubByIdByProfile,\n        mapping(address => bool) storage _collectModuleWhitelisted,\n        mapping(address => bool) storage _referenceModuleWhitelisted\n    ) external {\n        // Validate existence of the pointed publication\n        uint256 pubCount = _profileById[vars.profileIdPointed].pubCount;\n        if (pubCount < vars.pubIdPointed || vars.pubIdPointed == 0)\n            revert Errors.PublicationDoesNotExist();\n\n        _pubByIdByProfile[vars.profileId][pubId].contentURI = vars.contentURI;\n        _pubByIdByProfile[vars.profileId][pubId].profileIdPointed = vars.profileIdPointed;\n        _pubByIdByProfile[vars.profileId][pubId].pubIdPointed = vars.pubIdPointed;\n\n        // Collect Module Initialization\n        bytes memory collectModuleReturnData = _initPubCollectModule(\n            vars.profileId,\n            pubId,\n            vars.collectModule,\n            vars.collectModuleData,\n            _pubByIdByProfile,\n            _collectModuleWhitelisted\n        );\n\n        // Reference module initialization\n        bytes memory referenceModuleReturnData = _initPubReferenceModule(\n            vars.profileId,\n            pubId,\n            vars.referenceModule,\n            vars.referenceModuleData,\n            _pubByIdByProfile,\n            _referenceModuleWhitelisted\n        );\n\n        // Reference module validation\n        address refModule = _pubByIdByProfile[vars.profileIdPointed][vars.pubIdPointed]\n            .referenceModule;\n        if (refModule != address(0)) {\n            IReferenceModule(refModule).processComment(\n                vars.profileId,\n                vars.profileIdPointed,\n                vars.pubIdPointed\n            );\n        }\n\n        // Prevents a stack too deep error\n        _emitCommentCreated(vars, pubId, collectModuleReturnData, referenceModuleReturnData);\n    }\n\n    /**\n     * @notice Creates a mirror publication mapped to the given profile.\n     *\n     * @param profileId The profile ID to associate this publication to.\n     * @param profileIdPointed The profile ID of the pointed publication's publisher.\n     * @param pubIdPointed The pointed publication's publication ID.\n     * @param referenceModule The reference module to set for this publication, if any.\n     * @param referenceModuleData The data to pass to the reference module for publication initialization.\n     * @param pubId The publication ID to associate with this publication.\n     * @param _pubByIdByProfile The storage reference to the mapping of publications by publication ID by profile ID.\n     * @param _referenceModuleWhitelisted The storage reference to the mapping of whitelist status by reference module address.\n     */\n    function createMirror(\n        uint256 profileId,\n        uint256 profileIdPointed,\n        uint256 pubIdPointed,\n        address referenceModule,\n        bytes calldata referenceModuleData,\n        uint256 pubId,\n        mapping(uint256 => mapping(uint256 => DataTypes.PublicationStruct))\n            storage _pubByIdByProfile,\n        mapping(address => bool) storage _referenceModuleWhitelisted\n    ) external {\n        (uint256 rootProfileIdPointed, uint256 rootPubIdPointed, ) = Helpers.getPointedIfMirror(\n            profileIdPointed,\n            pubIdPointed,\n            _pubByIdByProfile\n        );\n\n        _pubByIdByProfile[profileId][pubId].profileIdPointed = rootProfileIdPointed;\n        _pubByIdByProfile[profileId][pubId].pubIdPointed = rootPubIdPointed;\n\n        // Reference module initialization\n        bytes memory referenceModuleReturnData = _initPubReferenceModule(\n            profileId,\n            pubId,\n            referenceModule,\n            referenceModuleData,\n            _pubByIdByProfile,\n            _referenceModuleWhitelisted\n        );\n\n        // Reference module validation\n        address refModule = _pubByIdByProfile[rootProfileIdPointed][rootPubIdPointed]\n            .referenceModule;\n        if (refModule != address(0)) {\n            IReferenceModule(refModule).processMirror(\n                profileId,\n                rootProfileIdPointed,\n                rootPubIdPointed\n            );\n        }\n\n        emit Events.MirrorCreated(\n            profileId,\n            pubId,\n            rootProfileIdPointed,\n            rootPubIdPointed,\n            referenceModule,\n            referenceModuleReturnData,\n            block.timestamp\n        );\n    }\n\n    function _initPubCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        address collectModule,\n        bytes memory collectModuleData,\n        mapping(uint256 => mapping(uint256 => DataTypes.PublicationStruct))\n            storage _pubByIdByProfile,\n        mapping(address => bool) storage _collectModuleWhitelisted\n    ) private returns (bytes memory) {\n        if (!_collectModuleWhitelisted[collectModule]) revert Errors.CollectModuleNotWhitelisted();\n        _pubByIdByProfile[profileId][pubId].collectModule = collectModule;\n        return\n            ICollectModule(collectModule).initializePublicationCollectModule(\n                profileId,\n                pubId,\n                collectModuleData\n            );\n    }\n\n    function _initPubReferenceModule(\n        uint256 profileId,\n        uint256 pubId,\n        address referenceModule,\n        bytes memory referenceModuleData,\n        mapping(uint256 => mapping(uint256 => DataTypes.PublicationStruct))\n            storage _pubByIdByProfile,\n        mapping(address => bool) storage _referenceModuleWhitelisted\n    ) private returns (bytes memory) {\n        if (referenceModule != address(0)) {\n            if (!_referenceModuleWhitelisted[referenceModule])\n                revert Errors.ReferenceModuleNotWhitelisted();\n            _pubByIdByProfile[profileId][pubId].referenceModule = referenceModule;\n            return\n                IReferenceModule(referenceModule).initializeReferenceModule(\n                    profileId,\n                    pubId,\n                    referenceModuleData\n                );\n        } else {\n            return new bytes(0);\n        }\n    }\n\n    function _initFollowModule(\n        uint256 profileId,\n        address followModule,\n        bytes memory followModuleData,\n        mapping(address => bool) storage _followModuleWhitelisted\n    ) private returns (bytes memory) {\n        if (followModule != address(0)) {\n            if (!_followModuleWhitelisted[followModule]) revert Errors.FollowModuleNotWhitelisted();\n            bytes memory returnData = IFollowModule(followModule).initializeFollowModule(\n                profileId,\n                followModuleData\n            );\n            return returnData;\n        } else {\n            return new bytes(0);\n        }\n    }\n\n    function _emitCommentCreated(\n        DataTypes.CommentData memory vars,\n        uint256 pubId,\n        bytes memory collectModuleReturnData,\n        bytes memory referenceModuleReturnData\n    ) private {\n        emit Events.CommentCreated(\n            vars.profileId,\n            pubId,\n            vars.contentURI,\n            vars.profileIdPointed,\n            vars.pubIdPointed,\n            vars.collectModule,\n            collectModuleReturnData,\n            vars.referenceModule,\n            referenceModuleReturnData,\n            block.timestamp\n        );\n    }\n\n    function _emitProfileCreated(\n        uint256 profileId,\n        DataTypes.CreateProfileData calldata vars,\n        bytes memory followModuleReturnData\n    ) internal {\n        emit Events.ProfileCreated(\n            profileId,\n            msg.sender, // Creator is always the msg sender\n            vars.to,\n            vars.handle,\n            vars.imageURI,\n            vars.followModule,\n            followModuleReturnData,\n            vars.followNFTURI,\n            block.timestamp\n        );\n    }\n\n    function _validateHandle(string calldata handle) private pure {\n        bytes memory byteHandle = bytes(handle);\n        if (byteHandle.length == 0 || byteHandle.length > Constants.MAX_HANDLE_LENGTH)\n            revert Errors.HandleLengthInvalid();\n\n        for (uint256 i = 0; i < byteHandle.length; ++i) {\n            if (\n                (byteHandle[i] < '0' ||\n                    byteHandle[i] > 'z' ||\n                    (byteHandle[i] > '9' && byteHandle[i] < 'a')) && byteHandle[i] != '.'\n            ) revert Errors.HandleContainsInvalidCharacters();\n        }\n    }\n}"
    }
  ]
}