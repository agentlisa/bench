{
  "Title": "M-17: Users can bypass auction mechanism for `LenderCommitmentGroup_Smart` liquidation mechanism for loans that are close to end of loan",
  "Content": "# Issue M-17: Users can bypass auction mechanism for `LenderCommitmentGroup_Smart` liquidation mechanism for loans that are close to end of loan \n\nSource: https://github.com/sherlock-audit/2024-04-teller-finance-judging/issues/289 \n\n## Found by \npkqs90\n\n## Summary\n\n`LenderCommitmentGroup_Smart` has an auction mechanism for users to help liquidate default loans. The auction begins from 8x of amountOwed gradually decreasing to 0x. However, for loans that are close to end of loan, users can bypass this mechanism and pay only 1x of amountOwed to perform liquidation.\n\n## Vulnerability Detail\n\nFor loans that are close to end of loan, the calculated due date and default timestamp will not change upon a repay. See function `getLoanDefaultTimestamp()` which calls `calculateNextDueDate()`. If the calculated `dueDate` is larger than `endOfLoan`, the due date will return `endOfLoan`.\n\n```solidity\n    function getLoanDefaultTimestamp(uint256 _bidId)\n        public\n        view\n        returns (uint256)\n    {\n        Bid storage bid = bids[_bidId];\n\n        uint32 defaultDuration = _getBidDefaultDuration(_bidId);\n\n        uint32 dueDate = calculateNextDueDate(_bidId);\n\n        return dueDate + defaultDuration;\n    }\n\n    function calculateNextDueDate(\n        uint32 _acceptedTimestamp,\n        uint32 _paymentCycle,\n        uint32 _loanDuration,\n        uint32 _lastRepaidTimestamp,\n        PaymentCycleType _bidPaymentCycleType\n    ) public view returns (uint32 dueDate_) {\n        ...\n        uint32 endOfLoan = _acceptedTimestamp + _loanDuration;\n        //if we are in the last payment cycle, the next due date is the end of loan duration\n>       if (dueDate_ > endOfLoan) {\n>           dueDate_ = endOfLoan;\n>       }\n    }\n\n```\n\nThis means for a loan that is close to the end of loan, and is already default. The normal way to liquidate would be participating the auction using `liquidateDefaultedLoanWithIncentive()`.\n\nHowever, a user can first repay the collateral by `TellerV2#repayLoanFullWithoutCollateralWithdraw` and make the amountOwed equal to zero, then call `liquidateDefaultedLoanWithIncentive()` and pass `_tokenAmountDifference == 0`. Since the due date does not change upon a repay, the loan is still in default, and the user can successfully perform the liquidation.\n\nIf the user participated the auction, he would have to pay 8x the amount of tokens. However, by repaying in TellerV2, he only needs to pay 1x and can perform the liquidation.\n\n```solidity\n    function liquidateDefaultedLoanWithIncentive(\n        uint256 _bidId,\n        int256 _tokenAmountDifference\n    ) public bidIsActiveForGroup(_bidId) {\n>       uint256 amountDue = getAmountOwedForBid(_bidId, false);\n\n        uint256 loanDefaultedTimeStamp = ITellerV2(TELLER_V2)\n            .getLoanDefaultTimestamp(_bidId);\n\n>       int256 minAmountDifference = getMinimumAmountDifferenceToCloseDefaultedLoan(\n>               amountDue,\n>               loanDefaultedTimeStamp\n            );\n\n        require(\n            _tokenAmountDifference >= minAmountDifference,\n            \"Insufficient tokenAmountDifference\"\n        );\n\n        if (_tokenAmountDifference > 0) {\n            //this is used when the collateral value is higher than the principal (rare)\n            //the loan will be completely made whole and our contract gets extra funds too\n            uint256 tokensToTakeFromSender = abs(_tokenAmountDifference);\n\n            IERC20(principalToken).transferFrom(\n                msg.sender,\n                address(this),\n                amountDue + tokensToTakeFromSender\n            );\n\n            tokenDifferenceFromLiquidations += int256(tokensToTakeFromSender);\n\n            totalPrincipalTokensRepaid += amountDue;\n        } else {\n           \n            uint256 tokensToGiveToSender = abs(_tokenAmountDifference);\n\n>           IERC20(principalToken).transferFrom(\n                msg.sender,\n                address(this),\n                amountDue - tokensToGiveToSender\n            );\n\n            tokenDifferenceFromLiquidations -= int256(tokensToGiveToSender);\n\n            totalPrincipalTokensRepaid += amountDue;\n        }\n\n        //this will give collateral to the caller\n        ITellerV2(TELLER_V2).lenderCloseLoanWithRecipient(_bidId, msg.sender);\n    }\n```\n\n## Impact\n\nFor loans that are close to end of loan, users can bypass auction mechanism and pay only 1x of amountOwed to perform liquidation.\n\n## Code Snippet\n\n- https://github.com/sherlock-audit/2024-04-teller-finance/blob/main/teller-protocol-v2-audit-2024/packages/contracts/contracts/LenderCommitmentForwarder/extensions/LenderCommitmentGroup/LenderCommitmentGroup_Smart.sol#L422\n- https://github.com/sherlock-audit/2024-04-teller-finance/blob/main/teller-protocol-v2-audit-2024/packages/contracts/contracts/TellerV2.sol#L1234-L1246\n- https://github.com/sherlock-audit/2024-04-teller-finance/blob/main/teller-protocol-v2-audit-2024/packages/contracts/contracts/libraries/V2Calculations.sol#L212-L214\n\n## Tool used\n\nManual review\n\n## Recommendation\n\nIf a loan is already close to end of loan date, only allow the lender to repay.\n\n\n\n## Discussion\n\n**ethereumdegen**\n\nCan you elaborate on why this is a problem and what the code fix should be ?  perhaps with tests before and after? \n  i dont understand.  thanks . \n  \n  \n  Seems weird to say that them fully paying the loan is a problem. \n\n**ethereumdegen**\n\nOk i think this actually may pose a problem.  if the price of the collateral goes up super high, it could become a race to make these two calls .  the issue is that ANYONE can repay the loan for 1x , not that the original borrower can . \n\nWe may need to a way to allow the lender group contract to 'close' defaulted loans (that are owed to it) in such a way as to prevent anyone repaying them and thus arbitrarily modifying the \"getAmountDue\" to mess with this liquidation calculation \n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/teller-protocol/teller-protocol-v2-audit-2024/pull/41\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/295",
  "Code": [
    {
      "filename": "teller-protocol-v2-audit-2024/packages/contracts/contracts/LenderCommitmentForwarder/extensions/LenderCommitmentGroup/LenderCommitmentGroup_Smart.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Contracts\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Interfaces\nimport \"../../../interfaces/ITellerV2Context.sol\";\nimport \"../../../interfaces/IProtocolFee.sol\";\nimport \"../../../interfaces/ITellerV2Storage.sol\";\nimport \"../../../interfaces/ITellerV2.sol\";\n\nimport \"../../../interfaces/IFlashRolloverLoan.sol\";\nimport \"../../../libraries/NumbersLib.sol\";\n\nimport \"../../../interfaces/uniswap/IUniswapV3Pool.sol\";\n\nimport \"../../../interfaces/uniswap/IUniswapV3Factory.sol\";\n\nimport \"../../../libraries/uniswap/TickMath.sol\";\nimport \"../../../libraries/uniswap/FixedPoint96.sol\";\nimport \"../../../libraries/uniswap/FullMath.sol\";\n\nimport \"./LenderCommitmentGroupShares.sol\";\n\nimport { MathUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\nimport { CommitmentCollateralType, ISmartCommitment } from \"../../../interfaces/ISmartCommitment.sol\";\nimport { ILoanRepaymentListener } from \"../../../interfaces/ILoanRepaymentListener.sol\";\n\nimport { ILoanRepaymentCallbacks } from \"../../../interfaces/ILoanRepaymentCallbacks.sol\";\n\nimport { ILenderCommitmentGroup } from \"../../../interfaces/ILenderCommitmentGroup.sol\";\nimport { Payment } from \"../../../TellerV2Storage.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/*\n \n\n Each LenderCommitmentGroup SmartContract acts as its own Loan Commitment (for the SmartCommitmentForwarder) and acts as its own Lender in the Teller Protocol.\n\n Lender Users can deposit principal tokens in this contract and this will give them Share Tokens (LP tokens) representing their ownership in the liquidity pool of this contract.\n\n Borrower Users can borrow principal token funds from this contract (via the SCF contract) by providing collateral tokens in the proper amount as specified by the rules of this smart contract.\n These collateral tokens are then owned by this smart contract and are returned to the borrower via the Teller Protocol rules to the borrower if and only if the borrower repays principal and interest of the loan they took.\n\n If the borrower defaults on a loan, for 24 hours a liquidation auction is automatically conducted by this smart contract in order to incentivize a liquidator to take the collateral tokens in exchange for principal tokens.\n\n  \n \n\n*/\n\ncontract LenderCommitmentGroup_Smart is\n    ILenderCommitmentGroup,\n    ISmartCommitment,\n    ILoanRepaymentListener,\n    Initializable,\n    OwnableUpgradeable,\n    PausableUpgradeable\n{\n    using AddressUpgradeable for address;\n    using NumbersLib for uint256;\n\n    uint256 public immutable STANDARD_EXPANSION_FACTOR = 1e18;\n\n    uint256 public immutable UNISWAP_EXPANSION_FACTOR = 2**96;\n\n    uint256 public immutable EXCHANGE_RATE_EXPANSION_FACTOR = 1e36;  \n\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable TELLER_V2;\n    address public immutable SMART_COMMITMENT_FORWARDER;\n    address public immutable UNISWAP_V3_FACTORY;\n    address public UNISWAP_V3_POOL;\n \n    LenderCommitmentGroupShares public poolSharesToken;\n\n    IERC20 public principalToken;\n    IERC20 public collateralToken;\n\n    uint256 marketId;\n\n \n    uint256 public totalPrincipalTokensCommitted; \n    uint256 public totalPrincipalTokensWithdrawn;\n\n    uint256 public totalPrincipalTokensLended;\n    uint256 public totalPrincipalTokensRepaid; //subtract this and the above to find total principal tokens outstanding for loans\n\n    \n \n    uint256 public totalInterestCollected;\n\n    uint16 public liquidityThresholdPercent; //5000 is 50 pct  // enforce max of 10000\n    uint16 public collateralRatio; //the overcollateralization ratio, typically 80 pct\n\n    uint32 public twapInterval;\n    uint32 public maxLoanDuration;\n    uint16 public interestRateLowerBound;\n    uint16 public interestRateUpperBound;\n\n\n    //mapping(address => uint256) public principalTokensCommittedByLender;\n    mapping(uint256 => bool) public activeBids;\n\n    //this excludes interest\n    // maybe it is possible to get rid of this storage slot and calculate it from totalPrincipalTokensRepaid, totalPrincipalTokensLended\n    int256 tokenDifferenceFromLiquidations;\n\n\n   \n\n    modifier onlySmartCommitmentForwarder() {\n        require(\n            msg.sender == address(SMART_COMMITMENT_FORWARDER),\n            \"Can only be called by Smart Commitment Forwarder\"\n        );\n        _;\n    }\n\n    modifier onlyTellerV2() {\n        require(\n            msg.sender == address(TELLER_V2),\n            \"Can only be called by TellerV2\"\n        );\n        _;\n    }\n\n    modifier bidIsActiveForGroup(uint256 _bidId) {\n        require(activeBids[_bidId] == true, \"Bid is not active for group\");\n\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _tellerV2,\n        address _smartCommitmentForwarder,\n        address _uniswapV3Factory\n    ) {\n        TELLER_V2 = _tellerV2;\n        SMART_COMMITMENT_FORWARDER = _smartCommitmentForwarder;\n        UNISWAP_V3_FACTORY = _uniswapV3Factory;\n    }\n\n    /*\n\n\n        \n    */\n    function initialize(\n        address _principalTokenAddress,\n        address _collateralTokenAddress,\n        uint256 _marketId,\n        uint32 _maxLoanDuration,\n        uint16 _interestRateLowerBound,\n        uint16 _interestRateUpperBound,\n        uint16 _liquidityThresholdPercent, // When 100% , the entire pool can be drawn for lending.  When 80%, only 80% of the pool can be drawn for lending. \n        uint16 _collateralRatio, //the required overcollateralization ratio.  10000 is 1:1 baseline , typically this is above 10000\n        uint24 _uniswapPoolFee,\n        uint32 _twapInterval\n    ) external initializer returns (address poolSharesToken_) {\n        // require(!_initialized,\"already initialized\");\n        // _initialized = true;\n\n        __Pausable_init();\n\n        principalToken = IERC20(_principalTokenAddress);\n        collateralToken = IERC20(_collateralTokenAddress);\n\n        UNISWAP_V3_POOL = IUniswapV3Factory(UNISWAP_V3_FACTORY).getPool(\n            _principalTokenAddress,\n            _collateralTokenAddress,\n            _uniswapPoolFee\n        );\n\n        require(UNISWAP_V3_POOL != address(0), \"Invalid uniswap pool address\");\n\n        marketId = _marketId;\n\n        //in order for this to succeed, first, that SmartCommitmentForwarder needs to be THE trusted forwarder for the market\n\n         \n        ITellerV2Context(TELLER_V2).approveMarketForwarder(\n            _marketId,\n            SMART_COMMITMENT_FORWARDER\n        );\n\n        maxLoanDuration = _maxLoanDuration;\n        interestRateLowerBound = _interestRateLowerBound;\n        interestRateUpperBound = _interestRateUpperBound;\n\n\n        \n        \n        require(interestRateLowerBound <= interestRateUpperBound, \"invalid _interestRateLowerBound\");\n\n        require(_liquidityThresholdPercent <= 10000, \"invalid _liquidityThresholdPercent\"); \n\n        liquidityThresholdPercent = _liquidityThresholdPercent;\n        collateralRatio = _collateralRatio;\n        twapInterval = _twapInterval;\n\n        \n        poolSharesToken_ = _deployPoolSharesToken();\n    }\n\n    function _deployPoolSharesToken()\n        internal\n        onlyInitializing\n        returns (address poolSharesToken_)\n    {\n      \n        require(\n            address(poolSharesToken) == address(0),\n            \"Pool shares already deployed\"\n        );\n\n\n        (string memory name, string memory symbol ) = _generateTokenNameAndSymbol(\n            address(principalToken),\n            address(collateralToken)\n        );\n\n        poolSharesToken = new LenderCommitmentGroupShares(\n            name,\n            symbol,\n            18  \n        );\n\n        return address(poolSharesToken);\n    }\n\n    function _generateTokenNameAndSymbol(address principalToken, address collateralToken) \n    internal view \n    returns (string memory name, string memory symbol) {\n        // Read the symbol of the principal token\n        string memory principalSymbol = ERC20(principalToken).symbol();\n        \n        // Read the symbol of the collateral token\n        string memory collateralSymbol = ERC20(collateralToken).symbol();\n        \n        // Combine the symbols to create the name\n        name = string(abi.encodePacked(\"GroupShares-\", principalSymbol, \"-\", collateralSymbol));\n        \n        // Combine the symbols to create the symbol\n        symbol = string(abi.encodePacked(\"SHR-\", principalSymbol, \"-\", collateralSymbol));\n    }\n\n    /**\n     * @notice This determines the number of shares you get for depositing principal tokens and the number of principal tokens you receive for burning shares\n     * @return rate_ The current exchange rate, scaled by the EXCHANGE_RATE_FACTOR.\n     */\n\n    function sharesExchangeRate() public view virtual returns (uint256 rate_) {\n        \n\n        uint256 poolTotalEstimatedValue = getPoolTotalEstimatedValue();\n\n        if (poolSharesToken.totalSupply() == 0) {\n            return EXCHANGE_RATE_EXPANSION_FACTOR; // 1 to 1 for first swap\n        }\n\n        rate_ =\n            (poolTotalEstimatedValue  *\n                EXCHANGE_RATE_EXPANSION_FACTOR) /\n            poolSharesToken.totalSupply();\n    }\n\n    function sharesExchangeRateInverse()\n        public\n        view\n        virtual\n        returns (uint256 rate_)\n    {\n        return\n            (EXCHANGE_RATE_EXPANSION_FACTOR * EXCHANGE_RATE_EXPANSION_FACTOR) /\n            sharesExchangeRate();\n    }\n\n    function getPoolTotalEstimatedValue()\n        public\n        view\n        returns (uint256 poolTotalEstimatedValue_)\n    {\n       \n         int256 poolTotalEstimatedValueSigned = int256(totalPrincipalTokensCommitted) \n         + int256(totalInterestCollected)  + int256(tokenDifferenceFromLiquidations) \n         - int256(totalPrincipalTokensWithdrawn);\n\n        //if the poolTotalEstimatedValue_ is less than 0, we treat it as 0.  \n        poolTotalEstimatedValue_ = poolTotalEstimatedValueSigned > int256(0)\n            ? uint256(poolTotalEstimatedValueSigned)\n            : 0;\n    }\n\n    /*\n    must be initialized for this to work ! \n    */\n    function addPrincipalToCommitmentGroup(\n        uint256 _amount,\n        address _sharesRecipient\n    ) external returns (uint256 sharesAmount_) {\n        //transfers the primary principal token from msg.sender into this contract escrow\n        \n        principalToken.transferFrom(msg.sender, address(this), _amount);\n\n        sharesAmount_ = _valueOfUnderlying(_amount, sharesExchangeRate());\n\n        totalPrincipalTokensCommitted += _amount;\n        //principalTokensCommittedByLender[msg.sender] += _amount;\n\n        //mint shares equal to _amount and give them to the shares recipient !!!\n        poolSharesToken.mint(_sharesRecipient, sharesAmount_);\n    }\n\n    function _valueOfUnderlying(uint256 amount, uint256 rate)\n        internal\n        pure\n        returns (uint256 value_)\n    {\n        if (rate == 0) {\n            return 0;\n        }\n\n        value_ = (amount * EXCHANGE_RATE_EXPANSION_FACTOR) / rate;\n    }\n\n    function acceptFundsForAcceptBid(\n        address _borrower,\n        uint256 _bidId,\n        uint256 _principalAmount,\n        uint256 _collateralAmount,\n        address _collateralTokenAddress,\n        uint256 _collateralTokenId, \n        uint32 _loanDuration,\n        uint16 _interestRate\n    ) external onlySmartCommitmentForwarder whenNotPaused {\n        \n        require(\n            _collateralTokenAddress == address(collateralToken),\n            \"Mismatching collateral token\"\n        );\n        //the interest rate must be at least as high has the commitment demands. The borrower can use a higher interest rate although that would not be beneficial to the borrower.\n        require(_interestRate >= getMinInterestRate(), \"Invalid interest rate\");\n        //the loan duration must be less than the commitment max loan duration. The lender who made the commitment expects the money to be returned before this window.\n        require(_loanDuration <= maxLoanDuration, \"Invalid loan max duration\");\n\n        require(\n            getPrincipalAmountAvailableToBorrow() >= _principalAmount,\n            \"Invalid loan max principal\"\n        );\n \n\n        //this is expanded by 10**18\n        uint256 requiredCollateral = getCollateralRequiredForPrincipalAmount(\n            _principalAmount\n        );\n\n        require(\n            (_collateralAmount * STANDARD_EXPANSION_FACTOR) >=\n                requiredCollateral,\n            \"Insufficient Borrower Collateral\"\n        );\n \n        principalToken.approve(address(TELLER_V2), _principalAmount);\n\n        //do not have to spoof/forward as this contract is the lender !\n        _acceptBidWithRepaymentListener(_bidId);\n\n        totalPrincipalTokensLended += _principalAmount;\n\n        activeBids[_bidId] = true; //bool for now\n        //emit event\n    }\n\n    function _acceptBidWithRepaymentListener(uint256 _bidId) internal {\n        ITellerV2(TELLER_V2).lenderAcceptBid(_bidId); //this gives out the funds to the borrower\n\n        ILoanRepaymentCallbacks(TELLER_V2).setRepaymentListenerForBid(\n            _bidId,\n            address(this)\n        );\n    }\n\n    /*\n       \n    */\n    function burnSharesToWithdrawEarnings(\n        uint256 _amountPoolSharesTokens,\n        address _recipient\n    ) external returns (uint256) {\n       \n\n        \n        poolSharesToken.burn(msg.sender, _amountPoolSharesTokens);\n\n        uint256 principalTokenValueToWithdraw = _valueOfUnderlying(\n            _amountPoolSharesTokens,\n            sharesExchangeRateInverse()\n        );\n\n        totalPrincipalTokensWithdrawn += principalTokenValueToWithdraw;\n\n        principalToken.transfer(_recipient, principalTokenValueToWithdraw);\n\n        return principalTokenValueToWithdraw;\n    }\n\n    /*\n\n\n    */\n\n    function liquidateDefaultedLoanWithIncentive(\n        uint256 _bidId,\n        int256 _tokenAmountDifference\n    ) public bidIsActiveForGroup(_bidId) {\n        uint256 amountDue = getAmountOwedForBid(_bidId, false);\n\n        uint256 loanDefaultedTimeStamp = ITellerV2(TELLER_V2)\n            .getLoanDefaultTimestamp(_bidId);\n\n        int256 minAmountDifference = getMinimumAmountDifferenceToCloseDefaultedLoan(\n                amountDue,\n                loanDefaultedTimeStamp\n            );\n\n        require(\n            _tokenAmountDifference >= minAmountDifference,\n            \"Insufficient tokenAmountDifference\"\n        );\n\n        if (_tokenAmountDifference > 0) {\n            //this is used when the collateral value is higher than the principal (rare)\n            //the loan will be completely made whole and our contract gets extra funds too\n            uint256 tokensToTakeFromSender = abs(_tokenAmountDifference);\n\n            IERC20(principalToken).transferFrom(\n                msg.sender,\n                address(this),\n                amountDue + tokensToTakeFromSender\n            );\n\n            tokenDifferenceFromLiquidations += int256(tokensToTakeFromSender);\n\n            totalPrincipalTokensRepaid += amountDue;\n        } else {\n           \n            uint256 tokensToGiveToSender = abs(_tokenAmountDifference);\n\n            IERC20(principalToken).transferFrom(\n                msg.sender,\n                address(this),\n                amountDue - tokensToGiveToSender\n            );\n\n            tokenDifferenceFromLiquidations -= int256(tokensToGiveToSender);\n\n            totalPrincipalTokensRepaid += amountDue;\n        }\n\n        //this will give collateral to the caller\n        ITellerV2(TELLER_V2).lenderCloseLoanWithRecipient(_bidId, msg.sender);\n    }\n\n    function getAmountOwedForBid(uint256 _bidId, bool _includeInterest)\n        public\n        view\n        virtual\n        returns (uint256 amountOwed_)\n    {\n        Payment memory amountOwedPayment = ITellerV2(TELLER_V2)\n            .calculateAmountOwed(_bidId, block.timestamp);\n\n        amountOwed_ = _includeInterest\n            ? amountOwedPayment.principal + amountOwedPayment.interest\n            : amountOwedPayment.principal;\n    }\n\n    /*\n        This function will calculate the incentive amount (using a uniswap bonus plus a timer)\n        of principal tokens that will be given to incentivize liquidating a loan \n \n    */\n    function getMinimumAmountDifferenceToCloseDefaultedLoan(\n        uint256 _amountOwed,\n        uint256 _loanDefaultedTimestamp\n    ) public view virtual returns (int256 amountDifference_) {\n        require(\n            _loanDefaultedTimestamp > 0,\n            \"Loan defaulted timestamp must be greater than zero\"\n        );\n        require(\n            block.timestamp > _loanDefaultedTimestamp,\n            \"Loan defaulted timestamp must be in the past\"\n        );\n\n        uint256 secondsSinceDefaulted = block.timestamp -\n            _loanDefaultedTimestamp;\n \n        int256 incentiveMultiplier = int256(86400) -\n            int256(secondsSinceDefaulted);\n\n        if (incentiveMultiplier < -10000) {\n            incentiveMultiplier = -10000;\n        }\n\n        amountDifference_ =\n            (int256(_amountOwed) * incentiveMultiplier) /\n            int256(10000);\n    }\n\n    function abs(int x) private pure returns (uint) {\n        return x >= 0 ? uint(x) : uint(-x);\n    }\n \n    function getCollateralRequiredForPrincipalAmount(uint256 _principalAmount)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 baseAmount = _calculateCollateralTokensAmountEquivalentToPrincipalTokens(\n                _principalAmount\n            );\n\n        //this is an amount of collateral\n        return baseAmount.percent(collateralRatio);\n    }\n\n    //this result is expanded by UNISWAP_EXPANSION_FACTOR\n    function _getUniswapV3TokenPairPrice(uint32 _twapInterval)\n        internal\n        view\n        returns (uint256)\n    {\n        // represents the square root of the price of token1 in terms of token0\n\n        uint160 sqrtPriceX96 = getSqrtTwapX96(_twapInterval);\n\n        //this output is the price ratio expanded by 1e18\n        return _getPriceFromSqrtX96(sqrtPriceX96);\n    }\n\n    //this result is expanded by UNISWAP_EXPANSION_FACTOR\n    function _getPriceFromSqrtX96(uint160 _sqrtPriceX96)\n        internal\n        pure\n        returns (uint256 price_)\n    {\n       \n        uint256 priceX96 = (uint256(_sqrtPriceX96) * uint256(_sqrtPriceX96)) /\n            (2**96);\n\n        // sqrtPrice is in X96 format so we scale it down to get the price\n        // Also note that this price is a relative price between the two tokens in the pool\n        // It's not a USD price\n        price_ = priceX96;\n    }\n\n    // ---- TWAP\n\n    function getSqrtTwapX96(uint32 twapInterval)\n        public\n        view\n        returns (uint160 sqrtPriceX96)\n    {\n        if (twapInterval == 0) {\n            // return the current price if twapInterval == 0\n            (sqrtPriceX96, , , , , , ) = IUniswapV3Pool(UNISWAP_V3_POOL)\n                .slot0();\n        } else {\n            uint32[] memory secondsAgos = new uint32[](2);\n            secondsAgos[0] = twapInterval; // from (before)\n            secondsAgos[1] = 0; // to (now)\n\n            (int56[] memory tickCumulatives, ) = IUniswapV3Pool(UNISWAP_V3_POOL)\n                .observe(secondsAgos);\n\n            // tick(imprecise as it's an integer) to price\n            sqrtPriceX96 = TickMath.getSqrtRatioAtTick(\n                int24(\n                    (tickCumulatives[1] - tickCumulatives[0]) /\n                        int32(twapInterval)\n                )\n            );\n        }\n    }\n\n    function _getPoolTokens()\n        internal\n        view\n        virtual\n        returns (address token0, address token1)\n    {\n        token0 = IUniswapV3Pool(UNISWAP_V3_POOL).token0();\n        token1 = IUniswapV3Pool(UNISWAP_V3_POOL).token1();\n    }\n\n    // -----\n\n    //this is expanded by 10e18\n    function _calculateCollateralTokensAmountEquivalentToPrincipalTokens(\n        uint256 principalTokenAmountValue\n    ) internal view returns (uint256 collateralTokensAmountToMatchValue) {\n        //same concept as zeroforone\n        (address token0, ) = _getPoolTokens();\n\n        bool principalTokenIsToken0 = (address(principalToken) == token0);\n\n        uint256 pairPriceWithTwap = _getUniswapV3TokenPairPrice(twapInterval);\n        uint256 pairPriceImmediate = _getUniswapV3TokenPairPrice(0);\n\n        return\n            _getCollateralTokensAmountEquivalentToPrincipalTokens(\n                principalTokenAmountValue,\n                pairPriceWithTwap,\n                pairPriceImmediate,\n                principalTokenIsToken0\n            );\n    }\n\n    /*\n        Dev Note: pairPriceWithTwap and pairPriceImmediate are expanded by UNISWAP_EXPANSION_FACTOR\n\n    */\n    function _getCollateralTokensAmountEquivalentToPrincipalTokens(\n        uint256 principalTokenAmountValue,\n        uint256 pairPriceWithTwap,\n        uint256 pairPriceImmediate,\n        bool principalTokenIsToken0\n    ) internal pure returns (uint256 collateralTokensAmountToMatchValue) {\n        if (principalTokenIsToken0) {\n            //token 1 to token 0 ?\n            uint256 worstCasePairPrice = Math.min(\n                pairPriceWithTwap,\n                pairPriceImmediate\n            );\n\n            collateralTokensAmountToMatchValue = token1ToToken0(\n                principalTokenAmountValue,\n                worstCasePairPrice //if this is lower, collateral tokens amt will be higher\n            );\n        } else {\n            //token 0 to token 1 ?\n            uint256 worstCasePairPrice = Math.max(\n                pairPriceWithTwap,\n                pairPriceImmediate\n            );\n\n            collateralTokensAmountToMatchValue = token0ToToken1(\n                principalTokenAmountValue,\n                worstCasePairPrice //if this is lower, collateral tokens amt will be higher\n            );\n        }\n    }\n\n    //note: the price is still expanded by UNISWAP_EXPANSION_FACTOR\n    function token0ToToken1(uint256 amountToken0, uint256 priceToken1PerToken0)\n        internal\n        pure\n        returns (uint256)\n    {\n        return\n            MathUpgradeable.mulDiv(\n                amountToken0,\n                UNISWAP_EXPANSION_FACTOR,\n                priceToken1PerToken0,\n                MathUpgradeable.Rounding.Up\n            );\n    }\n\n    //note: the price is still expanded by UNISWAP_EXPANSION_FACTOR\n    function token1ToToken0(uint256 amountToken1, uint256 priceToken1PerToken0)\n        internal\n        pure\n        returns (uint256)\n    {\n        return\n            MathUpgradeable.mulDiv(\n                amountToken1,\n                priceToken1PerToken0,\n                UNISWAP_EXPANSION_FACTOR,\n                MathUpgradeable.Rounding.Up\n            );\n    }\n\n    /*\n    This  callback occurs when a TellerV2 repayment happens or when a TellerV2 liquidate happens \n\n    lenderCloseLoan does not trigger a repayLoanCallback \n    */\n    function repayLoanCallback(\n        uint256 _bidId,\n        address repayer,\n        uint256 principalAmount,\n        uint256 interestAmount\n    ) external onlyTellerV2 {\n        //can use principal amt to increment amt paid back!! nice for math .\n        totalPrincipalTokensRepaid += principalAmount;\n        totalInterestCollected += interestAmount;\n    }\n\n  \n    function getTotalPrincipalTokensOutstandingInActiveLoans()\n        public\n        view\n        returns (uint256)\n    {\n        return totalPrincipalTokensLended - totalPrincipalTokensRepaid;\n    }\n\n    function getCollateralTokenAddress() external view returns (address) {\n        return address(collateralToken);\n    }\n\n    function getCollateralTokenId() external view returns (uint256) {\n        return 0;\n    }\n\n    function getCollateralTokenType()\n        external\n        view\n        returns (CommitmentCollateralType)\n    {\n        return CommitmentCollateralType.ERC20;\n    }\n\n    //this is expanded by 1e18\n    //this only exists to comply with the interface\n    function getRequiredCollateral(uint256 _principalAmount)\n        public\n        view\n        returns (uint256 requiredCollateral_)\n    {\n        requiredCollateral_ = getCollateralRequiredForPrincipalAmount(\n            _principalAmount\n        );\n    }\n\n    function getMarketId() external view returns (uint256) {\n        return marketId;\n    }\n\n    function getMaxLoanDuration() external view returns (uint32) {\n        return maxLoanDuration;\n    }\n\n    //this is always between 0 and 10000\n    function getPoolUtilizationRatio() public view returns (uint16) {\n\n        if (getPoolTotalEstimatedValue() == 0) {\n            return 0;\n        }\n\n        return uint16(  Math.min(   \n           getTotalPrincipalTokensOutstandingInActiveLoans()  * 10000  / \n           getPoolTotalEstimatedValue() , 10000  ));\n    }   \n\n \n    function getMinInterestRate() public view returns (uint16) {\n        return interestRateLowerBound + uint16( uint256(interestRateUpperBound-interestRateLowerBound).percent(getPoolUtilizationRatio()) );\n    }\n\n    function getPrincipalTokenAddress() external view returns (address) {\n        return address(principalToken);\n    }\n\n   \n\n    function getPrincipalAmountAvailableToBorrow()\n        public\n        view\n        returns (uint256)\n    {     \n\n            return  ( uint256( getPoolTotalEstimatedValue() )).percent(liquidityThresholdPercent) -\n            getTotalPrincipalTokensOutstandingInActiveLoans() ;\n     \n    }\n\n    /**\n     * @notice Lets the DAO/owner of the protocol implement an emergency stop mechanism.\n     */\n    function pauseBorrowing() public virtual onlyOwner whenNotPaused {\n        _pause();\n    }\n\n    /**\n     * @notice Lets the DAO/owner of the protocol undo a previously implemented emergency stop.\n     */\n    function unpauseBorrowing() public virtual onlyOwner whenPaused {\n        _unpause();\n    }\n}"
    },
    {
      "filename": "teller-protocol-v2-audit-2024/packages/contracts/contracts/TellerV2.sol",
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\n// Contracts\nimport \"./ProtocolFee.sol\";\nimport \"./TellerV2Storage.sol\";\nimport \"./TellerV2Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\n\n// Interfaces\nimport \"./interfaces/IMarketRegistry.sol\";\nimport \"./interfaces/IReputationManager.sol\";\nimport \"./interfaces/ITellerV2.sol\";\nimport { Collateral } from \"./interfaces/escrow/ICollateralEscrowV1.sol\";\nimport \"./interfaces/IEscrowVault.sol\";\n\nimport { ILoanRepaymentCallbacks } from \"./interfaces/ILoanRepaymentCallbacks.sol\";\nimport \"./interfaces/ILoanRepaymentListener.sol\";\n\n// Libraries\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./libraries/NumbersLib.sol\";\n\nimport { V2Calculations, PaymentCycleType } from \"./libraries/V2Calculations.sol\";\n\n/* Errors */\n/**\n * @notice This error is reverted when the action isn't allowed\n * @param bidId The id of the bid.\n * @param action The action string (i.e: 'repayLoan', 'cancelBid', 'etc)\n * @param message The message string to return to the user explaining why the tx was reverted\n */\nerror ActionNotAllowed(uint256 bidId, string action, string message);\n\n/**\n * @notice This error is reverted when repayment amount is less than the required minimum\n * @param bidId The id of the bid the borrower is attempting to repay.\n * @param payment The payment made by the borrower\n * @param minimumOwed The minimum owed value\n */\nerror PaymentNotMinimum(uint256 bidId, uint256 payment, uint256 minimumOwed);\n\ncontract TellerV2 is\n    ITellerV2,\n    ILoanRepaymentCallbacks,\n    OwnableUpgradeable,\n    ProtocolFee,\n    PausableUpgradeable,\n    TellerV2Storage,\n    TellerV2Context\n{\n    using Address for address;\n    using SafeERC20 for IERC20;\n    using NumbersLib for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    //the first 20 bytes of keccak256(\"lender manager\")\n    address constant USING_LENDER_MANAGER =\n        0x84D409EeD89F6558fE3646397146232665788bF8;\n\n    /** Events */\n\n    /**\n     * @notice This event is emitted when a new bid is submitted.\n     * @param bidId The id of the bid submitted.\n     * @param borrower The address of the bid borrower.\n     * @param metadataURI URI for additional bid information as part of loan bid.\n     */\n    event SubmittedBid(\n        uint256 indexed bidId,\n        address indexed borrower,\n        address receiver,\n        bytes32 indexed metadataURI\n    );\n\n    /**\n     * @notice This event is emitted when a bid has been accepted by a lender.\n     * @param bidId The id of the bid accepted.\n     * @param lender The address of the accepted bid lender.\n     */\n    event AcceptedBid(uint256 indexed bidId, address indexed lender);\n\n    /**\n     * @notice This event is emitted when a previously submitted bid has been cancelled.\n     * @param bidId The id of the cancelled bid.\n     */\n    event CancelledBid(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when market owner has cancelled a pending bid in their market.\n     * @param bidId The id of the bid funded.\n     *\n     * Note: The `CancelledBid` event will also be emitted.\n     */\n    event MarketOwnerCancelledBid(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a payment is made towards an active loan.\n     * @param bidId The id of the bid/loan to which the payment was made.\n     */\n    event LoanRepayment(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a loan has been fully repaid.\n     * @param bidId The id of the bid/loan which was repaid.\n     */\n    event LoanRepaid(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a loan has been closed by a lender to claim collateral.\n     * @param bidId The id of the bid accepted.\n     */\n    event LoanClosed(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a loan has been fully repaid.\n     * @param bidId The id of the bid/loan which was repaid.\n     */\n    event LoanLiquidated(uint256 indexed bidId, address indexed liquidator);\n\n    /**\n     * @notice This event is emitted when a fee has been paid related to a bid.\n     * @param bidId The id of the bid.\n     * @param feeType The name of the fee being paid.\n     * @param amount The amount of the fee being paid.\n     */\n    event FeePaid(\n        uint256 indexed bidId,\n        string indexed feeType,\n        uint256 indexed amount\n    );\n\n    /** Modifiers */\n\n    /**\n     * @notice This modifier is used to check if the state of a bid is pending, before running an action.\n     * @param _bidId The id of the bid to check the state for.\n     * @param _action The desired action to run on the bid.\n     */\n    modifier pendingBid(uint256 _bidId, string memory _action) {\n        if (bids[_bidId].state != BidState.PENDING) {\n            revert ActionNotAllowed(_bidId, _action, \"Bid must be pending\");\n        }\n\n        _;\n    }\n\n    /**\n     * @notice This modifier is used to check if the state of a loan has been accepted, before running an action.\n     * @param _bidId The id of the bid to check the state for.\n     * @param _action The desired action to run on the bid.\n     */\n    modifier acceptedLoan(uint256 _bidId, string memory _action) {\n        if (bids[_bidId].state != BidState.ACCEPTED) {\n            revert ActionNotAllowed(_bidId, _action, \"Loan must be accepted\");\n        }\n\n        _;\n    }\n\n    /** Constant Variables **/\n\n    uint8 public constant CURRENT_CODE_VERSION = 10;\n\n    uint32 public constant LIQUIDATION_DELAY = 86400; //ONE DAY IN SECONDS\n\n    /** Constructor **/\n\n    constructor(address trustedForwarder) TellerV2Context(trustedForwarder) {}\n\n    /** External Functions **/\n\n    /**\n     * @notice Initializes the proxy.\n     * @param _protocolFee The fee collected by the protocol for loan processing.\n     * @param _marketRegistry The address of the market registry contract for the protocol.\n     * @param _reputationManager The address of the reputation manager contra"
    }
  ]
}