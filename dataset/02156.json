{
  "Title": "M-3: Account can not be liquidated when price fall by 99%.",
  "Content": "# Issue M-3: Account can not be liquidated when price fall by 99%. \n\nSource: https://github.com/sherlock-audit/2023-03-taurus-judging/issues/61 \n\n## Found by \nroguereddwarf, spyrosonic10\n\n## Summary\nLiquidation fails when price fall by 99%.  \n\n## Vulnerability Detail\n`_calcLiquidation()` method has logic related to liquidations. This method calculate total liquidation discount,  collateral to liquidate and liquidation surcharge. All these calculations looks okay in normal scenarios but there is an edge case when liquidation fails if price crashes by 99% or more. In such scenario `collateralToLiquidateWithoutDiscount` will be very large and calculated liquidation surcharge becomes greater than `collateralToLiquidate`\n\n```solidity\nuint256 collateralToLiquidateWithoutDiscount = (_debtToLiquidate * (10 ** decimals)) / price;\ncollateralToLiquidate = (collateralToLiquidateWithoutDiscount * totalLiquidationDiscount) / Constants.PRECISION;\nif (collateralToLiquidate > _accountCollateral) {\n            collateralToLiquidate = _accountCollateral;\n}\nuint256 liquidationSurcharge = (collateralToLiquidateWithoutDiscount * LIQUIDATION_SURCHARGE) / Constants.PRECISION\n```\n\nContract revert from below line hence liquidation will fail in this scenario.\n\n```solidity\nuint256 collateralToLiquidator = collateralToLiquidate - liquidationSurcharge;\n```\n## Impact\nLiquidation fails when price crash  by 99% or more. Expected behaviour is that liquidation should be successful in all scenarios.\n\n## Code Snippet\nBlock of code that has bug.\nhttps://github.com/sherlock-audit/2023-03-taurus/blob/main/taurus-contracts/contracts/Vault/BaseVault.sol#L396-L422\n\nBelow is POC that prove failed liquidation.\n```js\nit(\"should revert liquidation if an account is unhealthy and price crashed 99%\", async () => {\n        // Assume price is crashed 99%\n        await glpOracle.updatePrice(PRECISION.mul(1).div(100));\n        // check if the account is underwater\n        const health = await gmxVault.getAccountHealth(user.address);\n        expect(health).eq(false);\n\n        // Check the liquidation amount\n        const liqAmt = await gmxVault.getMaxLiquidation(user.address);\n\n        // Mint some TAU to the liquidator and approve vault to spend it\n        await mintHelper(liqAmt, liquidator.address);\n        await tau.connect(liquidator).approve(gmxVault.address, liqAmt);\n        const totalTauSupply = await tau.totalSupply();\n\n        // liquidation will fail\n        const tx = gmxVault.connect(liquidator).liquidate(user.address, liqAmt, 0);\n        // reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)\n        await expect(tx).revertedWithPanic(0x11);\n      });\n```\n>PS: This test goes in 00_GmxYieldAdapter.ts and inside describe(\"Liquidate\", async () => { block defined at line 269\n\n## Tool used\n\nManual Review\n\n## Recommendation\nPresently liquidation surcharge is calculated on `collateralToLiquidateWithoutDiscount`.  Project team may want to reconsider this logic and calculate surcharge on `collateralToLiquidate` instead of `collateralToLiquidateWithoutDiscount`. This will be business decision but easy fix\n\nAnother option is you may want to calculate surcharge on `Math.min(collateralToLiquidate, collateralToLiquidateWithoutDiscount)`.\n \n```solidity\n        uint256 collateralToTakeSurchargeOn = Math.min(collateralToLiquidate, collateralToLiquidateWithoutDiscount);\n        uint256 liquidationSurcharge = (collateralToTakeSurchargeOn * LIQUIDATION_SURCHARGE) / Constants.PRECISION;\n        return (collateralToLiquidate, liquidationSurcharge);\n```\n\n## Discussion\n\n**Sierraescape**\n\nhttps://github.com/protokol/taurus-contracts/pull/122\n\n**hrishibhat**\n\nSince this is an edge case for the given price fall resulting in reverting liquidations, \nConsidering this as a valid medium\n\n**IAm0x52**\n\nEscalate for 10 USDC\n\nThis is the same root cause as #89 that the liquidation surcharge is calculated based on the uncapped amount. This is another symptom of that same underlying problem, so it should be a dupe of #89 \n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> This is the same root cause as #89 that the liquidation surcharge is calculated based on the uncapped amount. This is another symptom of that same underlying problem, so it should be a dupe of #89 \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**spyrosonic10**\n\nEscalate for 10 USDC\n\nI do not agree with escalation raised above. This issue is about failure of liquidation when price fall by x%. This finding is an edge case where it does impact all underwater accounts so it is fair to say that it impact whole protocol. Root cause and impact both are different in this issue compare to #89 so this is definitely not a duplicate of #89.\n\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> I do not agree with escalation raised above. This issue is about failure of liquidation when price fall by x%. This finding is an edge case where it does impact all underwater accounts so it is fair to say that it impact whole protocol. Root cause and impact both are different in this issue compare to #89 so this is definitely not a duplicate of #89.\n> \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nAccepting the first escalation. \nAfter further internal discussion, both the outcomes originate out of the same root cause of using `collateralToLiquidateWithoutDiscount` to calculate `liquidationSurcharge`. While one mentions increase in the fee the other instance increases to cause underflow. \nConsidering #89 a duplicate of this issue. \n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Accepting the first escalation. \n> After further internal discussion, both the outcomes originate out of the same root cause of using `collateralToLiquidateWithoutDiscount` to calculate `liquidationSurcharge`. While one mentions increase in the fee the other instance increases to cause underflow. \n> Considering #89 a duplicate of this issue. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/45",
  "Code": [
    {
      "filename": "taurus-contracts/contracts/Vault/BaseVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// Contracts\nimport { Controllable } from \"../Controller/Controllable.sol\";\nimport { Controller } from \"../Controller/Controller.sol\";\nimport { PriceOracleManager } from \"../Oracle/PriceOracleManager.sol\";\nimport { TauDripFeed } from \"./TauDripFeed.sol\";\nimport { SwapHandler } from \"./SwapHandler.sol\";\nimport { TAU } from \"../TAU.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\n\n// Libraries\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Constants } from \"../Libs/Constants.sol\";\nimport { TauMath } from \"../Libs/TauMath.sol\";\n\n// Note that this contract is not compatible with ERC777 tokens due to potential reentrancy concerns.\nabstract contract BaseVault is SwapHandler, UUPSUpgradeable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    /// Define the errors\n    error insufficientCollateral();\n    error userNotFound();\n    error wrongLiquidationAmount();\n    error incorrectDebtRepayAmount();\n    error insufficientCollateralLiquidated(uint256 debtRepaid, uint256 collateralReceived);\n    error cannotLiquidateHealthyAccount();\n\n    // Events\n    event Repay(address indexed _repayer, uint256 _amountTau);\n    event Borrow(address indexed _borrower, uint256 _amountTau);\n    event Deposit(address indexed _depositer, uint256 _amountAsset);\n    event Withdraw(address indexed _withdrawer, uint256 _amountAsset);\n    event AccountLiquidated(address _liquidator, address _account, uint256 _amount, uint256 _liqFees);\n    event TauEarned(address indexed _account, uint256 _amount); // Emitted when a user's debt is cancelled\n\n    struct UserDetails {\n        uint256 collateral; // Collateral amount deposited by user\n        uint256 debt; // Debt amount borrowed by user\n        uint256 lastUpdatedRewardPerCollateral; // Last updated reward per collateral for the user\n        uint256 startTimestamp; // Time when the first deposit was made by the user\n    }\n\n    /// @dev mapping of user and UserDetails\n    mapping(address => UserDetails) public userDetails;\n\n    /// @dev keep track of user addresses to index the userDetails for liquidation\n    address[] public userAddresses;\n\n    // Liquidation constants\n\n    // Minimum collateral ratio\n    uint256 public constant MIN_COL_RATIO = 1.2e18; // 120 %\n\n    // Maximum collateral ratio an account can have after being liquidated (limits liquidation size to only what is necessary)\n    uint256 public constant MAX_LIQ_COLL_RATIO = 1.3e18; // 130 %\n\n    uint256 public constant MAX_LIQ_DISCOUNT = 0.2e18; // 20 %\n\n    // 2% of the liquidated amount is sent to the FeeSplitter to fund protocol stability\n    // and disincentivize self-liquidation\n    uint256 public constant LIQUIDATION_SURCHARGE = 0.02e18;\n\n    function __BaseVault_init(address _controller, address _tau, address _collateralToken) internal initializer {\n        __Controllable_init(_controller);\n        __TauDripFeed_init(_tau, _collateralToken);\n    }\n\n    /**\n     * @dev modifier to update user's reward per collateral and pay off some of their debt. This is\n        executed before any function that modifies a user's collateral or debt.\n     * note if there is surplus TAU after the debt is paid off, it is added back to the drip feed.\n     */\n    modifier updateReward(address _account) {\n        // Disburse available yield from the drip feed\n        _disburseTau();\n\n        // If user has collateral, pay down their debt and recycle surplus rewards back into the tauDripFeed.\n        uint256 _userCollateral = userDetails[_account].collateral;\n        if (_userCollateral > 0) {\n            // Get diff between global rewardPerCollateral and user lastUpdatedRewardPerCollateral\n            uint256 _rewardDiff = cumulativeTauRewardPerCollateral -\n                userDetails[_account].lastUpdatedRewardPerCollateral;\n\n            // Calculate user's TAU earned since the last update, use it to pay off debt\n            uint256 _tauEarned = (_rewardDiff * _userCollateral) / Constants.PRECISION;\n\n            if (_tauEarned > 0) {\n                uint256 _userDebt = userDetails[_account].debt;\n                if (_tauEarned > _userDebt) {\n                    // If user has earned more than enough TAU to pay off their debt, pay off debt and add surplus to drip feed\n                    userDetails[_account].debt = 0;\n\n                    _withholdTau(_tauEarned - _userDebt);\n                    _tauEarned = _userDebt;\n                } else {\n                    // Pay off as much debt as possible\n                    userDetails[_account].debt = _userDebt - _tauEarned;\n                }\n\n                emit TauEarned(_account, _tauEarned);\n            }\n        } else {\n            // If this is a new user, add them to the userAddresses array to keep track of them.\n            if (userDetails[_account].startTimestamp == 0) {\n                userAddresses.push(_account);\n                userDetails[_account].startTimestamp = block.timestamp;\n            }\n        }\n\n        // Update user lastUpdatedRewardPerCollateral\n        userDetails[_account].lastUpdatedRewardPerCollateral = cumulativeTauRewardPerCollateral;\n        _;\n    }\n\n    //------------------------------------------------------------View functions------------------------------------------------------------\n\n    /// @dev In this function, we assume that TAU is worth $1 exactly. This allows users to arbitrage the difference, if any.\n    function getAccountHealth(address _account) public view returns (bool) {\n        uint256 ratio = _getCollRatio(_account);\n\n        return (ratio > MIN_COL_RATIO);\n    }\n\n    /**\n     * @dev calculate the max amount of debt that can be liquidated from an account\n     * @param _account is the address of the account to be liquidated\n     * @return maxRepay is the maximum amount of debt that can be liquidated from the account\n     */\n    function getMaxLiquidation(address _account) external view returns (uint256 maxRepay) {\n        (uint256 price, uint8 decimals) = _getCollPrice();\n        UserDetails memory accDetails = userDetails[_account];\n        uint256 _collRatio = TauMath._computeCR(accDetails.collateral, accDetails.debt, price, decimals);\n\n        // This call will revert if the account is healthy\n        uint256 totalLiquidationDiscount = _calcLiquidationDiscount(_collRatio);\n\n        maxRepay = _getMaxLiquidation(\n            accDetails.collateral,\n            accDetails.debt,\n            price,\n            decimals,\n            totalLiquidationDiscount\n        );\n        return maxRepay;\n    }\n\n    /// @dev Get the number of users\n    function getUsersCount() public view returns (uint256) {\n        return userAddresses.length;\n    }\n\n    /** @dev Get the user details in the range given start and end index.\n     * note the start and end index are inclusive\n     */\n    function getUsersDetailsInRange(uint256 _start, uint256 _end) public view returns (UserDetails[] memory users) {\n        if (_end > getUsersCount() || _start > _end) revert indexOutOfBound();\n\n        users = new UserDetails[](_end - _start + 1);\n\n        for (uint i = _start; i < _end; ++i) {\n            users[i - _start] = userDetails[userAddresses[i]];\n        }\n    }\n\n    /** @dev Get the user addresses in the range given start and end index\n     * note the start and end index are inclusive\n     */\n    function getUsers(uint256 _start, uint256 _end) public view returns (address[] memory users) {\n        if (_end > getUsersCount() || _start > _end) revert indexOutOfBound();\n\n        users = new address[](_end - _start + 1);\n\n        for (uint256 i = _start; i < _end; ++i) {\n            users[i - _start] = userAddresses[i];\n        }\n    }\n\n    function _checkAccountHealth(address _account) internal view {\n        if (!getAccountHealth(_account)) {\n            revert insufficientCollateral();\n        }\n    }\n\n    /// @dev In this function, we calculate the collateral ratio\n    function _getCollRatio(address _account) internal view returns (uint256 ratio) {\n        // Fetch the price from oracle manager\n        (uint256 price, uint8 decimals) = _getCollPrice();\n\n        // Check that user's collateral ratio is above minimum healthy ratio\n        ratio = TauMath._computeCR(userDetails[_account].collateral, userDetails[_account].debt, price, decimals);\n    }\n\n    function _getCollPrice() internal view virtual returns (uint256 price, uint8 decimals) {\n        bool success;\n\n        // Fetch the price from oracle manager\n        (price, decimals, success) = PriceOracleManager(\n            Controller(controller).addressMapper(Constants.PRICE_ORACLE_MANAGER)\n        ).getExternalPrice(collateralToken, abi.encodePacked(false));\n        if (!success) {\n            revert oracleCorrupt();\n        }\n    }\n\n    //------------------------------------------------------------User functions------------------------------------------------------------\n\n    function modifyPosition(\n        uint256 _collateralDelta,\n        uint256 _debtDelta,\n        bool _increaseCollateral,\n        bool _increaseDebt\n    ) external whenNotPaused updateReward(msg.sender) {\n        _modifyPosition(msg.sender, _collateralDelta, _debtDelta, _increaseCollateral, _increaseDebt);\n    }\n\n    /**\n     * @dev Function allowing a user to automatically close their position.\n     * Note that this function is available even when the contract is paused.\n     * Note that since this function does not call updateReward, it should only be used when the contract is paused.\n     *\n     */\n    function emergencyClosePosition() external {\n        _modifyPosition(msg.sender, userDetails[msg.sender].collateral, userDetails[msg.sender].debt, false, false);\n    }\n\n    /**\n     * @dev Find the max amount of debt that can be liquidated from an account.\n     * @param _collateral is the amount of collateral the user has.\n     * @param _debt is the amount of debt the user has.\n     * @param _price is $ / collateral\n     * @param _decimals is the number of decimals in price\n     * @param _liquidationDiscount is the liquidation discount in percentage, e.g. 120% * PRECISION\n     * @return maxRepay is the max amount of debt which can be repaid as part of the liquidation process, 0 if the user's account is healthy.\n     */\n    function _getMaxLiquidation(\n        uint256 _collateral,\n        uint256 _debt,\n        uint256 _price,\n        uint8 _decimals,\n        uint256 _liquidationDiscount\n    ) internal pure returns (uint256 maxRepay) {\n        // Formula to find the liquidation amount is as follows\n        // [(collateral * price) - (liqDiscount * liqAmount)] / (debt - liqAmount) = max liq ratio\n        // Therefore\n        // liqAmount = [(max liq ratio * debt) - (collateral * price)] / (max liq ratio - liqDiscount)\n        maxRepay =\n            ((MAX_LIQ_COLL_RATIO * _debt) - ((_collateral * _price * Constants.PRECISION) / (10 ** _decimals))) /\n            (MAX_LIQ_COLL_RATIO - _liquidationDiscount);\n\n        // Liquidators cannot repay more than the account's debt\n        if (maxRepay > _debt) {\n            maxRepay = _debt;\n        }\n\n        return maxRepay;\n    }\n\n    //------------------------------------------------------------BaseVault internal functions------------------------------------------------------------\n\n    /**\n     * @dev function to modify user collateral and debt in any way. If debt is increased or collateral reduced, the account must be healthy at the end of the tx.\n     * note that generally this function is called after updateReward, meaning that user details are up to date.\n     * @param _account is the account to be modified\n     * @param _collateralDelta is the absolute value of the change in collateral.\n     *  note that withdrawals cannot attempt to withdraw more than the user collateral balance, or the transaction will revert.\n     * @param _debtDelta is the absolute value of the change in debt\n     *  note that repayments can attempt to repay more than their debt balance. Only their debt balance will be pulled, and used to cancel out their debt.\n     * @param _increaseCollateral is true if collateral is being deposited, false if collateralDelta is 0 or collateral is being withdrawn\n     * @param _increaseDebt is true if debt is being borrowed, false if debtDelta is 0 or debt is being repaid\n     */\n    function _modifyPosition(\n        address _account,\n        uint256 _collateralDelta,\n        uint256 _debtDelta,\n        bool _increaseCollateral,\n        bool _increaseDebt\n    ) internal virtual {\n        bool mustCheckHealth; // False until an action is taken which can reduce account health\n\n        // Handle debt first, since TAU has no reentrancy concerns.\n        if (_debtDelta != 0) {\n            if (_increaseDebt) {\n                // Borrow TAU from the vault\n                userDetails[_account].debt += _debtDelta;\n                mustCheckHealth = true;\n                TAU(tau).mint(_account, _debtDelta);\n\n                emit Borrow(_account, _debtDelta);\n            } else {\n                // Repay TAU debt\n                uint256 currentDebt = userDetails[_account].debt;\n                if (_debtDelta > currentDebt) _debtDelta = currentDebt;\n                userDetails[_account].debt = currentDebt - _debtDelta;\n                // Burn Tau used to repay debt\n                TAU(tau).burnFrom(_account, _debtDelta);\n\n                emit Repay(_account, _debtDelta);\n            }\n        }\n\n        if (_collateralDelta != 0) {\n            if (_increaseCollateral) {\n                // Deposit collateral\n                userDetails[_account].collateral += _collateralDelta;\n                IERC20(collateralToken).safeTransferFrom(msg.sender, address(this), _collateralDelta);\n\n                emit Deposit(_account, _collateralDelta);\n            } else {\n                // Withdraw collateral\n                uint256 currentCollateral = userDetails[_account].collateral;\n                if (_collateralDelta > currentCollateral) revert insufficientCollateral();\n                userDetails[_account].collateral = currentCollateral - _collateralDelta;\n                mustCheckHealth = true;\n                IERC20(collateralToken).safeTransfer(msg.sender, _collateralDelta);\n\n                emit Withdraw(_account, _collateralDelta);\n            }\n        }\n\n        if (mustCheckHealth) {\n            _checkAccountHealth(_account);\n        }\n    }\n\n    //------------------------------------------------------------Liquidator/governance functions------------------------------------------------------------\n\n    /**\n     * @param _account is the account to be liquidated. It must be unhealthy.\n     * @param _debtAmount is the amount of debt to be repaid. It must be greater than 0. If the entire account is liquidateable, an arbitrarily\n     high debt amount will signal that the entire account should be liquidated. Otherwise, _debtAmount must be less than or equal to the max\n     debt which can be liquidated from the acount.\n     * @param _minExchangeRate represents the minimum number of collateral tokens which the liquidator is willing to receive in exchange for \n      1 debt token. A value of PRECISION will mean that the liquidation will revert unless the liquidator receives at least 1 collateral per\n      debt token repaid. A value of 0 means that slippage is not checked, and the liquidator will accept whatever the exchange rate happens to be.\n     * @return true if the liquidation was successful\n     */\n    function liquidate(\n        address _account,\n        uint256 _debtAmount,\n        uint256 _minExchangeRate\n    ) external onlyLiquidator whenNotPaused updateReward(_account) returns (bool) {\n        if (_debtAmount == 0) revert wrongLiquidationAmount();\n\n        UserDetails memory accDetails = userDetails[_account];\n\n        // Since Taurus accounts' debt continuously decreases, liquidators may pass in an arbitrarily large number in order to\n        // request to liquidate the entire account.\n        if (_debtAmount > accDetails.debt) {\n            _debtAmount = accDetails.debt;\n        }\n\n        // Get total fee charged to the user for this liquidation. Collateral equal to (liquidated taurus debt value * feeMultiplier) will be deducted from the user's account.\n        // This call reverts if the account is healthy or if the liquidation amount is too large.\n        (uint256 collateralToLiquidate, uint256 liquidationSurcharge) = _calcLiquidation(\n            accDetails.collateral,\n            accDetails.debt,\n            _debtAmount\n        );\n\n        // Check that collateral received is sufficient for liquidator\n        uint256 collateralToLiquidator = collateralToLiquidate - liquidationSurcharge;\n        if (collateralToLiquidator < (_debtAmount * _minExchangeRate) / Constants.PRECISION) {\n            revert insufficientCollateralLiquidated(_debtAmount, collateralToLiquidator);\n        }\n\n        // Update user info\n        userDetails[_account].collateral = accDetails.collateral - collateralToLiquidate;\n        userDetails[_account].debt = accDetails.debt - _debtAmount;\n\n        // Burn liquidator's Tau\n        TAU(tau).burnFrom(msg.sender, _debtAmount);\n\n        // Transfer part of _debtAmount to liquidator and Taurus as fees for liquidation\n        IERC20(collateralToken).safeTransfer(msg.sender, collateralToLiquidator);\n        IERC20(collateralToken).safeTransfer(\n            Controller(controller).addressMapper(Constants.FEE_SPLITTER),\n            liquidationSurcharge\n        );\n\n        emit AccountLiquidated(msg.sender, _account, collateralToLiquidate, liquidationSurcharge);\n\n        return true;\n    }\n\n    /**\n     * @dev calculate relevant liquidation parameters. If 100 TAU are liquidated, and the discount is 105%, then 100 * 1.05 = 105 TAU worth of collateral\n     * will be liquidated.\n     * @return collateralToLiquidate is the amount of the user's collateral which will be liquidated\n     * @return liquidationSurcharge is the amount of collateral which will be sent to the Taurus treasury as a liquidation fee\n     */\n    function _calcLiquidation(\n        uint256 _accountCollateral,\n        uint256 _accountDebt,\n        uint256 _debtToLiquidate\n    ) internal view returns (uint256 collateralToLiquidate, uint256 liquidationSurcharge) {\n        (uint256 price, uint8 decimals) = _getCollPrice();\n        uint256 _collRatio = TauMath._computeCR(_accountCollateral, _accountDebt, price, decimals);\n\n        uint256 totalLiquidationDiscount = _calcLiquidationDiscount(_collRatio);\n\n        uint256 collateralToLiquidateWithoutDiscount = (_debtToLiquidate * (10 ** decimals)) / price;\n        collateralToLiquidate = (collateralToLiquidateWithoutDiscount * totalLiquidationDiscount) / Constants.PRECISION;\n        if (collateralToLiquidate > _accountCollateral) {\n            collateralToLiquidate = _accountCollateral;\n        }\n\n        // Revert if requested liquidation amount is greater than allowed\n        if (\n            _debtToLiquidate >\n            _getMaxLiquidation(_accountCollateral, _accountDebt, price, decimals, totalLiquidationDiscount)\n        ) revert wrongLiquidationAmount();\n\n        return (\n            collateralToLiquidate,\n            (collateralToLiquidateWithoutDiscount * LIQUIDATION_SURCHARGE) / Constants.PRECISION\n        );\n    }\n\n    /**\n     * @dev calculate the current liquidation discount for a given account\n     * @return liquidationDiscount -- the discount applied to the price of the user's collateral. If 100 TAU of debt are liquidated, 100 * liquidationDiscount / PRECISION collateral \n     will be liquidated.\n     * note that the calculated discount includes the liquidation surcharge, so not all of the discounted funds will be sent to the liquidator.\n     * note that the discount cannot exceed MAX_LIQ_DISCOUNT.\n     * The liquidation discount may be any value in the range of (PRECISION, MAX_LIQ_DISCOUNT]. \n     */\n    function _calcLiquidationDiscount(uint256 _accountHealth) internal pure returns (uint256 liquidationDiscount) {\n        if (_accountHealth >= MIN_COL_RATIO) {\n            revert cannotLiquidateHealthyAccount();\n        }\n\n        // The liquidator's discount on user funds is based on how far underwater the position is, to simulate a dutch auction.\n        // The discount is capped at MAX_LIQ_DISCOUNT.\n        uint256 diff = (MIN_COL_RATIO + LIQUIDATION_SURCHARGE) - _accountHealth;\n        if (diff > MAX_LIQ_DISCOUNT) {\n            diff = MAX_LIQ_DISCOUNT;\n        }\n\n        liquidationDiscount = Constants.PRECISION + diff;\n    }\n\n    /**\n     * @dev Updates a user's rewards. Callable by anyone, but really only useful for keepers\n     *  to update inactive accounts (thus redistributing their excess rewards to the vault).\n     * @param _account is the account whose rewards will be updated\n     */\n    function updateRewards(address _account) external whenNotPaused updateReward(_account) {}\n\n    function _authorizeUpgrade(address newImplementation) internal virtual override onlyGovernor {}\n\n    uint256[48] private __gap;\n}"
    }
  ]
}