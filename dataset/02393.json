{
  "Title": "H-8: Protection buyer may buy multiple protections for same goldfinch NFT",
  "Content": "# Issue H-8: Protection buyer may buy multiple protections for same goldfinch NFT \n\nSource: https://github.com/sherlock-audit/2023-02-carapace-judging/issues/112 \n\n## Found by \nlibratus, ctf\\_sec, minhtrng, jkoppel, clems4ever, chaduke, \\_\\_141345\\_\\_, Allarious, immeas, c7e7eff, 0Kage, 0x52, modern\\_Alchemist\\_00, bin2chen\n\n## Summary\nThe Carapace protocol checks that a protection buyer does not buy a protection for an \namount greater than the remainingPrincipal in the corresponding loan. \nHowever it possible for the buyer to buy multiple different protections for the same Goldfinch loan.\n\n## Vulnerability Detail\nThe check for the possibility for a user to buy a protection is done here in `ReferenceLendingPools.canBuyProtection`:\nhttps://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/pool/ReferenceLendingPools.sol#L132-L168\n\nIt checks the protection about to be created does not cross remaining principal. But it still allows the user to create multiple protections for the same loan position.\n\n## Impact\nThe malicious user can `overprotect` their loan position on Goldfinch and thus claim a larger amount on loan default than what they lended. For now as the default claiming feature is not implemented, they can use this bug to DOS the protocol by using all funds deposited into the protocol reaching `leverageRatioFloor` and not allowing any new protections to be bought.\n\n## Code Snippet\n\n## Tool used\nManual Review\n\n## Recommendation\nKeep track of the total protection subscribed for a given loan and limit total protection value to remaining capital\n\n## Discussion\n\n**vnadoda**\n\n@clems4ev3r this is duplicate of #193 & #139\n\n**hrishibhat**\n\nSponsor comment from #193:\n\nDouble buying of protections for the same NFT is a known issue and we were planning to tackle it in an upcoming version because even after buying multiple protections buyers won't be able to claim for the same position as default payout will require NFT lock/transfer in the carapace vault.\n\nThis double counting of locked capital issue seems a legit concern.\nNow we are considering fixing this with other audit issues.\n\n\n**vnadoda**\n\n@clems4ev3r PR for this fix: https://github.com/carapace-finance/credit-default-swaps-contracts/pull/59\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/40",
  "Code": [
    {
      "filename": "contracts/core/pool/ReferenceLendingPools.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {UUPSUpgradeableBase} from \"../../UUPSUpgradeableBase.sol\";\n\nimport {IReferenceLendingPools, LendingPoolStatus, LendingProtocol, ProtectionPurchaseParams, ReferenceLendingPoolInfo} from \"../../interfaces/IReferenceLendingPools.sol\";\nimport {ILendingProtocolAdapter} from \"../../interfaces/ILendingProtocolAdapter.sol\";\nimport {ILendingProtocolAdapterFactory} from \"../../interfaces/ILendingProtocolAdapterFactory.sol\";\n\nimport \"../../libraries/Constants.sol\";\n\n/**\n * @title ReferenceLendingPools\n * @author Carapace Finance\n * @notice ReferenceLendingPools manages the basket of reference lending pools,\n * against which the carapace protocol can provide the protection.\n *\n * @dev This contract is upgradeable using the UUPS pattern.\n */\ncontract ReferenceLendingPools is UUPSUpgradeableBase, IReferenceLendingPools {\n  /////////////////////////////////////////////////////\n  ///             STORAGE - START                   ///\n  /////////////////////////////////////////////////////\n  /**\n   * @dev DO NOT CHANGE THE ORDER OF THESE VARIABLES ONCE DEPLOYED\n   */\n\n  /// @notice the lending protocol adapter factory\n  ILendingProtocolAdapterFactory private lendingProtocolAdapterFactory;\n\n  /// @notice the mapping of the lending pool address to the lending pool info\n  mapping(address => ReferenceLendingPoolInfo) public referenceLendingPools;\n\n  /// @notice an array of all the added lending pools in this basket\n  address[] private lendingPools;\n\n  //////////////////////////////////////////////////////\n  ///             STORAGE - END                     ///\n  /////////////////////////////////////////////////////\n\n  /** modifiers */\n\n  /// @dev modifier to check if the lending pool is supported,\n  /// i.e. added to this basket and is active\n  modifier whenLendingPoolSupported(address _lendingPoolAddress) {\n    if (!_isReferenceLendingPoolAdded(_lendingPoolAddress)) {\n      revert ReferenceLendingPoolNotSupported(_lendingPoolAddress);\n    }\n    _;\n  }\n\n  /// @inheritdoc IReferenceLendingPools\n  function initialize(\n    address _owner,\n    address[] calldata _lendingPools,\n    LendingProtocol[] calldata _lendingPoolProtocols,\n    uint256[] calldata _protectionPurchaseLimitsInDays,\n    address _lendingProtocolAdapterFactory\n  ) external override initializer {\n    if (\n      _lendingPools.length != _lendingPoolProtocols.length ||\n      _lendingPools.length != _protectionPurchaseLimitsInDays.length\n    ) {\n      revert ReferenceLendingPoolsConstructionError(\n        \"Array inputs length must match\"\n      );\n    }\n\n    if (_owner == Constants.ZERO_ADDRESS) {\n      revert ReferenceLendingPoolsConstructionError(\n        \"Owner address must not be zero\"\n      );\n    }\n\n    /// Initialize the UUPSUpgradeableBase\n    __UUPSUpgradeableBase_init();\n\n    lendingProtocolAdapterFactory = ILendingProtocolAdapterFactory(\n      _lendingProtocolAdapterFactory\n    );\n\n    /// Transfer ownership of this contract to the specified owner address\n    _transferOwnership(_owner);\n\n    /// Add the specified lending pools to the basket\n    uint256 length = _lendingPools.length;\n    for (uint256 i; i < length; ) {\n      _addReferenceLendingPool(\n        _lendingPools[i],\n        _lendingPoolProtocols[i],\n        _protectionPurchaseLimitsInDays[i]\n      );\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /** state changing functions */\n\n  /**\n   * @notice Adds a new reference lending pool to the basket.\n   * @dev This function can only be called by the owner of this contract.\n   * @dev This function is marked as payable for gas optimization.\n   * @param _lendingPoolAddress address of the lending pool\n   * @param _lendingPoolProtocol the protocol of underlying lending pool\n   * @param _protectionPurchaseLimitInDays the protection purchase limit in days.\n   * i.e. 90 days means the protection can be purchased within {_protectionPurchaseLimitInDays} days of\n   * lending pool being added to this contract.\n   */\n  function addReferenceLendingPool(\n    address _lendingPoolAddress,\n    LendingProtocol _lendingPoolProtocol,\n    uint256 _protectionPurchaseLimitInDays\n  ) external payable onlyOwner {\n    _addReferenceLendingPool(\n      _lendingPoolAddress,\n      _lendingPoolProtocol,\n      _protectionPurchaseLimitInDays\n    );\n  }\n\n  /** view functions */\n\n  /// @inheritdoc IReferenceLendingPools\n  function getLendingPools() public view override returns (address[] memory) {\n    return lendingPools;\n  }\n\n  /// @inheritdoc IReferenceLendingPools\n  function canBuyProtection(\n    address _buyer,\n    ProtectionPurchaseParams calldata _purchaseParams,\n    bool _isRenewal\n  )\n    external\n    view\n    override\n    whenLendingPoolSupported(_purchaseParams.lendingPoolAddress)\n    returns (bool)\n  {\n    ReferenceLendingPoolInfo storage lendingPoolInfo = referenceLendingPools[\n      _purchaseParams.lendingPoolAddress\n    ];\n\n    /// When buyer is not renewing the existing protection and\n    /// the protection purchase is NOT within purchase limit duration after\n    /// a lending pool added, the buyer cannot purchase protection.\n    /// i.e. if the purchase limit is 90 days, the buyer cannot purchase protection\n    /// after 90 days of lending pool added to the basket\n    if (\n      !_isRenewal &&\n      block.timestamp > lendingPoolInfo.protectionPurchaseLimitTimestamp\n    ) {\n      return false;\n    }\n\n    /// Verify that protection amount is less than or equal to the remaining principal\n    /// that buyer has lent to the underlying lending pool\n    return\n      _purchaseParams.protectionAmount <=\n      calculateRemainingPrincipal(\n        _purchaseParams.lendingPoolAddress,\n        _buyer,\n        _purchaseParams.nftLpTokenId\n      );\n  }\n\n  /// @inheritdoc IReferenceLendingPools\n  function calculateProtectionBuyerAPR(address _lendingPoolAddress)\n    public\n    view\n    override\n    whenLendingPoolSupported(_lendingPoolAddress)\n    returns (uint256)\n  {\n    return\n      _getLendingProtocolAdapter(_lendingPoolAddress)\n        .calculateProtectionBuyerAPR(_lendingPoolAddress);\n  }\n\n  /// @inheritdoc IReferenceLendingPools\n  function assessState()\n    public\n    view\n    override\n    returns (\n      address[] memory _lendingPools,\n      LendingPoolStatus[] memory _statuses\n    )\n  {\n    uint256 _length = lendingPools.length;\n    _lendingPools = new address[](_length);\n    _statuses = new LendingPoolStatus[](_length);\n\n    /// Iterate through all the lending pools in this basket and get their statuses\n    for (uint256 i; i < _length; ) {\n      _lendingPools[i] = lendingPools[i];\n      _statuses[i] = _getLendingPoolStatus(lendingPools[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /// @inheritdoc IReferenceLendingPools\n  function calculateRemainingPrincipal(\n    address _lendingPool,\n    address _lender,\n    uint256 _nftLpTokenId\n  )\n    public\n    view\n    override\n    whenLendingPoolSupported(_lendingPool)\n    returns (uint256)\n  {\n    return\n      _getLendingProtocolAdapter(_lendingPool).calculateRemainingPrincipal(\n        _lendingPool,\n        _lender,\n        _nftLpTokenId\n      );\n  }\n\n  /// @inheritdoc IReferenceLendingPools\n  function getLatestPaymentTimestamp(address _lendingPool)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    return\n      _getLendingProtocolAdapter(_lendingPool).getLatestPaymentTimestamp(\n        _lendingPool\n      );\n  }\n\n  /// @inheritdoc IReferenceLendingPools\n  function getPaymentPeriodInDays(address _lendingPool)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    return\n      _getLendingProtocolAdapter(_lendingPool).getPaymentPeriodInDays(\n        _lendingPool\n      );\n  }\n\n  /** internal functions */\n\n  /**\n   * @dev Adds a new reference lending pool to the basket if it is not already added.\n   */\n  function _addReferenceLendingPool(\n    address _lendingPoolAddress,\n    LendingProtocol _lendingPoolProtocol,\n    uint256 _protectionPurchaseLimitInDays\n  ) internal {\n    if (_lendingPoolAddress == Constants.ZERO_ADDRESS) {\n      revert ReferenceLendingPoolIsZeroAddress();\n    }\n\n    if (_isReferenceLendingPoolAdded(_lendingPoolAddress)) {\n      revert ReferenceLendingPoolAlreadyAdded(_lendingPoolAddress);\n    }\n\n    uint256 _protectionPurchaseLimitTimestamp = block.timestamp +\n      (_protectionPurchaseLimitInDays * Constants.SECONDS_IN_DAY_UINT);\n\n    /// add the underlying lending pool to this basket\n    referenceLendingPools[_lendingPoolAddress] = ReferenceLendingPoolInfo({\n      protocol: _lendingPoolProtocol,\n      addedTimestamp: block.timestamp,\n      protectionPurchaseLimitTimestamp: _protectionPurchaseLimitTimestamp\n    });\n    lendingPools.push(_lendingPoolAddress);\n\n    LendingPoolStatus _poolStatus = _getLendingPoolStatus(_lendingPoolAddress);\n    if (_poolStatus != LendingPoolStatus.Active) {\n      revert ReferenceLendingPoolIsNotActive(_lendingPoolAddress);\n    }\n\n    emit ReferenceLendingPoolAdded(\n      _lendingPoolAddress,\n      _lendingPoolProtocol,\n      block.timestamp,\n      _protectionPurchaseLimitTimestamp\n    );\n  }\n\n  /// @dev Returns the lending protocol adapter for the given lending pool address\n  function _getLendingProtocolAdapter(address _lendingPoolAddress)\n    internal\n    view\n    returns (ILendingProtocolAdapter)\n  {\n    return\n      lendingProtocolAdapterFactory.getLendingProtocolAdapter(\n        referenceLendingPools[_lendingPoolAddress].protocol\n      );\n  }\n\n  /// @dev Specifies whether the given lending pool is added to the basket or not\n  function _isReferenceLendingPoolAdded(address _lendingPoolAddress)\n    internal\n    view\n    returns (bool)\n  {\n    return referenceLendingPools[_lendingPoolAddress].addedTimestamp != 0;\n  }\n\n  /// @dev Returns the status of the given lending pool\n  function _getLendingPoolStatus(address _lendingPoolAddress)\n    internal\n    view\n    returns (LendingPoolStatus)\n  {\n    if (!_isReferenceLendingPoolAdded(_lendingPoolAddress)) {\n      return LendingPoolStatus.NotSupported;\n    }\n\n    ILendingProtocolAdapter _adapter = _getLendingProtocolAdapter(\n      _lendingPoolAddress\n    );\n\n    if (_adapter.isLendingPoolExpired(_lendingPoolAddress)) {\n      return LendingPoolStatus.Expired;\n    }\n\n    if (\n      _adapter.isLendingPoolLateWithinGracePeriod(\n        _lendingPoolAddress,\n        Constants.LATE_PAYMENT_GRACE_PERIOD_IN_DAYS\n      )\n    ) {\n      return LendingPoolStatus.LateWithinGracePeriod;\n    }\n\n    if (_adapter.isLendingPoolLate(_lendingPoolAddress)) {\n      return LendingPoolStatus.Late;\n    }\n\n    return LendingPoolStatus.Active;\n  }\n}"
    }
  ]
}