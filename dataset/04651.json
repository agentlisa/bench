{
  "Title": "Avoid duplicated code",
  "Content": "Duplicate code makes it harder to understand the code’s intention and thus, auditing the code correctly. It also increases the risk of introducing hidden bugs when modifying one of the copies of some code and not the others.\n\n\nThe logic in [transfer](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/RLC.sol#L62), [transferFrom](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/RLC.sol#L69), [balanceOf](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/RLC.sol#L79), [allowance](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/RLC.sol#L97) and [approve](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/RLC.sol#L83) is very similar to the provided methods in [StandardToken](https://github.com/OpenZeppelin/zeppelin-solidity/blob/52120a8c428de5e34f157b7eaed16d38f3029e66/contracts/token/StandardToken.sol) and could be refactored to avoid repetition. There is no need to rewrite the parent’s contract logic: consider using the [super keyword](https://ethereum.stackexchange.com/questions/12920/what-does-the-keyword-super-in-solidity-do) to access StandardToken implementation of methods, like so:\n\n\n\n```\n\nfunction transfer(address _to, uint _value) onlyUnlocked returns (bool success) {\n  return super.transfer(_to, _value);\n}\n\n```\n\nFurthermore, [the burn method](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/RLC.sol#L54) is a close rewrite of **transfer**, consider having burn call transfer instead.\n\n\nFinally, Crowdsale.sol could use OpenZeppelin’s Ownable instead of [implementing the same idea](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/Crowdsale.sol#L105).\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/RLC.sol",
      "content": "pragma solidity ^0.4.8;\n\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./ERC20.sol\";\nimport \"./TokenSpender.sol\";\n\ncontract RLC is ERC20, SafeMath, Ownable {\n\n    /* Public variables of the token */\n  string public name;       //fancy name\n  string public symbol;\n  uint8 public decimals;    //How many decimals to show.\n  string public version = 'v0.1'; \n  uint256 public initialSupply;\n  address public burnAddress;\n  uint256 public totalSupply;\n  bool public locked;\n  uint public unlockBlock;\n\n  mapping(address => uint) balances;\n  mapping (address => mapping (address => uint)) allowed;\n\n  // lock transfer during the ICO\n  modifier onlyUnlocked() {\n    if (msg.sender != owner && locked) throw;\n    _;\n  }\n\n  /*\n   *  The RLC Token created with the time at which the crowdsale end\n   */\n\n  function RLC() {\n    // lock the transfer function during the crowdsale\n    locked = true;\n    unlockBlock=  now + 45 days; // (testnet) - for mainnet put the block number\n\n    initialSupply = 87000000000000000;\n    totalSupply = initialSupply;\n    balances[msg.sender] = initialSupply;// Give the creator all initial tokens                    \n    name = 'iEx.ec Network Token';        // Set the name for display purposes     \n    symbol = 'RLC';                       // Set the symbol for display purposes  \n    decimals = 9;                        // Amount of decimals for display purposes\n    burnAddress = 0x1b32000000000000000000000000000000000000;\n  }\n\n  function unlock() {\n    if (now < unlockBlock) throw;\n    if (!locked) throw;   // to allow only 1 call\n    locked = false;\n  }\n\n  function burn(uint256 _value) returns (bool success){\n    balances[msg.sender] = safeSub(balances[msg.sender], _value) ;\n    balances[burnAddress] = safeAdd(balances[burnAddress], _value);\n    totalSupply = safeSub(totalSupply, _value);\n    Transfer(msg.sender, burnAddress, _value);\n    return true;\n  }\n\n  function transfer(address _to, uint _value) onlyUnlocked returns (bool success) {\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n    balances[_to] = safeAdd(balances[_to], _value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  function transferFrom(address _from, address _to, uint _value) onlyUnlocked returns (bool success) {\n    var _allowance = allowed[_from][msg.sender];\n    \n    balances[_to] = safeAdd(balances[_to], _value);\n    balances[_from] = safeSub(balances[_from], _value);\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  function balanceOf(address _owner) constant returns (uint balance) {\n    return balances[_owner];\n  }\n\n  function approve(address _spender, uint _value) returns (bool success) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n    /* Approve and then comunicate the approved contract in a single tx */\n  function approveAndCall(address _spender, uint256 _value, bytes _extraData, bytes _extraData2){    \n      TokenSpender spender = TokenSpender(_spender);\n      if (approve(_spender, _value)) {\n          spender.receiveApproval(msg.sender, _value, this, _extraData, _extraData2);\n      }\n  }\n\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n    return allowed[_owner][_spender];\n  }\n  \n    /* This unnamed function is called whenever someone tries to send ether to it */\n    function () {\n        throw;     // Prevents accidental sending of ether\n    }\n}"
    },
    {
      "filename": "contracts/RLC.sol",
      "content": "pragma solidity ^0.4.8;\n\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./ERC20.sol\";\nimport \"./TokenSpender.sol\";\n\ncontract RLC is ERC20, SafeMath, Ownable {\n\n    /* Public variables of the token */\n  string public name;       //fancy name\n  string public symbol;\n  uint8 public decimals;    //How many decimals to show.\n  string public version = 'v0.1'; \n  uint256 public initialSupply;\n  address public burnAddress;\n  uint256 public totalSupply;\n  bool public locked;\n  uint public unlockBlock;\n\n  mapping(address => uint) balances;\n  mapping (address => mapping (address => uint)) allowed;\n\n  // lock transfer during the ICO\n  modifier onlyUnlocked() {\n    if (msg.sender != owner && locked) throw;\n    _;\n  }\n\n  /*\n   *  The RLC Token created with the time at which the crowdsale end\n   */\n\n  function RLC() {\n    // lock the transfer function during the crowdsale\n    locked = true;\n    unlockBlock=  now + 45 days; // (testnet) - for mainnet put the block number\n\n    initialSupply = 87000000000000000;\n    totalSupply = initialSupply;\n    balances[msg.sender] = initialSupply;// Give the creator all initial tokens                    \n    name = 'iEx.ec Network Token';        // Set the name for display purposes     \n    symbol = 'RLC';                       // Set the symbol for display purposes  \n    decimals = 9;                        // Amount of decimals for display purposes\n    burnAddress = 0x1b32000000000000000000000000000000000000;\n  }\n\n  function unlock() {\n    if (now < unlockBlock) throw;\n    if (!locked) throw;   // to allow only 1 call\n    locked = false;\n  }\n\n  function burn(uint256 _value) returns (bool success){\n    balances[msg.sender] = safeSub(balances[msg.sender], _value) ;\n    balances[burnAddress] = safeAdd(balances[burnAddress], _value);\n    totalSupply = safeSub(totalSupply, _value);\n    Transfer(msg.sender, burnAddress, _value);\n    return true;\n  }\n\n  function transfer(address _to, uint _value) onlyUnlocked returns (bool success) {\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n    balances[_to] = safeAdd(balances[_to], _value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  function transferFrom(address _from, address _to, uint _value) onlyUnlocked returns (bool success) {\n    var _allowance = allowed[_from][msg.sender];\n    \n    balances[_to] = safeAdd(balances[_to], _value);\n    balances[_from] = safeSub(balances[_from], _value);\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  function balanceOf(address _owner) constant returns (uint balance) {\n    return balances[_owner];\n  }\n\n  function approve(address _spender, uint _value) returns (bool success) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n    /* Approve and then comunicate the approved contract in a single tx */\n  function approveAndCall(address _spender, uint256 _value, bytes _extraData, bytes _extraData2){    \n      TokenSpender spender = TokenSpender(_spender);\n      if (approve(_spender, _value)) {\n          spender.receiveApproval(msg.sender, _value, this, _extraData, _extraData2);\n      }\n  }\n\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n    return allowed[_owner][_spender];\n  }\n  \n    /* This unnamed function is called whenever someone tries to send ether to it */\n    function () {\n        throw;     // Prevents accidental sending of ether\n    }\n}"
    },
    {
      "filename": "contracts/Crowdsale.sol",
      "content": "pragma solidity ^0.4.8;\nimport \"./SafeMath.sol\";\nimport \"./RLC.sol\";\nimport \"./PullPayment.sol\";\nimport \"./Pausable.sol\";\n\n/*\n  Crowdsale Smart Contract for the iEx.ec project\n\n  This smart contract collects ETH and BTC, and in return emits RLC tokens to the backers\n\n  Thanks to BeyondTheVoid and TokenMarket who helped us shaping this code.\n\n */\n\n// To do : create a generic test with parameter to run abitrary simulation\n// To test: RLC allowance when reach Maxcap, Unlock transfer, pausable\n\n\ncontract Crowdsale is SafeMath, PullPayment, Pausable {\n\n  \tstruct Backer {\n  \t  uint weiReceived;\t// Amount of ETH given\n\t  string btc_address;  //store the btc address for full tracability\n\t  uint satoshiReceived;\t// Amount of BTC given\n\t  uint rlcToSend;   \t// rlc to distribute when the min cap is reached\n\t  uint rlcSent;\n\t}\n\n\tRLC \tpublic rlc;         // RLC contract reference\n\taddress public owner;       // Contract owner (iEx.ec team)\n\taddress public multisigETH; // Multisig contract that will receive the ETH\n\taddress public BTCproxy;\t// addess of the BTC Proxy\n\n\tuint public RLCPerETH;      // Number of RLC per ETH\n\tuint public RLCPerSATOSHI;  // Number of RLC per SATOSHI\n\tuint public ETHReceived;    // Number of ETH received\n\tuint public BTCReceived;    // Number of BTC received\n\tuint public RLCSentToETH;   // Number of RLC sent to ETH contributors\n\tuint public RLCSentToBTC;   // Number of RLC sent to BTC contributors\n\tuint public RLCEmitted;\t\t// Number of RLC emitted \n\tuint public startBlock;     // Crowdsale start block\n\tuint public endBlock;       // Crowdsale end block\n\tuint public minCap;         // Minimum number of RLC to sell\n\tuint public maxCap;         // Maximum number of RLC to sell\n\tbool public maxCapReached;  // Max cap has been reached\n\tuint public minInvestETH;   // Minimum amount to invest\n\tuint public minInvestBTC;   // Minimum amount to invest\n\tbool public crowdsaleClosed;// Is crowdsale still on going\n\t\n\taddress public bounty;\t\t// address at which the bounty RLC will be sent\n\taddress public reserve; \t// address at which the contingency reserve will be sent\n\taddress public team;\t\t// address at which the team RLC will be sent\n\n\tuint public rlc_bounty;\t\t// amount of bounties RLC\n\tuint public rlc_reserve;\t// amount of the contingency reserve\n\tuint public rlc_team;\t\t// amount of the team RLC \n\t\n\tmapping(address => Backer) public backers; //backersETH indexed by their ETH address\n\t//mapping(address => BackerBTC) public backersBTC; //backersBTC indexed by their (BTC,ETH) address\n\n    // Auth modifier, if the msg.sender isn't the expected address, throw.\n\tmodifier onlyBy(address a){\n\t    if (msg.sender != a) throw;  \n\t    _;\n\t}\n\n\tmodifier minCapNotReached() {\n\t\tif ((now<endBlock) || isMinCapReached() || (now > endBlock + 15 days)) throw;\n\t\t_;\n\t}\n\n\t/*\n\t *  /!\\ FUNCTION FOR TEST ONLY - WILL BE REMOVE IN THE FINAL CONTRACT\n\t */\n\n\tfunction closeCrowdsaleForRefund() {\n\t\tendBlock = now;\n\t}\n\t// same than finalise() without time condition\n\tfunction finalizeTEST() onlyBy(owner) {\n\t\t//moves the remaining ETH to the multisig address\n\t\tif (!multisigETH.send(this.balance)) throw;\n\t\t//moves RLC to the team, reserve and bounty address\n\t    if (!transferRLC(team,rlc_team)) throw;\n\t    if (!transferRLC(reserve,rlc_reserve)) throw;\t\n\t    if (!transferRLC(bounty,rlc_bounty)) throw;\n\t    rlc.burn(rlc.totalSupply() - RLCEmitted);\n\t\tcrowdsaleClosed = true;\n\t}\n\n\t/*\n\t * /!\\ END TEST FUNCTION\n\t */\n\n\n\tevent ReceivedETH(address addr, uint value);\n\tevent ReceivedBTC(address addr, string from, uint value);\n\tevent RefundBTC(string to, uint value);\n\tevent Logs(address indexed from, uint amount, string value);\n\t// Constructor of the contract.\n\tfunction Crowdsale(address _token, address _btcproxy) {\n\t\t\n\t  //set the different variables\n\t  owner = msg.sender;\n\t  BTCproxy = _btcproxy; // to change\n\t  rlc = RLC(_token); \t// RLC contract address\n\t  multisigETH = 0x8cd6B3D8713df6aA35894c8beA200c27Ebe92550;\n\t  team = 0x1000000000000000000000000000000000000000;\n\t  reserve = 0x2000000000000000000000000000000000000000;\n\t  bounty = 0x3000000000000000000000000000000000000000;\n\t  RLCSentToETH = 0;\n\t  RLCSentToBTC = 0;\n\t  minInvestETH = 100 finney; // 0.1 ether\n\t  minInvestBTC = 100000;     // approx 1 USD or 0.00100000 BTC\n\t  startBlock = now ;            // now (testnet)\n\t  endBlock =  now + 30 days;    // ever (testnet) startdate + 30 days\n\t  RLCPerETH = 5000000000000;    // FIXME  will be update\n\t  RLCPerSATOSHI = 50000;         // 5000 RLC par BTC == 50,000 RLC per satoshi\n\t  minCap=12000000000000000;\n\t  maxCap=60000000000000000;\n\t  rlc_bounty=1700000000000000;\t\t\n\t  //rlc_reserve=17000000000000000;\n\t  rlc_reserve=1700000000000000;\n\t  rlc_team=12000000000000000;\n\t  RLCEmitted = rlc_bounty + rlc_reserve + rlc_team;\n\t}\n\n\t/* \n\t* The fallback function corresponds to a donation in ETH\n\t*/\n\tfunction() payable\t{\n\t  receiveETH(msg.sender);\n\t}\n\n\t/*\n\t*\tReceives a donation in ETH\n\t*/\n\tfunction receiveETH(address beneficiary) stopInEmergency payable {\n\n\t  //don't accept funding under a predefined treshold\n\t  if (msg.value < minInvestETH) throw;  \n\n\t  // check if we are in the correct time slot\n\t  if ((now < startBlock) || (now > endBlock )) throw;  \n\n\t  //compute the number of RLC to send\n\t  uint rlcToSend = bonus((msg.value*RLCPerETH)/(1 ether));\n\t  //uint rlcToSend = bonus((msg.value*RLCPerFINNEY)/(1 finney));\n\n\t  // check if we are not reaching the maxCap by accepting this donation\n\t  if ((rlcToSend + RLCSentToETH + RLCSentToBTC) > maxCap) throw;\n\n\t  //update the backer\n\t  Backer backer = backers[beneficiary];\n\n\t  if (!transferRLC(beneficiary, rlcToSend)) throw;     // Do the transfer right now \n\n\t  backer.rlcSent = safeAdd(backer.rlcSent, rlcToSend);\n\t  backer.weiReceived = safeAdd(backer.weiReceived, msg.value); // Update the total wei collcted during the crowdfunding     \n\t  ETHReceived = safeAdd(ETHReceived, msg.value); // Update the total wei collcted during the crowdfunding\n\t  RLCSentToETH = safeAdd(RLCSentToETH, rlcToSend);\n\n\t  emitRLC(rlcToSend);\n\t  // send the corresponding contribution event\n\t  ReceivedETH(beneficiary,ETHReceived);\n\t}\n\t\n\t/*\n\t* receives a donation in BTC\n\t*/\n\n\t// Refund BTC in JS if function throw\n\n\tfunction receiveBTC(address beneficiary, string btc_address, uint value) stopInEmergency onlyBy(BTCproxy){\n\t  //don't accept funding under a predefined treshold\n\t  if (value < minInvestBTC) throw;  \n\n\t  // if we are in the correct time slot\n\t  if ((now < startBlock) || (now > endBlock )) throw;  \n\n\t  //compute the number of RLC to send\n\t  uint rlcToSend = bonus((value*RLCPerSATOSHI));\n\n\t  // check if we are not reaching the maxCap\n\t  if ((rlcToSend + RLCSentToETH + RLCSentToBTC) > maxCap) throw;\n\n\t  //update the backer\n\t  Backer backer = backers[beneficiary];\n\n\t  // if the min cap is reached, token transfer happens immediately possibly along\n\t  // with the previous donation\n\t  if (!transferRLC(beneficiary, rlcToSend)) throw;     // Do the transfer right now \n\n\t  backer.rlcSent = safeAdd(backer.rlcSent , rlcToSend);\n\t  backer.btc_address = btc_address;\n\t  backer.satoshiReceived = safeAdd(backer.satoshiReceived, value);\n\t  BTCReceived =  safeAdd(BTCReceived, value);// Update the total satoshi collcted during the crowdfunding \n\t  RLCSentToBTC = safeAdd(RLCSentToBTC, rlcToSend);\n\t  emitRLC(rlcToSend);\n\t  \n\t  ReceivedBTC(beneficiary, btc_address, BTCReceived);\n\t}\n\t\n\tfunction isMinCapReached() internal returns (bool) {\n\t\treturn (RLCSentToETH + RLCSentToBTC ) > minCap;\n\t}\n\n\tfunction isMaxCapReached() internal returns (bool) { \n\t\treturn (RLCSentToETH + RLCSentToBTC ) == maxCap;\n\t}\n\n\t// Compute the variable part\n\tfunction emitRLC(uint amount) internal {\n\t\tLogs(msg.sender ,amount, \"emitRLC\");\n\t\trlc_bounty+=amount/10;      // bounty is 10% of the crowdsale\n\t\trlc_team+=amount/20;        // team is 5% of the crowdsale\n\t\trlc_reserve+=amount/10; \t// contingency is 10% of the crowdsale\n\t\tRLCEmitted+=amount + amount/4;\t// adjust the total number of RLC emitted\n\t}\n\n\t/*\n\t  Compute the RLC bonus according to the investment period\n\t*/\n\tfunction bonus(uint amount) internal returns (uint) {\n\t  if (now < (startBlock + 10 days)) return (amount + amount/5);  // bonus 20%\n\t  if (now < startBlock + 20 days) return (amount + amount/10);  // bonus 10%\n\t  return amount;\n\t}\n\t\n\t/*\n\t * Transfer RLC to backers\n\t * Assumes that the owner of the token contract and the crowdsale contract is the same\n\t */\n\tfunction transferRLC(address to, uint amount) internal returns (bool) {\n\t  return rlc.transfer(to, amount);\n\t}\n\n\t/* \n\t * When mincap is not reach backer can call the approveAndCall function of the RLC token contract\n\t * whith this crowdsale contract on parameter with all the RLC they get in order to be refund\n\t */\n\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData, bytes _extraData2) minCapNotReached public {\n        if (msg.sender != address(rlc)) throw; \n        if (_extraData.length != 0) throw;  // no extradata needed\n        if (_extraData2.length != 0) throw;  // no extradata needed\n        if (_value != backers[_from].rlcSent) throw; // compare value from backer balance\n        if (!rlc.transferFrom(_from, address(this), _value)) throw ; // get the token back to the crowdsale contract\n\t\tuint ETHToSend = backers[_from].weiReceived;\n\t\tbackers[_from].weiReceived=0;\n\t\tuint BTCToSend = backers[_from].satoshiReceived;\n\t\tbackers[_from].satoshiReceived = 0;\n\t\tif (ETHToSend > 0) {\n\t\t\tasyncSend(_from,ETHToSend);\n\t\t}\n\t\tif (BTCToSend > 0)\n\t\t\tRefundBTC(backers[_from].btc_address ,BTCToSend); // event message to manually refund BTC\n    }\n/*\n    function receiveApprovalOLD(address _from, uint256 _value, address _token, bytes _extraData, bytes _extraData2) minCapNotReached public {\n        if (msg.sender != address(rlc)) throw; \n        if (bytes(_extraData).length != 0) throw;  // no extradata needed\n        if (bytes(_extraData2).length!= 0) throw;  // no extradata needed\n        if (_value != backers[_from].rlcSent) throw; // compare value from backer balance\n        if (!rlc.transferFrom(_from, address(this), _value)) throw ; // get the token back to the crowdsale contract\n\t\tuint ETHToSend = backers[_from].weiReceived;\n\t\tbackers[_from].weiReceived=0;\n\t\tuint BTCToSend = backers[_from].satoshiReceived;\n\t\tbackers[_from].satoshiReceived = 0;\n\t\tif (ETHToSend > 0) {\n\t\t\tif (_from.send(ETHToSend)) {\n\t\t\t\t\tRefundETH(_from,ETHToSend);\n\t\t\t\t} else {\n\t\t\t\t\tbackers[_from].weiReceived = ETHToSend;\n\t\t\t\t}\n\t\t}\n\t\tif (BTCToSend > 0)\n\t\t\tRefundBTC(backers[msg.sender].btc_address ,BTCToSend); // event message to manually refund BTC\n    }\n*/\n\n\t/*\n\t* Update the rate RLC per ETH, computed externally by using the BTCETH index on kraken every 10min\n\t*/\n\tfunction setRLCPerETH(uint rate) onlyBy(BTCproxy) {\n\t\tRLCPerETH=rate;\n\t}\n\t\n\t/*\t\n\t* Finalize the crowdsale, should be called after the refund period\n\t*/\n\tfunction finalize() onlyBy(owner) {\n\t\t//if ((now < endBlock + 15 days ) || (now > endBlock + 60 days)) throw;\n\t\tif (now < endBlock + 15 days ) throw;\n\t\t//moves the remaining ETH to the multisig address\n\t\tif (!multisigETH.send(this.balance)) throw;\n\t\t//moves RLC to the team, reserve and bounty address\n\t    if (!transferRLC(team,rlc_team)) throw;\n\t    if (!transferRLC(reserve,rlc_reserve)) throw;\t\n\t    if (!transferRLC(bounty,rlc_bounty)) throw;\n\t    rlc.burn(rlc.totalSupply() - RLCEmitted);\n\t\tcrowdsaleClosed = true;\n\t}\n}"
    }
  ]
}