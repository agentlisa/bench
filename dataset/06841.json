{
  "Title": "[M-03] Potential `stake()` DoS if sole safETH holder (ie: first depositor) unstakes `totalSupply` - 1",
  "Content": "\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L68-L81> <br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L98>\n\n### Impact\n\nPotential inability to stake (ie: DoS) if sole safETH user (ie: this would also make them the sole safETH holder) unstakes `totalSupply - 1`.\n\n### Proof of Concept\n\nThe goal of this POC is to prove that this line can revert <https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L98>\n\n            uint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice;\n\nThis can occur if the attacker can cause `preDepositPrice = 0`.\n\nA user who is the first staker will be the sole holder of 100% of `totalSupply` of safETH.\n\nThey can then unstake (and therefore burn) `totalSupply - 1` leaving a total of 1 wei of safETH in circulation.\n\nIn earlier lines in `stake()` <https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L77-L81>, we see\n\n            uint256 totalSupply = totalSupply();\n            uint256 preDepositPrice; // Price of safETH in regards to ETH\n            if (totalSupply == 0)\n                preDepositPrice = 10 ** 18; // initializes with a price of 1\n            else preDepositPrice = (10 ** 18 * underlyingValue) / totalSupply;\n\nWith `totalSupply = 1`, we see that the above code block will execute the `else` code path, and that if `underlyingValue = 0`, then `preDepositPrice = 0`.\n\n`underlyingValue` is set in earlier lines: <https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L68-L75>\n\n            uint256 underlyingValue = 0;\n\n            // Getting underlying value in terms of ETH for each derivative\n            for (uint i = 0; i < derivativeCount; i++)\n                underlyingValue +=\n                    (derivatives[i].ethPerDerivative(derivatives[i].balance()) *\n                        derivatives[i].balance()) /\n                    10 ** 18;\n\nFor a simple case, assume there is 1 derivative with 100% weight. Let's use rETH for this example since the derivative can get its `ethPerDerivative` price from an AMM. In this case:\n\n*   Assume the `ethPerDerivative()` value has been manipulated in the underlying AMM pool such that 1 derivative ETH is worth less than 1 ETH. eg: 1 rETH = 9.99...9e17 ETH\n*   In this case, also assume that since there is 1 wei of safETH circulating, there should be 1 wei of ETH staked through the protocol, and therefore `derivatives[i].balance() = 1 wei`.\n\nThis case will result in `underlyingValue += (9.99...9e17 * 1) / 10 ** 18 = 0`.\n\nWe can see that it is therefore possible to cause a divide by 0 revert and malfunction of the `stake()` function.\n\n### Recommended Mitigation Steps\n\nAssuming the deployment process will set up at least 1 derivative with a weight, simply adding a `stake()` operation of 0.5 ETH as the first depositor as part of the deployment process avoids the case where safETH totalSupply drops to 1 wei.\n\nOtherwise, within `unstake()` it is also possible to require that `totalSupply` does not fall between 0 and `minimumSupply` where `minimumSupply` is, for example, the configured `minAmount`.\n\n**[toshiSat (Asymmetry) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1016#issuecomment-1499721095):**\n > Seems like a pretty big edge case and it would leave the contract with basically no funds which doesn't seem like a High severity to me.\n\n**[Picodes (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1016#issuecomment-1511014172):**\n > Indeed, the described scenario isn't of high severity although the finding is valid. Basically, the first or last SafETH user could force the owner to redeploy, so downgrading to Medium. \n\n**[Asymmetry commented](https://github.com/code-423n4/2023-05-asymmetry-mitigation-contest#out-of-scope):**\n> Out of scope for mitigation review. We will be manually holding safETH to prevent this, if not redeploy.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-03-asymmetry",
  "Code": [
    {
      "filename": "contracts/SafEth/SafEth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../interfaces/uniswap/ISwapRouter.sol\";\nimport \"../interfaces/lido/IWStETH.sol\";\nimport \"../interfaces/lido/IstETH.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./SafEthStorage.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/// @title Contract that mints/burns and provides owner functions for safETH\n/// @author Asymmetry Finance\ncontract SafEth is\n    Initializable,\n    ERC20Upgradeable,\n    OwnableUpgradeable,\n    SafEthStorage\n{\n    event ChangeMinAmount(uint256 indexed minAmount);\n    event ChangeMaxAmount(uint256 indexed maxAmount);\n    event StakingPaused(bool indexed paused);\n    event UnstakingPaused(bool indexed paused);\n    event SetMaxSlippage(uint256 indexed index, uint256 slippage);\n    event Staked(address indexed recipient, uint ethIn, uint safEthOut);\n    event Unstaked(address indexed recipient, uint ethOut, uint safEthIn);\n    event WeightChange(uint indexed index, uint weight);\n    event DerivativeAdded(\n        address indexed contractAddress,\n        uint weight,\n        uint index\n    );\n    event Rebalanced();\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Function to initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n        @param _tokenName - name of erc20\n        @param _tokenSymbol - symbol of erc20\n    */\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol\n    ) external initializer {\n        ERC20Upgradeable.__ERC20_init(_tokenName, _tokenSymbol);\n        _transferOwnership(msg.sender);\n        minAmount = 5 * 10 ** 17; // initializing with .5 ETH as minimum\n        maxAmount = 200 * 10 ** 18; // initializing with 200 ETH as maximum\n    }\n\n    /**\n        @notice - Stake your ETH into safETH\n        @dev - Deposits into each derivative based on its weight\n        @dev - Mints safEth in a redeemable value which equals to the correct percentage of the total staked value\n    */\n    function stake() external payable {\n        require(pauseStaking == false, \"staking is paused\");\n        require(msg.value >= minAmount, \"amount too low\");\n        require(msg.value <= maxAmount, \"amount too high\");\n\n        uint256 underlyingValue = 0;\n\n        // Getting underlying value in terms of ETH for each derivative\n        for (uint i = 0; i < derivativeCount; i++)\n            underlyingValue +=\n                (derivatives[i].ethPerDerivative(derivatives[i].balance()) *\n                    derivatives[i].balance()) /\n                10 ** 18;\n\n        uint256 totalSupply = totalSupply();\n        uint256 preDepositPrice; // Price of safETH in regards to ETH\n        if (totalSupply == 0)\n            preDepositPrice = 10 ** 18; // initializes with a price of 1\n        else preDepositPrice = (10 ** 18 * underlyingValue) / totalSupply;\n\n        uint256 totalStakeValueEth = 0; // total amount of derivatives worth of ETH in system\n        for (uint i = 0; i < derivativeCount; i++) {\n            uint256 weight = weights[i];\n            IDerivative derivative = derivatives[i];\n            if (weight == 0) continue;\n            uint256 ethAmount = (msg.value * weight) / totalWeight;\n\n            // This is slightly less than ethAmount because slippage\n            uint256 depositAmount = derivative.deposit{value: ethAmount}();\n            uint derivativeReceivedEthValue = (derivative.ethPerDerivative(\n                depositAmount\n            ) * depositAmount) / 10 ** 18;\n            totalStakeValueEth += derivativeReceivedEthValue;\n        }\n        // mintAmount represents a percentage of the total assets in the system\n        uint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice;\n        _mint(msg.sender, mintAmount);\n        emit Staked(msg.sender, msg.value, mintAmount);\n    }\n\n    /**\n        @notice - Unstake your safETH into ETH\n        @dev - unstakes a percentage of safEth based on its total value\n        @param _safEthAmount - amount of safETH to unstake into ETH\n    */\n    function unstake(uint256 _safEthAmount) external {\n        require(pauseUnstaking == false, \"unstaking is paused\");\n        uint256 safEthTotalSupply = totalSupply();\n        uint256 ethAmountBefore = address(this).balance;\n\n        for (uint256 i = 0; i < derivativeCount; i++) {\n            // withdraw a percentage of each asset based on the amount of safETH\n            uint256 derivativeAmount = (derivatives[i].balance() *\n                _safEthAmount) / safEthTotalSupply;\n            if (derivativeAmount == 0) continue; // if derivative empty ignore\n            derivatives[i].withdraw(derivativeAmount);\n        }\n        _burn(msg.sender, _safEthAmount);\n        uint256 ethAmountAfter = address(this).balance;\n        uint256 ethAmountToWithdraw = ethAmountAfter - ethAmountBefore;\n        // solhint-disable-next-line\n        (bool sent, ) = address(msg.sender).call{value: ethAmountToWithdraw}(\n            \"\"\n        );\n        require(sent, \"Failed to send Ether\");\n        emit Unstaked(msg.sender, ethAmountToWithdraw, _safEthAmount);\n    }\n\n    /**\n        @notice - Rebalance each derivative to resemble the weight set for it\n        @dev - Withdraws all derivative and re-deposit them to have the correct weights\n        @dev - Depending on the balance of the derivative this could cause bad slippage\n        @dev - If weights are updated then it will slowly change over time to the correct weight distribution\n        @dev - Probably not going to be used often, if at all\n    */\n    function rebalanceToWeights() external onlyOwner {\n        uint256 ethAmountBefore = address(this).balance;\n        for (uint i = 0; i < derivativeCount; i++) {\n            if (derivatives[i].balance() > 0)\n                derivatives[i].withdraw(derivatives[i].balance());\n        }\n        uint256 ethAmountAfter = address(this).balance;\n        uint256 ethAmountToRebalance = ethAmountAfter - ethAmountBefore;\n\n        for (uint i = 0; i < derivativeCount; i++) {\n            if (weights[i] == 0 || ethAmountToRebalance == 0) continue;\n            uint256 ethAmount = (ethAmountToRebalance * weights[i]) /\n                totalWeight;\n            // Price will change due to slippage\n            derivatives[i].deposit{value: ethAmount}();\n        }\n        emit Rebalanced();\n    }\n\n    /**\n        @notice - Adds new derivative to the index fund\n        @dev - Weights are only in regards to each other, total weight changes with this function\n        @dev - If you want exact weights either do the math off chain or reset all existing derivates to the weights you want\n        @dev - Weights are approximate as it will slowly change as people stake\n        @param _derivativeIndex - index of the derivative you want to update the weight\n        @param _weight - new weight for this derivative.\n    */\n    function adjustWeight(\n        uint256 _derivativeIndex,\n        uint256 _weight\n    ) external onlyOwner {\n        weights[_derivativeIndex] = _weight;\n        uint256 localTotalWeight = 0;\n        for (uint256 i = 0; i < derivativeCount; i++)\n            localTotalWeight += weights[i];\n        totalWeight = localTotalWeight;\n        emit WeightChange(_derivativeIndex, _weight);\n    }\n\n    /**\n        @notice - Adds new derivative to the index fund\n        @param _contractAddress - Address of the derivative contract launched by AF\n        @param _weight - new weight for this derivative. \n    */\n    function addDerivative(\n        address _contractAddress,\n        uint256 _weight\n    ) external onlyOwner {\n        derivatives[derivativeCount] = IDerivative(_contractAddress);\n        weights[derivativeCount] = _weight;\n        derivativeCount++;\n\n        uint256 localTotalWeight = 0;\n        for (uint256 i = 0; i < derivativeCount; i++)\n            localTotalWeight += weights[i];\n        totalWeight = localTotalWeight;\n        emit DerivativeAdded(_contractAddress, _weight, derivativeCount);\n    }\n\n    /**\n        @notice - Sets the max slippage for a certain derivative index\n        @param _derivativeIndex - index of the derivative you want to update the slippage\n        @param _slippage - new slippage amount in wei\n    */\n    function setMaxSlippage(\n        uint _derivativeIndex,\n        uint _slippage\n    ) external onlyOwner {\n        derivatives[_derivativeIndex].setMaxSlippage(_slippage);\n        emit SetMaxSlippage(_derivativeIndex, _slippage);\n    }\n\n    /**\n        @notice - Sets the minimum amount a user is allowed to stake\n        @param _minAmount - amount to set as minimum stake value\n    */\n    function setMinAmount(uint256 _minAmount) external onlyOwner {\n        minAmount = _minAmount;\n        emit ChangeMinAmount(minAmount);\n    }\n\n    /**\n        @notice - Owner only function that sets the maximum amount a user is allowed to stake\n        @param _maxAmount - amount to set as maximum stake value\n    */\n    function setMaxAmount(uint256 _maxAmount) external onlyOwner {\n        maxAmount = _maxAmount;\n        emit ChangeMaxAmount(maxAmount);\n    }\n\n    /**\n        @notice - Owner only function that Enables/Disables the stake function\n        @param _pause - true disables staking / false enables staking\n    */\n    function setPauseStaking(bool _pause) external onlyOwner {\n        pauseStaking = _pause;\n        emit StakingPaused(pauseStaking);\n    }\n\n    /**\n        @notice - Owner only function that enables/disables the unstake function\n        @param _pause - true disables unstaking / false enables unstaking\n    */\n    function setPauseUnstaking(bool _pause) external onlyOwner {\n        pauseUnstaking = _pause;\n        emit UnstakingPaused(pauseUnstaking);\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/SafEth/SafEth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../interfaces/uniswap/ISwapRouter.sol\";\nimport \"../interfaces/lido/IWStETH.sol\";\nimport \"../interfaces/lido/IstETH.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./SafEthStorage.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/// @title Contract that mints/burns and provides owner functions for safETH\n/// @author Asymmetry Finance\ncontract SafEth is\n    Initializable,\n    ERC20Upgradeable,\n    OwnableUpgradeable,\n    SafEthStorage\n{\n    event ChangeMinAmount(uint256 indexed minAmount);\n    event ChangeMaxAmount(uint256 indexed maxAmount);\n    event StakingPaused(bool indexed paused);\n    event UnstakingPaused(bool indexed paused);\n    event SetMaxSlippage(uint256 indexed index, uint256 slippage);\n    event Staked(address indexed recipient, uint ethIn, uint safEthOut);\n    event Unstaked(address indexed recipient, uint ethOut, uint safEthIn);\n    event WeightChange(uint indexed index, uint weight);\n    event DerivativeAdded(\n        address indexed contractAddress,\n        uint weight,\n        uint index\n    );\n    event Rebalanced();\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Function to initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n        @param _tokenName - name of erc20\n        @param _tokenSymbol - symbol of erc20\n    */\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol\n    ) external initializer {\n        ERC20Upgradeable.__ERC20_init(_tokenName, _tokenSymbol);\n        _transferOwnership(msg.sender);\n        minAmount = 5 * 10 ** 17; // initializing with .5 ETH as minimum\n        maxAmount = 200 * 10 ** 18; // initializing with 200 ETH as maximum\n    }\n\n    /**\n        @notice - Stake your ETH into safETH\n        @dev - Deposits into each derivative based on its weight\n        @dev - Mints safEth in a redeemable value which equals to the correct percentage of the total staked value\n    */\n    function stake() external payable {\n        require(pauseStaking == false, \"staking is paused\");\n        require(msg.value >= minAmount, \"amount too low\");\n        require(msg.value <= maxAmount, \"amount too high\");\n\n        uint256 underlyingValue = 0;\n\n        // Getting underlying value in terms of ETH for each derivative\n        for (uint i = 0; i < derivativeCount; i++)\n            underlyingValue +=\n                (derivatives[i].ethPerDerivative(derivatives[i].balance()) *\n                    derivatives[i].balance()) /\n                10 ** 18;\n\n        uint256 totalSupply = totalSupply();\n        uint256 preDepositPrice; // Price of safETH in regards to ETH\n        if (totalSupply == 0)\n            preDepositPrice = 10 ** 18; // initializes with a price of 1\n        else preDepositPrice = (10 ** 18 * underlyingValue) / totalSupply;\n\n        uint256 totalStakeValueEth = 0; // total amount of derivatives worth of ETH in system\n        for (uint i = 0; i < derivativeCount; i++) {\n            uint256 weight = weights[i];\n            IDerivative derivative = derivatives[i];\n            if (weight == 0) continue;\n            uint256 ethAmount = (msg.value * weight) / totalWeight;\n\n            // This is slightly less than ethAmount because slippage\n            uint256 depositAmount = derivative.deposit{value: ethAmount}();\n            uint derivativeReceivedEthValue = (derivative.ethPerDerivative(\n                depositAmount\n            ) * depositAmount) / 10 ** 18;\n            totalStakeValueEth += derivativeReceivedEthValue;\n        }\n        // mintAmount represents a percentage of the total assets in the system\n        uint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice;\n        _mint(msg.sender, mintAmount);\n        emit Staked(msg.sender, msg.value, mintAmount);\n    }\n\n    /**\n        @notice - Unstake your safETH into ETH\n        @dev - unstakes a percentage of safEth based on its total value\n        @param _safEthAmount - amount of safETH to unstake into ETH\n    */\n    function unstake(uint256 _safEthAmount) external {\n        require(pauseUnstaking == false, \"unstaking is paused\");\n        uint256 safEthTotalSupply = totalSupply();\n        uint256 ethAmountBefore = address(this).balance;\n\n        for (uint256 i = 0; i < derivativeCount; i++) {\n            // withdraw a percentage of each asset based on the amount of safETH\n            uint256 derivativeAmount = (derivatives[i].balance() *\n                _safEthAmount) / safEthTotalSupply;\n            if (derivativeAmount == 0) continue; // if derivative empty ignore\n            derivatives[i].withdraw(derivativeAmount);\n        }\n        _burn(msg.sender, _safEthAmount);\n        uint256 ethAmountAfter = address(this).balance;\n        uint256 ethAmountToWithdraw = ethAmountAfter - ethAmountBefore;\n        // solhint-disable-next-line\n        (bool sent, ) = address(msg.sender).call{value: ethAmountToWithdraw}(\n            \"\"\n        );\n        require(sent, \"Failed to send Ether\");\n        emit Unstaked(msg.sender, ethAmountToWithdraw, _safEthAmount);\n    }\n\n    /**\n        @notice - Rebalance each derivative to resemble the weight set for it\n        @dev - Withdraws all derivative and re-deposit them to have the correct weights\n        @dev - Depending on the balance of the derivative this could cause bad slippage\n        @dev - If weights are updated then it will slowly change over time to the correct weight distribution\n        @dev - Probably not going to be used often, if at all\n    */\n    function rebalanceToWeights() external onlyOwner {\n        uint256 ethAmountBefore = address(this).balance;\n        for (uint i = 0; i < derivativeCount; i++) {\n            if (derivatives[i].balance() > 0)\n                derivatives[i].withdraw(derivatives[i].balance());\n        }\n        uint256 ethAmountAfter = address(this).balance;\n        uint256 ethAmountToRebalance = ethAmountAfter - ethAmountBefore;\n\n        for (uint i = 0; i < derivativeCount; i++) {\n            if (weights[i] == 0 || ethAmountToRebalance == 0) continue;\n            uint256 ethAmount = (ethAmountToRebalance * weights[i]) /\n                totalWeight;\n            // Price will change due to slippage\n            derivatives[i].deposit{value: ethAmount}();\n        }\n        emit Rebalanced();\n    }\n\n    /**\n        @notice - Adds new derivative to the index fund\n        @dev - Weights are only in regards to each other, total weight changes with this function\n        @dev - If you want exact weights either do the math off chain or reset all existing derivates to the weights you want\n        @dev - Weights are approximate as it will slowly change as people stake\n        @param _derivativeIndex - index of the derivative you want to update the weight\n        @param _weight - new weight for this derivative.\n    */\n    function adjustWeight(\n        uint256 _derivativeIndex,\n        uint256 _weight\n    ) external onlyOwner {\n        weights[_derivativeIndex] = _weight;\n        uint256 localTotalWeight = 0;\n        for (uint256 i = 0; i < derivativeCount; i++)\n            localTotalWeight += weights[i];\n        totalWeight = localTotalWeight;\n        emit WeightChange(_derivativeIndex, _weight);\n    }\n\n    /**\n        @notice - Adds new derivative to the index fund\n        @param _contractAddress - Address of the derivative contract launched by AF\n        @param _weight - new weight for this derivative. \n    */\n    function addDerivative(\n        address _contractAddress,\n        uint256 _weight\n    ) external onlyOwner {\n        derivatives[derivativeCount] = IDerivative(_contractAddress);\n        weights[derivativeCount] = _weight;\n        derivativeCount++;\n\n        uint256 localTotalWeight = 0;\n        for (uint256 i = 0; i < derivativeCount; i++)\n            localTotalWeight += weights[i];\n        totalWeight = localTotalWeight;\n        emit DerivativeAdded(_contractAddress, _weight, derivativeCount);\n    }\n\n    /**\n        @notice - Sets the max slippage for a certain derivative index\n        @param _derivativeIndex - index of the derivative you want to update the slippage\n        @param _slippage - new slippage amount in wei\n    */\n    function setMaxSlippage(\n        uint _derivativeIndex,\n        uint _slippage\n    ) external onlyOwner {\n        derivatives[_derivativeIndex].setMaxSlippage(_slippage);\n        emit SetMaxSlippage(_derivativeIndex, _slippage);\n    }\n\n    /**\n        @notice - Sets the minimum amount a user is allowed to stake\n        @param _minAmount - amount to set as minimum stake value\n    */\n    function setMinAmount(uint256 _minAmount) external onlyOwner {\n        minAmount = _minAmount;\n        emit ChangeMinAmount(minAmount);\n    }\n\n    /**\n        @notice - Owner only function that sets the maximum amount a user is allowed to stake\n        @param _maxAmount - amount to set as maximum stake value\n    */\n    function setMaxAmount(uint256 _maxAmount) external onlyOwner {\n        maxAmount = _maxAmount;\n        emit ChangeMaxAmount(maxAmount);\n    }\n\n    /**\n        @notice - Owner only function that Enables/Disables the stake function\n        @param _pause - true disables staking / false enables staking\n    */\n    function setPauseStaking(bool _pause) external onlyOwner {\n        pauseStaking = _pause;\n        emit StakingPaused(pauseStaking);\n    }\n\n    /**\n        @notice - Owner only function that enables/disables the unstake function\n        @param _pause - true disables unstaking / false enables unstaking\n    */\n    function setPauseUnstaking(bool _pause) external onlyOwner {\n        pauseUnstaking = _pause;\n        emit UnstakingPaused(pauseUnstaking);\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/SafEth/SafEth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../interfaces/uniswap/ISwapRouter.sol\";\nimport \"../interfaces/lido/IWStETH.sol\";\nimport \"../interfaces/lido/IstETH.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./SafEthStorage.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/// @title Contract that mints/burns and provides owner functions for safETH\n/// @author Asymmetry Finance\ncontract SafEth is\n    Initializable,\n    ERC20Upgradeable,\n    OwnableUpgradeable,\n    SafEthStorage\n{\n    event ChangeMinAmount(uint256 indexed minAmount);\n    event ChangeMaxAmount(uint256 indexed maxAmount);\n    event StakingPaused(bool indexed paused);\n    event UnstakingPaused(bool indexed paused);\n    event SetMaxSlippage(uint256 indexed index, uint256 slippage);\n    event Staked(address indexed recipient, uint ethIn, uint safEthOut);\n    event Unstaked(address indexed recipient, uint ethOut, uint safEthIn);\n    event WeightChange(uint indexed index, uint weight);\n    event DerivativeAdded(\n        address indexed contractAddress,\n        uint weight,\n        uint index\n    );\n    event Rebalanced();\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Function to initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n        @param _tokenName - name of erc20\n        @param _tokenSymbol - symbol of erc20\n    */\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol\n    ) external initializer {\n        ERC20Upgradeable.__ERC20_init(_tokenName, _tokenSymbol);\n        _transferOwnership(msg.sender);\n        minAmount = 5 * 10 ** 17; // initializing with .5 ETH as minimum\n        maxAmount = 200 * 10 ** 18; // initializing with 200 ETH as maximum\n    }\n\n    /**\n        @notice - Stake your ETH into safETH\n        @dev - Deposits into each derivative based on its weight\n        @dev - Mints safEth in a redeemable value which equals to the correct percentage of the total staked value\n    */\n    function stake() external payable {\n        require(pauseStaking == false, \"staking is paused\");\n        require(msg.value >= minAmount, \"amount too low\");\n        require(msg.value <= maxAmount, \"amount too high\");\n\n        uint256 underlyingValue = 0;\n\n        // Getting underlying value in terms of ETH for each derivative\n        for (uint i = 0; i < derivativeCount; i++)\n            underlyingValue +=\n                (derivatives[i].ethPerDerivative(derivatives[i].balance()) *\n                    derivatives[i].balance()) /\n                10 ** 18;\n\n        uint256 totalSupply = totalSupply();\n        uint256 preDepositPrice; // Price of safETH in regards to ETH\n        if (totalSupply == 0)\n            preDepositPrice = 10 ** 18; // initializes with a price of 1\n        else preDepositPrice = (10 ** 18 * underlyingValue) / totalSupply;\n\n        uint256 totalStakeValueEth = 0; // total amount of derivatives worth of ETH in system\n        for (uint i = 0; i < derivativeCount; i++) {\n            uint256 weight = weights[i];\n            IDerivative derivative = derivatives[i];\n            if (weight == 0) continue;\n            uint256 ethAmount = (msg.value * weight) / totalWeight;\n\n            // This is slightly less than ethAmount because slippage\n            uint256 depositAmount = derivative.deposit{value: ethAmount}();\n            uint derivativeReceivedEthValue = (derivative.ethPerDerivative(\n                depositAmount\n            ) * depositAmount) / 10 ** 18;\n            totalStakeValueEth += derivativeReceivedEthValue;\n        }\n        // mintAmount represents a percentage of the total assets in the system\n        uint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice;\n        _mint(msg.sender, mintAmount);\n        emit Staked(msg.sender, msg.value, mintAmount);\n    }\n\n    /**\n        @notice - Unstake your safETH into ETH\n        @dev - unstakes a percentage of safEth based on its total value\n        @param _safEthAmount - amount of safETH to unstake into ETH\n    */\n    function unstake(uint256 _safEthAmount) external {\n        require(pauseUnstaking == false, \"unstaking is paused\");\n        uint256 safEthTotalSupply = totalSupply();\n        uint256 ethAmountBefore = address(this).balance;\n\n        for (uint256 i = 0; i < derivativeCount; i++) {\n            // withdraw a percentage of each asset based on the amount of safETH\n            uint256 derivativeAmount = (derivatives[i].balance() *\n                _safEthAmount) / safEthTotalSupply;\n            if (derivativeAmount == 0) continue; // if derivative empty ignore\n            derivatives[i].withdraw(derivativeAmount);\n        }\n        _burn(msg.sender, _safEthAmount);\n        uint256 ethAmountAfter = address(this).balance;\n        uint256 ethAmountToWithdraw = ethAmountAfter - ethAmountBefore;\n        // solhint-disable-next-line\n        (bool sent, ) = address(msg.sender).call{value: ethAmountToWithdraw}(\n            \"\"\n        );\n        require(sent, \"Failed to send Ether\");\n        emit Unstaked(msg.sender, ethAmountToWithdraw, _safEthAmount);\n    }\n\n    /**\n        @notice - Rebalance each derivative to resemble the weight set for it\n        @dev - Withdraws all derivative and re-deposit them to have the correct weights\n        @dev - Depending on the balance of the derivative this could cause bad slippage\n        @dev - If weights are updated then it will slowly change over time to the correct weight distribution\n        @dev - Probably not going to be used often, if at all\n    */\n    function rebalanceToWeights() external onlyOwner {\n        uint256 ethAmountBefore = address(this).balance;\n        for (uint i = 0; i < derivativeCount; i++) {\n            if (derivatives[i].balance() > 0)\n                derivatives[i].withdraw(derivatives[i].balance());\n        }\n        uint256 ethAmountAfter = address(this).balance;\n        uint256 ethAmountToRebalance = ethAmountAfter - ethAmountBefore;\n\n        for (uint i = 0; i < derivativeCount; i++) {\n            if (weights[i] == 0 || ethAmountToRebalance == 0) continue;\n            uint256 ethAmount = (ethAmountToRebalance * weights[i]) /\n                totalWeight;\n            // Price will change due to slippage\n            derivatives[i].deposit{value: ethAmount}();\n        }\n        emit Rebalanced();\n    }\n\n    /**\n        @notice - Adds new derivative to the index fund\n        @dev - Weights are only in regards to each other, total weight changes with this function\n        @dev - If you want exact weights either do the math off chain or reset all existing derivates to the weights you want\n        @dev - Weights are approximate as it will slowly change as people stake\n        @param _derivativeIndex - index of the derivative you want to update the weight\n        @param _weight - new weight for this derivative.\n    */\n    function adjustWeight(\n        uint256 _derivativeIndex,\n        uint256 _weight\n    ) external onlyOwner {\n        weights[_derivativeIndex] = _weight;\n        uint256 localTotalWeight = 0;\n        for (uint256 i = 0; i < derivativeCount; i++)\n            localTotalWeight += weights[i];\n        totalWeight = localTotalWeight;\n        emit WeightChange(_derivativeIndex, _weight);\n    }\n\n    /**\n        @notice - Adds new derivative to the index fund\n        @param _contractAddress - Address of the derivative contract launched by AF\n        @param _weight - new weight for this derivative. \n    */\n    function addDerivative(\n        address _contractAddress,\n        uint256 _weight\n    ) external onlyOwner {\n        derivatives[derivativeCount] = IDerivative(_contractAddress);\n        weights[derivativeCount] = _weight;\n        derivativeCount++;\n\n        uint256 localTotalWeight = 0;\n        for (uint256 i = 0; i < derivativeCount; i++)\n            localTotalWeight += weights[i];\n        totalWeight = localTotalWeight;\n        emit DerivativeAdded(_contractAddress, _weight, derivativeCount);\n    }\n\n    /**\n        @notice - Sets the max slippage for a certain derivative index\n        @param _derivativeIndex - index of the derivative you want to update the slippage\n        @param _slippage - new slippage amount in wei\n    */\n    function setMaxSlippage(\n        uint _derivativeIndex,\n        uint _slippage\n    ) external onlyOwner {\n        derivatives[_derivativeIndex].setMaxSlippage(_slippage);\n        emit SetMaxSlippage(_derivativeIndex, _slippage);\n    }\n\n    /**\n        @notice - Sets the minimum amount a user is allowed to stake\n        @param _minAmount - amount to set as minimum stake value\n    */\n    function setMinAmount(uint256 _minAmount) external onlyOwner {\n        minAmount = _minAmount;\n        emit ChangeMinAmount(minAmount);\n    }\n\n    /**\n        @notice - Owner only function that sets the maximum amount a user is allowed to stake\n        @param _maxAmount - amount to set as maximum stake value\n    */\n    function setMaxAmount(uint256 _maxAmount) external onlyOwner {\n        maxAmount = _maxAmount;\n        emit ChangeMaxAmount(maxAmount);\n    }\n\n    /**\n        @notice - Owner only function that Enables/Disables the stake function\n        @param _pause - true disables staking / false enables staking\n    */\n    function setPauseStaking(bool _pause) external onlyOwner {\n        pauseStaking = _pause;\n        emit StakingPaused(pauseStaking);\n    }\n\n    /**\n        @notice - Owner only function that enables/disables the unstake function\n        @param _pause - true disables unstaking / false enables unstaking\n    */\n    function setPauseUnstaking(bool _pause) external onlyOwner {\n        pauseUnstaking = _pause;\n        emit UnstakingPaused(pauseUnstaking);\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/SafEth/SafEth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../interfaces/uniswap/ISwapRouter.sol\";\nimport \"../interfaces/lido/IWStETH.sol\";\nimport \"../interfaces/lido/IstETH.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./SafEthStorage.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/// @title Contract that mints/burns and provides owner functions for safETH\n/// @author Asymmetry Finance\ncontract SafEth is\n    Initializable,\n    ERC20Upgradeable,\n    OwnableUpgradeable,\n    SafEthStorage\n{\n    event ChangeMinAmount(uint256 indexed minAmount);\n    event ChangeMaxAmount(uint256 indexed maxAmount);\n    event StakingPaused(bool indexed paused);\n    event UnstakingPaused(bool indexed paused);\n    event SetMaxSlippage(uint256 indexed index, uint256 slippage);\n    event Staked(address indexed recipient, uint ethIn, uint safEthOut);\n    event Unstaked(address indexed recipient, uint ethOut, uint safEthIn);\n    event WeightChange(uint indexed index, uint weight);\n    event DerivativeAdded(\n        address indexed contractAddress,\n        uint weight,\n        uint index\n    );\n    event Rebalanced();\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Function to initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n        @param _tokenName - name of erc20\n        @param _tokenSymbol - symbol of erc20\n    */\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol\n    ) external initializer {\n        ERC20Upgradeable.__ERC20_init(_tokenName, _tokenSymbol);\n        _transferOwnership(msg.sender);\n        minAmount = 5 * 10 ** 17; // initializing with .5 ETH as minimum\n        maxAmount = 200 * 10 ** 18; // initializing with 200 ETH as maximum\n    }\n\n    /**\n        @notice - Stake your ETH into safETH\n        @dev - Deposits into each derivative based on its weight\n        @dev - Mints safEth in a redeemable value which equals to the correct percentage of the total staked value\n    */"
    }
  ]
}