{
  "Title": "M-11: Delayed Compound and Beta interest accrual reduces gamer rewards and affects funds distribution to vaults",
  "Content": "# Issue M-11: Delayed Compound and Beta interest accrual reduces gamer rewards and affects funds distribution to vaults \n\nSource: https://github.com/sherlock-audit/2023-01-derby-judging/issues/317 \n\n## Found by \nJeiwan, KingNFT, hyh, psy4n0n\n\n## Summary\nDuring rebalancing, Compound and Beta interest is not accrued until after gamer rewards are calculated leading to the rewards being calculated on the underlying amounts that are smaller than the real amounts. As a result, gamers receive reduced rewards. Also, since interest accrual doesn't happen when vaults push underlying amounts to `XChainController`, the underlying amounts to be distributed among vaults will be smaller that real amounts.\n## Vulnerability Detail\nThe Derby protocol allows users to deposit funds to third-party protocols to earn passive yield. Two of such protocols are Compound and Beta: funds deposited to Compound and Beta earn interest collected from borrowers who borrow the funds. Due to accruing of interest, the exchange rate of cTokens and BTokens increases over time: for example, 1 cToken can be exchange for 1.01 underlying token after some time.\n\nDuring rebalancing, Derby vaults report their underlying token balances (the amount of funds deposited in third-party protocols) to `XChainController`, which re-allocates and re-distributes them according to the allocations set by gamers. However, when the underlying balances are calculated, interest is not accrued on Compound and Beta:\n1. [setTotalUnderlying](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/MainVault.sol#L252) calls [balanceUnderlying](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Vault.sol#L344) on each of the supported protocol;\n1. [CompoundProvider.balanceUnderlying](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/CompoundProvider.sol#L90) multiplies contract's cToken balance by the exchange rate of the cToken;\n1. [CompoundProvider.exchangeRate](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/CompoundProvider.sol#L127) calls [ICToken.exchangeRateStored](https://github.com/compound-finance/compound-protocol/blob/master/contracts/CToken.sol#L279-L286), which doesn't accrue interest and returns cached exchange rate:\n> This function does not accrue interest before calculating the exchange rate\n1. Likewise, [BetaProvider.balanceUnderlying](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/BetaProvider.sol#L82) and [BetaProvider.calcShares](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/BetaProvider.sol#L99) read `IBeta.totalLoanable` and `IBeta.totalLoan` to convert BTokens to underlying tokens, however the interest is not accrued in `totalLoan` beforehand (as can be seen in the code of `BToken`, [accruing interest increases `totalLoan`](https://github.com/beta-finance/beta/blob/master/contracts/BToken.sol#L92-L93)).\n\nThus, the interest accrued by the funds deposited to Compound and Beta since the previous rebalancing won't be counted in the new rebalancing, and the underlying balance reported by the vault will be lower than the real balance.\n\nInterest is accrued only at the end of rebalancing, in the [Vault.rebalance](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Vault.sol#L135) function: first [deposit](https://github.com/compound-finance/compound-protocol/blob/master/contracts/CToken.sol#L387) or [withdrawal](https://github.com/compound-finance/compound-protocol/blob/master/contracts/CToken.sol#L457) to/from Compound and Beta will accrue interest. However, this will happen after gamer rewards have been calculated:\n1. gamer rewards are calculated in [storePriceAndRewards](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Vault.sol#L186), before funds are deposited/withdrawn to Compound or Beta;\n1. gamer rewards are calculated based on the underlying balance calculated in [calcUnderlyingIncBalance](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Vault.sol#L158), which reads the value of `savedTotalUnderlying`â€“it was set in the beginning of rebalancing, and interest wasn't accrued before it was set.\n\nThus, gamer rewards will always lag behind actual underlying balances of Compound and Beta, and gamers will always earn reduced rewards.\n## Impact\nGamer receive reduced rewards due to delayed accruing of interest in Compound and Beta.\n## Code Snippet\n1. `setTotalUnderlying` is called when vaults report their balances:\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/MainVault.sol#L252\n1. `setTotalUnderlying` calls `balanceUnderlying`, which calls `balanceUnderlying` on each protocol provider:\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Vault.sol#L344-L361\n1. `CompoundProvider.balanceUnderlying` calls `exchangeRate` to get the exchange rate of the cToken:\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/CompoundProvider.sol#L96\n1. The exchange rate is read via the `exchangeRateStored` function, which returned cached rate: the interest earned since the previous accrual is not counted:\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/CompoundProvider.sol#L127\nhttps://github.com/compound-finance/compound-protocol/blob/master/contracts/CToken.sol#L284-L293\n1. `BetaProvider.balanceUnderlying` and `BetaProvider.calcShares` read `IBeta.totalLoan` to convert BTokens to underlying tokens:\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/BetaProvider.sol#L89\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/BetaProvider.sol#L102\n1. In `BToken`, `totalLoan` is increased by accumulated interest when interest is accrued:\nhttps://github.com/beta-finance/beta/blob/master/contracts/BToken.sol#L92-L93\n## Tool used\nManual Review\n## Recommendation\nIn `CompoundProvider.exchangeRate`, consider calling [exchangeRateCurrent](https://github.com/compound-finance/compound-protocol/blob/master/contracts/CToken.sol#L274) instead of `exchangeRateStored`.\nIn `BetaProvider.balanceUnderlying` and `BetaProvider.calcShares` consider calling `IBeta.accrue` before calling `IBeta.totalLoan`.\n\n\n\n## Discussion\n\n**sjoerdsommen**\n\nThis does only lead to a slightly lower yield. If we would fix it, this would also lead to a more expensive call. We would have to investigate this. \n\n**hrishibhat**\n\nConsidering this issue a valid medium as there is a stale exchangeRateStored resulting in reduced rewards for depositors and affects allocator rewards. \n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/13",
  "Code": [
    {
      "filename": "derby-yield-optimiser/contracts/MainVault.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"./Vault.sol\";\n\nimport \"./Interfaces/IXProvider.sol\";\n\ncontract MainVault is Vault, VaultToken {\n  using SafeERC20 for IERC20;\n\n  struct UserInfo {\n    // amount in vaultCurrency the vault owes to the user\n    uint256 withdrawalAllowance;\n    // rebalancing period the withdrawal request is made\n    uint256 withdrawalRequestPeriod;\n    // amount in vaultCurrency the vault owes to the user\n    uint256 rewardAllowance;\n    // rebalancing period the reward request is made\n    uint256 rewardRequestPeriod;\n  }\n\n  address public derbyToken;\n  address public game;\n  address public xProvider;\n\n  bool public vaultOff;\n  // True when rewards should be swapped to derby tokens\n  bool public swapRewards;\n\n  // total amount of withdrawal requests for the vault to pull extra during a cross-chain rebalance, will be upped when a user makes a withdrawalRequest\n  // during a cross-chain rebalance the vault will pull extra funds by the amount of totalWithdrawalRequests and the totalWithdrawalRequests will turn into actual reservedFunds\n  uint256 internal totalWithdrawalRequests;\n  uint256 public exchangeRate;\n  uint32 public homeChain;\n  uint256 public amountToSendXChain;\n  uint256 public governanceFee; // Basis points\n  uint256 public maxDivergenceWithdraws;\n\n  string internal allowanceError = \"!Allowance\";\n\n  // (userAddress => userInfo struct)\n  mapping(address => UserInfo) internal userInfo;\n\n  // training\n  bool private training;\n  uint256 private maxTrainingDeposit;\n  mapping(address => bool) private whitelist;\n\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals,\n    uint256 _vaultNumber,\n    address _dao,\n    address _game,\n    address _controller,\n    address _vaultCurrency,\n    uint256 _uScale\n  )\n    VaultToken(_name, _symbol, _decimals)\n    Vault(_vaultNumber, _dao, _controller, _vaultCurrency, _uScale)\n  {\n    exchangeRate = _uScale;\n    game = _game;\n    governanceFee = 0;\n    maxDivergenceWithdraws = 1_000_000;\n  }\n\n  modifier onlyXProvider() {\n    require(msg.sender == xProvider, \"only xProvider\");\n    _;\n  }\n\n  modifier onlyWhenVaultIsOn() {\n    require(state == State.Idle, \"Rebalancing\");\n    require(!vaultOff, \"Vault is off\");\n    _;\n  }\n\n  modifier onlyWhenIdle() {\n    require(state == State.Idle, \"Rebalancing\");\n    _;\n  }\n\n  modifier onlyGame() {\n    require(msg.sender == game, \"only game\");\n    _;\n  }\n\n  event PushTotalUnderlying(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    uint256 _underlying,\n    uint256 _totalSupply,\n    uint256 _withdrawalRequests\n  );\n  event RebalanceXChain(uint256 _vaultNumber, uint256 _amount, address _asset);\n  event PushedRewardsToGame(uint256 _vaultNumber, uint32 _chain, int256[] _rewards);\n\n  /// @notice Deposit in Vault\n  /// @dev Deposit VaultCurrency to Vault and mint LP tokens\n  /// @param _amount Amount to deposit\n  /// @param _receiver Receiving adress for the tokens\n  /// @return shares Tokens received by buyer\n  function deposit(\n    uint256 _amount,\n    address _receiver\n  ) external nonReentrant onlyWhenVaultIsOn returns (uint256 shares) {\n    if (training) {\n      require(whitelist[msg.sender]);\n      uint256 balanceSender = (balanceOf(msg.sender) * exchangeRate) / (10 ** decimals());\n      require(_amount + balanceSender <= maxTrainingDeposit);\n    }\n\n    uint256 balanceBefore = getVaultBalance() - reservedFunds;\n    vaultCurrency.safeTransferFrom(msg.sender, address(this), _amount);\n    uint256 balanceAfter = getVaultBalance() - reservedFunds;\n\n    uint256 amount = balanceAfter - balanceBefore;\n    shares = (amount * (10 ** decimals())) / exchangeRate;\n\n    _mint(_receiver, shares);\n  }\n\n  /// @notice Withdraw from Vault\n  /// @dev Withdraw VaultCurrency from Vault and burn LP tokens\n  /// @param _amount Amount to withdraw in LP tokens\n  /// @param _receiver Receiving adress for the vaultcurrency\n  /// @return value Amount received by seller in vaultCurrency\n  function withdraw(\n    uint256 _amount,\n    address _receiver,\n    address _owner\n  ) external nonReentrant onlyWhenVaultIsOn returns (uint256 value) {\n    value = (_amount * exchangeRate) / (10 ** decimals());\n\n    require(value > 0, \"!value\");\n\n    require(getVaultBalance() - reservedFunds >= value, \"!funds\");\n\n    _burn(msg.sender, _amount);\n    transferFunds(_receiver, value);\n  }\n\n  /// @notice Withdrawal request for when the vault doesnt have enough funds available\n  /// @dev Will give the user allowance for his funds and pulls the extra funds at the next rebalance\n  /// @param _amount Amount to withdraw in LP token\n  function withdrawalRequest(\n    uint256 _amount\n  ) external nonReentrant onlyWhenVaultIsOn returns (uint256 value) {\n    UserInfo storage user = userInfo[msg.sender];\n    require(user.withdrawalRequestPeriod == 0, \"Already a request\");\n\n    value = (_amount * exchangeRate) / (10 ** decimals());\n\n    _burn(msg.sender, _amount);\n\n    user.withdrawalAllowance = value;\n    user.withdrawalRequestPeriod = rebalancingPeriod;\n    totalWithdrawalRequests += value;\n  }\n\n  /// @notice Withdraw the allowance the user requested on the last rebalancing period\n  /// @dev Will send the user funds and reset the allowance\n  function withdrawAllowance() external nonReentrant onlyWhenIdle returns (uint256 value) {\n    UserInfo storage user = userInfo[msg.sender];\n    require(user.withdrawalAllowance > 0, allowanceError);\n    require(rebalancingPeriod > user.withdrawalRequestPeriod, \"Funds not arrived\");\n\n    value = user.withdrawalAllowance;\n    value = checkForBalance(value);\n\n    reservedFunds -= value;\n    delete user.withdrawalAllowance;\n    delete user.withdrawalRequestPeriod;\n\n    transferFunds(msg.sender, value);\n  }\n\n  /// @notice Substract governance fee from value\n  /// @param _receiver Receiving adress for the vaultcurrency\n  /// @param _value Amount received by seller in vaultCurrency\n  function transferFunds(address _receiver, uint256 _value) internal {\n    uint256 govFee = (_value * governanceFee) / 10_000;\n\n    vaultCurrency.safeTransfer(getDao(), govFee);\n    vaultCurrency.safeTransfer(_receiver, _value - govFee);\n  }\n\n  /// @notice Function for the game to set a withdrawalRequest for the rewards of the game user\n  /// @param _value Amount to set a request in vaultCurrency\n  /// @param _user Address of the user\n  function redeemRewardsGame(\n    uint256 _value,\n    address _user\n  ) external onlyGame nonReentrant onlyWhenVaultIsOn {\n    UserInfo storage user = userInfo[_user];\n    require(user.rewardAllowance == 0, allowanceError);\n\n    user.rewardAllowance = _value;\n    user.rewardRequestPeriod = rebalancingPeriod;\n    totalWithdrawalRequests += _value;\n  }\n\n  /// @notice Withdraw the reward allowance set by the game with redeemRewardsGame\n  /// @dev Will swap vaultCurrency to Derby tokens, send the user funds and reset the allowance\n  function withdrawRewards() external nonReentrant onlyWhenIdle returns (uint256 value) {\n    UserInfo storage user = userInfo[msg.sender];\n    require(user.rewardAllowance > 0, allowanceError);\n    require(rebalancingPeriod > user.rewardRequestPeriod, \"!Funds\");\n\n    value = user.rewardAllowance;\n    value = checkForBalance(value);\n\n    reservedFunds -= value;\n    delete user.rewardAllowance;\n    delete user.rewardRequestPeriod;\n\n    if (swapRewards) {\n      uint256 tokensReceived = Swap.swapTokensMulti(\n        Swap.SwapInOut(value, address(vaultCurrency), derbyToken),\n        controller.getUniswapParams(),\n        true\n      );\n      IERC20(derbyToken).safeTransfer(msg.sender, tokensReceived);\n    } else {\n      vaultCurrency.safeTransfer(msg.sender, value);\n    }\n  }\n\n  /// @notice Sometimes when swapping stable coins the vault will get a fraction of a coin less then expected\n  /// @notice This is to make sure the vault doesnt get stuck\n  /// @notice Value will be set to the vaultBalance\n  /// @notice When divergence is greater then maxDivergenceWithdraws it will revert\n  /// @param _value Value the user wants to withdraw\n  /// @return value Value - divergence\n  function checkForBalance(uint256 _value) internal view returns (uint256) {\n    if (_value > getVaultBalance()) {\n      uint256 oldValue = _value;\n      _value = getVaultBalance();\n      require(oldValue - _value <= maxDivergenceWithdraws, \"Max divergence\");\n    }\n    return _value;\n  }\n\n  /// @notice Step 2 trigger; Vaults push totalUnderlying, totalSupply and totalWithdrawalRequests to xChainController\n  /// @notice Pushes totalUnderlying, totalSupply and totalWithdrawalRequests of the vault for this chainId to xController\n  function pushTotalUnderlyingToController() external payable onlyWhenIdle {\n    require(rebalanceNeeded(), \"!rebalance needed\");\n\n    setTotalUnderlying();\n    uint256 underlying = savedTotalUnderlying + getVaultBalance() - reservedFunds;\n\n    IXProvider(xProvider).pushTotalUnderlying{value: msg.value}(\n      vaultNumber,\n      homeChain,\n      underlying,\n      totalSupply(),\n      totalWithdrawalRequests\n    );\n\n    state = State.PushedUnderlying;\n    lastTimeStamp = block.timestamp;\n\n    emit PushTotalUnderlying(\n      vaultNumber,\n      homeChain,\n      underlying,\n      totalSupply(),\n      totalWithdrawalRequests\n    );\n  }\n\n  /// @notice See setXChainAllocationInt below\n  function setXChainAllocation(\n    uint256 _amountToSend,\n    uint256 _exchangeRate,\n    bool _receivingFunds\n  ) external onlyXProvider {\n    require(state == State.PushedUnderlying, stateError);\n    setXChainAllocationInt(_amountToSend, _exchangeRate, _receivingFunds);\n  }\n\n  /// @notice Step 3 end; xChainController pushes exchangeRate and amount the vaults have to send back to all vaults\n  /// @notice Will set the amount to send back to the xController by the xController\n  /// @dev Sets the amount and state so the dao can trigger the rebalanceXChain function\n  /// @dev When amount == 0 the vault doesnt need to send anything and will wait for funds from the xController\n  /// @param _amountToSend amount to send in vaultCurrency\n  function setXChainAllocationInt(\n    uint256 _amountToSend,\n    uint256 _exchangeRate,\n    bool _receivingFunds\n  ) internal {\n    amountToSendXChain = _amountToSend;\n    exchangeRate = _exchangeRate;\n\n    if (_amountToSend == 0 && !_receivingFunds) settleReservedFunds();\n    else if (_amountToSend == 0 && _receivingFunds) state = State.WaitingForFunds;\n    else state = State.SendingFundsXChain;\n  }\n\n  /// @notice Step 4 trigger; Push funds from vaults to xChainController\n  /// @notice Send vaultcurrency to the xController for xChain rebalance\n  /// @param _slippage Slippage tollerance for xChain swap, in BPS (i.e. 30 = 0.3%)\n  /// @param _relayerFee The fee offered to the relayers\n  function rebalanceXChain(uint256 _slippage, uint256 _relayerFee) external payable {\n    require(state == State.SendingFundsXChain, stateError);\n\n    if (amountToSendXChain > getVaultBalance()) pullFunds(amountToSendXChain);\n    if (amountToSendXChain > getVaultBalance()) amountToSendXChain = getVaultBalance();\n\n    vaultCurrency.safeIncreaseAllowance(xProvider, amountToSendXChain);\n    IXProvider(xProvider).xTransferToController{value: msg.value}(\n      vaultNumber,\n      amountToSendXChain,\n      address(vaultCurrency),\n      _slippage,\n      _relayerFee\n    );\n\n    emit RebalanceXChain(vaultNumber, amountToSendXChain, address(vaultCurrency));\n\n    amountToSendXChain = 0;\n    settleReservedFunds();\n  }\n\n  /// @notice Step 5 end; Push funds from xChainController to vaults\n  /// @notice Receiving feedback from xController when funds are received, so the vault can rebalance\n  function receiveFunds() external onlyXProvider {\n    if (state != State.WaitingForFunds) return;\n    settleReservedFunds();\n  }\n\n  /// @notice Helper to settle reserved funds when funds arrived and up to the next State\n  function settleReservedFunds() internal {\n    reservedFunds += totalWithdrawalRequests;\n    totalWithdrawalRequests = 0;\n    state = State.RebalanceVault;\n  }\n\n  /// @notice See receiveProtocolAllocations below\n  function receiveProtocolAllocations(int256[] memory _deltas) external onlyXProvider {\n    receiveProtocolAllocationsInt(_deltas);\n  }\n\n  /// @notice Step 6 end; Game pushes deltaAllocations to vaults\n  /// @notice Receives protocol allocation array from the game and settles the allocations\n  /// @param _deltas Array with delta allocations where the index matches the protocolId\n  function receiveProtocolAllocationsInt(int256[] memory _deltas) internal {\n    for (uint i = 0; i < _deltas.length; i++) {\n      int256 allocation = _deltas[i];\n      if (allocation == 0) continue;\n      setDeltaAllocationsInt(i, allocation);\n    }\n\n    deltaAllocationsReceived = true;\n  }\n\n  /// @notice Step 8 trigger; Vaults push rewardsPerLockedToken to game\n  function sendRewardsToGame() external payable {\n    require(state == State.SendRewardsPerToken, stateError);\n\n    int256[] memory rewards = rewardsToArray();\n    IXProvider(xProvider).pushRewardsToGame{value: msg.value}(vaultNumber, homeChain, rewards);\n\n    state = State.Idle;\n\n    emit PushedRewardsToGame(vaultNumber, homeChain, rewards);\n  }\n\n  /// @notice Receive feedback for the vault if the vault is set to on or off\n  /// @param _state bool for chainId on or off\n  function toggleVaultOnOff(bool _state) external onlyXProvider {\n    vaultOff = _state;\n  }\n\n  /// @notice Returns the amount in vaultCurrency the user is able to withdraw\n  function getWithdrawalAllowance() external view returns (uint256) {\n    return userInfo[msg.sender].withdrawalAllowance;\n  }\n\n  /// @notice Returns the rewards the user is able to withdraw\n  function getRewardAllowance() external view returns (uint256) {\n    return userInfo[msg.sender].rewardAllowance;\n  }\n\n  /*\n  Only Dao functions\n  */\n\n  /// @notice Setter for xProvider address\n  /// @param _xProvider new address of xProvider on this chain\n  function setHomeXProvider(address _xProvider) external onlyDao {\n    xProvider = _xProvider;\n  }\n\n  /// @notice Setter for derby token address\n  /// @param _token New address of the derby token\n  function setDaoToken(address _token) external onlyDao {\n    derbyToken = _token;\n  }\n\n  /// @notice Setter for new game address\n  /// @param _game New address of the game\n  function setGame(address _game) external onlyDao {\n    game = _game;\n  }\n\n  /// @notice Setter for swapping rewards to derby tokens\n  /// @param _state True when rewards should be swapped to derby tokens\n  function setSwapRewards(bool _state) external onlyDao {\n    swapRewards = _state;\n  }\n\n  /// @notice Setter for maximum divergence a user can get during a withdraw\n  /// @param _maxDivergence New maximum divergence in vaultCurrency\n  function setMaxDivergence(uint256 _maxDivergence) external onlyDao {\n    maxDivergenceWithdraws = _maxDivergence;\n  }\n\n  /*\n  Only Guardian functions\n  */\n\n  /// @notice Step 3: Guardian function\n  function setXChainAllocationGuard(\n    uint256 _amountToSend,\n    uint256 _exchangeRate,\n    bool _receivingFunds\n  ) external onlyGuardian {\n    setXChainAllocationInt(_amountToSend, _exchangeRate, _receivingFunds);\n  }\n\n  /// @notice Step 5: Guardian function\n  function receiveFundsGuard() external onlyGuardian {\n    settleReservedFunds();\n  }\n\n  /// @notice Step 6: Guardian function\n  function receiveProtocolAllocationsGuard(int256[] memory _deltas) external onlyGuardian {\n    receiveProtocolAllocationsInt(_deltas);\n  }\n\n  /// @notice Guardian function to set state when vault gets stuck for whatever reason\n  function setVaultStateGuard(State _state) external onlyGuardian {\n    state = _state;\n  }\n\n  /// @notice Setter for new homeChain Id\n  function setHomeChain(uint32 _homeChain) external onlyGuardian {\n    homeChain = _homeChain;\n  }\n\n  /// @notice Setter for governance fee\n  /// @param _fee Fee in basis points\n  function setGovernanceFee(uint16 _fee) external onlyGuardian {\n    governanceFee = _fee;\n  }\n\n  /// @notice Setter to control the training state in de deposit function\n  function setTraining(bool _state) external onlyGuardian {\n    training = _state;\n  }\n\n  /// @notice Setter for maximum amount to be able to deposit in training state\n  function setTrainingDeposit(uint256 _maxDeposit) external onlyGuardian {\n    maxTrainingDeposit = _maxDeposit;\n  }\n\n  /// @notice Setter to add an address to the whitelist\n  function addToWhitelist(address _address) external onlyGuardian {\n    whitelist[_address] = true;\n  }\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/Providers/CompoundProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../Interfaces/ExternalInterfaces/ICToken.sol\";\nimport \"../Interfaces/ExternalInterfaces/IComptroller.sol\";\nimport \"../Interfaces/IProvider.sol\";\n\ncontract CompoundProvider is IProvider {\n  using SafeERC20 for IERC20;\n\n  IComptroller public comptroller;\n\n  constructor(address _comptroller) {\n    comptroller = IComptroller(_comptroller);\n  }\n\n  /// @notice Deposit the underlying asset in Compound\n  /// @dev Pulls underlying asset from Vault, deposit them in Compound, send cTokens back.\n  /// @param _amount Amount to deposit\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @param _uToken Address of underlying Token eg USDC\n  /// @return Tokens received and sent to vault\n  function deposit(\n    uint256 _amount,\n    address _cToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\n\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\n    IERC20(_uToken).safeIncreaseAllowance(_cToken, _amount);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\n\n    uint256 cTokenBefore = ICToken(_cToken).balanceOf(address(this));\n    require(ICToken(_cToken).mint(_amount) == 0, \"Error minting Compound\");\n    uint256 cTokenAfter = ICToken(_cToken).balanceOf(address(this));\n\n    uint cTokensReceived = cTokenAfter - cTokenBefore;\n    ICToken(_cToken).transfer(msg.sender, cTokensReceived);\n\n    return cTokensReceived;\n  }\n\n  /// @notice Withdraw the underlying asset from Compound\n  /// @dev Pulls cTokens from Vault, redeem them from Compound, send underlying back.\n  /// @param _amount Amount to withdraw\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @param _uToken Address of underlying Token eg USDC\n  /// @return Underlying tokens received and sent to vault e.g USDC\n  function withdraw(\n    uint256 _amount,\n    address _cToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\n\n    uint256 balanceBeforeRedeem = IERC20(_uToken).balanceOf(address(this));\n\n    require(\n      ICToken(_cToken).transferFrom(msg.sender, address(this), _amount) == true,\n      \"Error: transferFrom\"\n    );\n    // Compound redeem: 0 on success, otherwise an Error code\n    require(ICToken(_cToken).redeem(_amount) == 0, \"Error: compound redeem\");\n\n    uint256 balanceAfterRedeem = IERC20(_uToken).balanceOf(address(this));\n    uint256 uTokensReceived = balanceAfterRedeem - balanceBeforeRedeem;\n\n    IERC20(_uToken).safeTransfer(msg.sender, uTokensReceived);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\n    require(\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\n      \"Error Withdraw: under/overflow\"\n    );\n\n    return uTokensReceived;\n  }\n\n  /// @notice Get balance from address in underlying token\n  /// @param _address Address to request balance from, most likely a Vault\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return balance in underlying token\n  function balanceUnderlying(\n    address _address,\n    address _cToken\n  ) public view override returns (uint256) {\n    uint256 balanceShares = balance(_address, _cToken);\n    // The returned exchange rate from comp is scaled by 1 * 10^(18 - 8 + Underlying Token Decimals).\n    uint256 price = exchangeRate(_cToken);\n    uint256 decimals = IERC20Metadata(ICToken(_cToken).underlying()).decimals();\n\n    return (balanceShares * price) / 10 ** (10 + decimals);\n  }\n\n  /// @notice Calculates how many shares are equal to the amount\n  /// @dev returned price from compound is scaled https://compound.finance/docs/ctokens#exchange-rate\n  /// @param _amount Amount in underyling token e.g USDC\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return number of shares i.e LP tokens\n  function calcShares(uint256 _amount, address _cToken) external view override returns (uint256) {\n    uint256 decimals = IERC20Metadata(ICToken(_cToken).underlying()).decimals();\n    uint256 shares = (_amount * (10 ** (10 + decimals))) / exchangeRate(_cToken);\n    return shares;\n  }\n\n  /// @notice Get balance of cToken from address\n  /// @param _address Address to request balance from\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return number of shares i.e LP tokens\n  function balance(address _address, address _cToken) public view override returns (uint256) {\n    uint256 _balanceShares = ICToken(_cToken).balanceOf(_address);\n    return _balanceShares;\n  }\n\n  /// @notice Exchange rate of underyling protocol token\n  /// @dev returned price from compound is scaled https://compound.finance/docs/ctokens#exchange-rate\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return price of LP token\n  function exchangeRate(address _cToken) public view override returns (uint256) {\n    uint256 _price = ICToken(_cToken).exchangeRateStored();\n    return _price;\n  }\n\n  /// @notice Claims/harvest COMP tokens from the Comptroller\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  function claim(address _cToken, address _claimer) external override returns (bool) {\n    address[] memory cTokens = new address[](1);\n    cTokens[0] = _cToken;\n    comptroller.claimComp(_claimer, cTokens);\n\n    return true;\n  }\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/Providers/CompoundProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../Interfaces/ExternalInterfaces/ICToken.sol\";\nimport \"../Interfaces/ExternalInterfaces/IComptroller.sol\";\nimport \"../Interfaces/IProvider.sol\";\n\ncontract CompoundProvider is IProvider {\n  using SafeERC20 for IERC20;\n\n  IComptroller public comptroller;\n\n  constructor(address _comptroller) {\n    comptroller = IComptroller(_comptroller);\n  }\n\n  /// @notice Deposit the underlying asset in Compound\n  /// @dev Pulls underlying asset from Vault, deposit them in Compound, send cTokens back.\n  /// @param _amount Amount to deposit\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @param _uToken Address of underlying Token eg USDC\n  /// @return Tokens received and sent to vault\n  function deposit(\n    uint256 _amount,\n    address _cToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\n\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\n    IERC20(_uToken).safeIncreaseAllowance(_cToken, _amount);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\n\n    uint256 cTokenBefore = ICToken(_cToken).balanceOf(address(this));\n    require(ICToken(_cToken).mint(_amount) == 0, \"Error minting Compound\");\n    uint256 cTokenAfter = ICToken(_cToken).balanceOf(address(this));\n\n    uint cTokensReceived = cTokenAfter - cTokenBefore;\n    ICToken(_cToken).transfer(msg.sender, cTokensReceived);\n\n    return cTokensReceived;\n  }\n\n  /// @notice Withdraw the underlying asset from Compound\n  /// @dev Pulls cTokens from Vault, redeem them from Compound, send underlying back.\n  /// @param _amount Amount to withdraw\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @param _uToken Address of underlying Token eg USDC\n  /// @return Underlying tokens received and sent to vault e.g USDC\n  function withdraw(\n    uint256 _amount,\n    address _cToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\n\n    uint256 balanceBeforeRedeem = IERC20(_uToken).balanceOf(address(this));\n\n    require(\n      ICToken(_cToken).transferFrom(msg.sender, address(this), _amount) == true,\n      \"Error: transferFrom\"\n    );\n    // Compound redeem: 0 on success, otherwise an Error code\n    require(ICToken(_cToken).redeem(_amount) == 0, \"Error: compound redeem\");\n\n    uint256 balanceAfterRedeem = IERC20(_uToken).balanceOf(address(this));\n    uint256 uTokensReceived = balanceAfterRedeem - balanceBeforeRedeem;\n\n    IERC20(_uToken).safeTransfer(msg.sender, uTokensReceived);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\n    require(\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\n      \"Error Withdraw: under/overflow\"\n    );\n\n    return uTokensReceived;\n  }\n\n  /// @notice Get balance from address in underlying token\n  /// @param _address Address to request balance from, most likely a Vault\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return balance in underlying token\n  function balanceUnderlying(\n    address _address,\n    address _cToken\n  ) public view override returns (uint256) {\n    uint256 balanceShares = balance(_address, _cToken);\n    // The returned exchange rate from comp is scaled by 1 * 10^(18 - 8 + Underlying Token Decimals).\n    uint256 price = exchangeRate(_cToken);\n    uint256 decimals = IERC20Metadata(ICToken(_cToken).underlying()).decimals();\n\n    return (balanceShares * price) / 10 ** (10 + decimals);\n  }\n\n  /// @notice Calculates how many shares are equal to the amount\n  /// @dev returned price from compound is scaled https://compound.finance/docs/ctokens#exchange-rate\n  /// @param _amount Amount in underyling token e.g USDC\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return number of shares i.e LP tokens\n  function calcShares(uint256 _amount, address _cToken) external view override returns (uint256) {\n    uint256 decimals = IERC20Metadata(ICToken(_cToken).underlying()).decimals();\n    uint256 shares = (_amount * (10 ** (10 + decimals))) / exchangeRate(_cToken);\n    return shares;\n  }\n\n  /// @notice Get balance of cToken from address\n  /// @param _address Address to request balance from\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return number of shares i.e LP tokens\n  function balance(address _address, address _cToken) public view override returns (uint256) {\n    uint256 _balanceShares = ICToken(_cToken).balanceOf(_address);\n    return _balanceShares;\n  }\n\n  /// @notice Exchange rate of underyling protocol token\n  /// @dev returned price from compound is scaled https://compound.finance/docs/ctokens#exchange-rate\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return price of LP token\n  function exchangeRate(address _cToken) public view override returns (uint256) {\n    uint256 _price = ICToken(_cToken).exchangeRateStored();\n    return _price;\n  }\n\n  /// @notice Claims/harvest COMP tokens from the Comptroller\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  function claim(address _cToken, address _claimer) external override returns (bool) {\n    address[] memory cTokens = new address[](1);\n    cTokens[0] = _cToken;\n    comptroller.claimComp(_claimer, cTokens);\n\n    return true;\n  }\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/Providers/BetaProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IBeta.sol\";\r\nimport \"../Interfaces/IProvider.sol\";\r\n\r\ncontract BetaProvider is IProvider {\r\n  using SafeERC20 for IERC20;\r\n\r\n  /// @notice Deposit the underlying asset in Idle\r\n  /// @dev Pulls underlying asset from Vault, deposit them in Idle, send tTokens back.\r\n  /// @param _amount Amount to deposit\r\n  /// @param _bToken Address of protocol LP Token eg cUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Tokens received and sent to vault\r\n  function deposit(\r\n    uint256 _amount,\r\n    address _bToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n    IERC20(_uToken).safeIncreaseAllowance(_bToken, _amount);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\r\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\r\n\r\n    uint256 tTokenBefore = IBeta(_bToken).balanceOf(address(this));\r\n    IBeta(_bToken).mint(address(this), _amount);\r\n    uint256 tTokenAfter = IBeta(_bToken).balanceOf(address(this));\r\n\r\n    uint tTokensReceived = tTokenAfter - tTokenBefore;\r\n    IBeta(_bToken).transfer(msg.sender, tTokensReceived);\r\n\r\n    return tTokensReceived;\r\n  }\r\n\r\n  /// @notice Withdraw the underlying asset from Idle\r\n  /// @dev Pulls tTokens from Vault, redeem them from Idle, send underlying back.\r\n  /// @param _amount Amount to withdraw\r\n  /// @param _bToken Address of protocol LP Token eg cUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Underlying tokens received and sent to vault e.g USDC\r\n  function withdraw(\r\n    uint256 _amount,\r\n    address _bToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\r\n\r\n    uint256 balanceBeforeRedeem = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    require(\r\n      IBeta(_bToken).transferFrom(msg.sender, address(this), _amount) == true,\r\n      \"Error: transferFrom\"\r\n    );\r\n    IBeta(_bToken).burn(address(this), _amount);\r\n\r\n    uint256 balanceAfterRedeem = IERC20(_uToken).balanceOf(address(this));\r\n    uint256 uTokensReceived = balanceAfterRedeem - balanceBeforeRedeem;\r\n\r\n    IERC20(_uToken).safeTransfer(msg.sender, uTokensReceived);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\r\n    require(\r\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\r\n      \"Error Withdraw: under/overflow\"\r\n    );\r\n\r\n    return uTokensReceived;\r\n  }\r\n\r\n  /// @notice Get balance from address in underlying token\r\n  /// @dev balance = poolvalue * shares / totalsupply\r\n  /// @param _address Address to request balance from, most likely an Vault\r\n  /// @param _bToken Address of protocol LP Token eg cUSDC\r\n  /// @return balance in underlying token\r\n  function balanceUnderlying(\r\n    address _address,\r\n    address _bToken\r\n  ) public view override returns (uint256) {\r\n    uint256 balanceShares = balance(_address, _bToken);\r\n    uint256 supply = IBeta(_bToken).totalSupply();\r\n    uint256 totalLoanable = IBeta(_bToken).totalLoanable();\r\n    uint256 totalLoan = IBeta(_bToken).totalLoan();\r\n\r\n    return (balanceShares * (totalLoanable + totalLoan)) / supply;\r\n  }\r\n\r\n  /// @notice Calculates how many shares are equal to the amount\r\n  /// @dev shares = totalsupply * balance / poolvalue\r\n  /// @param _amount Amount in underyling token e.g USDC\r\n  /// @param _bToken Address of protocol LP Token eg cUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function calcShares(uint256 _amount, address _bToken) external view override returns (uint256) {\r\n    uint256 supply = IBeta(_bToken).totalSupply();\r\n    uint256 totalLoanable = IBeta(_bToken).totalLoanable();\r\n    uint256 totalLoan = IBeta(_bToken).totalLoan();\r\n\r\n    return (_amount * supply) / (totalLoanable + totalLoan);\r\n  }\r\n\r\n  /// @notice Get balance of cToken from address\r\n  /// @param _address Address to request balance from\r\n  /// @param _bToken Address of protocol LP Token eg cUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function balance(address _address, address _bToken) public view override returns (uint256) {\r\n    return IBeta(_bToken).balanceOf(_address);\r\n  }\r\n\r\n  /// @notice Not used for Beta\r\n  /// @param _bToken Address of protocol LP Token eg yUSDC\r\n  /// @return price of LP token\r\n  function exchangeRate(address _b"
    }
  ]
}