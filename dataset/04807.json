{
  "Title": "[26] zkEVM's `CodeOracle` Precompile somewhat deviates from EVM's `extcodecopy` behavior",
  "Content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/precompiles/CodeOracle.yul#L4\n\n```yul\n * @notice The contract used to emulate EVM's `extcodecopy` behavior.\n\n```\n\nWe can see that this function is to emulate EVM extcodecopy behaviour, but it contatns multiple deviation to the etheruem's native implementation, to list a few:\n\n- **Memory Management:** `extcodecopy` allows specifying the destination memory location. `CodeOracle` relies on zkEVM's internal memory management, potentially reusing the same memory page for subsequent decommits, leading to caching issues.\n- **Functionality:** Unlike `extcodecopy` which copies a specific size of code, `CodeOracle` decommits the entire code based on a versioned hash stored in a separate contract.\n- **Error Handling:** `extcodecopy` handles out-of-gas situations during memory access. `CodeOracle` might not handle such cases, potentially leading to unexpected behavior.\n\n### Impact\n\nBorderline medium/low, since this is a deviation from Ethereum's specific implementation and would lead to confusion\n\n### Recommended Mitigation Steps\n\nConsider making it very similar to Ethereum's implementation or clearly document the deviation.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/system-contracts/contracts/precompiles/CodeOracle.yul",
      "content": "/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice The contract used to emulate EVM's `extcodecopy` behavior.\n */\nobject \"CodeOracle\" {\n    code {\n        return(0, 0)\n    }\n    object \"CodeOracle_deployed\" {\n        code {\n            ////////////////////////////////////////////////////////////////\n            //                      CONSTANTS\n            ////////////////////////////////////////////////////////////////\n\n            /// @notice The fixed address of the known code storage contract.\n            function KNOWN_CODES_CONTRACT_ADDR() -> ret {\n                ret := 0x0000000000000000000000000000000000008004\n            }\n\n            /// @notice The maximum value of the `uint32` type.\n            function UINT32_MAX() -> ret {\n                // 2^32 - 1\n                ret := 4294967295\n            }\n\n            ////////////////////////////////////////////////////////////////\n            //                      HELPER FUNCTIONS\n            ////////////////////////////////////////////////////////////////\n            \n            /// @notice The function that returns whether a certain versioned hash is marked as `known`\n            /// @param versionedHash The versioned hash to check\n            /// @return Whether the versioned hash is known\n            function isCodeHashKnown(versionedHash) -> ret {\n                // 1. Selector for `KnwonCodesStorage.getMarker(bytes32)`\n                mstore(0, 0x4c6314f000000000000000000000000000000000000000000000000000000000)\n                // 2. Input for `KnwonCodesStorage.getMarker(bytes32)`\n                mstore(4, versionedHash)\n\n                let success := staticcall(\n                    gas(),\n                    KNOWN_CODES_CONTRACT_ADDR(),\n                    0,\n                    36,\n                    0,\n                    32\n                )\n\n                if iszero(success) {\n                    // For some reason the call to the KnownCodesStorage failed.\n                    // Most likely out of gas.\n                    revert(0,0)\n                }\n\n                ret := mload(0)\n            }\n\n            /// @notice The cost for decommitment of a single 32-byte word.\n            function decommmitCostPerWord() -> ret {\n                ret := 4\n            }\n\n            /// @notice The function that performs that `decommit` operation, i.e. \n            /// given a versioned hash (i.e. `commitment` to some blob), it unpacks it \n            /// into the memory and returns it.\n            /// @param versionedHash The versioned hash to decommit.\n            /// @param lenInWords The length of the data in bytes to decommit.\n            function decommit(versionedHash, lenInWords) {\n                // The operation below are never expected to overflow since the `lenInWords` is a most 2 bytes long.\n                let gasCost := mul(decommmitCostPerWord(), lenInWords)\n\n                // The cost of the decommit operation can not exceed the maximum value of the `uint32` type.\n                // This should never happen in practice, since `lenInWords` is an u16 value, but we add this check \n                // just in case.\n                if gt(gasCost, UINT32_MAX()) {\n                    gasCost := UINT32_MAX()\n                }\n\n                // We execute the `decommit` opcode that, given a versioned hash, unpacks the data into the memory.\n                // Note, that this memory does not necessarily have to be the memory of this contract. If an unpack \n                // has happened before, we will reuse the memory page where the first unpack happened.\n                //\n                // This means that we have to be careful with the memory management, since in case this memory page was the first \n                // one where the `decommit` happened, its memory page will be always used as a cache for this versioned hash, \n                // regardless of correctness.\n                let success := verbatim_2i_1o(\"decommit\", versionedHash, gasCost)\n                if iszero(success) {\n                    // Decommitment failed\n                    revert(0,0)\n                }\n                \n                // The \"real\" result of the `decommit` operation is a pointer to the memory page where the data was unpacked.\n                // We do not know whether the data was unpacked into the memory of this contract or not.\n                //  \n                // Also, for technical reasons we can not access pointers directly, so we have to copy the pointer returned by the\n                // decommit operation into the `active` pointer. \n                verbatim_0i_0o(\"decommit_ptr_to_active\")\n\n                // This operation is never expected to overflow since the `lenInWords` is a most 2 bytes long.\n                let lenInBytes := mul(lenInWords, 32) \n\n                // To avoid the complexity of calculating the length of the preimage in circuits, the length of the pointer is always fixed to 2^21 bytes.\n                // So the amount of data actually copied is determined here.\n                // Note, that here we overwrite the first `lenInBytes` bytes of the memory, but it is fine since the written values are equivalent\n                // to the bytes previously written there by the `decommit` operation (in case this is the first page where the decomit happened).\n                // In the future we won't do this and simply return the pointer returned by the `decommit` operation, shrunk to the `lenInBytes` length.\n                verbatim_3i_0o(\"active_ptr_data_copy\", 0, 0, lenInBytes)\n\n                return(0, lenInBytes)\n            }\n\n            ////////////////////////////////////////////////////////////////\n            //                      FALLBACK\n            ////////////////////////////////////////////////////////////////\n\n            let versionedCodeHash := calldataload(0)\n\n            // Can not decommit unknown code\n            if iszero(isCodeHashKnown(versionedCodeHash)) {\n                revert(0, 0)\n            }\n\n            let version := shr(248, versionedCodeHash)\n            // Currently, only a single version of the code hash is supported:\n            // 1. The standard zkEVM bytecode. It has the following format:\n            //   - hash[0] -- version (0x01)\n            //   - hash[1] -- whether the contract is being constructed\n            //   - hash[2..3] -- big endian length of the bytecode in 32-byte words. This number must be odd.\n            //   - hash[4..31] -- the last 28 bytes of the sha256 hash.\n            // \n            // Note, that in theory it can represent just some random blob of bytes, while \n            // in practice it only represents only the corresponding bytecodes.\n\n            switch version \n            case 1 {\n                // We do not double check whether it is odd, since it assumed that only valid bytecodes\n                // can pass the `isCodeHashKnown` check.\n                let lengthInWords := and(shr(224, versionedCodeHash), 0xffff)\n                decommit(versionedCodeHash, lengthInWords)\n            }\n            default {\n                // Unsupported\n                revert(0,0)\n            }\n        }\n    }\n}"
    }
  ]
}