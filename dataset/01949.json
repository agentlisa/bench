{
  "Title": "M-2: Users might lose funds as `claimERC20Prize()` doesn't revert for no-revert-on-transfer tokens",
  "Content": "# Issue M-2: Users might lose funds as `claimERC20Prize()` doesn't revert for no-revert-on-transfer tokens \n\nSource: https://github.com/sherlock-audit/2023-04-footium-judging/issues/86 \n\n## Found by \n0xAsen, 0xGoodess, 0xGusMcCrae, 0xPkhatri, 0xRobocop, 0xStalin, 0xeix, 0xmuxyz, 0xnirlin, 14si2o\\_Flint, 8olidity, ACai7, AlexCzm, BAHOZ, Bauchibred, Bauer, Cryptor, DevABDee, Diana, GimelSec, J4de, Koolex, MiloTruck, PRAISE, PTolev, Phantasmagoria, Piyushshukla, PokemonAuditSimulator, Polaris\\_tow, Proxy, Quantish, R-Nemes, SanketKogekar, Sulpiride, TheNaubit, Tricko, \\_\\_141345\\_\\_, abiih, alliums8520, ast3ros, berlin-101, cergyk, ctf\\_sec, cuthalion0x, dacian, ddimitrov22, deadrxsezzz, djxploit, favelanky, georgits, holyhansss, innertia, jasonxiale, josephdara, jprod15, kiki\\_dev, l3r0ux, lewisbroadhurst, nzm\\_, oot2k, oualidpro, peanuts, ravikiran.web3, sach1r0, santipu\\_, sashik\\_eth, shaka, shame, thekmj, tibthecat, tsvetanovv, whoismatthewmc1, wzrdk3lly, yy\n## Summary\n\nUsers can call `claimERC20Prize()` without actually receiving tokens if a no-revert-on-failure token is used, causing a portion of their claimable tokens to become unclaimable.\n\n## Vulnerability Detail\n\nIn the `FootiumPrizeDistributor` contract, whitelisted users can call `claimERC20Prize()` to claim ERC20 tokens. The function adds the amount of tokens claimed to the user's total claim amount, and then transfers the tokens to the user:\n\n[FootiumPrizeDistributor.sol#L128-L131](https://github.com/sherlock-audit/2023-04-footium/blob/main/footium-eth-shareable/contracts/FootiumPrizeDistributor.sol#L128-L131)\n\n```solidity\nif (value > 0) {\n    totalERC20Claimed[_token][_to] += value;\n    _token.transfer(_to, value);\n}\n```\n\nAs the the return value from `transfer()` is not checked, `claimERC20Prize()` does not revert even when the transfer of tokens to the user fails.\n\nThis could potentially cause users to lose assets when:\n1. `_token` is a no-revert-on-failure token.\n2. The user calls `claimERC20Prize()` with `value` higher than the contract's token balance.\n\nAs the contract has an insufficient balance, `transfer()` will revert and the user receives no tokens. However, as `claimERC20Prize()` succeeds, `totalERC20Claimed` is permanently increased for the user, thus the user cannot claim these tokens again.\n\n## Impact\n\nUsers can call `claimERC20Prize()` without receiving the token amount specified. These tokens become permanently unclaimable for the user, leading to a loss of funds.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-footium/blob/main/footium-eth-shareable/contracts/FootiumPrizeDistributor.sol#L128-L131\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse `safeTransfer()` from Openzeppelin's [SafeERC20](https://docs.openzeppelin.com/contracts/2.x/api/token/erc20#SafeERC20) to transfer ERC20 tokens. Note that [`transferERC20()`](https://github.com/sherlock-audit/2023-04-footium/blob/main/footium-eth-shareable/contracts/FootiumEscrow.sol#L105-L111) in `FootiumEscrow.sol` also uses `transfer()` and is susceptible to the same vulnerability.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/71",
  "Code": [
    {
      "filename": "footium-eth-shareable/contracts/FootiumPrizeDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {MerkleProofUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./common/Errors.sol\";\n\nerror InvalidERC20MerkleProof();\nerror InvalidETHMerkleProof();\nerror InvalidAccount();\n\n/**\n * @title Footium Prize Distributor\n * @notice Whitelisted addresses claim ETH and ERC20 tokens from this contract via a Merkle Root.\n */\ncontract FootiumPrizeDistributor is\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable\n{\n    bytes32 private erc20MerkleRoot;\n    bytes32 private ethMerkleRoot;\n    mapping(IERC20Upgradeable => mapping(address => uint256))\n        private totalERC20Claimed;\n    mapping(address => uint256) private totalETHClaimed;\n\n    event SetERC20MerkleRoot(bytes32 merkleRoot);\n    event SetETHMerkleRoot(bytes32 merkleRoot);\n    event ClaimERC20(\n        IERC20Upgradeable indexed token,\n        address indexed to,\n        uint256 value\n    );\n    event ClaimETH(address indexed to, uint256 value);\n    event ETHReceived(address sender, uint256 amount);\n\n    /**\n     * @notice Initializes the Footium Prize Distributor contract.\n     */\n    function initialize() external initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n    }\n\n    /**\n     * @notice Enables the contract to receive ETH\n     * Emits a {ETHReceived} event when ETH is received.\n     */\n    receive() external payable {\n        emit ETHReceived(msg.sender, msg.value);\n    }\n\n    /**\n     * @notice Unpause the contract\n     * @dev Only owner address allowed.\n     */\n    function activateContract() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @notice Pause the contract\n     * @dev Only owner address allowed.\n     */\n    function pauseContract() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Sets the ERC20 prize claim merkle root\n     * @param _merkleRoot New merkel root to be set\n     * @dev Only the contract owner can set the merkle root\n     * Emits a {SetERC20MerkleRoot} event.\n     */\n    function setERC20MerkleRoot(bytes32 _merkleRoot) external onlyOwner {\n        erc20MerkleRoot = _merkleRoot;\n\n        emit SetERC20MerkleRoot(erc20MerkleRoot);\n    }\n\n    /**\n     * @notice Sets the ETH prize claim merkle root\n     * @param _merkleRoot New merkel root to be set\n     * @dev Only the contract owner can set the merkle root\n     * Emits a {SetETHMerkleRoot} event.\n     */\n    function setETHMerkleRoot(bytes32 _merkleRoot) external onlyOwner {\n        ethMerkleRoot = _merkleRoot;\n\n        emit SetETHMerkleRoot(ethMerkleRoot);\n    }\n\n    /**\n     * @notice Claims ERC20 tokens from the contract\n     * @param _to Prize receiver account address\n     * @param _token ERC20 token contract address\n     * @param _amount ERC20 token amount\n     * @param _proof Merkle proof for `erc20MerkleRoot`\n     * @dev The sender must provide a merkle proof for `erc20MerkleRoot`\n     * Emits a {ClaimERC20} event.\n     */\n    function claimERC20Prize(\n        address _to,\n        IERC20Upgradeable _token,\n        uint256 _amount,\n        bytes32[] calldata _proof\n    ) external whenNotPaused nonReentrant {\n        if (_to != msg.sender) {\n            revert InvalidAccount();\n        }\n\n        if (\n            !MerkleProofUpgradeable.verify(\n                _proof,\n                erc20MerkleRoot,\n                keccak256(abi.encodePacked(_token, _to, _amount))\n            )\n        ) {\n            revert InvalidERC20MerkleProof();\n        }\n\n        uint256 value = _amount - totalERC20Claimed[_token][_to];\n\n        if (value > 0) {\n            totalERC20Claimed[_token][_to] += value;\n            _token.transfer(_to, value);\n        }\n\n        emit ClaimERC20(_token, _to, value);\n    }\n\n    /**\n     * @notice Claims ETH tokens from the contract.\n     * @param _to Prize receiver account address\n     * @param _amount ETH amount\n     * @param _proof Merkle proof for `ethMerkleRoot`\n     * @dev The sender must provide a merkle proof for `ethMerkleRoot`.\n     * Emits a {ClaimETH} event.\n     */\n    function claimETHPrize(\n        address _to,\n        uint256 _amount,\n        bytes32[] calldata _proof\n    ) external whenNotPaused nonReentrant {\n        if (_to != msg.sender) {\n            revert InvalidAccount();\n        }\n\n        if (\n            !MerkleProofUpgradeable.verify(\n                _proof,\n                ethMerkleRoot,\n                keccak256(abi.encodePacked(_to, _amount))\n            )\n        ) {\n            revert InvalidETHMerkleProof();\n        }\n\n        uint256 value = _amount - totalETHClaimed[_to];\n\n        if (value > 0) {\n            totalETHClaimed[_to] += value;\n\n            (bool sent, ) = _to.call{value: value}(\"\");\n            if (!sent) {\n                revert FailedToSendETH(value);\n            }\n        }\n\n        emit ClaimETH(_to, value);\n    }\n}"
    },
    {
      "filename": "footium-eth-shareable/contracts/FootiumPrizeDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {MerkleProofUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./common/Errors.sol\";\n\nerror InvalidERC20MerkleProof();\nerror InvalidETHMerkleProof();\nerror InvalidAccount();\n\n/**\n * @title Footium Prize Distributor\n * @notice Whitelisted addresses claim ETH and ERC20 tokens from this contract via a Merkle Root.\n */\ncontract FootiumPrizeDistributor is\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable\n{\n    bytes32 private erc20MerkleRoot;\n    bytes32 private ethMerkleRoot;\n    mapping(IERC20Upgradeable => mapping(address => uint256))\n        private totalERC20Claimed;\n    mapping(address => uint256) private totalETHClaimed;\n\n    event SetERC20MerkleRoot(bytes32 merkleRoot);\n    event SetETHMerkleRoot(bytes32 merkleRoot);\n    event ClaimERC20(\n        IERC20Upgradeable indexed token,\n        address indexed to,\n        uint256 value\n    );\n    event ClaimETH(address indexed to, uint256 value);\n    event ETHReceived(address sender, uint256 amount);\n\n    /**\n     * @notice Initializes the Footium Prize Distributor contract.\n     */\n    function initialize() external initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n    }\n\n    /**\n     * @notice Enables the contract to receive ETH\n     * Emits a {ETHReceived} event when ETH is received.\n     */\n    receive() external payable {\n        emit ETHReceived(msg.sender, msg.value);\n    }\n\n    /**\n     * @notice Unpause the contract\n     * @dev Only owner address allowed.\n     */\n    function activateContract() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @notice Pause the contract\n     * @dev Only owner address allowed.\n     */\n    function pauseContract() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Sets the ERC20 prize claim merkle root\n     * @param _merkleRoot New merkel root to be set\n     * @dev Only the contract owner can set the merkle root\n     * Emits a {SetERC20MerkleRoot} event.\n     */\n    function setERC20MerkleRoot(bytes32 _merkleRoot) external onlyOwner {\n        erc20MerkleRoot = _merkleRoot;\n\n        emit SetERC20MerkleRoot(erc20MerkleRoot);\n    }\n\n    /**\n     * @notice Sets the ETH prize claim merkle root\n     * @param _merkleRoot New merkel root to be set\n     * @dev Only the contract owner can set the merkle root\n     * Emits a {SetETHMerkleRoot} event.\n     */\n    function setETHMerkleRoot(bytes32 _merkleRoot) external onlyOwner {\n        ethMerkleRoot = _merkleRoot;\n\n        emit SetETHMerkleRoot(ethMerkleRoot);\n    }\n\n    /**\n     * @notice Claims ERC20 tokens from the contract\n     * @param _to Prize receiver account address\n     * @param _token ERC20 token contract address\n     * @param _amount ERC20 token amount\n     * @param _proof Merkle proof for `erc20MerkleRoot`\n     * @dev The sender must provide a merkle proof for `erc20MerkleRoot`\n     * Emits a {ClaimERC20} event.\n     */\n    function claimERC20Prize(\n        address _to,\n        IERC20Upgradeable _token,\n        uint256 _amount,\n        bytes32[] calldata _proof\n    ) external whenNotPaused nonReentrant {\n        if (_to != msg.sender) {\n            revert InvalidAccount();\n        }\n\n        if (\n            !MerkleProofUpgradeable.verify(\n                _proof,\n                erc20MerkleRoot,\n                keccak256(abi.encodePacked(_token, _to, _amount))\n            )\n        ) {\n            revert InvalidERC20MerkleProof();\n        }\n\n        uint256 value = _amount - totalERC20Claimed[_token][_to];\n\n        if (value > 0) {\n            totalERC20Claimed[_token][_to] += value;\n            _token.transfer(_to, value);\n        }\n\n        emit ClaimERC20(_token, _to, value);\n    }\n\n    /**\n     * @notice Claims ETH tokens from the contract.\n     * @param _to Prize receiver account address\n     * @param _amount ETH amount\n     * @param _proof Merkle proof for `ethMerkleRoot`\n     * @dev The sender must provide a merkle proof for `ethMerkleRoot`.\n     * Emits a {ClaimETH} event.\n     */\n    function claimETHPrize(\n        address _to,\n        uint256 _amount,\n        bytes32[] calldata _proof\n    ) external whenNotPaused nonReentrant {\n        if (_to != msg.sender) {\n            revert InvalidAccount();\n        }\n\n        if (\n            !MerkleProofUpgradeable.verify(\n                _proof,\n                ethMerkleRoot,\n                keccak256(abi.encodePacked(_to, _amount))\n            )\n        ) {\n            revert InvalidETHMerkleProof();\n        }\n\n        uint256 value = _amount - totalETHClaimed[_to];\n\n        if (value > 0) {\n            totalETHClaimed[_to] += value;\n\n            (bool sent, ) = _to.call{value: value}(\"\");\n            if (!sent) {\n                revert FailedToSendETH(value);\n            }\n        }\n\n        emit ClaimETH(_to, value);\n    }\n}"
    },
    {
      "filename": "footium-eth-shareable/contracts/FootiumEscrow.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport {IERC1271} from \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"./common/Errors.sol\";\n\n/**\n * @title Footium Escrow\n * @notice An escrow contract that stores club's players and tokens.\n */\ncontract FootiumEscrow is ERC721Holder, IERC1271 {\n    bytes4 private constant MAGICVALUE = 0x1626ba7e;\n\n    address private immutable footiumClubAddress;\n    uint256 private immutable clubId;\n\n    event ETHReceived(address sender, uint256 amount);\n\n    /**\n     * @notice Constructs Footium Escrow contract\n     * @param _footiumClubAddress The address of Footium Club contract.\n     * @param _clubId Footium Club ID.\n     */\n    constructor(address _footiumClubAddress, uint256 _clubId) {\n        footiumClubAddress = _footiumClubAddress;\n        clubId = _clubId;\n    }\n\n    modifier onlyClubOwner() {\n        if (msg.sender != IERC721(footiumClubAddress).ownerOf(clubId)) {\n            revert NotClubOwner(clubId, msg.sender);\n        }\n        _;\n    }\n\n    /**\n     * @notice Enables the contract to receive ETH\n     * Emits a {ETHReceived} event when ETH is received.\n     */\n    receive() external payable {\n        emit ETHReceived(msg.sender, msg.value);\n    }\n\n    /**\n     * @notice Checks if the signature is valid.\n     * @param hash The Hashed message.\n     * @param signature The signature of hashed message.\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature)\n        external\n        view\n        returns (bytes4 magicValue)\n    {\n        if (\n            ECDSA.recover(hash, signature) ==\n            IERC721(footiumClubAddress).ownerOf(clubId)\n        ) {\n            return MAGICVALUE;\n        }\n\n        return 0xffffffff;\n    }\n\n    /**\n     * @notice Sets approval for ERC20 tokens.\n     * @param erc20Contract ERC20 contract address.\n     * @param to The address of token spender.\n     * @param amount Token amount to spend.\n     * @dev only the club owner address allowed.\n     */\n    function setApprovalForERC20(\n        IERC20 erc20Contract,\n        address to,\n        uint256 amount\n    ) external onlyClubOwner {\n        erc20Contract.approve(to, amount);\n    }\n\n    /**\n     * @notice Sets approval for ERC721 tokens.\n     * @param erc721Contract ERC721 contract address.\n     * @param to The address of token spender.\n     * @param approved Boolean flag indicating whether approved or not.\n     * @dev only the club owner address allowed.\n     */\n    function setApprovalForERC721(\n        IERC721 erc721Contract,\n        address to,\n        bool approved\n    ) external onlyClubOwner {\n        erc721Contract.setApprovalForAll(to, approved);\n    }\n\n    /**\n     * @notice Transfers ERC20 tokens to `to` address.\n     * @param erc20Contract ERC20 contract address.\n     * @param to Token receiver address.\n     * @param amount Token amount to transfer.\n     * @dev only the club owner address allowed.\n     */\n    function transferERC20(\n        IERC20 erc20Contract,\n        address to,\n        uint256 amount\n    ) external onlyClubOwner {\n        erc20Contract.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfers ERC721 tokens to `to` address.\n     * @param erc721Contract ERC721 contract address.\n     * @param to Token receiver address.\n     * @param tokenId Token ID to be transferred.\n     * @dev only the club owner address allowed.\n     */\n    function transferERC721(\n        IERC721 erc721Contract,\n        address to,\n        uint256 tokenId\n    ) external onlyClubOwner {\n        erc721Contract.safeTransferFrom(address(this), to, tokenId);\n    }\n\n    /**\n     * @notice Transfers contract available ether balance to the club owner address\n     * @dev Only club owner address allowed\n     */\n    function withdraw() external onlyClubOwner {\n        uint256 balance = address(this).balance;\n        if (balance > 0) {\n            (bool sent, ) = payable(msg.sender).call{value: balance}(\"\");\n            if (!sent) {\n                revert FailedToSendETH(balance);\n            }\n        }\n    }\n}"
    }
  ]
}