{
  "Title": "[M02] Negative DSR causes unexpected reverts",
  "Content": "[On line 66 of `DAIInterestRateModel.sol`](https://github.com/compound-finance/compound-protocol/blob/9ea64ddd166a78b264ba8006f688880085eeed13/contracts/DAIInterestRateModel.sol#L66), `1e27` is subtracted from `dsr`. If for any reason, `dsr` is less than `1e27` (which corresponds to a “negative” interest rate), any calls to [the `dsrPerBlock` function](https://github.com/compound-finance/compound-protocol/blob/9ea64ddd166a78b264ba8006f688880085eeed13/contracts/DAIInterestRateModel.sol#L64) will revert. This includes all calls to [the `poke` function](https://github.com/compound-finance/compound-protocol/blob/9ea64ddd166a78b264ba8006f688880085eeed13/contracts/DAIInterestRateModel.sol#L74) and [the `getSupplyRate` function](https://github.com/compound-finance/compound-protocol/blob/9ea64ddd166a78b264ba8006f688880085eeed13/contracts/DAIInterestRateModel.sol#L48).\n\n\nWhile the Maker developers have said they do not have plans to ever allow `dsr` to be less than `1e27`, this could still happen via the Maker governance system.\n\n\nReverting on `poke` could prevent updating the `baseRatePerBlock` and `multiplierPerBlock` state variables.\n\n\nConsider modifying `dsrPerBlock` such that it returns `0` when `dsr &lt; 1e27` (corresponding to a DSR of 0%). Also consider implementing a mechanism to remove DAI from the DSR contract, and to stop deposits into the DSR contract, just in case `dsr` is ever made less than `1e27`.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/DAIInterestRateModel.sol",
      "content": "pragma solidity ^0.5.12;\n\nimport \"./JumpRateModel.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n  * @title Compound's DAIInterestRateModel Contract\n  * @author Compound\n  * @notice The parameterized model described in section 2.4 of the original Compound Protocol whitepaper\n  */\ncontract DAIInterestRateModel is JumpRateModel {\n    using SafeMath for uint;\n\n    /**\n     * @notice The additional margin per block separating the base borrow rate from the roof (0.05% / block)\n     */\n    uint public constant gapPerBlock = 0.05e16 / blocksPerYear;\n\n    /**\n     * @notice The assumed (1 - reserve factor) used to calculate the minimum borrow rate (reserve factor = 0.05)\n     */\n    uint public constant assumedOneMinusReserveFactorMantissa = 0.95e18;\n\n    PotLike pot;\n    JugLike jug;\n\n    /**\n     * @notice Construct an interest rate model\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     * @param pot_ The address of the Dai pot (where DSR is earned)\n     * @param jug_ The address of the Dai jug (where SF is kept)\n     */\n    constructor(uint jumpMultiplierPerYear, uint kink_, address pot_, address jug_) JumpRateModel(0, 0, jumpMultiplierPerYear, kink_) public {\n        pot = PotLike(pot_);\n        jug = JugLike(jug_);\n        poke();\n    }\n\n    /**\n     * @notice Calculates the current supply interest rate per block including the Dai savings rate\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amnount of reserves the market has\n     * @param reserveFactorMantissa The current reserve factor the market has\n     * @return The supply rate per block (as a percentage, and scaled by 1e18)\n     */\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) public view returns (uint) {\n        uint protocolRate = super.getSupplyRate(cash, borrows, reserves, reserveFactorMantissa);\n\n        uint underlying = cash.add(borrows).sub(reserves);\n        if (underlying == 0) {\n            return protocolRate;\n        } else {\n            uint cashRate = cash.mul(dsrPerBlock()).div(underlying);\n            return cashRate.add(protocolRate);\n        }\n    }\n\n    /**\n     * @notice Calculates the Dai savings rate per block\n     * @return The Dai savings rate per block (as a percentage, and scaled by 1e18)\n     */\n    function dsrPerBlock() public view returns (uint) {\n        return pot\n            .dsr().sub(1e27)  // scaled 1e27 aka RAY, and includes an extra \"ONE\" before subraction\n            .div(1e9) // descale to 1e18\n            .mul(15); // 15 seconds per block\n    }\n\n    /**\n     * @notice Resets the baseRate and multiplier per block based on the stability fee and Dai savings rate\n     */\n    function poke() public {\n        (uint duty, ) = jug.ilks(\"ETH-A\");\n        uint stabilityFeePerBlock = duty.add(jug.base()).sub(1e27).mul(1e18).div(1e27).mul(15);\n\n        // We ensure the minimum borrow rate >= DSR / (1 - reserve factor)\n        baseRatePerBlock = dsrPerBlock().mul(1e18).div(assumedOneMinusReserveFactorMantissa);\n\n        // The roof borrow rate is max(base rate, stability fee) + gap, from which we derive the slope\n        if (baseRatePerBlock < stabilityFeePerBlock) {\n            multiplierPerBlock = stabilityFeePerBlock.sub(baseRatePerBlock).add(gapPerBlock).mul(1e18).div(kink);\n        } else {\n            multiplierPerBlock = gapPerBlock.mul(1e18).div(kink);\n        }\n\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\n    }\n}\n\n\n/*** Maker Interfaces ***/\n\ncontract PotLike {\n    function chi() public view returns (uint);\n    function dsr() public view returns (uint);\n    function rho() public view returns (uint);\n    function pie(address) public view returns (uint);\n    function drip() public returns (uint);\n    function join(uint) public;\n    function exit(uint) public;\n}\n\ncontract JugLike {\n    // --- Data ---\n    struct Ilk {\n        uint256 duty;\n        uint256  rho;\n    }\n\n   mapping (bytes32 => Ilk) public ilks;\n   uint256 public base;\n}"
    }
  ]
}