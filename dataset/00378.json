{
  "Title": "M-1: Potential damages due to incorrect implementation of the ````ZIP```` algorithm",
  "Content": "# Issue M-1: Potential damages due to incorrect implementation of the ````ZIP```` algorithm \n\nSource: https://github.com/sherlock-audit/2024-03-woofi-swap-judging/issues/13 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nKingNFT\n## Summary\n````WooracleV2_2.fallback()```` is used to post zipped token price and state data to the contract for sake of gas saving. However, the first 4 bytes of zipped data are not reserved to distinguish the ````ZIP```` call and other normal call's function selector.\nThis would cause  ````ZIP```` calls to be accidentally interpreted as any other functions in the contract, result in unintended exceptions and potential damages.\n\n## Vulnerability Detail\nAccording solidity's official doc, there are two forms of ````fallback()```` function ````with```` or ````without```` parameter\n```solidity\nfallback () external [payable];\nfallback (bytes calldata _input) external [payable] returns (bytes memory _output);\n```\nreference: https://docs.soliditylang.org/en/v0.8.12/contracts.html#fallback-function\nIn ````WooracleV2_2```` contract, the second form is used, but the implementation misses an important note from the above doc\n>If the version with parameters is used, _input will contain the full data sent to the contract (equal to msg.data) \n  \nAs the ````_input```` data is equal to ````msg.data````, the solidity compiler would firstly check if first 4 bytes matches any normal function selectors, and would only execute ````fallback(_input)```` while no matching. Therefore, in zipped data, the first 4 bytes must be set to some reserved function selector, such as ````0x00000000````, with no collision to normal function selectors. And the real zipped data then starts from 5th byte.\n\nThe following coded PoC shows cases that the zipped data is accidentally interpreted as:\n\n>function renounceOwnership();\n>function setStaleDuration(uint256);\n>function postPrice(address,uint128);\n>function syncTS(uint256);\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Test} from \"../../lib/forge-std/src/Test.sol\";\nimport {console2} from \"../../lib/forge-std/src/console2.sol\";\nimport {WooracleV2_2} from \"../../contracts/wooracle/WooracleV2_2.sol\";\n\ncontract WooracleZipBugTest is Test {\n    WooracleV2_2 public oracle;\n\n    function setUp() public {\n        oracle = new WooracleV2_2();\n    }\n\n    function testNormalCase() public {\n        /* reference:\n            File: test\\typescript\\wooraclev2_zip_inherit.test.ts\n            97:     function _encode_woo_price() {\n            op = 0\n            len = 1\n            (base, p)\n            base: 6, woo token\n            price: 0.23020\n            23020000 (decimal = 8)\n        */\n        uint8 base = 6;\n        bytes memory zip = _makeZipData({\n            op: 0,\n            length: 1,\n            leadingBytesOfBody: abi.encodePacked(base, uint32((2302 << 5) + 4))\n        });\n        (bool success, ) = address(oracle).call(zip);\n        assertEq(success, true);\n        address wooAddr = oracle.getBase(6);\n        (uint256 price, bool feasible) = oracle.price(wooAddr);\n        assertEq(price, 23020000);\n        assertTrue(feasible);\n    }\n\n    function testCollisionWithRenounceOwnership() public {\n        // selector of \"renounceOwnership()\": \"0x715018a6\"\n        bytes memory zip = _makeZipData({\n            op: 1,\n            length: 0x31,\n            leadingBytesOfBody: abi.encodePacked(hex\"5018a6\")\n        });\n        assertEq(oracle.owner(), address(this));\n        (bool success, ) = address(oracle).call(zip);\n        assertEq(success, true);\n        assertEq(oracle.owner(), address(0));\n    }\n\n    function testCollisionWithSetStaleDuration() public {\n        // selector of \"setStaleDuration(uint256)\": \"0x99235fd4\"\n        bytes memory zip = _makeZipData({\n            op: 2,\n            length: 0x19,\n            leadingBytesOfBody: abi.encodePacked(hex\"235fd4\")\n        });\n        assertEq(oracle.staleDuration(), 120); // default: 2 mins\n        (bool success, ) = address(oracle).call(zip);\n        assertEq(success, true);\n        uint256 expectedStaleDuration;\n        assembly {\n            expectedStaleDuration := mload(add(zip, 36))\n        }\n        assertEq(oracle.staleDuration(), expectedStaleDuration);\n        assertTrue(expectedStaleDuration != 120);\n    }\n\n    function testCollisionWithPostPrice() public {\n        // selector of \"postPrice(address,uint128)\": \"0xd5bade07\"\n        bytes memory addressAndPrice = abi.encode(address(0x1111), uint256(100));\n        bytes memory zip = _makeZipData({\n            op: 3,\n            length: 0x15,\n            leadingBytesOfBody: abi.encodePacked(hex\"bade07\", addressAndPrice)\n        });\n        (bool success, ) = address(oracle).call(zip);\n        assertEq(success, true);\n        (uint256 price, bool feasible) = oracle.price(address(0x1111));\n        assertEq(price, 100);\n        assertTrue(feasible);\n    }\n\n    function testCollisionWithSyncTS() public {\n        // selector of \"syncTS(uint256)\": \"4f1f1999\"\n        uint256 timestamp = 12345678;\n        bytes memory zip = _makeZipData({\n            op: 1,\n            length: 0xf,\n            leadingBytesOfBody: abi.encodePacked(hex\"1f1999\", timestamp)\n        });\n        (bool success, ) = address(oracle).call(zip);\n        assertEq(success, true);\n        assertEq(oracle.timestamp(), timestamp);\n    }\n\n    function _makeZipData(\n        uint8 op,\n        uint8 length,\n        bytes memory leadingBytesOfBody\n    ) internal returns (bytes memory result) {\n        assertTrue(length < 2 ** 6);\n        assertTrue(op < 4);\n        bytes1 head = bytes1(uint8((op << 6) + (length & 0x3F)));\n        uint256 sizeOfItem = op == 0 || op == 2 ? 5 : 13;\n        uint256 sizeOfHead = 1;\n        uint256 sizeOfBody = sizeOfItem * length;\n        assertTrue(sizeOfBody >= leadingBytesOfBody.length);\n        result = bytes.concat(head, leadingBytesOfBody, _makePseudoRandomBytes(sizeOfBody - leadingBytesOfBody.length));\n        assertEq(result.length, sizeOfHead + sizeOfBody);\n    }\n\n    function _makePseudoRandomBytes(uint256 length) internal returns (bytes memory result) {\n        uint256 words = (length + 31) / 32;\n        result = new bytes(words * 32);\n        for (uint256 i; i < words; ++i) {\n            bytes32 rand = keccak256(abi.encode(block.timestamp + i));\n            assembly {\n                mstore(add(add(result, 32), mul(i, 32)), rand)\n            }\n        }\n\n        assembly {\n            mstore(result, length) // change to required length\n        }\n        assertEq(length, result.length);\n    }\n}\n\n```\n\nAnd the logs:\n```solidity\n2024-03-woofi-swap\\WooPoolV2> forge test --match-contract WooracleZipBugTest -vv\n[⠢] Compiling...No files changed, compilation skipped\n[⠆] Compiling...\n\nRunning 5 tests for test/foundry/WooracleZipBug.t.sol:WooracleZipBugTest\n[PASS] testCollisionWithPostPrice() (gas: 48643)\n[PASS] testCollisionWithRenounceOwnership() (gas: 21301)\n[PASS] testCollisionWithSetStaleDuration() (gas: 18289)\n[PASS] testCollisionWithSyncTS() (gas: 35302)\n[PASS] testNormalCase() (gas: 48027)\nTest result: ok. 5 passed; 0 failed; 0 skipped; finished in 2.13ms\n\nRan 1 test suites: 5 tests passed, 0 failed, 0 skipped (5 total tests)\n```\n\n\n## Impact\nThis bug would result in unintended exceptions and potential damages such as:\n1) Collision with normal price post functions might cause users' trades executed on incorrect price and suffer losses.\n2) Collision with any view function might cause price post to fail silently and hold on trade processing until next submission, and users' trades might be executed on a delayed inexact price.\n3) Collision with ````setStaleDuration()```` might cause price freshness check to break down.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-03-woofi-swap/blob/main/WooPoolV2/contracts/wooracle/WooracleV2_2.sol#L394\n\n## Tool used\n\nManual Review\n\n## Recommendation\n```diff\ndiff --git a/WooPoolV2/contracts/wooracle/WooracleV2_2.sol b/WooPoolV2/contracts/wooracle/WooracleV2_2.sol\nindex 9e66c63..4a9138f 100644\n--- a/WooPoolV2/contracts/wooracle/WooracleV2_2.sol\n+++ b/WooPoolV2/contracts/wooracle/WooracleV2_2.sol\n@@ -416,9 +416,10 @@ contract WooracleV2_2 is Ownable, IWooracleV2 {\n         */\n\n         uint256 x = _input.length;\n-        require(x > 0, \"WooracleV2_2: !calldata\");\n+        require(x > 4, \"WooracleV2_2: !calldata\");\n+        require(bytes4(_input[0:4]) == bytes4(hex\"00000000\"));\n\n-        uint8 firstByte = uint8(bytes1(_input[0]));\n+        uint8 firstByte = uint8(bytes1(_input[5]));\n         uint8 op = firstByte >> 6; // 11000000\n         uint8 len = firstByte & 0x3F; // 00111111\n\n@@ -428,12 +429,12 @@ contract WooracleV2_2 is Ownable, IWooracleV2 {\n             uint128 p;\n\n             for (uint256 i = 0; i < len; ++i) {\n-                base = getBase(uint8(bytes1(_input[1 + i * 5:1 + i * 5 + 1])));\n-                p = _decodePrice(uint32(bytes4(_input[1 + i * 5 + 1:1 + i * 5 + 5])));\n+                base = getBase(uint8(bytes1(_input[5 + i * 5:5 + i * 5 + 1])));\n+                p = _decodePrice(uint32(bytes4(_input[5 + i * 5 + 1:5 + i * 5 + 5])));\n                 infos[base].price = p;\n             }\n\n-            timestamp = (op == 0) ? block.timestamp : uint256(uint32(bytes4(_input[1 + len * 5:1 + len * 5 + 4])));\n+            timestamp = (op == 0) ? block.timestamp : uint256(uint32(bytes4(_input[5 + len * 5:5 + len * 5 + 4])));\n         } else if (op == 1 || op == 3) {\n             // post states list\n             address base;\n@@ -442,14 +443,14 @@ contract WooracleV2_2 is Ownable, IWooracleV2 {\n             uint64 k;\n\n             for (uint256 i = 0; i < len; ++i) {\n-                base = getBase(uint8(bytes1(_input[1 + i * 9:1 + i * 9 + 1])));\n-                p = _decodePrice(uint32(bytes4(_input[1 + i * 9 + 1:1 + i * 9 + 5])));\n-                s = _decodeKS(uint16(bytes2(_input[1 + i * 9 + 5:1 + i * 9 + 7])));\n-                k = _decodeKS(uint16(bytes2(_input[1 + i * 9 + 7:1 + i * 9 + 9])));\n+                base = getBase(uint8(bytes1(_input[5 + i * 9:5 + i * 9 + 1])));\n+                p = _decodePrice(uint32(bytes4(_input[5 + i * 9 + 1:5 + i * 9 + 5])));\n+                s = _decodeKS(uint16(bytes2(_input[5 + i * 9 + 5:5 + i * 9 + 7])));\n+                k = _decodeKS(uint16(bytes2(_input[5 + i * 9 + 7:5 + i * 9 + 9])));\n                 _setState(base, p, s, k);\n             }\n\n-            timestamp = (op == 1) ? block.timestamp : uint256(uint32(bytes4(_input[1 + len * 9:1 + len * 9 + 4])));\n+            timestamp = (op == 1) ? block.timestamp : uint256(uint32(bytes4(_input[5 + len * 9:5 + len * 9 + 4])));\n         } else {\n             revert(\"WooracleV2_2: !op\");\n         }\n```\n\n\n\n## Discussion\n\n**fb-alexcq**\n\n- First your suggested issue right; it may have function collisions. Thanks for pointing it out.\n- More importantly, the frequency is negligible. We have 30 functions there, so collision probability is 30/(2^32) = 0.000000006984919;  We typically update our Wooracle in 5 seconds, so a collision only happen once every 1000,000,000 seconds , that is 31 years: https://calculat.io/en/date/seconds/1000000000\n- From engineering perspective: we utilize this zip fallback function to save calldata's gas consumption, so it's impossible to add another plain 4 bytes to only avoid collision. Even with collusion, our offline script can catch the tx failure and resend it again, it won't cause any disaster.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/277",
  "Code": [
    {
      "filename": "WooPoolV2/contracts/wooracle/WooracleV2_2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.14;\n\n/*\n\n░██╗░░░░░░░██╗░█████╗░░█████╗░░░░░░░███████╗██╗\n░██║░░██╗░░██║██╔══██╗██╔══██╗░░░░░░██╔════╝██║\n░╚██╗████╗██╔╝██║░░██║██║░░██║█████╗█████╗░░██║\n░░████╔═████║░██║░░██║██║░░██║╚════╝██╔══╝░░██║\n░░╚██╔╝░╚██╔╝░╚█████╔╝╚█████╔╝░░░░░░██║░░░░░██║\n░░░╚═╝░░░╚═╝░░░╚════╝░░╚════╝░░░░░░░╚═╝░░░░░╚═╝\n\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 WooTrade\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nimport \"../interfaces/IWooracleV2.sol\";\nimport \"../interfaces/AggregatorV3Interface.sol\";\n\nimport {TransferHelper} from \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\n// OpenZeppelin contracts\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title Wooracle V2.2 contract for WooPPV2\n/// subversion 1 change: no timestamp update for posting price from WooPP.\n/// subversion 2 change: support legacy postState utilizing block.timestamp\ncontract WooracleV2_2 is Ownable, IWooracleV2 {\n    /* ----- State variables ----- */\n\n    // 128 + 64 + 64 = 256 bits (slot size)\n    struct TokenInfo {\n        uint128 price; // as chainlink oracle (e.g. decimal = 8)                zip: 32 bits = (27, 5)\n        uint64 coeff; // k: decimal = 18.    18.4 * 1e18                        zip: 16 bits = (11, 5), 2^11 = 2048\n        uint64 spread; // s: decimal = 18.   spread <= 2e18   18.4 * 1e18       zip: 16 bits = (11, 5)\n    }\n\n    struct CLOracle {\n        address oracle;\n        uint8 decimal;\n        bool cloPreferred;\n    }\n\n    mapping(address => TokenInfo) public infos;\n    mapping(address => CLOracle) public clOracles;\n\n    address public quoteToken;\n    uint256 public timestamp;\n\n    uint256 public staleDuration;\n    uint64 public bound;\n\n    address public wooPP;\n\n    mapping(address => bool) public isAdmin;\n\n    mapping(uint8 => address) public basesMap;\n\n    constructor() {\n        staleDuration = uint256(120); // default: 2 mins\n        bound = uint64(1e16); // 1%\n    }\n\n    modifier onlyAdmin() {\n        require(owner() == msg.sender || isAdmin[msg.sender], \"WooracleV2_2: !Admin\");\n        _;\n    }\n\n    /* ----- External Functions ----- */\n\n    function setWooPP(address _wooPP) external onlyAdmin {\n        wooPP = _wooPP;\n    }\n\n    function setAdmin(address _addr, bool _flag) external onlyOwner {\n        isAdmin[_addr] = _flag;\n    }\n\n    /// @dev Set the quote token address.\n    /// @param _oracle the token address\n    function setQuoteToken(address _quote, address _oracle) external onlyAdmin {\n        quoteToken = _quote;\n        CLOracle storage cloRef = clOracles[_quote];\n        cloRef.oracle = _oracle;\n        cloRef.decimal = AggregatorV3Interface(_oracle).decimals();\n    }\n\n    function setBound(uint64 _bound) external onlyOwner {\n        bound = _bound;\n    }\n\n    function setCLOracle(\n        address _token,\n        address _oracle,\n        bool _cloPreferred\n    ) external onlyAdmin {\n        CLOracle storage cloRef = clOracles[_token];\n        cloRef.oracle = _oracle;\n        cloRef.decimal = AggregatorV3Interface(_oracle).decimals();\n        cloRef.cloPreferred = _cloPreferred;\n    }\n\n    function setCloPreferred(address _token, bool _cloPreferred) external onlyAdmin {\n        CLOracle storage cloRef = clOracles[_token];\n        cloRef.cloPreferred = _cloPreferred;\n    }\n\n    /// @dev Set the staleDuration.\n    /// @param _staleDuration the new stale duration\n    function setStaleDuration(uint256 _staleDuration) external onlyAdmin {\n        staleDuration = _staleDuration;\n    }\n\n    /// @dev Update the base token prices.\n    /// @param _base the baseToken address\n    /// @param _price the new prices for the base token\n    function postPrice(address _base, uint128 _price) external onlyAdmin {\n        infos[_base].price = _price;\n        if (msg.sender != wooPP) {\n            timestamp = block.timestamp;\n        }\n    }\n\n    /// @dev Update the base token prices.\n    /// @param _base the baseToken address\n    /// @param _price the new prices for the base token\n    function postPrice(\n        address _base,\n        uint128 _price,\n        uint256 _ts\n    ) external onlyAdmin {\n        infos[_base].price = _price;\n        timestamp = _ts;\n    }\n\n    /// @dev batch update baseTokens prices\n    /// @param _bases list of baseToken address\n    /// @param _prices the updated prices list\n    function postPriceList(\n        address[] calldata _bases,\n        uint128[] calldata _prices,\n        uint256 _ts\n    ) external onlyAdmin {\n        uint256 length = _bases.length;\n        require(length == _prices.length, \"WooracleV2_2: length_INVALID\");\n\n        unchecked {\n            for (uint256 i = 0; i < length; i++) {\n                infos[_bases[i]].price = _prices[i];\n            }\n        }\n\n        timestamp = _ts;\n    }\n\n    /// @dev update the state of the given base token.\n    /// @param _base baseToken address\n    /// @param _price the new prices\n    /// @param _spread the new spreads\n    /// @param _coeff the new slippage coefficent\n    function postState(\n        address _base,\n        uint128 _price,\n        uint64 _spread,\n        uint64 _coeff\n    ) external onlyAdmin {\n        _setState(_base, _price, _spread, _coeff);\n        timestamp = block.timestamp;\n    }\n\n    /// @dev update the state of the given base token with the offchain timestamp.\n    /// @param _base baseToken address\n    /// @param _price the new prices\n    /// @param _spread the new spreads\n    /// @param _coeff the new slippage coefficent\n    /// @param _ts the local timestamp\n    function postState(\n        address _base,\n        uint128 _price,\n        uint64 _spread,\n        uint64 _coeff,\n        uint256 _ts\n    ) external onlyAdmin {\n        _setState(_base, _price, _spread, _coeff);\n        timestamp = _ts;\n    }\n\n    /// @dev batch update the prices, spreads and slipagge coeffs info.\n    /// @param _bases list of baseToken address\n    /// @param _prices the prices list\n    /// @param _spreads the spreads list\n    /// @param _coeffs the slippage coefficent list\n    function postStateList(\n        address[] calldata _bases,\n        uint128[] calldata _prices,\n        uint64[] calldata _spreads,\n        uint64[] calldata _coeffs,\n        uint256 _ts\n    ) external onlyAdmin {\n        uint256 length = _bases.length;\n        unchecked {\n            for (uint256 i = 0; i < length; i++) {\n                _setState(_bases[i], _prices[i], _spreads[i], _coeffs[i]);\n            }\n        }\n        timestamp = _ts;\n    }\n\n    /*\n        Price logic:\n        - woPrice: wooracle price\n        - cloPrice: chainlink price\n\n        woFeasible is, price > 0 and price timestamp NOT stale\n\n        when woFeasible && priceWithinBound     -> woPrice, feasible\n        when woFeasible && !priceWithinBound    -> woPrice, infeasible\n        when !woFeasible && clo_preferred       -> cloPrice, feasible\n        when !woFeasible && !clo_preferred      -> cloPrice, infeasible\n    */\n    function price(address _base) public view override returns (uint256 priceOut, bool feasible) {\n        uint256 woPrice_ = uint256(infos[_base].price);\n        uint256 woPriceTimestamp = timestamp;\n\n        (uint256 cloPrice_, ) = _cloPriceInQuote(_base, quoteToken);\n\n        bool woFeasible = woPrice_ != 0 && block.timestamp <= (woPriceTimestamp + staleDuration);\n        bool woPriceInBound = cloPrice_ == 0 ||\n            ((cloPrice_ * (1e18 - bound)) / 1e18 <= woPrice_ && woPrice_ <= (cloPrice_ * (1e18 + bound)) / 1e18);\n\n        if (woFeasible) {\n            priceOut = woPrice_;\n            feasible = woPriceInBound;\n        } else {\n            priceOut = clOracles[_base].cloPreferred ? cloPrice_ : 0;\n            feasible = priceOut != 0;\n        }\n    }\n\n    /// @notice the price decimal for the specified base token\n    function decimals(address) external pure override returns (uint8) {\n        return 8;\n    }\n\n    function cloPrice(address _base) external view override returns (uint256 refPrice, uint256 refTimestamp) {\n        return _cloPriceInQuote(_base, quoteToken);\n    }\n\n    function isWoFeasible(address _base) external view override returns (bool) {\n        return infos[_base].price != 0 && block.timestamp <= (timestamp + staleDuration);\n    }\n\n    function syncTS() external onlyAdmin {\n        timestamp = block.timestamp;\n    }\n\n    function syncTS(uint256 _ts) external onlyAdmin {\n        timestamp = _ts;\n    }\n\n    function debugTS()\n        external\n        view\n        returns (\n            uint256 n,\n            uint256 bs,\n            uint256 ts,\n            bool f\n        )\n    {\n        n = block.number;\n        bs = block.timestamp;\n        ts = timestamp;\n        f = block.timestamp <= (timestamp + staleDuration);\n    }\n\n    function woSpread(address _base) external view override returns (uint64) {\n        return infos[_base].spread;\n    }\n\n    function woCoeff(address _base) external view override returns (uint64) {\n        return infos[_base].coeff;\n    }\n\n    // Wooracle price of the base token\n    function woPrice(address _base) external view override returns (uint128 priceOut, uint256 priceTimestampOut) {\n        priceOut = infos[_base].price;\n        priceTimestampOut = timestamp;\n    }\n\n    function woState(address _base) external view override returns (State memory) {\n        TokenInfo memory info = infos[_base];\n        return\n            State({\n                price: info.price,\n                spread: info.spread,\n                coeff: info.coeff,\n                woFeasible: (info.price != 0 && block.timestamp <= (timestamp + staleDuration))\n            });\n    }\n\n    function state(address _base) external view override returns (State memory) {\n        TokenInfo memory info = infos[_base];\n        (uint256 basePrice, bool feasible) = price(_base);\n        return State({price: uint128(basePrice), spread: info.spread, coeff: info.coeff, woFeasible: feasible});\n    }\n\n    function cloAddress(address _base) external view override returns (address clo) {\n        clo = clOracles[_base].oracle;\n    }\n\n    /* ----- Private Functions ----- */\n\n    function _setState(\n        address _base,\n        uint128 _price,\n        uint64 _spread,\n        uint64 _coeff\n    ) internal {\n        TokenInfo storage info = infos[_base];\n        info.price = _price;\n        info.spread = _spread;\n        info.coeff = _coeff;\n    }\n\n    function _cloPriceInQuote(address _fromToken, address _toToken)\n        internal\n        view\n        returns (uint256 refPrice, uint256 refTimestamp)\n    {\n        address baseOracle = clOracles[_fromToken].oracle;\n        if (baseOracle == address(0)) {\n            return (0, 0);\n        }\n        address quoteOracle = clOracles[_toToken].oracle;\n        uint8 quoteDecimal = clOracles[_toToken].decimal;\n\n        (, int256 rawBaseRefPrice, , uint256 baseUpdatedAt, ) = AggregatorV3Interface(baseOracle).latestRoundData();\n        (, int256 rawQuoteRefPrice, , uint256 quoteUpdatedAt, ) = AggregatorV3Interface(quoteOracle).latestRoundData();\n        uint256 baseRefPrice = uint256(rawBaseRefPrice);\n        uint256 quoteRefPrice = uint256(rawQuoteRefPrice);\n\n        // NOTE: Assume wooracle token decimal is same as chainlink token decimal.\n        uint256 ceoff = uint256(10)**quoteDecimal;\n        refPrice = (baseRefPrice * ceoff) / quoteRefPrice;\n        refTimestamp = baseUpdatedAt >= quoteUpdatedAt ? quoteUpdatedAt : baseUpdatedAt;\n    }\n\n    /* ----- Zip Related Functions ----- */\n\n    function setBase(uint8 _id, address _base) external onlyAdmin {\n        require(getBase(_id) == address(0), \"WooracleV2_2: !id_SET_ALREADY\");\n        basesMap[_id] = _base;\n    }\n\n    function getBase(uint8 _id) public view returns (address) {\n        address[5] memory CONST_BASES = [\n            // mload\n            // NOTE: Update token address for different chains\n            0x82aF49447D8a07e3bd95BD0d56f35241523fBab1, // WETH\n            0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f, // WBTC\n            0xcAFcD85D8ca7Ad1e1C6F82F651fA15E33AEfD07b, // WOO\n            0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9, // USDT\n            0x912CE59144191C1204E64559FE8253a0e49E6548 // ARB\n        ];\n\n        return _id < CONST_BASES.length ? CONST_BASES[_id] : basesMap[_id];\n    }\n\n    // https://docs.soliditylang.org/en/v0.8.12/contracts.html#fallback-function\n    // prettier-ignore\n    fallback (bytes calldata _input) external onlyAdmin returns (bytes memory _output) {\n        /*\n            2 bit:  0: post prices,\n                    1: post states,\n                    2: post prices with local timestamp\n                    3: post states with local timestamp\n            6 bits: length\n\n            post prices:\n               [price] -->\n                  base token: 8 bites (1 byte)\n                  price data: 32 bits = (27, 5)\n\n            post states:\n               [states] -->\n                  base token: 8 bites (1 byte)\n                  price:      32 bits (4 bytes) = (27, 5)\n                  k coeff:    16 bits (2 bytes) = (11, 5)\n                  s spread:   16 bits (2 bytes) = (11, 5)\n\n            4 bytes (32bits): timestamp\n                MAX: 2^32-1 = 4,294,967,295 = Feb 7, 2106 6:28:15 AM (~83 years away)\n        */\n\n        uint256 x = _input.length;\n        require(x > 0, \"WooracleV2_2: !calldata\");\n\n        uint8 firstByte = uint8(bytes1(_input[0]));\n        uint8 op = firstByte >> 6; // 11000000\n        uint8 len = firstByte & 0x3F; // 00111111\n\n        if (op == 0 || op == 2) {\n            // post prices list\n            address base;\n            uint128 p;\n\n            for (uint256 i = 0; i < len; ++i) {\n                base = getBase(uint8(bytes1(_input[1 + i * 5:1 + i * 5 + 1])));\n                p = _decodePrice(uint32(bytes4(_input[1 + i * 5 + 1:1 + i * 5 + 5])));\n                infos[base].price = p;\n            }\n\n            timestamp = (op == 0) ? block.timestamp : uint256(uint32(bytes4(_input[1 + len * 5:1 + len * 5 + 4])));\n        } else if (op == 1 || op == 3) {\n            // post states list\n            address base;\n            uint128 p;\n            uint64 s;\n            uint64 k;\n\n            for (uint256 i = 0; i < len; ++i) {\n                base = getBase(uint8(bytes1(_input[1 + i * 9:1 + i * 9 + 1])));\n                p = _decodePrice(uint32(bytes4(_input[1 + i * 9 + 1:1 + i * 9 + 5])));\n                s = _decodeKS(uint16(bytes2(_input[1 + i * 9 + 5:1 + i * 9 + 7])));\n                k = _decodeKS(uint16(bytes2(_input[1 + i * 9 + 7:1 + i * 9 + 9])));\n                _setState(base, p, s, k);\n            }\n\n            timestamp = (op == 1) ? block.timestamp : uint256(uint32(bytes4(_input[1 + len * 9:1 + len * 9 + 4])));\n        } else {\n            revert(\"WooracleV2_2: !op\");\n        }\n    }\n\n    function _decodePrice(uint32 b) internal pure returns (uint128) {\n        return uint128((b >> 5) * (10**(b & 0x1F))); // 0x1F = 00011111\n    }\n\n    function _decodeKS(uint16 b) internal pure returns (uint64) {\n        return uint64((b >> 5) * (10**(b & 0x1F)));\n    }\n\n    function inCaseTokenGotStuck(address stuckToken) external onlyAdmin {\n        if (stuckToken == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n            TransferHelper.safeTransferETH(owner(), address(this).balance);\n        } else {\n            uint256 amount = IERC20(stuckToken).balanceOf(address(this));\n            TransferHelper.safeTransfer(stuckToken, owner(), amount);\n        }\n    }\n}"
    }
  ]
}