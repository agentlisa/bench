{
  "Title": "Incorrect state transition may cause vault in stuck",
  "Content": "# Incorrect state transition may cause vault in stuck\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXCompound.sol#L127-L136\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXCompound.sol#L127-L136</a>\n\n\n# Summary\n\nIncorrect state transition may cause vault in stuck under `processCompoundCancellation` scenario.\n\n## Vulnerability Details\n\nWhen keeper execute `compound` action and GMXCallback return `afterDepositCancellation` action, then protocol will call `GMXCompound#processCompoundCancellation` function to change vault status.\n\nHowever, vault status is changed to `GMXTypes.Status.Compound_Failed` instead of `GMXTypes.Status.Open` by `GMXCompound#processCompoundCancellation` function, which is different with document described below:\n\nhttps://github.com/Cyfrin/2023-10-SteadeFi/blob/main/docs/sequences/strategy-gmx-compound-sequence-detailed.md\n\nand `All scenarios should be handled to ensure vault eventually returns to an Open status. Consider how a scenario might lead to a stuck vault (other statuses).`\n\n## Impact\n\nVault may stuck in unexpected state after `processCompoundCancellation` action.\n\n## Tools Used\n\nvscode, Manual Review\n\n## Recommendations\n\nChange the vault status to `Open` instead of `Compound_Failed` when call `GMXCompound#processCompoundCancellation` function.\n",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXCompound.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\n\n/**\n  * @title GMXCompound\n  * @author Steadefi\n  * @notice Re-usable library functions for compound operations for Steadefi leveraged vaults\n*/\nlibrary GMXCompound {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================== EVENTS ========================= */\n\n  event CompoundCompleted();\n  event CompoundCancelled();\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function compound(\n    GMXTypes.Store storage self,\n    GMXTypes.CompoundParams memory cp\n  ) external {\n    // Transfer any tokenA/B from trove to vault\n    if (self.tokenA.balanceOf(address(self.trove)) > 0) {\n      self.tokenA.safeTransferFrom(\n        address(self.trove),\n        address(this),\n        self.tokenA.balanceOf(address(self.trove))\n      );\n    }\n    if (self.tokenB.balanceOf(address(self.trove)) > 0) {\n      self.tokenB.safeTransferFrom(\n        address(self.trove),\n        address(this),\n        self.tokenB.balanceOf(address(self.trove))\n      );\n    }\n\n    uint256 _tokenInAmt = IERC20(cp.tokenIn).balanceOf(address(this));\n\n    // Only compound if tokenIn amount is more than 0\n    if (_tokenInAmt > 0) {\n      self.refundee = payable(msg.sender);\n\n      self.compoundCache.compoundParams = cp;\n\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = cp.tokenIn;\n      _sp.tokenOut = cp.tokenOut;\n      _sp.amountIn = _tokenInAmt;\n      _sp.amountOut = 0; // amount out minimum calculated in Swap\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = cp.deadline;\n\n      GMXManager.swapExactTokensForTokens(self, _sp);\n\n      GMXTypes.AddLiquidityParams memory _alp;\n\n      _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n      _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n\n      self.compoundCache.depositValue = GMXReader.convertToUsdValue(\n        self,\n        address(self.tokenA),\n        self.tokenA.balanceOf(address(this))\n      )\n      + GMXReader.convertToUsdValue(\n        self,\n        address(self.tokenB),\n        self.tokenB.balanceOf(address(this))\n      );\n\n      GMXChecks.beforeCompoundChecks(self);\n\n      self.status = GMXTypes.Status.Compound;\n\n      _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n        self,\n        self.compoundCache.depositValue,\n        cp.slippage\n      );\n\n      _alp.executionFee = cp.executionFee;\n\n      self.compoundCache.depositKey = GMXManager.addLiquidity(\n        self,\n        _alp\n      );\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processCompound(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessCompoundChecks(self);\n\n    self.status = GMXTypes.Status.Open;\n\n    emit CompoundCompleted();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processCompoundCancellation(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessCompoundCancellationChecks(self);\n\n    self.status = GMXTypes.Status.Compound_Failed;\n\n    emit CompoundCancelled();\n  }\n}"
    }
  ]
}