{
  "Title": "[H-07] Usage of `BalancerStrategy.updateCache` will cause single sided Loss, discount to Depositor and to OverBorrow from Singularity",
  "Content": "\nThe BalancerStrategy uses a cached value to determine it's balance in pool for which it takes Single Sided Exposure.\n\nThis means that the Strategy has some BPT tokens, but to price them, it's calling `vault.queryExit` which simulates withdrawing the LP in a single sided manner.\n\nDue to the single sided exposure, it's trivial to perform a Swap, that will change the internal balances of the pool, as a way to cause the Strategy to discount it's tokens.\n\nBy the same process, we can send more ETH as a way to inflate the value of the Strategy, which will then be cached.\n\nSince `_currentBalance` is a view-function, the YieldBox will accept these inflated values without a way to dispute them\n\n<https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/05ba7108a83c66dada98bc5bc75cf18004f2a49b/contracts/balancer/BalancerStrategy.sol#L138-L147>\n\n```solidity\n    function _deposited(uint256 amount) internal override nonReentrant {\n        uint256 queued = wrappedNative.balanceOf(address(this));\n        if (queued > depositThreshold) {\n            _vaultDeposit(queued);\n            emit AmountDeposited(queued);\n        }\n        emit AmountQueued(amount);\n\n        updateCache(); /// @audit this is updated too late (TODO PROOF)\n    }\n```\n\n### POC\n\n*   Imbalance the pool (Sandwich A)\n*   Update `updateCache`\n*   Deposit into YieldBox, YieldBox is using a `view` function, meaning it will use the manipulated strategy `_currentBalance`\n*   `_deposited` trigger an `updateCache`\n*   Rebalance the Pool (Sandwich B)\n*   Call `updateCache` again to bring back the rate to a higher value\n*   Withdraw at a gain\n\n### Result\n\nImbalance Up -> Allows OverBorrowing and causes insolvency to the protocol\nImbalance Down -> Liquidate Borrowers unfairly at a profit to the liquidator\nSandwhiching the Imbalance can be used to extract value from the strategy and steal user deposits as well\n\n### Mitigation\n\nUse fair reserve math, avoid single sided exposure (use the LP token as underlying, not one side of it)\n\n**[cryptotechmaker (Tapioca) confirmed](https://github.com/code-423n4/2023-07-tapioca-findings/issues/1447#issuecomment-1707823835)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/balancer/BalancerStrategy.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\n\nimport \"tapioca-sdk/dist/contracts/YieldBox/contracts/strategies/BaseStrategy.sol\";\nimport \"./interfaces/IBalancerVault.sol\";\nimport \"./interfaces/IBalancerPool.sol\";\nimport \"./interfaces/IBalancerHelpers.sol\";\n\n/*\n\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n*/\n\ncontract BalancerStrategy is BaseERC20Strategy, BoringOwnable, ReentrancyGuard {\n    using BoringERC20 for IERC20;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    IERC20 public immutable wrappedNative;\n    IERC20 public immutable bal;\n\n    bytes32 public poolId;\n    IBalancerVault public immutable vault;\n    IBalancerPool public immutable pool; //lp token\n    IBalancerHelpers public immutable helpers;\n    address[] public rewardTokens;\n\n    /// @notice Queues tokens up to depositThreshold\n    /// @dev When the amount of tokens is greater than the threshold, a deposit operation to Yearn is performed\n    uint256 public depositThreshold;\n\n    uint256 private _cachedCalculatedAmount;\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    event RewardTokens(uint256 _count);\n    event DepositThreshold(uint256 _old, uint256 _new);\n    event AmountQueued(uint256 amount);\n    event AmountDeposited(uint256 amount);\n    event AmountWithdrawn(address indexed to, uint256 amount);\n\n    constructor(\n        IYieldBox _yieldBox,\n        address _token,\n        address _vault,\n        bytes32 _poolId,\n        address _bal,\n        address _helpers\n    ) BaseERC20Strategy(_yieldBox, _token) {\n        wrappedNative = IERC20(_token);\n        bal = IERC20(_bal);\n\n        vault = IBalancerVault(_vault);\n        poolId = _poolId;\n\n        (address _stablePool, ) = vault.getPool(_poolId);\n        pool = IBalancerPool(_stablePool);\n\n        helpers = IBalancerHelpers(_helpers);\n\n        wrappedNative.approve(_vault, type(uint256).max);\n        IERC20(address(pool)).approve(_vault, type(uint256).max);\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice Returns the name of this strategy\n    function name() external pure override returns (string memory name_) {\n        return \"Balancer\";\n    }\n\n    /// @notice Returns the description of this strategy\n    function description()\n        external\n        pure\n        override\n        returns (string memory description_)\n    {\n        return \"Balancer strategy for wrapped native assets\";\n    }\n\n    /// @notice returns compounded amounts in wrappedNative\n    function compoundAmount() external pure returns (uint256 result) {\n        return 0;\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice Sets the deposit threshold\n    /// @param amount The new threshold amount\n    function setDepositThreshold(uint256 amount) external onlyOwner {\n        emit DepositThreshold(depositThreshold, amount);\n        depositThreshold = amount;\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    function compound(bytes memory) public {}\n\n    /// @notice withdraws everythig from the strategy\n    function emergencyWithdraw() external onlyOwner returns (uint256 result) {\n        uint256 toWithdraw = updateCache();\n        toWithdraw = toWithdraw - (toWithdraw * 50) / 10_000; //0.5%\n\n        result = _vaultWithdraw(toWithdraw);\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _currentBalance() internal view override returns (uint256 amount) {\n        uint256 queued = wrappedNative.balanceOf(address(this));\n\n        return _cachedCalculatedAmount + queued;\n    }\n\n    /// @dev deposits to Balancer or queues tokens if the 'depositThreshold' has not been met yet\n    ///      - when depositing to Balancer, cToken is minted to this contract\n    function _deposited(uint256 amount) internal override nonReentrant {\n        uint256 queued = wrappedNative.balanceOf(address(this));\n        if (queued > depositThreshold) {\n            _vaultDeposit(queued);\n            emit AmountDeposited(queued);\n        }\n        emit AmountQueued(amount);\n\n        updateCache();\n    }\n\n    function _vaultDeposit(uint256 amount) private {\n        uint256 lpBalanceBefore = pool.balanceOf(address(this));\n\n        (address[] memory poolTokens, , ) = vault.getPoolTokens(poolId);\n\n        int256 index = -1;\n        uint256[] memory maxAmountsIn = new uint256[](poolTokens.length);\n        for (uint256 i = 0; i < poolTokens.length; i++) {\n            if (poolTokens[i] == address(wrappedNative)) {\n                maxAmountsIn[i] = amount;\n                index = int256(i);\n            } else {\n                maxAmountsIn[i] = 0;\n            }\n        }\n\n        IBalancerVault.JoinPoolRequest memory joinPoolRequest;\n        joinPoolRequest.assets = poolTokens;\n        joinPoolRequest.maxAmountsIn = maxAmountsIn;\n        joinPoolRequest.fromInternalBalance = false;\n        joinPoolRequest.userData = abi.encode(1, maxAmountsIn);\n\n        (uint256 bptOut, ) = helpers.queryJoin(\n            poolId,\n            address(this),\n            address(this),\n            joinPoolRequest\n        );\n        bptOut = bptOut - (bptOut * 50) / 10_000; //0.5%\n\n        joinPoolRequest.userData = abi.encode(2, bptOut, uint256(index));\n\n        vault.joinPool(poolId, address(this), address(this), joinPoolRequest);\n        uint256 lpBalanceAfter = pool.balanceOf(address(this));\n\n        require(\n            lpBalanceAfter > lpBalanceBefore,\n            \"BalancerStrategy: vault deposit failed\"\n        );\n    }\n\n    /// @dev burns yToken in exchange of Token and withdraws from Yearn Vault\n    function _withdraw(\n        address to,\n        uint256 amount\n    ) internal override nonReentrant {\n        uint256 available = _currentBalance();\n        require(available >= amount, \"BalancerStrategy: amount not valid\");\n\n        uint256 queued = wrappedNative.balanceOf(address(this));\n        if (amount > queued) {\n            uint256 pricePerShare = pool.getRate();\n            uint256 decimals = IStrictERC20(address(pool)).decimals();\n            uint256 toWithdraw = (((amount - queued) * (10 ** decimals)) /\n                pricePerShare);\n\n            _vaultWithdraw(toWithdraw);\n        }\n\n        require(\n            amount <= wrappedNative.balanceOf(address(this)),\n            \"BalancerStrategy: not enough\"\n        );\n        wrappedNative.safeTransfer(to, amount);\n        updateCache();\n\n        emit AmountWithdrawn(to, amount);\n    }\n\n    function _vaultWithdraw(uint256 amount) private returns (uint256) {\n        uint256 wrappedNativeBalanceBefore = wrappedNative.balanceOf(\n            address(this)\n        );\n        (address[] memory poolTokens, , ) = vault.getPoolTokens(poolId);\n        int256 index = -1;\n        uint256[] memory minAmountsOut = new uint256[](poolTokens.length);\n        for (uint256 i = 0; i < poolTokens.length; i++) {\n            if (poolTokens[i] == address(wrappedNative)) {\n                minAmountsOut[i] = amount;\n                index = int256(i);\n            } else {\n                minAmountsOut[i] = 0;\n            }\n        }\n\n        IBalancerVault.ExitPoolRequest memory exitRequest;\n        exitRequest.assets = poolTokens;\n        exitRequest.minAmountsOut = minAmountsOut;\n        exitRequest.toInternalBalance = false;\n        exitRequest.userData = abi.encode(\n            2,\n            exitRequest.minAmountsOut,\n            pool.balanceOf(address(this))\n        );\n\n        (uint256 bptIn, ) = helpers.queryExit(\n            poolId,\n            address(this),\n            payable(this),\n            exitRequest\n        );\n        bptIn = bptIn + (bptIn * 250) / 10_000; //2.5%\n        uint256 maxBpt = pool.balanceOf(address(this));\n        if (bptIn > maxBpt) {\n            bptIn = maxBpt;\n        }\n        exitRequest.userData = abi.encode(0, bptIn, index);\n\n        vault.exitPool(poolId, address(this), payable(this), exitRequest);\n\n        uint256 wrappedNativeBalanceAfter = wrappedNative.balanceOf(\n            address(this)\n        );\n\n        require(\n            wrappedNativeBalanceAfter > wrappedNativeBalanceBefore,\n            \"BalancerStrategy: vault withdrawal failed\"\n        );\n\n        return wrappedNativeBalanceAfter - wrappedNativeBalanceBefore;\n    }\n\n    function updateCache() public returns (uint256) {\n        uint256 lpBalance = pool.balanceOf(address(this));\n\n        (address[] memory poolTokens, , ) = vault.getPoolTokens(poolId);\n        uint256 index;\n        uint256[] memory minAmountsOut = new uint256[](poolTokens.length);\n        for (uint256 i = 0; i < poolTokens.length; i++) {\n            if (poolTokens[i] == address(wrappedNative)) {\n                index = i;\n            }\n            minAmountsOut[i] = 0;\n        }\n\n        IBalancerVault.ExitPoolRequest memory exitRequest;\n        exitRequest.assets = poolTokens;\n        exitRequest.minAmountsOut = minAmountsOut;\n        exitRequest.toInternalBalance = false;\n        exitRequest.userData = abi.encode(0, lpBalance, index);\n\n        (, uint256[] memory amountsOut) = helpers.queryExit(\n            poolId,\n            address(this),\n            address(this),\n            exitRequest\n        );\n\n        _cachedCalculatedAmount = amountsOut[index];\n        return amountsOut[index];\n    }\n\n    receive() external payable {}\n}"
    }
  ]
}