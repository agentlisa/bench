{
  "Title": "M-7: castVote can be called by anyone even those without votes",
  "Content": "# Issue M-7: castVote can be called by anyone even those without votes \n\nSource: https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/25 \n\n## Found by \nhansfriese, 0x52, Trumpero\n\n## Summary\n\nGovernance#castVote can be called by anyone, even users that don't have any votes. Since the voting refund is per address, an adversary could use a large number of addresses to vote with zero votes to drain the vault.\n\n## Vulnerability Detail\n\n    function _castVote(address _voter, uint256 _proposalId, uint8 _support) internal returns (uint) {\n        // Only Active proposals can be voted on\n        if (state(_proposalId) != ProposalState.Active) revert InvalidStatus();\n        \n        // Only valid values for _support are 0 (against), 1 (for), and 2 (abstain)\n        if (_support > 2) revert InvalidInput();\n\n        Proposal storage proposal = proposals[_proposalId];\n\n        // If the voter has already voted, revert        \n        Receipt storage receipt = proposal.receipts[_voter];\n        if (receipt.hasVoted) revert AlreadyVoted();\n\n        // Calculate the number of votes a user is able to cast\n        // This takes into account delegation and community voting power\n        uint24 votes = (staking.getVotes(_voter)).toUint24();\n\n        // Update the proposal's total voting records based on the votes\n        if (_support == 0) {\n            proposal.againstVotes = proposal.againstVotes + votes;\n        } else if (_support == 1) {\n            proposal.forVotes = proposal.forVotes + votes;\n        } else if (_support == 2) {\n            proposal.abstainVotes = proposal.abstainVotes + votes;\n        }\n\n        // Update the user's receipt for this proposal\n        receipt.hasVoted = true;\n        receipt.support = _support;\n        receipt.votes = votes;\n\n        // Make these updates after the vote so it doesn't impact voting power for this vote.\n        ++totalCommunityScoreData.votes;\n\n        // We can update the total community voting power with no check because if you can vote, \n        // it means you have votes so you haven't delegated.\n        ++userCommunityScoreData[_voter].votes;\n\n        return votes;\n    }\n\nNowhere in the flow of voting does the function revert if the user calling it doesn't actually have any votes. staking#getVotes won't revert under any circumstances. Governance#_castVote only reverts if 1) the proposal isn't active 2) support > 2 or 3) if the user has already voted. The result is that any user can vote even if they don't have any votes, allowing users to maliciously burn vault funds by voting and claiming the vote refund. \n\n## Impact\n\nVault can be drained maliciously by users with no votes\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Governance.sol#L607-L646\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nGovernance#_castVote should revert if msg.sender doesn't have any votes:\n\n        // Calculate the number of votes a user is able to cast\n        // This takes into account delegation and community voting power\n        uint24 votes = (staking.getVotes(_voter)).toUint24();\n\n    +   if (votes == 0) revert NoVotes();\n\n        // Update the proposal's total voting records based on the votes\n        if (_support == 0) {\n            proposal.againstVotes = proposal.againstVotes + votes;\n        } else if (_support == 1) {\n            proposal.forVotes = proposal.forVotes + votes;\n        } else if (_support == 2) {\n            proposal.abstainVotes = proposal.abstainVotes + votes;\n        }\n\n## Discussion\n\n**zobront**\n\nThis is great and will fix, but an adversary being able to burn a small pool put aside for gas refunds for no personal benefit seems like a Medium, not a High.\n\n**ZakkMan**\n\nFixed: https://github.com/Solidity-Guild/FrankenDAO/pull/21\n\n**jack-the-pug**\n\nFix confirmed\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/18",
  "Code": [
    {
      "filename": "src/Governance.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n _______  _______  _______  _        _        _______  _          _______           _        _        _______\n(  ____ \\(  ____ )(  ___  )( (    /|| \\    /\\(  ____ \\( (    /|  (  ____ )|\\     /|( (    /|| \\    /\\(  ____ \\\n| (    \\/| (    )|| (   ) ||  \\  ( ||  \\  / /| (    \\/|  \\  ( |  | (    )|| )   ( ||  \\  ( ||  \\  / /| (    \\/\n| (__    | (____)|| (___) ||   \\ | ||  (_/ / | (__    |   \\ | |  | (____)|| |   | ||   \\ | ||  (_/ / | (_____\n|  __)   |     __)|  ___  || (\\ \\) ||   _ (  |  __)   | (\\ \\) |  |  _____)| |   | || (\\ \\) ||   _ (  (_____  )\n| (      | (\\ (   | (   ) || | \\   ||  ( \\ \\ | (      | | \\   |  | (      | |   | || | \\   ||  ( \\ \\       ) |\n| )      | ) \\ \\__| )   ( || )  \\  ||  /  \\ \\| (____/\\| )  \\  |  | )      | (___) || )  \\  ||  /  \\ \\/\\____) |\n|/       |/   \\__/|/     \\||/    )_)|_/    \\/(_______/|/    )_)  |/       (_______)|/    )_)|_/    \\/\\_______)\n\n*/\n\nimport \"./interfaces/IGovernance.sol\";\nimport \"./interfaces/IExecutor.sol\";\nimport \"./interfaces/IStaking.sol\";\nimport \"./utils/Admin.sol\";\nimport \"./utils/Refundable.sol\";\nimport \"./utils/SafeCast.sol\";\n\n/// @title FrankenDAO Governance\n/// @author Zach Obront & Zakk Fleischmann\n/// @notice Users use their staked FrankenPunks and FrankenMonsters to make & vote on governance proposals\n/** @dev Loosely forked from NounsDAOLogicV1.sol (0xa43afe317985726e4e194eb061af77fbcb43f944) with following major modifications:\n- add gas refunding for voting and creating proposals\n- pack proposal struct into fewer storage slots \n- track votes, proposals created, and proposal passed by user for community score calculation\n- track votes, proposals created, and proposal passed across all users counting towards community voting power\n- removed tempProposal from the proposal creation process\n- added a verification step for new proposals to confirm they passed Snapshot pre-governance\n- adjusted roles and permissions\n- added an array to track Active Proposals and a clear() function to remove them \n- removed the ability to pass a reason along with a vote, and to vote by EIP-712 signature\n- allow the contract to receive Ether (for gas refunds)\n */\ncontract Governance is IGovernance, Admin, Refundable {\n    using SafeCast for uint;\n\n    /// @notice The name of this contract\n    string public constant name = \"FrankenDAO\";\n\n    /// @notice The address of staked the Franken tokens\n    IStaking public staking;\n\n    //////////////////////////\n    //// Voting Constants ////\n    //////////////////////////\n\n    /// @notice The min setable voting delay \n    /// @dev votingDelay is the time between a proposal being created and voting opening\n    uint256 public constant MIN_VOTING_DELAY = 1 hours;\n\n    /// @notice The max setable voting delay\n    /// @dev votingDelay is the time between a proposal being created and voting opening\n    uint256 public constant MAX_VOTING_DELAY = 1 weeks;\n\n    /// @notice The minimum setable voting period \n    /// @dev votingPeriod is the time that voting is open for\n    uint256 public constant MIN_VOTING_PERIOD = 1 days; \n\n    /// @notice The max setable voting period \n    /// @dev votingPeriod is the time that voting is open for\n    uint256 public constant MAX_VOTING_PERIOD = 14 days;\n\n    /// @notice The minimum setable proposal threshold\n    /// @dev proposalThreshold is the minimum percentage of votes that a user must have to create a proposal\n    uint256 public constant MIN_PROPOSAL_THRESHOLD_BPS = 1; // 1 basis point or 0.01%\n\n    /// @notice The maximum setable proposal threshold\n    /// @dev proposalThreshold is the minimum percentage of votes that a user must have to create a proposal\n    uint256 public constant MAX_PROPOSAL_THRESHOLD_BPS = 1_000; // 1,000 basis points or 10%\n\n    /// @notice The minimum setable quorum votes basis points\n    /// @dev quorumVotesBPS is the minimum percentage of YES votes that must be cast on a proposal for it to succeed\n    uint256 public constant MIN_QUORUM_VOTES_BPS = 200; // 200 basis points or 2%\n\n    /// @notice The maximum setable quorum votes basis points\n    /// @dev quorumVotesBPS is the minimum percentage of YES votes that must be cast on a proposal for it to succeed\n    uint256 public constant MAX_QUORUM_VOTES_BPS = 2_000; // 2,000 basis points or 20%\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint256 public constant PROPOSAL_MAX_OPERATIONS = 10; // 10 actions\n\n    ///////////////////////////\n    //// Voting Parameters ////\n    ///////////////////////////\n\n    /// @notice The delay before voting on a proposal may take place, once proposed, in seconds.\n    uint256 public votingDelay;\n\n    /// @notice The duration of voting on a proposal, in seconds.\n    uint256 public votingPeriod;\n\n    /// @notice The basis point number of votes required in order for a voter to become a proposer. \n    uint256 public proposalThresholdBPS;\n\n    /// @notice The basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed. \n    uint256 public quorumVotesBPS;\n\n    /// @notice Whether or not gas is refunded for casting votes.\n    bool public votingRefund;\n\n    /// @notice Whether or not gas is refunded for submitting proposals.\n    bool public proposalRefund;\n\n    //////////////////\n    //// Proposal ////\n    //////////////////\n\n    /// @notice The total number of proposals\n    uint256 public proposalCount;\n\n    /// @notice The official record of all proposals ever proposed\n    mapping(uint256 => Proposal) public proposals;\n\n    /// @notice Propsals that are currently verified, but have not been canceled, vetoed, or queued\n    /** @dev Admins (or anyone else) will regularly clear out proposals that have been defeated \n             by calling clear() to keep gas costs of iterating through this array low  */\n    uint256[] public activeProposals;\n\n    /// @notice The latest proposal for each proposer\n    mapping(address => uint256) public latestProposalIds;\n\n    /// @notice The number of votes, verified proposals, and passed proposals for each user\n    mapping(address => CommunityScoreData) public userCommunityScoreData;\n\n    /// @notice The total number of votes, verified proposals, and passed proposals actively contributing to total community voting power\n    /** @dev Users only get community voting power if they currently have token voting power (ie have staked, undelegated tokens \n            or are delegated to). These totals adjust as users stake, undelegate, or delegate to ensure they only reflect the current \n            total community score. Therefore, these totals will not equal the sum of the totals in the userCommunityScoreData mapping. */\n    /// @dev This is used to calculate the total voting power of the entire system, so that we can calculate thresholds from BPS.\n    CommunityScoreData public totalCommunityScoreData;\n\n\n    /// @notice Initialize the contract during proxy setup\n    /// @param _executor The address of the FrankenDAO Executor\n    /// @param _staking The address of the staked FrankenPunks tokens\n    /// @param _founders The address of the founder multisig\n    /// @param _council The address of the council multisig\n    /// @param _votingPeriod The initial voting period (time voting is open for)\n    /// @param _votingDelay The initial voting delay (time between proposal creation and voting opening)\n    /// @param _proposalThresholdBPS The initial threshold to create a proposal (in basis points)\n    /// @param _quorumVotesBPS The initial threshold of quorum votes needed (in basis points)\n    function initialize(\n        address _staking,\n        address _executor,\n        address _founders,\n        address _council,\n        uint256 _votingPeriod,\n        uint256 _votingDelay,\n        uint256 _proposalThresholdBPS,\n        uint256 _quorumVotesBPS\n    ) public {\n        // Check whether this contract has already been initialized.\n        if (address(executor) != address(0)) revert AlreadyInitialized();\n        if (address(_executor) == address(0)) revert ZeroAddress();\n\n        if (_votingDelay < MIN_VOTING_DELAY || _votingDelay > MAX_VOTING_DELAY) revert ParameterOutOfBounds();\n        if (_votingPeriod < MIN_VOTING_PERIOD || _votingPeriod > MAX_VOTING_PERIOD) revert ParameterOutOfBounds();\n        if (_proposalThresholdBPS < MIN_PROPOSAL_THRESHOLD_BPS || _proposalThresholdBPS > MAX_PROPOSAL_THRESHOLD_BPS) revert ParameterOutOfBounds();\n        if (_quorumVotesBPS < MIN_QUORUM_VOTES_BPS || _quorumVotesBPS > MAX_QUORUM_VOTES_BPS) revert ParameterOutOfBounds();\n\n        executor = IExecutor(_executor);\n        founders = _founders;\n        council = _council;\n        staking = IStaking(_staking);\n\n        votingRefund = true;\n        proposalRefund = true;\n\n        emit VotingDelaySet(0, votingDelay = _votingDelay);\n        emit VotingPeriodSet(0, votingPeriod = _votingPeriod);\n        emit ProposalThresholdBPSSet(0, proposalThresholdBPS = _proposalThresholdBPS);\n        emit QuorumVotesBPSSet(0, quorumVotesBPS = _quorumVotesBPS);\n    }\n\n    ///////////////////\n    //// Modifiers ////\n    ///////////////////\n\n    modifier cancelable(uint _proposalId) {\n        Proposal storage proposal = proposals[_proposalId];\n\n        if (\n            // Proposals that are executed, canceled, or vetoed have already been removed from\n            // ActiveProposals array and the Executor queue.\n            state(_proposalId) == ProposalState.Executed ||\n            state(_proposalId) == ProposalState.Canceled ||\n            state(_proposalId) == ProposalState.Vetoed ||\n\n            // Proposals that are Defeated or Expired should be cleared instead, to preserve their state.\n            state(_proposalId) == ProposalState.Defeated ||\n            state(_proposalId) == ProposalState.Expired\n        ) revert InvalidStatus();\n\n        _;\n    }\n\n    ///////////////\n    //// Views ////\n    ///////////////\n\n    /// @notice Gets actions of a proposal\n    /// @param _proposalId the id of the proposal\n    /// @return targets Array of addresses that the Executor will call if the proposal passes\n    /// @return values Array of values (i.e. msg.value) that Executor will call if the proposal passes\n    /// @return signatures Array of function signatures that the Executor will call if the proposal passes\n    /// @return calldatas Array of calldata that the Executor will call if the proposal passes\n    function getActions(uint256 _proposalId) external view returns (\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas\n    ) {\n        Proposal storage p = proposals[_proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    /// @notice Gets the data of a proposal\n    /// @param _proposalId the id of the proposal\n    /// @return id the id of the proposal\n    /// @return proposer the address of the proposer\n    /// @return quorumVotes the number of YES votes needed for the proposal to pass\n    function getProposalData(uint256 _proposalId) public view returns (uint256, address, uint256) {\n        Proposal storage p = proposals[_proposalId];\n        return (p.id, p.proposer, p.quorumVotes);\n    }\n\n    /// @notice Gets the status of a proposal\n    /// @param _proposalId the id of the proposal\n    /// @return verified has the team verified the proposal?\n    /// @return canceled has the proposal been canceled?\n    /// @return vetoed has the proposal been vetoed?\n    /// @return executed has the proposal been executed?\n    function getProposalStatus(uint256 _proposalId) public view returns (bool, bool, bool, bool) {\n        Proposal storage p = proposals[_proposalId];\n        return (p.verified, p.canceled, p.vetoed, p.executed);\n    }\n\n    /// @notice Gets the voting status of a proposal\n    /// @param _proposalId the id of the proposal\n    /// @return forVotes the number of votes in favor of the proposal\n    /// @return againstVotes the number of votes against the proposal\n    /// @return abstainVotes the number of abstain votes\n    function getProposalVotes(uint256 _proposalId) public view returns (uint256, uint256, uint256) {\n        Proposal storage p = proposals[_proposalId];\n        return (p.forVotes, p.againstVotes, p.abstainVotes);\n    }\n\n    /// @notice Gets a list of all Active Proposals (created, but not queued, canceled, vetoed, or cleared)\n    /// @return activeProposals the list of proposal ids\n    function getActiveProposals() public view returns (uint256[] memory) {\n        return activeProposals;\n    }\n\n    \n    /// @notice Gets the receipt for a voter on a given proposal\n    /// @param _proposalId the id of proposal\n    /// @param _voter The address of the voter\n    /// @return The voting receipt (hasVoted, support, votes)\n    function getReceipt(uint256 _proposalId, address _voter) external view returns (Receipt memory) {\n        return proposals[_proposalId].receipts[_voter];\n    }\n\n    /// @notice Gets the state of a proposal\n    /// @param _proposalId The id of the proposal\n    /// @return Proposal state\n    function state(uint256 _proposalId) public view returns (ProposalState) {\n        if (_proposalId > proposalCount) revert InvalidId();\n        Proposal storage proposal = proposals[_proposalId];\n\n        // If the proposal has been vetoed, it should always return Vetoed.\n        if (proposal.vetoed) {\n            return ProposalState.Vetoed;\n\n        // If the proposal isn't verified by the time it ends, it's Canceled.\n        } else if (proposal.canceled || (!proposal.verified && block.timestamp > proposal.endTime)) {\n            return ProposalState.Canceled;\n\n        // If it's unverified at any time before end time, or if it is verified but is before start time, it's Pending.\n        }  else if (block.timestamp < proposal.startTime || !proposal.verified) {\n            return ProposalState.Pending;\n        \n        // If it's verified and after start time but before end time, it's Active.\n        } else if (block.timestamp <= proposal.endTime) {\n            return ProposalState.Active;\n\n        // If this is the case, it means it was verified and it's after the end time. \n        // The YES votes must be greater than the NO votes, and greater than or equal to quorumVotes to pass.\n        // If it doesn't meet these criteria, it's Defeated.\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {\n            return ProposalState.Defeated;\n\n        // If this is the case, the proposal passed, but it hasn't been queued yet, so it's Succeeded.\n        } else if (proposal.eta == 0) {\n            return ProposalState.Succeeded;\n\n        // execute() has been called, so the transaction has been run and the proposal is Executed.\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n\n        // If execute() hasn't been run and we're GRACE_PERIOD after the eta, it's Expired.\n        } else if (block.timestamp >= proposal.eta + executor.GRACE_PERIOD()) {\n            return ProposalState.Expired;\n        \n        // Otherwise, it's queued, unexecuted, and within the GRACE_PERIOD, so we're Queued.\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /// @notice Current proposal threshold based on the voting power of the system\n    /// @dev This incorporates the totals of both token voting power and community voting power\n    function proposalThreshold() public view returns (uint256) {\n        return bps2Uint(proposalThresholdBPS, staking.getTotalVotingPower());\n    }\n\n    /// @notice Current quorum threshold based on the voting power of the system\n    /// @dev This incorporates the totals of both token voting power and community voting power\n    function quorumVotes() public view returns (uint256) {\n        return bps2Uint(quorumVotesBPS, staking.getTotalVotingPower());\n    }\n\n    ///////////////////\n    //// Proposals ////\n    ///////////////////\n\n    /// @notice Function used to propose a new proposal\n    /// @param _targets Target addresses for proposal calls\n    /// @param _values Eth values for proposal calls\n    /// @param _signatures Function signatures for proposal calls\n    /// @param _calldatas Calldatas for proposal calls\n    /// @param _description String description of the proposal\n    /// @return Proposal id of new proposal\n    function propose(\n        address[] memory _targets,\n        uint256[] memory _values,\n        string[] memory _signatures,\n        bytes[] memory _calldatas,\n        string memory _description\n    ) public returns (uint256) {\n        uint proposalId;\n\n        // Refunds gas if proposalRefund is true\n        if (proposalRefund) {\n            uint256 startGas = gasleft();\n            proposalId = _propose(_targets, _values, _signatures, _calldatas, _description);\n            _refundGas(startGas);\n        } else {\n            proposalId = _propose(_targets, _values, _signatures, _calldatas, _description);\n        }\n        return proposalId;\n    }\n\n    /// @notice Function used to propose a new proposal\n    /// @param _targets Target addresses for proposal calls\n    /// @param _values Eth values for proposal calls\n    /// @param _signatures Function signatures for proposal calls\n    /// @param _calldatas Calldatas for proposal calls\n    /// @param _description String description of the proposal\n    /// @return Proposal id of new proposal\n    function _propose(\n        address[] memory _targets,\n        uint256[] memory _values,\n        string[] memory _signatures,\n        bytes[] memory _calldatas,\n        string memory _description\n    ) internal returns (uint256) {\n        // Confirm the proposer meets the proposalThreshold\n        uint votesNeededToPropose = proposalThreshold();\n        if (staking.getVotes(msg.sender) < votesNeededToPropose) revert NotEligible();\n\n        // Validate the proposal's actions\n        if (_targets.length == 0) revert InvalidProposal();\n        if (_targets.length > PROPOSAL_MAX_OPERATIONS) revert InvalidProposal();\n        if (\n            _targets.length != _values.length ||\n            _targets.length != _signatures.length ||\n            _targets.length != _calldatas.length\n        ) revert InvalidProposal();\n\n        // Ensure the proposer doesn't already have an active or pending proposal\n        uint latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n            if (\n                proposersLatestProposalState == ProposalState.Active || \n                proposersLatestProposalState == ProposalState.Pending\n            ) revert NotEligible();\n        }\n        \n        // Create a new proposal in storage, and fill it with the correct data\n        uint newProposalId = ++proposalCount;\n        Proposal storage newProposal = proposals[newProposalId];\n\n        // All non-array values in the Proposal struct are packed into 2 storage slots:\n        // Slot 1: id (96) + proposer (address, 160)\n        // Slot 2: quorumVotes (24), eta (32), startTime (32), endTime (32), forVotes (24), \n        //         againstVotes (24), canceled (8), vetoed (8), executed (8), verified (8)\n        \n        // All times are stored as uint32s, which takes us through the year 2106 (we can upgrade then :))\n        // All votes are stored as uint24s with lots of buffer, since max votes in system is < 4 million\n        // (10k punks * (max 50 token VP + max ~100 community VP) + 10k monsters * (max 25 token VP + max ~100 community VP))\n        \n        newProposal.id = newProposalId.toUint96();\n        newProposal.proposer = msg.sender;\n        newProposal.targets = _targets;\n        newProposal.values = _values;\n        newProposal.signatures = _signatures;\n        newProposal.calldatas = _calldatas;\n        newProposal.quorumVotes = quorumVotes().toUint24();\n        newProposal.startTime = (block.timestamp + votingDelay).toUint32();\n        newProposal.endTime = (block.timestamp + votingDelay + votingPeriod).toUint32();\n        \n        // Other values are set automatically:\n        //  - forVotes, againstVotes, and abstainVotes = 0\n        //  - verified, canceled, executed, and vetoed = false\n        //  - eta = 0\n\n        latestProposalIds[newProposal.proposer] = newProposalId;\n        activeProposals.push(newProposalId);\n\n        emit ProposalCreated(\n            newProposalId,\n            msg.sender,\n            _targets,\n            _values,\n            _signatures,\n            _calldatas,\n            newProposal.startTime,\n            newProposal.endTime,\n            newProposal.quorumVotes,\n            _description\n        );\n\n        return newProposalId;\n    }\n\n    /// @notice Function for verifying a proposal\n    /// @param _proposalId Id of the proposal to verify\n    /// @dev This is intended to confirm that the proposal got through Snapshot pre-governance\n    /// @dev This doesn't add any additional centralization risk, as the team already has veto power\n    function verifyProposal(uint _proposalId) external onlyAdmins {\n        // Can only verify proposals that are currently in the Pending state\n        if (state(_proposalId) != ProposalState.Pending) revert InvalidStatus();\n\n        Proposal storage proposal = proposals[_proposalId];\n        proposal.verified = true;\n\n        // If a proposal was valid, we are ready to award the community voting power bonuses to the proposer\n        ++userCommunityScoreData[proposal.proposer].proposalsCreated;\n        \n        // We don't need to check whether the proposer is accruing community voting power because\n        // they needed that voting power to propose, and once they have an Active Proposal, their\n        // tokens are locked from delegating and unstaking.\n        ++totalCommunityScoreData.proposalsCreated;\n    }\n\n    /////////////////\n    //// Execute ////\n    /////////////////\n\n    /// @notice Queues a proposal of state succeeded\n    /// @param _proposalId The id of the proposal to queue\n    function queue(uint256 _proposalId) external {\n        // Succeeded means we're past the endTime, yes votes outweigh no votes, and quorum threshold is met\n        if(state(_proposalId) != ProposalState.Succeeded) revert InvalidStatus();\n        \n        Proposal storage proposal = proposals[_proposalId];\n\n        // Set the ETA (time for execution) to the soonest time based on the Executor's delay\n        uint256 eta = block.timestamp + executor.DELAY();\n        proposal.eta = eta.toUint32();\n\n        // Queue separate transactions for each action in the proposal\n        uint numTargets = proposal.targets.length;\n        for (uint256 i = 0; i < numTargets; i++) {\n            executor.queueTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n        }\n\n        // If a proposal is queued, we are ready to award the community voting power bonuses to the proposer\n        ++userCommunityScoreData[proposal.proposer].proposalsCreated;\n        \n        // We don't need to check whether the proposer is accruing community voting power because\n        // they needed that voting power to propose, and once they have an Active Proposal, their\n        // tokens are locked from delegating and unstaking.\n        ++totalCommunityScoreData.proposalsCreated;\n        \n        // Remove the proposal from the Active Proposals array\n        _removeFromActiveProposals(_proposalId);\n\n        emit ProposalQueued(_proposalId, eta);\n    }\n\n    /// @notice Executes a queued proposal if eta has passed\n    /// @param _proposalId The id of the proposal to execute\n    function execute(uint256 _proposalId) external {\n        // Queued means the proposal is passed, queued, and within the grace period.\n        if (state(_proposalId) != ProposalState.Queued) revert InvalidStatus();\n\n        Proposal storage proposal = proposals[_proposalId];\n        proposal.executed = true;\n\n        // Separate transactions were queued for each action in the proposal, so execute each separately\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            executor.executeTransaction(\n                proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta\n            );\n        }\n\n        emit ProposalExecuted(_proposalId);\n    }\n\n    ////////////////////////////////\n    //// Cancel / Veto Proposal ////\n    ////////////////////////////////\n\n    /// @notice Vetoes a proposal \n    /// @param _proposalId The id of the proposal to veto\n    /// @dev This allows the founder or council multisig to veto a malicious proposal\n    function veto(uint256 _proposalId) external cancelable(_proposalId) onlyAdmins {\n        Proposal storage proposal = proposals[_proposalId];\n\n        // If the proposal is queued or executed, remove it from the Executor's queuedTransactions mapping\n        // Otherwise, remove it from the Active Proposals array\n        _removeTransactionWithQueuedOrExpiredCheck(proposal);\n\n        // Update the vetoed flag so the proposal's state is Vetoed\n        proposal.vetoed = true;\n\n        emit ProposalVetoed(_proposalId);\n    }\n\n    /// @notice Cancels a proposal\n    /// @param _proposalId The id of the proposal to cancel\n    function cancel(uint256 _proposalId) external cancelable(_proposalId) {\n        Proposal storage proposal = proposals[_proposalId];\n\n        // Proposals can be canceled if proposer themselves decide to cancel the proposal (at any time before execution)\n        // Nouns allows anyone to cancel if proposer falls below threshold, but because tokens are locked, this isn't possible\n        if (msg.sender != proposal.proposer) revert NotEligible();\n\n        // If the proposal is queued or executed, remove it from the Executor's queuedTransactions mapping\n        // Otherwise, remove it from the Active Proposals array\n        _removeTransactionWithQueuedOrExpiredCheck(proposal);\n\n        // Set the canceled flag to true to change the status to Canceled\n        proposal.canceled = true;   \n\n        emit ProposalCanceled(_proposalId);\n    }\n\n    /// @notice clear the proposal from the ActiveProposals array or the Executor's queuedTransactions\n    /// @param _proposalId The id of the proposal to clear\n    function clear(uint256 _proposalId) external {\n        Proposal storage proposal = proposals[_proposalId];\n\n        // This function can only be called in three situations:\n        // 1. EXPIRED: The proposal was queued but the grace period has passed (removes it from Executor's \n        //    queuedTransactions). We use this instead of using cancel() so Expired state is preserved.\n        // 2. DEFEATED: The proposal is over and was not passed (removes it from ActiveProposals array).\n        //    We use this instead of using cancel() so Defeated state is preserved.\n        // 3. UNVERIFIED AFTER END TIME (CANCELED): The proposal remained unverified through the endTime and is \n        //    now considered canceled (removes it from ActiveProposals array). We use this because cancel() is \n        //    not allowed to be called on canceled proposals, but this situation is a special case where the \n        //    proposal still needs to be removed from the ActiveProposals array.\n        if (\n            state(_proposalId) != ProposalState.Expired &&\n            state(_proposalId) != ProposalState.Defeated && \n            (proposal.verified || block.timestamp <= proposal.endTime)\n        ) revert NotEligible();\n\n        // If the proposal is Expired, remove it from the Executor's queuedTransactions mapping\n        // If the proposal is Defeated or Canceled, remove it from the Active Proposals array\n        _removeTransactionWithQueuedOrExpiredCheck(proposal);\n\n        emit ProposalCanceled(_proposalId);\n    }\n\n    ////////////////\n    //// Voting ////\n    ////////////////\n\n    /// @notice Cast a vote for a proposal\n    /// @param _proposalId The id of the proposal to vote on\n    /// @param _support The support value for the vote (0=against, 1=for, 2=abstain)\n    function castVote(uint256 _proposalId, uint8 _support) external {\n        // Refunds gas if votingRefund is true\n        if (votingRefund) {\n            uint256 startGas = gasleft();\n            uint votes = _castVote(msg.sender, _proposalId, _support);\n            emit VoteCast( msg.sender, _proposalId, _support, votes);\n            _refundGas(startGas);\n        } else {\n            uint votes = _castVote(msg.sender, _proposalId, _support);\n            emit VoteCast( msg.sender, _proposalId, _support, votes);\n        }\n    }\n\n    /// @notice Internal function that caries out voting logic\n    /// @param _voter The voter that is casting their vote\n    /// @param _proposalId The id of the proposal to vote on\n    /// @param _support The support value for the vote (0=against, 1=for, 2=abstain)\n    /// @return The number of votes cast\n    function _castVote(address _voter, uint256 _proposalId, uint8 _support) internal returns (uint) {\n        // Only Active proposals can be voted on\n        if (state(_proposalId) != ProposalState.Active) revert InvalidStatus();\n        \n        // Only valid values for _support are 0 (against), 1 (for), and 2 (abstain)\n        if (_support > 2) revert InvalidInput();\n\n        Proposal storage proposal = proposals[_proposalId];\n\n        // If the voter has already voted, revert        \n        Receipt storage receipt = proposal.receipts[_voter];\n        if (receipt.hasVoted) revert AlreadyVoted();\n\n        // Calculate the number of votes a user is able to cast\n        // This takes into account delegation and community voting power\n        uint24 votes = (staking.getVotes(_voter)).toUint24();\n\n        // Update the proposal's total voting records based on the votes\n        if (_support == 0) {\n            proposal.againstVotes = proposal.againstVotes + votes;\n        } else if (_support == 1) {\n            proposal.forVotes = proposal.forVotes + votes;\n        } else if (_support == 2) {\n            proposal.abstainVotes = proposal.abstainVotes + votes;\n        }\n\n        // Update the user's receipt for this proposal\n        receipt.hasVoted = true;\n        receipt.support = _support;\n        receipt.votes = votes;\n\n        // Make these updates after the vote so it doesn't impact voting power for this vote.\n        ++totalCommunityScoreData.votes;\n\n        // We can update the total community voting power with no check because if you can vote, \n        // it means you have votes so you haven't delegated.\n        ++userCommunityScoreData[_voter].votes;\n\n        return votes;\n    }\n\n\n    /////////////////\n    //// Helpers ////\n    /////////////////\n    \n    /// @notice Calculates a fixed value given a BPS value and a number to calculate against\n    /// @dev For example, if _bps is 5000, it means 50% of _number\n    /// @dev Used to calculate the proposalThreshold or quorumThreshold at a given point in time\n    function bps2Uint(uint256 _bps, uint256 _number) internal pure returns (uint256) {\n        return (_number * _bps) / 10000;\n    }\n\n    /// @notice Removes a proposal from the ActiveProposals array or the Executor's queuedTransactions mapping\n    /// @param _proposal The proposal to remove\n    function _removeTransactionWithQueuedOrExpiredCheck(Proposal storage _proposal) internal {\n        if (\n            state(_proposal.id) == ProposalState.Queued || \n            state(_proposal.id) == ProposalState.Expired\n        ) {\n            for (uint256 i = 0; i < _proposal.targets.length; i++) {\n                executor.cancelTransaction(\n                    _proposal.targets[i],\n                    _proposal.values[i],\n                    _proposal.signatures[i],\n                    _proposal.calldatas[i],\n                    _proposal.eta\n                );\n            }\n        } else {\n            _removeFromActiveProposals(_proposal.id);\n        }\n    }\n\n    /// @notice Removes a proposal from the ActiveProposals array\n    /// @param _id The id of the proposal to remove\n    /// @dev uses swap and pop to find the proposal, swap it with the final index, and pop the final index off\n    function _removeFromActiveProposals(uint256 _id) private {\n        uint256 index;\n        uint[] memory actives = activeProposals;\n\n        bool found = false;\n        for (uint256 i = 0; i < actives.length; i++) {\n            if (actives[i] == _id) {\n                found = true;\n                index = i;\n                break;\n            }\n        }\n\n        // This is important because otherwise, if the proposal is not found, it will remove the first index\n        // There s"
    }
  ]
}