{
  "Title": "[H-01] Custom redemption might revert if old assets were unregistered",
  "Content": "\n`quoteCustomRedemption()` works under the assumption that the maximum size of the `erc20sAll` should be `assetRegistry.size()`, however there can be cases where an asset was unregistered but still exists in an old basket, making the size of the old basket greater than `assetRegistry.size()`. In that case the function will revert with an index out of bounds error.\n\n### Impact\n\nUsers might not be able to use `redeemCustom` when needed.\n\nI think this should be considered high severity, since being able to redeem the token at all time is an essential feature for the protocol that's allowed also while frozen.\nNot being able to redeem can result in a depeg or in governance becoming malicious and stealing RToken collateral.\n\n### Proof of Concept\n\nConsider the following scenario:\n\n*   RToken deployed with 0.9 USDC, 0.05 USDT, 0.05 DAI\n*   Governance passed a vote to change it to 0.9 DAI and 0.1 USDC and un-register USDT\n*   Trading is paused before execution, so the basket switch occurs but the re-balance can't be executed. Meaning the actual assets that the backing manager holds are in accordance with the old basket\n*   A user wants to redeem using the old basket, but custom redemption reverts\n\nAs for the revert:\n\n*   `erc20sAll` is created [here](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/BasketHandler.sol#L391-L392) with the length of `assetRegistry.size()`, which is 2 in our case.\n*   Then in [this loop](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/BasketHandler.sol#L397-L428) the function tries to push 3 assets into `erc20sAll` which will result in an index-out-of-bonds error\n\n(the function doesn't include in the final results assets that aren't registered, but it does push them too into `erc20sAll`)\n\n### Recommended Mitigation Steps\n\nAllow the user to specify the length of the array `erc20sAll` to avoid this revert\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/4#issuecomment-1586269794):**\n > I believe this to be a stretch for high severity. It has several pre-conditions to end up in the proposed state and I do believe it would be entirely possible for governance to change back to the original state (USDC, USDT, DAI), so assets wouldn't be lost and the impact would more be along the lines of a temporary denial of service.\n> \n> Look forward to warden and sponsor comments. \n\n**[tbrent (Reserve) confirmed and commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/4#issuecomment-1587948710):**\n > @0xA5DF - nice find! Thoughts on an alternative mitigation?\n> - Could move L438 to just after L417, so that `erc20sAll` never includes unregistered ERC20s\n> - Would probably have to cache the assets as `assetsAll` for re-use around L438\n> - Has side-effect of making the ERC20 return list never include unregistered ERC20s. Current implementation can return a 0 value for an unregistered ERC20. This is properly handled by the RToken contract, but still, nice-to-have.\n\n**[0xA5DF (warden) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/4#issuecomment-1587988163):**\n > Hey @tbrent -<br>\n> That can work as well, the only downside I can think of is that in case there's an asset that's not registered and is repeated across different baskets - the `toAsset()` would be called multiple times for that asset (while under the current implementation and under the mitigation I've suggested it'll be called only once), this would cost about 300 gas units per additional call (100 for the call, 2 `sload`s to a warm slot inside the call itself)\n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/4#issuecomment-1588023172):**\n> @0xA5DF - Noted, good point.\n\n**[tbrent (Reserve) confirmed](https://github.com/code-423n4/2023-06-reserve-findings/issues/4#issuecomment-1620824425)**\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/4#issuecomment-1632948695):**\n > @tbrent - do you care to comment on your thoughts on severity? I am leaning towards M on this, but it sounds like you believe it is correct as labeled (high). \n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/4#issuecomment-1632984393):**\n > @0xean - Correct, I think high is appropriate. \n\n**[Reserve mitigated](https://github.com/code-423n4/2023-08-reserve-mitigation#individual-prs):**\n> Fix `redeemCustom`.<br>\n> PR: https://github.com/reserve-protocol/protocol/pull/857\n\n**Status:** Mitigation confirmed. Full details in reports from [ronnyx2017](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/7), [0xA5DF](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/30), and [rvierdiiev](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/3) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-06-reserve",
  "Code": [
    {
      "filename": "contracts/p1/BasketHandler.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"../interfaces/IAssetRegistry.sol\";\nimport \"../interfaces/IBasketHandler.sol\";\nimport \"../interfaces/IMain.sol\";\nimport \"../libraries/Array.sol\";\nimport \"../libraries/Fixed.sol\";\nimport \"./mixins/BasketLib.sol\";\nimport \"./mixins/Component.sol\";\n\n/**\n * @title BasketHandler\n * @notice Handles the basket configuration, definition, and evolution over time.\n */\ncontract BasketHandlerP1 is ComponentP1, IBasketHandler {\n    using BasketLibP1 for Basket;\n    using EnumerableMap for EnumerableMap.Bytes32ToUintMap;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using CollateralStatusComparator for CollateralStatus;\n    using FixLib for uint192;\n\n    uint192 public constant MAX_TARGET_AMT = 1e3 * FIX_ONE; // {target/BU} max basket weight\n    uint48 public constant MIN_WARMUP_PERIOD = 60; // {s} 1 minute\n    uint48 public constant MAX_WARMUP_PERIOD = 31536000; // {s} 1 year\n\n    // Peer components\n    IAssetRegistry private assetRegistry;\n    IBackingManager private backingManager;\n    IERC20 private rsr;\n    IRToken private rToken;\n    IStRSR private stRSR;\n\n    // config is the basket configuration, from which basket will be computed in a basket-switch\n    // event. config is only modified by governance through setPrimeBakset and setBackupConfig\n    BasketConfig private config;\n\n    // basket, disabled, nonce, and timestamp are only ever set by `_switchBasket()`\n    // basket is the current basket.\n    Basket private basket;\n\n    uint48 public nonce; // {basketNonce} A unique identifier for this basket instance\n    uint48 public timestamp; // The timestamp when this basket was last set\n\n    // If disabled is true, status() is DISABLED, the basket is invalid,\n    // and everything except redemption should be paused.\n    bool private disabled;\n\n    // === Function-local transitory vars ===\n\n    // These are effectively local variables of _switchBasket.\n    // Nothing should use their values from previous transactions.\n    EnumerableSet.Bytes32Set private _targetNames;\n    Basket private _newBasket;\n\n    // === Warmup Period ===\n    // Added in 3.0.0\n\n    // Warmup Period\n    uint48 public warmupPeriod; // {s} how long to wait until issuance/trading after regaining SOUND\n\n    // basket status changes, mainly set when `trackStatus()` is called\n    // used to enforce warmup period, after regaining SOUND\n    uint48 private lastStatusTimestamp;\n    CollateralStatus private lastStatus;\n\n    // === Historical basket nonces ===\n    // Added in 3.0.0\n\n    // A history of baskets by basket nonce; includes current basket\n    mapping(uint48 => Basket) private basketHistory;\n\n    // Effectively local variable of `requireConstantConfigTargets()`\n    EnumerableMap.Bytes32ToUintMap private _targetAmts; // targetName -> {target/BU}\n\n    // ===\n\n    // ==== Invariants ====\n    // basket is a valid Basket:\n    //   basket.erc20s is a valid collateral array and basket.erc20s == keys(basket.refAmts)\n    // config is a valid BasketConfig:\n    //   erc20s == keys(targetAmts) == keys(targetNames)\n    //   erc20s is a valid collateral array\n    //   for b in vals(backups), b.erc20s is a valid collateral array.\n    // if basket.erc20s is empty then disabled == true\n\n    // BasketHandler.init() just leaves the BasketHandler state zeroed\n    function init(IMain main_, uint48 warmupPeriod_) external initializer {\n        __Component_init(main_);\n\n        assetRegistry = main_.assetRegistry();\n        backingManager = main_.backingManager();\n        rsr = main_.rsr();\n        rToken = main_.rToken();\n        stRSR = main_.stRSR();\n\n        setWarmupPeriod(warmupPeriod_);\n\n        // Set last status to DISABLED (default)\n        lastStatus = CollateralStatus.DISABLED;\n        lastStatusTimestamp = uint48(block.timestamp);\n\n        disabled = true;\n    }\n\n    /// Disable the basket in order to schedule a basket refresh\n    /// @custom:protected\n    // checks: caller is assetRegistry\n    // effects: disabled' = true\n    function disableBasket() external {\n        require(_msgSender() == address(assetRegistry), \"asset registry only\");\n\n        uint256 len = basket.erc20s.length;\n        uint192[] memory refAmts = new uint192[](len);\n        for (uint256 i = 0; i < len; ++i) refAmts[i] = basket.refAmts[basket.erc20s[i]];\n        emit BasketSet(nonce, basket.erc20s, refAmts, true);\n        disabled = true;\n    }\n\n    /// Switch the basket, only callable directly by governance or after a default\n    /// @custom:interaction OR @custom:governance\n    // checks: either caller has OWNER,\n    //         or (basket is disabled after refresh and we're unpaused and unfrozen)\n    // actions: calls assetRegistry.refresh(), then _switchBasket()\n    // effects:\n    //   Either: (basket' is a valid nonempty basket, without DISABLED collateral,\n    //            that satisfies basketConfig) and disabled' = false\n    //   Or no such basket exists and disabled' = true\n    function refreshBasket() external {\n        assetRegistry.refresh();\n\n        require(\n            main.hasRole(OWNER, _msgSender()) ||\n                (status() == CollateralStatus.DISABLED && !main.tradingPausedOrFrozen()),\n            \"basket unrefreshable\"\n        );\n        _switchBasket();\n\n        trackStatus();\n    }\n\n    /// Track basket status changes if they ocurred\n    // effects: lastStatus' = status(), and lastStatusTimestamp' = current timestamp\n    /// @custom:refresher\n    function trackStatus() public {\n        CollateralStatus currentStatus = status();\n        if (currentStatus != lastStatus) {\n            emit BasketStatusChanged(lastStatus, currentStatus);\n            lastStatus = currentStatus;\n            lastStatusTimestamp = uint48(block.timestamp);\n        }\n    }\n\n    /// Set the prime basket in the basket configuration, in terms of erc20s and target amounts\n    /// @param erc20s The collateral for the new prime basket\n    /// @param targetAmts The target amounts (in) {target/BU} for the new prime basket\n    /// @custom:governance\n    // checks:\n    //   caller is OWNER\n    //   len(erc20s) == len(targetAmts)\n    //   erc20s is a valid collateral array\n    //   for all i, erc20[i] is in AssetRegistry as collateral\n    //   for all i, 0 < targetAmts[i] <= MAX_TARGET_AMT == 1000\n    //\n    // effects:\n    //   config'.erc20s = erc20s\n    //   config'.targetAmts[erc20s[i]] = targetAmts[i], for i from 0 to erc20s.length-1\n    //   config'.targetNames[e] = assetRegistry.toColl(e).targetName, for e in erc20s\n    function setPrimeBasket(IERC20[] calldata erc20s, uint192[] calldata targetAmts)\n        external\n        governance\n    {\n        require(erc20s.length > 0, \"cannot empty basket\");\n        require(erc20s.length == targetAmts.length, \"must be same length\");\n        requireValidCollArray(erc20s);\n\n        // If this isn't initial setup, require targets remain constant\n        if (config.erc20s.length > 0) requireConstantConfigTargets(erc20s, targetAmts);\n\n        // Clean up previous basket config\n        for (uint256 i = 0; i < config.erc20s.length; ++i) {\n            delete config.targetAmts[config.erc20s[i]];\n            delete config.targetNames[config.erc20s[i]];\n        }\n        delete config.erc20s;\n\n        // Set up new config basket\n        bytes32[] memory names = new bytes32[](erc20s.length);\n\n        for (uint256 i = 0; i < erc20s.length; ++i) {\n            // This is a nice catch to have, but in general it is possible for\n            // an ERC20 in the prime basket to have its asset unregistered.\n            require(assetRegistry.toAsset(erc20s[i]).isCollateral(), \"erc20 is not collateral\");\n            require(0 < targetAmts[i], \"invalid target amount; must be nonzero\");\n            require(targetAmts[i] <= MAX_TARGET_AMT, \"invalid target amount; too large\");\n\n            config.erc20s.push(erc20s[i]);\n            config.targetAmts[erc20s[i]] = targetAmts[i];\n            names[i] = assetRegistry.toColl(erc20s[i]).targetName();\n            config.targetNames[erc20s[i]] = names[i];\n        }\n\n        emit PrimeBasketSet(erc20s, targetAmts, names);\n    }\n\n    /// Set the backup configuration for some target name\n    /// @custom:governance\n    // checks:\n    //   caller is OWNER\n    //   erc20s is a valid collateral array\n    //   for all i, erc20[i] is in AssetRegistry as collateral\n    //\n    // effects:\n    //   config'.backups[targetName] = {max: max, erc20s: erc20s}\n    function setBackupConfig(\n        bytes32 targetName,\n        uint256 max,\n        IERC20[] calldata erc20s\n    ) external governance {\n        requireValidCollArray(erc20s);\n        BackupConfig storage conf = config.backups[targetName];\n        conf.max = max;\n        delete conf.erc20s;\n\n        for (uint256 i = 0; i < erc20s.length; ++i) {\n            // This is a nice catch to have, but in general it is possible for\n            // an ERC20 in the backup config to have its asset altered.\n            require(assetRegistry.toAsset(erc20s[i]).isCollateral(), \"erc20 is not collateral\");\n            conf.erc20s.push(erc20s[i]);\n        }\n        emit BackupConfigSet(targetName, max, erc20s);\n    }\n\n    /// @return Whether this contract owns enough collateral to cover rToken.basketsNeeded() BUs\n    /// ie, whether the protocol is currently fully collateralized\n    function fullyCollateralized() external view returns (bool) {\n        BasketRange memory held = basketsHeldBy(address(backingManager));\n        return held.bottom >= rToken.basketsNeeded();\n    }\n\n    /// @return status_ The status of the basket\n    // returns DISABLED if disabled == true, and worst(status(coll)) otherwise\n    function status() public view returns (CollateralStatus status_) {\n        uint256 size = basket.erc20s.length;\n\n        // untestable:\n        //      disabled is only set in _switchBasket, and only if size > 0.\n        if (disabled || size == 0) return CollateralStatus.DISABLED;\n\n        for (uint256 i = 0; i < size; ++i) {\n            CollateralStatus s = assetRegistry.toColl(basket.erc20s[i]).status();\n            if (s.worseThan(status_)) status_ = s;\n        }\n    }\n\n    /// @return Whether the basket is ready to issue and trade\n    function isReady() external view returns (bool) {\n        return\n            status() == CollateralStatus.SOUND &&\n            (block.timestamp >= lastStatusTimestamp + warmupPeriod);\n    }\n\n    /// @param erc20 The token contract to check for quantity for\n    /// @return {tok/BU} The token-quantity of an ERC20 token in the basket.\n    // Returns 0 if erc20 is not registered or not in the basket\n    // Returns FIX_MAX (in lieu of +infinity) if Collateral.refPerTok() is 0.\n    // Otherwise returns (token's basket.refAmts / token's Collateral.refPerTok())\n    function quantity(IERC20 erc20) public view returns (uint192) {\n        try assetRegistry.toColl(erc20) returns (ICollateral coll) {\n            return _quantity(erc20, coll);\n        } catch {\n            return FIX_ZERO;\n        }\n    }\n\n    /// Like quantity(), but unsafe because it DOES NOT CONFIRM THAT THE ASSET IS CORRECT\n    /// @param erc20 The ERC20 token contract for the asset\n    /// @param asset The registered asset plugin contract for the erc20\n    /// @return {tok/BU} The token-quantity of an ERC20 token in the basket.\n    // Returns 0 if erc20 is not registered or not in the basket\n    // Returns FIX_MAX (in lieu of +infinity) if Collateral.refPerTok() is 0.\n    // Otherwise returns (token's basket.refAmts / token's Collateral.refPerTok())\n    function quantityUnsafe(IERC20 erc20, IAsset asset) public view returns (uint192) {\n        if (!asset.isCollateral()) return FIX_ZERO;\n        return _quantity(erc20, ICollateral(address(asset)));\n    }\n\n    /// @param erc20 The token contract\n    /// @param coll The registered collateral plugin contract\n    /// @return {tok/BU} The token-quantity of an ERC20 token in the basket.\n    // Returns 0 if coll is not in the basket\n    // Returns FIX_MAX (in lieu of +infinity) if Collateral.refPerTok() is 0.\n    // Otherwise returns (token's basket.refAmts / token's Collateral.refPerTok())\n    function _quantity(IERC20 erc20, ICollateral coll) internal view returns (uint192) {\n        uint192 refPerTok = coll.refPerTok();\n        if (refPerTok == 0) return FIX_MAX;\n\n        // {tok/BU} = {ref/BU} / {ref/tok}\n        return basket.refAmts[erc20].div(refPerTok, CEIL);\n    }\n\n    /// Should not revert\n    /// @return low {UoA/BU} The lower end of the price estimate\n    /// @return high {UoA/BU} The upper end of the price estimate\n    // returns sum(quantity(erc20) * price(erc20) for erc20 in basket.erc20s)\n    function price() external view returns (uint192 low, uint192 high) {\n        return _price(false);\n    }\n\n    /// Should not revert\n    /// lowLow should be nonzero when the asset might be worth selling\n    /// @return lotLow {UoA/BU} The lower end of the lot price estimate\n    /// @return lotHigh {UoA/BU} The upper end of the lot price estimate\n    // returns sum(quantity(erc20) * lotPrice(erc20) for erc20 in basket.erc20s)\n    function lotPrice() external view returns (uint192 lotLow, uint192 lotHigh) {\n        return _price(true);\n    }\n\n    /// Returns the price of a BU, using the lot prices if `useLotPrice` is true\n    /// @return low {UoA/BU} The lower end of the price estimate\n    /// @return high {UoA/BU} The upper end of the price estimate\n    function _price(bool useLotPrice) internal view returns (uint192 low, uint192 high) {\n        uint256 low256;\n        uint256 high256;\n\n        uint256 len = basket.erc20s.length;\n        for (uint256 i = 0; i < len; ++i) {\n            uint192 qty = quantity(basket.erc20s[i]);\n            if (qty == 0) continue;\n\n            (uint192 lowP, uint192 highP) = useLotPrice\n                ? assetRegistry.toAsset(basket.erc20s[i]).lotPrice()\n                : assetRegistry.toAsset(basket.erc20s[i]).price();\n\n            low256 += qty.safeMul(lowP, RoundingMode.FLOOR);\n            high256 += qty.safeMul(highP, RoundingMode.CEIL);\n        }\n\n        // safe downcast: FIX_MAX is type(uint192).max\n        low = low256 >= FIX_MAX ? FIX_MAX : uint192(low256);\n        high = high256 >= FIX_MAX ? FIX_MAX : uint192(high256);\n    }\n\n    /// Return the current issuance/redemption value of `amount` BUs\n    /// @dev Subset of logic of quoteCustomRedemption; more gas efficient for current nonce\n    /// @param amount {BU}\n    /// @return erc20s The backing collateral erc20s\n    /// @return quantities {qTok} ERC20 token quantities equal to `amount` BUs\n    // Returns (erc20s, [quantity(e) * amount {as qTok} for e in erc20s])\n    function quote(uint192 amount, RoundingMode rounding)\n        external\n        view\n        returns (address[] memory erc20s, uint256[] memory quantities)\n    {\n        uint256 length = basket.erc20s.length;\n        erc20s = new address[](length);\n        quantities = new uint256[](length);\n\n        for (uint256 i = 0; i < length; ++i) {\n            erc20s[i] = address(basket.erc20s[i]);\n            ICollateral coll = assetRegistry.toColl(IERC20(erc20s[i]));\n\n            // {qTok} = {tok/BU} * {BU} * {tok} * {qTok/tok}\n            quantities[i] = _quantity(basket.erc20s[i], coll)\n                .safeMul(amount, rounding)\n                .shiftl_toUint(\n                    int8(IERC20Metadata(address(basket.erc20s[i])).decimals()),\n                    rounding\n                );\n        }\n    }\n\n    /// Return the redemption value of `amount` BUs for a linear combination of historical baskets\n    /// @param basketNonces An array of basket nonces to do redemption from\n    /// @param portions {1} An array of Fix quantities\n    /// @param amount {BU}\n    /// @return erc20s The backing collateral erc20s\n    /// @return quantities {qTok} ERC20 token quantities equal to `amount` BUs\n    // Returns (erc20s, [quantity(e) * amount {as qTok} for e in erc20s])\n    function quoteCustomRedemption(\n        uint48[] memory basketNonces,\n        uint192[] memory portions,\n        uint192 amount\n    ) external view returns (address[] memory erc20s, uint256[] memory quantities) {\n        require(basketNonces.length == portions.length, \"portions does not mirror basketNonces\");\n\n        IERC20[] memory erc20sAll = new IERC20[](assetRegistry.size());\n        uint192[] memory refAmtsAll = new uint192[](erc20sAll.length);\n\n        uint256 len; // length of return arrays\n\n        // Calculate the linear combination basket\n        for (uint48 i = 0; i < basketNonces.length; ++i) {\n            require(basketNonces[i] <= nonce, \"invalid basketNonce\");\n            Basket storage b = basketHistory[basketNonces[i]];\n\n            // Add-in refAmts contribution from historical basket\n            for (uint256 j = 0; j < b.erc20s.length; ++j) {\n                IERC20 erc20 = b.erc20s[j];\n                if (address(erc20) == address(0)) continue;\n\n                // Ugly search through erc20sAll\n                uint256 erc20Index = type(uint256).max;\n                for (uint256 k = 0; k < len; ++k) {\n                    if (erc20 == erc20sAll[k]) {\n                        erc20Index = k;\n                        continue;\n                    }\n                }\n\n                // Add new ERC20 entry if not found\n                uint192 amt = portions[i].mul(b.refAmts[erc20], FLOOR);\n                if (erc20Index == type(uint256).max) {\n                    erc20sAll[len] = erc20;\n\n                    // {ref} = {1} * {ref}\n                    refAmtsAll[len] = amt;\n                    ++len;\n                } else {\n                    // {ref} = {1} * {ref}\n                    refAmtsAll[erc20Index] += amt;\n                }\n            }\n        }\n\n        erc20s = new address[](len);\n        quantities = new uint256[](len);\n\n        // Calculate quantities\n        for (uint256 i = 0; i < len; ++i) {\n            erc20s[i] = address(erc20sAll[i]);\n\n            try assetRegistry.toAsset(IERC20(erc20s[i])) returns (IAsset asset) {\n                if (!asset.isCollateral()) continue; // skip token if no longer registered\n\n                // {tok} = {BU} * {ref/BU} / {ref/tok}\n                quantities[i] = safeMulDivFloor(\n                    amount,\n                    refAmtsAll[i],\n                    ICollateral(address(asset)).refPerTok()\n                ).shiftl_toUint(int8(asset.erc20Decimals()), FLOOR);\n                // marginally more penalizing than its sibling calculation that uses _quantity()\n                // because does not intermediately CEIL as part of the division\n            } catch (bytes memory errData) {\n                // untested:\n                //     OOG pattern tested in other contracts, cost to test here is high\n                // see: docs/solidity-style.md#Catching-Empty-Data\n                if (errData.length == 0) revert(); // solhint-disable-line reason-string\n            }\n        }\n    }\n\n    /// @return baskets {BU}\n    ///          .top The number of partial basket units: e.g max(coll.map((c) => c.balAsBUs())\n    ///          .bottom The number of whole basket units held by the account\n    /// @dev Returns (FIX_ZERO, FIX_MAX) for an empty or DISABLED basket\n    // Returns:\n    //    (0, 0), if (basket.erc20s is empty) or (disabled is true) or (status() is DISABLED)\n    //    min(e.balanceOf(account) / quantity(e) for e in basket.erc20s if quantity(e) > 0),\n    function basketsHeldBy(address account) public view returns (BasketRange memory baskets) {\n        uint256 length = basket.erc20s.length;\n        if (length == 0 || disabled) return BasketRange(FIX_ZERO, FIX_MAX);\n        baskets.bottom = FIX_MAX;\n\n        for (uint256 i = 0; i < length; ++i) {\n            ICollateral coll = assetRegistry.toColl(basket.erc20s[i]);\n            if (coll.status() == CollateralStatus.DISABLED) return BasketRange(FIX_ZERO, FIX_MAX);\n\n            uint192 refPerTok = coll.refPerTok();\n            // If refPerTok is 0, then we have zero of coll's reference unit.\n            // We know that basket.refAmts[basket.erc20s[i]] > 0, so we have no baskets.\n            if (refPerTok == 0) return BasketRange(FIX_ZERO, FIX_MAX);\n\n            // {tok/BU} = {ref/BU} / {ref/tok}.  0-division averted by condition above.\n            uint192 q = basket.refAmts[basket.erc20s[i]].div(refPerTok, CEIL);\n            // q > 0 because q = (n).div(_, CEIL) and n > 0\n\n            // {BU} = {tok} / {tok/BU}\n            uint192 inBUs = coll.bal(account).div(q);\n            baskets.bottom = fixMin(baskets.bottom, inBUs);\n            baskets.top = fixMax(baskets.top, inBUs);\n        }\n    }\n\n    // === Governance Setters ===\n\n    /// @custom:governance\n    function setWarmupPeriod(uint48 val) public governance {\n        require(val >= MIN_WARMUP_PERIOD && val <= MAX_WARMUP_PERIOD, \"invalid warmupPeriod\");\n        emit WarmupPeriodSet(warmupPeriod, val);\n        warmupPeriod = val;\n    }\n\n    // === Private ===\n\n    /// Select and save the next basket, based on the BasketConfig and Collateral statuses\n    function _switchBasket() private {\n        // Mark basket disabled. Pause most protocol functions unless there is a next basket\n        disabled = true;\n\n        bool success = _newBasket.nextBasket(_targetNames, config, assetRegistry);\n        // if success is true: _newBasket is the next basket\n\n        if (success) {\n            // nonce' = nonce + 1\n            // basket' = _newBasket\n            // timestamp' = now\n\n            nonce += 1;\n            basket.setFrom(_newBasket);\n            basketHistory[nonce].setFrom(_newBasket);\n            timestamp = uint48(block.timestamp);\n            disabled = false;\n        }\n\n        // Keep records, emit event\n        uint256 len = basket.erc20s.length;\n        uint192[] memory refAmts = new uint192[](len);\n        for (uint256 i = 0; i < len; ++i) {\n            refAmts[i] = basket.refAmts[basket.erc20s[i]];\n        }\n        emit BasketSet(nonce, basket.erc20s, refAmts, disabled);\n    }\n\n    /// Require that newERC20s and newTargetAmts preserve the current config targets\n    function requireConstantConfigTargets(\n        IERC20[] calldata newERC20s,\n        uint192[] calldata newTargetAmts\n    ) private {\n        // Empty _targetAmts mapping\n        while (_targetAmts.length() > 0) {\n            (bytes32 key, ) = _targetAmts.at(0);\n            _targetAmts.remove(key);\n        }\n\n        // Populate _targetAmts mapping with old basket config\n        uint256 len = config.erc20s.length;\n        for (uint256 i = 0; i < len; ++i) {\n            IERC20 erc20 = config.erc20s[i];\n            bytes32 targetName = config.targetNames[erc20];\n            (bool contains, uint256 amt) = _targetAmts.tryGet(targetName);\n            _targetAmts.set(\n                targetName,\n                contains ? amt + config.targetAmts[erc20] : config.targetAmts[erc20]\n            );\n        }\n\n        // Require new basket is exactly equal to old basket, in terms of targetAmts by targetName\n        len = newERC20s.length;\n        for (uint256 i = 0; i < len; ++i) {\n            bytes32 targetName = assetRegistry.toColl(newERC20s[i]).targetName();\n            (bool contains, uint256 amt) = _targetAmts.tryGet(targetName);\n            require(contains && amt >= newTargetAmts[i], \"new basket adds target weights\");\n            if (amt > newTargetAmts[i]) _targetAmts.set(targetName, amt - newTargetAmts[i]);\n            else _targetAmts.remove(targetName);\n        }\n        require(_targetAmts.length() == 0, \"new basket missing target weights\");\n    }\n\n    /// Require that erc20s is a valid collateral array\n    function requireValidCollArray(IERC20[] calldata erc20s) private view {\n        IERC20 zero = IERC20(address(0));\n\n        for (uint256 i = 0; i < erc20s.length; i++) {\n            require(erc20s[i] != rsr, \"RSR is not valid collateral\");\n            require(erc20s[i] != IERC20(address(rToken)), \"RToken is not valid collateral\");\n            require(erc20s[i] != IERC20(address(stRSR)), \"stRSR is not valid collateral\");\n            require(erc20s[i] != zero, \"address zero is not valid collateral\");\n        }\n\n        require(ArrayLib.allUnique(erc20s), \"contains duplicates\");\n    }\n\n    // ==== FacadeRead views ====\n    // Not used in-protocol; helpful for reconstructing state\n\n    /// Get a reference basket in today's collateral tokens, by nonce\n    /// @param basketNonce {basketNonce}\n    /// @return erc20s The erc20s in the reference basket\n    /// @return quantities {qTok/BU} The quantity of whole tokens per whole basket unit\n    function getHistoricalBasket(uint48 basketNonce)\n        external\n        view\n        returns (IERC20[] memory erc20s, uint256[] memory quantities)\n    {\n        Basket storage b = basketHistory[basketNonce];\n        erc20s = new IERC20[](b.erc20s.length);\n        quantities = new uint256[](erc20s.length);\n\n        for (uint256 i = 0; i < b.erc20s.length; ++i) {\n            erc20s[i] = b.erc20s[i];\n\n            try assetRegistry.toAsset(IERC20(erc20s[i])) returns (IAsset asset) {\n                if (!asset.isCollateral()) continue; // skip token if no longer registered\n\n                // {tok} = {BU} * {ref/BU} / {ref/tok}\n                quantities[i] = safeMulDivFloor(\n                    FIX_ONE,\n                    b.refAmts[erc20s[i]],\n                    ICollateral(address(asset)).refPerTok()\n                ).shiftl_toUint(int8(asset.erc20Decimals()), FLOOR);\n            } catch (bytes memory errData) {\n                // untested:\n                //     OOG pattern tested in other contracts, cost to test here is high\n                // see: docs/solidity-style.md#Catching-Empty-Data\n                if (errData.length == 0) revert(); // solhint-disable-line reason-string\n            }\n        }\n    }\n\n    /// Getter part1 for `config` struct variable\n    /// @dev Indices are shared across return values\n    /// @return erc20s The erc20s in the prime basket\n    /// @return targetNames The bytes32 name identifier of the target unit, per ERC20\n    /// @return targetAmts {target/BU} The amount of the target unit in the basket, per ERC20\n    function getPrimeBasket()\n        external\n        view\n        returns (\n            IERC20[] memory erc20s,\n            bytes32[] memory targetNames,\n            uint192[] memory targetAmts\n        )\n    {\n        erc20s = new IERC20[](config.erc20s.length);\n        targetNames = new bytes32[](erc20s.length);\n        targetAmts = new uint192[](erc20s.length);\n\n        for (uint256 i = 0; i < erc20s.length; ++i) {\n            erc20s[i] = config.erc20s[i];\n            targetNames[i] = config.targetNames[erc20s[i]];\n            targetAmts[i] = config.targetAmts[erc20s[i]];\n        }\n    }\n\n    /// Getter part2 for `config` struct variable\n    /// @param targetName The name of the target unit to lookup the backup for\n    /// @return erc20s The backup erc20s for the target unit, in order of most to least desirable\n    /// @return max The maximum number of tokens from the array to use at a single time\n    function getBackupConfig(bytes32 targetName)\n        external\n        view\n        returns (IERC20[] memory erc20s, uint256 max)\n    {\n        BackupConfig storage backup = config.backups[targetName];\n        erc20s = new IERC20[](backup.erc20s.length);\n        for (uint256 i = 0; i < erc20s.length; ++i) {\n            erc20s[i] = backup.erc20s[i];\n        }\n        max = backup.max;\n    }\n\n    // === Private ===\n\n    /// @return The floored result of FixLib.mulDiv\n    function safeMulDivFloor(\n        uint192 x,\n        uint192 y,\n        uint192 z\n    ) private view returns (uint192) {\n        try backingManager.mulDiv(x, y, z, FLOOR) returns (uint192 result) {\n            return result;\n        } catch Panic(uint256 errorCode) {\n            // 0x11: overflow\n            // 0x12: div-by-zero\n            assert(errorCode == 0x11 || errorCode == 0x12);\n        } catch (bytes memory reason) {\n            assert(keccak256(reason) == UIntOutofBoundsHash);\n        }\n        return FIX_MAX;\n    }\n\n    // ==== Storage Gap ====\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[37] private __gap;\n}"
    },
    {
      "filename": "contracts/p1/BasketHandler.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"../interfaces/IAssetRegistry.sol\";\nimport \"../interfaces/IBasketHandler.sol\";\nimport \"../interfaces/IMain.sol\";\nimport \"../libraries/Array.sol\";\nimport \"../libraries/Fixed.sol\";\nimport \"./mixins/BasketLib.sol\";\nimport \"./mixins/Component.sol\";\n\n/**\n * @title BasketHandler\n * @notice Handles the basket configuration, definition, and evolution over time.\n */\ncontract BasketHandlerP1 is ComponentP1, IBasketHandler {\n    using BasketLibP1 for Basket;\n    using EnumerableMap for EnumerableMap.Bytes32ToUintMap;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using CollateralStatusComparator for CollateralStatus;\n    using FixLib for uint192;\n\n    uint192 public constant MAX_TARGET_AMT = 1e3 * FIX_ONE; // {target/BU} max basket weight\n    uint48 public constant MIN_WARMUP_PERIOD = 60; // {s} 1 minute\n    uint48 public constant MAX_WARMUP_PERIOD = 31536000; // {s} 1 year\n\n    // Peer components\n    IAssetRegistry private assetRegistry;\n    IBackingManager private backingManager;\n    IERC20 private rsr;\n    IRToken private rToken;\n    IStRSR private stRSR;\n\n    // config is the basket configuration, from which basket will be computed in a basket-switch\n    // event. config is only modified by governance through setPrimeBakset and setBackupConfig\n    BasketConfig private config;\n\n    // basket, disabled, nonce, and timestamp are only ever set by `_switchBasket()`\n    // basket is the current basket.\n    Basket private basket;\n\n    uint48 public nonce; // {basketNonce} A unique identifier for this basket instance\n    uint48 public timestamp; // The timestamp when this basket was last set\n\n    // If disabled is true, status() is DISABLED, the basket is invalid,\n    // and everything except redemption should be paused.\n    bool private disabled;\n\n    // === Function-local transitory vars ===\n\n    // These are effectively local variables of _switchBasket.\n    // Nothing should use their values from previous transactions.\n    EnumerableSet.Bytes32Set private _targetNames;\n    Basket private _newBasket;\n\n    // === Warmup Period ===\n    // Added in 3.0.0\n\n    // Warmup Period\n    uint48 public warmupPeriod; // {s} how long to wait until issuance/trading after regaining SOUND\n\n    // basket status changes, mainly set when `trackStatus()` is called\n    // used to enforce warmup period, after regaining SOUND\n    uint48 private lastStatusTimestamp;\n    CollateralStatus private lastStatus;\n\n    // === Historical basket nonces ===\n    // Added in 3.0.0\n\n    // A history of baskets by basket nonce; includes current basket\n    mapping(uint48 => Basket) private basketHistory;\n\n    // Effectively local variable of `requireConstantConfigTargets()`\n    EnumerableMap.Bytes32ToUintMap private _targetAmts; // targetName -> {target/BU}\n\n    // ===\n\n    // ==== Invariants ====\n    // basket is a valid Basket:\n    //   basket.erc20s is a valid collateral array and basket.erc20s == keys(basket.refAmts)\n    // config is a valid BasketConfig:\n    //   erc20s == keys(targetAmts) == keys(targetNames)\n    //   erc20s is a valid collateral array\n    //   for b in vals(backups), b.erc20s is a valid collateral array.\n    // if basket.erc20s is empty then disabled == true\n\n    // BasketHandler.init() just leaves the BasketHandler state zeroed\n    function init(IMain main_, uint48 warmupPeriod_) external initializer {\n        __Component_init(main_);\n\n        assetRegistry = main_.assetRegistry();\n        backingManager = main_.backingManager();\n        rsr = main_.rsr();\n        rToken = main_.rToken();\n        stRSR = main_.stRSR();\n\n        setWarmupPeriod(warmupPeriod_);\n\n        // Set last status to DISABLED (default)\n        lastStatus = CollateralStatus.DISABLED;"
    }
  ]
}