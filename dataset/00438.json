{
  "Title": "M-19: Balancer rebalance operation is permanently blocked whenever owner assigns `rebalancer` role to some other address",
  "Content": "# Issue M-19: Balancer rebalance operation is permanently blocked whenever owner assigns `rebalancer` role to some other address \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/89 \n\n## Found by \n0xadrii, bin2chen, ctf\\_sec, hyh\n## Summary\n\nBalancer's `rebalance()` controls access rights by requesting `msg.sender` to simultaneously be owner and `rebalancer`, which blocks it whenever this role is assigned to any other address besides owner's (that should be the case for production use).\n\n## Vulnerability Detail\n\nBalancer's core operation can be blocked due to structuring of the access control check, which requires `msg.sender` to have both roles instead of either one of them.\n\n## Impact\n\nRebalancing, which is core functionality for mTOFT workflow, becomes inaccessible once owner transfers the `rebalancer` role elsewhere. To unblock the functionality the role has to be returned to the owner address and kept there, so rebalancing will have to be performed only directly from owner, which brings in operational risks as keeper operations will have to be run from owner account permanently, which can be compromised with higher probability this way.\n\nAlso, there is an impact of having `rebalancer` role set to a keeper bot and being unable to perform the rebalancing for a while until protocol will have role reassigned and the scripts run from owner account. This additional time needed can be crucial for user operations and in some situations lead to loss of funds.\n\nLikelihood: Low + Impact: High = Severity: Medium.\n\n## Code Snippet\n\nInitially `owner` and `rebalancer` are set to the same address:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/Balancer.sol#L101-L110\n\n```solidity\n    constructor(address _routerETH, address _router, address _owner) {\n        ...\n\n        transferOwnership(_owner);\n        rebalancer = _owner;\n        emit RebalancerUpdated(address(0), _owner);\n    }\n```\n\nOwner can then transfer `rebalancer` role to some other address, e.g. some keeper contract:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/Balancer.sol#L142-L149\n\n```solidity\n    /**\n     * @notice set rebalancer role\n     * @param _addr the new address\n     */\n    function setRebalancer(address _addr) external onlyOwner {\n >>     rebalancer = _addr;\n        emit RebalancerUpdated(rebalancer, _addr);\n    }\n```\n\nOnce owner transfers `rebalancer` role to anyone else, it will be impossible to rebalance as it's always `(msg.sender != owner() || msg.sender != rebalancer) == true`:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/Balancer.sol#L160-L176\n\n```solidity\n    /**\n     * @notice performs a rebalance operation\n     * @dev callable only by the owner\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _slippage the destination LayerZero id\n     * @param _amount the rebalanced amount\n     * @param _ercData custom send data\n     */\n    function rebalance(\n        address payable _srcOft,\n        uint16 _dstChainId,\n        uint256 _slippage,\n        uint256 _amount,\n        bytes memory _ercData\n    ) external payable onlyValidDestination(_srcOft, _dstChainId) onlyValidSlippage(_slippage) {\n>>      if (msg.sender != owner() || msg.sender != rebalancer) revert NotAuthorized();\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider updating the access control to allow either owner or `rebalancer`, e.g.:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/Balancer.sol#L169-L176\n\n```diff\n    function rebalance(\n        ...\n    ) external payable onlyValidDestination(_srcOft, _dstChainId) onlyValidSlippage(_slippage) {\n-       if (msg.sender != owner() || msg.sender != rebalancer) revert NotAuthorized();\n+       if (msg.sender != owner() && msg.sender != rebalancer) revert NotAuthorized();\n```\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  the natspec says \"callable only by the owner\", which means the rebalancer role should be both owner and rebalancer which makes this invalid\n\n\n\n**cryptotechmaker**\n\nLow.\nThat was the initial intention. However, we'll fix it. \n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/TapiocaZ/pull/179.\n\n**nevillehuang**\n\n@cryptotechmaker Why was this the initial intention? I am inclined to keep medium severity given a direct code change was made to unblock DoS.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "TapiocaZ/contracts/Balancer.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {IStargateRouter, IStargateRouterBase} from \"tapioca-periph/interfaces/external/stargate/IStargateRouter.sol\";\nimport {IStargateEthVault} from \"tapioca-periph/interfaces/external/stargate/IStargateEthVault.sol\";\nimport {ITOFTVault} from \"tapioca-periph/interfaces/tapiocaz/ITOFTVault.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title Balancer\n * @author TapiocaDAO\n * @notice Rebalances mTOFT by transferring underlying tokens to other layers through Stargate\n */\ncontract Balancer is Ownable {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice current OFT => chain => destination OFT\n     * @dev chain ids (https://stargateprotocol.gitbook.io/stargate/developers/chain-ids):\n     *         - Ethereum: 101\n     *         - BNB: 102\n     *         - Avalanche: 106\n     *         - Polygon: 109\n     *         - Arbitrum: 110\n     *         - Optimism: 111\n     *         - Fantom: 112\n     *         - Metis: 151\n     *     pool ids https://stargateprotocol.gitbook.io/stargate/developers/pool-ids\n     */\n    mapping(address => mapping(uint16 => OFTData)) public connectedOFTs;\n\n    struct OFTData {\n        uint256 srcPoolId;\n        uint256 dstPoolId;\n        address dstOft;\n        uint256 rebalanceable;\n    }\n\n    IStargateRouter public immutable routerETH;\n    IStargateRouter public immutable router;\n\n    address public rebalancer;\n\n    // @dev swapEth is not available on some chains\n    bool public disableEth;\n\n    event ConnectedChainUpdated(address indexed _srcOft, uint16 indexed _dstChainId, address indexed _dstOft);\n    event Rebalanced(\n        address indexed _srcOft, uint16 indexed _dstChainId, uint256 indexed _slippage, uint256 _amount, bool _isNative\n    );\n    event RebalanceAmountUpdated(\n        address indexed _srcOft, uint16 indexed _dstChainId, uint256 indexed _amount, uint256 _totalAmount\n    );\n    event ToggledSwapEth(bool indexed _old, bool indexed _new);\n    event EmergencySaved(address indexed _token, uint256 indexed _amount, bool indexed _native);\n    event RebalancerUpdated(address indexed prev, address indexed current);\n\n    error NotAuthorized();\n    error RouterNotValid();\n    error ExceedsBalance();\n    error DestinationNotValid();\n    error SlippageNotValid();\n    error FeeAmountNotSet();\n    error PoolInfoRequired();\n    error RebalanceAmountNotSet();\n    error Failed();\n    error SwapNotEnabled();\n    error AlreadyInitialized();\n    error RebalanceAmountNotValid();\n\n    modifier onlyValidDestination(address _srcOft, uint16 _dstChainId) {\n        if (connectedOFTs[_srcOft][_dstChainId].dstOft == address(0)) {\n            revert DestinationNotValid();\n        }\n        _;\n    }\n\n    modifier onlyValidSlippage(uint256 _slippage) {\n        // @dev a slippage higher than 20% shouldn't be necessary\n        if (_slippage >= 2e4) revert SlippageNotValid();\n        _;\n    }\n\n    constructor(address _routerETH, address _router, address _owner) {\n        if (_router == address(0)) revert RouterNotValid();\n        if (_routerETH == address(0)) revert RouterNotValid();\n        routerETH = IStargateRouter(_routerETH);\n        router = IStargateRouter(_router);\n\n        transferOwnership(_owner);\n        rebalancer = _owner;\n        emit RebalancerUpdated(address(0), _owner);\n    }\n\n    receive() external payable {}\n\n    /// =====================\n    /// View\n    /// =====================\n    function checker(address payable _srcOft, uint16 _dstChainId, uint256 _slippage)\n        external\n        view\n        returns (bool canExec, bytes memory execPayload)\n    {\n        bytes memory ercData;\n        {\n            if (ITOFT(_srcOft).erc20() != address(0)) {\n                ercData = abi.encode(\n                    connectedOFTs[_srcOft][_dstChainId].srcPoolId, connectedOFTs[_srcOft][_dstChainId].dstPoolId\n                );\n            }\n        }\n\n        canExec = connectedOFTs[_srcOft][_dstChainId].rebalanceable > 0;\n        execPayload = abi.encodeCall(\n            Balancer.rebalance,\n            (_srcOft, _dstChainId, _slippage, connectedOFTs[_srcOft][_dstChainId].rebalanceable, ercData)\n        );\n    }\n\n    /// =====================\n    /// Owner\n    /// =====================\n\n    /**\n     * @notice set rebalancer role\n     * @param _addr the new address\n     */\n    function setRebalancer(address _addr) external onlyOwner {\n        rebalancer = _addr;\n        emit RebalancerUpdated(rebalancer, _addr);\n    }\n\n    /**\n     * @notice toggle swap eth\n     * @param _val true/false\n     */\n    function setSwapEth(bool _val) external onlyOwner {\n        emit ToggledSwapEth(disableEth, _val);\n        disableEth = _val;\n    }\n\n    /**\n     * @notice performs a rebalance operation\n     * @dev callable only by the owner\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _slippage the destination LayerZero id\n     * @param _amount the rebalanced amount\n     * @param _ercData custom send data\n     */\n    function rebalance(\n        address payable _srcOft,\n        uint16 _dstChainId,\n        uint256 _slippage,\n        uint256 _amount,\n        bytes memory _ercData\n    ) external payable onlyValidDestination(_srcOft, _dstChainId) onlyValidSlippage(_slippage) {\n        if (msg.sender != owner() || msg.sender != rebalancer) revert NotAuthorized();\n\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable < _amount) {\n            revert RebalanceAmountNotSet();\n        }\n\n        //extract\n        ITOFT(_srcOft).extractUnderlying(_amount);\n\n        //send\n        {\n            bool _isNative = ITOFT(_srcOft).erc20() == address(0);\n            if (msg.value == 0) revert FeeAmountNotSet();\n            if (_isNative) {\n                if (disableEth) revert SwapNotEnabled();\n                _sendNative(_srcOft, _amount, _dstChainId, _slippage);\n            } else {\n                _sendToken(_srcOft, _amount, _dstChainId, _slippage, _ercData);\n            }\n\n            connectedOFTs[_srcOft][_dstChainId].rebalanceable -= _amount;\n            emit Rebalanced(_srcOft, _dstChainId, _slippage, _amount, _isNative);\n        }\n    }\n\n    /**\n     * @notice saves token/native gas from this contract\n     * @param _token the token address; `address(0)` should be passed for the Native coin\n     * @param _amount the amount to be saved\n     */\n    function emergencySaveTokens(address _token, uint256 _amount) external onlyOwner {\n        if (_token == address(0)) {\n            (bool sent,) = msg.sender.call{value: _amount}(\"\");\n            if (!sent) revert Failed();\n            emit EmergencySaved(_token, _amount, true);\n        } else {\n            IERC20(_token).safeTransfer(msg.sender, _amount);\n            emit EmergencySaved(_token, _amount, false);\n        }\n    }\n\n    /**\n     * @notice registeres mTapiocaOFT for rebalancing\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _dstOft the destination TOFT address\n     * @param _ercData custom send data\n     */\n    function initConnectedOFT(address _srcOft, uint16 _dstChainId, address _dstOft, bytes memory _ercData)\n        external\n        onlyOwner\n    {\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable > 0) {\n            revert AlreadyInitialized();\n        }\n        bool isNative = ITOFT(_srcOft).erc20() == address(0);\n        if (!isNative && _ercData.length == 0) revert PoolInfoRequired();\n\n        (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(_ercData, (uint256, uint256));\n\n        OFTData memory oftData =\n            OFTData({srcPoolId: _srcPoolId, dstPoolId: _dstPoolId, dstOft: _dstOft, rebalanceable: 0});\n\n        connectedOFTs[_srcOft][_dstChainId] = oftData;\n        emit ConnectedChainUpdated(_srcOft, _dstChainId, _dstOft);\n    }\n\n    /**\n     * @notice assings more rebalanceable amount for TOFT\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _amount the rebalanced amount\n     */\n    function addRebalanceAmount(address _srcOft, uint16 _dstChainId, uint256 _amount)\n        external\n        onlyValidDestination(_srcOft, _dstChainId)\n        onlyOwner\n    {\n        connectedOFTs[_srcOft][_dstChainId].rebalanceable += _amount;\n        uint256 totalToftSupply = ITOFTVault(ITOFT(_srcOft).vault()).viewSupply();\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable > totalToftSupply) {\n            revert RebalanceAmountNotValid();\n        }\n        emit RebalanceAmountUpdated(_srcOft, _dstChainId, _amount, connectedOFTs[_srcOft][_dstChainId].rebalanceable);\n    }\n\n    function retryRevert(uint16 _srcChainId, bytes calldata _srcAddress, uint256 _nonce) external payable onlyOwner {\n        router.retryRevert{value: msg.value}(_srcChainId, _srcAddress, _nonce);\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n    function _sendNative(address payable _oft, uint256 _amount, uint16 _dstChainId, uint256 _slippage) private {\n        if (address(this).balance < _amount) revert ExceedsBalance();\n        uint256 valueAmount = msg.value + _amount;\n        routerETH.swapETH{value: valueAmount}(\n            _dstChainId,\n            payable(this),\n            abi.encodePacked(connectedOFTs[_oft][_dstChainId].dstOft),\n            _amount,\n            _computeMinAmount(_amount, _slippage)\n        );\n    }\n\n    function _sendToken(\n        address payable _oft,\n        uint256 _amount,\n        uint16 _dstChainId,\n        uint256 _slippage,\n        bytes memory _data\n    ) private {\n        address erc20 = ITOFT(_oft).erc20();\n        if (IERC20Metadata(erc20).balanceOf(address(this)) < _amount) {\n            revert ExceedsBalance();\n        }\n        {\n            (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(_data, (uint256, uint256));\n            _routerSwap(_dstChainId, _srcPoolId, _dstPoolId, _amount, _slippage, _oft, erc20);\n        }\n    }\n\n    function _routerSwap(\n        uint16 _dstChainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        uint256 _amount,\n        uint256 _slippage,\n        address payable _oft,\n        address _erc20\n    ) private {\n        bytes memory _dst = abi.encodePacked(connectedOFTs[_oft][_dstChainId].dstOft);\n        IERC20(_erc20).safeApprove(address(router), _amount);\n        router.swap{value: msg.value}(\n            _dstChainId,\n            _srcPoolId,\n            _dstPoolId,\n            payable(this),\n            _amount,\n            _computeMinAmount(_amount, _slippage),\n            IStargateRouterBase.lzTxObj({dstGasForCall: 0, dstNativeAmount: 0, dstNativeAddr: \"0x0\"}),\n            _dst,\n            \"0x\"\n        );\n    }\n\n    function _computeMinAmount(uint256 _amount, uint256 _slippage) private pure returns (uint256) {\n        return _amount - ((_amount * _slippage) / 1e5);\n    }\n}"
    },
    {
      "filename": "TapiocaZ/contracts/Balancer.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {IStargateRouter, IStargateRouterBase} from \"tapioca-periph/interfaces/external/stargate/IStargateRouter.sol\";\nimport {IStargateEthVault} from \"tapioca-periph/interfaces/external/stargate/IStargateEthVault.sol\";\nimport {ITOFTVault} from \"tapioca-periph/interfaces/tapiocaz/ITOFTVault.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title Balancer\n * @author TapiocaDAO\n * @notice Rebalances mTOFT by transferring underlying tokens to other layers through Stargate\n */\ncontract Balancer is Ownable {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice current OFT => chain => destination OFT\n     * @dev chain ids (https://stargateprotocol.gitbook.io/stargate/developers/chain-ids):\n     *         - Ethereum: 101\n     *         - BNB: 102\n     *         - Avalanche: 106\n     *         - Polygon: 109\n     *         - Arbitrum: 110\n     *         - Optimism: 111\n     *         - Fantom: 112\n     *         - Metis: 151\n     *     pool ids https://stargateprotocol.gitbook.io/stargate/developers/pool-ids\n     */\n    mapping(address => mapping(uint16 => OFTData)) public connectedOFTs;\n\n    struct OFTData {\n        uint256 srcPoolId;\n        uint256 dstPoolId;\n        address dstOft;\n        uint256 rebalanceable;\n    }\n\n    IStargateRouter public immutable routerETH;\n    IStargateRouter public immutable router;\n\n    address public rebalancer;\n\n    // @dev swapEth is not available on some chains\n    bool public disableEth;\n\n    event ConnectedChainUpdated(address indexed _srcOft, uint16 indexed _dstChainId, address indexed _dstOft);\n    event Rebalanced(\n        address indexed _srcOft, uint16 indexed _dstChainId, uint256 indexed _slippage, uint256 _amount, bool _isNative\n    );\n    event RebalanceAmountUpdated(\n        address indexed _srcOft, uint16 indexed _dstChainId, uint256 indexed _amount, uint256 _totalAmount\n    );\n    event ToggledSwapEth(bool indexed _old, bool indexed _new);\n    event EmergencySaved(address indexed _token, uint256 indexed _amount, bool indexed _native);\n    event RebalancerUpdated(address indexed prev, address indexed current);\n\n    error NotAuthorized();\n    error RouterNotValid();\n    error ExceedsBalance();\n    error DestinationNotValid();\n    error SlippageNotValid();\n    error FeeAmountNotSet();\n    error PoolInfoRequired();\n    error RebalanceAmountNotSet();\n    error Failed();\n    error SwapNotEnabled();\n    error AlreadyInitialized();\n    error RebalanceAmountNotValid();\n\n    modifier onlyValidDestination(address _srcOft, uint16 _dstChainId) {\n        if (connectedOFTs[_srcOft][_dstChainId].dstOft == address(0)) {\n            revert DestinationNotValid();\n        }\n        _;\n    }\n\n    modifier onlyValidSlippage(uint256 _slippage) {\n        // @dev a slippage higher than 20% shouldn't be necessary\n        if (_slippage >= 2e4) revert SlippageNotValid();\n        _;\n    }\n\n    constructor(address _routerETH, address _router, address _owner) {\n        if (_router == address(0)) revert RouterNotValid();\n        if (_routerETH == address(0)) revert RouterNotValid();\n        routerETH = IStargateRouter(_routerETH);\n        router = IStargateRouter(_router);\n\n        transferOwnership(_owner);\n        rebalancer = _owner;\n        emit RebalancerUpdated(address(0), _owner);\n    }\n\n    receive() external payable {}\n\n    /// =====================\n    /// View\n    /// =====================\n    function checker(address payable _srcOft, uint16 _dstChainId, uint256 _slippage)\n        external\n        view\n        returns (bool canExec, bytes memory execPayload)\n    {\n        bytes memory ercData;\n        {\n            if (ITOFT(_srcOft).erc20() != address(0)) {\n                ercData = abi.encode(\n                    connectedOFTs[_srcOft][_dstChainId].srcPoolId, connectedOFTs[_srcOft][_dstChainId].dstPoolId\n                );\n            }\n        }\n\n        canExec = connectedOFTs[_srcOft][_dstChainId].rebalanceable > 0;\n        execPayload = abi.encodeCall(\n            Balancer.rebalance,\n            (_srcOft, _dstChainId, _slippage, connectedOFTs[_srcOft][_dstChainId].rebalanceable, ercData)\n        );\n    }\n\n    /// =====================\n    /// Owner\n    /// =====================\n\n    /**\n     * @notice set rebalancer role\n     * @param _addr the new address\n     */\n    function setRebalancer(address _addr) external onlyOwner {\n        rebalancer = _addr;\n        emit RebalancerUpdated(rebalancer, _addr);\n    }\n\n    /**\n     * @notice toggle swap eth\n     * @param _val true/false\n     */\n    function setSwapEth(bool _val) external onlyOwner {\n        emit ToggledSwapEth(disableEth, _val);\n        disableEth = _val;\n    }\n\n    /**\n     * @notice performs a rebalance operation\n     * @dev callable only by the owner\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _slippage the destination LayerZero id\n     * @param _amount the rebalanced amount\n     * @param _ercData custom send data\n     */\n    function rebalance(\n        address payable _srcOft,\n        uint16 _dstChainId,\n        uint256 _slippage,\n        uint256 _amount,\n        bytes memory _ercData\n    ) external payable onlyValidDestination(_srcOft, _dstChainId) onlyValidSlippage(_slippage) {\n        if (msg.sender != owner() || msg.sender != rebalancer) revert NotAuthorized();\n\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable < _amount) {\n            revert RebalanceAmountNotSet();\n        }\n\n        //extract\n        ITOFT(_srcOft).extractUnderlying(_amount);\n\n        //send\n        {\n            bool _isNative = ITOFT(_srcOft).erc20() == address(0);\n            if (msg.value == 0) revert FeeAmountNotSet();\n            if (_isNative) {\n                if (disableEth) revert SwapNotEnabled();\n                _sendNative(_srcOft, _amount, _dstChainId, _slippage);\n            } else {\n                _sendToken(_srcOft, _amount, _dstChainId, _slippage, _ercData);\n            }\n\n            connectedOFTs[_srcOft][_dstChainId].rebalanceable -= _amount;\n            emit Rebalanced(_srcOft, _dstChainId, _slippage, _amount, _isNative);\n        }\n    }\n\n    /**\n     * @notice saves token/native gas from this contract\n     * @param _token the token address; `address(0)` should be passed for the Native coin\n     * @param _amount the amount to be saved\n     */\n    function emergencySaveTokens(address _token, uint256 _amount) external onlyOwner {\n        if (_token == address(0)) {\n            (bool sent,) = msg.sender.call{value: _amount}(\"\");\n            if (!sent) revert Failed();\n            emit EmergencySaved(_token, _amount, true);\n        } else {\n            IERC20(_token).safeTransfer(msg.sender, _amount);\n            emit EmergencySaved(_token, _amount, false);\n        }\n    }\n\n    /**\n     * @notice registeres mTapiocaOFT for rebalancing\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _dstOft the destination TOFT address\n     * @param _ercData custom send data\n     */\n    function initConnectedOFT(address _srcOft, uint16 _dstChainId, address _dstOft, bytes memory _ercData)\n        external\n        onlyOwner\n    {\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable > 0) {\n            revert AlreadyInitialized();\n        }\n        bool isNative = ITOFT(_srcOft).erc20() == address(0);\n        if (!isNative && _ercData.length == 0) revert PoolInfoRequired();\n\n        (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(_ercData, (uint256, uint256));\n\n        OFTData memory oftData =\n            OFTData({srcPoolId: _srcPoolId, dstPoolId: _dstPoolId, dstOft: _dstOft, rebalanceable: 0});\n\n        connectedOFTs[_srcOft][_dstChainId] = oftData;\n        emit ConnectedChainUpdated(_srcOft, _dstChainId, _dstOft);\n    }\n\n    /**\n     * @notice assings more rebalanceable amount for TOFT\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _amount the rebalanced amount\n     */\n    function addRebalanceAmount(address _srcOft, uint16 _dstChainId, uint256 _amount)\n        external\n        onlyValidDestination(_srcOft, _dstChainId)\n        onlyOwner\n    {\n        connectedOFTs[_srcOft][_dstChainId].rebalanceable += _amount;\n        uint256 totalToftSupply = ITOFTVault(ITOFT(_srcOft).vault()).viewSupply();\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable > totalToftSupply) {\n            revert RebalanceAmountNotValid();\n        }\n        emit RebalanceAmountUpdated(_srcOft, _dstChainId, _amount, connectedOFTs[_srcOft][_dstChainId].rebalanceable);\n    }\n\n    function retryRevert(uint16 _srcChainId, bytes calldata _srcAddress, uint256 _nonce) external payable onlyOwner {\n        router.retryRevert{value: msg.value}(_srcChainId, _srcAddress, _nonce);\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n    function _sendNative(address payable _oft, uint256 _amount, uint16 _dstChainId, uint256 _slippage) private {\n        if (address(this).balance < _amount) revert ExceedsBalance();\n        uint256 valueAmount = msg.value + _amount;\n        routerETH.swapETH{value: valueAmount}(\n            _dstChainId,\n            payable(this),\n            abi.encodePacked(connectedOFTs[_oft][_dstChainId].dstOft),\n            _amount,\n            _computeMinAmount(_amount, _slippage)\n        );\n    }\n\n    function _sendToken(\n        address payable _oft,\n        uint256 _amount,\n        uint16 _dstChainId,\n        uint256 _slippage,\n        bytes memory _data\n    ) private {\n        address erc20 = ITOFT(_oft).erc20();\n        if (IERC20Metadata(erc20).balanceOf(address(this)) < _amount) {\n            revert ExceedsBalance();\n        }\n        {\n            (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(_data, (uint256, uint256));\n            _routerSwap(_dstChainId, _srcPoolId, _dstPoolId, _amount, _slippage, _oft, erc20);\n        }\n    }\n\n    function _routerSwap(\n        uint16 _dstChainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        uint256 _amount,\n        uint256 _slippage,\n        address payable _oft,\n        address _erc20\n    ) private {\n        bytes memory _dst = abi.encodePacked(connectedOFTs[_oft][_dstChainId].dstOft);\n        IERC20(_erc20).safeApprove(address(router), _amount);\n        router.swap{value: msg.value}(\n            _dstChainId,\n            _srcPoolId,\n            _dstPoolId,\n            payable(this),\n            _amount,\n            _computeMinAmount(_amount, _slippage),\n            IStargateRouterBase.lzTxObj({dstGasForCall: 0, dstNativeAmount: 0, dstNativeAddr: \"0x0\"}),\n            _dst,\n            \"0x\"\n        );\n    }\n\n    function _computeMinAmount(uint256 _amount, uint256 _slippage) private pure returns (uint256) {\n        return _amount - ((_amount * _slippage) / 1e5);\n    }\n}"
    },
    {
      "filename": "TapiocaZ/contracts/Balancer.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {IStargateRouter, IStargateRouterBase} from \"tapioca-periph/interfaces/external/stargate/IStargateRouter.sol\";\nimport {IStargateEthVault} from \"tapioca-periph/interfaces/external/stargate/IStargateEthVault.sol\";\nimport {ITOFTVault} from \"tapioca-periph/interfaces/tapiocaz/ITOFTVault.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title Balancer\n * @author TapiocaDAO\n * @notice Rebalances mTOFT by transferring underlying tokens to other layers through Stargate\n */\ncontract Balancer is Ownable {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice current OFT => chain => destination OFT\n     * @dev chain ids (https://stargateprotocol.gitbook.io/stargate/developers/chain-ids):\n     *         - Ethereum: 101\n     *         - BNB: 102\n     *         - Avalanche: 106\n     *         - Polygon: 109\n     *         - Arbitrum: 110\n     *         - Optimism: 111\n     *         - Fantom: 112\n     *         - Metis: 151\n     *     pool ids https://stargateprotocol.gitbook.io/stargate/developers/pool-ids\n     */\n    mapping(address => mapping(uint16 => OFTData)) public connectedOFTs;\n\n    struct OFTData {\n        uint256 srcPoolId;\n        uint256 dstPoolId;\n        address dstOft;\n        uint256 rebalanceable;\n    }\n\n    IStargateRouter public immutable routerETH;\n    IStargateRouter public immutable router;\n\n    address public rebalancer;\n\n    // @dev swapEth is not available on some chains\n    bool public disableEth;\n\n    event ConnectedChainUpdated(address indexed _srcOft, uint16 indexed _dstChainId, address indexed _dstOft);\n    event Rebalanced(\n        address indexed _srcOft, uint16 indexed _dstChainId, uint256 indexed _slippage, uint256 _amount, bool _isNative\n    );\n    event RebalanceAmountUpdated(\n        address indexed _srcOft, uint16 indexed _dstChainId, uint256 indexed _amount, uint256 _totalAmount\n    );\n    event ToggledSwapEth(bool indexed _old, bool indexed _new);\n    event EmergencySaved(address indexed _token, uint256 indexed _amount, bool indexed _native);\n    event RebalancerUpdated(address indexed prev, address indexed current);\n\n    error NotAuthorized();\n    error RouterNotValid();\n    error ExceedsBalance();\n    error DestinationNotValid();\n    error SlippageNotValid();\n    error FeeAmountNotSet();\n    error PoolInfoRequired();\n    error RebalanceAmountNotSet();\n    error Failed();\n    error SwapNotEnabled();\n    error AlreadyInitialized();\n    error RebalanceAmountNotValid();\n\n    modifier onlyValidDestination(address _srcOft, uint16 _dstChainId) {\n        if (connectedOFTs[_srcOft][_dstChainId].dstOft == address(0)) {\n            revert DestinationNotValid();\n        }\n        _;\n    }\n\n    modifier onlyValidSlippage(uint256 _slippage) {\n        // @dev a slippage higher than 20% shouldn't be necessary\n        if (_slippage >= 2e4) revert SlippageNotValid();\n        _;\n    }\n\n    constructor(address _routerETH, address _router, address _owner) {\n        if (_router == address(0)) revert RouterNotValid();\n        if (_routerETH == address(0)) revert RouterNotValid();\n        routerETH = IStargateRouter(_routerETH);\n        router = IStargateRouter(_router);\n\n        transferOwnership(_owner);\n        rebalancer = _owner;\n        emit RebalancerUpdated(address(0), _owner);\n    }\n\n    receive() external payable {}\n\n    /// =====================\n    /// View\n    /// =====================\n    function checker(address payable _srcOft, uint16 _dstChainId, uint256 _slippage)\n        external\n        view\n        returns (bool canExec, bytes memory execPayload)\n    {\n        bytes memory ercData;\n        {\n            if (ITOFT(_srcOft).erc20() != address(0)) {\n                ercData = abi.encode(\n                    connectedOFTs[_srcOft][_dstChainId].srcPoolId, connectedOFTs[_srcOft][_dstChainId].dstPoolId\n                );\n            }\n        }\n\n        canExec = connectedOFTs[_srcOft][_dstChainId].rebalanceable > 0;\n        execPayload = abi.encodeCall(\n            Balancer.rebalance,\n            (_srcOft, _dstChainId, _slippage, connectedOFTs[_srcOft][_dstChainId].rebalanceable, ercData)\n        );\n    }\n\n    /// =====================\n    /// Owner\n    /// =====================\n\n    /**\n     * @notice set rebalancer role\n     * @param _addr the new address\n     */\n    function setRebalancer(address _addr) external onlyOwner {\n        rebalancer = _addr;\n        emit RebalancerUpdated(rebalancer, _addr);\n    }\n\n    /**\n     * @notice toggle swap eth\n     * @param _val true/false\n     */\n    function setSwapEth(bool _val) external onlyOwner {\n        emit ToggledSwapEth(disableEth, _val);\n        disableEth = _val;\n    }\n\n    /**\n     * @notice performs a rebalance operation\n     * @dev callable only by the owner\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _slippage the destination LayerZero id\n     * @param _amount the rebalanced amount\n     * @param _ercData custom send data\n     */\n    function rebalance(\n        address payable _srcOft,\n        uint16 _dstChainId,\n        uint256 _slippage,\n        uint256 _amount,\n        bytes memory _ercData\n    ) external payable onlyValidDestination(_srcOft, _dstChainId) onlyValidSlippage(_slippage) {\n        if (msg.sender != owner() || msg.sender != rebalancer) revert NotAuthorized();\n\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable < _amount) {\n            revert RebalanceAmountNotSet();\n        }\n\n        //extract\n        ITOFT(_srcOft).extractUnderlying(_amount);\n\n        //send\n        {\n            bool _isNative = ITOFT(_srcOft).erc20() == address(0);\n            if (msg.value == 0) revert FeeAmountNotSet();\n            if (_isNative) {\n                if (disableEth) revert SwapNotEnabled();\n                _sendNative(_srcOft, _amount, _dstChainId, _slippage);\n            } else {\n                _sendToken(_srcOft, _amount, _dstChainId, _slippage, _ercData);\n            }\n\n            connectedOFTs[_srcOft][_dstChainId].rebalanceable -= _amount;\n            emit Rebalanced(_srcOft, _dstChainId, _slippage, _amount, _isNative);\n        }\n    }\n\n    /**\n     * @notice saves token/native gas from this contract\n     * @param _token the token address; `address(0)` should be passed for the Native coin\n     * @param _amount the amount to be saved\n     */\n    function emergencySaveTokens(address _token, uint256 _amount) external onlyOwner {\n        if (_token == address(0)) {\n            (bool sent,) = msg.sender.call{value: _amount}(\"\");\n            if (!sent) revert Failed();\n            emit EmergencySaved(_token, _amount, true);\n        } else {\n            IERC20(_token).safeTransfer(msg.sender, _amount);\n            emit EmergencySaved(_token, _amount, false);\n        }\n    }\n\n    /**\n     * @notice registeres mTapiocaOFT for rebalancing\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _dstOft the destination TOFT address\n     * @param _ercData custom send data\n     */\n    function initConnectedOFT(address _srcOft, uint16 _dstChainId, address _dstOft, bytes memory _ercData)\n        external\n        onlyOwner\n    {\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable > 0) {\n            revert AlreadyInitialized();\n        }\n        bool isNative = ITOFT(_srcOft).erc20() == address(0);\n        if (!isNative && _ercData.length == 0) revert PoolInfoRequired();\n\n        (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(_ercData, (uint256, uint256));\n\n        OFTData memory oftData =\n            OFTData({srcPoolId: _srcPoolId, dstPoolId: _dstPoolId, dstOft: _dstOft, rebalanceable: 0});\n\n        connectedOFTs[_srcOft][_dstChainId] = oftData;\n        emit ConnectedChainUpdated(_srcOft, _dstChainId, _dstOft);\n    }\n\n    /**\n     * @notice assings more rebalanceable amount for TOFT\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _amount the rebalanced amount\n     */\n    function addRebalanceAmount(address _srcOft, uint16 _dstChainId, uint256 _amount)\n        external\n        onlyValidDestination(_srcOft, _dstChainId)\n        onlyOwner\n    {\n        connectedOFTs[_srcOft][_dstChainId].rebalanceable += _amount;\n        uint256 totalToftSupply = ITOFTVault(ITOFT(_srcOft).vault()).viewSupply();\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable > totalToftSupply) {\n            revert RebalanceAmountNotValid();\n        }\n        emit RebalanceAmountUpdated(_srcOft, _dstChainId, _amount, connectedOFTs[_srcOft][_dstChainId].rebalanceable);\n    }\n\n    function retryRevert(uint16 _srcChainId, bytes calldata _srcAddress, uint256 _nonce) external payable onlyOwner {\n        router.retryRevert{value: msg.value}(_srcChainId, _srcAddress, _nonce);\n    }"
    }
  ]
}