{
  "Title": "[M01] Metadata stripping regex may mismatch",
  "Content": "Within `bytecode.ts`, the [regex patterns on lines 12 and 14](https://github.com/celo-org/celo-monorepo/blob/0e876e5cad0e93f5dd1fff853f4be3c9a0e5c2a7/packages/protocol/lib/bytecode.ts#L12-L14) are used to [match contract metadata](https://github.com/celo-org/celo-monorepo/blob/0e876e5cad0e93f5dd1fff853f4be3c9a0e5c2a7/packages/protocol/lib/bytecode.ts#L27) and strip it out. Contract metadata exists at the end of a contract. However, since these expressions match to a string of any length and at any location within the bytecode, they could potentially match to some string which is not the metadata. \n\n\nSince the metadata is of predictable length and occurs at the end of the contract bytecode, consider modifying the [Regex expressions on lines 12 and 14](https://github.com/celo-org/celo-monorepo/blob/0e876e5cad0e93f5dd1fff853f4be3c9a0e5c2a7/packages/protocol/lib/bytecode.ts#L12-L14) to the [`x{m,n}` quantifier](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Quantifiers) in place of the pattern `.*`, and modifying [the `stripMetadata` function](https://github.com/celo-org/celo-monorepo/blob/0e876e5cad0e93f5dd1fff853f4be3c9a0e5c2a7/packages/protocol/lib/bytecode.ts#L22-L34) to handle multiple potential matches and only assume the final one is the contract metadata.\n\n\n**Update**: *Fixed in [PR#6382](https://github.com/celo-org/celo-monorepo/pull/6382).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/lib/bytecode.ts",
      "content": "// tslint:disable: max-classes-per-file\n/*\n * The Solidity compiler appends a Swarm Hash of compilation metadata to the end\n * of bytecode. We find this hash based on the specification here:\n * https://solidity.readthedocs.io/en/develop/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode\n */\n\nimport { NULL_ADDRESS, trimLeading0x } from '@celo/base/lib/address'\n\nconst CONTRACT_METADATA_REGEXPS = [\n  // 0.5.8\n  'a165627a7a72305820.*0029',\n  // 0.5.13\n  'a265627a7a72315820.*64736f6c6343.*0032',\n]\n\nconst GENERAL_METADATA_REGEXP = new RegExp(\n  `^(.*)(${CONTRACT_METADATA_REGEXPS.map((r) => '(' + r + ')').join('|')})$`,\n  'i' // Use i flag to make search case insensitive.\n)\n\nexport const stripMetadata = (bytecode: string): string => {\n  if (bytecode === '0x') {\n    return '0x'\n  }\n\n  const match = bytecode.match(GENERAL_METADATA_REGEXP)\n  if (match === null) {\n    throw new Error(\n      'Only support stripping metadata from bytecodes generated by solc up to v0.5.13 with no experimental features.'\n    )\n  }\n  return match[1]\n}\n\n// Maps library names to their onchain addresses (formatted without \"0x\" prefix).\nexport interface LibraryLinks {\n  [name: string]: string\n}\n\n/*\n * Unresolved libraries appear as \"__LibraryName___...\" in bytecode output by\n * solc. The length of the entire string is 40 characters (accounting for the 20\n * bytes of the address that should be substituted in).\n */\nconst padForLink = (name: string): string => {\n  return `__${name}`.padEnd(40, '_')\n}\n\nexport const linkLibraries = (bytecode: string, libraryLinks: LibraryLinks): string => {\n  Object.keys(libraryLinks).forEach((libraryName) => {\n    const linkString = padForLink(libraryName)\n    // Use g flag to iterate through for all occurences.\n    bytecode = bytecode.replace(RegExp(linkString, 'g'), libraryLinks[libraryName])\n  })\n\n  return bytecode\n}\n\nconst ADDRESS_LENGTH = 40\nconst PUSH20_OPCODE = '73'\n// To check that a library isn't being called directly, the Solidity\n// compiler starts a library's bytecode with a comparison of the current\n// address with the address the library was deployed to (it has to differ\n// to ensure the library is being called with CALLCODE or DELEGATECALL\n// instead of a regular CALL).\n// The address is only known at contract construction time, so\n// the compiler's output contains a placeholder 0-address, while the onchain\n// bytecode has the correct address inserted.\n// Reference: https://solidity.readthedocs.io/en/v0.5.12/contracts.html#call-protection-for-libraries\nexport const verifyAndStripLibraryPrefix = (bytecode: string, address = NULL_ADDRESS) => {\n  if (bytecode.slice(2, 4) !== PUSH20_OPCODE) {\n    throw new Error(`Library bytecode doesn't start with address load`)\n  } else if (bytecode.slice(4, 4 + ADDRESS_LENGTH) !== trimLeading0x(address).toLowerCase()) {\n    throw new Error(`Library bytecode loads unexpected address at start`)\n  }\n\n  return bytecode.slice(4 + ADDRESS_LENGTH, bytecode.length)\n}\n\nexport class LibraryPositions {\n  static libraryLinkRegExpString = '__([A-Z][A-Za-z0-9]*)_{2,}'\n\n  positions: { [library: string]: number[] }\n\n  /*\n   * Creates a LibraryPositions object, which, for each yet to be linked library,\n   * contains the bytecode offsets of where the library address should be\n   * inserted.\n   */\n  constructor(bytecode: string) {\n    this.positions = {}\n    // Use g flag to iterate through for all occurences.\n    const libraryLinkRegExp = new RegExp(LibraryPositions.libraryLinkRegExpString, 'g')\n    let match = libraryLinkRegExp.exec(bytecode)\n    while (match != null) {\n      // The first capture group is the library's name\n      this.addPosition(match[1], match.index)\n      match = libraryLinkRegExp.exec(bytecode)\n    }\n  }\n\n  private addPosition(library: string, position: number) {\n    if (!this.positions[library]) {\n      this.positions[library] = []\n    }\n\n    this.positions[library].push(position)\n  }\n}\n\nexport class LibraryAddresses {\n  addresses: { [library: string]: string }\n\n  constructor() {\n    this.addresses = {}\n  }\n\n  collect = (bytecode: string, libraryPositions: LibraryPositions) =>\n    Object.keys(libraryPositions.positions).forEach((library) =>\n      libraryPositions.positions[library].forEach((position) => {\n        if (!this.addAddress(library, bytecode.slice(position, position + ADDRESS_LENGTH))) {\n          throw new Error(`Mismatched addresses for ${library} at ${position}`)\n        }\n      })\n    )\n\n  /*\n   * Tries to add a library name -> address mapping. If the library has already\n   * had an address added, checks that the new address matches the old one.\n   */\n  private addAddress(library: string, address: string): boolean {\n    if (!this.addresses[library]) {\n      this.addresses[library] = address\n    }\n\n    return this.addresses[library] === address\n  }\n}"
    },
    {
      "filename": "packages/protocol/lib/bytecode.ts",
      "content": "// tslint:disable: max-classes-per-file\n/*\n * The Solidity compiler appends a Swarm Hash of compilation metadata to the end\n * of bytecode. We find this hash based on the specification here:\n * https://solidity.readthedocs.io/en/develop/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode\n */\n\nimport { NULL_ADDRESS, trimLeading0x } from '@celo/base/lib/address'\n\nconst CONTRACT_METADATA_REGEXPS = [\n  // 0.5.8\n  'a165627a7a72305820.*0029',\n  // 0.5.13\n  'a265627a7a72315820.*64736f6c6343.*0032',\n]\n\nconst GENERAL_METADATA_REGEXP = new RegExp(\n  `^(.*)(${CONTRACT_METADATA_REGEXPS.map((r) => '(' + r + ')').join('|')})$`,\n  'i' // Use i flag to make search case insensitive.\n)\n\nexport const stripMetadata = (bytecode: string): string => {\n  if (bytecode === '0x') {\n    return '0x'\n  }\n\n  const match = bytecode.match(GENERAL_METADATA_REGEXP)\n  if (match === null) {\n    throw new Error(\n      'Only support stripping metadata from bytecodes generated by solc up to v0.5.13 with no experimental features.'\n    )\n  }\n  return match[1]\n}\n\n// Maps library names to their onchain addresses (formatted without \"0x\" prefix).\nexport interface LibraryLinks {\n  [name: string]: string\n}\n\n/*\n * Unresolved libraries appear as \"__LibraryName___...\" in bytecode output by\n * solc. The length of the entire string is 40 characters (accounting for the 20\n * bytes of the address that should be substituted in).\n */\nconst padForLink = (name: string): string => {\n  return `__${name}`.padEnd(40, '_')\n}\n\nexport const linkLibraries = (bytecode: string, libraryLinks: LibraryLinks): string => {\n  Object.keys(libraryLinks).forEach((libraryName) => {\n    const linkString = padForLink(libraryName)\n    // Use g flag to iterate through for all occurences.\n    bytecode = bytecode.replace(RegExp(linkString, 'g'), libraryLinks[libraryName])\n  })\n\n  return bytecode\n}\n\nconst ADDRESS_LENGTH = 40\nconst PUSH20_OPCODE = '73'\n// To check that a library isn't being called directly, the Solidity\n// compiler starts a library's bytecode with a comparison of the current\n// address with the address the library was deployed to (it has to differ\n// to ensure the library is being called with CALLCODE or DELEGATECALL\n// instead of a regular CALL).\n// The address is only known at contract construction time, so\n// the compiler's output contains a placeholder 0-address, while the onchain\n// bytecode has the correct address inserted.\n// Reference: https://solidity.readthedocs.io/en/v0.5.12/contracts.html#call-protection-for-libraries\nexport const verifyAndStripLibraryPrefix = (bytecode: string, address = NULL_ADDRESS) => {\n  if (bytecode.slice(2, 4) !== PUSH20_OPCODE) {\n    throw new Error(`Library bytecode doesn't start with address load`)\n  } else if (bytecode.slice(4, 4 + ADDRESS_LENGTH) !== trimLeading0x(address).toLowerCase()) {\n    throw new Error(`Library bytecode loads unexpected address at start`)\n  }\n\n  return bytecode.slice(4 + ADDRESS_LENGTH, bytecode.length)\n}\n\nexport class LibraryPositions {\n  static libraryLinkRegExpString = '__([A-Z][A-Za-z0-9]*)_{2,}'\n\n  positions: { [library: string]: number[] }\n\n  /*\n   * Creates a LibraryPositions object, which, for each yet to be linked library,\n   * contains the bytecode offsets of where the library address should be\n   * inserted.\n   */\n  constructor(bytecode: string) {\n    this.positions = {}\n    // Use g flag to iterate through for all occurences.\n    const libraryLinkRegExp = new RegExp(LibraryPositions.libraryLinkRegExpString, 'g')\n    let match = libraryLinkRegExp.exec(bytecode)\n    while (match != null) {\n      // The first capture group is the library's name\n      this.addPosition(match[1], match.index)\n      match = libraryLinkRegExp.exec(bytecode)\n    }\n  }\n\n  private addPosition(library: string, position: number) {\n    if (!this.positions[library]) {\n      this.positions[library] = []\n    }\n\n    this.positions[library].push(position)\n  }\n}\n\nexport class LibraryAddresses {\n  addresses: { [library: string]: string }\n\n  constructor() {\n    this.addresses = {}\n  }\n\n  collect = (bytecode: string, libraryPositions: LibraryPositions) =>\n    Object.keys(libraryPositions.positions).forEach((library) =>\n      libraryPositions.positions[library].forEach((position) => {\n        if (!this.addAddress(library, bytecode.slice(position, position + ADDRESS_LENGTH))) {\n          throw new Error(`Mismatched addresses for ${library} at ${position}`)\n        }\n      })\n    )\n\n  /*\n   * Tries to add a library name -> address mapping. If the library has already\n   * had an address added, checks that the new address matches the old one.\n   */\n  private addAddress(library: string, address: string): boolean {\n    if (!this.addresses[library]) {\n      this.addresses[library] = address\n    }\n\n    return this.addresses[library] === address\n  }\n}"
    }
  ]
}