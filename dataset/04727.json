{
  "Title": "[H-01] Native gas tokens can become stuck in `ASDRouter` contract",
  "Content": "\nIn case of a successful `asD` redemption flow, native gas tokens (`CANTO`) can become stuck in the `ASDRouter` contract.\n\nA successful execution of [`lzCompose`(...)](https://github.com/code-423n4/2024-03-canto/blob/1516028017a34ccfb4b0b19f5c5f17f5fa4cad42/contracts/asd/asdRouter.sol#L52-L111) ends with a call to [`_sendASD`(...)](https://github.com/code-423n4/2024-03-canto/blob/1516028017a34ccfb4b0b19f5c5f17f5fa4cad42/contracts/asd/asdRouter.sol#L130-L167):\n\n```solidity\nfunction _sendASD(bytes32 _guid, OftComposeMessage memory _payload, uint _amount) internal {\n    /* transfer the ASD tokens to the destination receiver */\n    if (_payload._dstLzEid == cantoLzEID) {\n        // just transfer the ASD tokens to the destination receiver\n        ...\n        ASDOFT(_payload._cantoAsdAddress).transfer(_payload._dstReceiver, _amount);   // @audit 0 of msg.value used\n    } else {\n        // use Layer Zero oapp to send ASD tokens to the destination receiver on the destination chain\n\n        // make sure msg.value is enough to cover the fee or this transaction will revert\n        if (msg.value < _payload._feeForSend) {   // @audit msg.value >= _payload._feeForSend seems intended, otherwise != should be used\n            // refund ASD tokens on canto\n            _refundToken(_guid, _payload._cantoAsdAddress, _payload._cantoRefundAddress, _amount, msg.value, \"insufficient msg.value for send fee\");\n            return;\n        }\n\n        // create send params for the Layer Zero oapp\n        ...\n\n        // send tokens\n        (bool successfulSend, bytes memory data) = payable(_payload._cantoAsdAddress).call{value: _payload._feeForSend}(abi.encodeWithSelector(IOFT.send.selector, sendParams, fee, _payload._cantoRefundAddress));   // @audit only _payload._feeForSend of msg.value used\n\n        // check if the send was successful\n        if (!successfulSend) {\n            // refund ASD tokens on canto\n            _refundToken(_guid, _payload._cantoAsdAddress, _payload._cantoRefundAddress, _amount, msg.value, string(data));\n            return;\n        }\n        ...\n    }\n    // @audit rest of msg.value is not refunded\n}\n```\n\nThereby, one can distinguish 3 scenarios:\n\n1. On error: `msg.value` is fully refunded to specified refund address.\n2. On successful transfer (within Canto chain): `0` of `msg.value` is used and any remaining value will be stuck.\n\n*One cannot assume and the contract doesn't require that `msg.value == 0` always holds in this case.*\n\n3. On successful transfer (to other chain): `_payload._feeForSend` of `msg.value` is used for sending `asD`, the remaining value will be stuck.\n\n*One cannot assume and the contract doesn't require that `msg.value == _payload._feeForSend` always holds in this case.*\n\nFurthermore, the present behaviour violates a protocol invariant, according to the [README](https://github.com/code-423n4/2024-03-canto/blob/1516028017a34ccfb4b0b19f5c5f17f5fa4cad42/README.md?plain=1#L193):\n\n> 1. `ASDRouter` native balance should always be zero.\n\n### Proof of Concept\n\nThe diff below modifies the existing test case `lzCompose: successful deposit and send on canto` to demonstrate that excess `msg.value` is not refunded in case of a successful `asD` redemption flow.\n\n```diff\ndiff --git a/test/ASDRouter.js b/test/ASDRouter.js\nindex 2a36337..eccedc0 100644\n--- a/test/ASDRouter.js\n+++ b/test/ASDRouter.js\n@@ -276,6 +276,7 @@ describe(\"ASDRouter\", function () {\n     it(\"lzCompose: successful deposit and send on canto\", async () => {\n         // update whitelist\n         await ASDUSDC.updateWhitelist(USDCOFT.target, true);\n+        const gas = ethers.parseEther(\"1\");\n         // call lzCompose with valid payload\n         await expect(\n             ASDRouter.lzCompose(\n@@ -287,12 +288,18 @@ describe(\"ASDRouter\", function () {\n                     generatedRouterPayload(cantoLzEndpoint.id, refundAddress, TESTASD.target, TESTASD.target, \"0\", refundAddress, \"0\")\n                 ),\n                 executorAddress,\n-                \"0x\"\n+                \"0x\",\n+                { value: gas }\n             )\n         )\n             .to.emit(ASDRouter, \"ASDSent\")\n             .withArgs(guid, refundAddress, TESTASD.target, amountUSDCSent, cantoLzEndpoint.id, false);\n         // expect ASD to be sent to canto\n         expect(await TESTASD.balanceOf(refundAddress)).to.equal(amountUSDCSent);\n+        \n+        // expect gas to be refunded and not held in ASDRouter\n+        expect(await ethers.provider.getBalance(ASDRouter.target)).to.equal(0);\n+        expect(await ethers.provider.getBalance(refundAddress)).to.equal(gas);\n+\n     });\n });\n```\n\n### Recommended Mitigation Steps\n\nApply the following changes to the [`_sendASD`(...)](https://github.com/code-423n4/2024-03-canto/blob/1516028017a34ccfb4b0b19f5c5f17f5fa4cad42/contracts/asd/asdRouter.sol#L130-L167) method in order to refund the remaining value (i.e. the native contract balance).\n\n```diff\ndiff --git a/contracts/asd/asdRouter.sol b/contracts/asd/asdRouter.sol\nindex 7cb4ecc..37786e1 100644\n--- a/contracts/asd/asdRouter.sol\n+++ b/contracts/asd/asdRouter.sol\n@@ -164,6 +164,10 @@ contract ASDRouter is IOAppComposer, Ownable {\n             }\n             emit ASDSent(_guid, _payload._dstReceiver, _payload._cantoAsdAddress, _amount, _payload._dstLzEid, true);\n         }\n+\n+        if (address(this).balance > 0) {\n+            payable(_payload._cantoRefundAddress).transfer(address(this).balance);\n+        }\n     }\n \n     /**\n```\n\nNote: Using `transfer` might not be an ideal choice, but this proposed solution in meant to be in analogy with the `_refundToken(...)` method.\n\n### Assessed type\n\nETH-Transfer\n\n**[3docSec (judge) commented](https://github.com/code-423n4/2024-03-canto-findings/issues/6#issuecomment-2036468654):**\n > Looks valid. The difference between `msg.value` and `_payload._feeForSend` is indeed not refunded to `_payload._cantoRefundAddress` as one would expect.\n\n**[dsudit01 (Canto) confirmed](https://github.com/code-423n4/2024-03-canto-findings/issues/6#issuecomment-2040292140)**\n\n**[3docSec (judge) increased severity to High and commented](https://github.com/code-423n4/2024-03-canto-findings/issues/6#issuecomment-2041070438):**\n > Upgrading to High as if I am not mistaken, there is no viable way to safely recover the native tokens stuck in the contract.\n\n**[SpicyMeatball (warden) commented](https://github.com/code-423n4/2024-03-canto-findings/issues/6#issuecomment-2041102837):**\n > @3docSec - it is true that there is no way to recover ETH from the router once the transaction succeeds, but I think it should be viewed as a user's mistake and QA is more appropriate. The report describes two cases in which ETH can stuck:\n> 1. `On successful transfer (within Canto chain)` - there is no need for the user to send a non-zero msg.value in this case.\n> 2. `On successful transfer (to other chain)` - since `_feeForSend` is known beforehand, sending `msg.value > _feeForSend` can be considered a mistake on user's side.\n\n**[3docSec (judge) commented](https://github.com/code-423n4/2024-03-canto-findings/issues/6#issuecomment-2041117922):**\n > > On successful transfer (within Canto chain).\n> \n> Agree, Low impact there.\n> \n> > `sending msg.value > _feeForSend` can be considered a mistake on user's side.\n> \n> The logic is protected against excess tokens and has a `refundAddress` for this purpose. The fact that refunds cover only full refunds and not partial ones is not one a user could reasonably expect.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-03-canto",
  "Code": [
    {
      "filename": "contracts/asd/asdRouter.sol",
      "content": "pragma solidity ^0.8.22;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IOAppComposer} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppComposer.sol\";\nimport {OFTComposeMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTComposeMsgCodec.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ASDOFT} from \"./asdOFT.sol\";\nimport {IOFT, SendParam, MessagingFee} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {OptionsBuilder} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/libs/OptionsBuilder.sol\";\nimport {ICrocSwapDex, ICrocImpact} from \"../ambient/CrocInterfaces.sol\";\nimport {ASDUSDC} from \"./asdUSDC.sol\";\n\n/**\n * @title ASDRouter\n */\n\ncontract ASDRouter is IOAppComposer, Ownable {\n    // ambient params\n    address public crocSwapAddress;\n    address public crocImpactAddress;\n    uint public constant ambientPoolIdx = 36000;\n    // canto chain params\n    address public noteAddress;\n    uint32 public cantoLzEID;\n    // asdUSDC contract for swapping to $NOTE\n    address public asdUSDC;\n\n    struct OftComposeMessage {\n        uint32 _dstLzEid;\n        address _dstReceiver;\n        address _dstAsdAddress;\n        address _cantoAsdAddress;\n        uint256 _minAmountASD;\n        address _cantoRefundAddress;\n        uint256 _feeForSend;\n    }\n\n    event LZReceived(bytes32 indexed _guid, address _from, bytes _message, address _executor, bytes _extraData, uint _value);\n\n    event TokenRefund(bytes32 indexed _guid, address _tokenAddress, address _refundAddress, uint _amount, uint _nativeAmount, string _reason);\n\n    event ASDSent(bytes32 indexed _guid, address _to, address _asdAddress, uint _amount, uint32 _dstEid, bool _lzSend);\n\n    constructor(address _noteAddress, uint32 _cantoLzEID, address _crocSwapAddress, address _crocImpactAddress, address _asdUSDCAddress) {\n        noteAddress = _noteAddress;\n        cantoLzEID = _cantoLzEID;\n        crocSwapAddress = _crocSwapAddress;\n        crocImpactAddress = _crocImpactAddress;\n        asdUSDC = _asdUSDCAddress;\n    }\n\n    /**\n     * @notice Called by the LZ executor after sending OFT tokens to this contract.\n     * @param _from The address of the OFT on this chain.\n     * @param _guid The GUID of the message.\n     * @param _message The message payload from the executor formatted as an OFT composed message.\n     * @param _executor The address of the executor.\n     * @param _extraData Additional data supplied by the executor.\n     * @dev Cannot revert anywhere, must send the tokens to the intended receiver if something fails (token's will be lost otherwise)\n     */\n    function lzCompose(address _from, bytes32 _guid, bytes calldata _message, address _executor, bytes calldata _extraData) external payable {\n        /* log event */\n        emit LZReceived(_guid, _from, _message, _executor, _extraData, msg.value);\n\n        /* decode OFT composed message */\n        (, , uint256 amountLD, bytes32 composeFrom, bytes memory composeMsg) = _decodeOFTComposeMsg(_message);\n\n        /* decode composed message payload */\n\n        // check the composed message for proper formatting\n        if (composeMsg.length != 224) {\n            // return tokens to the address that sent them (composeFrom)\n            _refundToken(_guid, _from, OFTComposeMsgCodec.bytes32ToAddress(composeFrom), amountLD, msg.value, \"Invalid composeMsg length\");\n            return;\n        }\n        OftComposeMessage memory payload = abi.decode(composeMsg, (OftComposeMessage));\n\n        /* check if the OFT stable coin is whitelisted */\n        if (!ASDUSDC(asdUSDC).whitelistedUSDCVersions(_from)) {\n            // return tokens to the refund address on canto\n            _refundToken(_guid, _from, payload._cantoRefundAddress, amountLD, msg.value, \"not whitelisted\");\n            return;\n        }\n\n        /* deposit oft to receive asdUSDC for swapping */\n        IERC20(_from).approve(asdUSDC, amountLD);\n        uint amountUSDC = ASDUSDC(asdUSDC).deposit(_from, amountLD);\n\n        /* swap tokens for $NOTE (check minAmount for slippage) */\n        (uint amountNote, bool successfulSwap) = _swapOFTForNote(asdUSDC, amountUSDC, payload._minAmountASD);\n\n        // check if the swap was successful\n        if (!successfulSwap) {\n            // return tokens to the refund address on canto\n            _refundToken(_guid, asdUSDC, payload._cantoRefundAddress, amountUSDC, msg.value, \"swap failed\");\n            return;\n        }\n\n        /* deposit $NOTE to the correct asd vault to receive ASD tokens */\n        (bool successfulDeposit, string memory reason) = _depositNoteToASDVault(payload._cantoAsdAddress, amountNote);\n\n        // check if deposit was successful\n        if (!successfulDeposit) {\n            // return $NOTE to the refund address on canto since OFT was swapped already\n            _refundToken(_guid, noteAddress, payload._cantoRefundAddress, amountNote, msg.value, reason);\n            return;\n        }\n\n        /* transfer the ASD tokens to the destination receiver */\n        _sendASD(_guid, payload, amountNote);\n    }\n\n    /**\n     *\n     * @param _message The message payload from the executor formatted as an OFT composed message.\n     * @return _nonce The nonce value.\n     * @return _srcEid The source endpoint ID.\n     * @return _amountLD The amount in local decimals.\n     * @return _composeFrom The composeFrom value (msg.sender on from chain).\n     * @return _composeMsg The composed message.\n     */\n    function _decodeOFTComposeMsg(bytes calldata _message) internal pure returns (uint64 _nonce, uint32 _srcEid, uint256 _amountLD, bytes32 _composeFrom, bytes memory _composeMsg) {\n        _nonce = OFTComposeMsgCodec.nonce(_message);\n        _srcEid = OFTComposeMsgCodec.srcEid(_message);\n        _amountLD = OFTComposeMsgCodec.amountLD(_message);\n        _composeFrom = OFTComposeMsgCodec.composeFrom(_message);\n        _composeMsg = OFTComposeMsgCodec.composeMsg(_message);\n    }\n\n    /**\n     * @param _guid the GUID of the message from layer zero.\n     * @param _payload the payload of the message.\n     * @param _amount  the amount of ASD tokens to send.\n     */\n    function _sendASD(bytes32 _guid, OftComposeMessage memory _payload, uint _amount) internal {\n        /* transfer the ASD tokens to the destination receiver */\n        if (_payload._dstLzEid == cantoLzEID) {\n            // just transfer the ASD tokens to the destination receiver\n            emit ASDSent(_guid, _payload._dstReceiver, _payload._cantoAsdAddress, _amount, _payload._dstLzEid, false);\n            ASDOFT(_payload._cantoAsdAddress).transfer(_payload._dstReceiver, _amount);\n        } else {\n            // use Layer Zero oapp to send ASD tokens to the destination receiver on the destination chain\n\n            // make sure msg.value is enough to cover the fee or this transaction will revert\n            if (msg.value < _payload._feeForSend) {\n                // refund ASD tokens on canto\n                _refundToken(_guid, _payload._cantoAsdAddress, _payload._cantoRefundAddress, _amount, msg.value, \"insufficient msg.value for send fee\");\n                return;\n            }\n\n            // create send params for the Layer Zero oapp\n            bytes memory sendOptions = OptionsBuilder.addExecutorLzReceiveOption(OptionsBuilder.newOptions(), 200000, 0);\n            SendParam memory sendParams = SendParam({dstEid: _payload._dstLzEid, to: OFTComposeMsgCodec.addressToBytes32(_payload._dstReceiver), amountLD: _amount, minAmountLD: _amount, extraOptions: sendOptions, composeMsg: \"0x\", oftCmd: \"0x\"});\n            MessagingFee memory fee = MessagingFee({nativeFee: _payload._feeForSend, lzTokenFee: 0});\n\n            // send tokens\n            (bool successfulSend, bytes memory data) = payable(_payload._cantoAsdAddress).call{value: _payload._feeForSend}(abi.encodeWithSelector(IOFT.send.selector, sendParams, fee, _payload._cantoRefundAddress));\n\n            // check if the send was successful\n            if (!successfulSend) {\n                // refund ASD tokens on canto\n                _refundToken(_guid, _payload._cantoAsdAddress, _payload._cantoRefundAddress, _amount, msg.value, string(data));\n                return;\n            }\n            emit ASDSent(_guid, _payload._dstReceiver, _payload._cantoAsdAddress, _amount, _payload._dstLzEid, true);\n        }\n    }\n\n    /**\n     * @notice refunds tokens when lzCompose fails\n     * @param _guid The GUID of the message from layer zero.\n     * @param _tokenAddress address of token\n     * @param _refundAddress address to refund to on canto\n     * @param _amount amount to send\n     * @param _nativeAmount amount to send in native token\n     */\n    function _refundToken(bytes32 _guid, address _tokenAddress, address _refundAddress, uint _amount, uint _nativeAmount, string memory _reason) internal {\n        // emit event\n        emit TokenRefund(_guid, _tokenAddress, _refundAddress, _amount, _nativeAmount, _reason);\n        // transfer tokens to refund address\n        IERC20(_tokenAddress).transfer(_refundAddress, _amount);\n        // transfer native tokens to refund address and check that this value is less than or equal to msg.value\n        if (_nativeAmount > 0 && _nativeAmount <= msg.value) {\n            payable(_refundAddress).transfer(_nativeAmount);\n        }\n    }\n\n    /**\n     * @notice deposits $NOTE to the correct asd vault to receive ASD tokens\n     * @param _asdVault The address of the ASD vault to deposit to\n     * @param _amountNote The amount of $NOTE to deposit\n     */\n    function _depositNoteToASDVault(address _asdVault, uint _amountNote) internal returns (bool, string memory) {\n        // approve asd vault to spend $NOTE\n        IERC20(noteAddress).approve(_asdVault, _amountNote);\n        // deposit $NOTE to asd vault (use call, so this doesn't revert)\n        (bool success, bytes memory errReason) = _asdVault.call(abi.encodeWithSelector(ASDOFT.mint.selector, _amountNote));\n        return (success, string(errReason));\n    }\n\n    /**\n     * @notice swaps an OFT stable coin for $NOTE\n     * @dev only callable by the owner\n     * @param _oftAddress The address of the OFT stable coin contract\n     * @param _amount The amount of OFT stable coin to swap\n     * @param _minAmountNote The minimum amount of $NOTE to receive\n     * @return amount The amount of $NOTE received or error code\n     */\n    function _swapOFTForNote(address _oftAddress, uint _amount, uint _minAmountNote) internal returns (uint, bool) {\n        // sort tokens\n        address baseToken;\n        address quoteToken;\n        if (_oftAddress < noteAddress) {\n            baseToken = _oftAddress;\n            quoteToken = noteAddress;\n        } else {\n            baseToken = noteAddress;\n            quoteToken = _oftAddress;\n        }\n        // check if pool exists\n        if (ambientPoolFor(baseToken, quoteToken, ambientPoolIdx) == 0) {\n            // nothing swapped, swapped failed\n            return (0, false);\n        }\n\n        // convert amount to uint128\n        uint128 amountConverted = uint128(_amount);\n        // query impact to make sure user will receive at least _minAmountNote\n        bool isNoteBase = baseToken == noteAddress;\n        (int128 baseFlow, int128 quoteFlow, ) = ICrocImpact(crocImpactAddress).calcImpact(baseToken, quoteToken, ambientPoolIdx, !isNoteBase, !isNoteBase, amountConverted, 0, 0);\n\n        // check if amount note received is greater than or equal to _minAmountNote\n\n        int minAmountInt = int(_minAmountNote); // stack too deep fix\n        // flow is negative if it left the pool, so multiply by -1\n        if (isNoteBase && -baseFlow < minAmountInt) {\n            // nothing swapped, swapped failed\n            return (0, false);\n        } else if (!isNoteBase && -quoteFlow < minAmountInt) {\n            // nothing swapped, swapped failed\n            return (0, false);\n        }\n        // convert minAmount to uint for stack too deep fix\n        uint128 uintMinAmount = uint128(_minAmountNote);\n\n        // swap is good to make, use call just in case revert occurs\n        (bool successSwap, bytes memory data) = crocSwapAddress.call(abi.encodeWithSelector(ICrocSwapDex.swap.selector, baseToken, quoteToken, ambientPoolIdx, !isNoteBase, !isNoteBase, amountConverted, 0, 0, uintMinAmount, 0));\n        if (!successSwap) {\n            // nothing swapped, swapped failed\n            return (0, false);\n        }\n        // return amount of note received\n        (int128 baseUsed, int128 quoteUsed) = abi.decode(data, (int128, int128));\n        return (uint128(-1 * (isNoteBase ? baseUsed : quoteUsed)), true);\n    }\n\n    function ambientPoolFor(address _baseToken, address _quoteToken, uint256 _poolIdx) internal view returns (uint256) {\n        bytes32 poolKey = keccak256(abi.encode(_baseToken, _quoteToken, _poolIdx));\n        uint POOL_PARAM_SLOT = 65545;\n        bytes32 slot = keccak256(abi.encode(poolKey, POOL_PARAM_SLOT));\n        return ICrocSwapDex(crocSwapAddress).readSlot(uint256(slot));\n    }\n}"
    },
    {
      "filename": "README.md?plain=1",
      "content": "# Canto audit details\n- Total Prize Pool: $13,500\n  - HM awards: $9,900\n  - Analysis awards: $500\n  - QA awards: $300\n  - Gas awards: $300\n  - Judge awards: $2,000\n  - Scout awards: $500\n \n  ❗️Awarding Note for Wardens, Judges, and Lookouts: If you want to claim your awards in $ worth of CANTO, you must follow the steps outlined in this thread; otherwise you'll be paid out in USDC.\n \n- Join [C4 Discord](https://discord.gg/code4rena) to register\n- Submit findings [using the C4 form](https://code4rena.com/contests/2024-03-canto/submit)\n- [Read our guidelines for more details](https://docs.code4rena.com/roles/wardens)\n- Starts March 29, 2024 20:00 UTC\n- Ends April 3, 2024 20:00 UTC\n\n## Automated Findings / Publicly Known Issues\n\nThe 4naly3er report can be found [here](https://github.com/code-423n4/2024-03-canto/blob/main/4naly3er-report.md).\n\n_Note for C4 wardens: Anything included in this `Automated Findings / Publicly Known Issues` section is considered a publicly known issue and is ineligible for awards._\n\n\n# Overview\n\n# Application Specific Dollar Omnichain Fungible Token (asD-OFT)\n\n## Background\n\nasD allows for protocols to earn yield on their users' dollar deposits. asD is always pegged to 1 $NOTE and this $NOTE can be deposited into the Canto Lending Market to accrue interest. This version of asD implements LayerZero's Omnichain Fungible Token to allow creators from any LayerZero supported chain to earn extra revenue from all stable coin deposits.\n\n#### Useful background information\n\n- NOTE: https://docs.canto.io/overview/canto-unit-of-account-usdnote\n- Canto Lending Market: https://docs.canto.io/overview/canto-lending-market-clm\n- Compound cTOKEN Documentation: https://docs.compound.finance/v2/ctokens\n- Layer Zero: https://docs.layerzero.network/contracts/overview\n- asD ERC20 c4 audit: https://code4rena.com/audits/2023-11-canto-application-specific-dollars-and-bonding-curves-for-1155s\n\n## asD Flow\n\nThe purpose of implementing cross chain functionality with asD is to allow developers from any supported chain to earn Canto Lending Market yield without needing to directly deploy their entire protocol on the Canto application layer. By using Layer Zero v2, we can accomplish this by bridging whitelisted stable coins to mint asD tokens that can then be bridged back to the original application.\n\n![asD Flow](asdFlow.png)\n\n## Contracts\n\n### ASDOFT\n\nThe ASDOFT contract is a direct implementation of the ASD ERC20 token used for [1155Tech](https://github.com/code-423n4/2023-11-canto) however it also implements LayerZero v2 OFT functionality. This allows for asD tokens minted on Canto as well as easily bridged back to the source application to be used in the protocol.\n\nIn order to ensure a 1:1 peg to $NOTE, only the ASDOFT should be deployed on Canto for minting, and regular OFT implementations should be deployed on all other supported chains.\n\n### ASDRouter\n\nThe ASDRouter contract allows for the minting of asD tokens to be done in a single transaction originating from any supported chain. A stable coin represented as an OFT is sent to the ASDRouter with \"lzCompose\" options passed to tell the Layer Zero executor to call `lzCompose` once it receives the message.\n\n```javascript\n function lzCompose(\n    address _from,\n    bytes32 _guid,\n    bytes calldata _message,\n    address _executor,\n    bytes calldata _extraData) external payable;\n```\n\nA user who wants to obtain asD tokens must send their stable assets to the ASDRouter through Layer Zero. The `_message` must be formatted as bytes with the form of the OFTComposeMessage struct:\n\n```javascript\nstruct OftComposeMessage {\n    uint32 _dstLzEid; // destination endpoint id\n    address _dstReceiver; // receiver on destination\n    address _dstAsdAddress; // asD address on destination\n    address _cantoAsdAddress; // asD on Canto (where to mint asD from)\n    uint256 _minAmountASD; // minimum amount (slippage for swap)\n    address _cantoRefundAddress; // canto refund address\n    uint256 _feeForSend; // fee for bridge to destination chain\n}\n```\n\nThis struct tells the Router which asD tokens to mint and where to send them after they are obtained. The `lzCompose` function on the Router performs the following steps\n\n1. Deposits stable coin for asdUSDC\n2. Swaps asdUSDC in ambient pool for $NOTE\n3. Deposits $NOTE to asD Vault for asD tokens\n4. Sends asD tokens to destination chain and address\n\nAfter lzCompose has been called, the Router should never have any tokens left over (all tokens are refunded or sent). With Layer Zero execution, if the `lzCompose` reverts, the OFT tokens are still received by the Router, but the compose message can be retried. Because of this, the Router protects against reverts by implementing saftey checks and refunds during each step. All refunds will be sent to the user's address on Canto. For any message that contains `msg.value`, the entire amount will also be refunded to the user as Canto.\n\nSaftey checks:\n\n1. Incorrect compose message formatting (OFT refunded)\n2. Not whitelisted stable coin version (OFT refunded)\n3. Unsuccessful swap to $NOTE (usdcOFT refunded)\n4. Unsuccessful deposit into asD vault ($NOTE refunded)\n5. Unsuccessful bridge of asD to destination of insufficient fee (asD refunded)\n\n### ASDUSDC\n\nASDUSDC is a simple wrapper for all of the different representations for the same stable coins that might be bridged through Layer Zero. The purpose of this is to limit the amount of pools needed for swapping tokens to $NOTE. With this wrapper, only one pool is needed and all OFT's representing the same can be wrapped into ASDUSDC and swapped for Note easily. A user can deposit any of the whitelisted usdc versions to mint ASDUSDC as well as withdraw any of those same versions (as long as there is enough locked) by burning their ASDUSDC.\n\n\n## Links\n\n- **Previous audits:** None\n- **Documentation:** https://github.com/Plex-Engineer/ASD-V2/blob/main/README.md\n- **Website:** https://canto.io/\n- **X/Twitter:** https://twitter.com/CantoPublic\n- **Discord:** https://discord.com/invite/63GmEXZsVf\n\n---\n\n# Scope\n\n### Files in scope\n\n\n| File                                  | Logic Contracts | Interfaces |  SLOC   | Purpose | Libraries used |\n|:------------------------------------- |:---------------:|:----------:|:-------:|:------- |:-------------- |\n| /contracts/clm/CTokenInterfaces.sol   |      ****       |     2      |   12    |    Interaction with Compound Lending Market cTokens     |       ****         |\n| /contracts/clm/Turnstile.sol          |      ****       |     1      |    3    |   Registers contract to CSR (contract secured revenue)      |      ****          |\n| /contracts/asd/asdOFT.sol             |        1        |    ****    |   47    |    Mints and burns ASD tokens by depositing/withdrawing $NOTE and supplying/withdrawing from Canto Lending Market     |     ERC20, OFT, CErc20Interface           |\n| /contracts/asd/asdRouter.sol          |        1        |    ****    |   138   |   Routes stable OFTs to correct ASD vault and returns to user on destination chain in a single transaction      |    OptionsBuilder, IOFT, OFTComposeMsgCodec, IOAppComposer            |\n| /contracts/asd/asdUSDC.sol            |        1        |    ****    |   40    |   Wrapper for different OFT representations of the same underlying token to be used in dex      |     ERC20           |\n| /contracts/ambient/CrocInterfaces.sol |      ****       |     2      |    7    |   Interface for ambient dex for router to swap for Note      |      ****          |\n| **Totals**                            |      **3**      |   **5**    | **247** |         |                |\n\n### Files out of scope\n| File |\n| ---- |\n| /contracts/test-contracts/USDCOFT.sol |\n| /contracts/test-contracts/TestERC20.sol |\n| /contracts/test-contracts/TestASD.sol |\n| /contracts/test-contracts/MockCrocSwap.sol |\n| /contracts/asd/OFT.sol |\n| /contracts/asd/OFTAdapter.sol |\n\n## Scoping Q &amp; A\n\n### General questions\n\n\n| Question                                | Answer                       |\n| --------------------------------------- | ---------------------------- |\n| ERC20 used by the protocol              |      Layer Zero OFT, USDC            |\n| Test coverage                           |  75%                          |\n| ERC721 used  by the protocol            |            None              |\n| ERC777 used by the protocol             |           None                |\n| ERC1155 used by the protocol            |              None            |\n| Chains the protocol will be deployed on | Ethereum, Arbitrum, Polygon, OtherCanto  |\n\n### ERC20 token behaviors in scope\n\n| Question                                                                                                                                                   | Answer |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------- |:------:|\n| [Missing return values](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#missing-return-values)                                                      |   ❌   |\n| [Fee on transfer](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#fee-on-transfer)                                                                  |   ✅   |\n| [Balance changes outside of transfers](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#balance-modifications-outside-of-transfers-rebasingairdrops) |   ❌   |\n| [Upgradeability](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#upgradable-tokens)                                                                 |   ❌   |\n| [Flash minting](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#flash-mintable-tokens)                                                              |   ❌   |\n| [Pausability](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#pausable-tokens)                                                                      |   ❌   |\n| [Approval race protections](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#approval-race-protections)                                              |   ❌   |\n| [Revert on approval to zero address](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#revert-on-approval-to-zero-address)                            |   ❌   |\n| [Revert on zero value approvals](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#revert-on-zero-value-approvals)                                    |   ❌   |\n| [Revert on zero value transfers](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#revert-on-zero-value-transfers)                                    |   ✅   |\n| [Revert on transfer to the zero address](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#revert-on-transfer-to-the-zero-address)                    |   ✅   |\n| [Revert on large approvals and/or transfers](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#revert-on-large-approvals--transfers)                  |   ❌   |\n| [Doesn't revert on failure](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#no-revert-on-failure)                                                   |   ✅   |\n| [Multiple token addresses](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#revert-on-zero-value-transfers)                                          |   ✅   |\n| [Low decimals ( < 6)](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#low-decimals)                                                                 |   ✅   |\n| [High decimals ( > 18)](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#high-decimals)                                                              |   ✅   |\n| [Blocklists](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#tokens-with-blocklists)                                                                |   ❌   |\n\n### External integrations (e.g., Uniswap) behavior in scope:\n\n\n| Question                                                  | Answer |\n| --------------------------------------------------------- |:------:|\n| Enabling/disabling fees (e.g. Blur disables/enables fees) |   No   |\n| Pausability (e.g. Uniswap pool gets paused)               |   No   |\n| Upgradeability (e.g. Uniswap gets upgraded)               |   No   |\n\n\n### EIP compliance checklist\nNone\n\n\n# Additional context\n\n## Main invariants\n\n1. `ASDRouter` native balance should always be zero.\n2. `ASDRouter` balance of any token should always be zero after lzCompose has completed\n3. `ASDUSDC` usdcBalances mapping should always sum to the totalSupply\n\n\n## Attack ideas (where to focus for bugs)\n* Since Layer Zero executors call `lzCompose` after sending funds to the `ASDRouter` Contract, this `lzCompose` function should never revert. \n* All external calls should be checked for success and decoding bytes must never fail. \n* All errors should result in refunds so that tokens do not get trapped in Layer Zero Protocol.\n\n\n## All trusted roles in the protocol\n\n\n| Role                                | Description                       |\n| --------------------------------------- | ---------------------------- |\n| ASDUSDC owner                          | Sets whitelist for tokens             |\n\n\n## Describe any novel or unique curve logic or mathematical models implemented in the contracts:\n\nNone\n\n\n\n## Running tests\n\n```bash\ngit clone https://github.com/code-423n4/2024-03-canto.git\n\ngit submodule update --init --recursive\n\nnpm install\n\nnpx hardhat compile\n\nnpx hardhat test\n```\nTo run code coverage\n```bash\nnpx hardhat coverage\n```\nTo run gas benchmarks\n```bash\nREPORT_GAS=true npx hardhat test\n```\n![canto_gas_report](https://github.com/code-423n4/2024-03-canto/assets/65364747/e029a8e9-3375-4fa8-8b83-531c916dc138)\n![canto_coverage](https://github.com/code-423n4/2024-03-canto/assets/65364747/dd43c395-56fc-45b4-94c4-2e014b0191f8)\n\n\n## Miscellaneous\nEmployees of Canto and employees' family members are ineligible to participate in this audit."
    },
    {
      "filename": "contracts/asd/asdRouter.sol",
      "content": "pragma solidity ^0.8.22;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IOAppComposer} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppComposer.sol\";\nimport {OFTComposeMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTComposeMsgCodec.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ASDOFT} from \"./asdOFT.sol\";\nimport {IOFT, SendParam, MessagingFee} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {OptionsBuilder} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/libs/OptionsBuilder.sol\";\nimport {ICrocSwapDex, ICrocImpact} from \"../ambient/CrocInterfaces.sol\";\nimport {ASDUSDC} from \"./asdUSDC.sol\";\n\n/**\n * @title ASDRouter\n */\n\ncontract ASDRouter is IOAppComposer, Ownable {\n    // ambient params\n    address public crocSwapAddress;\n    address public crocImpactAddress;\n    uint public constant ambientPoolIdx = 36000;\n    // canto chain params\n    address public noteAddress;\n    uint32 public cantoLzEID;\n    // asdUSDC contract for swapping to $NOTE\n    address public asdUSDC;\n\n    struct OftComposeMessage {\n        uint32 _dstLzEid;\n        address _dstReceiver;\n        address _dstAsdAddress;\n        address _cantoAsdAddress;\n        uint256 _minAmountASD;\n        address _cantoRefundAddress;\n        uint256 _feeForSend;\n    }\n\n    event LZReceived(bytes32 indexed _guid, address _from, bytes _message, address _executor, bytes _extraData, uint _value);\n\n    event TokenRefund(bytes32 indexed _guid, address _tokenAddress, address _refundAddress, uint _amount, uint _nativeAmount, string _reason);\n\n    event ASDSent(bytes32 indexed _guid, address _to, address _asdAddress, uint _amount, uint32 _dstEid, bool _lzSend);\n\n    constructor(address _noteAddress, uint32 _cantoLzEID, address _crocSwapAddress, address _crocImpactAddress, address _asdUSDCAddress) {\n        noteAddress = _noteAddress;\n        cantoLzEID = _cantoLzEID;\n        crocSwapAddress = _crocSwapAddress;\n        crocImpactAddress = _crocImpactAddress;\n        asdUSDC = _asdUSDCAddress;\n    }\n\n    /**\n     * @notice Called by the LZ executor after sending OFT tokens to this contract.\n     * @param _from The address of the OFT on this chain.\n     * @param _guid The GUID of the message.\n     * @param _message The message payload from the executor formatted as an OFT composed message.\n     * @param _executor The address of the executor.\n     * @param _extraData Additional data supplied by the executor.\n     * @dev Cannot revert anywhere, must send the tokens to the intended receiver if something fails (token's will be lost otherwise)\n     */\n    function lzCompose(address _from, bytes32 _guid, bytes calldata _message, address _executor, bytes calldata _extraData) external payable {\n        /* log event */\n        emit LZReceived(_guid, _from, _message, _executor, _extraData, msg.value);\n\n        /* decode OFT composed message */\n        (, , uint256 amountLD, bytes32 composeFrom, bytes memory composeMsg) = _decodeOFTComposeMsg(_message);\n\n        /* decode composed message payload */\n\n        // check the composed message for proper formatting\n        if (composeMsg.length != 224) {\n            // return tokens to the address that sent them (composeFrom)\n            _refundToken(_guid, _from, OFTComposeMsgCodec.bytes32ToAddress(composeFrom), amountLD, msg.value, \"Invalid composeMsg length\");\n            return;\n        }\n        OftComposeMessage memory payload = abi.decode(composeMsg, (OftComposeMessage));\n\n        /* check if the OFT stable coin is whitelisted */\n        if (!ASDUSDC(asdUSDC).whitelistedUSDCVersions(_from)) {\n            // return tokens to the refund address on canto\n            _refundToken(_guid, _from, payload._cantoRefundAddress, amountLD, msg.value, \"not whitelisted\");\n            return;\n        }\n\n        /* deposit oft to receive asdUSDC for swapping */\n        IERC20(_from).approve(asdUSDC, amountLD);\n        uint amountUSDC = ASDUSDC(asdUSDC).deposit(_from, amountLD);\n\n        /* swap tokens for $NOTE (check minAmount for slippage) */\n        (uint amountNote, bool successfulSwap) = _swapOFTForNote(asdUSDC, amountUSDC, payload._minAmountASD);\n\n        // check if the swap was successful\n        if (!successfulSwap) {\n            // return tokens to the refund address on canto\n            _refundToken(_guid, asdUSDC, payload._cantoRefundAddress, amountUSDC, msg.value, \"swap failed\");\n            return;\n        }\n\n        /* deposit $NOTE to the correct asd vault to receive ASD tokens */\n        (bool successfulDeposit, string memory reason) = _depositNoteToASDVault(payload._cantoAsdAddress, amountNote);\n\n        // check if deposit was successful\n        if (!successfulDeposit) {\n            // return $NOTE to the refund address on canto since OFT was swapped already\n            _refundToken(_guid, noteAddress, payload._cantoRefundAddress, amountNote, msg.value, reason);\n            return;\n        }\n\n        /* transfer the ASD tokens to the destination receiver */\n        _sendASD(_guid, payload, amountNote);\n    }\n\n    /**\n     *\n     * @param _message The message payload from the executor formatted as an OFT composed message.\n     * @return _nonce The nonce value.\n     * @return _srcEid The source endpoint ID.\n     * @return _amountLD The amount in local decimals.\n     * @return _composeFrom The composeFrom value (msg.sender on from chain).\n     * @return _composeMsg The composed message.\n     */\n    function _decodeOFTComposeMsg(bytes calldata _message) internal pure returns (uint64 _nonce, uint32 _srcEid, uint256 _amountLD, bytes32 _composeFrom, bytes memory _composeMsg) {"
    }
  ]
}