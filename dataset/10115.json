{
  "Title": "[M-03] `uncommit` sends tokens to the wrong user",
  "Content": "_Submitted by cmichel, also found by WatchPug_.\n\nThe `PoolCommitter._uncommit` function calls the `ILeveragedPool(leveragedPool).quoteTokenTransfer/mintTokens` function with `msg.sender`.\nBut in `_uncommit`'s case that's the **pool, not the commit owner**, see `onlyPool` modifier on `executeAllCommitments` which calls `_uncommit`.\n\n#### Impact\n\nUsers lose all tokens from their commitments as they are sent / minted to the pool instead.\n\n#### Recommended Mitigation Steps\n\nInstead of `msg.sender`, use `_commit.owner`:\n\n```solidity\n// minting: return quote tokens to the commit owner\n// @audit msg.sender is pool, should be _commit.owner\nILeveragedPool(leveragedPool).quoteTokenTransfer(msg.sender, _commit.amount);\n// same with mint cases\n```\n\n**[rogue developer (Tracer) disagreed with severity](https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-945331001):**\n > This is a valid issue. However, it requires there to be an underlying bug in the contracts which would make the `executeCommitment` call in `executeAllCommitments` revert (as `_uncommit` is only called in that case). If the warden can find a way for `executeCommitment` to revert, we would consider this to be an issue of this severity but otherwise we disagree with the severity as it requires/needs to be paired with another bug in the contracts.\n> \n> It's also worth noting that governance can rescue any funds (rather, quote/collateral tokens) from the `LeveragedPool` contract. So if there were to be a case where there was a bug in the contracts that led to `executeCommitment` reverting and the users having their mints (quote tokens sent back to the `LeveragedPool`), governance could pause the contracts, drain out the equivalent worth and set up another contract where users can burn their tokens/claim them; if they burned the tokens which later uncommitted, then governance could send them an equal amount in collateral tokens. On the same note, if a critical vulnerability in `executeCommitment` were to be happening whereby commits were being uncommitted, then governance could also pause the contracts, rescue the funds and do some combination of the efforts above to ensure users get the funds back securely.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955094840):**\n > Would setting up a commit such that this line will underflow\n> https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/PoolCommitter.sol#L305\n> , causing a revert, be a way to cause the function to call `_uncommit` ?\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955095206):**\n > Also, to clarify, you're saying you believe the code will never call `_uncommit` as it won't ever revert, right?\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955097577):**\n > At this time I believe that if a user mistakenly commits more than the value in `shadowPools[_commitType]` they can cause a silent revert which will trigger the bug\n> \n> I think only their own funds are at risk, and either passing along the original committer or storing it in the commitData would allow to safely return them their funds.\n> \n> With the information I have this issue sits between medium and high severity, high severity because user funds are at risk, medium because:\n> ```\n> 2 — Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> ```\n> \n> As of now I'll mark as medium and valid.\n> \n> Will think it over the weekend\n> \n> If the sponsor can let me know their take and reply to the questions above, that can help clarify the severity and validity\n\n**[rogue developer (Tracer) commented](https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955099303):**\n > > Would setting up a commit such that this line will underflow https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/PoolCommitter.sol#L305 , causing a revert, be a way to cause the function to call _uncommit ?\n> \n> @Alex the Entreprenerd No. `shadowPools` is a mapping of commit types to the sum of pool tokens to be burned (rather, to be executed because they've already been burned), or sum of collateral tokens to be used in minting that haven't been used for minting yet. `executeCommitment` can only be called on `Commit`'s, which are in the `commits` mapping, which can only be added to via the `commit` function where users have to commit to putting up collateral/burning their pool tokens, which is the function that increments `shadowPools`. I realise that sounds a bit convoluted, but basically `executeCommitment` and its `_commit` parameter has a direct dependency on users committing via the `commit` function, which increments `shadowPools` by the value of their commit (which they can't game -- their collateral tokens get sent to the `LeveragedPool` contract instantly and their tokens get burned instantly and they don't have access to those funds anymore). \n> \n> > Also, to clarify, you're saying you believe the code will never call `_uncommit` as it won't ever revert, right?\n> \n> Yes, that's right. It is there as a fail-safe (so that if there was some bug in a commit that stopped a commit in the queue from being executed, it wouldn't stop the markets). We are refactoring this code nonetheless though.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955101993):**\n > Alright from this information I understand that the underflow idea can't happen (gas optimization there would be to use `unsafe` operations I guess)\n> \n> I think given the system a refactoring to send the funds back is warranted\n> \n> That said the fact that there seems to be no way to get a revert excludes the high severity.\n> \n> That leaves us with the finding either being med or low risk\n> \n> Low risk would be acceptable as the code doesn't work as it suggests (`_uncommit` is never executed, and if it did it wouldn't reimburse the user)\n> \n> The alternative take is Medium: if `_uncommit` where executed it would cause in a loss of funds / funds stuck\n> \n> As of now I'll leave it as med, while we don't have a way to trigger `_uncommit` we can still make the claim that if `_uncommit` where to run, it wouldn't reimburse the user\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955108907):**\n > Going a little deeper for the sake of clarity:\n> \n> The math library is programmed to never revert:\n> https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/PoolSwapLibrary.sol#L256\n> \n> The amounts in commit are always greater than 0 so no revert there\n> \n> \n> The pool.setter is innocuous\n> \n> The only thing I found is the `pool.quoteTokenTransfer(_commit.owner, amountOut);`\n> \n> If for an unfortunate reason the pool is drained from the quoteToken and the safeTransfer fail, then the function would revert\n> \n> \n> On that note the way to perform this would be to use\n> `    function setKeeper(address _keeper) external override onlyGov onlyUnpaused {`\n> To change the keeper to a EOA / Malicious account\n> \n> And then run\n> `function payKeeperFromBalances(address to, uint256 amount)`\n> with the full amount (or close to it) of `amount <= shortBalance + longBalance`\n> \n> This seems to be a permissioned way (admin privilege) to rug funds from the LeveragedPool as well as enabling the `_uncommit` to be triggered\n> \n> Given these findings (which I may misunderstand, so feel free to correct me) I highly recommend the sponsor to ensure there's a timelock for changing keeper\n> Additionally (and I may be missing something) allowing `payKeeperFromBalances` to take an indiscriminate amount of funds may prove to be a rug vector the sponsor should consider eliminating.\n> \n> I'm fairly confident the [math library](https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMathQuad.sol) will never revert, even if you input a high fee, which means that while the end state may be unexpected, the function can be used to rug.\n> \n> Highly recommend the sponsor to consider having caps on the `amount` parameter for [`payKeeperFromBalances`](https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L111) as this function seems to be the way to break the protocol (and the trust of the users)\n> \n\n**[rogue developer (Tracer) commented](https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955112942):**\n > @Alex the Entreprenerd Yep, that's completely right. However (and this is something we should have made clear in an assumptions section), all markets will be deployed by the DAO/DAO multisig. You can see that the `payKeeperFromBalances` function has a modifier called `onlyGov` -- meaning only governance (the DAO/DAO multisig) can change this and that's something that's immutable and can't be changed. Governance also has the ability to take quote tokens out of the `LeveragedPool` contract (with `withdrawQuote`) unlike the hack with changing the keeper (more directly this way) but we've been going under the assumption that the only reason we'd do this is in the rescue of user funds in the case of some hack. \n> \n> If the governance multisig is compromised, they have the ability to do a lot of damage but we've been going under the assumption this just won't be the case, which I think is a safe one to make. So you're right in that `uncommit` can send tokens to the wrong user in case the function reverts because of governance draining funds directly or via setting a malicious keeper, but I think that `uncommit` sending tokens to the wrong user is the least of problems if that happens because governance would only ever drain funds in the case of a major hack. If we're going under the assumption that the multisig _can_ easily be compromised, then the \"centralisation\" point around the DAO would be a much bigger point. \n> \n> I still think this should be a low/information by virtue of the fact that unless there is an underlying bug in the contracts, `uncommit` can't be called (it may as well be dead code) -- if it gets called because governance has rugged, that is then relatively a fairly small problem because all the funds would be at risk in a much more direct way in that case.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955115864):**\n > @rogue developer agree that if governance is malicious, the `_uncommit` path is the least problem\n> \n> One thing to note is that the `keeper` has the ability of trying to claim a lot of fees, and the modifier seems to be `onlyKeeper` if the keeper were to be a bot, or a human operator they would have the ability of rugging, unless the parameter `amount` was under some check (let's say less than 1% AUM or something)\n> \n> I agree that you can set to the `PoolKeeper` contract which seems safe, once potential rug vector, again from governance would be to inject a high `gasPrice` via `setGasPrice` which as a `onlyOwner` modifier\n> \n> Contract for PoolKeeper:\n> https://arbiscan.io/address/0x759E817F0C40B11C775d1071d466B5ff5c6ce28e#code\n> \n> The owner is the Dev Multisig:\n> https://arbiscan.io/address/0x0f79e82ae88e1318b8cfc8b4a205fe2f982b928a#readContract\n> \n> This does give the Dev Multisig admin privileges and a potential for griefing at the very least if not rugging, as they could raise the gas price, and then run `performUpkeepSinglePool` which would eventually call `payKeeperFromBalances`\n> \n> That said, this is something I'm flagging up right now and outside of the contest\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955116449):**\n > As per the finding at this point I believe it's valid and at medium severity, it is not high severity due to need for existing preconditions that are not \"usual\", see definition from Gitbook:\n> `\n> 2 — Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> `\n> \n> We can agree that the pre-condition here are drastic and this finding would be the last of the protocols problems\n> \n> In terms of mitigation, ensuring that the funds are send back to the address that initiated the commit are more than sufficient\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955116649):**\n > Per the \"multisig privileges\" above, I recommend you replace `owner` on the poolKeeper with a TimeLock as in it's current state, the gasPrice may be a way to rug funds from depositors\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-10-tracer",
  "Code": [
    {
      "filename": "contracts/implementation/PoolCommitter.sol",
      "content": "//SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity 0.8.7;\n\nimport \"../interfaces/IPoolCommitter.sol\";\nimport \"../interfaces/ILeveragedPool.sol\";\nimport \"../interfaces/IPoolFactory.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./PoolSwapLibrary.sol\";\nimport \"../interfaces/IOracleWrapper.sol\";\n\n/// @title This contract is responsible for handling commitment logic\ncontract PoolCommitter is IPoolCommitter, Ownable {\n    // #### Globals\n\n    address public leveragedPool;\n    // Index 0 is the LONG token, index 1 is the SHORT token.\n    // Fetched from the LeveragedPool when leveragedPool is set\n    address[2] public tokens;\n\n    // MAX_UINT128\n    uint128 public constant NO_COMMITS_REMAINING = type(uint128).max;\n    uint128 public earliestCommitUnexecuted = NO_COMMITS_REMAINING;\n    uint128 public latestCommitUnexecuted;\n    uint128 public commitIDCounter;\n    uint128 public minimumCommitSize; // The minimum amount (in settlement tokens) that a user can commit in a single commitment\n    uint128 public maximumCommitQueueLength; // The maximum number of commitments that can be made for a given updateInterval\n    uint128 public currentCommitQueueLength;\n    uint256 public lastQueueLengthReset; // The time the queue length was last reset\n    mapping(uint128 => Commit) public commits;\n    mapping(uint256 => uint256) public shadowPools;\n\n    address public factory;\n    address public governance;\n\n    enum ScanDirection {\n        UP,\n        DOWN\n    }\n\n    constructor(\n        address _factory,\n        uint128 _minimumCommitSize,\n        uint128 _maximumCommitQueueLength\n    ) {\n        require(_factory != address(0), \"Factory address cannot be null\");\n        // set the factory on deploy\n        factory = _factory;\n        minimumCommitSize = _minimumCommitSize;\n        maximumCommitQueueLength = _maximumCommitQueueLength;\n        governance = IPoolFactory(factory).getOwner();\n        lastQueueLengthReset = block.timestamp;\n    }\n\n    /**\n     * @notice Commit to minting/burning long/short tokens after the next price change\n     * @param commitType Type of commit you're doing (Long vs Short, Mint vs Burn)\n     * @param amount Amount of quote tokens you want to commit to minting; OR amount of pool\n     *               tokens you want to burn\n     */\n    function commit(CommitType commitType, uint256 amount) external override {\n        require(currentCommitQueueLength < maximumCommitQueueLength, \"Too many commits in interval\");\n        require(amount > 0, \"Amount must not be zero\");\n        ILeveragedPool pool = ILeveragedPool(leveragedPool);\n        uint256 updateInterval = pool.updateInterval();\n        uint256 lastPriceTimestamp = pool.lastPriceTimestamp();\n        uint256 frontRunningInterval = pool.frontRunningInterval();\n\n        if (\n            PoolSwapLibrary.isBeforeFrontRunningInterval(\n                lastQueueLengthReset,\n                lastPriceTimestamp,\n                updateInterval,\n                frontRunningInterval\n            ) &&\n            !PoolSwapLibrary.isBeforeFrontRunningInterval(\n                block.timestamp,\n                lastPriceTimestamp,\n                updateInterval,\n                frontRunningInterval\n            )\n        ) {\n            /**\n             * The lastQueueLengthReset occured before the frontRunningInterval,\n             * and we are within the frontRunningInterval,\n             * so this is the first commit since frontRunningInterval has passed.\n             * Note: If and only if there are no `commit` calls within the frontRunningInterval, then\n             * `executeAllCommitments` will reset `currentCommitQueueLength` and update\n             * `lastQueueLengthReset`.\n             */\n            delete currentCommitQueueLength;\n            lastQueueLengthReset = block.timestamp;\n        }\n        currentCommitQueueLength += 1;\n        uint128 currentCommitIDCounter = commitIDCounter;\n        commitIDCounter = currentCommitIDCounter + 1;\n\n        // create commitment\n        commits[currentCommitIDCounter] = Commit({\n            commitType: commitType,\n            amount: amount,\n            owner: msg.sender,\n            created: uint40(block.timestamp)\n        });\n        uint256 _commitType = uint256(commitType);\n        shadowPools[_commitType] = shadowPools[_commitType] + amount;\n\n        if (earliestCommitUnexecuted == NO_COMMITS_REMAINING) {\n            earliestCommitUnexecuted = currentCommitIDCounter;\n        }\n        latestCommitUnexecuted = currentCommitIDCounter;\n\n        emit CreateCommit(currentCommitIDCounter, amount, commitType);\n        uint256 shortBalance = pool.shortBalance();\n        uint256 longBalance = pool.longBalance();\n\n        // pull in tokens\n        if (commitType == CommitType.LongMint || commitType == CommitType.ShortMint) {\n            // minting: pull in the quote token from the committer\n            require(amount >= minimumCommitSize, \"Amount less than minimum\");\n            pool.quoteTokenTransferFrom(msg.sender, leveragedPool, amount);\n        } else if (commitType == CommitType.LongBurn) {\n            // long burning: pull in long pool tokens from committer\n\n            // A theoretical amount based on current ratio. Used to get same units as minimumCommitSize\n            uint256 amountOut = PoolSwapLibrary.getWithdrawAmountOnBurn(\n                IERC20(tokens[0]).totalSupply(),\n                amount,\n                longBalance,\n                shadowPools[_commitType]\n            );\n            require(amountOut >= minimumCommitSize, \"Amount less than minimum\");\n            pool.burnTokens(0, amount, msg.sender);\n        } else if (commitType == CommitType.ShortBurn) {\n            // short burning: pull in short pool tokens from committer\n\n            // A theoretical amount based on current ratio. Used to get same units as minimumCommitSize\n            uint256 amountOut = PoolSwapLibrary.getWithdrawAmountOnBurn(\n                IERC20(tokens[1]).totalSupply(),\n                amount,\n                shortBalance,\n                shadowPools[_commitType]\n            );\n            require(amountOut >= minimumCommitSize, \"Amount less than minimum\");\n            pool.burnTokens(1, amount, msg.sender);\n        }\n    }\n\n    /**\n     * @dev When required, scan through the from earliestCommitUnexecuted to latestCommitUnexecuted\n     *      and set these variables to be correct based on which of the commits between them are\n     *      uncommited.\n     *      This is useful for when you uncommit the first or last commit, and you can scan backwards or forwards\n     *      in order to find the new value earliestCommitUnexecuted or latestCommitUnexecuted should be set to.\n     * @param direction UP if going from earliest to latest, DOWN if going from latest to earliest.\n     */\n    function skipDeletedMiddleCommits(ScanDirection direction) internal {\n        if (direction == ScanDirection.UP) {\n            uint128 nextEarliestCommitUnexecuted = earliestCommitUnexecuted;\n            while (nextEarliestCommitUnexecuted <= latestCommitUnexecuted) {\n                IPoolCommitter.Commit memory _commit = commits[nextEarliestCommitUnexecuted];\n                if (_commit.owner == address(0)) {\n                    // Commit deleted (uncommitted) or already executed\n                    nextEarliestCommitUnexecuted += 1; // It makes sense to set the next unexecuted to the next number\n                    continue;\n                } else {\n                    break;\n                }\n            }\n            if (nextEarliestCommitUnexecuted > latestCommitUnexecuted) {\n                // We have just bumped earliestCommitUnexecuted above latestCommitUnexecuted,\n                // we have therefore run out of commits\n                earliestCommitUnexecuted = NO_COMMITS_REMAINING;\n            } else {\n                earliestCommitUnexecuted = nextEarliestCommitUnexecuted;\n            }\n        }\n\n        if (direction == ScanDirection.DOWN) {\n            uint128 nextLatestCommitUnexecuted = latestCommitUnexecuted;\n            while (nextLatestCommitUnexecuted >= earliestCommitUnexecuted) {\n                IPoolCommitter.Commit memory _commit = commits[nextLatestCommitUnexecuted];\n                if (_commit.owner == address(0)) {\n                    // Commit deleted (uncommitted) or already executed\n                    nextLatestCommitUnexecuted -= 1;\n                    continue;\n                } else {\n                    break;\n                }\n            }\n            if (nextLatestCommitUnexecuted < earliestCommitUnexecuted) {\n                // We have just bumped earliestCommitUnexecuted above latestCommitUnexecuted,\n                // we have therefore run out of commits\n                earliestCommitUnexecuted = NO_COMMITS_REMAINING;\n            } else {\n                latestCommitUnexecuted = nextLatestCommitUnexecuted;\n            }\n        }\n    }\n\n    function _uncommit(Commit memory _commit, uint128 _commitID) internal {\n        // reduce pool commitment amount\n        uint256 _commitType = uint256(_commit.commitType);\n        shadowPools[_commitType] = shadowPools[_commitType] - _commit.amount;\n        emit RemoveCommit(_commitID, _commit.amount, _commit.commitType);\n\n        delete commits[_commitID];\n\n        if (earliestCommitUnexecuted == _commitID) {\n            // This is the first unexecuted commit, so we can bump this up one\n            earliestCommitUnexecuted += 1;\n            skipDeletedMiddleCommits(ScanDirection.UP);\n        }\n        if (latestCommitUnexecuted == _commitID && earliestCommitUnexecuted != NO_COMMITS_REMAINING) {\n            // This is the latest commit unexecuted that we are trying to delete.\n            latestCommitUnexecuted -= 1;\n            skipDeletedMiddleCommits(ScanDirection.DOWN);\n        }\n\n        // release tokens\n        if (_commit.commitType == CommitType.LongMint || _commit.commitType == CommitType.ShortMint) {\n            // minting: return quote tokens to the commit owner\n            ILeveragedPool(leveragedPool).quoteTokenTransfer(msg.sender, _commit.amount);\n        } else if (_commit.commitType == CommitType.LongBurn) {\n            // long burning: return long pool tokens to commit owner\n            ILeveragedPool(leveragedPool).mintTokens(0, _commit.amount, msg.sender);\n        } else if (_commit.commitType == CommitType.ShortBurn) {\n            // short burning: return short pool tokens to the commit owner\n            ILeveragedPool(leveragedPool).mintTokens(1, _commit.amount, msg.sender);\n        }\n    }\n\n    /**\n     * @notice Execute all the pending commits of a market\n     */\n    function executeAllCommitments() external override onlyPool {\n        if (earliestCommitUnexecuted == NO_COMMITS_REMAINING) {\n            return;\n        }\n        ILeveragedPool pool = ILeveragedPool(leveragedPool);\n        uint256 frontRunningInterval = pool.frontRunningInterval();\n        uint256 updateInterval = pool.updateInterval();\n        uint256 lastPriceTimestamp = pool.lastPriceTimestamp();\n\n        /**\n         * If the queue length was reset before the frontRunningInterval that just passed, it means\n         * there were no commitments during that frontRunningInterval, meaning we can reset queue length.\n         */\n        if (\n            PoolSwapLibrary.isBeforeFrontRunningInterval(\n                lastQueueLengthReset,\n                lastPriceTimestamp,\n                updateInterval,\n                frontRunningInterval\n            )\n        ) {\n            delete currentCommitQueueLength;\n            lastQueueLengthReset = block.timestamp;\n        }\n        uint128 nextEarliestCommitUnexecuted;\n\n        uint128 _latestCommitUnexecuted = latestCommitUnexecuted;\n        for (\n            nextEarliestCommitUnexecuted = earliestCommitUnexecuted;\n            nextEarliestCommitUnexecuted <= _latestCommitUnexecuted;\n            nextEarliestCommitUnexecuted++\n        ) {\n            IPoolCommitter.Commit memory _commit = commits[nextEarliestCommitUnexecuted];\n            // These two checks are so a given call to executeCommitment won't revert,\n            // allowing us to continue iterations, as well as update nextEarliestCommitUnexecuted.\n            if (_commit.owner == address(0)) {\n                // Commit deleted (uncommitted) or already executed\n                continue;\n            }\n            if (block.timestamp - _commit.created <= frontRunningInterval) {\n                // This commit is the first that was too late.\n                break;\n            }\n            emit ExecuteCommit(nextEarliestCommitUnexecuted);\n            try IPoolCommitter(address(this)).executeCommitment(_commit) {\n                delete commits[nextEarliestCommitUnexecuted];\n            } catch {\n                _uncommit(_commit, nextEarliestCommitUnexecuted);\n                emit FailedCommitExecution(nextEarliestCommitUnexecuted);\n            }\n            if (nextEarliestCommitUnexecuted == _latestCommitUnexecuted) {\n                // We have reached the last one\n                earliestCommitUnexecuted = NO_COMMITS_REMAINING;\n                return;\n            }\n        }\n        earliestCommitUnexecuted = nextEarliestCommitUnexecuted;\n    }\n\n    /**\n     * @notice Executes a single commitment\n     * @param _commit The commit to execute\n     */\n    function executeCommitment(Commit memory _commit) external override onlySelf {\n        ILeveragedPool pool = ILeveragedPool(leveragedPool);\n        uint256 shortBalance = pool.shortBalance();\n        uint256 longBalance = pool.longBalance();\n        uint256 _commitType = uint256(_commit.commitType);\n        shadowPools[_commitType] = shadowPools[_commitType] - _commit.amount;\n        if (_commit.commitType == CommitType.LongMint) {\n            uint256 mintAmount = PoolSwapLibrary.getMintAmount(\n                IERC20(tokens[0]).totalSupply(), // long token total supply,\n                _commit.amount, // amount of quote tokens commited to enter\n                longBalance, // total quote tokens in the long pull\n                shadowPools[uint256(CommitType.LongBurn)] // total pool tokens commited to be burned\n            );\n\n            pool.mintTokens(0, mintAmount, _commit.owner);\n            // update long and short balances\n            pool.setNewPoolBalances(longBalance + _commit.amount, shortBalance);\n        } else if (_commit.commitType == CommitType.LongBurn) {\n            uint256 amountOut = PoolSwapLibrary.getWithdrawAmountOnBurn(\n                IERC20(tokens[0]).totalSupply(),\n                _commit.amount,\n                longBalance,\n                shadowPools[_commitType] + _commit.amount\n            );\n\n            // update long and short balances\n            pool.setNewPoolBalances(longBalance - amountOut, shortBalance);\n            pool.quoteTokenTransfer(_commit.owner, amountOut);\n        } else if (_commit.commitType == CommitType.ShortMint) {\n            uint256 mintAmount = PoolSwapLibrary.getMintAmount(\n                IERC20(tokens[1]).totalSupply(), // short token total supply\n                _commit.amount,\n                shortBalance,\n                shadowPools[uint256(CommitType.ShortBurn)]\n            );\n\n            pool.mintTokens(1, mintAmount, _commit.owner);\n            pool.setNewPoolBalances(longBalance, shortBalance + _commit.amount);\n        } else if (_commit.commitType == CommitType.ShortBurn) {\n            uint256 amountOut = PoolSwapLibrary.getWithdrawAmountOnBurn(\n                IERC20(tokens[1]).totalSupply(),\n                _commit.amount,\n                shortBalance,\n                shadowPools[_commitType] + _commit.amount\n            );\n\n            // update long and short balances\n            pool.setNewPoolBalances(longBalance, shortBalance - amountOut);\n            pool.quoteTokenTransfer(_commit.owner, amountOut);\n        }\n    }\n\n    /**\n     * @return A Commit of a given ID\n     */\n    function getCommit(uint128 _commitID) external view override returns (Commit memory) {\n        return commits[_commitID];\n    }\n\n    function setQuoteAndPool(address _quoteToken, address _leveragedPool) external override onlyFactory {\n        require(_quoteToken != address(0), \"Quote token address cannot be 0 address\");\n        require(_leveragedPool != address(0), \"Leveraged pool address cannot be 0 address\");\n        leveragedPool = _leveragedPool;\n        IERC20 _token = IERC20(_quoteToken);\n        bool approvalSuccess = _token.approve(leveragedPool, _token.totalSupply());\n        require(approvalSuccess, \"ERC20 approval failed\");\n        tokens = ILeveragedPool(leveragedPool).poolTokens();\n    }\n\n    function setMinimumCommitSize(uint128 _minimumCommitSize) external override onlyGov {\n        minimumCommitSize = _minimumCommitSize;\n        emit MinCommitSizeChanged(_minimumCommitSize);\n    }\n\n    function setMaxCommitQueueLength(uint128 _maximumCommitQueueLength) external override onlyGov {\n        require(_maximumCommitQueueLength > 0, \"Commit queue must be > 0\");\n        maximumCommitQueueLength = _maximumCommitQueueLength;\n        emit MaxCommitQueueLengthChanged(_maximumCommitQueueLength);\n    }\n\n    modifier onlyFactory() {\n        require(msg.sender == factory, \"Committer: not factory\");\n        _;\n    }\n\n    modifier onlyPool() {\n        require(msg.sender == leveragedPool, \"msg.sender not leveragedPool\");\n        _;\n    }\n\n    modifier onlySelf() {\n        require(msg.sender == address(this), \"msg.sender not self\");\n        _;\n    }\n\n    modifier onlyGov() {\n        require(msg.sender == governance, \"msg.sender not governance\");\n        _;\n    }\n}"
    },
    {
      "filename": "contracts/implementation/PoolCommitter.sol",
      "content": "//SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity 0.8.7;\n\nimport \"../interfaces/IPoolCommitter.sol\";\nimport \"../interfaces/ILeveragedPool.sol\";\nimport \"../interfaces/IPoolFactory.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./PoolSwapLibrary.sol\";\nimport \"../interfaces/IOracleWrapper.sol\";\n\n/// @title This contract is responsible for handling commitment logic\ncontract PoolCommitter is IPoolCommitter, Ownable {\n    // #### Globals\n\n    address public leveragedPool;\n    // Index 0 is the LONG token, index 1 is the SHORT token.\n    // Fetched from the LeveragedPool when leveragedPool is set\n    address[2] public tokens;\n\n    // MAX_UINT128\n    uint128 public constant NO_COMMITS_REMAINING = type(uint128).max;\n    uint128 public earliestCommitUnexecuted = NO_COMMITS_REMAINING;\n    uint128 public latestCommitUnexecuted;\n    uint128 public commitIDCounter;\n    uint128 public minimumCommitSize; // The minimum amount (in settlement tokens) that a user can commit in a single commitment\n    uint128 public maximumCommitQueueLength; // The maximum number of commitments that can be made for a given updateInterval\n    uint128 public currentCommitQueueLength;\n    uint256 public lastQueueLengthReset; // The time the queue length was last reset\n    mapping(uint128 => Commit) public commits;\n    mapping(uint256 => uint256) public shadowPools;\n\n    address public factory;\n    address public governance;\n\n    enum ScanDirection {\n        UP,\n        DOWN\n    }\n\n    constructor(\n        address _factory,\n        uint128 _minimumCommitSize,\n        uint128 _maximumCommitQueueLength\n    ) {\n        require(_factory != address(0), \"Factory address cannot be null\");\n        // set the factory on deploy\n        factory = _factory;\n        minimumCommitSize = _minimumCommitSize;\n        maximumCommitQueueLength = _maximumCommitQueueLength;\n        governance = IPoolFactory(factory).getOwner();\n        lastQueueLengthReset = block.timestamp;\n    }\n\n    /**\n     * @notice Commit to minting/burning long/short tokens after the next price change\n     * @param commitType Type of commit you're doing (Long vs Short, Mint vs Burn)\n     * @param amount Amount of quote tokens you want to commit to minting; OR amount of pool\n     *               tokens you want to burn\n     */\n    function commit(CommitType commitType, uint256 amount) external override {\n        require(currentCommitQueueLength < maximumCommitQueueLength, \"Too many commits in interval\");\n        require(amount > 0, \"Amount must not be zero\");\n        ILeveragedPool pool = ILeveragedPool(leveragedPool);\n        uint256 updateInterval = pool.updateInterval();\n        uint256 lastPriceTimestamp = pool.lastPriceTimestamp();\n        uint256 frontRunningInterval = pool.frontRunningInterval();\n\n        if (\n            PoolSwapLibrary.isBeforeFrontRunningInterval(\n                lastQueueLengthReset,\n                lastPriceTimestamp,\n                updateInterval,\n                frontRunningInterval\n            ) &&\n            !PoolSwapLibrary.isBeforeFrontRunningInterval(\n                block.timestamp,\n                lastPriceTimestamp,\n                updateInterval,\n                frontRunningInterval\n            )\n        ) {\n            /**\n             * The lastQueueLengthReset occured before the frontRunningInterval,\n             * and we are within the frontRunningInterval,\n             * so this is the first commit since frontRunningInterval has passed.\n             * Note: If and only if there are no `commit` calls within the frontRunningInterval, then\n             * `executeAllCommitments` will reset `currentCommitQueueLength` and update\n             * `lastQueueLengthReset`.\n             */\n            delete currentCommitQueueLength;\n            lastQueueLengthReset = block.timestamp;\n        }\n        currentCommitQueueLength += 1;\n        uint128 currentCommitIDCounter = commitIDCounter;\n        commitIDCounter = currentCommitIDCounter + 1;\n\n        // create commitment\n        commits[currentCommitIDCounter] = Commit({\n            commitType: commitType,\n            amount: amount,\n            owner: msg.sender,\n            created: uint40(block.timestamp)\n        });\n        uint256 _commitType = uint256(commitType);\n        shadowPools[_commitType] = shadowPools[_commitType] + amount;\n\n        if (earliestCommitUnexecuted == NO_COMMITS_REMAINING) {\n            earliestCommitUnexecuted = currentCommitIDCounter;\n        }\n        latestCommitUnexecuted = currentCommitIDCounter;\n\n        emit CreateCommit(currentCommitIDCounter, amount, commitType);\n        uint256 shortBalance = pool.shortBalance();\n        uint256 longBalance = pool.longBalance();\n\n        // pull in tokens\n        if (commitType == CommitType.LongMint || commitType == CommitType.ShortMint) {\n            // minting: pull in the quote token from the committer\n            require(amount >= minimumCommitSize, \"Amount less than minimum\");\n            pool.quoteTokenTransferFrom(msg.sender, leveragedPool, amount);\n        } else if (commitType == CommitType.LongBurn) {\n            // long burning: pull in long pool tokens from committer\n\n            // A theoretical amount based on current ratio. Used to get same units as minimumCommitSize\n            uint256 amountOut = PoolSwapLibrary.getWithdrawAmountOnBurn(\n                IERC20(tokens[0]).totalSupply(),\n                amount,\n                longBalance,\n                shadowPools[_commitType]\n            );\n            require(amountOut >= minimumCommitSize, \"Amount less than minimum\");\n            pool.burnTokens(0, amount, msg.sender);\n        } else if (commitType == CommitType.ShortBurn) {\n            // short burning: pull in short pool tokens from committer\n\n            // A theoretical amount based on current ratio. Used to get same units as minimumCommitSize\n            uint256 amountOut = PoolSwapLibrary.getWithdrawAmountOnBurn(\n                IERC20(tokens[1]).totalSupply(),\n                amount,\n                shortBalance,\n                shadowPools[_commitType]\n            );\n            require(amountOut >= minimumCommitSize, \"Amount less than minimum\");\n            pool.burnTokens(1, amount, msg.sender);\n        }\n    }\n\n    /**\n     * @dev When required, scan through the from earliestCommitUnexecuted to latestCommitUnexecuted\n     *      and set these variables to be correct based on which of the commits between them are\n     *      uncommited.\n     *      This is useful for when you uncommit the first or last commit, and you can scan backwards or forwards\n     *      in order to find the new value earliestCommitUnexecuted or latestCommitUnexecuted should be set to.\n     * @param direction UP if going from earliest to latest, DOWN if going from latest to earliest.\n     */\n    function skipDeletedMiddleCommits(ScanDirection direction) internal {\n        if (direction == ScanDirection.UP) {\n            uint128 nextEarliestCommitUnexecuted = earliestCommitUnexecuted;\n            while (nextEarliestCommitUnexecuted <= latestCommitUnexecuted) {\n                IPoolCommitter.Commit memory _commit = commits[nextEarliestCommitUnexecuted];\n                if (_commit.owner == address(0)) {\n                    // Commit deleted (uncommitted) or already executed\n                    nextEarliestCommitUnexecuted += 1; // It makes sense to set the next unexecuted to the next number\n                    continue;\n                } else {\n                    break;\n                }\n            }\n            if (nextEarliestCommitUnexecuted > latestCommitUnexecuted) {\n                // We have just bumped earliestCommitUnexecuted above latestCommitUnexecuted,\n                // we have therefore run out of commits\n                earliestCommitUnexecuted = NO_COMMITS_REMAINING;\n            } else {\n                earliestCommitUnexecuted = nextEarliestCommitUnexecuted;\n            }\n        }\n\n        if (direction == ScanDirection.DOWN) {\n            uint128 nextLatestCommitUnexecuted = latestCommitUnexecuted;\n            while (nextLatestCommitUnexecuted >= earliestCommitUnexecuted) {\n                IPoolCommitter.Commit memory _commit = commits[nextLatestCommitUnexecuted];\n                if (_commit.owner == address(0)) {\n                    // Commit deleted (uncommitted) or already executed\n                    nextLatestCommitUnexecuted -= 1;\n                    continue;\n                } else {\n                    break;\n                }\n            }\n            if (nextLatestCommitUnexecuted < earliestCommitUnexecuted) {\n                // We have just bumped earliestCommitUnexecuted above latestCommitUnexecuted,\n                // we have therefore run out of commits\n                earliestCommitUnexecuted = NO_COMMITS_REMAINING;\n            } else {\n                latestCommitUnexecuted = nextLatestCommitUnexecuted;\n            }\n        }\n    }\n\n    function _uncommit(Commit memory _commit, uint128 _commitID) internal {\n        // reduce pool commitment amount\n        uint256 _commitType = uint256(_commit.commitType);\n        shadowPools[_commitType] = shadowPools[_commitType] - _commit.amount;\n        emit RemoveCommit(_commitID, _commit.amount, _commit.commitType);\n\n        delete commits[_commitID];\n\n        if (earliestCommitUnexecuted == _commitID) {\n            // This is the first unexecuted commit, so we can bump this up one\n            earliestCommitUnexecuted += 1;\n            skipDeletedMiddleCommits(ScanDirection.UP);\n        }\n        if (latestCommitUnexecuted == _commitID && earliestCommitUnexecuted != NO_COMMITS_REMAINING) {\n            // This is the latest commit unexecuted that we are trying to delete.\n            latestCommitUnexecuted -= 1;\n            skipDeletedMiddleCommits(ScanDirection.DOWN);\n        }\n\n        // release tokens\n        if (_commit.commitType == CommitType.LongMint || _commit.commitType == CommitType.ShortMint) {\n            // minting: return quote tokens to the commit owner\n            ILeveragedPool(leveragedPool).quoteTokenTransfer(msg.sender, _commit.amount);\n        } else if (_commit.commitType == CommitType.LongBurn) {\n            // long burning: return long pool tokens to commit owner\n            ILeveragedPool(leveragedPool).mintTokens(0, _commit.amount, msg.sender);\n        } else if (_commit.commitType == CommitType.ShortBurn) {\n            // short burning: return short pool tokens to the commit owner\n            ILeveragedPool(leveragedPool).mintTokens(1, _commit.amount, msg.sender);\n        }\n    }\n\n    /**\n     * @notice Execute all the pending commits of a market\n     */\n    function executeAllCommitments() external override onlyPool {\n        if (earliestCommitUnexecuted == NO_COMMITS_REMAINING) {\n            return;\n        }\n        ILeveragedPool pool = ILeveragedPool(leveragedPool);\n        uint256 frontRunningInterval = pool.frontRunningInterval();\n        uint256 updateInterval = pool.updateInterval();\n        uint256 lastPriceTimestamp = pool.lastPriceTimestamp();\n\n        /**\n         * If the queue length was reset before the frontRunningInterval that just passed, it means\n         * there were no commitments during that frontRunningInterval, meaning we can reset queue length.\n         */\n        if (\n            PoolSwapLibrary.isBeforeFrontRunningInterval(\n                lastQueueLengthReset,\n                lastPriceTimestamp,\n                updateInterval,\n                frontRunningInterval\n            )\n        ) {\n            delete currentCommitQueueLength;\n            lastQueueLengthReset = block.timestamp;\n        }\n        uint128 nextEarliestCommitUnexecuted;\n\n        uint128 _latestCommitUnexecuted = latestCommitUnexecuted;\n        for (\n            nextEarliestCommitUnexecuted = earliestCommitUnexecuted;\n            nextEarliestCommitUnexecuted <= _latestCommitUnexecuted;\n            nextEarliestCommitUnexecuted++\n        ) {\n            IPoolCommitter.Commit memory _commit = commits[nextEarliestCommitUnexecuted];\n            // These two checks are so a given call to executeCommitment won't revert,\n            // allowing us to continue iterations, as well as update nextEarliestCommitUnexecuted.\n            if (_commit.owner == address(0)) {\n                // Commit deleted (uncommitted) or already executed\n                continue;\n            }\n            if (block.timestamp - _commit.created <= frontRunningInterval) {\n                // This commit is the first that was too late.\n                break;\n            }\n            emit ExecuteCommit(nextEarliestCommitUnexecuted);\n            try IPoolCommitter(address(this)).executeCommitment(_commit) {\n                delete commits[nextEarliestCommitUnexecuted];\n            } catch {\n                _uncommit(_commit, nextEarliestCommitUnexecuted);\n                emit FailedCommitExecution(nextEarliestCommitUnexecuted);\n            }\n            if (nextEarliestCommitUnexecuted == _latestCommitUnexecuted) {\n                // We have reached the last one\n                earliestCommitUnexecuted = NO_COMMITS_REMAINING;\n                return;\n            }\n        }\n        earliestCommitUnexecuted = nextEarliestCommitUnexecuted;\n    }\n\n    /**\n     * @notice Executes a single commitment\n     * @param _commit The commit to execute\n     */\n    function executeCommitment(Commit memory _commit) external override onlySelf {\n        ILeveragedPool pool = ILeveragedPool(leveragedPool);\n        uint256 shortBalance = pool.shortBalance();\n        uint256 longBalance = pool.longBalance();\n        uint256 _commitType = uint256(_commit.commitType);\n        shadowPools[_commitType] = shadowPools[_commitType] - _commit.amount;\n        if (_commit.commitType == CommitType.LongMint) {\n            uint256 mintAmount = PoolSwapLibrary.getMintAmount(\n                IERC20(tokens[0]).totalSupply(), // long token total supply,\n                _commit.amount, // amount of quote tokens commited to enter\n                longBalance, // total quote tokens in the long pull\n                shadowPools[uint256(CommitType.LongBurn)] // total pool tokens commited to be burned\n            );\n\n            pool.mintTokens(0, mintAmount, _commit.owner);\n            // update long and short balances\n            pool.setNewPoolBalances(longBalance + _commit.amount, shortBalance);\n        } else if (_commit.commitType == CommitType.LongBurn) {\n            uint256 amountOut = PoolSwapLibrary.getWithdrawAmountOnBurn(\n                IERC20(tokens[0]).totalSupply(),\n                _commit.amount,\n                longBalance,\n                shadowPools[_commitType] + _commit.amount\n            );\n\n            // update long and short balances\n            pool.setNewPoolBalances(longBalance - amountOut, shortBalance);\n            pool.quoteTokenTransfer(_commit.owner, amountOut);"
    }
  ]
}