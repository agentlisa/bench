{
  "Title": "[G-03] Function `initialize()` in `L2SharedBridge.sol` can be optimized",
  "Content": "\n**File:** `L2SharedBridge.sol`\n\nThis issue requires code-refactoring of some code, thus it was reported separately.\n\n[File: code/contracts/zksync/contracts/bridge/L2SharedBridge.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/zksync/contracts/bridge/L2SharedBridge.sol#L60)\n```solidity\n60:         l1Bridge = _l1Bridge;\n61:         l2TokenProxyBytecodeHash = _l2TokenProxyBytecodeHash;\n62: \n63:         if (block.chainid != ERA_CHAIN_ID) {\n64:             address l2StandardToken = address(new L2StandardERC20{salt: bytes32(0)}());\n65:             l2TokenBeacon = new UpgradeableBeacon{salt: bytes32(0)}(l2StandardToken);\n66:             l2TokenBeacon.transferOwnership(_aliasedOwner);\n67:         } else {\n68:             require(_l1LegecyBridge != address(0), \"bf2\");\n69:             // l2StandardToken and l2TokenBeacon are already deployed on ERA, and stored in the proxy\n70:         }\n```\nWhen `block.chainid` is `ERA_CHAIN_ID` and `_l1LegecyBridge` is `address(0)` - we can revert earlier, without wasting gas on reading state variables: `l1Bridge` and `l2TokenProxyBytecodeHash`.\nMoreover, we can use `==` operator, instead of `!=`.\n\n```\n        if (block.chainid == ERA_CHAIN_ID) {\n        require(_l1LegecyBridge != address(0), \"bf2\");\n        } else {\n            address l2StandardToken = address(new L2StandardERC20{salt: bytes32(0)}());\n            l2TokenBeacon = new UpgradeableBeacon{salt: bytes32(0)}(l2StandardToken);\n            l2TokenBeacon.transferOwnership(_aliasedOwner);\n        }\n        l1Bridge = _l1Bridge;\n        l2TokenProxyBytecodeHash = _l2TokenProxyBytecodeHash;\n\n```\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/contracts/zksync/contracts/bridge/L2SharedBridge.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {BeaconProxy} from \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport {UpgradeableBeacon} from \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\n\nimport {IL1ERC20Bridge} from \"./interfaces/IL1ERC20Bridge.sol\";\nimport {IL2SharedBridge} from \"./interfaces/IL2SharedBridge.sol\";\nimport {IL2StandardToken} from \"./interfaces/IL2StandardToken.sol\";\n\nimport {L2StandardERC20} from \"./L2StandardERC20.sol\";\nimport {AddressAliasHelper} from \"../vendor/AddressAliasHelper.sol\";\nimport {L2ContractHelper, DEPLOYER_SYSTEM_CONTRACT, L2_BASE_TOKEN_ADDRESS, IContractDeployer} from \"../L2ContractHelper.sol\";\nimport {SystemContractsCaller} from \"../SystemContractsCaller.sol\";\nimport {ERA_CHAIN_ID, ERA_WETH_ADDRESS} from \"../Config.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The \"default\" bridge implementation for the ERC20 tokens. Note, that it does not\n/// support any custom token logic, i.e. rebase tokens' functionality is not supported.\ncontract L2SharedBridge is IL2SharedBridge, Initializable {\n    /// @dev The address of the L1 bridge counterpart.\n    address public override l1Bridge;\n\n    /// @dev Contract that stores the implementation address for token.\n    /// @dev For more details see https://docs.openzeppelin.com/contracts/3.x/api/proxy#UpgradeableBeacon.\n    UpgradeableBeacon public l2TokenBeacon;\n\n    /// @dev Bytecode hash of the proxy for tokens deployed by the bridge.\n    bytes32 internal l2TokenProxyBytecodeHash;\n\n    /// @dev A mapping l2 token address => l1 token address\n    mapping(address l2TokenAddress => address l1TokenAddress) public override l1TokenAddress;\n\n    address private l1LegacyBridge;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Disable the initialization to prevent Parity hack.\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the bridge contract for later use. Expected to be used in the proxy.\n    /// @param _l1Bridge The address of the L1 Bridge contract.\n    /// @param _l2TokenProxyBytecodeHash The bytecode hash of the proxy for tokens deployed by the bridge.\n    /// @param _aliasedOwner The address of the governor contract.\n    function initialize(\n        address _l1Bridge,\n        address _l1LegecyBridge,\n        bytes32 _l2TokenProxyBytecodeHash,\n        address _aliasedOwner\n    ) external reinitializer(2) {\n        require(_l1Bridge != address(0), \"bf\");\n        require(_l2TokenProxyBytecodeHash != bytes32(0), \"df\");\n        require(_aliasedOwner != address(0), \"sf\");\n        require(_l2TokenProxyBytecodeHash != bytes32(0), \"df\");\n\n        l1Bridge = _l1Bridge;\n        l2TokenProxyBytecodeHash = _l2TokenProxyBytecodeHash;\n\n        if (block.chainid != ERA_CHAIN_ID) {\n            address l2StandardToken = address(new L2StandardERC20{salt: bytes32(0)}());\n            l2TokenBeacon = new UpgradeableBeacon{salt: bytes32(0)}(l2StandardToken);\n            l2TokenBeacon.transferOwnership(_aliasedOwner);\n        } else {\n            require(_l1LegecyBridge != address(0), \"bf2\");\n            // l2StandardToken and l2TokenBeacon are already deployed on ERA, and stored in the proxy\n        }\n    }\n\n    /// @notice Finalize the deposit and mint funds\n    /// @param _l1Sender The account address that initiated the deposit on L1\n    /// @param _l2Receiver The account address that would receive minted ether\n    /// @param _l1Token The address of the token that was locked on the L1\n    /// @param _amount Total amount of tokens deposited from L1\n    /// @param _data The additional data that user can pass with the deposit\n    function finalizeDeposit(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable override {\n        // Only the L1 bridge counterpart can initiate and finalize the deposit.\n        require(\n            AddressAliasHelper.undoL1ToL2Alias(msg.sender) == l1Bridge ||\n                AddressAliasHelper.undoL1ToL2Alias(msg.sender) == l1LegacyBridge,\n            \"mq\"\n        );\n        require(msg.value == 0, \"Value should be 0 for ERC20 bridge\");\n\n        address expectedL2Token = l2TokenAddress(_l1Token);\n        address currentL1Token = l1TokenAddress[expectedL2Token];\n        if (currentL1Token == address(0)) {\n            address deployedToken = _deployL2Token(_l1Token, _data);\n            require(deployedToken == expectedL2Token, \"mt\");\n            l1TokenAddress[expectedL2Token] = _l1Token;\n        } else {\n            require(currentL1Token == _l1Token, \"gg\"); // Double check that the expected value equal to real one\n        }\n\n        IL2StandardToken(expectedL2Token).bridgeMint(_l2Receiver, _amount);\n        emit FinalizeDeposit(_l1Sender, _l2Receiver, expectedL2Token, _amount);\n    }\n\n    /// @dev Deploy and initialize the L2 token for the L1 counterpart\n    function _deployL2Token(address _l1Token, bytes calldata _data) internal returns (address) {\n        bytes32 salt = _getCreate2Salt(_l1Token);\n\n        BeaconProxy l2Token = _deployBeaconProxy(salt);\n        L2StandardERC20(address(l2Token)).bridgeInitialize(_l1Token, _data);\n\n        return address(l2Token);\n    }\n\n    /// @notice Initiates a withdrawal by burning funds on the contract and sending the message to L1\n    /// where tokens would be unlocked\n    /// @param _l1Receiver The account address that should receive funds on L1\n    /// @param _l2Token The L2 token address which is withdrawn\n    /// @param _amount The total amount of tokens to be withdrawn\n    function withdraw(address _l1Receiver, address _l2Token, uint256 _amount) external override {\n        require(_amount > 0, \"Amount cannot be zero\");\n\n        IL2StandardToken(_l2Token).bridgeBurn(msg.sender, _amount);\n\n        address l1Token = l1TokenAddress[_l2Token];\n        require(l1Token != address(0), \"yh\");\n\n        bytes memory message = _getL1WithdrawMessage(_l1Receiver, l1Token, _amount);\n        L2ContractHelper.sendMessageToL1(message);\n\n        emit WithdrawalInitiated(msg.sender, _l1Receiver, _l2Token, _amount);\n    }\n\n    /// @dev Encode the message for l2ToL1log sent with withdraw initialization\n    function _getL1WithdrawMessage(\n        address _to,\n        address _l1Token,\n        uint256 _amount\n    ) internal pure returns (bytes memory) {\n        // note we use the IL1ERC20Bridge.finalizeWithdrawal function selector to specify the selector for L1<>L2 messages,\n        // and we use this interface so that when the switch happened the old messages could be processed\n        return abi.encodePacked(IL1ERC20Bridge.finalizeWithdrawal.selector, _to, _l1Token, _amount);\n    }\n\n    /// @return Address of an L2 token counterpart\n    function l2TokenAddress(address _l1Token) public view override returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(address(l2TokenBeacon), \"\"));\n        bytes32 salt = _getCreate2Salt(_l1Token);\n        return\n            L2ContractHelper.computeCreate2Address(address(this), salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }\n\n    /// @dev Convert the L1 token address to the create2 salt of deployed L2 token\n    function _getCreate2Salt(address _l1Token) internal pure returns (bytes32 salt) {\n        salt = bytes32(uint256(uint160(_l1Token)));\n    }\n\n    /// @dev Deploy the beacon proxy for the L2 token, while using ContractDeployer system contract.\n    /// @dev This function uses raw call to ContractDeployer to make sure that exactly `l2TokenProxyBytecodeHash` is used\n    /// for the code of the proxy.\n    function _deployBeaconProxy(bytes32 salt) internal returns (BeaconProxy proxy) {\n        (bool success, bytes memory returndata) = SystemContractsCaller.systemCallWithReturndata(\n            uint32(gasleft()),\n            DEPLOYER_SYSTEM_CONTRACT,\n            0,\n            abi.encodeCall(\n                IContractDeployer.create2,\n                (salt, l2TokenProxyBytecodeHash, abi.encode(address(l2TokenBeacon), \"\"))\n            )\n        );\n\n        // The deployment should be successful and return the address of the proxy\n        require(success, \"mk\");\n        proxy = BeaconProxy(abi.decode(returndata, (address)));\n    }\n}"
    }
  ]
}