{
  "Title": "[4] State variables should be cached in stack variables rather than re-reading them from storage",
  "Content": "The instances below point to the second+ access of a state variable within a function. Caching of a state variable replace each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.\n\n*There are 32 instances of this issue:*\n```solidity\nFile: protocol/contracts/StakerVault.sol\n\n/// @audit token\n330:          uint256 oldBal = IERC20(token).balanceOf(address(this));\n\n/// @audit token\n333:              ILiquidityPool pool = addressProvider.getPoolForToken(token);\n\n/// @audit token\n337:          IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n/// @audit token\n338:          uint256 staked = IERC20(token).balanceOf(address(this)) - oldBal;\n\n/// @audit token\n375:          uint256 oldBal = IERC20(token).balanceOf(address(this));\n\n/// @audit token\n381:          IERC20(token).safeTransfer(dst, amount);\n\n/// @audit token\n383:          uint256 unstaked = oldBal.uncheckedSub(IERC20(token).balanceOf(address(this)));\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L330\n\n```solidity\nFile: protocol/contracts/BkdLocker.sol\n\n/// @audit totalLockedBoosted\n97:           curRewardTokenData.feeIntegral += amount.scaledDiv(totalLockedBoosted);\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L97\n\n```solidity\nFile: protocol/contracts/tokenomics/Minter.sol\n\n/// @audit currentInflationAmountLp\n91:               currentInflationAmountLp +\n\n/// @audit currentInflationAmountLp\n208:                  currentInflationAmountLp +\n\n/// @audit currentInflationAmountKeeper\n92:               currentInflationAmountKeeper +\n\n/// @audit currentInflationAmountKeeper\n209:                  currentInflationAmountKeeper +\n\n/// @audit currentInflationAmountAmm\n93:               currentInflationAmountAmm;\n\n/// @audit currentInflationAmountAmm\n210:                  currentInflationAmountAmm;\n\n/// @audit totalAvailableToNow\n220:          require(newTotalMintedToNow <= totalAvailableToNow, \"Mintable amount exceeded\");\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L91\n\n```solidity\nFile: protocol/contracts/tokenomics/InflationManager.sol\n\n/// @audit minter\n501:          uint256 lpInflationRate = Minter(minter).getLpInflationRate();\n\n/// @audit minter\n511:          uint256 keeperInflationRate = Minter(minter).getKeeperInflationRate();\n\n/// @audit minter\n526:          uint256 ammInflationRate = Minter(minter).getAmmInflationRate();\n\n/// @audit totalKeeperPoolWeight\n517:              totalKeeperPoolWeight;\n\n/// @audit totalKeeperPoolWeight\n575:          totalKeeperPoolWeight = totalKeeperPoolWeight > 0 ? totalKeeperPoolWeight : 0;\n\n/// @audit totalLpPoolWeight\n502:          uint256 poolInflationRate = (currentUInts256[key] * lpInflationRate) / totalLpPoolWeight;\n\n/// @audit totalLpPoolWeight\n589:          totalLpPoolWeight = totalLpPoolWeight > 0 ? totalLpPoolWeight : 0;\n\n/// @audit totalAmmTokenWeight\n528:              totalAmmTokenWeight;\n\n/// @audit totalAmmTokenWeight\n602:          totalAmmTokenWeight = totalAmmTokenWeight > 0 ? totalAmmTokenWeight : 0;\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L501\n\n```solidity\nFile: protocol/contracts/tokenomics/AmmGauge.sol\n\n/// @audit ammStakedIntegral\n159:          perUserStakedIntegral[user] = ammStakedIntegral;\n\n/// @audit totalStaked\n90:                   (block.timestamp - uint256(ammLastUpdated))).scaledDiv(totalStaked);\n\n/// @audit totalStaked\n148:              ammStakedIntegral += (currentRate * timeElapsed).scaledDiv(totalStaked);\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L159\n\n```solidity\nFile: protocol/contracts/tokenomics/VestedEscrow.sol\n\n/// @audit unallocatedSupply\n84:           require(unallocatedSupply > 0, \"No reward tokens in contract\");\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L84\n\n```solidity\nFile: protocol/contracts/tokenomics/KeeperGauge.sol\n\n/// @audit epoch\n87:           keeperRecords[beneficiary].feesInPeriod[epoch] += amount;\n\n/// @audit epoch\n88:           perPeriodTotalFees[epoch] += amount;\n\n/// @audit epoch\n131:              endEpoch = epoch;\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L87\n\n```solidity\nFile: protocol/contracts/access/RoleManager.sol\n\n/// @audit _roles[role].members\n148:          return _roles[role].members[account];\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L148\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-05-backd",
  "Code": [
    {
      "filename": "protocol/contracts/StakerVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../libraries/ScaledMath.sol\";\nimport \"../libraries/Errors.sol\";\nimport \"../libraries/AddressProviderHelpers.sol\";\nimport \"../libraries/UncheckedMath.sol\";\n\nimport \"../interfaces/IStakerVault.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/tokenomics/IRewardsGauge.sol\";\nimport \"../interfaces/tokenomics/IInflationManager.sol\";\nimport \"../interfaces/pool/ILiquidityPool.sol\";\nimport \"../interfaces/tokenomics/ILpGauge.sol\";\nimport \"../interfaces/IERC20Full.sol\";\n\nimport \"./utils/Preparable.sol\";\nimport \"./Controller.sol\";\nimport \"./pool/LiquidityPool.sol\";\nimport \"./access/Authorization.sol\";\nimport \"./utils/Pausable.sol\";\n\n/**\n * @notice This contract handles staked tokens from Backd pools\n * However, note that this is NOT an ERC-20 compliant contract and these\n * tokens should never be integrated with any protocol assuming ERC-20 compliant\n * tokens\n * @dev When paused, allows only withdraw/unstake\n */\ncontract StakerVault is IStakerVault, Authorization, Pausable, Initializable, Preparable {\n    using AddressProviderHelpers for IAddressProvider;\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using UncheckedMath for uint256;\n\n    bytes32 internal constant _LP_GAUGE = \"lpGauge\";\n\n    IController public immutable controller;\n\n    IInflationManager public immutable inflationManager;\n    IAddressProvider public immutable addressProvider;\n\n    address public token;\n\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public actionLockedBalances;\n\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    // All the data fields required for the staking tracking\n    uint256 private _poolTotalStaked;\n\n    mapping(address => bool) public strategies;\n    uint256 public strategiesTotalStaked;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        IInflationManager inflationManager_ = controller.inflationManager();\n        require(address(inflationManager_) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        inflationManager = inflationManager_;\n        addressProvider = _controller.addressProvider();\n    }\n\n    function initialize(address _token) external override initializer {\n        token = _token;\n    }\n\n    function initializeLpGauge(address _lpGauge) external override onlyGovernance returns (bool) {\n        require(currentAddresses[_LP_GAUGE] == address(0), Error.ROLE_EXISTS);\n        _setConfig(_LP_GAUGE, _lpGauge);\n        inflationManager.addGaugeForVault(token);\n        return true;\n    }\n\n    function prepareLpGauge(address _lpGauge) external override onlyGovernance returns (bool) {\n        _prepare(_LP_GAUGE, _lpGauge);\n        return true;\n    }\n\n    function executeLpGauge() external override onlyGovernance returns (bool) {\n        _executeAddress(_LP_GAUGE);\n        inflationManager.addGaugeForVault(token);\n        return true;\n    }\n\n    /**\n     * @notice Registers an address as a strategy to be excluded from token accumulation.\n     * @dev This should be used if a strategy deposits into a stakerVault and should not get gov. tokens.\n     * @return `true` if success.\n     */\n    function addStrategy(address strategy) external override returns (bool) {\n        require(msg.sender == address(inflationManager), Error.UNAUTHORIZED_ACCESS);\n        strategies[strategy] = true;\n        return true;\n    }\n\n    /**\n     * @notice Transfer staked tokens to an account.\n     * @dev This is not an ERC20 transfer, as tokens are still owned by this contract, but fees get updated in the LP pool.\n     * @param account Address to transfer to.\n     * @param amount Amount to transfer.\n     * @return `true` if success.\n     */\n    function transfer(address account, uint256 amount) external override notPaused returns (bool) {\n        require(msg.sender != account, Error.SELF_TRANSFER_NOT_ALLOWED);\n        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE);\n\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        pool.handleLpTokenTransfer(msg.sender, account, amount);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(msg.sender);\n            ILpGauge(lpGauge).userCheckpoint(account);\n        }\n\n        balances[msg.sender] -= amount;\n        balances[account] += amount;\n\n        emit Transfer(msg.sender, account, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer staked tokens from src to dst.\n     * @dev This is not an ERC20 transfer, as tokens are still owned by this contract, but fees get updated in the LP pool.\n     * @param src Address to transfer from.\n     * @param dst Address to transfer to.\n     * @param amount Amount to transfer.\n     * @return `true` if success.\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external override notPaused returns (bool) {\n        /* Do not allow self transfers */\n        require(src != dst, Error.SAME_ADDRESS_NOT_ALLOWED);\n\n        /* Get the allowance, infinite for the account owner */\n        uint256 startingAllowance;\n        if (msg.sender == src) {\n            startingAllowance = type(uint256).max;\n        } else {\n            startingAllowance = _allowances[src][msg.sender];\n        }\n        require(startingAllowance >= amount, Error.INSUFFICIENT_ALLOWANCE);\n\n        uint256 srcTokens = balances[src];\n        require(srcTokens >= amount, Error.INSUFFICIENT_BALANCE);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(src);\n            ILpGauge(lpGauge).userCheckpoint(dst);\n        }\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        pool.handleLpTokenTransfer(src, dst, amount);\n\n        /* Update token balances */\n        balances[src] = srcTokens.uncheckedSub(amount);\n        balances[dst] = balances[dst] + amount;\n\n        /* Update allowance if necessary */\n        if (startingAllowance != type(uint256).max) {\n            _allowances[src][msg.sender] = startingAllowance.uncheckedSub(amount);\n        }\n        emit Transfer(src, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Approve staked tokens for spender.\n     * @param spender Address to approve tokens for.\n     * @param amount Amount to approve.\n     * @return `true` if success.\n     */\n    function approve(address spender, uint256 amount) external override notPaused returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice If an action is registered and stakes funds, this updates the actionLockedBalances for the user.\n     * @param account Address that registered the action.\n     * @param amount Amount staked by the action.\n     * @return `true` if success.\n     */\n    function increaseActionLockedBalance(address account, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        require(addressProvider.isAction(msg.sender), Error.UNAUTHORIZED_ACCESS);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(account);\n        }\n        actionLockedBalances[account] += amount;\n        return true;\n    }\n\n    /**\n     * @notice If an action is executed/reset, this updates the actionLockedBalances for the user.\n     * @param account Address that registered the action.\n     * @param amount Amount executed/reset by the action.\n     * @return `true` if success.\n     */\n    function decreaseActionLockedBalance(address account, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        require(addressProvider.isAction(msg.sender), Error.UNAUTHORIZED_ACCESS);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(account);\n        }\n        if (actionLockedBalances[account] > amount) {\n            actionLockedBalances[account] = actionLockedBalances[account].uncheckedSub(amount);\n        } else {\n            actionLockedBalances[account] = 0;\n        }\n        return true;\n    }\n\n    function poolCheckpoint() external override returns (bool) {\n        if (currentAddresses[_LP_GAUGE] != address(0)) {\n            return ILpGauge(currentAddresses[_LP_GAUGE]).poolCheckpoint();\n        }\n        return false;\n    }\n\n    function getLpGauge() external view override returns (address) {\n        return currentAddresses[_LP_GAUGE];\n    }\n\n    function isStrategy(address user) external view override returns (bool) {\n        return strategies[user];\n    }\n\n    /**\n     * @notice Get the total amount of tokens that are staked by actions\n     * @return Total amount staked by actions\n     */\n    function getStakedByActions() external view override returns (uint256) {\n        address[] memory actions = addressProvider.allActions();\n        uint256 total;\n        for (uint256 i; i < actions.length; i = i.uncheckedInc()) {\n            total += balances[actions[i]];\n        }\n        return total;\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function balanceOf(address account) external view override returns (uint256) {\n        return balances[account];\n    }\n\n    function getPoolTotalStaked() external view override returns (uint256) {\n        return _poolTotalStaked;\n    }\n\n    /**\n     * @notice Returns the total balance in the staker vault, including that locked in positions.\n     * @param account Account to query balance for.\n     * @return Total balance in staker vault for account.\n     */\n    function stakedAndActionLockedBalanceOf(address account)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return balances[account] + actionLockedBalances[account];\n    }\n\n    function actionLockedBalanceOf(address account) external view override returns (uint256) {\n        return actionLockedBalances[account];\n    }\n\n    function decimals() external view override returns (uint8) {\n        return IERC20Full(token).decimals();\n    }\n\n    function getToken() external view override returns (address) {\n        return token;\n    }\n\n    function unstake(uint256 amount) public override returns (bool) {\n        return unstakeFor(msg.sender, msg.sender, amount);\n    }\n\n    /**\n     * @notice Stake an amount of vault tokens.\n     * @param amount Amount of token to stake.\n     * @return `true` if success.\n     */\n    function stake(uint256 amount) public override returns (bool) {\n        return stakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Stake amount of vault token on behalf of another account.\n     * @param account Account for which tokens will be staked.\n     * @param amount Amount of token to stake.\n     * @return `true` if success.\n     */\n    function stakeFor(address account, uint256 amount) public override notPaused returns (bool) {\n        require(IERC20(token).balanceOf(msg.sender) >= amount, Error.INSUFFICIENT_BALANCE);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(account);\n        }\n\n        uint256 oldBal = IERC20(token).balanceOf(address(this));\n\n        if (msg.sender != account) {\n            ILiquidityPool pool = addressProvider.getPoolForToken(token);\n            pool.handleLpTokenTransfer(msg.sender, account, amount);\n        }\n\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 staked = IERC20(token).balanceOf(address(this)) - oldBal;\n        require(staked == amount, Error.INVALID_AMOUNT);\n        balances[account] += staked;\n\n        if (strategies[account]) {\n            strategiesTotalStaked += staked;\n        } else {\n            _poolTotalStaked += staked;\n        }\n        emit Staked(account, amount);\n        return true;\n    }\n\n    /**\n     * @notice Unstake tokens on behalf of another account.\n     * @dev Needs to be approved.\n     * @param src Account for which tokens will be unstaked.\n     * @param dst Account receiving the tokens.\n     * @param amount Amount of token to unstake/receive.\n     * @return `true` if success.\n     */\n    function unstakeFor(\n        address src,\n        address dst,\n        uint256 amount\n    ) public override returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 allowance_ = _allowances[src][msg.sender];\n        require(\n            src == msg.sender || allowance_ >= amount || address(pool) == msg.sender,\n            Error.UNAUTHORIZED_ACCESS\n        );\n        require(balances[src] >= amount, Error.INSUFFICIENT_BALANCE);\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(src);\n        }\n        uint256 oldBal = IERC20(token).balanceOf(address(this));\n\n        if (src != dst) {\n            pool.handleLpTokenTransfer(src, dst, amount);\n        }\n\n        IERC20(token).safeTransfer(dst, amount);\n\n        uint256 unstaked = oldBal.uncheckedSub(IERC20(token).balanceOf(address(this)));\n\n        if (src != msg.sender && allowance_ != type(uint256).max && address(pool) != msg.sender) {\n            // update allowance\n            _allowances[src][msg.sender] -= unstaked;\n        }\n        balances[src] -= unstaked;\n\n        if (strategies[src]) {\n            strategiesTotalStaked -= unstaked;\n        } else {\n            _poolTotalStaked -= unstaked;\n        }\n        emit Unstaked(src, amount);\n        return true;\n    }\n\n    function _isAuthorizedToPause(address account) internal view override returns (bool) {\n        return _roleManager().hasRole(Roles.GOVERNANCE, account);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/BkdLocker.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../libraries/ScaledMath.sol\";\nimport \"../libraries/Errors.sol\";\nimport \"../libraries/EnumerableExtensions.sol\";\nimport \"../libraries/UncheckedMath.sol\";\nimport \"../interfaces/IBkdLocker.sol\";\nimport \"../interfaces/tokenomics/IMigrationContract.sol\";\nimport \"./utils/Preparable.sol\";\nimport \"./access/Authorization.sol\";\n\ncontract BkdLocker is IBkdLocker, Authorization, Preparable {\n    using ScaledMath for uint256;\n    using UncheckedMath for uint256;\n    using SafeERC20 for IERC20;\n    using EnumerableMapping for EnumerableMapping.AddressToUintMap;\n    using EnumerableExtensions for EnumerableMapping.AddressToUintMap;\n\n    bytes32 internal constant _START_BOOST = \"startBoost\";\n    bytes32 internal constant _MAX_BOOST = \"maxBoost\";\n    bytes32 internal constant _INCREASE_PERIOD = \"increasePeriod\";\n    bytes32 internal constant _WITHDRAW_DELAY = \"withdrawDelay\";\n\n    // User-specific data\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public boostFactors;\n    mapping(address => uint256) public lastUpdated;\n    mapping(address => WithdrawStash[]) public stashedGovTokens;\n    mapping(address => uint256) public totalStashed;\n\n    // Global data\n    uint256 public totalLocked;\n    uint256 public totalLockedBoosted;\n    uint256 public lastMigrationEvent;\n    EnumerableMapping.AddressToUintMap private _replacedRewardTokens;\n\n    // Reward token data\n    mapping(address => RewardTokenData) public rewardTokenData;\n    address public override rewardToken;\n    IERC20 public immutable govToken;\n\n    constructor(\n        address _rewardToken,\n        address _govToken,\n        IRoleManager roleManager\n    ) Authorization(roleManager) {\n        rewardToken = _rewardToken;\n        govToken = IERC20(_govToken);\n    }\n\n    function initialize(\n        uint256 startBoost,\n        uint256 maxBoost,\n        uint256 increasePeriod,\n        uint256 withdrawDelay\n    ) external override onlyGovernance {\n        require(currentUInts256[_START_BOOST] == 0, Error.CONTRACT_INITIALIZED);\n        _setConfig(_START_BOOST, startBoost);\n        _setConfig(_MAX_BOOST, maxBoost);\n        _setConfig(_INCREASE_PERIOD, increasePeriod);\n        _setConfig(_WITHDRAW_DELAY, withdrawDelay);\n    }\n\n    /**\n     * @notice Sets a new token to be the rewardToken. Fees are then accumulated in this token.\n     * @dev Previously used rewardTokens can be set again here.\n     */\n    function migrate(address newRewardToken) external override onlyGovernance {\n        _replacedRewardTokens.remove(newRewardToken);\n        _replacedRewardTokens.set(rewardToken, block.timestamp);\n        lastMigrationEvent = block.timestamp;\n        rewardToken = newRewardToken;\n    }\n\n    /**\n     * @notice Lock gov. tokens.\n     * @dev The amount needs to be approved in advance.\n     */\n    function lock(uint256 amount) external override {\n        return lockFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Deposit fees (in the rewardToken) to be distributed to lockers of gov. tokens.\n     * @dev `deposit` or `depositFor` needs to be called at least once before this function can be called\n     * @param amount Amount of rewardToken to deposit.\n     */\n    function depositFees(uint256 amount) external override {\n        require(amount > 0, Error.INVALID_AMOUNT);\n        require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);\n        IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);\n\n        RewardTokenData storage curRewardTokenData = rewardTokenData[rewardToken];\n\n        curRewardTokenData.feeIntegral += amount.scaledDiv(totalLockedBoosted);\n        curRewardTokenData.feeBalance += amount;\n        emit FeesDeposited(amount);\n    }\n\n    function claimFees() external override {\n        claimFees(rewardToken);\n    }\n\n    /**\n     * @notice Checkpoint function to update user data, in particular the boost factor.\n     */\n    function userCheckpoint(address user) external override {\n        _userCheckpoint(user, 0, balances[user]);\n    }\n\n    /**\n     * @notice Prepare unlocking of locked gov. tokens.\n     * @dev A delay is enforced and unlocking can only be executed after that.\n     * @param amount Amount of gov. tokens to prepare for unlocking.\n     */\n    function prepareUnlock(uint256 amount) external override {\n        require(\n            totalStashed[msg.sender] + amount <= balances[msg.sender],\n            \"Amount exceeds locked balance\"\n        );\n        totalStashed[msg.sender] += amount;\n        stashedGovTokens[msg.sender].push(\n            WithdrawStash(block.timestamp + currentUInts256[_WITHDRAW_DELAY], amount)\n        );\n        emit WithdrawPrepared(msg.sender, amount);\n    }\n\n    /**\n     * @notice Execute all prepared gov. token withdrawals.\n     */\n    function executeUnlocks() external override {\n        uint256 totalAvailableToWithdraw;\n        WithdrawStash[] storage stashedWithdraws = stashedGovTokens[msg.sender];\n        uint256 length = stashedWithdraws.length;\n        require(length > 0, \"No entries\");\n        uint256 i = length;\n        while (i > 0) {\n            i = i - 1;\n            if (stashedWithdraws[i].releaseTime <= block.timestamp) {\n                totalAvailableToWithdraw += stashedWithdraws[i].amount;\n\n                stashedWithdraws[i] = stashedWithdraws[stashedWithdraws.length - 1];\n\n                stashedWithdraws.pop();\n            }\n        }\n        totalStashed[msg.sender] -= totalAvailableToWithdraw;\n        uint256 newTotal = balances[msg.sender] - totalAvailableToWithdraw;\n        _userCheckpoint(msg.sender, 0, newTotal);\n        totalLocked -= totalAvailableToWithdraw;\n        govToken.safeTransfer(msg.sender, totalAvailableToWithdraw);\n        emit WithdrawExecuted(msg.sender, totalAvailableToWithdraw);\n    }\n\n    function getUserShare(address user) external view override returns (uint256) {\n        return getUserShare(user, rewardToken);\n    }\n\n    /**\n     * @notice Get the boosted locked balance for a user.\n     * @dev This includes the gov. tokens queued for withdrawal.\n     * @param user Address to get the boosted balance for.\n     * @return boosted balance for user.\n     */\n    function boostedBalance(address user) external view override returns (uint256) {\n        return balances[user].scaledMul(boostFactors[user]);\n    }\n\n    /**\n     * @notice Get the vote weight for a user.\n     * @dev This does not invlude the gov. tokens queued for withdrawal.\n     * @param user Address to get the vote weight for.\n     * @return vote weight for user.\n     */\n    function balanceOf(address user) external view override returns (uint256) {\n        return (balances[user] - totalStashed[user]).scaledMul(boostFactors[user]);\n    }\n\n    /**\n     * @notice Get the share of the total boosted locked balance for a user.\n     * @dev This includes the gov. tokens queued for withdrawal.\n     * @param user Address to get the share of the total boosted balance for.\n     * @return share of the total boosted balance for user.\n     */\n    function getShareOfTotalBoostedBalance(address user) external view override returns (uint256) {\n        return balances[user].scaledMul(boostFactors[user]).scaledDiv(totalLockedBoosted);\n    }\n\n    function getStashedGovTokens(address user)\n        external\n        view\n        override\n        returns (WithdrawStash[] memory)\n    {\n        return stashedGovTokens[user];\n    }\n\n    function claimableFees(address user) external view override returns (uint256) {\n        return claimableFees(user, rewardToken);\n    }\n\n    /**\n     * @notice Claim fees accumulated in the Locker.\n     */\n    function claimFees(address _rewardToken) public override {\n        require(\n            _rewardToken == rewardToken || _replacedRewardTokens.contains(_rewardToken),\n            Error.INVALID_ARGUMENT\n        );\n        _userCheckpoint(msg.sender, 0, balances[msg.sender]);\n        RewardTokenData storage curRewardTokenData = rewardTokenData[_rewardToken];\n        uint256 claimable = curRewardTokenData.userShares[msg.sender];\n        curRewardTokenData.userShares[msg.sender] = 0;\n        curRewardTokenData.feeBalance -= claimable;\n        IERC20(_rewardToken).safeTransfer(msg.sender, claimable);\n        emit RewardsClaimed(msg.sender, _rewardToken, claimable);\n    }\n\n    /**\n     * @notice Lock gov. tokens on behalf of another user.\n     * @dev The amount needs to be approved in advance.\n     * @param user Address of user to lock on behalf of.\n     * @param amount Amount of gov. tokens to lock.\n     */\n    function lockFor(address user, uint256 amount) public override {\n        govToken.safeTransferFrom(msg.sender, address(this), amount);\n        _userCheckpoint(user, amount, balances[user] + amount);\n        totalLocked += amount;\n        emit Locked(user, amount);\n    }\n\n    function getUserShare(address user, address _rewardToken)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return rewardTokenData[_rewardToken].userShares[user];\n    }\n\n    function claimableFees(address user, address _rewardToken)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 currentShare;\n        uint256 userBalance = balances[user];\n        RewardTokenData storage curRewardTokenData = rewardTokenData[_rewardToken];\n\n        // Compute the share earned by the user since they last updated\n        if (userBalance > 0) {\n            currentShare += (curRewardTokenData.feeIntegral -\n                curRewardTokenData.userFeeIntegrals[user]).scaledMul(\n                    userBalance.scaledMul(boostFactors[user])\n                );\n        }\n        return curRewardTokenData.userShares[user] + currentShare;\n    }\n\n    function computeNewBoost(\n        address user,\n        uint256 amountAdded,\n        uint256 newTotal\n    ) public view override returns (uint256) {\n        uint256 newBoost;\n        uint256 balance = balances[user];\n        uint256 startBoost = currentUInts256[_START_BOOST];\n        if (balance == 0 || newTotal == 0) {\n            newBoost = startBoost;\n        } else {\n            uint256 maxBoost = currentUInts256[_MAX_BOOST];\n            newBoost = boostFactors[user];\n            newBoost += (block.timestamp - lastUpdated[user])\n                .scaledDiv(currentUInts256[_INCREASE_PERIOD])\n                .scaledMul(maxBoost - startBoost);\n            if (newBoost > maxBoost) {\n                newBoost = maxBoost;\n            }\n            if (newTotal <= balance) {\n                return newBoost;\n            }\n            newBoost =\n                newBoost.scaledMul(balance.scaledDiv(newTotal)) +\n                startBoost.scaledMul(amountAdded.scaledDiv(newTotal));\n        }\n        return newBoost;\n    }\n\n    function _userCheckpoint(\n        address user,\n        uint256 amountAdded,\n        uint256 newTotal\n    ) internal {\n        RewardTokenData storage curRewardTokenData = rewardTokenData[rewardToken];\n\n        // Compute the share earned by the user since they last updated\n        uint256 userBalance = balances[user];\n        if (userBalance > 0) {\n            curRewardTokenData.userShares[user] += (curRewardTokenData.feeIntegral -\n                curRewardTokenData.userFeeIntegrals[user]).scaledMul(\n                    userBalance.scaledMul(boostFactors[user])\n                );\n\n            // Update values for previous rewardTokens\n            if (lastUpdated[user] < lastMigrationEvent) {\n                uint256 length = _replacedRewardTokens.length();\n                for (uint256 i; i < length; i = i.uncheckedInc()) {\n                    (address token, uint256 replacedAt) = _replacedRewardTokens.at(i);\n                    if (lastUpdated[user] < replacedAt) {\n                        RewardTokenData storage prevRewardTokenData = rewardTokenData[token];\n                        prevRewardTokenData.userShares[user] += (prevRewardTokenData.feeIntegral -\n                            prevRewardTokenData.userFeeIntegrals[user]).scaledMul(\n                                userBalance.scaledMul(boostFactors[user])\n                            );\n                        prevRewardTokenData.userFeeIntegrals[user] = prevRewardTokenData\n                            .feeIntegral;\n                    }\n                }\n            }\n        }\n\n        uint256 newBoost = computeNewBoost(user, amountAdded, newTotal);\n        totalLockedBoosted =\n            totalLockedBoosted +\n            newTotal.scaledMul(newBoost) -\n            balances[user].scaledMul(boostFactors[user]);\n\n        // Update user values\n        curRewardTokenData.userFeeIntegrals[user] = curRewardTokenData.feeIntegral;\n        lastUpdated[user] = block.timestamp;\n        boostFactors[user] = newBoost;\n        balances[user] = newTotal;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/tokenomics/Minter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/tokenomics/IBkdToken.sol\";\nimport \"../../interfaces/tokenomics/IMinter.sol\";\n\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/ScaledMath.sol\";\nimport \"../../libraries/AddressProviderHelpers.sol\";\n\nimport \"./BkdToken.sol\";\nimport \"../access/Authorization.sol\";\n\ncontract Minter is IMinter, Authorization, ReentrancyGuard {\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    uint256 private constant _INFLATION_DECAY_PERIOD = 365 days;\n\n    // Lp Rates\n    uint256 public immutable initialAnnualInflationRateLp;\n    uint256 public immutable annualInflationDecayLp;\n    uint256 public currentInflationAmountLp;\n\n    // Keeper Rates\n    uint256 public immutable initialPeriodKeeperInflation;\n    uint256 public immutable initialAnnualInflationRateKeeper;\n    uint256 public immutable annualInflationDecayKeeper;\n    uint256 public currentInflationAmountKeeper;\n\n    // AMM Rates\n    uint256 public immutable initialPeriodAmmInflation;\n    uint256 public immutable initialAnnualInflationRateAmm;\n    uint256 public immutable annualInflationDecayAmm;\n    uint256 public currentInflationAmountAmm;\n\n    bool public initialPeriodEnded;\n\n    // Non-inflation rates\n    uint256 public immutable nonInflationDistribution;\n    uint256 public issuedNonInflationSupply;\n\n    uint256 public lastInflationDecay;\n    uint256 public currentTotalInflation;\n\n    // Used for final safety check to ensure inflation is not exceeded\n    uint256 public totalAvailableToNow;\n    uint256 public totalMintedToNow;\n    uint256 public lastEvent;\n\n    IController public immutable controller;\n    BkdToken public token;\n\n    event TokensMinted(address beneficiary, uint256 amount);\n\n    constructor(\n        uint256 _annualInflationRateLp,\n        uint256 _annualInflationRateKeeper,\n        uint256 _annualInflationRateAmm,\n        uint256 _annualInflationDecayLp,\n        uint256 _annualInflationDecayKeeper,\n        uint256 _annualInflationDecayAmm,\n        uint256 _initialPeriodKeeperInflation,\n        uint256 _initialPeriodAmmInflation,\n        uint256 _nonInflationDistribution,\n        IController _controller\n    ) Authorization(_controller.addressProvider().getRoleManager()) {\n        require(_annualInflationDecayLp < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);\n        require(_annualInflationDecayKeeper < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);\n        require(_annualInflationDecayAmm < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);\n        initialAnnualInflationRateLp = _annualInflationRateLp;\n        initialAnnualInflationRateKeeper = _annualInflationRateKeeper;\n        initialAnnualInflationRateAmm = _annualInflationRateAmm;\n\n        annualInflationDecayLp = _annualInflationDecayLp;\n        annualInflationDecayKeeper = _annualInflationDecayKeeper;\n        annualInflationDecayAmm = _annualInflationDecayAmm;\n\n        initialPeriodKeeperInflation = _initialPeriodKeeperInflation;\n        initialPeriodAmmInflation = _initialPeriodAmmInflation;\n\n        currentInflationAmountLp = _annualInflationRateLp / _INFLATION_DECAY_PERIOD;\n        currentInflationAmountKeeper = _initialPeriodKeeperInflation / _INFLATION_DECAY_PERIOD;\n        currentInflationAmountAmm = _initialPeriodAmmInflation / _INFLATION_DECAY_PERIOD;\n\n        currentTotalInflation =\n            currentInflationAmountLp +\n            currentInflationAmountKeeper +\n            currentInflationAmountAmm;\n\n        nonInflationDistribution = _nonInflationDistribution;\n        controller = _controller;\n    }\n\n    function setToken(address _token) external override onlyGovernance {\n        require(address(token) == address(0), \"Token already set!\");\n        token = BkdToken(_token);\n    }\n\n    function startInflation() external override onlyGovernance {\n        require(lastEvent == 0, \"Inflation has already started.\");\n        lastEvent = block.timestamp;\n        lastInflationDecay = block.timestamp;\n    }\n\n    /**\n     * @notice Update the inflation rate according to the piecewise linear schedule.\n     * @dev This updates the inflation rate to the next linear segment in the inflations schedule.\n     * @return `true` if successful.\n     */\n    function executeInflationRateUpdate() external override returns (bool) {\n        return _executeInflationRateUpdate();\n    }\n\n    /**\n     * @notice Mints BKD tokens to a specified address.\n     * @dev Can only be called by the controller.\n     * @param beneficiary Address to mint tokens for.\n     * @param amount Amount of tokens to mint.\n     * @return `true` if successful.\n     */\n    function mint(address beneficiary, uint256 amount)\n        external\n        override\n        nonReentrant\n        returns (bool)\n    {\n        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);\n        if (lastEvent == 0) return false;\n        return _mint(beneficiary, amount);\n    }\n\n    /**\n     * @notice Mint tokens that are not part of the inflation schedule.\n     * @dev The amount of tokens that can be minted in total is subject to a pre-set upper limit.\n     * @param beneficiary Address to mint tok"
    }
  ]
}