{
  "Title": "Potential signature malleability in ERC865Token",
  "Content": "As [highlighted in the EIP 865’s ongoing discussion](https://github.com/ethereum/EIPs/issues/865#issuecomment-456921193), its current full implementation is affected by a signature malleability issue, steaming from the fact that in the current EIP, the `recover` function:\n\n\n* Allows both values 0/1 and 27/28 for `v`\n* Allows both lower and upper `s` values\n\n\nSignature malleability poses a security risk in systems that use these kind of signatures as unique identifiers; as is the case of the `ERC865Token` contract, where a [`signatures`](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/ERC865Token.sol#L18) [mapping](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/ERC865Token.sol#L18) takes care of tracking signed operations using a signature as the [identifier for each operation](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/ERC865Token.sol#L52).\n\n\nThe [`recover`](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/ERC865Token.sol#L344) [function implementation](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/ERC865Token.sol#L344) found in the `ERC865Token` contract appears to be copied from [OpenZeppelin-eth’s ECDSA library](https://github.com/OpenZeppelin/openzeppelin-eth/blob/v2.0.2/contracts/cryptography/ECDSA.sol#L18). Although [a set of lines](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/ERC865Token.sol#L362) were commented out in an attempt to patch the [signature malleability issue reported](https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1622) in the library, there is still debate around how to best approach the fix and whether only restricting the `v` value to 27/28 is sufficient to prevent signature malleability.\n\n\nTaking into account these issues, consider tracking unique operations using a hash of the payload (including a nonce to prevent equal operations from producing the same hash) instead of using potentially malleable signatures. This way, the custom implementation of the [`recover`](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/ERC865Token.sol#L344) [function](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/ERC865Token.sol#L344) in the `ERC865Token` contract could be removed from the codebase and instead directly imported from [OpenZeppelin’s ECDSA library](https://github.com/OpenZeppelin/openzeppelin-eth/blob/v2.0.2/contracts/cryptography/ECDSA.sol), since the [potential signature malleability issue](https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1622) in its `recover` function would no longer affect the `ERC865Token` implementation. In addition, the project will be able to benefit from thoroughly tested bug-fixes in future releases of the library.\n\n\nAs [EIP 865](https://github.com/ethereum/EIPs/issues/865) is still under discussion, it is highly recommended that the development team closely follows its evolution over time, not only to be aware of this and other security-related issues to be patched, but also of any changes that the contracts’ interfaces may suffer, which could eventually render the audited [`ERC865`](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/ERC865.sol) and [`ERC865Token`](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/ERC865Token.sol) contracts outdated and non-compliant.\n\n\nFor more details on what signature malleability is and how it can be exploited by attackers, please refer to:\n\n\n* [How Not to Use ECDSA](https://yondon.blog/2019/01/01/how-not-to-use-ecdsa/), by Yondon Fu.\n* [Bitcoin Transaction Malleability](https://eklitzke.org/bitcoin-transaction-malleability), by Evan Klitzke.\n\n\n***Update:*** *Fixed. The* [*contract is now using the*](https://github.com/propsproject/props-token-distribution/blob/7ead8c55da3770c4d39db8c89a8aa20ec62e97b1/contracts/token/ERC865Token.sol#L4) [*`recover`*](https://github.com/propsproject/props-token-distribution/blob/7ead8c55da3770c4d39db8c89a8aa20ec62e97b1/contracts/token/ERC865Token.sol#L4) [*function from OpenZeppelin*](https://github.com/propsproject/props-token-distribution/blob/7ead8c55da3770c4d39db8c89a8aa20ec62e97b1/contracts/token/ERC865Token.sol#L4)*. The hash of the payload and the signer address is now used as the identifier of the operation, for example, see* [*L215*](https://github.com/propsproject/props-token-distribution/blob/7ead8c55da3770c4d39db8c89a8aa20ec62e97b1/contracts/token/ERC865Token.sol#L215)*. Note that the EIP is still in draft.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/token/ERC865Token.sol",
      "content": "pragma solidity ^0.4.24;\n\n// import \"zeppelin-solidity/contracts/token/ERC20/StandardToken.sol\";\n// import \"openzeppelin-eth/contracts/token/ERC20/ERC20.sol\";\nimport \"./ERC865.sol\";\n\n/**\n * @title ERC865Token Token\n *\n * ERC865Token allows users paying transfers in tokens instead of gas\n * https://github.com/ethereum/EIPs/issues/865\n *\n */\n\ncontract ERC865Token is ERC865 {\n\n    /* Nonces of transfers performed */\n    mapping(bytes => bool) signatures;\n\n    event TransferPreSigned(address indexed from, address indexed to, address indexed delegate, uint256 amount, uint256 fee);\n    event ApprovalPreSigned(address indexed from, address indexed to, address indexed delegate, uint256 amount, uint256 fee);\n    /**\n     * @notice Submit a presigned transfer\n     * @param _signature bytes The signature, issued by the owner.\n     * @param _to address The address which you want to transfer to.\n     * @param _value uint256 The amount of tokens to be transferred.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function transferPreSigned(\n        bytes _signature,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {        \n        require(_to != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = transferPreSignedHashing(address(this), _to, _value, _fee, _nonce);\n\n        address from = recover(hashedTx, _signature);     \n        require(from != address(0));\n        _transfer(from, _to, _value);\n        _transfer(from, msg.sender, _fee);\n        // _balances[from] = _balances[from].sub(_value).sub(_fee);\n        // _balances[_to] = _balances[_to].add(_value);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Transfer(from, _to, _value);\n        // Transfer(from, msg.sender, _fee);\n        emit TransferPreSigned(from, _to, msg.sender, _value, _fee);\n        return true;\n    }\n\n    /**\n     * @notice Submit a presigned approval\n     * @param _signature bytes The signature, issued by the owner.\n     * @param _spender address The address which will spend the funds.\n     * @param _value uint256 The amount of tokens to allow.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function approvePreSigned(\n        bytes _signature,\n        address _spender,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        require(_spender != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = approvePreSignedHashing(address(this), _spender, _value, _fee, _nonce);\n        address from = recover(hashedTx, _signature);\n        require(from != address(0));\n        _approve(from, _spender, _value);\n        // _allowed[from][_spender] = _value;\n        _transfer(from, msg.sender, _fee);\n        // _balances[from] = _balances[from].sub(_fee);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Approval(from, _spender, _value);\n        // Transfer(from, msg.sender, _fee);\n        emit ApprovalPreSigned(from, _spender, msg.sender, _value, _fee);\n        return true;\n    }\n\n    /**\n     * @notice Increase the amount of tokens that an owner allowed to a spender.\n     * @param _signature bytes The signature, issued by the owner.\n     * @param _spender address The address which will spend the funds.\n     * @param _addedValue uint256 The amount of tokens to increase the allowance by.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function increaseApprovalPreSigned(\n        bytes _signature,\n        address _spender,\n        uint256 _addedValue,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        require(_spender != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = increaseApprovalPreSignedHashing(address(this), _spender, _addedValue, _fee, _nonce);\n        address from = recover(hashedTx, _signature);\n        require(from != address(0));\n        _approve(from, _spender, allowance(from, _spender).add(_addedValue));\n        // _allowed[from][_spender] = _allowed[from][_spender].add(_addedValue);\n        _transfer(from, msg.sender, _fee);\n        // _balances[from] = _balances[from].sub(_fee);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Approval(from, _spender, _allowed[from][_spender]);\n        // Transfer(from, msg.sender, _fee);\n        emit ApprovalPreSigned(from, _spender, msg.sender, allowance(from, _spender), _fee);\n        return true;\n    }\n\n    /**\n     * @notice Decrease the amount of tokens that an owner allowed to a spender.\n     * @param _signature bytes The signature, issued by the owner\n     * @param _spender address The address which will spend the funds.\n     * @param _subtractedValue uint256 The amount of tokens to decrease the allowance by.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function decreaseApprovalPreSigned(\n        bytes _signature,\n        address _spender,\n        uint256 _subtractedValue,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        require(_spender != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = decreaseApprovalPreSignedHashing(address(this), _spender, _subtractedValue, _fee, _nonce);\n        address from = recover(hashedTx, _signature);\n        require(from != address(0));\n\n        uint oldValue = allowance(from, _spender);\n        if (_subtractedValue > oldValue) {\n            _approve(from, _spender, 0);\n            // _allowed[from][_spender] = 0;\n        } else {\n            _approve(from, _spender, allowance(from,_spender).sub(_subtractedValue));\n            // _allowed[from][_spender] = oldValue.sub(_subtractedValue);\n        }\n        _transfer(from, msg.sender, _fee);\n        // _balances[from] = _balances[from].sub(_fee);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Approval(from, _spender, _subtractedValue);\n        // Transfer(from, msg.sender, _fee);\n        emit ApprovalPreSigned(from, _spender, msg.sender, allowance(from, _spender), _fee);\n        return true;\n    }\n\n    /**\n     * @notice Transfer tokens from one address to another\n     * @param _signature bytes The signature, issued by the spender.\n     * @param _from address The address which you want to send tokens from.\n     * @param _to address The address which you want to transfer to.\n     * @param _value uint256 The amount of tokens to be transferred.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the spender.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function transferFromPreSigned(\n        bytes _signature,\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        require(_to != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = transferFromPreSignedHashing(address(this), _from, _to, _value, _fee, _nonce);\n\n        address spender = recover(hashedTx, _signature);\n        require(spender != address(0));\n\n        _transfer(_from, _to, _value);\n        // _balances[_from] = _balances[_from].sub(_value);\n        // _balances[_to] = _balances[_to].add(_value);\n        _approve(_from, spender, allowance(_from, spender).sub(_value));\n        // _allowed[_from][spender] = _allowed[_from][spender].sub(_value);\n        _transfer(spender, msg.sender, _fee);\n        // _balances[spender] = _balances[spender].sub(_fee);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Transfer(_from, _to, _value);\n        // Transfer(spender, msg.sender, _fee);\n        return true;\n    }\n\n\n    /**\n     * @notice Hash (keccak256) of the payload used by transferPreSigned\n     * @param _token address The address of the token.\n     * @param _to address The address which you want to transfer to.\n     * @param _value uint256 The amount of tokens to be transferred.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function transferPreSignedHashing(\n        address _token,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"48664c16\": transferPreSignedHashing(address,address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0x48664c16), _token, _to, _value, _fee, _nonce));\n    }\n\n    /**\n     * @notice Hash (keccak256) of the payload used by approvePreSigned\n     * @param _token address The address of the token\n     * @param _spender address The address which will spend the funds.\n     * @param _value uint256 The amount of tokens to allow.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function approvePreSignedHashing(\n        address _token,\n        address _spender,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"f7ac9c2e\": approvePreSignedHashing(address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0xf7ac9c2e), _token, _spender, _value, _fee, _nonce));\n    }\n\n    /**\n     * @notice Hash (keccak256) of the payload used by increaseApprovalPreSigned\n     * @param _token address The address of the token\n     * @param _spender address The address which will spend the funds.\n     * @param _addedValue uint256 The amount of tokens to increase the allowance by.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function increaseApprovalPreSignedHashing(\n        address _token,\n        address _spender,\n        uint256 _addedValue,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"a45f71ff\": increaseApprovalPreSignedHashing(address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0xa45f71ff), _token, _spender, _addedValue, _fee, _nonce));\n    }\n\n     /**\n      * @notice Hash (keccak256) of the payload used by decreaseApprovalPreSigned\n      * @param _token address The address of the token\n      * @param _spender address The address which will spend the funds.\n      * @param _subtractedValue uint256 The amount of tokens to decrease the allowance by.\n      * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n      * @param _nonce uint256 Presigned transaction number.\n      */\n    function decreaseApprovalPreSignedHashing(\n        address _token,\n        address _spender,\n        uint256 _subtractedValue,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"59388d78\": decreaseApprovalPreSignedHashing(address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0x59388d78), _token, _spender, _subtractedValue, _fee, _nonce));\n    }\n\n    /**\n     * @notice Hash (keccak256) of the payload used by transferFromPreSigned\n     * @param _token address The address of the token\n     * @param _from address The address which you want to send tokens from.\n     * @param _to address The address which you want to transfer to.\n     * @param _value uint256 The amount of tokens to be transferred.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the spender.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function transferFromPreSignedHashing(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"b7656dc5\": transferFromPreSignedHashing(address,address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0xb7656dc5), _token, _from, _to, _value, _fee, _nonce));\n    }\n\n    /**\n     * @notice Recover signer address from a message by using his signature\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n     * @param sig bytes signature, the signature is generated using web3.eth.sign()\n     */\n    function recover(bytes32 hash, bytes sig) public pure returns (address) {\n      bytes32 r;\n      bytes32 s;\n      uint8 v;\n\n      //Check the signature length\n      if (sig.length != 65) {\n        return (address(0));\n      }\n\n      // Divide the signature in r, s and v variables\n      assembly {\n        r := mload(add(sig, 32))\n        s := mload(add(sig, 64))\n        v := byte(0, mload(add(sig, 96)))\n      }\n\n    //   // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n    //    if (v < 27) {\n    //         v += 27;\n    //    }\n\n      // If the version is correct return the signer address\n      if (v != 27 && v != 28) {\n        return (address(0));\n      } else {\n        return ecrecover(hash, v, r, s);\n      }\n    }\n\n}"
    },
    {
      "filename": "contracts/token/ERC865Token.sol",
      "content": "pragma solidity ^0.4.24;\n\n// import \"zeppelin-solidity/contracts/token/ERC20/StandardToken.sol\";\n// import \"openzeppelin-eth/contracts/token/ERC20/ERC20.sol\";\nimport \"./ERC865.sol\";\n\n/**\n * @title ERC865Token Token\n *\n * ERC865Token allows users paying transfers in tokens instead of gas\n * https://github.com/ethereum/EIPs/issues/865\n *\n */\n\ncontract ERC865Token is ERC865 {\n\n    /* Nonces of transfers performed */\n    mapping(bytes => bool) signatures;\n\n    event TransferPreSigned(address indexed from, address indexed to, address indexed delegate, uint256 amount, uint256 fee);\n    event ApprovalPreSigned(address indexed from, address indexed to, address indexed delegate, uint256 amount, uint256 fee);\n    /**\n     * @notice Submit a presigned transfer\n     * @param _signature bytes The signature, issued by the owner.\n     * @param _to address The address which you want to transfer to.\n     * @param _value uint256 The amount of tokens to be transferred.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function transferPreSigned(\n        bytes _signature,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {        \n        require(_to != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = transferPreSignedHashing(address(this), _to, _value, _fee, _nonce);\n\n        address from = recover(hashedTx, _signature);     \n        require(from != address(0));\n        _transfer(from, _to, _value);\n        _transfer(from, msg.sender, _fee);\n        // _balances[from] = _balances[from].sub(_value).sub(_fee);\n        // _balances[_to] = _balances[_to].add(_value);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Transfer(from, _to, _value);\n        // Transfer(from, msg.sender, _fee);\n        emit TransferPreSigned(from, _to, msg.sender, _value, _fee);\n        return true;\n    }\n\n    /**\n     * @notice Submit a presigned approval\n     * @param _signature bytes The signature, issued by the owner.\n     * @param _spender address The address which will spend the funds.\n     * @param _value uint256 The amount of tokens to allow.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function approvePreSigned(\n        bytes _signature,\n        address _spender,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        require(_spender != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = approvePreSignedHashing(address(this), _spender, _value, _fee, _nonce);\n        address from = recover(hashedTx, _signature);\n        require(from != address(0));\n        _approve(from, _spender, _value);\n        // _allowed[from][_spender] = _value;\n        _transfer(from, msg.sender, _fee);\n        // _balances[from] = _balances[from].sub(_fee);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Approval(from, _spender, _value);\n        // Transfer(from, msg.sender, _fee);\n        emit ApprovalPreSigned(from, _spender, msg.sender, _value, _fee);\n        return true;\n    }\n\n    /**\n     * @notice Increase the amount of tokens that an owner allowed to a spender.\n     * @param _signature bytes The signature, issued by the owner.\n     * @param _spender address The address which will spend the funds.\n     * @param _addedValue uint256 The amount of tokens to increase the allowance by.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function increaseApprovalPreSigned(\n        bytes _signature,\n        address _spender,\n        uint256 _addedValue,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        require(_spender != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = increaseApprovalPreSignedHashing(address(this), _spender, _addedValue, _fee, _nonce);\n        address from = recover(hashedTx, _signature);\n        require(from != address(0));\n        _approve(from, _spender, allowance(from, _spender).add(_addedValue));\n        // _allowed[from][_spender] = _allowed[from][_spender].add(_addedValue);\n        _transfer(from, msg.sender, _fee);\n        // _balances[from] = _balances[from].sub(_fee);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Approval(from, _spender, _allowed[from][_spender]);\n        // Transfer(from, msg.sender, _fee);\n        emit ApprovalPreSigned(from, _spender, msg.sender, allowance(from, _spender), _fee);\n        return true;\n    }\n\n    /**\n     * @notice Decrease the amount of tokens that an owner allowed to a spender.\n     * @param _signature bytes The signature, issued by the owner\n     * @param _spender address The address which will spend the funds.\n     * @param _subtractedValue uint256 The amount of tokens to decrease the allowance by.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function decreaseApprovalPreSigned(\n        bytes _signature,\n        address _spender,\n        uint256 _subtractedValue,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        require(_spender != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = decreaseApprovalPreSignedHashing(address(this), _spender, _subtractedValue, _fee, _nonce);\n        address from = recover(hashedTx, _signature);\n        require(from != address(0));\n\n        uint oldValue = allowance(from, _spender);\n        if (_subtractedValue > oldValue) {\n            _approve(from, _spender, 0);\n            // _allowed[from][_spender] = 0;\n        } else {\n            _approve(from, _spender, allowance(from,_spender).sub(_subtractedValue));\n            // _allowed[from][_spender] = oldValue.sub(_subtractedValue);\n        }\n        _transfer(from, msg.sender, _fee);\n        // _balances[from] = _balances[from].sub(_fee);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Approval(from, _spender, _subtractedValue);\n        // Transfer(from, msg.sender, _fee);\n        emit ApprovalPreSigned(from, _spender, msg.sender, allowance(from, _spender), _fee);\n        return true;\n    }\n\n    /**\n     * @notice Transfer tokens from one address to another\n     * @param _signature bytes The signature, issued by the spender.\n     * @param _from address The address which you want to send tokens from.\n     * @param _to address The address which you want to transfer to.\n     * @param _value uint256 The amount of tokens to be transferred.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the spender.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function transferFromPreSigned(\n        bytes _signature,\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        require(_to != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = transferFromPreSignedHashing(address(this), _from, _to, _value, _fee, _nonce);\n\n        address spender = recover(hashedTx, _signature);\n        require(spender != address(0));\n\n        _transfer(_from, _to, _value);\n        // _balances[_from] = _balances[_from].sub(_value);\n        // _balances[_to] = _balances[_to].add(_value);\n        _approve(_from, spender, allowance(_from, spender).sub(_value));\n        // _allowed[_from][spender] = _allowed[_from][spender].sub(_value);\n        _transfer(spender, msg.sender, _fee);\n        // _balances[spender] = _balances[spender].sub(_fee);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Transfer(_from, _to, _value);\n        // Transfer(spender, msg.sender, _fee);\n        return true;\n    }\n\n\n    /**\n     * @notice Hash (keccak256) of the payload used by transferPreSigned\n     * @param _token address The address of the token.\n     * @param _to address The address which you want to transfer to.\n     * @param _value uint256 The amount of tokens to be transferred.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function transferPreSignedHashing(\n        address _token,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"48664c16\": transferPreSignedHashing(address,address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0x48664c16), _token, _to, _value, _fee, _nonce));\n    }\n\n    /**\n     * @notice Hash (keccak256) of the payload used by approvePreSigned\n     * @param _token address The address of the token\n     * @param _spender address The address which will spend the funds.\n     * @param _value uint256 The amount of tokens to allow.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function approvePreSignedHashing(\n        address _token,\n        address _spender,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"f7ac9c2e\": approvePreSignedHashing(address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0xf7ac9c2e), _token, _spender, _value, _fee, _nonce));\n    }\n\n    /**\n     * @notice Hash (keccak256) of the payload used by increaseApprovalPreSigned\n     * @param _token address The address of the token\n     * @param _spender address The address which will spend the funds.\n     * @param _addedValue uint256 The amount of tokens to increase the allowance by.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function increaseApprovalPreSignedHashing(\n        address _token,\n        address _spender,\n        uint256 _addedValue,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"a45f71ff\": increaseApprovalPreSignedHashing(address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0xa45f71ff), _token, _spender, _addedValue, _fee, _nonce));\n    }\n\n     /**\n      * @notice Hash (keccak256) of the payload used by decreaseApprovalPreSigned\n      * @param _token address The address of the token\n      * @param _spender address The address which will spend the funds.\n      * @param _subtractedValue uint256 The amount of tokens to decrease the allowance by.\n      * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n      * @param _nonce uint256 Presigned transaction number.\n      */\n    function decreaseApprovalPreSignedHashing(\n        address _token,\n        address _spender,\n        uint256 _subtractedValue,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"59388d78\": decreaseApprovalPreSignedHashing(address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0x59388d78), _token, _spender, _subtractedValue, _fee, _nonce));\n    }\n\n    /**\n     * @notice Hash (keccak256) of the payload used by transferFromPreSigned\n     * @param _token address The address of the token\n     * @param _from address The address which you want to send tokens from.\n     * @param _to address The address which you want to transfer to.\n     * @param _value uint256 The amount of tokens to be transferred.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the spender.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function transferFromPreSignedHashing(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"b7656dc5\": transferFromPreSignedHashing(address,address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0xb7656dc5), _token, _from, _to, _value, _fee, _nonce));\n    }\n\n    /**\n     * @notice Recover signer address from a message by using his signature\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n     * @param sig bytes signature, the signature is generated using web3.eth.sign()\n     */\n    function recover(bytes32 hash, bytes sig) public pure returns (address) {\n      bytes32 r;\n      bytes32 s;\n      uint8 v;\n\n      //Check the signature length\n      if (sig.length != 65) {\n        return (address(0));\n      }\n\n      // Divide the signature in r, s and v variables\n      assembly {\n        r := mload(add(sig, 32))\n        s := mload(add(sig, 64))\n        v := byte(0, mload(add(sig, 96)))\n      }\n\n    //   // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n    //    if (v < 27) {\n    //         v += 27;\n    //    }\n\n      // If the version is correct return the signer address\n      if (v != 27 && v != 28) {\n        return (address(0));\n      } else {\n        return ecrecover(hash, v, r, s);\n      }\n    }\n\n}"
    },
    {
      "filename": "contracts/token/ERC865Token.sol",
      "content": "pragma solidity ^0.4.24;\n\n// import \"zeppelin-solidity/contracts/token/ERC20/StandardToken.sol\";\n// import \"openzeppelin-eth/contracts/token/ERC20/ERC20.sol\";\nimport \"./ERC865.sol\";\n\n/**\n * @title ERC865Token Token\n *\n * ERC865Token allows users paying transfers in tokens instead of gas\n * https://github.com/ethereum/EIPs/issues/865\n *\n */\n\ncontract ERC865Token is ERC865 {\n\n    /* Nonces of transfers performed */\n    mapping(bytes => bool) signatures;\n\n    event TransferPreSigned(address indexed from, address indexed to, address indexed delegate, uint256 amount, uint256 fee);\n    event ApprovalPreSigned(address indexed from, address indexed to, address indexed delegate, uint256 amount, uint256 fee);\n    /**\n     * @notice Submit a presigned transfer\n     * @param _signature bytes The signature, issued by the owner.\n     * @param _to address The address which you want to transfer to.\n     * @param _value uint256 The amount of tokens to be transferred.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function transferPreSigned(\n        bytes _signature,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {        \n        require(_to != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = transferPreSignedHashing(address(this), _to, _value, _fee, _nonce);\n\n        address from = recover(hashedTx, _signature);     \n        require(from != address(0));\n        _transfer(from, _to, _value);\n        _transfer(from, msg.sender, _fee);\n        // _balances[from] = _balances[from].sub(_value).sub(_fee);\n        // _balances[_to] = _balances[_to].add(_value);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Transfer(from, _to, _value);\n        // Transfer(from, msg.sender, _fee);\n        emit TransferPreSigned(from, _to, msg.sender, _value, _fee);\n        return true;\n    }\n\n    /**\n     * @notice Submit a presigned approval\n     * @param _signature bytes The signature, issued by the owner.\n     * @param _spender address The address which will spend the funds.\n     * @param _value uint256 The amount of tokens to allow.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function approvePreSigned(\n        bytes _signature,\n        address _spender,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        require(_spender != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = approvePreSignedHashing(address(this), _spender, _value, _fee, _nonce);\n        address from = recover(hashedTx, _signature);\n        require(from != address(0));\n        _approve(from, _spender, _value);\n        // _allowed[from][_spender] = _value;\n        _transfer(from, msg.sender, _fee);\n        // _balances[from] = _balances[from].sub(_fee);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Approval(from, _spender, _value);\n        // Transfer(from, msg.sender, _fee);\n        emit ApprovalPreSigned(from, _spender, msg.sender, _value, _fee);\n        return true;\n    }\n\n    /**\n     * @notice Increase the amount of tokens that an owner allowed to a spender.\n     * @param _signature bytes The signature, issued by the owner.\n     * @param _spender address The address which will spend the funds.\n     * @param _addedValue uint256 The amount of tokens to increase the allowance by.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function increaseApprovalPreSigned(\n        bytes _signature,\n        address _spender,\n        uint256 _addedValue,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        require(_spender != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = increaseApprovalPreSignedHashing(address(this), _spender, _addedValue, _fee, _nonce);\n        address from = recover(hashedTx, _signature);\n        require(from != address(0));\n        _approve(from, _spender, allowance(from, _spender).add(_addedValue));\n        // _allowed[from][_spender] = _allowed[from][_spender].add(_addedValue);\n        _transfer(from, msg.sender, _fee);"
    }
  ]
}