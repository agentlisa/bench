{
  "Title": "M-5: Wrong Inflator used in calculating HTP to determine accrualIndex in accrueInterest",
  "Content": "# Issue M-5: Wrong Inflator used in calculating HTP to determine accrualIndex in accrueInterest \n\nSource: https://github.com/sherlock-audit/2023-04-ajna-judging/issues/111 \n\n## Found by \nChinmay\n## Summary\nWhen accruing Interest, the interest is added according to the deposits in all buckets upto the lower of LUP and HTP prices' buckets. But HTP is wrongly calculated in the ```accrueInterest``` function.\n\n## Vulnerability Detail\nAll major functions in ```Pool.sol``` use ```_accrueInterest``` which makes a call to ```PoolCommons.accrueInterest``` to accrue the interest for all deposits above the minimum of LUP and HTP prices, which means upto the lower of the ```LupIndex``` and ```HTPIndex``` because indexes move in the opposite direction of prices. Here in ```accrueInterest``` function, the ```accrualIndex``` is calculated as the higher of LUPIndex and HTPIndex to make sure interest is calculated for all deserving deposits above ```min(HTP price, LUP price)``` ie. ```max(LUP index, HTP index)```.\n\nBut the ```accrualIndex``` has been implemented incorrectly. The HTP is calculated using the ```newInflator``` which incorporates the newly accrued interest into the HTP calculation, whereas the LUP is calculated with old values. The ```accrualIndex``` is set to ```max(LUP index, HTP index)```. then.\n\nAssume that the LUP price > HTP price. So, LUP index < HTP index. Hence, for the ```interestEarningDeposit``` all the deposits above the HTP index will be considered. But the value of HTP index is wrong now because it is calculated using new Inflator which means that the new Interest has been added in calculation of HTP already and thus the derived HTP index will be lower in value(which means upper in the bucket system). Assume that still after this LUP index < HTP index\n\nNow since the old LUP index and new HTP index is used in the ```max(LUP index, HTP index)``` function, and LUP index is still < HTP index (ie. LUP price > HTP price) thus the deposits that were between the old HTP index and the new HTP index have been left out of the ```interestEarningDeposit``` calculation. \n\nI talked to the developers about this discrepancy between new HTP and old LUP being used, and they said ```\"I can see the argument in favor of using the prior inflator here to be totally precise.\"```\n\nAlso, one of them said, ```\"It should be computed using the debt prior to the interest accrual itself, as it's determining the the minimum amount of deposit onto which that interest would be applied\"```\n\nThis means that the htp index has been underestimated because it has been made lower(ie. upper in the bucket system) and thus the deposits that lie between the old HTP index and new HTP index have not been considered for calculating ```interestEarningDeposit``` when they should have been considered because before the interest accrual itself, those deposits were under the deserving ```max(LUP index, HTP index)``` bracket. \n\nThis means ```interestEarningDeposit``` has been underestimated and later calculations at PoolCommons.sol#L253 for lender Factor have become wrong.   \n\n## Impact\nThis is a logic mistake and leads to wrong values for the lenderFactor. \n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-ajna/blob/e2439305cc093204a0d927aac19d898f4a0edb3d/ajna-core/src/libraries/external/PoolCommons.sol#L232\n\n## Tool used\n\nManual Review\n\n## Recommendation\nCalculate htp using the old inflator to correctly include all deposits that were deserving to get into ```interestEarningDeposit``` calculation.\n\n\n\n\n## Discussion\n\n**0xffff11**\n\nDeleted duplication of #88  due to explaining a slightly different issue\n\n**dmitriia**\n\nFix in PR#916 looks ok, it replaces `newInflator_` with the current `poolState_.inflator` in accrueInterest()'s `htp` calculation.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/75",
  "Code": [
    {
      "filename": "ajna-core/src/libraries/external/PoolCommons.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport { PRBMathSD59x18 } from \"@prb-math/contracts/PRBMathSD59x18.sol\";\nimport { PRBMathUD60x18 } from \"@prb-math/contracts/PRBMathUD60x18.sol\";\n\nimport { InterestState, EmaState, PoolState, DepositsState } from '../../interfaces/pool/commons/IPoolState.sol';\n\nimport { _dwatp, _indexOf, MAX_FENWICK_INDEX, MIN_PRICE, MAX_PRICE } from '../helpers/PoolHelper.sol';\n\nimport { Deposits } from '../internal/Deposits.sol';\nimport { Buckets }  from '../internal/Buckets.sol';\nimport { Loans }    from '../internal/Loans.sol';\nimport { Maths }    from '../internal/Maths.sol';\n\n/**\n    @title  PoolCommons library\n    @notice External library containing logic for common pool functionality:\n            - interest rate accrual and interest rate params update\n            - pool utilization\n */\nlibrary PoolCommons {\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    uint256 internal constant CUBIC_ROOT_1000000 = 100 * 1e18;\n    uint256 internal constant ONE_THIRD          = 0.333333333333333334 * 1e18;\n\n    uint256 internal constant INCREASE_COEFFICIENT = 1.1 * 1e18;\n    uint256 internal constant DECREASE_COEFFICIENT = 0.9 * 1e18;\n    int256  internal constant PERCENT_102          = 1.02 * 1e18;\n    int256  internal constant NEG_H_MAU_HOURS      = -0.057762265046662105 * 1e18; // -ln(2)/12\n    int256  internal constant NEG_H_TU_HOURS       = -0.008251752149523158 * 1e18; // -ln(2)/84\n\n    /**************/\n    /*** Events ***/\n    /**************/\n\n    // See `IPoolEvents` for descriptions\n    event ResetInterestRate(uint256 oldRate, uint256 newRate);\n    event UpdateInterestRate(uint256 oldRate, uint256 newRate);\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    /// @dev Struct used for `updateInterestState` function local vars.\n    struct UpdateInterestLocalVars {\n        uint256 debtEma;\n        uint256 depositEma;\n        uint256 debtColEma;\n        uint256 lupt0DebtEma;\n        uint256 t0Debt2ToCollateral;\n        uint256 newMeaningfulDeposit;\n        uint256 newDebt;\n        uint256 newDebtCol;\n        uint256 newLupt0Debt;\n        uint256 lastEmaUpdate;\n        int256 elapsed;\n        int256 weightMau;\n        int256 weightTu;\n        uint256 newInterestRate;\n        uint256 nonAuctionedT0Debt;\n    }\n\n    /**************************/\n    /*** External Functions ***/\n    /**************************/\n\n    /**\n     *  @notice Calculates EMAs, caches values required for calculating interest rate, and saves new values in storage.\n     *  @notice Calculates new pool interest rate (Never called more than once every 12 hours) and saves new values in storage.\n     *  @dev    === Write state ===\n     *  @dev    `EMA`s state\n     *  @dev    interest rate accumulator and `interestRateUpdate` state\n     *  @dev    === Emit events ===\n     *  @dev    - `UpdateInterestRate` / `ResetInterestRate`\n     */\n    function updateInterestState(\n        InterestState storage interestParams_,\n        EmaState      storage emaParams_,\n        DepositsState storage deposits_,\n        PoolState memory poolState_,\n        uint256 lup_\n    ) external {\n        UpdateInterestLocalVars memory vars;\n        // load existing EMA values\n        vars.debtEma       = emaParams_.debtEma;\n        vars.depositEma    = emaParams_.depositEma;\n        vars.debtColEma    = emaParams_.debtColEma;\n        vars.lupt0DebtEma  = emaParams_.lupt0DebtEma;\n        vars.lastEmaUpdate = emaParams_.emaUpdate;\n\n        vars.t0Debt2ToCollateral = interestParams_.t0Debt2ToCollateral;\n\n        // calculate new interest params\n        vars.nonAuctionedT0Debt = poolState_.t0Debt - poolState_.t0DebtInAuction;\n        vars.newDebt = Maths.wmul(vars.nonAuctionedT0Debt, poolState_.inflator);\n        // new meaningful deposit cannot be less than pool's debt\n        vars.newMeaningfulDeposit = Maths.max(\n            _meaningfulDeposit(\n                deposits_,\n                poolState_.t0DebtInAuction,\n                vars.nonAuctionedT0Debt,\n                poolState_.inflator,\n                vars.t0Debt2ToCollateral\n            ),\n            vars.newDebt\n        );\n        vars.newDebtCol   = Maths.wmul(poolState_.inflator, vars.t0Debt2ToCollateral);\n        vars.newLupt0Debt = Maths.wmul(lup_, vars.nonAuctionedT0Debt);\n\n        // update EMAs only once per block\n        if (vars.lastEmaUpdate != block.timestamp) {\n\n            // first time EMAs are updated, initialize EMAs\n            if (vars.lastEmaUpdate == 0) {\n                vars.debtEma      = vars.newDebt;\n                vars.depositEma   = vars.newMeaningfulDeposit;\n                vars.debtColEma   = vars.newDebtCol;\n                vars.lupt0DebtEma = vars.newLupt0Debt;\n            } else {\n                vars.elapsed   = int256(Maths.wdiv(block.timestamp - vars.lastEmaUpdate, 1 hours));\n                vars.weightMau = PRBMathSD59x18.exp(PRBMathSD59x18.mul(NEG_H_MAU_HOURS, vars.elapsed));\n                vars.weightTu  = PRBMathSD59x18.exp(PRBMathSD59x18.mul(NEG_H_TU_HOURS,  vars.elapsed));\n\n                // calculate the t0 debt EMA, used for MAU\n                vars.debtEma = uint256(\n                    PRBMathSD59x18.mul(vars.weightMau, int256(vars.debtEma)) +\n                    PRBMathSD59x18.mul(1e18 - vars.weightMau, int256(interestParams_.debt))\n                );\n\n                // update the meaningful deposit EMA, used for MAU\n                vars.depositEma = uint256(\n                    PRBMathSD59x18.mul(vars.weightMau, int256(vars.depositEma)) +\n                    PRBMathSD59x18.mul(1e18 - vars.weightMau, int256(interestParams_.meaningfulDeposit))\n                );\n\n                // calculate the debt squared to collateral EMA, used for TU\n                vars.debtColEma = uint256(\n                    PRBMathSD59x18.mul(vars.weightTu, int256(vars.debtColEma)) +\n                    PRBMathSD59x18.mul(1e18 - vars.weightTu, int256(interestParams_.debtCol))\n                );\n\n                // calculate the EMA of LUP * t0 debt\n                vars.lupt0DebtEma = uint256(\n                    PRBMathSD59x18.mul(vars.weightTu, int256(vars.lupt0DebtEma)) +\n                    PRBMathSD59x18.mul(1e18 - vars.weightTu, int256(interestParams_.lupt0Debt))\n                );\n            }\n\n            // save EMAs in storage\n            emaParams_.debtEma      = vars.debtEma;\n            emaParams_.depositEma   = vars.depositEma;\n            emaParams_.debtColEma   = vars.debtColEma;\n            emaParams_.lupt0DebtEma = vars.lupt0DebtEma;\n\n            // save last EMA update time\n            emaParams_.emaUpdate = block.timestamp;\n        }\n\n        // reset interest rate if pool rate > 10% and debtEma < 5% of depositEma\n        if (\n            poolState_.rate > 0.1 * 1e18\n            &&\n            vars.debtEma < Maths.wmul(vars.depositEma, 0.05 * 1e18)\n        ) {\n            interestParams_.interestRate       = uint208(0.1 * 1e18);\n            interestParams_.interestRateUpdate = uint48(block.timestamp);\n\n            emit ResetInterestRate(\n                poolState_.rate,\n                0.1 * 1e18\n            );\n        }\n        // otherwise calculate and update interest rate if it has been more than 12 hours since the last update\n        else if (block.timestamp - interestParams_.interestRateUpdate > 12 hours) {\n            vars.newInterestRate = _calculateInterestRate(\n                poolState_,\n                vars.debtEma,\n                vars.depositEma,\n                vars.debtColEma,\n                vars.lupt0DebtEma\n            );\n\n            if (poolState_.rate != vars.newInterestRate) {\n                interestParams_.interestRate       = uint208(vars.newInterestRate);\n                interestParams_.interestRateUpdate = uint48(block.timestamp);\n\n                emit UpdateInterestRate(\n                    poolState_.rate,\n                    vars.newInterestRate\n                );\n            }\n        }\n\n        // save new interest rate params to storage\n        interestParams_.debt              = vars.newDebt;\n        interestParams_.meaningfulDeposit = vars.newMeaningfulDeposit;\n        interestParams_.debtCol           = vars.newDebtCol;\n        interestParams_.lupt0Debt         = vars.newLupt0Debt;\n    }\n\n    /**\n     *  @notice Calculates new pool interest and scale the fenwick tree to update amount of debt owed to lenders (saved in storage).\n     *  @dev    === Write state ===\n     *  @dev    - `Deposits.mult` (scale `Fenwick` tree with new interest accrued):\n     *  @dev      update `scaling` array state\n     *  @param  emaParams_      Struct for pool `EMA`s state.\n     *  @param  deposits_       Struct for pool deposits state.\n     *  @param  poolState_      Current state of the pool.\n     *  @param  thresholdPrice_ Current Pool Threshold Price.\n     *  @param  elapsed_        Time elapsed since last inflator update.\n     *  @return newInflator_    The new value of pool inflator.\n     *  @return newInterest_    The new interest accrued.\n     */\n    function accrueInterest(\n        EmaState      storage emaParams_,\n        DepositsState storage deposits_,\n        PoolState calldata poolState_,\n        uint256 thresholdPrice_,\n        uint256 elapsed_\n    ) external returns (uint256 newInflator_, uint256 newInterest_) {\n        // Scale the borrower inflator to update amount of interest owed by borrowers\n        uint256 pendingFactor = PRBMathUD60x18.exp((poolState_.rate * elapsed_) / 365 days);\n\n        // calculate the highest threshold price\n        newInflator_ = Maths.wmul(poolState_.inflator, pendingFactor);\n        uint256 htp = Maths.wmul(thresholdPrice_, newInflator_);\n\n        uint256 accrualIndex;\n        if (htp > MAX_PRICE)      accrualIndex = 1;                 // if HTP is over the highest price bucket then no buckets earn interest\n        else if (htp < MIN_PRICE) accrualIndex = MAX_FENWICK_INDEX; // if HTP is under the lowest price bucket then all buckets earn interest\n        else                      accrualIndex = _indexOf(htp);     // else HTP bucket earn interest\n\n        uint256 lupIndex = Deposits.findIndexOfSum(deposits_, poolState_.debt);\n        // accrual price is less of lup and htp, and prices decrease as index increases\n        if (lupIndex > accrualIndex) accrualIndex = lupIndex;\n\n        uint256 interestEarningDeposit = Deposits.prefixSum(deposits_, accrualIndex);\n\n        if (interestEarningDeposit != 0) {\n            newInterest_ = Maths.wmul(\n                _lenderInterestMargin(_utilization(emaParams_.debtEma, emaParams_.depositEma)),\n                Maths.wmul(pendingFactor - Maths.WAD, poolState_.debt)\n            );\n\n            // lender factor computation, capped at 10x the interest factor for borrowers\n            uint256 lenderFactor = Maths.min(\n                Maths.floorWdiv(newInterest_, interestEarningDeposit),\n                Maths.wmul(pendingFactor - Maths.WAD, Maths.wad(10))\n            ) + Maths.WAD;\n\n            // Scale the fenwick tree to update amount of debt owed to lenders\n            Deposits.mult(deposits_, accrualIndex, lenderFactor);\n        }\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    /**\n     *  @notice Calculates new pool interest rate.\n     */\n    function _calculateInterestRate(\n        PoolState memory poolState_,\n        uint256 debtEma_,\n        uint256 depositEma_,\n        uint256 debtColEma_,\n        uint256 lupt0DebtEma_\n    ) internal pure returns (uint256 newInterestRate_)  {\n        // meaningful actual utilization\n        int256 mau;\n        // meaningful actual utilization * 1.02\n        int256 mau102;\n\n        if (poolState_.debt != 0) {\n            // calculate meaningful actual utilization for interest rate update\n            mau    = int256(_utilization(debtEma_, depositEma_));\n            mau102 = mau * PERCENT_102 / 1e18;\n        }\n\n        // calculate target utilization\n        int256 tu = (lupt0DebtEma_ != 0) ? \n            int256(Maths.wdiv(debtColEma_, lupt0DebtEma_)) : int(Maths.WAD);\n\n        newInterestRate_ = poolState_.rate;\n\n        // raise rates if 4*(tu-1.02*mau) < (tu+1.02*mau-1)^2-1\n        if (4 * (tu - mau102) < (((tu + mau102 - 1e18) / 1e9) ** 2) - 1e18) {\n            newInterestRate_ = Maths.wmul(poolState_.rate, INCREASE_COEFFICIENT);\n        // decrease rates if 4*(tu-mau) > 1-(tu+mau-1)^2\n        } else if (4 * (tu - mau) > 1e18 - ((tu + mau - 1e18) ** 2) / 1e18) {\n            newInterestRate_ = Maths.wmul(poolState_.rate, DECREASE_COEFFICIENT);\n        }\n\n        // bound rates between 10 bps and 50000%\n        newInterestRate_ = Maths.min(500 * 1e18, Maths.max(0.001 * 1e18, newInterestRate_));\n    }\n\n    /**\n     *  @notice Calculates pool meaningful actual utilization.\n     *  @param  debtEma_     `EMA` of pool debt.\n     *  @param  depositEma_  `EMA` of meaningful pool deposit.\n     *  @return utilization_ Pool meaningful actual utilization value.\n     */\n    function _utilization(\n        uint256 debtEma_,\n        uint256 depositEma_\n    ) internal pure returns (uint256 utilization_) {\n        if (depositEma_ != 0) utilization_ = Maths.wdiv(debtEma_, depositEma_);\n    }\n\n    /**\n     *  @notice Calculates lender interest margin.\n     *  @param  mau_ Meaningful actual utilization.\n     *  @return The lender interest margin value.\n     */\n    function _lenderInterestMargin(\n        uint256 mau_\n    ) internal pure returns (uint256) {\n        // Net Interest Margin = ((1 - MAU1)^(1/3) * 0.15)\n        // Where MAU1 is MAU capped at 100% (min(MAU,1))\n        // Lender Interest Margin = 1 - Net Interest Margin\n\n        // PRBMath library forbids raising a number < 1e18 to a power.  Using the product and quotient rules of \n        // exponents, rewrite the equation with a coefficient s which provides sufficient precision:\n        // Net Interest Margin = ((1 - MAU1) * s)^(1/3) / s^(1/3) * 0.15\n\n        uint256 base = 1_000_000 * 1e18 - Maths.min(mau_, 1e18) * 1_000_000;\n        // If unutilized deposit is infinitessimal, lenders get 100% of interest.\n        if (base < 1e18) {\n            return 1e18;\n        } else {\n            // cubic root of the percentage of meaningful unutilized deposit\n            uint256 crpud = PRBMathUD60x18.pow(base, ONE_THIRD);\n            // finish calculating Net Interest Margin, and then convert to Lender Interest Margin\n            return 1e18 - Maths.wdiv(Maths.wmul(crpud, 0.15 * 1e18), CUBIC_ROOT_1000000);\n        }\n    }\n\n    /**\n     *  @notice Calculates pool's meaningful deposit.\n     *  @param  deposits_            Struct for pool deposits state.\n     *  @param  t0DebtInAuction_     Value of pool's t0 debt currently in auction.\n     *  @param  nonAuctionedT0Debt_  Value of pool's t0 debt that is not in auction.\n     *  @param  inflator_            Pool's current inflator.\n     *  @param  t0Debt2ToCollateral_ `t0Debt2ToCollateral` ratio.\n     *  @return meaningfulDeposit_   Pool's meaningful deposit.\n     */\n    function _meaningfulDeposit(\n        DepositsState storage deposits_,\n        uint256 t0DebtInAuction_,\n        uint256 nonAuctionedT0Debt_,\n        uint256 inflator_,\n        uint256 t0Debt2ToCollateral_\n    ) internal view returns (uint256 meaningfulDeposit_) {\n        uint256 dwatp = _dwatp(nonAuctionedT0Debt_, inflator_, t0Debt2ToCollateral_);\n        if (dwatp == 0) {\n            meaningfulDeposit_ = Deposits.treeSum(deposits_);\n        } else {\n            if      (dwatp >= MAX_PRICE) meaningfulDeposit_ = 0;\n            else if (dwatp >= MIN_PRICE) meaningfulDeposit_ = Deposits.prefixSum(deposits_, _indexOf(dwatp));\n            else                         meaningfulDeposit_ = Deposits.treeSum(deposits_);\n        }\n        meaningfulDeposit_ -= Maths.min(\n            meaningfulDeposit_,\n            Maths.wmul(t0DebtInAuction_, inflator_)\n        );\n    }\n\n    /**********************/\n    /*** View Functions ***/\n    /**********************/\n\n    /**\n     *  @notice Calculates pool interest factor for a given interest rate and time elapsed since last inflator update.\n     *  @param  interestRate_   Current pool interest rate.\n     *  @param  elapsed_        Time elapsed since last inflator update.\n     *  @return The value of pool interest factor.\n     */\n    function pendingInterestFactor(\n        uint256 interestRate_,\n        uint256 elapsed_\n    ) external pure returns (uint256) {\n        return PRBMathUD60x18.exp((interestRate_ * elapsed_) / 365 days);\n    }\n\n    /**\n     *  @notice Calculates pool pending inflator given the current inflator, time of last update and current interest rate.\n     *  @param  inflator_      Current pool inflator.\n     *  @param  inflatorUpdate Timestamp when inflator was updated.\n     *  @param  interestRate_  The interest rate of the pool.\n     *  @return The pending value of pool inflator.\n     */\n    function pendingInflator(\n        uint256 inflator_,\n        uint256 inflatorUpdate,\n        uint256 interestRate_\n    ) external view returns (uint256) {\n        return Maths.wmul(\n            inflator_,\n            PRBMathUD60x18.exp((interestRate_ * (block.timestamp - inflatorUpdate)) / 365 days)\n        );\n    }\n\n    /**\n     *  @notice Calculates lender interest margin for a given meaningful actual utilization.\n     *  @dev Wrapper of the internal function.\n     */\n    function lenderInterestMargin(\n        uint256 mau_\n    ) external pure returns (uint256) {\n        return _lenderInterestMargin(mau_);\n    }\n\n    /**\n     *  @notice Calculates pool meaningful actual utilization.\n     *  @dev Wrapper of the internal function.\n     */\n    function utilization(\n        EmaState storage emaParams_\n    ) external view returns (uint256 utilization_) {\n        return _utilization(emaParams_.debtEma, emaParams_.depositEma);\n    }\n}"
    }
  ]
}