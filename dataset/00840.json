{
  "Title": "M-7: Possible incorrect price for tokens in Balancer stable pool due to amplification parameter update",
  "Content": "# Issue M-7: Possible incorrect price for tokens in Balancer stable pool due to amplification parameter update \n\nSource: https://github.com/sherlock-audit/2023-11-olympus-judging/issues/178 \n\n## Found by \nhash\n## Summary\nIncorrect price calculation of tokens in StablePools if amplification factor is being updated\n\n## Vulnerability Detail\nThe amplification parameter used to calculate the invariant can be in a state of update. In such a case, the current amplification parameter can differ from the amplificaiton parameter at the time of the last invariant calculation.\nThe current implementaiton of `getTokenPriceFromStablePool` doesn't consider this and always uses the amplification factor obtained by calling `getLastInvariant` \n\nhttps://github.com/sherlock-audit/2023-11-olympus/blob/main/bophades/src/modules/PRICE/submodules/feeds/BalancerPoolTokenPrice.sol#L811-L827\n```solidity\n            function getTokenPriceFromStablePool(\n        address lookupToken_,\n        uint8 outputDecimals_,\n        bytes calldata params_\n    ) external view returns (uint256) {\n\n                .....\n\n                try pool.getLastInvariant() returns (uint256, uint256 ampFactor) {\n                   \n                   // @audit the amplification factor as of the last invariant calculation is used\n                    lookupTokensPerDestinationToken = StableMath._calcOutGivenIn(\n                        ampFactor,\n                        balances_,\n                        destinationTokenIndex,\n                        lookupTokenIndex,\n                        1e18,\n                        StableMath._calculateInvariant(ampFactor, balances_) // Sometimes the fetched invariant value does not work, so calculate it\n                    );\n```\n\nhttps://vscode.blockscan.com/ethereum/0x1e19cf2d73a72ef1332c882f20534b6519be0276\nStablePool.sol\n```solidity\n\n        // @audit the amplification parameter can be updated\n        function startAmplificationParameterUpdate(uint256 rawEndValue, uint256 endTime) external authenticate {\n\n        // @audit for calculating the invariant the current amplification factor is obtained by calling _getAmplificationParameter()\n        function _onSwapGivenIn(\n        SwapRequest memory swapRequest,\n        uint256[] memory balances,\n        uint256 indexIn,\n        uint256 indexOut\n    ) internal virtual override whenNotPaused returns (uint256) {\n        (uint256 currentAmp, ) = _getAmplificationParameter();\n        uint256 amountOut = StableMath._calcOutGivenIn(currentAmp, balances, indexIn, indexOut, swapRequest.amount);\n        return amountOut;\n    }\n```\n\n\n## Impact\nIn case the amplification parameter of a pool is being updated by the admin, wrong price will be calculated.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-11-olympus/blob/main/bophades/src/modules/PRICE/submodules/feeds/BalancerPoolTokenPrice.sol#L811-L827\n\n## Tool used\nManual Review\n\n## Recommendation\nUse the latest amplification factor by callling the `getAmplificationParameter` function\n\n\n\n## Discussion\n\n**0xJem**\n\nThis doesn't seem valid - if the amplification factor is changed since the invariant was last calculated, wouldn't the value of the invariant also be invalid?\n\n**nevillehuang**\n\nHi @0xJem here is additional information provided by watson:\n\nThe invariant used for calculating swap amounts in Balancer is always based on the latest amplification factor hence their calculation would be latest. If there are no join actions, the cached amplification factor which is used by Olympus will not reflect the new one and will result in a different invariant and different token price.\n\ni am attaching a poc if required:\nhttps://gist.github.com/10xhash/8e24d0765ee98def8c6409c71a7d2b17\n\n**0xauditsea**\n\nEscalate\n\nThis looks like invalid. Logically thinking, using `getLastInvariant` is more precise because the goal of this price feed is to calculate spot price of the balancer pool. If current amplification factor is used, it doesn't represent current state of the pool.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This looks like invalid. Logically thinking, using `getLastInvariant` is more precise because the goal of this price feed is to calculate spot price of the balancer pool. If current amplification factor is used, it doesn't represent current state of the pool.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Czar102**\n\n@nevillehuang what do you think?\n\n**nevillehuang**\n\n@Czar102 I don't quite understand what @0xauditsea is pointing to. If you want to calculate the latest spot price, shouldn't you use the latest factor as indicated by the PoC by @10xhash? \n\n**Czar102**\n\n@0xauditsea could you explain your reasoning in more detail?\n\n**nevillehuang**\n\n@10xhash does this affect ALL pools intended to be integrated during the time of contest?\n\n**10xhash**\n\nIt has to be clarified what `intended to be integrated pools` at the time of contest are:\n1. If only the list of tokens mentioned in the readme _can be _in a pool__ ( as mentioned in previous replies this is not required per the contest definition since all tokens are not required to interact with contracts ) : There are 0 stable pools including normal, metastable etc. The only possible stable pool of any type that can be used with the above restriction is the dai-sdai metastable pool which has to be deployed in future.\n2. Else it must atleast include normal stable pools and according to balancer's [documentation](https://docs.balancer.fi/reference/authorizer/mainnet.html#last-generated-on-2024-01-10) {search startAmplificationParameterUpdate} and testing done on the dai-usdc-usdt pool, it would be affected\n\n**Czar102**\n\n1. Metastable pools are not supposed to be supported.\n2. This documentation seems to be for Avalanche, while the contracts will be deployed on mainnet. I believe this functionality exists on mainnet too, right?\n\nAside from that, the impact is that the price calculated is the price at the last pool update (trade) instead of the current price?\n\n**10xhash**\n\n2. The link opens up to Mainnet for me, if not you would have the option to select the chain on leftside. Yes.  \n\nThe impact would be that the amplification parameter used in the price calculation will be that of the last join action (addliquidity , removeliquidity) which will be different from the actual one used in the pool calculations. This will result in an incorrect price until some user performs a join operation.  \n\n**Czar102**\n\nAdding/removing liquidity doesn't necessarily happen often. This, together with the amplification parameter change, is a very unlikely situation, nevertheless a possible one.\n\nIt's a borderline Med/Low, but I am inclined to keep this one a valid Medium. I don't understand the point made in the escalation, and @0xauditsea hasn't elaborated when asked for additional information.\n\n**gstoyanovbg**\n\nIn determining the impact of this report, in my opinion, it should be assessed how much the price can change in the described circumstances and whether the change is significant. I conducted a foundry test that shows the change in the price of AURA_BAL at different values of the amplification factor. The test should be added to BalancerPoolTokenPriceStable.t.sol.\n\n```solidity\nfunction test_amp_factor_impact() public {\n        bytes memory params = encodeBalancerPoolParams(mockStablePool);\n        uint256 price;\n\n        mockStablePool.setLastInvariant(INVARIANT, AMP_FACTOR);\n        price = balancerSubmodule.getTokenPriceFromStablePool(\n            AURA_BAL,\n            PRICE_DECIMALS,\n            params\n        );\n        console.log(\"%d, AMP_FACTOR = 50000\", price);\n\n        mockStablePool.setLastInvariant(INVARIANT, AMP_FACTOR + 2000);\n        price = balancerSubmodule.getTokenPriceFromStablePool(\n            AURA_BAL,\n            PRICE_DECIMALS,\n            params\n        );\n        console.log(\"%d, AMP_FACTOR = 50000 + 2000\", price);\n\n        mockStablePool.setLastInvariant(INVARIANT, AMP_FACTOR + 10000);\n        price = balancerSubmodule.getTokenPriceFromStablePool(\n            AURA_BAL,\n            PRICE_DECIMALS,\n            params\n        );\n        console.log(\"%d, AMP_FACTOR = 50000 + 10000\", price);\n\n        mockStablePool.setLastInvariant(INVARIANT, AMP_FACTOR * 2);\n        price = balancerSubmodule.getTokenPriceFromStablePool(\n            AURA_BAL,\n            PRICE_DECIMALS,\n            params\n        );\n        console.log(\"%d, AMP_FACTOR = 50000 * 2\", price);\n\n        mockStablePool.setLastInvariant(INVARIANT, AMP_FACTOR * 4);\n        price = balancerSubmodule.getTokenPriceFromStablePool(\n            AURA_BAL,\n            PRICE_DECIMALS,\n            params\n        );\n        console.log(\"%d, AMP_FACTOR = 50000 * 4\", price);\n\n        mockStablePool.setLastInvariant(INVARIANT, AMP_FACTOR * 10);\n        price = balancerSubmodule.getTokenPriceFromStablePool(\n            AURA_BAL,\n            PRICE_DECIMALS,\n            params\n        );\n        console.log(\"%d, AMP_FACTOR = 50000 * 10\", price);\n\n        mockStablePool.setLastInvariant(INVARIANT, AMP_FACTOR * 100);\n        price = balancerSubmodule.getTokenPriceFromStablePool(\n            AURA_BAL,\n            PRICE_DECIMALS,\n            params\n        );\n        console.log(\"%d, AMP_FACTOR = 50000 * 100\", price);\n    }\n```\n>  16602528871962134544, AMP_FACTOR = 50000\n  16606565178508667081, AMP_FACTOR = 50000 + 2000\n  16620074517406602667, AMP_FACTOR = 50000 + 10000\n  16655599693391809126, AMP_FACTOR = 50000 * 2\n  16682630482761745824, AMP_FACTOR = 50000 * 4\n  16699011129392628938, AMP_FACTOR = 50000 * 10\n  16708898633935285195, AMP_FACTOR = 50000 * 100\n\nFrom the obtained results, it can be seen that the change in price is small. Even if we increase it 100 times to the maximum possible value of 5000 * 10^3, the change in price is around 0.1 (0.63%). For such a large increase of the amplification factor, it would take about 7 days (2x per day). Another question is what is the chance that there will be no join or exit within these 7 days.\n\n@Czar102 I don't know if this is significant enough change in the price for Sherlock, but wanted to share it to be sure it will be taken into consideration.\n\n\n**Czar102**\n\n@gstoyanovbg Thank you for the test, it looks like this should be a low severity issue.\n\n@10xhash Can you provide a scenario where the price would be altered by more than 5%?\n\n**10xhash**\n\nPlace the test inside test/ and run `forge test --mt testHash_AmplificationDiff5`\nIt is asserted that the diff in price is > 5% when the current amplification parameter is divided by 6 with a 4 day period. Dividing by 6 would make the pool close to 8000 (currently 50000). \n \n```solidity\npragma solidity 0.8.15;\n\nimport \"forge-std/Test.sol\";\nimport {IStablePool} from \"src/libraries/Balancer/interfaces/IStablePool.sol\";\nimport {IVault} from \"src/libraries/Balancer/interfaces/IVault.sol\";\nimport {FullMath} from \"src/libraries/FullMath.sol\";\nimport {StableMath} from \"src/libraries/Balancer/math/StableMath.sol\";\nimport {IVault} from \"src/libraries/Balancer/interfaces/IVault.sol\";\nimport {IBasePool} from \"src/libraries/Balancer/interfaces/IBasePool.sol\";\nimport {IWeightedPool} from \"src/libraries/Balancer/interfaces/IWeightedPool.sol\";\nimport {IStablePool} from \"src/libraries/Balancer/interfaces/IStablePool.sol\";\nimport {VaultReentrancyLib} from \"src/libraries/Balancer/contracts/VaultReentrancyLib.sol\";\nimport {LogExpMath} from \"src/libraries/Balancer/math/LogExpMath.sol\";\nimport {FixedPoint} from \"src/libraries/Balancer/math/FixedPoint.sol\";\n\ninterface IStablePoolWithAmp is IStablePool {\n    function getAmplificationParameter()\n        external\n        view\n        returns (uint amp, bool isUpdating, uint precision);\n\n        \n\n        function startAmplificationParameterUpdate(uint256 rawEndValue, uint256 endTime) external;\n}\n\ninterface IERC20 {\n    function approve(address spender,uint amount) external;\n} \n\nenum SwapKind { GIVEN_IN, GIVEN_OUT }\n\n\nstruct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        address assetIn;\n        address assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n        struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n\ninterface VaultWithSwap is IVault{\n    function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    ) external payable returns (uint256);\n}\n\ncontract PriceTest is Test {\n    using FullMath for uint256;\n\n    function testHash_AmplificationDiff5() public {\n        VaultWithSwap balVault = VaultWithSwap(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n        IStablePoolWithAmp pool = IStablePoolWithAmp(0x3dd0843A028C86e0b760b1A76929d1C5Ef93a2dd);\n        \n        (, uint cachedAmpFactor) = pool.getLastInvariant();\n        {\n            (, bool isUpdating, ) = pool.getAmplificationParameter();\n             assert(isUpdating == false);\n        }\n\n        console.log(\"cahced factor\",cachedAmpFactor);\n\n        {\n        address mainnetFeeSetter = 0xf4A80929163C5179Ca042E1B292F5EFBBE3D89e6;\n        \n        vm.startPrank(mainnetFeeSetter);\n        pool.startAmplificationParameterUpdate(cachedAmpFactor / 6 / 1e3, block.timestamp + 4 days);\n\n        vm.warp(block.timestamp + 4 days + 100);\n\n        // perform swaps to update the balances with latest amp factor\n        {\n            (uint amp,bool isUpdating , ) = pool.getAmplificationParameter();\n            assert(isUpdating == false);\n        }\n\n        console.log(\"amp params set\");\n        }\n\n        uint[] memory balances_;\n        uint actualAmpFactor;\n{\nbytes32 poolId = pool.getPoolId();\n        (actualAmpFactor, , ) = pool.getAmplificationParameter();\n\n        (,  balances_, ) = balVault.getPoolTokens(poolId);\n        uint256[] memory scalingFactors = pool.getScalingFactors();\n        {\n            \n            uint256 len = scalingFactors.length;\n            for (uint256 i; i < len; ++i) {\n                balances_[i] = FixedPoint.mulDown(balances_[i], scalingFactors[i]);\n            }\n        }\n}\n        \n\n        // lookup token auraBal and destination token lp token\n        \n        uint oldCachedPrice;\n        uint newAmpFactorPrice;\n        {\n            uint destinationTokenIndex = 0;\n        uint lookupTokenIndex = 1;\n            console.log(\"calculation with previous amp factor\");\n            uint lookupTokensPerDestinationToken;\n            lookupTokensPerDestinationToken = StableMath._calcOutGivenIn(\n                cachedAmpFactor,\n                balances_,\n                destinationTokenIndex,\n                lookupTokenIndex,\n                1e18,\n                StableMath._calculateInvariant(cachedAmpFactor, balances_)\n            );\n\n            // Downscale the amount to token decimals\n        uint256[] memory scalingFactors = pool.getScalingFactors();\n            lookupTokensPerDestinationToken = FixedPoint.divDown(\n                lookupTokensPerDestinationToken,\n                scalingFactors[lookupTokenIndex]\n            );\n\n            uint outputDecimals = 8;\n\n            lookupTokensPerDestinationToken =\n                (lookupTokensPerDestinationToken * 10 ** outputDecimals) /\n                1e18;\n\n            uint destinationTokenPrice =  1127000000;\n            console.log(\"bal lp price\", destinationTokenPrice);\n            uint lookupTokenPrice;\n\n            lookupTokenPrice = destinationTokenPrice.mulDiv(\n                10 ** outputDecimals,\n                lookupTokensPerDestinationToken\n            );\n            oldCachedPrice = lookupTokenPrice;\n            console.log(\"aurabal price\", lookupTokenPrice);\n        }\n\n        {\n            uint destinationTokenIndex = 0;\n        uint lookupTokenIndex = 1;\n            console.log(\"calculation with updated amp factor\");\n            uint lookupTokensPerDestinationToken;\n            lookupTokensPerDestinationToken = StableMath._calcOutGivenIn(\n                actualAmpFactor,\n                balances_,\n                destinationTokenIndex,\n                lookupTokenIndex,\n                1e18,\n                StableMath._calculateInvariant(actualAmpFactor, balances_)\n            );\n\n            // Downscale the amount to token decimals\n        uint256[] memory scalingFactors = pool.getScalingFactors();\n            lookupTokensPerDestinationToken = FixedPoint.divDown(\n                lookupTokensPerDestinationToken,\n                scalingFactors[lookupTokenIndex]\n            );\n\n            uint outputDecimals = 8;\n\n            lookupTokensPerDestinationToken =\n                (lookupTokensPerDestinationToken * 10 ** outputDecimals) /\n                1e18;\n\n            uint destinationTokenPrice = 1127000000;\n            console.log(\"bal lp price\", destinationTokenPrice);\n            uint lookupTokenPrice;\n\n            lookupTokenPrice = destinationTokenPrice.mulDiv(\n                10 ** outputDecimals,\n                lookupTokensPerDestinationToken\n            );\n            newAmpFactorPrice = lookupTokenPrice;\n            console.log(\"aurabal price\", lookupTokenPrice);\n        }\n\n        assert((oldCachedPrice -newAmpFactorPrice) * 100 * 1e18 / newAmpFactorPrice > 5 ether);\n      \n    }\n    \n}\n```\n\n**gstoyanovbg**\n\n@10xhash well done, i think your test is valid and shows a significant price change.\n\n**Czar102**\n\nThank you @10xhash! Planning to leave the issue as is.\n\n**Czar102**\n\nResult:\nMedium\nUnique\n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xauditsea](https://github.com/sherlock-audit/2023-11-olympus-judging/issues/178/#issuecomment-1881788707): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/128",
  "Code": [
    {
      "filename": "bophades/src/modules/PRICE/submodules/feeds/BalancerPoolTokenPrice.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport \"modules/PRICE/PRICE.v2.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {FullMath} from \"src/libraries/FullMath.sol\";\nimport {StableMath} from \"src/libraries/Balancer/math/StableMath.sol\";\nimport {IVault} from \"src/libraries/Balancer/interfaces/IVault.sol\";\nimport {IBasePool} from \"src/libraries/Balancer/interfaces/IBasePool.sol\";\nimport {IWeightedPool} from \"src/libraries/Balancer/interfaces/IWeightedPool.sol\";\nimport {IStablePool} from \"src/libraries/Balancer/interfaces/IStablePool.sol\";\nimport {VaultReentrancyLib} from \"src/libraries/Balancer/contracts/VaultReentrancyLib.sol\";\nimport {LogExpMath} from \"src/libraries/Balancer/math/LogExpMath.sol\";\nimport {FixedPoint} from \"src/libraries/Balancer/math/FixedPoint.sol\";\n\n/// @title      BalancerPoolTokenPrice\n/// @author     0xJem\n/// @notice     Provides prices related to Balancer pools\ncontract BalancerPoolTokenPrice is PriceSubmodule {\n    using FullMath for uint256;\n\n    /// @notice     Any token or pool with a decimal scale greater than this would result in an overflow\n    uint8 internal constant BASE_10_MAX_EXPONENT = 50;\n\n    /// @notice     Used when calculating the value of a token in a weighted pool\n    uint8 internal constant WEIGHTED_POOL_POW_DECIMALS = 18;\n\n    /// @notice             Parameters for a Balancer weighted pool\n    ///\n    /// @param pool         Address of the Balancer pool\n    struct BalancerWeightedPoolParams {\n        IWeightedPool pool;\n    }\n\n    /// @notice             Parameters for a Balancer stable pool\n    ///\n    /// @param pool         Address of the Balancer pool\n    struct BalancerStablePoolParams {\n        IStablePool pool;\n    }\n\n    /// @notice             Struct to cache data related to a Balancer weighted pool\n    /// @dev                This is not persisted between calls, and is only used to reduce the number of parameters\n    struct BalancerWeightedPoolCache {\n        address[] tokens;\n        uint256[] weights;\n        uint256[] balances;\n        uint8 decimals;\n        bytes32 poolId;\n    }\n\n    // ========== ERRORS ========== //\n\n    /// @notice             The number of decimals of the asset is greater than the maximum allowed\n    ///\n    /// @param asset_       The address of the asset\n    /// @param decimals_    The number of decimals of the asset\n    /// @param maxDecimals_ The maximum number of decimals allowed\n    error Balancer_AssetDecimalsOutOfBounds(address asset_, uint8 decimals_, uint8 maxDecimals_);\n\n    /// @notice             The provided token was not found in the Balancer pool\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    /// @param asset_       The address of the token\n    error Balancer_LookupTokenNotFound(bytes32 poolId_, address asset_);\n\n    /// @notice                 The desired number of output decimals is greater than the maximum allowed\n    ///\n    /// @param outputDecimals_  The desired number of output decimals\n    /// @param maxDecimals_     The maximum number of decimals allowed\n    error Balancer_OutputDecimalsOutOfBounds(uint8 outputDecimals_, uint8 maxDecimals_);\n\n    /// @notice                 The number of decimals of the pool is greater than the maximum allowed\n    ///\n    /// @param poolId_          The id of the Balancer pool\n    /// @param poolDecimals_    The number of decimals of the pool\n    /// @param maxDecimals_     The maximum number of decimals allowed\n    error Balancer_PoolDecimalsOutOfBounds(\n        bytes32 poolId_,\n        uint8 poolDecimals_,\n        uint8 maxDecimals_\n    );\n\n    /// @notice             The stable rate returned by the pool is invalid\n    /// @dev                This currently only occurs if the rate is 0\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    /// @param rate_        The stable rate returned by the pool\n    error Balancer_PoolStableRateInvalid(bytes32 poolId_, uint256 rate_);\n\n    /// @notice             The total supply returned by the pool is invalid\n    /// @dev                This currently only occurs if the total supply is 0\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    /// @param supply_      The total supply returned by the pool\n    error Balancer_PoolSupplyInvalid(bytes32 poolId_, uint256 supply_);\n\n    /// @notice             A token in the pool is invalid\n    /// @dev                This currently only occurs if the token address is 0\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    /// @param index_       The index of the token in the pool\n    /// @param token_       The address of the token\n    error Balancer_PoolTokenInvalid(bytes32 poolId_, uint256 index_, address token_);\n\n    /// @notice             The value of the Balancer pool is zero\n    /// @dev                This currently only occurs if the number of tokens is 0\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    error Balancer_PoolValueZero(bytes32 poolId_);\n\n    /// @notice             There is a mismatch between the number of tokens and weights\n    /// @dev                This is unlikely to occur, but is in place to be defensive\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    /// @param tokenCount_  The number of tokens in the Balancer pool\n    /// @param weightCount_ The number of weights in the Balancer pool\n    error Balancer_PoolTokenWeightMismatch(\n        bytes32 poolId_,\n        uint256 tokenCount_,\n        uint256 weightCount_\n    );\n\n    /// @notice                 There is a mismatch between the number of tokens and balances\n    /// @dev                    This is unlikely to occur, but is in place to be defensive\n    ///\n    /// @param poolId_          The id of the Balancer pool\n    /// @param tokenCount_      The number of tokens in the Balancer pool\n    /// @param balanceCount_    The number of balances in the Balancer pool\n    error Balancer_PoolTokenBalanceMismatch(\n        bytes32 poolId_,\n        uint256 tokenCount_,\n        uint256 balanceCount_\n    );\n\n    /// @notice                 There is a mismatch between the number of tokens, balances and weights\n    /// @dev                    This is unlikely to occur, but is in place to be defensive\n    ///\n    /// @param poolId_          The id of the Balancer pool\n    /// @param tokenCount_      The number of tokens in the Balancer pool\n    /// @param balanceCount_    The number of balances in the Balancer pool\n    /// @param weightCount_     The number of weights in the Balancer pool\n    error Balancer_PoolTokenBalanceWeightMismatch(\n        bytes32 poolId_,\n        uint256 tokenCount_,\n        uint256 balanceCount_,\n        uint256 weightCount_\n    );\n\n    /// @notice             The pool is not a stable pool\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    error Balancer_PoolTypeNotStable(bytes32 poolId_);\n\n    /// @notice             The pool is not a weighted pool\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    error Balancer_PoolTypeNotWeighted(bytes32 poolId_);\n\n    /// @notice             A weight in the pool is invalid\n    /// @dev                This currently only occurs if the weight is 0\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    /// @param index_       The index of the weight in the pool\n    /// @param weight_      The value of the weight\n    error Balancer_PoolWeightInvalid(bytes32 poolId_, uint256 index_, uint256 weight_);\n\n    /// @notice             The price of a corresponding token could not be found\n    /// @dev                This occurs if there are no asset definitions in PRICE\n    /// @dev                for the other tokens in the Balancer pool, and hence\n    /// @dev                the price of the lookup token cannot be determined\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    /// @param lookupToken_ The token to determine the price of\n    error Balancer_PriceNotFound(bytes32 poolId_, address lookupToken_);\n\n    // ========== STATE VARIABLES ========== //\n\n    /// @notice     Address of the Balancer vault\n    IVault public immutable balVault;\n\n    // ========== CONSTRUCTOR ========== //\n\n    constructor(Module parent_, IVault balVault_) Submodule(parent_) {\n        balVault = balVault_;\n    }\n\n    // ========== SUBMODULE FUNCTIONS =========== //\n\n    /// @inheritdoc Submodule\n    function SUBKEYCODE() public pure override returns (SubKeycode) {\n        return toSubKeycode(\"PRICE.BPT\");\n    }\n\n    /// @inheritdoc Submodule\n    function VERSION() public pure override returns (uint8 major, uint8 minor) {\n        major = 1;\n        minor = 0;\n    }\n\n    // ========== HELPER FUNCTIONS ========== //\n\n    /// @notice                     Converts `value_` from the ERC20 token's decimals to `outputDecimals_`\n    /// @dev                        This function will revert if:\n    /// @dev                        - Converting the token's decimals would result in an overflow.\n    ///\n    /// @param value_               Value in native ERC20 token decimals\n    /// @param token_               The address of the ERC20 token\n    /// @param outputDecimals_      The desired number of decimals\n    /// @return                     Number in the scale of `outputDecimals_`\n    function _convertERC20Decimals(\n        uint256 value_,\n        address token_,\n        uint8 outputDecimals_\n    ) internal view returns (uint256) {\n        uint8 tokenDecimals = ERC20(token_).decimals();\n        if (tokenDecimals > BASE_10_MAX_EXPONENT)\n            revert Balancer_AssetDecimalsOutOfBounds(token_, tokenDecimals, BASE_10_MAX_EXPONENT);\n\n        return value_.mulDiv(10 ** outputDecimals_, 10 ** tokenDecimals);\n    }\n\n    /// @notice                     Obtains the balance/weight ratio of the token at index `index_` in the pool\n    /// @dev                        This function will revert if:\n    /// @dev                        - Converting the pool's decimals would result in an overflow.\n    ///\n    /// @dev                        As this function is accessing the balances of the pool, ensure that VaultReentrancyLib\n    /// @dev                        is called in order to prevent re-entrancy attacks.\n    ///\n    /// @param cache                Cached data related to the Balancer weighted pool\n    /// @param index_               Index of the token in the Balancer pool\n    /// @param outputDecimals_      The desired number of decimals\n    /// @return                     Balance in the scale of `outputDecimals_`\n    function _getTokenBalanceWeighting(\n        BalancerWeightedPoolCache memory cache,\n        uint256 index_,\n        uint8 outputDecimals_\n    ) internal view returns (uint256) {\n        uint256 tokenBalance = _convertERC20Decimals(\n            cache.balances[index_],\n            cache.tokens[index_],\n            outputDecimals_\n        );\n\n        uint256 tokenWeight = cache.weights[index_].mulDiv(\n            10 ** outputDecimals_,\n            10 ** cache.decimals\n        );\n\n        return tokenBalance.mulDiv(10 ** outputDecimals_, tokenWeight);\n    }\n\n    /// @notice                     Calculates the value of a token in a Balancer weighted pool\n    /// @dev                        This function will revert if:\n    /// @dev                        - The provided token is address(0)\n    /// @dev                        - The provided weight is 0\n    ///\n    /// @param token_               Address of the token\n    /// @param weight_              Weight of the token in the Balancer pool\n    /// @param poolDecimals_        The number of decimals of the Balancer pool\n    /// @param outputDecimals_      The desired number of decimals\n    /// @param poolId_              id of the Balancer pool\n    /// @param index_               Index of the token in the Balancer pool\n    /// @return                     Value in the scale of `outputDecimals_`\n    function _getTokenValueInWeightedPool(\n        address token_,\n        uint256 weight_,\n        uint8 poolDecimals_,\n        uint8 outputDecimals_,\n        bytes32 poolId_,\n        uint256 index_\n    ) internal view returns (uint256) {\n        if (token_ == address(0)) revert Balancer_PoolTokenInvalid(poolId_, index_, token_);\n        if (weight_ == 0) revert Balancer_PoolWeightInvalid(poolId_, index_, weight_);\n\n        uint256 price; // Scale: `WEIGHTED_POOL_POW_DECIMALS`\n        {\n            /**\n             * PRICE will revert if there is an issue resolving the price, or if it is 0.\n             *\n             * As the value of the pool token is reliant on the price of every underlying token,\n             * the revert from PRICE is not caught.\n             */\n            (uint256 price_, ) = _PRICE().getPrice(token_, PRICEv2.Variant.CURRENT); // Scale: `outputDecimals_`\n\n            price = price_.mulDiv(10 ** WEIGHTED_POOL_POW_DECIMALS, 10 ** outputDecimals_);\n        }\n\n        // Scale: `WEIGHTED_POOL_POW_DECIMALS`\n        uint256 weight = weight_.mulDiv(10 ** WEIGHTED_POOL_POW_DECIMALS, 10 ** poolDecimals_);\n\n        // All inputs to pow need to be in the scale of WEIGHTED_POOL_POW_DECIMALS, so adjust for that\n        uint256 value = LogExpMath.pow(\n            price.mulDiv(10 ** WEIGHTED_POOL_POW_DECIMALS, weight),\n            weight\n        ); // Scale: `WEIGHTED_POOL_POW_DECIMALS`\n\n        // Adjust for `outputDecimals_`\n        return value.mulDiv(10 ** outputDecimals_, 10 ** WEIGHTED_POOL_POW_DECIMALS);\n    }\n\n    /// @notice                     Calculates the value of a Balancer weighted pool\n    /// @dev                        This function calculates the value of each token and returns the sum.\n    ///\n    /// @param tokens_              Array of tokens in the Balancer pool\n    /// @param weights_             Array of weights of the tokens in the Balancer pool\n    /// @param poolDecimals_        The number of decimals of the Balancer pool\n    /// @param outputDecimals_      The desired number of decimals\n    /// @return                     Value in the scale of `outputDecimals_`\n    function _getWeightedPoolRawValue(\n        address[] memory tokens_,\n        uint256[] memory weights_,\n        uint8 poolDecimals_,\n        uint8 outputDecimals_,\n        bytes32 poolId_\n    ) internal view returns (uint256) {\n        uint256 len = tokens_.length;\n\n        uint256 poolValue = 0; // Scale: `outputDecimals_`\n        for (uint256 i; i < len; ) {\n            uint256 currentValue = _getTokenValueInWeightedPool(\n                tokens_[i],\n                weights_[i],\n                poolDecimals_,\n                outputDecimals_,\n                poolId_,\n                i\n            );\n\n            if (poolValue == 0) {\n                poolValue = currentValue;\n            } else {\n                poolValue = poolValue.mulDiv(currentValue, 10 ** outputDecimals_);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return poolValue;\n    }\n\n    // ========== POOL TOKEN PRICE FUNCTIONS ========== //\n\n    /// @notice                 Determines the unit price of the pool token for the Balancer weighted pool specified in `params_`.\n    /// @dev                    To avoid price manipulation, this function calculated the pool token price in the manner recommended by\n    /// @dev                    Balancer at https://docs.balancer.fi/concepts/advanced/valuing-bpt/valuing-bpt.html#on-chain-price-evaluation :\n    /// @dev                    - Obtains the prices of all tokens in the pool from PRICE (usually using price feeds)\n    /// @dev                    - Applies a guard to protect against re-entrancy attacks on the Balancer pool\n    ///\n    /// @dev                    This function will revert if:\n    /// @dev                    - The scale of `outputDecimals_` or the pool's decimals is too high\n    /// @dev                    - The pool is mis-configured\n    /// @dev                    - If the pool is not a weighted pool\n    ///\n    /// @param outputDecimals_  The number of output decimals\n    /// @param params_          Balancer pool parameters of type `BalancerWeightedPoolParams`\n    /// @return                 Price in the scale of `outputDecimals_`\n    function getWeightedPoolTokenPrice(\n        address,\n        uint8 outputDecimals_,\n        bytes calldata params_\n    ) external view returns (uint256) {\n        // Prevent overflow\n        if (outputDecimals_ > BASE_10_MAX_EXPONENT)\n            revert Balancer_OutputDecimalsOutOfBounds(outputDecimals_, BASE_10_MAX_EXPONENT);\n\n        address[] memory tokens;\n        uint256[] memory weights;\n        uint256 poolMultiplier; // outputDecimals_\n        uint8 poolDecimals;\n        bytes32 poolId;\n        {\n            // Decode params\n            BalancerWeightedPoolParams memory params = abi.decode(\n                params_,\n                (BalancerWeightedPoolParams)\n            );\n            if (address(params.pool) == address(0)) revert Balancer_PoolTypeNotWeighted(bytes32(0));\n\n            IWeightedPool pool = IWeightedPool(params.pool);\n\n            // Get pool ID\n            poolId = pool.getPoolId();\n\n            // Prevent re-entrancy attacks\n            VaultReentrancyLib.ensureNotInVaultContext(balVault);\n\n            // Get tokens in the pool from vault\n            (address[] memory tokens_, , ) = balVault.getPoolTokens(poolId);\n            tokens = tokens_;\n\n            // Get weights\n            try pool.getNormalizedWeights() returns (uint256[] memory weights_) {\n                weights = weights_;\n            } catch {\n                // Exit if it is not a weighted pool\n                revert Balancer_PoolTypeNotWeighted(poolId);\n            }\n\n            uint256 poolSupply_ = pool.totalSupply(); // pool decimals\n            if (poolSupply_ == 0) revert Balancer_PoolSupplyInvalid(poolId, 0);\n\n            uint256 poolInvariant_ = pool.getInvariant(); // pool decimals\n\n            poolDecimals = pool.decimals();\n            if (poolDecimals > BASE_10_MAX_EXPONENT)\n                revert Balancer_PoolDecimalsOutOfBounds(poolId, poolDecimals, BASE_10_MAX_EXPONENT);\n\n            // The invariant and supply have the same scale, so we can shift the result into outputDecimals_\n            poolMultiplier = poolInvariant_.mulDiv(10 ** outputDecimals_, poolSupply_);\n        }\n\n        // Iterate through tokens, get prices, and determine pool value\n        uint256 len = tokens.length;\n        if (weights.length != len)\n            revert Balancer_PoolTokenWeightMismatch(poolId, len, weights.length);\n\n        uint256 poolValue = _getWeightedPoolRawValue(\n            tokens,\n            weights,\n            poolDecimals,\n            outputDecimals_,\n            poolId\n        );\n        // No coins or balances\n        if (poolValue == 0) revert Balancer_PoolValueZero(poolId);\n\n        // Calculate price of pool token in terms of outputDecimals_\n        uint256 poolTokenPrice = poolMultiplier.mulDiv(poolValue, 10 ** outputDecimals_);\n\n        return poolTokenPrice;\n    }\n\n    /// @notice                 Determines the unit price of the pool token for the Balancer stable pool specified in `params_`.\n    /// @dev                    To avoid price manipulation, this function calculated the pool token price in the following manner:\n    /// @dev                    - Applies a guard to protect against re-entrancy attacks on the Balancer pool\n    /// @dev                    - Utilises the formula suggested by Balancer: https://docs.balancer.fi/concepts/advanced/valuing-bpt/valuing-bpt.html#on-chain-price-evaluation\n    ///\n    /// @dev                    This function will revert if:\n    /// @dev                    - The scale of `outputDecimals_` or the pool's decimals is too high\n    /// @dev                    - The pool is mis-configured\n    /// @dev                    - If the pool is not a stable pool or is a composable stable pool (determined by the absence of the `getLastInvariant()` function)\n    ///\n    /// @dev                    NOTE: If there is a significant de-peg between the prices of constituent assets, the token price will be inaccurate. See the now-deleted mention of this: https://github.com/balancer/docs/pull/112/files\n    ///\n    /// @param outputDecimals_  The number of output decimals\n    /// @param params_          Balancer pool parameters of type `BalancerStablePoolParams`\n    /// @return                 Price in the scale of outputDecimals_\n    function getStablePoolTokenPrice(\n        address,\n        uint8 outputDecimals_,\n        bytes calldata params_\n    ) external view returns (uint256) {\n        // Prevent overflow\n        if (outputDecimals_ > BASE_10_MAX_EXPONENT)\n            revert Balancer_OutputDecimalsOutOfBounds(outputDecimals_, BASE_10_MAX_EXPONENT);\n\n        address[] memory tokens;\n        uint256 poolRate; // pool decimals\n        uint8 poolDecimals;\n        bytes32 poolId;\n        {\n            // Decode params\n            BalancerStablePoolParams memory params = abi.decode(\n                params_,\n                (BalancerStablePoolParams)\n            );\n            if (address(params.pool) == address(0)) revert Balancer_PoolTypeNotStable(bytes32(0));\n\n            IStablePool pool = IStablePool(params.pool);\n\n            // Get pool ID\n            poolId = pool.getPoolId();\n\n            // Ensure that the pool is a stable pool, but not a composable stable pool.\n            // Determining the LP token price using a composable stable pool is sufficiently different from other\n            // stable pools, and should be added in a separate adapter/function at a later date.\n            try pool.getLastInvariant() returns (uint256, uint256) {\n                // Do nothing\n            } catch (bytes memory) {\n                revert Balancer_PoolTypeNotStable(poolId);\n            }\n\n            // Prevent re-entrancy attacks\n            VaultReentrancyLib.ensureNotInVaultContext(balVault);\n\n            // Get tokens in the pool from vault\n            (address[] memory tokens_, , ) = balVault.getPoolTokens(poolId);\n            tokens = tokens_;\n\n            // Get rate\n            try pool.getRate() returns (uint256 rate_) {\n                if (rate_ == 0) {\n                    revert Balancer_PoolStableRateInvalid(poolId, 0);\n                }\n\n                poolRate = rate_;\n            } catch {\n                // Exit if it is not a stable pool\n                revert Balancer_PoolTypeNotStable(poolId);\n            }\n\n            poolDecimals = pool.decimals();\n            if (poolDecimals > BASE_10_MAX_EXPONENT)\n                revert Balancer_PoolDecimalsOutOfBounds(poolId, poolDecimals, BASE_10_MAX_EXPONENT);\n        }\n\n        // Get the base token price\n        uint256 len = tokens.length;\n        if (len == 0) revert Balancer_PoolValueZero(poolId);\n\n        uint256 minimumPrice; // outputDecimals_\n        {\n            /**\n             * The Balancer docs do not currently state this, but a historical version noted\n             * that getRate() should be multiplied by the minimum price of the tokens in the\n             * pool in order to get a valuation. This is the same approach as used by Curve stable pools.\n             */\n            for (uint256 i; i < len; i++) {\n                address token = tokens[i];\n                if (token == address(0)) revert Balancer_PoolTokenInvalid(poolId, i, token);\n\n                /**\n                 * PRICE will revert if there is an issue resolving the price, or if it is 0.\n                 *\n                 * As the value of the pool token is reliant on the price of every underlying token,\n                 * the revert from PRICE is not caught.\n                 */\n                (uint256 price_, ) = _PRICE().getPrice(token, PRICEv2.Variant.CURRENT); // outputDecimals_\n\n                if (minimumPrice == 0) {\n                    minimumPrice = price_;\n                } else if (price_ < minimumPrice) {\n                    minimumPrice = price_;\n                }\n            }\n        }\n\n        /**\n         * NOTE: if this line is reached, minimumPrice is guaranteed to be non-zero:\n         * - the length of the `tokens` array is greater than 0\n         * - the price of each token is non-zero (or else it would have reverted)\n         *\n         * Gas is saved by skipping a check on the value of minimumPrice.\n         */\n        uint256 poolValue = poolRate.mulDiv(minimumPrice, 10 ** poolDecimals); // outputDecimals_\n\n        return poolValue;\n    }\n\n    // ========== TOKEN SPOT PRICE FUNCTIONS ========== //\n\n    /// @notice                 Determines the spot price of the specified token from the Balancer pool specified in `params_`.\n    /// @dev                    It does this by:\n    /// @dev                    - Determining the price and reserves of the token paired with `lookupToken_`\n    /// @dev                    - Determining the corresponding price of `lookupToken_`\n    ///\n    /// @dev                    Will revert upon the following:\n    /// @dev                    - If `outputDecimals_` or the pool's decimals are too high\n    /// @dev                    - If the transaction involves reentrancy on the Balancer pool\n    /// @dev                    - If the pool is not a weighted pool\n    ///\n    /// @dev                    NOTE: as the reserves of Balancer pools can be manipulated using flash loans, the spot price\n    /// @dev                    can also be manipulated. Price feeds are a preferred source of price data. Use this function with caution.\n    ///\n    /// @param lookupToken_     The token to determine the price of\n    /// @param outputDecimals_  The number of output decimals\n    /// @param params_          Balancer pool parameters of type `BalancerWeightedPoolParams`\n    /// @return                 Price in the scale of `outputDecimals_`\n    function getTokenPriceFromWeightedPool(\n        address lookupToken_,\n        uint8 outputDecimals_,\n        bytes calldata params_\n    ) external view returns (uint256) {\n        // Prevent overflow\n        if (outputDecimals_ > BASE_10_MAX_EXPONENT)\n            revert Balancer_OutputDecimalsOutOfBounds(outputDecimals_, BASE_10_MAX_EXPONENT);\n\n        // Decode params\n        IWeightedPool pool;\n        {\n            BalancerWeightedPoolParams memory params = abi.decode(\n                params_,\n                (BalancerWeightedPoolParams)\n            );\n            if (address(params.pool) == address(0)) revert Balancer_PoolTypeNotWeighted(bytes32(0));\n\n            pool = IWeightedPool(params.pool);\n        }\n\n        BalancerWeightedPoolCache memory poolCache;\n        uint256 lookupTokenIndex = type(uint256).max;\n        uint256 destinationTokenIndex = type(uint256).max;\n        uint256 destinationTokenPrice; // Scale: outputDecimals_\n        {\n            // Prevent re-entrancy attacks\n            VaultReentrancyLib.ensureNotInVaultContext(balVault);\n\n            // Get tokens in the pool from vault\n            poolCache.poolId = pool.getPoolId();\n            (address[] memory tokens_, uint256[] memory balances_, ) = balVault.getPoolTokens(\n                poolCache.poolId\n            );\n            poolCache.tokens = tokens_;\n            poolCache.balances = balances_;\n            poolCache.decimals = pool.decimals();\n\n            if (poolCache.decimals > BASE_10_MAX_EXPONENT)\n                revert Balancer_PoolDecimalsOutOfBounds(\n                    poolCache.poolId,\n                    poolCache.decimals,\n                    BASE_10_MAX_EXPONENT\n                );\n\n            // Test if the weights function exists, otherwise revert\n            try pool.getNormalizedWeights() returns (uint256[] memory weights_) {\n                poolCache.weights = weights_;\n            } catch (bytes memory) {\n                revert Balancer_PoolTypeNotWeighted(poolCache.poolId);\n            }\n\n            // Check for consistency of tokens\n            if (\n                !(poolCache.tokens.length == poolCache.balances.length &&\n                    poolCache.balances.length == poolCache.weights.length)\n            )\n                revert Balancer_PoolTokenBalanceWeightMismatch(\n                    poolCache.poolId,\n                    poolCache.tokens.length,\n                    poolCache.balances.length,\n                    poolCache.weights.length\n                );\n\n            // Determine the index of the lookup token and an appropriate destination token\n            uint256 tokensLen = poolCache.tokens.length;\n            for (uint256 i; i < tokensLen; i++) {\n                // If address is zero, complain\n                address currentToken = poolCache.tokens[i];\n                if (currentToken == address(0))\n                    revert Balancer_PoolTokenInvalid(poolCache.poolId, i, currentToken);\n\n                // If lookup token\n                if (lookupToken_ == currentToken) {\n                    lookupTokenIndex = i;\n                    continue;\n                }\n\n                // Don't set the destination token again\n                if (destinationTokenIndex != type(uint256).max) continue;\n\n                /**\n                 * PRICE will revert if there is an issue resolving the price, or if it is 0.\n                 *\n                 * We catch this, so that other candidate tokens can be tested.\n                 */\n                try _PRICE().getPrice(currentToken, PRICEv2.Variant.CURRENT) returns (\n                    uint256 currentPrice,\n                    uint48 timestamp\n                ) {\n                    destinationTokenIndex = i;\n                    destinationTokenPrice = currentPrice;\n                } catch (bytes memory) {\n                    continue;\n                }\n            }\n\n            // Lookup token not found\n            if (lookupTokenIndex == type(uint256).max)\n                revert Balancer_LookupTokenNotFound(poolCache.poolId, lookupToken_);\n\n            // No destination token found with a price\n            if (destinationTokenPrice == 0 || destinationTokenIndex == type(uint256).max)\n                revert Balancer_PriceNotFound(poolCache.poolId, lookupToken_);\n        }\n\n        // Calculate the rate of the lookup token\n        uint256 lookupTokenUsdPrice;\n        {\n            // Weightings\n            // Scale: outputDecimals_\n            uint256 lookupTokenWeighting = _getTokenBalanceWeighting(\n                poolCache,\n                lookupTokenIndex,\n                outputDecimals_\n            );\n            uint256 destinationTokenWeighting = _getTokenBalanceWeighting(\n                poolCache,\n                destinationTokenIndex,\n                outputDecimals_\n            );\n\n            // Get the lookupToken in terms of the destinationToken\n            // Source: https://docs.balancer.fi/reference/math/weighted-math.html#spot-price\n            lookupTokenUsdPrice = destinationTokenWeighting.mulDiv(\n                destinationTokenPrice,\n                lookupTokenWeighting\n            );\n        }\n\n        return lookupTokenUsdPrice;\n    }\n\n    /// @notice                 Determines the spot price of the specified token from the Balancer pool specified in `params_`.\n    /// @dev                    It does this by:\n    /// @dev                    - Using the Balancer StableMath library to determine the quantity of `lookupToken_` returned for 1 of\n    /// @dev                    any token paired with `lookupToken_` for which a price is available\n    ///\n    /// @dev                    Will revert upon the following:\n    /// @dev                    - If the transaction involves reentrancy on the Balancer pool\n    /// @dev                    - If the pool is not a stable pool or is a composable stable pool (determined by the absence of the `getLastInvariant()` function)\n    ///\n    /// @dev                    NOTE: as the reserves of Balancer pools can be manipulated using flash loans, the spot price\n    /// @dev                    can also be manipulated. Price feeds are a preferred source of price data. Use this function with caution.\n    ///\n    /// @param lookupToken_     The token to determine the price of\n    /// @param outputDecimals_  The number of output decimals\n    /// @param params_          Balancer pool parameters of type `BalancerStablePoolParams`\n    /// @return                 Price in the scale of `outputDecimals_`\n    function getTokenPriceFromStablePool(\n        address lookupToken_,\n        uint8 outputDecimals_,\n        bytes calldata params_\n    ) external view returns (uint256) {\n        // Prevent overflow\n        if (outputDecimals_ > BASE_10_MAX_EXPONENT)\n            revert Balancer_OutputDecimalsOutOfBounds(outputDecimals_, BASE_10_MAX_EXPONENT);\n\n        // Decode params"
    }
  ]
}