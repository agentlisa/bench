{
  "Title": "[10] Hardcoded block numbers will lead to unsuccessful off-boarding",
  "Content": "\n*Note: At the judgeâ€™s request [here](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1061#issuecomment-1919014163), this downgraded issue from the same warden has been included in this report for completeness.*\n\n### Lines of code\n\nhttps://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/governance/LendingTermOffboarding.sol#L36\n\n### Impact\n\nOff-boarding is with a duration of **46523 blocks** (7 days), calculated from `block.number` on the Ethereum chain 13 sec/block, but the development team wants to deploy in L2 chains as well:\n\n> [**Deployment**: we anticipate to launch on Ethereum mainnet & L2s like Arbitrum.](https://github.com/code-423n4/2023-12-ethereumcreditguild/tree/main?tab=readme-ov-file#additional-context)\n\nThere is no way to change the off-boarding duration and most of the proposals on the L2 chains will fail due to the high amount of votes required in a short amount of period.\n\n### Proof of Concept\n\nhttps://github.com/0xJuancito/multichain-auditor?tab=readme-ov-file#block-production-may-not-be-constant\n\nThe most widely used L2 chains are `Arbitrum`, `Optimism`, and `Polygon zkEVM`. But the average block time is different on all of them:\n\n- `Arbitrum` - 0.26 sec.\n- `Optimism` - 2 sec.\n- `Polygon zkEVM` - 7 sec.\n\nOn **Optimism** 46523 blocks will pass for approximately 26 hours as there are 1800 blocks per hour.\n\nIf we take **Arbitrum** 46523 blocks will pass for approximately 3 hours and 36 minutes as there are 13846 blocks per hour.\n\nWe can see from the proposals (`GIP_0.sol`) `10_000_000e18` set as an `OFFBOARD_QUORUM` and we can conclude that there is no way quorum to be satisfied within 216 minutes.\n\nGovernor can change the quorum for a given `LendingTermOffboarding.sol` contract but this exposes risk as this will significantly decrease the decentralization.\n\n### Recommended Mitigation Steps\n\nConsider allowing the deployer to set the `POLL_DURATION_BLOCKS` from the constructor instead of assigning it to constant.\n\n### Assessed type\n\nMath\n\n**[TrungOre (judge) decreased severity to Low](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1034#issuecomment-1908992753)**\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-12-ethereumcreditguild",
  "Code": [
    {
      "filename": "src/governance/LendingTermOffboarding.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {SimplePSM} from \"@src/loan/SimplePSM.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {LendingTerm} from \"@src/loan/LendingTerm.sol\";\n\n/// @notice Utils to offboard a LendingTerm.\n/// This contract works somewhat similarly to a Veto governor: any GUILD holder can poll for the removal\n/// of a lending term, and if enough GUILD holders vote for a removal poll, the term can be offboarded\n/// without delay.\n/// When a term is offboarded, no new loans can be issued, and GUILD holders cannot vote for the term anymore.\n/// After a term is offboarded, all the loans have to be called, then the term can be cleaned up (roles).\ncontract LendingTermOffboarding is CoreRef {\n    /// @notice emitted when a user supports the removal of a lending term\n    event OffboardSupport(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 indexed snapshotBlock,\n        address user,\n        uint256 userWeight\n    );\n    /// @notice emitted when a lending term is offboarded\n    event Offboard(uint256 indexed timestamp, address indexed term);\n    /// @notice emitted when a lending term is cleaned up\n    event Cleanup(uint256 indexed timestamp, address indexed term);\n\n    /// @notice Emitted when quorum is updated.\n    event QuorumUpdated(uint256 oldQuorum, uint256 newQuorum);\n\n    /// @notice maximum age of polls for them to be considered valid.\n    /// This offboarding mechanism is meant to be used in a reactive fashion, and\n    /// polls should not stay open for a long time.\n    uint256 public constant POLL_DURATION_BLOCKS = 46523; // ~7 days @ 13s/block\n\n    /// @notice quorum for offboarding a lending term\n    uint256 public quorum;\n\n    /// @notice reference to the GUILD token\n    address public immutable guildToken;\n\n    /// @notice reference to the PSM\n    address public immutable psm;\n\n    /// @notice list of removal polls created.\n    /// keys = [snapshotBlock][termAddress] -> quorum supporting the removal.\n    mapping(uint256 => mapping(address => uint256)) public polls;\n\n    /// @notice list of user votes in removal polls\n    /// keys = [userAddress][snapshotBlock][termAddress] -> user vote weight.\n    mapping(address => mapping(uint256 => mapping(address => uint256)))\n        public userPollVotes;\n\n    /// @notice block number of last removal polls created for each term.\n    /// key = [termAddress] -> block number.\n    mapping(address => uint256) public lastPollBlock;\n\n    /// @notice mapping of terms that can be offboarded.\n    mapping(address => bool) public canOffboard;\n\n    /// @notice number of offboardings in progress.\n    uint256 public nOffboardingsInProgress;\n\n    constructor(\n        address _core,\n        address _guildToken,\n        address _psm,\n        uint256 _quorum\n    ) CoreRef(_core) {\n        guildToken = _guildToken;\n        psm = _psm;\n        quorum = _quorum;\n    }\n\n    /// @notice set the quorum for offboard votes\n    function setQuorum(\n        uint256 _quorum\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        emit QuorumUpdated(quorum, _quorum);\n        quorum = _quorum;\n    }\n\n    /// @notice Propose to offboard a given LendingTerm.\n    /// @dev the poll starts with 1 wei of voting power, to initialize the storage slot\n    /// that counts the number of user supports (a value of 0 is used as the existence\n    /// check to know if a poll has been created).\n    function proposeOffboard(address term) external whenNotPaused {\n        require(\n            polls[block.number][term] == 0,\n            \"LendingTermOffboarding: poll exists\"\n        );\n        require(\n            block.number > lastPollBlock[term] + POLL_DURATION_BLOCKS,\n            \"LendingTermOffboarding: poll active\"\n        );\n        // Check that the term is an active gauge\n        require(\n            GuildToken(guildToken).isGauge(term),\n            \"LendingTermOffboarding: not an active term\"\n        );\n\n        polls[block.number][term] = 1; // voting power\n        lastPollBlock[term] = block.number;\n        emit OffboardSupport(\n            block.timestamp,\n            term,\n            block.number,\n            address(0),\n            1\n        );\n    }\n\n    /// @notice Support a poll to offboard a given LendingTerm.\n    function supportOffboard(\n        uint256 snapshotBlock,\n        address term\n    ) external whenNotPaused {\n        require(\n            block.number <= snapshotBlock + POLL_DURATION_BLOCKS,\n            \"LendingTermOffboarding: poll expired\"\n        );\n        uint256 _weight = polls[snapshotBlock][term];\n        require(_weight != 0, \"LendingTermOffboarding: poll not found\");\n        uint256 userWeight = GuildToken(guildToken).getPastVotes(\n            msg.sender,\n            snapshotBlock\n        );\n        require(userWeight != 0, \"LendingTermOffboarding: zero weight\");\n        require(\n            userPollVotes[msg.sender][snapshotBlock][term] == 0,\n            \"LendingTermOffboarding: already voted\"\n        );\n\n        userPollVotes[msg.sender][snapshotBlock][term] = userWeight;\n        polls[snapshotBlock][term] = _weight + userWeight;\n        if (_weight + userWeight >= quorum) {\n            canOffboard[term] = true;\n        }\n        emit OffboardSupport(\n            block.timestamp,\n            term,\n            snapshotBlock,\n            msg.sender,\n            userWeight\n        );\n    }\n\n    /// @notice Offboard a LendingTerm.\n    /// This will prevent new loans from being open, and will prevent GUILD holders to vote for the term.\n    /// @param term LendingTerm to offboard from the system.\n    function offboard(address term) external whenNotPaused {\n        require(canOffboard[term], \"LendingTermOffboarding: quorum not met\");\n\n        // update protocol config\n        // this will revert if the term has already been offboarded\n        // through another mean.\n        GuildToken(guildToken).removeGauge(term);\n\n        // pause psm redemptions\n        if (\n            nOffboardingsInProgress++ == 0 &&\n            !SimplePSM(psm).redemptionsPaused()\n        ) {\n            SimplePSM(psm).setRedemptionsPaused(true);\n        }\n\n        emit Offboard(block.timestamp, term);\n    }\n\n    /// @notice Cleanup roles of a LendingTerm.\n    /// This is only callable after a term has been offboarded and all its loans have been closed.\n    /// @param term LendingTerm to cleanup.\n    function cleanup(address term) external whenNotPaused {\n        require(canOffboard[term], \"LendingTermOffboarding: quorum not met\");\n        require(\n            LendingTerm(term).issuance() == 0,\n            \"LendingTermOffboarding: not all loans closed\"\n        );\n        require(\n            GuildToken(guildToken).isDeprecatedGauge(term),\n            \"LendingTermOffboarding: re-onboarded\"\n        );\n\n        // update protocol config\n        core().revokeRole(CoreRoles.RATE_LIMITED_CREDIT_MINTER, term);\n        core().revokeRole(CoreRoles.GAUGE_PNL_NOTIFIER, term);\n\n        // unpause psm redemptions\n        if (\n            --nOffboardingsInProgress == 0 && SimplePSM(psm).redemptionsPaused()\n        ) {\n            SimplePSM(psm).setRedemptionsPaused(false);\n        }\n\n        canOffboard[term] = false;\n        emit Cleanup(block.timestamp, term);\n    }\n}"
    }
  ]
}