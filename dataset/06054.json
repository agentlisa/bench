{
  "Title": "[G-03] Redundant `return` in the `try` clause",
  "Content": "This `try` clause has already returned `low` and `high` and is returning the same things again in its nested logic, which is inexpedient and unnecessary. Similar behavior is also found in [`Asset.price`](https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/Asset.sol#L112-L121). \n\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/RTokenAsset.sol#L86-L94\n\n```diff\n    function price() public view virtual returns (uint192, uint192) {\n        try this.tryPrice() returns (uint192 low, uint192 high) {\n-            return (low, high);\n        } catch (bytes memory errData) {\n            // see: docs/solidity-style.md#Catching-Empty-Data\n            if (errData.length == 0) revert(); // solhint-disable-line reason-string\n            return (0, FIX_MAX);\n        }\n    }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-reserve",
  "Code": [
    {
      "filename": "contracts/plugins/assets/Asset.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.19;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../interfaces/IAsset.sol\";\nimport \"./OracleLib.sol\";\nimport \"./VersionedAsset.sol\";\n\ncontract Asset is IAsset, VersionedAsset {\n    using FixLib for uint192;\n    using OracleLib for AggregatorV3Interface;\n\n    AggregatorV3Interface public immutable chainlinkFeed; // {UoA/tok}\n\n    IERC20Metadata public immutable erc20;\n\n    uint8 public immutable erc20Decimals;\n\n    uint192 public immutable override maxTradeVolume; // {UoA}\n\n    uint48 public immutable oracleTimeout; // {s}\n\n    uint192 public immutable oracleError; // {1}\n\n    // === Lot price ===\n\n    uint48 public immutable priceTimeout; // {s} The period over which `savedHighPrice` decays to 0\n\n    uint192 public savedLowPrice; // {UoA/tok} The low price of the token during the last update\n\n    uint192 public savedHighPrice; // {UoA/tok} The high price of the token during the last update\n\n    uint48 public lastSave; // {s} The timestamp when prices were last saved\n\n    /// @param priceTimeout_ {s} The number of seconds over which savedHighPrice decays to 0\n    /// @param chainlinkFeed_ Feed units: {UoA/tok}\n    /// @param oracleError_ {1} The % the oracle feed can be off by\n    /// @param maxTradeVolume_ {UoA} The max trade volume, in UoA\n    /// @param oracleTimeout_ {s} The number of seconds until a oracle value becomes invalid\n    constructor(\n        uint48 priceTimeout_,\n        AggregatorV3Interface chainlinkFeed_,\n        uint192 oracleError_,\n        IERC20Metadata erc20_,\n        uint192 maxTradeVolume_,\n        uint48 oracleTimeout_\n    ) {\n        require(priceTimeout_ > 0, \"price timeout zero\");\n        require(address(chainlinkFeed_) != address(0), \"missing chainlink feed\");\n        require(oracleError_ > 0 && oracleError_ < FIX_ONE, \"oracle error out of range\");\n        require(address(erc20_) != address(0), \"missing erc20\");\n        require(maxTradeVolume_ > 0, \"invalid max trade volume\");\n        require(oracleTimeout_ > 0, \"oracleTimeout zero\");\n        priceTimeout = priceTimeout_;\n        chainlinkFeed = chainlinkFeed_;\n        oracleError = oracleError_;\n        erc20 = erc20_;\n        erc20Decimals = erc20.decimals();\n        maxTradeVolume = maxTradeVolume_;\n        oracleTimeout = oracleTimeout_;\n    }\n\n    /// Can revert, used by other contract functions in order to catch errors\n    /// Should not return FIX_MAX for low\n    /// Should only return FIX_MAX for high if low is 0\n    /// @dev The third (unused) variable is only here for compatibility with Collateral\n    /// @return low {UoA/tok} The low price estimate\n    /// @return high {UoA/tok} The high price estimate\n    function tryPrice()\n        external\n        view\n        virtual\n        returns (\n            uint192 low,\n            uint192 high,\n            uint192\n        )\n    {\n        uint192 p = chainlinkFeed.price(oracleTimeout); // {UoA/tok}\n        uint192 err = p.mul(oracleError, CEIL);\n        // assert(low <= high); obviously true just by inspection\n        return (p - err, p + err, 0);\n    }\n\n    /// Should not revert\n    /// Refresh saved prices\n    function refresh() public virtual override {\n        try this.tryPrice() returns (uint192 low, uint192 high, uint192) {\n            // {UoA/tok}, {UoA/tok}\n            // (0, 0) is a valid price; (0, FIX_MAX) is unpriced\n\n            // Save prices if priced\n            if (high < FIX_MAX) {\n                savedLowPrice = low;\n                savedHighPrice = high;\n                lastSave = uint48(block.timestamp);\n            } else {\n                // must be unpriced\n                assert(low == 0);\n            }\n        } catch (bytes memory errData) {\n            // see: docs/solidity-style.md#Catching-Empty-Data\n            if (errData.length == 0) revert(); // solhint-disable-line reason-string\n        }\n    }\n\n    /// Should not revert\n    /// @dev Should be general enough to not need to be overridden\n    /// @return {UoA/tok} The lower end of the price estimate\n    /// @return {UoA/tok} The upper end of the price estimate\n    function price() public view virtual returns (uint192, uint192) {\n        try this.tryPrice() returns (uint192 low, uint192 high, uint192) {\n            assert(low <= high);\n            return (low, high);\n        } catch (bytes memory errData) {\n            // see: docs/solidity-style.md#Catching-Empty-Data\n            if (errData.length == 0) revert(); // solhint-disable-line reason-string\n            return (0, FIX_MAX);\n        }\n    }\n\n    /// Should not revert\n    /// lotLow should be nonzero when the asset might be worth selling\n    /// @dev Should be general enough to not need to be overridden\n    /// @return lotLow {UoA/tok} The lower end of the lot price estimate\n    /// @return lotHigh {UoA/tok} The upper end of the lot price estimate\n    function lotPrice() external view virtual returns (uint192 lotLow, uint192 lotHigh) {\n        try this.tryPrice() returns (uint192 low, uint192 high, uint192) {\n            // if the price feed is still functioning, use that\n            lotLow = low;\n            lotHigh = high;\n        } catch (bytes memory errData) {\n            // see: docs/solidity-style.md#Catching-Empty-Data\n            if (errData.length == 0) revert(); // solhint-disable-line reason-string\n\n            // if the price feed is broken, use a decayed historical value\n\n            uint48 delta = uint48(block.timestamp) - lastSave; // {s}\n            if (delta <= oracleTimeout) {\n                lotLow = savedLowPrice;\n                lotHigh = savedHighPrice;\n            } else if (delta >= oracleTimeout + priceTimeout) {\n                return (0, 0); // no price after full timeout\n            } else {\n                // oracleTimeout <= delta <= oracleTimeout + priceTimeout\n\n                // {1} = {s} / {s}\n                uint192 lotMultiplier = divuu(oracleTimeout + priceTimeout - delta, priceTimeout);\n\n                // {UoA/tok} = {UoA/tok} * {1}\n                lotLow = savedLowPrice.mul(lotMultiplier);\n                lotHigh = savedHighPrice.mul(lotMultiplier);\n            }\n        }\n        assert(lotLow <= lotHigh);\n    }\n\n    /// @return {tok} The balance of the ERC20 in whole tokens\n    function bal(address account) external view virtual returns (uint192) {\n        return shiftl_toFix(erc20.balanceOf(account), -int8(erc20Decimals));\n    }\n\n    /// @return If the asset is an instance of ICollateral or not\n    function isCollateral() external pure virtual returns (bool) {\n        return false;\n    }\n\n    // solhint-disable no-empty-blocks\n\n    /// Claim rewards earned by holding a balance of the ERC20 token\n    /// DEPRECATED: claimRewards() will be removed from all assets and collateral plugins\n    function claimRewards() external virtual {}\n\n    // solhint-enable no-empty-blocks\n}"
    },
    {
      "filename": "contracts/plugins/assets/RTokenAsset.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.19;\n\nimport \"../../p1/mixins/RecollateralizationLib.sol\";\nimport \"../../interfaces/IMain.sol\";\nimport \"../../interfaces/IRToken.sol\";\nimport \"../../interfaces/IRTokenOracle.sol\";\nimport \"./Asset.sol\";\nimport \"./VersionedAsset.sol\";\n\nuint256 constant ORACLE_TIMEOUT = 15 minutes;\n\n/// Once an RToken gets large enough to get a price feed, replacing this asset with\n/// a simpler one will do wonders for gas usage\n// @dev This RTokenAsset is ONLY compatible with Protocol ^3.0.0\ncontract RTokenAsset is IAsset, VersionedAsset, IRTokenOracle {\n    using FixLib for uint192;\n    using OracleLib for AggregatorV3Interface;\n\n    // Component addresses are not mutable in protocol, so it's safe to cache these\n    IMain public immutable main;\n    IBasketHandler public immutable basketHandler;\n    IAssetRegistry public immutable assetRegistry;\n    IBackingManager public immutable backingManager;\n\n    IERC20Metadata public immutable erc20;\n\n    uint8 public immutable erc20Decimals;\n\n    uint192 public immutable maxTradeVolume; // {UoA}\n\n    // Oracle State\n    CachedOracleData public cachedOracleData;\n\n    /// @param maxTradeVolume_ {UoA} The max trade volume, in UoA\n    constructor(IRToken erc20_, uint192 maxTradeVolume_) {\n        require(address(erc20_) != address(0), \"missing erc20\");\n        require(maxTradeVolume_ > 0, \"invalid max trade volume\");\n\n        main = erc20_.main();\n        basketHandler = main.basketHandler();\n        assetRegistry = main.assetRegistry();\n        backingManager = main.backingManager();\n\n        erc20 = IERC20Metadata(address(erc20_));\n        erc20Decimals = erc20_.decimals();\n        maxTradeVolume = maxTradeVolume_;\n    }\n\n    /// Can revert, used by other contract functions in order to catch errors\n    /// @return low {UoA/tok} The low price estimate\n    /// @return high {UoA/tok} The high price estimate\n    function tryPrice() external view virtual returns (uint192 low, uint192 high) {\n        (uint192 lowBUPrice, uint192 highBUPrice) = basketHandler.price(); // {UoA/BU}\n        assert(lowBUPrice <= highBUPrice); // not obviously true just by inspection\n\n        // Here we take advantage of the fact that we know RToken has 18 decimals\n        // to convert between uint256 an uint192. Fits due to assumed max totalSupply.\n        uint192 supply = _safeWrap(IRToken(address(erc20)).totalSupply());\n\n        if (supply == 0) return (lowBUPrice, highBUPrice);\n\n        // The RToken's price is not symmetric like other assets!\n        // range.bottom is lower because of the slippage from the shortfall\n        BasketRange memory range = basketRange(); // {BU}\n\n        // {UoA/tok} = {BU} * {UoA/BU} / {tok}\n        low = range.bottom.mulDiv(lowBUPrice, supply, FLOOR);\n        high = range.top.mulDiv(highBUPrice, supply, CEIL);\n\n        assert(low <= high); // not obviously true\n    }\n\n    // solhint-disable no-empty-blocks\n    function refresh() public virtual override {\n        // No need to save lastPrice; can piggyback off the backing collateral's lotPrice()\n\n        cachedOracleData.cachedAtTime = 0; // force oracle refresh\n    }\n\n    // solhint-enable no-empty-blocks\n\n    /// Should not revert\n    /// @return {UoA/tok} The lower end of the price estimate\n    /// @return {UoA/tok} The upper end of the price estimate\n    function price() public view virtual returns (uint192, uint192) {\n        try this.tryPrice() returns (uint192 low, uint192 high) {\n            return (low, high);\n        } catch (bytes memory errData) {\n            // see: docs/solidity-style.md#Catching-Empty-Data\n            if (errData.length == 0) revert(); // solhint-disable-line reason-string\n            return (0, FIX_MAX);\n        }\n    }\n\n    /// Should not revert\n    /// lotLow should be nonzero when the asset might be worth selling\n    /// @return lotLow {UoA/tok} The lower end of the lot price estimate\n    /// @return lotHigh {UoA/tok} The upper end of the lot price estimate\n    function lotPrice() external view returns (uint192 lotLow, uint192 lotHigh) {\n        (uint192 buLow, uint192 buHigh) = basketHandler.lotPrice(); // {UoA/BU}\n\n        // Here we take advantage of the fact that we know RToken has 18 decimals\n        // to convert between uint256 an uint192. Fits due to assumed max totalSupply.\n        uint192 supply = _safeWrap(IRToken(address(erc20)).totalSupply());\n\n        if (supply == 0) return (buLow, buHigh);\n\n        BasketRange memory range = basketRange(); // {BU}\n\n        // {UoA/tok} = {BU} * {UoA/BU} / {tok}\n        lotLow = range.bottom.mulDiv(buLow, supply, FLOOR);\n        lotHigh = range.top.mulDiv(buHigh, supply, CEIL);\n        assert(lotLow <= lotHigh); // not obviously true\n    }\n\n    /// @return {tok} The balance of the ERC20 in whole tokens\n    function bal(address account) external view returns (uint192) {\n        // The RToken has 18 decimals, so there's no reason to waste gas here doing a shiftl_toFix\n        // return shiftl_toFix(erc20.balanceOf(account), -int8(erc20Decimals));\n        return _safeWrap(erc20.balanceOf(account));\n    }\n\n    /// @return {s} The timestamp of the last refresh; always 0 since prices are never saved\n    function lastSave() external pure returns (uint48) {\n        return 0;\n    }\n\n    /// @return If the asset is an instance of ICollateral or not\n    function isCollateral() external pure virtual returns (bool) {\n        return false;\n    }\n\n    // solhint-disable no-empty-blocks\n\n    /// Claim rewards earned by holding a balance of the ERC20 token\n    /// DEPRECATED: claimRewards() will be removed from all assets and collateral plugins\n    function claimRewards() external virtual {}\n\n    // solhint-enable no-empty-blocks\n\n    function forceUpdatePrice() external {\n        _updateCachedPrice();\n    }\n\n    function latestPrice() external returns (uint192 rTokenPrice, uint256 updatedAt) {\n        // Situations that require an update, from most common to least common.\n        if (\n            cachedOracleData.cachedAtTime + ORACLE_TIMEOUT <= block.timestamp || // Cache Timeout\n            cachedOracleData.cachedAtNonce != basketHandler.nonce() || // Basket nonce was updated\n            cachedOracleData.cachedTradesNonce != backingManager.tradesNonce() || // New trades\n            cachedOracleData.cachedTradesOpen != backingManager.tradesOpen() // ..or settled\n        ) {\n            _updateCachedPrice();\n        }\n\n        return (cachedOracleData.cachedPrice, cachedOracleData.cachedAtTime);\n    }\n\n    // ==== Private ====\n\n    // Update Oracle Data\n    function _updateCachedPrice() internal {\n        (uint192 low, uint192 high) = price();\n\n        require(low != 0 && high != FIX_MAX, \"invalid price\");\n\n        cachedOracleData = CachedOracleData(\n            (low + high) / 2,\n            block.timestamp,\n            basketHandler.nonce(),\n            backingManager.tradesOpen(),\n            backingManager.tradesNonce()\n        );\n    }\n\n    /// Computationally expensive basketRange calculation; used in price() & lotPrice()\n    function basketRange() private view returns (BasketRange memory range) {\n        BasketRange memory basketsHeld = basketHandler.basketsHeldBy(address(backingManager));\n        uint192 basketsNeeded = IRToken(address(erc20)).basketsNeeded(); // {BU}\n\n        // if (basketHandler.fullyCollateralized())\n        if (basketsHeld.bottom >= basketsNeeded) {\n            range.bottom = basketsNeeded;\n            range.top = basketsNeeded;\n        } else {\n            // Note: Extremely this is extremely wasteful in terms of gas. This only exists so\n            // there is _some_ asset to represent the RToken itself when it is deployed, in\n            // the absence of an external price feed. Any RToken that gets reasonably big\n            // should switch over to an asset with a price feed.\n\n            TradingContext memory ctx;\n\n            ctx.basketsHeld = basketsHeld;\n            ctx.bm = backingManager;\n            ctx.bh = basketHandler;\n            ctx.ar = assetRegistry;\n            ctx.stRSR = main.stRSR();\n            ctx.rsr = main.rsr();\n            ctx.rToken = main.rToken();\n            ctx.minTradeVolume = backingManager.minTradeVolume();\n            ctx.maxTradeSlippage = backingManager.maxTradeSlippage();\n\n            // Calculate quantities\n            Registry memory reg = ctx.ar.getRegistry();\n            ctx.quantities = new uint192[](reg.erc20s.length);\n            for (uint256 i = 0; i < reg.erc20s.length; ++i) {\n                ctx.quantities[i] = ctx.bh.quantityUnsafe(reg.erc20s[i], reg.assets[i]);\n            }\n\n            // will exclude UoA value from RToken balances at BackingManager\n            range = RecollateralizationLibP1.basketRange(ctx, reg);\n        }\n    }\n}"
    }
  ]
}