{
  "Title": "[L-01] Use fixed compiler version",
  "Content": "All in scope contracts use `^0.8.0` as compiler version.\n\nThey should use a fixed version, i.e. `0.8.12`, to make sure the contracts are always compiled with the intended version.  \n\n[https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/amplifier/MuteAmplifier.sol#L2](https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/amplifier/MuteAmplifier.sol#L2)  \n\n[https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/bonds/MuteBond.sol#L2](https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/bonds/MuteBond.sol#L2)  \n\n[https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/dao/dMute.sol#L2](https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/dao/dMute.sol#L2)  \n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2023-03-mute-switch-versus-contest",
  "Code": [
    {
      "filename": "contracts/amplifier/MuteAmplifier.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../libraries/SafeMath.sol';\nimport '../libraries/TransferHelper.sol';\nimport '../libraries/Ownable.sol';\nimport '../interfaces/IERC20.sol';\nimport '../interfaces/IMuteSwitchPairDynamic.sol';\n\n\n/// @notice Stake Token-Token Mute LP tokens for Token rewards\ncontract MuteAmplifier is Ownable{\n    using SafeMath for uint256;\n    using TransferHelper for address;\n\n    /* ======== EVENTS ======== */\n    event Deposit(uint256 totalRewards, uint256 startTime, uint256 endTime);\n    event Stake(address indexed staker, uint256 lpTokenIn);\n    event Payout(address indexed staker, uint256 reward, uint256 remainder);\n    event FeePayout(address indexed staker, uint256 fee0, uint256 fee1);\n    event Withdraw(address indexed staker, uint256 lpTokenOut, uint256 remainder);\n    event Refresh(uint256 totalRewards, uint256 startTime, uint256 endTime);\n\n\n    /* ======== STATE VARIABLES ======== */\n\n    address public lpToken; // MuteSwitchPairDynamic token\n    address public muteToken; // mute token\n    address public dToken; // dmute contract\n\n    uint256 public totalStakers; // total # of individual stakers\n    uint256 public totalRewards; // total amount of mute emissions\n    uint256 public totalFees0; // total fees accumulated for the lp token0\n    uint256 public totalFees1; // total fees accumulated for the lp token1\n    uint256 public totalReclaimed; // total amount of mute reclaimed to treasury\n    uint256 public totalClaimedRewards; // total amount of mute claimed by stakers\n    uint256 public totalClaimedFees0; // total amount of lp token0 fees claimed by stakers\n    uint256 public totalClaimedFees1; // total amount of lp token1 fees claimed by stakers\n\n    uint256 public startTime; // when to start emissions\n    uint256 public firstStakeTime; // timestamp of first deposit\n    uint256 public endTime; // when to end emissions\n\n    uint256 private _totalStakeLpToken; // total amount of lp tokens staked\n    uint256 private _totalWeight; // total weight of rewards to lp tokens\n    uint256 private _totalWeightFee0; // total weight of lp token0 fees to lp tokens\n    uint256 private _totalWeightFee1; // total weight of lp token1 fees to lp tokens\n\n    uint256 private _mostRecentValueCalcTime; // latest update modifier timestamp\n\n    uint256 public _stakeDivisor; // divisor set in place for modification of reward boost\n\n    uint256 public management_fee; // lp withdrawal fee\n    address public treasury; // address that receives the lp withdrawal fee\n\n    uint private unlocked = 1;\n\n    mapping(address => uint256) public userClaimedRewards; // total mute rewards users have claimed\n\n    mapping(address => uint256) private _userStakedLpToken; // total lp tokens a user has deposited\n    mapping(address => uint256) private _userWeighted; // a users weight of rewards to lp tokens at the moment of a users deposit\n    mapping(address => uint256) private _userWeightedFee0; // a users weight of lp token0 fees to lp tokens at the moment of a users deposit\n    mapping(address => uint256) private _userWeightedFee1; // a users weight of lp token1 fees to lp tokens at the moment of a users deposit\n\n    mapping(address => uint256) private _userAccumulated; // cache of rewards users have not yet pulled out yet\n    mapping(address => uint256) private _userStakedBlock; // the latest block a user deposited - used for dMute multipler\n\n    // contract view info for a specific user\n    struct DripInfo {\n      uint256 perSecondReward;\n      uint256 totalLP;\n      uint256 multiplier_current;\n      uint256 multiplier_last;\n      uint256 currentReward;\n      uint256 fee0;\n      uint256 fee1;\n    }\n\n    /* ======== MODIFIERS ======== */\n\n    modifier nonReentrant() {\n        require(unlocked == 1, 'ReentrancyGuard: reentrant call');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    modifier update() {\n        if (_mostRecentValueCalcTime == 0) {\n            _mostRecentValueCalcTime = firstStakeTime;\n        }\n\n        uint256 totalCurrentStake = totalStake();\n\n        if (totalCurrentStake > 0 && _mostRecentValueCalcTime < endTime) {\n            uint256 value = 0;\n            uint256 sinceLastCalc = block.timestamp.sub(_mostRecentValueCalcTime);\n            uint256 perSecondReward = totalRewards.div(endTime.sub(firstStakeTime));\n\n            if (block.timestamp < endTime) {\n                value = sinceLastCalc.mul(perSecondReward);\n            } else {\n                uint256 sinceEndTime = block.timestamp.sub(endTime);\n                value = (sinceLastCalc.sub(sinceEndTime)).mul(perSecondReward);\n            }\n\n            _totalWeight = _totalWeight.add(value.mul(10**18).div(totalCurrentStake));\n\n            _mostRecentValueCalcTime = block.timestamp;\n\n            (uint fee0, uint fee1) = IMuteSwitchPairDynamic(lpToken).claimFees();\n\n            _totalWeightFee0 = _totalWeightFee0.add(fee0.mul(10**18).div(totalCurrentStake));\n            _totalWeightFee1 = _totalWeightFee1.add(fee1.mul(10**18).div(totalCurrentStake));\n\n            totalFees0 = totalFees0.add(fee0);\n            totalFees1 = totalFees1.add(fee1);\n        }\n\n        _;\n    }\n\n    /* ======== CONSTRUCTOR ======== */\n\n    /**\n     *  @notice sets the amplifier pool variables on launch\n     *  @param _lpToken address\n     *  @param _muteToken address\n     *  @param _dToken address\n     *  @param divisor uint\n     *  @param _mgmt_fee uint\n     *  @param _treasury address\n     */\n    constructor (address _lpToken, address _muteToken, address _dToken, uint256 divisor, uint256 _mgmt_fee, address _treasury) {\n        require(divisor >= 10 ** 18, \"MuteAmplifier: invalid _stakeDivisor\");\n        require(_lpToken != address(0), \"MuteAmplifier: invalid lpToken\");\n        require(_muteToken != address(0), \"MuteAmplifier: invalid muteToken\");\n        require(_dToken != address(0), \"MuteAmplifier: invalid dToken\");\n        require(_mgmt_fee >= 0 && _mgmt_fee <= 1000, \"MuteAmplifier: invalid _mgmt_fee\");\n        require(_treasury != address(0), \"MuteAmplifier: invalid treasury\");\n\n        lpToken = _lpToken;\n        muteToken = _muteToken;\n        dToken = _dToken;\n        _stakeDivisor = divisor;\n        management_fee = _mgmt_fee; //bps 10k\n        treasury = _treasury;\n\n        TransferHelper.safeApprove(muteToken, _dToken, type(uint256).max);\n    }\n\n\n    /* ======== OWNER FUNCTIONS ======== */\n\n    /**\n     *  @notice sets the start and end time of this pool. Rewards must be sent in prior to calling this function. Can only be called once\n     *  @param _startTime address\n     *  @param _endTime address\n     */\n    function initializeDeposit(uint256 _startTime, uint256 _endTime) external virtual onlyOwner {\n        require(startTime == 0, \"MuteAmplifier::deposit: already received deposit\");\n        require(_startTime >= block.timestamp, \"MuteAmplifier::deposit: start time must be in future\");\n        require(_endTime > _startTime, \"MuteAmplifier::deposit: end time must after start time\");\n\n        totalRewards = IERC20(muteToken).balanceOf(address(this));\n        require(totalRewards > 0, \"MuteAmplifier::deposit: no rewards\");\n\n        startTime = _startTime;\n        endTime = _endTime;\n\n        emit Deposit(totalRewards, _startTime, _endTime);\n    }\n\n    /**\n     *  @notice withdraws tokens not meant to be in this contract\n     *  @param tokenToRescue address\n     *  @param to address\n     *  @param amount uint256\n     */\n    function rescueTokens(address tokenToRescue, address to, uint256 amount) external virtual onlyOwner nonReentrant {\n        if (tokenToRescue == lpToken) {\n            require(amount <= IERC20(lpToken).balanceOf(address(this)).sub(_totalStakeLpToken),\n                \"MuteAmplifier::rescueTokens: that Token-Eth belongs to stakers\"\n            );\n        } else if (tokenToRescue == muteToken) {\n            if (totalStakers > 0) {\n                require(amount <= IERC20(muteToken).balanceOf(address(this)).sub(totalRewards.sub(totalClaimedRewards)),\n                    \"MuteAmplifier::rescueTokens: that muteToken belongs to stakers\"\n                );\n            }\n        }\n\n        IERC20(tokenToRescue).transfer(to, amount);\n    }\n\n\n    /* ======== USER FUNCTIONS ======== */\n\n    /**\n     *  @notice stakes a certain amount of lp tokens\n     *  @param lpTokenIn uint\n     */\n    function stake(uint256 lpTokenIn) external virtual update nonReentrant {\n        require(lpTokenIn > 0, \"MuteAmplifier::stake: missing stake\");\n        require(block.timestamp >= startTime && startTime !=0, \"MuteAmplifier::stake: not live yet\");\n        require(IERC20(muteToken).balanceOf(address(this)) > 0, \"MuteAmplifier::stake: no reward balance\");\n\n        if (firstStakeTime == 0) {\n            firstStakeTime = block.timestamp;\n        } else {\n            require(block.timestamp < endTime, \"MuteAmplifier::stake: staking is over\");\n        }\n\n        lpToken.safeTransferFrom(msg.sender, address(this), lpTokenIn);\n\n        if (totalUserStake(msg.sender) == 0) {\n            totalStakers = totalStakers.add(1);\n        }\n\n        _stake(lpTokenIn, msg.sender);\n\n        emit Stake(msg.sender, lpTokenIn);\n    }\n\n    /**\n     * @notice  Transfer reward tokens from contract to sender, withdraw lp and apply tax\n     */\n    function withdraw() external virtual update nonReentrant returns (uint256 lpTokenOut, uint256 reward, uint256 remainder, uint256 fee0, uint256 fee1) {\n        totalStakers = totalStakers.sub(1);\n\n        (lpTokenOut, reward, remainder, fee0, fee1) = _applyReward(msg.sender);\n\n        if (lpTokenOut > 0) {\n            uint256 fee = lpTokenOut.mul(management_fee).div(10000);\n            lpToken.safeTransfer(msg.sender, lpTokenOut.sub(fee));\n            lpToken.safeTransfer(treasury, fee);\n        }\n\n        // remaining allocated rewards sent back\n        if(remainder > 0){\n          totalReclaimed = totalReclaimed.add(remainder);\n          IERC20(muteToken).transfer(treasury, remainder);\n        }\n        // payout rewards\n        if (reward > 0) {\n            uint256 week_time = 60 * 60 * 24 * 7;\n            IDMute(dToken).LockTo(reward, week_time ,msg.sender);\n\n            userClaimedRewards[msg.sender] = userClaimedRewards[msg.sender].add(\n                reward\n            );\n            totalClaimedRewards = totalClaimedRewards.add(reward);\n\n            emit Payout(msg.sender, reward, remainder);\n        }\n\n        // payout fee0 fee1\n        if ((fee0 > 0 || fee1 > 0) && fee0 <= totalFees0 && fee1 <= totalFees1) {\n            address(IMuteSwitchPairDynamic(lpToken).token0()).safeTransfer(msg.sender, fee0);\n            address(IMuteSwitchPairDynamic(lpToken).token1()).safeTransfer(msg.sender, fee1);\n\n            totalClaimedFees0 = totalClaimedFees0.add(fee0);\n            totalClaimedFees1 = totalClaimedFees1.add(fee1);\n\n            emit FeePayout(msg.sender, fee0, fee1);\n        }\n\n\n        emit Withdraw(msg.sender, lpTokenOut, remainder);\n    }\n\n    /**\n     * @notice  Transfer reward tokens from contract to sender, restake lp\n     */\n    function payout() external virtual update nonReentrant returns (uint256 reward) {\n        require(block.timestamp < endTime, \"MuteAmplifier::payout: withdraw instead\");\n\n        (uint256 lpTokenOut, uint256 _reward, uint256 remainder, uint fee0, uint fee1) = _applyReward(msg.sender);\n\n        reward = _reward;\n        // remaining allocated rewards sent back\n        if(remainder > 0){\n          totalReclaimed = totalReclaimed.add(remainder);\n          IERC20(muteToken).transfer(treasury, remainder);\n        }\n        // payout rewards\n        if (reward > 0) {\n            uint256 week_time = 1 weeks;\n            IDMute(dToken).LockTo(reward, week_time ,msg.sender);\n\n            userClaimedRewards[msg.sender] = userClaimedRewards[msg.sender].add(\n                reward\n            );\n            totalClaimedRewards = totalClaimedRewards.add(reward);\n        }\n\n        // payout fee0 fee1\n        if ((fee0 > 0 || fee1 > 0) && fee0 <= totalFees0 && fee1 <= totalFees1) {\n            address(IMuteSwitchPairDynamic(lpToken).token0()).safeTransfer(msg.sender, fee0);\n            address(IMuteSwitchPairDynamic(lpToken).token1()).safeTransfer(msg.sender, fee1);\n\n            totalClaimedFees0 = totalClaimedFees0.add(fee0);\n            totalClaimedFees1 = totalClaimedFees1.add(fee1);\n\n            emit FeePayout(msg.sender, fee0, fee1);\n        }\n\n        _stake(lpTokenOut, msg.sender);\n\n        emit Payout(msg.sender, _reward, remainder);\n    }\n\n    /**\n     *  @notice stakes a certain amount of lp tokens to an account\n     *  @param lpTokenIn uint\n     *  @param account address\n     */\n    function _stake(uint256 lpTokenIn, address account) private {\n        uint256 addBackLpToken;\n\n        if (totalUserStake(account) > 0) {\n            (uint256 lpTokenOut, uint256 reward, uint256 remainder, uint fee0, uint fee1) = _applyReward(account);\n            addBackLpToken = lpTokenOut;\n            _userStakedLpToken[account] = lpTokenOut;\n            _userAccumulated[account] = reward;\n\n            // remaining allocated rewards sent back\n            if(remainder > 0){\n              totalReclaimed = totalReclaimed.add(remainder);\n              IERC20(muteToken).transfer(treasury, remainder);\n            }\n\n            // payout fee0 fee1\n            if ((fee0 > 0 || fee1 > 0) && fee0 <= totalFees0 && fee1 <= totalFees1) {\n                address(IMuteSwitchPairDynamic(lpToken).token0()).safeTransfer(account, fee0);\n                address(IMuteSwitchPairDynamic(lpToken).token1()).safeTransfer(account, fee1);\n\n                totalClaimedFees0 = totalClaimedFees0.add(fee0);\n                totalClaimedFees1 = totalClaimedFees1.add(fee1);\n\n                emit FeePayout(account, fee0, fee1);\n            }\n        }\n\n        _userStakedLpToken[account] = _userStakedLpToken[account].add(\n            lpTokenIn\n        );\n\n        _userWeighted[account] = _totalWeight;\n        _userWeightedFee0[account] = _totalWeightFee0;\n        _userWeightedFee1[account] = _totalWeightFee1;\n\n        _userStakedBlock[account] = block.number;\n\n        _totalStakeLpToken = _totalStakeLpToken.add(lpTokenIn);\n\n        if (addBackLpToken > 0) {\n            _totalStakeLpToken = _totalStakeLpToken.add(addBackLpToken);\n        }\n    }\n\n    /**\n     *  @notice applys the current reward for an account and resets its state\n     *  @param account address\n     */\n    function _applyReward(address account) private returns (uint256 lpTokenOut, uint256 reward, uint256 remainder, uint256 fee0, uint256 fee1) {\n        lpTokenOut = totalUserStake(account);\n        require(lpTokenOut > 0, \"MuteAmplifier::_applyReward: no coins staked\");\n\n        // current rewards based on multiplier\n        reward = lpTokenOut.mul(_totalWeight.sub(_userWeighted[account])).div(calculateMultiplier(account, true));\n        // max possible rewards\n        remainder = lpTokenOut.mul(_totalWeight.sub(_userWeighted[account])).div(10**18);\n        // calculate left over rewards\n        remainder = remainder.sub(reward);\n        // add back any accumulated rewards\n        reward = reward.add(_userAccumulated[account]);\n\n        fee0 = lpTokenOut.mul(_totalWeightFee0.sub(_userWeightedFee0[account])).div(10**18);\n\n        fee1 = lpTokenOut.mul(_totalWeightFee1.sub(_userWeightedFee1[account])).div(10**18);\n\n        _totalStakeLpToken = _totalStakeLpToken.sub(lpTokenOut);\n\n        _userStakedLpToken[account] = 0;\n\n        _userAccumulated[account] = 0;\n    }\n\n    /* ======== HELPER FUNCTIONS ======== */\n\n    /**\n     *  @notice returns total lp tokens staked\n     */\n    function totalStake() public view returns (uint256 total) {\n        total = _totalStakeLpToken;\n    }\n\n    /**\n     *  @notice returns total lp tokens staked for a certain user\n     */\n    function totalUserStake(address user) public view returns (uint256 total) {\n        total = _userStakedLpToken[user];\n    }\n\n    /**\n     *  @notice returns the latest block a user staked at\n     */\n    function userStakedBlock(address user) external view returns (uint256 num) {\n        num = _userStakedBlock[user];\n    }\n\n    /**\n     *  @notice returns drip info for certain user\n     *  @param user address\n     */\n    function dripInfo(address user) external view returns (DripInfo memory info) {\n\n        info.perSecondReward = totalRewards.div(endTime.sub(firstStakeTime));\n        info.totalLP = _totalStakeLpToken;\n        info.multiplier_current = calculateMultiplier(user, false);\n        info.multiplier_last = calculateMultiplier(user, true);\n\n\n        uint256 totalCurrentStake = totalStake();\n        if (totalCurrentStake > 0 && _mostRecentValueCalcTime < endTime) {\n            uint256 value = 0;\n            uint256 sinceLastCalc = block.timestamp.sub(_mostRecentValueCalcTime);\n\n            if (block.timestamp < endTime) {\n                value = sinceLastCalc.mul(info.perSecondReward);\n            } else {\n                uint256 sinceEndTime = block.timestamp.sub(endTime);\n                value = (sinceLastCalc.sub(sinceEndTime)).mul(info.perSecondReward);\n            }\n\n            uint256 totWeightLocal = _totalWeight.add(value.mul(10**18).div(totalCurrentStake));\n\n            (uint fee0, uint fee1) = IMuteSwitchPairDynamic(lpToken).claimFeesView(user);\n\n            uint256 _totalWeightFee0Local = _totalWeightFee0.add(fee0.mul(10**18).div(totalCurrentStake));\n            uint256 _totalWeightFee1Local = _totalWeightFee1.add(fee1.mul(10**18).div(totalCurrentStake));\n\n            // current rewards based on multiplier\n            info.currentReward = totalUserStake(user).mul(totWeightLocal.sub(_userWeighted[user])).div(info.multiplier_last);\n            // add back any accumulated rewards\n            info.currentReward = info.currentReward.add(_userAccumulated[user]);\n\n\n            info.fee0 = totalUserStake(user).mul(_totalWeightFee0Local.sub(_userWeightedFee0[user])).div(10**18);\n            info.fee1 = totalUserStake(user).mul(_totalWeightFee1Local.sub(_userWeightedFee1[user])).div(10**18);\n\n        } else {\n          // current rewards based on multiplier\n          info.currentReward = totalUserStake(user).mul(_totalWeight.sub(_userWeighted[user])).div(info.multiplier_last);\n          // add back any accumulated rewards\n          info.currentReward = info.currentReward.add(_userAccumulated[user]);\n        }\n\n    }\n\n\n\n    /**\n     *  @notice returns the multiplier for a certain user based on their dMute holdings to pool ratio.\n     *  toggling enforce shows the account difference betweeen its staked multiplier and current\n     *  e.g stakedivisor of 2e18 = 50% starting point\n     *  1e18 = max reward value\n     *  2e18 - (((2e18- 1e18) * (5000 * 10e18 / 10000) / 10e18)) = 1.5e18\n     *  @param account address\n     *  @param enforce bool\n     */\n    function calculateMultiplier(address account, bool enforce) public view returns (uint256) {\n        require(account != address(0), \"MuteAmplifier::calculateMultiplier: missing account\");\n\n        uint256 accountDTokenValue;\n\n        // zkSync block.number = L1 batch number. This at times is the same for a few minutes. To avoid breaking the call to the dMute contract\n        // we take the previous block into account\n        uint256 staked_block =  _userStakedBlock[account] == block.number ? _userStakedBlock[account] - 1 : _userStakedBlock[account];\n\n        if(staked_block != 0 && enforce)\n          accountDTokenValue = IDMute(dToken).getPriorVotes(account, staked_block);\n        else\n          accountDTokenValue = IDMute(dToken).getPriorVotes(account, block.number - 1);\n\n        if(accountDTokenValue == 0){\n          return _stakeDivisor;\n        }\n\n        uint256 stakeDifference = _stakeDivisor.sub(10 ** 18);\n\n        // ratio of dMute holdings to pool\n        uint256 tokenRatio = accountDTokenValue.mul(10**18).div(totalRewards);\n\n        stakeDifference = stakeDifference.mul(clamp_value(tokenRatio, 10**18)).div(10**18);\n\n        return _stakeDivisor.sub(stakeDifference);\n    }\n\n\n\n\n    /**\n     *  @notice returns the multiplier for a certain user based on their dMute underlying usd value their staked lp usd value.\n     *  toggling enforce shows the account difference betweeen its staked multiplier and current\n     *  e.g stakedivisor of 2e18 = 50% starting point\n     *  1e18 = max reward value\n     *  2e18 - (((2e18- 1e18) * (5000 * 10e18 / 10000) / 10e18)) = 1.5e18\n     *  @param account address\n     *  @param enforce bool\n     */\n\n    /*\n    function calculateMultiplier(address account, bool enforce) public view returns (uint256) {\n        require(account != address(0), \"MuteAmplifier::calculateMultiplier: missing account\");\n\n        uint ratio;\n\n        // zkSync block.number = L1 batch number. This at times is the same for a few minutes. To avoid breaking the call to the dMute contract\n        // we take the previous block into account\n        uint256 staked_block =  _userStakedBlock[account] == block.number ? _userStakedBlock[account] - 1 : _userStakedBlock[account];\n\n        if(staked_block!= 0 && enforce)\n          ratio = IAmplifierOracleHub().holdingsToMuteRatio(account, _lpToken, _userStakedLpToken[account], staked_block);\n        else\n          ratio = IAmplifierOracleHub().holdingsToMuteRatio(account, _lpToken, _userStakedLpToken[account], block.number - 1);\n\n        if(ratio == 0){\n          return _stakeDivisor;\n        }\n\n        uint256 stakeDifference = _stakeDivisor.sub(10 ** 18).mul(clamp_value(ratio.div(10**18), 10**18)).div(10**18);\n\n        return _stakeDivisor.sub(stakeDifference);\n    }\n    */\n\n\n    /**\n     *  @notice returns the clamped value based on the max clamp limit\n     *  @param min uint\n     *  @param max uint\n     */\n    function clamp_value(uint min, uint max) pure public returns (uint) {\n        if (min < max) {\n            return min;\n        } else {\n            return max;\n        }\n    }\n}\n\n\ninterface IDMute {\n    function balanceOf(address account) external view returns(uint256 amount);\n    function getPriorVotes(address account, uint256 block) external view returns(uint256 amount);\n    function LockTo(uint256 _amount, uint256 _lock_time, address to) external;\n}"
    },
    {
      "filename": "contracts/bonds/MuteBond.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../libraries/SafeMath.sol';\nimport '../libraries/TransferHelper.sol';\n\ncontract MuteBond {\n    using SafeMath for uint;\n\n    /* ======== EVENTS ======== */\n\n    event BondCreated(uint deposit, uint payout, address depositor, uint time);\n    event BondPriceChanged(uint internalPrice, uint debtRatio);\n    event MaxPriceChanged(uint _price);\n    event MaxPayoutChanged(uint _price);\n    event EpochDurationChanged(uint _payout);\n    event BondLockTimeChanged(uint _duration);\n    event StartPriceChanged(uint _lock);\n\n     /* ======== STATE VARIABLES ======== */\n\n    address immutable private muteToken; // token paid for principal\n    address immutable private dMuteToken;\n    address immutable private lpToken; // inflow token\n    ITreasury immutable private customTreasury; // pays for and receives principal\n    uint public bond_time_lock = 7 days; // length of lockup in dMute for bonds\n\n    uint public totalPayoutGiven; // total amount of mute paid\n    uint public totalDebt; // total amount of LP collected\n\n    uint public epochDuration = 7 days; // the length of an epoch from getting from startPrice  to maxPrice\n    uint public maxPrice; // max limit price for the LP token (LP:mute ratio)\n    uint public startPrice; // start price of the LP token (LP:mute ratio)\n    uint public maxPayout; // max amount of mute tokens to sell in each epoch\n    uint public epochStart; // timestamp of the current epoch start\n    uint public epoch; // amount of cycles for bonds so far\n\n    BondTerms[] public terms; // identifies the terms for a bond in a given epoch\n    Bonds[] public bonds; // stores individual deposits\n\n    // Info for bond epochs\n    struct BondTerms {\n        uint bondTotal; // amount of tokens bonded so far\n        uint payoutTotal;\n        uint lastTimestamp;\n    }\n\n    // Info for a single depositors bond info\n    struct Bonds {\n        uint value; //\n        uint payout; //\n        address depositor; //\n        uint timestamp;\n    }\n\n\n\n    /* ======== CONSTRUCTOR ======== */\n\n    /**\n     *  @notice initializes the bond\n     *  @param _customTreasury address\n     *  @param _lpToken address\n     *  @param _dmuteToken address\n     *  @param _maxPrice uint\n     *  @param _startPrice uint\n     *  @param _maxPayout uint\n     */\n    constructor(address _customTreasury, address _lpToken, address _dmuteToken,\n                uint _maxPrice, uint _startPrice, uint _maxPayout) {\n        require( _customTreasury != address(0) && _lpToken != address(0));\n        customTreasury = ITreasury( _customTreasury );\n        muteToken = ITreasury(_customTreasury).payoutToken();\n        dMuteToken = _dmuteToken;\n\n        lpToken = _lpToken;\n\n        // approve lock token to spend payout\n        TransferHelper.safeApprove(muteToken, dMuteToken, type(uint256).max);\n\n\n        require(_maxPrice >= _startPrice, \"starting price < min\");\n\n        epochStart = block.timestamp;\n        maxPrice = _maxPrice;\n        startPrice = _startPrice;\n        maxPayout = _maxPayout;\n\n        terms.push(BondTerms(0,0,0));\n    }\n\n\n    /* ======== OWNER FUNCTIONS ======== */\n\n    /**\n     *  @notice sets the max limit price for the LP token\n     *  @param _price uint\n     */\n    function setMaxPrice(uint _price) external {\n        require(msg.sender == customTreasury.owner());\n        maxPrice = _price;\n        emit MaxPriceChanged(_price);\n    }\n\n    /**\n     *  @notice sets the start price for the LP token\n     *  @param _price uint\n     */\n    function setStartPrice(uint _price) external {\n        require(msg.sender == customTreasury.owner());\n        startPrice = _price;\n        emit StartPriceChanged(_price);\n    }\n\n    /**\n     *  @notice sets the max amount of mute tokens to sell in each epoch\n     *  @param _payout uint\n     */\n    function setMaxPayout(uint _payout) external {\n        require(msg.sender == customTreasury.owner());\n        maxPayout = _payout;\n        emit MaxPayoutChanged(_payout);\n    }\n\n    /**\n     *  @notice sets the length of bond epoch\n     *  @param _duration uint\n     */\n    function setEpochDuration(uint _duration) external {\n        require(msg.sender == customTreasury.owner());\n        epochDuration = _duration;\n        emit EpochDurationChanged(_duration);\n    }\n\n    /**\n     *  @notice sets the length of lockup for mute purchases in dMute\n     *  @param _lock uint\n     */\n    function setBondTimeLock(uint _lock) external {\n        require(msg.sender == customTreasury.owner());\n        bond_time_lock = _lock;\n        emit BondLockTimeChanged(_lock);\n    }\n\n    /* ======== USER FUNCTIONS ======== */\n\n    /**\n     *  @notice purchase a bond with LP, bump bond price back by 5% after purchase based on current delta\n     *  @param value uint\n     *  @param _depositor address\n     *  @param max_buy bool\n     */\n    function deposit(uint value, address _depositor, bool max_buy) external returns (uint) {\n        // amount of mute tokens\n        uint payout = payoutFor( value );\n        if(max_buy == true){\n          value = maxPurchaseAmount();\n          payout = maxDeposit();\n        } else {\n          // safety checks for custom purchase\n          require( payout >= ((10**18) / 100), \"Bond too small\" ); // must be > 0.01 payout token ( underflow protection )\n          require( payout <= maxPayout, \"Bond too large\"); // size protection because there is no slippage\n          require( payout <= maxDeposit(), \"Deposit too large\"); // size protection because there is no slippage\n        }\n\n\n        // total debt is increased\n        totalDebt = totalDebt.add( value );\n        totalPayoutGiven = totalPayoutGiven.add(payout); // total payout increased\n\n        customTreasury.sendPayoutTokens(payout);\n        TransferHelper.safeTransferFrom(lpToken, msg.sender, address(customTreasury), value ); // transfer principal bonded to custom treasury\n\n        // indexed events are emitted\n        emit BondCreated(value, payout, _depositor, block.timestamp);\n\n        bonds.push(Bonds(value, payout, _depositor, block.timestamp));\n        // redeem bond for user, mint dMute tokens for duration of vest period\n        IDMute(dMuteToken).LockTo(payout, bond_time_lock, _depositor);\n\n        terms[epoch].payoutTotal = terms[epoch].payoutTotal + payout;\n        terms[epoch].bondTotal = terms[epoch].bondTotal + value;\n        terms[epoch].lastTimestamp = block.timestamp;\n\n        // adjust price by a ~5% premium of delta\n        uint timeElapsed = block.timestamp - epochStart;\n        epochStart = epochStart.add(timeElapsed.mul(5).div(100));\n        // safety check\n        if(epochStart >= block.timestamp)\n          epochStart = block.timestamp;\n\n        // exhausted this bond, issue new one\n        if(terms[epoch].payoutTotal == maxPayout){\n            terms.push(BondTerms(0,0,0));\n            epochStart = block.timestamp;\n            epoch++;\n        }\n\n        return payout;\n    }\n\n    /* ======== HELPER FUNCTIONS ======== */\n\n\n    /**\n     *  @notice returns bond info for the current epoch and global values\n     */\n    function bondInfo() external view returns (uint totDebt, uint totPayout, uint price, uint maxDep, uint maxPurchase, uint maxPay) {\n        totDebt = totalDebt;\n        totPayout = totalPayoutGiven;\n        price = bondPrice();\n        maxDep = maxDeposit();\n        maxPurchase = maxPurchaseAmount();\n        maxPay = maxPayout;\n    }\n\n    /**\n     *  @notice returns current epoch\n     */\n    function currentEpoch() public view returns (uint) {\n        return epoch;\n    }\n\n    /**\n     *  @notice returns current bond price\n     */\n    function bondPrice() public view returns (uint) {\n        uint timeElapsed = block.timestamp - epochStart;\n        uint priceDelta = maxPrice - startPrice;\n\n        if(timeElapsed > epochDuration)\n          timeElapsed = epochDuration;\n\n        return timeElapsed.mul(priceDelta).div(epochDuration).add(startPrice);\n    }\n\n    /**\n     *  @notice returns bond price for amount\n     *  @param _am uint\n     */\n    function payoutFor(uint _am) public view returns (uint) {\n        return bondPrice().mul(_am).div(10**18);\n    }\n\n    /**\n     *  @notice returns max amount of lp tokens receivable in current bond epoch\n     */\n    function maxPurchaseAmount() public view returns (uint) {\n        return maxDeposit().mul(10**18).div(bondPrice());\n    }\n\n    /**\n     *  @notice returns remaining mute tokens in current bond epoch\n     */\n    function maxDeposit() public view returns (uint) {\n        return maxPayout.sub(terms[epoch].payoutTotal);\n    }\n\n}\n\ninterface ITreasury {\n    function sendPayoutTokens(uint _amountPayoutToken) external;\n    function valueOfToken( address _principalTokenAddress, uint _amount ) external view returns ( uint value_ );\n    function payoutToken() external view returns (address);\n    function owner() external view returns (address);\n}\n\ninterface IDMute {\n  function LockTo(uint256 _amount, uint256 _lock_time, address to) external;\n}"
    },
    {
      "filename": "contracts/dao/dMute.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../interfaces/IERC20.sol';\nimport '../libraries/SafeMath.sol';\nimport './dSoulBound.sol';\n\n/// @notice Mute DAO token, untransferrable\ncontract dMute is dSoulBound {\n    using SafeMath for uint;\n\n    address public MuteToken;\n\n    struct UserLockInfo {\n      uint256 amount;\n      uint256 time;\n      uint256 tokens_minted;\n    }\n\n    mapping(address => UserLockInfo[]) public _userLocks;\n\n    uint private unlocked = 1;\n\n    event LockEvent(address to, uint256 lockAmount, uint256 mintedAmount, uint256 totalTime);\n    event RedeemEvent(address to, uint256 unlockedAmount, uint256 burnAmount);\n\n    modifier nonReentrant() {\n        require(unlocked == 1, 'dMute::ReentrancyGuard: REENTRANT_CALL');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    /// @dev Expects a LP token address & the base reward muteToken address\n    constructor (address _muteToken) {\n        require(_muteToken != address(0), \"MuteAmplifier: invalid muteToken\");\n        MuteToken = _muteToken;\n    }\n\n    /*\n    function lockBonus(uint256 lock_time) internal view returns (uint256){\n        uint256 week_time = 60 * 60 * 24 * 7;\n        uint256 max_lock = week_time.mul(52 * 2); // 2 years\n\n        return lock_time.mul(10**18).div(max_lock).mul(10);\n    }\n    */\n\n    function timeToTokens(uint256 _amount, uint256 _lock_time) internal pure returns (uint256){\n        uint256 week_time = 1 weeks;\n        uint256"
    }
  ]
}