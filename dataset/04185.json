{
  "Title": "No limit on the number of loop iterations",
  "Content": "\n- [strategy-cmpd-dai-v1.sol#L287](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/compound/strategy-cmpd-dai-v1.sol#L287)\n\n    With small `_borrowAndSupply` and `supplied` values and a large `_supplyAmount` value, there will come a point when there will be so many iterations that there is not enough gas to record changes.\n    It is recommended to check for the expected number of iterations before starting the loop. \n    This problem will not stop the work of the smart contract, because in the `leverageUntil` function, the key parameter of the `_supplyAmount` cycle can be set as a parameter when calling this function, and by selecting the required value, it will be possible to execute the functionality.\n\n- [strategy-cmpd-dai-v1.sol#L320](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/compound/strategy-cmpd-dai-v1.sol#L320)\n\n    With small `_supplyAmount` and `_redeemAndRepay` values and a large `supplied` value, there will come a point when there will be so many iterations that there is not enough gas to record changes. It is recommended to check for the expected number of iterations before starting the loop. \n    This problem will not stop the work of the smart contract, because in the `deleverageUntil` function, the key parameter of the `_supplyAmount` cycle can be set as a parameter when calling this function, and by selecting the required value, it will be possible to execute the functionality.\n\nStatus: *Acknowledged.*\n\nClient's comment: *The team is aware of this issue, but there is already a mitigation strategy. We have the option to change `colFactorLeverageBuffer` and/or `colFactorSyncBuffer` to be of a higher or lower value to avoid the out of gas problem. Additionally, we can leverage or deleverage until a specified supply amount with the `deleverageUntil` and `leverageUntil` functions. Based on the contract`s current operation, it consumes 1.8 million gas for leveraging or deleveraging to the max, so there is already a substantial buffer from the max limit of 12 million gas.*\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/strategies/compound/strategy-cmpd-dai-v1.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\nimport \"../../lib/erc20.sol\";\nimport \"../../lib/safe-math.sol\";\nimport \"../../lib/exponential.sol\";\n\nimport \"../strategy-base.sol\";\n\nimport \"../../interfaces/jar.sol\";\nimport \"../../interfaces/uniswapv2.sol\";\nimport \"../../interfaces/controller.sol\";\nimport \"../../interfaces/compound.sol\";\n\ncontract StrategyCmpdDaiV1 is StrategyBase, Exponential {\n    address\n        public constant comptroller = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n    address public constant lens = 0xd513d22422a3062Bd342Ae374b4b9c20E0a9a074;\n    address public constant dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address public constant comp = 0xc00e94Cb662C3520282E6f5717214004A7f26888;\n    address public constant cdai = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\n    address public constant cether = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n\n    // Require a 0.1 buffer between\n    // market collateral factor and strategy's collateral factor\n    // when leveraging\n    uint256 colFactorLeverageBuffer = 100;\n    uint256 colFactorLeverageBufferMax = 1000;\n\n    // Allow a 0.05 buffer\n    // between market collateral factor and strategy's collateral factor\n    // until we have to deleverage\n    // This is so we can hit max leverage and keep accruing interest\n    uint256 colFactorSyncBuffer = 50;\n    uint256 colFactorSyncBufferMax = 1000;\n\n    // Keeper bots\n    // Maintain leverage within buffer\n    mapping(address => bool) keepers;\n\n    constructor(\n        address _governance,\n        address _strategist,\n        address _controller,\n        address _timelock\n    )\n        public\n        StrategyBase(dai, _governance, _strategist, _controller, _timelock)\n    {\n        // Enter cDAI Market\n        address[] memory ctokens = new address[](1);\n        ctokens[0] = cdai;\n        IComptroller(comptroller).enterMarkets(ctokens);\n    }\n\n    // **** Modifiers **** //\n\n    modifier onlyKeepers {\n        require(\n            keepers[msg.sender] ||\n                msg.sender == address(this) ||\n                msg.sender == strategist ||\n                msg.sender == governance,\n            \"!keepers\"\n        );\n        _;\n    }\n\n    // **** Views **** //\n\n    function getName() external override pure returns (string memory) {\n        return \"StrategyCompoundDaiV1\";\n    }\n\n    function getSuppliedView() public view returns (uint256) {\n        (, uint256 cTokenBal, , uint256 exchangeRate) = ICToken(cdai)\n            .getAccountSnapshot(address(this));\n\n        (, uint256 bal) = mulScalarTruncate(\n            Exp({mantissa: exchangeRate}),\n            cTokenBal\n        );\n\n        return bal;\n    }\n\n    function getBorrowedView() public view returns (uint256) {\n        return ICToken(cdai).borrowBalanceStored(address(this));\n    }\n\n    function balanceOfPool() public override view returns (uint256) {\n        uint256 supplied = getSuppliedView();\n        uint256 borrowed = getBorrowedView();\n        return supplied.sub(borrowed);\n    }\n\n    // Given an unleveraged supply balance, return the target\n    // leveraged supply balance which is still within the safety buffer\n    function getLeveragedSupplyTarget(uint256 supplyBalance)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 leverage = getMaxLeverage();\n        return supplyBalance.mul(leverage).div(1e18);\n    }\n\n    function getSafeLeverageColFactor() public view returns (uint256) {\n        uint256 colFactor = getMarketColFactor();\n\n        // Collateral factor within the buffer\n        uint256 safeColFactor = colFactor.sub(\n            colFactorLeverageBuffer.mul(1e18).div(colFactorLeverageBufferMax)\n        );\n\n        return safeColFactor;\n    }\n\n    function getSafeSyncColFactor() public view returns (uint256) {\n        uint256 colFactor = getMarketColFactor();\n\n        // Collateral factor within the buffer\n        uint256 safeColFactor = colFactor.sub(\n            colFactorSyncBuffer.mul(1e18).div(colFactorSyncBufferMax)\n        );\n\n        return safeColFactor;\n    }\n\n    function getMarketColFactor() public view returns (uint256) {\n        (, uint256 colFactor) = IComptroller(comptroller).markets(cdai);\n\n        return colFactor;\n    }\n\n    // Max leverage we can go up to, w.r.t safe buffer\n    function getMaxLeverage() public view returns (uint256) {\n        uint256 safeLeverageColFactor = getSafeLeverageColFactor();\n\n        // Infinite geometric series\n        uint256 leverage = uint256(1e36).div(1e18 - safeLeverageColFactor);\n        return leverage;\n    }\n\n    // **** Pseudo-view functions (use `callStatic` on these) **** //\n    /* The reason why these exists is because of the nature of the\n       interest accruing supply + borrow balance. The \"view\" methods\n       are technically snapshots and don't represent the real value.\n       As such there are pseudo view methods where you can retrieve the\n       results by calling `callStatic`.\n    */\n\n    function getCompAccrued() public returns (uint256) {\n        (, , , uint256 accrued) = ICompoundLens(lens).getCompBalanceMetadataExt(\n            comp,\n            comptroller,\n            address(this)\n        );\n\n        return accrued;\n    }\n\n    function getColFactor() public returns (uint256) {\n        uint256 supplied = getSupplied();\n        uint256 borrowed = getBorrowed();\n\n        return borrowed.mul(1e18).div(supplied);\n    }\n\n    function getSuppliedUnleveraged() public returns (uint256) {\n        uint256 supplied = getSupplied();\n        uint256 borrowed = getBorrowed();\n\n        return supplied.sub(borrowed);\n    }\n\n    function getSupplied() public returns (uint256) {\n        return ICToken(cdai).balanceOfUnderlying(address(this));\n    }\n\n    function getBorrowed() public returns (uint256) {\n        return ICToken(cdai).borrowBalanceCurrent(address(this));\n    }\n\n    function getBorrowable() public returns (uint256) {\n        uint256 supplied = getSupplied();\n        uint256 borrowed = getBorrowed();\n\n        (, uint256 colFactor) = IComptroller(comptroller).markets(cdai);\n\n        // 99.99% just in case some dust accumulates\n        return\n            supplied.mul(colFactor).div(1e18).sub(borrowed).mul(9999).div(\n                10000\n            );\n    }\n\n    function getCurrentLeverage() public returns (uint256) {\n        uint256 supplied = getSupplied();\n        uint256 borrowed = getBorrowed();\n\n        return supplied.mul(1e18).div(supplied.sub(borrowed));\n    }\n\n    // **** Setters **** //\n\n    function addKeeper(address _keeper) public {\n        require(\n            msg.sender == governance || msg.sender == strategist,\n            \"!governance\"\n        );\n        keepers[_keeper] = true;\n    }\n\n    function removeKeeper(address _keeper) public {\n        require(\n            msg.sender == governance || msg.sender == strategist,\n            \"!governance\"\n        );\n        keepers[_keeper] = false;\n    }\n\n    function setColFactorLeverageBuffer(uint256 _colFactorLeverageBuffer)\n        public\n    {\n        require(\n            msg.sender == governance || msg.sender == strategist,\n            \"!governance\"\n        );\n        colFactorLeverageBuffer = _colFactorLeverageBuffer;\n    }\n\n    function setColFactorSyncBuffer(uint256 _colFactorSyncBuffer) public {\n        require(\n            msg.sender == governance || msg.sender == strategist,\n            \"!governance\"\n        );\n        colFactorSyncBuffer = _colFactorSyncBuffer;\n    }\n\n    // **** State mutations **** //\n\n    // Do a `callStatic` on this.\n    // If it returns true then run it for realz. (i.e. eth_signedTx, not eth_call)\n    function sync() public returns (bool) {\n        uint256 colFactor = getColFactor();\n        uint256 safeSyncColFactor = getSafeSyncColFactor();\n\n        // If we're not safe\n        if (colFactor > safeSyncColFactor) {\n            uint256 unleveragedSupply = getSuppliedUnleveraged();\n            uint256 idealSupply = getLeveragedSupplyTarget(unleveragedSupply);\n\n            deleverageUntil(idealSupply);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    function leverageToMax() public {\n        uint256 unleveragedSupply = getSuppliedUnleveraged();\n        uint256 idealSupply = getLeveragedSupplyTarget(unleveragedSupply);\n        leverageUntil(idealSupply);\n    }\n\n    // Leverages until we're supplying <x> amount\n    // 1. Redeem <x> DAI\n    // 2. Repay <x> DAI\n    function leverageUntil(uint256 _supplyAmount) public onlyKeepers {\n        // 1. Borrow out <X> DAI\n        // 2. Supply <X> DAI\n\n        uint256 leverage = getMaxLeverage();\n        uint256 unleveragedSupply = getSuppliedUnleveraged();\n        require(\n            _supplyAmount >= unleveragedSupply &&\n                _supplyAmount <= unleveragedSupply.mul(leverage).div(1e18),\n            \"!leverage\"\n        );\n\n        // Since we're only leveraging one asset\n        // Supplied = borrowed\n        uint256 _borrowAndSupply;\n        uint256 supplied = getSupplied();\n        while (supplied < _supplyAmount) {\n            _borrowAndSupply = getBorrowable();\n\n            if (supplied.add(_borrowAndSupply) > _supplyAmount) {\n                _borrowAndSupply = _supplyAmount.sub(supplied);\n            }\n\n            ICToken(cdai).borrow(_borrowAndSupply);\n            deposit();\n\n            supplied = supplied.add(_borrowAndSupply);\n        }\n    }\n\n    function deleverageToMin() public {\n        uint256 unleveragedSupply = getSuppliedUnleveraged();\n        deleverageUntil(unleveragedSupply);\n    }\n\n    // Deleverages until we're supplying <x> amount\n    // 1. Redeem <x> DAI\n    // 2. Repay <x> DAI\n    function deleverageUntil(uint256 _supplyAmount) public onlyKeepers {\n        uint256 unleveragedSupply = getSuppliedUnleveraged();\n        uint256 supplied = getSupplied();\n        require(\n            _supplyAmount >= unleveragedSupply && _supplyAmount <= supplied,\n            \"!deleverage\"\n        );\n\n        // Since we're only leveraging on 1 asset\n        // redeemable = borrowable\n        uint256 _redeemAndRepay = getBorrowable();\n        do {\n            if (supplied.sub(_redeemAndRepay) < _supplyAmount) {\n                _redeemAndRepay = supplied.sub(_supplyAmount);\n            }\n\n            require(\n                ICToken(cdai).redeemUnderlying(_redeemAndRepay) == 0,\n                \"!redeem\"\n            );\n            IERC20(dai).safeApprove(cdai, 0);\n            IERC20(dai).safeApprove(cdai, _redeemAndRepay);\n            require(ICToken(cdai).repayBorrow(_redeemAndRepay) == 0, \"!repay\");\n\n            supplied = supplied.sub(_redeemAndRepay);\n        } while (supplied > _supplyAmount);\n    }\n\n    function harvest() public override onlyBenevolent {\n        address[] memory ctokens = new address[](1);\n        ctokens[0] = cdai;\n\n        IComptroller(comptroller).claimComp(address(this), ctokens);\n        uint256 _comp = IERC20(comp).balanceOf(address(this));\n        if (_comp > 0) {\n            _swapUniswap(comp, want, _comp);\n        }\n\n        uint256 _want = IERC20(want).balanceOf(address(this));\n        if (_want > 0) {\n            // Fees 4.5% goes to treasury\n            IERC20(want).safeTransfer(\n                IController(controller).treasury(),\n                _want.mul(performanceFee).div(performanceMax)\n            );\n\n            deposit();\n        }\n    }\n\n    function deposit() public override {\n        uint256 _want = IERC20(want).balanceOf(address(this));\n        if (_want > 0) {\n            IERC20(want).safeApprove(cdai, 0);\n            IERC20(want).safeApprove(cdai, _want);\n            require(ICToken(cdai).mint(_want) == 0, \"!deposit\");\n        }\n    }\n\n    function _withdrawSome(uint256 _amount)\n        internal\n        override\n        returns (uint256)\n    {\n        uint256 _want = balanceOfWant();\n        if (_want < _amount) {\n            uint256 _redeem = _amount.sub(_want);\n\n            // Make sure market can cover liquidity\n            require(ICToken(cdai).getCash() >= _redeem, \"!cash-liquidity\");\n\n            // How much borrowed amount do we need to free?\n            uint256 borrowed = getBorrowed();\n            uint256 supplied = getSupplied();\n            uint256 curLeverage = getCurrentLeverage();\n            uint256 borrowedToBeFree = _redeem.mul(curLeverage).div(1e18);\n\n            // If the amount we need to free is > borrowed\n            // Just free up all the borrowed amount\n            if (borrowedToBeFree > borrowed) {\n                this.deleverageToMin();\n            } else {\n                // Otherwise just keep freeing up borrowed amounts until\n                // we hit a safe number to redeem our underlying\n                this.deleverageUntil(supplied.sub(borrowedToBeFree));\n            }\n\n            // Redeems underlying\n            require(ICToken(cdai).redeemUnderlying(_redeem) == 0, \"!redeem\");\n        }\n\n        return _amount;\n    }\n}"
    },
    {
      "filename": "src/strategies/compound/strategy-cmpd-dai-v1.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\nimport \"../../lib/erc20.sol\";\nimport \"../../lib/safe-math.sol\";\nimport \"../../lib/exponential.sol\";\n\nimport \"../strategy-base.sol\";\n\nimport \"../../interfaces/jar.sol\";\nimport \"../../interfaces/uniswapv2.sol\";\nimport \"../../interfaces/controller.sol\";\nimport \"../../interfaces/compound.sol\";\n\ncontract StrategyCmpdDaiV1 is StrategyBase, Exponential {\n    address\n        public constant comptroller = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n    address public constant lens = 0xd513d22422a3062Bd342Ae374b4b9c20E0a9a074;\n    address public constant dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address public constant comp = 0xc00e94Cb662C3520282E6f5717214004A7f26888;\n    address public constant cdai = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\n    address public constant cether = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n\n    // Require a 0.1 buffer between\n    // market collateral factor and strategy's collateral factor\n    // when leveraging\n    uint256 colFactorLeverageBuffer = 100;\n    uint256 colFactorLeverageBufferMax = 1000;\n\n    // Allow a 0.05 buffer\n    // between market collateral factor and strategy's collateral factor\n    // until we have to deleverage\n    // This is so we can hit max leverage and keep accruing interest\n    uint256 colFactorSyncBuffer = 50;\n    uint256 colFactorSyncBufferMax = 1000;\n\n    // Keeper bots\n    // Maintain leverage within buffer\n    mapping(address => bool) keepers;\n\n    constructor(\n        address _governance,\n        address _strategist,\n        address _controller,\n        address _timelock\n    )\n        public\n        StrategyBase(dai, _governance, _strategist, _controller, _timelock)\n    {\n        // Enter cDAI Market\n        address[] memory ctokens = new address[](1);\n        ctokens[0] = cdai;\n        IComptroller(comptroller).enterMarkets(ctokens);\n    }\n\n    // **** Modifiers **** //\n\n    modifier onlyKeepers {\n        require(\n            keepers[msg.sender] ||\n                msg.sender == address(this) ||\n                msg.sender == strategist ||\n                msg.sender == governance,\n            \"!keepers\"\n        );\n        _;\n    }\n\n    // **** Views **** //\n\n    function getName() external override pure returns (string memory) {\n        return \"StrategyCompoundDaiV1\";\n    }\n\n    function getSuppliedView() public view returns (uint256) {\n        (, uint256 cTokenBal, , uint256 exchangeRate) = ICToken(cdai)\n            .getAccountSnapshot(address(this));\n\n        (, uint256 bal) = mulScalarTruncate(\n            Exp({mantissa: exchangeRate}),\n            cTokenBal\n        );\n\n        return bal;\n    }\n\n    function getBorrowedView() public view returns (uint256) {\n        return ICToken(cdai).borrowBalanceStored(address(this));\n    }\n\n    function balanceOfPool() public override view returns (uint256) {\n        uint256 supplied = getSuppliedView();\n        uint256 borrowed = getBorrowedView();\n        return supplied.sub(borrowed);\n    }\n\n    // Given an unleveraged supply balance, return the target\n    // leveraged supply balance which is still within the safety buffer\n    function getLeveragedSupplyTarget(uint256 supplyBalance)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 leverage = getMaxLeverage();\n        return supplyBalance.mul(leverage).div(1e18);\n    }\n\n    function getSafeLeverageColFactor() public view returns (uint256) {\n        uint256 colFactor = getMarketColFactor();\n\n        // Collateral factor within the buffer\n        uint256 safeColFactor = colFactor.sub(\n            colFactorLeverageBuffer.mul(1e18).div(colFactorLeverageBufferMax)\n        );\n\n        return safeColFactor;\n    }\n\n    function getSafeSyncColFactor() public view returns (uint256) {\n        uint256 colFactor = getMarketColFactor();\n\n        // Collateral factor within the buffer\n        uint256 safeColFactor = colFactor.sub(\n            colFactorSyncBuffer.mul(1e18).div(colFactorSyncBufferMax)\n        );\n\n        return safeColFactor;\n    }\n\n    function getMarketColFactor() public view returns (uint256) {\n        (, uint256 colFactor) = IComptroller(comptroller).markets(cdai);\n\n        return colFactor;\n    }\n\n    // Max leverage we can go up to, w.r.t safe buffer\n    function getMaxLeverage() public view returns (uint256) {\n        uint256 safeLeverageColFactor = getSafeLeverageColFactor();\n\n        // Infinite geometric series\n        uint256 leverage = uint256(1e36).div(1e18 - safeLeverageColFactor);\n        return leverage;\n    }\n\n    // **** Pseudo-view functions (use `callStatic` on these) **** //\n    /* The reason why these exists is because of the nature of the\n       interest accruing supply + borrow balance. The \"view\" methods\n       are technically snapshots and don't represent the real value.\n       As such there are pseudo view methods where you can retrieve the\n       results by calling `callStatic`.\n    */\n\n    function getCompAccrued() public returns (uint256) {\n        (, , , uint256 accrued) = ICompoundLens(lens).getCompBalanceMetadataExt(\n            comp,\n            comptroller,\n            address(this)\n        );\n\n        return accrued;\n    }\n\n    function getColFactor() public returns (uint256) {\n        uint256 supplied = getSupplied();\n        uint256 borrowed = getBorrowed();\n\n        return borrowed.mul(1e18).div(supplied);\n    }\n\n    function getSuppliedUnleveraged() public returns (uint256) {\n        uint256 supplied = getSupplied();\n        uint256 borrowed = getBorrowed();\n\n        return supplied.sub(borrowed);\n    }\n\n    function getSupplied() public returns (uint256) {\n        return ICToken(cdai).balanceOfUnderlying(address(this));\n    }\n\n    function getBorrowed() public returns (uint256) {\n        return ICToken(cdai).borrowBalanceCurrent(address(this));\n    }\n\n    function getBorrowable() public returns (uint256) {\n        uint256 supplied = getSupplied();\n        uint256 borrowed = getBorrowed();\n\n        (, uint256 colFactor) = IComptroller(comptroller).markets(cdai);\n\n        // 99.99% just in case some dust accumulates\n        return\n            supplied.mul(colFactor).div(1e18).sub(borrowed).mul(9999).div(\n                10000\n            );\n    }\n\n    function getCurrentLeverage() public returns (uint256) {\n        uint256 supplied = getSupplied();\n        uint256 borrowed = getBorrowed();\n\n        return supplied.mul(1e18).div(supplied.sub(borrowed));\n    }\n\n    // **** Setters **** //\n\n    function addKeeper(address _keeper) public {\n        require(\n            msg.sender == governance || msg.sender == strategist,\n            \"!governance\"\n        );\n        keepers[_keeper] = true;\n    }\n\n    function removeKeeper(address _keeper) public {\n        require(\n            msg.sender == governance || msg.sender == strategist,\n            \"!governance\"\n        );\n        keepers[_keeper] = false;\n    }\n\n    function setColFactorLeverageBuffer(uint256 _colFactorLeverageBuffer)\n        public\n    {\n        require(\n            msg.sender == governance || msg.sender == strategist,\n            \"!governance\"\n        );\n        colFactorLeverageBuffer = _colFactorLeverageBuffer;\n    }\n\n    function setColFactorSyncBuffer(uint256 _colFactorSyncBuffer) public {\n        require(\n            msg.sender == governance || msg.sender == strategist,\n            \"!governance\"\n        );\n        colFactorSyncBuffer = _colFactorSyncBuffer;\n    }\n\n    // **** State mutations **** //\n\n    // Do a `callStatic` on this.\n    // If it returns true then run it for realz. (i.e. eth_signedTx, not eth_call)\n    function sync() public returns (bool) {\n        uint256 colFactor = getColFactor();\n        uint256 safeSyncColFactor = getSafeSyncColFactor();\n\n        // If we're not safe\n        if (colFactor > safeSyncColFactor) {\n            uint256 unleveragedSupply = getSuppliedUnleveraged();\n            uint256 idealSupply = getLeveragedSupplyTarget(unleveragedSupply);\n\n            deleverageUntil(idealSupply);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    function leverageToMax() public {\n        uint256 unleveragedSupply = getSuppliedUnleveraged();\n        uint256 idealSupply = getLeveragedSupplyTarget(unleveragedSupply);\n        leverageUntil(idealSupply);\n    }\n\n    // Leverages until we're supplying <x> amount\n    // 1. Redeem <x> DAI\n    // 2. Repay <x> DAI\n    function leverageUntil(uint256 _supplyAmount) public onlyKeepers {\n        // 1. Borrow out <X> DAI\n        // 2. Supply <X> DAI\n\n        uint256 leverage = getMaxLeverage();\n        uint256 unleveragedSupply = getSuppliedUnleveraged();\n        require(\n            _supplyAmount >= unleveragedSupply &&\n                _supplyAmount <= unleveragedSupply.mul(leverage).div(1e18),\n            \"!leverage\"\n        );\n\n        // Since we're only leveraging one asset\n        // Supplied = borrowed\n        uint256 _borrowAndSupply;\n        uint256 supplied = getSupplied();\n        while (supplied < _supplyAmount) {\n            _borrowAndSupply = getBorrowable();\n\n            if (supplied.add(_borrowAndSupply) > _supplyAmount) {\n                _borrowAndSupply = _supplyAmount.sub(supplied);\n            }\n\n            ICToken(cdai).borrow(_borrowAndSupply);\n            deposit();\n\n            supplied = supplied.add(_borrowAndSupply);\n        }\n    }\n\n    function deleverageToMin() public {\n        uint256 unleveragedSupply = getSuppliedUnleveraged();\n        deleverageUntil(unleveragedSupply);\n    }\n\n    // Deleverages until we're supplying <x> amount\n    // 1. Redeem <x> DAI\n    // 2. Repay <x> DAI\n    function deleverageUntil(uint256 _supplyAmount) public onlyKeepers {\n        uint256 unleveragedSupply = getSuppliedUnleveraged();\n        uint256 supplied = getSupplied();\n        require(\n            _supplyAmount >= unleveragedSupply && _supplyAmount <= supplied,\n            \"!deleverage\"\n        );\n\n        // Since we're only leveraging on 1 asset\n        // redeemable = borrowable\n        uint256 _redeemAndRepay = getBorrowable();\n        do {\n            if (supplied.sub(_redeemAndRepay) < _supplyAmount) {\n                _redeemAndRepay = supplied.sub(_supplyAmount);\n            }\n\n            require(\n                ICToken(cdai).redeemUnderlying(_redeemAndRepay) == 0,\n                \"!redeem\"\n            );\n            IERC20(dai).safeApprove(cdai, 0);\n            IERC20(dai).safeApprove(cdai, _redeemAndRepay);\n            require(ICToken(cdai).repayBorrow(_redeemAndRepay) == 0, \"!repay\");\n\n            supplied = supplied.sub(_redeemAndRepay);\n        } while (supplied > _supplyAmount);\n    }\n\n    function harvest() public override onlyBenevolent {\n        address[] memory ctokens = new address[](1);\n        ctokens[0] = cdai;\n\n        IComptroller(comptroller).claimComp(address(this), ctokens);\n        uint256 _comp = IERC20(comp).balanceOf(address(this));\n        if (_comp > 0) {\n            _swapUniswap(comp, want, _comp);\n        }\n\n        uint256 _want = IERC20(want).balanceOf(address(this));\n        if (_want > 0) {\n            // Fees 4.5% goes to treasury\n            IERC20(want).safeTransfer(\n                IController(controller).treasury(),\n                _want.mul(performanceFee).div(performanceMax)\n            );\n\n            deposit();\n        }\n    }\n\n    function deposit() public override {\n        uint256 _want = IERC20(want).balanceOf(address(this));\n        if (_want > 0) {\n            IERC20(want).safeApprove(cdai, 0);\n            IERC20(want).safeApprove(cdai, _want);\n            require(ICToken(cdai).mint(_want) == 0, \"!deposit\");\n        }\n    }\n\n    function _withdrawSome(uint256 _amount)\n        internal\n        override\n        returns (uint256)\n    {\n        uint256 _want = balanceOfWant();\n        if (_want < _amount) {\n            uint256 _redeem = _amount.sub(_want);\n\n            // Make sure market can cover liquidity\n            require(ICToken(cdai).getCash() >= _redeem, \"!cash-liquidity\");\n\n            // How much borrowed amount do we need to free?\n            uint256 borrowed = getBorrowed();\n            uint256 supplied = getSupplied();\n            uint256 curLeverage = getCurrentLeverage();\n            uint256 borrowedToBeFree = _redeem.mul(curLeverage).div(1e18);\n\n            // If the amount we need to free is > borrowed\n            // Just free up all the borrowed amount\n            if (borrowedToBeFree > borrowed) {\n                this.deleverageToMin();\n            } else {\n                // Otherwise just keep freeing up borrowed amounts until\n                // we hit a safe number to redeem our underlying\n                this.deleverageUntil(supplied.sub(borrowedToBeFree));\n            }\n\n            // Redeems underlying\n            require(ICToken(cdai).redeemUnderlying(_redeem) == 0, \"!redeem\");\n        }\n\n        return _amount;\n    }\n}"
    }
  ]
}