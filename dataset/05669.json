{
  "Title": "[M-03] Loss of funds for the sender when ``L1->L2`` TX fails in the bootloader on L2",
  "Content": "\n### Sending ``L1->L2`` TX\n\nIn zksync, `requestL2Transaction`  can be used to send a ``L1->L2`` TX.\n\n```solidity\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable nonReentrant senderCanCallFunction(s.allowList) returns (bytes32 canonicalTxHash) {\n```\n\n[Mailbox.requestL2Transaction:L236-L245](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L236-L245)\n\nAn important param is `_l2TxGasLimit`, which is used to process the TX on L2. The L2 gas limit should include both the overhead for processing the batch and the L2 gas needed to process the transaction itself (i.e. the actual `l2GasLimit` that will be used for the transaction).\n\nSo, `_l2TxGasLimit` should have an amount that's enough to cover:\n\n1.  Transaction overhead.\n2.  The transaction itself (body execution).\n\nTo ensure this, there is a validation enforced on `requestL2Transaction` before pushing the TX to the `priorityQueue`.\n\n```solidity\n\tL2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams, _calldata, _factoryDeps);\n\n\tbytes memory transactionEncoding = abi.encode(transaction);\n\n\tTransactionValidator.validateL1ToL2Transaction(transaction, transactionEncoding, s.priorityTxMaxGasLimit);\n```\n\n[Mailbox.\\_writePriorityOp:L361-L368](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L361-L368)\n\nThis is to make sure the transaction at least get a chance to be executed.\n\n### Bootloader ``L1->L2`` TX execuation flow\n\nWhen the bootloader receives the ``L1->L2`` TX, it does the following:\n\n1. Calculates the L2 gas limit for the transaction's body, i.e. without intrinsic costs and overhead.\n\n```solidity\n\tlet gasLimitForTx, reservedGas := getGasLimitForTx(\n\t\tinnerTxDataOffset, \n\t\ttransactionIndex, \n\t\tgasPerPubdata, \n\t\tL1_TX_INTRINSIC_L2_GAS(), \n\t\tL1_TX_INTRINSIC_PUBDATA()\n\t)\n```\n\n[bootloader:L878-L884](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L878-L884)\n\n**gasLimitForTx** - is the gas limit for the transaction's body.<br>\n**reservedGas** - is the amount of gas that is beyond the operator's trust limit to refund it back later.\n\nNote: the operator's trust limit is guaranteed to be at least `MAX_GAS_PER_TRANSACTION` which is at the moment `80000000` (check `SystemConfig.json`).\n\n2. Ensure that the deposited eth covers `txInternalCost` and `value`.\n\n```solidity\n\tlet gasPrice := getMaxFeePerGas(innerTxDataOffset)\n\tlet txInternalCost := safeMul(gasPrice, gasLimit, \"poa\")\n\tlet value := getValue(innerTxDataOffset)\n\tif lt(getReserved0(innerTxDataOffset), safeAdd(value, txInternalCost, \"ol\")) {\n\t\tassertionError(\"deposited eth too low\")\n\t}\n```\n\n[bootloader:L901-L906](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L901-L906)\n\n3.  Checks if **gasLimitForTx** is greater than `gasUsedOnPreparation` and then calls `getExecuteL1TxAndGetRefund` to attempt to execute the TX. This function returns a `potentialRefund` if there is any.\n\n```solidity\n\t\tif gt(gasLimitForTx, gasUsedOnPreparation) {\n\t\t\tlet potentialRefund := 0\n\n\t\t\tpotentialRefund, success := getExecuteL1TxAndGetRefund(txDataOffset, sub(gasLimitForTx, gasUsedOnPreparation))\n\n```\n\n[bootloader:L908-L912](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L908-L912)\n\nFor example, let's say the sender has `10_000_000` gas limit (after deducting the overhead ..etc.), and the TX execution consumed `3_000_000`, then the `potentialRefund` is supposed to be `10_000_000-3_000_000 = 7_000_000`. This will be returned to `refundRecipient`. However, if the actual TX execution fails, then `potentialRefund` will always be zero. Therefore, no refund for the sender at all. In other words, let's say that the TX execution consumed only `500_000` only till it reverted (for whatever reason). so, the `potentialRefund` should be `9_500_000` which is not the case since it will be always zero on failure.\n\nNote: obviously this is not applicable if ``L1->L2`` transactions were set to be free. [Check the comments here](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L927-L931).\n\n### Reason & Explanation\n\nThis issue occurs due to the fact that near call opcode is used to execute the TX (to avoid 63/64 rule), and when the TX execution fails, near call panic is utilised to avoid reverting the bootloader and to revert minting ether to the user.\n\n```solidity\n\tlet gasBeforeExecution := gas() \n\tsuccess := ZKSYNC_NEAR_CALL_executeL1Tx(\n\t\tcallAbi,\n\t\ttxDataOffset\n\t)\n```\n\n[bootloader:L980-L988](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L980-L988)\n\n```solidity\n\t// If the success is zero, we will revert in order\n\t// to revert the minting of ether to the user\n\tif iszero(success) {\n\t\tnearCallPanic()\n\t}\n```\n\n[bootloader:L1665-L1670](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1665-L1670)\n\nCheck [zkSync specific opcodes: Generally accessible](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/System%20contracts%20bootloader%20description.md#generally-accessible),\n\n> `near_call`. It is basically a “framed” jump to some location of the code of your contract. The difference between the `near_call` and ordinary jump are:\n> \n> - It is possible to provide an `ergsLimit` for it. Note, that unlike `“far_call”s` (i.e. calls between contracts) the 63/64 rule does not apply to them.\n> - If the near call frame panics, all state changes made by it are reversed. Please note, that the memory changes will not be reverted.\n\nPlease note that the only way to revert only the `near_call` frame (and not the parent) is to trigger out of gas error or invalid opcode.\n\nCheck [Simulations via our compiler: Simulating `near_call` (in Yul only)](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/System%20contracts%20bootloader%20description.md#simulations-via-our-compiler)\n\n> Important note: the compiler behaves in a way that if there is a revert in the bootloader, the `ZKSYNC_CATCH_NEAR_CALL` is not called and the parent frame is reverted as well. The only way to revert only the `near_call` frame is to trigger VM’s panic (it can be triggered with either invalid opcode or out of gas error).\n\nIn  `ZKSYNC_NEAR_CALL_executeL1Tx`,  `nearCallPanic()` is called in case of TX failure. If we check `nearCallPanic()` function, we find that it exhausts all the gas of the current frame so that out of gas error is triggered.\n\n```solidity\n\t/// @dev Used to panic from the nearCall without reverting the parent frame.\n\t/// If you use `revert(...)`, the error will bubble up from the near call and\n\t/// make the bootloader to revert as well. This method allows to exit the nearCall only.\n\tfunction nearCallPanic() {\n\t\t// Here we exhaust all the gas of the current frame.\n\t\t// This will cause the execution to panic.\n\t\t// Note, that it will cause only the inner call to panic.\n\t\tprecompileCall(gas())\n\t}\n```\n\n[bootloader:L1678-L1686](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1678-L1686)\n\nBecause of this, no matter how much gas was spent on the TX itself, if it fails, all the unused remaining gas will be burned.\n\nAccording to the docs [zkSync: Batch overhead & limited resources of the batch](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/zkSync%20fee%20model.md#batch-overhead--limited-resources-of-the-batch) the refund should be provided at the end of the transaction.\n\n> Note, that before the transaction is executed, the system can not know how many of the limited system resources the transaction will actually take, so we need to charge for the worst case and provide the refund at the end of the transaction\n\n**On the surface, this might not look like a critical issue since the lost funds are relatively small. However, this may be true for normal or small transactions unlike computationally intensive tasks which may require big upfront payment. The lost funds will be not negligible.**\n\nPlease refer to [How baseFee works on zkSync](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/zkSync%20fee%20model.md#how-basefee-works-on-zksync)\n\n> This does not actually matter a lot for normal transactions, since most of the costs will still go on pubdata for them. However, it may matter for computationally intensive tasks, meaning that for them a big upfront payment will be required, with the refund at the end of the transaction for all the overspent gas.\n\nPlease note that while there is `MAX_TRANSACTION_GAS_LIMIT` for the `gasLimit`, it may go way beyond the `MAX_TRANSACTION_GAS_LIMIT` (since the contracts can be 10s of kilobytes in size). This is called Trusted gas limit which is provided by the operator.\n\nPlease check [Trusted gas limit](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/zkSync%20fee%20model.md#trusted-gas-limit)\n\n> the operator may provide the trusted gas limit, i.e. the limit which exceeds `MAX_TRANSACTION_GAS_LIMIT` assuming that the operator knows what he is doing (e.g. he is sure that the excess gas will be spent on the pubdata).\n\nFrom this, we conclude that the upper limit for the loss is the cost of the `gaslimit` provided by the user which could possibly be a big amount of payment to cover complex tasks (assuming the operator provided a trusted gas limit bigger or equal to `gaslimit` provided by the user).\n\nIt's worth mentioning, that this breaks the trust assumptions that the users have, since the users assume that they will always get a refund if it wasn't consumed by their requested TX.\n\nFor the reasons explained above, I've set the severity to high.\n\n### Proof of Concept\n\nWe have one test file. This file demonstrates two cases:\n1. `test_actual_gas_spent_on_success()` - When the TX succeed, the potential refund holds the actual remaining gas to be refunded.\n2. `test_no_gas_refund_on_failure` - When the TX fails, the potential refund is zero.\n\nImportant notes:\n- While the test is not executed via zkEVM, the only specific opcode for this PoC is, the near call panic. For this reason, it is simulated.\n- The code is written in solidity for simplicity. However, for this PoC, it is good enough to demonstrate and prove the issue.\n\nTo run the test file:\n```sh\nforge test --via-ir -vv\n```\n\nYou should get the following output:\n\n```sh\n[PASS] test_actual_gas_spent_on_success() (gas: 47121)\nLogs:\n  Nearcall callAbi: 100000000\n  gasSpentOnExecution: 31533\n  success:  true\n  potentialRefund: 99968467\n\n[PASS] test_no_gas_refund_on_failure() (gas: 101606767)\nLogs:\n  Nearcall callAbi: 100000000\n  gasSpentOnExecution: 101591221\n  success:  false\n  potentialRefund: 0\n\nTest result: ok. 2 passed; 0 failed; finished in 604.85ms\n```\n\n### Test File\n\n<details> \n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n// PoC => No refund for gas on `L1->L2` tx failure, it always burns the gas even if not used\n\nimport {Test} from \"forge-std/Test.sol\";\nimport \"forge-std/console.sol\";\n\nimport {DSTest} from \"ds-test/test.sol\";\n\nuint256 constant OVERHEAD_TX = 100_000; // assume overhead as 100000\nuint256 constant GAS_PREP = 2000; // assume preparation value\n\ncontract ExternalContract {\n    uint256 varState;\n\n    function doSomething(uint256 num) external {\n        varState = 1;\n\n        //  revert if num is zero to cause nearCallPanic later\n        if (num == 0) {\n            revert(\"something wrong happened\");\n        }\n    }\n}\n\ninterface IExternalContract {\n    function doSomething(uint256 num) external;\n}\n\ninterface IBooloaderMock {\n    function ZKSYNC_NEAR_CALL_SIMULATION_executeL1Tx(\n        uint256 callAbi,\n        bytes memory txCalldataEncoded\n    ) external;\n}\n\ncontract BooloaderMock {\n    ExternalContract externalContract;\n\n    constructor() {\n        externalContract = new ExternalContract();\n    }\n\n    /// @dev The overhead in gas that will be used when checking whether the context has enough gas, i.e.\n    /// when checking for X gas, the context should have at least X+CHECK_ENOUGH_GAS_OVERHEAD() gas.\n    function CHECK_ENOUGH_GAS_OVERHEAD() internal pure returns (uint256 ret) {\n        ret = 1000000;\n    }\n\n    function checkEnoughGas(uint256 gasToProvide) internal view {\n        // Using margin of CHECK_ENOUGH_GAS_OVERHEAD gas to make sure that the operation will indeed\n        // have enough gas\n        // CHECK_ENOUGH_GAS_OVERHEAD => 1_000_000\n        if (gasleft() < (gasToProvide + CHECK_ENOUGH_GAS_OVERHEAD())) {\n            revert(\"No enough gas\");\n        }\n    }\n\n    function notifyExecutionResult(bool success) internal {}\n\n    function nearCallPanic() internal pure {\n        // Here we exhaust all the gas of the current frame.\n        // This will cause the execution to panic.\n        // Note, that it will cause only the inner call to panic.\n        uint256 x = 0;\n        while (true) {\n            x += 1;\n        }\n    }\n\n    // simulation of near call\n    function ZKSYNC_NEAR_CALL_SIMULATION_executeL1Tx(\n        uint256 callAbi,\n        bytes memory txCalldataEncoded\n    ) public {\n        (bool success, ) = address(externalContract).call{gas: callAbi}(\n            txCalldataEncoded\n        );\n\n        if (!success) {\n            // nearCall panic\n            nearCallPanic();\n        }\n    }\n\n    function getExecuteL1TxAndGetRefund(\n        uint256 gasForExecution,\n        bytes memory txCalldataExternalContract\n    ) internal returns (uint256 potentialRefund, bool success) {\n        uint256 callAbi = gasForExecution;\n\n        checkEnoughGas(gasForExecution);\n\n        uint256 gasBeforeExecution = gasleft();\n\n        bytes memory txCalldataEncoded = abi.encodeCall(\n            IBooloaderMock.ZKSYNC_NEAR_CALL_SIMULATION_executeL1Tx,\n            (callAbi, txCalldataExternalContract)\n        );\n\n        console.log(\"Nearcall callAbi: %d\", callAbi);\n        // pass 64/63 to simulate nearCall that doesn't follow this 63/64 rule\n        uint256 fullGas = (callAbi * 64) / 63;\n        (success, ) = address(this).call{gas: fullGas}(txCalldataEncoded);\n\n        notifyExecutionResult(success);\n        uint256 gasSpentOnExecution = gasBeforeExecution - gasleft();\n        console.log(\"gasSpentOnExecution: %d\", gasSpentOnExecution);\n        if (gasSpentOnExecution <= gasForExecution) {\n            potentialRefund = gasForExecution - gasSpentOnExecution;\n        }\n    }\n\n    function processL1Tx(\n        uint256 l2ValueProvidedByUser,\n        uint256 gasLimitProvidedByUser,\n        bytes memory txCalldataExternalContract\n    ) external payable returns (uint256 potentialRefund, bool success) {\n        uint256 overheadTX = OVERHEAD_TX; // assume overhead for simplicity\n        uint256 gasLimitForTx = gasLimitProvidedByUser - overheadTX;\n        uint256 gasUsedOnPreparation = GAS_PREP; // assume preparation value simplicity\n        uint256 gasLimit = gasLimitProvidedByUser;\n\n        uint256 gasPrice = 13e9;\n        uint256 txInternalCost = gasPrice * gasLimit;\n        require(\n            msg.value >= l2ValueProvidedByUser + txInternalCost,\n            \"deposited eth too low\"\n        );\n        require(gasLimitForTx > gasUsedOnPreparation, \"Tx didn't continue\");\n\n        (potentialRefund, success) = getExecuteL1TxAndGetRefund(\n            (gasLimitForTx - gasUsedOnPreparation),\n            txCalldataExternalContract\n        );\n    }\n}\n\ncontract BootloaderMockTest is DSTest, Test {\n    BooloaderMock bootloaderMock;\n\n    function setUp() public {\n        bootloaderMock = new BooloaderMock();\n        vm.deal(address(this),100 ether);\n    }\n\n    function test_no_gas_refund_on_failure() public {\n        uint256 gasLimitByUser = 100_000_000 + OVERHEAD_TX + GAS_PREP;\n        uint256 l2Value = 0;\n        bytes memory txCalldataExternalContract = abi.encodeCall(\n            IExternalContract.doSomething,\n            (0) // value 0 cause the call to fail\n        );\n        (uint256 potentialRefund, bool success) = bootloaderMock.processL1Tx{\n            value: 10 ether\n        }(l2Value, gasLimitByUser, txCalldataExternalContract);\n        console.log(\"success: \", success);\n        console.log(\"potentialRefund: %d\", potentialRefund);\n    }\n\n    function test_actual_gas_spent_on_success() public {\n        uint256 gasLimitByUser = 100_000_000 + OVERHEAD_TX + GAS_PREP;\n        uint256 l2Value = 0;\n        bytes memory txCalldataExternalContract = abi.encodeCall(\n            IExternalContract.doSomething,\n            (1) // value 1 makes the call successful\n        );\n        (uint256 potentialRefund, bool success) = bootloaderMock.processL1Tx{\n            value: 10 ether\n        }(l2Value, gasLimitByUser, txCalldataExternalContract);\n        console.log(\"success: \", success);\n        console.log(\"potentialRefund: %d\", potentialRefund);\n    }\n}\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nOne suggestion is to use invalid opcode instead of burning gas.\n\n**[miladpiri (zkSync) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/979#issuecomment-1794734112):**\n > It is Low. The user does indeed lose all the gas if success is false, as we invoke the `nearCallPanic` that burns all the gas in the near call (which is basically all the execution gas).\n\n**[Alex the Entreprenerd (judge) decreased severity to QA and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/979#issuecomment-1826777382):**\n > I believe the design decision makes sense, a ``L1->L2`` must consume all gas as otherwise computing the refunds would be ripe for exploitation.\n\n**[koolexcrypto (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/979#issuecomment-1837508334):**\n > \n> @Alex the Entreprenerd - I kindly ask you to re-evaluate the issue above considering the following:\n> \n> **EVM non-equivalence** \n>\n>  If you check the [differences from Ethereum at zkSync docs](https://era.zksync.io/docs/reference/architecture/differences-with-ethereum.html), EVM REVERT instruction is not listed. Meaning that, REVERT behaviour in zkSync Era VM should behave exactly the same as in EVM. Here is a simple summary of how the [EIP-140](https://eips.ethereum.org/EIPS/eip-140) defines the REVERT instruction: \n>  > The REVERT instruction provides a way to stop execution and revert state changes, without consuming all provided gas and with the ability to return a reason.\n> \n> The REVERT instruction behaviour is also confirmed in the [ZkSync Era Virtual Machine primer document](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/VM%20Section/ZkSync%20Era%20Virtual%20Machine%20primer.md#return-revert-panic) which says:\n> > Revert: a recoverable error happened. Unspent gas is returned to the caller, which will execute the exception handler. The instruction is revert.\n> \n> However, it is not the case as demonstrated in the issue above. This is due to the fact that when a TX (requested from L1) fails due to a REVERT opcode in the contract code of the callee, all the remaining gas (from the actual execution gas) will be always consumed. This behaviour is similar to the deprecated/removed opcode `throw` from EVM.\n> \n> **EVM Behaviour Discrepancy**\n>\n> Assume we have:\n> - **User X** - who is the caller.\n> - **Contract C** - on L2 which is the callee and has **Function F**.\n> - **Function F** - which consists of 1000 lines of code. However at line 4, there is a revert.\n> \n> Let's check two scenarios:\n> \n> 1. **User X** calls **Function F** by sending an L2 TX directly, at line 4, the execution finishes due to the revert and all unspent gas is returned to the caller.\n> 2. **User X** calls the same function **Function F** by sending an L2 TX indirectly (i.e. requested from L1), at line 4, the execution stops due to the revert and all unspent gas is consumed anyway.\n> \n> In the first scenario, REVERT behaves exactly as expected.\n> In the second scenario, REVERT behaves as if it was the deprecated/removed opcode `throw`. *Please note that we are talking here about the actual execution gas.*\n>\n> From this, we can see how the Bootloader breaks the zkSync Era VM  consistency\n> \n> **zkSync Era's fee model**\n> \n> Some distinctive feature of zkSync Era's fee model is the abundance of refunds for **unused limited system resources** and **overpaid computation**. Please check [High-level: conclusion](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/zkSync%20fee%20model.md#high-level-conclusion) which says:\n> > The other distinctive feature of the fee model used on zkSync is the abundance of refunds, i.e.:\n> > - For unused limited system resources.\n> > - For overpaid computation.\n> \n> Also, In the [Fee mechanism](https://era.zksync.io/docs/reference/concepts/fee-model.html) docs which says:\n> > zkSync Era's fee model is similar to Ethereum’s where gas is charged for computational cost, cost of publishing data on-chain and storage effects.\n> \n> The above issue shows how the implementation is not aligned with this design since it charges for opcodes that were never executed (i.e. opcodes that happen to be after a REVERT). Therefore, no resources have been used for it.\n> \n> In the light of this basis, the unspent gas should be returned to the user especially when the user can not influence the relevant logic in the bootloader by any mean. In other words, we have 4 actors:\n> 1. Caller\n> 2. Callee\n> 3. Operator\n> 4. zkSync Era VM\n> \n> When the caller sends an L2 TX (from L1), It seems that the caller can not provide any input that could prevent the issue from occuring.\n> \n> Lastly, it breaks the trust assumption that the users (or protocols) have, since they assume that they will receive back their unspent gas from the actual execution gas since it wasn't consumed by the TX.\n\n**[Alex the Entreprenerd (judge) increased severity to Medium and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/979#issuecomment-1849046921):**\n > I went back and forth on this finding a bit because:\n> - It's impossible to determine what a reverted transaction should have cost.\n> - Meaning that it's impossible for zkSync to calculate the refund based on the fair value of the expected tx cost.\n> - However, it is fair to expect that just like a normal revert, the cost paid would be capped at the gas spent and not at the gas set as limit.\n> \n> Due to this, the finding can be interpreted as saying that:\n> ``L1->L2`` txs that revert will consume all gas. With this being inconsistent for the EVM, and potentially risky for end users, I agree with Medium Severity\n>\n> The gas used is known and a refund could be computed, which is, in my opinion, inconsistent with other behaviours of the system. I understand the Sponsor may elect for a nofix, and that this would be a warning to developers/end-users/integrators.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport {IMailbox, TxStatus} from \"../interfaces/IMailbox.sol\";\nimport {Merkle} from \"../libraries/Merkle.sol\";\nimport {PriorityQueue, PriorityOperation} from \"../libraries/PriorityQueue.sol\";\nimport {TransactionValidator} from \"../libraries/TransactionValidator.sol\";\nimport {L2Message, L2Log} from \"../Storage.sol\";\nimport {UncheckedMath} from \"../../common/libraries/UncheckedMath.sol\";\nimport {UnsafeBytes} from \"../../common/libraries/UnsafeBytes.sol\";\nimport {L2ContractHelper} from \"../../common/libraries/L2ContractHelper.sol\";\nimport {AddressAliasHelper} from \"../../vendor/AddressAliasHelper.sol\";\nimport {IAllowList} from \"../../common/interfaces/IAllowList.sol\";\nimport {Base} from \"./Base.sol\";\nimport {\n    REQUIRED_L2_GAS_PRICE_PER_PUBDATA,\n    FAIR_L2_GAS_PRICE,\n    L1_GAS_PER_PUBDATA_BYTE,\n    L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH,\n    PRIORITY_OPERATION_L2_TX_TYPE,\n    PRIORITY_EXPIRATION,\n    MAX_NEW_FACTORY_DEPS\n} from \"../Config.sol\";\nimport {\n    L2_BOOTLOADER_ADDRESS,\n    L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n    L2_ETH_TOKEN_SYSTEM_CONTRACT_ADDR\n} from \"../../common/L2ContractAddresses.sol\";\n\n\n/// @title zkSync Mailbox contract providing interfaces for L1 <-> L2 interaction.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract MailboxFacet is Base, IMailbox {\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    string public constant override getName = \"MailboxFacet\";\n\n    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 batch number\n    /// @param _batchNumber The executed L2 batch number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 batch where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @notice Prove that a specific L2 log was sent in a specific L2 batch\n    /// @param _batchNumber The executed L2 batch number in which the log appeared\n    /// @param _index The position of the l2log in the L2 logs Merkle tree\n    /// @param _log Information about the sent log\n    /// @param _proof Merkle proof for inclusion of the L2 log\n    /// @return Whether the proof is correct and L2 log is included in batch\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @notice Prove that the L1 -> L2 transaction was processed with the specified status.\n    /// @param _l2TxHash The L2 canonical transaction hash\n    /// @param _l2BatchNumber The L2 batch number where the transaction was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction\n    /// @param _status The execution status of the L1 -> L2 transaction (true - success & 0 - fail)\n    /// @return Whether the proof is correct and the transaction was actually executed with provided status\n    /// NOTE: It may return `false` for incorrect proof, but it doesn't mean that the L1 -> L2 transaction has an opposite status!\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view override returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    /// @notice Transfer ether from the contract to the receiver\n    /// @dev Reverts only if the transfer call failed\n    function _withdrawFunds(address _to, uint256 _amount) internal {\n        bool callSuccess;\n        // Low-level assembly call, to avoid any memory copying (save gas)\n        assembly {\n            callSuccess := call(gas(), _to, _amount, 0, 0, 0, 0)\n        }\n        require(callSuccess, \"pz\");\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, \"xx\");\n\n        bytes32 hashedLog = keccak256(\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, \"tw\");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    /// @param _gasPrice expected L1 gas price at which the user requests the transaction execution\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount of L2 gas that the operator may charge the user for a single byte of pubdata.\n    /// @return The estimated ETH spent on L2 gas for the transaction\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public pure returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in ETH to be paid.\n    /// @param _l1GasPrice The gas price on L1.\n    /// @param _gasPricePerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in ETH\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPricePerPubdata) internal pure returns (uint256) {\n        uint256 pubdataPriceETH = L1_GAS_PER_PUBDATA_BYTE * _l1GasPrice;\n        uint256 minL2GasPriceETH = (pubdataPriceETH + _gasPricePerPubdata - 1) / _gasPricePerPubdata;\n\n        return Math.max(FAIR_L2_GAS_PRICE, minL2GasPriceETH);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external override nonReentrant senderCanCallFunction(s.allowList) {\n        require(!s.isEthWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex], \"jj\");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_ETH_TOKEN_SYSTEM_CONTRACT_ADDR,\n            data: _message\n        });\n\n        (address _l1WithdrawReceiver, uint256 _amount) = _parseL2WithdrawalMessage(_message);\n\n        bool proofValid = proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n        require(proofValid, \"pi\"); // Failed to verify that withdrawal was actually initialized on L2\n\n        s.isEthWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex] = true;\n        _withdrawFunds(_l1WithdrawReceiver, _amount);\n\n        emit EthWithdrawalFinalized(_l1WithdrawReceiver, _amount);\n    }\n\n    /// @notice Request execution of L2 transaction from L1.\n    /// @param _contractL2 The L2 receiver address\n    /// @param _l2Value `msg.value` of L2 transaction\n    /// @param _calldata The input of the L2 transaction\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount L2 gas that the operator may charge the user for single byte of pubdata.\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient's address to eliminate sending funds to addresses out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds are controllable,\n    /// since address aliasing to the from address for the L2 tx will be applied if the L1 `msg.sender` is a contract.\n    /// Without address aliasing for L1 contracts as refund recipients they would not be able to make proper L2 tx requests\n    /// through the Mailbox to use or withdraw the funds from L2, and the funds would be lost.\n    /// @return canonicalTxHash The hash of the requested L2 transaction. This hash can be used to follow the transaction status\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable nonReentrant senderCanCallFunction(s.allowList) returns (bytes32 canonicalTxHash) {\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        address sender = msg.sender;\n        if (sender != tx.origin) {\n            sender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        // Enforcing that `_l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using \"exotic\" numbers for _l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, \"qp\");\n\n        // The L1 -> L2 transaction may be failed and funds will be sent to the `_refundRecipient`,\n        // so we use `msg.value` instead of `_l2Value` as the bridged amount.\n        _verifyDepositLimit(msg.sender, msg.value);\n        canonicalTxHash = _requestL2Transaction(\n            sender,\n            _contractL2,\n            _l2Value,\n            _calldata,\n            _l2GasLimit,\n            _l2GasPerPubdataByteLimit,\n            _factoryDeps,\n            false,\n            _refundRecipient\n        );\n    }\n\n    function _verifyDepositLimit(address _depositor, uint256 _amount) internal {\n        IAllowList.Deposit memory limitData = IAllowList(s.allowList).getTokenDepositLimitData(address(0)); // address(0) denotes the ETH\n        if (!limitData.depositLimitation) return; // no deposit limitation is placed for ETH\n\n        require(s.totalDepositedAmountPerUser[_depositor] + _amount <= limitData.depositCap, \"d2\");\n        s.totalDepositedAmountPerUser[_depositor] += _amount;\n    }\n\n    function _requestL2Transaction(\n        address _sender,\n        address _contractAddressL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        bool _isFree,\n        address _refundRecipient\n    ) internal returns (bytes32 canonicalTxHash) {\n        require(_factoryDeps.length <= MAX_NEW_FACTORY_DEPS, \"uj\");\n        uint64 expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n        uint256 txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Here we manually assign fields for the struct to prevent \"stack too deep\" error\n        WritePriorityOpParams memory params;\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        // Using a new scope to prevent \"stack too deep\" error\n        {\n            params.l2GasPrice = _isFree ? 0 : _deriveL2GasPrice(tx.gasprice, _l2GasPerPubdataByteLimit);\n            uint256 baseCost = params.l2GasPrice * _l2GasLimit;\n            require(msg.value >= baseCost + _l2Value, \"mv\"); // The `msg.value` doesn't cover the transaction cost\n        }\n\n        // If the `_refundRecipient` is not provided, we use the `_sender` as the recipient.\n        address refundRecipient = _refundRecipient == address(0) ? _sender : _refundRecipient;\n        // If the `_refundRecipient` is a smart contract, we apply the L1 to L2 alias to prevent foot guns.\n        if (refundRecipient.code.length > 0) {\n            refundRecipient = AddressAliasHelper.applyL1ToL2Alias(refundRecipient);\n        }\n\n        params.sender = _sender;\n        params.txId = txId;\n        params.l2Value = _l2Value;\n        params.contractAddressL2 = _contractAddressL2;\n        params.expirationTimestamp = expirationTimestamp;\n        params.l2GasLimit = _l2GasLimit;\n        params.l2GasPricePerPubdata = _l2GasPerPubdataByteLimit;\n        params.valueToMint = msg.value;\n        params.refundRecipient = refundRecipient;\n\n        canonicalTxHash = _writePriorityOp(params, _calldata, _factoryDeps);\n    }\n\n    function _serializeL2Transaction(\n        WritePriorityOpParams memory _priorityOpParams,\n        bytes calldata _calldata,\n        bytes[] calldata _factoryDeps\n    ) internal pure returns (L2CanonicalTransaction memory transaction) {\n        transaction = L2CanonicalTransaction({\n            txType: PRIORITY_OPERATION_L2_TX_TYPE,\n            from: uint256(uint160(_priorityOpParams.sender)),\n            to: uint256(uint160(_priorityOpParams.contractAddressL2)),\n            gasLimit: _priorityOpParams.l2GasLimit,\n            gasPerPubdataByteLimit: _priorityOpParams.l2GasPricePerPubdata,\n            maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as \"nonce\" for L1->L2 transactions\n            nonce: uint256(_priorityOpParams.txId),\n            value: _priorityOpParams.l2Value,\n            reserved: [_priorityOpParams.valueToMint, uint256(uint160(_priorityOpParams.refundRecipient)), 0, 0],\n            data: _calldata,\n            signature: new bytes(0),\n            factoryDeps: _hashFactoryDeps(_factoryDeps),\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        WritePriorityOpParams memory _priorityOpParams,\n        bytes calldata _calldata,\n        bytes[] calldata _factoryDeps\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams, _calldata, _factoryDeps);\n\n        bytes memory transactionEncoding = abi.encode(transaction);\n\n        TransactionValidator.validateL1ToL2Transaction(transaction, transactionEncoding, s.priorityTxMaxGasLimit);\n\n        canonicalTxHash = keccak256(transactionEncoding);\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationTimestamp: _priorityOpParams.expirationTimestamp,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that is needed for the operator to simulate priority queue offchain\n        emit NewPriorityRequest(\n            _priorityOpParams.txId,\n            canonicalTxHash,\n            _priorityOpParams.expirationTimestamp,\n            transaction,\n            _factoryDeps\n        );\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] calldata _factoryDeps)\n        internal\n        pure\n        returns (uint256[] memory hashedFactoryDeps)\n    {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n\n    /// @dev Decode the withdraw message that came from L2\n    function _parseL2WithdrawalMessage(bytes memory _message)\n        internal\n        pure\n        returns (address l1Receiver, uint256 amount)\n    {\n        // We check that the message is long enough to read the data.\n        // Please note that there are two versions of the message:\n        // 1. The message that is sent by `withdraw(address _l1Receiver)`\n        // It should be equal to the length of the bytes4 function signature + address l1Receiver + uint256 amount = 4 + 20 + 32 = 56 (bytes).\n        // 2. The message that is sent by `withdrawWithMessage(address _l1Receiver, bytes calldata _additionalData)`\n        // It should be equal to the length of the following:\n        // bytes4 function signature + address l1Receiver + uint256 amount + address l2Sender + bytes _additionalData =\n        // = 4 + 20 + 32 + 32 + _additionalData.length >= 68 (bytes).\n\n        // So the data is expected to be at least 56 bytes long.\n        require(_message.length >= 56, \"pm\");\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_message, 0);\n        require(bytes4(functionSignature) == this.finalizeEthWithdrawal.selector, \"is\");\n\n        (l1Receiver, offset) = UnsafeBytes.readAddress(_message, offset);\n        (amount, offset) = UnsafeBytes.readUint256(_message, offset);\n    }\n}"
    },
    {
      "filename": "code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport {IMailbox, TxStatus} from \"../interfaces/IMailbox.sol\";\nimport {Merkle} from \"../libraries/Merkle.sol\";\nimport {PriorityQueue, PriorityOperation} from \"../libraries/PriorityQueue.sol\";\nimport {TransactionValidator} from \"../libraries/TransactionValidator.sol\";\nimport {L2Message, L2Log} from \"../Storage.sol\";\nimport {UncheckedMath} from \"../../common/libraries/UncheckedMath.sol\";\nimport {UnsafeBytes} from \"../../common/libraries/UnsafeBytes.sol\";\nimport {L2ContractHelper} from \"../../common/libraries/L2ContractHelper.sol\";\nimport {AddressAliasHelper} from \"../../vendor/AddressAliasHelper.sol\";\nimport {IAllowList} from \"../../common/interfaces/IAllowList.sol\";\nimport {Base} from \"./Base.sol\";\nimport {\n    REQUIRED_L2_GAS_PRICE_PER_PUBDATA,\n    FAIR_L2_GAS_PRICE,\n    L1_GAS_PER_PUBDATA_BYTE,\n    L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH,\n    PRIORITY_OPERATION_L2_TX_TYPE,\n    PRIORITY_EXPIRATION,\n    MAX_NEW_FACTORY_DEPS\n} from \"../Config.sol\";\nimport {\n    L2_BOOTLOADER_ADDRESS,\n    L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n    L2_ETH_TOKEN_SYSTEM_CONTRACT_ADDR\n} from \"../../common/L2ContractAddresses.sol\";\n\n\n/// @title zkSync Mailbox contract providing interfaces for L1 <-> L2 interaction.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract MailboxFacet is Base, IMailbox {\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    string public constant override getName = \"MailboxFacet\";\n\n    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 batch number\n    /// @param _batchNumber The executed L2 batch number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 batch where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @notice Prove that a specific L2 log was sent in a specific L2 batch\n    /// @param _batchNumber The executed L2 batch number in which the log appeared\n    /// @param _index The position of the l2log in the L2 logs Merkle tree\n    /// @param _log Information about the sent log\n    /// @param _proof Merkle proof for inclusion of the L2 log\n    /// @return Whether the proof is correct and L2 log is included in batch\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @notice Prove that the L1 -> L2 transaction was processed with the specified status.\n    /// @param _l2TxHash The L2 canonical transaction hash\n    /// @param _l2BatchNumber The L2 batch number where the transaction was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction\n    /// @param _status The execution status of the L1 -> L2 transaction (true - success & 0 - fail)\n    /// @return Whether the proof is correct and the transaction was actually executed with provided status\n    /// NOTE: It may return `false` for incorrect proof, but it doesn't mean that the L1 -> L2 transaction has an opposite status!\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view override returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    /// @notice Transfer ether from the contract to the receiver\n    /// @dev Reverts only if the transfer call failed\n    function _withdrawFunds(address _to, uint256 _amount) internal {\n        bool callSuccess;\n        // Low-level assembly call, to avoid any memory copying (save gas)\n        assembly {\n            callSuccess := call(gas(), _to, _amount, 0, 0, 0, 0)\n        }\n        require(callSuccess, \"pz\");\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, \"xx\");\n\n        bytes32 hashedLog = keccak256(\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, \"tw\");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    /// @param _gasPrice expected L1 gas price at which the user requests the transaction execution\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount of L2 gas that the operator may charge the user for a single byte of pubdata.\n    /// @return The estimated ETH spent on L2 gas for the transaction\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public pure returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in ETH to be paid.\n    /// @param _l1GasPrice The gas price on L1.\n    /// @param _gasPricePerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in ETH\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPricePerPubdata) internal pure returns (uint256) {\n        uint256 pubdataPriceETH = L1_GAS_PER_PUBDATA_BYTE * _l1GasPrice;\n        uint256 minL2GasPriceETH = (pubdataPriceETH + _gasPricePerPubdata - 1) / _gasPricePerPubdata;\n\n        return Math.max(FAIR_L2_GAS_PRICE, minL2GasPriceETH);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external override nonReentrant senderCanCallFunction(s.allowList) {\n        require(!s.isEthWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex], \"jj\");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_ETH_TOKEN_SYSTEM_CONTRACT_ADDR,\n            data: _message\n        });\n\n        (address _l1WithdrawReceiver, uint256 _amount) = _parseL2WithdrawalMessage(_message);\n\n        bool proofValid = proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n        require(proofValid, \"pi\"); // Failed to verify that withdrawal was actually initialized on L2\n\n        s.isEthWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex] = true;\n        _withdrawFunds(_l1WithdrawReceiver, _amount);\n\n        emit EthWithdrawalFinalized(_l1WithdrawReceiver, _amount);\n    }\n\n    /// @notice Request execution of L2 transaction from L1.\n    /// @param _contractL2 The L2 receiver address\n    /// @param _l2Value `msg.value` of L2 transaction\n    /// @param _calldata The input of the L2 transaction\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount L2 gas that the operator may charge the user for single byte of pubdata.\n    /// @param _factoryDeps A"
    }
  ]
}