{
  "Title": "[H-01] Permanent DOS in `liquidity_lockbox` for under $10",
  "Content": "\n<https://github.com/code-423n4/2023-12-autonolas/blob/main/lockbox-solana/solidity/liquidity_lockbox.sol#L54> <br><https://github.com/code-423n4/2023-12-autonolas/blob/main/lockbox-solana/solidity/liquidity_lockbox.sol#L181-L184>\n\nThe `liquidity_lockbox` contract in the `lockbox-solana` project is vulnerable to permanent DOS due to its storage limitations. The contract uses a Program Derived Address (PDA) as a data account, which is created with a maximum size limit of 10 KB.\n\nEvery time the `deposit()` function is called, a new element is added to `positionAccounts`, `mapPositionAccountPdaAta`, and `mapPositionAccountLiquidity`, which decreases the available storage by `64 + 32 + 32 = 128` bits. This means that the contract will run out of space after at most `80000 / 128 = 625` deposits.\n\nOnce the storage limit is reached, no further deposits can be made, effectively causing a permanent DoS condition. This could be exploited by an attacker to block the contract's functionality at a very small cost.\n\n### Proof of Concept\n\nAn attacker can cause a permanent DoS of the contract by calling `deposit()` with the minimum position size only 625 times. This will fill up the storage limit of the PDA, preventing any further deposits from being made.\n\nSince neither the contract nor seemingly Orca's pool contracts impose a limitation on the minimum position size, this can be achieved at a very low cost of `625 * dust * transaction fees`:\n\n<img width=\"400\" alt=\"no min deposit in SOL/OLAS pool\" src=\"https://github.com/code-423n4/org/assets/153658521/48ca4eb0-5a4f-4310-a9ac-7869afa17ae8\">\n\n### Recommended Mitigation Steps\n\nThe maximum size of a PDA is 10 **KiB** on creation, only slightly larger than the current allocated space of 10 KB. The Solana SDK does provide a method to resize a data account ([source](https://docs.rs/solana-sdk/latest/solana_sdk/account_info/struct.AccountInfo.html#method.realloc)), but this functionality isn't currently implemented in Solang ([source](https://github.com/hyperledger/solang/issues/1434)).\n\nA potential solution to this issue is to use an externally created account as a data account, which can have a size limit of up to 10 MiB, as explained in this [StackExchange post](https://solana.stackexchange.com/a/46).\n\nAlternatively, free up space by [clearing](https://solang.readthedocs.io/en/latest/language/contract_storage.html#how-to-clear-contract-storage) the aforementioned variables in storage for withdrawn positions.\n\nHowever, a more prudent security recommendation would be to leverage the Solana SDK directly, despite the potential need for contract reimplementation and the learning curve associated with Rust. The Solana SDK offers greater flexibility and is less likely to introduce unforeseen vulnerabilities. Solang, while a valuable tool, is still under active development and will usually lag behind the SDK, which could inadvertently introduce complexity and potential vulnerabilities due to compiler discrepancies.\n\n**[kupermind (Olas) confirmed](https://github.com/code-423n4/2023-12-autonolas-findings/issues/445#issuecomment-1892614507)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-12-autonolas",
  "Code": [
    {
      "filename": "lockbox-solana/solidity/liquidity_lockbox.sol",
      "content": "import \"./library/spl_token.sol\";\nimport \"./interfaces/whirlpool.sol\";\n\n// Position struct\nstruct Position {\n    // Whirlpool (LP pool) address, 32 bytes\n    address whirlpool;\n    // Position mint (liquidity NFT) address, 32 bytes\n    address positionMint;\n    // Position liquidity, 16 bytes\n    uint128 liquidity;\n    // Tick lower index, 4 bytes\n    int32 tickLowerIndex;\n    /// Tick upper index, 4 bytes\n    int32 tickUpperIndex;\n}\n\n/// @dev The liquidity in the position cannot be practically bigger than the max of uint64 since\n///      spl token functions are limited by the uint64 value.\n\n@program_id(\"GUGGHzwC8wEKY3g7QS38YmoS8t5Q2faWAGAfxDK2bXbb\")\ncontract liquidity_lockbox {\n    // Orca whirlpool program address\n    address public constant orca = address\"whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc\";\n    // Whirlpool (LP) pool address\n    address public pool;\n    // Current program owned PDA account address\n    address public pdaProgram;\n    // Bridged token mint address\n    address public bridgedTokenMint;\n    // PDA bridged token account address\n    address public pdaBridgedTokenAccount;\n    // PDA header for position account\n    uint64 public pdaHeader = 0xd0f7407ae48fbcaa;\n    // Program PDA seed\n    bytes public constant pdaProgramSeed = \"pdaProgram\";\n    // Program PDA bump\n    bytes1 public pdaBump;\n    int32 public constant minTickLowerIndex = -443632;\n    int32 public constant maxTickLowerIndex = 443632;\n\n    // Total number of token accounts (even those that hold no positions anymore)\n    uint32 public numPositionAccounts;\n    // First available account index in the set of accounts;\n    uint32 public firstAvailablePositionAccountIndex;\n    // Total liquidity in a lockbox\n    uint64 public totalLiquidity;\n\n    //\n    mapping(address => uint64) public mapPositionAccountLiquidity;\n    mapping(address => address) public mapPositionAccountPdaAta;\n    address[type(uint32).max] public positionAccounts;\n\n    @space(10000)\n    @payer(payer)\n    @seed(\"pdaProgram\")\n    constructor(\n        address _pool,\n        address _bridgedTokenMint,\n        address _pdaBridgedTokenAccount,\n        @bump bytes1 _bump\n    ) {\n        pool = _pool;\n        bridgedTokenMint = _bridgedTokenMint;\n        pdaBridgedTokenAccount = _pdaBridgedTokenAccount;\n\n        // Independently derive the PDA address from the seeds, bump, and programId\n        (address pda, bytes1 bump) = try_find_program_address([\"pdaProgram\"], type(liquidity_lockbox).program_id);\n\n        // Verify that the bump passed to the constructor matches the bump derived from the seeds and programId\n        if (bump != _bump) {\n            revert(\"Invalid bump\");\n        }\n\n        // Assign pda and bump\n        pdaProgram = pda;\n        pdaBump = bump;\n    }\n\n    /// @dev Gets the position data.\n    /// @param position Position account.\n    /// @param positionMint Position mint (NFT).\n    /// @return positionData Position data.\n    function _getPositionData(AccountInfo position, address positionMint) internal view returns (Position positionData) {\n        // Extract the position data\n        positionData = Position({\n            whirlpool: position.data.readAddress(8),\n            positionMint: position.data.readAddress(40),\n            liquidity: position.data.readUint128LE(72),\n            tickLowerIndex: position.data.readInt32LE(88),\n            tickUpperIndex: position.data.readInt32LE(92)\n        });\n\n        // Check that the liquidity is within uint64 bounds\n        if (positionData.liquidity > type(uint64).max) {\n            revert(\"Liquidity overflow\");\n        }\n\n        // Check the whirlpool\n        if (positionData.whirlpool != pool) {\n            revert(\"Wrong pool address\");\n        }\n\n        // Check the NFT address\n        if (positionData.positionMint != positionMint) {\n            revert(\"Wrong NFT address\");\n        }\n\n        // Check tick values\n        if (positionData.tickLowerIndex != minTickLowerIndex || positionData.tickUpperIndex != maxTickLowerIndex) {\n            revert(\"Wrong ticks\");\n        }\n\n        // Check the PDA ownership\n        if (position.owner != orca) {\n            revert(\"Wrong PDA owner\");\n        }\n\n        // Check the PDA header data\n        uint64 header = position.data.readUint64LE(0);\n        if (header != pdaHeader) {\n            revert(\"Wrong PDA header\");\n        }\n\n        // Check the PDA address correctness\n        (address pdaPosition, ) = try_find_program_address([\"position\", positionData.positionMint], orca);\n        if (pdaPosition != position.key) {\n            revert(\"Wrong position PDA\");\n        }\n    }\n\n    /// @dev Deposits the position mint (NFT) in order to get a corresponding liquidity amount of bridged tokens\n    @mutableAccount(userPositionAccount)\n    @mutableAccount(pdaPositionAccount)\n    @mutableAccount(userBridgedTokenAccount)\n    @mutableAccount(bridgedTokenMint)\n    @account(position)\n    @account(positionMint)\n    @signer(userWallet)\n    function deposit() external {\n        // Get the position data based on provided accounts\n        Position positionData = _getPositionData(tx.accounts.position, tx.accounts.positionMint.key);\n\n        uint64 positionLiquidity = uint64(positionData.liquidity);\n\n        // Check that the mint of the user position ATA matches the position mint\n        address positionMint = tx.accounts.userPositionAccount.data.readAddress(0);\n        if (positionMint != tx.accounts.positionMint.key) {\n            revert(\"Wrong user position ATA\");\n        }\n\n        // Check that the bridged token mint account is correct\n        if (tx.accounts.bridgedTokenMint.key != bridgedTokenMint) {\n            revert(\"Wrong bridged token mint account\");\n        }\n\n        // PDA position account owner must be the PDA program account\n        address pdaPositionOwner = tx.accounts.pdaPositionAccount.data.readAddress(32);\n        if (pdaPositionOwner != pdaProgram) {\n            revert(\"Wrong PDA position owner\");\n        }\n\n        // Transfer the position NFT to the pdaPositionAccount address of this program\n        SplToken.transfer(\n            tx.accounts.userPositionAccount.key,\n            tx.accounts.pdaPositionAccount.key,\n            tx.accounts.userWallet.key,\n            1);\n\n        // Mint bridged tokens to the user\n        SplToken.pda_mint_to(\n            bridgedTokenMint,\n            tx.accounts.userBridgedTokenAccount.key,\n            pdaProgram,\n            positionLiquidity,\n            pdaProgramSeed,\n            pdaBump);\n\n        // Record position liquidity amount and its correspondent account address\n        address positionAddress = tx.accounts.position.key;\n        mapPositionAccountLiquidity[positionAddress] = positionLiquidity;\n        address pdaPositionAta = tx.accounts.pdaPositionAccount.key;\n        mapPositionAccountPdaAta[positionAddress] = pdaPositionAta;\n        positionAccounts[numPositionAccounts] = positionAddress;\n\n        // Increase the total number of positions\n        numPositionAccounts++;\n        // Increase the amount of total liquidity\n        totalLiquidity += positionLiquidity;\n    }\n\n    /// @dev Withdraws LP tokens separately to each token ATA and burns provided bridge tokens.\n    /// @param amount Bridged token amount.\n    @mutableAccount(pool)\n    @account(tokenProgramId)\n    @mutableAccount(position)\n    @mutableAccount(userBridgedTokenAccount)\n    @mutableAccount(pdaBridgedTokenAccount)\n    @mutableAccount(userWallet)\n    @mutableAccount(bridgedTokenMint)\n    @mutableAccount(pdaPositionAccount)\n    @mutableAccount(userTokenAccountA)\n    @mutableAccount(userTokenAccountB)\n    @mutableAccount(tokenVaultA)\n    @mutableAccount(tokenVaultB)\n    @mutableAccount(tickArrayLower)\n    @mutableAccount(tickArrayUpper)\n    @mutableAccount(positionMint)\n    @signer(sig)\n    function withdraw(uint64 amount) external {\n        address positionAddress = positionAccounts[firstAvailablePositionAccountIndex];\n        if (positionAddress != tx.accounts.position.key) {\n            revert(\"Wrong liquidity token account\");\n        }\n\n        address pdaPositionAta = tx.accounts.pdaPositionAccount.key;\n        if (mapPositionAccountPdaAta[positionAddress] != pdaPositionAta) {\n            revert(\"Wrong position ATA\");\n        }\n\n        uint64 positionLiquidity = mapPositionAccountLiquidity[positionAddress];\n        // Check that the token account exists\n        if (positionLiquidity == 0) {\n            revert(\"No liquidity on a provided token account\");\n        }\n\n        // Check the requested amount to be smaller or equal than the position liquidity\n        if (amount > positionLiquidity) {\n            revert(\"Amount exceeds a position liquidity\");\n        }\n\n        // Check the pdaBridgedTokenAccount address\n        if (tx.accounts.pdaBridgedTokenAccount.key != pdaBridgedTokenAccount) {\n            revert(\"Wrong PDA bridged token ATA\");\n        }\n\n        // Check that the pool is correct\n        if (tx.accounts.pool.key != pool) {\n            revert(\"Pool address is incorrect\");\n        }\n\n        // Check that the bridged token mint account is correct\n        if (tx.accounts.bridgedTokenMint.key != bridgedTokenMint) {\n            revert(\"Wrong bridged token mint account\");\n        }\n\n        // Transfer bridged tokens to the pdaBridgedTokenAccount address of this program\n        SplToken.transfer(\n            tx.accounts.userBridgedTokenAccount.key,\n            pdaBridgedTokenAccount,\n            tx.accounts.userWallet.key,\n            amount);\n\n        // Decrease the total liquidity amount\n        totalLiquidity -= amount;\n\n        // Burn acquired bridged tokens\n        SplToken.pda_burn(pdaBridgedTokenAccount, bridgedTokenMint, pdaProgram, amount, pdaProgramSeed, pdaBump);\n\n        // Decrease the position liquidity\n        AccountMeta[11] metasDecreaseLiquidity = [\n            AccountMeta({pubkey: pool, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: SplToken.tokenProgramId, is_writable: false, is_signer: false}),\n            AccountMeta({pubkey: pdaProgram, is_writable: false, is_signer: true}),\n            AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: pdaPositionAta, is_writable: false, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.userTokenAccountA.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.userTokenAccountB.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.tokenVaultA.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.tokenVaultB.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.tickArrayLower.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.tickArrayUpper.key, is_writable: true, is_signer: false})\n        ];\n        // a026d06f685b2c01 - decreaseLiquidity, eff0ae00000000000000000000000000 - amount, aaf1950200000000 - minA, b8522d0000000000 - minB\n        // bytes bincode = \"0xa026d06f685b2c01eff0ae00000000000000000000000000aaf1950200000000b8522d0000000000\";\n        // orca.call{accounts: metasDecreaseLiquidity, seeds: [[pdaProgramSeed, pdaBump]]}(bincode);\n        whirlpool.decreaseLiquidity{accounts: metasDecreaseLiquidity, seeds: [[pdaProgramSeed, pdaBump]]}(amount, 0, 0);\n\n        // Update the token remainder\n        uint64 remainder = positionLiquidity - amount;\n        // Update liquidity and its associated position account\n        mapPositionAccountLiquidity[positionAddress] = remainder;\n\n        // If requested amount can be fully covered by the current position liquidity, close the position\n        if (remainder == 0) {\n            // Update fees for the position\n            AccountMeta[4] metasUpdateFees = [\n                AccountMeta({pubkey: pool, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.tickArrayLower.key, is_writable: false, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.tickArrayUpper.key, is_writable: false, is_signer: false})\n            ];\n            whirlpool.updateFeesAndRewards{accounts: metasUpdateFees, seeds: [[pdaProgramSeed, pdaBump]]}();\n\n            // Collect fees from the position\n            AccountMeta[9] metasCollectFees = [\n                AccountMeta({pubkey: pool, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: pdaProgram, is_writable: false, is_signer: true}),\n                AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: pdaPositionAta, is_writable: false, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.userTokenAccountA.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.tokenVaultA.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.userTokenAccountB.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.tokenVaultB.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: SplToken.tokenProgramId, is_writable: false, is_signer: false})\n            ];\n            whirlpool.collectFees{accounts: metasCollectFees, seeds: [[pdaProgramSeed, pdaBump]]}();\n\n            // Close the position\n            AccountMeta[6] metasClosePosition = [\n                AccountMeta({pubkey: pdaProgram, is_writable: false, is_signer: true}),\n                AccountMeta({pubkey: tx.accounts.userWallet.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.positionMint.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: pdaPositionAta, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: SplToken.tokenProgramId, is_writable: false, is_signer: false})\n            ];\n            whirlpool.closePosition{accounts: metasClosePosition, seeds: [[pdaProgramSeed, pdaBump]]}();\n\n            // Increase the first available position account index\n            firstAvailablePositionAccountIndex++;\n        }\n    }\n\n    /// @dev Gets the position data.\n    /// @return Position data.\n    @account(position)\n    @account(positionMint)\n    function getPositionData() external view returns (Position) {\n        return _getPositionData(tx.accounts.position, tx.accounts.positionMint.key);\n    }\n\n    /// @dev Gets liquidity amounts and position accounts in order to correctly withdraw a specified liquidity amount.\n    /// @param amount Liquidity amount to withdraw.\n    /// @return positionAmounts Position amounts.\n    /// @return positionAddresses Position mint addresses.\n    /// @return positionPdaAtas Position PDA ATA-s controlled by the program.\n    function getLiquidityAmountsAndPositions(uint64 amount)\n        external view returns (uint64[] positionAmounts, address[] positionAddresses, address[] positionPdaAtas)\n    {\n        if (amount > totalLiquidity) {\n            revert (\"Requested amount is too big for the total available liquidity\");\n        }\n\n        uint64 liquiditySum = 0;\n        uint32 numPositions = 0;\n        uint64 amountLeft = 0;\n\n        // Get the number of allocated positions\n        for (uint32 i = firstAvailablePositionAccountIndex; i < numPositionAccounts; ++i) {\n            address positionAddress = positionAccounts[i];\n            uint64 positionLiquidity = mapPositionAccountLiquidity[positionAddress];\n\n            // Increase a total calculated liquidity and a number of positions to return\n            liquiditySum += positionLiquidity;\n            numPositions++;\n\n            // Check if the accumulated liquidity is enough to cover the requested amount\n            if (liquiditySum >= amount) {\n                amountLeft = liquiditySum - amount;\n                break;\n            }\n        }\n\n        // Allocate the necessary arrays and fill the values\n        positionAddresses = new address[](numPositions);\n        positionAmounts = new uint64[](numPositions);\n        positionPdaAtas = new address[](numPositions);\n        for (uint32 i = 0; i < numPositions; ++i) {\n            positionAddresses[i] = positionAccounts[firstAvailablePositionAccountIndex + i];\n            positionAmounts[i] = mapPositionAccountLiquidity[positionAddresses[i]];\n            positionPdaAtas[i] = mapPositionAccountPdaAta[positionAddresses[i]];\n        }\n\n        // Adjust the last position, if it was not fully allocated\n        if (numPositions > 0 && amountLeft > 0) {\n            positionAmounts[numPositions - 1] = amountLeft;\n        }\n    }\n\n    /// @dev Gets token account balance.\n    @account(account)\n    function getBalance() external view returns (uint64) {\n        return SplToken.get_balance(tx.accounts.account);\n    }\n\n    /// @dev Gets total supply of a provided token account.\n    @account(account)\n    function totalSupply() external view returns (uint64) {\n        return SplToken.total_supply(tx.accounts.account);\n    }\n}"
    }
  ]
}