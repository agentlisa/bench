{
  "Title": "[M03] Rounding errors in Roots library reduce FEI received from bonding curve",
  "Content": "The [`Roots` library](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/utils/Roots.sol#L5) implements a [`cubeRoot` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/utils/Roots.sol#L7-L18). It then implements a [`twoThirdsRoot` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/utils/Roots.sol#L26-L28) which calls `cubeRoot`. This `twoThirdsRoot` function can have large rounding errors due to the order of operations. The `cubeRoot` function returns a truncated integer, which is then squared in the `twoThirdsRoot` function. The effect is that the `twoThirdsRoot` function is biased downwards, potentially significantly depending on the scale. For example, `twoThirdsRoot(124)` returns 16, whereas the true value is approximately 24.87.\n\n\nThe `Roots` library also implements a [`threeHalfsRoot` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/utils/Roots.sol#L21-L23) which suffers the same downward bias caused by incorrect order of operations. This `threeHalfsRoot` function calls the [`sqrt` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/utils/Roots.sol#L30-L32) which returns a truncated value. The `threeHalfsRoot` function then raises the truncated value to the power of three. Again, results may significantly deviate from expected values. For example, `threeHalfsRoot(8)` returns 8, whereas the true value is approximately 22.63.\n\n\nThe `threeHalfsRoot` and `twoThirdsRoot` functions are called from the [`_getBondingCurveAmountOut` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/bondingcurve/EthBondingCurve.sol#L36-L37), which is used to calculate the `amountOut` for every purchase made before the protocol reaches scale via the [`getAmountOut` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/bondingcurve/BondingCurve.sol#L84-L90).\n\n\nAs is, the `twoThirdsRoot` and `threeHalfsRoot` functions scale well, with relatively small percentage errors on big numbers. By changing the order of operations in the [`twoThirdsRoot`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/utils/Roots.sol#L27) and [`threeHalfsRoot`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/utils/Roots.sol#L22) functions, we observed a decrease in the propagated discrepancy in the `BondingCurve` test for the `Pre Scale` scenario which checks for the [`Correct`FEI`sent`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/test/bondingcurve/EthBondingCurve.test.js#L52-L54). Do note, the test was written to expect a value of `51529`, but the correct value is `51977`, so the test fails after increasing the accuracy of the `twoThirdsRoot` and `threeHalfsRoot` functions.\n\n\nConsider combining the arithmetic functions and changing the order of operations such that truncating steps are performed last while being mindful of potential overflows.\n\n\n**Update:** *Fixed in [PR#31](https://github.com/fei-protocol/fei-protocol-core/pull/31). In the words of the Fei team: “This change reduced the error by 1-2 orders of magnitude on the number ranges in this test class”.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/utils/Roots.sol",
      "content": "pragma solidity ^0.6.0;\n\nimport \"@uniswap/lib/contracts/libraries/Babylonian.sol\";\n\nlibrary Roots {\n    // Newton's method https://en.wikipedia.org/wiki/Cube_root#Numerical_methods\n    function cubeRoot(uint y) internal pure returns (uint z) {\n        if (y > 7) {\n            z = y;\n            uint x = y / 3 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / (x * x) + (2 * x)) / 3;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    // x^(3/2);\n    function threeHalfsRoot(uint x) internal pure returns (uint) {\n        return sqrt(x) ** 3;\n    }\n\n    // x^(2/3);\n    function twoThirdsRoot(uint x) internal pure returns (uint) {\n        return cubeRoot(x) ** 2;\n    }\n\n    function sqrt(uint y) internal pure returns (uint) {\n        return Babylonian.sqrt(y);\n    }\n}"
    },
    {
      "filename": "contracts/utils/Roots.sol",
      "content": "pragma solidity ^0.6.0;\n\nimport \"@uniswap/lib/contracts/libraries/Babylonian.sol\";\n\nlibrary Roots {\n    // Newton's method https://en.wikipedia.org/wiki/Cube_root#Numerical_methods\n    function cubeRoot(uint y) internal pure returns (uint z) {\n        if (y > 7) {\n            z = y;\n            uint x = y / 3 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / (x * x) + (2 * x)) / 3;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    // x^(3/2);\n    function threeHalfsRoot(uint x) internal pure returns (uint) {\n        return sqrt(x) ** 3;\n    }\n\n    // x^(2/3);\n    function twoThirdsRoot(uint x) internal pure returns (uint) {\n        return cubeRoot(x) ** 2;\n    }\n\n    function sqrt(uint y) internal pure returns (uint) {\n        return Babylonian.sqrt(y);\n    }\n}"
    },
    {
      "filename": "contracts/bondingcurve/EthBondingCurve.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./BondingCurve.sol\";\nimport \"../pcv/IPCVDeposit.sol\";\n\n/// @title a square root growth bonding curve for purchasing FEI with ETH\n/// @author Fei Protocol\ncontract EthBondingCurve is BondingCurve {\n\n\tconstructor(\n\t\tuint scale, \n\t\taddress core, \n\t\taddress[] memory pcvDeposits, \n\t\tuint[] memory ratios, \n\t\taddress oracle,\n\t\tuint32 duration,\n\t\tuint incentive\n\t) public BondingCurve(\n\t\t\tscale, \n\t\t\tcore, \n\t\t\tpcvDeposits, \n\t\t\tratios, \n\t\t\toracle, \n\t\t\tduration,\n\t\t\tincentive\n\t) {}\n\n\tfunction purchase(address to, uint amountIn) external override payable postGenesis returns (uint amountOut) {\n\t\trequire(msg.value == amountIn, \"Bonding Curve: Sent value does not equal input\");\n\t\treturn _purchase(amountIn, to);\n\t}\n\n\t// Represents the integral solved for upper bound of P(x) = (X/S)^1/2 * O\n\tfunction _getBondingCurveAmountOut(uint adjustedAmountIn) internal view override returns (uint amountOut) {\n\t\tuint radicand = (3 * adjustedAmountIn * scale.sqrt() / 2) + totalPurchased.threeHalfsRoot();\n\t\treturn radicand.twoThirdsRoot() - totalPurchased;\n\t}\n\n\tfunction _getBondingCurvePriceMultiplier() internal view override returns(Decimal.D256 memory) {\n\t\treturn Decimal.ratio(totalPurchased.sqrt(), scale.sqrt());\n\t}\n\n\tfunction _allocateSingle(uint amount, address pcvDeposit) internal override {\n\t\tIPCVDeposit(pcvDeposit).deposit{value : amount}(amount);\n\t}\n\n\tfunction getTotalPCVHeld() public view override returns(uint) {\n\t\treturn address(this).balance;\n\t}\n}"
    },
    {
      "filename": "contracts/utils/Roots.sol",
      "content": "pragma solidity ^0.6.0;\n\nimport \"@uniswap/lib/contracts/libraries/Babylonian.sol\";\n\nlibrary Roots {\n    // Newton's method https://en.wikipedia.org/wiki/Cube_root#Numerical_methods\n    function cubeRoot(uint y) internal pure returns (uint z) {\n        if (y > 7) {\n            z = y;\n            uint x = y / 3 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / (x * x) + (2 * x)) / 3;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    // x^(3/2);\n    function threeHalfsRoot(uint x) internal pure returns (uint) {\n        return sqrt(x) ** 3;\n    }\n\n    // x^(2/3);\n    function twoThirdsRoot(uint x) internal pure returns (uint) {\n        return cubeRoot(x) ** 2;\n    }\n\n    function sqrt(uint y) internal pure returns (uint) {\n        return Babylonian.sqrt(y);\n    }\n}"
    }
  ]
}