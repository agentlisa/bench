{
  "Title": "[M05] Excessive Curve 3Pool withdrawal",
  "Content": "When withdrawing funds from the `ThreePoolStrategy`, the number of LP tokens to burn is determined by [retrieving the asset value of all LP tokens](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/strategies/ThreePoolStrategy.sol#L178-L181), and then [scaling down linearly](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/strategies/ThreePoolStrategy.sol#L184) to the desired withdrawal amount. However, not all LP tokens are valued equally: as the size of the withdrawal increases, the value of each LP token should decrease. This means [the withdrawal](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/strategies/ThreePoolStrategy.sol#L201-L206) will retrieve too many tokens.\n\n\nTo account for this, any excess tokens are [sent to the vault](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/strategies/ThreePoolStrategy.sol#L209-L212). The comments and variables names suggest that the excess amount would be negligible. However, since most use cases involve withdrawing a small fraction of all the assets invested by this strategy, and the discrepancy increases as the fraction decreases, it could be significant. It is worth noting that excess funds that are sent to the vault do not automatically trigger a reallocation if they exceed the internal liquidity buffer.\n\n\nTo avoid excess withdrawals, consider using [the `calc_token_amount` function](https://curve.readthedocs.io/exchange-pools.html#StableSwap.calc_token_amount) to determine the number of LP tokens to burn or [the `remove_liquidity_imbalance` function](https://curve.readthedocs.io/exchange-pools.html#StableSwap.remove_liquidity_imbalance) to withdraw a specific amount of asset tokens.\n\n\n**Update:** *Partially fixed in [PR#718](https://github.com/OriginProtocol/origin-dollar/pull/718). Although `remove_liquidity_imbalance` is now used to avoid excess withdrawal from Curveâ€™s 3Pool, the strategy contract [still withdraws, at most, the maximum amount needed from the Gauge](https://github.com/OriginProtocol/origin-dollar/blob/685771c2ea2e20d73440382eb1353e67bb2f7c8e/contracts/contracts/strategies/ThreePoolStrategy.sol#L184-L191). In addition, the strict in inequality in [this require statement](https://github.com/OriginProtocol/origin-dollar/blob/685771c2ea2e20d73440382eb1353e67bb2f7c8e/contracts/contracts/strategies/ThreePoolStrategy.sol#L183) makes it impossible to withdraw the max amount of `pTokens`.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/contracts/strategies/ThreePoolStrategy.sol",
      "content": "pragma solidity 0.5.11;\n\n/**\n * @title Curve 3Pool Strategy\n * @notice Investment strategy for investing stablecoins via Curve 3Pool\n * @author Origin Protocol Inc\n */\n\nimport { ICurvePool } from \"./ICurvePool.sol\";\nimport { ICurveGauge } from \"./ICurveGauge.sol\";\nimport { ICRVMinter } from \"./ICRVMinter.sol\";\nimport {\n    IERC20,\n    InitializableAbstractStrategy\n} from \"../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\n\ncontract ThreePoolStrategy is InitializableAbstractStrategy {\n    using StableMath for uint256;\n\n    event RewardTokenCollected(address recipient, uint256 amount);\n\n    address crvGaugeAddress;\n    address crvMinterAddress;\n    uint256 constant maxSlippage = 1e16; // 1%, same as the Curve UI\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as Curve strategies don't fit\n     * well within that abstraction.\n     * @param _platformAddress Address of the Curve 3pool\n     * @param _vaultAddress Address of the vault\n     * @param _rewardTokenAddress Address of CRV\n     * @param _assets Addresses of supported assets. MUST be passed in the same\n     *                order as returned by coins on the pool contract, i.e.\n     *                DAI, USDC, USDT\n     * @param _pTokens Platform Token corresponding addresses\n     * @param _crvGaugeAddress Address of the Curve DAO gauge for this pool\n     * @param _crvMinterAddress Address of the CRV minter for rewards\n     */\n    function initialize(\n        address _platformAddress, // 3Pool address\n        address _vaultAddress,\n        address _rewardTokenAddress, // CRV\n        address[] calldata _assets,\n        address[] calldata _pTokens,\n        address _crvGaugeAddress,\n        address _crvMinterAddress\n    ) external onlyGovernor initializer {\n        // Should be set prior to abstract initialize call otherwise\n        // abstractSetPToken calls will fail\n        crvGaugeAddress = _crvGaugeAddress;\n        crvMinterAddress = _crvMinterAddress;\n        InitializableAbstractStrategy._initialize(\n            _platformAddress,\n            _vaultAddress,\n            _rewardTokenAddress,\n            _assets,\n            _pTokens\n        );\n    }\n\n    /**\n     * @dev Collect accumulated CRV and send to Vault.\n     */\n    function collectRewardToken() external onlyVault nonReentrant {\n        IERC20 crvToken = IERC20(rewardTokenAddress);\n        ICRVMinter minter = ICRVMinter(crvMinterAddress);\n        uint256 balance = crvToken.balanceOf(address(this));\n        emit RewardTokenCollected(vaultAddress, balance);\n        minter.mint(crvGaugeAddress);\n        crvToken.safeTransfer(vaultAddress, balance);\n    }\n\n    /**\n     * @dev Deposit asset into the Curve 3Pool\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        onlyVault\n        nonReentrant\n    {\n        require(_amount > 0, \"Must deposit something\");\n        emit Deposit(_asset, address(platformAddress), _amount);\n        // 3Pool requires passing deposit amounts for all 3 assets, set to 0 for\n        // all\n        uint256[3] memory _amounts;\n        uint256 poolCoinIndex = _getPoolCoinIndex(_asset);\n        // Set the amount on the asset we want to deposit\n        _amounts[poolCoinIndex] = _amount;\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        uint256 assetDecimals = Helpers.getDecimals(_asset);\n        uint256 depositValue = _amount\n            .scaleBy(int8(18 - assetDecimals))\n            .divPrecisely(curvePool.get_virtual_price());\n        uint256 minMintAmount = depositValue.mulTruncate(\n            uint256(1e18).sub(maxSlippage)\n        );\n        // Do the deposit to 3pool\n        curvePool.add_liquidity(_amounts, minMintAmount);\n        // Deposit into Gauge\n        IERC20 pToken = IERC20(assetToPToken[_asset]);\n        ICurveGauge(crvGaugeAddress).deposit(\n            pToken.balanceOf(address(this)),\n            address(this)\n        );\n    }\n\n    /**\n     * @dev Deposit the entire balance of any supported asset into the Curve 3pool\n     */\n    function depositAll() external onlyVault nonReentrant {\n        uint256[3] memory _amounts = [uint256(0), uint256(0), uint256(0)];\n        uint256 depositValue = 0;\n        ICurvePool curvePool = ICurvePool(platformAddress);\n\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            address assetAddress = assetsMapped[i];\n            uint256 balance = IERC20(assetAddress).balanceOf(address(this));\n            if (balance > 0) {\n                uint256 poolCoinIndex = _getPoolCoinIndex(assetAddress);\n                // Set the amount on the asset we want to deposit\n                _amounts[poolCoinIndex] = balance;\n                uint256 assetDecimals = Helpers.getDecimals(assetAddress);\n                // Get value of deposit in Curve LP token to later determine\n                // the minMintAmount argument for add_liquidity\n                depositValue = depositValue.add(\n                    balance.scaleBy(int8(18 - assetDecimals)).divPrecisely(\n                        curvePool.get_virtual_price()\n                    )\n                );\n                emit Deposit(assetAddress, address(platformAddress), balance);\n            }\n        }\n\n        uint256 minMintAmount = depositValue.mulTruncate(\n            uint256(1e18).sub(maxSlippage)\n        );\n        // Do the deposit to 3pool\n        curvePool.add_liquidity(_amounts, minMintAmount);\n        // Deposit into Gauge, the PToken is the same (3Crv) for all mapped\n        // assets, so just get the address from the first one\n        IERC20 pToken = IERC20(assetToPToken[assetsMapped[0]]);\n        ICurveGauge(crvGaugeAddress).deposit(\n            pToken.balanceOf(address(this)),\n            address(this)\n        );\n    }\n\n    /**\n     * @dev Withdraw asset from Curve 3Pool\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external onlyVault nonReentrant {\n        require(_recipient != address(0), \"Invalid recipient\");\n        require(_amount > 0, \"Invalid amount\");\n\n        emit Withdrawal(_asset, address(assetToPToken[_asset]), _amount);\n\n        // Calculate how much of the pool token we need to withdraw\n        (uint256 contractPTokens, , uint256 totalPTokens) = _getTotalPTokens();\n\n        require(totalPTokens > 0, \"Insufficient 3CRV balance\");\n\n        uint256 poolCoinIndex = _getPoolCoinIndex(_asset);\n        // Calculate the max amount of the asset we'd get if we withdrew all the\n        // platform tokens\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        uint256 maxAmount = curvePool.calc_withdraw_one_coin(\n            totalPTokens,\n            int128(poolCoinIndex)\n        );\n\n        // Calculate how many platform tokens we need to withdraw the asset amount\n        uint256 withdrawPTokens = totalPTokens.mul(_amount).div(maxAmount);\n        if (contractPTokens < withdrawPTokens) {\n            // Not enough of pool token exists on this contract, some must be\n            // staked in Gauge, unstake difference\n            ICurveGauge(crvGaugeAddress).withdraw(\n                withdrawPTokens.sub(contractPTokens)\n            );\n        }\n\n        // Calculate a minimum withdrawal amount\n        uint256 assetDecimals = Helpers.getDecimals(_asset);\n        // 3crv is 1e18, subtract slippage percentage and scale to asset\n        // decimals\n        uint256 minWithdrawAmount = withdrawPTokens\n            .mulTruncate(uint256(1e18).sub(maxSlippage))\n            .scaleBy(int8(assetDecimals - 18));\n\n        curvePool.remove_liquidity_one_coin(\n            withdrawPTokens,\n            int128(poolCoinIndex),\n            minWithdrawAmount\n        );\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n\n        // Transfer any leftover dust back to the vault buffer.\n        uint256 dust = IERC20(_asset).balanceOf(address(this));\n        if (dust > 0) {\n            IERC20(_asset).safeTransfer(vaultAddress, dust);\n        }\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll() external onlyVaultOrGovernor nonReentrant {\n        // Withdraw all from Gauge\n        (, uint256 gaugePTokens, uint256 totalPTokens) = _getTotalPTokens();\n        ICurveGauge(crvGaugeAddress).withdraw(gaugePTokens);\n        uint256[3] memory minWithdrawAmounts = [\n            uint256(0),\n            uint256(0),\n            uint256(0)\n        ];\n        // Calculate min withdrawal amounts for each coin\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            address assetAddress = assetsMapped[i];\n            uint256 virtualBalance = checkBalance(assetAddress);\n            uint256 poolCoinIndex = _getPoolCoinIndex(assetAddress);\n            minWithdrawAmounts[poolCoinIndex] = virtualBalance.mulTruncate(\n                uint256(1e18).sub(maxSlippage)\n            );\n        }\n        // Remove liqudiity\n        ICurvePool threePool = ICurvePool(platformAddress);\n        threePool.remove_liquidity(totalPTokens, minWithdrawAmounts);\n        // Transfer assets out ot Vault\n        // Note that Curve will provide all 3 of the assets in 3pool even if\n        // we have not set PToken addresses for all of them in this strategy\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            IERC20 asset = IERC20(threePool.coins(i));\n            asset.safeTransfer(vaultAddress, asset.balanceOf(address(this)));\n        }\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        public\n        view\n        returns (uint256 balance)\n    {\n        require(assetToPToken[_asset] != address(0), \"Unsupported asset\");\n        // LP tokens in this contract. This should generally be nothing as we\n        // should always stake the full balance in the Gauge, but include for\n        // safety\n        (, , uint256 totalPTokens) = _getTotalPTokens();\n        ICurvePool curvePool = ICurvePool(platformAddress);\n\n        uint256 pTokenTotalSupply = IERC20(assetToPToken[_asset]).totalSupply();\n        if (pTokenTotalSupply > 0) {\n            uint256 poolCoinIndex = _getPoolCoinIndex(_asset);\n            uint256 curveBalance = curvePool.balances(poolCoinIndex);\n            if (curveBalance > 0) {\n                balance = totalPTokens.mul(curveBalance).div(pTokenTotalSupply);\n            }\n        }\n    }\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) external view returns (bool) {\n        return assetToPToken[_asset] != address(0);\n    }\n\n    /**\n     * @dev Approve the spending of all assets by their corresponding pool tokens,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens() external {\n        // This strategy is a special case since it only supports one asset\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            _abstractSetPToken(assetsMapped[i], assetToPToken[assetsMapped[i]]);\n        }\n    }\n\n    /**\n     * @dev Calculate the total platform token balance (i.e. 3CRV) that exist in\n     * this contract or is staked in the Gauge (or in other words, the total\n     * amount platform tokens we own).\n     * @return totalPTokens Total amount of platform tokens in native decimals\n     */\n    function _getTotalPTokens()\n        internal\n        view\n        returns (\n            uint256 contractPTokens,\n            uint256 gaugePTokens,\n            uint256 totalPTokens\n        )\n    {\n        contractPTokens = IERC20(assetToPToken[assetsMapped[0]]).balanceOf(\n            address(this)\n        );\n        ICurveGauge gauge = ICurveGauge(crvGaugeAddress);\n        gaugePTokens = gauge.balanceOf(address(this));\n        totalPTokens = contractPTokens.add(gaugePTokens);\n    }\n\n    /**\n     * @dev Call the necessary approvals for the Curve pool and gauge\n     * @param _asset Address of the asset\n     * @param _pToken Address of the corresponding platform token (i.e. 3CRV)\n     */\n    function _abstractSetPToken(address _asset, address _pToken) internal {\n        IERC20 asset = IERC20(_asset);\n        IERC20 pToken = IERC20(_pToken);\n        // 3Pool for asset (required for adding liquidity)\n        asset.safeApprove(platformAddress, 0);\n        asset.safeApprove(platformAddress, uint256(-1));\n        // 3Pool for LP token (required for removing liquidity)\n        pToken.safeApprove(platformAddress, 0);\n        pToken.safeApprove(platformAddress, uint256(-1));\n        // Gauge for LP token\n        pToken.safeApprove(crvGaugeAddress, 0);\n        pToken.safeApprove(crvGaugeAddress, uint256(-1));\n    }\n\n    /**\n     * @dev Get the index of the coin in 3pool\n     */\n    function _getPoolCoinIndex(address _asset) internal view returns (uint256) {\n        for (uint256 i = 0; i < 3; i++) {\n            if (assetsMapped[i] == _asset) return i;\n        }\n        revert(\"Invalid 3pool asset\");\n    }\n}"
    },
    {
      "filename": "contracts/contracts/strategies/ThreePoolStrategy.sol",
      "content": "pragma solidity 0.5.11;\n\n/**\n * @title Curve 3Pool Strategy\n * @notice Investment strategy for investing stablecoins via Curve 3Pool\n * @author Origin Protocol Inc\n */\n\nimport { ICurvePool } from \"./ICurvePool.sol\";\nimport { ICurveGauge } from \"./ICurveGauge.sol\";\nimport { ICRVMinter } from \"./ICRVMinter.sol\";\nimport {\n    IERC20,\n    InitializableAbstractStrategy\n} from \"../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\n\ncontract ThreePoolStrategy is InitializableAbstractStrategy {\n    using StableMath for uint256;\n\n    event RewardTokenCollected(address recipient, uint256 amount);\n\n    address crvGaugeAddress;\n    address crvMinterAddress;\n    uint256 constant maxSlippage = 1e16; // 1%, same as the Curve UI\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as Curve strategies don't fit\n     * well within that abstraction.\n     * @param _platformAddress Address of the Curve 3pool\n     * @param _vaultAddress Address of the vault\n     * @param _rewardTokenAddress Address of CRV\n     * @param _assets Addresses of supported assets. MUST be passed in the same\n     *                order as returned by coins on the pool contract, i.e.\n     *                DAI, USDC, USDT\n     * @param _pTokens Platform Token corresponding addresses\n     * @param _crvGaugeAddress Address of the Curve DAO gauge for this pool\n     * @param _crvMinterAddress Address of the CRV minter for rewards\n     */\n    function initialize(\n        address _platformAddress, // 3Pool address\n        address _vaultAddress,\n        address _rewardTokenAddress, // CRV\n        address[] calldata _assets,\n        address[] calldata _pTokens,\n        address _crvGaugeAddress,\n        address _crvMinterAddress\n    ) external onlyGovernor initializer {\n        // Should be set prior to abstract initialize call otherwise\n        // abstractSetPToken calls will fail\n        crvGaugeAddress = _crvGaugeAddress;\n        crvMinterAddress = _crvMinterAddress;\n        InitializableAbstractStrategy._initialize(\n            _platformAddress,\n            _vaultAddress,\n            _rewardTokenAddress,\n            _assets,\n            _pTokens\n        );\n    }\n\n    /**\n     * @dev Collect accumulated CRV and send to Vault.\n     */\n    function collectRewardToken() external onlyVault nonReentrant {\n        IERC20 crvToken = IERC20(rewardTokenAddress);\n        ICRVMinter minter = ICRVMinter(crvMinterAddress);\n        uint256 balance = crvToken.balanceOf(address(this));\n        emit RewardTokenCollected(vaultAddress, balance);\n        minter.mint(crvGaugeAddress);\n        crvToken.safeTransfer(vaultAddress, balance);\n    }\n\n    /**\n     * @dev Deposit asset into the Curve 3Pool\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        onlyVault\n        nonReentrant\n    {\n        require(_amount > 0, \"Must deposit something\");\n        emit Deposit(_asset, address(platformAddress), _amount);\n        // 3Pool requires passing deposit amounts for all 3 assets, set to 0 for\n        // all\n        uint256[3] memory _amounts;\n        uint256 poolCoinIndex = _getPoolCoinIndex(_asset);\n        // Set the amount on the asset we want to deposit\n        _amounts[poolCoinIndex] = _amount;\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        uint256 assetDecimals = Helpers.getDecimals(_asset);\n        uint256 depositValue = _amount\n            .scaleBy(int8(18 - assetDecimals))\n            .divPrecisely(curvePool.get_virtual_price());\n        uint256 minMintAmount = depositValue.mulTruncate(\n            uint256(1e18).sub(maxSlippage)\n        );\n        // Do the deposit to 3pool\n        curvePool.add_liquidity(_amounts, minMintAmount);\n        // Deposit into Gauge\n        IERC20 pToken = IERC20(assetToPToken[_asset]);\n        ICurveGauge(crvGaugeAddress).deposit(\n            pToken.balanceOf(address(this)),\n            address(this)\n        );\n    }\n\n    /**\n     * @dev Deposit the entire balance of any supported asset into the Curve 3pool\n     */\n    function depositAll() external onlyVault nonReentrant {\n        uint256[3] memory _amounts = [uint256(0), uint256(0), uint256(0)];\n        uint256 depositValue = 0;\n        ICurvePool curvePool = ICurvePool(platformAddress);\n\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            address assetAddress = assetsMapped[i];\n            uint256 balance = IERC20(assetAddress).balanceOf(address(this));\n            if (balance > 0) {\n                uint256 poolCoinIndex = _getPoolCoinIndex(assetAddress);\n                // Set the amount on the asset we want to deposit\n                _amounts[poolCoinIndex] = balance;\n                uint256 assetDecimals = Helpers.getDecimals(assetAddress);\n                // Get value of deposit in Curve LP token to later determine\n                // the minMintAmount argument for add_liquidity\n                depositValue = depositValue.add(\n                    balance.scaleBy(int8(18 - assetDecimals)).divPrecisely(\n                        curvePool.get_virtual_price()\n                    )\n                );\n                emit Deposit(assetAddress, address(platformAddress), balance);\n            }\n        }\n\n        uint256 minMintAmount = depositValue.mulTruncate(\n            uint256(1e18).sub(maxSlippage)\n        );\n        // Do the deposit to 3pool\n        curvePool.add_liquidity(_amounts, minMintAmount);\n        // Deposit into Gauge, the PToken is the same (3Crv) for all mapped\n        // assets, so just get the address from the first one\n        IERC20 pToken = IERC20(assetToPToken[assetsMapped[0]]);\n        ICurveGauge(crvGaugeAddress).deposit(\n            pToken.balanceOf(address(this)),\n            address(this)\n        );\n    }\n\n    /**\n     * @dev Withdraw asset from Curve 3Pool\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external onlyVault nonReentrant {\n        require(_recipient != address(0), \"Invalid recipient\");\n        require(_amount > 0, \"Invalid amount\");\n\n        emit Withdrawal(_asset, address(assetToPToken[_asset]), _amount);\n\n        // Calculate how much of the pool token we need to withdraw\n        (uint256 contractPTokens, , uint256 totalPTokens) = _getTotalPTokens();\n\n        require(totalPTokens > 0, \"Insufficient 3CRV balance\");\n\n        uint256 poolCoinIndex = _getPoolCoinIndex(_asset);\n        // Calculate the max amount of the asset we'd get if we withdrew all the\n        // platform tokens\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        uint256 maxAmount = curvePool.calc_withdraw_one_coin(\n            totalPTokens,\n            int128(poolCoinIndex)\n        );\n\n        // Calculate how many platform tokens we need to withdraw the asset amount\n        uint256 withdrawPTokens = totalPTokens.mul(_amount).div(maxAmount);\n        if (contractPTokens < withdrawPTokens) {\n            // Not enough of pool token exists on this contract, some must be\n            // staked in Gauge, unstake difference\n            ICurveGauge(crvGaugeAddress).withdraw(\n                withdrawPTokens.sub(contractPTokens)\n            );\n        }\n\n        // Calculate a minimum withdrawal amount\n        uint256 assetDecimals = Helpers.getDecimals(_asset);\n        // 3crv is 1e18, subtract slippage percentage and scale to asset\n        // decimals\n        uint256 minWithdrawAmount = withdrawPTokens\n            .mulTruncate(uint256(1e18).sub(maxSlippage))\n            .scaleBy(int8(assetDecimals - 18));\n\n        curvePool.remove_liquidity_one_coin(\n            withdrawPTokens,\n            int128(poolCoinIndex),\n            minWithdrawAmount\n        );\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n\n        // Transfer any leftover dust back to the vault buffer.\n        uint256 dust = IERC20(_asset).balanceOf(address(this));\n        if (dust > 0) {\n            IERC20(_asset).safeTransfer(vaultAddress, dust);\n        }\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll() external onlyVaultOrGovernor nonReentrant {\n        // Withdraw all from Gauge\n        (, uint256 gaugePTokens, uint256 totalPTokens) = _getTotalPTokens();\n        ICurveGauge(crvGaugeAddress).withdraw(gaugePTokens);\n        uint256[3] memory minWithdrawAmounts = [\n            uint256(0),\n            uint256(0),\n            uint256(0)\n        ];\n        // Calculate min withdrawal amounts for each coin\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            address assetAddress = assetsMapped[i];\n            uint256 virtualBalance = checkBalance(assetAddress);\n            uint256 poolCoinIndex = _getPoolCoinIndex(assetAddress);\n            minWithdrawAmounts[poolCoinIndex] = virtualBalance.mulTruncate(\n                uint256(1e18).sub(maxSlippage)\n            );\n        }\n        // Remove liqudiity\n        ICurvePool threePool = ICurvePool(platformAddress);\n        threePool.remove_liquidity(totalPTokens, minWithdrawAmounts);\n        // Transfer assets out ot Vault\n        // Note that Curve will provide all 3 of the assets in 3pool even if\n        // we have not set PToken addresses for all of them in this strategy\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            IERC20 asset = IERC20(threePool.coins(i));\n            asset.safeTransfer(vaultAddress, asset.balanceOf(address(this)));\n        }\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        public\n        view\n        returns (uint256 balance)\n    {\n        require(assetToPToken[_asset] != address(0), \"Unsupported asset\");\n        // LP tokens in this contract. This should generally be nothing as we\n        // should always stake the full balance in the Gauge, but include for\n        // safety\n        (, , uint256 totalPTokens) = _getTotalPTokens();\n        ICurvePool curvePool = ICurvePool(platformAddress);\n\n        uint256 pTokenTotalSupply = IERC20(assetToPToken[_asset]).totalSupply();\n        if (pTokenTotalSupply > 0) {\n            uint256 poolCoinIndex = _getPoolCoinIndex(_asset);\n            uint256 curveBalance = curvePool.balances(poolCoinIndex);\n            if (curveBalance > 0) {\n                balance = totalPTokens.mul(curveBalance).div(pTokenTotalSupply);\n            }\n        }\n    }\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) external view returns (bool) {\n        return assetToPToken[_asset] != address(0);\n    }\n\n    /**\n     * @dev Approve the spending of all assets by their corresponding pool tokens,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens() external {\n        // This strategy is a special case since it only supports one asset\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            _abstractSetPToken(assetsMapped[i], assetToPToken[assetsMapped[i]]);\n        }\n    }\n\n    /**\n     * @dev Calculate the total platform token balance (i.e. 3CRV) that exist in\n     * this contract or is staked in the Gauge (or in other words, the total\n     * amount platform tokens we own).\n     * @return totalPTokens Total amount of platform tokens in native decimals\n     */\n    function _getTotalPTokens()\n        internal\n        view\n        returns (\n            uint256 contractPTokens,\n            uint256 gaugePTokens,\n            uint256 totalPTokens\n        )\n    {\n        contractPTokens = IERC20(assetToPToken[assetsMapped[0]]).balanceOf(\n            address(this)\n        );\n        ICurveGauge gauge = ICurveGauge(crvGaugeAddress);\n        gaugePTokens = gauge.balanceOf(address(this));\n        totalPTokens = contractPTokens.add(gaugePTokens);\n    }\n\n    /**\n     * @dev Call the necessary approvals for the Curve pool and gauge\n     * @param _asset Address of the asset\n     * @param _pToken Address of the corresponding platform token (i.e. 3CRV)\n     */\n    function _abstractSetPToken(address _asset, address _pToken) internal {\n        IERC20 asset = IERC20(_asset);\n        IERC20 pToken = IERC20(_pToken);\n        // 3Pool for asset (required for adding liquidity)\n        asset.safeApprove(platformAddress, 0);\n        asset.safeApprove(platformAddress, uint256(-1));\n        // 3Pool for LP token (required for removing liquidity)\n        pToken.safeApprove(platformAddress, 0);\n        pToken.safeApprove(platformAddress, uint256(-1));\n        // Gauge for LP token\n        pToken.safeApprove(crvGaugeAddress, 0);\n        pToken.safeApprove(crvGaugeAddress, uint256(-1));\n    }\n\n    /**\n     * @dev Get the index of the coin in 3pool\n     */\n    function _getPoolCoinIndex(address _asset) internal view returns (uint256) {\n        for (uint256 i = 0; i < 3; i++) {\n            if (assetsMapped[i] == _asset) return i;\n        }\n        revert(\"Invalid 3pool asset\");\n    }\n}"
    }
  ]
}