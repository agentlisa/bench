{
  "Title": "M-5: Dilution of Donations in Tranche",
  "Content": "# Issue M-5: Dilution of Donations in Tranche \n\nSource: https://github.com/sherlock-audit/2023-12-arcadia-judging/issues/121 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nAtharv, erosjohn, pash0k\n## Summary\nIn this attack, the attacker takes advantage of the non-atomic nature of the donation and the share valuation process. By strategically placing deposit and withdrawal transactions around the donation transaction, the attacker can temporarily inflate their share of the pool to capture a large portion of the donated funds, which they then quickly exit with, leaving the pool with their original investment plus extra value extracted from the donation.\n\n## Vulnerability Detail\nThough there is no reasonable flow where users will just 'donate' assets to others, Risk Manager may needs to call `donateToTranche` to compensate the jrTranche after an auction didn't get sold and was manually liquidated after cutoff time or in case of bad debt. \n\n`donateToTranche` function of a lending pool smart contract, allows for a sandwich attack that can be exploited by a malicious actor to dilute the impact of donations made to a specific tranche. This attack involves front-running a detected donation transaction with a large deposit and following it up with an immediate withdrawal after the donation is processed.\n\nThe lending pool contract in question allows liquidity providers (LPs) to deposit funds into tranches, which represent slices of the pool's capital with varying risk profiles. The `donateToTranche` function permits external parties to donate assets to a tranche, thereby increasing the value of the tranche's shares and benefiting all LPs proportionally. Transactions can be observed by one of the LP's before they are mined. An attacker can exploit this by identifying a pending donation transaction and executing a sandwich attack. This attack results in the dilution of the donation's intended effect, as the attacker's actions siphon off a portion of the donated funds.\n\n## Impact\nDilution of Donation: The intended impact of the donation on the original LPs is diluted as the attacker siphons off a portion of the donated funds.\n\n## Steps to Reproduce Issue\n1. Front-Running: The attacker deposits a significant amount of assets into the target tranche before the donation transaction is confirmed, temporarily increasing their share of the tranche.\n\n2. Donation Processing: The original donation transaction is processed, increasing the value of the tranche's shares, including those recently acquired by the attacker.\n\n3. Back-Running: The attacker immediately withdraws their total balance from the tranche, which now includes a portion of the donated assets, effectively extracting value from the donation meant for the original LPs.\n\n## Code Snippet\n [Code Snippet](https://github.com/sherlock-audit/2023-12-arcadia/blob/main/lending-v2/src/LendingPool.sol#L350)\n\n## Coded PoC\n```solidity\nhttps://github.com/Atharv181/Arcadia-POC\n```\n```javascript\n- git clone https://github.com/Atharv181/Arcadia-POC\n- cd Arcadia-POC\n- forge install\n- forge test --mt test_PoC -vvv\n```\n\n## Tool used\n\nManual Review, Foundry\n\n## Recommendation\n- Snapshot Mechanism: Take snapshots of share ownership at random intervals and distribute donations based on the snapshot to prevent exploitation.\n- Timelocks: Implement a timelock mechanism that requires funds to be locked for a certain period before they can be withdrawn.\n\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  invalid\n\n\n\n**nevillehuang**\n\nLow severity, A combination of Front and Back running not possible on Base, Optimism and Arbitrum due to private sequencers. Other chains were not explicitly mentioned, or at least all the issues and the duplicates do not present a possible chain where a sandwich attack is possible.\n\n**zzykxx**\n\nEscalate\n\nI'm escalating this on behalf of @pa-sh0k because I believe his claims should be considered via a proper escalation. This is what he states:\n\nThe loss of funds can be caused not only if the attacker executes an atomic sandwich attack, but also if they do the following steps:\n\n1. backrun the liquidation that ended up in transferring collateral to the admin, since this always leads to the donateToTranche call, and then deposit to the tranche\n2. backrun the donation itself and redeem their shares, obtaining profit\n\nHence, the reason for invalidation is incorrect.\n\nAlso, the sponsor has acknowledged the issue in discord channel. \n\nBy Sherlock’s rules, this issue is a medium, it suits the following criteria: “Causes a loss of funds but requires certain external conditions or specific states, or a loss is highly constrained. The losses must exceed small, finite amount of funds, and any amount relevant based on the precision or significance of the loss”.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> I'm escalating this on behalf of @pa-sh0k because I believe his claims should be considered via a proper escalation. This is what he states:\n> \n> The loss of funds can be caused not only if the attacker executes an atomic sandwich attack, but also if they do the following steps:\n> \n> 1. backrun the liquidation that ended up in transferring collateral to the admin, since this always leads to the donateToTranche call, and then deposit to the tranche\n> 2. backrun the donation itself and redeem their shares, obtaining profit\n> \n> Hence, the reason for invalidation is incorrect.\n> \n> Also, the sponsor has acknowledged the issue in discord channel. \n> \n> By Sherlock’s rules, this issue is a medium, it suits the following criteria: “Causes a loss of funds but requires certain external conditions or specific states, or a loss is highly constrained. The losses must exceed small, finite amount of funds, and any amount relevant based on the precision or significance of the loss”.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Thomas-Smets**\n\nIf such a backrun would happen, the admin would just not donate via `donateToTranche`.\n\nThe auction proceeds would in this case donated via different means (it is already the unhappy flow of an unhappy flow where things have to be handled manually).\nA bit annoying, but no loss of user funds.\n\nSo the attacker has the risk that they have to provide liquidty in the Tranche for un unknown amount of time, without any certainty of profits at all.\n\n**pa-sh0k**\n\nDetecting the backrun and getting the funds back to the depositors via different means is indeed a solution to the problem. \nHowever, it does not make the problem itself invalid or non-existent: there may be different solutions and all of them, of course, should lead to no loss of user funds.\n\nThe issue still exists and it can be prevented using the described method only if it was known beforehand, but it was not stated in the known issues or anywhere else. \n\nI have said this in the discord channel, but since the conversation was moved here, I will add a quote so anyone can understand the context:\n\n> private sequencer doesn't have anything to do with this issue, this can be done in separate blocks and with backruns, \n> check my comment on this issue: https://github.com/sherlock-audit/2023-12-arcadia-judging/issues/128\n> So, the attack has the following scenario:\n> - a liquidation results in unhappy flow with unsold collateral\n> - collateral is sent to the admin\n> - in the next block (or a bit later), once the attacker sees this onchain, attacker deposits funds to the junior tranche\n> - during period of length T admin manually sells the collateral\n> - admin donates the funds to the junior tranche\n> - in next block (or a bit later), once the attacker sees this onchain, attacker redeems their shares\n>\n> This results in gains for the attacker and losses for the original depositors, since they got less funds that they should have after the liquidation was manually resolved\n\n\nAlso, wanted to state that my issue, #128 , is a duplicate of this one and everything said in this discussion is applicable to it and vice versa.\n\n\n\n\n**Thomas-Smets**\n\nI want to state again that `donateToTranche` is never enforced by the protocol in any means.\nIt is a function that **can** but not **must** be used in the case a manual liquidation is triggered.\n\nNormally if the protocol functions as expected, auctions terminate automatically.\n\nWe however foresaw a flow that if for some reason an auction would not end (this already means things did not work out as expected), a trusted user (set by the Creditor) can **manually** liquidate the assets.\n\nAfter the assets are liquidated he can choose if and how to distribute the assets to potentially impacted users.\nThe `donateToTranche` is a function that might help in this process but the protocol obliges nobody to use it.\nIt is not part of the core functionality. It is a function to help in an already manual unhappy flow of a unhappy flow.\n\nThere are no guaranteed losses for LPs, and attackers have no guaranteed way to make profits, but have to put significant amounts of capital at stake.\n\nNote on the recommendations:\n\n> Snapshot Mechanism: Take snapshots of share ownership at random intervals and distribute donations based on the snapshot to prevent exploitation.\n\nSnapshots are not mutually exclusive from `donateToTranche`. We are in a manual trusted flow.\nIf the manual liquidator could liquidate remaining assets before new people deposit in the Tranche he can use `donateToTranche`. If not they can use a snapshot and distribute funds.\n\n> Timelocks: Implement a timelock mechanism that requires funds to be locked for a certain period before they can be withdrawn.\n\nThis creates new issues and risks since the the locking mechanisms of Tranches are already complex.\n\n**pa-sh0k**\n\nBefore this issue was submitted, escalated and this discussion was started, it was **not** stated anywhere, that backrunning activity will be monitored and if something malicious is noticed, other ways of liquidation settling will be used. \n\nIf you have known about such attack vector and already had other ways of handling it, it should have been stated in the known issues. \n\n**Thomas-Smets**\n\nIt is a trusted manual flow executed by a permissioned role!\nAnd that is clearly stated in the code\n\n**nevillehuang**\n\nAgree with sponsor comments [here](https://github.com/sherlock-audit/2023-12-arcadia-judging/issues/121#issuecomment-1972955779), this issue should remain low severity.\n\n**pa-sh0k**\n\nThe fact that it is executed by a permissioned role is already assumed in the issue. The issue is that when trusted manual flow is executed by a permissioned role using `donateToTranche`, users' funds can be stolen.\n\nWhat is stated in the code (LendingPool.sol#L346-L347) about `donateToTranche` is the following:\n> It is supposed to serve as a way to compensate the jrTranche after an auction didn't get sold and was manually liquidated after cutoffTime.\n\nFrom this comment it cannot be concluded that backrunning will be monitored and if something malicious is noticed, other ways of liquidation settling will be used.\n\nThe fact that this flow is executed by a permissioned role does not make it invincible.\n\nWhat was stated previously:\n\n> I do acknowledge it exists, but we consider it a low, since pay-out for attackers is uncertain and as you said, it can be prevented if an attacker really tries to pull it of.\n\nObviously, this issue can't be prevented it is not known about by the admin. Since it was submitted, which is my job as a Watson, now the admins know about it and can prevent the loss of funds. \n\nAddressing the Sherlock's criteria:\n\n“Causes a loss of funds but requires certain external conditions or specific states, or a loss is highly constrained. The losses must exceed small, finite amount of funds, and any amount relevant based on the precision or significance of the loss”.\n\nThis issue requires certain external conditions and causes loss of funds if these conditions are met. \n\nRegarding the following words of the sponsor:\n> attackers have no guaranteed way to make profits, but have to put significant amounts of capital at stake\n\nAttacker is guaranteed to make profits if the conditions are met. Also, probability of depositing funds into the protocol as a liquidity provider for a short period of time, which the attacker would have to do, has near-to-zero risk of losing money. They would probably even make money by providing liquidity. \n\n\n\n\n**Thomas-Smets**\n\n> From this comment it cannot be concluded that backrunning will be monitored and if something malicious is noticed, other ways of liquidation settling will be used.\n\nAs we say in the comment:\n\nIt is supposed to serve as _**a way**_ to compensate the jrTranche after an auction didn't get sold and was manually liquidated after cutoffTime.\n\nnot\n\nIt is supposed to serve as _**the way**_ to compensate the jrTranche after an auction didn't get sold and was manually liquidated after cutoffTime.\n\nAddressing the Sherlock's criteria:\n\nWe even state that this flow is not enforced by the smart contracts:\nhttps://github.com/arcadia-finance/lending-v2/blob/dcc682742949d56928e7e8e281839d2229bd9737/src/Liquidator.sol#L431\n\n**pa-sh0k**\n\n\"Not enforced by the smart contracts\" is equal to \"it is manual\", which is already assumed in the issue.\n\nThe issue is invalid if `donateToTranche` is never used for refunding the users. The comments imply that at some point it will be used for it, so, once it is used, the mentioned conditions are met and loss of funds is caused.\n\nThe argument that if admin wants to use `donateToTranche` but sees that an attacker made a large deposit trying to frontrun the call and then will decide to use other way of refunding is not applicable here, as before this issue was submitted, the need for monitoring and preventing such attack was not known.\n\n\nIf other way of refunding is chosen for some other reasons, the attacker can simply withdraw their funds at no loss.\n\n**Atharv181**\n\nI'd like to further emphasize the significance of our concerns. While it's true that the `donateToTranche` function is not the only method for handling manual liquidation settlements, it remains a potential avenue for exploitation. If the protocol was aware of this vulnerability beforehand, it raises questions as to why it wasn't explicitly mentioned in the known issues.\n\nIt's crucial to acknowledge that while the function may not be mandatory, it still represents a pathway that could be exploited under certain conditions. \n\nRecognizing the possibility of backrunning activity and subsequently choosing not to utilize the donateToTranche function as a precautionary measure does not invalidate the existence of the issue. Instead, it serves as a practical mitigation strategy and underscores the importance of proactive risk management.\n\nFurthermore, while opting not to use the `donateToTranche` function in certain scenarios may reduce the likelihood of exploitation, it doesn't negate the need for addressing the underlying vulnerability. It's important to view this decision as a proactive measure aimed at minimizing risk rather than dismissing the issue altogether.\n\n**Atharv181**\n\nTalking about the severity the identified vulnerability clearly meets the criteria for a **medium** severity issue. It results in a loss of funds, as highlighted by the **Dilution of Donations**, which directly impacts the intended recipients of those funds. While the exploit may require certain external conditions or specific states to occur, the potential for loss is significant and cannot be dismissed lightly.\n\nThe fact that the vulnerability exists and can lead to tangible financial harm underscores its severity. Even though the losses may not be immediate or guaranteed, they exceed a small, finite amount of funds, especially when considering the significance of the loss to affected lenders.\n\n**Thomas-Smets**\n\nLet's not use chatGPT when discussing the findings.\n\n**Atharv181**\n\nSorry for this. I come from non-English speaking country hence I used it for less grammar mistakes. I hope you understand. \nI will make sure this will not happen again. Thank you.\n  \n\n**erosjohn**\n\nI would like to add that even if there is no attacker, this will harm other users' profits. As long as a new user deposits assets into jrTranche after `_settleAuction()` is called, when `donateToTranche()` is called later to compensate the jrTranche, the profit of the original user will be diluted.\nObviously, the operation of a new user depositing assets into tranche will happen at any time, and as long as the protocol is not checked, you have no way to avoid it.\n\n**Czar102**\n\n> The protocol will later \"donate\" these proceeds back to the impacted Tranches\n\nIt seems that the donation was to be to Tranches, not to Tranches' holders at the time of the auction/auction failure. This itself is a logical issue that should be recognized as the core issue here.\n\nI think most doubts regarding the validity of this issue come from the fact that modifying the planned usage of the functionality solves this issue. I don't think this means that an issue is invalid.\n\nIf I am mistaken and there is other clear evidence that the donation was to be done to holders at the time the auctioned assets were subtracted from a tranche's balance, I will agree with invalidation. Right now, the sponsor's arguments seem to be that this the comments were suggesting a route for next steps, and these steps could be different. Without mentioning the mint monitoring checks, this seems to be equivalent to an approach that \"in a manual action, we would notice this issue\", while assuming that the issue will be found anyway doesn't invalidate its existence.\n@nevillehuang @Thomas-Smets do my points make sense?\n\n**nevillehuang**\n\n@Czar102 This issue is definitely possible, however, `donateToTranche()` is not a core functionality of the protocol, as it is solely used for manual liquidations to allow the manual liquidator to possibly serve as a way to compensate junior tranches. I suggest relooking at the sponsor comments [here](https://github.com/sherlock-audit/2023-12-arcadia-judging/issues/121#issuecomment-1972955779) and [here](https://github.com/sherlock-audit/2023-12-arcadia-judging/issues/121#issuecomment-1973443177)\n\n**pa-sh0k**\n\n@nevillehuang why \"not a core functionality\" is used as an argument for issue's invalidity? It is definitely in scope and is a part of the protocol\n\n**Thomas-Smets**\n\n> @nevillehuang why \"not a core functionality\" is used as an argument for issue's invalidity? It is definitely in scope and is a part of the protocol\n\nThe function is never called from a function within the protocol.\nIt is always a someone from outside the protocol that must call the function.\nAn attacker is never certain the function will be called, they cannot enforce it in any way possible.\n\nIf you read my comments above I am not denying it is an issue, I stated that since there is no guarantee on profit and it can even be avoided there is ever profit for an attacker, I consider it a low issue.\n\n**Czar102**\n\nIs there an expectation of a donation of nonzero proceeds in the unhappy flow? Or are positive proceeds not expected? @Thomas-Smets \n\n**Atharv181**\n\n> I would like to add that even if there is no attacker, this will harm other users' profits. As long as a new user deposits assets into  jrTranche after _settleAuction() is called, when donateToTranche() is called later to compensate the jrTranche, the profit of the original user will be diluted.\n\nAlso dilutes the donations for users.\n\n\n**Atharv181**\n\n\n![image](https://github.com/sherlock-audit/2023-12-arcadia-judging/assets/73999654/e73d82bb-b0fe-4a05-8b55-3f4a45a12cc6)\n\nIt is clearly mentioned [here](https://github.com/sherlock-audit/2023-12-arcadia/blob/de7289bebb3729505a2462aa044b3960d8926d78/lending-v2/src/LendingPool.sol#L346) that it is used to compensate the tranche after an auction didn't get sold (unhappy flow)\n\n\n\n**Thomas-Smets**\n\nMy point of view: it is a low issue\nI feel discussing it more is not that useful since we are just in a yes-no discussion.\n\nWe are talking about an emergency situation where the protocol already didn't function as expected and that has to be resolved 100% manually. And in no way is `donateToTranche()` enforced to be called, if it can be called it makes things easier, if not it can still be resolved 100% without losses to users.\n\n1. It should never occur in the first place (low probability)\n2. If an attacker wants to make significant profits with this, they have to put a lot of funds in the Tranche (order of total liquidity in the Tranche). This also can't be done atomic or via flash loans, so it have to actual attacker funds locked in Tranche. Even if it happens the dilution is a share of a single badDebt amount shared over all LPs.\n3. The attacker can not trigger or be sure `donateToTranche()` is ever triggered. The recipient of the Account is a permissioned role, and not forced to use `donateToTranche()` in this specific flow.\n\n> @Czar102 Is there an expectation of a donation of nonzero proceeds in the unhappy flow? Or are positive proceeds not expected?\n\nNot sure I fully understand the question, `auctionBoughtIn` is only called if an auction failed, that can be due to market conditions (-> no profit) or due to technical problems (reverting getValue or sometghing like that), in the latter case it can be that the proceeds of the manually liquidated Account were bigger than the initial debt.\n\n@Atharv181, It is clearly mentioned [here](https://github.com/sherlock-audit/2023-12-arcadia/blob/de7289bebb3729505a2462aa044b3960d8926d78/lending-v2/src/LendingPool.sol#L346) that it is used to compensate the tranche after an auction didn't get sold (unhappy flow)\n\nWe say very clear: It is **_A way_**. We do not say it is **_the way_**.\nIt is not enforced by the logic of the protocol!\n\n**Czar102**\n\nThe situation of unhappy flow hasn't been taken out of scope (despite it being perceived as extremely improbable), and it has been explicitly mentioned that the `donateToTranche()` is to be used in scenarios where funds from the liquidation are to be returned. An action not being enforced by the smart contract logic doesn't make the intended use of a function out of scope.\n\nSince this approach is exploitable, I'm planning to consider it a valid Medium severity issue.\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [zzykxx](https://github.com/sherlock-audit/2023-12-arcadia-judging/issues/121/#issuecomment-1970897812): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/137",
  "Code": [
    {
      "filename": "lending-v2/src/LendingPool.sol",
      "content": "/**\n * Created by Pragma Labs\n * SPDX-License-Identifier: BUSL-1.1\n */\npragma solidity 0.8.22;\n\nimport { Creditor } from \"../lib/accounts-v2/src/abstracts/Creditor.sol\";\nimport { DebtToken, ERC20, ERC4626 } from \"./DebtToken.sol\";\nimport { FixedPointMathLib } from \"../lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport { IAccount } from \"./interfaces/IAccount.sol\";\nimport { IFactory } from \"./interfaces/IFactory.sol\";\nimport { ILendingPool } from \"./interfaces/ILendingPool.sol\";\nimport { ITranche } from \"./interfaces/ITranche.sol\";\nimport { LendingPoolErrors } from \"./libraries/Errors.sol\";\nimport { LendingPoolGuardian } from \"./guardians/LendingPoolGuardian.sol\";\nimport { LogExpMath } from \"./libraries/LogExpMath.sol\";\nimport { SafeCastLib } from \"../lib/solmate/src/utils/SafeCastLib.sol\";\nimport { SafeTransferLib } from \"../lib/solmate/src/utils/SafeTransferLib.sol\";\n\n/**\n * @title Arcadia LendingPool.\n * @author Pragma Labs\n * @notice The Lending pool is responsible for the:\n * - Accounting of the liabilities of borrowers via the debtTokens (ERC4626).\n * - Accounting of the liquidity of the Liquidity Providers, via one or more Tranche(s) (ERC4626).\n * - Management of issuing and repaying debt.\n * - Management of interest payments.\n * - Settlement of liquidations and default events.\n */\ncontract LendingPool is LendingPoolGuardian, Creditor, DebtToken, ILendingPool {\n    using FixedPointMathLib for uint256;\n    using SafeTransferLib for ERC20;\n\n    /* //////////////////////////////////////////////////////////////\n                                CONSTANTS\n    ////////////////////////////////////////////////////////////// */\n\n    // Seconds per year, leap years ignored.\n    uint256 internal constant YEARLY_SECONDS = 31_536_000;\n    // Contract address of the Arcadia Account Factory.\n    address internal immutable ACCOUNT_FACTORY;\n    // Contract address of the Liquidator contract.\n    address internal immutable LIQUIDATOR;\n    // The unit for fixed point numbers with 4 decimals precision.\n    uint256 internal constant ONE_4 = 10_000;\n    // Maximum total liquidation penalty, 4 decimal precision.\n    uint256 internal constant MAX_TOTAL_PENALTY = 1100;\n\n    /* //////////////////////////////////////////////////////////////\n                                STORAGE\n    ////////////////////////////////////////////////////////////// */\n\n    // The current interest rate, 18 decimals precision.\n    uint80 public interestRate;\n    // The interest rate when utilisation is 0.\n    // 18 decimals precision.\n    uint72 internal baseRatePerYear;\n    // The slope of the first curve, defined as the delta in interest rate for a delta in utilisation of 100%.\n    // 18 decimals precision.\n    uint72 internal lowSlopePerYear;\n    // The slope of the second curve, defined as the delta in interest rate for a delta in utilisation of 100%.\n    // 18 decimals precision.\n    uint72 internal highSlopePerYear;\n    // The optimal capital utilisation, where we go from the first curve to the steeper second curve.\n    // 4 decimal precision.\n    uint16 internal utilisationThreshold;\n    // Last timestamp that interests were realized.\n    uint32 internal lastSyncedTimestamp;\n    // Fee issued upon taking debt, 4 decimals precision (10 equals 0.001 or 0.1%), capped at 255 (2.55%).\n    uint8 public originationFee;\n    // Sum of all the interest weights of the tranches + treasury.\n    uint24 internal totalInterestWeight;\n    // Fraction (interestWeightTreasury / totalInterestWeight) of the interest fees that go to the treasury.\n    uint16 internal interestWeightTreasury;\n    // Fraction (liquidationWeightTreasury / totalLiquidationWeight) of the liquidation fees that goes to the treasury.\n    uint16 internal liquidationWeightTreasury;\n    // Fraction (liquidationWeightTranche / totalLiquidationWeight) of the liquidation fees that goes to the most Junior Tranche.\n    uint16 internal liquidationWeightTranche;\n\n    // Total amount of `underlying asset` that is claimable by the LPs. Does not take into account pending interests.\n    uint128 internal totalRealisedLiquidity;\n    // The minimum amount of collateral that must be held in an Account before a position can be opened.\n    uint96 internal minimumMargin;\n\n    // Address of the protocol treasury.\n    address internal treasury;\n    // Number of auctions that are currently in progress.\n    uint16 internal auctionsInProgress;\n    // Maximum amount of `underlying asset` that is paid as fee to the initiator/terminator of a liquidation.\n    uint80 internal maxReward;\n    // Minimum initiation and termination reward, relative to the minimumMargin, 4 decimal precision.\n    uint16 internal minRewardWeight;\n    // Fee paid to the Liquidation Initiator.\n    // Defined as a fraction of the openDebt with 4 decimals precision.\n    // Absolute fee can be further capped to a max amount by the creditor.\n    uint16 internal initiationWeight;\n    // Penalty the Account owner has to pay to the Creditor on top of the open Debt for being liquidated.\n    // Defined as a fraction of the openDebt with 4 decimals precision.\n    uint16 internal penaltyWeight;\n    // Fee paid to the address that is ending an auction.\n    // Defined as a fraction of the openDebt with 4 decimals precision.\n    uint16 internal terminationWeight;\n\n    // Array of the interest weights of each Tranche.\n    // Fraction (interestWeightTranches[i] / totalInterestWeight) of the interest fees that go to Tranche i.\n    uint16[] internal interestWeightTranches;\n    // Array of the contract addresses of the Tranches.\n    address[] internal tranches;\n\n    // Map tranche => status.\n    mapping(address => bool) internal isTranche;\n    // Map tranche => interestWeight.\n    // Fraction (interestWeightTranches[i] / totalInterestWeight) of the interest fees that go to Tranche i.\n    mapping(address => uint256) internal interestWeight;\n    // Map tranche => realisedLiquidity.\n    // Amount of `underlying asset` that is claimable by the liquidity providers.\n    // Does not take into account pending interests.\n    mapping(address => uint256) internal realisedLiquidityOf;\n    // Map Account => owner => beneficiary => amount.\n    // Stores the credit allowances for a beneficiary per Account and per Owner.\n    mapping(address => mapping(address => mapping(address => uint256))) public creditAllowance;\n\n    /* //////////////////////////////////////////////////////////////\n                                EVENTS\n    ////////////////////////////////////////////////////////////// */\n\n    event AuctionStarted(address indexed account, address indexed creditor, uint128 openDebt);\n    event AuctionFinished(\n        address indexed account,\n        address indexed creditor,\n        uint256 startDebt,\n        uint256 initiationReward,\n        uint256 terminationReward,\n        uint256 penalty,\n        uint256 badDebt,\n        uint256 surplus\n    );\n    event Borrow(\n        address indexed account, address indexed by, address to, uint256 amount, uint256 fee, bytes3 indexed referrer\n    );\n    event CreditApproval(address indexed account, address indexed owner, address indexed beneficiary, uint256 amount);\n    event InterestSynced(uint256 interest);\n    event InterestWeightTrancheUpdated(address indexed tranche, uint8 indexed trancheIndex, uint16 interestWeight);\n    event LiquidationWeightTrancheUpdated(uint16 liquidationWeight);\n    event PoolStateUpdated(uint256 totalDebt, uint256 totalLiquidity, uint80 interestRate);\n    event Repay(address indexed account, address indexed from, uint256 amount);\n    event TranchePopped(address tranche);\n    event TreasuryWeightsUpdated(uint16 interestWeight, uint16 liquidationWeight);\n\n    /* //////////////////////////////////////////////////////////////\n                                MODIFIERS\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Checks if caller is the Liquidator.\n     */\n    modifier onlyLiquidator() {\n        if (LIQUIDATOR != msg.sender) revert LendingPoolErrors.Unauthorized();\n        _;\n    }\n\n    /**\n     * @notice Checks if caller is a Tranche.\n     */\n    modifier onlyTranche() {\n        if (!isTranche[msg.sender]) revert LendingPoolErrors.Unauthorized();\n        _;\n    }\n\n    /**\n     * @notice Syncs interest to LPs and treasury and updates the interest rate.\n     */\n    modifier processInterests() {\n        _syncInterests();\n        _;\n        // _updateInterestRate() modifies the state (effect), but can safely be called after interactions.\n        // Cannot be exploited by re-entrancy attack.\n        _updateInterestRate(realisedDebt, totalRealisedLiquidity);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice The constructor for a lending pool.\n     * @param riskManager_ The address of the new Risk Manager.\n     * @param asset_ The underlying ERC20 token of the Lending Pool.\n     * @param treasury_ The address of the protocol treasury.\n     * @param accountFactory The contract address of the Arcadia Account Factory.\n     * @param liquidator The contract address of the Liquidator.\n     * @dev The name and symbol of the DebtToken are automatically generated, based on the name and symbol of the underlying token.\n     */\n    constructor(address riskManager_, ERC20 asset_, address treasury_, address accountFactory, address liquidator)\n        LendingPoolGuardian()\n        Creditor(riskManager_)\n        DebtToken(asset_)\n    {\n        treasury = treasury_;\n        ACCOUNT_FACTORY = accountFactory;\n        LIQUIDATOR = liquidator;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                            TRANCHES LOGIC\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Adds a tranche to the Lending Pool.\n     * @param tranche The address of the Tranche.\n     * @param interestWeight_ The interest weight of the specific Tranche.\n     * @dev The order of the tranches is important, the most senior tranche is added first at index 0, the most junior at the last index.\n     * @dev Each Tranche is an ERC4626 contract.\n     * @dev The interest weight of each Tranche determines the relative share of the yield (interest payments) that goes to its Liquidity providers.\n     */\n    function addTranche(address tranche, uint16 interestWeight_) external onlyOwner processInterests {\n        if (auctionsInProgress > 0) revert LendingPoolErrors.AuctionOngoing();\n        if (isTranche[tranche]) revert LendingPoolErrors.TrancheAlreadyExists();\n\n        totalInterestWeight += interestWeight_;\n        interestWeightTranches.push(interestWeight_);\n        interestWeight[tranche] = interestWeight_;\n\n        uint8 trancheIndex = uint8(tranches.length);\n        tranches.push(tranche);\n        isTranche[tranche] = true;\n\n        emit InterestWeightTrancheUpdated(tranche, trancheIndex, interestWeight_);\n    }\n\n    /**\n     * @notice Changes the interest weight of a specific Tranche.\n     * @param index The index of the Tranche for which a new interest weight is being set.\n     * @param interestWeight_ The new interest weight of the Tranche at the index.\n     * @dev The interest weight of each Tranche determines the relative share of yield (interest payments) that goes to its Liquidity providers.\n     */\n    function setInterestWeightTranche(uint256 index, uint16 interestWeight_) external onlyOwner processInterests {\n        if (index >= tranches.length) revert LendingPoolErrors.NonExistingTranche();\n        totalInterestWeight = totalInterestWeight - interestWeightTranches[index] + interestWeight_;\n        interestWeightTranches[index] = interestWeight_;\n        address tranche = tranches[index];\n        interestWeight[tranche] = interestWeight_;\n\n        emit InterestWeightTrancheUpdated(tranche, uint8(index), interestWeight_);\n    }\n\n    /**\n     * @notice Changes the liquidation weight of the most Junior Tranche.\n     * @param liquidationWeight The new liquidation weight of the Tranche at the highest index.\n     * @dev The liquidation weight determines the relative share of liquidation fees that goes to the most Junior Tranche.\n     */\n    function setLiquidationWeightTranche(uint16 liquidationWeight) external onlyOwner {\n        emit LiquidationWeightTrancheUpdated(liquidationWeightTranche = liquidationWeight);\n    }\n\n    /**\n     * @notice Removes the Tranche at the last index (most junior).\n     * @param index The index of the last Tranche.\n     * @param tranche The address of the last Tranche.\n     * @dev This function can only be called by the function _processDefault(uint256 assets),\n     * when there is a default as big as (or bigger than) the complete amount of liquidity of the most junior Tranche.\n     * @dev Passing the input parameters to the function saves gas compared to reading the address and index of the last Tranche from storage.\n     * No need to check if index and Tranche are indeed of the last tranche since function is only called by _processDefault.\n     */\n    function _popTranche(uint256 index, address tranche) internal {\n        unchecked {\n            totalInterestWeight -= interestWeightTranches[index];\n        }\n        isTranche[tranche] = false;\n        interestWeightTranches.pop();\n        tranches.pop();\n        interestWeight[tranche] = 0;\n\n        emit TranchePopped(tranche);\n    }\n\n    /* ///////////////////////////////////////////////////////////////\n                    TREASURY FEE CONFIGURATION\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Changes the interest and liquidation weight of the Treasury.\n     * @param interestWeight_ The new interestWeight of the treasury.\n     * @param liquidationWeight The new liquidationWeight of the treasury.\n     * @dev The interestWeight determines the relative share of the yield (interest payments) that goes to the protocol treasury.\n     * @dev Setting interestWeightTreasury to a very high value will cause the treasury to collect all interest fees from that moment on.\n     * Although this will affect the future profits of liquidity providers, no funds nor realized interest are at risk for LPs.\n     */\n    function setTreasuryWeights(uint16 interestWeight_, uint16 liquidationWeight) external onlyOwner processInterests {\n        totalInterestWeight = totalInterestWeight - interestWeightTreasury + interestWeight_;\n\n        emit TreasuryWeightsUpdated(\n            interestWeightTreasury = interestWeight_, liquidationWeightTreasury = liquidationWeight\n        );\n    }\n\n    /**\n     * @notice Sets new treasury address.\n     * @param treasury_ The new address of the treasury.\n     */\n    function setTreasury(address treasury_) external onlyOwner {\n        treasury = treasury_;\n    }\n\n    /**\n     * @notice Sets the new origination fee.\n     * @param originationFee_ The new origination fee.\n     * @dev originationFee is limited by being a uint8 -> max value is 2.55%\n     * 4 decimal precision (10 = 0.1%).\n     */\n    function setOriginationFee(uint8 originationFee_) external onlyOwner {\n        originationFee = originationFee_;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Deposit assets in the Lending Pool.\n     * @param assets The amount of assets of the underlying ERC20 tokens being deposited.\n     * @param from The address of the Liquidity Provider who deposits the underlying ERC20 token via a Tranche.\n     * @dev This function can only be called by Tranches.\n     */\n    function depositInLendingPool(uint256 assets, address from)\n        external\n        whenDepositNotPaused\n        onlyTranche\n        processInterests\n    {\n        // Need to transfer before minting or ERC777s could reenter.\n        // Address(this) is trusted -> no risk on re-entrancy attack after transfer.\n        asset.safeTransferFrom(from, address(this), assets);\n\n        unchecked {\n            realisedLiquidityOf[msg.sender] += assets;\n            totalRealisedLiquidity = SafeCastLib.safeCastTo128(assets + totalRealisedLiquidity);\n        }\n    }\n\n    /**\n     * @notice Donate assets to the Lending Pool.\n     * @param trancheIndex The index of the tranche to donate to.\n     * @param assets The amount of assets of the underlying ERC20 tokens being deposited.\n     * @dev Can be used by anyone to donate assets to the Lending Pool.\n     * It is supposed to serve as a way to compensate the jrTranche after an\n     * auction didn't get sold and was manually liquidated after cutoffTime.\n     * @dev Inflation attacks by the first depositor in the Tranches have to be prevented with virtual assets/shares.\n     */\n    function donateToTranche(uint256 trancheIndex, uint256 assets) external whenDepositNotPaused processInterests {\n        if (assets == 0) revert LendingPoolErrors.ZeroAmount();\n\n        address tranche = tranches[trancheIndex];\n\n        // Need to transfer before donating or ERC777s could reenter.\n        // Address(this) is trusted -> no risk on re-entrancy attack after transfer.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        unchecked {\n            realisedLiquidityOf[tranche] += assets; //[̲̅$̲̅(̲̅ ͡° ͜ʖ ͡°̲̅)̲̅$̲̅]\n            totalRealisedLiquidity = SafeCastLib.safeCastTo128(assets + totalRealisedLiquidity);\n        }\n    }\n\n    /**\n     * @notice Withdraw assets from the Lending Pool.\n     * @param assets The amount of assets of the underlying ERC20 tokens being withdrawn.\n     * @param receiver The address of the receiver of the underlying ERC20 tokens.\n     * @dev This function can be called by anyone with an open balance (realisedLiquidityOf[address] bigger than 0),\n     * which can be both Tranches as other address (treasury, Liquidation Initiators, Liquidated Account Owner...).\n     */\n    function withdrawFromLendingPool(uint256 assets, address receiver)\n        external\n        whenWithdrawNotPaused\n        processInterests\n    {\n        if (realisedLiquidityOf[msg.sender] < assets) revert LendingPoolErrors.AmountExceedsBalance();\n\n        unchecked {\n            realisedLiquidityOf[msg.sender] -= assets;\n            totalRealisedLiquidity = SafeCastLib.safeCastTo128(totalRealisedLiquidity - assets);\n        }\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                            LENDING LOGIC\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Approve a beneficiary to take out debt against an Arcadia Account.\n     * @param beneficiary The address of the beneficiary who can take out debt backed by an Arcadia Account.\n     * @param amount The amount of underlying ERC20 tokens to be lent out.\n     * @param account The address of the Arcadia Account backing the debt.\n     */\n    function approveBeneficiary(address beneficiary, uint256 amount, address account) external {\n        // If Account is not an actual address of an Arcadia Account, ownerOfAccount(address) will return the zero address.\n        if (IFactory(ACCOUNT_FACTORY).ownerOfAccount(account) != msg.sender) revert LendingPoolErrors.Unauthorized();\n\n        creditAllowance[account][msg.sender][beneficiary] = amount;\n\n        emit CreditApproval(account, msg.sender, beneficiary, amount);\n    }\n\n    /**\n     * @notice Takes out debt backed by collateral in an Arcadia Account.\n     * @param amount The amount of underlying ERC20 tokens to be lent out.\n     * @param account The address of the Arcadia Account backing the debt.\n     * @param to The address who receives the lent out underlying tokens.\n     * @param referrer A unique identifier of the referrer, who will receive part of the fees generated by this transaction.\n     * @dev The sender might be different than the owner if they have the proper allowances.\n     */\n    function borrow(uint256 amount, address account, address to, bytes3 referrer)\n        external\n        whenBorrowNotPaused\n        processInterests\n    {\n        // If Account is not an actual address of an Account, ownerOfAccount(address) will return the zero address.\n        address accountOwner = IFactory(ACCOUNT_FACTORY).ownerOfAccount(account);\n        if (accountOwner == address(0)) revert LendingPoolErrors.IsNotAnAccount();\n\n        uint256 amountWithFee = amount + amount.mulDivUp(originationFee, ONE_4);\n\n        // Check allowances to take debt.\n        if (accountOwner != msg.sender) {\n            uint256 allowed = creditAllowance[account][accountOwner][msg.sender];\n            if (allowed != type(uint256).max) {\n                creditAllowance[account][accountOwner][msg.sender] = allowed - amountWithFee;\n            }\n        }\n\n        // Mint debt tokens to the Account.\n        _deposit(amountWithFee, account);\n\n        // Add origination fee to the treasury.\n        unchecked {\n            if (amountWithFee - amount > 0) {\n                totalRealisedLiquidity = SafeCastLib.safeCastTo128(amountWithFee + totalRealisedLiquidity - amount);\n                realisedLiquidityOf[treasury] += amountWithFee - amount;\n            }\n        }\n\n        // UpdateOpenPosition checks that the Account indeed has opened a margin account for this Lending Pool and\n        // checks that it is still healthy after the debt is increased with amountWithFee.\n        // Reverts in Account if one of the checks fails.\n        uint256 accountVersion = IAccount(account).increaseOpenPosition(maxWithdraw(account));\n        if (!isValidVersion[accountVersion]) revert LendingPoolErrors.InvalidVersion();\n\n        // Transfer fails if there is insufficient liquidity in the pool.\n        asset.safeTransfer(to, amount);\n\n        emit Borrow(account, msg.sender, to, amount, amountWithFee - amount, referrer);\n    }\n\n    /**\n     * @notice Repays debt.\n     * @param amount The amount of underlying ERC20 tokens to be repaid.\n     * @param account The contract address of the Arcadia Account backing the debt.\n     * @dev if Account is not an actual address of an Arcadia Account, maxWithdraw(account) will always return 0.\n     * Function will not revert, but amount is always 0.\n     * @dev Anyone (EOAs and contracts) can repay debt in the name of an Account.\n     */\n    function repay(uint256 amount, address account) external whenRepayNotPaused processInterests {\n        uint256 accountDebt = maxWithdraw(account);\n        amount = accountDebt > amount ? amount : accountDebt;\n\n        // Need to transfer before burning debt or ERC777s could reenter.\n        // Address(this) is trusted -> no risk on re-entrancy attack after transfer.\n        asset.safeTransferFrom(msg.sender, address(this), amount);\n\n        _withdraw(amount, address(this), account);\n\n        emit Repay(account, msg.sender, amount);\n    }\n\n    /**\n     * @notice Repays debt via an auction.\n     * @param startDebt The amount of debt of the Account the moment the liquidation was initiated.\n     * @param minimumMargin_ The minimum margin of the Account.\n     * @param amount The amount repaid by a bidder during the auction.\n     * @param account The contract address of the Arcadia Account backing the debt.\n     * @param bidder The address of the bidder.\n     * @return earlyTerminate Bool indicating whether the full amount of debt was repaid.\n     * @dev This function allows a liquidator to repay a specified amount of debt for a user.\n     */\n    function auctionRepay(uint256 startDebt, uint256 minimumMargin_, uint256 amount, address account, address bidder)\n        external\n        whenLiquidationNotPaused\n        onlyLiquidator\n        processInterests\n        returns (bool earlyTerminate)\n    {\n        // Need to transfer before burning debt or ERC777s could reenter.\n        // Address(this) is trusted -> no risk on re-entrancy attack after transfer.\n        asset.safeTransferFrom(bidder, address(this), amount);\n\n        uint256 accountDebt = maxWithdraw(account);\n        if (accountDebt == 0) revert LendingPoolErrors.IsNotAnAccountWithDebt();\n        if (accountDebt <= amount) {\n            // The amount recovered by selling assets during the auction is bigger than the total debt of the Account.\n            // -> Terminate the auction and make the surplus available to the Account-Owner.\n            earlyTerminate = true;\n            unchecked {\n                _settleLiquidationHappyFlow(account, startDebt, minimumMargin_, bidder, (amount - accountDebt));\n            }\n            amount = accountDebt;\n        }\n\n        _withdraw(amount, address(this), account);\n\n        emit Repay(account, bidder, amount);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                        LEVERAGED ACTIONS LOGIC\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Execute and interact with external logic on leverage.\n     * @param amountBorrowed The amount of underlying ERC20 tokens to be lent out.\n     * @param account The address of the Arcadia Account backing the debt.\n     * @param actionTarget The address of the Action Target to call.\n     * @param actionData A bytes object containing three actionAssetData structs, an address array and a bytes array.\n     * @param referrer A unique identifier of the referrer, who will receive part of the fees generated by this transaction.\n     * @dev The sender might be different than the owner if they have the proper allowances.\n     * @dev accountManagementAction() works similar to flash loans, this function optimistically calls external logic and checks for the Account state at the very end.\n     */\n    function flashAction(\n        uint256 amountBorrowed,\n        address account,\n        address actionTarget,\n        bytes calldata actionData,\n        bytes3 referrer\n    ) external whenBorrowNotPaused processInterests {\n        // If Account is not an actual address of a Account, ownerOfAccount(address) will return the zero address.\n        address accountOwner = IFactory(ACCOUNT_FACTORY).ownerOfAccount(account);\n        if (accountOwner == address(0)) revert LendingPoolErrors.IsNotAnAccount();\n\n        uint256 amountBorrowedWithFee = amountBorrowed + amountBorrowed.mulDivUp(originationFee, ONE_4);\n\n        // Check allowances to take debt.\n        if (accountOwner != msg.sender) {\n            // Since calling accountManagementAction() gives the sender full control over all assets in the Account,\n            // Only Beneficiaries with maximum allowance can call the flashAction function.\n            if (creditAllowance[account][accountOwner][msg.sender] != type(uint256).max) {\n                revert LendingPoolErrors.Unauthorized();\n            }\n        }\n\n        // Mint debt tokens to the Account, debt must be minted before the actions in the Account are performed.\n        _deposit(amountBorrowedWithFee, account);\n\n        // Add origination fee to the treasury.\n        unchecked {\n            if (amountBorrowedWithFee - amountBorrowed > 0) {\n                totalRealisedLiquidity += SafeCastLib.safeCastTo128(amountBorrowedWithFee - amountBorrowed);\n                realisedLiquidityOf[treasury] += amountBorrowedWithFee - amountBorrowed;\n            }\n        }\n\n        // Need to update the actionTimestamp before transferring tokens,\n        // or ERC777s could reenter to frontrun Account transfers.\n        IAccount(account).updateActionTimestampByCreditor();\n\n        // Send Borrowed funds to the actionTarget.\n        asset.safeTransfer(actionTarget, amountBorrowed);\n\n        // The Action Target will use the borrowed funds (optionally with additional assets withdrawn from the Account)\n        // to execute one or more actions (swap, deposit, mint...).\n        // Next the action Target will deposit any of the remaining funds or any of the recipient token\n        // resulting from the actions back into the Account.\n        // As last step, after all assets are deposited back into the Account a final health check is done:\n        // The Collateral Value of all assets in the Account is bigger than the total liabilities against the Account (including the debt taken during this function).\n        // flashActionByCreditor also checks that the Account indeed has opened a margin account for this Lending Pool.\n        {\n            uint256 accountVersion = IAccount(account).flashActionByCreditor(actionTarget, actionData);\n            if (!isValidVersion[accountVersion]) revert LendingPoolErrors.InvalidVersion();\n        }\n\n        unchecked {\n            emit Borrow(\n                account, msg.sender, actionTarget, amountBorrowed, amountBorrowedWithFee - amountBorrowed, referrer\n            );\n        }\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Returns the total amount of outstanding debt in the underlying asset.\n     * @return totalDebt The total debt in underlying assets.\n     */\n    function totalAssets() public view override returns (uint256 totalDebt) {\n        // Avoid a second calculation of unrealised debt (expensive)\n        // if interests are already synced this block.\n        if (lastSyncedTimestamp != uint32(block.timestamp)) {\n            totalDebt = realisedDebt + calcUnrealisedDebt();\n        } else {\n            totalDebt = realisedDebt;\n        }\n    }\n\n    /**\n     * @notice Returns the total redeemable amount of liquidity in the underlying asset.\n     * @return totalLiquidity_ The total redeemable amount of liquidity in the underlying asset.\n     */\n    function totalLiquidity() external view returns (uint256 totalLiquidity_) {\n        // Avoid a second calculation of unrealised debt (expensive)\n        // if interests are already synced this block.\n        if (lastSyncedTimestamp != uint32(block.timestamp)) {\n            // The total liquidity equals the sum of the realised liquidity, and the pending interests.\n            unchecked {\n                totalLiquidity_ = totalRealisedLiquidity + calcUnrealisedDebt();\n            }\n        } else {\n            totalLiquidity_ = totalRealisedLiquidity;\n        }\n    }\n\n    /**\n     * @notice Returns the redeemable amount of liquidity in the underlying asset of an address.\n     * @param owner_ The address of the liquidity provider.\n     * @return assets The redeemable amount of liquidity in the underlying asset.\n     * @dev This function syncs the interests to prevent calculating UnrealisedDebt twice when depositing/withdrawing through the Tranches.\n     * @dev After calling this function, the interest rate will not be updated until the next processInterests() call.\n     */\n    function liquidityOfAndSync(address owner_) external returns (uint256 assets) {\n        _syncInterests();\n        assets = realisedLiquidityOf[owner_];\n    }\n\n    /**\n     * @notice Returns the redeemable amount of liquidity in the underlying asset of an address.\n     * @param owner_ The address of the liquidity provider.\n     * @return assets The redeemable amount of liquidity in the underlying asset.\n     */\n    function liquidityOf(address owner_) external view returns (uint256 assets) {\n        // Avoid a second calculation of unrealised debt (expensive).\n        // if interests are already synced this block.\n        if (lastSyncedTimestamp != uint32(block.timestamp)) {\n            // The total liquidity of a tranche equals the sum of the realised liquidity\n            // of the tranche, and its pending interests.\n            uint256 interest = calcUnrealisedDebt().mulDivDown(interestWeight[owner_], totalInterestWeight);\n            unchecked {\n                assets = realisedLiquidityOf[owner_] + interest;\n            }\n        } else {\n            assets = realisedLiquidityOf[owner_];\n        }\n    }\n\n    /**\n     * @notice Skims any surplus funds in the LendingPool to the treasury.\n     * @dev In normal conditions (when there are no ongoing auctions), the total Claimable Liquidity should be equal\n     * to the sum of the available funds (the balanceOf() the underlying asset) in the pool and the total open debt.\n     * In practice the actual sum of available funds and total open debt will always be bigger than the total Claimable Liquidity.\n     * This because of the rounding errors of the ERC4626 calculations (conversions between assets and shares),\n     * or because someone accidentally sent funds directly to the"
    }
  ]
}