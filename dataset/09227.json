{
  "Title": "[L-02] Low level calls don't check for contract existence",
  "Content": "\nLow level calls return success if called on a destructed contract. See OpenZeppelin's Address.so which checks address.code.length\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts-full/libraries/TokenUtils.sol   #1\n\n65       function safeTransfer(address token, address recipient, uint256 amount) internal {\n66           (bool success, bytes memory data) = token.call(\n67               abi.encodeWithSelector(IERC20Minimal.transfer.selector, recipient, amount)\n68:          );\n```\n\n<https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/libraries/TokenUtils.sol#L65-L68>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-05-alchemix-contest",
  "Code": [
    {
      "filename": "contracts-full/libraries/TokenUtils.sol",
      "content": "pragma solidity ^0.8.11;\n\nimport \"../interfaces/IERC20Burnable.sol\";\nimport \"../interfaces/IERC20Metadata.sol\";\nimport \"../interfaces/IERC20Minimal.sol\";\nimport \"../interfaces/IERC20Mintable.sol\";\n\n/// @title  TokenUtils\n/// @author Alchemix Finance\nlibrary TokenUtils {\n    /// @notice An error used to indicate that a call to an ERC20 contract failed.\n    ///\n    /// @param target  The target address.\n    /// @param success If the call to the token was a success.\n    /// @param data    The resulting data from the call. This is error data when the call was not a success. Otherwise,\n    ///                this is malformed data when the call was a success.\n    error ERC20CallFailed(address target, bool success, bytes data);\n\n    /// @dev A safe function to get the decimals of an ERC20 token.\n    ///\n    /// @dev Reverts with a {CallFailed} error if execution of the query fails or returns an unexpected value.\n    ///\n    /// @param token The target token.\n    ///\n    /// @return The amount of decimals of the token.\n    function expectDecimals(address token) internal view returns (uint8) {\n        (bool success, bytes memory data) = token.staticcall(\n            abi.encodeWithSelector(IERC20Metadata.decimals.selector)\n        );\n\n        if (!success || data.length < 32) {\n            revert ERC20CallFailed(token, success, data);\n        }\n\n        return abi.decode(data, (uint8));\n    }\n\n    /// @dev Gets the balance of tokens held by an account.\n    ///\n    /// @dev Reverts with a {CallFailed} error if execution of the query fails or returns an unexpected value.\n    ///\n    /// @param token   The token to check the balance of.\n    /// @param account The address of the token holder.\n    ///\n    /// @return The balance of the tokens held by an account.\n    function safeBalanceOf(address token, address account) internal view returns (uint256) {\n        (bool success, bytes memory data) = token.staticcall(\n            abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, account)\n        );\n\n        if (!success || data.length < 32) {\n            revert ERC20CallFailed(token, success, data);\n        }\n\n        return abi.decode(data, (uint256));\n    }\n\n    /// @dev Transfers tokens to another address.\n    ///\n    /// @dev Reverts with a {CallFailed} error if execution of the transfer failed or returns an unexpected value.\n    ///\n    /// @param token     The token to transfer.\n    /// @param recipient The address of the recipient.\n    /// @param amount    The amount of tokens to transfer.\n    function safeTransfer(address token, address recipient, uint256 amount) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20Minimal.transfer.selector, recipient, amount)\n        );\n\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\n            revert ERC20CallFailed(token, success, data);\n        }\n    }\n\n    /// @dev Approves tokens for the smart contract.\n    ///\n    /// @dev Reverts with a {CallFailed} error if execution of the approval fails or returns an unexpected value.\n    ///\n    /// @param token   The token to approve.\n    /// @param spender The contract to spend the tokens.\n    /// @param value   The amount of tokens to approve.\n    function safeApprove(address token, address spender, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20Minimal.approve.selector, spender, value)\n        );\n\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\n            revert ERC20CallFailed(token, success, data);\n        }\n    }\n\n    /// @dev Transfer tokens from one address to another address.\n    ///\n    /// @dev Reverts with a {CallFailed} error if execution of the transfer fails or returns an unexpected value.\n    ///\n    /// @param token     The token to transfer.\n    /// @param owner     The address of the owner.\n    /// @param recipient The address of the recipient.\n    /// @param amount    The amount of tokens to transfer.\n    function safeTransferFrom(address token, address owner, address recipient, uint256 amount) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20Minimal.transferFrom.selector, owner, recipient, amount)\n        );\n\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\n            revert ERC20CallFailed(token, success, data);\n        }\n    }\n\n    /// @dev Mints tokens to an address.\n    ///\n    /// @dev Reverts with a {CallFailed} error if execution of the mint fails or returns an unexpected value.\n    ///\n    /// @param token     The token to mint.\n    /// @param recipient The address of the recipient.\n    /// @param amount    The amount of tokens to mint.\n    function safeMint(address token, address recipient, uint256 amount) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20Mintable.mint.selector, recipient, amount)\n        );\n\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\n            revert ERC20CallFailed(token, success, data);\n        }\n    }\n\n    /// @dev Burns tokens.\n    ///\n    /// Reverts with a `CallFailed` error if execution of the burn fails or returns an unexpected value.\n    ///\n    /// @param token  The token to burn.\n    /// @param amount The amount of tokens to burn.\n    function safeBurn(address token, uint256 amount) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20Burnable.burn.selector, amount)\n        );\n\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\n            revert ERC20CallFailed(token, success, data);\n        }\n    }\n\n    /// @dev Burns tokens from its total supply.\n    ///\n    /// @dev Reverts with a {CallFailed} error if execution of the burn fails or returns an unexpected value.\n    ///\n    /// @param token  The token to burn.\n    /// @param owner  The owner of the tokens.\n    /// @param amount The amount of tokens to burn.\n    function safeBurnFrom(address token, address owner, uint256 amount) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20Burnable.burnFrom.selector, owner, amount)\n        );\n\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\n            revert ERC20CallFailed(token, success, data);\n        }\n    }\n}"
    }
  ]
}