{
  "Title": "[M-03] Protocol markets are incompatible with rebasing tokens",
  "Content": "\nSome tokens (eg. [AMPL](https://etherscan.io/token/0xd46ba6d942050d489dbd938a2c909a5d5039a161)), known as rebasing tokens, have dynamic balances. This means that the token balance of an address could increase or decrease over time.\n\nHowever, markets in the protocol are unable to handle such changes in token balance. When lenders call `depositUpTo()`, the amount of assets they deposit is stored as a fixed amount in `account.scaledBalance`:\n\n[WildcatMarket.sol#L56-L65](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/market/WildcatMarket.sol#L56-L65)\n\n```solidity\n    uint104 scaledAmount = state.scaleAmount(amount).toUint104();\n    if (scaledAmount == 0) revert NullMintAmount();\n\n    // Transfer deposit from caller\n    asset.safeTransferFrom(msg.sender, address(this), amount);\n\n    // Cache account data and revert if not authorized to deposit.\n    Account memory account = _getAccountWithRole(msg.sender, AuthRole.DepositAndWithdraw);\n    account.scaledBalance += scaledAmount;\n    _accounts[msg.sender] = account;\n```\n\nAfterwards, when lenders want to withdraw their assets, the amount of assets that they can withdraw will be based off this value.\n\nTherefore, since a lender's `scaledBalance` is fixed and does not change according to the underlying asset balance, lenders will lose funds if they deposit into a market with a rebasing token as the asset.\n\nFor example, if AMPL is used as the market's asset, and AMPL rebases to increase the token balance of all its users, lenders in the market will still only be able to withdraw the original amount they deposited multiplied by the market's interest rate. The underlying increase in AMPL will not accrue to anyone, and is only accessible by the borrower by calling [`borrow()`](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/market/WildcatMarket.sol#L111-L131).\n\n### Impact\n\nIf a market uses a rebasing tokens as its asset, lenders will lose funds when the asset token rebases.\n\n### Recommended Mitigation\n\nConsider implementing a token blacklist in the protocol, such as in `WildcatArchController`, and adding all rebasing tokens to this blacklist.\n\nAdditionally, consider documenting that markets are not compatible with rebasing tokens.\n\n### Assessed type\n\nERC20\n\n**[laurenceday (Wildcat) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2023-10-wildcat-findings/issues/503#issuecomment-1788179177):**\n > This is a Low that we can flag up to borrowers deploying. Not interested in maintaining a token whitelist or blacklist, as it goes against the point that we don't intervene.\n\n**[0xTheC0der (judge) commented](https://github.com/code-423n4/2023-10-wildcat-findings/issues/503#issuecomment-1800342262):**\n > 1. I cannot find any info within the scope of this audit that rebasing tokens are OOS or unsupported. Please let me know, in case I overlooked it.\n> 2. Rebasing tokens, like `stETH` to name a \"central\" example, are no novelty in the DeFi space anymore and users expect DeFi protocols to be compatible with them when no further notice is provided.\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2023-10-wildcat-findings/issues/503).*\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-wildcat",
  "Code": [
    {
      "filename": "src/market/WildcatMarket.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../libraries/FeeMath.sol';\nimport './WildcatMarketBase.sol';\nimport './WildcatMarketConfig.sol';\nimport './WildcatMarketToken.sol';\nimport './WildcatMarketWithdrawals.sol';\n\ncontract WildcatMarket is\n  WildcatMarketBase,\n  WildcatMarketConfig,\n  WildcatMarketToken,\n  WildcatMarketWithdrawals\n{\n  using MathUtils for uint256;\n  using SafeCastLib for uint256;\n  using SafeTransferLib for address;\n\n  /**\n   * @dev Apply pending interest, delinquency fees and protocol fees\n   *      to the state and process the pending withdrawal batch if\n   *      one exists and has expired, then update the market's\n   *      delinquency status.\n   */\n  function updateState() external nonReentrant {\n    MarketState memory state = _getUpdatedState();\n    _writeState(state);\n  }\n\n  /**\n   * @dev Deposit up to `amount` underlying assets and mint market tokens\n   *      for `msg.sender`.\n   *\n   *      The actual deposit amount is limited by the market's maximum deposit\n   *      amount, which is the configured `maxTotalSupply` minus the current\n   *      total supply.\n   *\n   *      Reverts if the market is closed or if the scaled token amount\n   *      that would be minted for the deposit is zero.\n   */\n  function depositUpTo(\n    uint256 amount\n  ) public virtual nonReentrant returns (uint256 /* actualAmount */) {\n    // Get current state\n    MarketState memory state = _getUpdatedState();\n\n    if (state.isClosed) {\n      revert DepositToClosedMarket();\n    }\n\n    // Reduce amount if it would exceed totalSupply\n    amount = MathUtils.min(amount, state.maximumDeposit());\n\n    // Scale the mint amount\n    uint104 scaledAmount = state.scaleAmount(amount).toUint104();\n    if (scaledAmount == 0) revert NullMintAmount();\n\n    // Transfer deposit from caller\n    asset.safeTransferFrom(msg.sender, address(this), amount);\n\n    // Cache account data and revert if not authorized to deposit.\n    Account memory account = _getAccountWithRole(msg.sender, AuthRole.DepositAndWithdraw);\n    account.scaledBalance += scaledAmount;\n    _accounts[msg.sender] = account;\n\n    emit Transfer(address(0), msg.sender, amount);\n    emit Deposit(msg.sender, amount, scaledAmount);\n\n    // Increase supply\n    state.scaledTotalSupply += scaledAmount;\n\n    // Update stored state\n    _writeState(state);\n\n    return amount;\n  }\n\n  /**\n   * @dev Deposit exactly `amount` underlying assets and mint market tokens\n   *      for `msg.sender`.\n   *\n   *     Reverts if the deposit amount would cause the market to exceed the\n   *     configured `maxTotalSupply`.\n   */\n  function deposit(uint256 amount) external virtual {\n    uint256 actualAmount = depositUpTo(amount);\n    if (amount != actualAmount) {\n      revert MaxSupplyExceeded();\n    }\n  }\n\n  /**\n   * @dev Withdraw available protocol fees to the fee recipient.\n   */\n  function collectFees() external nonReentrant {\n    MarketState memory state = _getUpdatedState();\n    if (state.accruedProtocolFees == 0) {\n      revert NullFeeAmount();\n    }\n    uint128 withdrawableFees = state.withdrawableProtocolFees(totalAssets());\n    if (withdrawableFees == 0) {\n      revert InsufficientReservesForFeeWithdrawal();\n    }\n    state.accruedProtocolFees -= withdrawableFees;\n    _writeState(state);\n    asset.safeTransfer(feeRecipient, withdrawableFees);\n    emit FeesCollected(withdrawableFees);\n  }\n\n  /**\n   * @dev Withdraw funds from the market to the borrower.\n   *\n   *      Can only withdraw up to the assets that are not required\n   *      to meet the borrower's collateral obligations.\n   *\n   *      Reverts if the market is closed.\n   */\n  function borrow(uint256 amount) external onlyBorrower nonReentrant {\n    MarketState memory state = _getUpdatedState();\n    if (state.isClosed) {\n      revert BorrowFromClosedMarket();\n    }\n    uint256 borrowable = state.borrowableAssets(totalAssets());\n    if (amount > borrowable) {\n      revert BorrowAmountTooHigh();\n    }\n    _writeState(state);\n    asset.safeTransfer(msg.sender, amount);\n    emit Borrow(amount);\n  }\n\n  /**\n   * @dev Sets the market APR to 0% and marks market as closed.\n   *\n   *      Can not be called if there are any unpaid withdrawal batches.\n   *\n   *      Transfers remaining debts from borrower if market is not fully\n   *      collateralized; otherwise, transfers any assets in excess of\n   *      debts to the borrower.\n   */\n  function closeMarket() external onlyController nonReentrant {\n    MarketState memory state = _getUpdatedState();\n    state.annualInterestBips = 0;\n    state.isClosed = true;\n    state.reserveRatioBips = 0;\n    if (_withdrawalData.unpaidBatches.length() > 0) {\n      revert CloseMarketWithUnpaidWithdrawals();\n    }\n    uint256 currentlyHeld = totalAssets();\n    uint256 totalDebts = state.totalDebts();\n    if (currentlyHeld < totalDebts) {\n      // Transfer remaining debts from borrower\n      asset.safeTransferFrom(borrower, address(this), totalDebts - currentlyHeld);\n    } else if (currentlyHeld > totalDebts) {\n      // Transfer excess assets to borrower\n      asset.safeTransfer(borrower, currentlyHeld - totalDebts);\n    }\n    _writeState(state);\n    emit MarketClosed(block.timestamp);\n  }\n}"
    },
    {
      "filename": "src/market/WildcatMarket.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../libraries/FeeMath.sol';\nimport './WildcatMarketBase.sol';\nimport './WildcatMarketConfig.sol';\nimport './WildcatMarketToken.sol';\nimport './WildcatMarketWithdrawals.sol';\n\ncontract WildcatMarket is\n  WildcatMarketBase,\n  WildcatMarketConfig,\n  WildcatMarketToken,\n  WildcatMarketWithdrawals\n{\n  using MathUtils for uint256;\n  using SafeCastLib for uint256;\n  using SafeTransferLib for address;\n\n  /**\n   * @dev Apply pending interest, delinquency fees and protocol fees\n   *      to the state and process the pending withdrawal batch if\n   *      one exists and has expired, then update the market's\n   *      delinquency status.\n   */\n  function updateState() external nonReentrant {\n    MarketState memory state = _getUpdatedState();\n    _writeState(state);\n  }\n\n  /**\n   * @dev Deposit up to `amount` underlying assets and mint market tokens\n   *      for `msg.sender`.\n   *\n   *      The actual deposit amount is limited by the market's maximum deposit\n   *      amount, which is the configured `maxTotalSupply` minus the current\n   *      total supply.\n   *\n   *      Reverts if the market is closed or if the scaled token amount\n   *      that would be minted for the deposit is zero.\n   */\n  function depositUpTo(\n    uint256 amount\n  ) public virtual nonReentrant returns (uint256 /* actualAmount */) {\n    // Get current state\n    MarketState memory state = _getUpdatedState();\n\n    if (state.isClosed) {\n      revert DepositToClosedMarket();\n    }\n\n    // Reduce amount if it would exceed totalSupply\n    amount = MathUtils.min(amount, state.maximumDeposit());\n\n    // Scale the mint amount\n    uint104 scaledAmount = state.scaleAmount(amount).toUint104();\n    if (scaledAmount == 0) revert NullMintAmount();\n\n    // Transfer deposit from caller\n    asset.safeTransferFrom(msg.sender, address(this), amount);\n\n    // Cache account data and revert if not authorized to deposit.\n    Account memory account = _getAccountWithRole(msg.sender, AuthRole.DepositAndWithdraw);\n    account.scaledBalance += scaledAmount;\n    _accounts[msg.sender] = account;\n\n    emit Transfer(address(0), msg.sender, amount);\n    emit Deposit(msg.sender, amount, scaledAmount);\n\n    // Increase supply\n    state.scaledTotalSupply += scaledAmount;\n\n    // Update stored state\n    _writeState(state);\n\n    return amount;\n  }\n\n  /**\n   * @dev Deposit exactly `amount` underlying assets and mint market tokens\n   *      for `msg.sender`.\n   *\n   *     Reverts if the deposit amount would cause the market to exceed the\n   *     configured `maxTotalSupply`.\n   */\n  function deposit(uint256 amount) external virtual {\n    uint256 actualAmount = depositUpTo(amount);\n    if (amount != actualAmount) {\n      revert MaxSupplyExceeded();\n    }\n  }\n\n  /**\n   * @dev Withdraw available protocol fees to the fee recipient.\n   */\n  function collectFees() external nonReentrant {\n    MarketState memory state = _getUpdatedState();\n    if (state.accruedProtocolFees == 0) {\n      revert NullFeeAmount();\n    }\n    uint128 withdrawableFees = state.withdrawableProtocolFees(totalAssets());\n    if (withdrawableFees == 0) {\n      revert InsufficientReservesForFeeWithdrawal();\n    }\n    state.accruedProtocolFees -= withdrawableFees;\n    _writeState(state);\n    asset.safeTransfer(feeRecipient, withdrawableFees);\n    emit FeesCollected(withdrawableFees);\n  }\n\n  /**\n   * @dev Withdraw funds from the market to the borrower.\n   *\n   *      Can only withdraw up to the assets that are not required\n   *      to meet the borrower's collateral obligations.\n   *\n   *      Reverts if the market is closed.\n   */\n  function borrow(uint256 amount) external onlyBorrower nonReentrant {\n    MarketState memory state = _getUpdatedState();\n    if (state.isClosed) {\n      revert BorrowFromClosedMarket();\n    }\n    uint256 borrowable = state.borrowableAssets(totalAssets());\n    if (amount > borrowable) {\n      revert BorrowAmountTooHigh();\n    }\n    _writeState(state);\n    asset.safeTransfer(msg.sender, amount);\n    emit Borrow(amount);\n  }\n\n  /**\n   * @dev Sets the market APR to 0% and marks market as closed.\n   *\n   *      Can not be called if there are any unpaid withdrawal batches.\n   *\n   *      Transfers remaining debts from borrower if market is not fully\n   *      collateralized; otherwise, transfers any assets in excess of\n   *      debts to the borrower.\n   */\n  function closeMarket() external onlyController nonReentrant {\n    MarketState memory state = _getUpdatedState();\n    state.annualInterestBips = 0;\n    state.isClosed = true;\n    state.reserveRatioBips = 0;\n    if (_withdrawalData.unpaidBatches.length() > 0) {\n      revert CloseMarketWithUnpaidWithdrawals();\n    }\n    uint256 currentlyHeld = totalAssets();\n    uint256 totalDebts = state.totalDebts();\n    if (currentlyHeld < totalDebts) {\n      // Transfer remaining debts from borrower\n      asset.safeTransferFrom(borrower, address(this), totalDebts - currentlyHeld);\n    } else if (currentlyHeld > totalDebts) {\n      // Transfer excess assets to borrower\n      asset.safeTransfer(borrower, currentlyHeld - totalDebts);\n    }\n    _writeState(state);\n    emit MarketClosed(block.timestamp);\n  }\n}"
    }
  ]
}