{
  "Title": "Disable Implementation Contract",
  "Content": "The `L1StandardBridge` implementation contract [sets the messenger to the zero address](https://github.com/mantlenetworkio/mantle/blob/d627d242fe19f50f344f1ff4b27532d1757303a6/packages/contracts/contracts/L1/messaging/L1StandardBridge.sol#L41), but this doesn't prevent it from being [initialized](https://github.com/mantlenetworkio/mantle/blob/d627d242fe19f50f344f1ff4b27532d1757303a6/packages/contracts/contracts/L1/messaging/L1StandardBridge.sol#L53).\n\n\nIn the interest of limiting the attack surface, consider ensuring the implementation contract cannot be initialized. This could be achieved by setting the messenger to an unused non-zero address.\n\n\n***Update:** Acknowledged, not resolved. The Mantle team stated:*\n\n\n\n> *We will use our proxy contract to initialize right after deploying the bridge contract, and the proxy contract will be required to be initialized only once. Even if someone tries to initialize the implementation contract afterwards, it will have no impact on our proxy contract.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/contracts/contracts/L1/messaging/L1StandardBridge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Interface Imports */\nimport { IL1StandardBridge } from \"./IL1StandardBridge.sol\";\nimport { IL1ERC20Bridge } from \"./IL1ERC20Bridge.sol\";\nimport { IL2ERC20Bridge } from \"../../L2/messaging/IL2ERC20Bridge.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/* Library Imports */\nimport { CrossDomainEnabled } from \"../../libraries/bridge/CrossDomainEnabled.sol\";\nimport { Lib_PredeployAddresses } from \"../../libraries/constants/Lib_PredeployAddresses.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title L1StandardBridge\n * @dev The L1 ETH and ERC20 Bridge is a contract which stores deposited L1 funds and standard\n * tokens that are in use on L2. It synchronizes a corresponding L2 Bridge, informing it of deposits\n * and listening to it for newly finalized withdrawals.\n *\n */\ncontract L1StandardBridge is IL1StandardBridge, CrossDomainEnabled {\n    using SafeERC20 for IERC20;\n\n    /********************************\n     * External Contract References *\n     ********************************/\n\n    address public l2TokenBridge;\n    address public l1MantleAddress;\n\n    // Maps L1 token to L2 token to balance of the L1 token deposited\n    mapping(address => mapping(address => uint256)) public deposits;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    // This contract lives behind a proxy, so the constructor parameters will go unused.\n    constructor() CrossDomainEnabled(address(0)) {}\n\n    /******************\n     * Initialization *\n     ******************/\n\n    /**\n     * @param _l1messenger L1 Messenger address being used for cross-chain communications.\n     * @param _l2TokenBridge L2 standard bridge address.\n     * @param _l1MantleAddress initialize L1 mantle address\n     */\n    // slither-disable-next-line external-function\n    function initialize(address _l1messenger, address _l2TokenBridge, address _l1MantleAddress) public {\n        require(messenger == address(0), \"Contract has already been initialized.\");\n        messenger = _l1messenger;\n        l2TokenBridge = _l2TokenBridge;\n        l1MantleAddress = _l1MantleAddress;\n    }\n\n    /**************\n     * Depositing *\n     **************/\n\n    /** @dev Modifier requiring sender to be EOA.  This check could be bypassed by a malicious\n     *  contract via initcode, but it takes care of the user error we want to avoid.\n     */\n    modifier onlyEOA() {\n        // Used to stop deposits from contracts (avoid accidentally lost tokens)\n        require(!Address.isContract(msg.sender), \"Account not EOA\");\n        require(tx.origin==msg.sender, \"msg.sender is not ts origin\");\n        _;\n    }\n\n    /**\n     * @dev This function can be called with no data\n     * to deposit an amount of ETH to the caller's balance on L2.\n     * Since the receive function doesn't take data, a conservative\n     * default amount is forwarded to L2.\n     */\n    receive() external payable onlyEOA {\n        _initiateETHDeposit(msg.sender, msg.sender, 200_000, bytes(\"\"));\n    }\n\n    /**\n     * @inheritdoc IL1StandardBridge\n     */\n    function depositETH(uint32 _l2Gas, bytes calldata _data) external payable onlyEOA {\n        _initiateETHDeposit(msg.sender, msg.sender, _l2Gas, _data);\n    }\n\n    /**\n     * @inheritdoc IL1StandardBridge\n     */\n    function depositETHTo(\n        address _to,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external payable {\n        _initiateETHDeposit(msg.sender, _to, _l2Gas, _data);\n    }\n\n    /**\n     * @dev Performs the logic for deposits by storing the ETH and informing the L2 ETH Gateway of\n     * the deposit.\n     * @param _from Account to pull the deposit from on L1.\n     * @param _to Account to give the deposit to on L2.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function _initiateETHDeposit(\n        address _from,\n        address _to,\n        uint32 _l2Gas,\n        bytes memory _data\n    ) internal {\n        // Construct calldata for finalizeDeposit call\n        bytes memory message = abi.encodeWithSelector(\n            IL2ERC20Bridge.finalizeDeposit.selector,\n            address(0),\n            Lib_PredeployAddresses.BVM_ETH,\n            _from,\n            _to,\n            msg.value,\n            _data\n        );\n\n        // Send calldata into L2\n        // slither-disable-next-line reentrancy-events\n        sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);\n\n        // slither-disable-next-line reentrancy-events\n        emit ETHDepositInitiated(_from, _to, msg.value, _data);\n    }\n\n    /**\n     * @inheritdoc IL1ERC20Bridge\n     */\n    function depositERC20(\n        address _l1Token,\n        address _l2Token,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external virtual onlyEOA {\n        _initiateERC20Deposit(_l1Token, _l2Token, msg.sender, msg.sender, _amount, _l2Gas, _data);\n    }\n\n    /**\n     * @inheritdoc IL1ERC20Bridge\n     */\n    function depositERC20To(\n        address _l1Token,\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external virtual {\n        _initiateERC20Deposit(_l1Token, _l2Token, msg.sender, _to, _amount, _l2Gas, _data);\n    }\n\n    /**\n     * @dev Performs the logic for deposits by informing the L2 Deposited Token\n     * contract of the deposit and calling a handler to lock the L1 funds. (e.g. transferFrom)\n     *\n     * @param _l1Token Address of the L1 ERC20 we are depositing\n     * @param _l2Token Address of the L1 respective L2 ERC20\n     * @param _from Account to pull the deposit from on L1\n     * @param _to Account to give the deposit to on L2\n     * @param _amount Amount of the ERC20 to deposit.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function _initiateERC20Deposit(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) internal {\n        // When a deposit is initiated on L1, the L1 Bridge transfers the funds to itself for future\n        // withdrawals. The use of safeTransferFrom enables support of \"broken tokens\" which do not\n        // return a boolean value.\n        // slither-disable-next-line reentrancy-events, reentrancy-benign\n        IERC20(_l1Token).safeTransferFrom(_from, address(this), _amount);\n\n        // Construct calldata for _l2Token.finalizeDeposit(_to, _amount)\n        bytes memory message;\n        if (_l1Token == l1MantleAddress) {\n            // Construct calldata for finalizeDeposit call\n            require(_l2Token == Lib_PredeployAddresses.BVM_MANTLE, \"Unmatched token pair\");\n            message = abi.encodeWithSelector(\n                IL2ERC20Bridge.finalizeDeposit.selector,\n                address(0x1A4b46696b2bB4794Eb3D4c26f1c55F9170fa4C5),\n                Lib_PredeployAddresses.BVM_MANTLE,\n                _from,\n                _to,\n                _amount,\n                _data\n            );\n\n        } else {\n            // Construct calldata for finalizeDeposit call\n            message = abi.encodeWithSelector(\n                IL2ERC20Bridge.finalizeDeposit.selector,\n                _l1Token,\n                _l2Token,\n                _from,\n                _to,\n                _amount,\n                _data\n            );\n        }\n\n\n        // Send calldata into L2\n        // slither-disable-next-line reentrancy-events, reentrancy-benign\n        sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);\n\n        // slither-disable-next-line reentrancy-benign\n        deposits[_l1Token][_l2Token] = deposits[_l1Token][_l2Token] + _amount;\n\n        // slither-disable-next-line reentrancy-events\n        emit ERC20DepositInitiated(_l1Token, _l2Token, _from, _to, _amount, _data);\n    }\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n\n    /**\n     * @inheritdoc IL1StandardBridge\n     */\n    function finalizeETHWithdrawal(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external onlyFromCrossDomainAccount(l2TokenBridge) {\n        // slither-disable-next-line reentrancy-events\n        (bool success, ) = _to.call{ value: _amount }(new bytes(0));\n        require(success, \"TransferHelper::safeTransferETH: ETH transfer failed\");\n\n        // slither-disable-next-line reentrancy-events\n        emit ETHWithdrawalFinalized(_from, _to, _amount, _data);\n    }\n\n    /**\n     * @inheritdoc IL1ERC20Bridge\n     */\n    function finalizeMantleWithdrawal(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external onlyFromCrossDomainAccount(l2TokenBridge) {\n        finalizeERC20Withdrawal(l1MantleAddress, Lib_PredeployAddresses.BVM_MANTLE, _from, _to, _amount, _data);\n    }\n\n    /**\n     * @inheritdoc IL1ERC20Bridge\n     */\n    function finalizeERC20Withdrawal(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) public onlyFromCrossDomainAccount(l2TokenBridge) {\n        deposits[_l1Token][_l2Token] = deposits[_l1Token][_l2Token] - _amount;\n\n        // When a withdrawal is finalized on L1, the L1 Bridge transfers the funds to the withdrawer\n        // slither-disable-next-line reentrancy-events\n        IERC20(_l1Token).safeTransfer(_to, _amount);\n\n        // slither-disable-next-line reentrancy-events\n        emit ERC20WithdrawalFinalized(_l1Token, _l2Token, _from, _to, _amount, _data);\n    }\n\n    /*****************************\n     * Temporary - Migrating ETH *\n     *****************************/\n\n    /**\n     * @dev Adds ETH balance to the account. This is meant to allow for ETH\n     * to be migrated from an old gateway to a new gateway.\n     * NOTE: This is left for one upgrade only so we are able to receive the migrated ETH from the\n     * old contract\n     */\n    function donateETH() external payable {}\n}"
    }
  ]
}