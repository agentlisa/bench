{
  "Title": "[N-01] `RemoteAddressValidator::_lowerCase` will not work for Solana addresses",
  "Content": "\nhttps://github.com/code-423n4/2023-07-axelar/blob/main/contracts/its/remote-address-validator/RemoteAddressValidator.sol#L54-L61\n\n```solidity\nFile: its/remote-address-validator/RemoteAddressValidator.sol\n\n54:    function _lowerCase(string memory s) internal pure returns (string memory) {\n55:        uint256 length = bytes(s).length;\n56:        for (uint256 i; i < length; i++) {\n57:            uint8 b = uint8(bytes(s)[i]);\n58:            if ((b >= 65) && (b <= 70)) bytes(s)[i] = bytes1(b + uint8(32));\n59:        }\n60:        return s;\n61:    }\n```\n\nThis converts an address to lowercase (`65-70 -> A-F`). Solana addresses are `base58` encoded versions of a 32 byte array. Thus, they first have more letters and converting it to lowercase will make it another address.\n\n### Recommendation\n\nConsider changing this before adding Solana as a supported chain.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-axelar",
  "Code": [
    {
      "filename": "contracts/its/remote-address-validator/RemoteAddressValidator.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport { IRemoteAddressValidator } from '../interfaces/IRemoteAddressValidator.sol';\nimport { AddressToString } from '../../gmp-sdk/util/AddressString.sol';\nimport { Upgradable } from '../../gmp-sdk/upgradable/Upgradable.sol';\n\n/**\n * @title RemoteAddressValidator\n * @dev Manages and validates remote addresses, keeps track of addresses supported by the Axelar gateway contract\n */\ncontract RemoteAddressValidator is IRemoteAddressValidator, Upgradable {\n    using AddressToString for address;\n\n    mapping(string => bytes32) public remoteAddressHashes;\n    mapping(string => string) public remoteAddresses;\n    address public immutable interchainTokenServiceAddress;\n    bytes32 public immutable interchainTokenServiceAddressHash;\n    mapping(string => bool) public supportedByGateway;\n\n    bytes32 private constant CONTRACT_ID = keccak256('remote-address-validator');\n\n    /**\n     * @dev Constructs the RemoteAddressValidator contract, both array parameters must be equal in length\n     * @param _interchainTokenServiceAddress Address of the interchain token service\n     */\n    constructor(address _interchainTokenServiceAddress) {\n        if (_interchainTokenServiceAddress == address(0)) revert ZeroAddress();\n        interchainTokenServiceAddress = _interchainTokenServiceAddress;\n        interchainTokenServiceAddressHash = keccak256(bytes(_lowerCase(interchainTokenServiceAddress.toString())));\n    }\n\n    /**\n     * @notice Getter for the contract id.\n     */\n    function contractId() external pure returns (bytes32) {\n        return CONTRACT_ID;\n    }\n\n    function _setup(bytes calldata params) internal override {\n        (string[] memory trustedChainNames, string[] memory trustedAddresses) = abi.decode(params, (string[], string[]));\n        uint256 length = trustedChainNames.length;\n        if (length != trustedAddresses.length) revert LengthMismatch();\n        for (uint256 i; i < length; ++i) {\n            addTrustedAddress(trustedChainNames[i], trustedAddresses[i]);\n        }\n    }\n\n    /**\n     * @dev Converts a string to lower case\n     * @param s Input string to be converted\n     * @return string lowercase version of the input string\n     */\n    function _lowerCase(string memory s) internal pure returns (string memory) {\n        uint256 length = bytes(s).length;\n        for (uint256 i; i < length; i++) {\n            uint8 b = uint8(bytes(s)[i]);\n            if ((b >= 65) && (b <= 70)) bytes(s)[i] = bytes1(b + uint8(32));\n        }\n        return s;\n    }\n\n    /**\n     * @dev Validates that the sender is a valid interchain token service address\n     * @param sourceChain Source chain of the transaction\n     * @param sourceAddress Source address of the transaction\n     * @return bool true if the sender is validated, false otherwise\n     */\n    function validateSender(string calldata sourceChain, string calldata sourceAddress) external view returns (bool) {\n        string memory sourceAddressLC = _lowerCase(sourceAddress);\n        bytes32 sourceAddressHash = keccak256(bytes(sourceAddressLC));\n        if (sourceAddressHash == interchainTokenServiceAddressHash) {\n            return true;\n        }\n        return sourceAddressHash == remoteAddressHashes[sourceChain];\n    }\n\n    /**\n     * @dev Adds a trusted interchain token service address for the specified chain\n     * @param chain Chain name of the interchain token service\n     * @param addr Interchain token service address to be added\n     */\n    function addTrustedAddress(string memory chain, string memory addr) public onlyOwner {\n        if (bytes(chain).length == 0) revert ZeroStringLength();\n        if (bytes(addr).length == 0) revert ZeroStringLength();\n        remoteAddressHashes[chain] = keccak256(bytes(_lowerCase(addr)));\n        remoteAddresses[chain] = addr;\n        emit TrustedAddressAdded(chain, addr);\n    }\n\n    /**\n     * @dev Removes a trusted interchain token service address\n     * @param chain Chain name of the interchain token service to be removed\n     */\n    function removeTrustedAddress(string calldata chain) external onlyOwner {\n        if (bytes(chain).length == 0) revert ZeroStringLength();\n        remoteAddressHashes[chain] = bytes32(0);\n        remoteAddresses[chain] = '';\n        emit TrustedAddressRemoved(chain);\n    }\n\n    /**\n     * @dev Adds chains that are supported by the Axelar gateway\n     * @param chainNames List of chain names to be added as supported\n     */\n    function addGatewaySupportedChains(string[] calldata chainNames) external onlyOwner {\n        uint256 length = chainNames.length;\n        for (uint256 i; i < length; ++i) {\n            string calldata chainName = chainNames[i];\n            supportedByGateway[chainName] = true;\n            emit GatewaySupportedChainAdded(chainName);\n        }\n    }\n\n    /**\n     * @dev Removes chains that are no longer supported by the Axelar gateway\n     * @param chainNames List of chain names to be removed as supported\n     */\n    function removeGatewaySupportedChains(string[] calldata chainNames) external onlyOwner {\n        uint256 length = chainNames.length;\n        for (uint256 i; i < length; ++i) {\n            string calldata chainName = chainNames[i];\n            supportedByGateway[chainName] = false;\n            emit GatewaySupportedChainRemoved(chainName);\n        }\n    }\n\n    /**\n     * @dev Fetches the interchain token service address for the specified chain\n     * @param chainName Name of the chain\n     * @return remoteAddress Interchain token service address for the specified chain\n     */\n    function getRemoteAddress(string calldata chainName) external view returns (string memory remoteAddress) {\n        remoteAddress = remoteAddresses[chainName];\n        if (bytes(remoteAddress).length == 0) {\n            remoteAddress = interchainTokenServiceAddress.toString();\n        }\n    }\n}"
    }
  ]
}