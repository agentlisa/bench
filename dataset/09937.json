{
  "Title": "[M-04] `NestedFactory`: User can utilise accidentally sent ETH funds via `processOutputOrders()` / `processInputAndOutputOrders()`",
  "Content": "_Submitted by GreyArt_\n\n[NestedFactory.sol#L71](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L71)<br>\n[NestedFactory.sol#L286-L296](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L286-L296)<br>\n[NestedFactory.sol#L370-L375](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L370-L375)<br>\n[NestedFactory.sol#L482-L492](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L482-L492)<br>\n\nShould a user accidentally send ETH to the `NestedFactory`, anyone can utilise it to their own benefit by calling `processOutputOrders()` / `processInputAndOutputOrders()`. This is possible because:\n\n1.  `receive()` has no restriction on the sender\n2.  `processOutputOrders()` does not check `msg.value`, and rightly so, because funds are expected to come from `reserve`.\n3.  `transferInputTokens()` does not handle the case where `ETH` could be specified as an address by the user for an output order.\n\n```jsx\nif (address(_inputToken) == ETH) {\n  require(address(this).balance >= _inputTokenAmount, \"NF: INVALID_AMOUNT_IN\");\n  weth.deposit{ value: _inputTokenAmount }();\n  return (IERC20(address(weth)), _inputTokenAmount);\n}\n```\n\nHence, the attack vector is simple. Should a user accidentally send ETH to the contract, create an output `Order` with `token` being `ETH` and amount corresponding to the NestedFactoryâ€™s ETH balance.\n\n### Recommended Mitigation Steps\n\n1.  Since plain / direct`ETH` transfers are only expected to solely come from `weth` (excluding payable functions), we recommend restricting the sender to be `weth`, like how it is done in `[FeeSplitter](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L101-L104)`.\n\n    We are aware that this was raised previously here: [code-423n4/2021-11-nested-findings#188](https://github.com/code-423n4/2021-11-nested-findings/issues/188) and would like to add that restricting the sender in the `receive()` function will not affect `payable` functions. From from what we see, plain ETH transfers are also not expected to come from other sources like `NestedReserve` or operators.\n\n```solidity\nreceive() external payable {\n  require(msg.sender == address(weth), \"NF: ETH_SENDER_NOT_WETH\");\n}\n```\n\n2.  Check that `_fromReserve` is false in the scenario `address(_inputToken) == ETH`.\n\n```solidity\nif (address(_inputToken) == ETH) {\n  require(!_fromReserve, \"NF: INVALID_INPUT_TOKEN\");\n  require(address(this).balance >= _inputTokenAmount, \"NF: INVALID_AMOUNT_IN\");\n  weth.deposit{ value: _inputTokenAmount }();\n  return (IERC20(address(weth)), _inputTokenAmount);\n}\n```\n\n**[maximebrugel (Nested Finance) confirmed and resolved](https://github.com/code-423n4/2022-02-nested-findings/issues/44):**\n> PR: [Med/High Risk Fixes](https://github.com/NestedFi/nested-core-lego/pull/100)\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-nested-finance-contest",
  "Code": [
    {
      "filename": "contracts/NestedFactory.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.11;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./abstracts/OwnableProxyDelegation.sol\";\nimport \"./abstracts/MixinOperatorResolver.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\nimport \"./interfaces/external/IWETH.sol\";\nimport \"./interfaces/INestedFactory.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./NestedReserve.sol\";\nimport \"./NestedAsset.sol\";\nimport \"./NestedRecords.sol\";\n\n/// @title Creates, updates and destroys NestedAssets (portfolios).\n/// @notice Responsible for the business logic of the protocol and interaction with operators\ncontract NestedFactory is INestedFactory, ReentrancyGuard, OwnableProxyDelegation, MixinOperatorResolver {\n    using SafeERC20 for IERC20;\n\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Supported operators by the factory contract\n    bytes32[] private operators;\n\n    /// @dev Current feeSplitter contract/address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Current reserve contract/address\n    NestedReserve public immutable reserve;\n\n    /// @dev Current nested asset (ERC721) contract/address\n    NestedAsset public immutable nestedAsset;\n\n    /// @dev Wrapped Ether contract/address\n    /// Note: Will be WMATIC, WAVAX, WBNB,... Depending on the chain.\n    IWETH public immutable weth;\n\n    /// @dev Current records contract/address\n    NestedRecords public immutable nestedRecords;\n\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\n\n    constructor(\n        NestedAsset _nestedAsset,\n        NestedRecords _nestedRecords,\n        NestedReserve _reserve,\n        FeeSplitter _feeSplitter,\n        IWETH _weth,\n        address _operatorResolver\n    ) MixinOperatorResolver(_operatorResolver) {\n        require(\n            address(_nestedAsset) != address(0) &&\n                address(_nestedRecords) != address(0) &&\n                address(_reserve) != address(0) &&\n                address(_feeSplitter) != address(0) &&\n                address(_weth) != address(0) &&\n                _operatorResolver != address(0),\n            \"NF: INVALID_ADDRESS\"\n        );\n        nestedAsset = _nestedAsset;\n        nestedRecords = _nestedRecords;\n        reserve = _reserve;\n        feeSplitter = _feeSplitter;\n        weth = _weth;\n    }\n\n    /// @dev Receive function\n    receive() external payable {}\n\n    /* ------------------------------ MODIFIERS ---------------------------- */\n\n    /// @dev Reverts the transaction if the caller is not the token owner\n    /// @param _nftId The NFT Id\n    modifier onlyTokenOwner(uint256 _nftId) {\n        require(nestedAsset.ownerOf(_nftId) == _msgSender(), \"NF: CALLER_NOT_OWNER\");\n        _;\n    }\n\n    /// @dev Reverts the transaction if the nft is locked (hold by design).\n    /// The block.timestamp must be greater than NFT record lock timestamp\n    /// @param _nftId The NFT Id\n    modifier isUnlocked(uint256 _nftId) {\n        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), \"NF: LOCKED_NFT\");\n        _;\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Get the required operators\n    function resolverOperatorsRequired() public view override returns (bytes32[] memory) {\n        return operators;\n    }\n\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function addOperator(bytes32 operator) external override onlyOwner {\n        require(operator != bytes32(\"\"), \"NF: INVALID_OPERATOR_NAME\");\n        bytes32[] memory operatorsCache = operators;\n        for (uint256 i = 0; i < operatorsCache.length; i++) {\n            require(operatorsCache[i] != operator, \"NF: EXISTENT_OPERATOR\");\n        }\n        operators.push(operator);\n        emit OperatorAdded(operator);\n    }\n\n    /// @inheritdoc INestedFactory\n    function removeOperator(bytes32 operator) external override onlyOwner {\n        uint256 operatorsLength = operators.length;\n        for (uint256 i = 0; i < operatorsLength; i++) {\n            if (operators[i] == operator) {\n                operators[i] = operators[operatorsLength - 1];\n                operators.pop();\n                emit OperatorRemoved(operator);\n                return;\n            }\n        }\n        revert(\"NF: NON_EXISTENT_OPERATOR\");\n    }\n\n    /// @inheritdoc INestedFactory\n    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {\n        require(address(_feeSplitter) != address(0), \"NF: INVALID_FEE_SPLITTER_ADDRESS\");\n        feeSplitter = _feeSplitter;\n        emit FeeSplitterUpdated(address(_feeSplitter));\n    }\n\n    /// @inheritdoc INestedFactory\n    function unlockTokens(IERC20 _token) external override onlyOwner {\n        uint256 amount = _token.balanceOf(address(this));\n        _token.safeTransfer(owner(), amount);\n        emit TokensUnlocked(address(_token), amount);\n    }\n\n    /* -------------------------- USERS FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function create(uint256 _originalTokenId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n\n        _checkMsgValue(_batchedOrders);\n        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _batchedOrders[i], false);\n            _transferFeeWithRoyalty(fees, tokenSold, nftId);\n        }\n\n        emit NftCreated(nftId, _originalTokenId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _checkMsgValue(_batchedOrders);\n        _processInputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _processOutputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputAndOutputOrders(\n        uint256 _nftId,\n        BatchedInputOrders[] calldata _batchedInputOrders,\n        BatchedOutputOrders[] calldata _batchedOutputOrders\n    ) external payable override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        _checkMsgValue(_batchedInputOrders);\n        _processInputOrders(_nftId, _batchedInputOrders);\n        _processOutputOrders(_nftId, _batchedOutputOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function destroy(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);\n        uint256 tokensLength = tokens.length;\n        require(_orders.length != 0, \"NF: INVALID_ORDERS\");\n        require(tokensLength == _orders.length, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < tokensLength; i++) {\n            uint256 amount = nestedRecords.getAssetHolding(_nftId, tokens[i]);\n            reserve.withdraw(IERC20(tokens[i]), amount);\n\n            _safeSubmitOrder(tokens[i], address(_buyToken), amount, _nftId, _orders[i]);\n            nestedRecords.freeHolding(_nftId, tokens[i]);\n        }\n\n        // Amount calculation to send fees and tokens\n        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;\n        uint256 amountFees = amountBought / 100; // 1% Fee\n        amountBought -= amountFees;\n\n        _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);\n        _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());\n\n        // Burn NFT\n        nestedRecords.removeNFT(_nftId);\n        nestedAsset.burn(_msgSender(), _nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function withdraw(uint256 _nftId, uint256 _tokenIndex)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);\n        require(assetTokensLength > _tokenIndex, \"NF: INVALID_TOKEN_INDEX\");\n        // Use destroy instead if NFT has a single holding\n        require(assetTokensLength > 1, \"NF: UNALLOWED_EMPTY_PORTFOLIO\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        address token = nestedRecords.getAssetTokens(_nftId)[_tokenIndex];\n\n        uint256 amount = nestedRecords.getAssetHolding(_nftId, token);\n        reserve.withdraw(IERC20(token), amount);\n        _safeTransferWithFees(IERC20(token), amount, _msgSender(), _nftId);\n\n        nestedRecords.deleteAsset(_nftId, _tokenIndex);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function updateLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {\n        nestedRecords.updateLockTimestamp(_nftId, _timestamp);\n    }\n\n    /* ------------------------- PRIVATE FUNCTIONS ------------------------- */\n\n    /// @dev Internal logic extraction of processInputOrders()\n    /// @param _nftId The id of the NFT to update\n    /// @param _batchedOrders The order to execute\n    function _processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders) private {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(\n                _nftId,\n                _batchedOrders[i],\n                _batchedOrders[i].fromReserve\n            );\n            _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n        }\n    }\n\n    /// @dev Internal logic extraction of processOutputOrders()\n    /// @param _nftId The id of the NFT to update\n    /// @param _batchedOrders The order to execute\n    function _processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders) private {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(\n                _nftId,\n                _batchedOrders[i],\n                _batchedOrders[i].toReserve\n            );\n            _transferFeeWithRoyalty(feesAmount, _batchedOrders[i].outputToken, _nftId);\n            if (!_batchedOrders[i].toReserve) {\n                _safeTransferAndUnwrap(_batchedOrders[i].outputToken, amountBought - feesAmount, _msgSender());\n            }\n        }\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit orders (where the input is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _batchedOrders The order to process\n    /// @param _fromReserve True if the input tokens are from the reserve (portfolio)\n    /// @return feesAmount The total amount of fees on the input\n    /// @return tokenSold The ERC20 token sold (in case of ETH to WETH)\n    function _submitInOrders(\n        uint256 _nftId,\n        BatchedInputOrders calldata _batchedOrders,\n        bool _fromReserve\n    ) private returns (uint256 feesAmount, IERC20 tokenSold) {\n        uint256 batchLength = _batchedOrders.orders.length;\n        require(batchLength != 0, \"NF: INVALID_ORDERS\");\n        uint256 _inputTokenAmount;\n        (tokenSold, _inputTokenAmount) = _transferInputTokens(\n            _nftId,\n            _batchedOrders.inputToken,\n            _batchedOrders.amount,\n            _fromReserve\n        );\n\n        uint256 amountSpent;\n        for (uint256 i = 0; i < batchLength; i++) {\n            amountSpent += _submitOrder(\n                address(tokenSold),\n                _batchedOrders.orders[i].token,\n                _nftId,\n                _batchedOrders.orders[i],\n                true // always to the reserve\n            );\n        }\n        feesAmount = amountSpent / 100; // 1% Fee\n        require(amountSpent <= _inputTokenAmount - feesAmount, \"NF: OVERSPENT\");\n\n        uint256 underSpentAmount = _inputTokenAmount - feesAmount - amountSpent;\n        if (underSpentAmount != 0) {\n            tokenSold.safeTransfer(_fromReserve ? address(reserve) : _msgSender(), underSpentAmount);\n        }\n\n        // If input is from the reserve, update the records\n        if (_fromReserve) {\n            _decreaseHoldingAmount(_nftId, address(tokenSold), _inputTokenAmount - underSpentAmount);\n        }\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit sell orders (where the output is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _batchedOrders The order to process\n    /// @param _toReserve True if the output is store in the reserve/records (portfolio), false if not.\n    /// @return feesAmount The total amount of fees on the output\n    /// @return amountBought The total amount bought\n    function _submitOutOrders(\n        uint256 _nftId,\n        BatchedOutputOrders calldata _batchedOrders,\n        bool _toReserve\n    ) private returns (uint256 feesAmount, uint256 amountBought) {\n        uint256 batchLength = _batchedOrders.orders.length;\n        require(batchLength != 0, \"NF: INVALID_ORDERS\");\n        require(_batchedOrders.amounts.length == batchLength, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this));\n\n        IERC20 _inputToken;\n        uint256 _inputTokenAmount;\n        for (uint256 i = 0; i < _batchedOrders.orders.length; i++) {\n            (_inputToken, _inputTokenAmount) = _transferInputTokens(\n                _nftId,\n                IERC20(_batchedOrders.orders[i].token),\n                _batchedOrders.amounts[i],\n                true\n            );\n\n            // Submit order and update holding of spent token\n            uint256 amountSpent = _submitOrder(\n                address(_inputToken),\n                address(_batchedOrders.outputToken),\n                _nftId,\n                _batchedOrders.orders[i],\n                false\n            );\n            require(amountSpent <= _inputTokenAmount, \"NF: OVERSPENT\");\n\n            uint256 underSpentAmount = _inputTokenAmount - amountSpent;\n            if (underSpentAmount != 0) {\n                _inputToken.safeTransfer(address(reserve), underSpentAmount);\n            }\n\n            _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount - underSpentAmount);\n        }\n\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this)) - amountBought;\n        feesAmount = amountBought / 100; // 1% Fee\n\n        if (_toReserve) {\n            _transferToReserveAndStore(_batchedOrders.outputToken, amountBought - feesAmount, _nftId);\n        }\n    }\n\n    /// @dev Call the operator to submit the order and add the output\n    /// assets to the reserve (if needed).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    /// @param _toReserve True if the output is store in the reserve/records, false if not.\n    function _submitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _nftId,\n        Order calldata _order,\n        bool _toReserve\n    ) private returns (uint256 amountSpent) {\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n        require(success, \"NF: OPERATOR_CALL_FAILED\");\n\n        if (_toReserve) {\n            _transferToReserveAndStore(IERC20(_outputToken), amounts[0], _nftId);\n        }\n        amountSpent = amounts[1];\n    }\n\n    /// @dev Call the operator to submit the order but dont stop if the call to the operator fail.\n    ///      It will send the input token back to the msg.sender.\n    /// Note : The _toReserve Boolean has been removed (compare to _submitOrder) since it was\n    ///        useless for the only use case (destroy).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _amountToSpend The input amount available (to spend)\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    function _safeSubmitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _amountToSpend,\n        uint256 _nftId,\n        Order calldata _order\n    ) private {\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n        if (success) {\n            require(amounts[1] <= _amountToSpend, \"NestedFactory::_safeSubmitOrder: Overspent\");\n            if (_amountToSpend > amounts[1]) {\n                IERC20(_inputToken).safeTransfer(_msgSender(), _amountToSpend - amounts[1]);\n            }\n        } else {\n            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);\n        }\n    }\n\n    /// @dev Transfer tokens to the reserve, and compute the amount received to store\n    /// in the records. We need to know the amount received in case of deflationary tokens.\n    /// @param _token The token to transfer (IERC20)\n    /// @param _amount The amount to send to the reserve\n    /// @param _nftId The Token ID to store the assets\n    function _transferToReserveAndStore(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _nftId\n    ) private {\n        address reserveAddr = address(reserve);\n        uint256 balanceReserveBefore = _token.balanceOf(reserveAddr);\n\n        // Send output to reserve\n        _token.safeTransfer(reserveAddr, _amount);\n\n        uint256 balanceReserveAfter = _token.balanceOf(reserveAddr);\n\n        nestedRecords.store(_nftId, address(_token), balanceReserveAfter - balanceReserveBefore, reserveAddr);\n    }\n\n    /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve\n    ///      or the user wallet, to the factory.\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token to receive\n    /// @param _inputTokenAmount Amount to transfer\n    /// @param _fromReserve True to transfer from the reserve\n    /// @return Token transfered (in case of ETH)\n    ///         The real amount received after the transfer to the factory\n    function _transferInputTokens(\n        uint256 _nftId,\n        IERC20 _inputToken,\n        uint256 _inputTokenAmount,\n        bool _fromReserve\n    ) private returns (IERC20, uint256) {\n        if (address(_inputToken) == ETH) {\n            require(address(this).balance >= _inputTokenAmount, \"NF: INVALID_AMOUNT_IN\");\n            weth.deposit{ value: _inputTokenAmount }();\n            return (IERC20(address(weth)), _inputTokenAmount);\n        }\n\n        uint256 balanceBefore = _inputToken.balanceOf(address(this));\n        if (_fromReserve) {\n            require(\n                nestedRecords.getAssetHolding(_nftId, address(_inputToken)) >= _inputTokenAmount,\n                \"NF: INSUFFICIENT_AMOUNT_IN\"\n            );\n            // Get input from reserve\n            reserve.withdraw(IERC20(_inputToken), _inputTokenAmount);\n        } else {\n            _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount);\n        }\n        return (_inputToken, _inputToken.balanceOf(address(this)) - balanceBefore);\n    }\n\n    /// @dev Send a fee to the FeeSplitter, royalties will be paid to the owner of the original asset\n    /// @param _amount Amount to send\n    /// @param _token Token to send\n    /// @param _nftId User portfolio ID used to find a potential royalties recipient\n    function _transferFeeWithRoyalty(\n        uint256 _amount,\n        IERC20 _token,\n        uint256 _nftId\n    ) private {\n        address originalOwner = nestedAsset.originalOwner(_nftId);\n        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\n        if (originalOwner != address(0)) {\n            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);\n        } else {\n            feeSplitter.sendFees(_token, _amount);\n        }\n    }\n\n    /// @dev Decrease the amount of a NFT holding\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token holding\n    /// @param _amount The amount to subtract from the actual holding amount\n    function _decreaseHoldingAmount(\n        uint256 _nftId,\n        address _inputToken,\n        uint256 _amount\n    ) private {\n        nestedRecords.updateHoldingAmount(\n            _nftId,\n            _inputToken,\n            nestedRecords.getAssetHolding(_nftId, _inputToken) - _amount\n        );\n    }\n\n    /// @dev Transfer a token amount from the factory to the recipient.\n    ///      The token is unwrapped if WETH.\n    /// @param _token The token to transfer\n    /// @param _amount The amount to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferAndUnwrap(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest\n    ) private {\n        // if buy token is WETH, unwrap it instead of transferring it to the sender\n        if (address(_token) == address(weth)) {\n            IWETH(weth).withdraw(_amount);\n            (bool success, ) = _dest.call{ value: _amount }(\"\");\n            require(success, \"NF: ETH_TRANSFER_ERROR\");\n        } else {\n            _token.safeTransfer(_dest, _amount);\n        }\n    }\n\n    /// @dev Transfer from factory and collect fees\n    /// @param _token The token to transfer\n    /// @param _amount The amount (with fees) to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferWithFees(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest,\n        uint256 _nftId\n    ) private {\n        uint256 feeAmount = _amount / 100; // 1% Fee\n        _transferFeeWithRoyalty(feeAmount, _token, _nftId);\n        _token.safeTransfer(_dest, _amount - feeAmount);\n    }\n\n    /// @dev Verify that msg.value is equal to the amount needed (in the orders)\n    /// @param _batchedOrders The batched input orders\n    function _checkMsgValue(BatchedInputOrders[] calldata _batchedOrders) private {\n        uint256 ethNeeded;\n        for (uint256 i = 0; i < _batchedOrders.length; i++) {\n            if (address(_batchedOrders[i].inputToken) == ETH) {\n                ethNeeded += _batchedOrders[i].amount;\n            }\n        }\n        require(msg.value == ethNeeded, \"NF: WRONG_MSG_VALUE\");\n    }\n}"
    },
    {
      "filename": "contracts/NestedFactory.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.11;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./abstracts/OwnableProxyDelegation.sol\";\nimport \"./abstracts/MixinOperatorResolver.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\nimport \"./interfaces/external/IWETH.sol\";\nimport \"./interfaces/INestedFactory.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./NestedReserve.sol\";\nimport \"./NestedAsset.sol\";\nimport \"./NestedRecords.sol\";\n\n/// @title Creates, updates and destroys NestedAssets (portfolios).\n/// @notice Responsible for the business logic of the protocol and interaction with operators\ncontract NestedFactory is INestedFactory, ReentrancyGuard, OwnableProxyDelegation, MixinOperatorResolver {\n    using SafeERC20 for IERC20;\n\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Supported operators by the factory contract\n    bytes32[] private operators;\n\n    /// @dev Current feeSplitter contract/address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Current reserve contract/address\n    NestedReserve public immutable reserve;\n\n    /// @dev Current nested asset (ERC721) contract/address\n    NestedAsset public immutable nestedAsset;\n\n    /// @dev Wrapped Ether contract/address\n    /// Note: Will be WMATIC, WAVAX, WBNB,... Depending on the chain.\n    IWETH public immutable weth;\n\n    /// @dev Current records contract/address\n    NestedRecords public immutable nestedRecords;\n\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\n\n    constructor(\n        NestedAsset _nestedAsset,\n        NestedRecords _nestedRecords,\n        NestedReserve _reserve,\n        FeeSplitter _feeSplitter,\n        IWETH _weth,\n        address _operatorResolver\n    ) MixinOperatorResolver(_operatorResolver) {\n        require(\n            address(_nestedAsset) != address(0) &&\n                address(_nestedRecords) != address(0) &&\n                address(_reserve) != address(0) &&\n                address(_feeSplitter) != address(0) &&\n                address(_weth) != address(0) &&\n                _operatorResolver != address(0),\n            \"NF: INVALID_ADDRESS\"\n        );\n        nestedAsset = _nestedAsset;\n        nestedRecords = _nestedRecords;\n        reserve = _reserve;\n        feeSplitter = _feeSplitter;\n        weth = _weth;\n    }\n\n    /// @dev Receive function\n    receive() external payable {}\n\n    /* ------------------------------ MODIFIERS ---------------------------- */\n\n    /// @dev Reverts the transaction if the caller is not the token owner\n    /// @param _nftId The NFT Id\n    modifier onlyTokenOwner(uint256 _nftId) {\n        require(nestedAsset.ownerOf(_nftId) == _msgSender(), \"NF: CALLER_NOT_OWNER\");\n        _;\n    }\n\n    /// @dev Reverts the transaction if the nft is locked (hold by design).\n    /// The block.timestamp must be greater than NFT record lock timestamp\n    /// @param _nftId The NFT Id\n    modifier isUnlocked(uint256 _nftId) {\n        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), \"NF: LOCKED_NFT\");\n        _;\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Get the required operators\n    function resolverOperatorsRequired() public view override returns (bytes32[] memory) {\n        return operators;\n    }\n\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function addOperator(bytes32 operator) external override onlyOwner {\n        require(operator != bytes32(\"\"), \"NF: INVALID_OPERATOR_NAME\");\n        bytes32[] memory operatorsCache = operators;\n        for (uint256 i = 0; i < operatorsCache.length; i++) {\n            require(operatorsCache[i] != operator, \"NF: EXISTENT_OPERATOR\");\n        }\n        operators.push(operator);\n        emit OperatorAdded(operator);\n    }\n\n    /// @inheritdoc INestedFactory\n    function removeOperator(bytes32 operator) external override onlyOwner {\n        uint256 operatorsLength = operators.length;\n        for (uint256 i = 0; i < operatorsLength; i++) {\n            if (operators[i] == operator) {\n                operators[i] = operators[operatorsLength - 1];\n                operators.pop();\n                emit OperatorRemoved(operator);\n                return;\n            }\n        }\n        revert(\"NF: NON_EXISTENT_OPERATOR\");\n    }\n\n    /// @inheritdoc INestedFactory\n    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {\n        require(address(_feeSplitter) != address(0), \"NF: INVALID_FEE_SPLITTER_ADDRESS\");\n        feeSplitter = _feeSplitter;\n        emit FeeSplitterUpdated(address(_feeSplitter));\n    }\n\n    /// @inheritdoc INestedFactory\n    function unlockTokens(IERC20 _token) external override onlyOwner {\n        uint256 amount = _token.balanceOf(address(this));\n        _token.safeTransfer(owner(), amount);\n        emit TokensUnlocked(address(_token), amount);\n    }\n\n    /* -------------------------- USERS FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function create(uint256 _originalTokenId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n\n        _checkMsgValue(_batchedOrders);\n        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _batchedOrders[i], false);\n            _transferFeeWithRoyalty(fees, tokenSold, nftId);\n        }\n\n        emit NftCreated(nftId, _originalTokenId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _checkMsgValue(_batchedOrders);\n        _processInputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _processOutputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputAndOutputOrders(\n        uint256 _nftId,\n        BatchedInputOrders[] calldata _batchedInputOrders,\n        BatchedOutputOrders[] calldata _batchedOutputOrders\n    ) external payable override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        _checkMsgValue(_batchedInputOrders);\n        _processInputOrders(_nftId, _batchedInputOrders);\n        _processOutputOrders(_nftId, _batchedOutputOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function destroy(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);\n        uint256 tokensLength = tokens.length;\n        require(_orders.length != 0, \"NF: INVALID_ORDERS\");\n        require(tokensLength == _orders.length, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < tokensLength; i++) {\n            uint256 amount = nestedRecords.getAssetHolding(_nftId, tokens[i]);\n            reserve.withdraw(IERC20(tokens[i]), amount);\n\n            _safeSubmitOrder(tokens[i], address(_buyToken), amount, _nftId, _orders[i]);\n            nestedRecords.freeHolding(_nftId, tokens[i]);\n        }\n\n        // Amount calculation to send fees and tokens\n        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;\n        uint256 amountFees = amountBought / 100; // 1% Fee\n        amountBought -= amountFees;\n\n        _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);\n        _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());\n\n        // Burn NFT\n        nestedRecords.removeNFT(_nftId);\n        nestedAsset.burn(_msgSender(), _nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function withdraw(uint256 _nftId, uint256 _tokenIndex)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);\n        require(assetTokensLength > _tokenIndex, \"NF: INVALID_"
    }
  ]
}