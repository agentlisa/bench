{
  "Title": "M-2: PriceOracle will use the wrong price if the Chainlink registry returns price outside min/max range",
  "Content": "# Issue M-2: PriceOracle will use the wrong price if the Chainlink registry returns price outside min/max range \n\nSource: https://github.com/sherlock-audit/2023-05-ironbank-judging/issues/25 \n\n## Found by \n0x52, 0x8chars, Angry\\_Mustache\\_Man, Bauchibred, BenRai, BugBusters, Jaraxxus, Madalad, R-Nemes, bitsurfer, branch\\_indigo, deadrxsezzz, shaka, thekmj, tsvetanovv\n## Summary\n\nChainlink aggregators have a built in circuit breaker if the price of an asset goes outside of a predetermined price band. The result is that if an asset experiences a huge drop in value (i.e. LUNA crash) the price of the oracle will continue to return the minPrice instead of the actual price of the asset. This would allow user to continue borrowing with the asset but at the wrong price. This is exactly what happened to [Venus on BSC when LUNA imploded](https://rekt.news/venus-blizz-rekt/).\n\n## Vulnerability Detail\n\nNote there is only a check for `price` to be non-negative, and not within an acceptable range.\n\n```solidity\nfunction getPriceFromChainlink(address base, address quote) internal view returns (uint256) {\n    (, int256 price,,,) = registry.latestRoundData(base, quote);\n    require(price > 0, \"invalid price\");\n\n    // Extend the decimals to 1e18.\n    return uint256(price) * 10 ** (18 - uint256(registry.decimals(base, quote)));\n}\n```\nhttps://github.com/sherlock-audit/2023-05-ironbank/blob/main/ib-v2/src/protocol/oracle/PriceOracle.sol#L66-L72\n\nA similar issue is seen [here](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/18).\n\n## Impact\n\nThe wrong price may be returned in the event of a market crash. An adversary will then be able to borrow against the wrong price and incur bad debt to the protocol.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-ironbank/blob/main/ib-v2/src/protocol/oracle/PriceOracle.sol#L66-L72\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nImplement the proper check for each asset. **It must revert in the case of bad price**.\n\n```solidity\nfunction getPriceFromChainlink(address base, address quote) internal view returns (uint256) {\n    (, int256 price,,,) = registry.latestRoundData(base, quote);\n    require(price >= minPrice && price <= maxPrice, \"invalid price\"); // @audit use the proper minPrice and maxPrice for each asset\n\n    // Extend the decimals to 1e18.\n    return uint256(price) * 10 ** (18 - uint256(registry.decimals(base, quote)));\n}\n```\n\n\n\n## Discussion\n\n**ibsunhub**\n\nIt's not practical to setup the min price and max price for individual asset. It's hard to define a reasonable range for each asset and it will make oracle configuration more complex. It's much easier to make human error.\n\nAlso, we had an off-chain backend system to monitor the price from ChainLink. If the price is off, we would intervene to pause the oracle.\n\n**0xffff11**\n\n@ibsunhub If the oracle is paused, wouldn't functions that require of that oracle response also be paused during that time? \n\n**ibsunhub**\n\nYes, functions that need to retrieve the price will revert. They are `borrow`, `redeem`, `transferIBToken`, and `liquidate`.\n\n**0xffff11**\n\nSo, I see what the watson points out. I see that you have an off-chain safeguard for this. Therefore, I would mark the issue as invalid. Though I don't think the solution should be to revert. Liquidations can be key while oracle is paused. I think the fix should be the one from https://github.com/sherlock-audit/2023-05-ironbank-judging/issues/433 (secondary oracle and a try catch)\n\n**0xffff11**\n\nInvalid, Iron has an off-chain safeguard for price deviation that would prevent this\n\n**iamjakethehuman**\n\nEscalate for 10 USDC\nThe off-chain safeguard is never mentioned. Watsons are not supposed to know it exists.\nAlso, the supposed solution imposes an even larger risk as any user would be able to enter tbe market of which the oracle reverts and avoid liquidations. Issue should be marked as valid and another solution should be proposed.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> The off-chain safeguard is never mentioned. Watsons are not supposed to know it exists.\n> Also, the supposed solution imposes an even larger risk as any user would be able to enter tbe market of which the oracle reverts and avoid liquidations. Issue should be marked as valid and another solution should be proposed.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ADK0010**\n\nAlso the contest page doesn't talk about any off-chain safeguards.\n\n![ironbank_escalation](https://github.com/sherlock-audit/2023-05-ironbank-judging/assets/87230982/87ca067f-cbe0-44a2-b15f-956b7e0e3c5c)\n\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nThis is a valid medium \n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [iamjakethehuman](https://github.com/sherlock-audit/2023-05-ironbank-judging/issues/25/#issuecomment-1606059538): accepted\n\n**ib-tycho**\n\nHow do you establish a reasonable minimum and maximum price range for each asset? \nThe incident related to Venus that you mentioned was caused by the inherent risk of the LUNA token itself. Evaluating the risk associated with an asset should always be taken into account when listing it. I disagree with relying solely on manual human input for setting the price range, as it does not address the underlying issue faced by Venus. Therefore, we will not make changes to address this matter.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/84",
  "Code": [
    {
      "filename": "ib-v2/src/protocol/oracle/PriceOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol\";\nimport \"chainlink/contracts/src/v0.8/Denominations.sol\";\nimport \"openzeppelin-contracts/contracts/access/Ownable2Step.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../extensions/interfaces/WstEthInterface.sol\";\nimport \"../../interfaces/PriceOracleInterface.sol\";\n\ncontract PriceOracle is Ownable2Step, PriceOracleInterface {\n    /// @notice The Chainlink feed registry\n    FeedRegistryInterface public immutable registry;\n\n    /// @notice The address of Lido staked ETH\n    address public immutable steth;\n\n    /// @notice The address of Lido wrapped staked ETH\n    address public immutable wsteth;\n\n    struct AggregatorInfo {\n        address base;\n        address quote;\n    }\n\n    /// @notice The mapping from asset to aggregator\n    mapping(address => AggregatorInfo) public aggregators;\n\n    constructor(address registry_, address steth_, address wsteth_) {\n        registry = FeedRegistryInterface(registry_);\n        steth = steth_;\n        wsteth = wsteth_;\n    }\n\n    /**\n     * @notice Get the price of an asset in USD.\n     * @dev The price returned will be normalized by asset's decimals.\n     * @param asset The asset to get the price of\n     * @return The price of the asset in USD\n     */\n    function getPrice(address asset) external view returns (uint256) {\n        if (asset == wsteth) {\n            uint256 stEthPrice = getPriceFromChainlink(steth, Denominations.USD);\n            uint256 stEthPerToken = WstEthInterface(wsteth).stEthPerToken();\n            uint256 wstEthPrice = (stEthPrice * stEthPerToken) / 1e18;\n            return getNormalizedPrice(wstEthPrice, asset);\n        }\n\n        AggregatorInfo memory aggregatorInfo = aggregators[asset];\n        uint256 price = getPriceFromChainlink(aggregatorInfo.base, aggregatorInfo.quote);\n        if (aggregatorInfo.quote == Denominations.ETH) {\n            // Convert the price to USD based if it's ETH based.\n            uint256 ethUsdPrice = getPriceFromChainlink(Denominations.ETH, Denominations.USD);\n            price = (price * ethUsdPrice) / 1e18;\n        }\n        return getNormalizedPrice(price, asset);\n    }\n\n    /**\n     * @notice Get price from Chainlink.\n     * @param base The base asset\n     * @param quote The quote asset\n     * @return The price\n     */\n    function getPriceFromChainlink(address base, address quote) internal view returns (uint256) {\n        (, int256 price,,,) = registry.latestRoundData(base, quote);\n        require(price > 0, \"invalid price\");\n\n        // Extend the decimals to 1e18.\n        return uint256(price) * 10 ** (18 - uint256(registry.decimals(base, quote)));\n    }\n\n    /**\n     * @dev Get the normalized price.\n     * @param price The price\n     * @param asset The asset\n     * @return The normalized price\n     */\n    function getNormalizedPrice(uint256 price, address asset) internal view returns (uint256) {\n        uint8 decimals = IERC20Metadata(asset).decimals();\n        return price * 10 ** (18 - decimals);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    struct Aggregator {\n        address asset;\n        address base;\n        address quote;\n    }\n\n    /**\n     * @notice Set the aggregators.\n     * @param aggrs The aggregators\n     */\n    function _setAggregators(Aggregator[] calldata aggrs) external onlyOwner {\n        uint256 length = aggrs.length;\n        for (uint256 i = 0; i < length;) {\n            if (aggrs[i].base != address(0)) {\n                require(aggrs[i].quote == Denominations.ETH || aggrs[i].quote == Denominations.USD, \"unsupported quote\");\n\n                // Make sure the aggregator works.\n                address aggregator = address(registry.getFeed(aggrs[i].base, aggrs[i].quote));\n                require(registry.isFeedEnabled(aggregator), \"aggregator not enabled\");\n\n                (, int256 price,,,) = registry.latestRoundData(aggrs[i].base, aggrs[i].quote);\n                require(price > 0, \"invalid price\");\n            }\n            aggregators[aggrs[i].asset] = AggregatorInfo({base: aggrs[i].base, quote: aggrs[i].quote});\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "ib-v2/src/protocol/oracle/PriceOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol\";\nimport \"chainlink/contracts/src/v0.8/Denominations.sol\";\nimport \"openzeppelin-contracts/contracts/access/Ownable2Step.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../extensions/interfaces/WstEthInterface.sol\";\nimport \"../../interfaces/PriceOracleInterface.sol\";\n\ncontract PriceOracle is Ownable2Step, PriceOracleInterface {\n    /// @notice The Chainlink feed registry\n    FeedRegistryInterface public immutable registry;\n\n    /// @notice The address of Lido staked ETH\n    address public immutable steth;\n\n    /// @notice The address of Lido wrapped staked ETH\n    address public immutable wsteth;\n\n    struct AggregatorInfo {\n        address base;\n        address quote;\n    }\n\n    /// @notice The mapping from asset to aggregator\n    mapping(address => AggregatorInfo) public aggregators;\n\n    constructor(address registry_, address steth_, address wsteth_) {\n        registry = FeedRegistryInterface(registry_);\n        steth = steth_;\n        wsteth = wsteth_;\n    }\n\n    /**\n     * @notice Get the price of an asset in USD.\n     * @dev The price returned will be normalized by asset's decimals.\n     * @param asset The asset to get the price of\n     * @return The price of the asset in USD\n     */\n    function getPrice(address asset) external view returns (uint256) {\n        if (asset == wsteth) {\n            uint256 stEthPrice = getPriceFromChainlink(steth, Denominations.USD);\n            uint256 stEthPerToken = WstEthInterface(wsteth).stEthPerToken();\n            uint256 wstEthPrice = (stEthPrice * stEthPerToken) / 1e18;\n            return getNormalizedPrice(wstEthPrice, asset);\n        }\n\n        AggregatorInfo memory aggregatorInfo = aggregators[asset];\n        uint256 price = getPriceFromChainlink(aggregatorInfo.base, aggregatorInfo.quote);\n        if (aggregatorInfo.quote == Denominations.ETH) {\n            // Convert the price to USD based if it's ETH based.\n            uint256 ethUsdPrice = getPriceFromChainlink(Denominations.ETH, Denominations.USD);\n            price = (price * ethUsdPrice) / 1e18;\n        }\n        return getNormalizedPrice(price, asset);\n    }\n\n    /**\n     * @notice Get price from Chainlink.\n     * @param base The base asset\n     * @param quote The quote asset\n     * @return The price\n     */\n    function getPriceFromChainlink(address base, address quote) internal view returns (uint256) {\n        (, int256 price,,,) = registry.latestRoundData(base, quote);\n        require(price > 0, \"invalid price\");\n\n        // Extend the decimals to 1e18.\n        return uint256(price) * 10 ** (18 - uint256(registry.decimals(base, quote)));\n    }\n\n    /**\n     * @dev Get the normalized price.\n     * @param price The price\n     * @param asset The asset\n     * @return The normalized price\n     */\n    function getNormalizedPrice(uint256 price, address asset) internal view returns (uint256) {\n        uint8 decimals = IERC20Metadata(asset).decimals();\n        return price * 10 ** (18 - decimals);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    struct Aggregator {\n        address asset;\n        address base;\n        address quote;\n    }\n\n    /**\n     * @notice Set the aggregators.\n     * @param aggrs The aggregators\n     */\n    function _setAggregators(Aggregator[] calldata aggrs) external onlyOwner {\n        uint256 length = aggrs.length;\n        for (uint256 i = 0; i < length;) {\n            if (aggrs[i].base != address(0)) {\n                require(aggrs[i].quote == Denominations.ETH || aggrs[i].quote == Denominations.USD, \"unsupported quote\");\n\n                // Make sure the aggregator works.\n                address aggregator = address(registry.getFeed(aggrs[i].base, aggrs[i].quote));\n                require(registry.isFeedEnabled(aggregator), \"aggregator not enabled\");\n\n                (, int256 price,,,) = registry.latestRoundData(aggrs[i].base, aggrs[i].quote);\n                require(price > 0, \"invalid price\");\n            }\n            aggregators[aggrs[i].asset] = AggregatorInfo({base: aggrs[i].base, quote: aggrs[i].quote});\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n}"
    }
  ]
}