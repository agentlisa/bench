{
  "Title": "M-10: Protocol is completely incompatible with USDT due to lack of 0 approval",
  "Content": "# Issue M-10: Protocol is completely incompatible with USDT due to lack of 0 approval \n\nSource: https://github.com/sherlock-audit/2023-06-dodo-judging/issues/203 \n\n## Found by \n0x4db5362c, 0x52, MohammedRizwan, PRAISE, Sulpiride, Vagner, jprod15, kutugu, shealtielanz, shogoki, tsvetanovv\n## Summary\n\nUSDT will revert if the current allowance is greater than 0 and an non-zero approval is made. There are multiple instances throughout the contracts where this causes issues. In some places this can create scenarios where it becomes impossible to liquidate and/or borrow it.\n\n## Vulnerability Detail\n\nSee summary.\n\n## Impact\n\nUSDT may become impossible to liquidate or borrow \n\n## Code Snippet\n\n[D3Funding.sol#L20-L23](https://github.com/sherlock-audit/2023-06-dodo/blob/a8d30e611acc9762029f8756d6a5b81825faf348/new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Funding.sol#L20-L23)\n\n[D3Funding.sol#L50-L53](https://github.com/sherlock-audit/2023-06-dodo/blob/a8d30e611acc9762029f8756d6a5b81825faf348/new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Funding.sol#L50-L53)\n\n[D3Funding.sol#L64-L67](https://github.com/sherlock-audit/2023-06-dodo/blob/a8d30e611acc9762029f8756d6a5b81825faf348/new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Funding.sol#L64-L67)\n\n[D3MMLiquidationRouter.sol#L24](https://github.com/sherlock-audit/2023-06-dodo/blob/a8d30e611acc9762029f8756d6a5b81825faf348/new-dodo-v3/contracts/DODOV3MM/periphery/D3MMLiquidationRouter.sol#L24)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUtilize the OZ safeERC20 library and safeApprove\n\n\n\n## Discussion\n\n**osmanozdemir1**\n\nEscalate for 10 USDC\n\nI agree with \"approve to 0 first\" is one of the most common bugs in the space but I think it is invalid for this protocol.\n\nApproval calls to token contracts are made from pool contracts in this protocol, like [borrow()](https://github.com/sherlock-audit/2023-06-dodo/blob/a8d30e611acc9762029f8756d6a5b81825faf348/new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Funding.sol#L20-L23) and [updateReserveByVault()](https://github.com/sherlock-audit/2023-06-dodo/blob/a8d30e611acc9762029f8756d6a5b81825faf348/new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Funding.sol#L50-L53) functions.\n\nBefore calling the approve function, the allowance of the vault is checked and the call is made if `allowance < type(uint256).max`. Then the approve is called and the allowance is set to type(uint256).max.\n\n- If a pool tries to borrow for the first time, allowance is set to `type(uint256).max`.\n- Allowance will not decrease after that ever even if the vault uses that allowance. The reason for that is according to ERC20, allowances will not decrease after spending if the allowance was `type(uint256).max`.\n- If the pool tries to borrow again, there won't be a problem as allowance is already `type(uint256).max`, and [this call](https://github.com/sherlock-audit/2023-06-dodo/blob/a8d30e611acc9762029f8756d6a5b81825faf348/new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Funding.sol#L21-L22) will not be made.\n\nI believe the issue is invalid for this protocol as the approval is not expected to be used by EOAs. A pool can not directly approve to a non-zero value because it doesn't have a function to make that call. That's why I don't see a scenario where the allowance is not zero, and not `type(uint256).max` at the same time. It has to be either 0 or `type(uint256).max`, and this won't cause function to revert.\n\n**sherlock-admin2**\n\n > Escalate for 10 USDC\n> \n> I agree with \"approve to 0 first\" is one of the most common bugs in the space but I think it is invalid for this protocol.\n> \n> Approval calls to token contracts are made from pool contracts in this protocol, like [borrow()](https://github.com/sherlock-audit/2023-06-dodo/blob/a8d30e611acc9762029f8756d6a5b81825faf348/new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Funding.sol#L20-L23) and [updateReserveByVault()](https://github.com/sherlock-audit/2023-06-dodo/blob/a8d30e611acc9762029f8756d6a5b81825faf348/new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Funding.sol#L50-L53) functions.\n> \n> Before calling the approve function, the allowance of the vault is checked and the call is made if `allowance < type(uint256).max`. Then the approve is called and the allowance is set to type(uint256).max.\n> \n> - If a pool tries to borrow for the first time, allowance is set to `type(uint256).max`.\n> - Allowance will not decrease after that ever even if the vault uses that allowance. The reason for that is according to ERC20, allowances will not decrease after spending if the allowance was `type(uint256).max`.\n> - If the pool tries to borrow again, there won't be a problem as allowance is already `type(uint256).max`, and [this call](https://github.com/sherlock-audit/2023-06-dodo/blob/a8d30e611acc9762029f8756d6a5b81825faf348/new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Funding.sol#L21-L22) will not be made.\n> \n> I believe the issue is invalid for this protocol as the approval is not expected to be used by EOAs. A pool can not directly approve to a non-zero value because it doesn't have a function to make that call. That's why I don't see a scenario where the allowance is not zero, and not `type(uint256).max` at the same time. It has to be either 0 or `type(uint256).max`, and this won't cause function to revert.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**marie-fourier**\n\n@osmanozdemir1 isn't the allowance check done wrong in the [line 50](https://github.com/sherlock-audit/2023-06-dodo/blob/a8d30e611acc9762029f8756d6a5b81825faf348/new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Funding.sol#L50)? \nIt should be `allowance(address(this), state._D3_VAULT_)`, otherwise it will call approve on each call of `updateReserveByVault`, so I think the issue is valid.\n\n**osmanozdemir1**\n\n> @osmanozdemir1 isn't the allowance check done wrong in the [line 50](https://github.com/sherlock-audit/2023-06-dodo/blob/a8d30e611acc9762029f8756d6a5b81825faf348/new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Funding.sol#L50)? It should be `allowance(address(this), state._D3_VAULT_)`, otherwise it will call approve on each call of `updateReserveByVault`, so I think the issue is valid.\n\nOh, I see. You're definitely right about that, and this makes it problematic due to the wrong implementation in line 50. Root cause is wrong allowance check and I totally missed it. Thanks for the comment.\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [osmanozdemir1](https://github.com/sherlock-audit/2023-06-dodo-judging/issues/203/#issuecomment-1651444299): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/89",
  "Code": [
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Funding.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../lib/DecimalMath.sol\";\nimport \"../intf/ID3Vault.sol\";\nimport \"../../intf/ID3Oracle.sol\";\nimport \"./D3Storage.sol\";\n\n/// @notice pool funding model, manage pool borrow/repay and maker deposi/withdraw\ncontract D3Funding is D3Storage {\n    using SafeERC20 for IERC20;\n\n    /// @notice borrow tokens from vault\n    function borrow(address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        // call vault's poolBorrow function\n        ID3Vault(state._D3_VAULT_).poolBorrow(token, amount);\n        // approve max, ensure vault could force liquidate\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n        require(checkBorrowSafe(), Errors.NOT_BORROW_SAFE);\n    }\n\n    /// @notice repay vault with certain amount of borrowed assets \n    function repay(address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        // call vault's poolRepay\n        ID3Vault(state._D3_VAULT_).poolRepay(token, amount);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n    }\n\n    /// @notice repay vault all debt of this token\n    function repayAll(address token) external onlyOwner nonReentrant poolOngoing {\n        ID3Vault(state._D3_VAULT_).poolRepayAll(token);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n\n    }\n\n    /// @notice used through liquidation\n    function updateReserveByVault(address token) external onlyVault {\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n        _updateReserve(token);\n    }\n\n    /// @notice maker deposit, anyone could deposit but only maker could withdraw\n    function makerDeposit(address token) external nonReentrant poolOngoing {\n        require(ID3Oracle(state._ORACLE_).isFeasible(token), Errors.TOKEN_NOT_FEASIBLE);\n        // transfer in from proxies\n        uint256 tokenInAmount = IERC20(token).balanceOf(address(this)) - state.balances[token];\n        _updateReserve(token);\n        // if token in tokenlist, approve max, ensure vault could force liquidate\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(_checkTokenInTokenlist(token) && allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n        require(checkSafe(), Errors.NOT_SAFE);\n\n        emit MakerDeposit(token, tokenInAmount);\n    }\n\n    function makerWithdraw(address to, address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        IERC20(token).safeTransfer(to, amount);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n        require(checkBorrowSafe(), Errors.NOT_BORROW_SAFE);\n\n        emit MakerWithdraw(to, token, amount);\n    }\n\n    // below IM: not safe!\n    function checkSafe() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkSafe(address(this));\n    }\n\n    // check when borrowing asset\n    function checkBorrowSafe() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkBorrowSafe(address(this));\n    }\n\n    // blow MM: dangerous!\n    function checkCanBeLiquidated() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkCanBeLiquidated(address(this));\n    }\n\n    function startLiquidation() external onlyVault {\n        isInLiquidation = true;\n    }\n\n    function finishLiquidation() external onlyVault {\n        isInLiquidation = false;\n    }\n\n    function _updateReserve(address token) internal {\n        state.balances[token] = IERC20(token).balanceOf(address(this));\n    }\n\n    function _checkTokenInTokenlist(address token) internal view returns(bool){\n        return ID3Vault(state._D3_VAULT_).tokens(token); \n    }\n}"
    },
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Funding.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../lib/DecimalMath.sol\";\nimport \"../intf/ID3Vault.sol\";\nimport \"../../intf/ID3Oracle.sol\";\nimport \"./D3Storage.sol\";\n\n/// @notice pool funding model, manage pool borrow/repay and maker deposi/withdraw\ncontract D3Funding is D3Storage {\n    using SafeERC20 for IERC20;\n\n    /// @notice borrow tokens from vault\n    function borrow(address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        // call vault's poolBorrow function\n        ID3Vault(state._D3_VAULT_).poolBorrow(token, amount);\n        // approve max, ensure vault could force liquidate\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n        require(checkBorrowSafe(), Errors.NOT_BORROW_SAFE);\n    }\n\n    /// @notice repay vault with certain amount of borrowed assets \n    function repay(address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        // call vault's poolRepay\n        ID3Vault(state._D3_VAULT_).poolRepay(token, amount);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n    }\n\n    /// @notice repay vault all debt of this token\n    function repayAll(address token) external onlyOwner nonReentrant poolOngoing {\n        ID3Vault(state._D3_VAULT_).poolRepayAll(token);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n\n    }\n\n    /// @notice used through liquidation\n    function updateReserveByVault(address token) external onlyVault {\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n        _updateReserve(token);\n    }\n\n    /// @notice maker deposit, anyone could deposit but only maker could withdraw\n    function makerDeposit(address token) external nonReentrant poolOngoing {\n        require(ID3Oracle(state._ORACLE_).isFeasible(token), Errors.TOKEN_NOT_FEASIBLE);\n        // transfer in from proxies\n        uint256 tokenInAmount = IERC20(token).balanceOf(address(this)) - state.balances[token];\n        _updateReserve(token);\n        // if token in tokenlist, approve max, ensure vault could force liquidate\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(_checkTokenInTokenlist(token) && allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n        require(checkSafe(), Errors.NOT_SAFE);\n\n        emit MakerDeposit(token, tokenInAmount);\n    }\n\n    function makerWithdraw(address to, address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        IERC20(token).safeTransfer(to, amount);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n        require(checkBorrowSafe(), Errors.NOT_BORROW_SAFE);\n\n        emit MakerWithdraw(to, token, amount);\n    }\n\n    // below IM: not safe!\n    function checkSafe() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkSafe(address(this));\n    }\n\n    // check when borrowing asset\n    function checkBorrowSafe() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkBorrowSafe(address(this));\n    }\n\n    // blow MM: dangerous!\n    function checkCanBeLiquidated() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkCanBeLiquidated(address(this));\n    }\n\n    function startLiquidation() external onlyVault {\n        isInLiquidation = true;\n    }\n\n    function finishLiquidation() external onlyVault {\n        isInLiquidation = false;\n    }\n\n    function _updateReserve(address token) internal {\n        state.balances[token] = IERC20(token).balanceOf(address(this));\n    }\n\n    function _checkTokenInTokenlist(address token) internal view returns(bool){\n        return ID3Vault(state._D3_VAULT_).tokens(token); \n    }\n}"
    },
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Funding.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../lib/DecimalMath.sol\";\nimport \"../intf/ID3Vault.sol\";\nimport \"../../intf/ID3Oracle.sol\";\nimport \"./D3Storage.sol\";\n\n/// @notice pool funding model, manage pool borrow/repay and maker deposi/withdraw\ncontract D3Funding is D3Storage {\n    using SafeERC20 for IERC20;\n\n    /// @notice borrow tokens from vault\n    function borrow(address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        // call vault's poolBorrow function\n        ID3Vault(state._D3_VAULT_).poolBorrow(token, amount);\n        // approve max, ensure vault could force liquidate\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n        require(checkBorrowSafe(), Errors.NOT_BORROW_SAFE);\n    }\n\n    /// @notice repay vault with certain amount of borrowed assets \n    function repay(address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        // call vault's poolRepay\n        ID3Vault(state._D3_VAULT_).poolRepay(token, amount);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n    }\n\n    /// @notice repay vault all debt of this token\n    function repayAll(address token) external onlyOwner nonReentrant poolOngoing {\n        ID3Vault(state._D3_VAULT_).poolRepayAll(token);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n\n    }\n\n    /// @notice used through liquidation\n    function updateReserveByVault(address token) external onlyVault {\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n        _updateReserve(token);\n    }\n\n    /// @notice maker deposit, anyone could deposit but only maker could withdraw\n    function makerDeposit(address token) external nonReentrant poolOngoing {\n        require(ID3Oracle(state._ORACLE_).isFeasible(token), Errors.TOKEN_NOT_FEASIBLE);\n        // transfer in from proxies\n        uint256 tokenInAmount = IERC20(token).balanceOf(address(this)) - state.balances[token];\n        _updateReserve(token);\n        // if token in tokenlist, approve max, ensure vault could force liquidate\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(_checkTokenInTokenlist(token) && allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n        require(checkSafe(), Errors.NOT_SAFE);\n\n        emit MakerDeposit(token, tokenInAmount);\n    }\n\n    function makerWithdraw(address to, address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        IERC20(token).safeTransfer(to, amount);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n        require(checkBorrowSafe(), Errors.NOT_BORROW_SAFE);\n\n        emit MakerWithdraw(to, token, amount);\n    }\n\n    // below IM: not safe!\n    function checkSafe() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkSafe(address(this));\n    }\n\n    // check when borrowing asset\n    function checkBorrowSafe() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkBorrowSafe(address(this));\n    }\n\n    // blow MM: dangerous!\n    function checkCanBeLiquidated() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkCanBeLiquidated(address(this));\n    }\n\n    function startLiquidation() external onlyVault {\n        isInLiquidation = true;\n    }\n\n    function finishLiquidation() external onlyVault {\n        isInLiquidation = false;\n    }\n\n    function _updateReserve(address token) internal {\n        state.balances[token] = IERC20(token).balanceOf(address(this));\n    }\n\n    function _checkTokenInTokenlist(address token) internal view returns(bool){\n        return ID3Vault(state._D3_VAULT_).tokens(token); \n    }\n}"
    },
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/periphery/D3MMLiquidationRouter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract D3MMLiquidationRouter {\n    address public immutable _DODO_APPROVE_;\n\n    constructor(address dodoApprove) {\n        _DODO_APPROVE_ = dodoApprove;\n    }\n\n    struct LiquidationOrder {\n        address fromToken;\n        address toToken;\n        uint256 fromAmount;\n    }\n\n    /// @notice D3MM call this function to do liquidation swap\n    /// @param order The liquidation order\n    /// @param router The router contract address\n    /// @param routeData The data will be parsed to router call\n    function D3Callee(LiquidationOrder calldata order, address router, bytes calldata routeData) external {\n        IERC20(order.fromToken).approve(_DODO_APPROVE_, type(uint256).max);\n        (bool success, bytes memory data) = router.call(routeData);\n        if (!success) {\n            assembly {\n                revert(add(data, 32), mload(data))\n            }\n        }\n        IERC20(order.toToken).transfer(msg.sender, IERC20(order.toToken).balanceOf(address(this)));\n    }\n}"
    },
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Funding.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../lib/DecimalMath.sol\";\nimport \"../intf/ID3Vault.sol\";\nimport \"../../intf/ID3Oracle.sol\";\nimport \"./D3Storage.sol\";\n\n/// @notice pool funding model, manage pool borrow/repay and maker deposi/withdraw\ncontract D3Funding is D3Storage {\n    using SafeERC20 for IERC20;\n\n    /// @notice borrow tokens from vault\n    function borrow(address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        // call vault's poolBorrow function\n        ID3Vault(state._D3_VAULT_).poolBorrow(token, amount);\n        // approve max, ensure vault could force liquidate\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n        require(checkBorrowSafe(), Errors.NOT_BORROW_SAFE);\n    }\n\n    /// @notice repay vault with certain amount of borrowed assets \n    function repay(address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        // call vault's poolRepay\n        ID3Vault(state._D3_VAULT_).poolRepay(token, amount);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n    }\n\n    /// @notice repay vault all debt of this token\n    function repayAll(address token) external onlyOwner nonReentrant poolOngoing {\n        ID3Vault(state._D3_VAULT_).poolRepayAll(token);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n\n    }\n\n    /// @notice used through liquidation\n    function updateReserveByVault(address token) external onlyVault {\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n        _updateReserve(token);\n    }\n\n    /// @notice maker deposit, anyone could deposit but only maker could withdraw\n    function makerDeposit(address token) external nonReentrant poolOngoing {\n        require(ID3Oracle(state._ORACLE_).isFeasible(token), Errors.TOKEN_NOT_FEASIBLE);\n        // transfer in from proxies\n        uint256 tokenInAmount = IERC20(token).balanceOf(address(this)) - state.balances[token];\n        _updateReserve(token);\n        // if token in tokenlist, approve max, ensure vault could force liquidate\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(_checkTokenInTokenlist(token) && allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n        require(checkSafe(), Errors.NOT_SAFE);\n\n        emit MakerDeposit(token, tokenInAmount);\n    }\n\n    function makerWithdraw(address to, address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        IERC20(token).safeTransfer(to, amount);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n        require(checkBorrowSafe(), Errors.NOT_BORROW_SAFE);\n\n        emit MakerWithdraw(to, token, amount);\n    }\n\n    // below IM: not safe!\n    function checkSafe() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkSafe(address(this));\n    }\n\n    // check when borrowing asset\n    function checkBorrowSafe() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkBorrowSafe(address(this));\n    }\n\n    // blow MM: dangerous!\n    function checkCanBeLiquidated() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkCanBeLiquidated(address(this));\n    }\n\n    function startLiquidation() external onlyVault {\n        isInLiquidation = true;\n    }\n\n    function finishLiquidation() external onlyVault {\n        isInLiquidation = false;\n    }\n\n    function _updateReserve(address token) internal {\n        state.balances[token] = IERC20(token).balanceOf(address(this));\n    }\n\n    function _checkTokenInTokenlist(address token) internal view returns(bool){\n        return ID3Vault(state._D3_VAULT_).tokens(token); \n    }\n}"
    },
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Funding.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../lib/DecimalMath.sol\";\nimport \"../intf/ID3Vault.sol\";\nimport \"../../intf/ID3Oracle.sol\";\nimport \"./D3Storage.sol\";\n\n/// @notice pool funding model, manage pool borrow/repay and maker deposi/withdraw\ncontract D3Funding is D3Storage {\n    using SafeERC20 for IERC20;\n\n    /// @notice borrow tokens from vault\n    function borrow(address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        // call vault's poolBorrow function\n        ID3Vault(state._D3_VAULT_).poolBorrow(token, amount);\n        // approve max, ensure vault could force liquidate\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n        require(checkBorrowSafe(), Errors.NOT_BORROW_SAFE);\n    }\n\n    /// @notice repay vault with certain amount of borrowed assets \n    function repay(address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        // call vault's poolRepay\n        ID3Vault(state._D3_VAULT_).poolRepay(token, amount);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n    }\n\n    /// @notice repay vault all debt of this token\n    function repayAll(address token) external onlyOwner nonReentrant poolOngoing {\n        ID3Vault(state._D3_VAULT_).poolRepayAll(token);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n\n    }\n\n    /// @notice used through liquidation\n    function updateReserveByVault(address token) external onlyVault {\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n        _updateReserve(token);\n    }\n\n    /// @notice maker deposit, anyone could deposit but only maker could withdraw\n    function makerDeposit(address token) external nonReentrant poolOngoing {\n        require(ID3Oracle(state._ORACLE_).isFeasible(token), Errors.TOKEN_NOT_FEASIBLE);\n        // transfer in from proxies\n        uint256 tokenInAmount = IERC20(token).balanceOf(address(this)) - state.balances[token];\n        _updateReserve(token);\n        // if token in tokenlist, approve max, ensure vault could force liquidate\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(_checkTokenInTokenlist(token) && allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n        require(checkSafe(), Errors.NOT_SAFE);\n\n        emit MakerDeposit(token, tokenInAmount);\n    }\n\n    function makerWithdraw(address to, address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        IERC20(token).safeTransfer(to, amount);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n        require(checkBorrowSafe(), Errors.NOT_BORROW_SAFE);\n\n        emit MakerWithdraw(to, token, amount);\n    }\n\n    // below IM: not safe!\n    function checkSafe() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkSafe(address(this));\n    }\n\n    // check when borrowing asset\n    function checkBorrowSafe() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkBorrowSafe(address(this));\n    }\n\n    // blow MM: dangerous!\n    function checkCanBeLiquidated() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkCanBeLiquidated(address(this));\n    }\n\n    function startLiquidation() external onlyVault {\n        isInLiquidation = true;\n    }\n\n    function finishLiquidation() external onlyVault {\n        isInLiquidation = false;\n    }\n\n    function _updateReserve(address token) internal {\n        state.balances[token] = IERC20(token).balanceOf(address(this));\n    }\n\n    function _checkTokenInTokenlist(address token) internal view returns(bool){\n        return ID3Vault(state._D3_VAULT_).tokens(token); \n    }\n}"
    },
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Funding.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../lib/DecimalMath.sol\";\nimport \"../intf/ID3Vault.sol\";\nimport \"../../intf/ID3Oracle.sol\";\nimport \"./D3Storage.sol\";\n\n/// @notice pool funding model, manage pool borrow/repay and maker deposi/withdraw\ncontract D3Funding is D3Storage {\n    using SafeERC20 for IERC20;\n\n    /// @notice borrow tokens from vault\n    function borrow(address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        // call vault's poolBorrow function\n        ID3Vault(state._D3_VAULT_).poolBorrow(token, amount);\n        // approve max, ensure vault could force liquidate\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n        require(checkBorrowSafe(), Errors.NOT_BORROW_SAFE);\n    }\n\n    /// @notice repay vault with certain amount of borrowed assets \n    function repay(address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        // call vault's poolRepay\n        ID3Vault(state._D3_VAULT_).poolRepay(token, amount);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n    }\n\n    /// @notice repay vault all debt of this token\n    function repayAll(address token) external onlyOwner nonReentrant poolOngoing {\n        ID3Vault(state._D3_VAULT_).poolRepayAll(token);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n\n    }\n\n    /// @notice used through liquidation\n    function updateReserveByVault(address token) external onlyVault {\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n        _updateReserve(token);\n    }\n\n    /// @notice maker deposit, anyone could deposit but only maker could withdraw\n    function makerDeposit(address token) external nonReentrant poolOngoing {\n        require(ID3Oracle(state._ORACLE_).isFeasible(token), Errors.TOKEN_NOT_FEASIBLE);\n        // transfer in from proxies\n        uint256 tokenInAmount = IERC20(token).balanceOf(address(this)) - state.balances[token];\n        _updateReserve(token);\n        // if token in tokenlist, approve max, ensure vault could force liquidate\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(_checkTokenInTokenlist(token) && allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n        require(checkSafe(), Errors.NOT_SAFE);\n\n        emit MakerDeposit(token, tokenInAmount);\n    }\n\n    function makerWithdraw(address to, address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        IERC20(token).safeTransfer(to, amount);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n        require(checkBorrowSafe(), Errors.NOT_BORROW_SAFE);\n\n        emit MakerWithdraw(to, token, amount);\n    }\n\n    // below IM: not safe!\n    function checkSafe() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkSafe(address(this));\n    }\n\n    // check when borrowing asset\n    function checkBorrowSafe() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkBorrowSafe(address(this));\n    }\n\n    // blow MM: dangerous!\n    function checkCanBeLiquidated() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkCanBeLiquidated(address(this));\n    }\n\n    function startLiquidation() external onlyVault {\n        isInLiquidation = true;\n    }\n\n    function finishLiquidation() external onlyVault {\n        isInLiquidation = false;\n    }\n\n    function _updateReserve(address token) internal {\n        state.balances[token] = IERC20(token).balanceOf(address(this));\n    }\n\n    function _checkTokenInTokenlist(address token) internal view returns(bool){\n        return ID3Vault(state._D3_VAULT_).tokens(token); \n    }\n}"
    },
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Funding.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../lib/DecimalMath.sol\";\nimport \"../intf/ID3Vault.sol\";\nimport \"../../intf/ID3Oracle.sol\";\nimport \"./D3Storage.sol\";\n\n/// @notice pool funding model, manage pool borrow/repay and maker deposi/withdraw\ncontract D3Funding is D3Storage {\n    using SafeERC20 for IERC20;\n\n    /// @notice borrow tokens from vault\n    function borrow(address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        // call vault's poolBorrow function\n        ID3Vault(state._D3_VAULT_).poolBorrow(token, amount);\n        // approve max, ensure vault could force liquidate\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n        require(checkBorrowSafe(), Errors.NOT_BORROW_SAFE);\n    }\n\n    /// @notice repay vault with certain amount of borrowed assets \n    function repay(address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        // call vault's poolRepay\n        ID3Vault(state._D3_VAULT_).poolRepay(token, amount);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n    }\n\n    /// @notice repay vault all debt of this token\n    function repayAll(address token) external onlyOwner nonReentrant poolOngoing {\n        ID3Vault(state._D3_VAULT_).poolRepayAll(token);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n\n    }\n\n    /// @notice used through liquidation\n    function updateReserveByVault(address token) external onlyVault {\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n        _updateReserve(token);\n    }\n\n    /// @notice maker deposit, anyone could deposit but only maker could withdraw\n    function makerDeposit(address token) external nonReentrant poolOngoing {\n        require(ID3Oracle(state._ORACLE_).isFeasible(token), Errors.TOKEN_NOT_FEASIBLE);\n        // transfer in from proxies\n        uint256 tokenInAmount = IERC20(token).balanceOf(address(this)) - state.balances[token];\n        _updateReserve(token);\n        // if token in tokenlist, approve max, ensure vault could force liquidate\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(_checkTokenInTokenlist(token) && allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n        require(checkSafe(), Errors.NOT_SAFE);\n\n        emit MakerDeposit(token, tokenInAmount);\n    }\n\n    function makerWithdraw(address to, address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        IERC20(token).safeTransfer(to, amount);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n        require(checkBorrowSafe(), Errors.NOT_BORROW_SAFE);\n\n        emit MakerWithdraw(to, token, amount);\n    }\n\n    // below IM: not safe!\n    function checkSafe() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkSafe(address(this));\n    }\n\n    // check when borrowing asset\n    function checkBorrowSafe() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkBorrowSafe(address(this));\n    }\n\n    // blow MM: dangerous!\n    function checkCanBeLiquidated() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkCanBeLiquidated(address(this));\n    }\n\n    function startLiquidation() external onlyVault {\n        isInLiquidation = true;\n    }\n\n    function finishLiquidation() external onlyVault {\n        isInLiquidation = false;\n    }\n\n    function _updateReserve(address token) internal {\n        state.balances[token] = IERC20(token).balanceOf(address(this));\n    }\n\n    function _checkTokenInTokenlist(address token) internal view returns(bool){\n        return ID3Vault(state._D3_VAULT_).tokens(token); \n    }\n}"
    },
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Funding.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../lib/DecimalMath.sol\";\nimport \"../intf/ID3Vault.sol\";\nimport \"../../intf/ID3Oracle.sol\";\nimport \"./D3Storage.sol\";\n\n/// @notice pool funding model, manage pool borrow/repay and maker deposi/withdraw\ncontract D3Funding is D3Storage {\n    using SafeERC20 for IERC20;\n\n    /// @notice borrow tokens from vault\n    function borrow(address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        // call vault's poolBorrow function\n        ID3Vault(state._D3_VAULT_).poolBorrow(token, amount);\n        // approve max, ensure vault could force liquidate\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(allowance < type(uint256).max) {"
    }
  ]
}