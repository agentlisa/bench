{
  "Title": "[G-04] Don't cache calls/variables if using them once",
  "Content": "\n### No need to cache `lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER)`\n\nhttps://github.com/code-423n4/2023-11-kelp/blob/f751d7594051c0766c7ecd1e68daeb0661e43ee3/src/NodeDelegator.sol#L38-L46\n```solidity\nFile: /src/NodeDelegator.sol\n38:    function maxApproveToEigenStrategyManager(address asset)\n39:        external\n40:        override\n41:        onlySupportedAsset(asset)\n42:        onlyLRTManager\n43:    {\n44:        address eigenlayerStrategyManagerAddress = lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER);\n45:        IERC20(asset).approve(eigenlayerStrategyManagerAddress, type(uint256).max);\n46:    }\n```\n\nThe variable `eigenlayerStrategyManagerAddress` is only used once, therefore no need to cache the call.\n\n```diff\ndiff --git a/src/NodeDelegator.sol b/src/NodeDelegator.sol\nindex bba20ca..989218c 100644\n--- a/src/NodeDelegator.sol\n+++ b/src/NodeDelegator.sol\n@@ -41,8 +41,7 @@ contract NodeDelegator is INodeDelegator, LRTConfigRoleChecker, PausableUpgradea\n         onlySupportedAsset(asset)\n         onlyLRTManager\n     {\n-        address eigenlayerStrategyManagerAddress = lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER);\n-        IERC20(asset).approve(eigenlayerStrategyManagerAddress, type(uint256).max);\n+        IERC20(asset).approve(lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY\n```\n\n### No need to cache `lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER)`\n\nhttps://github.com/code-423n4/2023-11-kelp/blob/f751d7594051c0766c7ecd1e68daeb0661e43ee3/src/NodeDelegator.sol#L51-L68\n\n```solidity\nFile: /src/NodeDelegator.sol\n51:    function depositAssetIntoStrategy(address asset)\n\n58:    {\n59:        address strategy = lrtConfig.assetStrategy(asset);\n60:        IERC20 token = IERC20(asset);\n61:        address eigenlayerStrategyManagerAddress = lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER);\n\n63:        uint256 balance = token.balanceOf(address(this));\n\n65:        emit AssetDepositIntoStrategy(asset, strategy, balance);\n\n67:IEigenStrategyManager(eigenlayerStrategyManagerAddress).depositIntoStrategy(IStrategy(strategy), token, balance);\n68:    }\n```\n\n```diff\n     /// @notice Deposits an asset lying in this NDC into its strategy\n@@ -58,13 +58,12 @@ contract NodeDelegator is INodeDelegator, LRTConfigRoleChecker, PausableUpgradea\n     {\n         address strategy = lrtConfig.assetStrategy(asset);\n         IERC20 token = IERC20(asset);\n-        address eigenlayerStrategyManagerAddress = lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER);\n\n         uint256 balance = token.balanceOf(address(this));\n\n         emit AssetDepositIntoStrategy(asset, strategy, balance);\n\n-        IEigenStrategyManager(eigenlayerStrategyManagerAddress).depositIntoStrategy(IStrategy(strategy), token, balance);\n+        IEigenStrategyManager(lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER)).depositIntoStrategy(IStrategy(strategy), token, balance);\n     }\n\n```\n\n### No need to cache `lrtConfig.getContract(LRTConstants.LRT_DEPOSIT_POOL)`\n\nhttps://github.com/code-423n4/2023-11-kelp/blob/f751d7594051c0766c7ecd1e68daeb0661e43ee3/src/NodeDelegator.sol#L74-L89\n\n\n```solidity\nFile: /src/NodeDelegator.sol\n74:    function transferBackToLRTDepositPool(\n\n84:        address lrtDepositPool = lrtConfig.getContract(LRTConstants.LRT_DEPOSIT_POOL);\n\n86:        if (!IERC20(asset).transfer(lrtDepositPool, amount)) {\n87:            revert TokenTransferFailed();\n88:        }\n89:    }\n```\n\n```diff\n     /// @notice Deposits an asset lying in this NDC into its strategy\n@@ -81,9 +81,8 @@ contract NodeDelegator is INodeDelegator, LRTConfigRoleChecker, PausableUpgradea\n         onlySupportedAsset(asset)\n         onlyLRTManager\n     {\n-        address lrtDepositPool = lrtConfig.getContract(LRTConstants.LRT_DEPOSIT_POOL);\n\n-        if (!IERC20(asset).transfer(lrtDepositPool, amount)) {\n+        if (!IERC20(asset).transfer(lrtConfig.getContract(LRTConstants.LRT_DEPOSIT_POOL), amount)) {\n             revert TokenTransferFailed();\n         }\n     }\n```\n\n### No need to cache `lrtConfig.assetStrategy(asset)`\n\nhttps://github.com/code-423n4/2023-11-kelp/blob/f751d7594051c0766c7ecd1e68daeb0661e43ee3/src/NodeDelegator.sol#L121-L124\n\n```solidity\nFile: /src/NodeDelegator.sol\n121:    function getAssetBalance(address asset) external view override returns (uint256) {\n122:        address strategy = lrtConfig.assetStrategy(asset);\n123:        return IStrategy(strategy).userUnderlyingView(address(this));\n124:    }\n```\n\n```diff\n     function getAssetBalance(address asset) external view override returns (uin\nt256) {\n-        address strategy = lrtConfig.assetStrategy(asset);\n-        return IStrategy(strategy).userUnderlyingView(address(this));\n+        return IStrategy(lrtConfig.assetStrategy(asset)).userUnderlyingView(address(this));\n     }\n```\n\n### No need to cache `nodeDelegatorQueue[ndcIndex]`\n\nhttps://github.com/code-423n4/2023-11-kelp/blob/f751d7594051c0766c7ecd1e68daeb0661e43ee3/src/LRTDepositPool.sol#L183-L197\n\n```solidity\nFile: /src/LRTDepositPool.sol\n183:    function transferAssetToNodeDelegator(\n\n192:    {\n193:        address nodeDelegator = nodeDelegatorQueue[ndcIndex];\n194:        if (!IERC20(asset).transfer(nodeDelegator, amount)) {\n195:            revert TokenTransferFailed();\n196:        }\n197:    }\n```\n\n```diff\n@@ -190,8 +190,7 @@ contract LRTDepositPool is ILRTDepositPool, LRTConfigRoleChecker, PausableUpgrad\n         onlyLRTManager\n         onlySupportedAsset(asset)\n     {\n-        address nodeDelegator = nodeDelegatorQueue[ndcIndex];\n-        if (!IERC20(asset).transfer(nodeDelegator, amount)) {\n+        if (!IERC20(asset).transfer(nodeDelegatorQueue[ndcIndex], amount)) {\n             revert TokenTransferFailed();\n         }\n     }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-11-kelp",
  "Code": [
    {
      "filename": "src/NodeDelegator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport { UtilLib } from \"./utils/UtilLib.sol\";\nimport { LRTConstants } from \"./utils/LRTConstants.sol\";\nimport { LRTConfigRoleChecker, ILRTConfig } from \"./utils/LRTConfigRoleChecker.sol\";\n\nimport { INodeDelegator } from \"./interfaces/INodeDelegator.sol\";\nimport { IStrategy } from \"./interfaces/IStrategy.sol\";\nimport { IEigenStrategyManager } from \"./interfaces/IEigenStrategyManager.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @title NodeDelegator Contract\n/// @notice The contract that handles the depositing of assets into strategies\ncontract NodeDelegator is INodeDelegator, LRTConfigRoleChecker, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract\n    /// @param lrtConfigAddr LRT config address\n    function initialize(address lrtConfigAddr) external initializer {\n        UtilLib.checkNonZeroAddress(lrtConfigAddr);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        lrtConfig = ILRTConfig(lrtConfigAddr);\n        emit UpdatedLRTConfig(lrtConfigAddr);\n    }\n\n    /// @notice Approves the maximum amount of an asset to the eigen strategy manager\n    /// @dev only supported assets can be deposited and only called by the LRT manager\n    /// @param asset the asset to deposit\n    function maxApproveToEigenStrategyManager(address asset)\n        external\n        override\n        onlySupportedAsset(asset)\n        onlyLRTManager\n    {\n        address eigenlayerStrategyManagerAddress = lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER);\n        IERC20(asset).approve(eigenlayerStrategyManagerAddress, type(uint256).max);\n    }\n\n    /// @notice Deposits an asset lying in this NDC into its strategy\n    /// @dev only supported assets can be deposited and only called by the LRT manager\n    /// @param asset the asset to deposit\n    function depositAssetIntoStrategy(address asset)\n        external\n        override\n        whenNotPaused\n        nonReentrant\n        onlySupportedAsset(asset)\n        onlyLRTManager\n    {\n        address strategy = lrtConfig.assetStrategy(asset);\n        IERC20 token = IERC20(asset);\n        address eigenlayerStrategyManagerAddress = lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER);\n\n        uint256 balance = token.balanceOf(address(this));\n\n        emit AssetDepositIntoStrategy(asset, strategy, balance);\n\n        IEigenStrategyManager(eigenlayerStrategyManagerAddress).depositIntoStrategy(IStrategy(strategy), token, balance);\n    }\n\n    /// @notice Transfers an asset back to the LRT deposit pool\n    /// @dev only supported assets can be transferred and only called by the LRT manager\n    /// @param asset the asset to transfer\n    /// @param amount the amount to transfer\n    function transferBackToLRTDepositPool(\n        address asset,\n        uint256 amount\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        onlySupportedAsset(asset)\n        onlyLRTManager\n    {\n        address lrtDepositPool = lrtConfig.getContract(LRTConstants.LRT_DEPOSIT_POOL);\n\n        if (!IERC20(asset).transfer(lrtDepositPool, amount)) {\n            revert TokenTransferFailed();\n        }\n    }\n\n    /// @notice Fetches balance of all assets staked in eigen layer through this contract\n    /// @return assets the assets that the node delegator has deposited into strategies\n    /// @return assetBalances the balances of the assets that the node delegator has deposited into strategies\n    function getAssetBalances()\n        external\n        view\n        override\n        returns (address[] memory assets, uint256[] memory assetBalances)\n    {\n        address eigenlayerStrategyManagerAddress = lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER);\n\n        (IStrategy[] memory strategies,) =\n            IEigenStrategyManager(eigenlayerStrategyManagerAddress).getDeposits(address(this));\n\n        uint256 strategiesLength = strategies.length;\n        assets = new address[](strategiesLength);\n        assetBalances = new uint256[](strategiesLength);\n\n        for (uint256 i = 0; i < strategiesLength;) {\n            assets[i] = address(IStrategy(strategies[i]).underlyingToken());\n            assetBalances[i] = IStrategy(strategies[i]).userUnderlyingView(address(this));\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Returns the balance of an asset that the node delegator has deposited into the strategy\n    /// @param asset the asset to get the balance of\n    /// @return stakedBalance the balance of the asset\n    function getAssetBalance(address asset) external view override returns (uint256) {\n        address strategy = lrtConfig.assetStrategy(asset);\n        return IStrategy(strategy).userUnderlyingView(address(this));\n    }\n\n    /// @dev Triggers stopped state. Contract must not be paused.\n    function pause() external onlyLRTManager {\n        _pause();\n    }\n\n    /// @dev Returns to normal state. Contract must be paused\n    function unpause() external onlyLRTAdmin {\n        _unpause();\n    }\n}"
    },
    {
      "filename": "src/NodeDelegator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport { UtilLib } from \"./utils/UtilLib.sol\";\nimport { LRTConstants } from \"./utils/LRTConstants.sol\";\nimport { LRTConfigRoleChecker, ILRTConfig } from \"./utils/LRTConfigRoleChecker.sol\";\n\nimport { INodeDelegator } from \"./interfaces/INodeDelegator.sol\";\nimport { IStrategy } from \"./interfaces/IStrategy.sol\";\nimport { IEigenStrategyManager } from \"./interfaces/IEigenStrategyManager.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @title NodeDelegator Contract\n/// @notice The contract that handles the depositing of assets into strategies\ncontract NodeDelegator is INodeDelegator, LRTConfigRoleChecker, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract\n    /// @param lrtConfigAddr LRT config address\n    function initialize(address lrtConfigAddr) external initializer {\n        UtilLib.checkNonZeroAddress(lrtConfigAddr);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        lrtConfig = ILRTConfig(lrtConfigAddr);\n        emit UpdatedLRTConfig(lrtConfigAddr);\n    }\n\n    /// @notice Approves the maximum amount of an asset to the eigen strategy manager\n    /// @dev only supported assets can be deposited and only called by the LRT manager\n    /// @param asset the asset to deposit\n    function maxApproveToEigenStrategyManager(address asset)\n        external\n        override\n        onlySupportedAsset(asset)\n        onlyLRTManager\n    {\n        address eigenlayerStrategyManagerAddress = lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER);\n        IERC20(asset).approve(eigenlayerStrategyManagerAddress, type(uint256).max);\n    }\n\n    /// @notice Deposits an asset lying in this NDC into its strategy\n    /// @dev only supported assets can be deposited and only called by the LRT manager\n    /// @param asset the asset to deposit\n    function depositAssetIntoStrategy(address asset)\n        external\n        override\n        whenNotPaused\n        nonReentrant\n        onlySupportedAsset(asset)\n        onlyLRTManager\n    {\n        address strategy = lrtConfig.assetStrategy(asset);\n        IERC20 token = IERC20(asset);\n        address eigenlayerStrategyManagerAddress = lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER);\n\n        uint256 balance = token.balanceOf(address(this));\n\n        emit AssetDepositIntoStrategy(asset, strategy, balance);\n\n        IEigenStrategyManager(eigenlayerStrategyManagerAddress).depositIntoStrategy(IStrategy(strategy), token, balance);\n    }\n\n    /// @notice Transfers an asset back to the LRT deposit pool\n    /// @dev only supported assets can be transferred and only called by the LRT manager\n    /// @param asset the asset to transfer\n    /// @param amount the amount to transfer\n    function transferBackToLRTDepositPool(\n        address asset,\n        uint256 amount\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        onlySupportedAsset(asset)\n        onlyLRTManager\n    {\n        address lrtDepositPool = lrtConfig.getContract(LRTConstants.LRT_DEPOSIT_POOL);\n\n        if (!IERC20(asset).transfer(lrtDepositPool, amount)) {\n            revert TokenTransferFailed();\n        }\n    }\n\n    /// @notice Fetches balance of all assets staked in eigen layer through this contract\n    /// @return assets the assets that the node delegator has deposited into strategies\n    /// @return assetBalances the balances of the assets that the node delegator has deposited into strategies\n    function getAssetBalances()\n        external\n        view\n        override\n        returns (address[] memory assets, uint256[] memory assetBalances)\n    {\n        address eigenlayerStrategyManagerAddress = lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER);\n\n        (IStrategy[] memory strategies,) =\n            IEigenStrategyManager(eigenlayerStrategyManagerAddress).getDeposits(address(this));\n\n        uint256 strategiesLength = strategies.length;\n        assets = new address[](strategiesLength);\n        assetBalances = new uint256[](strategiesLength);\n\n        for (uint256 i = 0; i < strategiesLength;) {\n            assets[i] = address(IStrategy(strategies[i]).underlyingToken());\n            assetBalances[i] = IStrategy(strategies[i]).userUnderlyingView(address(this));\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Returns the balance of an asset that the node delegator has deposited into the strategy\n    /// @param asset the asset to get the balance of\n    /// @return stakedBalance the balance of the asset\n    function getAssetBalance(address asset) external view override returns (uint256) {\n        address strategy = lrtConfig.assetStrategy(asset);\n        return IStrategy(strategy).userUnderlyingView(address(this));\n    }\n\n    /// @dev Triggers stopped state. Contract must not be paused.\n    function pause() external onlyLRTManager {\n        _pause();\n    }\n\n    /// @dev Returns to normal state. Contract must be paused\n    function unpause() external onlyLRTAdmin {\n        _unpause();\n    }\n}"
    },
    {
      "filename": "src/NodeDelegator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport { UtilLib } from \"./utils/UtilLib.sol\";\nimport { LRTConstants } from \"./utils/LRTConstants.sol\";\nimport { LRTConfigRoleChecker, ILRTConfig } from \"./utils/LRTConfigRoleChecker.sol\";\n\nimport { INodeDelegator } from \"./interfaces/INodeDelegator.sol\";\nimport { IStrategy } from \"./interfaces/IStrategy.sol\";\nimport { IEigenStrategyManager } from \"./interfaces/IEigenStrategyManager.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @title NodeDelegator Contract\n/// @notice The contract that handles the depositing of assets into strategies\ncontract NodeDelegator is INodeDelegator, LRTConfigRoleChecker, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract\n    /// @param lrtConfigAddr LRT config address\n    function initialize(address lrtConfigAddr) external initializer {\n        UtilLib.checkNonZeroAddress(lrtConfigAddr);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        lrtConfig = ILRTConfig(lrtConfigAddr);\n        emit UpdatedLRTConfig(lrtConfigAddr);\n    }\n\n    /// @notice Approves the maximum amount of an asset to the eigen strategy manager\n    /// @dev only supported assets can be deposited and only called by the LRT manager\n    /// @param asset the asset to deposit\n    function maxApproveToEigenStrategyManager(address asset)\n        external\n        override\n        onlySupportedAsset(asset)\n        onlyLRTManager\n    {\n        address eigenlayerStrategyManagerAddress = lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER);\n        IERC20(asset).approve(eigenlayerStrategyManagerAddress, type(uint256).max);\n    }\n\n    /// @notice Deposits an asset lying in this NDC into its strategy\n    /// @dev only supported assets can be deposited and only called by the LRT manager\n    /// @param asset the asset to deposit\n    function depositAssetIntoStrategy(address asset)\n        external\n        override\n        whenNotPaused\n        nonReentrant\n        onlySupportedAsset(asset)\n        onlyLRTManager\n    {\n        address strategy = lrtConfig.assetStrategy(asset);\n        IERC20 token = IERC20(asset);\n        address eigenlayerStrategyManagerAddress = lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER);\n\n        uint256 balance = token.balanceOf(address(this));\n\n        emit AssetDepositIntoStrategy(asset, strategy, balance);\n\n        IEigenStrategyManager(eigenlayerStrategyManagerAddress).depositIntoStrategy(IStrategy(strategy), token, balance);\n    }\n\n    /// @notice Transfers an asset back to the LRT deposit pool\n    /// @dev only supported assets can be transferred and only called by the LRT manager\n    /// @param asset the asset to transfer\n    /// @param amount the amount to transfer\n    function transferBackToLRTDepositPool(\n        address asset,\n        uint256 amount\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        onlySupportedAsset(asset)\n        onlyLRTManager\n    {\n        address lrtDepositPool = lrtConfig.getContract(LRTConstants.LRT_DEPOSIT_POOL);\n\n        if (!IERC20(asset).transfer(lrtDepositPool, amount)) {\n            revert TokenTransferFailed();\n        }\n    }\n\n    /// @notice Fetches balance of all assets staked in eigen layer through this contract\n    /// @return assets the assets that the node delegator has deposited into strategies\n    /// @return assetBalances the balances of the assets that the node delegator has deposited into strategies\n    function getAssetBalances()\n        external\n        view\n        override\n        returns (address[] memory assets, uint256[] memory assetBalances)\n    {\n        address eigenlayerStrategyManagerAddress = lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER);\n\n        (IStrategy[] memory strategies,) =\n            IEigenStrategyManager(eigenlayerStrategyManagerAddress).getDeposits(address(this));\n\n        uint256 strategiesLength = strategies.length;\n        assets = new address[](strategiesLength);\n        assetBalances = new uint256[](strategiesLength);\n\n        for (uint256 i = 0; i < strategiesLength;) {\n            assets[i] = address(IStrategy(strategies[i]).underlyingToken());\n            assetBalances[i] = IStrategy(strategies[i]).userUnderlyingView(address(this));\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Returns the balance of an asset that the node delegator has deposited into the strategy\n    /// @param asset the asset to get the balance of\n    /// @return stakedBalance the balance of the asset\n    function getAssetBalance(address asset) external view override returns (uint256) {\n        address strategy = lrtConfig.assetStrategy(asset);\n        return IStrategy(strategy).userUnderlyingView(address(this));\n    }\n\n    /// @dev Triggers stopped state. Contract must not be paused.\n    function pause() external onlyLRTManager {\n        _pause();\n    }\n\n    /// @dev Returns to normal state. Contract must be paused\n    function unpause() external onlyLRTAdmin {\n        _unpause();\n    }\n}"
    },
    {
      "filename": "src/NodeDelegator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport { UtilLib } from \"./utils/UtilLib.sol\";\nimport { LRTConstants } from \"./utils/LRTConstants.sol\";\nimport { LRTConfigRoleChecker, ILRTConfig } from \"./utils/LRTConfigRoleChecker.sol\";\n\nimport { INodeDelegator } from \"./interfaces/INodeDelegator.sol\";\nimport { IStrategy } from \"./interfaces/IStrategy.sol\";\nimport { IEigenStrategyManager } from \"./interfaces/IEigenStrategyManager.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @title NodeDelegator Contract\n/// @notice The contract that handles the depositing of assets into strategies\ncontract NodeDelegator is INodeDelegator, LRTConfigRoleChecker, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract\n    /// @param lrtConfigAddr LRT config address\n    function initialize(address lrtConfigAddr) external initializer {\n        UtilLib.checkNonZeroAddress(lrtConfigAddr);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        lrtConfig = ILRTConfig(lrtConfigAddr);\n        emit UpdatedLRTConfig(lrtConfigAddr);\n    }\n\n    /// @notice Approves the maximum amount of an asset to the eigen strategy manager\n    /// @dev only supported assets can be deposited and only called by the LRT manager\n    /// @param asset the asset to deposit\n    function maxApproveToEigenStrategyManager(address asset)\n        external\n        override\n        onlySupportedAsset(asset)\n        onlyLRTManager\n    {\n        address eigenlayerStrategyManagerAddress = lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER);\n        IERC20(asset).approve(eigenlayerStrategyManagerAddress, type(uint256).max);\n    }\n\n    /// @notice Deposits an asset lying in this NDC into its strategy\n    /// @dev only supported assets can be deposited and only called by the LRT manager\n    /// @param asset the asset to deposit\n    function depositAssetIntoStrategy(address asset)\n        external\n        override\n        whenNotPaused\n        nonReentrant\n        onlySupportedAsset(asset)\n        onlyLRTManager\n    {\n        address strategy = lrtConfig.assetStrategy(asset);\n        IERC20 token = IERC20(asset);\n        address eigenlayerStrategyManagerAddress = lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER);\n\n        uint256 balance = token.balanceOf(address(this));\n\n        emit AssetDepositIntoStrategy(asset, strategy, balance);\n\n        IEigenStrategyManager(eigenlayerStrategyManagerAddress).depositIntoStrategy(IStrategy(strategy), token, balance);\n    }\n\n    /// @notice Transfers an asset back to the LRT deposit pool\n    /// @dev only supported assets can be transferred and only called by the LRT manager\n    /// @param asset the asset to transfer\n    /// @param amount the amount to transfer\n    function transferBackToLRTDepositPool(\n        address asset,\n        uint256 amount\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        onlySupportedAsset(asset)\n        onlyLRTManager\n    {\n        address lrtDepositPool = lrtConfig.getContract(LRTConstants.LRT_DEPOSIT_POOL);\n\n        if (!IERC20(asset).transfer(lrtDepositPool, amount)) {\n            revert TokenTransferFailed();\n        }\n    }\n\n    /// @notice Fetches balance of all assets staked in eigen layer through this contract\n    /// @return assets the assets that the node delegator has deposited into strategies\n    /// @return assetBalances the balances of the assets that the node delegator has deposited into strategies\n    function getAssetBalances()\n        external\n        view\n        override\n        returns (address[] memory assets, uint256[] memory assetBalances)\n    {\n        address eigenlayerStrategyManagerAddress = lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER);\n\n        (IStrategy[] memory strategies,) =\n            IEigenStrategyManager(eigenlayerStrategyManagerAddress).getDeposits(address(this));\n\n        uint256 strategiesLength = strategies.length;\n        assets = new address[](strategiesLength);\n        assetBalances = new uint256[](strategiesLength);\n\n        for (uint256 i = 0; i < strategiesLength;) {\n            assets[i] = address(IStrategy(strategies[i]).underlyingToken());\n            assetBalances[i] = IStrategy(strategies[i]).userUnderlyingView(address(this));\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Returns the balance of an asset that the node delegator has deposited into the strategy\n    /// @param asset the asset to get the balance of\n    /// @return stakedBalance the balance of the asset\n    function getAssetBalance(address asset) external view override returns (uint256) {\n        address strategy = lrtConfig.assetStrategy(asset);\n        return IStrategy(strategy).userUnderlyingView(address(this));\n    }\n\n    /// @dev Triggers stopped state. Contract must not be paused.\n    function pause() external onlyLRTManager {\n        _pause();\n    }\n\n    /// @dev Returns to normal state. Contract must be paused\n    function unpause() external onlyLRTAdmin {\n        _unpause();\n    }\n}"
    },
    {
      "filename": "src/LRTDepositPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport { UtilLib } from \"./utils/UtilLib.sol\";\nimport { LRTConstants } from \"./utils/LRTConstants.sol\";\n\nimport { LRTConfigRoleChecker, ILRTConfig } from \"./utils/LRTConfigRoleChecker.sol\";\nimport { IRSETH } from \"./interfaces/IRSETH.sol\";\nimport { ILRTOracle } from \"./interfaces/ILRTOracle.sol\";\nimport { INodeDelegator } from \"./interfaces/INodeDelegator.sol\";\nimport { ILRTDepositPool } from \"./interfaces/ILRTDepositPool.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @title LRTDepositPool - Deposit Pool Contract for LSTs\n/// @notice Handles LST asset deposits\ncontract LRTDepositPool is ILRTDepositPool, LRTConfigRoleChecker, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    uint256 public maxNodeDelegatorCount;\n\n    address[] public nodeDelegatorQueue;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract\n    /// @param lrtConfigAddr LRT config address\n    function initialize(address lrtConfigAddr) external initializer {\n        UtilLib.checkNonZeroAddress(lrtConfigAddr);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        maxNodeDelegatorCount = 10;\n        lrtConfig = ILRTConfig(lrtConfigAddr);\n        emit UpdatedLRTConfig(lrtConfigAddr);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            view functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice gets the total asset present in protocol\n    /// @param asset Asset address\n    /// @return totalAssetDeposit total asset present in protocol\n    function getTotalAssetDeposits(address asset) public view override returns (uint256 totalAssetDeposit) {\n        (uint256 assetLyingInDepositPool, uint256 assetLyingInNDCs, uint256 assetStakedInEigenLayer) =\n            getAssetDistributionData(asset);\n        return (assetLyingInDepositPool + assetLyingInNDCs + assetStakedInEigenLayer);\n    }\n\n    /// @notice gets the current limit of asset deposit\n    /// @param asset Asset address\n    /// @return currentLimit Current limit of asset deposit\n    function getAssetCurrentLimit(address asset) public view override returns (uint256) {\n        return lrtConfig.depositLimitByAsset(asset) - getTotalAssetDeposits(asset);\n    }\n\n    /// @dev get node delegator queue\n    /// @return nodeDelegatorQueue Array of node delegator contract addresses\n    function getNodeDelegatorQueue() external view override returns (address[] memory) {\n        return nodeDelegatorQueue;\n    }\n\n    /// @dev provides asset amount distribution data among depositPool, NDCs and eigenLayer\n    /// @param asset the asset to get the total amount of\n    /// @return assetLyingInDepositPool asset amount lying in this LRTDepositPool contract\n    /// @return assetLyingInNDCs asset amount sum lying in all NDC contract\n    /// @return assetStakedInEigenLayer asset amount staked in eigen layer through all NDCs\n    function getAssetDistributionData(address asset)\n        public\n        view\n        override\n        onlySupportedAsset(asset)\n        returns (uint256 assetLyingInDepositPool, uint256 assetLyingInNDCs, uint256 assetStakedInEigenLayer)\n    {\n        // Question: is here the right place to have this? Could it be in LRTConfig?\n        assetLyingInDepositPool = IERC20(asset).balanceOf(address(this));\n\n        uint256 ndcsCount = nodeDelegatorQueue.length;\n        for (uint256 i; i < ndcsCount;) {\n            assetLyingInNDCs += IERC20(asset).balanceOf(nodeDelegatorQueue[i]);\n            assetStakedInEigenLayer += INodeDelegator(nodeDelegatorQueue[i]).getAssetBalance(asset);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice View amount of rsETH to mint for given asset amount\n    /// @param asset Asset address\n    /// @param amount Asset amount\n    /// @return rsethAmountToMint Amount of rseth to mint\n    function getRsETHAmountToMint(\n        address asset,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (uint256 rsethAmountToMint)\n    {\n        // setup oracle contract\n        address lrtOracleAddress = lrtConfig.getContract(LRTConstants.LRT_ORACLE);\n        ILRTOracle lrtOracle = ILRTOracle(lrtOracleAddress);\n\n        // calculate rseth amount to mint based on asset amount and asset exchange rate\n        rsethAmountToMint = (amount * lrtOracle.getAssetPrice(asset)) / lrtOracle.getRSETHPrice();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            write functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice helps user stake LST to the protocol\n    /// @param asset LST asset address to stake\n    /// @param depositAmount LST asset amount to stake\n    function depositAsset(\n        address asset,\n        uint256 depositAmount\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        onlySupportedAsset(asset)\n    {\n        // checks\n        if (depositAmount == 0) {\n            revert InvalidAmount();\n        }\n        if (depositAmount > getAssetCurrentLimit(asset)) {\n            revert MaximumDepositLimitReached();\n        }\n\n        if (!IERC20(asset).transferFrom(msg.sender, address(this), depositAmount)) {\n            revert TokenTransferFailed();\n        }\n\n        // interactions\n        uint256 rsethAmountMinted = _mintRsETH(asset, depositAmount);\n\n        emit AssetDeposit(asset, depositAmount, rsethAmountMinted);\n    }\n\n    /// @dev private function to mint rseth. It calculates rseth amount to mint based on asset amount and asset exchange\n    /// rates from oracle\n    /// @param _asset Asset address\n    /// @param _amount Asset amount to mint rseth\n    /// @return rsethAmountToMint Amount of rseth minted\n    function _mintRsETH(address _asset, uint256 _amount) private returns (uint256 rsethAmountToMint) {\n        (rsethAmountToMint) = getRsETHAmountToMint(_asset, _amount);\n\n        address rsethToken = lrtConfig.rsETH();\n        // mint rseth for user\n        IRSETH(rsethToken).mint(msg.sender, rsethAmountToMint);\n    }\n\n    /// @notice add new node delegator contract addresses\n    /// @dev only callable by LRT manager\n    /// @param nodeDelegatorContracts Array of NodeDelegator contract addresses\n    function addNodeDelegatorContractToQueue(address[] calldata nodeDelegatorContracts) external onlyLRTAdmin {\n        uint256 length = nodeDelegatorContracts.length;\n        if (nodeDelegatorQueue.length + length > maxNodeDelegatorCount) {\n            revert MaximumNodeDelegatorCountReached();\n        }\n\n        for (uint256 i; i < length;) {\n            UtilLib.checkNonZeroAddress(nodeDelegatorContracts[i]);\n            nodeDelegatorQueue.push(nodeDelegatorContracts[i]);\n            emit NodeDelegatorAddedinQueue(nodeDelegatorContracts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice transfers asset lying in this DepositPool to node delegator contract\n    /// @dev only callable by LRT manager\n    /// @param ndcIndex Index of NodeDelegator contract address in nodeDelegatorQueue\n    /// @param asset Asset address\n    /// @param amount Asset amount to transfer\n    function transferAssetToNodeDelegator(\n        uint256 ndcIndex,\n        address asset,\n        uint256 amount\n    )\n        external\n        nonReentrant\n        onlyLRTManager\n        onlySupportedAsset(asset)\n    {\n        address nodeDelegator = nodeDelegatorQueue[ndcIndex];\n        if (!IERC20(asset).transfer(nodeDelegator, amount)) {\n            revert TokenTransferFailed();\n        }\n    }\n\n    /// @notice update max node delegator count\n    /// @dev only callable by LRT admin\n    /// @param maxNodeDelegatorCount_ Maximum count of node delegator\n    function updateMaxNodeDelegatorCount(uint256 maxNodeDelegatorCount_) external onlyLRTAdmin {\n        maxNodeDelegatorCount = maxNodeDelegatorCount_;\n        emit MaxNodeDelegatorCountUpdated(maxNodeDelegatorCount);\n    }\n\n    /// @dev Triggers stopped state. Contract must not be paused.\n    function pause() external onlyLRTManager {\n        _pause();\n    }\n\n    /// @dev Returns to normal state. Contract must be paused\n    function unpause() external onlyLRTAdmin {\n        _unpause();\n    }\n}"
    }
  ]
}