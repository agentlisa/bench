{
  "Title": "[M-18]  `_getUniswapTwapWei()` will show incorrect price for negative ticks cause it doesn't round up for negative ticks",
  "Content": "\nTake a look at <https://github.com/code-423n4/2024-01-salty/blob/f742b554e18ae1a07cb8d4617ec8aa50db037c1c/src/price_feed/CoreUniswapFeed.sol#L49-L75>\n\n<details>\n\n```solidity\n\t// Returns amount of token0 * (10**18) given token1\n    function _getUniswapTwapWei( IUniswapV3Pool pool, uint256 twapInterval ) public view returns (uint256)\n    \t{\n\t\tuint32[] memory secondsAgo = new uint32[](2);\n\t\tsecondsAgo[0] = uint32(twapInterval); // from (before)\n\t\tsecondsAgo[1] = 0; // to (now)\n\n        // Get the historical tick data using the observe() function\n         (int56[] memory tickCumulatives, ) = pool.observe(secondsAgo);\n\t\t//@audit\n\t\tint24 tick = int24((tickCumulatives[1] - tickCumulatives[0]) / int56(uint56(twapInterval)));\n\t\tuint160 sqrtPriceX96 = TickMath.getSqrtRatioAtTick( tick );\n\t\tuint256 p = FullMath.mulDiv(sqrtPriceX96, sqrtPriceX96, FixedPoint96.Q96 );\n\n\t\tuint8 decimals0 = ( ERC20( pool.token0() ) ).decimals();\n\t\tuint8 decimals1 = ( ERC20( pool.token1() ) ).decimals();\n\n\t\tif ( decimals1 > decimals0 )\n\t\t\treturn FullMath.mulDiv( 10 ** ( 18 + decimals1 - decimals0 ), FixedPoint96.Q96, p );\n\n\t\tif ( decimals0 > decimals1 )\n\t\t\treturn ( FixedPoint96.Q96 * ( 10 ** 18 ) ) / ( p * ( 10 ** ( decimals0 - decimals1 ) ) );\n\n\t\treturn ( FixedPoint96.Q96 * ( 10 ** 18 ) ) / p;\n    \t}\n\n```\n</details>\n\nThis function is used to get twap price tick using uniswap oracle. it uses `pool.observe()` to get `tickCumulatives` array which is then used to calculate `int24 tick`.\n\nThe problem is that in case if `int24(tickCumulatives[1] - tickCumulatives[0])` is negative, then the tick should be rounded down as it's done in the[ uniswap library](https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/OracleLibrary.sol#L36).\n\nAs result, in case if `int24(tickCumulatives[1] - tickCumulatives[0])` is negative and `(tickCumulatives[1] - tickCumulatives[0]) % secondsAgo != 0`, then returned tick will be bigger then it should be, which opens possibility for some price manipulations and arbitrage opportunities.\n\n### Impact\n\nIn case if ` int24(tickCumulatives[1] - tickCumulatives[0])  `is negative and `((tickCumulatives[1] - tickCumulatives[0]) % secondsAgo != 0`, then returned tick will be bigger than it should be which places protocol wanting prices to be right not be able to achieve this goal, note that where as protocol still relies on multiple sources of price, they still come down and end on weighing the differences between the prices and reverting if a certain limit is passed, effectively causing the pricing logic to be unavailable and also reverting on important functions like `CollateralAndLiquidity::liquidate()` cause a call to `underlyingTokenValueInUSD()` is made which would not be available.\n\n### Recommended Mitigation Steps\n\nAdd this line:\n`if (tickCumulatives[1] - tickCumulatives[0] < 0 && (tickCumulatives[1] - tickCumulatives[0]) % secondsAgo != 0) timeWeightedTick --;`\n\n**[othernet-global (Salty.IO) confirmed and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/380#issuecomment-1950451692):**\n > Now rounds down for negative ticks as suggested.\n> \n> https://github.com/othernet-global/salty-io/commit/4625393e9bd010778003a1424201513885068800\n\n > The stablecoin framework: /stablecoin, /price_feed, WBTC/WETH collateral, PriceAggregator, price feeds and USDS have been removed:\n> https://github.com/othernet-global/salty-io/commit/88b7fd1f3f5e037a155424a85275efd79f3e9bf9\n\n**Status:** Mitigation confirmed. Full details in reports from [t0x1c](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/19), [zzebra83](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/99), and [0xpiken](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/81).\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/price_feed/CoreUniswapFeed.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport \"v3-core/interfaces/IUniswapV3Pool.sol\";\nimport \"v3-core/libraries/FixedPoint96.sol\";\nimport \"v3-core/libraries/TickMath.sol\";\nimport \"v3-core/libraries/FullMath.sol\";\nimport \"./interfaces/IPriceFeed.sol\";\n\n\n// Returns TWAPs for WBTC and WETH for associated Uniswap v3 pools.\n// Prices are returned with 18 decimals.\ncontract CoreUniswapFeed is IPriceFeed\n    {\n    // 30 minute TWAP period to resist price manipulation\n    uint256 public constant TWAP_PERIOD = 30 minutes;\n\n\n\t// Uniswap v3 pool addresses\n    IUniswapV3Pool immutable public UNISWAP_V3_WBTC_WETH;\n\tIUniswapV3Pool immutable public UNISWAP_V3_WETH_USDC;\n\n\tIERC20 immutable public wbtc;\n    IERC20 immutable public weth;\n    IERC20 immutable public usdc;\n\n    bool immutable public wbtc_wethFlipped;\n    bool immutable public weth_usdcFlipped;\n\n\n\tconstructor( IERC20 _wbtc, IERC20 _weth, IERC20 _usdc, address _UNISWAP_V3_WBTC_WETH, address _UNISWAP_V3_WETH_USDC )\n\t\t{\n\t\tUNISWAP_V3_WBTC_WETH = IUniswapV3Pool(_UNISWAP_V3_WBTC_WETH);\n\t\tUNISWAP_V3_WETH_USDC = IUniswapV3Pool(_UNISWAP_V3_WETH_USDC);\n\n\t\tusdc = _usdc;\n\t\twbtc = _wbtc;\n\t\tweth = _weth;\n\n\t\t// Non-flipped is WBTC/WETH order\n\t\twbtc_wethFlipped = address(weth) < address(wbtc);\n\n\t\t// Non-flipped is WETH/USDC order\n\t\tweth_usdcFlipped = address(usdc) < address(weth);\n\t\t}\n\n\n\t// Returns amount of token0 * (10**18) given token1\n    function _getUniswapTwapWei( IUniswapV3Pool pool, uint256 twapInterval ) public view returns (uint256)\n    \t{\n\t\tuint32[] memory secondsAgo = new uint32[](2);\n\t\tsecondsAgo[0] = uint32(twapInterval); // from (before)\n\t\tsecondsAgo[1] = 0; // to (now)\n\n        // Get the historical tick data using the observe() function\n         (int56[] memory tickCumulatives, ) = pool.observe(secondsAgo);\n\n\t\tint24 tick = int24((tickCumulatives[1] - tickCumulatives[0]) / int56(uint56(twapInterval)));\n\t\tuint160 sqrtPriceX96 = TickMath.getSqrtRatioAtTick( tick );\n\t\tuint256 p = FullMath.mulDiv(sqrtPriceX96, sqrtPriceX96, FixedPoint96.Q96 );\n\n\t\tuint8 decimals0 = ( ERC20( pool.token0() ) ).decimals();\n\t\tuint8 decimals1 = ( ERC20( pool.token1() ) ).decimals();\n\n\t\tif ( decimals1 > decimals0 )\n\t\t\treturn FullMath.mulDiv( 10 ** ( 18 + decimals1 - decimals0 ), FixedPoint96.Q96, p );\n\n\t\tif ( decimals0 > decimals1 )\n\t\t\treturn ( FixedPoint96.Q96 * ( 10 ** 18 ) ) / ( p * ( 10 ** ( decimals0 - decimals1 ) ) );\n\n\t\treturn ( FixedPoint96.Q96 * ( 10 ** 18 ) ) / p;\n    \t}\n\n\n\t// Wrap the _getUniswapTwapWei function in a public function that includes a try/catch.\n\t// Returns zero on any type of failure.\n\t// virtual - really just needed for the derived unit tests\n    function getUniswapTwapWei( IUniswapV3Pool pool, uint256 twapInterval ) public virtual view returns (uint256)\n\t\t{\n\t\t// Initialize return value to 0\n\t\tuint256 twap = 0;\n\t\ttry this._getUniswapTwapWei(pool, twapInterval) returns (uint256 result)\n\t\t\t{\n\t\t\ttwap = result;\n\t\t\t}\n\t\tcatch (bytes memory)\n\t\t\t{\n\t\t\t// In case of failure, twap will remain 0\n\t\t\t}\n\n\t\treturn twap;\n\t\t}\n\n\n\t// Uses WBTC/WETH and WETH/USDC pools because they have much higher TVL than just the Uniswap v3 WBTC/USD pool.\n\tfunction getTwapWBTC( uint256 twapInterval ) public virtual view returns (uint256)\n\t\t{\n    \tuint256 uniswapWBTC_WETH = getUniswapTwapWei( UNISWAP_V3_WBTC_WETH, twapInterval );\n        uint256 uniswapWETH_USDC = getUniswapTwapWei( UNISWAP_V3_WETH_USDC, twapInterval );\n\n\t\t// Return zero if either is invalid\n        if ((uniswapWBTC_WETH == 0) || (uniswapWETH_USDC == 0 ))\n\t        return 0;\n\n\t\tif ( wbtc_wethFlipped )\n\t\t\tuniswapWBTC_WETH = 10**36 / uniswapWBTC_WETH;\n\n\t\tif ( ! weth_usdcFlipped )\n\t\t\tuniswapWETH_USDC = 10**36 / uniswapWETH_USDC;\n\n\t\treturn ( uniswapWETH_USDC * 10**18) / uniswapWBTC_WETH;\n\t\t}\n\n\n\t// virtual - really just needed for the derived unit tests\n\tfunction getTwapWETH( uint256 twapInterval ) public virtual view returns (uint256)\n\t\t{\n        uint256 uniswapWETH_USDC = getUniswapTwapWei( UNISWAP_V3_WETH_USDC, twapInterval );\n\n\t\t// Return zero if invalid\n        if ( uniswapWETH_USDC == 0 )\n\t        return 0;\n\n        if ( ! weth_usdcFlipped )\n        \treturn 10**36 / uniswapWETH_USDC;\n        else\n        \treturn uniswapWETH_USDC;\n\t\t}\n\n\n\t// Returned price is the 30 minutes TWAP by default\n\tfunction getPriceBTC() external view returns (uint256)\n\t\t{\n\t\treturn getTwapWBTC( TWAP_PERIOD );\n\t\t}\n\n\n\t// Returned price is the 30 minutes TWAP by default.\n\t// For this to be changed the DAO needs to use a new CoreUniswapFeed contract (or other contract that implements IPriceFeed.sol)\n\tfunction getPriceETH() external view returns (uint256)\n\t\t{\n\t\treturn getTwapWETH( TWAP_PERIOD );\n\t\t}\n    }"
    },
    {
      "filename": "contracts/libraries/OracleLibrary.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0 <0.8.0;\n\nimport '@uniswap/v3-core/contracts/libraries/FullMath.sol';\nimport '@uniswap/v3-core/contracts/libraries/TickMath.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\n\n/// @title Oracle library\n/// @notice Provides functions to integrate with V3 pool oracle\nlibrary OracleLibrary {\n    /// @notice Calculates time-weighted means of tick and liquidity for a given Uniswap V3 pool\n    /// @param pool Address of the pool that we want to observe\n    /// @param secondsAgo Number of seconds in the past from which to calculate the time-weighted means\n    /// @return arithmeticMeanTick The arithmetic mean tick from (block.timestamp - secondsAgo) to block.timestamp\n    /// @return harmonicMeanLiquidity The harmonic mean liquidity from (block.timestamp - secondsAgo) to block.timestamp\n    function consult(address pool, uint32 secondsAgo)\n        internal\n        view\n        returns (int24 arithmeticMeanTick, uint128 harmonicMeanLiquidity)\n    {\n        require(secondsAgo != 0, 'BP');\n\n        uint32[] memory secondsAgos = new uint32[](2);\n        secondsAgos[0] = secondsAgo;\n        secondsAgos[1] = 0;\n\n        (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) =\n            IUniswapV3Pool(pool).observe(secondsAgos);\n\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n        uint160 secondsPerLiquidityCumulativesDelta =\n            secondsPerLiquidityCumulativeX128s[1] - secondsPerLiquidityCumulativeX128s[0];\n\n        arithmeticMeanTick = int24(tickCumulativesDelta / secondsAgo);\n        // Always round to negative infinity\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % secondsAgo != 0)) arithmeticMeanTick--;\n\n        // We are multiplying here instead of shifting to ensure that harmonicMeanLiquidity doesn't overflow uint128\n        uint192 secondsAgoX160 = uint192(secondsAgo) * type(uint160).max;\n        harmonicMeanLiquidity = uint128(secondsAgoX160 / (uint192(secondsPerLiquidityCumulativesDelta) << 32));\n    }\n\n    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange\n    /// @param tick Tick value used to calculate the quote\n    /// @param baseAmount Amount of token to be converted\n    /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\n    /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\n    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\n    function getQuoteAtTick(\n        int24 tick,\n        uint128 baseAmount,\n        address baseToken,\n        address quoteToken\n    ) internal pure returns (uint256 quoteAmount) {\n        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\n\n        // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself\n        if (sqrtRatioX96 <= type(uint128).max) {\n            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n                : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n        } else {\n            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n                : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n        }\n    }\n\n    /// @notice Given a pool, it returns the number of seconds ago of the oldest stored observation\n    /// @param pool Address of Uniswap V3 pool that we want to observe\n    /// @return secondsAgo The number of seconds ago of the oldest observation stored for the pool\n    function getOldestObservationSecondsAgo(address pool) internal view returns (uint32 secondsAgo) {\n        (, , uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\n        require(observationCardinality > 0, 'NI');\n\n        (uint32 observationTimestamp, , , bool initialized) =\n            IUniswapV3Pool(pool).observations((observationIndex + 1) % observationCardinality);\n\n        // The next index might not be initialized if the cardinality is in the process of increasing\n        // In this case the oldest observation is always in index 0\n        if (!initialized) {\n            (observationTimestamp, , , ) = IUniswapV3Pool(pool).observations(0);\n        }\n\n        secondsAgo = uint32(block.timestamp) - observationTimestamp;\n    }\n\n    /// @notice Given a pool, it returns the tick value as of the start of the current block\n    /// @param pool Address of Uniswap V3 pool\n    /// @return The tick that the pool was in at the start of the current block\n    function getBlockStartingTickAndLiquidity(address pool) internal view returns (int24, uint128) {\n        (, int24 tick, uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\n\n        // 2 observations are needed to reliably calculate the block starting tick\n        require(observationCardinality > 1, 'NEO');\n\n        // If the latest observation occurred in the past, then no tick-changing trades have happened in this block\n        // therefore the tick in `slot0` is the same as at the beginning of the current block.\n        // We don't need to check if this observation is initialized - it is guaranteed to be.\n        (uint32 observationTimestamp, int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128, ) =\n            IUniswapV3Pool(pool).observations(observationIndex);\n        if (observationTimestamp != uint32(block.timestamp)) {\n            return (tick, IUniswapV3Pool(pool).liquidity());\n        }\n\n        uint256 prevIndex = (uint256(observationIndex) + observationCardinality - 1) % observationCardinality;\n        (\n            uint32 prevObservationTimestamp,\n            int56 prevTickCumulative,\n            uint160 prevSecondsPerLiquidityCumulativeX128,\n            bool prevInitialized\n        ) = IUniswapV3Pool(pool).observations(prevIndex);\n\n        require(prevInitialized, 'ONI');\n\n        uint32 delta = observationTimestamp - prevObservationTimestamp;\n        tick = int24((tickCumulative - prevTickCumulative) / delta);\n        uint128 liquidity =\n            uint128(\n                (uint192(delta) * type(uint160).max) /\n                    (uint192(secondsPerLiquidityCumulativeX128 - prevSecondsPerLiquidityCumulativeX128) << 32)\n            );\n        return (tick, liquidity);\n    }\n\n    /// @notice Information for calculating a weighted arithmetic mean tick\n    struct WeightedTickData {\n        int24 tick;\n        uint128 weight;\n    }\n\n    /// @notice Given an array of ticks and weights, calculates the weighted arithmetic mean tick\n    /// @param weightedTickData An array of ticks and weights\n    /// @return weightedArithmeticMeanTick The weighted arithmetic mean tick\n    /// @dev Each entry of `weightedTickData` should represents ticks from pools with the same underlying pool tokens. If they do not,\n    /// extreme care must be taken to ensure that ticks are comparable (including decimal differences).\n    /// @dev Note that the weighted arithmetic mean tick corresponds to the weighted geometric mean price.\n    function getWeightedArithmeticMeanTick(WeightedTickData[] memory weightedTickData)\n        internal\n        pure\n        returns (int24 weightedArithmeticMeanTick)\n    {\n        // Accumulates the sum of products between each tick and its weight\n        int256 numerator;\n\n        // Accumulates the sum of the weights\n        uint256 denominator;\n\n        // Products fit in 152 bits, so it would take an array of length ~2**104 to overflow this logic\n        for (uint256 i; i < weightedTickData.length; i++) {\n            numerator += weightedTickData[i].tick * int256(weightedTickData[i].weight);\n            denominator += weightedTickData[i].weight;\n        }\n\n        weightedArithmeticMeanTick = int24(numerator / int256(denominator));\n        // Always round to negative infinity\n        if (numerator < 0 && (numerator % int256(denominator) != 0)) weightedArithmeticMeanTick--;\n    }\n\n    /// @notice Returns the \"synthetic\" tick which represents the price of the first entry in `tokens` in terms of the last\n    /// @dev Useful for calculating relative prices along routes.\n    /// @dev There must be one tick for each pairwise set of tokens.\n    /// @param tokens The token contract addresses\n    /// @param ticks The ticks, representing the price of each token pair in `tokens`\n    /// @return syntheticTick The synthetic tick, representing the relative price of the outermost tokens in `tokens`\n    function getChainedPrice(address[] memory tokens, int24[] memory ticks)\n        internal\n        pure\n        returns (int256 syntheticTick)\n    {\n        require(tokens.length - 1 == ticks.length, 'DL');\n        for (uint256 i = 1; i <= ticks.length; i++) {\n            // check the tokens for address sort order, then accumulate the\n            // ticks into the running synthetic tick, ensuring that intermediate tokens \"cancel out\"\n            tokens[i - 1] < tokens[i] ? syntheticTick += ticks[i - 1] : syntheticTick -= ticks[i - 1];\n        }\n    }\n}"
    }
  ]
}