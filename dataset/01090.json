{
  "Title": "ERC-777 Tokens Lead to Improper Tracking",
  "Content": "[`RiskFundConverter`](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/RiskFundConverter.sol) and [`XVSVaultConverter`](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/XVSVaultConverter.sol) are offering the income generated by the Venus protocol to external agents for either `USDT` or `XVS`. Upon swapping the assets, the agent can call, for example, the [`convertExactTokens`](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/AbstractTokenConverter.sol#L196-L229) function which transfers `USDT` or `XVS` from the agent to the converter contract and sends the tokens to the agent. [By subtracting the token balance before the transfer by the token balance after the transfer](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/AbstractTokenConverter.sol#L601-L607), the converter contract knows how many tokens were sent out in order to update the internal state in the [`postConversionHook` function](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/RiskFundConverter.sol#L185-L202).\n\n\nIf the token is an [ERC-777](https://eips.ethereum.org/EIPS/eip-777) and the external agent has registered a `receive` hook, it will be able to execute arbitrary code during the transfer. During this arbitrary code execution, the agent is able to influence the token balance by either transferring out tokens or acquiring additional tokens (e.g., by interacting with a DEX or lending protocol). By performing this action, the agent is able to inflate or deflate the calculation of the amount of funds which were sent out of the converter contract.\n\n\nAs this value is used to keep track of the number of assets held by the converter, the agent is able to create a discrepancy between the amount of tokens that the converter is tracking and the one it is actually holding. In case the converter is tracking fewer tokens than it actually holds, the balances can easily be synced using the [`updateAssetsState` function](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/RiskFundConverter.sol#L147-L171). However, in case the converter is tracking more tokens than it actually holds, honest external agents' swaps [will result in a revert](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/AbstractTokenConverter.sol#L603) as the converter does not hold enough tokens to perform a swap.\n\n\nConsider tracking the amount of tokens which were sent out of the converter by subtracting the token balance of the converter instead of the token balance of the external agent.\n\n\n***Update:** Resolved at commit [939da0a](https://github.com/VenusProtocol/protocol-reserve/pull/24/commits/939da0aa86b65a98e59c56e5ddb03391c6f71fa7).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/TokenConverter/RiskFundConverter.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport { SafeERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { ResilientOracle } from \"@venusprotocol/oracle/contracts/ResilientOracle.sol\";\n\nimport { AbstractTokenConverter } from \"./AbstractTokenConverter.sol\";\nimport { ensureNonzeroAddress } from \"../Utils/Validators.sol\";\nimport { IPoolRegistry } from \"../Interfaces/IPoolRegistry.sol\";\nimport { IComptroller } from \"../Interfaces/IComptroller.sol\";\nimport { IRiskFund } from \"../Interfaces/IRiskFund.sol\";\nimport { IVToken } from \"../Interfaces/IVToken.sol\";\nimport { EXP_SCALE } from \"../Utils/Constants.sol\";\n\ncontract RiskFundConverter is AbstractTokenConverter {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice Address of the core pool comptroller\n    address public immutable corePoolComptroller;\n\n    ///@notice Address of the vBNB\n    ///@dev This address is used to exclude the BNB market while in getPools method\n    address public immutable vBNB;\n\n    ///@notice Address of the native wrapped currency\n    address public immutable NATIVE_WRAPPED;\n\n    /// @notice Store the previous state for the asset transferred to ProtocolShareReserve combined(for all pools)\n    mapping(address => uint256) internal assetsReserves;\n\n    /// @notice Store the asset's reserve per pool in the ProtocolShareReserve\n    /// @dev Comptroller(pool) -> Asset -> amount\n    mapping(address => mapping(address => uint256)) internal poolsAssetsReserves;\n\n    /// @notice Address of pool registry contract\n    address public poolRegistry;\n\n    /// @notice This mapping would contain the assets for the pool which would be send to RiskFund directly\n    /// @dev Comptroller(pool) -> Asset -> bool(should transfer directly on true)\n    mapping(address => mapping(address => bool)) public poolsAssetsDirectTransfer;\n\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    /// variables without shifting down storage in the inheritance chain\n    uint256[46] private __gap;\n\n    /// @notice Emitted when pool registry address is updated\n    event PoolRegistryUpdated(address indexed oldPoolRegistry, address indexed newPoolRegistry);\n\n    // Event emitted after the updation of the assets reserves\n    // amount -> reserve increased by amount\n    event AssetsReservesUpdated(address indexed comptroller, address indexed asset, uint256 amount);\n\n    // Event emitted after the funds transferred to the destination address\n    event AssetTransferredToDestination(address indexed comptroller, address indexed asset, uint256 amount);\n\n    // Event emitted after the poolsAssetsDirectTransfer mapping is updated\n    event PoolAssetsDirectTransferUpdated(address indexed comptroller, address indexed asset, bool value);\n\n    // Error thrown when comptrollers array length is not equal to assets array length\n    error InvalidArguments();\n\n    /// @param corePoolComptroller_ Address of the Comptroller pool\n    /// @param vBNB_ Address of the vBNB\n    /// @param nativeWrapped_ Address of the wrapped native currency\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address corePoolComptroller_, address vBNB_, address nativeWrapped_) {\n        ensureNonzeroAddress(corePoolComptroller_);\n        corePoolComptroller = corePoolComptroller_;\n        vBNB = vBNB_;\n        NATIVE_WRAPPED = nativeWrapped_;\n    }\n\n    /// @param accessControlManager_ Access control manager contract address\n    /// @param priceOracle_ Resilient oracle address\n    /// @param destinationAddress_  Address at all incoming tokens will transferred to\n    /// @param poolRegistry_ Address of the pool registry\n    function initialize(\n        address accessControlManager_,\n        ResilientOracle priceOracle_,\n        address destinationAddress_,\n        address poolRegistry_\n    ) public initializer {\n        // Initialize AbstractTokenConverter\n        __AbstractTokenConverter_init(accessControlManager_, priceOracle_, destinationAddress_);\n        poolRegistry = poolRegistry_;\n    }\n\n    /// @dev Pool registry setter\n    /// @param poolRegistry_ Address of the pool registry\n    /// @custom:event PoolRegistryUpdated emits on success\n    /// @custom:error ZeroAddressNotAllowed is thrown when pool registry address is zero\n    function setPoolRegistry(address poolRegistry_) external onlyOwner {\n        ensureNonzeroAddress(poolRegistry_);\n        address oldPoolRegistry = poolRegistry;\n        poolRegistry = poolRegistry_;\n        emit PoolRegistryUpdated(oldPoolRegistry, poolRegistry_);\n    }\n\n    /// @notice Update the poolsAssetsDirectTransfer mapping\n    /// @param comptrollers Addresses of the pools\n    /// @param assets Addresses of the assets need to be added for direct transfer\n    /// @custom:error InvalidArguments thrown when comptrollers array length is not equal to assets array length\n    /// @custom:access Restricted by ACM\n    function setPoolsAssetsDirectTransfer(\n        address[] calldata comptrollers,\n        address[][] calldata assets,\n        bool[][] calldata values\n    ) external {\n        _checkAccessAllowed(\"setPoolsAssetsDirectTransfer(address[],address[][],bool[][])\");\n\n        uint256 comptrollersLength = comptrollers.length;\n\n        if ((comptrollersLength != assets.length) || (comptrollersLength != values.length)) {\n            revert InvalidArguments();\n        }\n\n        for (uint256 i; i < comptrollersLength; ++i) {\n            address[] memory poolAssets = assets[i];\n            bool[] memory assetsValues = values[i];\n\n            if (poolAssets.length != assetsValues.length) {\n                revert InvalidArguments();\n            }\n\n            for (uint256 j; j < poolAssets.length; ++j) {\n                poolsAssetsDirectTransfer[comptrollers[i]][poolAssets[j]] = assetsValues[j];\n                emit PoolAssetsDirectTransferUpdated(comptrollers[i], poolAssets[j], assetsValues[j]);\n            }\n        }\n    }\n\n    /// @dev Get the Amount of the asset in the risk fund for the specific pool\n    /// @param comptroller Comptroller address (pool)\n    /// @param asset Asset address\n    /// @return Asset's reserve in risk fund\n    function getPoolAssetReserve(address comptroller, address asset) external view returns (uint256) {\n        require(IComptroller(comptroller).isComptroller(), \"ReserveHelpers: Comptroller address invalid\");\n        require(asset != address(0), \"ReserveHelpers: Asset address invalid\");\n        return poolsAssetsReserves[comptroller][asset];\n    }\n\n    /// @dev Update the reserve of the asset for the specific pool after transferring to risk fund\n    /// and transferring funds to the protocol share reserve\n    /// @param comptroller Comptroller address (pool)\n    /// @param asset Asset address\n    function updateAssetsState(address comptroller, address asset) public {\n        require(IComptroller(comptroller).isComptroller(), \"ReserveHelpers: Comptroller address invalid\");\n        require(asset != address(0), \"ReserveHelpers: Asset address invalid\");\n        require(poolRegistry != address(0), \"ReserveHelpers: Pool Registry address is not set\");\n        require(ensureAssetListed(comptroller, asset), \"ReserveHelpers: The pool doesn't support the asset\");\n\n        IERC20Upgradeable token = IERC20Upgradeable(asset);\n        uint256 currentBalance = token.balanceOf(address(this));\n        uint256 assetReserve = assetsReserves[asset];\n        if (currentBalance > assetReserve) {\n            uint256 balanceDifference;\n            unchecked {\n                balanceDifference = currentBalance - assetReserve;\n            }\n            if (poolsAssetsDirectTransfer[comptroller][asset]) {\n                token.safeTransfer(destinationAddress, balanceDifference);\n                emit AssetTransferredToDestination(comptroller, asset, balanceDifference);\n                IRiskFund(destinationAddress).updatePoolState(comptroller, asset, balanceDifference);\n            } else {\n                assetsReserves[asset] += balanceDifference;\n                poolsAssetsReserves[comptroller][asset] += balanceDifference;\n                emit AssetsReservesUpdated(comptroller, asset, balanceDifference);\n            }\n        }\n    }\n\n    /// @notice Get the balance for specific token\n    /// @param tokenAddress Address of the token\n    function balanceOf(address tokenAddress) public view override returns (uint256 tokenBalance) {\n        return assetsReserves[tokenAddress];\n    }\n\n    /// @notice Hook to perform after converting tokens\n    /// @dev After transfromation poolsAssetsReserves are settled by pool's reserves fraction\n    /// @param tokenInAddress Address of the tokenIn\n    /// @param tokenOutAddress Address of the tokenOut\n    /// @param amountIn Amount of tokenIn transferred\n    /// @param amountOut Amount of tokenOut transferred\n    function postConversionHook(\n        address tokenInAddress,\n        address tokenOutAddress,\n        uint256 amountIn,\n        uint256 amountOut\n    ) internal override {\n        address[] memory pools = getPools(tokenOutAddress);\n        uint256 assetReserve = assetsReserves[tokenOutAddress];\n        for (uint256 i; i < pools.length; ++i) {\n            uint256 poolShare = (poolsAssetsReserves[pools[i]][tokenOutAddress] * EXP_SCALE) / assetReserve;\n            if (poolShare == 0) continue;\n            updatePoolAssetsReserve(pools[i], tokenOutAddress, amountOut, poolShare);\n            uint256 poolAmountInShare = (poolShare * amountIn) / EXP_SCALE;\n            IRiskFund(destinationAddress).updatePoolState(pools[i], tokenInAddress, poolAmountInShare);\n        }\n\n        assetsReserves[tokenOutAddress] -= amountOut;\n    }\n\n    /// @notice Operations to perform after sweepToken\n    /// @param tokenAddress Address of the token\n    /// @param amount Amount transferred to address(to)\n    function postSweepToken(address tokenAddress, uint256 amount) internal override {\n        uint256 balance = IERC20Upgradeable(tokenAddress).balanceOf(address(this));\n        uint256 balanceDiff = balance - assetsReserves[tokenAddress];\n\n        if (balanceDiff < amount) {\n            uint256 amountDiff = amount - balanceDiff;\n            address[] memory pools = getPools(tokenAddress);\n            uint256 assetReserve = assetsReserves[tokenAddress];\n            for (uint256 i; i < pools.length; ++i) {\n                uint256 poolShare = (poolsAssetsReserves[pools[i]][tokenAddress] * EXP_SCALE) / assetReserve;\n                if (poolShare == 0) continue;\n                updatePoolAssetsReserve(pools[i], tokenAddress, amountDiff, poolShare);\n            }\n            assetsReserves[tokenAddress] -= amountDiff;\n        }\n    }\n\n    /// @notice Update the poolAssetsResreves upon transferring the tokens\n    /// @param pool Address of the pool\n    /// @param tokenAddress Address of the token\n    /// @param amount Amount transferred to address(to)\n    /// @param poolShare share for corresponding pool\n    function updatePoolAssetsReserve(address pool, address tokenAddress, uint256 amount, uint256 poolShare) internal {\n        uint256 poolAmountShare = (poolShare * amount) / EXP_SCALE;\n        poolsAssetsReserves[pool][tokenAddress] -= poolAmountShare;\n    }\n\n    /// @notice Get the array of all pools addresses\n    /// @param tokenAddress Address of the token\n    function getPools(address tokenAddress) internal view returns (address[] memory) {\n        address[] memory pools = IPoolRegistry(poolRegistry).getPoolsSupportedByAsset(tokenAddress);\n\n        if (isAssetListedInCore(tokenAddress)) {\n            uint256 poolsLength = pools.length;\n            address[] memory poolsWithCore = new address[](poolsLength + 1);\n\n            for (uint256 i; i < poolsLength; ++i) {\n                poolsWithCore[i] = pools[i];\n            }\n            poolsWithCore[poolsLength] = corePoolComptroller;\n            return poolsWithCore;\n        }\n\n        return pools;\n    }\n\n    function isAssetListedInCore(address tokenAddress) internal view returns (bool isAssetListed) {\n        address[] memory coreMarkets = IComptroller(corePoolComptroller).getAllMarkets();\n\n        for (uint256 i; i < coreMarkets.length; ++i) {\n            isAssetListed = (vBNB == coreMarkets[i])\n                ? (tokenAddress == NATIVE_WRAPPED)\n                : (IVToken(coreMarkets[i]).underlying() == tokenAddress);\n\n            if (isAssetListed) {\n                break;\n            }\n        }\n    }\n\n    function ensureAssetListed(address comptroller, address asset) internal view returns (bool) {\n        if (comptroller == corePoolComptroller) {\n            return isAssetListedInCore(asset);\n        }\n\n        return IPoolRegistry(poolRegistry).getVTokenForAsset(comptroller, asset) != address(0);\n    }\n}"
    }
  ]
}