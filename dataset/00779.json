{
  "Title": "M-13: getTargetExternalLendingAmount() targetAmount may far less than the correct value",
  "Content": "# Issue M-13: getTargetExternalLendingAmount() targetAmount may far less than the correct value \n\nSource: https://github.com/sherlock-audit/2023-12-notional-update-5-judging/issues/52 \n\n## Found by \nbin2chen\n## Summary\nWhen calculating `ExternalLending.getTargetExternalLendingAmount()`,\nit restricts `targetAmount`  greater than `oracleData.maxExternalDeposit`.\nHowever, it does not take into account that `oracleData.maxExternalDeposit` includes the protocol deposit `currentExternalUnderlyingLend` \nThis may result in the returned quantity being far less than the correct quantity.\n\n## Vulnerability Detail\nin `getTargetExternalLendingAmount()` \nIt restricts `targetAmount` greater than `oracleData.maxExternalDeposit`.\n```solidity\n    function getTargetExternalLendingAmount(\n        Token memory underlyingToken,\n        PrimeCashFactors memory factors,\n        RebalancingTargetData memory rebalancingTargetData,\n        OracleData memory oracleData,\n        PrimeRate memory pr\n    ) internal pure returns (uint256 targetAmount) {\n...\n\n        targetAmount = SafeUint256.min(\n            // totalPrimeCashInUnderlying and totalPrimeDebtInUnderlying are in 8 decimals, convert it to native\n            // token precision here for accurate comparison. No underflow possible since targetExternalUnderlyingLend\n            // is floored at zero.\n            uint256(underlyingToken.convertToExternal(targetExternalUnderlyingLend)),\n            // maxExternalUnderlyingLend is limit enforced by setting externalWithdrawThreshold\n            // maxExternalDeposit is limit due to the supply cap on external pools\n@>          SafeUint256.min(maxExternalUnderlyingLend, oracleData.maxExternalDeposit)\n        );\n```\nthis is : `targetAmount = min(targetExternalUnderlyingLend, maxExternalUnderlyingLend, oracleData.maxExternalDeposit)`\n\nThe problem is that when calculating `oracleData.maxExternalDeposit`, it does not exclude the existing deposit `currentExternalUnderlyingLend` of the current protocol.\n\nFor example:\n`currentExternalUnderlyingLend = 100`\n`targetExternalUnderlyingLend = 100`\n`maxExternalUnderlyingLend = 10000`\n`oracleData.maxExternalDeposit = 0`        (All AAVE deposits include the current deposit `currentExternalUnderlyingLend`)\n\nIf according to the current calculation result: `targetAmount=0`, this will result in needing to withdraw `100`.  (currentExternalUnderlyingLend - targetAmount)\n\nIn fact, only when the calculation result needs to increase the `deposit` (targetAmount > currentExternalUnderlyingLend), it needs to be restricted by `maxExternalDeposit`.\n\nThe correct one should be neither deposit nor withdraw, that is, `targetAmount=currentExternalUnderlyingLend = 100`.\n\n## Impact\n\nA too small `targetAmount` will cause the withdrawal of deposits that should not be withdrawn, damaging the interests of the protocol.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/internal/balances/ExternalLending.sol#L89C1-L97C11\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nOnly when `targetAmount > currentExternalUnderlyingLend` is a deposit needed, it should be considered that it cannot exceed `oracleData.maxExternalDeposit`\n\n```diff\n    function getTargetExternalLendingAmount(\n        Token memory underlyingToken,\n        PrimeCashFactors memory factors,\n        RebalancingTargetData memory rebalancingTargetData,\n        OracleData memory oracleData,\n        PrimeRate memory pr\n    ) internal pure returns (uint256 targetAmount) {\n...\n\n-        targetAmount = SafeUint256.min(\n-            // totalPrimeCashInUnderlying and totalPrimeDebtInUnderlying are in 8 decimals, convert it to native\n-            // token precision here for accurate comparison. No underflow possible since targetExternalUnderlyingLend\n-            // is floored at zero.\n-            uint256(underlyingToken.convertToExternal(targetExternalUnderlyingLend)),\n-            // maxExternalUnderlyingLend is limit enforced by setting externalWithdrawThreshold\n-            // maxExternalDeposit is limit due to the supply cap on external pools\n-            SafeUint256.min(maxExternalUnderlyingLend, oracleData.maxExternalDeposit)\n-        );\n\n+       targetAmount = SafeUint256.min(uint256(underlyingToken.convertToExternal(targetExternalUnderlyingLend)),maxExternalUnderlyingLend);\n+       if (targetAmount > oracleData.currentExternalUnderlyingLend) { //when deposit ,  must check maxExternalDeposit\n+            uint256 forDeposit = targetAmount - oracleData.currentExternalUnderlyingLend;\n+            if (forDeposit > oracleData.maxExternalDeposit) {\n+                targetAmount = targetAmount.sub(\n+                    forDeposit - oracleData.maxExternalDeposit\n+                );                \n+            }\n+        }\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid because { This is valid medium ; watson explained how an incorrect value can be returned}\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/142",
  "Code": [
    {
      "filename": "contracts-v3/contracts/internal/balances/ExternalLending.sol",
      "content": "// SPDX-License-Identifier: BSUL-1.1\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    Token,\n    PrimeRate,\n    PrimeCashFactors,\n    RebalancingTargetData\n} from \"../../global/Types.sol\";\nimport {\n    IPrimeCashHoldingsOracle,\n    OracleData,\n    RedeemData,\n    DepositData\n} from \"../../../interfaces/notional/IPrimeCashHoldingsOracle.sol\";\nimport {TokenHandler} from \"./TokenHandler.sol\";\n\nimport {LibStorage} from \"../../global/LibStorage.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\n\nimport {PrimeRateLib} from \"../pCash/PrimeRateLib.sol\";\nimport {PrimeCashExchangeRate} from \"../pCash/PrimeCashExchangeRate.sol\";\nimport {GenericToken} from \"./protocols/GenericToken.sol\";\n\n\nlibrary ExternalLending {\n    using PrimeRateLib for PrimeRate;\n    using SafeUint256 for uint256;\n    using SafeInt256 for int256;\n    using TokenHandler for Token;\n\n    function getTargetExternalLendingAmount(\n        Token memory underlyingToken,\n        PrimeCashFactors memory factors,\n        RebalancingTargetData memory rebalancingTargetData,\n        OracleData memory oracleData,\n        PrimeRate memory pr\n    ) internal pure returns (uint256 targetAmount) {\n        // Short circuit a zero target\n        if (rebalancingTargetData.targetUtilization == 0) return 0;\n\n        int256 totalPrimeCashInUnderlying = pr.convertToUnderlying(int256(factors.totalPrimeSupply));\n        int256 totalPrimeDebtInUnderlying = pr.convertDebtStorageToUnderlying(int256(factors.totalPrimeDebt).neg()).abs();\n\n        // The target amount to lend is based on a target \"utilization\" of the total prime supply. For example, for\n        // a target utilization of 80%, if the prime cash utilization is 70% (totalPrimeSupply / totalPrimeDebt) then\n        // we want to lend 10% of the total prime supply. This ensures that 20% of the totalPrimeSupply will not be held\n        // in external money markets which run the risk of becoming unredeemable.\n        int256 targetExternalUnderlyingLend = totalPrimeCashInUnderlying\n            .mul(rebalancingTargetData.targetUtilization)\n            .div(Constants.PERCENTAGE_DECIMALS)\n            .sub(totalPrimeDebtInUnderlying);\n        // Floor this value at zero. This will be negative above the target utilization. We do not want to be lending at\n        // all above the target.\n        if (targetExternalUnderlyingLend < 0) targetExternalUnderlyingLend = 0;\n\n        // To ensure redeemability of Notional’s funds on external lending markets,\n        // Notional requires there to be redeemable funds on the external lending market\n        // that are a multiple of the funds that Notional has lent on that market itself.\n        //\n        // The max amount that Notional can lend on that market is a function\n        // of the excess redeemable funds on that market\n        // (funds that are redeemable in excess of Notional’s own funds on that market)\n        // and the externalWithdrawThreshold.\n        //\n        // excessFunds = externalUnderlyingAvailableForWithdraw - currentExternalUnderlyingLend\n        //\n        // maxExternalUnderlyingLend * (externalWithdrawThreshold + 1) = maxExternalUnderlyingLend + excessFunds\n        //\n        // maxExternalUnderlyingLend * (externalWithdrawThreshold + 1) - maxExternalUnderlyingLend = excessFunds\n        //\n        // maxExternalUnderlyingLend * externalWithdrawThreshold = excessFunds\n        //\n        // maxExternalUnderlyingLend = excessFunds / externalWithdrawThreshold\n        uint256 maxExternalUnderlyingLend;\n        if (oracleData.currentExternalUnderlyingLend < oracleData.externalUnderlyingAvailableForWithdraw) {\n            maxExternalUnderlyingLend =\n                (oracleData.externalUnderlyingAvailableForWithdraw - oracleData.currentExternalUnderlyingLend)\n                .mul(uint256(Constants.PERCENTAGE_DECIMALS))\n                .div(rebalancingTargetData.externalWithdrawThreshold);\n        } else {\n            maxExternalUnderlyingLend = 0;\n        }\n\n        targetAmount = SafeUint256.min(\n            // totalPrimeCashInUnderlying and totalPrimeDebtInUnderlying are in 8 decimals, convert it to native\n            // token precision here for accurate comparison. No underflow possible since targetExternalUnderlyingLend\n            // is floored at zero.\n            uint256(underlyingToken.convertToExternal(targetExternalUnderlyingLend)),\n            // maxExternalUnderlyingLend is limit enforced by setting externalWithdrawThreshold\n            // maxExternalDeposit is limit due to the supply cap on external pools\n            SafeUint256.min(maxExternalUnderlyingLend, oracleData.maxExternalDeposit)\n        );\n        // in case of redemption, make sure there is enough to withdraw, important for health check so that\n        // it does not trigger rebalances (redemptions) when there is nothing to redeem\n        if (targetAmount < oracleData.currentExternalUnderlyingLend) {\n            uint256 forRedemption = oracleData.currentExternalUnderlyingLend - targetAmount;\n            if (oracleData.externalUnderlyingAvailableForWithdraw < forRedemption) {\n                // increase target amount so that redemptions amount match externalUnderlyingAvailableForWithdraw\n                targetAmount = targetAmount.add(\n                    // unchecked - is safe here, overflow is not possible due to above if conditional\n                    forRedemption - oracleData.externalUnderlyingAvailableForWithdraw\n                );\n            }\n        }\n    }\n\n    /// @notice Prime cash holdings may be in underlying tokens or they may be held in other money market\n    /// protocols like Compound, Aave or Euler. If there is insufficient underlying tokens to withdraw on\n    /// the contract, this method will redeem money market tokens in order to gain sufficient underlying\n    /// to withdraw from the contract.\n    /// @param currencyId associated currency id\n    /// @param underlying underlying token information\n    /// @param withdrawAmountExternal amount of underlying to withdraw in external token precision\n    function redeemMoneyMarketIfRequired(\n        uint16 currencyId,\n        Token memory underlying,\n        uint256 withdrawAmountExternal\n    ) internal {\n        // If there is sufficient balance of the underlying to withdraw from the contract\n        // immediately, just return.\n        mapping(address => uint256) storage store = LibStorage.getStoredTokenBalances();\n        uint256 currentBalance = store[underlying.tokenAddress];\n        if (withdrawAmountExternal <= currentBalance) return;\n\n        IPrimeCashHoldingsOracle oracle = PrimeCashExchangeRate.getPrimeCashHoldingsOracle(currencyId);\n        // Redemption data returns an array of contract calls to make from the Notional proxy (which\n        // is holding all of the money market tokens).\n        (RedeemData[] memory data) = oracle.getRedemptionCalldata(withdrawAmountExternal - currentBalance);\n\n        // This is the total expected underlying that we should redeem after all redemption calls\n        // are executed.\n        uint256 totalUnderlyingRedeemed = executeMoneyMarketRedemptions(underlying, data);\n\n        // Ensure that we have sufficient funds before we exit\n        require(withdrawAmountExternal <= currentBalance.add(totalUnderlyingRedeemed)); // dev: insufficient redeem\n    }\n\n    /// @notice It is critical that this method measures and records the balanceOf changes before and after\n    /// every token change. If not, then external donations can affect the valuation of pCash and pDebt\n    /// tokens which may be exploitable.\n    /// @param redeemData parameters from the prime cash holding oracle\n    function executeMoneyMarketRedemptions(\n        Token memory underlyingToken,\n        RedeemData[] memory redeemData\n    ) internal returns (uint256 totalUnderlyingRedeemed) {\n        for (uint256 i; i < redeemData.length; i++) {\n            RedeemData memory data = redeemData[i];\n            // Measure the token balance change if the `assetToken` value is set in the\n            // current redemption data struct. \n            uint256 oldAssetBalance = IERC20(data.assetToken).balanceOf(address(this));\n\n            // Measure the underlying balance change before and after the call.\n            uint256 oldUnderlyingBalance = TokenHandler.balanceOf(underlyingToken, address(this));\n\n            // Some asset tokens may require multiple calls to redeem if there is an unstake\n            // or redemption from WETH involved. We only measure the asset token balance change\n            // on the final redemption call, as dictated by the prime cash holdings oracle.\n            for (uint256 j; j < data.targets.length; j++) {\n                GenericToken.executeLowLevelCall(data.targets[j], 0, data.callData[j]);\n            }\n\n            // Ensure that we get sufficient underlying on every redemption\n            uint256 newUnderlyingBalance = TokenHandler.balanceOf(underlyingToken, address(this));\n            uint256 underlyingBalanceChange = newUnderlyingBalance.sub(oldUnderlyingBalance);\n            // If the call is not the final redemption, then expectedUnderlying should\n            // be set to zero.\n            require(data.expectedUnderlying <= underlyingBalanceChange);\n\n            // Measure and update the asset token\n            uint256 newAssetBalance = IERC20(data.assetToken).balanceOf(address(this));\n            require(newAssetBalance <= oldAssetBalance);\n\n            if (\n                (data.rebasingTokenBalanceAdjustment != 0) &&\n                // This equation only makes sense when the \"asset token\" is a rebasing token\n                // in the same denomination as the underlying token. This will only be reached\n                // if the rebasingTokenBalanceAdjustment is set to a non-zero value\n                (underlyingBalanceChange != oldAssetBalance.sub(newAssetBalance))\n            ) {\n                newAssetBalance = newAssetBalance.add(data.rebasingTokenBalanceAdjustment);\n            }\n\n            TokenHandler.updateStoredTokenBalance(data.assetToken, oldAssetBalance, newAssetBalance);\n\n            // Update the total value with the net change\n            totalUnderlyingRedeemed = totalUnderlyingRedeemed.add(underlyingBalanceChange);\n\n            // totalUnderlyingRedeemed is always positive or zero.\n            TokenHandler.updateStoredTokenBalance(underlyingToken.tokenAddress, oldUnderlyingBalance, newUnderlyingBalance);\n        }\n    }\n\n    /// @notice Executes deposits to an external lending protocol. Only called during a rebalance executed\n    /// by the TreasuryAction contract.\n    function executeDeposits(Token memory underlyingToken, DepositData[] memory deposits) internal {\n        for (uint256 i; i < deposits.length; i++) {\n            DepositData memory depositData = deposits[i];\n            // Measure the token balance change if the `assetToken` value is set in the\n            // current deposit data struct.\n            uint256 oldAssetBalance = IERC20(depositData.assetToken).balanceOf(address(this));\n\n            // Measure the underlying balance change before and after the call.\n            uint256 oldUnderlyingBalance = underlyingToken.balanceOf(address(this));\n\n            for (uint256 j; j < depositData.targets.length; ++j) {\n                GenericToken.executeLowLevelCall(\n                    depositData.targets[j],\n                    depositData.msgValue[j],\n                    depositData.callData[j]\n                );\n            }\n\n            // Ensure that the underlying balance change matches the deposit amount\n            uint256 newUnderlyingBalance = underlyingToken.balanceOf(address(this));\n            uint256 underlyingBalanceChange = oldUnderlyingBalance.sub(newUnderlyingBalance);\n            // Ensure that only the specified amount of underlying has left the protocol\n            require(underlyingBalanceChange <= depositData.underlyingDepositAmount);\n\n            // Measure and update the asset token\n            uint256 newAssetBalance = IERC20(depositData.assetToken).balanceOf(address(this));\n            require(oldAssetBalance <= newAssetBalance);\n\n            if (\n                (depositData.rebasingTokenBalanceAdjustment != 0) &&\n                // This equation only makes sense when the \"asset token\" is a rebasing token\n                // in the same denomination as the underlying token. This will only be reached\n                // if the rebasingTokenBalanceAdjustment is set to a non-zero value\n                (underlyingBalanceChange != newAssetBalance.sub(oldAssetBalance))\n            ) {\n                newAssetBalance = newAssetBalance.add(depositData.rebasingTokenBalanceAdjustment);\n            }\n\n            TokenHandler.updateStoredTokenBalance(depositData.assetToken, oldAssetBalance, newAssetBalance);\n            TokenHandler.updateStoredTokenBalance(\n                underlyingToken.tokenAddress, oldUnderlyingBalance, newUnderlyingBalance\n            );\n        }\n    }\n\n}"
    }
  ]
}