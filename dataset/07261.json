{
  "Title": "[H-15] Wrong starting price when listing on Seaport for assets that has less than 18 decimals",
  "Content": "\nAccording to Astaria's docs: <br><https://docs.astaria.xyz/docs/protocol-mechanics/loanterms>\n\n> Liquidation initial ask: Should the NFT go into liquidation, the initial price of the auction will be set to this value. Note that this set as a starting point for a dutch auction, and the price will decrease over the liquidation period. This figure is should also be specified in 10^18 format.\n\nThe liquidation initial ask is specified in 18 decimals. This is then used as a starting price when the NFT goes under auction on OpenSea. However, if the asset has less than 18 decimals, then the starting price goes wrong to Seaport.\n\nThis results in listing the NFT with too high price that makes it unlikely to be sold.\n\n### Proof of Concept\n\nThe starting price is set to the liquidation initial ask:\n\n```sh\n    listedOrder = s.COLLATERAL_TOKEN.auctionVault(\n      ICollateralToken.AuctionVaultParams({\n        settlementToken: stack[position].lien.token,\n        collateralId: stack[position].lien.collateralId,\n        maxDuration: auctionWindowMax,\n        startingPrice: stack[0].lien.details.liquidationInitialAsk,\n        endingPrice: 1_000 wei\n      })\n    );\n```\n\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/AstariaRouter.sol#L639-L647>\n\nLet's assume the asset is USDC which has 6 decimals:\n\n1.  Strategist signs a strategy with liquidationInitialAsk **1000e18**.\n2.  Following the docs, this means the starting price is supposed to be **1000** USDC\n3.  The NFT is being liquidated\n4.  1000e18 is passed to Seaport along with asset USDC\n5.  Seaport lists the NFT, and the price will be too high as1000e18 will be **1000000000000000** USDC\n\n### Recommended Mitigation Steps\n\n1.  Either fetch the asset's decimals on-chain or add it as a part of the strategy.\n2.  Convert liquidationInitialAsk to the asset's decimals before passing it as a starting price.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/235)**\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-01-astaria",
  "Code": [
    {
      "filename": "src/AstariaRouter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\nimport {Authority} from \"solmate/auth/Auth.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {ITransferProxy} from \"core/interfaces/ITransferProxy.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\nimport {\n  ClonesWithImmutableArgs\n} from \"clones-with-immutable-args/ClonesWithImmutableArgs.sol\";\n\nimport {CollateralLookup} from \"core/libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"core/interfaces/ICollateralToken.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {IVaultImplementation} from \"core/interfaces/IVaultImplementation.sol\";\nimport {IAstariaVaultBase} from \"core/interfaces/IAstariaVaultBase.sol\";\nimport {IStrategyValidator} from \"core/interfaces/IStrategyValidator.sol\";\n\nimport {MerkleProofLib} from \"core/utils/MerkleProofLib.sol\";\nimport {Pausable} from \"core/utils/Pausable.sol\";\nimport {IERC4626} from \"core/interfaces/IERC4626.sol\";\nimport {ERC4626Router} from \"gpl/ERC4626Router.sol\";\nimport {IPublicVault} from \"core/interfaces/IPublicVault.sol\";\nimport {OrderParameters} from \"seaport/lib/ConsiderationStructs.sol\";\nimport {AuthInitializable} from \"core/AuthInitializable.sol\";\nimport {Initializable} from \"./utils/Initializable.sol\";\n\n/**\n * @title AstariaRouter\n * @notice This contract manages the deployment of Vaults and universal Astaria actions.\n */\ncontract AstariaRouter is\n  AuthInitializable,\n  Initializable,\n  ERC4626Router,\n  Pausable,\n  IAstariaRouter\n{\n  using SafeTransferLib for ERC20;\n  using SafeCastLib for uint256;\n  using CollateralLookup for address;\n  using FixedPointMathLib for uint256;\n\n  uint256 private constant ROUTER_SLOT =\n    uint256(keccak256(\"xyz.astaria.AstariaRouter.storage.location\")) - 1;\n\n  // cast --to-bytes32 $(cast sig \"OutOfBoundError()\")\n  uint256 private constant OUTOFBOUND_ERROR_SELECTOR =\n    0x571e08d100000000000000000000000000000000000000000000000000000000;\n  uint256 private constant ONE_WORD = 0x20;\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @dev Setup transfer authority and set up addresses for deployed CollateralToken, LienToken, TransferProxy contracts, as well as PublicVault and SoloVault implementations to clone.\n   * @param _AUTHORITY The authority manager.\n   * @param _COLLATERAL_TOKEN The address of the deployed CollateralToken contract.\n   * @param _LIEN_TOKEN The address of the deployed LienToken contract.\n   * @param _TRANSFER_PROXY The address of the deployed TransferProxy contract.\n   * @param _VAULT_IMPL The address of a base implementation of VaultImplementation for cloning.\n   * @param _SOLO_IMPL The address of a base implementation of a PrivateVault for cloning.\n   */\n  function initialize(\n    Authority _AUTHORITY,\n    ICollateralToken _COLLATERAL_TOKEN,\n    ILienToken _LIEN_TOKEN,\n    ITransferProxy _TRANSFER_PROXY,\n    address _VAULT_IMPL,\n    address _SOLO_IMPL,\n    address _WITHDRAW_IMPL,\n    address _BEACON_PROXY_IMPL,\n    address _CLEARING_HOUSE_IMPL\n  ) external initializer {\n    __initAuth(msg.sender, address(_AUTHORITY));\n    RouterStorage storage s = _loadRouterSlot();\n\n    s.COLLATERAL_TOKEN = _COLLATERAL_TOKEN;\n    s.LIEN_TOKEN = _LIEN_TOKEN;\n    s.TRANSFER_PROXY = _TRANSFER_PROXY;\n    s.implementations[uint8(ImplementationType.PrivateVault)] = _SOLO_IMPL;\n    s.implementations[uint8(ImplementationType.PublicVault)] = _VAULT_IMPL;\n    s.implementations[uint8(ImplementationType.WithdrawProxy)] = _WITHDRAW_IMPL;\n    s.implementations[\n      uint8(ImplementationType.ClearingHouse)\n    ] = _CLEARING_HOUSE_IMPL;\n    s.BEACON_PROXY_IMPLEMENTATION = _BEACON_PROXY_IMPL;\n    s.auctionWindow = uint32(2 days);\n    s.auctionWindowBuffer = uint32(1 days);\n\n    s.liquidationFeeNumerator = uint32(130);\n    s.liquidationFeeDenominator = uint32(1000);\n    s.minInterestBPS = uint32((uint256(1e15) * 5) / (365 days));\n    s.minEpochLength = uint32(7 days);\n    s.maxEpochLength = uint32(45 days);\n    s.maxInterestRate = ((uint256(1e16) * 200) / (365 days)).safeCastTo88();\n    //63419583966; // 200% apy / second\n    s.buyoutFeeNumerator = uint32(100);\n    s.buyoutFeeDenominator = uint32(1000);\n    s.minDurationIncrease = uint32(5 days);\n    s.guardian = msg.sender;\n  }\n\n  function mint(\n    IERC4626 vault,\n    address to,\n    uint256 shares,\n    uint256 maxAmountIn\n  )\n    public\n    payable\n    virtual\n    override\n    validVault(address(vault))\n    returns (uint256 amountIn)\n  {\n    return super.mint(vault, to, shares, maxAmountIn);\n  }\n\n  function deposit(\n    IERC4626 vault,\n    address to,\n    uint256 amount,\n    uint256 minSharesOut\n  )\n    public\n    payable\n    virtual\n    override\n    validVault(address(vault))\n    returns (uint256 sharesOut)\n  {\n    return super.deposit(vault, to, amount, minSharesOut);\n  }\n\n  function withdraw(\n    IERC4626 vault,\n    address to,\n    uint256 amount,\n    uint256 maxSharesOut\n  )\n    public\n    payable\n    virtual\n    override\n    validVault(address(vault))\n    returns (uint256 sharesOut)\n  {\n    return super.withdraw(vault, to, amount, maxSharesOut);\n  }\n\n  function redeem(\n    IERC4626 vault,\n    address to,\n    uint256 shares,\n    uint256 minAmountOut\n  )\n    public\n    payable\n    virtual\n    override\n    validVault(address(vault))\n    returns (uint256 amountOut)\n  {\n    return super.redeem(vault, to, shares, minAmountOut);\n  }\n\n  function redeemFutureEpoch(\n    IPublicVault vault,\n    uint256 shares,\n    address receiver,\n    uint64 epoch\n  ) public virtual validVault(address(vault)) returns (uint256 assets) {\n    return vault.redeemFutureEpoch(shares, receiver, msg.sender, epoch);\n  }\n\n  modifier validVault(address targetVault) {\n    if (!isValidVault(targetVault)) {\n      revert InvalidVault(targetVault);\n    }\n    _;\n  }\n\n  function pullToken(\n    address token,\n    uint256 amount,\n    address recipient\n  ) public payable override {\n    RouterStorage storage s = _loadRouterSlot();\n    s.TRANSFER_PROXY.tokenTransferFrom(\n      address(token),\n      msg.sender,\n      recipient,\n      amount\n    );\n  }\n\n  function _loadRouterSlot() internal pure returns (RouterStorage storage rs) {\n    uint256 slot = ROUTER_SLOT;\n    assembly {\n      rs.slot := slot\n    }\n  }\n\n  function feeTo() public view returns (address) {\n    RouterStorage storage s = _loadRouterSlot();\n    return s.feeTo;\n  }\n\n  function BEACON_PROXY_IMPLEMENTATION() public view returns (address) {\n    RouterStorage storage s = _loadRouterSlot();\n    return s.BEACON_PROXY_IMPLEMENTATION;\n  }\n\n  function LIEN_TOKEN() public view returns (ILienToken) {\n    RouterStorage storage s = _loadRouterSlot();\n    return s.LIEN_TOKEN;\n  }\n\n  function TRANSFER_PROXY() public view returns (ITransferProxy) {\n    RouterStorage storage s = _loadRouterSlot();\n    return s.TRANSFER_PROXY;\n  }\n\n  function COLLATERAL_TOKEN() public view returns (ICollateralToken) {\n    RouterStorage storage s = _loadRouterSlot();\n    return s.COLLATERAL_TOKEN;\n  }\n\n  /**\n   * @dev Enables _pause, freezing functions with the whenNotPaused modifier.\n   */\n  function __emergencyPause() external requiresAuth whenNotPaused {\n    _pause();\n  }\n\n  /**\n   * @dev Disables _pause, un-freezing functions with the whenNotPaused modifier.\n   */\n  function __emergencyUnpause() external requiresAuth whenPaused {\n    _unpause();\n  }\n\n  function fileBatch(File[] calldata files) external requiresAuth {\n    uint256 i;\n    for (; i < files.length; ) {\n      _file(files[i]);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function file(File calldata incoming) public requiresAuth {\n    _file(incoming);\n  }\n\n  function _file(File calldata incoming) internal {\n    RouterStorage storage s = _loadRouterSlot();\n    FileType what = incoming.what;\n    bytes memory data = incoming.data;\n    if (what == FileType.AuctionWindow) {\n      (uint256 window, uint256 windowBuffer) = abi.decode(\n        data,\n        (uint256, uint256)\n      );\n      s.auctionWindow = window.safeCastTo32();\n      s.auctionWindowBuffer = windowBuffer.safeCastTo32();\n    } else if (what == FileType.LiquidationFee) {\n      (uint256 numerator, uint256 denominator) = abi.decode(\n        data,\n        (uint256, uint256)\n      );\n      if (denominator < numerator) revert InvalidFileData();\n      s.liquidationFeeNumerator = numerator.safeCastTo32();\n      s.liquidationFeeDenominator = denominator.safeCastTo32();\n    } else if (what == FileType.ProtocolFee) {\n      (uint256 numerator, uint256 denominator) = abi.decode(\n        data,\n        (uint256, uint256)\n      );\n      if (denominator < numerator) revert InvalidFileData();\n      s.protocolFeeNumerator = numerator.safeCastTo32();\n      s.protocolFeeDenominator = denominator.safeCastTo32();\n    } else if (what == FileType.BuyoutFee) {\n      (uint256 numerator, uint256 denominator) = abi.decode(\n        data,\n        (uint256, uint256)\n      );\n      if (denominator < numerator) revert InvalidFileData();\n      s.buyoutFeeNumerator = numerator.safeCastTo32();\n      s.buyoutFeeDenominator = denominator.safeCastTo32();\n    } else if (what == FileType.MinInterestBPS) {\n      uint256 value = abi.decode(data, (uint256));\n      s.minInterestBPS = value.safeCastTo32();\n    } else if (what == FileType.MinDurationIncrease) {\n      uint256 value = abi.decode(data, (uint256));\n      s.minDurationIncrease = value.safeCastTo32();\n    } else if (what == FileType.MinEpochLength) {\n      s.minEpochLength = abi.decode(data, (uint256)).safeCastTo32();\n    } else if (what == FileType.MaxEpochLength) {\n      s.maxEpochLength = abi.decode(data, (uint256)).safeCastTo32();\n    } else if (what == FileType.MaxInterestRate) {\n      s.maxInterestRate = abi.decode(data, (uint256)).safeCastTo88();\n    } else if (what == FileType.FeeTo) {\n      address addr = abi.decode(data, (address));\n      if (addr == address(0)) revert InvalidFileData();\n      s.feeTo = addr;\n    } else if (what == FileType.StrategyValidator) {\n      (uint8 TYPE, address addr) = abi.decode(data, (uint8, address));\n      if (addr == address(0)) revert InvalidFileData();\n      s.strategyValidators[TYPE] = addr;\n    } else {\n      revert UnsupportedFile();\n    }\n\n    emit FileUpdated(what, data);\n  }\n\n  function setNewGuardian(address _guardian) external {\n    RouterStorage storage s = _loadRouterSlot();\n    require(msg.sender == s.guardian);\n    s.newGuardian = _guardian;\n  }\n\n  function __renounceGuardian() external {\n    RouterStorage storage s = _loadRouterSlot();\n    require(msg.sender == s.guardian);\n    s.guardian = address(0);\n    s.newGuardian = address(0);\n  }\n\n  function __acceptGuardian() external {\n    RouterStorage storage s = _loadRouterSlot();\n    require(msg.sender == s.newGuardian);\n    s.guardian = s.newGuardian;\n    delete s.newGuardian;\n  }\n\n  function fileGuardian(File[] calldata file) external {\n    RouterStorage storage s = _loadRouterSlot();\n    require(msg.sender == address(s.guardian));\n\n    uint256 i;\n    for (; i < file.length; ) {\n      FileType what = file[i].what;\n      bytes memory data = file[i].data;\n      if (what == FileType.Implementation) {\n        (uint8 implType, address addr) = abi.decode(data, (uint8, address));\n        if (addr == address(0)) revert InvalidFileData();\n        s.implementations[implType] = addr;\n      } else if (what == FileType.CollateralToken) {\n        address addr = abi.decode(data, (address));\n        if (addr == address(0)) revert InvalidFileData();\n        s.COLLATERAL_TOKEN = ICollateralToken(addr);\n      } else if (what == FileType.LienToken) {\n        address addr = abi.decode(data, (address));\n        if (addr == address(0)) revert InvalidFileData();\n        s.LIEN_TOKEN = ILienToken(addr);\n      } else if (what == FileType.TransferProxy) {\n        address addr = abi.decode(data, (address));\n        if (addr == address(0)) revert InvalidFileData();\n        s.TRANSFER_PROXY = ITransferProxy(addr);\n      } else {\n        revert UnsupportedFile();\n      }\n      emit FileUpdated(what, data);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  //PUBLIC\n\n  function getImpl(uint8 implType) external view returns (address impl) {\n    impl = _loadRouterSlot().implementations[implType];\n    if (impl == address(0)) {\n      revert(\"unsupported/impl\");\n    }\n  }\n\n  function getAuctionWindow(bool includeBuffer) public view returns (uint256) {\n    RouterStorage storage s = _loadRouterSlot();\n    return s.auctionWindow + (includeBuffer ? s.auctionWindowBuffer : 0);\n  }\n\n  function _sliceUint(bytes memory bs, uint256 start)\n    internal\n    pure\n    returns (uint256 x)\n  {\n    uint256 length = bs.length;\n\n    assembly {\n      let end := add(ONE_WORD, start)\n\n      if lt(length, end) {\n        mstore(0, OUTOFBOUND_ERROR_SELECTOR)\n        revert(0, ONE_WORD)\n      }\n\n      x := mload(add(bs, end))\n    }\n  }\n\n  function validateCommitment(\n    IAstariaRouter.Commitment calldata commitment,\n    uint256 timeToSecondEpochEnd\n  ) public view returns (ILienToken.Lien memory lien) {\n    return\n      _validateCommitment(_loadRouterSlot(), commitment, timeToSecondEpochEnd);\n  }\n\n  function _validateCommitment(\n    RouterStorage storage s,\n    IAstariaRouter.Commitment calldata commitment,\n    uint256 timeToSecondEpochEnd\n  ) internal view returns (ILienToken.Lien memory lien) {\n    if (block.timestamp > commitment.lienRequest.strategy.deadline) {\n      revert InvalidCommitmentState(CommitmentState.EXPIRED);\n    }\n    uint8 nlrType = uint8(_sliceUint(commitment.lienRequest.nlrDetails, 0));\n    address strategyValidator = s.strategyValidators[nlrType];\n    if (strategyValidator == address(0)) {\n      revert InvalidStrategy(nlrType);\n    }\n    (bytes32 leaf, ILienToken.Details memory details) = IStrategyValidator(\n      strategyValidator\n    ).validateAndParse(\n        commitment.lienRequest,\n        s.COLLATERAL_TOKEN.ownerOf(\n          commitment.tokenContract.computeId(commitment.tokenId)\n        ),\n        commitment.tokenContract,\n        commitment.tokenId\n      );\n\n    if (details.rate == uint256(0) || details.rate > s.maxInterestRate) {\n      revert InvalidCommitmentState(CommitmentState.INVALID_RATE);\n    }\n\n    if (details.maxAmount < commitment.lienRequest.amount) {\n      revert InvalidCommitmentState(CommitmentState.INVALID_AMOUNT);\n    }\n\n    if (\n      !MerkleProofLib.verify(\n        commitment.lienRequest.merkle.proof,\n        commitment.lienRequest.merkle.root,\n        leaf\n      )\n    ) {\n      revert InvalidCommitmentState(CommitmentState.INVALID);\n    }\n\n    if (timeToSecondEpochEnd > 0 && details.duration > timeToSecondEpochEnd) {\n      details.duration = timeToSecondEpochEnd;\n    }\n\n    lien = ILienToken.Lien({\n      collateralType: nlrType,\n      details: details,\n      strategyRoot: commitment.lienRequest.merkle.root,\n      collateralId: commitment.tokenContract.computeId(commitment.tokenId),\n      vault: commitment.lienRequest.strategy.vault,\n      token: IAstariaVaultBase(commitment.lienRequest.strategy.vault).asset()\n    });\n  }\n\n  function commitToLiens(IAstariaRouter.Commitment[] memory commitments)\n    public\n    whenNotPaused\n    returns (uint256[] memory lienIds, ILienToken.Stack[] memory stack)\n  {\n    RouterStorage storage s = _loadRouterSlot();\n\n    uint256 totalBorrowed;\n    lienIds = new uint256[](commitments.length);\n    _transferAndDepositAssetIfAble(\n      s,\n      commitments[0].tokenContract,\n      commitments[0].tokenId\n    );\n\n    uint256 i;\n    for (; i < commitments.length; ) {\n      if (i != 0) {\n        commitments[i].lienRequest.stack = stack;\n      }\n      uint256 payout;\n      (lienIds[i], stack, payout) = _executeCommitment(s, commitments[i]);\n      totalBorrowed += payout;\n      unchecked {\n        ++i;\n      }\n    }\n\n    ERC20(IAstariaVaultBase(commitments[0].lienRequest.strategy.vault).asset())\n      .safeTransfer(msg.sender, totalBorrowed);\n  }\n\n  function newVault(address delegate, address underlying)\n    external\n    whenNotPaused\n    returns (address)\n  {\n    address[] memory allowList = new address[](1);\n    allowList[0] = msg.sender;\n    RouterStorage storage s = _loadRouterSlot();\n\n    return\n      _newVault(\n        s,\n        underlying,\n        uint256(0),\n        delegate,\n        uint256(0),\n        true,\n        allowList,\n        uint256(0)\n      );\n  }\n\n  function newPublicVault(\n    uint256 epochLength,\n    address delegate,\n    address underlying,\n    uint256 vaultFee,\n    bool allowListEnabled,\n    address[] calldata allowList,\n    uint256 depositCap\n  ) public whenNotPaused returns (address) {\n    RouterStorage storage s = _loadRouterSlot();\n    if (s.minEpochLength > epochLength) {\n      revert IPublicVault.InvalidState(\n        IPublicVault.InvalidStates.EPOCH_TOO_LOW\n      );\n    }\n    if (s.maxEpochLength < epochLength) {\n      revert IPublicVault.InvalidState(\n        IPublicVault.InvalidStates.EPOCH_TOO_HIGH\n      );\n    }\n    return\n      _newVault(\n        s,\n        underlying,\n        epochLength,\n        delegate,\n        vaultFee,\n        allowListEnabled,\n        allowList,\n        depositCap\n      );\n  }\n\n  function requestLienPosition(\n    IAstariaRouter.Commitment calldata params,\n    address receiver\n  )\n    external\n    whenNotPaused\n    validVault(msg.sender)\n    returns (\n      uint256,\n      ILienToken.Stack[] memory,\n      uint256\n    )\n  {\n    RouterStorage storage s = _loadRouterSlot();\n\n    return\n      s.LIEN_TOKEN.createLien(\n        ILienToken.LienActionEncumber({\n          lien: _validateCommitment({\n            s: s,\n            commitment: params,\n            timeToSecondEpochEnd: IPublicVault(msg.sender).supportsInterface(\n              type(IPublicVault).interfaceId\n            )\n              ? IPublicVault(msg.sender).timeToSecondEpochEnd()\n              : 0\n          }),\n          amount: params.lienRequest.amount,\n          stack: params.lienRequest.stack,\n          receiver: receiver\n        })\n      );\n  }\n\n  function canLiquidate(ILienToken.Stack memory stack)\n    public\n    view\n    returns (bool)\n  {\n    RouterStorage storage s = _loadRouterSlot();\n    return (stack.point.end <= block.timestamp ||\n      msg.sender == s.COLLATERAL_TOKEN.ownerOf(stack.lien.collateralId));\n  }\n\n  function liquidate(ILienToken.Stack[] memory stack, uint8 position)\n    public\n    returns (OrderParameters memory listedOrder)\n  {\n    if (!canLiquidate(stack[position])) {\n      revert InvalidLienState(LienState.HEALTHY);\n    }\n\n    RouterStorage storage s = _loadRouterSlot();\n    uint256 auctionWindowMax = s.auctionWindow + s.auctionWindowBuffer;\n\n    s.LIEN_TOKEN.stopLiens(\n      stack[position].lien.collateralId,\n      auctionWindowMax,\n      stack,\n      msg.sender\n    );\n    emit Liquidation(stack[position].lien.collateralId, position);\n    listedOrder = s.COLLATERAL_TOKEN.auctionVault(\n      ICollateralToken.AuctionVaultParams({\n        settlementToken: stack[position].lien.token,\n        collateralId: stack[position].lien.collateralId,\n        maxDuration: auctionWindowMax,\n        startingPrice: stack[0].lien.details.liquidationInitialAsk,\n        endingPrice: 1_000 wei\n      })\n    );\n  }\n\n  function getProtocolFee(uint256 amountIn) external view returns (uint256) {\n    RouterStorage storage s = _loadRouterSlot();\n\n    return\n      amountIn.mulDivDown(s.protocolFeeNumerator, s.protocolFeeDenominator);\n  }\n\n  function getLiquidatorFee(uint256 amountIn) external view returns (uint256) {\n    RouterStorage storage s = _loadRouterSlot();\n\n    return\n      amountIn.mulDivDown(\n        s.liquidationFeeNumerator,\n        s.liquidationFeeDenominator\n      );\n  }\n\n  function getBuyoutFee(uint256 remainingInterestIn)\n    external\n    view\n    returns (uint256)\n  {\n    RouterStorage storage s = _loadRouterSlot();\n    return\n      remainingInterestIn.mulDivDown(\n        s.buyoutFeeNumerator,\n        s.buyoutFeeDenominator\n      );\n  }\n\n  function isValidVault(address vault) public view returns (bool) {\n    return _loadRouterSlot().vaults[vault];\n  }\n\n  function isValidRefinance(\n    ILienToken.Lien calldata newLien,\n    uint8 position,\n    ILienToken.Stack[] calldata stack\n  ) public view returns (bool) {\n    RouterStorage storage s = _loadRouterSlot();\n    uint256 maxNewRate = uint256(stack[position].lien.details.rate) -\n      s.minInterestBPS;\n\n    if (newLien.collateralId != stack[0].lien.collateralId) {\n      revert InvalidRefinanceCollateral(newLien.collateralId);\n    }\n    return\n      (newLien.details.rate <= maxNewRate &&\n        newLien.details.duration + block.timestamp >=\n        stack[position].point.end) ||\n      (block.timestamp + newLien.details.duration - stack[position].point.end >=\n        s.minDurationIncrease &&\n        newLien.details.rate <= stack[position].lien.details.rate);\n  }\n\n  /**\n   * @dev Deploys a new Vault.\n   * @param epochLength The length of each epoch for a new PublicVault. If 0, deploys a PrivateVault.\n   * @param delegate The address of the Vault delegate.\n   * @param allowListEnabled Whether or not the Vault has an LP whitelist.\n   * @return vaultAddr The address for the new Vault.\n   */\n  function _newVault(\n    RouterStorage storage s,\n    address underlying,\n    uint256 epochLength,\n    address delegate,\n    uint256 vaultFee,\n    bool allowListEnabled,\n    address[] memory allowList,\n    uint256 depositCap\n  ) internal returns (address vaultAddr) {\n    uint8 vaultType;\n\n    if (epochLength > uint256(0)) {\n      vaultType = uint8(ImplementationType.PublicVault);\n    } else {\n      vaultType = uint8(ImplementationType.PrivateVault);\n    }\n\n    //immutable data\n    vaultAddr = ClonesWithImmutableArgs.clone(\n      s.BEACON_PROXY_IMPLEMENTATION,\n      abi.encodePacked(\n        address(this),\n        vaultType,\n        msg.sender,\n        underlying,\n        block.timestamp,\n        epochLength,\n        vaultFee\n      )\n    );\n\n    //mutable data\n    IVaultImplementation(vaultAddr).init(\n      IVaultImplementation.InitParams({\n        delegate: delegate,\n        allowListEnabled: allowListEnabled,\n        allowList: allowList,\n        depositCap: depositCap\n      })\n    );\n\n    s.vaults[vaultAddr] = true;\n\n    emit NewVault(msg.sender, delegate, vaultAddr, vaultType);\n\n    return vaultAddr;\n  }\n\n  function _executeCommitment(\n    RouterStorage storage s,\n    IAstariaRouter.Commitment memory c\n  )\n    internal\n    returns (\n      uint256,\n      ILienToken.Stack[] memory stack,\n      uint256 payout\n    )\n  {\n    uint256 collateralId = c.tokenContract.computeId(c.tokenId);\n\n    if (msg.sender != s.COLLATERAL_TOKEN.ownerOf(collateralId)) {\n      revert InvalidSenderForCollateral(msg.sender, collateralId);\n    }\n    if (!s.vaults[c.lienRequest.strategy.vault]) {\n      revert InvalidVault(c.lienRequest.strategy.vault);\n    }\n    //router must be approved for the collateral to take a loan,\n    return\n      IVaultImplementation(c.lienRequest.strategy.vault).commitToLien(\n        c,\n        address(this)\n      );\n  }\n\n  function _transferAndDepositAssetIfAble(\n    RouterStorage storage s,\n    address tokenContract,\n    uint256 tokenId\n  ) internal {\n    ERC721 token = ERC721(tokenContract);\n    if (token.ownerOf(tokenId) == msg.sender) {\n      token.safeTransferFrom(\n        msg.sender,\n        address(s.COLLATERAL_TOKEN),\n        tokenId,\n        \"\"\n      );\n    }\n  }\n}"
    }
  ]
}