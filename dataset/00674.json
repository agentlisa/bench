{
  "Title": "No kick motivation in case of many little locks",
  "Content": "##### Description\n\nA `kick()` caller receives a kickPenalty which is `voteLocks[].amount * 10%`.\n\n- https://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/tokenomics/CNCLockerV2.sol#L342\n\nIf this reward does not exceed the gas cost, no one would have the motivation to call `kick()`. It is possible when `voteLocks[].amount` is small enough.\n\nSo, users are motivated to make many smaller locks to protect their locks from kicking.\n\n##### Recommendation\n\nWe recommend introducing a function of kicking many expired voteLocks in one call.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/tokenomics/CNCLockerV2.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../../libraries/ScaledMath.sol\";\nimport \"../../interfaces/tokenomics/ICNCLockerV2.sol\";\nimport \"../../interfaces/tokenomics/ICNCToken.sol\";\nimport \"../../interfaces/tokenomics/ICNCVoteLocker.sol\";\nimport \"../../interfaces/IController.sol\";\n\ncontract CNCLockerV2 is ICNCLockerV2, Ownable {\n    using SafeERC20 for ICNCToken;\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using ScaledMath for uint128;\n    using MerkleProof for MerkleProof.Proof;\n\n    address public constant V1_LOCKER = address(0x3F41480DD3b32F1cC579125F9570DCcD07E07667);\n\n    uint128 internal constant _MIN_LOCK_TIME = 120 days;\n    uint128 internal constant _MAX_LOCK_TIME = 240 days;\n    uint128 internal constant _GRACE_PERIOD = 28 days;\n    uint128 internal constant _MIN_BOOST = 1e18;\n    uint128 internal constant _MAX_BOOST = 1.5e18;\n    uint128 internal constant _KICK_PENALTY = 1e17;\n    uint256 internal constant _MAX_KICK_PENALTY_AMOUNT = 1000e18;\n    uint128 constant _AIRDROP_DURATION = 182 days;\n    uint256 internal constant _MAX_AIRDROP_BOOST = 3.5e18;\n\n    ICNCToken public immutable cncToken;\n\n    // Boost data\n    mapping(address => uint256) public lockedBalance;\n    mapping(address => uint256) public lockedBoosted;\n    mapping(address => VoteLock[]) public voteLocks;\n    mapping(address => uint256) internal _airdroppedBoost;\n    mapping(address => bool) public override claimedAirdrop;\n    uint64 internal _nextId;\n    uint256 public immutable airdropEndTime;\n    bytes32 public immutable merkleRoot;\n    uint256 public totalLocked;\n    uint256 public totalBoosted;\n    bool public isShutdown;\n\n    // Fee data\n    IERC20 public immutable crv;\n    IERC20 public immutable cvx;\n    uint256 public accruedFeesIntegralCrv;\n    uint256 public accruedFeesIntegralCvx;\n    mapping(address => uint256) public perAccountAccruedCrv;\n    mapping(address => uint256) public perAccountFeesCrv;\n    mapping(address => uint256) public perAccountAccruedCvx;\n    mapping(address => uint256) public perAccountFeesCvx;\n\n    address public immutable treasury;\n    IController public immutable controller;\n\n    constructor(\n        address _controller,\n        address _cncToken,\n        address _treasury,\n        address _crv,\n        address _cvx,\n        bytes32 _merkleRoot\n    ) Ownable() {\n        controller = IController(_controller);\n        cncToken = ICNCToken(_cncToken);\n        treasury = _treasury;\n        crv = IERC20(_crv);\n        cvx = IERC20(_cvx);\n        airdropEndTime = block.timestamp + _AIRDROP_DURATION;\n        merkleRoot = _merkleRoot;\n    }\n\n    function lock(uint256 amount, uint64 lockTime) external override {\n        lock(amount, lockTime, false);\n    }\n\n    /// @notice Lock an amount of CNC for vlCNC.\n    /// @param amount Amount of CNC to lock.\n    /// @param lockTime Duration of the lock.\n    /// @param relock_ `True` if this is a relock of an existing lock.\n    function lock(uint256 amount, uint64 lockTime, bool relock_) public override {\n        lockFor(amount, lockTime, relock_, msg.sender);\n    }\n\n    /// @notice Lock an amount of CNC for vlCNC.\n    /// @param amount Amount of CNC to lock.\n    /// @param lockTime Duration of the lock.\n    /// @param relock_ `True` if this is a relock of all existing locks.\n    /// @param account The account to receive the vlCNC.\n    function lockFor(\n        uint256 amount,\n        uint64 lockTime,\n        bool relock_,\n        address account\n    ) public override {\n        require(!isShutdown, \"locker suspended\");\n        require((_MIN_LOCK_TIME <= lockTime) && (lockTime <= _MAX_LOCK_TIME), \"lock time invalid\");\n        require(!relock_ || msg.sender == account, \"relock only for self\");\n        _feeCheckpoint(account);\n        cncToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        uint128 boost = computeBoost(lockTime);\n\n        uint256 airdropBoost_ = airdropBoost(msg.sender);\n        if (airdropBoost_ > 1e18) {\n            claimedAirdrop[msg.sender] = true;\n            boost = boost.mulDownUint128(uint128(airdropBoost_));\n            delete _airdroppedBoost[msg.sender];\n        }\n\n        uint64 unlockTime = uint64(block.timestamp) + lockTime;\n        uint256 boostedAmount;\n\n        if (relock_) {\n            uint256 length = voteLocks[account].length;\n            for (uint256 i; i < length; i++) {\n                require(\n                    voteLocks[account][i].unlockTime < unlockTime,\n                    \"cannot move the unlock time up\"\n                );\n            }\n            delete voteLocks[account];\n            totalBoosted -= lockedBoosted[account];\n            lockedBoosted[account] = 0;\n            _addVoteLock(account, lockedBalance[account] + amount, unlockTime, boost);\n            boostedAmount = (lockedBalance[account] + amount).mulDown(uint256(boost));\n        } else {\n            _addVoteLock(account, amount, unlockTime, boost);\n            boostedAmount = amount.mulDown(boost);\n        }\n        totalLocked += amount;\n        totalBoosted += boostedAmount;\n        lockedBalance[account] += amount;\n        lockedBoosted[account] += boostedAmount;\n        emit Locked(account, amount, unlockTime, relock_);\n    }\n\n    /// @notice Process all expired locks of msg.sender and withdraw unlocked CNC.\n    function executeAvailableUnlocks() external override returns (uint256) {\n        return executeAvailableUnlocksFor(msg.sender);\n    }\n\n    /// @notice Process all expired locks of msg.sender and withdraw unlocked CNC to `dst`.\n    function executeAvailableUnlocksFor(address dst) public override returns (uint256) {\n        require(dst != address(0), \"invalid destination\");\n        _feeCheckpoint(msg.sender);\n        uint256 sumUnlockable;\n        uint256 sumBoosted;\n        VoteLock[] storage _pending = voteLocks[msg.sender];\n        uint256 i = _pending.length;\n        while (i > 0) {\n            i = i - 1;\n\n            if (isShutdown || _pending[i].unlockTime <= block.timestamp) {\n                sumUnlockable += _pending[i].amount;\n                sumBoosted += _pending[i].amount.mulDown(_pending[i].boost);\n                _pending[i] = _pending[_pending.length - 1];\n                _pending.pop();\n            }\n        }\n        totalLocked -= sumUnlockable;\n        totalBoosted -= sumBoosted;\n        lockedBalance[msg.sender] -= sumUnlockable;\n        lockedBoosted[msg.sender] -= sumBoosted;\n        cncToken.safeTransfer(dst, sumUnlockable);\n        emit UnlockExecuted(msg.sender, sumUnlockable);\n        return sumUnlockable;\n    }\n\n    /// @notice Process specified locks of msg.sender and withdraw unlocked CNC to `dst`.\n    /// @param dst Destination address to receive unlocked CNC.\n    /// @param lockIds Array of lock IDs to process.\n    /// @return unlocked Amount of CNC unlocked.\n    function executeUnlocks(\n        address dst,\n        uint64[] calldata lockIds\n    ) public override returns (uint256) {\n        _feeCheckpoint(msg.sender);\n        uint256 sumUnlockable;\n        uint256 sumBoosted;\n        VoteLock[] storage _pending = voteLocks[msg.sender];\n        for (uint256 idIndex; idIndex < lockIds.length; idIndex++) {\n            uint256 index = _getLockIndexById(msg.sender, lockIds[idIndex]);\n            require(\n                isShutdown || _pending[index].unlockTime <= block.timestamp,\n                \"lock not expired\"\n            );\n            sumUnlockable += _pending[index].amount;\n            sumBoosted += _pending[index].amount.mulDown(_pending[index].boost);\n            _pending[index] = _pending[_pending.length - 1];\n            _pending.pop();\n        }\n        totalLocked -= sumUnlockable;\n        totalBoosted -= sumBoosted;\n        lockedBalance[msg.sender] -= sumUnlockable;\n        lockedBoosted[msg.sender] -= sumBoosted;\n        cncToken.safeTransfer(dst, sumUnlockable);\n        emit UnlockExecuted(msg.sender, sumUnlockable);\n        return sumUnlockable;\n    }\n\n    /// @notice Get unlocked CNC balance for an address\n    /// @param user Address to get unlocked CNC balance for\n    /// @return Unlocked CNC balance\n    function unlockableBalance(address user) public view override returns (uint256) {\n        uint256 sumUnlockable = 0;\n        VoteLock[] storage _pending = voteLocks[user];\n        uint256 length = _pending.length;\n        for (uint256 i; i < length; i++) {\n            if (_pending[i].unlockTime <= uint128(block.timestamp)) {\n                sumUnlockable += _pending[i].amount;\n            }\n        }\n        return sumUnlockable;\n    }\n\n    /// @notice Get unlocked boosted CNC balance for an address\n    /// @param user Address to get unlocked boosted CNC balance for\n    /// @return Unlocked boosted CNC balance\n    function unlockableBalanceBoosted(address user) public view override returns (uint256) {\n        uint256 sumUnlockable = 0;\n        VoteLock[] storage _pending = voteLocks[user];\n        uint256 length = _pending.length;\n        for (uint256 i; i < length; i++) {\n            if (_pending[i].unlockTime <= uint128(block.timestamp)) {\n                sumUnlockable += _pending[i].amount.mulDown(_pending[i].boost);\n            }\n        }\n        return sumUnlockable;\n    }\n\n    function shutDown() external override onlyOwner {\n        require(!isShutdown, \"locker already suspended\");\n        isShutdown = true;\n        emit Shutdown();\n    }\n\n    function recoverToken(address token) external override {\n        require(\n            token != address(cncToken) && token != address(crv) && token != address(cvx),\n            \"cannot withdraw token\"\n        );\n        IERC20 _token = IERC20(token);\n        _token.safeTransfer(treasury, _token.balanceOf(address(this)));\n        emit TokenRecovered(token);\n    }\n\n    /// @notice Relock a specific lock\n    /// @dev Users locking CNC can create multiple locks therefore individual locks can be relocked separately.\n    /// @param lockId Id of the lock to relock.\n    /// @param lockTime Duration for which the locks's CNC amount should be relocked for.\n    function relock(uint64 lockId, uint64 lockTime) external override {\n        require(!isShutdown, \"locker suspended\");\n        require((_MIN_LOCK_TIME <= lockTime) && (lockTime <= _MAX_LOCK_TIME), \"lock time invalid\");\n        _feeCheckpoint(msg.sender);\n        _relock(lockId, lockTime);\n    }\n\n    /// @notice Relock specified locks\n    /// @param lockIds Ids of the locks to relock.\n    /// @param lockTime Duration for which the locks's CNC amount should be relocked for.\n    function relockMultiple(uint64[] calldata lockIds, uint64 lockTime) external override {\n        require(!isShutdown, \"locker suspended\");\n        require((_MIN_LOCK_TIME <= lockTime) && (lockTime <= _MAX_LOCK_TIME), \"lock time invalid\");\n        _feeCheckpoint(msg.sender);\n        for (uint256 i; i < lockIds.length; i++) {\n            _relock(lockIds[i], lockTime);\n        }\n    }\n\n    function _relock(uint64 lockId, uint64 lockTime) internal {\n        uint256 lockIndex = _getLockIndexById(msg.sender, lockId);\n\n        uint128 boost = computeBoost(lockTime);\n\n        uint64 unlockTime = uint64(block.timestamp) + lockTime;\n\n        VoteLock[] storage locks = voteLocks[msg.sender];\n        require(locks[lockIndex].unlockTime < unlockTime, \"cannot move the unlock time up\");\n        uint256 amount = locks[lockIndex].amount;\n        uint256 previousBoostedAmount = locks[lockIndex].amount.mulDown(locks[lockIndex].boost);\n        locks[lockIndex] = locks[locks.length - 1];\n        locks.pop();\n\n        _addVoteLock(msg.sender, amount, unlockTime, boost);\n        uint256 boostedAmount = amount.mulDown(boost);\n\n        totalBoosted = totalBoosted + boostedAmount - previousBoostedAmount;\n        lockedBoosted[msg.sender] =\n            lockedBoosted[msg.sender] +\n            boostedAmount -\n            previousBoostedAmount;\n\n        emit Relocked(msg.sender, amount);\n    }\n\n    function relock(uint64 lockTime) external override {\n        require(!isShutdown, \"locker suspended\");\n        require((_MIN_LOCK_TIME <= lockTime) && (lockTime <= _MAX_LOCK_TIME), \"lock time invalid\");\n        _feeCheckpoint(msg.sender);\n\n        uint128 boost = computeBoost(lockTime);\n\n        uint64 unlockTime = uint64(block.timestamp) + lockTime;\n\n        uint256 length = voteLocks[msg.sender].length;\n        for (uint256 i; i < length; i++) {\n            require(\n                voteLocks[msg.sender][i].unlockTime < unlockTime,\n                \"cannot move the unlock time up\"\n            );\n        }\n        delete voteLocks[msg.sender];\n        totalBoosted -= lockedBoosted[msg.sender];\n        lockedBoosted[msg.sender] = 0;\n        _addVoteLock(msg.sender, lockedBalance[msg.sender], unlockTime, boost);\n        uint256 boostedAmount = lockedBalance[msg.sender].mulDown(uint256(boost));\n        totalBoosted += boostedAmount;\n        lockedBoosted[msg.sender] += boostedAmount;\n        emit Relocked(msg.sender, lockedBalance[msg.sender]);\n    }\n\n    /// @notice Kick an expired lock\n    function kick(address user, uint64 lockId) external override {\n        uint256 lockIndex = _getLockIndexById(user, lockId);\n        VoteLock[] storage _pending = voteLocks[user];\n        require(\n            _pending[lockIndex].unlockTime + _GRACE_PERIOD <= uint128(block.timestamp),\n            \"cannot kick this lock\"\n        );\n        _feeCheckpoint(user);\n        uint256 amount = _pending[lockIndex].amount;\n        totalLocked -= amount;\n        totalBoosted -= amount.mulDown(_pending[lockIndex].boost);\n        lockedBalance[user] -= amount;\n        lockedBoosted[user] -= amount.mulDown(_pending[lockIndex].boost);\n        uint256 kickPenalty = amount.mulDown(_KICK_PENALTY);\n        if (kickPenalty > _MAX_KICK_PENALTY_AMOUNT) {\n            kickPenalty = _MAX_KICK_PENALTY_AMOUNT;\n        }\n        cncToken.safeTransfer(user, amount - kickPenalty);\n        cncToken.safeTransfer(msg.sender, kickPenalty);\n        emit KickExecuted(user, msg.sender, amount);\n        _pending[lockIndex] = _pending[_pending.length - 1];\n        _pending.pop();\n    }\n\n    function receiveFees(uint256 amountCrv, uint256 amountCvx) external override {\n        crv.safeTransferFrom(msg.sender, address(this), amountCrv);\n        cvx.safeTransferFrom(msg.sender, address(this), amountCvx);\n        accruedFeesIntegralCrv += amountCrv.divDown(totalBoosted);\n        accruedFeesIntegralCvx += amountCvx.divDown(totalBoosted);\n        emit FeesReceived(msg.sender, amountCrv, amountCvx);\n    }\n\n    function claimFees() external override returns (uint256 crvAmount, uint256 cvxAmount) {\n        _feeCheckpoint(msg.sender);\n        crvAmount = perAccountFeesCrv[msg.sender];\n        cvxAmount = perAccountFeesCvx[msg.sender];\n        crv.safeTransfer(msg.sender, crvAmount);\n        cvx.safeTransfer(msg.sender, cvxAmount);\n        perAccountFeesCrv[msg.sender] = 0;\n        perAccountFeesCvx[msg.sender] = 0;\n        emit FeesClaimed(msg.sender, crvAmount, cvxAmount);\n    }\n\n    function claimAirdropBoost(uint256 amount, MerkleProof.Proof calldata proof) external override {\n        require(block.timestamp < airdropEndTime, \"airdrop ended\");\n        require(!claimedAirdrop[msg.sender], \"already claimed\");\n        require(amount <= _MAX_AIRDROP_BOOST, \"amount exceeds max airdrop boost\");\n        bytes32 node = keccak256(abi.encodePacked(msg.sender, amount));\n        require(proof.isValid(node, merkleRoot), \"invalid proof\");\n        _airdroppedBoost[msg.sender] = amount;\n        emit AirdropBoostClaimed(msg.sender, amount);\n    }\n\n    function claimableFees(\n        address account\n    ) external view override returns (uint256 claimableCrv, uint256 claimableCvx) {\n        uint256 boost_ = lockedBoosted[account];\n        claimableCrv =\n            perAccountFeesCrv[account] +\n            boost_.mulDown(accruedFeesIntegralCrv - perAccountAccruedCrv[account]);\n        claimableCvx =\n            perAccountFeesCvx[account] +\n            boost_.mulDown(accruedFeesIntegralCvx - perAccountAccruedCvx[account]);\n    }\n\n    function balanceOf(address user) external view override returns (uint256) {\n        return totalVoteBoost(user);\n    }\n\n    function _feeCheckpoint(address account) internal {\n        uint256 boost_ = lockedBoosted[account];\n        perAccountFeesCrv[account] += boost_.mulDown(\n            accruedFeesIntegralCrv - perAccountAccruedCrv[account]\n        );\n        perAccountAccruedCrv[account] = accruedFeesIntegralCrv;\n        perAccountFeesCvx[account] += boost_.mulDown(\n            accruedFeesIntegralCvx - perAccountAccruedCvx[account]\n        );\n        perAccountAccruedCvx[account] = accruedFeesIntegralCvx;\n    }\n\n    function computeBoost(uint128 lockTime) public pure override returns (uint128) {\n        return ((_MAX_BOOST - _MIN_BOOST).mulDownUint128(\n            (lockTime - _MIN_LOCK_TIME).divDownUint128(_MAX_LOCK_TIME - _MIN_LOCK_TIME)\n        ) + _MIN_BOOST);\n    }\n\n    function airdropBoost(address account) public view override returns (uint256) {\n        if (_airdroppedBoost[account] == 0) return 1e18;\n        return _airdroppedBoost[account];\n    }\n\n    function totalVoteBoost(address account) public view override returns (uint256) {\n        return totalRewardsBoost(account).mulDown(controller.lpTokenStaker().getBoost(account));\n    }\n\n    function totalRewardsBoost(address account) public view override returns (uint256) {\n        return\n            lockedBoosted[account] -\n            unlockableBalanceBoosted(account) +\n            ICNCVoteLocker(V1_LOCKER).balanceOf(account);\n    }\n\n    function userLocks(address account) external view override returns (VoteLock[] memory) {\n        return voteLocks[account];\n    }\n\n    function _getLockIndexById(address user, uint64 id) internal view returns (uint256) {\n        uint256 length_ = voteLocks[user].length;\n        for (uint256 i; i < length_; i++) {\n            if (voteLocks[user][i].id == id) {\n                return i;\n            }\n        }\n        revert(\"lock doesn't exist\");\n    }\n\n    function _addVoteLock(address user, uint256 amount, uint64 unlockTime, uint128 boost) internal {\n        uint64 id = _nextId;\n        voteLocks[user].push(VoteLock(amount, unlockTime, boost, id));\n        _nextId = id + 1;\n    }\n}"
    }
  ]
}