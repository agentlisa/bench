{
  "Title": "H-9: Swapping 100 tokens in DepositReceipt_ETH and DepositReciept_USDC breaks usage of WBTC LP and other high value tokens",
  "Content": "# Issue H-9: Swapping 100 tokens in DepositReceipt_ETH and DepositReciept_USDC breaks usage of WBTC LP and other high value tokens \n\nSource: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/46 \n\n## Found by \nclems4ever, 0x52\n\n## Summary\n\nDepositReceipt_ETH and DepositReciept_USDC checks the value of liquidity by swapping 100 tokens through the swap router. WBTC is a good example of a token that will likely never work as LP due to the massive value of swapping 100 WBTC. This makes DepositReceipt_ETH and DepositReciept_USDC revert during slippage checks after calculating amount out. As of the time of writing this, WETH also experiences a 11% slippage when trading 100 tokens. Since DepositReceipt_ETH only supports 18 decimal tokens, WETH/USDC would have to use DepositReciept_USDC, resulting in WETH/USDC being incompatible. The fluctuating liquidity could also make this a big issue as well. If liquidity reduces after deposits are made, user deposits could be permanently trapped. \n\n## Vulnerability Detail\n\n        //check swap value of 100tokens to USDC to protect against flash loan attacks\n        uint256 amountOut; //amount received by trade\n        bool stablePool; //if the traded pool is stable or volatile.\n        (amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token1, USDC);\n\nThe above lines try to swap 100 tokens from token1 to USDC. In the case of WBTC 100 tokens is a monstrous amount to swap. Given the low liquidity on the network, it simply won't function due to slippage requirements.\n\n    function _priceCollateral(IDepositReceipt depositReceipt, uint256 _NFTId) internal view returns(uint256){  \n        uint256 pooledTokens = depositReceipt.pooledTokens(_NFTId);      \n        return( depositReceipt.priceLiquidity(pooledTokens));\n    }\n\n    function totalCollateralValue(address _collateralAddress, address _owner) public view returns(uint256){\n        NFTids memory userNFTs = loanNFTids[_collateralAddress][_owner];\n        IDepositReceipt depositReceipt = IDepositReceipt(_collateralAddress);\n        //slither-disable-next-line uninitialized-local-variables\n        uint256 totalPooledTokens;\n        for(uint256 i =0; i < NFT_LIMIT; i++){\n            //check if each slot contains an NFT\n            if (userNFTs.ids[i] != 0){\n                totalPooledTokens += depositReceipt.pooledTokens(userNFTs.ids[i]);\n            }\n        }\n        return(depositReceipt.priceLiquidity(totalPooledTokens));\n    }\n\nOne of the two functions above are used to price LP for every vault action on Vault_Velo. If liquidity is sufficient when user deposits but then drys up after, the users deposit would be permanently trapped in the in the vault. In addition to this liquidation would also become impossible causing the protocol to assume bad debt.\n\nThis could also be exploited by a malicious user. First they deposit a large amount of collateral into the Velodrome WBTC/USDC pair. They take a portion of their LP and take a loan against it. Now they withdraw the rest of their LP. Since there is no longer enough liquidity to swap 100 tokens with 5% slippage, they are now safe from liquidation, allowing a risk free loan.\n\n## Impact\n\nLPs that contain high value tokens will be unusable at best and freeze user funds or be abused at the worst case\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_ETH.sol#L93-L152\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L75-L130\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange the number of tokens to an immutable, so that it can be set individually for each token. Optionally you can add checks (shown below) to make sure that the number of tokens being swapped will result in at least some minimum value of USDC is received. Similar changes should be made for DepositReceipt_ETH:\n\n    constructor(string memory _name, \n                string memory _symbol, \n                address _router, \n                address _token0,\n                address _token1,\n                uint256 _tokensToSwap,\n                bool _stable,\n                address _priceFeed) \n                ERC721(_name, _symbol){\n\n        ...\n\n        if (keccak256(token0Symbol) == keccak256(USDCSymbol)){\n            require( IERC20Metadata(_token1).decimals() == 18, \"Token does not have 18dp\");\n\n    +       (amountOut,) = _router.getAmountOut(_tokensToSwap, token1, USDC);\n\n    +       //swapping tokens must yield at least 100 USDC\n    +       require( amountOut >= 1e8);\n    +       tokensToSwap = _tokensToSwap;\n        }\n        else\n        {   \n            bytes memory token1Symbol = abi.encodePacked(IERC20Metadata(_token1).symbol());\n            require( keccak256(token1Symbol) == keccak256(USDCSymbol), \"One token must be USDC\");\n            require( IERC20Metadata(_token0).decimals() == 18, \"Token does not have 18dp\");\n            \n    +       (amountOut, ) = _router.getAmountOut(_tokensToSwap, token0, USDC);\n\n    +       //swapping tokens must yield at least 100 USDC\n    +       require( amountOut >= 1e8);\n    +       tokensToSwap = _tokensToSwap;\n        }\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix\n\n**kree-dotcom**\n\nFixed https://github.com/kree-dotcom/Velo-Deposit-Tokens/commit/76bb63d885759825d93e95925364806168d02e51\n\nBoth DepositReceipts have had the swap quantity changed to an immutable. DepositReceipt_USDC contains further checks to ensure the swap quantity would receive between 100 and 105 USDC on deployment so we know it is the right scale. This check could also be done with DepositReceipt_ETH but because the value of ETH is dynamic it would be a little more complex so instead we just included a non-zero value check. \n\nSorry, corrected a mistake with still using the `HUNDRED` constant for scaling this trade\nhttps://github.com/kree-dotcom/Velo-Deposit-Tokens/commit/d8e7651f44a4cee07d23c00aa6ee612e25879771\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/22",
  "Code": [
    {
      "filename": "contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_ETH.sol",
      "content": "pragma solidity =0.8.9;\n\nimport \"./DepositReceipt_Base.sol\";\n\ncontract DepositReceipt_ETH is  DepositReceipt_Base {\n    \n    //Price deviation limit when checking pool exchange rate against Chainlink Oracle\n    uint256 private constant ALLOWED_DEVIATION = 5e16; //5% in 1e18 / ETH scale\n    //deployed address of WETH on Optimism Mainnet\n    address private constant WETH = 0x4200000000000000000000000000000000000006;\n    \n    //Chainlink oracle sources\n    IAggregatorV3 ETHPriceFeed;\n    IAggregatorV3 tokenPriceFeed;\n    \n    // ten to the power of the number of decimals given by both price feeds\n    uint256 immutable oracleBase;\n    \n\n    /**\n    *    @notice Zero address checks done in Templater that generates DepositReceipt and so not needed here.\n    **/\n    constructor(string memory _name, \n                string memory _symbol, \n                address _router, \n                address _token0,\n                address _token1,\n                bool _stable,\n                address _ETHPriceFeed,\n                address _tokenPriceFeed) \n                ERC721(_name, _symbol){\n\n        //we dont want the `DEFAULT_ADMIN_ROLE` to exist as this doesn't require a \n        // time delay to add/remove any role and so is dangerous. \n        //So we ignore it and set our weaker admin role.\n        _setupRole(ADMIN_ROLE, msg.sender);\n        currentLastId = 1; //avoid id 0\n        //set up details for underlying tokens\n        router = IRouter(_router);\n\n        //here we check one token is USDC and that the other token has 18d.p.\n        //this prevents pricing mistakes and is defensive design against dev oversight.\n        //Obvious this is not a full check, a malicious ERC20 can set it's own symbol as USDC too \n        //but in practice as only the multi-sig should be deploying via Templater this is not a concern \n        \n        bytes memory WETHSymbol = abi.encodePacked(\"WETH\");\n        bytes memory token0Symbol = abi.encodePacked(IERC20Metadata(_token0).symbol());\n        //equality cannot be checked for strings so we hash them first.\n        if (keccak256(token0Symbol) == keccak256(WETHSymbol)){\n            require( IERC20Metadata(_token1).decimals() == 18, \"Token does not have 18dp\");\n        }\n        else\n        {   \n            bytes memory token1Symbol = abi.encodePacked(IERC20Metadata(_token1).symbol());\n            \n            require( keccak256(token1Symbol) == keccak256(WETHSymbol), \"One token must be WETH\");\n            require( IERC20Metadata(_token0).decimals() == 18, \"Token does not have 18dp\");\n            \n        }\n\n        token0 = _token0;\n        token1 = _token1;\n        stable = _stable;\n    \n        //fetch details for ETH price feed\n        ETHPriceFeed = IAggregatorV3(_ETHPriceFeed);\n        tokenPriceFeed = IAggregatorV3(_tokenPriceFeed);\n        IAccessControlledOffchainAggregator  ETHaggregator = IAccessControlledOffchainAggregator(ETHPriceFeed.aggregator());\n        //fetch the pricefeeds hard limits so we can be aware if these have been reached.\n        ETHMinPrice = ETHaggregator.minAnswer();\n        ETHMaxPrice = ETHaggregator.maxAnswer();\n        uint256 ETHOracleDecimals = ETHPriceFeed.decimals();  //Chainlink USD oracles have 8d.p.\n        require(ETHOracleDecimals == tokenPriceFeed.decimals());\n\n        //fetch details for Token price feed\n        \n        IAccessControlledOffchainAggregator  tokenAggregator = IAccessControlledOffchainAggregator(tokenPriceFeed.aggregator());\n        //fetch the pricefeeds hard limits so we can be aware if these have been reached.\n        tokenMinPrice = tokenAggregator.minAnswer();\n        tokenMaxPrice = tokenAggregator.maxAnswer();\n        // because we have checked both oracles have the same amount of decimals we only store one OracleBase\n        oracleBase = 10 ** ETHOracleDecimals; \n        \n    }\n\n   /**\n    *  @notice this is used to price pooled Tokens by determining their underlying assets and then pricing these\n    *  @notice the two ways to do this are to price to USDC as  a dollar equivalent or to ETH then use Chainlink price feeds\n    *  @dev each DepositReceipt has a bespoke valuation method, make sure it fits the tokens\n    *  @dev each DepositReceipt's valuation method is sensitive to available liquidity keep this in mind as liquidating a pooled token by using the same pool will reduce overall liquidity\n\n    */\n    function priceLiquidity(uint256 _liquidity) external override view returns(uint256){\n        uint256 token0Amount;\n        uint256 token1Amount;\n        (token0Amount, token1Amount) = viewQuoteRemoveLiquidity(_liquidity);\n        \n        uint256 value0;\n        uint256 value1;\n        if (token0 == WETH){\n            //check swap value of 100tokens to USDC to protect against flash loan attacks\n            uint256 amountOut; //amount received by trade\n            bool stablePool; //if the traded pool is stable or volatile.\n            (amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token1, WETH);\n            \n            require(stablePool == stable, \"pricing occuring through wrong pool\" );\n\n            uint256 tokenOraclePrice = getOraclePrice(tokenPriceFeed, tokenMaxPrice, tokenMinPrice);\n            uint256 ETHOraclePrice = getOraclePrice(ETHPriceFeed, ETHMaxPrice, ETHMinPrice);\n            //reduce amountOut to the value of one token in dollars in the same scale as tokenOraclePrice (1e8)\n            uint256 valueOut = amountOut * ETHOraclePrice / HUNDRED / BASE; \n\n            //calculate acceptable deviations from oracle price\n            \n            uint256 lowerBound = (tokenOraclePrice * (BASE - ALLOWED_DEVIATION)) / BASE;\n            uint256 upperBound = (tokenOraclePrice * (BASE + ALLOWED_DEVIATION)) / BASE;\n            //because 1 USDC = $1 we can compare its amount directly to bounds\n            \n            require(lowerBound < valueOut, \"Price shift low detected\");\n            require(upperBound > valueOut, \"Price shift high detected\");\n\n            value0 = token0Amount * ETHOraclePrice;\n            \n            value1 = token1Amount * tokenOraclePrice;\n        }\n        //token1 must be WETH\n        else {\n            \n            //check swap value of 100tokens to WETH to protect against flash loan attacks\n            uint256 amountOut; //amount received by trade\n            bool stablePool; //if the traded pool is stable or volatile.\n            (amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token0, WETH);\n            require(stablePool == stable, \"pricing occuring through wrong pool\" );\n            uint256 tokenOraclePrice = getOraclePrice(tokenPriceFeed, tokenMaxPrice, tokenMinPrice);\n            uint256 ETHOraclePrice = getOraclePrice(ETHPriceFeed, ETHMaxPrice, ETHMinPrice);\n            //reduce amountOut to the value of one token in dollars in the same scale as tokenOraclePrice (1e8)\n            uint256 valueOut = amountOut * ETHOraclePrice / HUNDRED / BASE; \n            //calculate acceptable deviations from oracle price\n            uint256 lowerBound = (tokenOraclePrice * (BASE - ALLOWED_DEVIATION)) / BASE;\n            uint256 upperBound = (tokenOraclePrice * (BASE + ALLOWED_DEVIATION)) / BASE;\n            //because 1 USDC = $1 we can compare its amount directly to bounds\n            require(lowerBound < valueOut, \"Price shift low detected\");\n            require(upperBound > valueOut, \"Price shift high detected\");\n\n            value1 = token1Amount * ETHOraclePrice;\n            \n            value0 = token0Amount * tokenOraclePrice;\n        }\n        // because value0 and value1 are in the same scale we can reduce them to 1e18 scale after adding.\n        return((value0 + value1)/oracleBase);\n    }\n}"
    },
    {
      "filename": "contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol",
      "content": "pragma solidity =0.8.9;\n\nimport \"./DepositReceipt_Base.sol\";\n\ncontract DepositReceipt_USDC is  DepositReceipt_Base {\n\n    uint256 private constant SCALE_SHIFT = 1e12; //brings USDC 6.d.p up to 18d.p. standard\n    uint256 private constant USDC_BASE = 1e6; //used for division in USDC 6.d.p scale\n    uint256 private constant ALLOWED_DEVIATION = 5e16; //5% in 1e18 / ETH scale\n    address private constant USDC = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607; \n\n    //Chainlink oracle source\n    IAggregatorV3 public priceFeed;\n    // ten to the power of the number of decimals given by the price feed\n    uint256 private immutable oracleBase;\n\n    /**\n    *    @notice Zero address checks done in Templater that generates DepositReceipt and so not needed here.\n    **/\n    constructor(string memory _name, \n                string memory _symbol, \n                address _router, \n                address _token0,\n                address _token1,\n                bool _stable,\n                address _priceFeed) \n                ERC721(_name, _symbol){\n\n        //we dont want the `DEFAULT_ADMIN_ROLE` to exist as this doesn't require a \n        // time delay to add/remove any role and so is dangerous. \n        //So we ignore it and set our weaker admin role.\n        _setupRole(ADMIN_ROLE, msg.sender);\n        currentLastId = 1; //avoid id 0\n        //set up details for underlying tokens\n        router = IRouter(_router);\n\n        //here we check one token is USDC and that the other token has 18d.p.\n        //this prevents pricing mistakes and is defensive design against dev oversight.\n        //Obvious this is not a full check, a malicious ERC20 can set it's own symbol as USDC too \n        //but in practice as only the multi-sig should be deploying via Templater this is not a concern \n        \n        bytes memory USDCSymbol = abi.encodePacked(\"USDC\");\n        bytes memory token0Symbol = abi.encodePacked(IERC20Metadata(_token0).symbol());\n        //equality cannot be checked for strings so we hash them first.\n        if (keccak256(token0Symbol) == keccak256(USDCSymbol)){\n            require( IERC20Metadata(_token1).decimals() == 18, \"Token does not have 18dp\");\n        }\n        else\n        {   \n            bytes memory token1Symbol = abi.encodePacked(IERC20Metadata(_token1).symbol());\n            \n            require( keccak256(token1Symbol) == keccak256(USDCSymbol), \"One token must be USDC\");\n            require( IERC20Metadata(_token0).decimals() == 18, \"Token does not have 18dp\");\n            \n        }\n\n        token0 = _token0;\n        token1 = _token1;\n        stable = _stable;\n        priceFeed = IAggregatorV3(_priceFeed);\n        IAccessControlledOffchainAggregator  aggregator = IAccessControlledOffchainAggregator(priceFeed.aggregator());\n        //fetch the pricefeeds hard limits so we can be aware if these have been reached.\n        tokenMinPrice = aggregator.minAnswer();\n        tokenMaxPrice = aggregator.maxAnswer();\n        oracleBase = 10 ** priceFeed.decimals();  //Chainlink USD oracles have 8d.p.\n    }\n\n   /**\n    *  @notice this is used to price pooled Tokens by determining their underlying assets and then pricing these\n    *  @notice the two ways to do this are to price to USDC as  a dollar equivalent or to ETH then use Chainlink price feeds\n    *  @dev each DepositReceipt has a bespoke valuation method, make sure it fits the tokens\n    *  @dev each DepositReceipt's valuation method is sensitive to available liquidity keep this in mind as liquidating a pooled token by using the same pool will reduce overall liquidity\n\n    */\n    function priceLiquidity(uint256 _liquidity) external override view returns(uint256){\n        uint256 token0Amount;\n        uint256 token1Amount;\n        (token0Amount, token1Amount) = viewQuoteRemoveLiquidity(_liquidity);\n        //USDC route \n        uint256 value0;\n        uint256 value1;\n        if (token0 == USDC){\n            //hardcode value of USDC at $1\n            //check swap value of 100tokens to USDC to protect against flash loan attacks\n            uint256 amountOut; //amount received by trade\n            bool stablePool; //if the traded pool is stable or volatile.\n            (amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token1, USDC);\n            require(stablePool == stable, \"pricing occuring through wrong pool\" );\n\n            uint256 oraclePrice = getOraclePrice(priceFeed, tokenMaxPrice, tokenMinPrice);\n            amountOut = (amountOut * oracleBase) / USDC_BASE / HUNDRED; //shift USDC amount to same scale as oracle\n\n            //calculate acceptable deviations from oracle price\n            uint256 lowerBound = (oraclePrice * (BASE - ALLOWED_DEVIATION)) / BASE;\n            uint256 upperBound = (oraclePrice * (BASE + ALLOWED_DEVIATION)) / BASE;\n            //because 1 USDC = $1 we can compare its amount directly to bounds\n            require(lowerBound < amountOut, \"Price shift low detected\");\n            require(upperBound > amountOut, \"Price shift high detected\");\n\n            value0 = token0Amount * SCALE_SHIFT;\n            \n            value1 = (token1Amount * oraclePrice) / oracleBase;\n        }\n        //token1 must be USDC \n        else {\n            //hardcode value of USDC at $1\n            //check swap value of 100tokens to USDC to protect against flash loan attacks\n            uint256 amountOut; //amount received by trade\n            bool stablePool; //if the traded pool is stable or volatile.\n            (amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token0, USDC);\n            require(stablePool == stable, \"pricing occuring through wrong pool\" );\n\n            uint256 oraclePrice = getOraclePrice(priceFeed, tokenMaxPrice, tokenMinPrice);\n            amountOut = (amountOut * oracleBase) / USDC_BASE / HUNDRED; //shift USDC amount to same scale as oracle\n\n            //calculate acceptable deviations from oracle price\n            uint256 lowerBound = (oraclePrice * (BASE - ALLOWED_DEVIATION)) / BASE;\n            uint256 upperBound = (oraclePrice * (BASE + ALLOWED_DEVIATION)) / BASE;\n            //because 1 USDC = $1 we can compare its amount directly to bounds\n            require(lowerBound < amountOut, \"Price shift low detected\");\n            require(upperBound > amountOut, \"Price shift high detected\");\n\n            value1 = token1Amount * SCALE_SHIFT;\n           \n            value0 = (token0Amount * oraclePrice) / oracleBase;\n        }\n        //Invariant: both value0 and value1 are in ETH scale 18.d.p now\n        //USDC has only 6 decimals so we bring it up to the same scale as other 18d.p ERC20s\n        return(value0 + value1);\n    }\n}"
    }
  ]
}