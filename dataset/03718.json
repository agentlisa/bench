{
  "Title": "Unreachable code in `getCTokenBalanceInternal`",
  "Content": "##### Description\nAffecting variable `accountTokens[account]` always makes `isCollateralTokenInit[account]` true, so `accountCollateralTokens[account]` will be returned. Otherwise balance is 0\nhttps://github.com/CreamFi/compound-protocol/blob/23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20.sol#L408\n\n##### Recommendation\nWe recommend to remove unreachable part\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/CCollateralCapErc20.sol",
      "content": "pragma solidity ^0.5.16;\n\nimport \"./CToken.sol\";\nimport \"./ComptrollerStorage.sol\";\n\n/**\n * @title Cream's Comptroller interface extension\n */\ninterface ComptrollerInterfaceExtension {\n    function checkMembership(address account, CToken cToken) external view returns (bool);\n\n    function updateCTokenVersion(address cToken, ComptrollerV2Storage.Version version) external;\n}\n\n/**\n * @title Cream's CCollateralCapErc20 Contract\n * @notice CTokens which wrap an EIP-20 underlying with collateral cap\n * @author Cream\n */\ncontract CCollateralCapErc20 is CToken, CCollateralCapErc20Interface {\n    /**\n     * @notice Initialize the new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param decimals_ ERC-20 decimal precision of this token\n     */\n    function initialize(address underlying_,\n                        ComptrollerInterface comptroller_,\n                        InterestRateModel interestRateModel_,\n                        uint initialExchangeRateMantissa_,\n                        string memory name_,\n                        string memory symbol_,\n                        uint8 decimals_) public {\n        // CToken initialize does the bulk of the work\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        EIP20Interface(underlying).totalSupply();\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mint(uint mintAmount) external returns (uint) {\n        (uint err,) = mintInternal(mintAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeem(uint redeemTokens) external returns (uint) {\n        return redeemInternal(redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\n        return redeemUnderlyingInternal(redeemAmount);\n    }\n\n    /**\n      * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function borrow(uint borrowAmount) external returns (uint) {\n        return borrowInternal(borrowAmount);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrow(uint repayAmount) external returns (uint) {\n        (uint err,) = repayBorrowInternal(repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint) {\n        (uint err,) = repayBorrowBehalfInternal(borrower, repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) external returns (uint) {\n        (uint err,) = liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\n        return err;\n    }\n\n    /**\n     * @notice The sender adds to reserves.\n     * @param addAmount The amount fo underlying token to add as reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _addReserves(uint addAmount) external returns (uint) {\n        return _addReservesInternal(addAmount);\n    }\n\n    /**\n     * @notice Set the given collateral cap for the market.\n     * @param newCollateralCap New collateral cap for this market. A value of 0 corresponds to no cap.\n     */\n    function _setCollateralCap(uint newCollateralCap) external {\n        require(msg.sender == admin, \"only admin can set collateral cap\");\n\n        collateralCap = newCollateralCap;\n        emit NewCollateralCap(address(this), newCollateralCap);\n    }\n\n    /**\n     * @notice Absorb excess cash into reserves.\n     */\n    function gulp() external nonReentrant {\n        uint256 cashOnChain = getCashOnChain();\n        uint256 cashPrior = getCashPrior();\n\n        uint excessCash = sub_(cashOnChain, cashPrior);\n        totalReserves = add_(totalReserves, excessCash);\n        internalCash = cashOnChain;\n    }\n\n    /**\n     * @notice Flash loan funds to a given account.\n     * @param receiver The receiver address for the funds\n     * @param amount The amount of the funds to be loaned\n     * @param params The other parameters\n     */\n    function flashLoan(address receiver, uint amount, bytes calldata params) external nonReentrant {\n        uint cashOnChainBefore = getCashOnChain();\n        uint cashBefore = getCashPrior();\n        require(cashBefore >= amount, \"INSUFFICIENT_LIQUIDITY\");\n\n        // 1. calculate fee, 1 bips = 1/10000\n        uint totalFee = div_(mul_(amount, flashFeeBips), 10000);\n\n        // 2. transfer fund to receiver\n        doTransferOut(address(uint160(receiver)), amount);\n\n        // 3. execute receiver's callback function\n        IFlashloanReceiver(receiver).executeOperation(msg.sender, underlying, amount, totalFee, params);\n\n        // 4. check balance\n        uint cashOnChainAfter = getCashOnChain();\n        require(cashOnChainAfter == add_(cashOnChainBefore, totalFee), \"BALANCE_INCONSISTENT\");\n\n        // 5. update reserves and internal cash\n        uint reservesFee = mul_ScalarTruncate(Exp({mantissa: reserveFactorMantissa}), totalFee);\n        totalReserves = add_(totalReserves, reservesFee);\n        internalCash = add_(cashBefore, totalFee);\n\n        emit Flashloan(receiver, amount, totalFee, reservesFee);\n    }\n\n    /**\n     * @notice Register account collateral tokens if there is space.\n     * @param account The account to register\n     * @dev This function could only be called by comptroller.\n     * @return The actual registered amount of collateral\n     */\n    function registerCollateral(address account) external returns (uint) {\n        // Make sure accountCollateralTokens of `account` is initialized.\n        initializeAccountCollateralTokens(account);\n\n        require(msg.sender == address(comptroller), \"only comptroller may register collateral for user\");\n\n        uint amount = sub_(accountTokens[account], accountCollateralTokens[account]);\n        return increaseUserCollateralInternal(account, amount);\n    }\n\n    /**\n     * @notice Unregister account collateral tokens if the account still has enough collateral.\n     * @dev This function could only be called by comptroller.\n     * @param account The account to unregister\n     */\n    function unregisterCollateral(address account) external {\n        // Make sure accountCollateralTokens of `account` is initialized.\n        initializeAccountCollateralTokens(account);\n\n        require(msg.sender == address(comptroller), \"only comptroller may unregister collateral for user\");\n\n        decreaseUserCollateralInternal(account, accountCollateralTokens[account]);\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets internal balance of this contract in terms of the underlying.\n     *  It excludes balance from direct transfer.\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() internal view returns (uint) {\n        return internalCash;\n    }\n\n    /**\n     * @notice Gets total balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashOnChain() internal view returns (uint) {\n        EIP20Interface token = EIP20Interface(underlying);\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @notice Initialize the account's collateral tokens. This function should be called in the beginning of every function\n     *  that accesses accountCollateralTokens or accountTokens.\n     * @param account The account of accountCollateralTokens that needs to be updated\n     */\n    function initializeAccountCollateralTokens(address account) internal {\n        /**\n         * If isCollateralTokenInit is false, it means accountCollateralTokens was not initialized yet.\n         * This case will only happen once and must be the very beginning. accountCollateralTokens is a new structure and its\n         * initial value should be equal to accountTokens if user has entered the market. However, it's almost impossible to\n         * check every user's value when the implementation becomes active. Therefore, it must rely on every action which will\n         * access accountTokens to call this function to check if accountCollateralTokens needed to be initialized.\n         */\n        if (!isCollateralTokenInit[account]) {\n            if (ComptrollerInterfaceExtension(address(comptroller)).checkMembership(account, CToken(this))) {\n                accountCollateralTokens[account] = accountTokens[account];\n                totalCollateralTokens = add_(totalCollateralTokens, accountTokens[account]);\n\n                emit UserCollateralChanged(account, accountCollateralTokens[account]);\n            }\n            isCollateralTokenInit[account] = true;\n        }\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address from, uint amount) internal returns (uint) {\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n        uint balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n        token.transferFrom(from, address(this), amount);\n\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {                       // This is a non-standard ERC-20\n                    success := not(0)          // set success to true\n                }\n                case 32 {                      // This is a compliant ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0)        // Set `success = returndata` of external call\n                }\n                default {                      // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n        // Calculate the amount that was *actually* transferred\n        uint balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n        uint transferredIn = sub_(balanceAfter, balanceBefore);\n        internalCash = add_(internalCash, transferredIn);\n        return transferredIn;\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address payable to, uint amount) internal {\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n        token.transfer(to, amount);\n\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {                      // This is a non-standard ERC-20\n                    success := not(0)          // set success to true\n                }\n                case 32 {                     // This is a complaint ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0)        // Set `success = returndata` of external call\n                }\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n        internalCash = sub_(internalCash, amount);\n    }\n\n    /**\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n        // Make sure accountCollateralTokens of `src` and `dst` are initialized.\n        initializeAccountCollateralTokens(src);\n        initializeAccountCollateralTokens(dst);\n\n        /**\n         * For every user, accountTokens must be greater than or equal to accountCollateralTokens.\n         * The buffer between the two values will be transferred first.\n         * bufferTokens = accountTokens[src] - accountCollateralTokens[src]\n         * collateralTokens = tokens - bufferTokens\n         */\n        uint bufferTokens = sub_(accountTokens[src], accountCollateralTokens[src]);\n        uint collateralTokens = 0;\n        if (tokens > bufferTokens) {\n            collateralTokens = sub_(tokens, bufferTokens);\n        }\n\n        /**\n         * Since bufferTokens are not collateralized and can be transferred freely, we only check with comptroller\n         * whether collateralized tokens can be transferred.\n         */\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, collateralTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Do not allow self-transfers */\n        if (src == dst) {\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        /* Get the allowance, infinite for the account owner */\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(-1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        uint allowanceNew = sub_(startingAllowance, tokens);\n        accountTokens[src] = sub_(accountTokens[src], tokens);\n        accountTokens[dst] = add_(accountTokens[dst], tokens);\n        if (collateralTokens > 0) {\n            accountCollateralTokens[src] = sub_(accountCollateralTokens[src], collateralTokens);\n            accountCollateralTokens[dst] = add_(accountCollateralTokens[dst], collateralTokens);\n\n            emit UserCollateralChanged(src, accountCollateralTokens[src]);\n            emit UserCollateralChanged(dst, accountCollateralTokens[dst]);\n        }\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != uint(-1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n\n        // unused function\n        // comptroller.transferVerify(address(this), src, dst, tokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Get the account's cToken balances\n     * @param account The address of the account\n     */\n    function getCTokenBalanceInternal(address account) internal view returns (uint) {\n        if (isCollateralTokenInit[account]) {\n            return accountCollateralTokens[account];\n        } else {\n            /**\n             * If the value of accountCollateralTokens was not initialized, we should return the value of accountTokens.\n             */\n            return accountTokens[account];\n        }\n    }\n\n    /**\n     * @notice Increase user's collateral. Increase as much as we can.\n     * @param account The address of the account\n     * @param amount The amount of collateral user wants to increase\n     * @return The actual increased amount of collateral\n     */\n    function increaseUserCollateralInternal(address account, uint amount) internal returns (uint) {\n        uint totalCollateralTokensNew = add_(totalCollateralTokens, amount);\n        if (collateralCap == 0 || (collateralCap != 0 && totalCollateralTokensNew <= collateralCap)) {\n            // 1. If collateral cap is not set,\n            // 2. If collateral cap is set but has enough space for this user,\n            // give all the user needs.\n            totalCollateralTokens = totalCollateralTokensNew;\n            accountCollateralTokens[account] = add_(accountCollateralTokens[account], amount);\n\n            emit UserCollateralChanged(account, accountCollateralTokens[account]);\n            return amount;\n        } else if (collateralCap > totalCollateralTokens) {\n            // If the collateral cap is set but the remaining cap is not enough for this user,\n            // give the remaining parts to the user.\n            uint gap = sub_(collateralCap, totalCollateralTokens);\n            totalCollateralTokens = add_(totalCollateralTokens, gap);\n            accountCollateralTokens[account] = add_(accountCollateralTokens[account], gap);\n\n            emit UserCollateralChanged(account, accountCollateralTokens[account]);\n            return gap;\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Decrease user's collateral. Reject if the amount can't be fully decrease.\n     * @param account The address of the account\n     * @param amount The amount of collateral user wants to decrease\n     */\n    function decreaseUserCollateralInternal(address account, uint amount) internal {\n        require(comptroller.redeemAllowed(address(this), account, amount) == 0, \"comptroller rejection\");\n\n        totalCollateralTokens = sub_(totalCollateralTokens, amount);\n        accountCollateralTokens[account] = sub_(accountCollateralTokens[account], amount);\n\n        emit UserCollateralChanged(account, accountCollateralTokens[account]);\n    }\n\n    struct MintLocalVars {\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint actualMintAmount;\n    }\n\n    /**\n     * @notice User supplies assets into the market and receives cTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n        // Make sure accountCollateralTokens of `minter` is initialized.\n        initializeAccountCollateralTokens(minter);\n\n        /* Fail if mint not allowed */\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n        }\n\n        MintLocalVars memory vars;\n\n        vars.exchangeRateMantissa = exchangeRateStoredInternal();\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n        /*\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n        vars.mintTokens = div_ScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        /*\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n         *  totalSupply = totalSupply + mintTokens\n         *  accountTokens[minter] = accountTokens[minter] + mintTokens\n         */\n        totalSupply = add_(totalSupply, vars.mintTokens);\n        accountTokens[minter] = add_(accountTokens[minter], vars.mintTokens);\n\n        /*\n         * We only allocate collateral tokens if the minter has entered the market.\n         */\n        if (ComptrollerInterfaceExtension(address(comptroller)).checkMembership(minter, CToken(this))) {\n            increaseUserCollateralInternal(minter, vars.mintTokens);\n        }\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n    }\n\n    struct RedeemLocalVars {\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n    }\n\n    /**\n     * @notice User redeems cTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n        // Make sure accountCollateralTokens of `redeemer` is initialized.\n        initializeAccountCollateralTokens(redeemer);\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n        RedeemLocalVars memory vars;\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        vars.exchangeRateMantissa = exchangeRateStoredInternal();\n\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            vars.redeemTokens = redeemTokensIn;\n            vars.redeemAmount = mul_ScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n            vars.redeemTokens = div_ScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        /**\n         * For every user, accountTokens must be greater than or equal to accountCollateralTokens.\n         * The buffer between the two values will be redeemed first.\n         * bufferTokens = accountTokens[redeemer] - accountCollateralTokens[redeemer]\n         * collateralTokens = redeemTokens - bufferTokens\n         */\n        uint bufferTokens = sub_(accountTokens[redeemer], accountCollateralTokens[redeemer]);\n        uint collateralTokens = 0;\n        if (vars.redeemTokens > bufferTokens) {\n            collateralTokens = sub_(vars.redeemTokens, bufferTokens);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n        }\n\n        /* Fail gracefully if protocol has insufficient cash */\n        if (getCashPrior() < vars.redeemAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(redeemer, vars.redeemAmount);\n\n        /*\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         */\n        totalSupply = sub_(totalSupply, vars.redeemTokens);\n        accountTokens[redeemer] = sub_(accountTokens[redeemer], vars.redeemTokens);\n\n        /*\n         * We only deallocate collateral tokens if the redeemer needs to redeem them.\n         */\n        if (collateralTokens > 0) {\n            decreaseUserCollateralInternal(redeemer, collateralTokens);\n        }\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        /* We call the defense hook */\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\n     *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\n        // Make sure accountCollateralTokens of `liquidator` and `borrower` are initialized.\n        initializeAccountCollateralTokens(liquidator);\n        initializeAccountCollateralTokens(borrower);\n\n        /* Fail if seize not allowed */\n        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n        }\n\n        /*\n         * We calculate the new borrower and liquidator token balances and token collateral balances, failing on underflow/overflow:\n         *  accountTokens[borrower] = accountTokens[borrower] - seizeTokens\n         *  accountTokens[liquidator] = accountTokens[liquidator] + seizeTokens\n         *  accountCollateralTokens[borrower] = accountCollateralTokens[borrower] - seizeTokens\n         *  accountCollateralTokens[liquidator] = accountCollateralTokens[liquidator] + seizeTokens\n         */\n        accountTokens[borrower] = sub_(accountTokens[borrower], seizeTokens);\n        accountTokens[liquidator] = add_(accountTokens[liquidator], seizeTokens);\n        accountCollateralTokens[borrower] = sub_(accountCollateralTokens[borrower], seizeTokens);\n        accountCollateralTokens[liquidator] = add_(accountCollateralTokens[liquidator], seizeTokens);\n\n        /* Emit a Transfer, UserCollateralChanged events */\n        emit Transfer(borrower, liquidator, seizeTokens);\n        emit UserCollateralChanged(borrower, accountCollateralTokens[borrower]);\n        emit UserCollateralChanged(liquidator, accountCollateralTokens[liquidator]);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n}"
    }
  ]
}