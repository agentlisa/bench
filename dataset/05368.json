{
  "Title": "[M-08] MaxHeap.sol: Already extracted tokenId may be extracted again",
  "Content": "\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/MaxHeap.sol#L102> \n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/MaxHeap.sol#L156>\n\n`MaxHeap.sol#extractMax` function only decreases the `size` variable without initializing the `heap` state variable.\nOn the other hand, `MaxHeap.sol#maxHeapify` function involves the `heap` variable for the out-of-bound index which will contain dirty non-zero value.\nAs a result, uncleared dirty value of `heap` state variable will be used in the process and already extracted tokenId will be extracted again.\n\n### Proof of Concept\n\n`MaxHeap.sol#extractMax` function is following.\n\n```solidity\nFile: MaxHeap.sol\n156:     function extractMax() external onlyAdmin returns (uint256, uint256) {\n157:         require(size > 0, \"Heap is empty\");\n158: \n159:         uint256 popped = heap[0];\n160:         heap[0] = heap[--size];\n161:         maxHeapify(0);\n162: \n163:         return (popped, valueMapping[popped]);\n164:     }\n```\n\nAs can be seen, the above funcion decreases `size` state variable by one, but does not initialize the `heap[size]` value to zero.\nIn the meantime,`MaxHeap.sol#maxHeapify` function is following.\n\n```solidity\nFile: MaxHeap.sol\n094:     function maxHeapify(uint256 pos) internal {\n095:         uint256 left = 2 * pos + 1;\n096:         uint256 right = 2 * pos + 2;\n097: \n098:         uint256 posValue = valueMapping[heap[pos]];\n099:         uint256 leftValue = valueMapping[heap[left]];\n100:         uint256 rightValue = valueMapping[heap[right]];\n101: \n102:         if (pos >= (size / 2) && pos <= size) return;\n103: \n104:         if (posValue < leftValue || posValue < rightValue) {\n105:             if (leftValue > rightValue) {\n106:                 swap(pos, left);\n107:                 maxHeapify(left);\n108:             } else {\n109:                 swap(pos, right);\n110:                 maxHeapify(right);\n111:             }\n112:         }\n113:     }\n```\n\nFor example, if `size=2` and `pos=0`, `right = 2 = size` holds true.\nSo the `heap[right]=heap[size]` indicates the value of out-of-bound index which may be not initialized in `extractMax` function ahead.\nBut in `L102` since `pos = 0 < (size / 2) = 1` holds true, the function does not return and continue to proceed the below section of function.\nThus, abnormal phenomena occurs due to the value that should not be used.\n\nWe can verify the above issue by adding and running the following test code to `test/max-heap/Updates.t.sol`.\n\n```solidity\n    function testExtractUpdateError() public {\n        // Insert 3 items with value 20 and remove them all\n        maxHeapTester.insert(1, 20);\n        maxHeapTester.insert(2, 20);\n        maxHeapTester.insert(3, 20);\n\n        maxHeapTester.extractMax();\n        maxHeapTester.extractMax();\n        maxHeapTester.extractMax(); // Because all of 3 items are removed, itemId=1,2,3 should never be extracted after.\n\n        // Insert 2 items with value 10 which is small than 20\n        maxHeapTester.insert(4, 10);\n        maxHeapTester.insert(5, 10);\n        // Update value to cause maxHeapify\n        maxHeapTester.updateValue(4, 5);\n\n        // Now the item should be itemId=5, value=10\n        // But in fact the max item is itemId=3, value=20 now.\n        (uint256 itemId, uint256 value) = maxHeapTester.extractMax(); // itemId=3 will be extracted again\n\n        require(itemId == 5, \"Item ID should be 5 but 3 now\");\n        require(value == 10, \"value should be 10 but 20 now\");\n    }\n```\n\nAs a result of test code, the return value of the last `extractMax` call is not `(itemId, value) = (5, 10)` but `(itemId, value) = (3, 20)` which is error.\nAccording to `READM.md#L313`, the above result must not be forbidden.\n\n### Recommended Mitigation Steps\n\nModify the `MaxHeap.sol#extractMax` function as follows:\n\n```solidity\n    function extractMax() external onlyAdmin returns (uint256, uint256) {\n        require(size > 0, \"Heap is empty\");\n\n        uint256 popped = heap[0];\n        heap[0] = heap[--size];\n ++     heap[size] = 0;\n        maxHeapify(0);\n\n        return (popped, valueMapping[popped]);\n    }\n```\n\nSince the value of `heap[size]` is initialized to zero, no errors will occur even though the value of out-of-bound index is used in `maxHeapify` function.\n\n**[rocketman-21 (Revolution) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/266#issuecomment-1877704894):**\n > Think this should be medium, it requires that we make the values of the maxheap less than they were inserted at, which isn't possible in CultureIndex (which is upvote only)\n\n**[0xTheC0der (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/266#issuecomment-1885934024):**\n> I judged this contest with a strict baseline for Medium severity findings.\n> However, I was \"forced\" to accept a view-only ERC-721 violation as valid Medium due to historical precedence on C4.\n> As the present issue is similarly deviating from spec without severe impacts on the functionality of the protocol at its current state, it seems fair and consistent to move forward with Medium severity and therefore appropriately value the effort behind uncovering this very valid bug.\n\n_Note: For full discussion see [here](https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/266)_\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-revolutionprotocol",
  "Code": [
    {
      "filename": "packages/revolution/src/MaxHeap.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.22;\n\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\n\nimport { UUPS } from \"./libs/proxy/UUPS.sol\";\nimport { VersionedContract } from \"./version/VersionedContract.sol\";\n\n/// @title MaxHeap implementation in Solidity\n/// @dev This contract implements a Max Heap data structure with basic operations\n/// @author Written by rocketman and gpt4\ncontract MaxHeap is VersionedContract, UUPS, Ownable2StepUpgradeable, ReentrancyGuardUpgradeable {\n    /// @notice The parent contract that is allowed to update the data store\n    address public admin;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                          MODIFIERS                       ///\n    ///                                                          ///\n\n    /**\n     * @notice Require that the minter has not been locked.\n     */\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Sender is not the admin\");\n        _;\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initializes the maxheap contract\n     * @param _initialOwner The initial owner of the contract\n     * @param _admin The contract that is allowed to update the data store\n     */\n    function initialize(address _initialOwner, address _admin) public initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n\n        admin = _admin;\n\n        __Ownable_init(_initialOwner);\n        __ReentrancyGuard_init();\n    }\n\n    /// @notice Struct to represent an item in the heap by it's ID\n    mapping(uint256 => uint256) public heap;\n\n    uint256 public size = 0;\n\n    /// @notice Mapping to keep track of the value of an item in the heap\n    mapping(uint256 => uint256) public valueMapping;\n\n    /// @notice Mapping to keep track of the position of an item in the heap\n    mapping(uint256 => uint256) public positionMapping;\n\n    /// @notice Get the parent index of a given position\n    /// @param pos The position for which to find the parent\n    /// @return The index of the parent node\n    function parent(uint256 pos) private pure returns (uint256) {\n        require(pos != 0, \"Position should not be zero\");\n        return (pos - 1) / 2;\n    }\n\n    /// @notice Swap two nodes in the heap\n    /// @param fpos The position of the first node\n    /// @param spos The position of the second node\n    function swap(uint256 fpos, uint256 spos) private {\n        (heap[fpos], heap[spos]) = (heap[spos], heap[fpos]);\n        (positionMapping[heap[fpos]], positionMapping[heap[spos]]) = (fpos, spos);\n    }\n\n    /// @notice Reheapify the heap starting at a given position\n    /// @dev This ensures that the heap property is maintained\n    /// @param pos The starting position for the heapify operation\n    function maxHeapify(uint256 pos) internal {\n        uint256 left = 2 * pos + 1;\n        uint256 right = 2 * pos + 2;\n\n        uint256 posValue = valueMapping[heap[pos]];\n        uint256 leftValue = valueMapping[heap[left]];\n        uint256 rightValue = valueMapping[heap[right]];\n\n        if (pos >= (size / 2) && pos <= size) return;\n\n        if (posValue < leftValue || posValue < rightValue) {\n            if (leftValue > rightValue) {\n                swap(pos, left);\n                maxHeapify(left);\n            } else {\n                swap(pos, right);\n                maxHeapify(right);\n            }\n        }\n    }\n\n    /// @notice Insert an element into the heap\n    /// @dev The function will revert if the heap is full\n    /// @param itemId The item ID to insert\n    /// @param value The value to insert\n    function insert(uint256 itemId, uint256 value) public onlyAdmin {\n        heap[size] = itemId;\n        valueMapping[itemId] = value; // Update the value mapping\n        positionMapping[itemId] = size; // Update the position mapping\n\n        uint256 current = size;\n        while (current != 0 && valueMapping[heap[current]] > valueMapping[heap[parent(current)]]) {\n            swap(current, parent(current));\n            current = parent(current);\n        }\n        size++;\n    }\n\n    /// @notice Update the value of an existing item in the heap\n    /// @param itemId The item ID whose vote count needs to be updated\n    /// @param newValue The new value for the item\n    /// @dev This function adjusts the heap to maintain the max-heap property after updating the vote count\n    function updateValue(uint256 itemId, uint256 newValue) public onlyAdmin {\n        uint256 position = positionMapping[itemId];\n        uint256 oldValue = valueMapping[itemId];\n\n        // Update the value in the valueMapping\n        valueMapping[itemId] = newValue;\n\n        // Decide whether to perform upwards or downwards heapify\n        if (newValue > oldValue) {\n            // Upwards heapify\n            while (position != 0 && valueMapping[heap[position]] > valueMapping[heap[parent(position)]]) {\n                swap(position, parent(position));\n                position = parent(position);\n            }\n        } else if (newValue < oldValue) maxHeapify(position); // Downwards heapify\n    }\n\n    /// @notice Extract the maximum element from the heap\n    /// @dev The function will revert if the heap is empty\n    /// @return The maximum element from the heap\n    function extractMax() external onlyAdmin returns (uint256, uint256) {\n        require(size > 0, \"Heap is empty\");\n\n        uint256 popped = heap[0];\n        heap[0] = heap[--size];\n        maxHeapify(0);\n\n        return (popped, valueMapping[popped]);\n    }\n\n    /// @notice Get the maximum element from the heap\n    /// @dev The function will revert if the heap is empty\n    /// @return The maximum element from the heap\n    function getMax() public view returns (uint256, uint256) {\n        require(size > 0, \"Heap is empty\");\n        return (heap[0], valueMapping[heap[0]]);\n    }\n\n    ///                                                          ///\n    ///                     MAX HEAP UPGRADE                     ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the new implementation is a registered upgrade\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}"
    },
    {
      "filename": "packages/revolution/src/MaxHeap.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.22;\n\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\n\nimport { UUPS } from \"./libs/proxy/UUPS.sol\";\nimport { VersionedContract } from \"./version/VersionedContract.sol\";\n\n/// @title MaxHeap implementation in Solidity\n/// @dev This contract implements a Max Heap data structure with basic operations\n/// @author Written by rocketman and gpt4\ncontract MaxHeap is VersionedContract, UUPS, Ownable2StepUpgradeable, ReentrancyGuardUpgradeable {\n    /// @notice The parent contract that is allowed to update the data store\n    address public admin;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                          MODIFIERS                       ///\n    ///                                                          ///\n\n    /**\n     * @notice Require that the minter has not been locked.\n     */\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Sender is not the admin\");\n        _;\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initializes the maxheap contract\n     * @param _initialOwner The initial owner of the contract\n     * @param _admin The contract that is allowed to update the data store\n     */\n    function initialize(address _initialOwner, address _admin) public initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n\n        admin = _admin;\n\n        __Ownable_init(_initialOwner);\n        __ReentrancyGuard_init();\n    }\n\n    /// @notice Struct to represent an item in the heap by it's ID\n    mapping(uint256 => uint256) public heap;\n\n    uint256 public size = 0;\n\n    /// @notice Mapping to keep track of the value of an item in the heap\n    mapping(uint256 => uint256) public valueMapping;\n\n    /// @notice Mapping to keep track of the position of an item in the heap\n    mapping(uint256 => uint256) public positionMapping;\n\n    /// @notice Get the parent index of a given position\n    /// @param pos The position for which to find the parent\n    /// @return The index of the parent node\n    function parent(uint256 pos) private pure returns (uint256) {\n        require(pos != 0, \"Position should not be zero\");\n        return (pos - 1) / 2;\n    }\n\n    /// @notice Swap two nodes in the heap\n    /// @param fpos The position of the first node\n    /// @param spos The position of the second node\n    function swap(uint256 fpos, uint256 spos) private {\n        (heap[fpos], heap[spos]) = (heap[spos], heap[fpos]);\n        (positionMapping[heap[fpos]], positionMapping[heap[spos]]) = (fpos, spos);\n    }\n\n    /// @notice Reheapify the heap starting at a given position\n    /// @dev This ensures that the heap property is maintained\n    /// @param pos The starting position for the heapify operation\n    function maxHeapify(uint256 pos) internal {\n        uint256 left = 2 * pos + 1;\n        uint256 right = 2 * pos + 2;\n\n        uint256 posValue = valueMapping[heap[pos]];\n        uint256 leftValue = valueMapping[heap[left]];\n        uint256 rightValue = valueMapping[heap[right]];\n\n        if (pos >= (size / 2) && pos <= size) return;\n\n        if (posValue < leftValue || posValue < rightValue) {\n            if (leftValue > rightValue) {\n                swap(pos, left);\n                maxHeapify(left);\n            } else {\n                swap(pos, right);\n                maxHeapify(right);\n            }\n        }\n    }\n\n    /// @notice Insert an element into the heap\n    /// @dev The function will revert if the heap is full\n    /// @param itemId The item ID to insert\n    /// @param value The value to insert\n    function insert(uint256 itemId, uint256 value) public onlyAdmin {\n        heap[size] = itemId;\n        valueMapping[itemId] = value; // Update the value mapping\n        positionMapping[itemId] = size; // Update the position mapping\n\n        uint256 current = size;\n        while (current != 0 && valueMapping[heap[current]] > valueMapping[heap[parent(current)]]) {\n            swap(current, parent(current));\n            current = parent(current);\n        }\n        size++;\n    }\n\n    /// @notice Update the value of an existing item in the heap\n    /// @param itemId The item ID whose vote count needs to be updated\n    /// @param newValue The new value for the item\n    /// @dev This function adjusts the heap to maintain the max-heap property after updating the vote count\n    function updateValue(uint256 itemId, uint256 newValue) public onlyAdmin {\n        uint256 position = positionMapping[itemId];\n        uint256 oldValue = valueMapping[itemId];\n\n        // Update the value in the valueMapping\n        valueMapping[itemId] = newValue;\n\n        // Decide whether to perform upwards or downwards heapify\n        if (newValue > oldValue) {\n            // Upwards heapify\n            while (position != 0 && valueMapping[heap[position]] > valueMapping[heap[parent(position)]]) {\n                swap(position, parent(position));\n                position = parent(position);\n            }\n        } else if (newValue < oldValue) maxHeapify(position); // Downwards heapify\n    }\n\n    /// @notice Extract the maximum element from the heap\n    /// @dev The function will revert if the heap is empty\n    /// @return The maximum element from the heap\n    function extractMax() external onlyAdmin returns (uint256, uint256) {\n        require(size > 0, \"Heap is empty\");\n\n        uint256 popped = heap[0];\n        heap[0] = heap[--size];\n        maxHeapify(0);\n\n        return (popped, valueMapping[popped]);\n    }\n\n    /// @notice Get the maximum element from the heap\n    /// @dev The function will revert if the heap is empty\n    /// @return The maximum element from the heap\n    function getMax() public view returns (uint256, uint256) {\n        require(size > 0, \"Heap is empty\");\n        return (heap[0], valueMapping[heap[0]]);\n    }\n\n    ///                                                          ///\n    ///                     MAX HEAP UPGRADE                     ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the new implementation is a registered upgrade\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}"
    }
  ]
}