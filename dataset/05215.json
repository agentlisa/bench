{
  "Title": "[M-02] Loss of precission when calculating the accumulated CANTO per share",
  "Content": "\nWhen calculating the amount of CANTO per share in `update_market`, dividing by `1e18` in `cantoReward` and multiplying by the same value in `accCantoPerShare` rounds down the final value, making the amount of rewards users will receive be less than expected.\n\n### Proof of Concept\n\nIt's well known that Solidity rounds down when doing an integer division, and because of that, it is always recommended to multiply before dividing to avoid that precision loss. However, if we go to:\n\n[**LendingLedger, function update_market**](https://github.com/code-423n4/2024-01-canto/blob/5e0d6f1f981993f83d0db862bcf1b2a49bb6ff50/src/LendingLedger.sol#L67C1-L70C93)\n\n```solidity\n    function update_market(address _market) public {\n        require(lendingMarketWhitelist[_market], \"Market not whitelisted\");\n        MarketInfo storage market = marketInfo[_market];\n        if (block.number > market.lastRewardBlock) {\n            uint256 marketSupply = lendingMarketTotalBalance[_market];\n            if (marketSupply > 0) {\n                uint256 i = market.lastRewardBlock;\n                while (i < block.number) {\n                    uint256 epoch = (i / BLOCK_EPOCH) * BLOCK_EPOCH; // Rewards and voting weights are aligned on a weekly basis\n                    uint256 nextEpoch = i + BLOCK_EPOCH;\n                    uint256 blockDelta = Math.min(nextEpoch, block.number) - i;\n                    uint256 cantoReward = (blockDelta *\n                        cantoPerBlock[epoch] *\n                        gaugeController.gauge_relative_weight_write(_market, epoch)) / 1e18;\n                    market.accCantoPerShare += uint128((cantoReward * 1e18) / marketSupply);\n                    market.secRewardsPerShare += uint128((blockDelta * 1e18) / marketSupply); // TODO: Scaling\n                    i += blockDelta;\n                }\n            }\n            market.lastRewardBlock = uint64(block.number);\n        }\n    }\n```\n\nand we expand the maths behind `accCantoPerShare` and `cantoReward`:\n\n```solidity\n                    uint256 cantoReward = (blockDelta *\n                        cantoPerBlock[epoch] *\n                        gaugeController.gauge_relative_weight_write(_market, epoch)) / 1e18;\n                    market.accCantoPerShare += uint128((cantoReward * 1e18) / marketSupply);\n```\n\nlike follows:\n\n$$(cantoReward \\* 1e18) \\ / \\ marketSupply$$\n\n$$(((blockDelta \\* cantoPerBlock\\[epoch] \\* gaugeController.gauge_relative_weight_write(\\_market, epoch)) \\ / \\ 1e18) \\ \\* \\ 1e18) \\ / \\ marketSupply$$\n\n$$((stuff \\ / \\ 1e18) \\ \\* \\ 1e18) \\ / \\ marketSupply$$\n\nwe see there is a hidden division before a multiplication that is rounding down the whole expression. This is bad as the precision loss can be significant, which leads to the given market having less rewards to offer to its users. Run the next test inside a foundry project to see such a divergence in the precision if we multiply before dividing:\n\n```solidity\n    // @audit the assumes are to avoid under/overflows errors\n    function testPOC(uint256 x) external pure {\n        vm.assume(x < type(uint256).max / 1e18);\n        vm.assume(x > 1e18);\n        console2.log(\"(x / 1e18) * 1e18\", (x / 1e18) * 1e18);\n        console2.log(\"(x * 1e18) / 1e18\", (x * 1e18) / 1e18);\n    }\n```\n\nSome examples:\n\n      [7725] POC::testPOC(1164518589284217277370 [1.164e21]) \n        ├─ [0] VM::assume(true) [staticcall]\n        │   └─ ← ()\n        ├─ [0] VM::assume(true) [staticcall]\n        │   └─ ← ()\n        ├─ [0] console::log((x / 1e18) * 1e18, 1164000000000000000000 [1.164e21]) [staticcall]\n        │   └─ ← ()\n        ├─ [0] console::log((x * 1e18) / 1e18, 1164518589284217277370 [1.164e21]) [staticcall]\n        │   └─ ← ()\n        └─ ← ()\n\n      [7725] POC::testPOC(16826228168456047587 [1.682e19]) \n        ├─ [0] VM::assume(true) [staticcall]\n        │   └─ ← ()\n        ├─ [0] VM::assume(true) [staticcall]\n        │   └─ ← ()\n        ├─ [0] console::log((x / 1e18) * 1e18, 16000000000000000000 [1.6e19]) [staticcall]\n        │   └─ ← ()\n        ├─ [0] console::log((x * 1e18) / 1e18, 16826228168456047587 [1.682e19]) [staticcall]\n        │   └─ ← ()\n        └─ ← ()\n\n      [7725] POC::testPOC(5693222591586418917 [5.693e18]) \n        ├─ [0] VM::assume(true) [staticcall]\n        │   └─ ← ()\n        ├─ [0] VM::assume(true) [staticcall]\n        │   └─ ← ()\n        ├─ [0] console::log((x / 1e18) * 1e18, 5000000000000000000 [5e18]) [staticcall]\n        │   └─ ← ()\n        ├─ [0] console::log((x * 1e18) / 1e18, 5693222591586418917 [5.693e18]) [staticcall]\n        │   └─ ← ()\n        └─ ← ()\n\n### Recommended Mitigation Steps\n\nChange the `update_market` function to:\n\n```diff\n    function update_market(address _market) public {\n        require(lendingMarketWhitelist[_market], \"Market not whitelisted\");\n        MarketInfo storage market = marketInfo[_market];\n        if (block.number > market.lastRewardBlock) {\n            uint256 marketSupply = lendingMarketTotalBalance[_market];\n            if (marketSupply > 0) {\n                uint256 i = market.lastRewardBlock;\n                while (i < block.number) {\n                    uint256 epoch = (i / BLOCK_EPOCH) * BLOCK_EPOCH; // Rewards and voting weights are aligned on a weekly basis\n                    uint256 nextEpoch = i + BLOCK_EPOCH;\n                    uint256 blockDelta = Math.min(nextEpoch, block.number) - i;\n                    uint256 cantoReward = (blockDelta *\n                        cantoPerBlock[epoch] *\n-                       gaugeController.gauge_relative_weight_write(_market, epoch)) / 1e18;\n-                   market.accCantoPerShare += uint128((cantoReward * 1e18) / marketSupply);\n+                       gaugeController.gauge_relative_weight_write(_market, epoch)) * 1e18;\n+                   market.accCantoPerShare += uint128((cantoReward / 1e18) / marketSupply);\n                    market.secRewardsPerShare += uint128((blockDelta * 1e18) / marketSupply); // TODO: Scaling\n                    i += blockDelta;\n                }\n            }\n            market.lastRewardBlock = uint64(block.number);\n        }\n    }\n```\n\n**[OpenCoreCH (Canto) confirmed and commented](https://github.com/code-423n4/2024-01-canto-findings/issues/8#issuecomment-1918855809):**\n > The given examples do not directly apply in our case, we divide a number with 36 decimals by `1e18` and then multiply by `1e18` again (`blockDelta` has 0, `cantoPerBlock` 18, `gauge_relative_weight_write` 18). Looking at it again, this is pretty inefficient, but I cannot think of a situation where it causes a non-negligible (higher than a few wei) difference in the end. Will double check that.\n\n > Ok so I think it could lead to situations where up to 1 CANTO is not distributed, e.g. if `(blockDelta *\n>                         cantoPerBlock[epoch] *\n>                         gaugeController.gauge_relative_weight_write(_market, epoch))` is 0.99e18, it will round down to 0. Not a huge loss, but also not ideal (especially because it can be avoided easily), so will be changed.\n\n**[Alex the Entreprenerd (Judge) commented](https://github.com/code-423n4/2024-01-canto-findings/issues/8#issuecomment-1920971297):**\n > The Warden has shown how, due to rounding a small loss of yield can accrue.\n> \n> Due to the small scope of the codebase and the specificity of the finding, I'm leaving as Medium as of now.\n\n**[OpenCoreCH (Canto) commented](https://github.com/code-423n4/2024-01-canto-findings/issues/8#issuecomment-1923573595)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-canto",
  "Code": [
    {
      "filename": "src/LendingLedger.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport {VotingEscrow} from \"./VotingEscrow.sol\";\nimport {GaugeController} from \"./GaugeController.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract LendingLedger {\n    // Constants\n    uint256 public constant BLOCK_EPOCH = 100_000; // 100000 blocks, roughly 1 week\n\n    // State\n    address public governance;\n    GaugeController public gaugeController;\n    mapping(address => bool) public lendingMarketWhitelist;\n\n    /// @dev Info for each user.\n    struct UserInfo {\n        uint256 amount; // Amount of cNOTE that the user has provided.\n        int256 rewardDebt; // Amount of CANTO entitled to the user.\n        int256 secRewardDebt; // Amount of secondary rewards entitled to the user.\n    }\n\n    /// @dev Info of each lending market.\n    struct MarketInfo {\n        uint128 accCantoPerShare;\n        uint128 secRewardsPerShare;\n        uint64 lastRewardBlock;\n    }\n\n    mapping(address => mapping(address => UserInfo)) public userInfo; // Info of each user for the different lending markets\n    mapping(address => MarketInfo) public marketInfo; // Info of each lending market\n\n    mapping(uint256 => uint256) public cantoPerBlock; // CANTO per block for each epoch\n\n    /// @dev Lending Market => Epoch => Balance\n    mapping(address => uint256) public lendingMarketTotalBalance; // Total balance locked within the market\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance);\n        _;\n    }\n\n    constructor(address _gaugeController, address _governance) {\n        gaugeController = GaugeController(_gaugeController);\n        governance = _governance;\n    }\n\n    /// @notice Set governance address\n    /// @param _governance New governance address\n    function setGovernance(address _governance) external onlyGovernance {\n        governance = _governance;\n    }\n\n    function update_market(address _market) public {\n        require(lendingMarketWhitelist[_market], \"Market not whitelisted\");\n        MarketInfo storage market = marketInfo[_market];\n        if (block.number > market.lastRewardBlock) {\n            uint256 marketSupply = lendingMarketTotalBalance[_market];\n            if (marketSupply > 0) {\n                uint256 i = market.lastRewardBlock;\n                while (i < block.number) {\n                    uint256 epoch = (i / BLOCK_EPOCH) * BLOCK_EPOCH; // Rewards and voting weights are aligned on a weekly basis\n                    uint256 nextEpoch = i + BLOCK_EPOCH;\n                    uint256 blockDelta = Math.min(nextEpoch, block.number) - i;\n                    uint256 cantoReward = (blockDelta *\n                        cantoPerBlock[epoch] *\n                        gaugeController.gauge_relative_weight_write(_market, epoch)) / 1e18;\n                    market.accCantoPerShare += uint128((cantoReward * 1e18) / marketSupply);\n                    market.secRewardsPerShare += uint128((blockDelta * 1e18) / marketSupply); // TODO: Scaling\n                    i += blockDelta;\n                }\n            }\n            market.lastRewardBlock = uint64(block.number);\n        }\n    }\n\n    /// @notice Function that is called by the lending market on cNOTE deposits / withdrawals\n    /// @param _lender The address of the lender\n    /// @param _delta The amount of cNote deposited (positive) or withdrawn (negative)\n    function sync_ledger(address _lender, int256 _delta) external {\n        address lendingMarket = msg.sender;\n        update_market(lendingMarket); // Checks if the market is whitelisted\n        MarketInfo storage market = marketInfo[lendingMarket];\n        UserInfo storage user = userInfo[lendingMarket][_lender];\n\n        if (_delta >= 0) {\n            user.amount += uint256(_delta);\n            user.rewardDebt += int256((uint256(_delta) * market.accCantoPerShare) / 1e18);\n            user.secRewardDebt += int256((uint256(_delta) * market.secRewardsPerShare) / 1e18);\n        } else {\n            user.amount -= uint256(-_delta);\n            user.rewardDebt -= int256((uint256(-_delta) * market.accCantoPerShare) / 1e18);\n            user.secRewardDebt -= int256((uint256(-_delta) * market.secRewardsPerShare) / 1e18);\n        }\n        int256 updatedMarketBalance = int256(lendingMarketTotalBalance[lendingMarket]) + _delta;\n        require(updatedMarketBalance >= 0, \"Market balance underflow\"); // Sanity check performed here, but the market should ensure that this never happens\n        lendingMarketTotalBalance[lendingMarket] = uint256(updatedMarketBalance);\n    }\n\n    /// @notice Claim the CANTO for a given market. Can only be performed for prior (i.e. finished) epochs, not the current one\n    /// @param _market Address of the market\n    function claim(address _market) external {\n        update_market(_market); // Checks if the market is whitelisted\n        MarketInfo storage market = marketInfo[_market];\n        UserInfo storage user = userInfo[_market][msg.sender];\n        int256 accumulatedCanto = int256((uint256(user.amount) * market.accCantoPerShare) / 1e18);\n        int256 cantoToSend = accumulatedCanto - user.rewardDebt;\n\n        user.rewardDebt = accumulatedCanto;\n\n        if (cantoToSend > 0) {\n            (bool success, ) = msg.sender.call{value: uint256(cantoToSend)}(\"\");\n            require(success, \"Failed to send CANTO\");\n        }\n    }\n\n    /// @notice Used by governance to set the overall CANTO rewards per epoch\n    /// @param _fromEpoch From which epoch (provided as block number) to set the rewards from\n    /// @param _toEpoch Until which epoch (provided as block number) to set the rewards to\n    /// @param _amountPerBlock The amount per block\n    function setRewards(\n        uint256 _fromEpoch,\n        uint256 _toEpoch,\n        uint256 _amountPerBlock\n    ) external onlyGovernance {\n        require(_fromEpoch % BLOCK_EPOCH == 0 && _toEpoch % BLOCK_EPOCH == 0, \"Invalid block number\");\n        for (uint256 i = _fromEpoch; i <= _toEpoch; i += BLOCK_EPOCH) {\n            cantoPerBlock[i] = _amountPerBlock;\n        }\n    }\n\n    /// @notice Used by governance to whitelist a lending market\n    /// @param _market Address of the market to whitelist\n    /// @param _isWhiteListed Whether the market is whitelisted or not\n    function whiteListLendingMarket(address _market, bool _isWhiteListed) external onlyGovernance {\n        require(lendingMarketWhitelist[_market] != _isWhiteListed, \"No change\");\n        lendingMarketWhitelist[_market] = _isWhiteListed;\n        if (_isWhiteListed) {\n            marketInfo[_market].lastRewardBlock = uint64(block.number);\n        }\n    }\n\n    receive() external payable {}\n}"
    }
  ]
}