{
  "Title": "M-10: Unable to deposit to Tranche/Adaptor under certain conditions",
  "Content": "# Issue M-10: Unable to deposit to Tranche/Adaptor under certain conditions \n\nSource: https://github.com/sherlock-audit/2024-01-napier-judging/issues/105 \n\n## Found by \nAuditorPraise, xiaoming90\n## Summary\n\nMinting of PT and YT is the core feature of the protocol. Without the ability to mint PT and YT, the protocol would not operate. \n\nThe user cannot deposit into the Tranche to issue new PT + YT under certain conditions.\n\n## Vulnerability Detail\n\nThe comment in Line 133 below mentioned that the `stakeAmount` can be zero. \n\nThe reason is that when `targetBufferEth < (availableEth + queueEthCache)`,  it is possible that there is a pending withdrawal request (`queueEthCache`) and no available ETH left in the buffer (`availableEth = 0`). Refer to the comment in Line 123 below.\n\nAs a result, the code at Line 127 below will restrict the amount of ETH to be staked and set the `stakeAmount` to zero.\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/adapters/BaseLSTAdapter.sol#L133\n\n```solidity\nFile: BaseLSTAdapter.sol\n071:     function prefundedDeposit() external nonReentrant returns (uint256, uint256) {\n..SNIP..\n113:         uint256 stakeAmount;\n114:         unchecked {\n115:             stakeAmount = availableEth + queueEthCache - targetBufferEth; // non-zero, no underflow\n116:         }\n117:         // If the stake amount exceeds 95% of the available ETH, cap the stake amount.\n118:         // This is to prevent the buffer from being completely drained. This is not a complete solution.\n119:         //\n120:         // The condition: stakeAmount > availableEth, is equivalent to: queueEthCache > targetBufferEth\n121:         // Possible scenarios:\n122:         // - Target buffer percentage was changed to a lower value and there is a large withdrawal request pending.\n123:         // - There is a pending withdrawal request and the available ETH are not left in the buffer.\n124:         // - There is no pending withdrawal request and the available ETH are not left in the buffer.\n125:         uint256 maxStakeAmount = (availableEth * 95) / 100;\n126:         if (stakeAmount > maxStakeAmount) {\n127:             stakeAmount = maxStakeAmount; // max 95% of the available ETH\n128:         }\n129: \n130:         /// INTERACT ///\n131:         // Deposit into the yield source\n132:         // Actual amount of ETH spent may be less than the requested amount.\n133:         stakeAmount = _stake(stakeAmount); // stake amount can be 0\n```\n\nHowever, the issue is that when `_stake` function is called with `stakeAmount` set to zero, it will result in zero ETH being staked and Line 77 below will revert.\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/adapters/lido/StEtherAdapter.sol#L77\n\n```solidity\nFile: StEtherAdapter.sol\n64:     /// @inheritdoc BaseLSTAdapter\n65:     /// @dev Lido has a limit on the amount of ETH that can be staked.\n66:     /// @dev Need to check the current staking limit before staking to prevent DoS.\n67:     function _stake(uint256 stakeAmount) internal override returns (uint256) {\n68:         uint256 stakeLimit = STETH.getCurrentStakeLimit();\n69:         if (stakeAmount > stakeLimit) {\n70:             // Cap stake amount\n71:             stakeAmount = stakeLimit;\n72:         }\n73: \n74:         IWETH9(Constants.WETH).withdraw(stakeAmount);\n75:         uint256 _stETHAmt = STETH.submit{value: stakeAmount}(address(this));\n76: \n77:         if (_stETHAmt == 0) revert InvariantViolation();\n78:         return stakeAmount;\n79:     }\n```\n\nA similar issue also occurs for the sFRXETH adaptor. If `FRXETH_MINTER.submit` function is called with `stakeAmount == 0`, it will revert.\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/adapters/frax/SFrxETHAdapter.sol#L76\n\n```solidity\nFile: SFrxETHAdapter.sol\n71:     /// @notice Mint sfrxETH using WETH\n72:     function _stake(uint256 stakeAmount) internal override returns (uint256) {\n73:         IWETH9(Constants.WETH).withdraw(stakeAmount);\n74:         FRXETH_MINTER.submit{value: stakeAmount}();\n75:         uint256 received = STAKED_FRXETH.deposit(stakeAmount, address(this));\n76:         if (received == 0) revert InvariantViolation();\n77: \n78:         return stakeAmount;\n79:     }\n```\n\nThe following shows that the `FRXETH_MINTER.submit` function will revert if submitted ETH is zero below.\n\nhttps://etherscan.io/address/0xbAFA44EFE7901E04E39Dad13167D089C559c1138#code#F1#L89\n\n```solidity\n/// @notice Mint frxETH to the recipient using sender's funds. Internal portion\nfunction _submit(address recipient) internal nonReentrant {\n    // Initial pause and value checks\n    require(!submitPaused, \"Submit is paused\");\n    require(msg.value != 0, \"Cannot submit 0\");\n```\n\n## Impact\n\nMinting of PT and YT is the core feature of the protocol. Without the ability to mint PT and YT, the protocol would not operate. The user cannot deposit into the Tranche to issue new PT + YT under certain conditions. Breaking of core protocol/contract functionality.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/adapters/BaseLSTAdapter.sol#L133\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nShort-circuit the `_stake` function by returning zero value immediately if the `stakeAmount` is zero.\n\nFile: StEtherAdapter.sol\n\n```diff\nfunction _stake(uint256 stakeAmount) internal override returns (uint256) {\n+\tif (stakeAmount == 0) return 0;\t\n\tuint256 stakeLimit = STETH.getCurrentStakeLimit();\n\tif (stakeAmount > stakeLimit) {\n\t\t// Cap stake amount\n\t\tstakeAmount = stakeLimit;\n\t}\n\n\tIWETH9(Constants.WETH).withdraw(stakeAmount);\n\tuint256 _stETHAmt = STETH.submit{value: stakeAmount}(address(this));\n\n\tif (_stETHAmt == 0) revert InvariantViolation();\n\treturn stakeAmount;\n}\n```\n\nFile: SFrxETHAdapter.sol\n\n```diff\nfunction _stake(uint256 stakeAmount) internal override returns (uint256) {\n+\tif (stakeAmount == 0) return 0;\t\n\tIWETH9(Constants.WETH).withdraw(stakeAmount);\n\tFRXETH_MINTER.submit{value: stakeAmount}();\n\tuint256 received = STAKED_FRXETH.deposit(stakeAmount, address(this));\n\tif (received == 0) revert InvariantViolation();\n\n\treturn stakeAmount;\n}\n```\n\n\n\n## Discussion\n\n**sherlock-admin3**\n\nThe protocol team fixed this issue in PR/commit https://github.com/napierfi/napier-v1/pull/169.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/171",
  "Code": [
    {
      "filename": "napier-v1/src/adapters/BaseLSTAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport {IWETH9} from \"../interfaces/IWETH9.sol\";\nimport {IERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/IERC20.sol\";\n\nimport {BaseAdapter} from \"../BaseAdapter.sol\";\nimport {ERC4626} from \"@openzeppelin/contracts@4.9.3/token/ERC20/extensions/ERC4626.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts@4.9.3/security/ReentrancyGuard.sol\";\n\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport {WETH} from \"../Constants.sol\";\n\n/// @notice Adapter for Liquid Staking Token (LST)\n/// @dev This adapter facilitates immediate ETH withdrawals without a waiting period.\n/// It maintains an ETH buffer to enable these withdrawals. The size of this buffer is determined\n/// by a specified desired buffer percentage. The maintenance of the buffer\n/// are handled by a designated account.\n/// @dev LST Adapter is NOT compatible with EIP4626 standard. We don't expect it to be used by other contracts other than Tranche.\nabstract contract BaseLSTAdapter is BaseAdapter, ERC4626, ReentrancyGuard {\n    using SafeCast for uint256;\n\n    uint256 constant BUFFER_PERCENTAGE_PRECISION = 1e18; // 1e18 = 100%\n    uint256 constant MIN_BUFFER_PERCENTAGE = 0.01 * 1e18; // 1%\n\n    /// @notice Rebalancer of the ETH buffer, can be set by the owner\n    /// @notice The account can request a withdrawal\n    address public rebalancer;\n\n    /// @notice Desired buffer percentage in WAD\n    uint256 public targetBufferPercentage = 0.1 * 1e18; // 10% desired buffer percentage\n\n    /// @notice Amount of ETH pending withdrawal\n    uint128 public withdrawalQueueEth;\n\n    /// @notice Amount of ETH available (Buffer), does not include pending withdrawal. Internal accounting of ETH\n    uint128 public bufferEth;\n\n    /// @notice Request ID of the withdrawal request\n    /// @dev 0 if there is no pending withdrawal request\n    uint256 public requestId;\n\n    error ZeroAssets();\n    error ZeroShares();\n    error InsufficientBuffer();\n    error BufferTooLarge();\n    error InvalidBufferPercentage();\n    error WithdrawalPending();\n    error NoPendingWithdrawal();\n    error NotRebalancer();\n    error NotImplemented();\n\n    /// @notice Reverts if the caller is not the rebalancer\n    modifier onlyRebalancer() {\n        if (rebalancer != msg.sender) revert NotRebalancer();\n        _;\n    }\n\n    /// @dev Adapter itself is the target token\n    constructor(address _rebalancer) BaseAdapter(WETH, address(this)) ERC4626((IWETH9(WETH))) {\n        rebalancer = _rebalancer;\n    }\n\n    ////////////////////////////////////////////////////////\n    /// ADAPTER METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Handles prefunded deposits\n    /// @return The amount of staked ETH\n    /// @return The amount of shares minted\n    function prefundedDeposit() external nonReentrant returns (uint256, uint256) {\n        uint256 bufferEthCache = bufferEth; // cache storage reads\n        uint256 queueEthCache = withdrawalQueueEth; // cache storage reads\n        uint256 assets = IWETH9(WETH).balanceOf(address(this)) - bufferEthCache; // amount of WETH deposited at this time\n        uint256 shares = previewDeposit(assets);\n\n        if (assets == 0) return (0, 0);\n        if (shares == 0) revert ZeroShares();\n\n        // Calculate the target buffer amount considering the user's deposit.\n        // bufferRatio is defined as the ratio of ETH balance to the total assets in the adapter in ETH.\n        // Formula:\n        // desiredBufferRatio = (withdrawalQueueEth + bufferEth + assets - s) / (withdrawalQueueEth + bufferEth + stakedEth + assets)\n        // Where:\n        // assets := Amount of ETH the user is depositing\n        // s := Amount of ETH to stake at this time, s <= bufferEth + assets.\n        //\n        // Thus, the formula can be simplified to:\n        // s = (withdrawalQueueEth + bufferEth + assets) - (withdrawalQueueEth + bufferEth + stakedEth + assets) * desiredBufferRatio\n        //   = (withdrawalQueueEth + bufferEth + assets) - targetBufferEth\n        //\n        // Flow:\n        // If `s` <= 0, don't stake any ETH.\n        // If `s` < bufferEth + assets, stake `s` amount of ETH.\n        // If `s` >= bufferEth + assets, all available ETH can be staked in theory.\n        // However, we cap the stake amount. This is to prevent the buffer from being completely drained.\n        //\n        // Let `a` be the available amount of ETH in the buffer after the deposit. `a` is calculated as:\n        // a = (bufferEth + assets) - s\n        uint256 targetBufferEth = ((totalAssets() + assets) * targetBufferPercentage) / BUFFER_PERCENTAGE_PRECISION;\n\n        /// WRITE ///\n        _mint(msg.sender, shares);\n\n        uint256 availableEth = bufferEthCache + assets; // non-zero\n\n        // If the buffer is insufficient: Doesn't stake any of the deposit\n        if (targetBufferEth >= availableEth + queueEthCache) {\n            bufferEth = availableEth.toUint128();\n            return (assets, shares);\n        }\n\n        uint256 stakeAmount;\n        unchecked {\n            stakeAmount = availableEth + queueEthCache - targetBufferEth; // non-zero, no underflow\n        }\n        // If the stake amount exceeds 95% of the available ETH, cap the stake amount.\n        // This is to prevent the buffer from being completely drained. This is not a complete solution.\n        //\n        // The condition: stakeAmount > availableEth, is equivalent to: queueEthCache > targetBufferEth\n        // Possible scenarios:\n        // - Target buffer percentage was changed to a lower value and there is a large withdrawal request pending.\n        // - There is a pending withdrawal request and the available ETH are not left in the buffer.\n        // - There is no pending withdrawal request and the available ETH are not left in the buffer.\n        uint256 maxStakeAmount = (availableEth * 95) / 100;\n        if (stakeAmount > maxStakeAmount) {\n            stakeAmount = maxStakeAmount; // max 95% of the available ETH\n        }\n\n        /// INTERACT ///\n        // Deposit into the yield source\n        // Actual amount of ETH spent may be less than the requested amount.\n        stakeAmount = _stake(stakeAmount); // stake amount can be 0\n\n        /// WRITE ///\n        bufferEth = (availableEth - stakeAmount).toUint128(); // no underflow theoretically\n\n        return (assets, shares);\n    }\n\n    /// @notice Handles prefunded redemptions\n    /// @dev Withdraw from the buffer. If the buffer is insufficient, revert with an error\n    /// @param recipient The address to receive the redeemed WETH\n    /// @return The amount of redeemed WETH\n    /// @return The amount of shares burned\n    function prefundedRedeem(address recipient) external virtual returns (uint256, uint256) {\n        uint256 shares = balanceOf(address(this));\n        uint256 assets = previewRedeem(shares);\n\n        if (shares == 0) return (0, 0);\n        if (assets == 0) revert ZeroAssets();\n\n        uint256 bufferEthCache = bufferEth;\n        // If the buffer is insufficient, shares cannot be redeemed immediately\n        // Need to wait for the withdrawal to be completed and the buffer to be refilled.\n        if (assets > bufferEthCache) revert InsufficientBuffer();\n\n        unchecked {\n            /// WRITE ///\n            // Reduce the buffer and burn the shares\n            bufferEth = (bufferEthCache - assets).toUint128(); // no underflow\n            _burn(address(this), shares);\n        }\n\n        /// INTERACT ///\n        IWETH9(WETH).transfer(recipient, assets);\n\n        return (assets, shares);\n    }\n\n    ////////////////////////////////////////////////////////\n    /// VIRTUAL METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Request a withdrawal of ETH\n    /// @dev This function is called by only the rebalancer\n    /// @dev Reverts if there is a pending withdrawal request\n    /// @dev Reverts if the buffer is sufficient to cover the desired buffer percentage of the total assets\n    function requestWithdrawal() external virtual nonReentrant onlyRebalancer {\n        if (requestId != 0) revert WithdrawalPending();\n\n        uint256 targetBufferEth = (totalAssets() * targetBufferPercentage) / BUFFER_PERCENTAGE_PRECISION;\n\n        // If the buffer exceeds the target buffer, revert.\n        // If the buffer is insufficient, request a withdrawal to refill the buffer.\n        // note: use `>=` instead of `>` to prevent amount of ETH to withdraw to be 0\n        // note: At this point, `withdrawalQueueEth` is 0 because there is no pending withdrawal request.\n        // `nonStakedEth` = `bufferEth` + 0 = `bufferEth`\n        uint256 bufferEthCache = bufferEth;\n        if (bufferEthCache >= targetBufferEth) revert BufferTooLarge();\n\n        unchecked {\n            // Ensure that `withdrawAmount` is non-zero and withdrawalQueueEth is zero.\n            uint256 withdrawAmount = targetBufferEth - bufferEthCache; // no underflow\n\n            /// WRITE & INTERACT ///\n            // Record the pending withdrawal request\n            // Request a withdrawal\n            (uint256 queueAmount, uint256 _requestId) = _requestWithdrawal(withdrawAmount);\n            withdrawalQueueEth = queueAmount.toUint128();\n            requestId = _requestId;\n        }\n    }\n\n    /// @notice Request a withdrawal of all staked ETH\n    /// @dev This function is called by only the rebalancer\n    /// @dev Reverts if there is a pending withdrawal request\n    function requestWithdrawalAll() external virtual;\n\n    /// @notice Claim the finized withdrawal request\n    /// @dev This function is called by anyone\n    /// @dev Reverts if there is no pending withdrawal request\n    function claimWithdrawal() external virtual;\n\n    /// @notice Stake the given amount of ETH into the yield source\n    /// @param stakeAmount The amount of ETH to stake\n    /// @return The actual amount of ETH spent\n    function _stake(uint256 stakeAmount) internal virtual returns (uint256);\n\n    /// @notice Request a withdrawal of the given amount of ETH from the yield source\n    /// @param withdrawAmount The amount of ETH to withdraw\n    /// @return queueAmount The amount of ETH withdrawn\n    /// @return requestId The request Id of the withdrawal request\n    function _requestWithdrawal(\n        uint256 withdrawAmount\n    ) internal virtual returns (uint256 queueAmount, uint256 requestId);\n\n    /// @dev Must be overridden by inheriting contracts\n    /// @inheritdoc ERC4626\n    function totalAssets() public view virtual override returns (uint256) {}\n\n    function scale() external view override returns (uint256) {\n        return convertToAssets(1e18);\n    }\n\n    /// @notice Returns the present buffer percentage in WAD. e.g) 10% => 0.1 * 1e18\n    function bufferPresentPercentage() external view returns (uint256) {\n        return ((bufferEth + withdrawalQueueEth) * BUFFER_PERCENTAGE_PRECISION) / totalAssets();\n    }\n\n    ////////////////////////////////////////////////////////\n    /// ADMIN METHOD\n    ////////////////////////////////////////////////////////\n\n    function setRebalancer(address _rebalancer) external onlyOwner {\n        rebalancer = _rebalancer;\n    }\n\n    /// @notice Set the maximum buffer percentage\n    /// @param _targetBufferPercentage The maximum buffer percentage in WAD\n    function setTargetBufferPercentage(uint256 _targetBufferPercentage) external onlyRebalancer {\n        if (_targetBufferPercentage < MIN_BUFFER_PERCENTAGE || _targetBufferPercentage > BUFFER_PERCENTAGE_PRECISION) {\n            revert InvalidBufferPercentage();\n        }\n        targetBufferPercentage = _targetBufferPercentage;\n    }\n\n    /////////////////////////////////////////////////////////\n    /// NOT IMPLEMENTED METHOD\n    /////////////////////////////////////////////////////////\n\n    /// @notice direct deposit,mint,redeem,withdraw should be reverted.\n    function deposit(uint256, address) public pure override returns (uint256) {\n        revert NotImplemented();\n    }\n\n    function mint(uint256, address) public pure override returns (uint256) {\n        revert NotImplemented();\n    }\n\n    function withdraw(uint256, address, address) public pure override returns (uint256) {\n        revert NotImplemented();\n    }\n\n    function redeem(uint256, address, address) public pure override returns (uint256) {\n        revert NotImplemented();\n    }\n}"
    },
    {
      "filename": "napier-v1/src/adapters/lido/StEtherAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport {IWETH9} from \"../../interfaces/IWETH9.sol\";\nimport {IStETH} from \"./interfaces/IStETH.sol\";\nimport {IWithdrawalQueueERC721} from \"./interfaces/IWithdrawalQueueERC721.sol\";\n\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport \"../../Constants.sol\" as Constants;\n\nimport {ERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/ERC20.sol\";\nimport {BaseLSTAdapter} from \"../BaseLSTAdapter.sol\";\n\n/// @title StETHAdapter - estETH\n/// @dev Important security note:\n/// 1. The vault share price (estETH / WETH) increases as stETH accrues staking rewards.\n/// StETH withdrawals are processed by the Lido withdrawal queue contract.\n/// While waiting for the stETH withdrawal request to be finalized, estETH holders don't receive\n/// staking rewards from the pending stETH and still take risks during withdrawal.\n///\n/// 2. This contract doesn't independently keep track of the stETH balance, so it is possible\n/// for an attacker to directly transfer stETH to this contract, increase the share price.\ncontract StEtherAdapter is BaseLSTAdapter {\n    using SafeCast for uint256;\n\n    error InvariantViolation();\n\n    /// @notice stETH\n    IStETH constant STETH = IStETH(Constants.STETH);\n\n    /// @dev Lido WithdrawalQueueERC721\n    IWithdrawalQueueERC721 constant LIDO_WITHDRAWAL_QUEUE = IWithdrawalQueueERC721(Constants.LIDO_WITHDRAWAL_QUEUE);\n\n    receive() external payable {}\n\n    constructor(address _rebalancer) BaseLSTAdapter(_rebalancer) ERC20(\"Napier StETH Adapter\", \"eStETH\") {\n        STETH.approve(address(LIDO_WITHDRAWAL_QUEUE), type(uint256).max);\n    }\n\n    /// @notice Claim withdrawal from Lido\n    /// @dev Reverts if there is no pending withdrawal\n    /// @dev Reverts if the withdrawal request has not been finalized yet by Lido\n    /// @dev note estETH scale may be decreased if Lido has been slashed by misbehavior.\n    function claimWithdrawal() external override nonReentrant {\n        uint256 _requestId = requestId;\n        if (_requestId == 0) revert NoPendingWithdrawal();\n\n        /// WRITE ///\n        delete withdrawalQueueEth;\n        delete requestId;\n\n        /// INTERACT ///\n        // Claimed amount can be less than requested amount due to slashing.\n        uint256 balanceBefore = address(this).balance;\n        LIDO_WITHDRAWAL_QUEUE.claimWithdrawal(_requestId);\n        uint256 claimed = address(this).balance - balanceBefore;\n\n        /// WRITE ///\n        bufferEth += claimed.toUint128();\n\n        IWETH9(Constants.WETH).deposit{value: claimed}();\n    }\n\n    /// @inheritdoc BaseLSTAdapter\n    /// @dev Lido has a limit on the amount of ETH that can be staked.\n    /// @dev Need to check the current staking limit before staking to prevent DoS.\n    function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        uint256 stakeLimit = STETH.getCurrentStakeLimit();\n        if (stakeAmount > stakeLimit) {\n            // Cap stake amount\n            stakeAmount = stakeLimit;\n        }\n\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        uint256 _stETHAmt = STETH.submit{value: stakeAmount}(address(this));\n\n        if (_stETHAmt == 0) revert InvariantViolation();\n        return stakeAmount;\n    }\n\n    /// @inheritdoc BaseLSTAdapter\n    /// @dev Lido has a limit on the amount of ETH that can be unstaked.\n    function requestWithdrawalAll() external override nonReentrant onlyRebalancer {\n        if (requestId != 0) revert WithdrawalPending();\n        /// INTERACT ///\n        (uint256 queuedEth, uint256 _requestId) = _requestWithdrawal(STETH.balanceOf(address(this)));\n        /// WRITE ///\n        withdrawalQueueEth = queuedEth.toUint128();\n        requestId = _requestId;\n    }\n\n    /// @dev note stETH holders don't receive rewards but still take risks during withdrawal.\n    function _requestWithdrawal(uint256 withdrawAmount) internal override returns (uint256, uint256) {\n        // Validate withdrawAmount - https://docs.lido.fi/contracts/withdrawal-queue-erc721/#request\n        // The minimal amount for a request is 100 wei, and the maximum is 1000 eth\n        if (withdrawAmount < 100) return (0, 0);\n        if (withdrawAmount > 500 ether) withdrawAmount = 500 ether; // half of the maximum\n\n        // stETH amount\n        uint256[] memory _amounts = new uint256[](1);\n\n        /// INTERACT ///\n        // The amount of ether that will be withdrawn is limited to\n        // the number of stETH tokens transferred to this contract at the moment of request.\n        // So, we will not receive the rewards for the period of time while these tokens stay in the queue.\n        _amounts[0] = withdrawAmount;\n        uint256[] memory _requestIds = LIDO_WITHDRAWAL_QUEUE.requestWithdrawals(_amounts, address(this)); // Dev: Ensure id is not 0\n        if (_requestIds[0] == 0) revert InvariantViolation();\n\n        /// WRITE ///\n        return (withdrawAmount, _requestIds[0]);\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        uint256 stEthBalance = STETH.balanceOf(address(this));\n        return withdrawalQueueEth + bufferEth + stEthBalance;\n    }\n}"
    },
    {
      "filename": "napier-v1/src/adapters/frax/SFrxETHAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/IERC20.sol\";\nimport {IWETH9} from \"../../interfaces/IWETH9.sol\";\nimport {IERC4626} from \"@openzeppelin/contracts@4.9.3/interfaces/IERC4626.sol\";\nimport {IFrxETHMinter} from \"./interfaces/IFrxETHMinter.sol\";\nimport {IFraxEtherRedemptionQueue} from \"./interfaces/IFraxEtherRedemptionQueue.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts@4.9.3/token/ERC721/IERC721Receiver.sol\";\n\nimport {ERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/ERC20.sol\";\nimport {BaseLSTAdapter} from \"../BaseLSTAdapter.sol\";\n\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport \"../../Constants.sol\" as Constants;\n\n/// @title SFrxETHAdapter - esfrxETH\n/// @dev Important security note:\n/// 1. The vault share price (esfrxETH / WETH) increases as sfrxETH accrues staking rewards.\n/// However, the share price decreases when frxETH (sfrxETH) is withdrawn.\n/// Withdrawals are processed by the FraxEther redemption queue contract.\n/// Frax takes a fee at the time of withdrawal requests, which temporarily reduces the share price.\n/// This loss is pro-rated among all esfrxETH holders.\n/// As a mitigation measure, we allow only authorized rebalancers to request withdrawals.\n///\n/// 2. This contract doesn't independently keep track of the sfrxETH balance, so it is possible\n/// for an attacker to directly transfer sfrxETH to this contract, increase the share price.\ncontract SFrxETHAdapter is BaseLSTAdapter, IERC721Receiver {\n    using SafeCast for uint256;\n\n    error InvariantViolation();\n\n    /// @notice frxETH\n    IERC20 constant FRXETH = IERC20(Constants.FRXETH);\n\n    /// @notice sfrxETH\n    IERC4626 constant STAKED_FRXETH = IERC4626(Constants.STAKED_FRXETH);\n\n    /// @dev FraxEther redemption queue contract https://etherscan.io/address/0x82bA8da44Cd5261762e629dd5c605b17715727bd\n    IFraxEtherRedemptionQueue constant REDEMPTION_QUEUE =\n        IFraxEtherRedemptionQueue(0x82bA8da44Cd5261762e629dd5c605b17715727bd);\n\n    /// @dev FraxEther minter contract\n    IFrxETHMinter constant FRXETH_MINTER = IFrxETHMinter(0xbAFA44EFE7901E04E39Dad13167D089C559c1138);\n\n    receive() external payable {}\n\n    constructor(address _rebalancer) BaseLSTAdapter(_rebalancer) ERC20(\"Napier FrxETH Adapter\", \"eFrxETH\") {\n        FRXETH.approve(address(STAKED_FRXETH), type(uint256).max);\n        FRXETH.approve(address(REDEMPTION_QUEUE), type(uint256).max);\n    }\n\n    function claimWithdrawal() external override {\n        uint256 _requestId = requestId;\n        uint256 _withdrawalQueueEth = withdrawalQueueEth;\n        if (_requestId == 0) revert NoPendingWithdrawal();\n\n        /// WRITE ///\n        delete withdrawalQueueEth;\n        delete requestId;\n        bufferEth += _withdrawalQueueEth.toUint128();\n\n        /// INTERACT ///\n        uint256 balanceBefore = address(this).balance;\n        REDEMPTION_QUEUE.burnRedemptionTicketNft(_requestId, payable(this));\n        if (address(this).balance < balanceBefore + _withdrawalQueueEth) revert InvariantViolation();\n\n        IWETH9(Constants.WETH).deposit{value: _withdrawalQueueEth}();\n    }\n\n    /// @notice Mint sfrxETH using WETH\n    function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        FRXETH_MINTER.submit{value: stakeAmount}();\n        uint256 received = STAKED_FRXETH.deposit(stakeAmount, address(this));\n        if (received == 0) revert InvariantViolation();\n\n        return stakeAmount;\n    }\n\n    function requestWithdrawalAll() external override nonReentrant onlyRebalancer {\n        if (requestId != 0) revert WithdrawalPending();\n        uint256 _requestId = REDEMPTION_QUEUE.redemptionQueueState().nextNftId;\n        /// INTERACT ///\n        // Redeem all sfrxETH for frxETH\n        uint256 balance = STAKED_FRXETH.balanceOf(address(this));\n        uint256 withdrawAmount = STAKED_FRXETH.redeem(balance, address(this), address(this));\n\n        REDEMPTION_QUEUE.enterRedemptionQueue({amountToRedeem: withdrawAmount.toUint120(), recipient: address(this)});\n\n        /// WRITE ///\n        withdrawalQueueEth = REDEMPTION_QUEUE.nftInformation(_requestId).amount; // cast uint120 to uint128\n        requestId = _requestId;\n    }\n\n    /// @notice Request about `withdrawAmount` of ETH to be unstaked from sfrxETH.\n    /// @param withdrawAmount Amount of ETH to withdraw\n    function _requestWithdrawal(uint256 withdrawAmount) internal override returns (uint256, uint256) {\n        uint256 _requestId = REDEMPTION_QUEUE.redemptionQueueState().nextNftId; // Dev: Ensure id is not 0\n        /// INTERACT ///\n        uint256 frxEthBalanceBefore = FRXETH.balanceOf(address(this)); // 0 is expected if no one has donated frxETH to this contract\n        STAKED_FRXETH.withdraw(withdrawAmount, address(this), address(this));\n        uint256 frxEthWithdrawn = FRXETH.balanceOf(address(this)) - frxEthBalanceBefore;\n        // Transfer frxETH and mint redemption ticket.\n        // note: `amountToRedeem` is an amount in frxETH, not ETH.\n        // However, frxETH would be soft-pegged to ETH, so we treat them as 1:1 for simplicity here.\n        // Also, actual ETH amount to withdraw would be slightly less than `withdrawAmount` due to the redemption fee.\n        REDEMPTION_QUEUE.enterRedemptionQueue({amountToRedeem: frxEthWithdrawn.toUint120(), recipient: address(this)});\n        /// WRITE ///\n        // Note: The redemption queue contract returns the exact amount of ETH to withdraw.\n        uint256 queueEth = REDEMPTION_QUEUE.nftInformation(_requestId).amount; // cast uint120 to uint128\n        return (queueEth, _requestId);\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        uint256 balance = STAKED_FRXETH.balanceOf(address(this));\n        uint256 balanceInFrxEth = STAKED_FRXETH.convertToAssets(balance);\n        return withdrawalQueueEth + bufferEth + balanceInFrxEth; // 1 frxEth = 1 ETH\n    }\n\n    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n        return 0x150b7a02; // bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n    }\n}"
    },
    {
      "filename": "napier-v1/src/adapters/BaseLSTAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport {IWETH9} from \"../interfaces/IWETH9.sol\";\nimport {IERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/IERC20.sol\";\n\nimport {BaseAdapter} from \"../BaseAdapter.sol\";\nimport {ERC4626} from \"@openzeppelin/contracts@4.9.3/token/ERC20/extensions/ERC4626.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts@4.9.3/security/ReentrancyGuard.sol\";\n\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport {WETH} from \"../Constants.sol\";\n\n/// @notice Adapter for Liquid Staking Token (LST)\n/// @dev This adapter facilitates immediate ETH withdrawals without a waiting period.\n/// It maintains an ETH buffer to enable these withdrawals. The size of this buffer is determined\n/// by a specified desired buffer percentage. The maintenance of the buffer\n/// are handled by a designated account.\n/// @dev LST Adapter is NOT compatible with EIP4626 standard. We don't expect it to be used by other contracts other than Tranche.\nabstract contract BaseLSTAdapter is BaseAdapter, ERC4626, ReentrancyGuard {\n    using SafeCast for uint256;\n\n    uint256 constant BUFFER_PERCENTAGE_PRECISION = 1e18; // 1e18 = 100%\n    uint256 constant MIN_BUFFER_PERCENTAGE = 0.01 * 1e18; // 1%\n\n    /// @notice Rebalancer of the ETH buffer, can be set by the owner\n    /// @notice The account can request a withdrawal\n    address public rebalancer;\n\n    /// @notice Desired buffer percentage in WAD\n    uint256 public targetBufferPercentage = 0.1 * 1e18; // 10% desired buffer percentage\n\n    /// @notice Amount of ETH pending withdrawal\n    uint128 public withdrawalQueueEth;\n\n    /// @notice Amount of ETH available (Buffer), does not include pending withdrawal. Internal accounting of ETH\n    uint128 public bufferEth;\n\n    /// @notice Request ID of the withdrawal request\n    /// @dev 0 if there is no pending withdrawal request\n    uint256 public requestId;\n\n    error ZeroAssets();\n    error ZeroShares();\n    error InsufficientBuffer();\n    error BufferTooLarge();\n    error InvalidBufferPercentage();\n    error WithdrawalPending();\n    error NoPendingWithdrawal();\n    error NotRebalancer();\n    error NotImplemented();\n\n    /// @notice Reverts if the caller is not the rebalancer\n    modifier onlyRebalancer() {\n        if (rebalancer != msg.sender) revert NotRebalancer();\n        _;\n    }\n\n    /// @dev Adapter itself is the target token\n    constructor(address _rebalancer) BaseAdapter(WETH, address(this)) ERC4626((IWETH9(WETH))) {\n        rebalancer = _rebalancer;\n    }\n\n    ////////////////////////////////////////////////////////\n    /// ADAPTER METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Handles prefunded deposits\n    /// @return The amount of staked ETH\n    /// @return The amount of shares minted\n    function prefundedDeposit() external nonReentrant returns (uint256, uint256) {\n        uint256 bufferEthCache = bufferEth; // cache storage reads\n        uint256 queueEthCache = withdrawalQueueEth; // cache storage reads\n        uint256 assets = IWETH9(WETH).balanceOf(address(this)) - bufferEthCache; // amount of WETH deposited at this time\n        uint256 shares = previewDeposit(assets);\n\n        if (assets == 0) return (0, 0);\n        if (shares == 0) revert ZeroShares();\n\n        // Calculate the target buffer amount considering the user's deposit.\n        // bufferRatio is defined as the ratio of ETH balance to the total assets in the adapter in ETH.\n        // Formula:\n        // desiredBufferRatio = (withdrawalQueueEth + bufferEth + assets - s) / (withdrawalQueueEth + bufferEth + stakedEth + assets)\n        // Where:\n        // assets := Amount of ETH the user is depositing\n        // s := Amount of ETH to stake at this time, s <= bufferEth + assets.\n        //\n        // Thus, the formula can be simplified to:\n        // s = (withdrawalQueueEth + bufferEth + assets) - (withdrawalQueueEth + bufferEth + stakedEth + assets) * desiredBufferRatio\n        //   = (withdrawalQueueEth + bufferEth + assets) - targetBufferEth\n        //\n        // Flow:\n        // If `s` <= 0, don't stake any ETH.\n        // If `s` < bufferEth + assets, stake `s` amount of ETH.\n        // If `s` >= bufferEth + assets, all available ETH can be staked in theory.\n        // However, we cap the stake amount. This is to prevent the buffer from being completely drained.\n        //\n        // Let `a` be the available amount of ETH in the buffer after the deposit. `a` is calculated as:\n        // a = (bufferEth + assets) - s\n        uint256 targetBufferEth = ((totalAssets() + assets) * targetBufferPercentage) / BUFFER_PERCENTAGE_PRECISION;\n\n        /// WRITE ///\n        _mint(msg.sender, shares);\n\n        uint256 availableEth = bufferEthCache + assets; // non-zero\n\n        // If the buffer is insufficient: Doesn't stake any of the deposit\n        if (targetBufferEth >= availableEth + queueEthCache) {\n            bufferEth = availableEth.toUint128();\n            return (assets, shares);\n        }\n\n        uint256 stakeAmount;\n        unchecked {\n            stakeAmount = availableEth + queueEthCache - targetBufferEth; // non-zero, no underflow\n        }\n        // If the stake amount exceeds 95% of the available ETH, cap the stake amount.\n        // This is to prevent the buffer from being completely drained. This is not a complete solution.\n        //\n        // The condition: stakeAmount > availableEth, is equivalent to: queueEthCache > targetBufferEth\n        // Possible scenarios:\n        // - Target buffer percentage was changed to a lower value and there is a large withdrawal request pending.\n        // - There is a pending withdrawal request and the available ETH are not left in the buffer.\n        // - There is no pending withdrawal request and the available ETH are not left in the buffer.\n        uint256 maxStakeAmount = (availableEth * 95) / 100;\n        if (stakeAmount > maxStakeAmount) {\n            stakeAmount = maxStakeAmount; // max 95% of the available ETH\n        }\n\n        /// INTERACT ///\n        // Deposit into the yield source\n        // Actual amount of ETH spent may be less than the requested amount.\n        stakeAmount = _stake(stakeAmount); // stake amount can be 0\n\n        /// WRITE ///\n        bufferEth = (availableEth - stakeAmount).toUint128(); // no underflow theoretically\n\n        return (assets, shares);\n    }\n\n    /// @notice Handles prefunded redemptions\n    /// @dev Withdraw from the buffer. If the buffer is insufficient, revert with an error\n    /// @param recipient The address to receive the redeemed WETH\n    /// @return The amount of redeemed WETH\n    /// @return The amount of shares burned\n    function prefundedRedeem(address recipient) external virtual returns (uint256, uint256) {\n        uint256 shares = balanceOf(address(this));\n        uint256 assets = previewRedeem(shares);\n\n        if (shares == 0) return (0, 0);\n        if (assets == 0) revert ZeroAssets();\n\n        uint256 bufferEthCache = bufferEth;\n        // If the buffer is insufficient, shares cannot be redeemed immediately\n        // Need to wait for the withdrawal to be completed and the buffer to be refilled.\n        if (assets > bufferEthCache) revert InsufficientBuffer();\n\n        unchecked {\n            /// WRITE ///\n            // Reduce the buffer and burn the shares\n            bufferEth = (bufferEthCache - assets).toUint128(); // no underflow\n            _burn(address(this), shares);\n        }\n\n        /// INTERACT ///\n        IWETH9(WETH).transfer(recipient, assets);\n\n        return (assets, shares);\n    }\n\n    ////////////////////////////////////////////////////////\n    /// VIRTUAL METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Request a withdrawal of ETH\n    /// @dev This function is called by only the rebalancer\n    /// @dev Reverts if there is a pending withdrawal request\n    /// @dev Reverts if the buffer is sufficient to cover the desired buffer percentage of the total assets\n    function requestWithdrawal() external virtual nonReentrant onlyRebalancer {\n        if (requestId != 0) revert WithdrawalPending();\n\n        uint256 targetBufferEth = (totalAssets() * targetBufferPercentage) / BUFFER_PERCENTAGE_PRECISION;\n\n        // If the buffer exceeds the target buffer, revert.\n        // If the buffer is insufficient, request a withdrawal to refill the buffer.\n        // note: use `>=` instead of `>` to prevent amount of ETH to withdraw to be 0\n        // note: At this point, `withdrawalQueueEth` is 0 because there is no pending withdrawal request.\n        // `nonStakedEth` = `bufferEth` + 0 = `bufferEth`\n        uint256 bufferEthCache ="
    }
  ]
}