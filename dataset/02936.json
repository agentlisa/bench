{
  "Title": "H-1: Attacker can steal the accumulated topup fees in the `topupproxy` contract's balance",
  "Content": "# Issue H-1: Attacker can steal the accumulated topup fees in the `topupproxy` contract's balance \n\nSource: https://github.com/sherlock-audit/2022-10-mover-judging/issues/112 \n\n## Found by \nminhquanym, Jeiwan, 0x52, hansfriese, WATCHPUG, GalloDaSballo, berndartmueller\n\n## Summary\n\nThe accumulated fees in the `topupproxy` contract's balance can be stolen by an attacker by using malicious `_bridgeTxData` and using `1inch`'s as `targetAddress`.\n\n## Vulnerability Detail\n\nThis attack vector is enabled by multiple traits of the `topupproxy` contract:\n\n#### 1. Shared whitelist\n\nPer to deploy script, the same `trustedregistry` will be shared among `exchangeproxy` and `topupproxy`.\n\nTherefore, the 2 whitelisted swap aggregator contracts will also be allowed to be called on `topupproxy`:\n\n- 0x Proxy\n- 1inch Proxy\n\nAnd the 2 whitelisted bridge contracts can be called on `exchangeproxy`:\n\n- Synapse\n- Across\n\n#### 2. Unlimited allowance rather than only the amount of the current topup to the bridge's `targetAddress`\n\nAt L414, the `targetAddress` will be granted an unlimited allowance rather than just the amount of the current transaction.\n\nhttps://github.com/sherlock-audit/2022-10-mover/blob/main/cardtopup_contract/contracts/HardenedTopupProxy.sol#L414\n\n#### 3. `1inch` can be used to pull an arbitrary amount of funds from the caller and execute arbitrary call\n\nThe design of `1inch`'s `AggregationRouterV4` can be used to pull funds from the `topupproxy` and execute arbitrary external call:\n\nhttps://polygonscan.com/address/0x1111111254fb6c44bAC0beD2854e76F90643097d#code\n\nSee L2309-2321.\n\n#### 4. The topup fee will be left in the contract's balance\n\nhttps://github.com/sherlock-audit/2022-10-mover/blob/main/cardtopup_contract/contracts/HardenedTopupProxy.sol#L348-L352\n\n---\n\nCombining all the 3 above together, the attacker can call `CardTopupPermit() -> _processTopup() -> 1inch#swap()` and drain all the funds in the contract:\n\n- _token: cardTopupToken\n- _bridgeType: 0\n- _bridgeTxData:\n    - targetAddress: 1inch Proxy\n    - callData:\n        - amount: all the topupproxy's balance\n        - srcReceiver: attacker's address\n\n\n## Impact\n\nAll the accumulated fees can be stolen by the attacker.\n\n## Code Snippet\n\nhttps://polygonscan.com/address/0x1111111254fb6c44bAC0beD2854e76F90643097d#code\n\nhttps://github.com/sherlock-audit/2022-10-mover/blob/main/cardtopup_contract/contracts/HardenedTopupProxy.sol#L348-L352\n\nhttps://github.com/sherlock-audit/2022-10-mover/blob/main/cardtopup_contract/migrations/5_connect_contracts.js#L54-L61\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n1. The accumulated fees should not be left in the contract;\n2. Only give the whitelisted `targetAddress` the allowance of the amount (`_amount`) transferred into the `topupproxy` contract within this transaction from the caller;\n2. The whitelist should not be shared.\n\n## Discussion\n\n**McMannaman**\n\nDuplicate of\nhttps://github.com/sherlock-audit/2022-10-mover-judging/issues/60\nhttps://github.com/sherlock-audit/2022-10-mover-judging/issues/37\nhttps://github.com/sherlock-audit/2022-10-mover-judging/issues/38\nhttps://github.com/sherlock-audit/2022-10-mover-judging/issues/52\n\nalthough this is the best and most comprehensive of them all.\n\nI think that it's a low vulnerability (user funds are not affected by this and fees are harvested from time to time anyway in the normal flow of operation).\nBut, regardless -- this issue has a valid point.\n\n\n**hrishibhat**\n\nHey @McMannaman, since #38 is also considered a duplicate, which is considered medium. Shouldn't the rest of the issues be medium too?\n\n**amozgov**\n\n@hrishibhat correct, as @McMannaman mentioned - this is not a \"high\" vulnerability since no user funds are at risk, there is a tag \"disagree with severity\" \n\n**Evert0x**\n\nWe will not change the severity of this issue as protocol funds are at risk. \n\n**McMannaman**\n\nThe fixes are in https://github.com/viaMover/2022-10-mover/pull/1\n\n**jacksanford1**\n\nBringing over some comments from https://github.com/viaMover/2022-10-mover/pull/1\n\n**McMannaman**\nAdded reentrancy protection (also for issue #120)\nPlus an additional check that only the USDC amount expected is deducted from contract when bridging regardless of bytes call data.\nhttps://github.com/sherlock-audit/2022-10-mover-judging/issues/112\n\n**WatchPug**\n1. It's better to ensure that the whitelist is not shared between the two contracts. Otherwise, the attacker can still steal the topup fee from HardenedTopupProxy by using 1inch as targetAddress in their _bridgeTxData. Can you also make the changes required to the deploy script to reflect that?\n2. Seems like the attacker can still steal the exchange fee sitting on the exchangeProxyContract.\n\n**McMannaman**\n1. I have updated the migrations to reflect that whitelists would be separated (and 2 child contracts just to keep migrations-compatible).\n\n2. Could you please elaborate on how the attacker could steal exchange fee on the exchangeProxyContract? The fees are (if they would be non-zero) in USDC-only (the target token would be USDC), or, more generally in some single token, fees could be claimed before token change, before, e.g. hypothetically, to USDT. And if we know the target token, then lines\nhttps://github.com/viaMover/2022-10-mover/blob/fix-112-reentrancyamountcheck/cardtopup_contract/contracts/HardenedTopupProxy.sol#L443 and\nhttps://github.com/viaMover/2022-10-mover/blob/fix-112-reentrancyamountcheck/cardtopup_contract/contracts/ExchangeProxy.sol#L198\nshould protect from draining fees:\n\n(non-swap scenario):\n1. an amount is stated as parameter when calling topup, then that amount is transferred to the Topup proxy;\n2. no swap is called;\n3. bridged amount is checked to exactly match provided amount (regardless of what is provided/called in the bridge data/call);\n\n(swap scenario):\n1. an amount is stated as parameter when calling topup, then that amount is transferred to the Topup proxy;\n2. swap is called, the actual received amount in USDC is now the amount we're working with (regardless of what is provided/called in the bridge data/call) -- deducting fees on both proxies;\n3. bridged amount is checked to exactly match amount stated by Exchange proxy (regardless of what is provided/called in the bridge data/call);\n\nso there are several assumptions we're working with:\n- fees are collected in single token type (otherwise they can be stolen, yes);\n- exchange proxy is callable only by Transfer proxy (a require https://github.com/viaMover/2022-10-mover/blob/fix-112-reentrancyamountcheck/cardtopup_contract/contracts/ExchangeProxy.sol#L151);\n- if user uses some manipulation to escape (avoid paying own) fees (don't know how this is achievable though without reentrancy) -- this is violation of terms of use, even if possible, should be of little rationale to user;\n\nPlease point if I'm missing something (no code examples needed, just a description would be enough).\n\n@jack-the-pug \n\n**WatchPug**\n> * fees are collected in single token type (otherwise they can be stolen, yes);\n\nYeah, I think this is the case where the accumulated fees on the `exchangeProxyContract` can be stolen.\n\nI agree that this is not a major risk, though.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/10",
  "Code": [
    {
      "filename": "cardtopup_contract/contracts/HardenedTopupProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n///////////////////////////////////////////////////////////////////////////\n//     __/|      \n//  __////  /|   This smart contract is part of Mover infrastructure\n// |// //_///    https://viamover.com\n//    |_/ //     support@viamover.com\n//       |/\n///////////////////////////////////////////////////////////////////////////\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./interfaces/IExchangeProxy.sol\";\nimport \"./interfaces/IContractWhitelist.sol\";\nimport \"./interfaces/IAcrossBridgeSpokePool.sol\";\n\nimport \"./utils/RLPReader.sol\";\nimport \"./utils/SafeAllowanceResetUpgradeable.sol\";\n\n/**\n    @dev HardenedTopupProxy is a transfer proxy contract for ERC20 and ETH card topups from (currently from L2 Polygon)\n    - extract fees;\n    - call token conversion if needed;\n    - bridge to L1 card settlement relay;\n    - non-custodial, not holding any funds;\n    - fees are accumulated on this contract's balance (if fees enabled);\n\n    Several considerations about the functions of this contract:\n       - Security is important, esp. compared to gas costs on L2 (which are negligible for most L2s);\n       - We try to avoid allowance-related attack vector by applying 2 required conditions before\n         making a transfer of some ERC20 from user wallet (regardless of the operation):\n           1. transfer is made only from msg.sender (so 3rd party cannot access other's funds), the only\n              exceotion could be that transaction is initiated from trusted party;\n           2. allowance is made to the amount requested in the operation (or only slightly more) --\n              size check must pass otherwise revert, and allowance must be done recently, this is proved\n              either by a trusted party with that specific role, or by prodiving proof so it could be\n              verified by contract on-chain (this is technically limited to 256 most recent blocks though);\n       - This contract does not hold any user funds, and is not intended to do so\n       \n       - Operations could be disabled at any time for security reasons (probably by automatic scanners);\n\n       - 3rd party contracts used:\n           - Bridging (Across and Synapse);\n           - Swaps (1inch and 0x);\n         all 3rd party addresses calls must pass whitelist contract registry check, if it fails, tx reverts.\n\n    Approval timing check could be done using three approaches:\n    1. without backend (on-chain):\n       a. use permit() if token supports it. DAI-type permits would fail size check as they\n          put allowance to 0xffff....ffff;\n       b. verify using block hash\n          - approve should be called within 256 blocks of the transaction called triggering this check;\n          - caller must provide block number, tx index, and MPT proof so the tx could be verified\n            using the block hash;\n    2. with backend:\n       - trusted signer address is provided (preset in contract) and an appropriate signed message\n         is provided, stating that recent approval was performed;\n    \n    Approval size check\n     - approval size must match the tolerance and decimals of the token being checked and must be larger\n       than requested amount but smaller than tolerance treshold;\n*/\ncontract HardenedTopupProxy is AccessControlUpgradeable, SafeAllowanceResetUpgradeable {\n    using SafeMathUpgradeable for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address payable;\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for bytes;\n    using ByteUtil for bytes;\n\n    // provided by this contract to bridges/swaps contracts\n    uint256 private constant ALLOWANCE_SIZE = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    // token address for non-wrapped eth\n    address private constant ETH_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // VARIABLES\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    // could be hardcoded per chain, but are kept as variables for test convenience\n    uint private CHAIN_ID;      // e.g. 137 for Polygon\n    bytes private CHAIN_ID_RLP; // e.g. '\\x81\\x89' for Polygon\n\n    // if greater than zero, this is a fractional amount (1e18 = 1.0) fee applied to all topups (after exchange to USDC)\n    uint256 public topupFee;\n    // if greater than zero, this is a fractional amount (1e18 = 1.0) fee applied to exchange operations with exchange proxy\n    uint256 public exchangeFee;\n    // allowance top boundary (in)\n    uint256 private allowanceTreshold;\n    // allowance max signature age (seconds)\n    uint256 private allowanceSignatureTimespan;\n\n    // minimum and maximum allowed amounts to perform topup (editable by admin, current minimum is ~25 USDC, maximum ~10000 USDC)\n    uint256 private minAmount;\n    uint256 private maxAmount;\n\n    // exchange proxy/middleware contract (trusted)\n    IExchangeProxy private exchangeProxyContract;\n\n    // contract registry (when making 'call' for bridge addresses its checked against this trusted registry)\n    IContractWhitelist private trustedRegistryContract;\n\n    // address (EOA or contract) with single function to collect accumulated fees\n    address private yieldDistributorAddress;\n\n    // trusted execution wallets to provide signature of recent approval\n    bytes32 public constant TRUSTED_EXETUTOR_ROLE = keccak256(\"TRUSTED_EXECUTION\");\n\n    // ability to immediately suspend contract functions for emergency cases (unpause by admin) for automated security systems\n    bytes32 public constant TRUSTED_PAUSER_ROLE = keccak256(\"TRUSTED_PAUSER\");\n\n    // no topups are allowed if paused\n    bool public paused;\n\n    // L1 Eth address for card topup settlement\n    address private cardPartnerAddress;\n\n    // Token that could be bridged and used for card top-up\n    address private cardTopupToken;\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // EVENTS\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    // this is main event that is emitted after bridging to settlement chain is called\n    event CardTopup(address indexed account, address token, uint256 valueToken, uint256 valueUSDC, bytes32 _receiverHash);\n\n    // auxiliary event that can be used to track bridge addresses and match incoming target chain transactions\n    event BridgeTx(address indexed account, address token, uint256 amount, address bridge, address destination);\n\n    // event emitted when the topup or swap fee is changed\n    event FeeChanged(string indexed name, uint256 value);\n\n    // event that is triggered if amdin retrieves funds from this contract using EmenergencyTransfer method\n    event EmergencyTransfer(address indexed token, address indexed destination, uint256 amount);\n\n    /**\n        @dev chainId and chainIdRLP could be hardcoded, but are provided to constructor for flexibility\n          and testing convenience.\n     */\n    function initialize(uint _chainId, bytes memory _chainIdRLP) public initializer {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        CHAIN_ID = _chainId;\n        CHAIN_ID_RLP = _chainIdRLP;\n\n        // no need to initialize zero and false values\n        // paused = false;\n        // topupFee = 0;\n        // exchangeFee = 0;\n        // minAmount = 0;\n        maxAmount = 10000000000;\n\n        // 10% allowance tolerance treshold\n        allowanceTreshold = 1_100_000_000_000_000_000;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // ADMIN SETTERS\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    /**\n        @dev modifier to allow only DEFAULT_ADMIN_ROLE access to certain methods\n     */\n    modifier onlyAdmin() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"admin only\");\n        _;\n    }\n\n    function setExchangeProxy(address _exchangeProxyContract) public onlyAdmin {\n        exchangeProxyContract = IExchangeProxy(_exchangeProxyContract);\n    }\n\n    function setTrustedRegistry(address _trustedRegistryContract) public onlyAdmin {\n        trustedRegistryContract = IContractWhitelist(_trustedRegistryContract);\n    }\n\n    // allowance treshold can be modified by admin to relax/stricten approval amount matching\n    function setAllowanceTreshold(uint256 _allowanceTreshold) public onlyAdmin {\n        allowanceTreshold = _allowanceTreshold;\n    }\n\n    // period of signature validity for approval can be modified by admin\n    function setAllowanceSignatureTimespan(uint256 _allowanceSignatureTimespan) public onlyAdmin {\n        allowanceSignatureTimespan = _allowanceSignatureTimespan;\n    }\n\n    function setYieldDistributor(address _tokenAddress, address _distributorAddress) public onlyAdmin {\n        yieldDistributorAddress = _distributorAddress;\n        // only yield to be redistributed should be present on this contract balance in baseAsset\n        resetAllowanceIfNeeded(IERC20Upgradeable(_tokenAddress), _distributorAddress, ALLOWANCE_SIZE);\n    }\n\n    function setTopupFee(uint256 _topupFee) public onlyAdmin {\n        topupFee = _topupFee;\n        emit FeeChanged(\"topup\", _topupFee);\n    }\n\n    function setExchangeFee(uint256 _exchangeFee) public onlyAdmin {\n        exchangeFee = _exchangeFee;\n        emit FeeChanged(\"exchange\", _exchangeFee);\n    }\n\n    function setCardPartnerAddress(address _cardPartnerAddress) public onlyAdmin {\n        cardPartnerAddress = _cardPartnerAddress;\n    }\n\n    // card topup token is planned to be USDC (or chain equivalent), but can be changed by admin at any time\n    function setCardTopupToken(address _topupToken) public onlyAdmin {\n        cardTopupToken = _topupToken;\n    }\n\n    function setMinAmount(uint256 _minAmount) public onlyAdmin {\n        minAmount = _minAmount;\n    }\n\n    function setMaxAmount(uint256 _maxAmount) public onlyAdmin {\n        maxAmount = _maxAmount;\n    }\n\n    // this method could also be used by admin to unpause operations\n    function setPaused(bool _paused) public onlyAdmin {\n        paused = _paused;\n    }\n\n    /**\n        @dev pause could be triggered by a trusted pauser EOA that is linked to a security backend\n     */\n    function pauseOperation() public {\n        require(hasRole(TRUSTED_PAUSER_ROLE, msg.sender), \"pauser only\");\n        paused = true;\n    }\n\n    /**\n        @dev this function is similar to emergencyTransfer, but relates to yield distribution\n          fees are not transferred immediately to save gas costs for user operations\n          so they accumulate on this contract address and can be claimed by yield distributor\n          when appropriate. Anyway, no user funds should appear on this contract, it\n          only performs transfers, so such function has great power, but should be safe\n          It does not require approval, so may be used by yield distributor to get fees from swaps\n          in different small token amounts\n    */\n    function claimFees(address _token, uint256 _amount) public {\n        require(msg.sender == yieldDistributorAddress, \"yield distributor only\");\n        if (_token != ETH_TOKEN_ADDRESS) {\n            IERC20Upgradeable(_token).safeTransfer(msg.sender, _amount);\n        } else {\n            payable(msg.sender).sendValue(_amount);\n        }\n    }\n\n    /**\n        @dev all Mover contracts that do not hold funds have this emergency function if someone occasionally\n          transfers ERC20 tokens directly to this contract\n          this metod is callable only by admin, no timelock etc., because this contract is not aimed to hold user funds\n    */\n    function emergencyTransfer(\n        address _token,\n        address _destination,\n        uint256 _amount\n    ) public onlyAdmin {\n        if (_token != ETH_TOKEN_ADDRESS) {\n            IERC20Upgradeable(_token).safeTransfer(_destination, _amount);\n        } else {\n            payable(_destination).sendValue(_amount);\n        }\n        emit EmergencyTransfer(_token, _destination, _amount);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CROSS-CHAIN TOPUP MAIN INTERNAL FUNCTIONS\n    //   the normal call chain is as following:\n    //   public Top-up method -> _processTopup() -> execute swap (optional) -> bridgeAssetDirect()\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    \n\n    /**\n        @dev check that current (for state of this block/tx) approval of token and amount is at least the\n          planned topup value, but not larger than some treshold (10% by default) to enforce allowance for\n          single (current) operation, not leaving standing significant token allowance for this contract in the future\n     */\n    function checkAllowance(address _token, uint256 _amount) view internal {\n        require(IERC20Upgradeable(_token).allowance(msg.sender, address(this)) >= _amount, \"insufficient allowance\");\n        require(IERC20Upgradeable(_token).allowance(msg.sender, address(this)) < _amount.mul(allowanceTreshold).div(1e18), \"excessive allowance\");\n    }\n\n    /**\n        @dev process a topup (swap if needed and bridge to L1 where card settlement occurs) for arbitrary ERC20 or native token\n        @param _bridgeType 0 == SYNAPSE, 1 == ACROSS\n        @param _bridgeTxData for synapse bridge its address + bytes formed by their SDK/API, for Across bridge its only the 20 bytes its pool address\n     */\n    function _processTopup(address _beneficiary, address _token, uint256 _amount, uint256 _expectedMinimumReceived, bytes memory _convertData, uint256 _bridgeType, bytes memory _bridgeTxData, bytes32 _receiverHash) internal\n    {\n        // don't go further is contract function is paused (by admin or pauser)\n        require(paused == false, \"operations paused\");\n\n        // if execution passes to here, it means:\n        // 1. operations are active;\n        // 2. allowance check is passed, allowance is set and we can use funds from _beneficiary's address;\n        // next steps are:\n        // 1. transfer token to this contract or exchange proxy\n        //    TODO (future version): check if token must be unwrapped by a partner\n        //    (vault tokens, etc. that could not be swapped and should be unwrapped in some way)\n        // 2. swap if needed and transfer USDC to this contract\n        // 3. deduct topup fee (if needed)\n        // 4. check allowance to the bridge contract\n        // 5. check the bridge address is in the whitelist and perform a call to bridge\n\n        // if the token to be provided matches the defined cardTopupToken, do not perform any\n        // swap, just deduct topup fee (if fee > 0) and proceed to bridging for settlement\n        if (_token == cardTopupToken) {\n            // beneficiary is msg.sender (perform static check)\n            IERC20Upgradeable(_token).safeTransferFrom(_beneficiary, address(this), _amount);\n\n            uint256 feeAmount = _amount.mul(topupFee).div(1e18);\n\n            // bridge from _beneficiary to card L1 relay\n            _bridgeAssetDirect(_amount.sub(feeAmount), _bridgeType, _bridgeTxData);\n\n            emit CardTopup(_beneficiary, _token, _amount, _amount.sub(feeAmount), _receiverHash);\n            return;\n        }\n\n        // conversion is required, perform swap through exchangeProxy\n        if (_token != ETH_TOKEN_ADDRESS) {\n            // transfer tokens on the exchange proxy balance before performing swap call\n            IERC20Upgradeable(_token).safeTransferFrom(_beneficiary, address(exchangeProxyContract), _amount);\n        }\n\n        // exchange proxy is trusted and would check swap provider on its own in trusted registry contract\n        uint256 amountReceived =\n            IExchangeProxy(address(exchangeProxyContract)).executeSwapDirect{value: msg.value}(\n                address(this),\n                _token,\n                cardTopupToken,\n                _amount,\n                exchangeFee,\n                _convertData\n            );\n\n        // this is sanity check from the client if the swap misbehaves\n        require(amountReceived >= _expectedMinimumReceived, \"minimum swap amount not met\");\n\n        // fee is deducted in receiving token (USDC)\n        if (topupFee != 0) {\n            uint256 feeAmount = amountReceived.mul(topupFee).div(1e18);\n            amountReceived = amountReceived.sub(feeAmount);\n        }\n\n        if (_bridgeType == 0) {\n            // if using Synapse bridge and a swap was performed\n            // because of Synapse bridge interface is off-chain\n            // modify part of bridgeTxData to reflect new amount\n            // in bridgeTxData, its layout is as following:\n            // bytes   0..19 target address (topup relay on L1)\n            // bytes  20..23 function signature\n            // bytes  24..151 bridge tx params\n            // bytes 152..183 min to mint\n            // bytes 184..279 bridge tx params\n            // bytes 280..311 min dy\n            // bytes 312..407 bridge tx params\n            // bytes 408..439 source amount\n            // bytes 440..471 bridge tx params\n            uint256 minMint = amountReceived.mul(950000).div(1000000); // 0.95 nUSD to mint\n            uint256 minDy = amountReceived.mul(910000).div(1000000); // 0.91 expected to be received\n            assembly {\n                // first 32 bytes of 'bytes' is it's length, and after that it's contents\n                // so offsets are 32+152=184, 32+280=312, 32+408=440\n                mstore(add(_bridgeTxData, 184), minMint)\n                mstore(add(_bridgeTxData, 312), minDy)\n                mstore(add(_bridgeTxData, 440), amountReceived)\n            }\n        }\n\n        // bridge from _beneficiary to card L1 relay\n        _bridgeAssetDirect(amountReceived, _bridgeType, _bridgeTxData);\n\n        // this event is important for the backend to track topup activity, esp. store receiverHash\n        // that could provide ability to topup topup tag associated with arbitrary card/address\n        emit CardTopup(_beneficiary, _token, _amount, amountReceived, _receiverHash);\n    }\n\n    /**\n        @dev bridgeAssetDirect is checking amount conditions, extracts bridge address from bridgeTxData\n          bytes, verifies that it is trusted, and executes bridge call that can vary depending on the bridge\n          type. Currently Synapse (bridgeType == 0) and Across (bridgeType ==1) are supported.\n          We are assuming that bridge address os stored in trusted contract registry, and thus, even provided\n          by capability to pass arbitrary bytes in the call data for the e.g. Synapse bridge, this should\n          not provide ability to access or manipulate other users funds in any way.\n     */\n    function _bridgeAssetDirect(uint256 _amount, uint256 _bridgeType, bytes memory _bridgeTxData) internal {\n        require(_amount >= minAmount, \"minimum amount not met\");\n        require(_amount < maxAmount, \"maximum amount exceeded\");\n\n        // first 20 bytes (data is tightly packed, not in 32 byte words) are the address\n        // of the bridge contract to be called for bridging\n        address targetAddress;\n        assembly {\n            targetAddress := mload(add(_bridgeTxData, 0x14))\n        }\n\n        // call method is very powerful, as it allows to call anything pretending to be the topup proxy\n        // so we protect ourserves by allowing only the addresses we add to allowlist\n        require(trustedRegistryContract.isWhitelisted(targetAddress), \"call to non-trusted\");\n\n        // allowance of max uint256 is provided (if current allowance < bridging amount)\n        // for the topup token to be used bridge contract from this contract\n        // this topup proxy contract does not hold user funds/tokens, balance should only\n        // consist of collected fees (which are harvested periodically)\n        resetAllowanceIfNeeded(IERC20Upgradeable(cardTopupToken), targetAddress, _amount);\n\n        if (_bridgeType == 0)\n        {\n            // Synapse bridge call data is retrieved by performing a call by the application\n            // to bridge SDK and is not transformed by this contract\n            bytes memory callData = _bridgeTxData.slice(20, _bridgeTxData.length - 20);\n            (bool success, ) = targetAddress.call(callData);\n            require(success, \"BRIDGE_CALL_FAILED\");\n        } else if (_bridgeType == 1) {\n            // Across bridge can be called through defined interface, the variable of fee percentage\n            // is depending on gas price conditions in the target chain and is retrieved by the\n            // application off-chain by calling the Across bridge API\n            uint256 feePct;\n            assembly {\n                // offset 0x20 to data and 0x14 to tightly packed address, at offset 0x34 32 bytes expected are fee pct\n                feePct := mload(add(_bridgeTxData, 0x34))\n            }\n            IAcrossBridgeSpokePool(targetAddress).deposit(cardPartnerAddress,\n                cardTopupToken,\n                _amount,\n                1, // L1 Eth mainnet\n                uint64(feePct), // max is 495_000_000_000_000_000 (49.5%) fee (bridge has 50% fee allowed as max)\n                uint32(block.timestamp));\n        } else {\n            revert(\"unknown bridge\");\n        }\n\n        // this event is auxiliary (CardTopup event is main one), but used for bridged in/out transaction matching\n        emit BridgeTx(msg.sender, cardTopupToken, _amount, targetAddress, cardPartnerAddress);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    \n    // INTERNAL FUNCTIONS FOR TRUSTED SIGNATURE BASED ALLOWANCE CHECK\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    /**\n        @dev reconstruct a message to be verified (signed by trusted backend) that allowance is recent and of correct value\n     */\n    function constructMsg(bytes32 _addrhash, address _token, uint256 _amount, uint256 _timestamp) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"MOVER TOPUP \", _addrhash, \" TOKEN \", _token, \" AMOUNT \", _amount, \" TS \", _timestamp));\n    }\n\n    /**\n        @dev recover signer by ecrecover from a signature presented in bytes array\n     */\n    function recoverSigner(bytes32 message, bytes memory sig) internal pure returns (address)\n    {\n        // signature is expected to be exactly 65 bytes (2 * 32 byte words and a checksum)\n        require(sig.length == 65, \"invalid sig length\");\n\n        // signature components\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            // first 32 bytes, after the length prefix\n            r := mload(add(sig, 32))\n            // second 32 bytes\n            s := mload(add(sig, 64))\n            // final byte (first byte of the next 32 bytes)\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n            v += 27;\n        }\n\n        return ecrecover(message, v, r, s);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    \n    // INTERNAL FUNCTIONS FOR MERKLE-PATRICIA-TRIE ALLOWANCE CHECK\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    \n    //\n    // These functions are created to perform approval checks (approval timing) -- to verify that certain ERC20 \n    // token's approve() indeed happened within 256 most recent blocks using on-chain proof.\n    // There helper functions use MPT RLP-encoded proof which is matched against block hash (available\n    // to smart contract), transaction is extracted from proof, RLP-decoded, sender, spender and allowance\n    // amount are checked to be valid as well.\n    //\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    \n  \n    uint256 constant TX_ROOT_HASH_INDEX = 4;\n\n    /**\n        @dev structure to represent RLP-decoded transaction data extracted from proof (only used fields are preserved)\n          as transaction data is not containing sender directly, we reconstruct unsigned transaction (RLP-encoded),\n          and its hash (unsignedHash) is used to retrieven sender (signer) address to verify approval proof.\n          Other fields are used to verify transaction parameters: data (function signature, amount, spender),\n          to (token) and chainID to avoid reusing proofs between chains.\n     */\n    struct SignedTransaction {\n        uint256 chainID;      // for EIP-1661 only\n        address to;           // target ERC-20 contract (token)\n        bytes data;           // used to check that method is approve, spender and amount\n        uint256 v;            // signature checksum\n        uint256 r;            // 1st signature component\n        uint256 s;            // 2nd signature component\n        bytes32 unsignedHash; // for extracting sender address\n    }\n\n    /**\n      * @dev check if the RLP encoded item is empty (could be list or value byte sequence)\n      * @notice In lists 0xc0 means empty list as additional condition\n      */\n    function isEmpty(RLPReader.RLPItem memory item, bool byteSequence) internal pure returns (bool) {\n        if (item.len != 1) {\n            return false;\n        }\n        uint8 b;\n        uint memPtr = item.memPtr;\n        assembly { b := byte(0, mload(memPtr)) }\n        return b == 0x80 /* empty byte string */ || (!byteSequence && b == 0xc0 /* empty list */);\n    }\n\n    /**\n     * @dev RLP encodes a list of RLP encoded byte byte strings. This method is used to reconstruct\n         RLP-encoded unsigned transaction, so its hash could be used to extract sender adderss\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\n     * @param self The list of RLP encoded byte strings.\n     * @return The RLP encoded list of items in bytes.\n     */\n    function encodeList(RLPReader.RLPItem[] memory self) internal pure returns (bytes memory) {\n        if (self.length == 0) {\n            return new bytes(0);\n        }\n\n        uint len;\n        uint i;\n        for (i = 0; i < self.length; i++) {\n            len += self[i].len;\n        }\n\n        bytes memory flattened = new bytes(len);\n        uint flattenedPtr;\n        assembly { flattenedPtr := add(flattened, 0x20) }\n\n        for(i = 0; i < self.length; i++) {\n            bytes memory item = self[i].toRlpBytes();\n            \n            uint listPtr;\n            assembly { listPtr := add(item, 0x20)}\n\n            ByteUtil.memcpy(listPtr, flattenedPtr, item.length);\n            flattenedPtr += self[i].len;\n        }\n        \n        return bytes.concat(encodeLength(flattened.length, 192), flattened);\n    }\n\n    /**\n     * @dev Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\n     * @param len The length of the string or the payload.\n     * @param offset 128 if item is string, 192 if item is list.\n     * @return RLP encoded bytes.\n     */\n    function encodeLength(uint len, uint offset) private pure returns (bytes memory) {\n        bytes memory encoded;\n        if (len < 56) {\n            encoded = new bytes(1);\n            encoded[0] = bytes32(len + offset)[31];\n        } else {\n            uint lenLen;\n            uint i = 1;\n            while (len / i != 0) {\n                lenLen++;\n                i *= 256;\n            }\n\n            encoded = new bytes(lenLen + 1);\n            encoded[0] = bytes32(lenLen + offset + 55)[31];\n            for(i = 1; i <= lenLen; i++) {\n                encoded[i] = bytes32((len / (256**(lenLen-i))) % 256)[31];\n            }\n        }\n        return encoded;\n    }\n\n    /**\n      * @dev decode RLP-endoded signed transaction (legacy or EIP-1559 London type)\n        @return t transaction data structure that includes reconstructed unsigned tx and\n             signature values that would allow to recover sender (tx signer)\n      * @notice In lists 0xc0 means empty list as additional condition\n      */\n    function decodeSignedTx(bytes memory rlpSignedTx) internal view returns (SignedTransaction memory t) {\n        // if has prefix 0x2 its tx from London hardfork (0x1 Berlin is rare and not supported)\n        if (uint8(rlpSignedTx[0]) != 0x2) {\n            // legacy tx\n            RLPReader.RLPItem[] memory fields = rlpSignedTx.toRlpItem().toList();\n            \n            require(!isEmpty(fields[3], false), 'contract creation tx proof');\n            \n            uint V = (fields[6].toUint() + 1) % 2; // in legacy txes clean chainID from this field, we need V for sender address recovery\n            uint R = fields[7].toUint();\n            uint S = fields[8].toUint();\n            uint chainID = (fields[6].toUint() - 35) / 2; // EIP-155\n\n            // 137 Polygon ChainID RLP-encoded, we would place appropriate Chain ID to check on every L2 contract instance\n            bytes memory polygonChainId = CHAIN_ID_RLP;\n            bytes memory zeroValue = '\\x80';\n            fields[6] = polygonChainId.toRlpItem(); //encodeUint(chainID).toRlpItem(); // (for unsigned legacy tx V equals ChainID)\n            fields[7] = zeroValue.toRlpItem(); //encoded value of 0, encodeUint(0).toRlpItem();\n            fields[8] = zeroValue.toRlpItem(); //encoded value of 0, encodeUint(0).toRlpItem();\n\n            t = SignedTransaction(\n                chainID,\n                fields[3].toAddress(), // to (token)\n                fields[5].toBytes(), // tx data\n                V, // V\n                R, // R\n                S, // S\n                encodeList(fields).toRlpItem().rlpBytesKeccak256() // unsigned hash (for sender address recovery)\n            );\n        } else {\n            // London tx\n            RLPReader.RLPItem[] memory fields = rlpSignedTx.toRlpItemStripTxPrefix().toList();\n\n            require(!isEmpty(fields[5], false), 'contract creation tx proof');\n\n            // unsigned hash does not include V, R, S at all, so cut array length by 3\n            uint V = fields[9].toUint();\n            uint R = fields[10].toUint();\n            uint S = fields[11].toUint();\n            assembly { mstore(fields, sub(mload(fields), 3)) }\n\n            t = SignedTransaction(\n                fields[0].toUint(), // chainId\n                fields[5].toAddress(), // to (token)\n                fields[7].toBytes(), // tx data\n                V, // V\n                R, // R\n                S, // S\n                // unsigned tx should be encoded with same 0x2 prefix (London EIP-1559) as signed tx \n                keccak256(abi.encodePacked(uint8(0x2), encodeList(fields).toRlpItem().toRlpBytes())) // unsigned hash (for sender address recovery)\n            );\n        }\n    }\n\n    /**\n        @dev nibble is a unit to distinguish key-value values of Merkle-Patricia trie of Ethereum data stucture\n     */\n    function decodeNibbles(bytes memory compact, uint skipNibbles) internal pure returns (bytes memory nibbles) {\n        require(compact.length > 0);\n\n        uint length = compact.length * 2;\n        require(skipNibbles <= length);\n        length -= skipNibbles;\n\n        nibbles = new bytes(length);\n        uint nibblesLength = 0;\n\n        for (uint i = skipNibbles; i < skipNibbles + length; i += 1) {\n            if (i % 2 == 0) {\n                nibbles[nibblesLength] = bytes1((uint8(compact[i/2]) >> 4) & 0xF);\n            } else {\n                nibbles[nibblesLength] = bytes1((uint8(compact[i/2]) >> 0) & 0xF);\n            }\n            nibblesLength += 1;\n        }\n\n        assert(nibblesLength == nibbles.length);\n    }\n\n    /**\n        @dev decode a bytes sequence to traverse MPT nodes\n     */\n    function merklePatriciaCompactDecode(bytes memory compact) internal pure returns (bool isLeaf, bytes memory nibb"
    }
  ]
}