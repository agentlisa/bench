{
  "Title": "The getFirstUnprocessedPriorityTx Function Does Not Revert When There Are No Unprocessed Transactions",
  "Content": "The [`getFirstUnprocessedPriorityTx`](https://github.com/matter-labs/era-contracts/blob/518bfff51085743dc85d2824d823aaf4bb3e82d8/ethereum/contracts/zksync/facets/Getters.sol#L63-L65) function of the `Getters` contract is expected to return the first unprocessed priority transaction. In case there are no unprocessed priority transactions, the function should revert, as indicated in the [NatSpec comment](https://github.com/matter-labs/era-contracts/blob/518bfff51085743dc85d2824d823aaf4bb3e82d8/ethereum/contracts/zksync/facets/Getters.sol#L61) comment. The issue is that the function uses the `PriorityQueue` library, which simply returns [the head of the queue](https://github.com/matter-labs/era-contracts/blob/518bfff51085743dc85d2824d823aaf4bb3e82d8/ethereum/contracts/zksync/libraries/PriorityQueue.sol#L35-L37) and does not revert when there are no unprocessed priority transactions.\n\n\nConsider reverting when there are no unprocessed priority transactions.\n\n\n***Update:** Resolved in [pull request #137](https://github.com/matter-labs/era-contracts/pull/137) at commit [ff8a9cd](https://github.com/matter-labs/era-contracts/pull/137/commits/ff8a9cd30112d484684a9b45e3a6f526e0c2b732). The Matter Labs team stated:*\n\n\n\n> *We decide to keep the current behavior for the simplicity of the function. However, it does make sense to update the comment.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "ethereum/contracts/zksync/facets/Getters.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport \"./Base.sol\";\nimport \"../libraries/Diamond.sol\";\nimport \"../libraries/PriorityQueue.sol\";\nimport \"../../common/libraries/UncheckedMath.sol\";\nimport \"../interfaces/IGetters.sol\";\nimport \"../interfaces/ILegacyGetters.sol\";\n\n/// @title Getters Contract implements functions for getting contract state from outside the batchchain.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract GettersFacet is Base, IGetters, ILegacyGetters {\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    string public constant override getName = \"GettersFacet\";\n\n    /*//////////////////////////////////////////////////////////////\n                            CUSTOM GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @return The address of the verifier smart contract\n    function getVerifier() external view returns (address) {\n        return address(s.verifier);\n    }\n\n    /// @return The address of the current governor\n    function getGovernor() external view returns (address) {\n        return s.governor;\n    }\n\n    /// @return The address of the pending governor\n    function getPendingGovernor() external view returns (address) {\n        return s.pendingGovernor;\n    }\n\n    /// @return The total number of batches that were committed\n    function getTotalBatchesCommitted() external view returns (uint256) {\n        return s.totalBatchesCommitted;\n    }\n\n    /// @return The total number of batches that were committed & verified\n    function getTotalBatchesVerified() external view returns (uint256) {\n        return s.totalBatchesVerified;\n    }\n\n    /// @return The total number of batches that were committed & verified & executed\n    function getTotalBatchesExecuted() external view returns (uint256) {\n        return s.totalBatchesExecuted;\n    }\n\n    /// @return The total number of priority operations that were added to the priority queue, including all processed ones\n    function getTotalPriorityTxs() external view returns (uint256) {\n        return s.priorityQueue.getTotalPriorityTxs();\n    }\n\n    /// @notice Returns zero if and only if no operations were processed from the queue\n    /// @notice Reverts if there are no unprocessed priority transactions\n    /// @return Index of the oldest priority operation that wasn't processed yet\n    function getFirstUnprocessedPriorityTx() external view returns (uint256) {\n        return s.priorityQueue.getFirstUnprocessedPriorityTx();\n    }\n\n    /// @return The number of priority operations currently in the queue\n    function getPriorityQueueSize() external view returns (uint256) {\n        return s.priorityQueue.getSize();\n    }\n\n    /// @return The first unprocessed priority operation from the queue\n    function priorityQueueFrontOperation() external view returns (PriorityOperation memory) {\n        return s.priorityQueue.front();\n    }\n\n    /// @return Whether the address has a validator access\n    function isValidator(address _address) external view returns (bool) {\n        return s.validators[_address];\n    }\n\n    /// @return Merkle root of the tree with L2 logs for the selected batch\n    function l2LogsRootHash(uint256 _batchNumber) external view returns (bytes32) {\n        return s.l2LogsRootHashes[_batchNumber];\n    }\n\n    /// @notice For unfinalized (non executed) batches may change\n    /// @dev returns zero for non-committed batches\n    /// @return The hash of committed L2 batch.\n    function storedBatchHash(uint256 _batchNumber) external view returns (bytes32) {\n        return s.storedBatchHashes[_batchNumber];\n    }\n\n    /// @return Bytecode hash of bootloader program.\n    function getL2BootloaderBytecodeHash() external view returns (bytes32) {\n        return s.l2BootloaderBytecodeHash;\n    }\n\n    /// @return Bytecode hash of default account (bytecode for EOA).\n    function getL2DefaultAccountBytecodeHash() external view returns (bytes32) {\n        return s.l2DefaultAccountBytecodeHash;\n    }\n\n    /// @return Verifier parameters.\n    function getVerifierParams() external view returns (VerifierParams memory) {\n        return s.verifierParams;\n    }\n\n    /// @return The current protocol version\n    function getProtocolVersion() external view returns (uint256) {\n        return s.protocolVersion;\n    }\n\n    /// @return The upgrade system contract transaction hash, 0 if the upgrade is not initialized\n    function getL2SystemContractsUpgradeTxHash() external view returns (bytes32) {\n        return s.l2SystemContractsUpgradeTxHash;\n    }\n\n    /// @return The L2 batch number in which the upgrade transaction was processed.\n    /// @dev It is equal to 0 in the following two cases:\n    /// - No upgrade transaction has ever been processed.\n    /// - The upgrade transaction has been processed and the batch with such transaction has been\n    /// executed (i.e. finalized).\n    function getL2SystemContractsUpgradeBatchNumber() external view returns (uint256) {\n        return s.l2SystemContractsUpgradeBatchNumber;\n    }\n\n    /// @return Whether the diamond is frozen or not\n    function isDiamondStorageFrozen() external view returns (bool) {\n        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();\n        return ds.isFrozen;\n    }\n\n    /// @return isFreezable Whether the facet can be frozen by the governor or always accessible\n    function isFacetFreezable(address _facet) external view returns (bool isFreezable) {\n        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();\n\n        // There is no direct way to get whether the facet address is freezable,\n        // so we get it from one of the selectors that are associated with the facet.\n        uint256 selectorsArrayLen = ds.facetToSelectors[_facet].selectors.length;\n        if (selectorsArrayLen != 0) {\n            bytes4 selector0 = ds.facetToSelectors[_facet].selectors[0];\n            isFreezable = ds.selectorToFacet[selector0].isFreezable;\n        }\n    }\n\n    /// @return The maximum number of L2 gas that a user can request for L1 -> L2 transactions\n    function getPriorityTxMaxGasLimit() external view returns (uint256) {\n        return s.priorityTxMaxGasLimit;\n    }\n\n    /// @return Whether the selector can be frozen by the governor or always accessible\n    function isFunctionFreezable(bytes4 _selector) external view returns (bool) {\n        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();\n        require(ds.selectorToFacet[_selector].facetAddress != address(0), \"g2\");\n        return ds.selectorToFacet[_selector].isFreezable;\n    }\n\n    /// @return Whether a withdrawal has been finalized.\n    /// @param _l2BatchNumber The L2 batch number within which the withdrawal happened.\n    /// @param _l2MessageIndex The index of the L2->L1 message denoting the withdrawal.\n    function isEthWithdrawalFinalized(uint256 _l2BatchNumber, uint256 _l2MessageIndex) external view returns (bool) {\n        return s.isEthWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            DIAMOND LOUPE\n     //////////////////////////////////////////////////////////////*/\n\n    /// @return result All facet addresses and their function selectors\n    function facets() external view returns (Facet[] memory result) {\n        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();\n\n        uint256 facetsLen = ds.facets.length;\n        result = new Facet[](facetsLen);\n\n        for (uint256 i = 0; i < facetsLen; i = i.uncheckedInc()) {\n            address facetAddr = ds.facets[i];\n            Diamond.FacetToSelectors memory facetToSelectors = ds.facetToSelectors[facetAddr];\n\n            result[i] = Facet(facetAddr, facetToSelectors.selectors);\n        }\n    }\n\n    /// @return NON-sorted array with function selectors supported by a specific facet\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory) {\n        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();\n        return ds.facetToSelectors[_facet].selectors;\n    }\n\n    /// @return NON-sorted array of facet addresses supported on diamond\n    function facetAddresses() external view returns (address[] memory) {\n        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();\n        return ds.facets;\n    }\n\n    /// @return Facet address associated with a selector. Zero if the selector is not added to the diamond\n    function facetAddress(bytes4 _selector) external view returns (address) {\n        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();\n        return ds.selectorToFacet[_selector].facetAddress;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPRECATED METHODS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @return The total number of batches that were committed\n    /// @dev It is a *deprecated* method, please use `getTotalBatchesCommitted` instead\n    function getTotalBlocksCommitted() external view returns (uint256) {\n        return s.totalBatchesCommitted;\n    }\n\n    /// @return The total number of batches that were committed & verified\n    /// @dev It is a *deprecated* method, please use `getTotalBatchesVerified` instead.\n    function getTotalBlocksVerified() external view returns (uint256) {\n        return s.totalBatchesVerified;\n    }\n\n    /// @return The total number of batches that were committed & verified & executed\n    /// @dev It is a *deprecated* method, please use `getTotalBatchesExecuted` instead.\n    function getTotalBlocksExecuted() external view returns (uint256) {\n        return s.totalBatchesExecuted;\n    }\n\n    /// @notice For unfinalized (non executed) batches may change\n    /// @dev It is a *deprecated* method, please use `storedBatchHash` instead.\n    /// @dev returns zero for non-committed batches\n    /// @return The hash of committed L2 batch.\n    function storedBlockHash(uint256 _batchNumber) external view returns (bytes32) {\n        return s.storedBatchHashes[_batchNumber];\n    }\n\n    /// @return The L2 batch number in which the upgrade transaction was processed.\n    /// @dev It is a *deprecated* method, please use `getL2SystemContractsUpgradeBatchNumber` instead.\n    /// @dev It is equal to 0 in the following two cases:\n    /// - No upgrade transaction has ever been processed.\n    /// - The upgrade transaction has been processed and the batch with such transaction has been\n    /// executed (i.e. finalized).\n    function getL2SystemContractsUpgradeBlockNumber() external view returns (uint256) {\n        return s.l2SystemContractsUpgradeBatchNumber;\n    }\n}"
    }
  ]
}