{
  "Title": "Precision loss in `swETH::_deposit` from unnecessary hidden division before multiplication",
  "Content": "**Description:** `swETH::_deposit` [L170](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/swETH.sol#L170) contains a hidden unnecessary [division before multiplication](https://dacian.me/precision-loss-errors#heading-division-before-multiplication) as the call to `_ethToSwETHRate` performs a division which then gets multiplied by `msg.value`:\n```solidity\nuint256 swETHAmount = wrap(msg.value).mul(_ethToSwETHRate()).unwrap();\n// @audit expanding this out\n// wrap(msg.value).mul(_ethToSwETHRate()).unwrap();\n// wrap(msg.value).mul(wrap(1 ether).div(_swETHToETHRate())).unwrap();\n```\n\nThis issue has not been introduced in the new changes but is in the mainnet [code](https://github.com/SwellNetwork/v3-core-public/blob/master/contracts/lst/contracts/implementations/swETH.sol#L170).\n\n**Impact:** Slightly less `swETH` will be minted to depositors. While the amount by which individual depositors are short-changed is individually small, the effect is cumulative and increases as depositors and deposit size increase.\n\n**Proof of Concept:** This stand-alone stateless fuzz test can be run inside Foundry to prove this as well as provided hard-coded test cases:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport {UD60x18, wrap} from \"@prb/math/src/UD60x18.sol\";\n\nimport \"forge-std/Test.sol\";\n\n// run from base project directory with:\n// (fuzz test) forge test --match-test FuzzMint -vvv\n// (hardcoded) forge test --match-test HardcodedMint -vvv\ncontract MintTest is Test {\n\n    uint256 private constant SWETH_ETH_RATE = 1050754209601187151; //as of 2024-02-15\n\n    function _mintOriginal(uint256 inputAmount) private pure returns(uint256) {\n        // hidden division before multiplication\n        // wrap(inputAmount).mul(_ethToSwETHRate()).unwrap();\n        // wrap(inputAmount).mul(wrap(1 ether).div(_swETHToETHRate())).unwrap()\n\n        return wrap(inputAmount).mul(wrap(1 ether).div(wrap(SWETH_ETH_RATE))).unwrap();\n    }\n\n    function _mintFixed(uint256 inputAmount) private pure returns(uint256) {\n        // refactor to perform multiplication before division\n        // wrap(inputAmount).mul(wrap(1 ether)).div(_swETHToETHRate()).unwrap();\n\n        return wrap(inputAmount).mul(wrap(1 ether)).div(wrap(SWETH_ETH_RATE)).unwrap();\n    }\n\n    function test_FuzzMint(uint256 inputAmount) public pure {\n        uint256 resultOriginal = _mintOriginal(inputAmount);\n        uint256 resultFixed    = _mintFixed(inputAmount);\n\n        assert(resultOriginal == resultFixed);\n    }\n\n    function test_HardcodedMint() public {\n        // found by fuzzer\n        console.log(_mintFixed(3656923177187149889) - _mintOriginal(3656923177187149889)); // 1\n\n        // 100 eth\n        console.log(_mintFixed(100 ether) - _mintOriginal(100 ether)); // 21\n\n        // 1000 eth\n        console.log(_mintFixed(1000 ether) - _mintOriginal(1000 ether)); // 215\n\n        // 10000 eth\n        console.log(_mintFixed(10000 ether) - _mintOriginal(10000 ether)); // 2159\n    }\n}\n```\n\n**Recommended Mitigation:** Refactor to perform multiplication before division:\n```solidity\nuint256 swETHAmount = wrap(msg.value).mul(wrap(1 ether)).div(_swETHToETHRate()).unwrap();\n```\n\n**Swell:** Fixed in commit [cb093ea](https://github.com/SwellNetwork/v3-contracts-lst/commit/cb093eac675e5248a3f736a01a3725d794dd177e).\n\n**Cyfrin:**\nVerified.\n\n\\clearpage",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/lst/contracts/implementations/swETH.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.16;\n\nimport {UD60x18, wrap} from \"@prb/math/src/UD60x18.sol\";\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {EnumerableSetUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {Whitelist} from \"./Whitelist.sol\";\n\nimport {SwellLib} from \"../libraries/SwellLib.sol\";\n\nimport {IswETH} from \"../interfaces/IswETH.sol\";\nimport {IAccessControlManager} from \"../interfaces/IAccessControlManager.sol\";\nimport {INodeOperatorRegistry} from \"../interfaces/INodeOperatorRegistry.sol\";\nimport {IRateProvider} from \"../vendors/IRateProvider.sol\";\n\n/**\n * @title swETH\n * @notice Contract for handling user deposits in ETH in exchange for swETH at the stored rate. Also handles the rate updates from the BOT wallet which will occur at a fixed interval.\n * @author https://github.com/max-taylor\n * @dev This contract inherits the Whitelist contract which holds the Access control manager state variable and the checkRole modifier\n */\ncontract swETH is\n  Initializable,\n  Whitelist,\n  IswETH,\n  IRateProvider,\n  ERC20Upgradeable\n{\n  using SafeERC20 for IERC20;\n  using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n  uint256 public override lastRepriceETHReserves;\n  uint256 private swETHToETHRateFixed;\n\n  uint256 public override swellTreasuryRewardPercentage;\n  uint256 public override nodeOperatorRewardPercentage;\n\n  uint256 public override lastRepriceUNIX;\n\n  uint256 public override totalETHDeposited;\n\n  uint256 public override minimumRepriceTime;\n  uint256 public override maximumRepriceDifferencePercentage;\n  uint256 public override maximumRepriceswETHDifferencePercentage;\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  fallback() external {\n    revert SwellLib.InvalidMethodCall();\n  }\n\n  function initialize(\n    IAccessControlManager _accessControlManager\n  ) external initializer checkZeroAddress(address(_accessControlManager)) {\n    __ERC20_init(\"swETH\", \"swETH\");\n\n    __Whitelist_init(_accessControlManager);\n  }\n\n  // ************************************\n  // ***** External methods ******\n\n  function withdrawERC20(\n    IERC20 _token\n  ) external override checkRole(SwellLib.PLATFORM_ADMIN) {\n    uint256 contractBalance = _token.balanceOf(address(this));\n    if (contractBalance == 0) {\n      revert SwellLib.NoTokensToWithdraw();\n    }\n\n    _token.safeTransfer(msg.sender, contractBalance);\n  }\n\n  function setSwellTreasuryRewardPercentage(\n    uint256 _newSwellTreasuryRewardPercentage\n  ) external override checkRole(SwellLib.PLATFORM_ADMIN) {\n    // Joined percentage total cannot exeed 100% (1 ether)\n    if (\n      nodeOperatorRewardPercentage + _newSwellTreasuryRewardPercentage > 1 ether\n    ) {\n      revert RewardPercentageTotalOverflow();\n    }\n\n    emit SwellTreasuryRewardPercentageUpdate(\n      swellTreasuryRewardPercentage,\n      _newSwellTreasuryRewardPercentage\n    );\n\n    swellTreasuryRewardPercentage = _newSwellTreasuryRewardPercentage;\n  }\n\n  function setNodeOperatorRewardPercentage(\n    uint256 _newNodeOperatorRewardPercentage\n  ) external override checkRole(SwellLib.PLATFORM_ADMIN) {\n    // Joined percentage total cannot exeed 100% (1 ether)\n    if (\n      swellTreasuryRewardPercentage + _newNodeOperatorRewardPercentage > 1 ether\n    ) {\n      revert RewardPercentageTotalOverflow();\n    }\n\n    emit NodeOperatorRewardPercentageUpdate(\n      nodeOperatorRewardPercentage,\n      _newNodeOperatorRewardPercentage\n    );\n\n    nodeOperatorRewardPercentage = _newNodeOperatorRewardPercentage;\n  }\n\n  function setMinimumRepriceTime(\n    uint256 _minimumRepriceTime\n  ) external checkRole(SwellLib.PLATFORM_ADMIN) {\n    emit MinimumRepriceTimeUpdated(minimumRepriceTime, _minimumRepriceTime);\n\n    minimumRepriceTime = _minimumRepriceTime;\n  }\n\n  function setMaximumRepriceswETHDifferencePercentage(\n    uint256 _maximumRepriceswETHDifferencePercentage\n  ) external checkRole(SwellLib.PLATFORM_ADMIN) {\n    emit MaximumRepriceswETHDifferencePercentageUpdated(\n      maximumRepriceswETHDifferencePercentage,\n      _maximumRepriceswETHDifferencePercentage\n    );\n\n    maximumRepriceswETHDifferencePercentage = _maximumRepriceswETHDifferencePercentage;\n  }\n\n  function setMaximumRepriceDifferencePercentage(\n    uint256 _maximumRepriceDifferencePercentage\n  ) external checkRole(SwellLib.PLATFORM_ADMIN) {\n    emit MaximumRepriceDifferencePercentageUpdated(\n      maximumRepriceDifferencePercentage,\n      _maximumRepriceDifferencePercentage\n    );\n\n    maximumRepriceDifferencePercentage = _maximumRepriceDifferencePercentage;\n  }\n\n  function swETHToETHRate() external view override returns (uint256) {\n    return _swETHToETHRate().unwrap();\n  }\n\n  function ethToSwETHRate() external view override returns (uint256) {\n    return _ethToSwETHRate().unwrap();\n  }\n\n  function getRate() external view override returns (uint256) {\n    // This method is identical to swETHToETHRate but is required for the Balancer Metastable pools. Keeping this and the swETHToETHRate method because the swETHToETHRate method is more readable for integrations.\n    return _swETHToETHRate().unwrap();\n  }\n\n  function _deposit(address referral) internal checkWhitelist(msg.sender) {\n    if (AccessControlManager.coreMethodsPaused()) {\n      revert SwellLib.CoreMethodsPaused();\n    }\n\n    if (msg.value == 0) {\n      revert SwellLib.InvalidETHDeposit();\n    }\n\n    uint256 swETHAmount = wrap(msg.value)\n      .mul(wrap(1 ether))\n      .div(_swETHToETHRate())\n      .unwrap();\n\n    _mint(msg.sender, swETHAmount);\n\n    totalETHDeposited += msg.value;\n\n    AddressUpgradeable.sendValue(\n      payable(address(AccessControlManager.DepositManager())),\n      msg.value\n    );\n\n    emit ETHDepositReceived(\n      msg.sender,\n      msg.value,\n      swETHAmount,\n      totalETHDeposited,\n      referral\n    );\n  }\n\n  function deposit() external payable override {\n    _deposit(address(0));\n  }\n\n  function depositWithReferral(address referral) external payable override {\n    if (msg.sender == referral) {\n      revert SwellLib.CannotReferSelf();\n    }\n    _deposit(referral);\n  }\n\n  function reprice(\n    uint256 _preRewardETHReserves,\n    uint256 _newETHRewards,\n    uint256 _swETHTotalSupply\n  ) external override checkRole(SwellLib.REPRICER) {\n    uint256 currSupply = totalSupply();\n\n    if (_swETHTotalSupply == 0 || currSupply == 0) {\n      revert CannotRepriceWithZeroSwETHSupply();\n    }\n\n    if (_preRewardETHReserves == 0) {\n      revert InvalidPreRewardETHReserves();\n    }\n\n    uint256 cachedLastRepriceUNIX = lastRepriceUNIX;\n\n    uint256 timeSinceLastReprice = block.timestamp - cachedLastRepriceUNIX;\n    uint256 cachedMinimumRepriceTime = minimumRepriceTime;\n\n    if (timeSinceLastReprice < cachedMinimumRepriceTime) {\n      revert NotEnoughTimeElapsedForReprice(\n        cachedMinimumRepriceTime - timeSinceLastReprice\n      );\n    }\n\n    uint256 totalReserves = _preRewardETHReserves + _newETHRewards;\n\n    uint256 cachedNodeOperatorRewardPercentage = nodeOperatorRewardPercentage;\n\n    uint256 rewardPercentageTotal = swellTreasuryRewardPercentage +\n      cachedNodeOperatorRewardPercentage;\n\n    UD60x18 rewardsInETH = wrap(_newETHRewards).mul(\n      wrap(rewardPercentageTotal)\n    );\n\n    UD60x18 rewardsInSwETH = wrap(_swETHTotalSupply).mul(rewardsInETH).div(\n      wrap(totalReserves - rewardsInETH.unwrap())\n    );\n\n    // Also including the amount of new swETH that was minted alongside the provided swETH total supply\n    uint256 updatedSwETHToETHRateFixed = wrap(totalReserves)\n      .div(wrap(_swETHTotalSupply + rewardsInSwETH.unwrap()))\n      .unwrap();\n\n    // Ensure that the reprice differences are within expected ranges, only if the reprice method has been called before\n    if (cachedLastRepriceUNIX != 0) {\n      uint256 cachedSwETHToETHRateFixed = swETHToETHRateFixed;\n      // Check repricing rate difference\n      uint256 repriceDiff = _absolute(\n        updatedSwETHToETHRateFixed,\n        cachedSwETHToETHRateFixed\n      );\n\n      uint256 maximumRepriceDiff = wrap(cachedSwETHToETHRateFixed)\n        .mul(wrap(maximumRepriceDifferencePercentage))\n        .unwrap();\n\n      if (repriceDiff > maximumRepriceDiff) {\n        revert RepriceDifferenceTooLarge(repriceDiff, maximumRepriceDiff);\n      }\n    }\n\n    // Check swETH supply provided with actual current supply\n    uint256 swETHSupplyDiff = _absolute(currSupply, _swETHTotalSupply);\n\n    uint256 maximumswETHDiff = (currSupply *\n      maximumRepriceswETHDifferencePercentage) / 1 ether;\n\n    if (swETHSupplyDiff > maximumswETHDiff) {\n      revert RepriceswETHDifferenceTooLarge(swETHSupplyDiff, maximumswETHDiff);\n    }\n\n    uint256 nodeOperatorRewards;\n    uint256 swellTreasuryRewards;\n\n    if (rewardsInSwETH.unwrap() != 0) {\n      UD60x18 nodeOperatorRewardPortion = wrap(\n        cachedNodeOperatorRewardPercentage\n      ).div(wrap(rewardPercentageTotal));\n\n      nodeOperatorRewards = nodeOperatorRewardPortion\n        .mul(rewardsInSwETH)\n        .unwrap();\n\n      INodeOperatorRegistry nodeOperatorRegistry = AccessControlManager\n        .NodeOperatorRegistry();\n\n      uint256 totalActiveValidators = nodeOperatorRegistry\n        .getPoRAddressListLength();\n\n      if (totalActiveValidators == 0) {\n        nodeOperatorRewards = 0;\n      } else if (nodeOperatorRewards != 0) {\n        uint128 totalOperators = nodeOperatorRegistry.numOperators();\n\n        UD60x18 rewardsPerValidator = wrap(nodeOperatorRewards).div(\n          wrap(totalActiveValidators)\n        );\n\n        // Operator Id's start at 1\n        for (uint128 i = 1; i <= totalOperators; ) {\n          (\n            address rewardAddress,\n            uint256 operatorActiveValidators\n          ) = nodeOperatorRegistry.getRewardDetailsForOperatorId(i);\n\n          if (operatorActiveValidators != 0) {\n            uint256 operatorsRewardShare = rewardsPerValidator\n              .mul(wrap(operatorActiveValidators))\n              .unwrap();\n\n            _mint(rewardAddress, operatorsRewardShare);\n          }\n\n          // Will never overflow as the total operators are capped at uint128\n          unchecked {\n            ++i;\n          }\n        }\n      }\n\n      // Transfer the remaining rewards to the treasury\n      swellTreasuryRewards = rewardsInSwETH.unwrap() - nodeOperatorRewards;\n\n      if (swellTreasuryRewards != 0) {\n        _mint(AccessControlManager.SwellTreasury(), swellTreasuryRewards);\n      }\n    }\n\n    lastRepriceETHReserves = totalReserves;\n    lastRepriceUNIX = block.timestamp;\n    swETHToETHRateFixed = updatedSwETHToETHRateFixed;\n\n    emit Reprice(\n      totalReserves,\n      updatedSwETHToETHRateFixed,\n      nodeOperatorRewards,\n      swellTreasuryRewards,\n      totalETHDeposited\n    );\n  }\n\n  function burn(uint256 amount) external override {\n    if (amount == 0) {\n      revert CannotBurnZeroSwETH();\n    }\n\n    _burn(msg.sender, amount);\n  }\n\n  // ************************************\n  // ***** Internal methods ******\n\n  /**\n   * @dev Returns the ETH -> swETH rate, if no PoR reading has come through the rate is 1:1\n   * @return The rate as a fixed-point type\n   */\n  function _ethToSwETHRate() internal view returns (UD60x18) {\n    return wrap(1 ether).div(_swETHToETHRate());\n  }\n\n  /**\n   * @dev Returns the swETH -> ETH rate, if no PoR reading has come in the rate is 1:1\n   * @return The rate as a fixed-point type\n   */\n  function _swETHToETHRate() internal view returns (UD60x18) {\n    uint256 cachedSwETHToETHRateFixed = swETHToETHRateFixed;\n\n    if (cachedSwETHToETHRateFixed == 0) {\n      return wrap(1 ether);\n    }\n\n    return wrap(cachedSwETHToETHRateFixed);\n  }\n\n  /**\n   * @dev Returns the absolute difference between two uint256 values\n   */\n  function _absolute(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    if (_a < _b) {\n      return _b - _a;\n    }\n\n    return _a - _b;\n  }\n}"
    }
  ]
}