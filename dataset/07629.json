{
  "Title": "[H-12] Sender transferring GiantMevAndFeesPool tokens can afterward experience pool DOS and orphaning of future rewards",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L170-L173\n\n\n# Vulnerability details\n\n## Impact\nWhen a user transfers away GiantMevAndFeesPool tokens, the pool's claimed[] computed is left unchanged and still corresponds to what they had claimed with their old (higher) number of tokens. (See GiantMevAndFeesPool afterTokenTransfer() - no adjustment is made to claimed[] on the from side.) As a result, their claimed[] may be higher than the max amount they could possibly have claimed for their new (smaller) number of tokens. The erroneous claimed value can cause an integer overflow when the claimed[] value is subtracted, leading to inability for this user to access some functions of the GiantMevAndFeesPool - including such things as being able to transfer their tokens (overflow is triggered in a callback attempting to pay out their rewards). These overflows will occur in SyndicateRewardsProcessor's _previewAccumulatedETH() and _distributeETHRewardsToUserForToken(), the latter of which is called in a number of places. When rewards are later accumulated in the pool, the user will not be able to claim certain rewards owed to them because of the incorrect (high) claimed[] value. The excess rewards will be orphaned in the pool.\n\n## Proof of Concept\nThis patch demonstrates both DOS and orphaned rewards due to the claimed[] error described above. Note that the patch includes a temp fix for the separate issue calculating claimed[] in _distributeETHRewardsToUserForToken() in order to demonstrate this is a separate issue.\n\nRun test\n```\nforge test -m testTransferDOSUserOrphansFutureRewards\n```\n\nPatch\n```diff\ndiff --git a/contracts/liquid-staking/SyndicateRewardsProcessor.sol b/contracts/liquid-staking/SyndicateRewardsProcessor.sol\nindex 81be706..ca44ae6 100644\n--- a/contracts/liquid-staking/SyndicateRewardsProcessor.sol\n+++ b/contracts/liquid-staking/SyndicateRewardsProcessor.sol\n@@ -60,7 +60,7 @@ abstract contract SyndicateRewardsProcessor {\n             // Calculate how much ETH rewards the address is owed / due \n             uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) - claimed[_user][_token];\n             if (due > 0) {\n-                claimed[_user][_token] = due;\n+                claimed[_user][_token] += due; // temp fix claimed calculation\n \n                 totalClaimed += due;\n \ndiff --git a/test/foundry/GiantPools.t.sol b/test/foundry/GiantPools.t.sol\nindex 7e8bfdb..6468373 100644\n--- a/test/foundry/GiantPools.t.sol\n+++ b/test/foundry/GiantPools.t.sol\n@@ -5,14 +5,18 @@ pragma solidity ^0.8.13;\n import \"forge-std/console.sol\";\n import { TestUtils } from \"../utils/TestUtils.sol\";\n \n+import { MockLiquidStakingManager } from \"../../contracts/testing/liquid-staking/MockLiquidStakingManager.sol\";\n import { GiantSavETHVaultPool } from \"../../contracts/liquid-staking/GiantSavETHVaultPool.sol\";\n import { GiantMevAndFeesPool } from \"../../contracts/liquid-staking/GiantMevAndFeesPool.sol\";\n import { LPToken } from \"../../contracts/liquid-staking/LPToken.sol\";\n+import { GiantLP } from \"../../contracts/liquid-staking/GiantLP.sol\";\n import { MockSlotRegistry } from \"../../contracts/testing/stakehouse/MockSlotRegistry.sol\";\n import { MockSavETHVault } from \"../../contracts/testing/liquid-staking/MockSavETHVault.sol\";\n import { MockGiantSavETHVaultPool } from \"../../contracts/testing/liquid-staking/MockGiantSavETHVaultPool.sol\";\n import { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n \n+import \"forge-std/console.sol\";\n+\n contract GiantPoolTests is TestUtils {\n \n     MockGiantSavETHVaultPool public giantSavETHPool;\n@@ -116,4 +120,171 @@ contract GiantPoolTests is TestUtils {\n         assertEq(dETHToken.balanceOf(savETHUser), 24 ether);\n     }\n \n+    function addNewLSM(address payable giantFeesAndMevPool, bytes memory blsPubKey) public returns (address payable) {\n+        manager = deployNewLiquidStakingNetwork(\n+            factory,\n+            admin,\n+            true,\n+            \"LSDN\"\n+        );\n+\n+        savETHVault = MockSavETHVault(address(manager.savETHVault()));\n+\n+        giantSavETHPool = new MockGiantSavETHVaultPool(factory, savETHVault.dETHToken());\n+\n+        // Set up users and ETH\n+        address nodeRunner = accountOne; vm.deal(nodeRunner, 12 ether);\n+        address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);\n+\n+        // Register BLS key\n+        registerSingleBLSPubKey(nodeRunner, blsPubKey, accountFour);\n+\n+        // Deposit ETH into giant savETH\n+        vm.prank(savETHUser);\n+        giantSavETHPool.depositETH{value: 24 ether}(24 ether);\n+        assertEq(giantSavETHPool.lpTokenETH().balanceOf(savETHUser), 24 ether);\n+        assertEq(address(giantSavETHPool).balance, 24 ether);\n+\n+        // Deploy ETH from giant LP into savETH pool of LSDN instance\n+        bytes[][] memory blsKeysForVaults = new bytes[][](1);\n+        blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKey);\n+\n+        uint256[][] memory stakeAmountsForVaults = new uint256[][](1);\n+        stakeAmountsForVaults[0] = getUint256ArrayFromValues(24 ether);\n+\n+        giantSavETHPool.batchDepositETHForStaking(\n+            getAddressArrayFromValues(address(manager.savETHVault())),\n+            getUint256ArrayFromValues(24 ether),\n+            blsKeysForVaults,\n+            stakeAmountsForVaults\n+        );\n+        assertEq(address(manager.savETHVault()).balance, 24 ether);\n+\n+        assert(giantFeesAndMevPool.balance >= 4 ether);\n+        stakeAmountsForVaults[0] = getUint256ArrayFromValues(4 ether);\n+        GiantMevAndFeesPool(giantFeesAndMevPool).batchDepositETHForStaking(\n+            getAddressArrayFromValues(address(manager.stakingFundsVault())),\n+            getUint256ArrayFromValues(4 ether),\n+            blsKeysForVaults,\n+            stakeAmountsForVaults\n+        );\n+\n+        // Ensure we can stake and mint derivatives\n+        stakeAndMintDerivativesSingleKey(blsPubKey);\n+\n+        return payable(manager);\n+    }\n+\n+    function testTransferDOSUserOrphansFutureRewards() public {\n+\n+        address feesAndMevUserOne = accountTwo; vm.deal(feesAndMevUserOne, 8 ether);\n+        address feesAndMevUserTwo = accountFour;\n+\n+       // Deposit ETH into giant fees and mev\n+        vm.startPrank(feesAndMevUserOne);\n+        giantFeesAndMevPool.depositETH{value: 8 ether}(8 ether);\n+        vm.stopPrank();\n+\n+        MockLiquidStakingManager manager1 = MockLiquidStakingManager(addNewLSM(payable(giantFeesAndMevPool), blsPubKeyOne));\n+        MockLiquidStakingManager manager2 = MockLiquidStakingManager(addNewLSM(payable(giantFeesAndMevPool), blsPubKeyTwo));\n+\n+        bytes[][] memory blsPubKeyOneInput = new bytes[][](1);\n+        blsPubKeyOneInput[0] = getBytesArrayFromBytes(blsPubKeyOne);\n+\n+        bytes[][] memory blsPubKeyTwoInput = new bytes[][](1);\n+        blsPubKeyTwoInput[0] = getBytesArrayFromBytes(blsPubKeyTwo);\n+\n+        vm.warp(block.timestamp + 3 hours);\n+\n+        // Add 2 eth rewards to manager1's staking funds vault.\n+        vm.deal(address(manager1.stakingFundsVault()), 2 ether);\n+\n+        // Claim rewards into the giant pool and distribute them to user one.\n+        vm.startPrank(feesAndMevUserOne);\n+        giantFeesAndMevPool.claimRewards(\n+            feesAndMevUserOne,\n+            getAddressArrayFromValues(address(manager1.stakingFundsVault())),\n+            blsPubKeyOneInput);\n+        vm.stopPrank();\n+\n+        // User one has received all the rewards and has no more previewed rewards.\n+        assertEq(feesAndMevUserOne.balance, 2 ether);\n+        assertEq(giantFeesAndMevPool.totalRewardsReceived(), 2 ether);\n+        assertEq(\n+            giantFeesAndMevPool.previewAccumulatedETH(\n+                feesAndMevUserOne,\n+                new address[](0),\n+                new LPToken[][](0)),\n+                0);\n+\n+        // Check the claimed[] value for user 1. It is correct.\n+        assertEq(\n+            giantFeesAndMevPool.claimed(feesAndMevUserOne, address(giantFeesAndMevPool.lpTokenETH())),\n+            2 ether);\n+\n+        // User one transfers half their giant tokens to user 2.\n+        vm.startPrank(feesAndMevUserOne);\n+        giantFeesAndMevPool.lpTokenETH().transfer(feesAndMevUserTwo, 4 ether);\n+        vm.stopPrank();\n+\n+        // After the tokens have been transferred to user 2, user 1's claimed[] remains\n+        // unchanged - and is higher than the accumulated payout per share for user 1's\n+        // current number of shares.\n+        assertEq(\n+            giantFeesAndMevPool.claimed(feesAndMevUserOne, address(giantFeesAndMevPool.lpTokenETH())),\n+            2 ether);\n+\n+        // With this incorrect value of claimed[] causing a subtraction underflow, user one\n+        // cannot preview accumulated eth or perform any action that attempts to claim their\n+        // rewards such as transferring their tokens.\n+        vm.startPrank(feesAndMevUserOne);\n+        vm.expectRevert();\n+        giantFeesAndMevPool.previewAccumulatedETH(\n+            feesAndMevUserOne,\n+            new address[](0),\n+            new LPToken[][](0));\n+\n+        console.log(\"the revert expected now\");\n+        GiantLP token = giantFeesAndMevPool.lpTokenETH();\n+        vm.expectRevert();\n+        token.transfer(feesAndMevUserTwo, 1 ether);\n+        vm.stopPrank();\n+\n+        // Add 1 eth rewards to manager2's staking funds vault.\n+        vm.deal(address(manager2.stakingFundsVault()), 2 ether);\n+\n+        // User 2 claims rewards into the giant pool and obtains its 1/2 share.\n+        vm.startPrank(feesAndMevUserTwo);\n+        giantFeesAndMevPool.claimRewards(\n+            feesAndMevUserTwo,\n+            getAddressArrayFromValues(address(manager2.stakingFundsVault())),\n+            blsPubKeyTwoInput);\n+        vm.stopPrank();\n+        assertEq(feesAndMevUserTwo.balance, 1 ether);\n+\n+        // At this point, user 1 ought to have accumulated 1 ether from the rewards,\n+        // however accumulated eth is listed as 0.\n+        // The reason is that when the giant pool tokens were transferred to\n+        // user two, the claimed[] value for user one was left unchanged.\n+        assertEq(\n+            giantFeesAndMevPool.previewAccumulatedETH(\n+                feesAndMevUserOne,\n+                new address[](0),\n+                new LPToken[][](0)),\n+                0);\n+\n+        // The pool has received 4 eth rewards and paid out 3, but no users\n+        // are listed as having accumulated the eth. It is orphaned.\n+        assertEq(giantFeesAndMevPool.totalRewardsReceived(), 4 ether);\n+        assertEq(giantFeesAndMevPool.totalClaimed(), 3 ether);\n+\n+        assertEq(\n+            giantFeesAndMevPool.previewAccumulatedETH(\n+                feesAndMevUserTwo,\n+                new address[](0),\n+                new LPToken[][](0)),\n+                0);\n+\n+    }\n+\n }\n\\ No newline at end of file\n\n```\n## Tools Used\n\n## Recommended Mitigation Steps\nReduce claimed[] when necessary on the from side when GiantMevAndFeesPool tokens are transferred. Alternatively, claimed[] could be calculated on a per share basis rather than a total basis in order to simplify some of the adjustments that must be made in the code for claimed[].",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
  "Code": [
    {
      "filename": "contracts/liquid-staking/GiantMevAndFeesPool.sol",
      "content": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\n/// @notice A giant pool that can provide liquidity to any liquid staking network's staking funds vault\ncontract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, SyndicateRewardsProcessor {\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(this), \"GiantETHLP\", \"gMevETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Stake ETH against multiple BLS keys within multiple LSDNs and specify the amount of ETH being supplied for each key\n    /// @dev Uses contract balance for funding and get Staking Funds Vault LP in exchange for ETH\n    /// @param _stakingFundsVault List of mev and fees vaults being interacted with\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeyOfKnots For every staking funds vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _amounts List of amounts of ETH being staked per BLS public key\n    function batchDepositETHForStaking(\n        address[] calldata _stakingFundsVault,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeyOfKnots,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVault.length;\n        require(numOfVaults > 0, \"Zero vaults\");\n        require(numOfVaults == _blsPublicKeyOfKnots.length, \"Inconsistent lengths\");\n        require(numOfVaults == _amounts.length, \"Inconsistent lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            // As ETH is being deployed to a staking funds vault, it is no longer idle\n            idleETH -= _ETHTransactionAmounts[i];\n\n            StakingFundsVault sfv = StakingFundsVault(payable(_stakingFundsVault[i]));\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(sfv.liquidStakingNetworkManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            sfv.batchDepositETHForStaking{ value: _ETHTransactionAmounts[i] }(\n                _blsPublicKeyOfKnots[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a giant LP to claim a % of the revenue received by the MEV and Fees Pool\n    function claimRewards(\n        address _recipient,\n        address[] calldata _stakingFundsVaults,\n        bytes[][] calldata _blsPublicKeysForKnots\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty array\");\n        require(numOfVaults == _blsPublicKeysForKnots.length, \"Inconsistent array lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).claimRewards(\n                address(this),\n                _blsPublicKeysForKnots[i]\n            );\n        }\n\n        updateAccumulatedETHPerLP();\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            _recipient\n        );\n    }\n\n    /// @notice Preview total ETH accumulated by an address\n    function previewAccumulatedETH(\n        address _user,\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens\n    ) external view returns (uint256) {\n        require(_stakingFundsVaults.length == _lpTokens.length, \"Inconsistent array lengths\");\n\n        uint256 accumulated;\n        for (uint256 i; i < _stakingFundsVaults.length; ++i) {\n            accumulated = StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(\n                address(this),\n                _lpTokens[i]\n            );\n        }\n\n        return _previewAccumulatedETH(_user, address(lpTokenETH), lpTokenETH.balanceOf(_user), lpTokenETH.totalSupply(), accumulated);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _stakingFundsVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a Staking Funds vault can be brought back into the giant pool\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a staking funds vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).burnLPTokensForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Distribute any new ETH received to LP holders\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(lpTokenETH.totalSupply());\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function beforeTokenTransfer(address _from, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        updateAccumulatedETHPerLP();\n\n        // Make sure that `_from` gets total accrued before transfer as post transferred anything owed will be wiped\n        if (_from != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                _from,\n                address(lpTokenETH),\n                lpTokenETH.balanceOf(_from),\n                _from\n            );\n        }\n\n        // Make sure that `_to` gets total accrued before transfer as post transferred anything owed will be wiped\n        _distributeETHRewardsToUserForToken(\n            _to,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(_to),\n            _to\n        );\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function afterTokenTransfer(address, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        _setClaimedToMax(_to);\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate excluding idle ETH from LP depositors\n    function totalRewardsReceived() public view override returns (uint256) {\n        return address(this).balance + totalClaimed - idleETH;\n    }\n\n    /// @dev On withdrawing LP in exchange for burning giant LP, claim rewards\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal override {\n        // Use the transfer hook of LPToken to trigger the claiming accrued ETH\n        for (uint256 i; i < _lpTokens.length; ++i) {\n            _lpTokens[i].transfer(address(this), _lpTokens[i].balanceOf(address(this)));\n        }\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            msg.sender\n        );\n    }\n\n    /// @dev On depositing on ETH set claimed to max claim so the new depositor cannot claim ETH that they have not accrued\n    function _onDepositETH() internal override {\n        _setClaimedToMax(msg.sender);\n    }\n\n    /// @dev Internal re-usable method for setting claimed to max for msg.sender\n    function _setClaimedToMax(address _user) internal {\n        // New ETH stakers are not entitled to ETH earned by\n        claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;\n    }\n}"
    }
  ]
}