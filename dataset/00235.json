{
  "Title": "Missing Docstrings",
  "Content": "Throughout the [codebase](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/), there are several parts that do not have docstrings. For instance:\n\n\n* The [`mint`](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/L2/BVM_ETH.sol#L24-L30) function of the [`BVM_ETH`](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/L2/BVM_ETH.sol) contract is not documented.\n* The [variables](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/L2/GasPriceOracle.sol#L29-L31), [events](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/L2/GasPriceOracle.sol#L41-L43), and [modifiers](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/L2/GasPriceOracle.sol#L48-L55) of the [`GasPriceOracle`](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/L2/GasPriceOracle.sol) contract are not documented.\n* The [L1\\_MNT\\_ADDRESS](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/L1/L1CrossDomainMessenger.sol#L31) variable of the [`L1CrossDomainMessenger`](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/L1/L1CrossDomainMessenger.sol) contract is missing documentation. The same variable [lacks](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/L1/L1StandardBridge.sol#L29) docstrings in the `L1StandardBridge` and [in the](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/L2/L2StandardBridge.sol#L28) `L2StandardBridge` contracts.\n* The [`bridgeMNTTo`](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/L2/L2StandardBridge.sol#L525-L531) function of the [`L2StandardBridge`](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/L2/L2StandardBridge.sol) contract is not documented.\n* In the `depositTransaction` [function](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L451) of the `OptimismPortal` contract it is possible to bridge simultaneously ETH and MNT at the same time. If this is the case the user should not use the normal flow of bridging through `L2CrossDomainMessenger` and `L2StandardBridge` since this supports bridging only one asset at time. Consider warning the user about it.\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not `public`, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/latest/natspec-format.html) (NatSpec).\n\n\n***Update:** Acknowledged, not resolved. The Mantle team stated:*\n\n\n\n> *No need to fix.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/contracts-bedrock/contracts/L2/BVM_ETH.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\n\n/* Contract Imports */\nimport { OptimismMintableERC20 } from \"../universal/OptimismMintableERC20.sol\";\n\n/**\n * @title BVM_ETH\n * @dev The ETH predeploy provides an ERC20 interface for ETH deposited to Layer 2. Note that\n * unlike on Layer 1, Layer 2 accounts do not have a balance field.\n */\ncontract BVM_ETH is OptimismMintableERC20 {\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor()\n    OptimismMintableERC20(Predeploys.L2_STANDARD_BRIDGE, address(0), \"Ether\", \"WETH\")\n    {}\n\n    function mint(address _to, uint256 _amount)\n        public\n        virtual\n        override\n    {\n        revert(\"BVM_ETH: mint is disabled by normal contract calling. BVM_ETH mint can only be triggered in deposit transaction execution, similar to MNT mint on L2.\");\n    }\n\n    /**\n * @notice A modifier that only allows the L2_TO_L1_MESSAGE_PASSER to call\n     */\n    modifier onlyL2Passer() {\n        require(msg.sender == Predeploys.L2_TO_L1_MESSAGE_PASSER, \"OptimismMintableERC20: only L2MessagePasser can burn\");\n        _;\n    }\n\n    /**\n    * @notice Allows the StandardBridge on this network to burn tokens.\n     *\n     * @param _from   Address to burn tokens from.\n     * @param _amount Amount of tokens to burn.\n     */\n    function burn(address _from, uint256 _amount)\n        external\n        virtual\n        override\n        onlyL2Passer\n    {\n        _burn(_from, _amount);\n        emit Burn(_from, _amount);\n    }\n}"
    },
    {
      "filename": "packages/contracts-bedrock/contracts/L2/GasPriceOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Semver } from \"../universal/Semver.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { L1Block } from \"../L2/L1Block.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x420000000000000000000000000000000000000F\n * @title GasPriceOracle\n * @notice This contract maintains the variables responsible for computing the L1 portion of the\n *         total fee charged on L2. Before Bedrock, this contract held variables in state that were\n *         read during the state transition function to compute the L1 portion of the transaction\n *         fee. After Bedrock, this contract now simply proxies the L1Block contract, which has\n *         the values used to compute the L1 portion of the fee in its state.\n *\n *         The contract exposes an API that is useful for knowing how large the L1 portion of the\n *         transaction fee will be. The following events were deprecated with Bedrock:\n *         - event OverheadUpdated(uint256 overhead);\n *         - event ScalarUpdated(uint256 scalar);\n *         - event DecimalsUpdated(uint256 decimals);\n */\ncontract GasPriceOracle is Semver {\n    /**\n     * @notice Number of decimals used in the scalar.\n     */\n    uint256 public constant DECIMALS = 6;\n    uint256 public tokenRatio;\n    address public owner;\n    address public operator;\n\n    /**\n     * @custom:semver 1.0.0\n     */\n    constructor() Semver(1, 0, 0) {}\n\n    /**********\n    * Events *\n    **********/\n    event TokenRatioUpdated(uint256 indexed previousTokenRatio, uint256 indexed newTokenRatio);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event OperatorUpdated(address indexed previousOperator, address indexed newOperator);\n\n    /**********\n    * Modifiers *\n    **********/\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Caller is not the owner\");\n        _;\n    }\n    modifier onlyOperator() {\n        require(operator == msg.sender, \"Caller is not the operator\");\n        _;\n    }\n\n    /**\n    * Allows the owner to modify the operator.\n    * @param _operator New operator\n     */\n    // slither-disable-next-line external-function\n    function setOperator(address _operator) public onlyOwner {\n        address previousOperator = operator;\n        operator = _operator;\n        emit OperatorUpdated(previousOperator, operator);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`_owner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address _owner) public onlyOwner {\n        require(_owner != address(0), \"new owner is the zero address\");\n        address previousOwner = owner;\n        owner = _owner;\n        emit OwnershipTransferred(previousOwner, owner);\n    }\n\n    /**\n    * Allows the operator to modify the token ratio.\n    * @param _tokenRatio New tokenRatio\n     */\n    // slither-disable-next-line external-function\n    function setTokenRatio(uint256 _tokenRatio) public onlyOperator {\n        uint256 previousTokenRatio = _tokenRatio;\n        tokenRatio = _tokenRatio;\n        emit TokenRatioUpdated(previousTokenRatio, tokenRatio);\n    }\n\n    /**\n     * @notice Computes the L1 portion of the fee based on the size of the rlp encoded input\n     *         transaction, the current L1 base fee, and the various dynamic parameters.\n     *\n     * @param _data Unsigned fully RLP-encoded transaction to get the L1 fee for.\n     *\n     * @return L1 fee that should be paid for the tx\n     */\n    function getL1Fee(bytes memory _data) external view returns (uint256) {\n        uint256 l1GasUsed = getL1GasUsed(_data);\n        uint256 l1Fee = l1GasUsed * l1BaseFee();\n        uint256 divisor = 10**DECIMALS;\n        uint256 unscaled = l1Fee * scalar();\n        uint256 scaled = unscaled / divisor;\n        return scaled;\n    }\n\n    /**\n     * @notice Retrieves the current gas price (base fee).\n     *\n     * @return Current L2 gas price (base fee).\n     */\n    function gasPrice() public view returns (uint256) {\n        return block.basefee;\n    }\n\n    /**\n     * @notice Retrieves the current base fee.\n     *\n     * @return Current L2 base fee.\n     */\n    function baseFee() public view returns (uint256) {\n        return block.basefee;\n    }\n\n    /**\n     * @notice Retrieves the current fee overhead.\n     *\n     * @return Current fee overhead.\n     */\n    function overhead() public view returns (uint256) {\n        return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).l1FeeOverhead();\n    }\n\n    /**\n     * @notice Retrieves the current fee scalar.\n     *\n     * @return Current fee scalar.\n     */\n    function scalar() public view returns (uint256) {\n        return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).l1FeeScalar();\n    }\n\n    /**\n     * @notice Retrieves the latest known L1 base fee.\n     *\n     * @return Latest known L1 base fee.\n     */\n    function l1BaseFee() public view returns (uint256) {\n        return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).basefee();\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Retrieves the number of decimals used in the scalar.\n     *\n     * @return Number of decimals used in the scalar.\n     */\n    function decimals() public pure returns (uint256) {\n        return DECIMALS;\n    }\n\n    /**\n     * @notice Computes the amount of L1 gas used for a transaction. Adds the overhead which\n     *         represents the per-transaction gas overhead of posting the transaction and state\n     *         roots to L1. Adds 68 bytes of padding to account for the fact that the input does\n     *         not have a signature.\n     *\n     * @param _data Unsigned fully RLP-encoded transaction to get the L1 gas for.\n     *\n     * @return Amount of L1 gas used to publish the transaction.\n     */\n    function getL1GasUsed(bytes memory _data) public view returns (uint256) {\n        uint256 total = 0;\n        uint256 length = _data.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (_data[i] == 0) {\n                total += 4;\n            } else {\n                total += 16;\n            }\n        }\n        uint256 unsigned = total + overhead();\n        return unsigned + (68 * 16);\n    }\n}"
    },
    {
      "filename": "packages/contracts-bedrock/contracts/L1/L1CrossDomainMessenger.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\n\nimport { OptimismPortal } from \"./OptimismPortal.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { L2CrossDomainMessenger } from \"../L2/L2CrossDomainMessenger.sol\";\n\n/**\n * @custom:proxied\n * @title L1CrossDomainMessenger\n * @notice The L1CrossDomainMessenger is a message passing interface between L1 and L2 responsible\n *         for sending and receiving data on the L1 side. Users are encouraged to use this\n *         interface instead of interacting with lower-level contracts directly.\n */\ncontract L1CrossDomainMessenger is CrossDomainMessenger, Semver {\n    using SafeERC20 for IERC20;\n    /**\n     * @notice Address of the OptimismPortal.\n     */\n    OptimismPortal public immutable PORTAL;\n\n    address public immutable L1_MNT_ADDRESS;\n    /**\n     * @custom:semver 1.4.0\n     *\n     * @param _portal Address of the OptimismPortal contract on this network.\n     */\n    constructor(OptimismPortal _portal, address l1mnt)\n        Semver(1, 4, 0)\n        CrossDomainMessenger(Predeploys.L2_CROSS_DOMAIN_MESSENGER)\n    {\n        PORTAL = _portal;\n        L1_MNT_ADDRESS = l1mnt;\n        initialize();\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize() public initializer {\n        __CrossDomainMessenger_init();\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _sendMessage(\n        uint256 _mntAmount,\n        address _to,\n        uint64 _gasLimit,\n        bytes memory _data\n    ) internal override {\n        PORTAL.depositTransaction{value: msg.value}(msg.value, _mntAmount, _to, _mntAmount, _gasLimit, false, _data);\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function sendMessage(\n        uint256 _mntAmount,\n        address _target,\n        bytes calldata _message,\n        uint32 _minGasLimit\n    ) external payable override {\n        if (_mntAmount!=0){\n            IERC20(L1_MNT_ADDRESS).safeTransferFrom(msg.sender, address(this), _mntAmount);\n            bool success = IERC20(L1_MNT_ADDRESS).approve(address(PORTAL), _mntAmount);\n            require(success,\"the approve for L1 mnt to OptimismPortal failed\");\n        }\n\n        // Triggers a message to the other messenger. Note that the amount of gas provided to the\n        // message is the amount of gas requested by the user PLUS the base gas value. We want to\n        // guarantee the property that the call to the target contract will always have at least\n        // the minimum gas limit specified by the user.\n        _sendMessage(\n            _mntAmount,\n            OTHER_MESSENGER,\n            baseGas(_message, _minGasLimit),\n            abi.encodeWithSelector(\n                L2CrossDomainMessenger.relayMessage.selector,\n                messageNonce(),\n                msg.sender,\n                _target,\n                _mntAmount,\n                msg.value,\n                _minGasLimit,\n                _message\n            )\n        );\n\n        emit SentMessage(_target, msg.sender, _message, messageNonce(), _minGasLimit);\n        emit SentMessageExtension1(msg.sender, _mntAmount, msg.value);\n\n        unchecked {\n            ++msgNonce;\n        }\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _minGasLimit\n    ) external payable override {\n\n        // Triggers a message to the other messenger. Note that the amount of gas provided to the\n        // message is the amount of gas requested by the user PLUS the base gas value. We want to\n        // guarantee the property that the call to the target contract will always have at least\n        // the minimum gas limit specified by the user.\n        _sendMessage(\n            0,\n            OTHER_MESSENGER,\n            baseGas(_message, _minGasLimit),\n            abi.encodeWithSelector(\n                L2CrossDomainMessenger.relayMessage.selector,\n                messageNonce(),\n                msg.sender,\n                _target,\n                0,\n                msg.value,\n                _minGasLimit,\n                _message\n            )\n        );\n\n        emit SentMessage(_target, msg.sender, _message, messageNonce(), _minGasLimit);\n        emit SentMessageExtension1(msg.sender, 0, msg.value);\n\n        unchecked {\n            ++msgNonce;\n        }\n    }\n\n    /**\n     * @notice Relays a message that was sent by the other CrossDomainMessenger contract. Can only\n     *         be executed via cross-chain call from the other messenger OR if the message was\n     *         already received once and is currently being replayed.\n     *\n     * @param _nonce       Nonce of the message being relayed.\n     * @param _sender      Address of the user who sent the message.\n     * @param _target      Address that the message is targeted at.\n     * @param _mntValue    MNT value to send with the message.\n     * @param _ethValue    ETH value to send with the message.\n     * @param _minGasLimit Minimum amount of gas that the message can be executed with.\n     * @param _message     Message to send to the target.\n     */\n    function relayMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _mntValue,\n        uint256 _ethValue,\n        uint256 _minGasLimit,\n        bytes calldata _message\n    ) external payable override {\n        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\n        require(\n            version < 2,\n            \"CrossDomainMessenger: only version 0 or 1 messages are supported at this time\"\n        );\n\n        // If the message is version 0, then it's a migrated legacy withdrawal. We therefore need\n        // to check that the legacy version of the message has not already been relayed.\n        if (version == 0) {\n            bytes32 oldHash = Hashing.hashCrossDomainMessageV0(_target, _sender, _message, _nonce);\n            require(\n                successfulMessages[oldHash] == false,\n                \"CrossDomainMessenger: legacy withdrawal already relayed\"\n            );\n        }\n\n        // We use the v1 message hash as the unique identifier for the message because it commits\n        // to the value and minimum gas limit of the message.\n        bytes32 versionedHash = Hashing.hashCrossDomainMessageV1(\n            _nonce,\n            _sender,\n            _target,\n            _mntValue,\n            _ethValue,\n            _minGasLimit,\n            _message\n        );\n\n        if (_isOtherMessenger()) {\n            // These properties should always hold when the message is first submitted (as\n            // opposed to being replayed).\n            assert(msg.value == _ethValue);\n            assert(!failedMessages[versionedHash]);\n        } else {\n            require(\n                msg.value == 0,\n                \"CrossDomainMessenger: value must be zero unless message is from a system address\"\n            );\n\n            require(\n                failedMessages[versionedHash],\n                \"CrossDomainMessenger: message cannot be replayed\"\n            );\n        }\n\n        require(\n            _isUnsafeTarget(_target) == false,\n            \"CrossDomainMessenger: cannot send message to blocked system address\"\n        );\n\n        require(\n            successfulMessages[versionedHash] == false,\n            \"CrossDomainMessenger: message has already been relayed\"\n        );\n\n        // If there is not enough gas left to perform the external call and finish the execution,\n        // return early and assign the message to the failedMessages mapping.\n        // We are asserting that we have enough gas to:\n        // 1. Call the target contract (_minGasLimit + RELAY_CALL_OVERHEAD + RELAY_GAS_CHECK_BUFFER)\n        //   1.a. The RELAY_CALL_OVERHEAD is included in `hasMinGas`.\n        // 2. Finish the execution after the external call (RELAY_RESERVED_GAS).\n        //\n        // If `xDomainMsgSender` is not the default L2 sender, this function\n        // is being re-entered. This marks the message as failed to allow it to be replayed.\n        if (\n            !SafeCall.hasMinGas(_minGasLimit, RELAY_RESERVED_GAS + RELAY_GAS_CHECK_BUFFER) ||\n        xDomainMsgSender != Constants.DEFAULT_L2_SENDER\n        ) {\n            failedMessages[versionedHash] = true;\n            emit FailedRelayedMessage(versionedHash);\n\n            // Revert in this case if the transaction was triggered by the estimation address. This\n            // should only be possible during gas estimation or we have bigger problems. Reverting\n            // here will make the behavior of gas estimation change such that the gas limit\n            // computed will be the amount required to relay the message, even if that amount is\n            // greater than the minimum gas limit specified by the user.\n            if (tx.origin == Constants.ESTIMATION_ADDRESS) {\n                revert(\"CrossDomainMessenger: failed to relay message\");\n            }\n\n            return;\n        }\n        if (_mntValue!=0){\n            IERC20(L1_MNT_ADDRESS).approve(_target, _mntValue);\n        }\n        xDomainMsgSender = _sender;\n        bool success = SafeCall.call(_target, gasleft() - RELAY_RESERVED_GAS, _ethValue, _message);\n        xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\n        if (_mntValue!=0){\n            IERC20(L1_MNT_ADDRESS).approve(_target, 0);\n        }\n        if (success) {\n            successfulMessages[versionedHash] = true;\n            emit RelayedMessage(versionedHash);\n        } else {\n            failedMessages[versionedHash] = true;\n            emit FailedRelayedMessage(versionedHash);\n\n            // Revert in this case if the transaction was triggered by the estimation address. This\n            // should only be possible during gas estimation or we have bigger problems. Reverting\n            // here will make the behavior of gas estimation change such that the gas limit\n            // computed will be the amount required to relay the message, even if that amount is\n            // greater than the minimum gas limit specified by the user.\n            if (tx.origin == Constants.ESTIMATION_ADDRESS) {\n                revert(\"CrossDomainMessenger: failed to relay message\");\n            }\n        }\n    }\n\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _isOtherMessenger() internal view override returns (bool) {\n        return msg.sender == address(PORTAL) && PORTAL.l2Sender() == OTHER_MESSENGER;\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _isUnsafeTarget(address _target) internal view override returns (bool) {\n        return _target == address(this) || _target == address(PORTAL);\n    }\n}"
    },
    {
      "filename": "packages/contracts-bedrock/contracts/L2/L2StandardBridge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { OptimismMintableERC20 } from \"../universal/OptimismMintableERC20.sol\";\nimport { L1StandardBridge } from \"../L1/L1StandardBridge.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000010\n * @title L2StandardBridge\n * @notice The L2StandardBridge is responsible for transfering ETH and ERC20 tokens between L1 and\n *         L2. In the case that an ERC20 token is native to L2, it will be escrowed within this\n *         contract. If the ERC20 token is native to L1, it will be burnt.\n *         NOTE: this contract is not intended to support all variations of ERC20 tokens. Examples\n *         of some token types that may not be properly supported by this contract include, but are\n *         not limited to: tokens with transfer fees, rebasing tokens, and tokens with blocklists.\n */\ncontract L2StandardBridge is StandardBridge, Semver {\n\n    using SafeERC20 for IERC20;\n\n    address public immutable L1_MNT_ADDRESS;\n\n    /**\n     * @custom:legacy\n     * @notice Emitted whenever a withdrawal from L2 to L1 is initiated.\n     *\n     * @param l1Token   Address of the token on L1.\n     * @param l2Token   Address of the corresponding token on L2.\n     * @param from      Address of the withdrawer.\n     * @param to        Address of the recipient on L1.\n     * @param amount    Amount of the ERC20 withdrawn.\n     * @param extraData Extra data attached to the withdrawal.\n     */\n    event WithdrawalInitiated(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @custom:legacy\n     * @notice Emitted whenever an ERC20 deposit is finalized.\n     *\n     * @param l1Token   Address of the token on L1.\n     * @param l2Token   Address of the corresponding token on L2.\n     * @param from      Address of the depositor.\n     * @param to        Address of the recipient on L2.\n     * @param amount    Amount of the ERC20 deposited.\n     * @param extraData Extra data attached to the deposit.\n     */\n    event DepositFinalized(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @custom:semver 1.1.0\n     *\n     * @param _otherBridge Address of the L1StandardBridge.\n     */\n    constructor(address payable _otherBridge, address _l1mnt)\n        Semver(1, 1, 0)\n        StandardBridge(payable(Predeploys.L2_CROSS_DOMAIN_MESSENGER), _otherBridge)\n    {\n        L1_MNT_ADDRESS = _l1mnt;\n    }\n\n    /**\n     * @notice Allows EOAs to bridge ETH by sending directly to the bridge.\n     */\n    receive() external payable override onlyEOA {\n        _initiateBridgeMNT(\n            msg.sender,\n            msg.sender,\n            msg.value,\n            RECEIVE_DEFAULT_GAS_LIMIT,\n            bytes(\"\")\n        );\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Initiates a withdrawal from L2 to L1.\n     *         This function only works with OptimismMintableERC20 tokens or ether. Use the\n     *         `bridgeERC20` function to bridge native L2 tokens to L1.\n     *\n     * @param _l2Token     Address of the L2 token to withdraw.\n     * @param _amount      Amount of the L2 token to withdraw.\n     * @param _minGasLimit Minimum gas limit to use for the transaction.\n     * @param _extraData   Extra data attached to the withdrawal.\n     */\n    function withdraw(\n        address _l2Token,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external payable onlyEOA {\n        _initiateWithdrawal(_l2Token, msg.sender, msg.sender, _amount, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Initiates a withdrawal from L2 to L1 to a target account on L1.\n     *         Note that if ETH is sent to a contract on L1 and the call fails, then that ETH will\n     *         be locked in the L1StandardBridge. ETH may be recoverable if the call can be\n     *         successfully replayed by increasing the amount of gas supplied to the call. If the\n     *         call will fail for any amount of gas, then the ETH will be locked permanently.\n     *         This function only works with OptimismMintableERC20 tokens or ether. Use the\n     *         `bridgeERC20To` function to bridge native L2 tokens to L1.\n     *\n     * @param _l2Token     Address of the L2 token to withdraw.\n     * @param _to          Recipient account on L1.\n     * @param _amount      Amount of the L2 token to withdraw.\n     * @param _minGasLimit Minimum gas limit to use for the transaction.\n     * @param _extraData   Extra data attached to the withdrawal.\n     */\n    function withdrawTo(\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external payable {\n        _initiateWithdrawal(_l2Token, msg.sender, _to, _amount, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Finalizes a deposit from L1 to L2. To finalize a deposit of ether, use address(0)\n     *         and the l1Token and the Legacy ERC20 ether predeploy address as the l2Token.\n     *\n     * @param _l1Token   Address of the L1 token to deposit.\n     * @param _l2Token   Address of the corresponding L2 token.\n     * @param _from      Address of the depositor.\n     * @param _to        Address of the recipient.\n     * @param _amount    Amount of the tokens being deposited.\n     * @param _extraData Extra data attached to the deposit.\n     */\n    function finalizeDeposit(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _extraData\n    ) external payable {\n        if (_l1Token == L1_MNT_ADDRESS && _l2Token == Predeploys.LEGACY_ERC20_MNT) {\n            finalizeBridgeMNT(_from, _to, _amount, _extraData);\n        } else if (_l1Token == address(0) && _l2Token == Predeploys.BVM_ETH) {\n            finalizeBridgeETH(_from, _to, _amount, _extraData);\n        } else {\n            finalizeBridgeERC20(_l2Token, _l1Token, _from, _to, _amount, _extraData);\n        }\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Retrieves the access of the corresponding L1 bridge contract.\n     *\n     * @return Address of the corresponding L1 bridge contract.\n     */\n    function l1TokenBridge() external view returns (address) {\n        return address(OTHER_BRIDGE);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Internal function to a withdrawal from L2 to L1 to a target account on L1.\n     *\n     * @param _l2Token     Address of the L2 token to withdraw.\n     * @param _from        Address of the withdrawer.\n     * @param _to          Recipient account on L1.\n     * @param _amount      Amount of the L2 token to withdraw.\n     * @param _minGasLimit Minimum gas limit to use for the transaction.\n     * @param _extraData   Extra data attached to the withdrawal.\n     */\n    function _initiateWithdrawal(\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes memory _extraData\n    ) internal {\n        if (_l2Token == Predeploys.BVM_ETH) {\n            _initiateBridgeETH(_from, _to, _amount, _minGasLimit, _extraData);\n        } else if (_l2Token == address(0)) {\n            _initiateBridgeMNT(_from, _to, _amount, _minGasLimit, _extraData);\n        } else {\n            address l1Token = OptimismMintableERC20(_l2Token).l1Token();\n            _initiateBridgeERC20(_l2Token, l1Token, _from, _to, _amount, _minGasLimit, _extraData);\n        }\n    }\n\n    /**\n * @notice Initiates a bridge of ETH through the CrossDomainMessenger.\n     *\n     * @param _from        Address of the sender.\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of ETH being bridged.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function _initiateBridgeETH(\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes memory _extraData\n    ) internal override {\n        require(msg.value==0, \"L2StandardBridge: the MNT value should be zero. \");\n        IERC20(Predeploys.BVM_ETH).safeTransferFrom(msg.sender, address(this), _amount);\n        IERC20(Predeploys.BVM_ETH).approve(Predeploys.L2_CROSS_DOMAIN_MESSENGER, _amount);\n\n        // Emit the correct events. By default this will be _amount, but child\n        // contracts may override this function in order to emit legacy events as well.\n        _emitETHBridgeInitiated(_from, _to, _amount, _extraData);\n\n        MESSENGER.sendMessage(\n            _amount,\n            address(OTHER_BRIDGE),\n            abi.encodeWithSelector(\n                L1StandardBridge.finalizeBridgeETH.selector,\n                _from,\n                _to,\n                _amount,\n                _extraData\n            ),\n            _minGasLimit\n        );\n    }\n\n    /**\n     * @notice Sends MNT tokens to a receiver's address on the other chain.\n     *\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of local tokens to deposit.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function _initiateBridgeMNT(\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes memory _extraData\n    ) internal override {\n        require(\n            msg.value == _amount,\n            \"StandardBridge: bridging MNT must include sufficient MNT value\"\n        );\n\n        // Emit the correct events. By default this will be ERC20BridgeInitiated, but child\n        // contracts may override this function in order to emit legacy events as well.\n        _emitMNTBridgeInitiated(_from, _to, _amount, _extraData);\n        uint256 zeroETHValue = 0;\n        MESSENGER.sendMessage{value: msg.value}(\n            zeroETHValue,\n            address(OTHER_BRIDGE),\n            abi.encodeWithSelector(\n                L1StandardBridge.finalizeBridgeMNT.selector,\n                // Because this call will be executed on the remote chain, we reverse the order of\n                // the remote and local token addresses relative to their order in the\n                // finalizeBridgeERC20 function.\n                _from,\n                _to,\n                _amount,\n                _extraData\n            ),\n            _minGasLimit\n        );\n    }\n\n    /**\n * @notice Sends ERC20 tokens to a receiver's address on the other chain.\n     *\n     * @param _localToken  Address of the ERC20 on this chain.\n     * @param _remoteToken Address of the corresponding token on the remote chain.\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of local tokens to deposit.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function _initiateBridgeERC20(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes memory _extraData\n    ) internal override {\n        require(msg.value==0, \"L2StandardBridge: the MNT value should be zero. \");\n        require(_localToken != Predeploys.BVM_ETH && _remoteToken != address(0),\n            \"L2StandardBridge: BridgeERC20 do not support ETH bridging.\");\n        require(_localToken != address(0x0) && _remoteToken != L1_MNT_ADDRESS,\n            \"L2StandardBridge: BridgeERC20 do not support MNT bridging.\");\n\n        if (_isOptimismMintableERC20(_localToken)) {\n            require(\n                _isCorrectTokenPair(_localToken, _remoteToken),\n                \"StandardBridge: wrong remote token for Optimism Mintable ERC20 local token\"\n            );\n\n            OptimismMintableERC20(_localToken).burn(_from, _amount);\n        } else {\n            IERC20(_localToken).safeTransferFrom(_from, address(this), _amount);\n            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] + _amount;\n        }\n\n        // Emit the correct events. By default this will be ERC20BridgeInitiated, but child\n        // contracts may override this"
    }
  ]
}