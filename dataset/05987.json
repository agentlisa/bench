{
  "Title": "[05] Missing constructor check for `AuctionDurationGteSequencePeriod()`",
  "Content": "The error `RngAuction.AuctionDurationGteSequencePeriod` has been declared but never used. It should be utilized to implement the following missing check.\n\nhttps://github.com/GenerationSoftware/pt-v5-draw-auction/blob/f1c6d14a1772d6609de1870f8713fb79977d51c1/src/RngAuction.sol#L140-L156\n\n```diff\n  constructor(\n    RNGInterface rng_,\n    address owner_,\n    uint64 sequencePeriod_,\n    uint64 sequenceOffset_,\n    uint64 auctionDurationSeconds_,\n    uint64 auctionTargetTime_\n  ) Ownable(owner_) {\n    if (sequencePeriod_ == 0) revert SequencePeriodZero();\n    if (auctionTargetTime_ > auctionDurationSeconds_) revert AuctionTargetTimeExceedsDuration(uint64(auctionTargetTime_), uint64(auctionDurationSeconds_));\n+    if (auctionDurationSeconds_ > sequencePeriod_) revert AuctionDurationGteSequencePeriod(uint64(auctionDurationSeconds_), uint64(sequencePeriod_));\n    sequencePeriod = sequencePeriod_;\n    sequenceOffset = sequenceOffset_;\n    auctionDuration = auctionDurationSeconds_;\n    auctionTargetTime = auctionTargetTime_;\n    _auctionTargetTimeFraction = intoUD2x18(convert(uint(auctionTargetTime_)).div(convert(uint(auctionDurationSeconds_))));\n    _setNextRngService(rng_);\n  }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-08-pooltogether",
  "Code": [
    {
      "filename": "src/RngAuction.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport { IERC20 } from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport { Ownable } from \"owner-manager/Ownable.sol\";\nimport { RNGInterface } from \"rng/RNGInterface.sol\";\nimport { UD2x18 } from \"prb-math/UD2x18.sol\";\nimport { UD60x18, convert, intoUD2x18 } from \"prb-math/UD60x18.sol\";\n\nimport { RewardLib } from \"./libraries/RewardLib.sol\";\nimport { IAuction, AuctionResult } from \"./interfaces/IAuction.sol\";\n\n/**\n  * @notice The results of a successful RNG auction.\n  * @param recipient The recipient of the auction reward\n  * @param rewardFraction The reward fraction that the user will receive\n  * @param sequenceId The id of the sequence that this auction belonged to\n  * @param rng The RNG service that was used to generate the random number\n  * @param rngRequestId The id of the RNG request that was made\n  * @dev   The `sequenceId` value should not be assumed to be the same as a prize pool drawId, but the sequence and offset should match the prize pool.\n  */\nstruct RngAuctionResult {\n  address recipient;\n  UD2x18 rewardFraction;\n  uint32 sequenceId;\n  RNGInterface rng;\n  uint32 rngRequestId;\n}\n\n/* ============ Custom Errors ============ */\n\n/// @notice Thrown when the auction duration is zero.\nerror AuctionDurationZero();\n\n/// @notice Thrown if the auction target time is zero.\nerror AuctionTargetTimeZero();\n\n/**\n  * @notice Thrown if the auction target time exceeds the auction duration.\n  * @param auctionTargetTime The auction target time to complete in seconds\n  * @param auctionDuration The auction duration in seconds\n  */\nerror AuctionTargetTimeExceedsDuration(uint64 auctionTargetTime, uint64 auctionDuration);\n\n/// @notice Thrown when the sequence period is zero.\nerror SequencePeriodZero();\n\n/**\n  * @notice Thrown when the auction duration is greater than or equal to the sequence.\n  * @param auctionDuration The auction duration in seconds\n  * @param sequencePeriod The sequence period in seconds\n  */\nerror AuctionDurationGteSequencePeriod(uint64 auctionDuration, uint64 sequencePeriod);\n\n/// @notice Thrown when the RNG address passed to the setter function is zero address.\nerror RngZeroAddress();\n\n/// @notice Thrown if the next sequence cannot yet be started\nerror CannotStartNextSequence();\n\n/// @notice Thrown if the time elapsed since the start of the auction is greater than the auction duration.\nerror AuctionExpired();\n\n/**\n * @title PoolTogether V5 RngAuction\n * @author Generation Software Team\n * @notice The RngAuction allows anyone to request a new random number using the RNG service set.\n *         The auction incetivises RNG requests to be started in-sync with prize pool draw\n *         periods across all chains.\n */\ncontract RngAuction is IAuction, Ownable {\n  using SafeERC20 for IERC20;\n\n  /* ============ Variables ============ */\n\n  /// @notice Duration of the auction in seconds\n  /// @dev This must always be less than the sequence period since the auction needs to complete each period.\n  uint64 public immutable auctionDuration;\n\n  /// @notice The target time to complete the auction in seconds\n  uint64 public immutable auctionTargetTime;\n\n  /// @notice The target time to complete the auction as a fraction of the auction duration\n  UD2x18 internal immutable _auctionTargetTimeFraction;\n\n  /// @notice Duration of the sequence that the auction should align with\n  /// @dev This must always be greater than the auction duration.\n  uint64 public immutable sequencePeriod;\n\n  /**\n   * @notice Offset of the sequence in seconds\n   * @dev If the next sequence starts at unix timestamp `t`, then a valid offset is equal to `t % sequencePeriod`.\n   * @dev If the offset is set to some point in the future, some calculations will fail until that time, effectively\n   * preventing any auctions until then.\n   */\n  uint64 public immutable sequenceOffset;\n\n  /// @notice New RNG instance that will be applied before the next auction completion\n  RNGInterface internal _nextRng;\n\n  /// @notice The last auction result\n  RngAuctionResult internal _lastAuction;\n\n  /* ============ Events ============ */\n\n  /**\n   * @notice Emitted when the RNG service address is set.\n   * @param rngService RNG service address\n   */\n  event SetNextRngService(RNGInterface indexed rngService);\n\n  /**\n   * @notice Emitted when the auction is completed.\n   * @param recipient The recipient of the auction awards\n   * @param sequenceId The sequence ID for the auction\n   * @param elapsedTime The amount of time that the auction ran for in seconds\n   * @param rewardFraction The fraction of the available rewards to be sent to the recipient\n   */\n  event RngAuctionCompleted(\n    address indexed recipient,\n    uint32 indexed sequenceId,\n    RNGInterface indexed rng,\n    uint32 rngRequestId,\n    uint64 elapsedTime,\n    UD2x18 rewardFraction\n  );\n\n  /* ============ Constructor ============ */\n\n  /**\n   * @notice Deploy the RngAuction smart contract.\n   * @param rng_ Address of the RNG service\n   * @param owner_ Address of the RngAuction owner. The owner may swap out the RNG service.\n   * @param sequencePeriod_ Sequence period in seconds\n   * @param sequenceOffset_ Sequence offset in seconds\n   * @param auctionDurationSeconds_ Auction duration in seconds\n   * @param auctionTargetTime_ Target time to complete the auction in seconds\n   */\n  constructor(\n    RNGInterface rng_,\n    address owner_,\n    uint64 sequencePeriod_,\n    uint64 sequenceOffset_,\n    uint64 auctionDurationSeconds_,\n    uint64 auctionTargetTime_\n  ) Ownable(owner_) {\n    if (sequencePeriod_ == 0) revert SequencePeriodZero();\n    if (auctionTargetTime_ > auctionDurationSeconds_) revert AuctionTargetTimeExceedsDuration(uint64(auctionTargetTime_), uint64(auctionDurationSeconds_));\n    sequencePeriod = sequencePeriod_;\n    sequenceOffset = sequenceOffset_;\n    auctionDuration = auctionDurationSeconds_;\n    auctionTargetTime = auctionTargetTime_;\n    _auctionTargetTimeFraction = intoUD2x18(convert(uint(auctionTargetTime_)).div(convert(uint(auctionDurationSeconds_))));\n    _setNextRngService(rng_);\n  }\n\n  /* ============ External Functions ============ */\n\n  /**\n   * @notice  Starts the RNG Request, ends the current auction, and stores the reward fraction to\n   *          be allocated to the recipient.\n   * @dev     Will revert if the current auction has already been completed or expired.\n   * @dev     If the RNG Service requests a `feeToken` for payment, the RNG-Request-Fee is expected\n   *          to be held within this contract before calling this function.\n   * @dev     If there is a pending RNGInstance (see _nextRng), it will be swapped in before the\n   *          auction is completed.\n   * @param _rewardRecipient Address that will receive the auction reward for starting the RNG request\n   */\n  function startRngRequest(address _rewardRecipient) external {\n    if (!_canStartNextSequence()) revert CannotStartNextSequence();\n\n    RNGInterface rng = _nextRng;\n\n    uint64 _auctionElapsedTimeSeconds = _auctionElapsedTime();\n    if (_auctionElapsedTimeSeconds > auctionDuration) revert AuctionExpired();\n\n    (address _feeToken, uint256 _requestFee) = rng.getRequestFee();\n    if (_feeToken != address(0) && _requestFee > 0) {\n      if (IERC20(_feeToken).balanceOf(address(this)) < _requestFee) {\n        // Transfer tokens from caller to this contract before continuing\n        IERC20(_feeToken).transferFrom(msg.sender, address(this), _requestFee);\n      }\n      // Increase allowance for the RNG service to take the request fee\n      IERC20(_feeToken).safeIncreaseAllowance(address(rng), _requestFee);\n    }\n\n    (uint32 rngRequestId,) = rng.requestRandomNumber();\n    uint32 sequenceId = _openSequenceId();\n    UD2x18 rewardFraction = _currentFractionalReward();\n\n    _lastAuction = RngAuctionResult({\n      recipient: _rewardRecipient,\n      rewardFraction: rewardFraction,\n      sequenceId: sequenceId,\n      rng: rng,\n      rngRequestId: rngRequestId\n    });\n\n    emit RngAuctionCompleted(\n      _rewardRecipient,\n      sequenceId,\n      rng,\n      rngRequestId,\n      _auctionElapsedTimeSeconds,\n      rewardFraction\n    );\n  }\n\n  /* ============ State Functions ============ */\n\n  /**\n   * @dev The auction is complete when the RNG has been requested for the current sequence.\n   */\n  function canStartNextSequence() external view returns (bool) {\n    return _canStartNextSequence();\n  }\n\n  /**\n   * @dev The auction is open if RNG has not been requested yet this sequence and the\n   * auction has not expired.\n   */\n  function isAuctionOpen() external view returns (bool) {\n    return _canStartNextSequence() && _auctionElapsedTime() <= auctionDuration;\n  }\n\n  /// @notice The amount of time remaining in the current open auction\n  /// @return The elapsed time since the auction started\n  function auctionElapsedTime() external view returns (uint64) {\n    return _auctionElapsedTime();\n  }\n\n  /// @notice The current reward as a fraction.\n  function currentFractionalReward() external view returns (UD2x18) {\n    return _currentFractionalReward();\n  }\n\n  /// @notice Returns the last rng auction result.\n  function getLastAuction() external view returns (RngAuctionResult memory) {\n    return _lastAuction;\n  }\n\n  /// @notice Returns the last auction as a AuctionResult struct to be used to calculate rewards\n  function getLastAuctionResult()\n    external\n    view\n    returns (AuctionResult memory)\n  {\n    address recipient = _lastAuction.recipient;\n    UD2x18 rewardFraction = _lastAuction.rewardFraction;\n    return AuctionResult({\n      recipient: recipient,\n      rewardFraction: rewardFraction\n    });\n  }\n\n  /**\n   * @notice Calculates a unique identifier for the current sequence.\n   * @return The current sequence ID.\n   */\n  function openSequenceId() external view returns (uint32) {\n    return _openSequenceId();\n  }\n\n  /**\n   * @notice Returns the last sequence ID.\n   * @return The last sequence ID.\n   */\n  function lastSequenceId() external view returns (uint32) {\n    return _lastAuction.sequenceId;\n  }\n\n  /**\n   * @notice Returns whether the RNG request has completed or not for the current sequence.\n   * @return True if the RNG request has completed, false otherwise.\n   */\n  function isRngComplete() external view returns (bool) {\n    return _isRngComplete();\n  }\n\n  /**\n   * @notice Returns the result of the last RNG Request.\n   * @dev The RNG service may revert if the current RNG request is not complete.\n   * @dev Not marked as view since RNGInterface.randomNumber is not a view function.\n   * @return randomNumber The random number result\n   * @return rngCompletedAt The timestamp at which the random number request was completed\n   */\n  function getRngResults()\n    external\n    returns (\n      uint256 randomNumber, uint64 rngCompletedAt\n    )\n  {\n    RNGInterface rng = _lastAuction.rng;\n    uint32 requestId = _lastAuction.rngRequestId;\n    return (rng.randomNumber(requestId), rng.completedAt(requestId));\n  }\n\n  /// @notice Computes the reward fraction for the given auction elapsed time.\n  function computeRewardFraction(uint64 __auctionElapsedTime) external view returns (UD2x18) {\n    return _computeRewardFraction(__auctionElapsedTime);\n  }\n\n  /* ============ Getter Functions ============ */\n\n  /**\n   * @notice Returns the RNG service used to generate random numbers.\n   * @return RNG service instance\n   */\n  function getLastRngService() external view returns (RNGInterface) {\n    return _lastAuction.rng;\n  }\n\n  /**\n   * @notice Returns the pending RNG service that will replace the current service before the next auction completes.\n   * @return RNG service instance\n   */\n  function getNextRngService() external view returns (RNGInterface) {\n    return _nextRng;\n  }\n\n  /**\n   * @notice Returns the sequence offset.\n   * @return The sequence offset in seconds\n   */\n  function getSequenceOffset() external view returns (uint64) {\n    return sequenceOffset;\n  }\n\n  /**\n   * @notice Returns the sequence period.\n   * @return The sequence period in seconds\n   */\n  function getSequencePeriod() external view returns (uint64) {\n    return sequencePeriod;\n  }\n\n  /* ============ Setters ============ */\n\n  /**\n   * @notice Sets the RNG service used to generate random numbers.\n   * @dev Only callable by the owner.\n   * @dev The service will not be udpated immediately so the current auction is not disturbed. Instead,\n   * it will be swapped out right before the next auction is completed.\n   * @param _rngService Address of the new RNG service\n   */\n  function setNextRngService(RNGInterface _rngService) external onlyOwner {\n    _setNextRngService(_rngService);\n  }\n\n  /* ============ Internal Functions ============ */\n\n  /**\n   * @notice Returns the current timestamp.\n   * @return The current timestamp.\n   */\n  function _currentTime() internal view returns (uint64) {\n    return uint64(block.timestamp);\n  }\n\n  /**\n   * @notice Calculates a unique identifier for the current sequence.\n   * @return The current sequence ID.\n   */\n  function _openSequenceId() internal view returns (uint32) {\n    /**\n     * Use integer division to calculate a unique ID based off the current timestamp that will remain the same\n     * throughout the entire sequence.\n     */\n    uint64 currentTime = _currentTime();\n    if (currentTime < sequenceOffset) {\n      return 0;\n    }\n    return uint32((currentTime - sequenceOffset) / sequencePeriod);\n  }\n\n  /**\n   * @notice Calculates the elapsed time for the current RNG auction.\n   * @return The elapsed time since the start of the current RNG auction in seconds.\n   */\n  function _auctionElapsedTime() internal view returns (uint64) {\n    uint64 currentTime = _currentTime();\n    if (currentTime < sequenceOffset) {\n      return 0;\n    }\n    return (_currentTime() - sequenceOffset) % sequencePeriod;\n  }\n\n  /**\n   * @notice Calculates the reward fraction for the current auction if it were to be completed at this time.\n   * @dev Uses the last sold fraction as the target price for this auction.\n   * @return The current reward fraction as a UD2x18 value\n   */\n  function _currentFractionalReward() internal view returns (UD2x18) {\n    return _computeRewardFraction(_auctionElapsedTime());\n  }\n\n  function _computeRewardFraction(uint64 __auctionElapsedTime) internal view returns (UD2x18) {\n    return\n      RewardLib.fractionalReward(\n        __auctionElapsedTime,\n        auctionDuration,\n        _auctionTargetTimeFraction,\n        _lastAuction.rewardFraction\n      );\n  }\n\n  /**\n   * @notice Returns whether the RNG request has been started for the current sequence.\n   * @return True if the RNG request has been started, false otherwise.\n   */\n  function _canStartNextSequence() internal view returns (bool) {\n    return _lastAuction.sequenceId != _openSequenceId();\n  }\n\n  /**\n   * @notice Returns whether the RNG request has completed or not for the current sequence ID.\n   * @return True if the RNG request has completed, false otherwise.\n   */\n  function _isRngComplete() internal view returns (bool) {\n    RNGInterface rng = _lastAuction.rng;\n    uint32 requestId = _lastAuction.rngRequestId;\n    return !_canStartNextSequence() && rng.isRequestComplete(requestId);\n  }\n\n  /**\n   * @notice Sets the RNG service used to generate random numbers.\n   * @param _newRng Address of the new RNG service\n   */\n  function _setNextRngService(RNGInterface _newRng) internal {\n    if (address(_newRng) == address(0)) revert RngZeroAddress();\n\n    // Set as pending if RNG is being replaced.\n    // The RNG will be swapped with the pending one before the next random number is requested.\n    _nextRng = _newRng;\n\n    emit SetNextRngService(_newRng);\n  }\n}"
    }
  ]
}