{
  "Title": "[G-01] Function `processRebond()` can be more optimized (Save 207 Gas on average)",
  "Content": "\nGas benchmarks based on function `rebondWithHint()` which calls our function of interest.\n\n|        | Min    | Max | Avg   | \n| ------ | --- | ------- | ----- | \n| Before | 229425    | 231632   | 230529 \n| After  | 229218    | 231425   | 230322 \n\n```solidity\nFile: /contracts/bonding/BondingManager.sol\n1564:    function processRebond(\n1565:        address _delegator,\n1566:        uint256 _unbondingLockId,\n1567:        address _newPosPrev,\n1568:        address _newPosNext\n1569:    ) internal autoCheckpoint(_delegator) {\n1570:        Delegator storage del = delegators[_delegator];\n1571:        UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];\n\n1573:        require(isValidUnbondingLock(_delegator, _unbondingLockId), \"invalid unbonding lock ID\");\n```\n\nOf interest to us is the require statement on line 1573:<br>\n`require(isValidUnbondingLock(_delegator, _unbondingLockId), \"invalid unbonding lock ID\");`\n\nThe statement makes a function call to `isValidUnbondingLock()` which we can see its implementation on https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L1167-L1170.\n\n```solidity\nFile: /contracts/bonding/BondingManager.sol\n1167:    function isValidUnbondingLock(address _delegator, uint256 _unbondingLockId) public view returns (bool) {\n1168:       // A unbonding lock is only valid if it has a non-zero withdraw round (the default value is zero)\n1169:        return delegators[_delegator].unbondingLocks[_unbondingLockId].withdrawRound > 0;\n1170:    }\n```\nNote the return statement in the above function `return delegators[_delegator].unbondingLocks[_unbondingLockId].withdrawRound > 0;`.<br>\nWe make some state reads by reading `delegators[_delegator]`.\n\nBack to our original function context, note we also made the same state read on https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L1570.\n\n```solidity\n1570:        Delegator storage del = delegators[_delegator];\n```\n\nThe require statement ends up doing the following:<br>\n`require(delegators[_delegator].unbondingLocks[_unbondingLockId].withdrawRound > 0,\"invalid unbonding lock ID\");`\n\nNote the variable `delegators[_delegator].unbondingLocks[_unbondingLockId]` is equivalent to the variable `lock` declared here  `UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];`\n\nIf we inline the function `isValidUnbondingLock()` we can avoid making this two state reads and take advantage of the already declared variable.\n\n```diff\ndiff --git a/contracts/bonding/BondingManager.sol b/contracts/bonding/BondingManager.sol\nindex 93e06ba..2482d64 100644\n--- a/contracts/bonding/BondingManager.sol\n+++ b/contracts/bonding/BondingManager.sol\n@@ -1569,8 +1569,7 @@ contract BondingManager is ManagerProxyTarget, IBondingManager {\n     ) internal autoCheckpoint(_delegator) {\n         Delegator storage del = delegators[_delegator];\n         UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];\n-\n-        require(isValidUnbondingLock(_delegator, _unbondingLockId), \"invalid unbonding lock ID\");\n+        require(lock.withdrawRound > 0,\"invalid unbonding lock ID\");\n```\n\n\nhttps://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L249-L257\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-08-livepeer",
  "Code": [
    {
      "filename": "contracts/bonding/BondingManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../ManagerProxyTarget.sol\";\nimport \"./IBondingManager.sol\";\nimport \"../libraries/SortedDoublyLL.sol\";\nimport \"../libraries/MathUtils.sol\";\nimport \"../libraries/PreciseMathUtils.sol\";\nimport \"./libraries/EarningsPool.sol\";\nimport \"./libraries/EarningsPoolLIP36.sol\";\nimport \"../token/ILivepeerToken.sol\";\nimport \"../token/IMinter.sol\";\nimport \"../rounds/IRoundsManager.sol\";\nimport \"../snapshots/IMerkleSnapshot.sol\";\nimport \"./IBondingVotes.sol\";\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @title BondingManager\n * @notice Manages bonding, transcoder and rewards/fee accounting related operations of the Livepeer protocol\n */\ncontract BondingManager is ManagerProxyTarget, IBondingManager {\n    using SafeMath for uint256;\n    using SortedDoublyLL for SortedDoublyLL.Data;\n    using EarningsPool for EarningsPool.Data;\n    using EarningsPoolLIP36 for EarningsPool.Data;\n\n    // Constants\n    // Occurances are replaced at compile time\n    // and computed to a single value if possible by the optimizer\n    uint256 constant MAX_FUTURE_ROUND = 2**256 - 1;\n\n    // Time between unbonding and possible withdrawl in rounds\n    uint64 public unbondingPeriod;\n\n    // Represents a transcoder's current state\n    struct Transcoder {\n        uint256 lastRewardRound; // Last round that the transcoder called reward\n        uint256 rewardCut; // % of reward paid to transcoder by a delegator\n        uint256 feeShare; // % of fees paid to delegators by transcoder\n        mapping(uint256 => EarningsPool.Data) earningsPoolPerRound; // Mapping of round => earnings pool for the round\n        uint256 lastActiveStakeUpdateRound; // Round for which the stake was last updated while the transcoder is active\n        uint256 activationRound; // Round in which the transcoder became active - 0 if inactive\n        uint256 deactivationRound; // Round in which the transcoder will become inactive\n        uint256 activeCumulativeRewards; // The transcoder's cumulative rewards that are active in the current round\n        uint256 cumulativeRewards; // The transcoder's cumulative rewards (earned via the its active staked rewards and its reward cut).\n        uint256 cumulativeFees; // The transcoder's cumulative fees (earned via the its active staked rewards and its fee share)\n        uint256 lastFeeRound; // Latest round in which the transcoder received fees\n    }\n\n    // The various states a transcoder can be in\n    enum TranscoderStatus {\n        NotRegistered,\n        Registered\n    }\n\n    // Represents a delegator's current state\n    struct Delegator {\n        uint256 bondedAmount; // The amount of bonded tokens\n        uint256 fees; // The amount of fees collected\n        address delegateAddress; // The address delegated to\n        uint256 delegatedAmount; // The amount of tokens delegated to the delegator\n        uint256 startRound; // The round the delegator transitions to bonded phase and is delegated to someone\n        uint256 lastClaimRound; // The last round during which the delegator claimed its earnings\n        uint256 nextUnbondingLockId; // ID for the next unbonding lock created\n        mapping(uint256 => UnbondingLock) unbondingLocks; // Mapping of unbonding lock ID => unbonding lock\n    }\n\n    // The various states a delegator can be in\n    enum DelegatorStatus {\n        Pending,\n        Bonded,\n        Unbonded\n    }\n\n    // Represents an amount of tokens that are being unbonded\n    struct UnbondingLock {\n        uint256 amount; // Amount of tokens being unbonded\n        uint256 withdrawRound; // Round at which unbonding period is over and tokens can be withdrawn\n    }\n\n    // Keep track of the known transcoders and delegators\n    mapping(address => Delegator) private delegators;\n    mapping(address => Transcoder) private transcoders;\n\n    // The total active stake (sum of the stake of active set members) for the current round\n    uint256 public currentRoundTotalActiveStake;\n    // The total active stake (sum of the stake of active set members) for the next round\n    uint256 public nextRoundTotalActiveStake;\n\n    // The transcoder pool is used to keep track of the transcoders that are eligible for activation.\n    // The pool keeps track of the pending active set in round N and the start of round N + 1 transcoders\n    // in the pool are locked into the active set for round N + 1\n    SortedDoublyLL.Data private transcoderPool;\n\n    // The % of newly minted rewards to be routed to the treasury. Represented as a PreciseMathUtils percPoint value.\n    uint256 public treasuryRewardCutRate;\n    // The value for `treasuryRewardCutRate` to be set on the next round initialization.\n    uint256 public nextRoundTreasuryRewardCutRate;\n\n    // If the balance of the treasury in LPT is above this value, automatic treasury contributions will halt.\n    uint256 public treasuryBalanceCeiling;\n\n    // Check if sender is TicketBroker\n    modifier onlyTicketBroker() {\n        _onlyTicketBroker();\n        _;\n    }\n\n    // Check if sender is RoundsManager\n    modifier onlyRoundsManager() {\n        _onlyRoundsManager();\n        _;\n    }\n\n    // Check if sender is Verifier\n    modifier onlyVerifier() {\n        _onlyVerifier();\n        _;\n    }\n\n    // Check if current round is initialized\n    modifier currentRoundInitialized() {\n        _currentRoundInitialized();\n        _;\n    }\n\n    // Automatically claim earnings from lastClaimRound through the current round\n    modifier autoClaimEarnings(address _delegator) {\n        _autoClaimEarnings(_delegator);\n        _;\n    }\n\n    modifier autoCheckpoint(address _account) {\n        _;\n        _checkpointBondingState(_account, delegators[_account], transcoders[_account]);\n    }\n\n    /**\n     * @notice BondingManager constructor. Only invokes constructor of base Manager contract with provided Controller address\n     * @dev This constructor will not initialize any state variables besides `controller`. The following setter functions\n     * should be used to initialize state variables post-deployment:\n     * - setUnbondingPeriod()\n     * - setNumActiveTranscoders()\n     * - setMaxEarningsClaimsRounds()\n     * @param _controller Address of Controller that this contract will be registered with\n     */\n    constructor(address _controller) Manager(_controller) {}\n\n    /**\n     * @notice Set unbonding period. Only callable by Controller owner\n     * @param _unbondingPeriod Rounds between unbonding and possible withdrawal\n     */\n    function setUnbondingPeriod(uint64 _unbondingPeriod) external onlyControllerOwner {\n        unbondingPeriod = _unbondingPeriod;\n\n        emit ParameterUpdate(\"unbondingPeriod\");\n    }\n\n    /**\n     * @notice Set treasury reward cut rate. Only callable by Controller owner. Notice that the change will only be\n     * effective on the next round.\n     * @param _cutRate Percentage of newly minted rewards to route to the treasury. Must be a valid PreciseMathUtils\n     * percentage (<100% specified with 27-digits precision).\n     */\n    function setTreasuryRewardCutRate(uint256 _cutRate) external onlyControllerOwner {\n        _setTreasuryRewardCutRate(_cutRate);\n    }\n\n    /**\n     * @notice Set treasury balance ceiling. Only callable by Controller owner\n     * @param _ceiling Balance at which treasury reward contributions should halt. Specified in LPT fractional units\n     * (18-digit precision).\n     */\n    function setTreasuryBalanceCeiling(uint256 _ceiling) external onlyControllerOwner {\n        treasuryBalanceCeiling = _ceiling;\n\n        emit ParameterUpdate(\"treasuryBalanceCeiling\");\n    }\n\n    /**\n     * @notice Set maximum number of active transcoders. Only callable by Controller owner\n     * @param _numActiveTranscoders Number of active transcoders\n     */\n    function setNumActiveTranscoders(uint256 _numActiveTranscoders) external onlyControllerOwner {\n        transcoderPool.setMaxSize(_numActiveTranscoders);\n\n        emit ParameterUpdate(\"numActiveTranscoders\");\n    }\n\n    /**\n     * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it\n     * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR\n     * @param _rewardCut % of reward paid to transcoder by a delegator\n     * @param _feeShare % of fees paid to delegators by a transcoder\n     */\n    function transcoder(uint256 _rewardCut, uint256 _feeShare) external {\n        transcoderWithHint(_rewardCut, _feeShare, address(0), address(0));\n    }\n\n    /**\n     * @notice Delegate stake towards a specific address\n     * @param _amount The amount of tokens to stake\n     * @param _to The address of the transcoder to stake towards\n     */\n    function bond(uint256 _amount, address _to) external {\n        bondWithHint(_amount, _to, address(0), address(0), address(0), address(0));\n    }\n\n    /**\n     * @notice Unbond an amount of the delegator's bonded stake\n     * @param _amount Amount of tokens to unbond\n     */\n    function unbond(uint256 _amount) external {\n        unbondWithHint(_amount, address(0), address(0));\n    }\n\n    /**\n     * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status\n     * @param _unbondingLockId ID of unbonding lock to rebond with\n     */\n    function rebond(uint256 _unbondingLockId) external {\n        rebondWithHint(_unbondingLockId, address(0), address(0));\n    }\n\n    /**\n     * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status\n     * @param _to Address of delegate\n     * @param _unbondingLockId ID of unbonding lock to rebond with\n     */\n    function rebondFromUnbonded(address _to, uint256 _unbondingLockId) external {\n        rebondFromUnbondedWithHint(_to, _unbondingLockId, address(0), address(0));\n    }\n\n    /**\n     * @notice Checkpoints the bonding state for a given account.\n     * @dev This is to allow checkpointing an account that has an inconsistent checkpoint with its current state.\n     * @param _account The account to make the checkpoint for\n     */\n    function checkpointBondingState(address _account) external {\n        _checkpointBondingState(_account, delegators[_account], transcoders[_account]);\n    }\n\n    /**\n     * @notice Withdraws tokens for an unbonding lock that has existed through an unbonding period\n     * @param _unbondingLockId ID of unbonding lock to withdraw with\n     */\n    function withdrawStake(uint256 _unbondingLockId) external whenSystemNotPaused currentRoundInitialized {\n        Delegator storage del = delegators[msg.sender];\n        UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];\n\n        require(isValidUnbondingLock(msg.sender, _unbondingLockId), \"invalid unbonding lock ID\");\n        require(\n            lock.withdrawRound <= roundsManager().currentRound(),\n            \"withdraw round must be before or equal to the current round\"\n        );\n\n        uint256 amount = lock.amount;\n        uint256 withdrawRound = lock.withdrawRound;\n        // Delete unbonding lock\n        delete del.unbondingLocks[_unbondingLockId];\n\n        // Tell Minter to transfer stake (LPT) to the delegator\n        minter().trustedTransferTokens(msg.sender, amount);\n\n        emit WithdrawStake(msg.sender, _unbondingLockId, amount, withdrawRound);\n    }\n\n    /**\n     * @notice Withdraws fees to the caller\n     */\n    function withdrawFees(address payable _recipient, uint256 _amount)\n        external\n        whenSystemNotPaused\n        currentRoundInitialized\n        autoClaimEarnings(msg.sender)\n    {\n        require(_recipient != address(0), \"invalid recipient\");\n        uint256 fees = delegators[msg.sender].fees;\n        require(fees >= _amount, \"insufficient fees to withdraw\");\n        delegators[msg.sender].fees = fees.sub(_amount);\n\n        // Tell Minter to transfer fees (ETH) to the address\n        minter().trustedWithdrawETH(_recipient, _amount);\n\n        emit WithdrawFees(msg.sender, _recipient, _amount);\n    }\n\n    /**\n     * @notice Mint token rewards for an active transcoder and its delegators\n     */\n    function reward() external {\n        rewardWithHint(address(0), address(0));\n    }\n\n    /**\n     * @notice Update transcoder's fee pool. Only callable by the TicketBroker\n     * @param _transcoder Transcoder address\n     * @param _fees Fees to be added to the fee pool\n     */\n    function updateTranscoderWithFees(\n        address _transcoder,\n        uint256 _fees,\n        uint256 _round\n    ) external whenSystemNotPaused onlyTicketBroker {\n        // Silence unused param compiler warning\n        _round;\n\n        require(isRegisteredTranscoder(_transcoder), \"transcoder must be registered\");\n\n        uint256 currentRound = roundsManager().currentRound();\n\n        Transcoder storage t = transcoders[_transcoder];\n\n        uint256 lastRewardRound = t.lastRewardRound;\n        uint256 activeCumulativeRewards = t.activeCumulativeRewards;\n\n        // LIP-36: Add fees for the current round instead of '_round'\n        // https://github.com/livepeer/LIPs/issues/35#issuecomment-673659199\n        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];\n        EarningsPool.Data memory prevEarningsPool = latestCumulativeFactorsPool(t, currentRound.sub(1));\n\n        // if transcoder hasn't called 'reward()' for '_round' its 'transcoderFeeShare', 'transcoderRewardCut' and 'totalStake'\n        // on the 'EarningsPool' for '_round' would not be initialized and the fee distribution wouldn't happen as expected\n        // for cumulative fee calculation this would result in division by zero.\n        if (currentRound > lastRewardRound) {\n            earningsPool.setCommission(t.rewardCut, t.feeShare);\n\n            uint256 lastUpdateRound = t.lastActiveStakeUpdateRound;\n            if (lastUpdateRound < currentRound) {\n                earningsPool.setStake(t.earningsPoolPerRound[lastUpdateRound].totalStake);\n            }\n\n            // If reward() has not been called yet in the current round, then the transcoder's activeCumulativeRewards has not\n            // yet been set in for the round. When the transcoder calls reward() its activeCumulativeRewards will be set to its\n            // current cumulativeRewards. So, we can just use the transcoder's cumulativeRewards here because this will become\n            // the transcoder's activeCumulativeRewards if it calls reward() later on in the current round\n            activeCumulativeRewards = t.cumulativeRewards;\n        }\n\n        uint256 totalStake = earningsPool.totalStake;\n        if (prevEarningsPool.cumulativeRewardFactor == 0 && lastRewardRound == currentRound) {\n            // if transcoder called reward for 'currentRound' but not for 'currentRound - 1' (missed reward call)\n            // retroactively calculate what its cumulativeRewardFactor would have been for 'currentRound - 1' (cfr. previous lastRewardRound for transcoder)\n            // based on rewards for currentRound\n            IMinter mtr = minter();\n            uint256 rewards = PreciseMathUtils.percOf(\n                mtr.currentMintableTokens().add(mtr.currentMintedTokens()),\n                totalStake,\n                currentRoundTotalActiveStake\n            );\n\n            // Deduct what would have been the treasury rewards\n            uint256 treasuryRewards = MathUtils.percOf(rewards, treasuryRewardCutRate);\n            rewards = rewards.sub(treasuryRewards);\n\n            uint256 transcoderCommissionRewards = MathUtils.percOf(rewards, earningsPool.transcoderRewardCut);\n            uint256 delegatorsRewards = rewards.sub(transcoderCommissionRewards);\n\n            prevEarningsPool.cumulativeRewardFactor = PreciseMathUtils.percOf(\n                earningsPool.cumulativeRewardFactor,\n                totalStake,\n                delegatorsRewards.add(totalStake)\n            );\n        }\n\n        uint256 delegatorsFees = MathUtils.percOf(_fees, earningsPool.transcoderFeeShare);\n        uint256 transcoderCommissionFees = _fees.sub(delegatorsFees);\n        // Calculate the fees earned by the transcoder's earned rewards\n        uint256 transcoderRewardStakeFees = PreciseMathUtils.percOf(\n            delegatorsFees,\n            activeCumulativeRewards,\n            totalStake\n        );\n        // Track fees earned by the transcoder based on its earned rewards and feeShare\n        t.cumulativeFees = t.cumulativeFees.add(transcoderRewardStakeFees).add(transcoderCommissionFees);\n        // Update cumulative fee factor with new fees\n        // The cumulativeFeeFactor is used to calculate fees for all delegators including the transcoder (self-delegated)\n        // Note that delegatorsFees includes transcoderRewardStakeFees, but no delegator will claim that amount using\n        // the earnings claiming algorithm and instead that amount is accounted for in the transcoder's cumulativeFees field\n        earningsPool.updateCumulativeFeeFactor(prevEarningsPool, delegatorsFees);\n\n        t.lastFeeRound = currentRound;\n    }\n\n    /**\n     * @notice Slash a transcoder. Only callable by the Verifier\n     * @param _transcoder Transcoder address\n     * @param _finder Finder that proved a transcoder violated a slashing condition. Null address if there is no finder\n     * @param _slashAmount Percentage of transcoder bond to be slashed\n     * @param _finderFee Percentage of penalty awarded to finder. Zero if there is no finder\n     */\n    function slashTranscoder(\n        address _transcoder,\n        address _finder,\n        uint256 _slashAmount,\n        uint256 _finderFee\n    ) external whenSystemNotPaused onlyVerifier autoClaimEarnings(_transcoder) autoCheckpoint(_transcoder) {\n        Delegator storage del = delegators[_transcoder];\n\n        if (del.bondedAmount > 0) {\n            uint256 penalty = MathUtils.percOf(delegators[_transcoder].bondedAmount, _slashAmount);\n\n            // If active transcoder, resign it\n            if (transcoderPool.contains(_transcoder)) {\n                resignTranscoder(_transcoder);\n            }\n\n            // Decrease bonded stake\n            del.bondedAmount = del.bondedAmount.sub(penalty);\n\n            // If still bonded decrease delegate's delegated amount\n            if (delegatorStatus(_transcoder) == DelegatorStatus.Bonded) {\n                delegators[del.delegateAddress].delegatedAmount = delegators[del.delegateAddress].delegatedAmount.sub(\n                    penalty\n                );\n            }\n\n            // Account for penalty\n            uint256 burnAmount = penalty;\n\n            // Award finder fee if there is a finder address\n            if (_finder != address(0)) {\n                uint256 finderAmount = MathUtils.percOf(penalty, _finderFee);\n                minter().trustedTransferTokens(_finder, finderAmount);\n\n                // Minter burns the slashed funds - finder reward\n                minter().trustedBurnTokens(burnAmount.sub(finderAmount));\n\n                emit TranscoderSlashed(_transcoder, _finder, penalty, finderAmount);\n            } else {\n                // Minter burns the slashed funds\n                minter().trustedBurnTokens(burnAmount);\n\n                emit TranscoderSlashed(_transcoder, address(0), penalty, 0);\n            }\n        } else {\n            emit TranscoderSlashed(_transcoder, _finder, 0, 0);\n        }\n    }\n\n    /**\n     * @notice Claim token pools shares for a delegator from its lastClaimRound through the end round\n     * @param _endRound The last round for which to claim token pools shares for a delegator\n     */\n    function claimEarnings(uint256 _endRound)\n        external\n        whenSystemNotPaused\n        currentRoundInitialized\n        autoCheckpoint(msg.sender)\n    {\n        // Silence unused param compiler warning\n        _endRound;\n\n        _autoClaimEarnings(msg.sender);\n    }\n\n    /**\n     * @notice Called during round initialization to set the total active stake for the round. Only callable by the RoundsManager\n     */\n    function setCurrentRoundTotalActiveStake() external onlyRoundsManager {\n        currentRoundTotalActiveStake = nextRoundTotalActiveStake;\n\n        if (nextRoundTreasuryRewardCutRate != treasuryRewardCutRate) {\n            treasuryRewardCutRate = nextRoundTreasuryRewardCutRate;\n            // The treasury cut rate changes in a delayed fashion so we want to emit the parameter update event here\n            emit ParameterUpdate(\"treasuryRewardCutRate\");\n        }\n\n        bondingVotes().checkpointTotalActiveStake(currentRoundTotalActiveStake, roundsManager().currentRound());\n    }\n\n    /**\n     * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it using an optional list hint\n     * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR. If the caller is going to be added to the pool, the\n     * caller can provide an optional hint for the insertion position in the pool via the `_newPosPrev` and `_newPosNext` params. A linear search will\n     * be executed starting at the hint to find the correct position - in the best case, the hint is the correct position so no search is executed.\n     * See SortedDoublyLL.sol for details on list hints\n     * @param _rewardCut % of reward paid to transcoder by a delegator\n     * @param _feeShare % of fees paid to delegators by a transcoder\n     * @param _newPosPrev Address of previous transcoder in pool if the caller joins the pool\n     * @param _newPosNext Address of next transcoder in pool if the caller joins the pool\n     */\n    function transcoderWithHint(\n        uint256 _rewardCut,\n        uint256 _feeShare,\n        address _newPosPrev,\n        address _newPosNext\n    ) public whenSystemNotPaused currentRoundInitialized {\n        require(!roundsManager().currentRoundLocked(), \"can't update transcoder params, current round is locked\");\n        require(MathUtils.validPerc(_rewardCut), \"invalid rewardCut percentage\");\n        require(MathUtils.validPerc(_feeShare), \"invalid feeShare percentage\");\n        require(isRegisteredTranscoder(msg.sender), \"transcoder must be registered\");\n\n        Transcoder storage t = transcoders[msg.sender];\n        uint256 currentRound = roundsManager().currentRound();\n\n        require(\n            !isActiveTranscoder(msg.sender) || t.lastRewardRound == currentRound,\n            \"caller can't be active or must have already called reward for the current round\"\n        );\n\n        t.rewardCut = _rewardCut;\n        t.feeShare = _feeShare;\n\n        if (!transcoderPool.contains(msg.sender)) {\n            tryToJoinActiveSet(\n                msg.sender,\n                delegators[msg.sender].delegatedAmount,\n                currentRound.add(1),\n                _newPosPrev,\n                _newPosNext\n            );\n        }\n\n        emit TranscoderUpdate(msg.sender, _rewardCut, _feeShare);\n    }\n\n    /**\n     * @notice Delegates stake \"on behalf of\" another address towards a specific address\n     * and updates the transcoder pool using optional list hints if needed\n     * @dev If the caller is decreasing the stake of its old delegate in the transcoder pool, the caller can provide an optional hint\n     * for the insertion position of the old delegate via the `_oldDelegateNewPosPrev` and `_oldDelegateNewPosNext` params.\n     * If the caller is delegating to a delegate that is in the transcoder pool, the caller can provide an optional hint for the\n     * insertion position of the delegate via the `_currDelegateNewPosPrev` and `_currDelegateNewPosNext` params.\n     * In both cases, a linear search will be executed starting at the hint to find the correct position. In the best case, the hint\n     * is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints\n     * @param _amount The amount of tokens to stake.\n     * @param _owner The address of the owner of the bond\n     * @param _to The address of the transcoder to stake towards\n     * @param _oldDelegateNewPosPrev The address of the previous transcoder in the pool for the old delegate\n     * @param _oldDelegateNewPosNext The address of the next transcoder in the pool for the old delegate\n     * @param _currDelegateNewPosPrev The address of the previous transcoder in the pool for the current delegate\n     * @param _currDelegateNewPosNext The address of the next transcoder in the pool for the current delegate\n     */\n    function bondForWithHint(\n        uint256 _amount,\n        address _owner,\n        address _to,\n        address _oldDelegateNewPosPrev,\n        address _oldDelegateNewPosNext,\n        address _currDelegateNewPosPrev,\n        address _currDelegateNewPosNext\n    ) public whenSystemNotPaused currentRoundInitialized {\n        // the `autoClaimEarnings` modifier has been replaced with its internal function as a `Stack too deep` error work-around\n        _autoClaimEarnings(_owner);\n        Delegator storage del = delegators[_owner];\n\n        uint256 currentRound = roundsManager().currentRound();\n        // Amount to delegate\n        uint256 delegationAmount = _amount;\n        // Current delegate\n        address currentDelegate = del.delegateAddress;\n        // Current bonded amount\n        uint256 currentBondedAmount = del.bondedAmount;\n\n        // Requirements for a third party caller that is not the L2Migrator\n        if (msg.sender != _owner && msg.sender != l2Migrator()) {\n            // Does not trigger self-delegation\n            // Does not change the delegate if it is already non-null\n            if (delegatorStatus(_owner) == DelegatorStatus.Unbonded) {\n                require(_to != _owner, \"INVALID_DELEGATE\");\n            } else {\n                require(currentDelegate == _to, \"INVALID_DELEGATE_CHANGE\");\n            }\n        }\n\n        if (delegatorStatus(_owner) == DelegatorStatus.Unbonded) {\n            // New delegate\n            // Set start round\n            // Don't set start round if delegator is in pending state because the start round would not change\n            del.startRound = currentRound.add(1);\n            // Unbonded state = no existing delegate and no bonded stake\n            // Thus, delegation amount = provided amount\n        } else if (currentBondedAmount > 0 && currentDelegate != _to) {\n            // A registered transcoder cannot delegate its bonded stake toward another address\n            // because it can only be delegated toward itself\n            // In the future, if delegation towards another registered transcoder as an already\n            // registered transcoder becomes useful (i.e. for transitive delegation), this restriction\n            // could be removed\n            require(!isRegisteredTranscoder(_owner), \"registered transcoders can't delegate towards other addresses\");\n            // Changing delegate\n            // Set start round\n            del.startRound = currentRound.add(1);\n            // Update amount to delegate with previous delegation amount\n            delegationAmount = delegationAmount.add(currentBondedAmount);\n\n            decreaseTotalStake(currentDelegate, currentBondedAmount, _oldDelegateNewPosPrev, _oldDelegateNewPosNext);\n        }\n\n        {\n            Transcoder storage newDelegate = transcoders[_to];\n            EarningsPool.Data storage currPool = newDelegate.earningsPoolPerRound[currentRound];\n            if (currPool.cumulativeRewardFactor == 0) {\n                currPool.cumulativeRewardFactor = cumulativeFactorsPool(newDelegate, newDelegate.lastRewardRound)\n                    .cumulativeRewardFactor;\n            }\n            if (currPool.cumulativeFeeFactor == 0) {\n                currPool.cumulativeFeeFactor = cumulativeFactorsPool(newDelegate, newDelegate.lastFeeRound)\n                    .cumulativeFeeFactor;\n            }\n        }\n\n        // cannot delegate to someone without having bonded stake\n        require(delegationAmount > 0, \"delegation amount must be greater than 0\");\n        // Update delegate\n        del.delegateAddress = _to;\n        // Update bonded amount\n        del.bondedAmount = currentBondedAmount.add(_amount);\n\n        increaseTotalStake(_to, delegationAmount, _currDelegateNewPosPrev, _currDelegateNewPosNext);\n\n        if (_amount > 0) {\n            // Transfer the LPT to the Minter\n            livepeerToken().transferFrom(msg.sender, address(minter()), _amount);\n        }\n\n        emit Bond(_to, currentDelegate, _owner, _amount, del.bondedAmount);\n\n        // the `autoCheckpoint` modifier has been replaced with its internal function as a `Stack too deep` error work-around\n        _checkpointBondingState(_owner, del, transcoders[_owner]);\n    }\n\n    /**\n     * @notice Delegates stake towards a specific address and updates the transcoder pool using optional list hints if needed\n     * @dev If the caller is decreasing the stake of its old delegate in the transcoder pool, the caller can provide an optional hint\n     * for the insertion position of the old delegate via the `_oldDelegateNewPosPrev` and `_oldDelegateNewPosNext` params.\n     * If the caller is delegating to a delegate that is in the transcoder pool, the caller can provide an optional hint for the\n     * insertion position of the delegate via the `_currDelegateNewPosPrev` and `_currDelegateNewPosNext` params.\n     * In both cases, a linear search will be executed starting at the hint to find the correct position. In the best case, the hint\n     * is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints\n     * @param _amount The amount of tokens to stake.\n     * @param _to The address of the transcoder to stake towards\n     * @param _oldDelegateNewPosPrev The address of the previous transcoder in the pool for the old delegate\n     * @param _oldDelegateNewPosNext The address of the next transcoder in the pool for the old delegate\n     * @param _currDelegateNewPosPrev The address of the previous transcoder in the pool for the current delegate\n     * @param _currDelegateNewPosNext The address of the next transcoder in the pool for the current delegate\n     */\n    function bondWithHint(\n        uint256 _amount,\n        address _to,\n        address _oldDelegateNewPosPrev,\n        address _oldDelegateNewPosNext,\n        address _currDelegateNewPosPrev,\n        address _currDelegateNewPosNext\n    ) public {\n        bondForWithHint(\n            _amount,\n            msg.sender,\n            _to,\n            _oldDelegateNewPosPrev,\n            _oldDelegateNewPosNext,\n            _currDelegateNewPosPrev,\n            _currDelegateNewPosNext\n        );\n    }\n\n    /**\n     * @notice Transfers ownership of a bond to a new delegator using optional hints if needed\n     *\n     * If the receiver is already bonded to a different delegate than the bond owner then the stake goes\n     * to the receiver's delegate otherwise the receiver's delegate is set as the owner's delegate\n     *\n     * @dev If the original delegate is in the transcoder pool, the caller can provide an optional hint for the\n     * insertion position of the delegate via the `_oldDelegateNewPosPrev` and `_oldDelegateNewPosNext` params.\n     * If the target delegate is in the transcoder pool, the caller can provide an optional hint for the\n     * insertion position of the delegate via the `_newDelegateNewPosPrev` and `_newDelegateNewPosNext` params.\n     *\n     * In both cases, a linear search will be executed starting at the hint to find the correct position. In the best case, the hint\n     * is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints\n     * @param _delegator Receiver of the bond\n     * @param _amount Portion of the bond to transfer to receiver\n     * @param _oldDelegateNewPosPrev Address of previous transcoder in pool if the delegate remains in the pool\n     * @param _oldDelegateNewPosNext Address of next transcoder in pool if the delegate remains in the pool\n     * @param _newDelegateNewPosPrev Address of previous transcoder in pool if the delegate is in the pool\n     * @param _newDelegateNewPosNext Address of next transcoder in pool if the delegate is in the pool\n     */\n    function transferBond(\n        address _delegator,\n        uint256 _amount,\n        address _oldDelegateNewPosPrev,\n        address _oldDelegateNewPosNext,\n        address _newDelegateNewPosPrev,\n        address _newDelegateNewPosNext\n    ) public whenSystemNotPaused currentRoundInitialized {\n        // the `autoClaimEarnings` modifier has been replaced with its internal function as a `Stack too deep` error work-around\n        _autoClaimEarnings(msg.sender);\n        Delegator storage oldDel = delegators[msg.sender];\n        Delegator storage newDel"
    }
  ]
}