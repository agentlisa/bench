{
  "Title": "[H-55] `_sendToken` implementation in `Balancer.sol` is wrong which will make the underlying erc20 be send to a random address and lost",
  "Content": "\nThe function `_sendToken` is called on `rebalance` to perform the rebalance operation by the owner which will transfer native token or the underlying ERC20 for a specific tOFT token to other chains. This function uses the `router` from Stargate to transfer the tokens, but the implementation of the `swap` is done wrong which will make the tokens to be lost.\n\n### Proof of Concept\n\n`_sendToken` calls Stargate's router `swap` function with the all the parameters needed as can be seen here <https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/Balancer.sol#L322-L332>, but the problem relies that the destination address is computed by calling `abi.encode(connectedOFTs[_oft][_dstChainId].dstOft)` instead of the `abi.encodePacked(connectedOFTs[_oft][_dstChainId].dstOft)` <https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/Balancer.sol#L316-L318>.\nPer Stargate documentation <https://stargateprotocol.gitbook.io/stargate/developers/how-to-swap> , the address of the swap need to casted to bytes by using `abi.encodePacked` and not `abi.encode`, casting which is done correctly in the `_sendNative` function <https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/Balancer.sol#L291> . The big difference between `abi.encodePacked` and `abi.encode` is that `abi.encode` will fill the remaining 12 bytes of casting a 20 bytes address with 0 values. Here is an example of casting the address `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`\n\n```solidity\nbytes normalAbi = 0x0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4;\nbytes packedAbi = 0x5b38da6a701c568545dcfcb03fcb875f56beddc4;\n```\n\nThis will hurt the whole logic of the `swap` since when the `lzReceive` function on the `Bridge.sol` contract from Startgate will be called, the address where the funds will be sent will be a wrong address. As you can see here the `lzReceive` on `Bridge.sol` for Abitrum for example uses assembly to load 20 bytes of the `payload` to the `toAddress`  <https://arbiscan.io/address/0x352d8275aae3e0c2404d9f68f6cee084b5beb3dd#code#F1#L88>\nwhich in our case, for the address that I provided as an example it would be\n\n```solidity\ntoAddress = 0x0000000000000000000000005b38Da6A701c5685;\n```\n\nbecause `abi.encode` was used instead of `abi.ecnodePacked`.\nThen it will try to swap the tokens to this address, by calling `sgReceive` on it, which will not exist in most of the case and the assets will be lost, as specified by Stargate documentation <https://stargateprotocol.gitbook.io/stargate/composability-stargatecomposed.sol>\n\n### Recommended Mitigation Steps\n\nUse `abi.encodePacked` instead of `abi.encode` on `_sendToken`, same as the protocol does in `_sendNative`, so the assumptions will be correct.\n\n**[0xRektora (Tapioca) confirmed](https://github.com/code-423n4/2023-07-tapioca-findings/issues/369#issuecomment-1680940751)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/Balancer.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"tapioca-periph/contracts/interfaces/ITapiocaOFT.sol\";\nimport \"tapioca-periph/contracts/interfaces/IStargateRouter.sol\";\nimport \"@rari-capital/solmate/src/auth/Owned.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n//\n//                 .(%%%%%%%%%%%%*       *\n//             #%%%%%%%%%%%%%%%%%%%%*  ####*\n//          #%%%%%%%%%%%%%%%%%%%%%#  /####\n//       ,%%%%%%%%%%%%%%%%%%%%%%%   ####.  %\n//                                #####\n//                              #####\n//   #####%#####              *####*  ####%#####*\n//  (#########(              #####     ##########.\n//  ##########             #####.      .##########\n//                       ,####/\n//                      #####\n//  %%%%%%%%%%        (####.           *%%%%%%%%%#\n//  .%%%%%%%%%%     *####(            .%%%%%%%%%%\n//   *%%%%%%%%%%   #####             #%%%%%%%%%%\n//               (####.\n//      ,((((  ,####(          /(((((((((((((\n//        *,  #####  ,(((((((((((((((((((((\n//          (####   ((((((((((((((((((((/\n//         ####*  (((((((((((((((((((\n//                     ,**//*,.\n\n/// @title Rebalancing contract\n/// @notice Balances linked tOFT underlying token between the connected chains\n/// @dev transfers tokens to other layers through Stargate\ncontract Balancer is Owned {\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    /// @notice current OFT => chain => destination OFT\n    /// @dev chain ids (https://stargateprotocol.gitbook.io/stargate/developers/chain-ids):\n    ///         - Ethereum: 101\n    ///         - BNB: 102\n    ///         - Avalanche: 106\n    ///         - Polygon: 109\n    ///         - Arbitrum: 110\n    ///         - Optimism: 111\n    ///         - Fantom: 112\n    ///         - Metis: 151\n    ///     pool ids https://stargateprotocol.gitbook.io/stargate/developers/pool-ids\n    mapping(address => mapping(uint16 => OFTData)) public connectedOFTs;\n\n    struct OFTData {\n        uint256 srcPoolId;\n        uint256 dstPoolId;\n        address dstOft;\n        uint256 rebalanceable;\n    }\n\n    /// @notice StargetETH router address\n    IStargateRouter public immutable routerETH;\n    /// @notice Stargate router address\n    IStargateRouter public immutable router;\n\n    uint256 private constant SLIPPAGE_PRECISION = 1e5;\n\n    // ************************ //\n    // *** EVENTS FUNCTIONS *** //\n    // ************************ //\n    /// @notice event emitted when mTapiocaOFT is initialized\n    event ConnectedChainUpdated(\n        address indexed _srcOft,\n        uint16 _dstChainId,\n        address indexed _dstOft\n    );\n    /// @notice event emitted when a rebalance operation is performed\n    /// @dev rebalancing means sending an amount of the underlying token to one of the connected chains\n    event Rebalanced(\n        address indexed _srcOft,\n        uint16 _dstChainId,\n        uint256 _slippage,\n        uint256 _amount,\n        bool _isNative\n    );\n    /// @notice event emitted when max rebalanceable amount is updated\n    event RebalanceAmountUpdated(\n        address _srcOft,\n        uint16 _dstChainId,\n        uint256 _amount,\n        uint256 _totalAmount\n    );\n\n    // ************************ //\n    // *** ERRORS FUNCTIONS *** //\n    // ************************ //\n    /// @notice error thrown when IStargetRouter address is not valid\n    error RouterNotValid();\n    /// @notice error thrown when value exceeds balance\n    error ExceedsBalance();\n    /// @notice error thrown when chain destination is not valid\n    error DestinationNotValid();\n    /// @notice error thrown when dex slippage is not valid\n    error SlippageNotValid();\n    /// @notice error thrown when fee amount is not set\n    error FeeAmountNotSet();\n    error PoolInfoRequired();\n    error RebalanceAmountNotSet();\n    error DestinationOftNotValid();\n\n    // *************************** //\n    // *** MODIFIERS FUNCTIONS *** //\n    // *************************** //\n    modifier onlyValidDestination(address _srcOft, uint16 _dstChainId) {\n        if (connectedOFTs[_srcOft][_dstChainId].dstOft == address(0))\n            revert DestinationNotValid();\n        _;\n    }\n\n    modifier onlyValidSlippage(uint256 _slippage) {\n        if (_slippage >= 1e5) revert SlippageNotValid();\n        _;\n    }\n\n    constructor(\n        address _routerETH,\n        address _router,\n        address _owner\n    ) Owned(_owner) {\n        if (_router == address(0)) revert RouterNotValid();\n        if (_routerETH == address(0)) revert RouterNotValid();\n        routerETH = IStargateRouter(_routerETH);\n        router = IStargateRouter(_router);\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n\n    function checker(\n        address payable _srcOft,\n        uint16 _dstChainId\n    ) external view returns (bool canExec, bytes memory execPayload) {\n        bytes memory ercData;\n        if (ITapiocaOFT(_srcOft).erc20() == address(0)) {\n            ercData = abi.encode(\n                connectedOFTs[_srcOft][_dstChainId].srcPoolId,\n                connectedOFTs[_srcOft][_dstChainId].dstPoolId\n            );\n        }\n\n        canExec = connectedOFTs[_srcOft][_dstChainId].rebalanceable > 0;\n        execPayload = abi.encodeCall(\n            Balancer.rebalance,\n            (\n                _srcOft,\n                _dstChainId,\n                1e3, //1% slippage\n                connectedOFTs[_srcOft][_dstChainId].rebalanceable,\n                ercData\n            )\n        );\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice performs a rebalance operation\n    /// @dev callable only by the owner\n    /// @param _srcOft the source TOFT address\n    /// @param _dstChainId the destination LayerZero id\n    /// @param _slippage the destination LayerZero id\n    /// @param _amount the rebalanced amount\n    /// @param _ercData custom send data\n    function rebalance(\n        address payable _srcOft,\n        uint16 _dstChainId,\n        uint256 _slippage,\n        uint256 _amount,\n        bytes memory _ercData\n    )\n        external\n        payable\n        onlyOwner\n        onlyValidDestination(_srcOft, _dstChainId)\n        onlyValidSlippage(_slippage)\n    {\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable < _amount)\n            revert RebalanceAmountNotSet();\n\n        //check if OFT is still valid\n        if (\n            !_isValidOft(\n                _srcOft,\n                connectedOFTs[_srcOft][_dstChainId].dstOft,\n                _dstChainId\n            )\n        ) revert DestinationOftNotValid();\n\n        //extract\n        ITapiocaOFT(_srcOft).extractUnderlying(_amount);\n\n        //send\n        bool _isNative = ITapiocaOFT(_srcOft).erc20() == address(0);\n        if (_isNative) {\n            if (msg.value <= _amount) revert FeeAmountNotSet();\n            _sendNative(_srcOft, _amount, _dstChainId, _slippage);\n        } else {\n            if (msg.value == 0) revert FeeAmountNotSet();\n            _sendToken(_srcOft, _amount, _dstChainId, _slippage, _ercData);\n        }\n\n        connectedOFTs[_srcOft][_dstChainId].rebalanceable -= _amount;\n        emit Rebalanced(_srcOft, _dstChainId, _slippage, _amount, _isNative);\n    }\n\n    /// @notice registeres mTapiocaOFT for rebalancing\n    /// @param _srcOft the source TOFT address\n    /// @param _dstChainId the destination LayerZero id\n    /// @param _dstOft the destination TOFT address\n    /// @param _ercData custom send data\n    function initConnectedOFT(\n        address _srcOft,\n        uint16 _dstChainId,\n        address _dstOft,\n        bytes memory _ercData\n    ) external onlyOwner {\n        bool isNative = ITapiocaOFT(_srcOft).erc20() == address(0);\n        if (!isNative && _ercData.length == 0) revert PoolInfoRequired();\n        if (!_isValidOft(_srcOft, _dstOft, _dstChainId))\n            revert DestinationOftNotValid();\n\n        (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(\n            _ercData,\n            (uint256, uint256)\n        );\n\n        OFTData memory oftData = OFTData({\n            srcPoolId: _srcPoolId,\n            dstPoolId: _dstPoolId,\n            dstOft: _dstOft,\n            rebalanceable: 0\n        });\n\n        connectedOFTs[_srcOft][_dstChainId] = oftData;\n        emit ConnectedChainUpdated(_srcOft, _dstChainId, _dstOft);\n    }\n\n    /// @notice assings more rebalanceable amount for TOFT\n    /// @param _srcOft the source TOFT address\n    /// @param _dstChainId the destination LayerZero id\n    /// @param _amount the rebalanced amount\n    function addRebalanceAmount(\n        address _srcOft,\n        uint16 _dstChainId,\n        uint256 _amount\n    ) external onlyValidDestination(_srcOft, _dstChainId) onlyOwner {\n        connectedOFTs[_srcOft][_dstChainId].rebalanceable += _amount;\n        emit RebalanceAmountUpdated(\n            _srcOft,\n            _dstChainId,\n            _amount,\n            connectedOFTs[_srcOft][_dstChainId].rebalanceable\n        );\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _isValidOft(\n        address _srcOft,\n        address _dstOft,\n        uint16 _dstChainId\n    ) private view returns (bool) {\n        bytes memory trustedRemotePath = abi.encodePacked(_dstOft, _srcOft);\n        return\n            ITapiocaOFT(_srcOft).isTrustedRemote(\n                _dstChainId,\n                trustedRemotePath\n            );\n    }\n\n    function _sendNative(\n        address payable _oft,\n        uint256 _amount,\n        uint16 _dstChainId,\n        uint256 _slippage\n    ) private {\n        if (address(this).balance < _amount) revert ExceedsBalance();\n\n        routerETH.swapETH(\n            _dstChainId,\n            _oft, //refund\n            abi.encodePacked(connectedOFTs[_oft][_dstChainId].dstOft),\n            _amount,\n            _computeMinAmount(_amount, _slippage)\n        );\n    }\n\n    function _sendToken(\n        address payable _oft,\n        uint256 _amount,\n        uint16 _dstChainId,\n        uint256 _slippage,\n        bytes memory _data\n    ) private {\n        IERC20Metadata erc20 = IERC20Metadata(ITapiocaOFT(_oft).erc20());\n        if (erc20.balanceOf(address(this)) < _amount) revert ExceedsBalance();\n\n        (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(\n            _data,\n            (uint256, uint256)\n        );\n\n        IStargateRouter.lzTxObj memory _lzTxParams = IStargateRouterBase\n            .lzTxObj({\n                dstGasForCall: 0,\n                dstNativeAmount: msg.value,\n                dstNativeAddr: abi.encode(\n                    connectedOFTs[_oft][_dstChainId].dstOft\n                )\n            });\n\n        erc20.approve(address(router), _amount);\n        router.swap(\n            _dstChainId,\n            _srcPoolId,\n            _dstPoolId,\n            _oft, //refund,\n            _amount,\n            _computeMinAmount(_amount, _slippage),\n            _lzTxParams,\n            _lzTxParams.dstNativeAddr,\n            \"0x\"\n        );\n    }\n\n    function _computeMinAmount(\n        uint256 _amount,\n        uint256 _slippage\n    ) private pure returns (uint256) {\n        return _amount - ((_amount * _slippage) / SLIPPAGE_PRECISION);\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/Balancer.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"tapioca-periph/contracts/interfaces/ITapiocaOFT.sol\";\nimport \"tapioca-periph/contracts/interfaces/IStargateRouter.sol\";\nimport \"@rari-capital/solmate/src/auth/Owned.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n//\n//                 .(%%%%%%%%%%%%*       *\n//             #%%%%%%%%%%%%%%%%%%%%*  ####*\n//          #%%%%%%%%%%%%%%%%%%%%%#  /####\n//       ,%%%%%%%%%%%%%%%%%%%%%%%   ####.  %\n//                                #####\n//                              #####\n//   #####%#####              *####*  ####%#####*\n//  (#########(              #####     ##########.\n//  ##########             #####.      .##########\n//                       ,####/\n//                      #####\n//  %%%%%%%%%%        (####.           *%%%%%%%%%#\n//  .%%%%%%%%%%     *####(            .%%%%%%%%%%\n//   *%%%%%%%%%%   #####             #%%%%%%%%%%\n//               (####.\n//      ,((((  ,####(          /(((((((((((((\n//        *,  #####  ,(((((((((((((((((((((\n//          (####   ((((((((((((((((((((/\n//         ####*  (((((((((((((((((((\n//                     ,**//*,.\n\n/// @title Rebalancing contract\n/// @notice Balances linked tOFT underlying token between the connected chains\n/// @dev transfers tokens to other layers through Stargate\ncontract Balancer is Owned {\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    /// @notice current OFT => chain => destination OFT\n    /// @dev chain ids (https://stargateprotocol.gitbook.io/stargate/developers/chain-ids):\n    ///         - Ethereum: 101\n    ///         - BNB: 102\n    ///         - Avalanche: 106\n    ///         - Polygon: 109\n    ///         - Arbitrum: 110\n    ///         - Optimism: 111\n    ///         - Fantom: 112\n    ///         - Metis: 151\n    ///     pool ids https://stargateprotocol.gitbook.io/stargate/developers/pool-ids\n    mapping(address => mapping(uint16 => OFTData)) public connectedOFTs;\n\n    struct OFTData {\n        uint256 srcPoolId;\n        uint256 dstPoolId;\n        address dstOft;\n        uint256 rebalanceable;\n    }\n\n    /// @notice StargetETH router address\n    IStargateRouter public immutable routerETH;\n    /// @notice Stargate router address\n    IStargateRouter public immutable router;\n\n    uint256 private constant SLIPPAGE_PRECISION = 1e5;\n\n    // ************************ //\n    // *** EVENTS FUNCTIONS *** //\n    // ************************ //\n    /// @notice event emitted when mTapiocaOFT is initialized\n    event ConnectedChainUpdated(\n        address indexed _srcOft,\n        uint16 _dstChainId,\n        address indexed _dstOft\n    );\n    /// @notice event emitted when a rebalance operation is performed\n    /// @dev rebalancing means sending an amount of the underlying token to one of the connected chains\n    event Rebalanced(\n        address indexed _srcOft,\n        uint16 _dstChainId,\n        uint256 _slippage,\n        uint256 _amount,\n        bool _isNative\n    );\n    /// @notice event emitted when max rebalanceable amount is updated\n    event RebalanceAmountUpdated(\n        address _srcOft,\n        uint16 _dstChainId,\n        uint256 _amount,\n        uint256 _totalAmount\n    );\n\n    // ************************ //\n    // *** ERRORS FUNCTIONS *** //\n    // ************************ //\n    /// @notice error thrown when IStargetRouter address is not valid\n    error RouterNotValid();\n    /// @notice error thrown when value exceeds balance\n    error ExceedsBalance();\n    /// @notice error thrown when chain destination is not valid\n    error DestinationNotValid();\n    /// @notice error thrown when dex slippage is not valid\n    error SlippageNotValid();\n    /// @notice error thrown when fee amount is not set\n    error FeeAmountNotSet();\n    error PoolInfoRequired();\n    error RebalanceAmountNotSet();\n    error DestinationOftNotValid();\n\n    // *************************** //\n    // *** MODIFIERS FUNCTIONS *** //\n    // *************************** //\n    modifier onlyValidDestination(address _srcOft, uint16 _dstChainId) {\n        if (connectedOFTs[_srcOft][_dstChainId].dstOft == address(0))\n            revert DestinationNotValid();\n        _;\n    }\n\n    modifier onlyValidSlippage(uint256 _slippage) {\n        if (_slippage >= 1e5) revert SlippageNotValid();\n        _;\n    }\n\n    constructor(\n        address _routerETH,\n        address _router,\n        address _owner\n    ) Owned(_owner) {\n        if (_router == address(0)) revert RouterNotValid();\n        if (_routerETH == address(0)) revert RouterNotValid();\n        routerETH = IStargateRouter(_routerETH);\n        router = IStargateRouter(_router);\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n\n    function checker(\n        address payable _srcOft,\n        uint16 _dstChainId\n    ) external view returns (bool canExec, bytes memory execPayload) {\n        bytes memory ercData;\n        if (ITapiocaOFT(_srcOft).erc20() == address(0)) {\n            ercData = abi.encode(\n                connectedOFTs[_srcOft][_dstChainId].srcPoolId,\n                connectedOFTs[_srcOft][_dstChainId].dstPoolId\n            );\n        }\n\n        canExec = connectedOFTs[_srcOft][_dstChainId].rebalanceable > 0;\n        execPayload = abi.encodeCall(\n            Balancer.rebalance,\n            (\n                _srcOft,\n                _dstChainId,\n                1e3, //1% slippage\n                connectedOFTs[_srcOft][_dstChainId].rebalanceable,\n                ercData\n            )\n        );\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice performs a rebalance operation\n    /// @dev callable only by the owner\n    /// @param _srcOft the source TOFT address\n    /// @param _dstChainId the destination LayerZero id\n    /// @param _slippage the destination LayerZero id\n    /// @param _amount the rebalanced amount\n    /// @param _ercData custom send data\n    function rebalance(\n        address payable _srcOft,\n        uint16 _dstChainId,\n        uint256 _slippage,\n        uint256 _amount,\n        bytes memory _ercData\n    )\n        external\n        payable\n        onlyOwner\n        onlyValidDestination(_srcOft, _dstChainId)\n        onlyValidSlippage(_slippage)\n    {\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable < _amount)\n            revert RebalanceAmountNotSet();\n\n        //check if OFT is still valid\n        if (\n            !_isValidOft(\n                _srcOft,\n                connectedOFTs[_srcOft][_dstChainId].dstOft,\n                _dstChainId\n            )\n        ) revert DestinationOftNotValid();\n\n        //extract\n        ITapiocaOFT(_srcOft).extractUnderlying(_amount);\n\n        //send\n        bool _isNative = ITapiocaOFT(_srcOft).erc20() == address(0);\n        if (_isNative) {\n            if (msg.value <= _amount) revert FeeAmountNotSet();\n            _sendNative(_srcOft, _amount, _dstChainId, _slippage);\n        } else {\n            if (msg.value == 0) revert FeeAmountNotSet();\n            _sendToken(_srcOft, _amount, _dstChainId, _slippage, _ercData);\n        }\n\n        connectedOFTs[_srcOft][_dstChainId].rebalanceable -= _amount;\n        emit Rebalanced(_srcOft, _dstChainId, _slippage, _amount, _isNative);\n    }\n\n    /// @notice registeres mTapiocaOFT for rebalancing\n    /// @param _srcOft the source TOFT address\n    /// @param _dstChainId the destination LayerZero id\n    /// @param _dstOft the destination TOFT address\n    /// @param _ercData custom send data\n    function initConnectedOFT(\n        address _srcOft,\n        uint16 _dstChainId,\n        address _dstOft,\n        bytes memory _ercData\n    ) external onlyOwner {\n        bool isNative = ITapiocaOFT(_srcOft).erc20() == address(0);\n        if (!isNative && _ercData.length == 0) revert PoolInfoRequired();\n        if (!_isValidOft(_srcOft, _dstOft, _dstChainId))\n            revert DestinationOftNotValid();\n\n        (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(\n            _ercData,\n            (uint256, uint256)\n        );\n\n        OFTData memory oftData = OFTData({\n            srcPoolId: _srcPoolId,\n            dstPoolId: _dstPoolId,\n            dstOft: _dstOft,\n            rebalanceable: 0\n        });\n\n        connectedOFTs[_srcOft][_dstChainId] = oftData;\n        emit ConnectedChainUpdated(_srcOft, _dstChainId, _dstOft);\n    }\n\n    /// @notice assings more rebalanceable amount for TOFT\n    /// @param _srcOft the source TOFT address\n    /// @param _dstChainId the destination LayerZero id\n    /// @param _amount the rebalanced amount\n    function addRebalanceAmount(\n        address _srcOft,\n        uint16 _dstChainId,\n        uint256 _amount\n    ) external onlyValidDestination(_srcOft, _dstChainId) onlyOwner {\n        connectedOFTs[_srcOft][_dstChainId].rebalanceable += _amount;\n        emit RebalanceAmountUpdated(\n            _srcOft,\n            _dstChainId,\n            _amount,\n            connectedOFTs[_srcOft][_dstChainId].rebalanceable\n        );\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _isValidOft(\n        address _srcOft,\n        address _dstOft,\n        uint16 _dstChainId\n    ) private view returns (bool) {\n        bytes memory trustedRemotePath = abi.encodePacked(_dstOft, _srcOft);\n        return\n            ITapiocaOFT(_srcOft).isTrustedRemote(\n                _dstChainId,\n                trustedRemotePath\n            );\n    }\n\n    function _sendNative(\n        address payable _oft,\n        uint256 _amount,\n        uint16 _dstChainId,\n        uint256 _slippage\n    ) private {\n        if (address(this).balance < _amount) revert ExceedsBalance();\n\n        routerETH.swapETH(\n            _dstChainId,\n            _oft, //refund\n            abi.encodePacked(connectedOFTs[_oft][_dstChainId].dstOft),\n            _amount,\n            _computeMinAmount(_amount, _slippage)\n        );\n    }\n\n    function _sendToken(\n        address payable _oft,\n        uint256 _amount,\n        uint16 _dstChainId,\n        uint256 _slippage,\n        bytes memory _data\n    ) private {\n        IERC20Metadata erc20 = IERC20Metadata(ITapiocaOFT(_oft).erc20());\n        if (erc20.balanceOf(address(this)) < _amount) revert ExceedsBalance();\n\n        (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(\n            _data,\n            (uint256, uint256)\n        );\n\n        IStargateRouter.lzTxObj memory _lzTxParams = IStargateRouterBase\n            .lzTxObj({\n                dstGasForCall: 0,\n                dstNativeAmount: msg.value,\n                dstNativeAddr: abi.encode(\n                    connectedOFTs[_oft][_dstChainId].dstOft\n                )\n            });\n\n        erc20.approve(address(router), _amount);\n        router.swap(\n            _dstChainId,\n            _srcPoolId,\n            _dstPoolId,\n            _oft, //refund,\n            _amount,\n            _computeMinAmount(_amount, _slippage),\n            _lzTxParams,\n            _lzTxParams.dstNativeAddr,\n            \"0x\"\n        );\n    }\n\n    function _computeMinAmount(\n        uint256 _amount,\n        uint256 _slippage\n    ) private pure returns (uint256) {\n        return _amount - ((_amount * _slippage) / SLIPPAGE_PRECISION);\n    }\n\n    receive() external payable {}\n}"
    }
  ]
}