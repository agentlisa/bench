{
  "Title": "Sliced Bytes Are Cut Off",
  "Content": "In the `Bytes` library, the [`slice4`](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/store/src/Bytes.sol#L264) function intends to return a `bytes4` value from a `bytes32` value at a given index. While the output is correctly returned as a `bytes4` value, the actual output variable is declared as a `bytes2` value. This leads to only two correct bytes being returned from the index position followed by two zero bytes. The wrong data could escalate into more severe security issues depending on the context.\n\n\nConsider correcting the output variable type to `bytes4`.\n\n\n***Update:** Resolved in [pull request #2031](https://github.com/latticexyz/mud/pull/2031).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/store/src/Bytes.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n/**\n * @title Bytes\n * @notice Utility functions for bytes.\n */\nlibrary Bytes {\n  /**\n   * @dev Converts a `bytes` memory blob to a single `bytes32` memory value, starting at the given byte offset.\n   * @param input The `bytes` blob to read from.\n   * @param offset The byte offset at which to start reading.\n   * @return output The `bytes32` value.\n   */\n  function toBytes32(bytes memory input, uint256 offset) internal pure returns (bytes32 output) {\n    assembly {\n      // input is a pointer to the start of the bytes array\n      // in memory, the first 32 bytes are the length of the array\n      // so we add 32 to the pointer to get to the start of the data\n      // then we add the start offset to get to the start of the desired word\n      output := mload(add(input, add(0x20, offset)))\n    }\n  }\n\n  /************************************************************************\n   *\n   *    UTILS\n   *\n   ************************************************************************/\n\n  /**\n   * @dev Compares two bytes blobs for equality.\n   * @param a First bytes blob.\n   * @param b Second bytes blob.\n   * @return True if the two bytes blobs are equal, false otherwise.\n   */\n  function equals(bytes memory a, bytes memory b) internal pure returns (bool) {\n    if (a.length != b.length) {\n      return false;\n    }\n    return keccak256(a) == keccak256(b);\n  }\n\n  /**\n   * @dev Sets the length of a bytes blob in memory.\n   * This function does not resize the memory allocation; it only changes the length\n   * field, which affects operations that access the length property.\n   * @param input The bytes blob to modify.\n   * @param length The new length to set.\n   * @return Reference to the input bytes blob with modified length.\n   */\n  function setLength(bytes memory input, uint256 length) internal pure returns (bytes memory) {\n    assembly {\n      mstore(input, length)\n    }\n    return input;\n  }\n\n  /************************************************************************\n   *\n   *    SET\n   *\n   ************************************************************************/\n\n  /**\n   * @dev Sets a specific byte in a bytes32 value.\n   * @param input The bytes32 data in which a specific byte is to be altered.\n   * @param index The position of the byte to be altered. Index starts from the left.\n   * @param overwrite The new byte value to be set at the specified index.\n   * @return output The modified bytes32 data with the new byte value at the specified index.\n   */\n  function setBytes1(bytes32 input, uint256 index, bytes1 overwrite) internal pure returns (bytes32 output) {\n    bytes1 mask = 0xff;\n    assembly {\n      mask := shr(mul(8, index), mask) // create a mask by shifting 0xff right by index bytes\n      output := and(input, not(mask)) // zero out the byte at index\n      output := or(output, shr(mul(8, index), overwrite)) // set the byte at index\n    }\n    return output;\n  }\n\n  /**\n   * @dev Sets a specific 2-byte sequence in a bytes32 variable.\n   * @param input The bytes32 data in which a specific 2-byte sequence is to be altered.\n   * @param index The position of the 2-byte sequence to be altered. Index starts from the left.\n   * @param overwrite The new 2-byte value to be set at the specified index.\n   * @return output The modified bytes32 data with the new 2-byte value at the specified index.\n   */\n  function setBytes2(bytes32 input, uint256 index, bytes2 overwrite) internal pure returns (bytes32 output) {\n    bytes2 mask = 0xffff;\n    assembly {\n      mask := shr(mul(8, index), mask) // create a mask by shifting 0xffff right by index bytes\n      output := and(input, not(mask)) // zero out the byte at index\n      output := or(output, shr(mul(8, index), overwrite)) // set the byte at index\n    }\n    return output;\n  }\n\n  /**\n   * @dev Sets a specific 4-byte sequence in a bytes32 variable.\n   * @param input The bytes32 data in which a specific 4-byte sequence is to be altered.\n   * @param index The position of the 4-byte sequence to be altered. Index starts from the left.\n   * @param overwrite The new 4-byte value to be set at the specified index.\n   * @return output The modified bytes32 data with the new 4-byte value at the specified index.\n   */\n  function setBytes4(bytes32 input, uint256 index, bytes4 overwrite) internal pure returns (bytes32 output) {\n    bytes4 mask = 0xffffffff;\n    assembly {\n      mask := shr(mul(8, index), mask) // create a mask by shifting 0xffffffff right by index bytes\n      output := and(input, not(mask)) // zero out the byte at index\n      output := or(output, shr(mul(8, index), overwrite)) // set the byte at index\n    }\n    return output;\n  }\n\n  /**\n   * @dev Sets a specific 4-byte sequence in a bytes blob at a given index.\n   * @param input The bytes blob in which a specific 4-byte sequence is to be altered.\n   * @param index The position within the bytes blob to start altering the 4-byte sequence. Index starts from the left.\n   * @param overwrite The new 4-byte value to be set at the specified index.\n   * @return The modified bytes blob with the new 4-byte value at the specified index.\n   */\n  function setBytes4(bytes memory input, uint256 index, bytes4 overwrite) internal pure returns (bytes memory) {\n    bytes4 mask = 0xffffffff;\n    assembly {\n      let value := mload(add(add(input, 0x20), index)) // load 32 bytes from input starting at offset\n      value := and(value, not(mask)) // zero out the first 4 bytes\n      value := or(value, overwrite) // set the bytes at the offset\n      mstore(add(add(input, 0x20), index), value) // store the new value\n    }\n    return input;\n  }\n\n  /**\n   * @dev Sets a specific 5-byte sequence in a bytes32 variable.\n   * @param input The bytes32 data in which a specific 5-byte sequence is to be altered.\n   * @param index The position of the 5-byte sequence to be altered. Index starts from the left.\n   * @param overwrite The new 5-byte value to be set at the specified index.\n   * @return output The modified bytes32 data with the new 5-byte value at the specified index.\n   */\n  function setBytes5(bytes32 input, uint256 index, bytes5 overwrite) internal pure returns (bytes32 output) {\n    bytes5 mask = bytes5(type(uint40).max);\n    assembly {\n      mask := shr(mul(8, index), mask) // create a mask by shifting 0xff...ff right by index bytes\n      output := and(input, not(mask)) // zero out the byte at index\n      output := or(output, shr(mul(8, index), overwrite)) // set the byte at index\n    }\n    return output;\n  }\n\n  /**\n   * @dev Sets a specific 7-byte sequence in a bytes32 variable.\n   * @param input The bytes32 data in which a specific 7-byte sequence is to be altered.\n   * @param index The position of the 7-byte sequence to be altered. Index starts from the left.\n   * @param overwrite The new 7-byte value to be set at the specified index.\n   * @return output The modified bytes32 data with the new 7-byte value at the specified index.\n   */\n  function setBytes7(bytes32 input, uint256 index, bytes7 overwrite) internal pure returns (bytes32 output) {\n    bytes7 mask = bytes7(type(uint56).max);\n    assembly {\n      mask := shr(mul(8, index), mask) // create a mask by shifting 0xff...ff right by index bytes\n      output := and(input, not(mask)) // zero out the byte at index\n      output := or(output, shr(mul(8, index), overwrite)) // set the byte at index\n    }\n    return output;\n  }\n\n  /************************************************************************\n   *\n   *    SLICE\n   *\n   ************************************************************************/\n\n  /**\n   * @dev Extracts a single byte from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a byte is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes1 value from the specified position in the bytes blob.\n   */\n  function slice1(bytes memory data, uint256 start) internal pure returns (bytes1) {\n    bytes1 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a single byte from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a byte is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return The extracted bytes1 value from the specified position in the bytes32 value.\n   */\n  function slice1(bytes32 data, uint256 start) internal pure returns (bytes1) {\n    bytes1 output;\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 2-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 2-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes2 value from the specified position in the bytes blob.\n   */\n  function slice2(bytes memory data, uint256 start) internal pure returns (bytes2) {\n    bytes2 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 2-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 2-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return The extracted bytes2 value from the specified position in the bytes32 value.\n   */\n  function slice2(bytes32 data, uint256 start) internal pure returns (bytes2) {\n    bytes2 output;\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 3-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 3-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes3 value from the specified position in the bytes blob.\n   */\n  function slice3(bytes memory data, uint256 start) internal pure returns (bytes3) {\n    bytes3 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 4-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 4-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes4 value from the specified position in the bytes blob.\n   */\n  function slice4(bytes memory data, uint256 start) internal pure returns (bytes4) {\n    bytes4 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 4-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 4-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return The extracted bytes4 value from the specified position in the bytes32 value.\n   */\n  function slice4(bytes32 data, uint256 start) internal pure returns (bytes4) {\n    bytes2 output;\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 5-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 5-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes5 value from the specified position in the bytes blob.\n   */\n  function slice5(bytes memory data, uint256 start) internal pure returns (bytes5) {\n    bytes5 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 5-byte sequence from a bytes32 value starting at a specific position.\n   * @param data The bytes32 value from which a 5-byte sequence is to be extracted.\n   * @param start The starting position within the bytes32 value for extraction.\n   * @return The extracted bytes5 value from the specified position in the bytes32 value.\n   */\n  function slice5(bytes32 data, uint256 start) internal pure returns (bytes5) {\n    bytes5 output;\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 6-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 6-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes6 value from the specified position in the bytes blob.\n   */\n  function slice6(bytes memory data, uint256 start) internal pure returns (bytes6) {\n    bytes6 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 7-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 7-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes7 value from the specified position in the bytes blob.\n   */\n  function slice7(bytes memory data, uint256 start) internal pure returns (bytes7) {\n    bytes7 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 8-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 8-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes8 value from the specified position in the bytes blob.\n   */\n  function slice8(bytes memory data, uint256 start) internal pure returns (bytes8) {\n    bytes8 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 9-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 9-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes9 value from the specified position in the bytes blob.\n   */\n  function slice9(bytes memory data, uint256 start) internal pure returns (bytes9) {\n    bytes9 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 10-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 10-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes10 value from the specified position in the bytes blob.\n   */\n  function slice10(bytes memory data, uint256 start) internal pure returns (bytes10) {\n    bytes10 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 11-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 11-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes11 value from the specified position in the bytes blob.\n   */\n  function slice11(bytes memory data, uint256 start) internal pure returns (bytes11) {\n    bytes11 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 12-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 12-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes12 value from the specified position in the bytes blob.\n   */\n  function slice12(bytes memory data, uint256 start) internal pure returns (bytes12) {\n    bytes12 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 13-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 13-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes13 value from the specified position in the bytes blob.\n   */\n  function slice13(bytes memory data, uint256 start) internal pure returns (bytes13) {\n    bytes13 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 14-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 14-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes14 value from the specified position in the bytes blob.\n   */\n  function slice14(bytes memory data, uint256 start) internal pure returns (bytes14) {\n    bytes14 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 15-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 15-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes15 value from the specified position in the bytes blob.\n   */\n  function slice15(bytes memory data, uint256 start) internal pure returns (bytes15) {\n    bytes15 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 16-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 16-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes16 value from the specified position in the bytes blob.\n   */\n  function slice16(bytes memory data, uint256 start) internal pure returns (bytes16) {\n    bytes16 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 17-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 17-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes17 value from the specified position in the bytes blob.\n   */\n  function slice17(bytes memory data, uint256 start) internal pure returns (bytes17) {\n    bytes17 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 18-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 18-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes18 value from the specified position in the bytes blob.\n   */\n  function slice18(bytes memory data, uint256 start) internal pure returns (bytes18) {\n    bytes18 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 19-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 19-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes19 value from the specified position in the bytes blob.\n   */\n  function slice19(bytes memory data, uint256 start) internal pure returns (bytes19) {\n    bytes19 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 20-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 20-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes20 value from the specified position in the bytes blob.\n   */\n  function slice20(bytes memory data, uint256 start) internal pure returns (bytes20) {\n    bytes20 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 21-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 21-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes21 value from the specified position in the bytes blob.\n   */\n  function slice21(bytes memory data, uint256 start) internal pure returns (bytes21) {\n    bytes21 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 22-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 22-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes22 value from the specified position in the bytes blob.\n   */\n  function slice22(bytes memory data, uint256 start) internal pure returns (bytes22) {\n    bytes22 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 23-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 23-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes23 value from the specified position in the bytes blob.\n   */\n  function slice23(bytes memory data, uint256 start) internal pure returns (bytes23) {\n    bytes23 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 24-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 24-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes24 value from the specified position in the bytes blob.\n   */\n  function slice24(bytes memory data, uint256 start) internal pure returns (bytes24) {\n    bytes24 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 25-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 25-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes25 value from the specified position in the bytes blob.\n   */\n  function slice25(bytes memory data, uint256 start) internal pure returns (bytes25) {\n    bytes25 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 26-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 26-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes26 value from the specified position in the bytes blob.\n   */\n  function slice26(bytes memory data, uint256 start) internal pure returns (bytes26) {\n    bytes26 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 27-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 27-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes27 value from the specified position in the bytes blob.\n   */\n  function slice27(bytes memory data, uint256 start) internal pure returns (bytes27) {\n    bytes27 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 28-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 28-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes28 value from the specified position in the bytes blob.\n   */\n  function slice28(bytes memory data, uint256 start) internal pure returns (bytes28) {\n    bytes28 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 29-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 29-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes29 value from the specified position in the bytes blob.\n   */\n  function slice29(bytes memory data, uint256 start) internal pure returns (bytes29) {\n    bytes29 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 30-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 30-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes30 value from the specified position in the bytes blob.\n   */\n  function slice30(bytes memory data, uint256 start) internal pure returns (bytes30) {\n    bytes30 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 31-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 31-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes31 value from the specified position in the bytes blob.\n   */\n  function slice31(bytes memory data, uint256 start) internal pure returns (bytes31) {\n    bytes31 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /**\n   * @dev Extracts a 32-byte sequence from a bytes blob starting at a specific position.\n   * @param data The bytes blob from which a 32-byte sequence is to be extracted.\n   * @param start The starting position within the bytes blob for extraction.\n   * @return The extracted bytes32 value from the specified position in the bytes blob.\n   */\n  function slice32(bytes memory data, uint256 start) internal pure returns (bytes32) {\n    bytes32 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n}"
    }
  ]
}