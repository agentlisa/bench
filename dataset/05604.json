{
  "Title": "[H-05] Lenders can escape the blacklisting of their accounts because they can move their MarketTokens to different accounts and gain the `WithdrawOnly` Role on any account they want",
  "Content": "\nLenders can escape the sanctioning of their account in any market.\n\n### Proof of Concept\n\nBefore diving into the details of how the lenders can escape the sanctioning of their account, first, let's analyze how a lender can be excised from a Market:\n- When someone calls `nukeFromOrbit` within that market while flagged as sanctioned by the Chainanalysis oracle.\n- When the lender invokes `executeWithdrawal` while flagged as sanctioned by the Chainalysis oracle\n\nIn either of the two options, the execution flow calls the [`Sentinel::isSanctioned()` function](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/WildcatSanctionsSentinel.sol#L39-L43) to verify if the account(lender) is sanctioned by the borrower of the market\n- By analyzing the [`Sentinel::isSanctioned()` function](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/WildcatSanctionsSentinel.sol#L39-L43), it can be noted that the lender's account must have been sanctioned in the Oracle first before the account is finally sanction in a Market.\n\n**WildcatSanctionsSentinel.sol**\n\n```solidity\n  function isSanctioned(address borrower, address account) public view override returns (bool) {\n    //@audit-info => sanctionOverrides[borrower][account] must be false <==> sanction must not be overridden for this function to return true!\n    //@audit-info => If sanctionOverrides[borrower][account] is set to true, this function will return false, as if the account would not be sanctioned\n\n    //@audit-info => For this function to return true, the account's sanction should have not been overridden (it's set to false), and the account must have been sanctioned in the ChainalysisSanctionsList Oracle.\n    return\n      !sanctionOverrides[borrower][account] &&\n      IChainalysisSanctionsList(chainalysisSanctionsList).isSanctioned(account);\n  }\n```\n\nNow, based on the previous explanation, we know that the lender's account needs to be sanctioned in the Chainalysis Oracle before the [`Sentinel::isSanctioned()` function](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/WildcatSanctionsSentinel.sol#L39-L43) is called.\n\nThis opens up the doors for lenders who realize that their account has been sanctioned in the Chainalysis Oracle to move their MarketTokens to different accounts before the lender's account is fully blocked in the Market. You may be wondering what's the point of transferring tokens to accounts that have not been granted any role in the Market, I'll explain more about this shortly.\n\nThe lender transfers their MarketTokens to different accounts using the [`WildcatMarketToken::transfer()` function](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/market/WildcatMarketToken.sol#L36-L39). As a result, the lender's account that is sanctioned in the Chainalysis Oracle has no MarketTokens anymore; all those tokens have been moved to other accounts.\n\nNow, at this point, anybody could call the `nukeFromOrbit()` function to fully sanction the lender's account in a specific Market. Ether way, the Lender has already moved their tokens to other accounts.\n\nAt this point, the lender's MarketTokens were distributed among different accounts of their own. Such accounts have never interacted with the Market, so their current role is the `Null` Role.\n\nEverything might look fine because the accounts where the tokens were sent have no permissions to interact with the Market, but there is a bug that allows lenders to gain the `WithdrawOnly` Role on any account they want, without having the consent of the borrower.\n\nThis problem is located in the [`WildcatMarketController::updateLenderAuthorization()` function](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/WildcatMarketController.sol#L182-L190). The reason of this problem will be explained in the below code walkthrough:\n\nIn short, the Lender will be able to set the `WithdrawOnly` Role to any account they wish. The reason is that any account that is not registered in the `_authorizedLenders` variable of the Controller will forward the value of `_isAuthorized` as false. In the [`WildMarketConfig::updateAccountAuthorization()` function](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/market/WildcatMarketConfig.sol#L112-L126), because the value of `_isAuthorized` is false, it will end up granting the `WithdrawOnly` Role. This effectively allows any Lender to grant the `WithdrawOnly` Role to any account they want to.\n\n**WildcatMarketController.sol**\n\n```solidity\n  //@audit-info => Anybody can call this function and pass a lender and an array of markets where the changes will be applied!\n  function updateLenderAuthorization(address lender, address[] memory markets) external {\n    for (uint256 i; i < markets.length; i++) {\n      address market = markets[i];\n      if (!_controlledMarkets.contains(market)) {\n        revert NotControlledMarket();\n      }\n      //@audit-info => Forwards the value of the `lender` argument, and depending on the `lender` address is found in the _authorizedLenders EnumerableSet.AddressSet, will be forwarded a true or false accordingly\n        //@audit => If the lender address is not found in the _authorizedLenders variable, it will forward a false to the Market::updateAccountAuthorization() function\n      WildcatMarket(market).updateAccountAuthorization(lender, _authorizedLenders.contains(lender));\n    }\n  }\n```\n\n**EnumerableSet.sol**\n\n```solidity\nfunction contains(AddressSet storage set, address value) internal view returns (bool) {\n    //@audit-info => Calls the internal _contains()\n    //@audit-info => If the given value is found it will return true, otherwise it will return false!\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\n}\n\n//@audit-info => The internal function will just return a true or false if the given value is in the set or not, but the tx won't be reverted!\n/**\n* @dev Returns true if the value is in the set. O(1).\n*/\nfunction _contains(Set storage set, bytes32 value) private view returns (bool) {\n    return set._indexes[value] != 0;\n}\n```\n\n**WildcatMarketConfig.sol**\n\n```solidity\n  function updateAccountAuthorization(\n    address _account,\n    //@audit-info => For any account that is not registered in the `_authorizedLenders` of the Controller, this flag was set as false!\n    bool _isAuthorized\n  ) external onlyController nonReentrant {\n    MarketState memory state = _getUpdatedState();\n    //@audit-info => If the accountAddress is not registered in the storage, the approval role is set to Null\n    //@audit-info => If the account has been blacklisted, tx will revert!\n    Account memory account = _getAccount(_account);\n    if (_isAuthorized) {\n      account.approval = AuthRole.DepositAndWithdraw;\n    \n    //@audit => Any account not registered in the Controller will be assigned the WithdrawOnly role.\n    } else {\n      account.approval = AuthRole.WithdrawOnly;\n    }\n    _accounts[_account] = account;\n    _writeState(state);\n    emit AuthorizationStatusUpdated(_account, account.approval);\n  }\n```\n\nAt this point, the Lender has been able to move their MarketTokens to different accounts and to grant the `WithdrawOnly` Role to all of the accounts they wish to.\n\nNow, they can decide to exit the Market by queuing and executing some withdrawal requests from the different accounts where the MarketTokens were moved. Any of those accounts have now the `WithdrawOnly` Role and have a balance of MarketTokens, so the Lender will be able to exit the market from any of those accounts.\n\n### Recommended Mitigation Steps\n\nThe mitigation for this problem is very straight-forward, by limiting the access to which entities can call the [`WildcatMarketController::updateLenderAuthorization()` function](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/WildcatMarketController.sol#L182-L190); either only allow the Borrower to call it, or create a type of whitelist of valid actors who are capable of updating the lender's authorization on the Markets. In this way, the Lenders won't be capable of granting the `WithdrawOnly` Role to any account they want to; thus, they won't be able even to attempt to escape the sanctions.\n\n**WildcatMarketController.sol**\n\n```solidity\n- function updateLenderAuthorization(address lender, address[] memory markets) external {\n+ function updateLenderAuthorization(address lender, address[] memory markets) external onlyAuthorizedEntities(){\n    for (uint256 i; i < markets.length; i++) {\n      address market = markets[i];\n      if (!_controlledMarkets.contains(market)) {\n        revert NotControlledMarket();\n      }\n      WildcatMarket(market).updateAccountAuthorization(lender, _authorizedLenders.contains(lender));\n    }\n  }\n\nmodifier onlyAuthorizedEntities() {\n    require(msg.sender == <authorizedEntities>, \"you are not allowed sir\");\n    _;\n}\n```\n\n### Assessed type\n\nContext\n\n**[0xTheC0der (judge) increased severity to High](https://github.com/code-423n4/2023-10-wildcat-findings/issues/266#issuecomment-1798673899)**\n\n**[laurenceday (Wildcat) commented](https://github.com/code-423n4/2023-10-wildcat-findings/issues/266#issuecomment-1803367980):**\n > Mitigated [here](https://github.com/wildcat-finance/wildcat-protocol/pull/57/commits/2259d2a5f99c64d53d775e514ae0696bc2debb6c).\n\n**[laurenceday (Wildcat) confirmed](https://github.com/code-423n4/2023-10-wildcat-findings/issues/266#issuecomment-1810752119)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-10-wildcat",
  "Code": [
    {
      "filename": "src/WildcatSanctionsSentinel.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { IChainalysisSanctionsList } from './interfaces/IChainalysisSanctionsList.sol';\nimport { IWildcatArchController } from './interfaces/IWildcatArchController.sol';\nimport { IWildcatSanctionsSentinel } from './interfaces/IWildcatSanctionsSentinel.sol';\nimport { SanctionsList } from './libraries/Chainalysis.sol';\nimport { WildcatSanctionsEscrow } from './WildcatSanctionsEscrow.sol';\n\ncontract WildcatSanctionsSentinel is IWildcatSanctionsSentinel {\n  bytes32 public constant override WildcatSanctionsEscrowInitcodeHash =\n    keccak256(type(WildcatSanctionsEscrow).creationCode);\n\n  address public immutable override chainalysisSanctionsList;\n\n  address public immutable override archController;\n\n  TmpEscrowParams public override tmpEscrowParams;\n\n  mapping(address borrower => mapping(address account => bool sanctionOverride))\n    public\n    override sanctionOverrides;\n\n  constructor(address _archController, address _chainalysisSanctionsList) {\n    archController = _archController;\n    chainalysisSanctionsList = _chainalysisSanctionsList;\n    _resetTmpEscrowParams();\n  }\n\n  function _resetTmpEscrowParams() internal {\n    tmpEscrowParams = TmpEscrowParams(address(1), address(1), address(1));\n  }\n\n  /**\n   * @dev Returns boolean indicating whether `account` is sanctioned\n   *      on Chainalysis and that status has not been overridden by\n   *      `borrower`.\n   */\n  function isSanctioned(address borrower, address account) public view override returns (bool) {\n    return\n      !sanctionOverrides[borrower][account] &&\n      IChainalysisSanctionsList(chainalysisSanctionsList).isSanctioned(account);\n  }\n\n  /**\n   * @dev Overrides the sanction status of `account` for `borrower`.\n   */\n  function overrideSanction(address account) public override {\n    sanctionOverrides[msg.sender][account] = true;\n    emit SanctionOverride(msg.sender, account);\n  }\n\n  /**\n   * @dev Removes the sanction override of `account` for `borrower`.\n   */\n  function removeSanctionOverride(address account) public override {\n    sanctionOverrides[msg.sender][account] = false;\n    emit SanctionOverrideRemoved(msg.sender, account);\n  }\n\n  /**\n   * @dev Calculate the create2 escrow address for the combination\n   *      of `borrower`, `account`, and `asset`.\n   */\n  function getEscrowAddress(\n    address borrower,\n    address account,\n    address asset\n  ) public view override returns (address escrowAddress) {\n    return\n      address(\n        uint160(\n          uint256(\n            keccak256(\n              abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                keccak256(abi.encode(borrower, account, asset)),\n                WildcatSanctionsEscrowInitcodeHash\n              )\n            )\n          )\n        )\n      );\n  }\n\n  /**\n   * @dev Creates a new WildcatSanctionsEscrow contract for `borrower`,\n   *      `account`, and `asset` or returns the existing escrow contract\n   *      if one already exists.\n   *\n   *      The escrow contract is added to the set of sanction override\n   *      addresses for `borrower` so that it can not be blocked.\n   */\n  function createEscrow(\n    address borrower,\n    address account,\n    address asset\n  ) public override returns (address escrowContract) {\n    if (!IWildcatArchController(archController).isRegisteredMarket(msg.sender)) {\n      revert NotRegisteredMarket();\n    }\n\n    escrowContract = getEscrowAddress(borrower, account, asset);\n\n    if (escrowContract.codehash != bytes32(0)) return escrowContract;\n\n    tmpEscrowParams = TmpEscrowParams(borrower, account, asset);\n\n    new WildcatSanctionsEscrow{ salt: keccak256(abi.encode(borrower, account, asset)) }();\n\n    emit NewSanctionsEscrow(borrower, account, asset);\n\n    sanctionOverrides[borrower][escrowContract] = true;\n\n    emit SanctionOverride(borrower, escrowContract);\n\n    _resetTmpEscrowParams();\n  }\n}"
    },
    {
      "filename": "src/WildcatSanctionsSentinel.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { IChainalysisSanctionsList } from './interfaces/IChainalysisSanctionsList.sol';\nimport { IWildcatArchController } from './interfaces/IWildcatArchController.sol';\nimport { IWildcatSanctionsSentinel } from './interfaces/IWildcatSanctionsSentinel.sol';\nimport { SanctionsList } from './libraries/Chainalysis.sol';\nimport { WildcatSanctionsEscrow } from './WildcatSanctionsEscrow.sol';\n\ncontract WildcatSanctionsSentinel is IWildcatSanctionsSentinel {\n  bytes32 public constant override WildcatSanctionsEscrowInitcodeHash =\n    keccak256(type(WildcatSanctionsEscrow).creationCode);\n\n  address public immutable override chainalysisSanctionsList;\n\n  address public immutable override archController;\n\n  TmpEscrowParams public override tmpEscrowParams;\n\n  mapping(address borrower => mapping(address account => bool sanctionOverride))\n    public\n    override sanctionOverrides;\n\n  constructor(address _archController, address _chainalysisSanctionsList) {\n    archController = _archController;\n    chainalysisSanctionsList = _chainalysisSanctionsList;\n    _resetTmpEscrowParams();\n  }\n\n  function _resetTmpEscrowParams() internal {\n    tmpEscrowParams = TmpEscrowParams(address(1), address(1), address(1));\n  }\n\n  /**\n   * @dev Returns boolean indicating whether `account` is sanctioned\n   *      on Chainalysis and that status has not been overridden by\n   *      `borrower`.\n   */\n  function isSanctioned(address borrower, address account) public view override returns (bool) {\n    return\n      !sanctionOverrides[borrower][account] &&\n      IChainalysisSanctionsList(chainalysisSanctionsList).isSanctioned(account);\n  }\n\n  /**\n   * @dev Overrides the sanction status of `account` for `borrower`.\n   */\n  function overrideSanction(address account) public override {\n    sanctionOverrides[msg.sender][account] = true;\n    emit SanctionOverride(msg.sender, account);\n  }\n\n  /**\n   * @dev Removes the sanction override of `account` for `borrower`.\n   */\n  function removeSanctionOverride(address account) public override {\n    sanctionOverrides[msg.sender][account] = false;\n    emit SanctionOverrideRemoved(msg.sender, account);\n  }\n\n  /**\n   * @dev Calculate the create2 escrow address for the combination\n   *      of `borrower`, `account`, and `asset`.\n   */\n  function getEscrowAddress(\n    address borrower,\n    address account,\n    address asset\n  ) public view override returns (address escrowAddress) {\n    return\n      address(\n        uint160(\n          uint256(\n            keccak256(\n              abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                keccak256(abi.encode(borrower, account, asset)),\n                WildcatSanctionsEscrowInitcodeHash\n              )\n            )\n          )\n        )\n      );\n  }\n\n  /**\n   * @dev Creates a new WildcatSanctionsEscrow contract for `borrower`,\n   *      `account`, and `asset` or returns the existing escrow contract\n   *      if one already exists.\n   *\n   *      The escrow contract is added to the set of sanction override\n   *      addresses for `borrower` so that it can not be blocked.\n   */\n  function createEscrow(\n    address borrower,\n    address account,\n    address asset\n  ) public override returns (address escrowContract) {\n    if (!IWildcatArchController(archController).isRegisteredMarket(msg.sender)) {\n      revert NotRegisteredMarket();\n    }\n\n    escrowContract = getEscrowAddress(borrower, account, asset);\n\n    if (escrowContract.codehash != bytes32(0)) return escrowContract;\n\n    tmpEscrowParams = TmpEscrowParams(borrower, account, asset);\n\n    new WildcatSanctionsEscrow{ salt: keccak256(abi.encode(borrower, account, asset)) }();\n\n    emit NewSanctionsEscrow(borrower, account, asset);\n\n    sanctionOverrides[borrower][escrowContract] = true;\n\n    emit SanctionOverride(borrower, escrowContract);\n\n    _resetTmpEscrowParams();\n  }\n}"
    },
    {
      "filename": "src/WildcatSanctionsSentinel.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { IChainalysisSanctionsList } from './interfaces/IChainalysisSanctionsList.sol';\nimport { IWildcatArchController } from './interfaces/IWildcatArchController.sol';\nimport { IWildcatSanctionsSentinel } from './interfaces/IWildcatSanctionsSentinel.sol';\nimport { SanctionsList } from './libraries/Chainalysis.sol';\nimport { WildcatSanctionsEscrow } from './WildcatSanctionsEscrow.sol';\n\ncontract WildcatSanctionsSentinel is IWildcatSanctionsSentinel {\n  bytes32 public constant override WildcatSanctionsEscrowInitcodeHash =\n    keccak256(type(WildcatSanctionsEscrow).creationCode);\n\n  address public immutable override chainalysisSanctionsList;\n\n  address public immutable override archController;\n\n  TmpEscrowParams public override tmpEscrowParams;\n\n  mapping(address borrower => mapping(address account => bool sanctionOverride))\n    public\n    override sanctionOverrides;\n\n  constructor(address _archController, address _chainalysisSanctionsList) {\n    archController = _archController;\n    chainalysisSanctionsList = _chainalysisSanctionsList;\n    _resetTmpEscrowParams();\n  }\n\n  function _resetTmpEscrowParams() internal {\n    tmpEscrowParams = TmpEscrowParams(address(1), address(1), address(1));\n  }\n\n  /**\n   * @dev Returns boolean indicating whether `account` is sanctioned\n   *      on Chainalysis and that status has not been overridden by\n   *      `borrower`.\n   */\n  function isSanctioned(address borrower, address account) public view override returns (bool) {\n    return\n      !sanctionOverrides[borrower][account] &&\n      IChainalysisSanctionsList(chainalysisSanctionsList).isSanctioned(account);\n  }\n\n  /**\n   * @dev Overrides the sanction status of `account` for `borrower`.\n   */\n  function overrideSanction(address account) public override {\n    sanctionOverrides[msg.sender][account] = true;\n    emit SanctionOverride(msg.sender, account);\n  }\n\n  /**\n   * @dev Removes the sanction override of `account` for `borrower`.\n   */\n  function removeSanctionOverride(address account) public override {\n    sanctionOverrides[msg.sender][account] = false;\n    emit SanctionOverrideRemoved(msg.sender, account);\n  }\n\n  /**\n   * @dev Calculate the create2 escrow address for the combination\n   *      of `borrower`, `account`, and `asset`.\n   */\n  function getEscrowAddress(\n    address borrower,\n    address account,\n    address asset\n  ) public view override returns (address escrowAddress) {\n    return\n      address(\n        uint160(\n          uint256(\n            keccak256(\n              abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                keccak256(abi.encode(borrower, account, asset)),\n                WildcatSanctionsEscrowInitcodeHash\n              )\n            )\n          )\n        )\n      );\n  }\n\n  /**\n   * @dev Creates a new WildcatSanctionsEscrow contract for `borrower`,\n   *      `account`, and `asset` or returns the existing escrow contract\n   *      if one already exists.\n   *\n   *      The escrow contract is added to the set of sanction override\n   *      addresses for `borrower` so that it can not be blocked.\n   */\n  function createEscrow(\n    address borrower,\n    address account,\n    address asset\n  ) public override returns (address escrowContract) {\n    if (!IWildcatArchController(archController).isRegisteredMarket(msg.sender)) {\n      revert NotRegisteredMarket();\n    }\n\n    escrowContract = getEscrowAddress(borrower, account, asset);\n\n    if (escrowContract.codehash != bytes32(0)) return escrowContract;\n\n    tmpEscrowParams = TmpEscrowParams(borrower, account, asset);\n\n    new WildcatSanctionsEscrow{ salt: keccak256(abi.encode(borrower, account, asset)) }();\n\n    emit NewSanctionsEscrow(borrower, account, asset);\n\n    sanctionOverrides[borrower][escrowContract] = true;\n\n    emit SanctionOverride(borrower, escrowContract);\n\n    _resetTmpEscrowParams();\n  }\n}"
    },
    {
      "filename": "src/market/WildcatMarketToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport './WildcatMarketBase.sol';\n\ncontract WildcatMarketToken is WildcatMarketBase {\n  using SafeCastLib for uint256;\n\n  /* -------------------------------------------------------------------------- */\n  /*                                ERC20 Queries                               */\n  /* -------------------------------------------------------------------------- */\n\n  mapping(address => mapping(address => uint256)) public allowance;\n\n  /// @notice Returns the normalized balance of `account` with interest.\n  function balanceOf(address account) public view virtual nonReentrantView returns (uint256) {\n    (MarketState memory state, , ) = _calculateCurrentState();\n    return state.normalizeAmount(_accounts[account].scaledBalance);\n  }\n\n  /// @notice Returns the normalized total supply with interest.\n  function totalSupply() external view virtual nonReentrantView returns (uint256) {\n    (MarketState memory state, , ) = _calculateCurrentState();\n    return state.totalSupply();\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                                ERC20 Actions                               */\n  /* -------------------------------------------------------------------------- */\n\n  function approve(address spender, uint256 amount) external virtual nonReentrant returns (bool) {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  function transfer(address to, uint256 amount) external virtual nonReentrant returns (bool) {\n    _transfer(msg.sender, to, amount);\n    return true;\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external virtual nonReentrant returns (bool) {\n    uint256 allowed = allowance[from][msg.sender];\n\n    // Saves gas for unlimited approvals.\n    if (allowed != type(uint256).max) {\n      uint256 newAllowance = allowed - amount;\n      _approve(from, msg.sender, newAllowance);\n    }\n\n    _transfer(from, to, amount);\n\n    return true;\n  }\n\n  function _approve(address approver, address spender, uint256 amount) internal virtual {\n    allowance[approver][spender] = amount;\n    emit Approval(approver, spender, amount);\n  }\n\n  function _transfer(address from, address to, uint256 amount) internal virtual {\n    MarketState memory state = _getUpdatedState();\n    uint104 scaledAmount = state.scaleAmount(amount).toUint104();\n\n    if (scaledAmount == 0) {\n      revert NullTransferAmount();\n    }\n\n    Account memory fromAccount = _getAccount(from);\n    fromAccount.scaledBalance -= scaledAmount;\n    _accounts[from] = fromAccount;\n\n    Account memory toAccount = _getAccount(to);\n    toAccount.scaledBalance += scaledAmount;\n    _accounts[to] = toAccount;\n\n    _writeState(state);\n    emit Transfer(from, to, amount);\n  }\n}"
    },
    {
      "filename": "src/WildcatMarketController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { EnumerableSet } from 'openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport 'solady/utils/SafeTransferLib.sol';\nimport './market/WildcatMarket.sol';\nimport './interfaces/IWildcatArchController.sol';\nimport './interfaces/IWildcatMarketControllerEventsAndErrors.sol';\nimport './interfaces/IWildcatMarketControllerFactory.sol';\nimport './libraries/LibStoredInitCode.sol';\nimport './libraries/MathUtils.sol';\n\nstruct TemporaryReserveRatio {\n  uint128 reserveRatioBips;\n  uint128 expiry;\n}\n\nstruct TmpMarketParameterStorage {\n  address asset;\n  string namePrefix;\n  string symbolPrefix;\n  address feeRecipient;\n  uint16 protocolFeeBips;\n  uint128 maxTotalSupply;\n  uint16 annualInterestBips;\n  uint16 delinquencyFeeBips;\n  uint32 withdrawalBatchDuration;\n  uint16 reserveRatioBips;\n  uint32 delinquencyGracePeriod;\n}\n\ncontract WildcatMarketController is IWildcatMarketControllerEventsAndErrors {\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using SafeCastLib for uint256;\n  using SafeTransferLib for address;\n\n  /* -------------------------------------------------------------------------- */\n  /*                                 Immutables                                 */\n  /* -------------------------------------------------------------------------- */\n\n  IWildcatArchController public immutable archController;\n\n  IWildcatMarketControllerFactory public immutable controllerFactory;\n\n  address public immutable borrower;\n\n  address public immutable sentinel;\n\n  address public immutable marketInitCodeStorage;\n\n  uint256 public immutable marketInitCodeHash;\n\n  uint256 internal immutable ownCreate2Prefix = LibStoredInitCode.getCreate2Prefix(address(this));\n\n  uint32 internal immutable MinimumDelinquencyGracePeriod;\n  uint32 internal immutable MaximumDelinquencyGracePeriod;\n\n  uint16 internal immutable MinimumReserveRatioBips;\n  uint16 internal immutable MaximumReserveRatioBips;\n\n  uint16 internal immutable MinimumDelinquencyFeeBips;\n  uint16 internal immutable MaximumDelinquencyFeeBips;\n\n  uint32 internal immutable MinimumWithdrawalBatchDuration;\n  uint32 internal immutable MaximumWithdrawalBatchDuration;\n\n  uint16 internal immutable MinimumAnnualInterestBips;\n  uint16 internal immutable MaximumAnnualInterestBips;\n\n  EnumerableSet.AddressSet internal _authorizedLenders;\n  EnumerableSet.AddressSet internal _controlledMarkets;\n\n  /// @dev Temporary storage for market parameters, used during market deployment\n  TmpMarketParameterStorage internal _tmpMarketParameters;\n\n  mapping(address => TemporaryReserveRatio) public temporaryExcessReserveRatio;\n\n  // MarketParameterConstraints internal immutable constraints\n\n  modifier onlyBorrower() {\n    if (msg.sender != borrower) {\n      revert CallerNotBorrower();\n    }\n    _;\n  }\n\n  modifier onlyControlledMarket(address market) {\n    if (!_controlledMarkets.contains(market)) {\n      revert NotControlledMarket();\n    }\n    _;\n  }\n\n  constructor() {\n    controllerFactory = IWildcatMarketControllerFactory(msg.sender);\n    MarketControllerParameters memory parameters = controllerFactory.getMarketControllerParameters();\n    archController = IWildcatArchController(parameters.archController);\n    borrower = parameters.borrower;\n    sentinel = parameters.sentinel;\n    marketInitCodeStorage = parameters.marketInitCodeStorage;\n    marketInitCodeHash = parameters.marketInitCodeHash;\n    MinimumDelinquencyGracePeriod = parameters.minimumDelinquencyGracePeriod;\n    MaximumDelinquencyGracePeriod = parameters.maximumDelinquencyGracePeriod;\n    MinimumReserveRatioBips = parameters.minimumReserveRatioBips;\n    MaximumReserveRatioBips = parameters.maximumReserveRatioBips;\n    MinimumDelinquencyFeeBips = parameters.minimumDelinquencyFeeBips;\n    MaximumDelinquencyFeeBips = parameters.maximumDelinquencyFeeBips;\n    MinimumWithdrawalBatchDuration = parameters.minimumWithdrawalBatchDuration;\n    MaximumWithdrawalBatchDuration = parameters.maximumWithdrawalBatchDuration;\n    MinimumAnnualInterestBips = parameters.minimumAnnualInterestBips;\n    MaximumAnnualInterestBips = parameters.maximumAnnualInterestBips;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                               Lender Registry                              */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Returns the set of authorized lenders.\n   */\n  function getAuthorizedLenders() external view returns (address[] memory) {\n    return _authorizedLenders.values();\n  }\n\n  function getAuthorizedLenders(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _authorizedLenders.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _authorizedLenders.at(start + i);\n    }\n  }\n\n  function getAuthorizedLendersCount() external view returns (uint256) {\n    return _authorizedLenders.length();\n  }\n\n  function isAuthorizedLender(address lender) external view virtual returns (bool) {\n    return _authorizedLenders.contains(lender);\n  }\n\n  /**\n   * @dev Grant authorization for a set of lenders.\n   *\n   *      Note: Only updates the internal set of approved lenders.\n   *      Must call `updateLenderAuthorization` to apply changes\n   *      to existing market accounts\n   */\n  function authorizeLenders(address[] memory lenders) external onlyBorrower {\n    for (uint256 i = 0; i < lenders.length; i++) {\n      address lender = lenders[i];\n      if (_authorizedLenders.add(lender)) {\n        emit LenderAuthorized(lender);\n      }\n    }\n  }\n\n  /**\n   * @dev Revoke authorization for a set of lenders.\n   *\n   *      Note: Only updates the internal set of approved lenders.\n   *      Must call `updateLenderAuthorization` to apply changes\n   *      to existing market accounts\n   */\n  function deauthorizeLenders(address[] memory lenders) external onlyBorrower {\n    for (uint256 i = 0; i < lenders.length; i++) {\n      address lender = lenders[i];\n      if (_authorizedLenders.remove(lender)) {\n        emit LenderDeauthorized(lender);\n      }\n    }\n  }\n\n  /**\n   * @dev Update lender authorization for a set of markets to the current\n   *      status.\n   */\n  function updateLenderAuthorization(address lender, address[] memory markets) external {\n    for (uint256 i; i < markets.length; i++) {\n      address market = markets[i];\n      if (!_controlledMarkets.contains(market)) {\n        revert NotControlledMarket();\n      }\n      WildcatMarket(market).updateAccountAuthorization(lender, _authorizedLenders.contains(lender));\n    }\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                                Market Queries                               */\n  /* -------------------------------------------------------------------------- */\n\n  function isControlledMarket(address market) external view returns (bool) {\n    return _controlledMarkets.contains(market);\n  }\n\n  function getControlledMarkets() external view returns (address[] memory) {\n    return _controlledMarkets.values();\n  }\n\n  function getControlledMarkets(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _controlledMarkets.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _controlledMarkets.at(start + i);\n    }\n  }\n\n  function getControlledMarketsCount() external view returns (uint256) {\n    return _controlledMarkets.length();\n  }\n\n  function computeMarketAddress(\n    address asset,\n    string memory namePrefix,\n    string memory symbolPrefix\n  ) external view returns (address) {\n    bytes32 salt = _deriveSalt(asset, namePrefix, symbolPrefix);\n    return LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix, salt, marketInitCodeHash);\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                              Market Deployment                              */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Get the temporarily stored market parameters for a market that is\n   *      currently being deployed.\n   */\n  function getMarketParameters() external view returns (MarketParameters memory parameters) {\n    parameters.asset = _tmpMarketParameters.asset;\n    parameters.namePrefix = _tmpMarketParameters.namePrefix;\n    parameters.symbolPrefix = _tmpMarketParameters.symbolPrefix;\n    parameters.borrower = borrower;\n    parameters.controller = address(this);\n    parameters.feeRecipient = _tmpMarketParameters.feeRecipient;\n    parameters.sentinel = sentinel;\n    parameters.maxTotalSupply = _tmpMarketParameters.maxTotalSupply;\n    parameters.protocolFeeBips = _tmpMarketParameters.protocolFeeBips;\n    parameters.annualInterestBips = _tmpMarketParameters.annualInterestBips;\n    parameters.delinquencyFeeBips = _tmpMarketParameters.delinquencyFeeBips;\n    parameters.withdrawalBatchDuration = _tmpMarketParameters.withdrawalBatchDuration;\n    parameters.reserveRatioBips = _tmpMarketParameters.reserveRatioBips;\n    parameters.delinquencyGracePeriod = _tmpMarketParameters.delinquencyGracePeriod;\n  }\n\n  function _resetTmpMarketParameters() internal {\n    _tmpMarketParameters.asset = address(1);\n    _tmpMarketParameters.namePrefix = '_';\n    _tmpMarketParameters.symbolPrefix = '_';\n    _tmpMarketParameters.feeRecipient = address(1);\n    _tmpMarketParameters.protocolFeeBips = 1;\n    _tmpMarketParameters.maxTotalSupply = 1;\n    _tmpMarketParameters.annualInterestBips = 1;\n    _tmpMarketParameters.delinquencyFeeBips = 1;\n    _tmpMarketParameters.withdrawalBatchDuration = 1;\n    _tmpMarketParameters.reserveRatioBips = 1;\n    _tmpMarketParameters.delinquencyGracePeriod = 1;\n  }\n\n  /**\n   * @dev Deploys a create2 deployment of `WildcatMarket` unique to the\n   *      combination of `asset, namePrefix, symbolPrefix` and registers\n   *      it with the arch-controller.\n   *\n   *      If a market has already been deployed with these parameters,\n   *      reverts with `MarketAlreadyDeployed`.\n   *\n   *      If `msg.sender` is not `borrower` or `controllerFactory`,\n   *      reverts with `CallerNotBorrowerOrControllerFactory`.\n   *\n   *\t    If `msg.sender == borrower && !archController.isRegisteredBorrower(msg.sender)`,\n   *\t\t  reverts with `NotRegisteredBorrower`.\n   *\n   *      If called by `controllerFactory`, skips borrower check.\n   *\n   *      If either string is empty, reverts with `EmptyString`.\n   *\n   *      If `originationFeeAmount` returned by controller factory is not zero,\n   *      transfers `originationFeeAmount` of `originationFeeAsset` from\n   *      `msg.sender` to `feeRecipient`.\n   */\n  function deployMarket(\n    address asset,\n    string memory namePrefix,\n    string memory symbolPrefix,\n    uint128 maxTotalSupply,\n    uint16 annualInterestBips,\n    uint16 delinquencyFeeBips,\n    uint32 withdrawalBatchDuration,\n    uint16 reserveRatioBips,\n    uint32 delinquencyGracePeriod\n  ) external returns (address market) {\n    if (msg.sender == borrower) {\n      if (!archController.isRegisteredBorrower(msg.sender)) {\n        revert NotRegisteredBorrower();\n      }\n    } else if (msg.sender != address(controllerFactory)) {\n      revert CallerNotBorrowerOrControllerFactory();\n    }\n\n    enforceParameterConstraints(\n      namePrefix,\n      symbolPrefix,\n      annualInterestBips,\n      delinquencyFeeBips,\n      withdrawalBatchDuration,\n      reserveRatioBips,\n      delinquencyGracePeriod\n    );\n\n    TmpMarketParameterStorage memory parameters = TmpMarketParameterStorage({\n      asset: asset,\n      namePrefix: namePrefix,\n      symbolPrefix: symbolPrefix,\n      feeRecipient: address(0),\n      maxTotalSupply: maxTotalSupply,\n      protocolFeeBips: 0,\n      annualInterestBips: annualInterestBips,\n      delinquencyFeeBips: delinquencyFeeBips,\n      withdrawalBatchDuration: withdrawalBatchDuration,\n      reserveRatioBips: reserveRatioBips,\n      delinquencyGracePeriod: delinquencyGracePeriod\n    });\n\n    address originationFeeAsset;\n    uint80 originationFeeAmount;\n    (\n      parameters.feeRecipient,\n      originationFeeAsset,\n      originationFeeAmount,\n      parameters.protocolFeeBips\n    ) = controllerFactory.getProtocolFeeConfiguration();\n\n    _tmpMarketParameters = parameters;\n\n    if (originationFeeAsset != address(0)) {\n      originationFeeAsset.safeTransferFrom(borrower, parameters.feeRecipient, originationFeeAmount);\n    }\n\n    bytes32 salt = _deriveSalt(asset, namePrefix, symbolPrefix);\n    market = LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix, salt, marketInitCodeHash);\n    if (market.codehash != bytes32(0)) {\n      revert MarketAlreadyDeployed();\n    }\n    LibStoredInitCode.create2WithStoredInitCode(marketInitCodeStorage, salt);\n\n    archController.registerMarket(market);\n    _controlledMarkets.add(market);\n\n    _resetTmpMarketParameters();\n  }\n\n  /**\n   * @dev Derive create2 salt for a market given the asset address,\n   *      name prefix and symbol prefix.\n   *\n   *      The salt is unique to each market deployment in the controller,\n   *      so only one market can be deployed for each combination of `asset`,\n   *      `namePrefix` and `symbolPrefix`\n   */\n  function _deriveSalt(\n    address asset,\n    string memory namePrefix,\n    string memory symbolPrefix\n  ) internal pure returns (bytes32 salt) {\n    assembly {\n      // Cache free memory pointer\n      let freeMemoryPointer := mload(0x40)\n      // `keccak256(abi.encode(asset, keccak256(namePrefix), keccak256(symbolPrefix)))`\n      mstore(0x00, asset)\n      mstore(0x20, keccak256(add(namePrefix, 32), mload(namePrefix)))\n      mstore(0x40, keccak256(add(symbolPrefix, 32), mload(symbolPrefix)))\n      salt := keccak256(0, 0x60)\n      // Restore free memory pointer\n      mstore(0x40, freeMemoryPointer)\n    }\n  }\n\n  /**\n   * @dev Enforce constraints on market parameters, ensuring that\n   *      `annualInterestBips`, `delinquencyFeeBips`, `withdrawalBatchDuration`,\n   *      `reserveRatioBips` and `delinquencyGracePeriod` are within the\n   *      allowed ranges and that `namePrefix` and `symbolPrefix` are not null.\n   */\n  function enforceParameterConstraints(\n    string memory namePrefix,\n    string memory symbolPrefix,\n    uint16 annualInterestBips,\n    uint16 delinquencyFeeBips,\n    uint32 withdrawalBatchDuration,\n    uint16 reserveRatioBips,\n    uint32 delinquencyGracePeriod\n  ) internal view virtual {\n    assembly {\n      if or(iszero(mload(namePrefix)), iszero(mload(symbolPrefix))) {\n        // revert EmptyString();\n        mstore(0x00, 0xecd7b0d1)\n        revert(0x1c, 0x04)\n      }\n    }\n    assertValueInRange(\n      annualInterestBips,\n      MinimumAnnualInterestBips,\n      MaximumAnnualInterestBips,\n      AnnualInterestBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      delinquencyFeeBips,\n      MinimumDelinquencyFeeBips,\n      MaximumDelinquencyFeeBips,\n      DelinquencyFeeBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      withdrawalBatchDuration,\n      MinimumWithdrawalBatchDuration,\n      MaximumWithdrawalBatchDuration,\n      WithdrawalBatchDurationOutOfBounds.selector\n    );\n    assertValueInRange(\n      reserveRatioBips,\n      MinimumReserveRatioBips,\n      MaximumReserveRatioBips,\n      ReserveRatioBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      delinquencyGracePeriod,\n      MinimumDelinquencyGracePeriod,\n      MaximumDelinquencyGracePeriod,\n      DelinquencyGracePeriodOutOfBounds.selector\n    );\n  }\n\n  /**\n   * @dev Returns immutable constraints on market parameters that\n   *      the controller variant will enforce.\n   */\n  function getParameterConstraints()\n    external\n    view\n    returns (MarketParameterConstraints memory constraints)\n  {\n    constraints.minimumDelinquencyGracePeriod = MinimumDelinquencyGracePeriod;\n    constraints.maximumDelinquencyGracePeriod = MaximumDelinquencyGracePeriod;\n    constraints.minimumReserveRatioBips = MinimumReserveRatioBips;\n    constraints.maximumReserveRatioBips = MaximumReserveRatioBips;\n    constraints.minimumDelinquencyFeeBips = MinimumDelinquencyFeeBips;\n    constraints.maximumDelinquencyFeeBips = MaximumDelinquencyFeeBips;\n    constraints.minimumWithdrawalBatchDuration = MinimumWithdrawalBatchDuration;\n    constraints.maximumWithdrawalBatchDuration = MaximumWithdrawalBatchDuration;\n    constraints.minimumAnnualInterestBips = MinimumAnnualInterestBips;\n    constraints.maximumAnnualInterestBips = MaximumAnnualInterestBips;\n  }\n\n  /**\n   * @dev Modify the interest rate for a market.\n   * If the new interest rate is lower than the current interest rate,\n   * the reserve ratio is set to 90% for the next two weeks.\n   */\n  function setAnnualInterestBips(\n    address market,\n    uint16 annualInterestBips\n  ) external virtual onlyBorrower onlyControlledMarket(market) {\n    // If borrower is reducing the interest rate, increase the reserve\n    // ratio for the next two weeks.\n    if (annualInterestBips < WildcatMarket(market).annualInterestBips()) {\n      TemporaryReserveRatio storage tmp = temporaryExcessReserveRatio[market];\n\n      if (tmp.expiry == 0) {\n        tmp.reserveRatioBips = uint128(WildcatMarket(market).reserveRatioBips());\n\n        // Require 90% liquidity coverage for the next 2 weeks\n        WildcatMarket(market).setReserveRatioBips(9000);\n      }\n\n      tmp.expiry = uint128(block.timestamp + 2 weeks);\n    }\n\n    WildcatMarket(market).setAnnualInterestBips(annualInterestBips);\n  }\n\n  function resetReserveRatio(address market) external virtual {\n    TemporaryReserveRatio memory tmp = temporaryExcessReserveRatio[market];\n    if (tmp.expiry == 0) {\n      revertWithSelector(AprChangeNotPending.selector);\n    }\n    if (block.tim"
    }
  ]
}