{
  "Title": "[G-04]  Optimize names to save gas",
  "Content": "\n`public`/`external` function names and `public` member variable names can be optimized to save gas. See [this](https://gist.github.com/IllIllI000/a5d8b486a8259f9f77891a919febd1a9) link for an example of how it works. Below are the interfaces/abstract contracts that can be optimized so that the most frequently-called functions use the least amount of gas possible during method lookup. Method IDs that have two leading zero bytes can save **128 gas** each during deployment, and renaming functions to have lower method IDs will save **22 gas** per call, [per sorted position shifted](https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92)\n\n*There are 8 instances of this issue:*\n```solidity\nFile: contracts/ERC20EnabledLooksRareAggregator.sol\n\n/// @audit execute()\n15:   contract ERC20EnabledLooksRareAggregator is IERC20EnabledLooksRareAggregator, LowLevelERC20Transfer {\n\n```\nhttps://github.com/code-423n4/2022-11-looksrare/blob/e3b2c053f722b0ca2dce3a3eb06f64859b8b7a6f/contracts/ERC20EnabledLooksRareAggregator.sol#L15\n\n```solidity\nFile: contracts/interfaces/IERC20EnabledLooksRareAggregator.sol\n\n/// @audit execute()\n7:    interface IERC20EnabledLooksRareAggregator {\n\n```\nhttps://github.com/code-423n4/2022-11-looksrare/blob/e3b2c053f722b0ca2dce3a3eb06f64859b8b7a6f/contracts/interfaces/IERC20EnabledLooksRareAggregator.sol#L7\n\n```solidity\nFile: contracts/interfaces/ILooksRareAggregator.sol\n\n/// @audit execute()\n6:    interface ILooksRareAggregator {\n\n```\nhttps://github.com/code-423n4/2022-11-looksrare/blob/e3b2c053f722b0ca2dce3a3eb06f64859b8b7a6f/contracts/interfaces/ILooksRareAggregator.sol#L6\n\n```solidity\nFile: contracts/interfaces/IProxy.sol\n\n/// @audit execute()\n6:    interface IProxy {\n\n```\nhttps://github.com/code-423n4/2022-11-looksrare/blob/e3b2c053f722b0ca2dce3a3eb06f64859b8b7a6f/contracts/interfaces/IProxy.sol#L6\n\n```solidity\nFile: contracts/interfaces/SeaportInterface.sol\n\n/// @audit fulfillBasicOrder(), fulfillOrder(), fulfillAdvancedOrder(), fulfillAvailableOrders(), fulfillAvailableAdvancedOrders(), matchOrders(), matchAdvancedOrders(), cancel(), validate(), incrementCounter(), getOrderHash(), getOrderStatus(), getCounter(), information()\n28:   interface SeaportInterface {\n\n```\nhttps://github.com/code-423n4/2022-11-looksrare/blob/e3b2c053f722b0ca2dce3a3eb06f64859b8b7a6f/contracts/interfaces/SeaportInterface.sol#L28\n\n```solidity\nFile: contracts/LooksRareAggregator.sol\n\n/// @audit execute(), setERC20EnabledLooksRareAggregator(), addFunction(), removeFunction(), setFee(), approve(), supportsProxyFunction(), rescueERC721(), rescueERC1155()\n25:   contract LooksRareAggregator is\n\n```\nhttps://github.com/code-423n4/2022-11-looksrare/blob/e3b2c053f722b0ca2dce3a3eb06f64859b8b7a6f/contracts/LooksRareAggregator.sol#L25\n\n```solidity\nFile: contracts/OwnableTwoSteps.sol\n\n/// @audit cancelOwnershipTransfer(), confirmOwnershipRenouncement(), confirmOwnershipTransfer(), initiateOwnershipTransfer(), initiateOwnershipRenouncement()\n11:   abstract contract OwnableTwoSteps is IOwnableTwoSteps {\n\n```\nhttps://github.com/code-423n4/2022-11-looksrare/blob/e3b2c053f722b0ca2dce3a3eb06f64859b8b7a6f/contracts/OwnableTwoSteps.sol#L11\n\n```solidity\nFile: contracts/TokenRescuer.sol\n\n/// @audit rescueETH(), rescueERC20()\n14:   contract TokenRescuer is OwnableTwoSteps, LowLevelETH, LowLevelERC20Transfer {\n\n```\nhttps://github.com/code-423n4/2022-11-looksrare/blob/e3b2c053f722b0ca2dce3a3eb06f64859b8b7a6f/contracts/TokenRescuer.sol#L14\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-11-looksrare",
  "Code": [
    {
      "filename": "contracts/ERC20EnabledLooksRareAggregator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {LowLevelERC20Transfer} from \"./lowLevelCallers/LowLevelERC20Transfer.sol\";\nimport {IERC20EnabledLooksRareAggregator} from \"./interfaces/IERC20EnabledLooksRareAggregator.sol\";\nimport {ILooksRareAggregator} from \"./interfaces/ILooksRareAggregator.sol\";\nimport {TokenTransfer} from \"./libraries/OrderStructs.sol\";\n\n/**\n * @title ERC20EnabledLooksRareAggregator\n * @notice This contract allows NFT sweepers to buy NFTs from different marketplaces using ERC20 tokens\n *         by passing high-level structs + low-level bytes as calldata.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract ERC20EnabledLooksRareAggregator is IERC20EnabledLooksRareAggregator, LowLevelERC20Transfer {\n    ILooksRareAggregator public immutable aggregator;\n\n    /**\n     * @param _aggregator LooksRareAggregator's address\n     */\n    constructor(address _aggregator) {\n        aggregator = ILooksRareAggregator(_aggregator);\n    }\n\n    /**\n     * @inheritdoc IERC20EnabledLooksRareAggregator\n     */\n    function execute(\n        TokenTransfer[] calldata tokenTransfers,\n        ILooksRareAggregator.TradeData[] calldata tradeData,\n        address recipient,\n        bool isAtomic\n    ) external payable {\n        if (tokenTransfers.length == 0) revert UseLooksRareAggregatorDirectly();\n        _pullERC20Tokens(tokenTransfers, msg.sender);\n        aggregator.execute{value: msg.value}(tokenTransfers, tradeData, msg.sender, recipient, isAtomic);\n    }\n\n    function _pullERC20Tokens(TokenTransfer[] calldata tokenTransfers, address source) private {\n        uint256 tokenTransfersLength = tokenTransfers.length;\n        for (uint256 i; i < tokenTransfersLength; ) {\n            _executeERC20TransferFrom(\n                tokenTransfers[i].currency,\n                source,\n                address(aggregator),\n                tokenTransfers[i].amount\n            );\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/interfaces/IERC20EnabledLooksRareAggregator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {TokenTransfer} from \"../libraries/OrderStructs.sol\";\nimport {ILooksRareAggregator} from \"./ILooksRareAggregator.sol\";\n\ninterface IERC20EnabledLooksRareAggregator {\n    /**\n     * @notice Execute NFT sweeps in different marketplaces in a single transaction\n     * @param tokenTransfers Aggregated ERC20 token transfers for all markets\n     * @param tradeData Data object to be passed downstream to each marketplace's proxy for execution\n     * @param recipient The address to receive the purchased NFTs\n     * @param isAtomic Flag to enable atomic trades (all or nothing) or partial trades\n     */\n    function execute(\n        TokenTransfer[] calldata tokenTransfers,\n        ILooksRareAggregator.TradeData[] calldata tradeData,\n        address recipient,\n        bool isAtomic\n    ) external payable;\n\n    error UseLooksRareAggregatorDirectly();\n}"
    },
    {
      "filename": "contracts/interfaces/ILooksRareAggregator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {BasicOrder, TokenTransfer} from \"../libraries/OrderStructs.sol\";\n\ninterface ILooksRareAggregator {\n    struct TradeData {\n        address proxy; // The marketplace proxy's address\n        bytes4 selector; // The marketplace proxy's function selector\n        uint256 value; // The amount of ETH passed to the proxy during the function call\n        uint256 maxFeeBp; // The maximum fee basis point the buyer is willing to pay\n        BasicOrder[] orders; // Orders to be executed by the marketplace\n        bytes[] ordersExtraData; // Extra data for each order, specific for each marketplace\n        bytes extraData; // Extra data specific for each marketplace\n    }\n\n    /**\n     * @notice Execute NFT sweeps in different marketplaces in a single transaction\n     * @param tokenTransfers Aggregated ERC20 token transfers for all markets\n     * @param tradeData Data object to be passed downstream to each marketplace's proxy for execution\n     * @param originator The address that originated the transaction, hardcoded as msg.sender if it is called directly\n     * @param recipient The address to receive the purchased NFTs\n     * @param isAtomic Flag to enable atomic trades (all or nothing) or partial trades\n     */\n    function execute(\n        TokenTransfer[] calldata tokenTransfers,\n        TradeData[] calldata tradeData,\n        address originator,\n        address recipient,\n        bool isAtomic\n    ) external payable;\n\n    /**\n     * @dev Emitted when erc20EnabledLooksRareAggregator is set\n     */\n    event ERC20EnabledLooksRareAggregatorSet();\n\n    /**\n     * @dev Emitted when fee is updated\n     * @param proxy Proxy to apply the fee to\n     * @param bp Fee basis point\n     * @param recipient Fee recipient\n     */\n    event FeeUpdated(address proxy, uint256 bp, address recipient);\n\n    /**\n     * @notice Emitted when a marketplace proxy's function is enabled.\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     */\n    event FunctionAdded(address indexed proxy, bytes4 selector);\n\n    /**\n     * @notice Emitted when a marketplace proxy's function is disabled.\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     */\n    event FunctionRemoved(address indexed proxy, bytes4 selector);\n\n    /**\n     * @notice Emitted when execute is complete\n     * @param sweeper The address that submitted the transaction\n     */\n    event Sweep(address indexed sweeper);\n\n    error AlreadySet();\n    error FeeTooHigh();\n    error InvalidFunction();\n    error InvalidOrderLength();\n    error TradeExecutionFailed();\n    error UseERC20EnabledLooksRareAggregator();\n    error ZeroAddress();\n}"
    },
    {
      "filename": "contracts/interfaces/IProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {BasicOrder} from \"../libraries/OrderStructs.sol\";\n\ninterface IProxy {\n    error InvalidCaller();\n    error InvalidOrderLength();\n    error ZeroAddress();\n\n    /**\n     * @notice Execute NFT sweeps in a single transaction\n     * @param orders Orders to be executed\n     * @param ordersExtraData Extra data for each order\n     * @param extraData Extra data for the whole transaction\n     * @param recipient The address to receive the purchased NFTs\n     * @param isAtomic Flag to enable atomic trades (all or nothing) or partial trades\n     * @param feeBp Fee basis point to pay for the trade, set by the aggregator\n     * @param feeRecipient Fee recipient for the trade, set by the aggregator\n     */\n    function execute(\n        BasicOrder[] calldata orders,\n        bytes[] calldata ordersExtraData,\n        bytes calldata extraData,\n        address recipient,\n        bool isAtomic,\n        uint256 feeBp,\n        address feeRecipient\n    ) external payable;\n}"
    },
    {
      "filename": "contracts/interfaces/SeaportInterface.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// prettier-ignore\nimport {\n    BasicOrderParameters,\n    OrderComponents,\n    Fulfillment,\n    FulfillmentComponent,\n    Execution,\n    Order,\n    AdvancedOrder,\n    OrderStatus,\n    CriteriaResolver\n} from \"../libraries/seaport/ConsiderationStructs.sol\";\n\n/**\n * @title SeaportInterface\n * @author 0agegg\n * @custom:version 1.1\n * @notice Seaport is a generalized ETH/ERC20/ERC721/ERC1155 marketplace. It\n *         minimizes external calls to the greatest extent possible and provides\n *         lightweight methods for common routes as well as more flexible\n *         methods for composing advanced orders.\n *\n * @dev SeaportInterface contains all external function interfaces for Seaport.\n */\ninterface SeaportInterface {\n    /**\n     * @notice Fulfill an order offering an ERC721 token by supplying Ether (or\n     *         the native token for the given chain) as consideration for the\n     *         order. An arbitrary number of \"additional recipients\" may also be\n     *         supplied which will each receive native tokens from the fulfiller\n     *         as consideration.\n     *\n     * @param parameters Additional information on the fulfilled order. Note\n     *                   that the offerer must first approve this contract (or\n     *                   their preferred conduit if indicated by the order) for\n     *                   their offered ERC721 token to be transferred.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillBasicOrder(BasicOrderParameters calldata parameters) external payable returns (bool fulfilled);\n\n    /**\n     * @notice Fulfill an order with an arbitrary number of items for offer and\n     *         consideration. Note that this function does not support\n     *         criteria-based orders or partial filling of orders (though\n     *         filling the remainder of a partially-filled order is supported).\n     *\n     * @param order               The order to fulfill. Note that both the\n     *                            offerer and the fulfiller must first approve\n     *                            this contract (or the corresponding conduit if\n     *                            indicated) to transfer any relevant tokens on\n     *                            their behalf and that contracts must implement\n     *                            `onERC1155Received` to receive ERC1155 tokens\n     *                            as consideration.\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\n     *                            any, to source the fulfiller's token approvals\n     *                            from. The zero hash signifies that no conduit\n     *                            should be used, with direct approvals set on\n     *                            Seaport.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillOrder(Order calldata order, bytes32 fulfillerConduitKey) external payable returns (bool fulfilled);\n\n    /**\n     * @notice Fill an order, fully or partially, with an arbitrary number of\n     *         items for offer and consideration alongside criteria resolvers\n     *         containing specific token identifiers and associated proofs.\n     *\n     * @param advancedOrder       The order to fulfill along with the fraction\n     *                            of the order to attempt to fill. Note that\n     *                            both the offerer and the fulfiller must first\n     *                            approve this contract (or their preferred\n     *                            conduit if indicated by the order) to transfer\n     *                            any relevant tokens on their behalf and that\n     *                            contracts must implement `onERC1155Received`\n     *                            to receive ERC1155 tokens as consideration.\n     *                            Also note that all offer and consideration\n     *                            components must have no remainder after\n     *                            multiplication of the respective amount with\n     *                            the supplied fraction for the partial fill to\n     *                            be considered valid.\n     * @param criteriaResolvers   An array where each element contains a\n     *                            reference to a specific offer or\n     *                            consideration, a token identifier, and a proof\n     *                            that the supplied token identifier is\n     *                            contained in the merkle root held by the item\n     *                            in question's criteria element. Note that an\n     *                            empty criteria indicates that any\n     *                            (transferable) token identifier on the token\n     *                            in question is valid and that no associated\n     *                            proof needs to be supplied.\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\n     *                            any, to source the fulfiller's token approvals\n     *                            from. The zero hash signifies that no conduit\n     *                            should be used, with direct approvals set on\n     *                            Seaport.\n     * @param recipient           The intended recipient for all received items,\n     *                            with `address(0)` indicating that the caller\n     *                            should receive the items.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillAdvancedOrder(\n        AdvancedOrder calldata advancedOrder,\n        CriteriaResolver[] calldata criteriaResolvers,\n        bytes32 fulfillerConduitKey,\n        address recipient\n    ) external payable returns (bool fulfilled);\n\n    /**\n     * @notice Attempt to fill a group of orders, each with an arbitrary number\n     *         of items for offer and consideration. Any order that is not\n     *         currently active, has already been fully filled, or has been\n     *         cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *         Note that this function does not support criteria-based orders or\n     *         partial filling of orders (though filling the remainder of a\n     *         partially-filled order is supported).\n     *\n     * @param orders                    The orders to fulfill. Note that both\n     *                                  the offerer and the fulfiller must first\n     *                                  approve this contract (or the\n     *                                  corresponding conduit if indicated) to\n     *                                  transfer any relevant tokens on their\n     *                                  behalf and that contracts must implement\n     *                                  `onERC1155Received` to receive ERC1155\n     *                                  tokens as consideration.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller's token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used, with\n     *                                  direct approvals set on this contract.\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders.\n     */\n    function fulfillAvailableOrders(\n        Order[] calldata orders,\n        FulfillmentComponent[][] calldata offerFulfillments,\n        FulfillmentComponent[][] calldata considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        uint256 maximumFulfilled\n    ) external payable returns (bool[] memory availableOrders, Execution[] memory executions);\n\n    /**\n     * @notice Attempt to fill a group of orders, fully or partially, with an\n     *         arbitrary number of items for offer and consideration per order\n     *         alongside criteria resolvers containing specific token\n     *         identifiers and associated proofs. Any order that is not\n     *         currently active, has already been fully filled, or has been\n     *         cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *\n     * @param advancedOrders            The orders to fulfill along with the\n     *                                  fraction of those orders to attempt to\n     *                                  fill. Note that both the offerer and the\n     *                                  fulfiller must first approve this\n     *                                  contract (or their preferred conduit if\n     *                                  indicated by the order) to transfer any\n     *                                  relevant tokens on their behalf and that\n     *                                  contracts must implement\n     *                                  `onERC1155Received` to enable receipt of\n     *                                  ERC1155 tokens as consideration. Also\n     *                                  note that all offer and consideration\n     *                                  components must have no remainder after\n     *                                  multiplication of the respective amount\n     *                                  with the supplied fraction for an\n     *                                  order's partial fill amount to be\n     *                                  considered valid.\n     * @param criteriaResolvers         An array where each element contains a\n     *                                  reference to a specific offer or\n     *                                  consideration, a token identifier, and a\n     *                                  proof that the supplied token identifier\n     *                                  is contained in the merkle root held by\n     *                                  the item in question's criteria element.\n     *                                  Note that an empty criteria indicates\n     *                                  that any (transferable) token\n     *                                  identifier on the token in question is\n     *                                  valid and that no associated proof needs\n     *                                  to be supplied.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller's token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used, with\n     *                                  direct approvals set on this contract.\n     * @param recipient                 The intended recipient for all received\n     *                                  items, with `address(0)` indicating that\n     *                                  the caller should receive the items.\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders.\n     */\n    function fulfillAvailableAdvancedOrders(\n        AdvancedOrder[] calldata advancedOrders,\n        CriteriaResolver[] calldata criteriaResolvers,\n        FulfillmentComponent[][] calldata offerFulfillments,\n        FulfillmentComponent[][] calldata considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        address recipient,\n        uint256 maximumFulfilled\n    ) external payable returns (bool[] memory availableOrders, Execution[] memory executions);\n\n    /**\n     * @notice Match an arbitrary number of orders, each with an arbitrary\n     *         number of items for offer and consideration along with as set of\n     *         fulfillments allocating offer components to consideration\n     *         components. Note that this function does not support\n     *         criteria-based or partial filling of orders (though filling the\n     *         remainder of a partially-filled order is supported).\n     *\n     * @param orders       The orders to match. Note that both the offerer and\n     *                     fulfiller on each order must first approve this\n     *                     contract (or their conduit if indicated by the order)\n     *                     to transfer any relevant tokens on their behalf and\n     *                     each consideration recipient must implement\n     *                     `onERC1155Received` to enable ERC1155 token receipt.\n     * @param fulfillments An array of elements allocating offer components to\n     *                     consideration components. Note that each\n     *                     consideration component must be fully met for the\n     *                     match operation to be valid.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders.\n     */\n    function matchOrders(Order[] calldata orders, Fulfillment[] calldata fulfillments)\n        external\n        payable\n        returns (Execution[] memory executions);\n\n    /**\n     * @notice Match an arbitrary number of full or partial orders, each with an\n     *         arbitrary number of items for offer and consideration, supplying\n     *         criteria resolvers containing specific token identifiers and\n     *         associated proofs as well as fulfillments allocating offer\n     *         components to consideration components.\n     *\n     * @param orders            The advanced orders to match. Note that both the\n     *                          offerer and fulfiller on each order must first\n     *                          approve this contract (or a preferred conduit if\n     *                          indicated by the order) to transfer any relevant\n     *                          tokens on their behalf and each consideration\n     *                          recipient must implement `onERC1155Received` in\n     *                          order to receive ERC1155 tokens. Also note that\n     *                          the offer and consideration components for each\n     *                          order must have no remainder after multiplying\n     *                          the respective amount with the supplied fraction\n     *                          in order for the group of partial fills to be\n     *                          considered valid.\n     * @param criteriaResolvers An array where each element contains a reference\n     *                          to a specific order as well as that order's\n     *                          offer or consideration, a token identifier, and\n     *                          a proof that the supplied token identifier is\n     *                          contained in the order's merkle root. Note that\n     *                          an empty root indicates that any (transferable)\n     *                          token identifier is valid and that no associated\n     *                          proof needs to be supplied.\n     * @param fulfillments      An array of elements allocating offer components\n     *                          to consideration components. Note that each\n     *                          consideration component must be fully met in\n     *                          order for the match operation to be valid.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders.\n     */\n    function matchAdvancedOrders(\n        AdvancedOrder[] calldata orders,\n        CriteriaResolver[] calldata criteriaResolvers,\n        Fulfillment[] calldata fulfillments\n    ) external payable returns (Execution[] memory executions);\n\n    /**\n     * @notice Cancel an arbitrary number of orders. Note that only the offerer\n     *         or the zone of a given order may cancel it. Callers should ensure\n     *         that the intended order was cancelled by calling `getOrderStatus`\n     *         and confirming that `isCancelled` returns `true`.\n     *\n     * @param orders The orders to cancel.\n     *\n     * @return cancelled A boolean indicating whether the supplied orders have\n     *                   been successfully cancelled.\n     */\n    function cancel(OrderComponents[] calldata orders) external returns (bool cancelled);\n\n    /**\n     * @notice Validate an arbitrary number of orders, thereby registering their\n     *         signatures as valid and allowing the fulfiller to skip signature\n     *         verification on fulfillment. Note that validated orders may still\n     *         be unfulfillable due to invalid item amounts or other factors;\n     *         callers should determine whether validated orders are fulfillable\n     *         by simulating the fulfillment call prior to execution. Also note\n     *         that anyone can validate a signed order, but only the offerer can\n     *         validate an order without supplying a signature.\n     *\n     * @param orders The orders to validate.\n     *\n     * @return validated A boolean indicating whether the supplied orders have\n     *                   been successfully validated.\n     */\n    function validate(Order[] calldata orders) external returns (bool validated);\n\n    /**\n     * @notice Cancel all orders from a given offerer with a given zone in bulk\n     *         by incrementing a counter. Note that only the offerer may\n     *         increment the counter.\n     *\n     * @return newCounter The new counter.\n     */\n    function incrementCounter() external returns (uint256 newCounter);\n\n    /**\n     * @notice Retrieve the order hash for a given order.\n     *\n     * @param order The components of the order.\n     *\n     * @return orderHash The order hash.\n     */\n    function getOrderHash(OrderComponents calldata order) external view returns (bytes32 orderHash);\n\n    /**\n     * @notice Retrieve the status of a given order by hash, including whether\n     *         the order has been cancelled or validated and the fraction of the\n     *         order that has been filled.\n     *\n     * @param orderHash The order hash in question.\n     *\n     * @return isValidated A boolean indicating whether the order in question\n     *                     has been validated (i.e. previously approved or\n     *                     partially filled).\n     * @return isCancelled A boolean indicating whether the order in question\n     *                     has been cancelled.\n     * @return totalFilled The total portion of the order that has been filled\n     *                     (i.e. the \"numerator\").\n     * @return totalSize   The total size of the order that is either filled or\n     *                     unfilled (i.e. the \"denominator\").\n     */\n    function getOrderStatus(bytes32 orderHash)\n        external\n        view\n        returns (\n            bool isValidated,\n            bool isCancelled,\n            uint256 totalFilled,\n            uint256 totalSize\n        );\n\n    /**\n     * @notice Retrieve the current counter for a given offerer.\n     *\n     * @param offerer The offerer in question.\n     *\n     * @return counter The current counter.\n     */\n    function getCounter(address offerer) external view returns (uint256 counter);\n\n    /**\n     * @notice Retrieve configuration information for this contract.\n     *\n     * @return version           The contract version.\n     * @return domainSeparator   The domain separator for this contract.\n     * @return conduitController The conduit Controller set for this contract.\n     */\n    function information()\n        external\n        view\n        returns (\n            string memory version,\n            bytes32 domainSeparator,\n            address conduitController\n        );\n\n    /**\n     * @notice Retrieve the name of this contract.\n     *\n     * @return contractName The name of this contract.\n     */\n    function name() external view returns (string memory contractName);\n}"
    },
    {
      "filename": "contracts/LooksRareAggregator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"./ReentrancyGuard.sol\";\nimport {LowLevelERC20Approve} from \"./lowLevelCallers/LowLevelERC20Approve.sol\";\nimport {LowLevelERC721Transfer} from \"./lowLevelCallers/LowLevelERC721Transfer.sol\";\nimport {LowLevelERC1155Transfer} from \"./lowLevelCallers/LowLevelERC1155Transfer.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport {LooksRareProxy} from \"./proxies/LooksRareProxy.sol\";\nimport {BasicOrder, TokenTransfer} from \"./libraries/OrderStructs.sol\";\nimport {TokenRescuer} from \"./TokenRescuer.sol\";\nimport {TokenReceiver} from \"./TokenReceiver.sol\";\nimport {ILooksRareAggregator} from \"./interfaces/ILooksRareAggregator.sol\";\nimport {BasicOrder, FeeData, TokenTransfer} from \"./libraries/OrderStructs.sol\";\nimport {LooksRareProxy} from \"./proxies/LooksRareProxy.sol\";\nimport {TokenReceiver} from \"./TokenReceiver.sol\";\nimport {TokenRescuer} from \"./TokenRescuer.sol\";\n\n/**\n * @title LooksRareAggregator\n * @notice This contract allows NFT sweepers to buy NFTs from different marketplaces\n *         by passing high-level structs + low-level bytes as calldata.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract LooksRareAggregator is\n    ILooksRareAggregator,\n    TokenRescuer,\n    TokenReceiver,\n    ReentrancyGuard,\n    LowLevelERC20Approve,\n    LowLevelERC721Transfer,\n    LowLevelERC1155Transfer\n{\n    /**\n     * @notice Transactions that only involve ETH orders should be submitted to this contract\n     *         directly. Transactions that involve ERC20 orders should be submitted to the contract\n     *         ERC20EnabledLooksRareAggregator and it will call this contract's execution function.\n     *         The purpose is to prevent a malicious proxy from stealing users' ERC20 tokens if\n     *         this contract's ownership is compromised. By not providing any allowances to this\n     *         aggregator, even if a malicious proxy is added, it cannot call\n     *         token.transferFrom(victim, attacker, amount) inside the proxy within the context of the\n     *         aggregator.\n     */\n    address public erc20EnabledLooksRareAggregator;\n    mapping(address => mapping(bytes4 => bool)) private _proxyFunctionSelectors;\n    mapping(address => FeeData) private _proxyFeeData;\n\n    /**\n     * @inheritdoc ILooksRareAggregator\n     */\n    function execute(\n        TokenTransfer[] calldata tokenTransfers,\n        TradeData[] calldata tradeData,\n        address originator,\n        address recipient,\n        bool isAtomic\n    ) external payable nonReentrant {\n        if (recipient == address(0)) revert ZeroAddress();\n        uint256 tradeDataLength = tradeData.length;\n        if ("
    }
  ]
}