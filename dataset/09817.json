{
  "Title": "[M-13] Escrowed NFT can be stolen by anyone if no active buyPrice or auction exists for it",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketCore.sol#L77-L87\n\n\n# Vulnerability details\n\n\t\n\n## Impact\n\nIf a NFT happens to be in escrow with neither buyPrice, nor auction being initialised for it, there is a way to obtain it for free by any actor via `makeOffer`, `acceptOffer` combination.\n\nI.e. a malicious user can track the FNDNFTMarket contract and obtain any NFT from it for which there are no buyPrice or auction structures initialised. For example, if a NFT is mistakenly sent to the contract, an attacker can immediately steal it.\n\nThis will happen as NFT is being guarded by buyPrice and auction structures only. The severity here is medium as normal usage of the system imply that either one of them is initialised (NFT was sent to escrow as a part of `setBuyPrice` or `createReserveAuction`, and so one of the structures is present), so this seems to leave only mistakenly sent assets exposed.\n\n## Proof of Concept\n\nAn attacker can make a tiny offer with `makeOffer`:\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L189\n\nThen call `acceptOffer`, which will lead to `_acceptOffer`.\n\nDirect NFT transfer will fail in `_acceptOffer` as the NFT is being held by the contract and `_transferFromEscrow` will be called instead:\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L262-L271\n\n`_transferFromEscrow` calls will proceed according to the FNDNFTMarket defined order:\n```\nfunction _transferFromEscrow(\n...\n) internal override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice, NFTMarketOffer) {\n   super._transferFromEscrow(nftContract, tokenId, recipient, seller);\n}\n```\n\nIf there are no corresponding structures, the NFTMarketOffer, NFTMarketBuyPrice and NFTMarketReserveAuction versions of `_transferFromEscrow` will pass through the call to NFTMarketCore's plain transfer implementation:\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketCore.sol#L77-L87\n\nThis will effectively transfer the NFT to the attacker, which will pay gas costs and an arbitrary small offer price for it.\n\n## Recommended Mitigation Steps\n\nConsider adding additional checks to control who can obtain unallocated NFTs from the contract.\n\nProtocol controlled entity can handle such cases manually by initial sender's request.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-foundation-contest",
  "Code": [
    {
      "filename": "contracts/mixins/NFTMarketCore.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./Constants.sol\";\n\nimport \"../interfaces/IFethMarket.sol\";\n\nerror NFTMarketCore_FETH_Address_Is_Not_A_Contract();\nerror NFTMarketCore_Only_FETH_Can_Transfer_ETH();\n\n/**\n * @title A place for common modifiers and functions used by various NFTMarket mixins, if any.\n * @dev This also leaves a gap which can be used to add a new mixin to the top of the inheritance tree.\n */\nabstract contract NFTMarketCore is Constants {\n  using AddressUpgradeable for address;\n\n  /// @notice The FETH ERC-20 token for managing escrow and lockup.\n  IFethMarket internal immutable feth;\n\n  constructor(address _feth) {\n    if (!_feth.isContract()) {\n      revert NFTMarketCore_FETH_Address_Is_Not_A_Contract();\n    }\n    feth = IFethMarket(_feth);\n  }\n\n  /**\n   * @notice Only used by FETH. Any direct transfer from users will revert.\n   */\n  receive() external payable {\n    if (msg.sender != address(feth)) {\n      revert NFTMarketCore_Only_FETH_Can_Transfer_ETH();\n    }\n  }\n\n  /**\n   * @notice Notify implementors when an auction has received its first bid.\n   * Once a bid is received the sale is guaranteed to the auction winner\n   * and other sale mechanisms become unavailable.\n   * @dev Implementors of this interface should update internal state to reflect an auction has been kicked off.\n   */\n  function _afterAuctionStarted(\n    address, /*nftContract*/\n    uint256 /*tokenId*/ // solhint-disable-next-line no-empty-blocks\n  ) internal virtual {\n    // No-op\n  }\n\n  /**\n   * @notice If there is a buy price at this amount or lower, accept that and return true.\n   */\n  function _autoAcceptBuyPrice(\n    address nftContract,\n    uint256 tokenId,\n    uint256 amount\n  ) internal virtual returns (bool);\n\n  /**\n   * @notice If there is a valid offer at the given price or higher, accept that and return true.\n   */\n  function _autoAcceptOffer(\n    address nftContract,\n    uint256 tokenId,\n    uint256 minAmount\n  ) internal virtual returns (bool);\n\n  /**\n   * @notice Cancel the buyer's offer if there is one in order to free up their FETH balance.\n   */\n  function _cancelBuyersOffer(address nftContract, uint256 tokenId) internal virtual;\n\n  /**\n   * @notice Transfers the NFT from escrow and clears any state tracking this escrowed NFT.\n   */\n  function _transferFromEscrow(\n    address nftContract,\n    uint256 tokenId,\n    address recipient,\n    address /*seller*/\n  ) internal virtual {\n    IERC721(nftContract).transferFrom(address(this), recipient, tokenId);\n  }\n\n  /**\n   * @notice Transfers the NFT from escrow unless there is another reason for it to remain in escrow.\n   */\n  function _transferFromEscrowIfAvailable(\n    address nftContract,\n    uint256 tokenId,\n    address recipient\n  ) internal virtual {\n    IERC721(nftContract).transferFrom(address(this), recipient, tokenId);\n  }\n\n  /**\n   * @notice Transfers an NFT into escrow,\n   * if already there this requires the msg.sender is authorized to manage the sale of this NFT.\n   */\n  function _transferToEscrow(address nftContract, uint256 tokenId) internal virtual {\n    IERC721(nftContract).transferFrom(msg.sender, address(this), tokenId);\n  }\n\n  /**\n   * @notice Gets the FETH contract used to escrow offer funds.\n   * @return fethAddress The FETH contract address.\n   */\n  function getFethAddress() external view returns (address fethAddress) {\n    return address(feth);\n  }\n\n  /**\n   * @dev Determines the minimum amount when increasing an existing offer or bid.\n   */\n  function _getMinIncrement(uint256 currentAmount) internal pure returns (uint256) {\n    uint256 minIncrement = currentAmount * MIN_PERCENT_INCREMENT_IN_BASIS_POINTS;\n    unchecked {\n      minIncrement /= BASIS_POINTS;\n      if (minIncrement == 0) {\n        // Since minIncrement reduces from the currentAmount, this cannot overflow.\n        // The next amount must be at least 1 wei greater than the current.\n        return currentAmount + 1;\n      }\n    }\n\n    return minIncrement + currentAmount;\n  }\n\n  /**\n   * @notice Checks who the seller for an NFT is, checking escrow or return the current owner if not in escrow.\n   * @dev If the NFT did not have an escrowed seller to return, fall back to return the current owner.\n   */\n  function _getSellerFor(address nftContract, uint256 tokenId) internal view virtual returns (address payable seller) {\n    seller = payable(IERC721(nftContract).ownerOf(tokenId));\n  }\n\n  /**\n   * @notice Checks if an escrowed NFT is currently in active auction.\n   * @return Returns false if the auction has ended, even if it has not yet been settled.\n   */\n  function _isInActiveAuction(address nftContract, uint256 tokenId) internal view virtual returns (bool);\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   * @dev 50 slots were consumed by adding `ReentrancyGuard`.\n   */\n  uint256[950] private __gap;\n}"
    }
  ]
}