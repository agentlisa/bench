{
  "Title": "[H-02] First Liquidity provider can claim all initial pool rewards",
  "Content": "\n<https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/staking/StakingRewards.sol#L57> \n\n<https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/staking/StakingRewards.sol#L147> \n\n<https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/staking/StakingRewards.sol#L232>\n\nLiquidity providers can add liquidity to the protocol using the depositCollateralAndIncreaseShare or depositLiquidityAndIncreaseShare functions, both functions call the \\_increaseUserShare function to stake the users liquidity and account for the positions rewards. The current implementation has an issue, particularly in how it deals with the virtualRewards calculation for the first user. Since there is no current shares in the pool, then the virtualRewards calculation is skipped.\n\n```solidity\n// Increase a user's share for the given whitelisted pool.\n    function _increaseUserShare(address wallet, bytes32 poolID, uint256 increaseShareAmount, bool useCooldown)\n        internal\n    {\n        ...\n\tuint256 existingTotalShares = totalShares[poolID];\n\n        if (\n            existingTotalShares != 0 // prevent / 0\n        ) {\n            // Round up in favor of the protocol.\n            uint256 virtualRewardsToAdd = Math.ceilDiv(totalRewards[poolID] * increaseShareAmount, existingTotalShares);\n\n            user.virtualRewards += uint128(virtualRewardsToAdd);\n            totalRewards[poolID] += uint128(virtualRewardsToAdd);\n        }\n        // Update the deposit balances\n        user.userShare += uint128(increaseShareAmount);\n        totalShares[poolID] = existingTotalShares + increaseShareAmount;\n\t...\n    }\n```\n\nTo understand the implications of this, we need to look at how a user's rewards are calculated. The formula used in the userRewardForPool function is:\n\n*   **uint256 rewardsShare** **= (totalRewards\\[poolID] \\* user.userShare) / totalShares\\[poolID];**\n\nFrom this calculated rewardsShare, virtualRewards are then deducted:\n\n*   **return rewardsShare - user.virtualRewards;**\n\nIn the case where the first user stakes in an empty pool, they end up having the same number of shares as the totalShares in the pool, but with zero virtualRewards. This means that the first user can claim all the pools rewards in the staking contract, as their share of rewards would not have the necessary deduction of virtualRewards.\n\n```solidity\n// Returns the user's pending rewards for a specified pool.\n    function userRewardForPool(address wallet, bytes32 poolID) public view returns (uint256) {\n        ...\n        // Determine the share of the rewards for the user based on their deposited share\n        uint256 rewardsShare = (totalRewards[poolID] * user.userShare) / totalShares[poolID];\n\t...\n        return rewardsShare - user.virtualRewards;\n    }\n```\n\nA potential issue is the **lack** of Initial Rewards in the Contract. Initially, the staking contract does not contain any rewards, meaning that if a user were to claim rewards immediately, they would receive nothing. To overcome this, the user needs to trigger the **upkeep** function. This function is responsible for transferring up to the maximum allowable daily rewards to the staking contract.\n\nThe **upkeep** contract employs a timer to regulate the frequency and quantity of rewards distribution. However, since this timer begins counting from the moment of the contract's deployment (in the constructor), and considering the initial voting period for starting up the exchange spans several days, it becomes feasible to distribute the maximum daily reward amount by invoking upkeep.\n\n### Impact\n\nA LP can exploit this vulnerability to claim all the current staking rewards in the contract. Initially, there are 555k SALT bootstrap rewards per pool in the stakingRewardsEmitter, which are emitted at a rate of 1% per day. As a result, the first LP could claim up to 5.5k SALT.\n\n### Proof Of Concept\n\n```solidity\nfunction testFirstLPCanClaimAllRewards() public {\n        assertEq(salt.balanceOf(alice), 0);\n        bytes32 poolID1 = PoolUtils._poolID( wbtc, weth );\n        bytes32[] memory poolIDs = new bytes32[](1);\n        poolIDs[0] = poolID1;\n        skip(2 days);\n        // Total needs to be worth at least $2500\n\tuint256 depositedWBTC = ( 1000 ether *10**8) / priceAggregator.getPriceBTC();\n\tuint256 depositedWETH = ( 1000 ether *10**18) / priceAggregator.getPriceETH();\n\t(uint256 reserveWBTC, uint256 reserveWETH) = pools.getPoolReserves(wbtc, weth);\n\tvm.startPrank(alice);\n        // Alice call upkeep\n        upkeep.performUpkeep();\n        // check total rewards for pool\n        uint256[] memory totalRewards = new uint256[](1);\n        totalRewards = collateralAndLiquidity.totalRewardsForPools(poolIDs);\n        // Alice will deposit collateral \n\t(uint256 addedAmountWBTC, uint256 addedAmountWETH, uint256 addedLiquidity) = collateralAndLiquidity.depositCollateralAndIncreaseShare( depositedWBTC, depositedWETH, 0, block.timestamp, false );\n        // check alices rewards\n        uint rewardsAlice = collateralAndLiquidity.userRewardForPool(alice, poolIDs[0]);\n        collateralAndLiquidity.claimAllRewards(poolIDs);\n        vm.stopPrank();\n\n        assertEq(totalRewards[0], rewardsAlice);\n        assertEq(salt.balanceOf(alice), totalRewards[0]);\n    }\n```\n\n### Tools Used:\n\nFoundry\n\n### Recommendation:\n\nThe protocol can address this vulnerability in two ways:\n\n*   Call the **performUpkeep** function just before the initial distribution. This resets the timer, ensuring that a very small amount of rewards is sent to the staking contract if called again.\n*   Change the **lastUpkeepTime** to the start of when the exchange goes live, instead of in the constructor. This also ensures that only a minimal amount of rewards is sent to the staking contract upon subsequent calls, mitigating the problem.\n\n**[othernet-global (Salty.IO) confirmed and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/614#issuecomment-1945502553):**\n > performUpkeep is now called at the start of BootstrapBallot.finalizeBallot to reset the emissions timers just before liquidity rewards claiming is started.\n> \n> https://github.com/othernet-global/salty-io/commit/4f0c9c6a6e3e4234135ab7119a0e380af3e9776c\n\n**Status:** Mitigation confirmed. Full details in reports from [zzebra83](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/42), [0xpiken](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/62), and [t0x1c](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/32).\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/staking/StakingRewards.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport \"../pools/interfaces/IPoolsConfig.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"./interfaces/IStakingRewards.sol\";\nimport \"./interfaces/IStakingConfig.sol\";\nimport \"../interfaces/ISalt.sol\";\n\n// This contract allows users to receive rewards (as SALT tokens) for staking SALT or liquidity shares.\n// A user's reward is proportional to their share of the stake and is based on their share at the time that rewards are added.\n//\n// What staked shares represent is specific to the contracts that derive from StakingRewards.\n//\n// 1. Staking.sol: shares represent the amount of SALT staked (staked to the STAKED_SALT pool)\n// 2. Liquidity.sol: shares represent the amount of liquidity deposited and staked to specific pools\n\nabstract contract StakingRewards is IStakingRewards, ReentrancyGuard\n    {\n\tevent UserShareIncreased(address indexed wallet, bytes32 indexed poolID, uint256 amountIncreased);\n\tevent UserShareDecreased(address indexed wallet, bytes32 indexed poolID, uint256 amountDecreased, uint256 claimedRewards);\n\tevent RewardsClaimed(address indexed wallet, uint256 claimedRewards);\n\tevent SaltRewardsAdded(bytes32 indexed poolID, uint256 amountAdded);\n\n\tusing SafeERC20 for ISalt;\n\n\tISalt immutable public salt;\n\tIExchangeConfig immutable public exchangeConfig;\n    IStakingConfig immutable public stakingConfig;\n    IPoolsConfig immutable public poolsConfig;\n\n\t// A nested mapping that stores the UserShareInfo data for each user and each poolID.\n\tmapping(address=>mapping(bytes32=>UserShareInfo)) private _userShareInfo;\n\n    // A mapping that stores the total pending SALT rewards for each poolID.\n    mapping(bytes32=>uint256) public totalRewards;\n\n    // A mapping that stores the total shares for each poolID.\n    mapping(bytes32=>uint256) public totalShares;\n\n\n\t// Constructs a new StakingRewards contract with providing configs\n \tconstructor( IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IStakingConfig _stakingConfig )\n\t\t{\n\t\texchangeConfig = _exchangeConfig;\n    \tpoolsConfig = _poolsConfig;\n\t\tstakingConfig = _stakingConfig;\n\n\t\tsalt = _exchangeConfig.salt(); // cached for efficiency\n        }\n\n\n\t// Increase a user's share for the given whitelisted pool.\n\tfunction _increaseUserShare( address wallet, bytes32 poolID, uint256 increaseShareAmount, bool useCooldown ) internal\n\t\t{\n\t\trequire( poolsConfig.isWhitelisted( poolID ), \"Invalid pool\" );\n\t\trequire( increaseShareAmount != 0, \"Cannot increase zero share\" );\n\n\t\tUserShareInfo storage user = _userShareInfo[wallet][poolID];\n\n\t\tif ( useCooldown )\n\t\tif ( msg.sender != address(exchangeConfig.dao()) ) // DAO doesn't use the cooldown\n\t\t\t{\n\t\t\trequire( block.timestamp >= user.cooldownExpiration, \"Must wait for the cooldown to expire\" );\n\n\t\t\t// Update the cooldown expiration for future transactions\n\t\t\tuser.cooldownExpiration = block.timestamp + stakingConfig.modificationCooldown();\n\t\t\t}\n\n\t\tuint256 existingTotalShares = totalShares[poolID];\n\n\t\t// Determine the amount of virtualRewards to add based on the current ratio of rewards/shares.\n\t\t// The ratio of virtualRewards/increaseShareAmount is the same as totalRewards/totalShares for the pool.\n\t\t// The virtual rewards will be deducted later when calculating the user's owed rewards.\n        if ( existingTotalShares != 0 ) // prevent / 0\n        \t{\n\t\t\t// Round up in favor of the protocol.\n\t\t\tuint256 virtualRewardsToAdd = Math.ceilDiv( totalRewards[poolID] * increaseShareAmount, existingTotalShares );\n\n\t\t\tuser.virtualRewards += uint128(virtualRewardsToAdd);\n\t        totalRewards[poolID] += uint128(virtualRewardsToAdd);\n\t        }\n\n\t\t// Update the deposit balances\n\t\tuser.userShare += uint128(increaseShareAmount);\n\t\ttotalShares[poolID] = existingTotalShares + increaseShareAmount;\n\n\t\temit UserShareIncreased(wallet, poolID, increaseShareAmount);\n\t\t}\n\n\n\t// Decrease a user's share for the pool and have any pending rewards sent to them.\n\t// Does not require the pool to be valid (in case the pool was recently unwhitelisted).\n\tfunction _decreaseUserShare( address wallet, bytes32 poolID, uint256 decreaseShareAmount, bool useCooldown ) internal\n\t\t{\n\t\trequire( decreaseShareAmount != 0, \"Cannot decrease zero share\" );\n\n\t\tUserShareInfo storage user = _userShareInfo[wallet][poolID];\n\t\trequire( decreaseShareAmount <= user.userShare, \"Cannot decrease more than existing user share\" );\n\n\t\tif ( useCooldown )\n\t\tif ( msg.sender != address(exchangeConfig.dao()) ) // DAO doesn't use the cooldown\n\t\t\t{\n\t\t\trequire( block.timestamp >= user.cooldownExpiration, \"Must wait for the cooldown to expire\" );\n\n\t\t\t// Update the cooldown expiration for future transactions\n\t\t\tuser.cooldownExpiration = block.timestamp + stakingConfig.modificationCooldown();\n\t\t\t}\n\n\t\t// Determine the share of the rewards for the amountToDecrease (will include previously added virtual rewards)\n\t\tuint256 rewardsForAmount = ( totalRewards[poolID] * decreaseShareAmount ) / totalShares[poolID];\n\n\t\t// For the amountToDecrease determine the proportion of virtualRewards (proportional to all virtualRewards for the user)\n\t\t// Round virtualRewards down in favor of the protocol\n\t\tuint256 virtualRewardsToRemove = (user.virtualRewards * decreaseShareAmount) / user.userShare;\n\n\t\t// Update totals\n\t\ttotalRewards[poolID] -= rewardsForAmount;\n\t\ttotalShares[poolID] -= decreaseShareAmount;\n\n\t\t// Update the user's share and virtual rewards\n\t\tuser.userShare -= uint128(decreaseShareAmount);\n\t\tuser.virtualRewards -= uint128(virtualRewardsToRemove);\n\n\t\tuint256 claimableRewards = 0;\n\n\t\t// Some of the rewardsForAmount are actually virtualRewards and can't be claimed.\n\t\t// In the event that virtualRewards are greater than actual rewards - claimableRewards will stay zero.\n\t\tif ( virtualRewardsToRemove < rewardsForAmount )\n\t\t\tclaimableRewards = rewardsForAmount - virtualRewardsToRemove;\n\n\t\t// Send the claimable rewards\n\t\tif ( claimableRewards != 0 )\n\t\t\tsalt.safeTransfer( wallet, claimableRewards );\n\n\t\temit UserShareDecreased(wallet, poolID, decreaseShareAmount, claimableRewards);\n\t\t}\n\n\n\t// ===== PUBLIC FUNCTIONS =====\n\n\t// Claim all available SALT rewards from multiple pools for the user.\n\t// The claimed rewards are added to the user's virtual rewards balance - so that they can't be claimed again later.\n     function claimAllRewards( bytes32[] calldata poolIDs ) external nonReentrant returns (uint256 claimableRewards)\n    \t{\n\t\tmapping(bytes32=>UserShareInfo) storage userInfo = _userShareInfo[msg.sender];\n\n\t\tclaimableRewards = 0;\n\t\tfor( uint256 i = 0; i < poolIDs.length; i++ )\n\t\t\t{\n\t\t\tbytes32 poolID = poolIDs[i];\n\n\t\t\tuint256 pendingRewards = userRewardForPool( msg.sender, poolID );\n\n\t\t\t// Increase the virtualRewards balance for the user to account for them receiving the rewards without withdrawing\n\t\t\tuserInfo[poolID].virtualRewards += uint128(pendingRewards);\n\n\t\t\tclaimableRewards += pendingRewards;\n\t\t\t}\n\n\t\tif ( claimableRewards > 0 )\n\t\t\t{\n\t\t\t// Send the actual rewards\n\t\t\tsalt.safeTransfer( msg.sender, claimableRewards );\n\n\t\t\temit RewardsClaimed(msg.sender, claimableRewards);\n\t\t\t}\n    \t}\n\n\n\t// Adds SALT rewards for specific whitelisted pools.\n\t// There is some risk of addSALTRewards being frontrun to hunt rewards, but there are multiple mechanisms in place to prevent this from being effective.\n\t// 1. There is a cooldown period of default one hour before shares can be withdrawn once deposited.\n\t// 2. Staked SALT has a default unstake period of 52 weeks.\n\t// 3. Rewards are first placed into a RewardsEmitter which deposits rewards via addSALTRewards at the default rate of 1% per day.\n\t// 4. Rewards are deposited fairly often, with outstanding rewards being transferred with a frequency proportional to the activity of the exchange.\n\t// Example: if $100k rewards were being deposited in a bulk transaction, it would only equate to $1000 (1%) the first day,\n\t// or $10 in claimable rewards during a 15 minute upkeep period.\n \tfunction addSALTRewards( AddedReward[] calldata addedRewards ) external nonReentrant\n\t\t{\n\t\tuint256 sum = 0;\n\t\tfor( uint256 i = 0; i < addedRewards.length; i++ )\n\t\t\t{\n\t\t\tAddedReward memory addedReward = addedRewards[i];\n\n\t\t\tbytes32 poolID = addedReward.poolID;\n\t\t\trequire( poolsConfig.isWhitelisted( poolID ), \"Invalid pool\" );\n\n\t\t\tuint256 amountToAdd = addedReward.amountToAdd;\n\n\t\t\ttotalRewards[ poolID ] += amountToAdd;\n\t\t\tsum = sum + amountToAdd;\n\n\t\t\temit SaltRewardsAdded(poolID, amountToAdd);\n\t\t\t}\n\n\t\t// Transfer in the SALT for all the specified rewards\n\t\tif ( sum > 0 )\n\t\t\t{\n\t\t\t// Transfer the SALT rewards from the sender\n\t\t\tsalt.safeTransferFrom( msg.sender, address(this), sum );\n\t\t\t}\n\t\t}\n\n\n\t// === VIEWS ===\n\n\t// Returns the total shares for specified pools.\n\tfunction totalSharesForPools( bytes32[] calldata poolIDs ) external view returns (uint256[] memory shares)\n\t\t{\n\t\tshares = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < shares.length; i++ )\n\t\t\tshares[i] = totalShares[ poolIDs[i] ];\n\t\t}\n\n\n\t// Returns the total rewards for specified pools.\n\tfunction totalRewardsForPools( bytes32[] calldata poolIDs ) external view returns (uint256[] memory rewards)\n\t\t{\n\t\trewards = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < rewards.length; i++ )\n\t\t\trewards[i] = totalRewards[ poolIDs[i] ];\n\t\t}\n\n\n\t// Returns the user's pending rewards for a specified pool.\n\tfunction userRewardForPool( address wallet, bytes32 poolID ) public view returns (uint256)\n\t\t{\n\t\t// If there are no shares for the pool, the user can't have any shares either and there can't be any rewards\n\t\tif ( totalShares[poolID] == 0 )\n\t\t\treturn 0;\n\n\t\tUserShareInfo memory user = _userShareInfo[wallet][poolID];\n\t\tif ( user.userShare == 0 )\n\t\t\treturn 0;\n\n\t\t// Determine the share of the rewards for the user based on their deposited share\n\t\tuint256 rewardsShare = ( totalRewards[poolID] * user.userShare ) / totalShares[poolID];\n\n\t\t// Reduce by the virtualRewards - as they were only added to keep the share / rewards ratio the same when the used added their share\n\n\t\t// In the event that virtualRewards exceeds rewardsShare due to precision loss - just return zero\n\t\tif ( user.virtualRewards > rewardsShare )\n\t\t\treturn 0;\n\n\t\treturn rewardsShare - user.virtualRewards;\n\t\t}\n\n\n\t// Returns the user's pending rewards for specified pools.\n\tfunction userRewardsForPools( address wallet, bytes32[] calldata poolIDs ) external view returns (uint256[] memory rewards)\n\t\t{\n\t\trewards = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < rewards.length; i++ )\n\t\t\trewards[i] = userRewardForPool( wallet, poolIDs[i] );\n\t\t}\n\n\n\t// Get the user's shares for a specified pool.\n\tfunction userShareForPool( address wallet, bytes32 poolID ) public view returns (uint256)\n\t\t{\n\t\treturn _userShareInfo[wallet][poolID].userShare;\n\t\t}\n\n\n\t// Get the user's shares for specified pools.\n\tfunction userShareForPools( address wallet, bytes32[] calldata poolIDs ) external view returns (uint256[] memory shares)\n\t\t{\n\t\tshares = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < shares.length; i++ )\n\t\t\tshares[i] = _userShareInfo[wallet][ poolIDs[i] ].userShare;\n\t\t}\n\n\n\t// Get the user's virtual rewards for a specified pool.\n\tfunction userVirtualRewardsForPool( address wallet, bytes32 poolID ) public view returns (uint256)\n\t\t{\n\t\treturn _userShareInfo[wallet][poolID].virtualRewards;\n\t\t}\n\n\n\t// Get the cooldown time remaining for the user for specified pools.\n\tfunction userCooldowns( address wallet, bytes32[] calldata poolIDs ) external view returns (uint256[] memory cooldowns)\n\t\t{\n\t\tcooldowns = new uint256[]( poolIDs.length );\n\n\t\tmapping(bytes32=>UserShareInfo) storage userInfo = _userShareInfo[wallet];\n\n\t\tfor( uint256 i = 0; i < cooldowns.length; i++ )\n\t\t\t{\n\t\t\tuint256 cooldownExpiration = userInfo[ poolIDs[i] ].cooldownExpiration;\n\n\t\t\tif ( block.timestamp >= cooldownExpiration )\n\t\t\t\tcooldowns[i] = 0;\n\t\t\telse\n\t\t\t\tcooldowns[i] = cooldownExpiration - block.timestamp;\n\t\t\t}\n\t\t}\n\t}"
    },
    {
      "filename": "src/staking/StakingRewards.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport \"../pools/interfaces/IPoolsConfig.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"./interfaces/IStakingRewards.sol\";\nimport \"./interfaces/IStakingConfig.sol\";\nimport \"../interfaces/ISalt.sol\";\n\n// This contract allows users to receive rewards (as SALT tokens) for staking SALT or liquidity shares.\n// A user's reward is proportional to their share of the stake and is based on their share at the time that rewards are added.\n//\n// What staked shares represent is specific to the contracts that derive from StakingRewards.\n//\n// 1. Staking.sol: shares represent the amount of SALT staked (staked to the STAKED_SALT pool)\n// 2. Liquidity.sol: shares represent the amount of liquidity deposited and staked to specific pools\n\nabstract contract StakingRewards is IStakingRewards, ReentrancyGuard\n    {\n\tevent UserShareIncreased(address indexed wallet, bytes32 indexed poolID, uint256 amountIncreased);\n\tevent UserShareDecreased(address indexed wallet, bytes32 indexed poolID, uint256 amountDecreased, uint256 claimedRewards);\n\tevent RewardsClaimed(address indexed wallet, uint256 claimedRewards);\n\tevent SaltRewardsAdded(bytes32 indexed poolID, uint256 amountAdded);\n\n\tusing SafeERC20 for ISalt;\n\n\tISalt immutable public salt;\n\tIExchangeConfig immutable public exchangeConfig;\n    IStakingConfig immutable public stakingConfig;\n    IPoolsConfig immutable public poolsConfig;\n\n\t// A nested mapping that stores the UserShareInfo data for each user and each poolID.\n\tmapping(address=>mapping(bytes32=>UserShareInfo)) private _userShareInfo;\n\n    // A mapping that stores the total pending SALT rewards for each poolID.\n    mapping(bytes32=>uint256) public totalRewards;\n\n    // A mapping that stores the total shares for each poolID.\n    mapping(bytes32=>uint256) public totalShares;\n\n\n\t// Constructs a new StakingRewards contract with providing configs\n \tconstructor( IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IStakingConfig _stakingConfig )\n\t\t{\n\t\texchangeConfig = _exchangeConfig;\n    \tpoolsConfig = _poolsConfig;\n\t\tstakingConfig = _stakingConfig;\n\n\t\tsalt = _exchangeConfig.salt(); // cached for efficiency\n        }\n\n\n\t// Increase a user's share for the given whitelisted pool.\n\tfunction _increaseUserShare( address wallet, bytes32 poolID, uint256 increaseShareAmount, bool useCooldown ) internal\n\t\t{\n\t\trequire( poolsConfig.isWhitelisted( poolID ), \"Invalid pool\" );\n\t\trequire( increaseShareAmount != 0, \"Cannot increase zero share\" );\n\n\t\tUserShareInfo storage user = _userShareInfo[wallet][poolID];\n\n\t\tif ( useCooldown )\n\t\tif ( msg.sender != address(exchangeConfig.dao()) ) // DAO doesn't use the cooldown\n\t\t\t{\n\t\t\trequire( block.timestamp >= user.cooldownExpiration, \"Must wait for the cooldown to expire\" );\n\n\t\t\t// Update the cooldown expiration for future transactions\n\t\t\tuser.cooldownExpiration = block.timestamp + stakingConfig.modificationCooldown();\n\t\t\t}\n\n\t\tuint256 existingTotalShares = totalShares[poolID];\n\n\t\t// Determine the amount of virtualRewards to add based on the current ratio of rewards/shares.\n\t\t// The ratio of virtualRewards/increaseShareAmount is the same as totalRewards/totalShares for the pool.\n\t\t// The virtual rewards will be deducted later when calculating the user's owed rewards.\n        if ( existingTotalShares != 0 ) // prevent / 0\n        \t{\n\t\t\t// Round up in favor of the protocol.\n\t\t\tuint256 virtualRewardsToAdd = Math.ceilDiv( totalRewards[poolID] * increaseShareAmount, existingTotalShares );\n\n\t\t\tuser.virtualRewards += uint128(virtualRewardsToAdd);\n\t        totalRewards[poolID] += uint128(virtualRewardsToAdd);\n\t        }\n\n\t\t// Update the deposit balances\n\t\tuser.userShare += uint128(increaseShareAmount);\n\t\ttotalShares[poolID] = existingTotalShares + increaseShareAmount;\n\n\t\temit UserShareIncreased(wallet, poolID, increaseShareAmount);\n\t\t}\n\n\n\t// Decrease a user's share for the pool and have any pending rewards sent to them.\n\t// Does not require the pool to be valid (in case the pool was recently unwhitelisted).\n\tfunction _decreaseUserShare( address wallet, bytes32 poolID, uint256 decreaseShareAmount, bool useCooldown ) internal\n\t\t{\n\t\trequire( decreaseShareAmount != 0, \"Cannot decrease zero share\" );\n\n\t\tUserShareInfo storage user = _userShareInfo[wallet][poolID];\n\t\trequire( decreaseShareAmount <= user.userShare, \"Cannot decrease more than existing user share\" );\n\n\t\tif ( useCooldown )\n\t\tif ( msg.sender != address(exchangeConfig.dao()) ) // DAO doesn't use the cooldown\n\t\t\t{\n\t\t\trequire( block.timestamp >= user.cooldownExpiration, \"Must wait for the cooldown to expire\" );\n\n\t\t\t// Update the cooldown expiration for future transactions\n\t\t\tuser.cooldownExpiration = block.timestamp + stakingConfig.modificationCooldown();\n\t\t\t}\n\n\t\t// Determine the share of the rewards for the amountToDecrease (will include previously added virtual rewards)\n\t\tuint256 rewardsForAmount = ( totalRewards[poolID] * decreaseShareAmount ) / totalShares[poolID];\n\n\t\t// For the amountToDecrease determine the proportion of virtualRewards (proportional to all virtualRewards for the user)\n\t\t// Round virtualRewards down in favor of the protocol\n\t\tuint256 virtualRewardsToRemove = (user.virtualRewards * decreaseShareAmount) / user.userShare;\n\n\t\t// Update totals\n\t\ttotalRewards[poolID] -= rewardsForAmount;\n\t\ttotalShares[poolID] -= decreaseShareAmount;\n\n\t\t// Update the user's share and virtual rewards\n\t\tuser.userShare -= uint128(decreaseShareAmount);\n\t\tuser.virtualRewards -= uint128(virtualRewardsToRemove);\n\n\t\tuint256 claimableRewards = 0;\n\n\t\t// Some of the rewardsForAmount are actually virtualRewards and can't be claimed.\n\t\t// In the event that virtualRewards are greater than actual rewards - claimableRewards will stay zero.\n\t\tif ( virtualRewardsToRemove < rewardsForAmount )\n\t\t\tclaimableRewards = rewardsForAmount - virtualRewardsToRemove;\n\n\t\t// Send the claimable rewards\n\t\tif ( claimableRewards != 0 )\n\t\t\tsalt.safeTransfer( wallet, claimableRewards );\n\n\t\temit UserShareDecreased(wallet, poolID, decreaseShareAmount, claimableRewards);\n\t\t}\n\n\n\t// ===== PUBLIC FUNCTIONS =====\n\n\t// Claim all available SALT rewards from multiple pools for the user.\n\t// The claimed rewards are added to the user's virtual rewards balance - so that they can't be claimed again later.\n     function claimAllRewards( bytes32[] calldata poolIDs ) external nonReentrant returns (uint256 claimableRewards)\n    \t{\n\t\tmapping(bytes32=>UserShareInfo) storage userInfo = _userShareInfo[msg.sender];\n\n\t\tclaimableRewards = 0;\n\t\tfor( uint256 i = 0; i < poolIDs.length; i++ )\n\t\t\t{\n\t\t\tbytes32 poolID = poolIDs[i];\n\n\t\t\tuint256 pendingRewards = userRewardForPool( msg.sender, poolID );\n\n\t\t\t// Increase the virtualRewards balance for the user to account for them receiving the rewards without withdrawing\n\t\t\tuserInfo[poolID].virtualRewards += uint128(pendingRewards);\n\n\t\t\tclaimableRewards += pendingRewards;\n\t\t\t}\n\n\t\tif ( claimableRewards > 0 )\n\t\t\t{\n\t\t\t// Send the actual rewards\n\t\t\tsalt.safeTransfer( msg.sender, claimableRewards );\n\n\t\t\temit RewardsClaimed(msg.sender, claimableRewards);\n\t\t\t}\n    \t}\n\n\n\t// Adds SALT rewards for specific whitelisted pools.\n\t// There is some risk of addSALTRewards being frontrun to hunt rewards, but there are multiple mechanisms in place to prevent this from being effective.\n\t// 1. There is a cooldown period of default one hour before shares can be withdrawn once deposited.\n\t// 2. Staked SALT has a default unstake period of 52 weeks.\n\t// 3. Rewards are first placed into a RewardsEmitter which deposits rewards via addSALTRewards at the default rate of 1% per day.\n\t// 4. Rewards are deposited fairly often, with outstanding rewards being transferred with a frequency proportional to the activity of the exchange.\n\t// Example: if $100k rewards were being deposited in a bulk transaction, it would only equate to $1000 (1%) the first day,\n\t// or $10 in claimable rewards during a 15 minute upkeep period.\n \tfunction addSALTRewards( AddedReward[] calldata addedRewards ) external nonReentrant\n\t\t{\n\t\tuint256 sum = 0;\n\t\tfor( uint256 i = 0; i < addedRewards.length; i++ )\n\t\t\t{\n\t\t\tAddedReward memory addedReward = addedRewards[i];\n\n\t\t\tbytes32 poolID = addedReward.poolID;\n\t\t\trequire( poolsConfig.isWhitelisted( poolID ), \"Invalid pool\" );\n\n\t\t\tuint256 amountToAdd = addedReward.amountToAdd;\n\n\t\t\ttotalRewards[ poolID ] += amountToAdd;\n\t\t\tsum = sum + amountToAdd;\n\n\t\t\temit SaltRewardsAdded(poolID, amountToAdd);\n\t\t\t}\n\n\t\t// Transfer in the SALT for all the specified rewards\n\t\tif ( sum > 0 )\n\t\t\t{\n\t\t\t// Transfer the SALT rewards from the sender\n\t\t\tsalt.safeTransferFrom( msg.sender, address(this), sum );\n\t\t\t}\n\t\t}\n\n\n\t// === VIEWS ===\n\n\t// Returns the total shares for specified pools.\n\tfunction totalSharesForPools( bytes32[] calldata poolIDs ) external view returns (uint256[] memory shares)\n\t\t{\n\t\tshares = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < shares.length; i++ )\n\t\t\tshares[i] = totalShares[ poolIDs[i] ];\n\t\t}\n\n\n\t// Returns the total rewards for specified pools.\n\tfunction totalRewardsForPools( bytes32[] calldata poolIDs ) external view returns (uint256[] memory rewards)\n\t\t{\n\t\trewards = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < rewards.length; i++ )\n\t\t\trewards[i] = totalRewards[ poolIDs[i] ];\n\t\t}\n\n\n\t// Returns the user's pending rewards for a specified pool.\n\tfunction userRewardForPool( address wallet, bytes32 poolID ) public view returns (uint256)\n\t\t{\n\t\t// If there are no shares for the pool, the user can't have any shares either and there can't be any rewards\n\t\tif ( totalShares[poolID] == 0 )\n\t\t\treturn 0;\n\n\t\tUserShareInfo memory user = _userShareInfo[wallet][poolID];\n\t\tif ( user.userShare == 0 )\n\t\t\treturn 0;\n\n\t\t// Determine the share of the rewards for the user based on their deposited share\n\t\tuint256 rewardsShare = ( totalRewards[poolID] * user.userShare ) / totalShares[poolID];\n\n\t\t// Reduce by the virtualRewards - as they were only added to keep the share / rewards ratio the same when the used added their share\n\n\t\t// In the event that virtualRewards exceeds rewardsShare due to precision loss - just return zero\n\t\tif ( user.virtualRewards > rewardsShare )\n\t\t\treturn 0;\n\n\t\treturn rewardsShare - user.virtualRewards;\n\t\t}\n\n\n\t// Returns the user's pending rewards for specified pools.\n\tfunction userRewardsForPools( address wallet, bytes32[] calldata poolIDs ) external view returns (uint256[] memory rewards)\n\t\t{\n\t\trewards = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < rewards.length; i++ )\n\t\t\trewards[i] = userRewardForPool( wallet, poolIDs[i] );\n\t\t}\n\n\n\t// Get the user's shares for a specified pool.\n\tfunction userShareForPool( address wallet, bytes32 poolID ) public view returns (uint256)\n\t\t{\n\t\treturn _userShareInfo[wallet][poolID].userShare;\n\t\t}\n\n\n\t// Get the user's shares for specified pools.\n\tfunction userShareForPools( address wallet, bytes32[] calldata poolIDs ) external view returns (uint256[] memory shares)\n\t\t{\n\t\tshares = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < shares.length; i++ )\n\t\t\tshares[i] = _userShareInfo[wallet][ poolIDs[i] ].userShare;\n\t\t}\n\n\n\t// Get the user's virtual rewards for a specified pool.\n\tfunction userVirtualRewardsForPool( address wallet, bytes32 poolID ) public view returns (uint256)\n\t\t{\n\t\treturn _userShareInfo[wallet][poolID].virtualRewards;\n\t\t}\n\n\n\t// Get the cooldown time remaining for the user for specified pools.\n\tfunction userCooldowns( address wallet, bytes32[] calldata poolIDs ) external view returns (uint256[] memory cooldowns)\n\t\t{\n\t\tcooldowns = new uint256[]( poolIDs.length );\n\n\t\tmapping(bytes32=>UserShareInfo) storage userInfo = _userShareInfo[wallet];\n\n\t\tfor( uint256 i = 0; i < cooldowns.length; i++ )\n\t\t\t{\n\t\t\tuint256 cooldownExpiration = userInfo[ poolIDs[i] ].cooldownExpiration;\n\n\t\t\tif ( block.timestamp >= cooldownExpiration )\n\t\t\t\tcooldowns[i] = 0;\n\t\t\telse\n\t\t\t\tcooldowns[i] = cooldownExpiration - block.timestamp;\n\t\t\t}\n\t\t}\n\t}"
    },
    {
      "filename": "src/staking/StakingRewards.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport \"../pools/interfaces/IPoolsConfig.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"./interfaces/IStakingRewards.sol\";\nimport \"./interfaces/IStakingConfig.sol\";\nimport \"../interfaces/ISalt.sol\";\n\n// This contract allows users to receive rewards (as SALT tokens) for staking SALT or liquidity shares.\n// A user's reward is proportional to their share of the stake and is based on their share at the time that rewards are added.\n//\n// What staked shares represent is specific to the contracts that derive from StakingRewards.\n//\n// 1. Staking.sol: shares represent the amount of SALT staked (staked to the STAKED_SALT pool)\n// 2. Liquidity.sol: shares represent the amount of liquidity deposited and staked to specific pools\n\nabstract contract StakingRewards is IStakingRewards, ReentrancyGuard\n    {\n\tevent UserShareIncreased(address indexed wallet, bytes32 indexed poolID, uint256 amountIncreased);\n\tevent UserShareDecreased(address indexed wallet, bytes32 indexed poolID, uint256 amountDecreased, uint256 claimedRewards);\n\tevent RewardsClaimed(address indexed wallet, uint256 claimedRewards);\n\tevent SaltRewardsAdded(bytes32 indexed poolID, uint256 amountAdded);\n\n\tusing SafeERC20 for ISalt;\n\n\tISalt immutable public salt;\n\tIExchangeConfig immutable public exchangeConfig;\n    IStakingConfig immutable public stakingConfig;\n    IPoolsConfig immutable public poolsConfig;\n\n\t// A nested mapping that stores the UserShareInfo data for each user and each poolID.\n\tmapping(address=>mapping(bytes32=>UserShareInfo)) private _userShareInfo;\n\n    // A mapping that stores the total pending SALT rewards for each poolID.\n    mapping(bytes32=>uint256) public totalRewards;\n\n    // A mapping that stores the total shares for each poolID.\n    mapping(bytes32=>uint256) public totalShares;\n\n\n\t// Constructs a new StakingRewards contract with providing configs\n \tconstructor( IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IStakingConfig _stakingConfig )\n\t\t{\n\t\texchangeConfig = _exchangeConfig;\n    \tpoolsConfig = _poolsConfig;\n\t\tstakingConfig = _stakingConfig;\n\n\t\tsalt = _exchangeConfig.salt(); // cached for efficiency\n        }\n\n\n\t// Increase a user's share for the given whitelisted pool.\n\tfunction _increaseUserShare( address wallet, bytes32 poolID, uint256 increaseShareAmount, bool useCooldown ) internal\n\t\t{\n\t\trequire( poolsConfig.isWhitelisted( poolID ), \"Invalid pool\" );\n\t\trequire( increaseShareAmount != 0, \"Cannot increase zero share\" );\n\n\t\tUserShareInfo storage user = _userShareInfo[wallet][poolID];\n\n\t\tif ( useCooldown )\n\t\tif ( msg.sender != address(exchangeConfig.dao()) ) // DAO doesn't use the cooldown\n\t\t\t{\n\t\t\trequire( block.timestamp >= user.cooldownExpiration, \"Must wait for the cooldown to expire\" );\n\n\t\t\t// Update the cooldown expiration for future transactions\n\t\t\tuser.cooldownExpiration = block.timestamp + stakingConfig.modificationCooldown();\n\t\t\t}\n\n\t\tuint256 existingTotalShares = totalShares[poolID];\n\n\t\t// Determine the amount of virtualRewards to add based on the current ratio of rewards/shares.\n\t\t// The ratio of virtualRewards/increaseShareAmount is the same as totalRewards/totalShares for the pool.\n\t\t// The virtual rewards will be deducted later when calculating the user's owed rewards.\n        if ( existingTotalShares != 0 ) // prevent / 0\n        \t{\n\t\t\t// Round up in favor of the protocol.\n\t\t\tuint256 virtualRewardsToAdd = Math.ceilDiv( totalRewards[poolID] * increaseShareAmount, existingTotalShares );\n\n\t\t\tuser.virtualRewards += uint128(virtualRewardsToAdd);\n\t        totalRewards[poolID] += uint128(virtualRewardsToAdd);\n\t        }\n\n\t\t// Update the deposit balances\n\t\tuser.userShare += uint128(increaseShareAmount);\n\t\ttotalShares[poolID] = existingTotalShares + increaseShareAmount;\n\n\t\temit UserShareIncreased(wallet, poolID, increaseShareAmount);\n\t\t}\n\n\n\t// Decrease a user's share for the pool and have any pending rewards sent to them.\n\t// Does not require the pool to be valid (in case the pool was recently unwhitelisted).\n\tfunction _decreaseUserShare( address wallet, bytes32 poolID, uint256 decreaseShareAmount, bool useCooldown ) internal\n\t\t{\n\t\trequire( decreaseShareAmount != 0, \"Cannot decrease zero share\" );\n\n\t\tUserShareInfo storage user = _userShareInfo[wallet][poolID];\n\t\trequire( decreaseShareAmount <= user.userShare, \"Cannot decrease more than existing user share\" );\n\n\t\tif ( useCooldown )\n\t\tif ( msg.sender != address(exchangeConfig.dao()) ) // DAO doesn't use the cooldown\n\t\t\t{\n\t\t\trequire( block.timestamp >= user.cooldownExpiration, \"Must wait for the cooldown to expire\" );\n\n\t\t\t// Update the cooldown expiration for future transactions\n\t\t\tuser.cooldownExpiration = block.timestamp + stakingConfig.modificationCooldown();\n\t\t\t}\n\n\t\t// Determine the share of the rewards for the amountToDecrease (will include previously added virtual rewards)\n\t\tuint256 rewardsForAmount = ( totalRewards[poolID] * decreaseShareAmount ) / totalShares[poolID];\n\n\t\t// For the amountToDecrease determine the proportion of virtualRewards (proportional to all virtualRewards for the user)\n\t\t// Round virtualRewards down in favor of the protocol\n\t\tuint256 virtualRewardsToRemove = (user.virtualRewards * decreaseShareAmount) / user.userShare;\n\n\t\t// Update totals\n\t\ttotalRewards[poolID] -= rewardsForAmount;\n\t\ttotalShares[poolID] -= decreaseShareAmount;\n\n\t\t// Update the user's share and virtual rewards\n\t\tuser.userShare -= uint128(decreaseShareAmount);\n\t\tuser.virtualRewards -= uint128(virtualRewardsToRemove);\n\n\t\tuint256 claimableRewards = 0;\n\n\t\t// Some of the rewardsForAmount are actually virtualRewards and can't be claimed.\n\t\t// In the event that virtualRewards are greater than actual rewards - claimableRewards will stay zero.\n\t\tif ( virtualRewardsToRemove < rewardsForAmount )\n\t\t\tclaimableRewards = rewardsForAmount - virtualRewardsToRemove;\n\n\t\t// Send the claimable rewards\n\t\tif ( claimableRewards != 0 )\n\t\t\tsalt.safeTransfer( wallet, claimableRewards );\n\n\t\temit UserShareDecreased(wallet, poolID, decreaseShareAmount, claimableRewards);\n\t\t}\n\n\n\t// ===== PUBLIC FUNCTIONS =====\n\n\t// Claim all available SALT rewards from multiple pools for the user.\n\t// The claimed rewards are added to the user's virtual rewards balance - so that they can't be claimed again later.\n     function claimAllRewards( bytes32[] calldata poolIDs ) external nonReentrant returns (uint256 claimableRewards)\n    \t{\n\t\tmapping(bytes32=>UserShareInfo) storage userInfo = _userShareInfo[msg.sender];\n\n\t\tclaimableRewards = 0;\n\t\tfor( uint256 i = 0; i < poolIDs.length; i++ )\n\t\t\t{\n\t\t\tbytes32 poolID = poolIDs[i];\n\n\t\t\tuint256 pendingRewards = userRewardForPool( msg.sender, poolID );\n\n\t\t\t// Increase the virtualRewards balance for the user to account for them receiving the rewards without withdrawing\n\t\t\tuserInfo[poolID].virtualRewards += uint128(pendingRewards);\n\n\t\t\tclaimableRewards += pendingRewards;\n\t\t\t}\n\n\t\tif ( claimableRewards > 0 )\n\t\t\t{\n\t\t\t// Send the actual rewards\n\t\t\tsalt.safeTransfer( msg.sender, claimableRewards );\n\n\t\t\temit RewardsClaimed(msg.sender, claimableRewards);\n\t\t\t}\n    \t}\n\n\n\t// Adds SALT rewards for specific whitelisted pools.\n\t// There is some risk of addSALTRewards being frontrun to hunt rewards, but there are multiple mechanisms in place to prevent this from being effective.\n\t// 1. There is a cooldown period of default one hour before shares can be withdrawn once deposited.\n\t// 2. Staked SALT has a default unstake period of 52 weeks.\n\t// 3. Rewards are first placed into a RewardsEmitter which deposits rewards via addSALTRewards at the default rate of 1% per day.\n\t// 4. Rewards are deposited fairly often, with outstanding rewards being transferred with a frequency proportional to the activity of the exchange.\n\t// Example: if $100k rewards were being deposited in a bulk transaction, it would only equate to $1000 (1%) the first day,\n\t// or $10 in claimable rewards during a 15 minute upkeep period.\n \tfunction addSALTRewards( AddedReward[] calldata addedRewards ) external nonReentrant\n\t\t{\n\t\tuint256 sum = 0;\n\t\tfor( uint256 i = 0; i < addedRewards.length; i++ )\n\t\t\t{\n\t\t\tAddedReward memory addedReward = addedRewards[i];\n\n\t\t\tbytes32 poolID = addedReward.poolID;\n\t\t\trequire( p"
    }
  ]
}