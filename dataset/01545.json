{
  "Title": "CurveLP setters should not be used to update pools if the previous liquidity is not withdrawn yet",
  "Content": "##### Description\n\nCurveLP stores key pool addresses - deposits, withdrawals and approvals are deterministic to these pool. \nBut, for example, if the management calls `set_pool()` with the new pool, the operator will not be able to withdraw liquidity from the previous pool.\n\nThe are multiple of such setters:\n- https://github.com/yearn/yETH-bootstrap/blob/2dd219d3af49952275934638e8c9d50d0fef0d8f/contracts/modules/CurveLP.vy#L216\n- https://github.com/yearn/yETH-bootstrap/blob/2dd219d3af49952275934638e8c9d50d0fef0d8f/contracts/modules/CurveLP.vy#L270\n- https://github.com/yearn/yETH-bootstrap/blob/2dd219d3af49952275934638e8c9d50d0fef0d8f/contracts/modules/CurveLP.vy#L320\n- https://github.com/yearn/yETH-bootstrap/blob/2dd219d3af49952275934638e8c9d50d0fef0d8f/contracts/modules/CurveLP.vy#L349\n- https://github.com/yearn/yETH-bootstrap/blob/2dd219d3af49952275934638e8c9d50d0fef0d8f/contracts/modules/CurveLP.vy#L428\n\n##### Recommendation\n\nWe recommend checking that the previous pool does not have liquidity or allowing withdrawal from any pool and setting restriction only for new deposits.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/modules/CurveLP.vy",
      "content": "# @version 0.3.7\n\"\"\"\n@title Curve LP Module\n@author 0xkorin, Yearn Finance\n@license Copyright (c) Yearn Finance, 2023 - all rights reserved\n@notice\n    Module to manage the POL's yETH/ETH position.\n    Controlled by two roles: management and operator.\n    Operator can deposit/withdraw into Curve and subsequently into gauge/Convex/yVault.\n    Management can set relevant addresses\n\"\"\"\n\nfrom vyper.interfaces import ERC20\n\ninterface POL:\n    def receive_native(): payable\n    def send_native(_receiver: address, _amount: uint256): nonpayable\n    def mint(_amount: uint256): nonpayable\n    def burn(_amount: uint256): nonpayable\n\n# https://github.com/curvefi/curve-factory/blob/master/contracts/implementations/plain-2/Plain2ETHEMA.vy\ninterface CurvePool:\n    def add_liquidity(_amounts: uint256[2], _min_mint_amount: uint256, _receiver: address) -> uint256: payable\n    def remove_liquidity(_burn_amount: uint256, _min_amounts: uint256[2], _receiver: address) -> uint256[2]: nonpayable\n    def remove_liquidity_imbalance(_amounts: uint256[2], _max_burn_amount: uint256, _receiver: address) -> uint256: nonpayable\n\n# https://github.com/curvefi/curve-factory/blob/master/contracts/LiquidityGauge.vy\ninterface CurveGauge:\n    def set_rewards_receiver(_receiver: address): nonpayable\n    def deposit(_value: uint256): nonpayable\n    def withdraw(_value: uint256): nonpayable\n\n# https://github.com/convex-eth/platform/blob/main/contracts/contracts/Booster.sol\ninterface ConvexBooster:\n    def deposit(_pid: uint256, _amount: uint256, _stake: bool) -> bool: nonpayable\n    def withdraw(_pid: uint256, _amount: uint256) -> bool: nonpayable\n\n# https://github.com/convex-eth/platform/blob/main/contracts/contracts/BaseRewardPool.sol\ninterface ConvexRewards:\n    def stake(_amount: uint256): nonpayable\n    def withdraw(_amount: uint256, _claim: bool): nonpayable\n    def withdrawAndUnwrap(_amount: uint256, _claim: bool): nonpayable\n\n# https://github.com/yearn/yearn-vaults/blob/master/contracts/Vault.vy\ninterface YVault:\n    def deposit(_amount: uint256) -> uint256: nonpayable\n    def withdraw(_shares: uint256, _recipient: address, _max_loss: uint256) -> uint256: nonpayable\n\ntoken: public(immutable(address))\npol: public(immutable(address))\nmanagement: public(address)\npending_management: public(address)\noperator: public(address)\npending_operator: public(address)\npool: public(address)\ngauge: public(address)\nconvex_booster: public(address)\nconvex_pool_id: public(uint256)\nconvex_token: public(address)\nconvex_rewards: public(address)\nyvault: public(address)\n\nevent SetAddress:\n    index: indexed(uint256)\n    value: address\n\nevent PendingManagement:\n    management: indexed(address)\n\nevent SetManagement:\n    management: indexed(address)\n\nevent PendingOperator:\n    operator: indexed(address)\n\nevent SetOperator:\n    operator: indexed(address)\n\nevent FromPOL:\n    token: indexed(address)\n    amount: uint256\n\nevent ToPOL:\n    token: indexed(address)\n    amount: uint256\n\nevent AddLiquidity:\n    amounts_in: uint256[2]\n    amount_out: uint256\n\nevent RemoveLiquidity:\n    amount_in: uint256\n    amounts_out: uint256[2]\n\nevent Deposit:\n    pool: indexed(uint256)\n    amount_in: uint256\n    amount_out: uint256\n\nevent Withdraw:\n    pool: indexed(uint256)\n    amount_in: uint256\n    amount_out: uint256\n\nNATIVE: constant(address) = 0x0000000000000000000000000000000000000000\nMINT: constant(address)   = 0x0000000000000000000000000000000000000001\nBURN: constant(address)   = 0x0000000000000000000000000000000000000002\n\n@external\ndef __init__(_token: address, _pol: address):\n    \"\"\"\n    @notice Constructor\n    @param _token yETH token address\n    @param _pol POL address\n    \"\"\"\n    token = _token\n    pol = _pol\n    self.management = msg.sender\n    self.operator = msg.sender\n\n@external\n@payable\ndef __default__():\n    \"\"\"\n    @notice Receive ETH\n    \"\"\"\n    pass\n\n@external\ndef from_pol(_token: address, _amount: uint256):\n    \"\"\"\n    @notice Transfer `_amount` of `_token` from POL to this contract\n    @param _token \n        Token to transfer out of POL.\n        Use special designated values to mint/burn yETH or transfer ETH\n    @param _amount Amount of tokens to transfer\n    \"\"\"\n    assert msg.sender == self.operator\n    if _token == NATIVE:\n        POL(pol).send_native(self, _amount)\n    elif _token == MINT:\n        POL(pol).mint(_amount)\n    elif _token == BURN:\n        POL(pol).burn(_amount)\n    else:\n        assert ERC20(_token).transferFrom(pol, self, _amount, default_return_value=True)\n    log FromPOL(_token, _amount)\n\n@external\ndef to_pol(_token: address, _amount: uint256):\n    \"\"\"\n    @notice Transfer `_amount` of `_token` to POL from this contract\n    @param _token \n        Token to transfer into POL.\n        Use special designated value to transfer ETH\n    @param _amount Amount of tokens to transfer\n    \"\"\"\n    assert msg.sender == self.operator\n    if _token == NATIVE:\n        POL(pol).receive_native(value=_amount)\n    else:\n        assert ERC20(_token).transfer(pol, _amount, default_return_value=True)\n    log ToPOL(_token, _amount)\n\n@external\ndef set_operator(_operator: address):\n    \"\"\"\n    @notice \n        Set the pending operator address.\n        Needs to be accepted by that account separately to transfer operator over\n    @param _operator New pending operator address\n    \"\"\"\n    assert msg.sender == self.operator or msg.sender == self.management\n    self.pending_operator = _operator\n    log PendingOperator(_operator)\n\n@external\ndef accept_operator():\n    \"\"\"\n    @notice \n        Accept operator role.\n        Can only be called by account previously marked as pending operator by current operator\n    \"\"\"\n    assert msg.sender == self.pending_operator\n    self.pending_operator = empty(address)\n    self.operator = msg.sender\n    log SetOperator(msg.sender)\n\n@external\ndef set_management(_management: address):\n    \"\"\"\n    @notice \n        Set the pending management address.\n        Needs to be accepted by that account separately to transfer management over\n    @param _management New pending management address\n    \"\"\"\n    assert msg.sender == self.management\n    self.pending_management = _management\n    log PendingManagement(_management)\n\n@external\ndef accept_management():\n    \"\"\"\n    @notice \n        Accept management role.\n        Can only be called by account previously marked as pending management by current management\n    \"\"\"\n    assert msg.sender == self.pending_management\n    self.pending_management = empty(address)\n    self.management = msg.sender\n    log SetManagement(msg.sender)\n\n# CURVE POOL FUNCTIONS\n\n@external\ndef set_pool(_pool: address):\n    \"\"\"\n    @notice Set Curve yETH/ETH pool\n    @param _pool Pool address\n    \"\"\"\n    assert msg.sender == self.management\n    self.pool = _pool\n    log SetAddress(0, _pool)\n\n@external\ndef approve_pool(_amount: uint256):\n    \"\"\"\n    @notice Approve Curve pool to transfer yETH\n    @param _amount Amount of tokens to approve\n    \"\"\"\n    assert msg.sender == self.operator\n    assert ERC20(token).approve(self.pool, _amount, default_return_value=True)\n\n@external\ndef add_liquidity(_amounts: uint256[2], _min_lp: uint256):\n    \"\"\"\n    @notice Add liquidity to the Curve pool\n    @param _amounts ETH and yETH amounts\n    @param _min_lp Minimum amount of LP tokens to receive\n    \"\"\"\n    assert msg.sender == self.operator\n    lp: uint256 = CurvePool(self.pool).add_liquidity(_amounts, _min_lp, pol, value=_amounts[0])\n    log AddLiquidity(_amounts, lp)\n\n@external\ndef remove_liquidity(_lp_amount: uint256, _min_amounts: uint256[2]):\n    \"\"\"\n    @notice Remove liquidity from the Curve pool\n    @param _lp_amount Amount of LP tokens to redeem\n    @param _min_amounts Minimum amounts of ETH and yETH to receive\n    \"\"\"\n    assert msg.sender == self.operator\n    amounts: uint256[2] = CurvePool(self.pool).remove_liquidity(_lp_amount, _min_amounts, pol)\n    log RemoveLiquidity(_lp_amount, amounts)\n\n@external\ndef remove_liquidity_imbalance(_amounts: uint256[2], _max_lp: uint256):\n    \"\"\"\n    @notice Remove liquidity from the Curve pool in an imbalanced way\n    @param _amounts Amounts of ETH and yETH to receive\n    @param _max_lp Maximum amount of LP tokens to redeem\n    \"\"\"\n    assert msg.sender == self.operator\n    lp: uint256 = CurvePool(self.pool).remove_liquidity_imbalance(_amounts, _max_lp, pol)\n    log RemoveLiquidity(lp, _amounts)\n\n# GAUGE FUNCTIONS\n\n@external\ndef set_gauge(_gauge: address):\n    \"\"\"\n    @notice Set Curve gauge address\n    @param _gauge Gauge address\n    \"\"\"\n    assert msg.sender == self.management\n    self.gauge = _gauge\n    log SetAddress(1, _gauge)\n\n@external\ndef approve_gauge(_amount: uint256):\n    \"\"\"\n    @notice Approve gauge to transfer yETH\n    @param _amount Amount of tokens to approve\n    \"\"\"\n    assert msg.sender == self.operator\n    assert self.gauge != empty(address)\n    assert ERC20(self.pool).approve(self.gauge, _amount, default_return_value=True)\n\n@external\ndef gauge_rewards_receiver():\n    \"\"\"\n    @notice Set POL as Curve gauge rewards receiver\n    \"\"\"\n    assert msg.sender == self.management\n    CurveGauge(self.gauge).set_rewards_receiver(pol)\n\n@external\ndef deposit_gauge(_amount: uint256):\n    \"\"\"\n    @notice Deposit LP tokens into gauge\n    @param _amount Amount of tokens to deposit\n    \"\"\"\n    assert msg.sender == self.operator\n    CurveGauge(self.gauge).deposit(_amount)\n    log Deposit(0, _amount, _amount)\n\n@external\ndef withdraw_gauge(_amount: uint256):\n    \"\"\"\n    @notice Withdraw LP tokens from gauge\n    @param _amount Amount of tokens to withdraw\n    \"\"\"\n    assert msg.sender == self.operator\n    CurveGauge(self.gauge).withdraw(_amount)\n    log Withdraw(0, _amount, _amount)\n    \n# CONVEX FUNCTIONS\n\n@external\ndef set_convex_booster(_booster: address):\n    \"\"\"\n    @notice Set Convex booster address\n    @param _booster Booster address\n    \"\"\"\n    assert msg.sender == self.management\n    self.convex_booster = _booster\n    log SetAddress(2, _booster)\n\n@external\ndef set_convex_pool_id(_pool_id: uint256):\n    \"\"\"\n    @notice Set pool id for yETH/ETH pool\n    @param _pool_id Pool id\n    \"\"\"\n    assert msg.sender == self.management\n    self.convex_pool_id = _pool_id\n\n@external\ndef set_convex_token(_token: address):\n    \"\"\"\n    @notice Set Convex pool token\n    @param _token Token address\n    \"\"\"\n    assert msg.sender == self.management\n    self.convex_token = _token\n    log SetAddress(3, _token)\n\n@external\ndef set_convex_rewards(_rewards: address):\n    \"\"\"\n    @notice Set Convex rewards address\n    @param _rewards Rewards address\n    \"\"\"\n    assert msg.sender == self.management\n    self.convex_rewards = _rewards\n    log SetAddress(4, _rewards)\n\n@external\ndef approve_convex_booster(_amount: uint256):\n    \"\"\"\n    @notice Approve Convex booster to transfer LP tokens\n    @param _amount Amount of tokens to approve\n    \"\"\"\n    assert msg.sender == self.operator\n    assert self.convex_booster != empty(address)\n    assert ERC20(self.pool).approve(self.convex_booster, _amount, default_return_value=True)\n\n@external\ndef deposit_convex_booster(_amount: uint256):\n    \"\"\"\n    @notice Deposit LP tokens into Convex\n    @param _amount Amount of tokens to deposit\n    \"\"\"\n    assert msg.sender == self.operator\n    assert self.convex_pool_id != 0\n    ConvexBooster(self.convex_booster).deposit(self.convex_pool_id, _amount, True)\n    log Deposit(1, _amount, _amount)\n\n@external\ndef withdraw_convex_booster(_amount: uint256):\n    \"\"\"\n    @notice Withdraw LP tokens from Convex\n    @param _amount Amount of tokens to withdraw\n    \"\"\"\n    assert msg.sender == self.operator\n    assert self.convex_pool_id != 0\n    ConvexBooster(self.convex_booster).withdraw(self.convex_pool_id, _amount)\n    log Withdraw(1, _amount, _amount)\n\n@external\ndef approve_convex_rewards(_amount: uint256):\n    \"\"\"\n    @notice Approve Convex rewards contract to transfer Convex LP tokens\n    @param _amount Amount of tokens to approve\n    \"\"\"\n    assert msg.sender == self.operator\n    assert self.convex_rewards != empty(address)\n    assert ERC20(self.convex_token).approve(self.convex_rewards, _amount, default_return_value=True)\n\n@external\ndef deposit_convex_rewards(_amount: uint256):\n    \"\"\"\n    @notice Deposit Convex LP tokens into rewards contract\n    @param _amount Amount of tokens to deposit\n    \"\"\"\n    assert msg.sender == self.operator\n    ConvexRewards(self.convex_rewards).stake(_amount)\n    log Deposit(2, _amount, _amount)\n\n@external\ndef withdraw_convex_rewards(_amount: uint256, _unwrap: bool):\n    \"\"\"\n    @notice Withdraw Convex LP tokens from rewards contract\n    @param _amount Amount of tokens to withdraw\n    @param _unwrap True to also withdraw from Convex booster, False otherwise\n    \"\"\"\n    assert msg.sender == self.operator\n    if _unwrap:\n        ConvexRewards(self.convex_rewards).withdrawAndUnwrap(_amount, True)\n        log Withdraw(1, _amount, _amount)\n    else:\n        ConvexRewards(self.convex_rewards).withdraw(_amount, True)\n    log Withdraw(2, _amount, _amount)\n\n# YVAULT FUNCTIONS\n\n@external\ndef set_yvault(_yvault: address):\n    \"\"\"\n    @notice Set yearn vault contract\n    @param _yvault Yearn vault address\n    \"\"\"\n    assert msg.sender == self.management\n    self.yvault = _yvault\n    log SetAddress(5, _yvault)\n\n@external\ndef approve_yvault(_amount: uint256):\n    \"\"\"\n    @notice Approve Yearn vault to transfer LP tokens\n    @param _amount Amount of tokens to approve\n    \"\"\"\n    assert msg.sender == self.operator\n    assert self.yvault != empty(address)\n    assert ERC20(self.pool).approve(self.yvault, _amount, default_return_value=True)\n\n@external\ndef deposit_yvault(_amount: uint256):\n    \"\"\"\n    @notice Deposit LP tokens into Yearn vault\n    @param _amount Amount of tokens to deposit\n    \"\"\"\n    assert msg.sender == self.operator\n    shares: uint256 = YVault(self.yvault).deposit(_amount)\n    log Deposit(3, _amount, shares)\n\n@external\ndef withdraw_yvault(_shares: uint256, _max_loss: uint256):\n    \"\"\"\n    @notice Withdraw LP tokens from Yearn vault\n    @param _amount Amount of tokens to withdraw\n    \"\"\"\n    assert msg.sender == self.operator\n    amount: uint256 = YVault(self.yvault).withdraw(_shares, self, _max_loss)\n    log Withdraw(3, _shares, amount)"
    },
    {
      "filename": "contracts/modules/CurveLP.vy",
      "content": "# @version 0.3.7\n\"\"\"\n@title Curve LP Module\n@author 0xkorin, Yearn Finance\n@license Copyright (c) Yearn Finance, 2023 - all rights reserved\n@notice\n    Module to manage the POL's yETH/ETH position.\n    Controlled by two roles: management and operator.\n    Operator can deposit/withdraw into Curve and subsequently into gauge/Convex/yVault.\n    Management can set relevant addresses\n\"\"\"\n\nfrom vyper.interfaces import ERC20\n\ninterface POL:\n    def receive_native(): payable\n    def send_native(_receiver: address, _amount: uint256): nonpayable\n    def mint(_amount: uint256): nonpayable\n    def burn(_amount: uint256): nonpayable\n\n# https://github.com/curvefi/curve-factory/blob/master/contracts/implementations/plain-2/Plain2ETHEMA.vy\ninterface CurvePool:\n    def add_liquidity(_amounts: uint256[2], _min_mint_amount: uint256, _receiver: address) -> uint256: payable\n    def remove_liquidity(_burn_amount: uint256, _min_amounts: uint256[2], _receiver: address) -> uint256[2]: nonpayable\n    def remove_liquidity_imbalance(_amounts: uint256[2], _max_burn_amount: uint256, _receiver: address) -> uint256: nonpayable\n\n# https://github.com/curvefi/curve-factory/blob/master/contracts/LiquidityGauge.vy\ninterface CurveGauge:\n    def set_rewards_receiver(_receiver: address): nonpayable\n    def deposit(_value: uint256): nonpayable\n    def withdraw(_value: uint256): nonpayable\n\n# https://github.com/convex-eth/platform/blob/main/contracts/contracts/Booster.sol\ninterface ConvexBooster:\n    def deposit(_pid: uint256, _amount: uint256, _stake: bool) -> bool: nonpayable\n    def withdraw(_pid: uint256, _amount: uint256) -> bool: nonpayable\n\n# https://github.com/convex-eth/platform/blob/main/contracts/contracts/BaseRewardPool.sol\ninterface ConvexRewards:\n    def stake(_amount: uint256): nonpayable\n    def withdraw(_amount: uint256, _claim: bool): nonpayable\n    def withdrawAndUnwrap(_amount: uint256, _claim: bool): nonpayable\n\n# https://github.com/yearn/yearn-vaults/blob/master/contracts/Vault.vy\ninterface YVault:\n    def deposit(_amount: uint256) -> uint256: nonpayable\n    def withdraw(_shares: uint256, _recipient: address, _max_loss: uint256) -> uint256: nonpayable\n\ntoken: public(immutable(address))\npol: public(immutable(address))\nmanagement: public(address)\npending_management: public(address)\noperator: public(address)\npending_operator: public(address)\npool: public(address)\ngauge: public(address)\nconvex_booster: public(address)\nconvex_pool_id: public(uint256)\nconvex_token: public(address)\nconvex_rewards: public(address)\nyvault: public(address)\n\nevent SetAddress:\n    index: indexed(uint256)\n    value: address\n\nevent PendingManagement:\n    management: indexed(address)\n\nevent SetManagement:\n    management: indexed(address)\n\nevent PendingOperator:\n    operator: indexed(address)\n\nevent SetOperator:\n    operator: indexed(address)\n\nevent FromPOL:\n    token: indexed(address)\n    amount: uint256\n\nevent ToPOL:\n    token: indexed(address)\n    amount: uint256\n\nevent AddLiquidity:\n    amounts_in: uint256[2]\n    amount_out: uint256\n\nevent RemoveLiquidity:\n    amount_in: uint256\n    amounts_out: uint256[2]\n\nevent Deposit:\n    pool: indexed(uint256)\n    amount_in: uint256\n    amount_out: uint256\n\nevent Withdraw:\n    pool: indexed(uint256)\n    amount_in: uint256\n    amount_out: uint256\n\nNATIVE: constant(address) = 0x0000000000000000000000000000000000000000\nMINT: constant(address)   = 0x0000000000000000000000000000000000000001\nBURN: constant(address)   = 0x0000000000000000000000000000000000000002\n\n@external\ndef __init__(_token: address, _pol: address):\n    \"\"\"\n    @notice Constructor\n    @param _token yETH token address\n    @param _pol POL address\n    \"\"\"\n    token = _token\n    pol = _pol\n    self.management = msg.sender\n    self.operator = msg.sender\n\n@external\n@payable\ndef __default__():\n    \"\"\"\n    @notice Receive ETH\n    \"\"\"\n    pass\n\n@external\ndef from_pol(_token: address, _amount: uint256):\n    \"\"\"\n    @notice Transfer `_amount` of `_token` from POL to this contract\n    @param _token \n        Token to transfer out of POL.\n        Use special designated values to mint/burn yETH or transfer ETH\n    @param _amount Amount of tokens to transfer\n    \"\"\"\n    assert msg.sender == self.operator\n    if _token == NATIVE:\n        POL(pol).send_native(self, _amount)\n    elif _token == MINT:\n        POL(pol).mint(_amount)\n    elif _token == BURN:\n        POL(pol).burn(_amount)\n    else:\n        assert ERC20(_token).transferFrom(pol, self, _amount, default_return_value=True)\n    log FromPOL(_token, _amount)\n\n@external\ndef to_pol(_token: address, _amount: uint256):\n    \"\"\"\n    @notice Transfer `_amount` of `_token` to POL from this contract\n    @param _token \n        Token to transfer into POL.\n        Use special designated value to transfer ETH\n    @param _amount Amount of tokens to transfer\n    \"\"\"\n    assert msg.sender == self.operator\n    if _token == NATIVE:\n        POL(pol).receive_native(value=_amount)\n    else:\n        assert ERC20(_token).transfer(pol, _amount, default_return_value=True)\n    log ToPOL(_token, _amount)\n\n@external\ndef set_operator(_operator: address):\n    \"\"\"\n    @notice \n        Set the pending operator address.\n        Needs to be accepted by that account separately to transfer operator over\n    @param _operator New pending operator address\n    \"\"\"\n    assert msg.sender == self.operator or msg.sender == self.management\n    self.pending_operator = _operator\n    log PendingOperator(_operator)\n\n@external\ndef accept_operator():\n    \"\"\"\n    @notice \n        Accept operator role.\n        Can only be called by account previously marked as pending operator by current operator\n    \"\"\"\n    assert msg.sender == self.pending_operator\n    self.pending_operator = empty(address)\n    self.operator = msg.sender\n    log SetOperator(msg.sender)\n\n@external\ndef set_management(_management: address):\n    \"\"\"\n    @notice \n        Set the pending management address.\n        Needs to be accepted by that account separately to transfer management over\n    @param _management New pending management address\n    \"\"\"\n    assert msg.sender == self.management\n    self.pending_management = _management\n    log PendingManagement(_management)\n\n@external\ndef accept_management():\n    \"\"\"\n    @notice \n        Accept management role.\n        Can only be called by account previously marked as pending management by current management\n    \"\"\"\n    assert msg.sender == self.pending_management\n    self.pending_management = empty(address)\n    self.management = msg.sender\n    log SetManagement(msg.sender)\n\n# CURVE POOL FUNCTIONS\n\n@external\ndef set_pool(_pool: address):\n    \"\"\"\n    @notice Set Curve yETH/ETH pool\n    @param _pool Pool address\n    \"\"\"\n    assert msg.sender == self.management\n    self.pool = _pool\n    log SetAddress(0, _pool)\n\n@external\ndef approve_pool(_amount: uint256):\n    \"\"\"\n    @notice Approve Curve pool to transfer yETH\n    @param _amount Amount of tokens to approve\n    \"\"\"\n    assert msg.sender == self.operator\n    assert ERC20(token).approve(self.pool, _amount, default_return_value=True)\n\n@external\ndef add_liquidity(_amounts: uint256[2], _min_lp: uint256):\n    \"\"\"\n    @notice Add liquidity to the Curve pool\n    @param _amounts ETH and yETH amounts\n    @param _min_lp Minimum amount of LP tokens to receive\n    \"\"\"\n    assert msg.sender == self.operator\n    lp: uint256 = CurvePool(self.pool).add_liquidity(_amounts, _min_lp, pol, value=_amounts[0])\n    log AddLiquidity(_amounts, lp)\n\n@external\ndef remove_liquidity(_lp_amount: uint256, _min_amounts: uint256[2]):\n    \"\"\"\n    @notice Remove liquidity from the Curve pool\n    @param _lp_amount Amount of LP tokens to redeem\n    @param _min_amounts Minimum amounts of ETH and yETH to receive\n    \"\"\"\n    assert msg.sender == self.operator\n    amounts: uint256[2] = CurvePool(self.pool).remove_liquidity(_lp_amount, _min_amounts, pol)\n    log RemoveLiquidity(_lp_amount, amounts)\n\n@external\ndef remove_liquidity_imbalance(_amounts: uint256[2], _max_lp: uint256):\n    \"\"\"\n    @notice Remove liquidity from the Curve pool in an imbalanced way\n    @param _amounts Amounts of ETH and yETH to receive\n    @param _max_lp Maximum amount of LP tokens to redeem\n    \"\"\"\n    assert msg.sender == self.operator\n    lp: uint256 = CurvePool(self.pool).remove_liquidity_imbalance(_amounts, _max_lp, pol)\n    log RemoveLiquidity(lp, _amounts)\n\n# GAUGE FUNCTIONS\n\n@external\ndef set_gauge(_gauge: address):\n    \"\"\"\n    @notice Set Curve gauge address\n    @param _gauge Gauge address\n    \"\"\"\n    assert msg.sender == self.management\n    self.gauge = _gauge\n    log SetAddress(1, _gauge)\n\n@external\ndef approve_gauge(_amount: uint256):\n    \"\"\"\n    @notice Approve gauge to transfer yETH\n    @param _amount Amount of tokens to approve\n    \"\"\"\n    assert msg.sender == self.operator\n    assert self.gauge != empty(address)\n    assert ERC20(self.pool).approve(self.gauge, _amount, default_return_value=True)\n\n@external\ndef gauge_rewards_receiver():\n    \"\"\"\n    @notice Set POL as Curve gauge rewards receiver\n    \"\"\"\n    assert msg.sender == self.management\n    CurveGauge(self.gauge).set_rewards_receiver(pol)\n\n@external\ndef deposit_gauge(_amount: uint256):\n    \"\"\"\n    @notice Deposit LP tokens into gauge\n    @param _amount Amount of tokens to deposit\n    \"\"\"\n    assert msg.sender == self.operator\n    CurveGauge(self.gauge).deposit(_amount)\n    log Deposit(0, _amount, _amount)\n\n@external\ndef withdraw_gauge(_amount: uint256):\n    \"\"\"\n    @notice Withdraw LP tokens from gauge\n    @param _amount Amount of tokens to withdraw\n    \"\"\"\n    assert msg.sender == self.operator\n    CurveGauge(self.gauge).withdraw(_amount)\n    log Withdraw(0, _amount, _amount)\n    \n# CONVEX FUNCTIONS\n\n@external\ndef set_convex_booster(_booster: address):\n    \"\"\"\n    @notice Set Convex booster address\n    @param _booster Booster address\n    \"\"\"\n    assert msg.sender == self.management\n    self.convex_booster = _booster\n    log SetAddress(2, _booster)\n\n@external\ndef set_convex_pool_id(_pool_id: uint256):\n    \"\"\"\n    @notice Set pool id for yETH/ETH pool\n    @param _pool_id Pool id\n    \"\"\"\n    assert msg.sender == self.management\n    self.convex_pool_id = _pool_id\n\n@external\ndef set_convex_token(_token: address):\n    \"\"\"\n    @notice Set Convex pool token\n    @param _token Token address\n    \"\"\"\n    assert msg.sender == self.management\n    self.convex_token = _token\n    log SetAddress(3, _token)\n\n@external\ndef set_convex_rewards(_rewards: address):\n    \"\"\"\n    @notice Set Convex rewards address\n    @param _rewards Rewards address\n    \"\"\"\n    assert msg.sender == self.management\n    self.convex_rewards = _rewards\n    log SetAddress(4, _rewards)\n\n@external\ndef approve_convex_booster(_amount: uint256):\n    \"\"\"\n    @notice Approve Convex booster to transfer LP tokens\n    @param _amount Amount of tokens to approve\n    \"\"\"\n    assert msg.sender == self.operator\n    assert self.convex_booster != empty(address)\n    assert ERC20(self.pool).approve(self.convex_booster, _amount, default_return_value=True)\n\n@external\ndef deposit_convex_booster(_amount: uint256):\n    \"\"\"\n    @notice Deposit LP tokens into Convex\n    @param _amount Amount of tokens to deposit\n    \"\"\"\n    assert msg.sender == self.operator\n    assert self.convex_pool_id != 0\n    ConvexBooster(self.convex_booster).deposit(self.convex_pool_id, _amount, True)\n    log Deposit(1, _amount, _amount)\n\n@external\ndef withdraw_convex_booster(_amount: uint256):\n    \"\"\"\n    @notice Withdraw LP tokens from Convex\n    @param _amount Amount of tokens to withdraw\n    \"\"\"\n    assert msg.sender == self.operator\n    assert self.convex_pool_id != 0\n    ConvexBooster(self.convex_booster).withdraw(self.convex_pool_id, _amount)\n    log Withdraw(1, _amount, _amount)\n\n@external\ndef approve_convex_rewards(_amount: uint256):\n    \"\"\"\n    @notice Approve Convex rewards contract to transfer Convex LP tokens\n    @param _amount Amount of tokens to approve\n    \"\"\"\n    assert msg.sender == self.operator\n    assert self.convex_rewards != empty(address)\n    assert ERC20(self.convex_token).approve(self.convex_rewards, _amount, default_return_value=True)\n\n@external\ndef deposit_convex_rewards(_amount: uint256):\n    \"\"\"\n    @notice Deposit Convex LP tokens into rewards contract\n    @param _amount Amount of tokens to deposit\n    \"\"\"\n    assert msg.sender == self.operator\n    ConvexRewards(self.convex_rewards).stake(_amount)\n    log Deposit(2, _amount, _amount)\n\n@external\ndef withdraw_convex_rewards(_amount: uint256, _unwrap: bool):\n    \"\"\"\n    @notice Withdraw Convex LP tokens from rewards contract\n    @param _amount Amount of tokens to withdraw\n    @param _unwrap True to also withdraw from Convex booster, False otherwise\n    \"\"\"\n    assert msg.sender == self.operator\n    if _unwrap:\n        ConvexRewards(self.convex_rewards).withdrawAndUnwrap(_amount, True)\n        log Withdraw(1, _amount, _amount)\n    else:\n        ConvexRewards(self.convex_rewards).withdraw(_amount, True)\n    log Withdraw(2, _amount, _amount)\n\n# YVAULT FUNCTIONS\n\n@external\ndef set_yvault(_yvault: address):\n    \"\"\"\n    @notice Set yearn vault contract\n    @param _yvault Yearn vault address\n    \"\"\"\n    assert msg.sender == self.management\n    self.yvault = _yvault\n    log SetAddress(5, _yvault)\n\n@external\ndef approve_yvault(_amount: uint256):\n    \"\"\"\n    @notice Approve Yearn vault to transfer LP tokens\n    @param _amount Amount of tokens to approve\n    \"\"\"\n    assert msg.sender == self.operator\n    assert self.yvault != empty(address)\n    assert ERC20(self.pool).approve(self.yvault, _amount, default_return_value=True)\n\n@external\ndef deposit_yvault(_amount: uint256):\n    \"\"\"\n    @notice Deposit LP tokens into Yearn vault\n    @param _amount Amount of tokens to deposit\n    \"\"\"\n    assert msg.sender == self.operator\n    shares: uint256 = YVault(self.yvault).deposit(_amount)\n    log Deposit(3, _amount, shares)\n\n@external\ndef withdraw_yvault(_shares: uint256, _max_loss: uint256):\n    \"\"\"\n    @notice Withdraw LP tokens from Yearn vault\n    @param _amount Amount of tokens to withdraw\n    \"\"\"\n    assert msg.sender == self.operator\n    amount: uint256 = YVault(self.yvault).withdraw(_shares, self, _max_loss)\n    log Withdraw(3, _shares, amount)"
    },
    {
      "filename": "contracts/modules/CurveLP.vy",
      "content": "# @version 0.3.7\n\"\"\"\n@title Curve LP Module\n@author 0xkorin, Yearn Finance\n@license Copyright (c) Yearn Finance, 2023 - all rights reserved\n@notice\n    Module to manage the POL's yETH/ETH position.\n    Controlled by two roles: management and operator.\n    Operator can deposit/withdraw into Curve and subsequently into gauge/Convex/yVault.\n    Management can set relevant addresses\n\"\"\"\n\nfrom vyper.interfaces import ERC20\n\ninterface POL:\n    def receive_native(): payable\n    def send_native(_receiver: address, _amount: uint256): nonpayable\n    def mint(_amount: uint256): nonpayable\n    def burn(_amount: uint256): nonpayable\n\n# https://github.com/curvefi/curve-factory/blob/master/contracts/implementations/plain-2/Plain2ETHEMA.vy\ninterface CurvePool:\n    def add_liquidity(_amounts: uint256[2], _min_mint_amount: uint256, _receiver: address) -> uint256: payable\n    def remove_liquidity(_burn_amount: uint256, _min_amounts: uint256[2], _receiver: address) -> uint256[2]: nonpayable\n    def remove_liquidity_imbalance(_amounts: uint256[2], _max_burn_amount: uint256, _receiver: address) -> uint256: nonpayable\n\n# https://github.com/curvefi/curve-factory/blob/master/contracts/LiquidityGauge.vy\ninterface CurveGauge:\n    def set_rewards_receiver(_receiver: address): nonpayable\n    def deposit(_value: uint256): nonpayable\n    def withdraw(_value: uint256): nonpayable\n\n# https://github.com/convex-eth/platform/blob/main/contracts/contracts/Booster.sol\ninterface ConvexBooster:\n    def deposit(_pid: uint256, _amount: uint256, _stake: bool) -> bool: nonpayable\n    def withdraw(_pid: uint256, _amount: uint256) -> bool: nonpayable\n\n# https://github.com/convex-eth/platform/blob/main/contracts/contracts/BaseRewardPool.sol\ninterface ConvexRewards:\n    def stake(_amount: uint256): nonpayable\n    def withdraw(_amount: uint256, _claim: bool): nonpayable\n    def withdrawAndUnwrap(_amount: uint256, _claim: bool): nonpayable\n\n# https://github.com/yearn/yearn-vaults/blob/master/contracts/Vault.vy\ninterface YVault:\n    def deposit(_amount: uint256) -> uint256: nonpayable\n    def withdraw(_shares: uint256, _recipient: address, _max_loss: uint256) -> uint256: nonpayable\n\ntoken: public(immutable(address))\npol: public(immutable(address))\nmanagement: public(address)\npending_management: public(address)\noperator: public(address)\npending_operator: public(address)\npool: public(address)\ngauge: public(address)\nconvex_booster: public(address)\nconvex_pool_id: public(uint256)\nconvex_token: public(address)\nconvex_rewards: public(address)\nyvault: public(address)\n\nevent SetAddress:\n    index: indexed(uint256)\n    value: address\n\nevent PendingManagement:\n    management: indexed(address)\n\nevent SetManagement:\n    management: indexed(address)\n\nevent PendingOperator:\n    operator: indexed(address)\n\nevent SetOperator:\n    operator: indexed(address)\n\nevent FromPOL:\n    token: indexed(address)\n    amount: uint256\n\nevent ToPOL:\n    token: indexed(address)\n    amount: uint256\n\nevent AddLiquidity:\n    amounts_in: uint256[2]\n    amount_out: uint256\n\nevent RemoveLiquidity:\n    amount_in: uint256\n    amounts_out: uint256[2]\n\nevent Deposit:\n    pool: indexed(uint256)\n    amount_in: uint256\n    amount_out: uint256\n\nevent Withdraw:\n    pool: indexed(uint256)\n    amount_in: uint256\n    amount_out: uint256\n\nNATIVE: constant(address) = 0x0000000000000000000000000000000000000000\nMINT: constant(address)   = 0x0000000000000000000000000000000000000001\nBURN: constant(address)   = 0x0000000000000000000000000000000000000002\n\n@external\ndef __init__(_token: address, _pol: address):\n    \"\"\"\n    @notice Constructor\n    @param _token yETH token address\n    @param _pol POL address\n    \"\"\"\n    token = _token\n    pol = _pol\n    self.management = msg.sender\n    self.operator = msg.sender\n\n@external\n@payable\ndef __default__():\n    \"\"\"\n    @notice Receive ETH\n    \"\"\"\n    pass\n\n@external\ndef from_pol(_token: address, _amount: uint256):\n    \"\"\"\n    @notice Transfer `_amount` of `_token` from POL to this contract\n    @param _token \n        Token to transfer out of POL.\n        Use special designated values to mint/burn yETH or transfer ETH\n    @param _amount Amount of tokens to transfer\n    \"\"\"\n    assert msg.sender == self.operator\n    if _token == NATIVE:\n        POL(pol).send_native(self, _amount)\n    elif"
    }
  ]
}