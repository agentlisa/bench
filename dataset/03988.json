{
  "Title": "[L06] The relations between loops and their boundaries are not clear",
  "Content": "There are some occurrences in the codebase where `for` loops are used to iterate an entire array.\n\n\nThis is a [widely known problem in the Ethereum ecosystem](https://solidity.readthedocs.io/en/v0.5.3/security-considerations.html?highlight=loops#gas-limit-and-loops), as it is common that loops in Smart Contracts result in an out of gas error when the number of iterations that the loop needs to execute is too big.\n\n\n* In the [`getWhitelist` function](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/common/TransferWhitelist.sol#L71-L91) of the `TransferWhitelist` contract there are two loops iterating over the `whitelist` and the `registeredContracts` arrays correspondingly.\n* In the [`getAssetAllocationWeights` function](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/stability/Reserve.sol#L333-L343) of the `Reserve` contract, there is a `for` loop iterating over the `assetAllocationSymbols` array.\n\n\nConsider setting a hard cap on the number of iterations that the smart contracts should execute. Likewise, when the iteration limit is bounded by invariant properties in the code, consider enforcing that those properties are invariant. Finally, consider thoroughly reviewing the usage of `for` and `while` loops in the protocol and closely analyzing the effects of failures that may arise from the lack of limits in these loops.\n\n\n****Update:*** Not Fixed. [Issue #3420](https://github.com/celo-org/celo-monorepo/issues/3420) was created to keep track of this.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/TransferWhitelist.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"./UsingRegistry.sol\";\n\n/**\n * @title Holds a whitelist of addresses for which transfers should not be\n * frozen so that network initialization can take place.\n */\ncontract TransferWhitelist is Ownable, UsingRegistry {\n  using SafeMath for uint256;\n\n  address[] public whitelist;\n  bytes32[] public registeredContracts;\n\n  event WhitelistedAddress(address addr);\n  event WhitelistedRegistryId(bytes32 registryId);\n\n  constructor(address registryAddress) public {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n  }\n\n  /**\n   * @notice Add an address to the whitelist.\n   * @param newAddress The address to add.\n   */\n  function addAddress(address newAddress) external onlyOwner {\n    whitelist.push(newAddress);\n    emit WhitelistedAddress(newAddress);\n  }\n\n  /**\n   * @notice Adds the registry id of a whitelisted contract.\n   * @param registryId The id of the contract to be added.\n   */\n  function addRegisteredContract(bytes32 registryId) external onlyOwner {\n    require(\n      registry.getAddressFor(registryId) != address(0),\n      \"registryId does not corespond to a registered address\"\n    );\n    registeredContracts.push(registryId);\n    emit WhitelistedRegistryId(registryId);\n  }\n\n  /**\n   * @notice Gets the number of registered contracts\n   * @return The length of registeredContracts\n   */\n  function getRegisteredContractsLength() external view returns (uint256 length) {\n    return registeredContracts.length;\n  }\n\n  /**\n   * @notice Set the whitelist of addresses.\n   * @param  _whitelist The new whitelist of addresses.\n   */\n  function setWhitelist(address[] calldata _whitelist) external onlyOwner {\n    whitelist = _whitelist;\n  }\n\n  /**\n   * @notice Set the whitelist of registered contracts.\n   * @param  _registeredContracts The new whitelist of registered contract ids.\n   */\n  function setRegisteredContracts(bytes32[] calldata _registeredContracts) external onlyOwner {\n    registeredContracts = _registeredContracts;\n  }\n\n  /**\n   * @notice Appends the addresses of registered contracts to the\n   * whitelist before returning the list.\n   * @dev If a registry id is not yet registered, the null address\n   * will be appended to the list instead.\n   * @return  The full whitelist of addresses.\n   */\n  function getWhitelist() external view returns (address[] memory) {\n    uint256 len = whitelist.length.add(registeredContracts.length);\n    address[] memory _whitelist = new address[](len);\n    uint256 i = 0;\n    while (i < whitelist.length) {\n      _whitelist[i] = whitelist[i];\n      i = i.add(1);\n    }\n    for (uint256 j = 0; j < registeredContracts.length; j = j.add(1)) {\n      _whitelist[i] = registry.getAddressFor(registeredContracts[j]);\n      i = i.add(1);\n    }\n    return _whitelist;\n  }\n\n  /**\n   * @notice Clears all data (storage and bytecode) at this contract's address.\n   * @dev The balance of this contract is returned to the owner.\n   */\n  function selfDestruct() external onlyOwner {\n    selfdestruct(msg.sender);\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/stability/Reserve.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IReserve.sol\";\nimport \"./interfaces/ISortedOracles.sol\";\nimport \"./interfaces/IStableToken.sol\";\n\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\n/**\n * @title Ensures price stability of StableTokens with respect to their pegs\n */\ncontract Reserve is IReserve, Ownable, Initializable, UsingRegistry, ReentrancyGuard {\n  using SafeMath for uint256;\n  using FixidityLib for FixidityLib.Fraction;\n\n  struct TobinTaxCache {\n    uint128 numerator;\n    uint128 timestamp;\n  }\n\n  mapping(address => bool) public isToken;\n  address[] private _tokens;\n  TobinTaxCache public tobinTaxCache;\n  uint256 public tobinTaxStalenessThreshold;\n  uint256 public constant TOBIN_TAX_NUMERATOR = 5000000000000000000000; // 0.005\n  mapping(address => bool) public isSpender;\n\n  mapping(address => bool) public isOtherReserveAddress;\n  address[] public otherReserveAddresses;\n\n  bytes32[] public assetAllocationSymbols;\n  mapping(bytes32 => uint256) public assetAllocationWeights;\n\n  uint256 public lastSpendingDay;\n  uint256 public spendingLimit;\n  FixidityLib.Fraction private spendingRatio;\n\n  uint256 public frozenReserveGoldStartBalance;\n  uint256 public frozenReserveGoldStartDay;\n  uint256 public frozenReserveGoldDays;\n\n  event TobinTaxStalenessThresholdSet(uint256 value);\n  event DailySpendingRatioSet(uint256 ratio);\n  event TokenAdded(address indexed token);\n  event TokenRemoved(address indexed token, uint256 index);\n  event SpenderAdded(address indexed spender);\n  event SpenderRemoved(address indexed spender);\n  event OtherReserveAddressAdded(address indexed otherReserveAddress);\n  event OtherReserveAddressRemoved(address indexed otherReserveAddress, uint256 index);\n  event AssetAllocationSet(bytes32[] symbols, uint256[] weights);\n  event ReserveGoldTransferred(address indexed spender, address indexed to, uint256 value);\n\n  modifier isStableToken(address token) {\n    require(isToken[token], \"token addr was never registered\");\n    _;\n  }\n\n  function() external payable {} // solhint-disable no-empty-blocks\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   * @param _tobinTaxStalenessThreshold The initial number of seconds to cache tobin tax value for.\n   * @param _frozenGold The balance of reserve gold that is frozen.\n   * @param _frozenDays The number of days during which the frozen gold thaws.\n   */\n  function initialize(\n    address registryAddress,\n    uint256 _tobinTaxStalenessThreshold,\n    uint256 _spendingRatio,\n    uint256 _frozenGold,\n    uint256 _frozenDays,\n    bytes32[] calldata _assetAllocationSymbols,\n    uint256[] calldata _assetAllocationWeights\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setTobinTaxStalenessThreshold(_tobinTaxStalenessThreshold);\n    setDailySpendingRatio(_spendingRatio);\n    setFrozenGold(_frozenGold, _frozenDays);\n    setAssetAllocations(_assetAllocationSymbols, _assetAllocationWeights);\n  }\n\n  /**\n   * @notice Sets the number of seconds to cache the tobin tax value for.\n   * @param value The number of seconds to cache the tobin tax value for.\n   */\n  function setTobinTaxStalenessThreshold(uint256 value) public onlyOwner {\n    require(value > 0, \"value was zero\");\n    tobinTaxStalenessThreshold = value;\n    emit TobinTaxStalenessThresholdSet(value);\n  }\n\n  /**\n   * @notice Set the ratio of reserve that is spendable per day.\n   * @param ratio Spending ratio as unwrapped Fraction.\n   */\n  function setDailySpendingRatio(uint256 ratio) public onlyOwner {\n    spendingRatio = FixidityLib.wrap(ratio);\n    require(spendingRatio.lte(FixidityLib.fixed1()), \"spending ratio cannot be larger than 1\");\n    emit DailySpendingRatioSet(ratio);\n  }\n\n  /**\n   * @notice Get daily spending ratio.\n   * @return Spending ratio as unwrapped Fraction.\n   */\n  function getDailySpendingRatio() public view returns (uint256) {\n    return spendingRatio.unwrap();\n  }\n\n  /**\n   * @notice Sets the balance of reserve gold frozen from transfer.\n   * @param frozenGold The amount of cGLD frozen.\n   * @param frozenDays The number of days the frozen cGLD thaws over.\n   */\n  function setFrozenGold(uint256 frozenGold, uint256 frozenDays) public onlyOwner {\n    require(frozenGold <= address(this).balance);\n    frozenReserveGoldStartBalance = frozenGold;\n    frozenReserveGoldStartDay = now / 1 days;\n    frozenReserveGoldDays = frozenDays;\n  }\n\n  /**\n   * @notice Sets target allocations for Celo Gold and a diversified basket of non-Celo assets.\n   * @param symbols The symbol of each asset in the Reserve portfolio.\n   * @param weights The weight for the corresponding asset as unwrapped Fixidity.Fraction.\n   */\n  function setAssetAllocations(bytes32[] memory symbols, uint256[] memory weights)\n    public\n    onlyOwner\n  {\n    require(symbols.length == weights.length, \"Array length mismatch\");\n    FixidityLib.Fraction memory sum = FixidityLib.wrap(0);\n    for (uint256 i = 0; i < weights.length; i = i.add(1)) {\n      sum = sum.add(FixidityLib.wrap(weights[i]));\n    }\n    require(sum.equals(FixidityLib.fixed1()), \"Sum of asset allocation must be 1\");\n    for (uint256 i = 0; i < assetAllocationSymbols.length; i = i.add(1)) {\n      delete assetAllocationWeights[assetAllocationSymbols[i]];\n    }\n    assetAllocationSymbols = symbols;\n    for (uint256 i = 0; i < symbols.length; i = i.add(1)) {\n      require(assetAllocationWeights[symbols[i]] == 0, \"Cannot set weight twice\");\n      assetAllocationWeights[symbols[i]] = weights[i];\n    }\n    require(assetAllocationWeights[\"cGLD\"] != 0, \"Must set cGLD asset weight\");\n    emit AssetAllocationSet(symbols, weights);\n  }\n\n  /**\n   * @notice Add a token that the reserve will stabilize.\n   * @param token The address of the token being stabilized.\n   * @return Returns true if the transaction succeeds.\n   */\n  function addToken(address token) external onlyOwner nonReentrant returns (bool) {\n    require(!isToken[token], \"token addr already registered\");\n    // Require an exchange rate between the new token and Gold exists.\n    address sortedOraclesAddress = registry.getAddressForOrDie(SORTED_ORACLES_REGISTRY_ID);\n    ISortedOracles sortedOracles = ISortedOracles(sortedOraclesAddress);\n    uint256 tokenAmount;\n    uint256 goldAmount;\n    (tokenAmount, goldAmount) = sortedOracles.medianRate(token);\n    require(goldAmount > 0, \"median rate returned 0 gold\");\n    isToken[token] = true;\n    _tokens.push(token);\n    emit TokenAdded(token);\n    return true;\n  }\n\n  /**\n   * @notice Remove a token that the reserve will no longer stabilize.\n   * @param token The address of the token no longer being stabilized.\n   * @param index The index of the token in _tokens.\n   * @return Returns true if the transaction succeeds.\n   */\n  function removeToken(address token, uint256 index)\n    external\n    onlyOwner\n    isStableToken(token)\n    returns (bool)\n  {\n    require(\n      index < _tokens.length && _tokens[index] == token,\n      \"index into tokens list not mapped to token\"\n    );\n    isToken[token] = false;\n    address lastItem = _tokens[_tokens.length.sub(1)];\n    _tokens[index] = lastItem;\n    _tokens.length = _tokens.length.sub(1);\n    emit TokenRemoved(token, index);\n    return true;\n  }\n\n  /**\n   * @notice Add a reserve address whose balance shall be included in the reserve ratio.\n   * @param reserveAddress The reserve address to add.\n   * @return Returns true if the transaction succeeds.\n   */\n  function addOtherReserveAddress(address reserveAddress)\n    external\n    onlyOwner\n    nonReentrant\n    returns (bool)\n  {\n    require(!isOtherReserveAddress[reserveAddress], \"reserve addr already added\");\n    isOtherReserveAddress[reserveAddress] = true;\n    otherReserveAddresses.push(reserveAddress);\n    emit OtherReserveAddressAdded(reserveAddress);\n    return true;\n  }\n\n  /**\n   * @notice Remove reserve address whose balance shall no longer be included in the reserve ratio.\n   * @param reserveAddress The reserve address to remove.\n   * @param index The index of the reserve address in otherReserveAddresses.\n   * @return Returns true if the transaction succeeds.\n   */\n  function removeOtherReserveAddress(address reserveAddress, uint256 index)\n    external\n    onlyOwner\n    returns (bool)\n  {\n    require(isOtherReserveAddress[reserveAddress], \"reserve addr was never added\");\n    require(\n      index < otherReserveAddresses.length && otherReserveAddresses[index] == reserveAddress,\n      \"index into reserve list not mapped to address\"\n    );\n    isOtherReserveAddress[reserveAddress] = false;\n    address lastItem = otherReserveAddresses[otherReserveAddresses.length.sub(1)];\n    otherReserveAddresses[index] = lastItem;\n    otherReserveAddresses.length = otherReserveAddresses.length.sub(1);\n    emit OtherReserveAddressRemoved(reserveAddress, index);\n    return true;\n  }\n\n  /**\n   * @notice Gives an address permission to spend Reserve funds.\n   * @param spender The address that is allowed to spend Reserve funds.\n   */\n  function addSpender(address spender) external onlyOwner {\n    isSpender[spender] = true;\n    emit SpenderAdded(spender);\n  }\n\n  /**\n   * @notice Takes away an address's permission to spend Reserve funds.\n   * @param spender The address that is to be no longer allowed to spend Reserve funds.\n   */\n  function removeSpender(address spender) external onlyOwner {\n    isSpender[spender] = false;\n    emit SpenderRemoved(spender);\n  }\n\n  /**\n   * @notice Transfer gold.\n   * @param to The address that will receive the gold.\n   * @param value The amount of gold to transfer.\n   * @return Returns true if the transaction succeeds.\n   */\n  function transferGold(address payable to, uint256 value) external returns (bool) {\n    require(isSpender[msg.sender], \"sender not allowed to transfer Reserve funds\");\n    require(isOtherReserveAddress[to], \"can only transfer to other reserve address\");\n    return _transferGold(to, value);\n  }\n\n  function _transferGold(address payable to, uint256 value) internal returns (bool) {\n    require(value <= getUnfrozenBalance(), \"Exceeding unfrozen reserves\");\n    uint256 currentDay = now / 1 days;\n    if (currentDay > lastSpendingDay) {\n      uint256 balance = getUnfrozenReserveGoldBalance();\n      lastSpendingDay = currentDay;\n      spendingLimit = spendingRatio.multiply(FixidityLib.newFixed(balance)).fromFixed();\n    }\n    require(spendingLimit >= value, \"Exceeding spending limit\");\n    spendingLimit = spendingLimit.sub(value);\n    to.transfer(value);\n    emit ReserveGoldTransferred(msg.sender, to, value);\n    return true;\n  }\n\n  function transferExchangeGold(address payable to, uint256 value)\n    external\n    onlyRegisteredContract(EXCHANGE_REGISTRY_ID)\n    returns (bool)\n  {\n    return _transferGold(to, value);\n  }\n\n  /**\n   * @notice Returns the tobin tax, recomputing it if it's stale.\n   * @return The tobin tax amount as a fraction.\n   */\n  function getOrComputeTobinTax() external nonReentrant returns (uint256, uint256) {\n    // solhint-disable-next-line not-rely-on-time\n    if (now.sub(tobinTaxCache.timestamp) > tobinTaxStalenessThreshold) {\n      tobinTaxCache.numerator = uint128(computeTobinTax().unwrap());\n      tobinTaxCache.timestamp = uint128(now); // solhint-disable-line not-rely-on-time\n    }\n    return (uint256(tobinTaxCache.numerator), FixidityLib.fixed1().unwrap());\n  }\n\n  /**\n   * @notice Returns the list of stabilized token addresses.\n   * @return An array of addresses of stabilized tokens.\n   */\n  function getTokens() external view returns (address[] memory) {\n    return _tokens;\n  }\n\n  /**\n   * @notice Returns the list other addresses included in the reserve total.\n   * @return An array of other addresses included in the reserve total.\n   */\n  function getOtherReserveAddresses() external view returns (address[] memory) {\n    return otherReserveAddresses;\n  }\n\n  /**\n   * @notice Returns a list of token symbols that have been allocated.\n   * @return An array of token symbols that have been allocated.\n   */\n  function getAssetAllocationSymbols() external view returns (bytes32[] memory) {\n    return assetAllocationSymbols;\n  }\n\n  /**\n   * @notice Returns a list of weights used for the allocation of reserve assets.\n   * @return An array of a list of weights used for the allocation of reserve assets.\n   */\n  function getAssetAllocationWeights() external view returns (uint256[] memory) {\n    uint256[] memory weights = new uint256[](assetAllocationSymbols.length);\n    for (uint256 i = 0; i < assetAllocationSymbols.length; i = i.add(1)) {\n      weights[i] = assetAllocationWeights[assetAllocationSymbols[i]];\n    }\n    return weights;\n  }\n\n  /**\n   * @notice Returns the amount of unfrozen Celo Gold in the reserve.\n   * @return The total unfrozen Celo Gold in the reserve.\n   */\n  function getUnfrozenBalance() public view returns (uint256) {\n    uint256 balance = address(this).balance;\n    uint256 frozenReserveGold = getFrozenReserveGoldBalance();\n    return balance > frozenReserveGold ? balance.sub(frozenReserveGold) : 0;\n  }\n\n  /**\n   * @notice Returns the amount of Celo Gold included in the reserve.\n   * @return The Celo Gold amount included in the reserve.\n   */\n  function getReserveGoldBalance() public view returns (uint256) {\n    return address(this).balance.add(getOtherReserveAddressesGoldBalance());\n  }\n\n  /**\n   * @notice Returns the amount of Celo Gold included in other reserve addresses.\n   * @return The Celo Gold amount included in other reserve addresses.\n   */\n  function getOtherReserveAddressesGoldBalance() public view returns (uint256) {\n    uint256 reserveGoldBalance = 0;\n    for (uint256 i = 0; i < otherReserveAddresses.length; i = i.add(1)) {\n      reserveGoldBalance = reserveGoldBalance.add(otherReserveAddresses[i].balance);\n    }\n    return reserveGoldBalance;\n  }\n\n  /**\n   * @notice Returns the amount of unfrozen Celo Gold included in the reserve.\n   * @return The unfrozen Celo Gold amount included in the reserve.\n   */\n  function getUnfrozenReserveGoldBalance() public view returns (uint256) {\n    return getUnfrozenBalance().add(getOtherReserveAddressesGoldBalance());\n  }\n\n  /**\n   * @notice Returns the amount of frozen Celo Gold in the reserve.\n   * @return The total frozen Celo Gold in the reserve.\n   */\n  function getFrozenReserveGoldBalance() public view returns (uint256) {\n    uint256 currentDay = now / 1 days;\n    uint256 frozenDays = currentDay.sub(frozenReserveGoldStartDay);\n    if (frozenDays >= frozenReserveGoldDays) return 0;\n    return\n      frozenReserveGoldStartBalance.sub(\n        frozenReserveGoldStartBalance.mul(frozenDays).div(frozenReserveGoldDays)\n      );\n  }\n\n  /**\n   * @notice Computes the ratio of current reserve balance to total stable token valuation.\n   * @return Reserve ratio in a fixed point format.\n   */\n  function getReserveRatio() public view returns (uint256) {\n    address sortedOraclesAddress = registry.getAddressForOrDie(SORTED_ORACLES_REGISTRY_ID);\n    ISortedOracles sortedOracles = ISortedOracles(sortedOraclesAddress);\n    uint256 reserveGoldBalance = getUnfrozenReserveGoldBalance();\n    uint256 stableTokensValueInGold = 0;\n    FixidityLib.Fraction memory cgldWeight = FixidityLib.wrap(assetAllocationWeights[\"cGLD\"]);\n\n    for (uint256 i = 0; i < _tokens.length; i = i.add(1)) {\n      uint256 stableAmount;\n      uint256 goldAmount;\n      (stableAmount, goldAmount) = sortedOracles.medianRate(_tokens[i]);\n      uint256 stableTokenSupply = IERC20(_tokens[i]).totalSupply();\n      uint256 aStableTokenValueInGold = stableTokenSupply.mul(goldAmount).div(stableAmount);\n      stableTokensValueInGold = stableTokensValueInGold.add(aStableTokenValueInGold);\n    }\n    return\n      FixidityLib\n        .newFixed(reserveGoldBalance)\n        .divide(cgldWeight)\n        .divide(FixidityLib.newFixed(stableTokensValueInGold))\n        .unwrap();\n  }\n\n  /*\n   * Internal functions\n   */\n\n  /**\n   * @notice Computes a tobin tax based on the reserve ratio.\n   * @return The numerator of the tobin tax amount, where the denominator is 1000.\n   */\n  function computeTobinTax() private view returns (FixidityLib.Fraction memory) {\n    // The protocol calls for a 0.5% transfer tax on Celo Gold when the reserve ratio < 2.\n    FixidityLib.Fraction memory ratio = FixidityLib.wrap(getReserveRatio());\n    if (ratio.gte(FixidityLib.newFixed(2))) {\n      return FixidityLib.wrap(0);\n    } else {\n      return FixidityLib.wrap(TOBIN_TAX_NUMERATOR);\n    }\n  }\n}"
    }
  ]
}