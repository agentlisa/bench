{
  "Title": "M-14: Attackers Can DOS Balancer Vaults By Bypassing The BPT Threshold",
  "Content": "# Issue M-14: Attackers Can DOS Balancer Vaults By Bypassing The BPT Threshold \n\nSource: https://github.com/sherlock-audit/2022-09-notional-judging/issues/66 \n\n## Found by \nxiaoming90\n\n## Summary\n\nMalicious users can lock up all the leverage vaults offered by Notional causing denial-of-service by bypassing the BPT threshold and subseqently trigger an emergency settlement against the vaults.\n\n## Vulnerability Detail\n\nThe current BPT threshold is set to 20% of the total BTP supply based on the environment file provided during the audit.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/scripts/BalancerEnvironment.py#L41\n\n```solidity\nFile: BalancerEnvironment.py\n40:             \"oracleWindowInSeconds\": 3600,\n41:             \"maxBalancerPoolShare\": 2e3, # 20%\n42:             \"settlementSlippageLimitPercent\": 5e6, # 5%\n```\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/BalancerVaultStorage.sol#L60\n\n```solidity\nFile: BalancerVaultStorage.sol\n60:     function _bptThreshold(StrategyVaultSettings memory strategyVaultSettings, uint256 totalBPTSupply) \n61:         internal pure returns (uint256) {\n62:         return (totalBPTSupply * strategyVaultSettings.maxBalancerPoolShare) / BalancerConstants.VAULT_PERCENT_BASIS;\n63:     }\n```\n\nWhen the total number of BPT owned by the vault exceeds the BPT threshold, no one will be able to enter the vault as per the require check at Line 295-296 within the `TwoTokenPoolUtils._joinPoolAndStake` function.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol#L268\n\n```solidity\nFile: TwoTokenPoolUtils.sol\n268:     function _joinPoolAndStake(\n269:         TwoTokenPoolContext memory poolContext,\n270:         StrategyContext memory strategyContext,\n271:         AuraStakingContext memory stakingContext,\n272:         uint256 primaryAmount,\n273:         uint256 secondaryAmount,\n274:         uint256 minBPT\n275:     ) internal returns (uint256 bptMinted) {\n276:         // prettier-ignore\n277:         PoolParams memory poolParams = poolContext._getPoolParams( \n278:             primaryAmount, \n279:             secondaryAmount,\n280:             true // isJoin\n281:         );\n282: \n283:         bptMinted = BalancerUtils._joinPoolExactTokensIn({\n284:             context: poolContext.basePool,\n285:             params: poolParams,\n286:             minBPT: minBPT\n287:         });\n288: \n289:         // Check BPT threshold to make sure our share of the pool is\n290:         // below maxBalancerPoolShare\n291:         uint256 bptThreshold = strategyContext.vaultSettings._bptThreshold(\n292:             poolContext.basePool.pool.totalSupply()\n293:         );\n294:         uint256 bptHeldAfterJoin = strategyContext.totalBPTHeld + bptMinted;\n295:         if (bptHeldAfterJoin > bptThreshold)\n296:             revert Errors.BalancerPoolShareTooHigh(bptHeldAfterJoin, bptThreshold);\n297: \n298:         // Transfer token to Aura protocol for boosted staking\n299:         stakingContext.auraBooster.deposit(stakingContext.auraPoolId, bptMinted, true); // stake = true\n300:     }\n```\n\nAnother key point that is critical for this issue is that when the total number of BPT owned by the vault exceeds the BPT threshold, an emergency settlement can be triggered against the vault and anyone can triggered it as it is permissionless. A major side-effect of an emergency settlement is that the vault will be locked up after the emergency settlement. No one is allowed to enter the vault and users are only allowed to exit from the vault by taking their proportional share of cash and strategy tokens. The reason is that after the emergency settlement, there will be some asset cash balance in the vault and this will cause no one to be able to enter the vault due to the require check at Line 218. This side-effect has been verified by reviewing the codebase and clarifying with the sponsors.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/contracts-v2/contracts/internal/vaults/VaultState.sol#L207\n\n```solidity\nFile: VaultState.sol\n207:     function enterMaturity(\n208:         VaultState memory vaultState,\n209:         VaultAccount memory vaultAccount,\n210:         VaultConfig memory vaultConfig,\n211:         uint256 strategyTokenDeposit,\n212:         uint256 additionalUnderlyingExternal,\n213:         bytes calldata vaultData\n214:     ) internal returns (uint256 strategyTokensAdded) {\n215:         // If the vault state is holding asset cash this would mean that there is some sort of emergency de-risking\n216:         // event or the vault is in the process of settling debts. In both cases, we do not allow accounts to enter\n217:         // the vault.\n218:         require(vaultState.totalAssetCash == 0);\n```\n\nIf an attacker could force an emergency settlement on a vault anytime, he would be able to perform a DOS on the vault since the vault will basically be locked up after it. The following demonstrates how this can be performed:\n\n1) Assume that the total supply of BTP in the WETH/stETH Balancer Pool is 100,000 Therefore, the BPT threshold of the vault will be 20,000.\n2) Assume that the total number of BPT held by the vault is 19,900. \n3) Note that under normal circumstances, it is not possible for the users to exceed the BPT threshold because the transaction will revert if the `bptHeldAfterJoin > bptThreshold` after the user enters the vault.\n4) Note that at this point, the emergency settlement CANNOT be triggered against the vault because the vault has not exceeded BPT threshold yet\n5) Bob (attacker) flash-loans a large amount of ETH from dydx where the fee is almost non-existence (1 Wei Only)\n6) Bob allocates a portion of his ETH to join the WETH/stETH Balancer Pool. This will cause the total supply of BPT to increase significantly to 200,000.\n7) Bob allocates a portion of his ETH to enter the vault and causes the total number of BPT held by the vault to increase by 150 from 19,900 to 20,050. This is allowed because the total supply of BPT has increased to 200,000, and thus the BPT threshold has increased to 40,000. Also, Bob does not leverage himself and does not borrow from Notional since the flash loan already provided him with access to a large number of funds, and thus he does not need to pay for any borrowing cost to minimize the cost of this attack.\n8) At this point, due to the inflow of 150 BPT to the Balancer Pool, the total supply of BPT increase from 200,000 to 200,150.\n9) After entering the vault, Bob exits the WETH/stETH Balancer Pool entirely with all his 100,000 BPT position. This will cause the total supply of BPT to fall back to 100,150. Per my research, there is no exit fee when a Liquidity Provider exits a pool. Also, a Liquidity Provider only suffers a loss due to impermanent loss. However, since all these steps are executed within the same transaction, there is no impermanent loss because no one perform any token swap. Thus, there is no cost incurred by Bob for this step.\n10) Note that at this point, the emergency settlement CAN be triggered against the vault because the vault has exceeded the BPT threshold. The total number of BPT held by the vault is 20,050, and the BPT threshold is 20,030 (=100,150 * 0.2).\n11) Anyone can trigger the emergency settlement as it is permissionless. Bob triggered an emergency settlement against the vault, and 20 BPT will be sold off in the market so that the vault will not exceed the BPT threshold. It is important to ensure that the number of BPTs to be sold is kept as low as possible so that the total value of the vault will not be reduced by slippage during the trade. This is because Bob still owns the shares of the vault and he wants to get back as much of his original deposit as possible later. This value can be optimized further with Math.\n12) As mentioned earlier, after an emergency settlement, the vault will be locked up.  No one is allowed to enter the vault and users are only allowed to exit from the vault by taking their proportional share of cash and strategy tokens.\n13) Bob proceeds to redeem all his shares from the vault. He will get back all of his deposits minus the 20 BPT slippage loss during the emergency settlement that is split proportionally among all vault shareholders which is insignificant. Note that the Notional's leverage vault does not impose any exit fee.\n14) Bob proceeds to repay back his loan and pay 1 wei as the fee to dydx.\n15) The cost of attack is 1 wei (flash-loan fee) + 20 BPT slippage loss during the emergency settlement that is split proportionally among all vault shareholders, which is insignificant. The slippage loss during emergency settlement can be minimized by causing the total number of BPT held by the vault to exceed the BPT threshold by the smallest possible value.\n16) All the above steps will be executed within a single block/transaction.\n\n## Impact\n\nMalicious users can lock up all the leverage vaults offered by Notional causing denial-of-service. This results in a loss of funds for the protocol as the vault is no longer generating profit for the protocol, and also a loss of funds for vault users as they cannot realize the profits because they are forced to exit the vault prematurely.\n\nThe following are various reasons why someone would want to perform a DOS on Notional vaults:\n\n- Damage the reputation of Notional, and reduce users' trust in Notional\n- A competitor who is also offering a leverage vault attempts to bring down Notional\n- Someone who shorted Notional's protocol token\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/scripts/BalancerEnvironment.py#L41\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/BalancerVaultStorage.sol#L60\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol#L268\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/contracts-v2/contracts/internal/vaults/VaultState.sol#L207\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nShort term, consider the following measures to mitigate the issue:\n\n- The emergency settlement function is permissionless and can be called by anyone. It is recommended to implement access control to ensure that this function can only be triggered by Notional.\n- There is no withdrawal fee. Also, there is no deposit fee as long as users did not borrow from Notional. Therefore, this attack is mostly profitable. It is recommended to impose a fee on the users of the vault even if the users did not borrow from Notional. All users should be charged a fee for the use of the vault. This will make the attack less likely to be profitable in most cases.\n- Users can enter and exit the vault within the same transaction/block. This allows the attacker to leverage the flash-loan facility to reduce the cost of the attack to almost nothing. It is recommended to prevent users from entering and exiting the vault within the same transaction/block. If the user entered the vault in this block, he/she could only exit at the next block.\n\nLong term, update the implementation of the vault so that the vault will not be locked up after an emergency settlement. After selling off the excess BPT, the vault should allow users to enter the vault as per normal.\n\n## Discussion\n\n**jeffywu**\n\nThis is an interesting attack, we will think about the recommendations a bit. Since there is no loss of funds I'm not sure if this should be categorized as high. If this did happen, the most likely thing we would do is to upgrade the vault such that it could re-deposit its assets back into the Balancer vault which would mitigate the effects of the DOS altogether.\n\n**T-Woodward**\n\nYeah I agree with Jeff that this shouldn't be high severity because it's really more a way that an unscrupulous competitor could sabotage Notional, it wouldn't threaten user funds. I would call it medium.\n\nWe are making some changes here: \n\n1. We're permissioning the emergency settle function.\n2. We're implementing a minimum leverage ratio so that you can't enter/exit without paying the fees associated with borrowing and lending on Notional.\n\nThat should do it\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/2",
  "Code": [
    {
      "filename": "leveraged-vaults/scripts/BalancerEnvironment.py",
      "content": "import eth_abi\nfrom brownie import (\n    network, \n    nProxy,\n    MetaStable2TokenAuraVault,\n    Boosted3TokenAuraVault,\n    Boosted3TokenAuraHelper,\n    MetaStable2TokenAuraHelper\n)\nfrom brownie.network.contract import Contract\nfrom brownie.convert.datatypes import Wei\nfrom brownie.network.state import Chain\nfrom brownie.convert import to_bytes\nfrom scripts.common import deployArtifact, get_vault_config, set_flags\nfrom scripts.EnvironmentConfig import Environment\nfrom eth_utils import keccak\n\nchain = Chain()\nETH_ADDRESS = \"0x0000000000000000000000000000000000000000\"\n\nStrategyConfig = {\n    \"balancer2TokenStrats\": {\n        \"StratStableETHstETH\": {\n            \"vaultConfig\": get_vault_config(\n                flags=set_flags(0, ENABLED=True, ALLOW_ROLL_POSITION=True),\n                currencyId=1,\n                minAccountBorrowSize=1,\n                maxBorrowMarketIndex=3,\n                secondaryBorrowCurrencies=[0,0]\n            ),\n            \"secondaryBorrowCurrency\": None,\n            \"maxPrimaryBorrowCapacity\": 100_000_000e8,\n            \"name\": \"Balancer Stable ETH-stETH Strategy\",\n            \"primaryCurrency\": 1, # ETH\n            \"poolId\": \"0x32296969ef14eb0c6d29669c550d4a0449130230000200000000000000000080\",\n            \"liquidityGauge\": \"0xcd4722b7c24c29e0413bdcd9e51404b4539d14ae\",\n            \"auraRewardPool\": \"0xdcee1c640cc270121faf145f231fd8ff1d8d5cd4\",\n            \"feeReceiver\": \"0x0190702d5e52e0269c9319144d3ad62a60ebe526\",\n            \"maxUnderlyingSurplus\": 100e18, # 10 ETH\n            \"oracleWindowInSeconds\": 3600,\n            \"maxBalancerPoolShare\": 2e3, # 20%\n            \"settlementSlippageLimitPercent\": 5e6, # 5%\n            \"postMaturitySettlementSlippageLimitPercent\": 10e6, # 10%\n            \"emergencySettlementSlippageLimitPercent\": 10e6, # 10%\n            \"maxRewardTradeSlippageLimitPercent\": 5e6,\n            \"balancerOracleWeight\": 0.6e4, # 60%\n            \"settlementCoolDownInMinutes\": 60 * 6, # 6 hour settlement cooldown\n            \"postMaturitySettlementCoolDownInMinutes\": 60 * 6, # 6 hour settlement cooldown\n            \"feePercentage\": 1e2, # 1%\n            \"settlementWindow\": 3600 * 24 * 7,  # 1-week settlement\n            \"oraclePriceDeviationLimitPercent\": 500, # +/- 5%\n            \"balancerPoolSlippageLimitPercent\": 9900, # 1%\n        },\n        \"StratBoostedPoolDAIPrimary\": {\n            \"vaultConfig\": get_vault_config(\n                flags=set_flags(0, ENABLED=True, ALLOW_ROLL_POSITION=True),\n                currencyId=2,\n                minAccountBorrowSize=1,\n                maxBorrowMarketIndex=3,\n                secondaryBorrowCurrencies=[0,0]\n            ),\n            \"secondaryBorrowCurrency\": None,\n            \"maxPrimaryBorrowCapacity\": 100_000_000e8,\n            \"name\": \"Balancer Boosted Pool Strategy\",\n            \"primaryCurrency\": 2, # DAI\n            \"poolId\": \"0x7b50775383d3d6f0215a8f290f2c9e2eebbeceb20000000000000000000000fe\",\n            \"liquidityGauge\": \"0x68d019f64a7aa97e2d4e7363aee42251d08124fb\",\n            \"auraRewardPool\": \"0xcc2f52b57247f2bc58fec182b9a60dac5963d010\",\n            \"feeReceiver\": \"0x0190702d5e52e0269c9319144d3ad62a60ebe526\",\n            \"maxUnderlyingSurplus\": 10000e18, # 10000 DAI\n            \"oracleWindowInSeconds\": 0,\n            \"maxBalancerPoolShare\": 2e3, # 20%\n            \"settlementSlippageLimitPercent\": 5e6, # 5%\n            \"postMaturitySettlementSlippageLimitPercent\": 10e6, # 10%\n            \"emergencySettlementSlippageLimitPercent\": 10e6, # 10%\n            \"maxRewardTradeSlippageLimitPercent\": 5e6,\n            \"balancerOracleWeight\": 0,\n            \"settlementCoolDownInMinutes\": 60 * 6, # 6 hour settlement cooldown\n            \"postMaturitySettlementCoolDownInMinutes\": 60 * 6, # 6 hour settlement cooldown\n            \"feePercentage\": 1e2, # 1%\n            \"settlementWindow\": 3600 * 24 * 7,  # 1-week settlement\n            \"oraclePriceDeviationLimitPercent\": 50, # +/- 0.5%\n            \"balancerPoolSlippageLimitPercent\": 9900, # 1%\n        },\n        \"StratBoostedPoolUSDCPrimary\": {\n            \"vaultConfig\": get_vault_config(\n                flags=set_flags(0, ENABLED=True, ALLOW_ROLL_POSITION=True),\n                currencyId=3,\n                minAccountBorrowSize=1,\n                maxBorrowMarketIndex=3,\n                secondaryBorrowCurrencies=[0,0]\n            ),\n            \"secondaryBorrowCurrency\": None,\n            \"maxPrimaryBorrowCapacity\": 100_000_000e8,\n            \"name\": \"Balancer Boosted Pool Strategy\",\n            \"primaryCurrency\": 3, # USDC\n            \"poolId\": \"0x7b50775383d3d6f0215a8f290f2c9e2eebbeceb20000000000000000000000fe\",\n            \"liquidityGauge\": \"0x68d019f64a7aa97e2d4e7363aee42251d08124fb\",\n            \"auraRewardPool\": \"0xcc2f52b57247f2bc58fec182b9a60dac5963d010\",\n            \"feeReceiver\": \"0x0190702d5e52e0269c9319144d3ad62a60ebe526\",\n            \"maxUnderlyingSurplus\": 10000e6, # 10000 USDC\n            \"oracleWindowInSeconds\": 0,\n            \"maxBalancerPoolShare\": 2e3, # 20%\n            \"settlementSlippageLimitPercent\": 5e6, # 5%\n            \"postMaturitySettlementSlippageLimitPercent\": 10e6, # 10%\n            \"emergencySettlementSlippageLimitPercent\": 10e6, # 10%\n            \"maxRewardTradeSlippageLimitPercent\": 5e6,\n            \"balancerOracleWeight\": 0,\n            \"settlementCoolDownInMinutes\": 60 * 6, # 6 hour settlement cooldown\n            \"postMaturitySettlementCoolDownInMinutes\": 60 * 6, # 6 hour settlement cooldown\n            \"feePercentage\": 1e2, # 1%\n            \"settlementWindow\": 3600 * 24 * 7,  # 1-week settlement\n            \"oraclePriceDeviationLimitPercent\": 50, # +/- 0.5%\n            \"balancerPoolSlippageLimitPercent\": 9900, # 1%\n        }\n    }\n}\n\nclass BalancerEnvironment(Environment):\n    def __init__(self, network) -> None:\n        Environment.__init__(self, network)\n\n    def deployBalancerVault(self, strat, vaultContract, libs=None):\n        stratConfig = StrategyConfig[\"balancer2TokenStrats\"][strat]\n\n        # Deploy external libs\n        if libs != None:\n            for lib in libs:\n                lib.deploy({\"from\": self.deployer})\n\n        impl = vaultContract.deploy(\n            self.addresses[\"notional\"],\n            [\n                stratConfig[\"auraRewardPool\"],\n                [\n                    stratConfig[\"primaryCurrency\"],\n                    stratConfig[\"poolId\"],\n                    stratConfig[\"liquidityGauge\"],\n                    self.tradingModule.address,\n                    stratConfig[\"settlementWindow\"],\n                    stratConfig[\"feeReceiver\"]\n                ]\n            ],\n            {\"from\": self.deployer}\n        )\n\n        proxy = nProxy.deploy(impl.address, bytes(0), {\"from\": self.deployer})\n        vaultProxy = Contract.from_abi(stratConfig[\"name\"], proxy.address, vaultContract.abi)\n\n        print(\n            vaultProxy.initialize.encode_input(\n                [\n                    stratConfig[\"name\"],\n                    stratConfig[\"primaryCurrency\"],\n                    [\n                        stratConfig[\"maxUnderlyingSurplus\"],\n                        stratConfig[\"oracleWindowInSeconds\"],\n                        stratConfig[\"settlementSlippageLimitPercent\"], \n                        stratConfig[\"postMaturitySettlementSlippageLimitPercent\"], \n                        stratConfig[\"emergencySettlementSlippageLimitPercent\"], \n                        stratConfig[\"maxRewardTradeSlippageLimitPercent\"],\n                        stratConfig[\"maxBalancerPoolShare\"],\n                        stratConfig[\"balancerOracleWeight\"],\n                        stratConfig[\"settlementCoolDownInMinutes\"],\n                        stratConfig[\"postMaturitySettlementCoolDownInMinutes\"],\n                        stratConfig[\"feePercentage\"],\n                        stratConfig[\"oraclePriceDeviationLimitPercent\"],\n                        stratConfig[\"balancerPoolSlippageLimitPercent\"]\n                    ]\n                ]\n            )\n        )\n\n        vaultProxy.initialize(\n            [\n                stratConfig[\"name\"],\n                stratConfig[\"primaryCurrency\"],\n                [\n                    stratConfig[\"maxUnderlyingSurplus\"],\n                    stratConfig[\"oracleWindowInSeconds\"],\n                    stratConfig[\"settlementSlippageLimitPercent\"], \n                    stratConfig[\"postMaturitySettlementSlippageLimitPercent\"], \n                    stratConfig[\"emergencySettlementSlippageLimitPercent\"], \n                    stratConfig[\"maxRewardTradeSlippageLimitPercent\"],\n                    stratConfig[\"maxBalancerPoolShare\"],\n                    stratConfig[\"balancerOracleWeight\"],\n                    stratConfig[\"settlementCoolDownInMinutes\"],\n                    stratConfig[\"postMaturitySettlementCoolDownInMinutes\"],\n                    stratConfig[\"feePercentage\"],\n                    stratConfig[\"oraclePriceDeviationLimitPercent\"],\n                    stratConfig[\"balancerPoolSlippageLimitPercent\"]\n                ]\n            ],\n            {\"from\": self.notional.owner()}\n        )\n\n        self.notional.updateVault(\n            proxy.address,\n            stratConfig[\"vaultConfig\"],\n            stratConfig[\"maxPrimaryBorrowCapacity\"],\n            {\"from\": self.notional.owner()}\n        )\n\n        return vaultProxy\n\ndef getEnvironment(network = \"mainnet\"):\n    if network == \"mainnet-fork\" or network == \"hardhat-fork\":\n        network = \"mainnet\"\n    return BalancerEnvironment(network)\n\ndef main():\n    networkName = network.show_active()\n    if networkName == \"hardhat-fork\":\n        networkName = \"mainnet\"\n    env = BalancerEnvironment(networkName)\n    maturity = env.notional.getActiveMarkets(1)[0][1]\n\n    vault1 = env.deployBalancerVault(\n        \"StratStableETHstETH\", \n        MetaStable2TokenAuraVault,\n        [MetaStable2TokenAuraHelper]\n    )\n    vault2 = env.deployBalancerVault(\n        \"StratBoostedPoolDAIPrimary\", \n        Boosted3TokenAuraVault,\n        [Boosted3TokenAuraHelper]\n    )\n    vault3 = env.deployBalancerVault(\n        \"StratBoostedPoolUSDCPrimary\", \n        Boosted3TokenAuraVault,\n        [Boosted3TokenAuraHelper]\n    )"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/BalancerVaultStorage.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {StrategyVaultSettings, StrategyVaultState} from \"../BalancerVaultTypes.sol\";\nimport {BalancerEvents} from \"../BalancerEvents.sol\";\nimport {BalancerConstants} from \"./BalancerConstants.sol\";\n\nlibrary BalancerVaultStorage {\n    uint256 private constant STRATEGY_VAULT_SETTINGS_SLOT = 1000001;\n    uint256 private constant STRATEGY_VAULT_STATE_SLOT    = 1000002;\n\n    function _settings() private pure returns (mapping(uint256 => StrategyVaultSettings) storage store) {\n        assembly { store.slot := STRATEGY_VAULT_SETTINGS_SLOT }\n    }\n\n    function _state() private pure returns (mapping(uint256 => StrategyVaultState) storage store) {\n        assembly { store.slot := STRATEGY_VAULT_STATE_SLOT }\n    }\n\n    function getStrategyVaultSettings() internal view returns (StrategyVaultSettings memory) {\n        // Hardcode to the zero slot\n        return _settings()[0];\n    }\n\n    function setStrategyVaultSettings(\n        StrategyVaultSettings memory settings, \n        uint32 maxOracleQueryWindow,\n        uint16 balancerOracleWeight\n    ) internal {\n        require(settings.oracleWindowInSeconds <= maxOracleQueryWindow);\n        require(settings.settlementCoolDownInMinutes <= BalancerConstants.MAX_SETTLEMENT_COOLDOWN_IN_MINUTES);\n        require(settings.postMaturitySettlementCoolDownInMinutes <= BalancerConstants.MAX_SETTLEMENT_COOLDOWN_IN_MINUTES);\n        require(settings.maxRewardTradeSlippageLimitPercent <= BalancerConstants.SLIPPAGE_LIMIT_PRECISION);\n        require(settings.balancerOracleWeight <= balancerOracleWeight);\n        require(settings.maxBalancerPoolShare <= BalancerConstants.VAULT_PERCENT_BASIS);\n        require(settings.settlementSlippageLimitPercent <= BalancerConstants.SLIPPAGE_LIMIT_PRECISION);\n        require(settings.postMaturitySettlementSlippageLimitPercent <= BalancerConstants.SLIPPAGE_LIMIT_PRECISION);\n        require(settings.emergencySettlementSlippageLimitPercent <= BalancerConstants.SLIPPAGE_LIMIT_PRECISION);\n        require(settings.feePercentage <= BalancerConstants.VAULT_PERCENT_BASIS);\n        require(settings.oraclePriceDeviationLimitPercent <= BalancerConstants.VAULT_PERCENT_BASIS);\n\n        mapping(uint256 => StrategyVaultSettings) storage store = _settings();\n        // Hardcode to the zero slot\n        store[0] = settings;\n\n        emit BalancerEvents.StrategyVaultSettingsUpdated(settings);\n    }\n\n    function getStrategyVaultState() internal view returns (StrategyVaultState memory) {\n        // Hardcode to the zero slot\n        return _state()[0];\n    }\n\n    function setStrategyVaultState(StrategyVaultState memory state) internal {\n        mapping(uint256 => StrategyVaultState) storage store = _state();\n        // Hardcode to the zero slot\n        store[0] = state;\n    }\n\n    function _bptThreshold(StrategyVaultSettings memory strategyVaultSettings, uint256 totalBPTSupply) \n        internal pure returns (uint256) {\n        return (totalBPTSupply * strategyVaultSettings.maxBalancerPoolShare) / BalancerConstants.VAULT_PERCENT_BASIS;\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {\n    TwoTokenPoolContext, \n    OracleContext, \n    PoolParams,\n    DepositParams,\n    DynamicTradeParams,\n    DepositTradeParams,\n    RedeemParams,\n    AuraStakingContext,\n    StrategyContext,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../../BalancerVaultTypes.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {Constants} from \"../../../../global/Constants.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {IAsset} from \"../../../../../interfaces/balancer/IBalancerVault.sol\";\nimport {TradeHandler} from \"../../../../trading/TradeHandler.sol\";\nimport {BalancerUtils} from \"../pool/BalancerUtils.sol\";\nimport {AuraStakingUtils} from \"../staking/AuraStakingUtils.sol\";\nimport {BalancerVaultStorage} from \"../BalancerVaultStorage.sol\";\nimport {StrategyUtils} from \"../strategy/StrategyUtils.sol\";\nimport {TwoTokenPoolUtils} from \"../pool/TwoTokenPoolUtils.sol\";\nimport {ITradingModule, Trade} from \"../../../../../interfaces/trading/ITradingModule.sol\";\nimport {IPriceOracle} from \"../../../../../interfaces/balancer/IPriceOracle.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\n\nlibrary TwoTokenPoolUtils {\n    using TokenUtils for IERC20;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using TradeHandler for Trade;\n    using TypeConvert for uint256;\n    using StrategyUtils for StrategyContext;\n    using AuraStakingUtils for AuraStakingContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n    using BalancerVaultStorage for StrategyVaultState;\n\n    /// @notice Returns parameters for joining and exiting Balancer pools\n    function _getPoolParams(\n        TwoTokenPoolContext memory context,\n        uint256 primaryAmount,\n        uint256 secondaryAmount,\n        bool isJoin\n    ) internal pure returns (PoolParams memory) {\n        IAsset[] memory assets = new IAsset[](2);\n        assets[context.primaryIndex] = IAsset(context.primaryToken);\n        assets[context.secondaryIndex] = IAsset(context.secondaryToken);\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[context.primaryIndex] = primaryAmount;\n        amounts[context.secondaryIndex] = secondaryAmount;\n\n        uint256 msgValue;\n        if (isJoin && assets[context.primaryIndex] == IAsset(Deployments.ETH_ADDRESS)) {\n            msgValue = amounts[context.primaryIndex];\n        }\n\n        return PoolParams(assets, amounts, msgValue);\n    }\n\n    /// @notice Gets the oracle price pair price between two tokens using a weighted\n    /// average between a chainlink oracle and the balancer TWAP oracle.\n    /// @param poolContext oracle context variables\n    /// @param oracleContext oracle context variables\n    /// @param tradingModule address of the trading module\n    /// @return oraclePairPrice oracle price for the pair in 18 decimals\n    function _getOraclePairPrice(\n        TwoTokenPoolContext memory poolContext,\n        OracleContext memory oracleContext, \n        ITradingModule tradingModule\n    ) internal view returns (uint256 oraclePairPrice) {\n        // NOTE: this balancer price is denominated in 18 decimal places\n        uint256 balancerWeightedPrice;\n        if (oracleContext.balancerOracleWeight > 0) {\n            uint256 balancerPrice = BalancerUtils._getTimeWeightedOraclePrice(\n                address(poolContext.basePool.pool),\n                IPriceOracle.Variable.PAIR_PRICE,\n                oracleContext.oracleWindowInSeconds\n            );\n\n            if (poolContext.primaryIndex == 1) {\n                // If the primary index is the second token, we need to invert\n                // the balancer price.\n                balancerPrice = BalancerConstants.BALANCER_PRECISION_SQUARED / balancerPrice;\n            }\n\n            balancerWeightedPrice = balancerPrice * oracleContext.balancerOracleWeight;\n        }\n\n        uint256 chainlinkWeightedPrice;\n        if (oracleContext.balancerOracleWeight < BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION) {\n            (int256 rate, int256 decimals) = tradingModule.getOraclePrice(\n                poolContext.primaryToken, poolContext.secondaryToken\n            );\n            require(rate > 0);\n            require(decimals >= 0);\n\n            if (uint256(decimals) != BalancerConstants.BALANCER_PRECISION) {\n                rate = (rate * int256(BalancerConstants.BALANCER_PRECISION)) / decimals;\n            }\n\n            // No overflow in rate conversion, checked above\n            chainlinkWeightedPrice = uint256(rate) * \n                (BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION - oracleContext.balancerOracleWeight);\n        }\n\n        oraclePairPrice = (balancerWeightedPrice + chainlinkWeightedPrice) / \n            BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION;\n    }\n\n    /// @notice Gets the time-weighted primary token balance for a given bptAmount\n    /// @dev Balancer pool needs to be fully initialized with at least 1024 trades\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param bptAmount amount of balancer pool lp tokens\n    /// @return primaryAmount primary token balance\n    function _getTimeWeightedPrimaryBalance(\n        TwoTokenPoolContext memory poolContext,\n        OracleContext memory oracleContext,\n        StrategyContext memory strategyContext,\n        uint256 bptAmount\n    ) internal view returns (uint256 primaryAmount) {\n        // Gets the BPT token price denominated in token index = 0\n        uint256 bptPrice = BalancerUtils._getTimeWeightedOraclePrice(\n            address(poolContext.basePool.pool),\n            IPriceOracle.Variable.BPT_PRICE,\n            oracleContext.oracleWindowInSeconds\n        );\n\n        uint256 pairPrice = _getOraclePairPrice(poolContext, oracleContext, strategyContext.tradingModule);\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n\n        if (poolContext.primaryIndex == 0) {\n            // Since bptPrice is always denominated in the first token, we can just multiply by\n            // the amount in this case. Both bptPrice and bptAmount are in 1e18 but we need to scale\n            // this back to the primary token's native precision.\n            // underlyingValue = (bptPrice * bptAmount * primaryPrecision) / (1e18 * 1e18)\n            primaryAmount = (bptPrice * bptAmount * primaryPrecision) / \n                BalancerConstants.BALANCER_PRECISION_SQUARED;\n        } else {\n            // The second token in the BPT pool is the price that we want to get. In this case, we need to\n            // convert secondaryTokenValue to underlyingValue using the pairPrice.\n            // Both bptPrice and bptAmount are in 1e18\n            uint256 secondaryAmount = (bptPrice * bptAmount) / BalancerConstants.BALANCER_PRECISION;\n\n            // And then normalizing to primary token precision we add:\n            // PrimaryAmount = (SecondaryAmount * primaryPrecision) / PairPrice\n            primaryAmount = (secondaryAmount * primaryPrecision) / pairPrice;\n        }\n    }\n\n    function _approveBalancerTokens(TwoTokenPoolContext memory poolContext, address bptSpender) internal {\n        IERC20(poolContext.primaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n        IERC20(poolContext.secondaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n        // Allow BPT spender to pull BALANCER_POOL_TOKEN\n        IERC20(address(poolContext.basePool.pool)).checkApprove(bptSpender, type(uint256).max);\n    }\n\n    /// @notice Trade primary currency for secondary if the trade is specified\n    function _tradePrimaryForSecondary(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        bytes memory data\n    ) private returns (uint256 primarySold, uint256 secondaryBought) {\n        (DepositTradeParams memory params) = abi.decode(data, (DepositTradeParams));\n\n        (primarySold, secondaryBought) = StrategyUtils._executeDynamicTradeExactIn({\n            params: params.tradeParams, \n            tradingModule: strategyContext.tradingModule, \n            sellToken: poolContext.primaryToken, \n            buyToken: poolContext.secondaryToken, \n            amount: params.tradeAmount\n        });\n    }\n\n    function _deposit(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        uint256 deposit,\n        DepositParams memory params\n    ) internal returns (uint256 strategyTokensMinted) {\n        uint256 secondaryAmount;\n        if (params.tradeData.length != 0) {\n            // Allows users to trade on a different DEX instead of Balancer when joining\n            (uint256 primarySold, uint256 secondaryBought) = _tradePrimaryForSecondary({\n                poolContext: poolContext,\n                strategyContext: strategyContext,\n                data: params.tradeData\n            });\n            deposit -= primarySold;\n            secondaryAmount = secondaryBought;\n        }\n\n        uint256 bptMinted = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: stakingContext,\n            primaryAmount: deposit,\n            secondaryAmount: secondaryAmount,\n            minBPT: params.minBPT\n        });\n\n        strategyTokensMinted = strategyContext._convertBPTClaimToStrategyTokens(bptMinted);\n\n        // Update global supply count\n        strategyContext.vaultState.totalStrategyTokenGlobal += strategyTokensMinted.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _sellSecondaryBalance(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        RedeemParams memory params,\n        uint256 secondaryBalance\n    ) private returns (uint256 primaryPurchased) {\n        (DynamicTradeParams memory tradeParams) = abi.decode(\n            params.secondaryTradeParams, (DynamicTradeParams)\n        );\n\n        ( /*uint256 amountSold */, primaryPurchased) = \n            StrategyUtils._executeDynamicTradeExactIn({\n                params: tradeParams,\n                tradingModule: strategyContext.tradingModule,\n                sellToken: poolContext.secondaryToken,\n                buyToken: poolContext.primaryToken,\n                amount: secondaryBalance\n            });\n    }\n\n    function _redeem(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        address account,\n        uint256 strategyTokens,\n        uint256 maturity,\n        RedeemParams memory params\n    ) internal returns (uint256 finalPrimaryBalance) {\n        uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokens);\n\n        if (bptClaim == 0) return 0;\n\n        // Underlying token balances from exiting the pool\n        (uint256 primaryBalance, uint256 secondaryBalance)\n            = _unstakeAndExitPool(\n                poolContext, stakingContext, bptClaim, params.minPrimary, params.minSecondary\n            );\n\n        finalPrimaryBalance = primaryBalance;\n        if (secondaryBalance > 0) {\n            uint256 primaryPurchased = _sellSecondaryBalance(\n                poolContext, strategyContext, params, secondaryBalance\n            );\n\n            finalPrimaryBalance += primaryPurchased;\n        }\n\n        // Update global strategy token balance\n        strategyContext.vaultState.totalStrategyTokenGlobal -= strategyTokens.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _joinPoolAndStake(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        uint256 primaryAmount,\n        uint256 secondaryAmount,\n        uint256 minBPT\n    ) internal returns (uint256 bptMinted) {\n        // prettier-ignore\n        PoolParams memory poolParams = poolContext._getPoolParams( \n            primaryAmount, \n            secondaryAmount,\n            true // isJoin\n        );\n\n        bptMinted = BalancerUtils._joinPoolExactTokensIn({\n            context: poolContext.basePool,\n            params: poolParams,\n            minBPT: minBPT\n        });\n\n        // Check BPT threshold to make sure our share of the pool is\n        // below maxBalancerPoolShare\n        uint256 bptThreshold = strategyContext.vaultSettings._bptThreshold(\n            poolContext.basePool.pool.totalSupply()\n        );\n        uint256 bptHeldAfterJoin = strategyContext.totalBPTHeld + bptMinted;\n        if (bptHeldAfterJoin > bptThreshold)\n            revert Errors.BalancerPoolShareTooHigh(bptHeldAfterJoin, bptThreshold);\n\n        // Transfer token to Aura protocol for boosted staking\n        stakingContext.auraBooster.deposit(stakingContext.auraPoolId, bptMinted, true); // stake = true\n    }\n\n    function _unstakeAndExitPool(\n        TwoTokenPoolContext memory poolContext,\n        AuraStakingContext memory stakingContext,\n        uint256 bptClaim,\n        uint256 minPrimary,\n        uint256 minSecondary\n    ) internal returns (uint256 primaryBalance, uint256 secondaryBalance) {\n        // Withdraw BPT tokens back to the vault for redemption\n        stakingContext.auraRewardPool.withdrawAndUnwrap(bptClaim, false); // claimRewards = false\n\n        uint256[] memory exitBalances = BalancerUtils._exitPoolExactBPTIn({\n            context: poolContext.basePool,\n            params: poolContext._getPoolParams(minPrimary, minSecondary, false), // isJoin = false\n            bptExitAmount: bptClaim\n        });\n        \n        (primaryBalance, secondaryBalance) \n            = (exitBalances[poolContext.primaryIndex], exitBalances[poolContext.secondaryIndex]);\n    }\n\n    /// @notice We value strategy tokens in terms of the primary balance. The time weighted\n    /// primary balance is used in order to prevent pool manipulation.\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param strategyTokenAmount amount of strategy tokens\n    /// @return underlyingValue underlying value of strategy tokens\n    function _convertStrategyToUnderlying(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        OracleContext memory oracleContext,\n        uint256 strategyTokenAmount\n    ) internal view returns (int256 underlyingValue) {\n        \n        uint256 bptClaim \n            = strategyContext._convertStrategyTokensToBPTClaim(strategyTokenAmount);\n\n        underlyingValue \n            = poolContext._getTimeWeightedPrimaryBalance(oracleContext, strategyContext, bptClaim).toInt();\n    }\n}"
    },
    {
      "filename": "contracts-v2/contracts/internal/vaults/VaultState.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    VaultAccount,\n    VaultConfig,\n    VaultState,\n    VaultStateStorage,\n    VaultSettledAssetsStorage\n} from \"../../global/Types.sol\";\nimport {AssetRate, AssetRateParameters} from \"../markets/AssetRate.sol\";\nimport {Token, TokenHandler} from \"../balances/TokenHandler.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {VaultConfiguration} from \"./VaultConfiguration.sol\";\nimport {LibStorage} from \"../../global/LibStorage.sol\";\nimport {IStrategyVault} from \"../../../interfaces/notional/IStrategyVault.sol\";\n\n/// @notice VaultState holds a combination of asset cash and strategy tokens on behalf of the\n/// vault accounts. When accounts enter or exit the pool they receive vault shares corresponding to\n/// at the ratio of asset cash to strategy tokens in the corresponding maturity. A maturity may hold\n/// asset cash during a risk-off event or as it unwinds to repay its debt at maturity. A VaultState\n/// will also hold settlement values after a vault is matured.\nlibrary VaultStateLib {\n    using AssetRate for AssetRateParameters;\n    using TokenHandler for Token;\n    using VaultConfiguration for VaultConfig;\n    using SafeInt256 for int256;\n    using SafeUint256 for uint256;\n\n    event VaultStateUpdate(\n        address indexed vault,\n        uint256 indexed maturity,\n        int256 totalfCash,\n        uint256 totalAssetCash,\n        uint256 totalStrategyTokens,\n        uint256 totalVaultShares\n    );\n\n    event VaultSettled(\n        address indexed vault,\n        uint256 indexed maturity,\n        int256 totalfCash,\n        uint256 totalAssetCash,\n        uint256 totalStrategyTokens,\n        uint256 totalVaultShares,\n        int256 strategyTokenValue\n    );\n\n    event VaultEnterMaturity(\n        address indexed vault,\n        uint256 indexed maturity,\n        address indexed account,\n        uint256 underlyingTokensTransferred,\n        uint256 strategyTokenDeposited,\n        uint256 vaultSharesMinted\n    );\n\n    function getVaultState(address vault, uint256 maturity) internal view returns (VaultState memory vaultState) {\n        mapping(address => mapping(uint256 => VaultStateStorage)) storage store = LibStorage.getVaultState();\n        VaultStateStorage storage s = store[vault][maturity];\n\n        vaultState.maturity = maturity;\n        // fCash debts are represented as negative integers on the stack\n        vaultState.totalfCash = -int256(uint256(s.totalfCash));\n        vaultState.isSettled = s.isSettled;\n        vaultState.totalAssetCash = s.totalAssetCash;\n        vaultState.totalStrategyTokens = s.totalStrategyTokens;\n        vaultState.totalVaultShares = s.totalVaultShares;\n        vaultState.settlementStrategyTokenValue = s.settlementStrategyTokenValue;\n    }\n\n    /// @notice Sets a vault state before it has been settled\n    function setVaultState(VaultState memory vaultState, address vault) internal {\n        mapping(address => mapping(uint256 => VaultStateStorage)) storage store = LibStorage.getVaultState();\n        VaultStateStorage storage s = store[vault][vaultState.maturity];\n\n        require(vaultState.isSettled == false); // dev: cannot update vault state after settled\n\n        s.totalfCash = vaultState.totalfCash.neg().toUint().toUint80();\n        s.totalAssetCash = vaultState.totalAssetCash.toUint80();\n        s.totalStrategyTokens = vaultState.totalStrategyTokens.toUint80();\n        s.totalVaultShares = vaultState.totalVaultShares.toUint80();\n\n        emit VaultStateUpdate(\n            vault,\n            vaultState.maturity,\n            vaultState.totalfCash,\n            vaultState.totalAssetCash,\n            vaultState.totalStrategyTokens,\n            vaultState.totalVaultShares\n        );\n    }\n\n    /// @notice Settles a vault state by taking a snapshot of relevant values at settlement. This can only happen once\n    /// per maturity.\n    function setSettledVaultState(\n        VaultState memory vaultState,\n        VaultConfig memory vaultConfig,\n        AssetRateParameters memory settlementRate,\n        uint256 maturity,\n        uint256 blockTime\n    ) internal {\n        mapping(address"
    }
  ]
}