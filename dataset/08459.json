{
  "Title": "[M-04] VaultTracker miscalculates compounding interest",
  "Content": "_Submitted by GimelSec_\n\n<https://github.com/code-423n4/2022-07-swivel/blob/main/VaultTracker/VaultTracker.sol#L65>\n\n<https://github.com/code-423n4/2022-07-swivel/blob/main/VaultTracker/VaultTracker.sol#L100>\n\n<https://github.com/code-423n4/2022-07-swivel/blob/main/VaultTracker/VaultTracker.sol#L130>\n\n<https://github.com/code-423n4/2022-07-swivel/blob/main/VaultTracker/VaultTracker.sol#L172>\n\n<https://github.com/code-423n4/2022-07-swivel/blob/main/VaultTracker/VaultTracker.sol#L191>\n\n<https://github.com/code-423n4/2022-07-swivel/blob/main/VaultTracker/VaultTracker.sol#L228>\n\n### Impact\n\nVaultTracker neglect previously accrued interest while attempting to calculate new interest. This causes `nToken` holders to receive less yield than they should.\n\nAll functions within VaultTracker that calculate interest are affected, including `addNotional`, `removeNotional`, `redeemInterest`, `transferNotionalFrom` and `transferNotionalFee`.\n\n### Proof of Concept\n\nConsider the case where some user `N` tries to initiate a vault at 3 specific moments where `cToken` exchange rate is 5/10/20 respectively.\nThe corresponding market stays active and has not reached maturity. Additionally, `N` selects his premium volume to make `principalFilled` match the `cToken` exchange rate during each call to `initiateVaultFillingZcTokenInitiate`.\nWe recognize those exchange rates are most likely unrealistic, but we chose those for ease of demonstrating the bug. We also assume fees to be 0 for simplicity.\n\nFor the first call to `Swivel.deposit`\n\n*   `a` = 5\n*   `exchangeRate` = 5\n\nAssuming no additional fees while minting `cToken`, `N` will receive `cToken\\` for his 5 underlying tokens.\n\nFor the matching call to `VaultTracker.addNotional`\n\n*   `a` = 5\n*   `vlt.notional` = 0\n*   `exchangeRate` = 5\n\nSince this is the first time adding `nToken` to the vault, there is no need to consider any accumulated interests, and we can assign `a` directly to `vlt.notional`.\n\nThe result will be\n\n*   `vlt.notional` = 5\n*   `vlt.redeemable` = 0\n*   `cToken` held by `Swivel` = 1\n\nFor the second call to \\`Swivel.deposit, we have\n\n*   `a` = 10\n*   `exchangeRate` = 10\n\nThe matching call to `VaultTracker.addNotional` has\n\n*   `a` = 10\n*   `vlt.notional` = 5\n*   `vlt.redeemable` = 0\n*   `exchangeRate` = 10\n*   `vlt.exchangeRate` = 5\n\nThe `yield` is derived from `((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26` = `((10 * 1e26) / 5) - 1e26` = 1e26\nApplying this to `vlt.notional`, we get `interest` = `1e26 * 5 / 1e26` = 5\n\nThis results in\n\n*   `vlt.notional` = 5+10 = 15\n*   `vlt.redeemable` = 0+5 = 5\n*   `cToken` held by `Swivel` = 1+1 = 2\n\nNow comes the last call to `Swivel.deposit`, where\n\n*   `a` = 20\n*   `exchangeRate` = 20\n\n`VaultTracker.addNotional` has\n\n*   `a` = 20\n*   `vlt.notional` = 15\n*   `vlt.redeemable` = 5\n*   `exchangeRate` = 20\n*   `vlt.exchangeRate` = 10\n\n`yield` = `((20 * 1e26) / 10) - 1e26` = 1e26\n`interest` = `1e26 * 15 / 1e26` = 15\n\nSo we finally end up with\n\n*   `vlt.notional` = 15+20 = 35\n*   `vlt.redeemable` = 5+15 = 20\n*   `cToken` held by `Swivel` = 2+1 = 3\n\n<!---->\n\n    Swivel{\n      ...\n      function deposit(uint8 p, address u, address c, uint256 a) internal returns (bool) {\n        ...\n        if (p == uint8(Protocols.Compound)) { // TODO is Rari a drop in here?\n          return ICompound(c).mint(a) == 0;\n        }\n        ...\n      }\n      ...\n    }\n\n\n    VaultTracker{\n      ...\n      function addNotional(address o, uint256 a) external authorized(admin) returns (bool) {\n        uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n        Vault memory vlt = vaults[o];\n\n        if (vlt.notional > 0) {\n          uint256 yield;\n\n          // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n          // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n          if (maturityRate > 0) { // Calculate marginal interest\n            yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\n          } else {\n            yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\n          }\n\n          uint256 interest = (yield * vlt.notional) / 1e26;\n          // add interest and amount to position, reset cToken exchange rate\n          vlt.redeemable += interest;\n          vlt.notional += a;\n        } else {\n          vlt.notional = a;\n        }\n        vlt.exchangeRate = exchangeRate;\n        vaults[o] = vlt;\n\n        return true;\n      }\n        ...\n    }\n\nNow take a step back and think about the actual value of 3 `cToken` when `exchangeRate = 20`, it should be pretty obvious that the value tracked by `VaultTracker` = 35 + 20 = 55 is lesser than the actual value of `cToken` held by `Swivel` = 20\\*3 = 60.\n\nThis is due to `VaultTracker` neglecting that previously accrued interest should also be considered while calculating new interest.\n\n### Recommended Mitigation Steps\n\nFor all interest calculations, use `vlt.notional + vlt.redeemable` instead of just `vlt.notional` as `yield` base.\n\n**[JTraversa (Swivel) disputed and commented](https://github.com/code-423n4/2022-07-swivel-findings/issues/136#issuecomment-1185979753):**\n > I believe that this would be valid if the `redeemable` was not redeemable by the user at any point in time.\n> \n> While interest accrues, it accrues to the `redeemable` balance which is withdrawn at any time. \n> \n> That said, in most cases, the math required to store and do the additional calculation marginal interest on the `redeemable` balance is largely a UX consideration? Should users be required to redeem their `redeemable` to earn interest or should it be compounded naturally though bloat tx costs? \n> \n> Should we force additional costs on a per transaction basis (that likely costs more than the interest itself for the vast majority of users), or should we assume that once significant enough `redeemable` is accrued to earn reasonable further interest, it will be redeemed by the user. \n> \n> (e.g. with example being 400% interest, and assuming an (optimistic) 5% APY is possible, the example would take ~28 years to replicate, and gas costs for transactions in that 28 years would be significant).\n\n**[JTraversa (Swivel) disagreed with severity and commented](https://github.com/code-423n4/2022-07-swivel-findings/issues/136#issuecomment-1193348594):**\n> Thought about this one a bit more and it might slip in as acknowledged and disagreed with severity as it's more value leakage than anything else.\n> \n> It's a design decision, but could still be considered a detriment so perhaps not worth disputing all together?\n\n**[robrobbins (Swivel) commented](https://github.com/code-423n4/2022-07-swivel-findings/issues/136#issuecomment-1219849345):**\n> This is a design feature. We could just as easily dismiss this all together by stating _it is now documented that .notional is non compounding_. I don't think we should do that however as I agree with @JTraversa here that some acknowledgement should happen for bringing this up. But it is not a **risk** in any situation.\n\n**[robrobbins (Swivel) resolved](https://github.com/code-423n4/2022-07-swivel-findings/issues/136#issuecomment-1220016605):**\n > Addressed: https://github.com/Swivel-Finance/gost/pull/427\n\n**[0xean (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-07-swivel-findings/issues/136#issuecomment-1226426531):**\n > Going to reduce the severity on this to Medium as it has some pretty large external factors to end up in a scenario where it leaks any real value.  \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-07-swivel-v3-contest",
  "Code": [
    {
      "filename": "VaultTracker/VaultTracker.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Compounding.sol';\n\ncontract VaultTracker {\n  /// @notice A single custom error capable of indicating a wide range of detected errors by providing\n  /// an error code value whose string representation is documented <here>, and any possible other values\n  /// that are pertinent to the error.\n  error Exception(uint8, uint256, uint256, address, address);\n\n  struct Vault {\n    uint256 notional;\n    uint256 redeemable;\n    uint256 exchangeRate;\n  }\n\n  mapping(address => Vault) public vaults;\n\n  address public immutable admin;\n  address public immutable cTokenAddr;\n  address public immutable swivel;\n  uint256 public immutable maturity;\n  uint256 public maturityRate;\n  uint8 public immutable protocol;\n\n  /// @param m Maturity timestamp associated with this vault\n  /// @param c Compounding Token address associated with this vault\n  /// @param s Address of the deployed swivel contract\n  constructor(uint8 p, uint256 m, address c, address s) {\n    admin = msg.sender;\n    protocol = p;\n    maturity = m;\n    cTokenAddr = c;\n    swivel = s;\n\n    // instantiate swivel's vault (unblocking transferNotionalFee)\n    vaults[s] = Vault({\n      notional: 0,\n      redeemable: 0,\n      exchangeRate: Compounding.exchangeRate(p, c)\n    });\n  }\n\n  /// @notice Adds notional to a given address\n  /// @param o Address that owns a vault\n  /// @param a Amount of notional added\n  function addNotional(address o, uint256 a) external authorized(admin) returns (bool) {\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    Vault memory vlt = vaults[o];\n\n    if (vlt.notional > 0) {\n      uint256 yield;\n\n      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n      // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n      if (maturityRate > 0) { // Calculate marginal interest\n        yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\n      } else {\n        yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\n      }\n\n      uint256 interest = (yield * vlt.notional) / 1e26;\n      // add interest and amount to position, reset cToken exchange rate\n      vlt.redeemable += interest;\n      vlt.notional += a;\n    } else {\n      vlt.notional = a;\n    }\n\n    vlt.exchangeRate = exchangeRate;\n    vaults[o] = vlt;\n\n    return true;\n  }\n\n  /// @notice Removes notional from a given address\n  /// @param o Address that owns a vault\n  /// @param a Amount of notional to remove\n  function removeNotional(address o, uint256 a) external authorized(admin) returns (bool) {\n\n    Vault memory vlt = vaults[o];\n\n    if (a > vlt.notional) { revert Exception(31, a, vlt.notional, address(0), address(0)); }\n\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n    // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n    uint256 yield;\n    if (maturityRate > 0) { // Calculate marginal interest\n      yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\n    } else {\n      // calculate marginal interest\n      yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\n    }\n\n    uint256 interest = (yield * vlt.notional) / 1e26;\n    // remove amount from position, Add interest to position, reset cToken exchange rate\n    vlt.redeemable += interest;\n    vlt.notional -= a;\n    vlt.exchangeRate = exchangeRate;\n\n    vaults[o] = vlt;\n\n    return true;\n  }\n\n  /// @notice Redeem's interest accrued by a given address\n  /// @param o Address that owns a vault\n  function redeemInterest(address o) external authorized(admin) returns (uint256) {\n\n    Vault memory vlt = vaults[o];\n\n    uint256 redeemable = vlt.redeemable;\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n    // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n    uint256 yield;\n    if (maturityRate > 0) { // Calculate marginal interest\n      yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\n    } else {\n      // calculate marginal interest\n      yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\n    }\n\n    uint256 interest = (yield * vlt.notional) / 1e26;\n\n    vlt.exchangeRate = exchangeRate;\n    vlt.redeemable = 0;\n\n    vaults[o] = vlt;\n\n    // return adds marginal interest to previously accrued redeemable interest\n    return (redeemable + interest);\n  }\n\n  /// @notice Matures the vault\n  /// @param c The current cToken exchange rate\n  function matureVault(uint256 c) external authorized(admin) returns (bool) {\n    maturityRate = c;\n    return true;\n  }\n\n  /// @notice Transfers notional from one address to another\n  /// @param f Owner of the amount\n  /// @param t Recipient of the amount\n  /// @param a Amount to transfer\n  function transferNotionalFrom(address f, address t, uint256 a) external authorized(admin) returns (bool) {\n    if (f == t) { revert Exception(32, 0, 0, f, t); }\n\n    Vault memory from = vaults[f];\n    Vault memory to = vaults[t];\n\n    if (a > from.notional) { revert Exception(31, a, from.notional, address(0), address(0)); }\n\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n    // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n    uint256 yield;\n    if (maturityRate > 0) { \n      // calculate marginal interest\n      yield = ((maturityRate * 1e26) / from.exchangeRate) - 1e26;\n    } else {\n      yield = ((exchangeRate * 1e26) / from.exchangeRate) - 1e26;\n    }\n\n    uint256 interest = (yield * from.notional) / 1e26;\n    // remove amount from position, Add interest to position, reset cToken exchange rate\n    from.redeemable += interest;\n    from.notional -= a;\n    from.exchangeRate = exchangeRate;\n\n    vaults[f] = from;\n\n    // transfer notional to address \"t\", calculate interest if necessary\n    if (to.notional > 0) {\n      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n      // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n      if (maturityRate > 0) { \n        // calculate marginal interest\n        yield = ((maturityRate * 1e26) / to.exchangeRate) - 1e26;\n      } else {\n        yield = ((exchangeRate * 1e26) / to.exchangeRate) - 1e26;\n      }\n\n      uint256 newVaultInterest = (yield * to.notional) / 1e26;\n      // add interest and amount to position, reset cToken exchange rate\n      to.redeemable += newVaultInterest;\n      to.notional += a;\n    } else {\n      to.notional = a;\n    }\n\n    to.exchangeRate = exchangeRate;\n    vaults[t] = to;\n\n    return true;\n  }\n\n  /// @notice Transfers, in notional, a fee payment to the Swivel contract without recalculating marginal interest for the owner\n  /// @param f Owner of the amount\n  /// @param a Amount to transfer\n  function transferNotionalFee(address f, uint256 a) external authorized(admin) returns(bool) {\n    Vault memory oVault = vaults[f];\n    Vault memory sVault = vaults[swivel];\n\n    // remove notional from its owner\n    oVault.notional -= a;\n\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // check if exchangeRate has been stored already this block. If not, calculate marginal interest + store exchangeRate\n    uint256 yield;\n    if (sVault.exchangeRate != exchangeRate) {\n      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n      // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n      if (maturityRate > 0) { \n        // calculate marginal interest\n          yield = ((maturityRate * 1e26) / sVault.exchangeRate) - 1e26;\n      } else {\n          yield = ((exchangeRate * 1e26) / sVault.exchangeRate) - 1e26;\n      }\n      uint256 interest = (yield * sVault.notional) / 1e26;\n      // add interest and amount, reset cToken exchange rate\n      sVault.redeemable += interest;\n      sVault.exchangeRate = exchangeRate;\n    }\n    // add notional to swivel's vault\n    sVault.notional += a;\n    // store the adjusted vaults\n    vaults[swivel] = sVault;\n    vaults[f] = oVault;\n    return true;\n  }\n\n  /// @notice Returns both relevant balances for a given user's vault\n  /// @param o Address that owns a vault\n  function balancesOf(address o) external view returns (uint256, uint256) {\n    Vault memory vault = vaults[o];\n    return (vault.notional, vault.redeemable);\n  }\n\n  modifier authorized(address a) {\n    if(msg.sender != a) { revert Exception(0, 0, 0, msg.sender, a); }\n    _;\n  }\n}"
    },
    {
      "filename": "VaultTracker/VaultTracker.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Compounding.sol';\n\ncontract VaultTracker {\n  /// @notice A single custom error capable of indicating a wide range of detected errors by providing\n  /// an error code value whose string representation is documented <here>, and any possible other values\n  /// that are pertinent to the error.\n  error Exception(uint8, uint256, uint256, address, address);\n\n  struct Vault {\n    uint256 notional;\n    uint256 redeemable;\n    uint256 exchangeRate;\n  }\n\n  mapping(address => Vault) public vaults;\n\n  address public immutable admin;\n  address public immutable cTokenAddr;\n  address public immutable swivel;\n  uint256 public immutable maturity;\n  uint256 public maturityRate;\n  uint8 public immutable protocol;\n\n  /// @param m Maturity timestamp associated with this vault\n  /// @param c Compounding Token address associated with this vault\n  /// @param s Address of the deployed swivel contract\n  constructor(uint8 p, uint256 m, address c, address s) {\n    admin = msg.sender;\n    protocol = p;\n    maturity = m;\n    cTokenAddr = c;\n    swivel = s;\n\n    // instantiate swivel's vault (unblocking transferNotionalFee)\n    vaults[s] = Vault({\n      notional: 0,\n      redeemable: 0,\n      exchangeRate: Compounding.exchangeRate(p, c)\n    });\n  }\n\n  /// @notice Adds notional to a given address\n  /// @param o Address that owns a vault\n  /// @param a Amount of notional added\n  function addNotional(address o, uint256 a) external authorized(admin) returns (bool) {\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    Vault memory vlt = vaults[o];\n\n    if (vlt.notional > 0) {\n      uint256 yield;\n\n      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n      // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n      if (maturityRate > 0) { // Calculate marginal interest\n        yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\n      } else {\n        yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\n      }\n\n      uint256 interest = (yield * vlt.notional) / 1e26;\n      // add interest and amount to position, reset cToken exchange rate\n      vlt.redeemable += interest;\n      vlt.notional += a;\n    } else {\n      vlt.notional = a;\n    }\n\n    vlt.exchangeRate = exchangeRate;\n    vaults[o] = vlt;\n\n    return true;\n  }\n\n  /// @notice Removes notional from a given address\n  /// @param o Address that owns a vault\n  /// @param a Amount of notional to remove\n  function removeNotional(address o, uint256 a) external authorized(admin) returns (bool) {\n\n    Vault memory vlt = vaults[o];\n\n    if (a > vlt.notional) { revert Exception(31, a, vlt.notional, address(0), address(0)); }\n\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n    // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n    uint256 yield;\n    if (maturityRate > 0) { // Calculate marginal interest\n      yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\n    } else {\n      // calculate marginal interest\n      yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\n    }\n\n    uint256 interest = (yield * vlt.notional) / 1e26;\n    // remove amount from position, Add interest to position, reset cToken exchange rate\n    vlt.redeemable += interest;\n    vlt.notional -= a;\n    vlt.exchangeRate = exchangeRate;\n\n    vaults[o] = vlt;\n\n    return true;\n  }\n\n  /// @notice Redeem's interest accrued by a given address\n  /// @param o Address that owns a vault\n  function redeemInterest(address o) external authorized(admin) returns (uint256) {\n\n    Vault memory vlt = vaults[o];\n\n    uint256 redeemable = vlt.redeemable;\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n    // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n    uint256 yield;\n    if (maturityRate > 0) { // Calculate marginal interest\n      yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\n    } else {\n      // calculate marginal interest\n      yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\n    }\n\n    uint256 interest = (yield * vlt.notional) / 1e26;\n\n    vlt.exchangeRate = exchangeRate;\n    vlt.redeemable = 0;\n\n    vaults[o] = vlt;\n\n    // return adds marginal interest to previously accrued redeemable interest\n    return (redeemable + interest);\n  }\n\n  /// @notice Matures the vault\n  /// @param c The current cToken exchange rate\n  function matureVault(uint256 c) external authorized(admin) returns (bool) {\n    maturityRate = c;\n    return true;\n  }\n\n  /// @notice Transfers notional from one address to another\n  /// @param f Owner of the amount\n  /// @param t Recipient of the amount\n  /// @param a Amount to transfer\n  function transferNotionalFrom(address f, address t, uint256 a) external authorized(admin) returns (bool) {\n    if (f == t) { revert Exception(32, 0, 0, f, t); }\n\n    Vault memory from = vaults[f];\n    Vault memory to = vaults[t];\n\n    if (a > from.notional) { revert Exception(31, a, from.notional, address(0), address(0)); }\n\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n    // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n    uint256 yield;\n    if (maturityRate > 0) { \n      // calculate marginal interest\n      yield = ((maturityRate * 1e26) / from.exchangeRate) - 1e26;\n    } else {\n      yield = ((exchangeRate * 1e26) / from.exchangeRate) - 1e26;\n    }\n\n    uint256 interest = (yield * from.notional) / 1e26;\n    // remove amount from position, Add interest to position, reset cToken exchange rate\n    from.redeemable += interest;\n    from.notional -= a;\n    from.exchangeRate = exchangeRate;\n\n    vaults[f] = from;\n\n    // transfer notional to address \"t\", calculate interest if necessary\n    if (to.notional > 0) {\n      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n      // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n      if (maturityRate > 0) { \n        // calculate marginal interest\n        yield = ((maturityRate * 1e26) / to.exchangeRate) - 1e26;\n      } else {\n        yield = ((exchangeRate * 1e26) / to.exchangeRate) - 1e26;\n      }\n\n      uint256 newVaultInterest = (yield * to.notional) / 1e26;\n      // add interest and amount to position, reset cToken exchange rate\n      to.redeemable += newVaultInterest;\n      to.notional += a;\n    } else {\n      to.notional = a;\n    }\n\n    to.exchangeRate = exchangeRate;\n    vaults[t] = to;\n\n    return true;\n  }\n\n  /// @notice Transfers, in notional, a fee payment to the Swivel contract without recalculating marginal interest for the owner\n  /// @param f Owner of the amount\n  /// @param a Amount to transfer\n  function transferNotionalFee(address f, uint256 a) external authorized(admin) returns(bool) {\n    Vault memory oVault = vaults[f];\n    Vault memory sVault = vaults[swivel];\n\n    // remove notional from its owner\n    oVault.notional -= a;\n\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // check if exchangeRate has been stored already this block. If not, calculate marginal interest + store exchangeRate\n    uint256 yield;\n    if (sVault.exchangeRate != exchangeRate) {\n      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n      // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n      if (maturityRate > 0) { \n        // calculate marginal interest\n          yield = ((maturityRate * 1e26) / sVault.exchangeRate) - 1e26;\n      } else {\n          yield = ((exchangeRate * 1e26) / sVault.exchangeRate) - 1e26;\n      }\n      uint256 interest = (yield * sVault.notional) / 1e26;\n      // add interest and amount, reset cToken exchange rate\n      sVault.redeemable += interest;\n      sVault.exchangeRate = exchangeRate;\n    }\n    // add notional to swivel's vault\n    sVault.notional += a;\n    // store the adjusted vaults\n    vaults[swivel] = sVault;\n    vaults[f] = oVault;\n    return true;\n  }\n\n  /// @notice Returns both relevant balances for a given user's vault\n  /// @param o Address that owns a vault\n  function balancesOf(address o) external view returns (uint256, uint256) {\n    Vault memory vault = vaults[o];\n    return (vault.notional, vault.redeemable);\n  }\n\n  modifier authorized(address a) {\n    if(msg.sender != a) { revert Exception(0, 0, 0, msg.sender, a); }\n    _;\n  }\n}"
    },
    {
      "filename": "VaultTracker/VaultTracker.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Compounding.sol';\n\ncontract VaultTracker {\n  /// @notice A single custom error capable of indicating a wide range of detected errors by providing\n  /// an error code value whose string representation is documented <here>, and any possible other values\n  /// that are pertinent to the error.\n  error Exception(uint8, uint256, uint256, address, address);\n\n  struct Vault {\n    uint256 notional;\n    uint256 redeemable;\n    uint256 exchangeRate;\n  }\n\n  mapping(address => Vault) public vaults;\n\n  address public immutable admin;\n  address public immutable cTokenAddr;\n  address public immutable swivel;\n  uint256 public immutable maturity;\n  uint256 public maturityRate;\n  uint8 public immutable protocol;\n\n  /// @param m Maturity timestamp associated with this vault\n  /// @param c Compounding Token address associated with this vault\n  /// @param s Address of the deployed swivel contract\n  constructor(uint8 p, uint256 m, address c, address s) {\n    admin = msg.sender;\n    protocol = p;\n    maturity = m;\n    cTokenAddr = c;\n    swivel = s;\n\n    // instantiate swivel's vault (unblocking transferNotionalFee)\n    vaults[s] = Vault({\n      notional: 0,\n      redeemable: 0,\n      exchangeRate: Compounding.exchangeRate(p, c)\n    });\n  }\n\n  /// @notice Adds notional to a given address\n  /// @param o Address that owns a vault\n  /// @param a Amount of notional added\n  function addNotional(address o, uint256 a) external authorized(admin) returns (bool) {\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    Vault memory vlt = vaults[o];\n\n    if (vlt.notional > 0) {\n      uint256 yield;\n\n      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n      // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n      if (maturityRate > 0) { // Calculate marginal interest\n        yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\n      } else {\n        yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\n      }\n\n      uint256 interest = (yield * vlt.notional) / 1e26;\n      // add interest and amount to position, reset cToken exchange rate\n      vlt.redeemable += interest;\n      vlt.notional += a;\n    } else {\n      vlt.notional = a;\n    }\n\n    vlt.exchangeRate = exchangeRate;\n    vaults[o] = vlt;\n\n    return true;\n  }\n\n  /// @notice Removes notional from a given address\n  /// @param o Address that owns a vault\n  /// @param a Amount of notional to remove\n  function removeNotional(address o, uint256 a) external authorized(admin) returns (bool) {\n\n    Vault memory vlt = vaults[o];\n\n    if (a > vlt.notional) { revert Exception(31, a, vlt.notional, address(0), address(0)); }\n\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n    // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n    uint256 yield;\n    if (maturityRate > 0) { // Calculate marginal interest\n      yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\n    } else {\n      // calculate marginal interest\n      yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\n    }\n\n    uint256 interest = (yield * vlt.notional) / 1e26;\n    // remove amount from position, Add interest to position, reset cToken exchange rate\n    vlt.redeemable += interest;\n    vlt.notional -= a;\n    vlt.exchangeRate = exchangeRate;\n\n    vaults[o] = vlt;\n\n    return true;\n  }\n\n  /// @notice Redeem's interest accrued by a given address\n  /// @param o Address that owns a vault\n  function redeemInterest(address o) external authorized(admin) returns (uint256) {\n\n    Vault memory vlt = vaults[o];\n\n    uint256 redeemable = vlt.redeemable;\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n    // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n    uint256 yield;\n    if (maturityRate > 0) { // Calculate marginal interest\n      yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\n    } else {\n      // calculate marginal interest\n      yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\n    }\n\n    uint256 interest = (yield * vlt.notional) / 1e26;\n\n    vlt.exchangeRate = exchangeRate;\n    vlt.redeemable = 0;\n\n    vaults[o] = vlt;\n\n    // return adds marginal interest to previously accrued redeemable interest\n    return (redeemable + interest);\n  }\n\n  /// @notice Matures the vault\n  /// @param c The current cToken exchange rate\n  function matureVault(uint256 c) external authorized(admin) returns (bool) {\n    maturityRate = c;\n    return true;\n  }\n\n  /// @notice Transfers notional from one address to another\n  /// @param f Owner of the amount\n  /// @param t Recipient of the amount\n  /// @param a Amount to transfer\n  function transferNotionalFrom(address f, address t, uint256 a) external authorized(admin) returns (bool) {\n    if (f == t) { revert Exception(32, 0, 0, f, t); }\n\n    Vault memory from = vaults[f];\n    Vault memory to = vaults[t];\n\n    if (a > from.notional) { revert Exception(31, a, from.notional, address(0), address(0)); }\n\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n    // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n    uint256 yield;\n    if (maturityRate > 0) { \n      // calculate marginal interest\n      yield = ((maturityRate * 1e26) / from.exchangeRate) - 1e26;\n    } else {\n      yield = ((exchangeRate * 1e26) / from.exchangeRate) - 1e26;\n    }\n\n    uint256 interest = (yield * from.notional) / 1e26;\n    // remove amount from position, Add interest to position, reset cToken exchange rate\n    from.redeemable += interest;\n    from.notional -= a;\n    from.exchangeRate = exchangeRate;\n\n    vaults[f] = from;\n\n    // transfer notional to address \"t\", calculate interest if necessary\n    if (to.notional > 0) {\n      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n      // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n      if (maturityRate > 0) { \n        // calculate marginal interest\n        yield = ((maturityRate * 1e26) / to.exchangeRate) - 1e26;\n      } else {\n        yield = ((exchangeRate * 1e26) / to.exchangeRate) - 1e26;\n      }\n\n      uint256 newVaultInterest = (yield * to.notional) / 1e26;\n      // add interest and amount to position, reset cToken exchange rate\n      to.redeemable += newVaultInterest;\n      to.notional += a;\n    } else {\n      to.notional = a;\n    }\n\n    to.exchangeRate = exchangeRate;\n    vaults[t] = to;\n\n    return true;\n  }\n\n  /// @notice Transfers, in notional, a fee payment to the Swivel contract without recalculating marginal interest for the owner\n  /// @param f Owner of the amount\n  /// @param a Amount to transfer\n  function transferNotionalFee(address f, uint256 a) external authorized(admin) returns(bool) {\n    Vault memory oVault = vaults[f];\n    Vault memory sVault = vaults[swivel];\n\n    // remove notional from its owner\n    oVault.notional -= a;\n\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // check if exchangeRate has been stored already this block. If not, calculate marginal interest + store exchangeRate\n    uint256 yield;\n    if (sVault.exchangeRate != exchangeRate) {\n      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n      // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n      if (maturityRate > 0) { \n        // calculate marginal interest\n          yield = ((maturityRate * 1e26) / sVault.exchangeRate) - 1e26;\n      } else {\n          yield = ((exchangeRate * 1e26) / sVault.exchangeRate) - 1e26;\n      }\n      uint256 interest = (yield * sVault.notional) / 1e26;\n      // add interest and amount, reset cToken exchange rate\n      sVault.redeemable += interest;\n      sVault.exchangeRate = exchangeRate;\n    }\n    // add notional to swivel's vault\n    sVault.notional += a;\n    // store the adjusted vaults\n    vaults[swivel] = sVault;\n    vaults[f] = oVault;\n    return true;\n  }\n\n  /// @notice Returns both relevant balances for a given user's vault\n  /// @param o Address that owns a vault\n  function balancesOf(address o) external view returns (uint256, uint256) {\n    Vault memory vault = vaults[o];\n    return (vault.notional, vault.redeemable);\n  }\n\n  modifier authorized(address a) {\n    if(msg.sender != a) { revert Exception(0, 0, 0, msg.sender, a); }\n    _;\n  }\n}"
    },
    {
      "filename": "VaultTracker/VaultTracker.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Compounding.sol';\n\ncontract VaultTracker {\n  /// @notice A single custom error capable of indicating a wide range of detected errors by providing\n  /// an error code value whose string representation is documented <here>, and any possible other values\n  /// that are pertinent to the error.\n  error Exception(uint8, uint256, uint256, address, address);\n\n  struct Vault {\n    uint256 notional;\n    uint256 redeemable;\n    uint256 exchangeRate;\n  }\n\n  mapping(address => Vault) public vaults;\n\n  address public immutable admin;\n  address public immutable cTokenAddr;\n  address public immutable swivel;\n  uint256 public immutable maturity;\n  uint256 public maturityRate;\n  uint8 public immutable protocol;\n\n  /// @param m Maturity timestamp associated with this vault\n  /// @param c Compounding Token address associated with this vault\n  /// @param s Address of the deployed swivel contract\n  constructor(uint8 p, uint256 m, address c, address s) {\n    admin = msg.sender;\n    protocol = p;\n    maturity = m;\n    cTokenAddr = c;\n    swivel = s;\n\n    // instantiate swivel's vault (unblocking transferNotionalFee)\n    vaults[s] = Vault({\n      notional: 0,\n      redeemable: 0,\n      exchangeRate: Compounding.exchangeRate(p, c)\n    });\n  }\n\n  /// @notice Adds notional to a given address\n  /// @param o Address that owns a vault\n  /// @param a Amount of notional added\n  function addNotional(address o, uint256 a) external authorized(admin) returns (bool) {\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    Vault memory vlt = vaults[o];\n\n    if (vlt.notional > 0) {\n      uint256 yield;\n\n      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n      // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n      if (maturityRate > 0) { // Calculate marginal interest\n        yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\n      } else {\n        yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\n      }\n\n      uint256 interest = (yield * vlt.notional) / 1e26;\n      // add interest and amount to position, reset cToken exchange rate\n      vlt.redeemable += interest;\n      vlt.notional += a;\n    } else {\n      vlt.notional = a;\n    }\n\n    vlt.exchangeRate = exchangeRate;\n    vaults[o] = vlt;\n\n    return true;\n  }\n\n  /// @notice Removes notional from a given address\n  /// @param o Address that owns a vault\n  /// @param a Amount of notional to remove\n  function removeNotional(address o, uint256 a) external authorized(admin) returns (bool) {\n\n    Vault memory vlt = vaults[o];\n\n    if (a > vlt.notional) { revert Exception(31, a, vlt.notional, address(0), address(0)); }\n\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n    // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n    uint256 yield;\n    if (maturityRate > 0) { // Calculate marginal interest\n      yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\n    } else {\n      // calculate marginal interest\n      yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\n    }\n\n    uint256 interest = (yield * vlt.notional) / 1e26;\n    // remove amount from position, Add interest to position, reset cToken exchange rate\n    vlt.redeemable += interest;\n    vlt.notional -= a;\n    vlt.exchangeRate = exchangeRate;\n\n    vaults[o] = vlt;\n\n    return true;\n  }\n\n  /// @notice Redeem's interest accrued by a given address\n  /// @param o Address that owns a vault\n  function redeemInterest(address o) external authorized(admin) returns (uint256) {\n\n    Vault memory vlt = vaults[o];\n\n    uint256 redeemable = vlt.redeemable;\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n    // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n    uint256 yield;\n    if (maturityRate > 0) { // Calculate marginal interest\n      yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\n    } else {\n      // calculate marginal interest\n      yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\n    }\n\n    uint256 interest = (yield * vlt.notional) / 1e26;\n\n    vlt.exchangeRate = exchangeRate;\n    vlt.redeemable = 0;\n\n    vaults[o] = vlt;\n\n    // return adds marginal interest to previously accrued redeemable interest\n    return (redeemable + interest);\n  }\n\n  /// @notice Matures the vault\n  /// @param c The current cToken exchange rate\n  function matureVault(uint256 c) external authorized(admin) returns (bool) {\n    maturityRate = c;\n    return true;\n  }\n\n  /// @notice Transfers notional from one address to another\n  /// @param f Owner of the amount\n  /// @param t Recipient of the amount\n  /// @param a Amount to transfer\n  function transferNotionalFrom(address f, address t, uint256 a) external authorized(admin) returns (bool) {\n    if (f == t) { revert Exception(32, 0, 0, f, t); }\n\n    Vault memory from = vaults[f];\n    Vault memory to = vaults[t];\n\n    if (a > from.notional) { revert Exception(31, a, from.notional, address(0), address(0)); }\n\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate"
    }
  ]
}