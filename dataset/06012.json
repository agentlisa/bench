{
  "Title": "[N-08] Interfaces only used in tests should be separated from core interfaces",
  "Content": "### Summary\n\nIn the project, there are several interfaces only used in the tests. Those interfaces should not be in the same place as the interfaces used in the protocol contracts since they could be misleading.\n\n### Vulnerability Details\n\nIn the `contracts/interfaces` folder there are interfaces only used in tests and also interfaces used in the protocol contracts. Having them mixed together can be misleading and confusing so the ideal thing should be to separate them in different folders.\n\n### Impact\n\nThis can cause confusion and even use the wrong interfaces in tests or core protocol contracts.\n\n### Proof of Concept\n\nInterfaces only used in tests that should be moved to another folder:\n- https://github.com/code-423n4/2023-08-goodentry/blob/4b785d455fff04629d8675f21ef1d1632749b252/interfaces/IAToken.sol#L9\n- https://github.com/code-423n4/2023-08-goodentry/blob/4b785d455fff04629d8675f21ef1d1632749b252/interfaces/ICreditDelegationToken.sol#L4\n- https://github.com/code-423n4/2023-08-goodentry/blob/4b785d455fff04629d8675f21ef1d1632749b252/interfaces/IERC20.sol#L9\n- https://github.com/code-423n4/2023-08-goodentry/blob/4b785d455fff04629d8675f21ef1d1632749b252/interfaces/IInitializableAToken.sol#L12\n- https://github.com/code-423n4/2023-08-goodentry/blob/4b785d455fff04629d8675f21ef1d1632749b252/interfaces/ILendingPoolConfigurator.sol#L5\n- https://github.com/code-423n4/2023-08-goodentry/blob/4b785d455fff04629d8675f21ef1d1632749b252/interfaces/IScaledBalanceToken.sol#L4C11-L4C30\n\n### Recommended Mitigation Steps\n\nSeparate the test interfaces and the protocol interfaces in different folders.\n\n**[gzeon (Judge) commented](https://github.com/code-423n4/2023-08-goodentry-findings/issues/240#issuecomment-1685328958):**\n> These downgraded items were also considered in scoring:\n> \n> Low:\n> \n> [`ticks[]` in GeVault.sol not ordered in ascending price order](https://github.com/code-423n4/2023-08-goodentry-findings/issues/180)\n> \n> [Incorrect Oracle decimal assumption breaks price calculation](https://github.com/code-423n4/2023-08-goodentry-findings/issues/183)\n> \n> [Incorrect decimal checks excludes all valid pricefeed pairs](https://github.com/code-423n4/2023-08-goodentry-findings/issues/184)\n> \n> Non-critical: \n> \n> [Lack of validation between Tokenised Ranges and GeVault Uniswap Pool](https://github.com/code-423n4/2023-08-goodentry-findings/issues/187)\n\n\n**[Keref (Good Entry) acknowledged and commented](https://github.com/code-423n4/2023-08-goodentry-findings/issues/240#issuecomment-1689967922):**\n > Removed dead code and correct natspec.\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-08-goodentry",
  "Code": [
    {
      "filename": "interfaces/IAToken.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IScaledBalanceToken} from './IScaledBalanceToken.sol';\nimport {IInitializableAToken} from './IInitializableAToken.sol';\nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol';\n\ninterface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {\n  function _nonces(address owner) external view returns (uint256); //from EIP-2612\n  function name() external view  returns (string memory);\n  function version() external view returns (string memory);\n  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n \n  /**\n   * @dev Emitted after the mint action\n   * @param from The address performing the mint\n   * @param value The amount being\n   * @param index The new liquidity index of the reserve\n   **/\n  event Mint(address indexed from, uint256 value, uint256 index);\n\n  /**\n   * @dev Mints `amount` aTokens to `user`\n   * @param user The address receiving the minted tokens\n   * @param amount The amount of tokens getting minted\n   * @param index The new liquidity index of the reserve\n   * @return `true` if the the previous balance of the user was 0\n   */\n  function mint(\n    address user,\n    uint256 amount,\n    uint256 index\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted after aTokens are burned\n   * @param from The owner of the aTokens, getting them burned\n   * @param target The address that will receive the underlying\n   * @param value The amount being burned\n   * @param index The new liquidity index of the reserve\n   **/\n  event Burn(address indexed from, address indexed target, uint256 value, uint256 index);\n\n  /**\n   * @dev Emitted during the transfer action\n   * @param from The user whose tokens are being transferred\n   * @param to The recipient\n   * @param value The amount being transferred\n   * @param index The new liquidity index of the reserve\n   **/\n  event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\n\n  /**\n   * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n   * @param user The owner of the aTokens, getting them burned\n   * @param receiverOfUnderlying The address that will receive the underlying\n   * @param amount The amount being burned\n   * @param index The new liquidity index of the reserve\n   **/\n  function burn(\n    address user,\n    address receiverOfUnderlying,\n    uint256 amount,\n    uint256 index\n  ) external;\n\n  /**\n   * @dev Mints aTokens to the reserve treasury\n   * @param amount The amount of tokens getting minted\n   * @param index The new liquidity index of the reserve\n   */\n  function mintToTreasury(uint256 amount, uint256 index) external;\n\n  /**\n   * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\n   * @param from The address getting liquidated, current owner of the aTokens\n   * @param to The recipient\n   * @param value The amount of tokens getting transferred\n   **/\n  function transferOnLiquidation(\n    address from,\n    address to,\n    uint256 value\n  ) external;\n\n  /**\n   * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\n   * assets in borrow(), withdraw() and flashLoan()\n   * @param user The recipient of the underlying\n   * @param amount The amount getting transferred\n   * @return The amount transferred\n   **/\n  function transferUnderlyingTo(address user, uint256 amount) external returns (uint256);\n\n  /**\n   * @dev Invoked to execute actions on the aToken side after a repayment.\n   * @param user The user executing the repayment\n   * @param amount The amount getting repaid\n   **/\n  function handleRepayment(address user, uint256 amount) external;\n\n  /**\n   * @dev Returns the address of the incentives controller contract\n   **/\n  function getIncentivesController() external view returns (IAaveIncentivesController);\n\n  /**\n   * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   **/\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n}"
    },
    {
      "filename": "interfaces/ICreditDelegationToken.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.6.12;\n\ninterface ICreditDelegationToken {\n  event BorrowAllowanceDelegated(\n    address indexed fromUser,\n    address indexed toUser,\n    address asset,\n    uint256 amount\n  );\n\n  /**\n   * @dev delegates borrowing power to a user on the specific debt token\n   * @param delegatee the address receiving the delegated borrowing power\n   * @param amount the maximum amount being delegated. Delegation will still\n   * respect the liquidation constraints (even if delegated, a delegatee cannot\n   * force a delegator HF to go below 1)\n   **/\n  function approveDelegation(address delegatee, uint256 amount) external;\n\n  /**\n   * @dev returns the borrow allowance of the user\n   * @param fromUser The user to giving allowance\n   * @param toUser The user to give allowance to\n   * @return the current allowance of toUser\n   **/\n  function borrowAllowance(address fromUser, address toUser) external view returns (uint256);\n}"
    },
    {
      "filename": "interfaces/IERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/solc-0.6/contracts/token/ERC20/IERC20.sol\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    {
      "filename": "interfaces/IInitializableAToken.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\n\nimport {ILendingPool} from './IAaveLendingPoolV2.sol';\nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol';\n\n/**\n * @title IInitializableAToken\n * @notice Interface for the initialize function on AToken\n * @author Aave\n **/\ninterface IInitializableAToken {\n  /**\n   * @dev Emitted when an aToken is initialized\n   * @param underlyingAsset The address of the underlying asset\n   * @param pool The address of the associated lending pool\n   * @param treasury The address of the treasury\n   * @param incentivesController The address of the incentives controller for this aToken\n   * @param aTokenDecimals the decimals of the underlying\n   * @param aTokenName the name of the aToken\n   * @param aTokenSymbol the symbol of the aToken\n   * @param params A set of encoded parameters for additional initialization\n   **/\n  event Initialized(\n    address indexed underlyingAsset,\n    address indexed pool,\n    address treasury,\n    address incentivesController,\n    uint8 aTokenDecimals,\n    string aTokenName,\n    string aTokenSymbol,\n    bytes params\n  );\n\n  /**\n   * @dev Initializes the aToken\n   * @param pool The address of the lending pool where this aToken will be used\n   * @param treasury The address of the Aave treasury, receiving the fees on this aToken\n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   * @param incentivesController The smart contract managing potential incentives distribution\n   * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\n   * @param aTokenName The name of the aToken\n   * @param aTokenSymbol The symbol of the aToken\n   */\n  function initialize(\n    ILendingPool pool,\n    address treasury,\n    address underlyingAsset,\n    IAaveIncentivesController incentivesController,\n    uint8 aTokenDecimals,\n    string calldata aTokenName,\n    string calldata aTokenSymbol,\n    bytes calldata params\n  ) external;\n}"
    },
    {
      "filename": "interfaces/ILendingPoolConfigurator.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface ILendingPoolConfigurator {\n\n  function batchInitReserve(InitReserveInput[] calldata input) external;\n  function configureReserveAsCollateral(\n    address asset,\n    uint256 ltv,\n    uint256 liquidationThreshold,\n    uint256 liquidationBonus\n  ) external;\n\n  function enableBorrowingOnReserve(address asset, bool stableBorrowRateEnabled) external;\n  function setReserveFactor(address asset, uint256 reserveFactor) external;\n  function deactivateReserve(address asset) external;\n  function freezeReserve(address asset) external;\n\n  struct InitReserveInput {\n    address aTokenImpl;\n    address stableDebtTokenImpl;\n    address variableDebtTokenImpl;\n    uint8 underlyingAssetDecimals;\n    address interestRateStrategyAddress;\n    address underlyingAsset;\n    address treasury;\n    address incentivesController;\n    string underlyingAssetName;\n    string aTokenName;\n    string aTokenSymbol;\n    string variableDebtTokenName;\n    string variableDebtTokenSymbol;\n    string stableDebtTokenName;\n    string stableDebtTokenSymbol;\n    bytes params;\n  }\n\n  struct UpdateATokenInput {\n    address asset;\n    address treasury;\n    address incentivesController;\n    string name;\n    string symbol;\n    address implementation;\n    bytes params;\n  }\n\n  struct UpdateDebtTokenInput {\n    address asset;\n    address incentivesController;\n    string name;\n    string symbol;\n    address implementation;\n    bytes params;\n  }\n\n  /**\n   * @dev Emitted when a reserve is initialized.\n   * @param asset The address of the underlying asset of the reserve\n   * @param aToken The address of the associated aToken contract\n   * @param stableDebtToken The address of the associated stable rate debt token\n   * @param variableDebtToken The address of the associated variable rate debt token\n   * @param interestRateStrategyAddress The address of the interest rate strategy for the reserve\n   **/\n  event ReserveInitialized(\n    address indexed asset,\n    address indexed aToken,\n    address stableDebtToken,\n    address variableDebtToken,\n    address interestRateStrategyAddress\n  );\n\n  /**\n   * @dev Emitted when borrowing is enabled on a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param stableRateEnabled True if stable rate borrowing is enabled, false otherwise\n   **/\n  event BorrowingEnabledOnReserve(address indexed asset, bool stableRateEnabled);\n\n  /**\n   * @dev Emitted when borrowing is disabled on a reserve\n   * @param asset The address of the underlying asset of the reserve\n   **/\n  event BorrowingDisabledOnReserve(address indexed asset);\n\n  /**\n   * @dev Emitted when the collateralization risk parameters for the specified asset are updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param ltv The loan to value of the asset when used as collateral\n   * @param liquidationThreshold The threshold at which loans using this asset as collateral will be considered undercollateralized\n   * @param liquidationBonus The bonus liquidators receive to liquidate this asset\n   **/\n  event CollateralConfigurationChanged(\n    address indexed asset,\n    uint256 ltv,\n    uint256 liquidationThreshold,\n    uint256 liquidationBonus\n  );\n\n  /**\n   * @dev Emitted when stable rate borrowing is enabled on a reserve\n   * @param asset The address of the underlying asset of the reserve\n   **/\n  event StableRateEnabledOnReserve(address indexed asset);\n\n  /**\n   * @dev Emitted when stable rate borrowing is disabled on a reserve\n   * @param asset The address of the underlying asset of the reserve\n   **/\n  event StableRateDisabledOnReserve(address indexed asset);\n\n  /**\n   * @dev Emitted when a reserve is activated\n   * @param asset The address of the underlying asset of the reserve\n   **/\n  event ReserveActivated(address indexed asset);\n\n  /**\n   * @dev Emitted when a reserve is deactivated\n   * @param asset The address of the underlying asset of the reserve\n   **/\n  event ReserveDeactivated(address indexed asset);\n\n  /**\n   * @dev Emitted when a reserve is frozen\n   * @param asset The address of the underlying asset of the reserve\n   **/\n  event ReserveFrozen(address indexed asset);\n\n  /**\n   * @dev Emitted when a reserve is unfrozen\n   * @param asset The address of the underlying asset of the reserve\n   **/\n  event ReserveUnfrozen(address indexed asset);\n\n  /**\n   * @dev Emitted when a reserve factor is updated\n   * @param asset The address of the underlying asset of the reserve\n   * @param factor The new reserve factor\n   **/\n  event ReserveFactorChanged(address indexed asset, uint256 factor);\n\n  /**\n   * @dev Emitted when the reserve decimals are updated\n   * @param asset The address of the underlying asset of the reserve\n   * @param decimals The new decimals\n   **/\n  event ReserveDecimalsChanged(address indexed asset, uint256 decimals);\n\n  /**\n   * @dev Emitted when a reserve interest strategy contract is updated\n   * @param asset The address of the underlying asset of the reserve\n   * @param strategy The new address of the interest strategy contract\n   **/\n  event ReserveInterestRateStrategyChanged(address indexed asset, address strategy);\n\n  /**\n   * @dev Emitted when an aToken implementation is upgraded\n   * @param asset The address of the underlying asset of the reserve\n   * @param proxy The aToken proxy address\n   * @param implementation The new aToken implementation\n   **/\n  event ATokenUpgraded(\n    address indexed asset,\n    address indexed proxy,\n    address indexed implementation\n  );\n\n  /**\n   * @dev Emitted when the implementation of a stable debt token is upgraded\n   * @param asset The address of the underlying asset of the reserve\n   * @param proxy The stable debt token proxy address\n   * @param implementation The new aToken implementation\n   **/\n  event StableDebtTokenUpgraded(\n    address indexed asset,\n    address indexed proxy,\n    address indexed implementation\n  );\n\n  /**\n   * @dev Emitted when the implementation of a variable debt token is upgraded\n   * @param asset The address of the underlying asset of the reserve\n   * @param proxy The variable debt token proxy address\n   * @param implementation The new aToken implementation\n   **/\n  event VariableDebtTokenUpgraded(\n    address indexed asset,\n    address indexed proxy,\n    address indexed implementation\n  );\n}"
    },
    {
      "filename": "interfaces/IScaledBalanceToken.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.6.12;\n\ninterface IScaledBalanceToken {\n  /**\n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\n   * updated stored balance divided by the reserve's liquidity index at the moment of the update\n   * @param user The user whose balance is calculated\n   * @return The scaled balance of the user\n   **/\n  function scaledBalanceOf(address user) external view returns (uint256);\n\n  /**\n   * @dev Returns the scaled balance of the user and the scaled total supply.\n   * @param user The address of the user\n   * @return The scaled balance of the user\n   * @return The scaled balance and the scaled total supply\n   **/\n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\n\n  /**\n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n   * @return The scaled total supply\n   **/\n  function scaledTotalSupply() external view returns (uint256);\n}"
    }
  ]
}