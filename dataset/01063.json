{
  "Title": "H-2: Oracle.sol: manipulation via increasing Uniswap V3 pool observationCardinality",
  "Content": "# Issue H-2: Oracle.sol: manipulation via increasing Uniswap V3 pool observationCardinality \n\nSource: https://github.com/sherlock-audit/2023-10-aloe-judging/issues/40 \n\n## Found by \nroguereddwarf\nThis issue deals with how the `Oracle.consult` function can be provided with a malicious `seed` such as to return wrong results.  \n\nThis is a complex issue that requires multiple steps to be executed in order to set up and execute the attack.  \n\nIn depth knowledge of the UniswapV3 `observationCardinality` concept is needed as well as a wholesome understanding of the Aloe II protocol.  \n\nThis issue can occur as a result of an intentional attack but also as part of regular operation without attention to attack the protocol (even though unlikely).  \n\nThe corrupted data that the `Oracle.consult` function provides as a result of this issue is used upstream by the `VolatilityOracle`.  \n\nThe attack path is quite involved. However by exploiting this issue, the TWAP price can be manipulated as well as implied volatility (IV) and the probe prices.\n\n## Vulnerability Detail\nThe [`Oracle.consult`](https://github.com/aloelabs/aloe-ii/blob/c71e7b0cfdec830b1f054486dfe9d58ce407c7a4/core/src/libraries/Oracle.sol#L42-L137) function takes a `uint40 seed` parameter and can be used in either of two ways:  \n1. Set the highest 8 bit to a non-zero value [to use Uniswap V3's binary search to get observations](https://github.com/aloelabs/aloe-ii/blob/c71e7b0cfdec830b1f054486dfe9d58ce407c7a4/core/src/libraries/Oracle.sol#L51-L56)\n2. Set the highest 8 bit to zero and use the lower 32 bits to provide hints and [use the more efficient internal `Oracle.observe` function to get the observations](https://github.com/aloelabs/aloe-ii/blob/c71e7b0cfdec830b1f054486dfe9d58ce407c7a4/core/src/libraries/Oracle.sol#L57-L81)\n\nThe code for Aloe's [`Oracle.observe`](https://github.com/aloelabs/aloe-ii/blob/c71e7b0cfdec830b1f054486dfe9d58ce407c7a4/core/src/libraries/Oracle.sol#L161-L205) function is adapted from Uniswap V3's [Oracle library](https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/Oracle.sol).\n\nTo understand this issue it is necessary to understand Uniswap V3's `observationCardinality` concept.\n\nA deep dive can be found [here](https://uniswapv3book.com/docs/milestone_5/price-oracle/#observations-and-cardinality).  \n\nIn short, it is a circular array of variable size. The size of the array can be increased by ANYONE via calling [`Pool.increaseObservationCardinalityNext`](https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/UniswapV3Pool.sol#L255-L267).  \n\nThe Uniswap V3 [`Oracle.write`](https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/libraries/Oracle.sol#L78-L101) function will then take care of actually expanding the array once the current index has reached the end of the array. \n\nAs can be seen in [this](https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/libraries/Oracle.sol#L108-L120) function, uninitialized entries in the array have their timestamp set to `1`.  \n\nAnd all other values in the observation struct (array element) are set to zero:  \n\n```solidity\nstruct Observation {\n    // the block timestamp of the observation\n    uint32 blockTimestamp;\n    // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized\n    int56 tickCumulative;\n    // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized\n    uint160 secondsPerLiquidityCumulativeX128;\n    // whether or not the observation is initialized\n    bool initialized;\n}\n```\n\nHere's an example for a simplified array to illustrate how the Aloe `Oracle.observe` function might read an invalid value:  \n\n```text\nAssume we are looking for the target=10 timestamp.\n\nAnd the observations array looks like this (element values are timestamps):\n\n| 12 | 20 | 25 | 30 | 1 | 1 | 1 |\n\nThe length of the array is 7.\n\nLet's say we provide the index 6 as the seed and the current observationIndex is 3 (i.e. pointing to timestamp 30)\n\nThe Oracle.observe function then chooses 1 as the left timestamp and 12 as the right timestamp.\n\nThis means the invalid and uninitialized element at index 6 with timestamp 1 will be used to calculate the Oracle values.\n```\n\n[Here](https://github.com/aloelabs/aloe-ii/blob/c71e7b0cfdec830b1f054486dfe9d58ce407c7a4/core/src/libraries/Oracle.sol#L190-L198) is the section of the `Oracle.observe` function where the invalid element is used to calculate the result.  \n\nBy updating the observations (e.g. swaps in the Uniswap pool), an attacker can influence the value that is written on the left of the array, i.e. he can arrange for a scenario such that he can make the Aloe `Oracle` read a wrong value.  \n\nUpstream this causes the Aloe `Oracle` to continue calculation with `tickCumulatives` and `secondsPerLiquidityCumulativeX128s` haing a corrupted value. Either `secondsPerLiquidityCumulativeX128s[0]`, `tickCumulatives[0]` AND `secondsPerLiquidityCumulativeX128s[1]`, `tickCumulatives[1]` or only `secondsPerLiquidityCumulativeX128s[0]`, `tickCumulatives[0]` are assigned invalid values (depending on what the timestamp on the left of the array is).\n\n## Impact\nThe corrupted values are then used in the [further calculations](https://github.com/aloelabs/aloe-ii/blob/c71e7b0cfdec830b1f054486dfe9d58ce407c7a4/core/src/libraries/Oracle.sol#L84-L135) in `Oracle.consult` which reports its results upstream to `VolatilityOracle.update` and `VolatilityOracle.consult`, making their way into the core application.  \n\nThe TWAP price can be inflated such that bad debt can be taken on due to inflated valuation of Uniswap V3 liqudity.\n\nBesides that there are virtually endless possibilities for an attacker to exploit this scenario since the Oracle is at the very heart of the Aloe application and it's impossible to foresee all the permutations of values that a determined attacker may use.\n\nE.g. the TWAP price is used for liquidations where an incorrect TWAP price can lead to profit.\nIf the protocol expects you to exchange 1 BTC for 10k USDC, then you end up with ~20k profit.\n\nSince an attacker can make this scenario occur on purpose by updating the Uniswap observations (e.g. by executing swaps) and increasing observation cardinality, the severity of this finding is \"High\".  \n\n## Code Snippet\nAffected `Oracle.observe` function from Aloe II:\nhttps://github.com/aloelabs/aloe-ii/blob/c71e7b0cfdec830b1f054486dfe9d58ce407c7a4/core/src/libraries/Oracle.sol#L57-L81\n\n`Oracle` library from Uniswap V3 to see how to implement the necessary check for the `initialized` property:\nhttps://github.com/Uniswap/v3-core/blob/main/contracts/libraries/Oracle.sol\n\n## Tool used\nManual Review\n\n## Recommendation\nThe `Oracle.observe` function must not consider observations as valid that have not been initialized.  \n\nThis means the `initialized` field must be queried [here](https://github.com/aloelabs/aloe-ii/blob/c71e7b0cfdec830b1f054486dfe9d58ce407c7a4/core/src/libraries/Oracle.sol#L188) and [here](https://github.com/aloelabs/aloe-ii/blob/c71e7b0cfdec830b1f054486dfe9d58ce407c7a4/core/src/libraries/Oracle.sol#L171) and must be skipped over.  \n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> high, great valid finding. It appears the price can only be made extremely high and most probably it's almost impossible to avoid seemsLegit to be true (because only one of the 2W-W or W-0 windows can be manipulated, the other will have correct value), but due to another bug, liquidation ignores seemsLegit, so at the very least this manipulation allows to liquidate almost all accounts with borrows, which is enough for it to be high.\n\n**MohammedRizwan** commented:\n>  seems intended design\n\n\n\n**haydenshively**\n\nJust note that #114 is not a duplicate.\n\n**haydenshively**\n\nFixed in https://github.com/aloelabs/aloe-ii/pull/217\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/120",
  "Code": [
    {
      "filename": "core/src/libraries/Oracle.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\nimport {FixedPointMathLib as SoladyMath} from \"solady/utils/FixedPointMathLib.sol\";\nimport {IUniswapV3Pool} from \"v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport {UNISWAP_AVG_WINDOW} from \"./constants/Constants.sol\";\nimport {Q16} from \"./constants/Q.sol\";\nimport {TickMath} from \"./TickMath.sol\";\n\n/// @title Oracle\n/// @notice Provides functions to integrate with V3 pool oracle\n/// @author Aloe Labs, Inc.\n/// @author Modified from [Uniswap](https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/OracleLibrary.sol)\nlibrary Oracle {\n    struct PoolData {\n        // the current price (from pool.slot0())\n        uint160 sqrtPriceX96;\n        // the current tick (from pool.slot0())\n        int24 currentTick;\n        // the mean sqrt(price) over some period (OracleLibrary.consult() to get arithmeticMeanTick, then use TickMath)\n        uint160 sqrtMeanPriceX96;\n        // the mean liquidity over some period (OracleLibrary.consult())\n        uint160 secondsPerLiquidityX128;\n        // the number of seconds to look back when getting mean tick & mean liquidity\n        uint32 oracleLookback;\n        // the liquidity depth at currentTick (from pool.liquidity())\n        uint128 tickLiquidity;\n    }\n\n    /**\n     * @notice Calculates time-weighted means of tick and liquidity for a given Uniswap V3 pool\n     * @param pool Address of the pool that we want to observe\n     * @param seed The indices of `pool.observations` where we start our search for the 30-minute-old (lowest 16 bits)\n     * and 60-minute-old (next 16 bits) observations. Determine these off-chain to make this method more efficient\n     * than Uniswap's binary search. If any of the highest 8 bits are set, we fallback to onchain binary search.\n     * @return data An up-to-date `PoolData` struct containing all fields except `oracleLookback` and `tickLiquidity`\n     * @return metric If the price was manipulated at any point in the past `UNISWAP_AVG_WINDOW` seconds, then at\n     * some point in that period, this value will spike. It may still be high now, or (if the attacker is smart and\n     * well-financed) it may have returned to nominal.\n     */\n    function consult(IUniswapV3Pool pool, uint40 seed) internal view returns (PoolData memory data, uint56 metric) {\n        uint16 observationIndex;\n        uint16 observationCardinality;\n        (data.sqrtPriceX96, data.currentTick, observationIndex, observationCardinality, , , ) = pool.slot0();\n\n        unchecked {\n            int56[] memory tickCumulatives = new int56[](3);\n            uint160[] memory secondsPerLiquidityCumulativeX128s = new uint160[](3);\n\n            if ((seed >> 32) > 0) {\n                uint32[] memory secondsAgos = new uint32[](3);\n                secondsAgos[0] = UNISWAP_AVG_WINDOW * 2;\n                secondsAgos[1] = UNISWAP_AVG_WINDOW;\n                secondsAgos[2] = 0;\n                (tickCumulatives, secondsPerLiquidityCumulativeX128s) = pool.observe(secondsAgos);\n            } else {\n                (tickCumulatives[0], ) = observe(\n                    pool,\n                    uint32(block.timestamp - UNISWAP_AVG_WINDOW * 2),\n                    seed >> 16,\n                    data.currentTick,\n                    observationIndex,\n                    observationCardinality\n                );\n                (tickCumulatives[1], secondsPerLiquidityCumulativeX128s[1]) = observe(\n                    pool,\n                    uint32(block.timestamp - UNISWAP_AVG_WINDOW),\n                    seed % Q16,\n                    data.currentTick,\n                    observationIndex,\n                    observationCardinality\n                );\n                (tickCumulatives[2], secondsPerLiquidityCumulativeX128s[2]) = observe(\n                    pool,\n                    uint32(block.timestamp),\n                    observationIndex,\n                    data.currentTick,\n                    observationIndex,\n                    observationCardinality\n                );\n            }\n\n            data.secondsPerLiquidityX128 =\n                secondsPerLiquidityCumulativeX128s[2] -\n                secondsPerLiquidityCumulativeX128s[1];\n\n            // Compute arithmetic mean tick over `UNISWAP_AVG_WINDOW`, always rounding down to -inf\n            int256 delta = tickCumulatives[2] - tickCumulatives[1];\n            int256 meanTick0ToW = delta / int32(UNISWAP_AVG_WINDOW);\n            assembly (\"memory-safe\") {\n                // Equivalent: if (delta < 0 && (delta % UNISWAP_AVG_WINDOW != 0)) meanTick0ToW--;\n                meanTick0ToW := sub(meanTick0ToW, and(slt(delta, 0), iszero(iszero(smod(delta, UNISWAP_AVG_WINDOW)))))\n            }\n            data.sqrtMeanPriceX96 = TickMath.getSqrtRatioAtTick(int24(meanTick0ToW));\n\n            // Compute arithmetic mean tick over the interval [-2w, 0)\n            int256 meanTick0To2W = (tickCumulatives[2] - tickCumulatives[0]) / int32(UNISWAP_AVG_WINDOW * 2);\n            // Compute arithmetic mean tick over the interval [-2w, -w]\n            int256 meanTickWTo2W = (tickCumulatives[1] - tickCumulatives[0]) / int32(UNISWAP_AVG_WINDOW);\n            //                                         i                 i-2w                       i-w               i-2w\n            //        meanTick0To2W - meanTickWTo2W = (∑ tick_n * dt_n - ∑ tick_n * dt_n) / (2T) - (∑ tick_n * dt_n - ∑ tick_n * dt_n) / T\n            //                                         n=0               n=0                        n=0               n=0\n            //\n            //                                        i                   i-w\n            // 2T * (meanTick0To2W - meanTickWTo2W) = ∑ tick_n * dt_n  - 2∑ tick_n * dt_n\n            //                                        n=i-2w              n=i-2w\n            //\n            //                                        i                   i-w\n            //                                      = ∑ tick_n * dt_n  -  ∑ tick_n * dt_n\n            //                                        n=i-w               n=i-2w\n            //\n            // Thus far all values have been \"true\". We now assume that some manipulated value `manip_n` is added to each `tick_n`\n            //\n            //                                        i                               i-w\n            //                                      = ∑ (tick_n + manip_n) * dt_n  -  ∑ (tick_n + manip_n) * dt_n\n            //                                        n=i-w                           n=i-2w\n            //\n            //                                        i                   i-w                 i                    i-w\n            //                                      = ∑ tick_n * dt_n  -  ∑ tick_n * dt_n  +  ∑ manip_n * dt_n  -  ∑ manip_n * dt_n\n            //                                        n=i-w               n=i-2w              n=i-w                n=i-2w\n            //\n            //        meanTick0To2W - meanTickWTo2W = (meanTick0ToW_true - meanTickWTo2W_true) / 2  +  (sumManip0ToW - sumManipWTo2W) / (2T)\n            //\n            // For short time periods and reasonable market conditions, (meanTick0ToW_true - meanTickWTo2W_true) ≈ 0\n            //\n            //                                      ≈ (sumManip0ToW - sumManipWTo2W) / (2T)\n            //\n            // The TWAP we care about (see a few lines down) is measured over the interval [-w, 0). The result we've\n            // just derived contains `sumManip0ToW`, which is the sum of all manipulation in that same interval. As\n            // such, we use it as a metric for detecting manipulation. NOTE: If an attacker manipulates things to\n            // the same extent in the prior interval [-2w, -w), the metric will be 0. To guard against this, we must\n            // to watch the metric over the entire window. Even though it may be 0 *now*, it will have risen past a\n            // threshold at *some point* in the past `UNISWAP_AVG_WINDOW` seconds.\n            metric = uint56(SoladyMath.dist(meanTick0To2W, meanTickWTo2W));\n        }\n    }\n\n    /**\n     * @notice Searches for oracle observations nearest to the `target` time. If `target` lies between two existing\n     * observations, linearly interpolate between them. If `target` is newer than the most recent observation,\n     * we interpolate between the most recent one and a hypothetical one taken at the current block.\n     * @dev As long as `target <= block.timestamp`, return values should match what you'd get from Uniswap.\n     * @custom:example ```solidity\n     *   uint32[] memory secondsAgos = new uint32[](1);\n     *   secondsAgos[0] = block.timestamp - target;\n     *   (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) = pool.observe(\n     *     secondsAgos\n     *   );\n     * ```\n     * @param pool The Uniswap pool to examine\n     * @param target The timestamp of the desired observation\n     * @param seed The index of `pool.observations` where we start our search. Can be determined off-chain to make\n     * this method more efficient than Uniswap's binary search.\n     * @param tick The current tick (from `pool.slot0()`)\n     * @param observationIndex The current observation index (from `pool.slot0()`)\n     * @param observationCardinality The current observation cardinality (from `pool.slot0()`)\n     * @return The tick * time elapsed since `pool` was first initialized\n     * @return The time elapsed / max(1, liquidity) since `pool` was first initialized\n     */\n    function observe(\n        IUniswapV3Pool pool,\n        uint32 target,\n        uint256 seed,\n        int24 tick,\n        uint16 observationIndex,\n        uint16 observationCardinality\n    ) internal view returns (int56, uint160) {\n        unchecked {\n            seed %= observationCardinality;\n            (uint32 timeL, int56 tickCumL, uint160 liqCumL, ) = pool.observations(seed);\n\n            for (uint256 i = 0; i < observationCardinality; i++) {\n                if (timeL == target) {\n                    return (tickCumL, liqCumL);\n                }\n\n                if (timeL < target && seed == observationIndex) {\n                    uint56 delta = uint56(target - timeL);\n                    uint128 liquidity = pool.liquidity();\n                    return (\n                        tickCumL + tick * int56(delta),\n                        liqCumL + (uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)\n                    );\n                }\n\n                seed = (seed + 1) % observationCardinality;\n                (uint32 timeR, int56 tickCumR, uint160 liqCumR, ) = pool.observations(seed);\n\n                if (timeL < target && target < timeR) {\n                    uint56 delta = uint56(target - timeL);\n                    uint56 denom = uint56(timeR - timeL);\n                    // Uniswap divides before multiplying, so we do too\n                    return (\n                        tickCumL + ((tickCumR - tickCumL) / int56(denom)) * int56(delta),\n                        liqCumL + uint160(((liqCumR - liqCumL) * delta) / denom)\n                    );\n                }\n\n                (timeL, tickCumL, liqCumL) = (timeR, tickCumR, liqCumR);\n            }\n\n            revert(\"OLD\");\n        }\n    }\n\n    /**\n     * @notice Given a pool, returns the number of seconds ago of the oldest stored observation\n     * @param pool Address of Uniswap V3 pool that we want to observe\n     * @param observationIndex The observation index from pool.slot0()\n     * @param observationCardinality The observationCardinality from pool.slot0()\n     * @dev `(, , uint16 observationIndex, uint16 observationCardinality, , , ) = pool.slot0();`\n     * @return secondsAgo The number of seconds ago that the oldest observation was stored\n     */\n    function getMaxSecondsAgo(\n        IUniswapV3Pool pool,\n        uint16 observationIndex,\n        uint16 observationCardinality\n    ) internal view returns (uint32 secondsAgo) {\n        require(observationCardinality != 0, \"NI\");\n\n        unchecked {\n            (uint32 observationTimestamp, , , bool initialized) = pool.observations(\n                (observationIndex + 1) % observationCardinality\n            );\n\n            // The next index might not be initialized if the cardinality is in the process of increasing\n            // In this case the oldest observation is always in index 0\n            if (!initialized) {\n                (observationTimestamp, , , ) = pool.observations(0);\n            }\n\n            secondsAgo = uint32(block.timestamp) - observationTimestamp;\n        }\n    }\n}"
    },
    {
      "filename": "core/src/libraries/Oracle.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\nimport {FixedPointMathLib as SoladyMath} from \"solady/utils/FixedPointMathLib.sol\";\nimport {IUniswapV3Pool} from \"v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport {UNISWAP_AVG_WINDOW} from \"./constants/Constants.sol\";\nimport {Q16} from \"./constants/Q.sol\";\nimport {TickMath} from \"./TickMath.sol\";\n\n/// @title Oracle\n/// @notice Provides functions to integrate with V3 pool oracle\n/// @author Aloe Labs, Inc.\n/// @author Modified from [Uniswap](https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/OracleLibrary.sol)\nlibrary Oracle {\n    struct PoolData {\n        // the current price (from pool.slot0())\n        uint160 sqrtPriceX96;\n        // the current tick (from pool.slot0())\n        int24 currentTick;\n        // the mean sqrt(price) over some period (OracleLibrary.consult() to get arithmeticMeanTick, then use TickMath)\n        uint160 sqrtMeanPriceX96;\n        // the mean liquidity over some period (OracleLibrary.consult())\n        uint160 secondsPerLiquidityX128;\n        // the number of seconds to look back when getting mean tick & mean liquidity\n        uint32 oracleLookback;\n        // the liquidity depth at currentTick (from pool.liquidity())\n        uint128 tickLiquidity;\n    }\n\n    /**\n     * @notice Calculates time-weighted means of tick and liquidity for a given Uniswap V3 pool\n     * @param pool Address of the pool that we want to observe\n     * @param seed The indices of `pool.observations` where we start our search for the 30-minute-old (lowest 16 bits)\n     * and 60-minute-old (next 16 bits) observations. Determine these off-chain to make this method more efficient\n     * than Uniswap's binary search. If any of the highest 8 bits are set, we fallback to onchain binary search.\n     * @return data An up-to-date `PoolData` struct containing all fields except `oracleLookback` and `tickLiquidity`\n     * @return metric If the price was manipulated at any point in the past `UNISWAP_AVG_WINDOW` seconds, then at\n     * some point in that period, this value will spike. It may still be high now, or (if the attacker is smart and\n     * well-financed) it may have returned to nominal.\n     */\n    function consult(IUniswapV3Pool pool, uint40 seed) internal view returns (PoolData memory data, uint56 metric) {\n        uint16 observationIndex;\n        uint16 observationCardinality;\n        (data.sqrtPriceX96, data.currentTick, observationIndex, observationCardinality, , , ) = pool.slot0();\n\n        unchecked {\n            int56[] memory tickCumulatives = new int56[](3);\n            uint160[] memory secondsPerLiquidityCumulativeX128s = new uint160[](3);\n\n            if ((seed >> 32) > 0) {\n                uint32[] memory secondsAgos = new uint32[](3);\n                secondsAgos[0] = UNISWAP_AVG_WINDOW * 2;\n                secondsAgos[1] = UNISWAP_AVG_WINDOW;\n                secondsAgos[2] = 0;\n                (tickCumulatives, secondsPerLiquidityCumulativeX128s) = pool.observe(secondsAgos);\n            } else {\n                (tickCumulatives[0], ) = observe(\n                    pool,\n                    uint32(block.timestamp - UNISWAP_AVG_WINDOW * 2),\n                    seed >> 16,\n                    data.currentTick,\n                    observationIndex,\n                    observationCardinality\n                );\n                (tickCumulatives[1], secondsPerLiquidityCumulativeX128s[1]) = observe(\n                    pool,\n                    uint32(block.timestamp - UNISWAP_AVG_WINDOW),\n                    seed % Q16,\n                    data.currentTick,\n                    observationIndex,\n                    observationCardinality\n                );\n                (tickCumulatives[2], secondsPerLiquidityCumulativeX128s[2]) = observe(\n                    pool,\n                    uint32(block.timestamp),\n                    observationIndex,\n                    data.currentTick,\n                    observationIndex,\n                    observationCardinality\n                );\n            }\n\n            data.secondsPerLiquidityX128 =\n                secondsPerLiquidityCumulativeX128s[2] -\n                secondsPerLiquidityCumulativeX128s[1];\n\n            // Compute arithmetic mean tick over `UNISWAP_AVG_WINDOW`, always rounding down to -inf\n            int256 delta = tickCumulatives[2] - tickCumulatives[1];\n            int256 meanTick0ToW = delta / int32(UNISWAP_AVG_WINDOW);\n            assembly (\"memory-safe\") {\n                // Equivalent: if (delta < 0 && (delta % UNISWAP_AVG_WINDOW != 0)) meanTick0ToW--;\n                meanTick0ToW := sub(meanTick0ToW, and(slt(delta, 0), iszero(iszero(smod(delta, UNISWAP_AVG_WINDOW)))))\n            }\n            data.sqrtMeanPriceX96 = TickMath.getSqrtRatioAtTick(int24(meanTick0ToW));\n\n            // Compute arithmetic mean tick over the interval [-2w, 0)\n            int256 meanTick0To2W = (tickCumulatives[2] - tickCumulatives[0]) / int32(UNISWAP_AVG_WINDOW * 2);\n            // Compute arithmetic mean tick over the interval [-2w, -w]\n            int256 meanTickWTo2W = (tickCumulatives[1] - tickCumulatives[0]) / int32(UNISWAP_AVG_WINDOW);\n            //                                         i                 i-2w                       i-w               i-2w\n            //        meanTick0To2W - meanTickWTo2W = (∑ tick_n * dt_n - ∑ tick_n * dt_n) / (2T) - (∑ tick_n * dt_n - ∑ tick_n * dt_n) / T\n            //                                         n=0               n=0                        n=0               n=0\n            //\n            //                                        i                   i-w\n            // 2T * (meanTick0To2W - meanTickWTo2W) = ∑ tick_n * dt_n  - 2∑ tick_n * dt_n\n            //                                        n=i-2w              n=i-2w\n            //\n            //                                        i                   i-w\n            //                                      = ∑ tick_n * dt_n  -  ∑ tick_n * dt_n\n            //                                        n=i-w               n=i-2w\n            //\n            // Thus far all values have been \"true\". We now assume that some manipulated value `manip_n` is added to each `tick_n`\n            //\n            //                                        i                               i-w\n            //                                      = ∑ (tick_n + manip_n) * dt_n  -  ∑ (tick_n + manip_n) * dt_n\n            //                                        n=i-w                           n=i-2w\n            //\n            //                                        i                   i-w                 i                    i-w\n            //                                      = ∑ tick_n * dt_n  -  ∑ tick_n * dt_n  +  ∑ manip_n * dt_n  -  ∑ manip_n * dt_n\n            //                                        n=i-w               n=i-2w              n=i-w                n=i-2w\n            //\n            //        meanTick0To2W - meanTickWTo2W = (meanTick0ToW_true - meanTickWTo2W_true) / 2  +  (sumManip0ToW - sumManipWTo2W) / (2T)\n            //\n            // For short time periods and reasonable market conditions, (meanTick0ToW_true - meanTickWTo2W_true) ≈ 0\n            //\n            //                                      ≈ (sumManip0ToW - sumManipWTo2W) / (2T)\n            //\n            // The TWAP we care about (see a few lines down) is measured over the interval [-w, 0). The result we've\n            // just derived contains `sumManip0ToW`, which is the sum of all manipulation in that same interval. As\n            // such, we use it as a metric for detecting manipulation. NOTE: If an attacker manipulates things to\n            // the same extent in the prior interval [-2w, -w), the metric will be 0. To guard against this, we must\n            // to watch the metric over the entire window. Even though it may be 0 *now*, it will have risen past a\n            // threshold at *some point* in the past `UNISWAP_AVG_WINDOW` seconds.\n            metric = uint56(SoladyMath.dist(meanTick0To2W, meanTickWTo2W));\n        }\n    }\n\n    /**\n     * @notice Searches for oracle observations nearest to the `target` time. If `target` lies between two existing\n     * observations, linearly interpolate between them. If `target` is newer than the most recent observation,\n     * we interpolate between the most recent one and a hypothetical one taken at the current block.\n     * @dev As long as `target <= block.timestamp`, return values should match what you'd get from Uniswap.\n     * @custom:example ```solidity\n     *   uint32[] memory secondsAgos = new uint32[](1);\n     *   secondsAgos[0] = block.timestamp - target;\n     *   (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) = pool.observe(\n     *     secondsAgos\n     *   );\n     * ```\n     * @param pool The Uniswap pool to examine\n     * @param target The timestamp of the desired observation\n     * @param seed The index of `pool.observations` where we start our search. Can be determined off-chain to make\n     * this method more efficient than Uniswap's binary search.\n     * @param tick The current tick (from `pool.slot0()`)\n     * @param observationIndex The current observation index (from `pool.slot0()`)\n     * @param observationCardinality The current observation cardinality (from `pool.slot0()`)\n     * @return The tick * time elapsed since `pool` was first initialized\n     * @return The time elapsed / max(1, liquidity) since `pool` was first initialized\n     */\n    function observe(\n        IUniswapV3Pool pool,\n        uint32 target,\n        uint256 seed,\n        int24 tick,\n        uint16 observationIndex,\n        uint16 observationCardinality\n    ) internal view returns (int56, uint160) {\n        unchecked {\n            seed %= observationCardinality;\n            (uint32 timeL, int56 tickCumL, uint160 liqCumL, ) = pool.observations(seed);\n\n            for (uint256 i = 0; i < observationCardinality; i++) {\n                if (timeL == target) {\n                    return (tickCumL, liqCumL);\n                }\n\n                if (timeL < target && seed == observationIndex) {\n                    uint56 delta = uint56(target - timeL);\n                    uint128 liquidity = pool.liquidity();\n                    return (\n                        tickCumL + tick * int56(delta),\n                        liqCumL + (uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)\n                    );\n                }\n\n                seed = (seed + 1) % observationCardinality;\n                (uint32 timeR, int56 tickCumR, uint160 liqCumR, ) = pool.observations(seed);\n\n                if (timeL < target && target < timeR) {\n                    uint56 delta = uint56(target - timeL);\n                    uint56 denom = uint56(timeR - timeL);\n                    // Uniswap divides before multiplying, so we do too\n                    return (\n                        tickCumL + ((tickCumR - tickCumL) / int56(denom)) * int56(delta),\n                        liqCumL + uint160(((liqCumR - liqCumL) * delta) / denom)\n                    );\n                }\n\n                (timeL, tickCumL, liqCumL) = (timeR, tickCumR, liqCumR);\n            }\n\n            revert(\"OLD\");\n        }\n    }\n\n    /**\n     * @notice Given a pool, returns the number of seconds ago of the oldest stored observation\n     * @param pool Address of Uniswap V3 pool that we want to observe\n     * @param observationIndex The observation index from pool.slot0()\n     * @param observationCardinality The observationCardinality from pool.slot0()\n     * @dev `(, , uint16 observationIndex, uint16 observationCardinality, , , ) = pool.slot0();`\n     * @return secondsAgo The number of seconds ago that the oldest observation was stored\n     */\n    function getMaxSecondsAgo(\n        IUniswapV3Pool pool,\n        uint16 observationIndex,\n        uint16 observationCardinality\n    ) internal view returns (uint32 secondsAgo) {\n        require(observationCardinality != 0, \"NI\");\n\n        unchecked {\n            (uint32 observationTimestamp, , , bool initialized) = pool.observations(\n                (observationIndex + 1) % observationCardinality\n            );\n\n            // The next index might not be initialized if the cardinality is in the process of increasing\n            // In this case the oldest observation is always in index 0\n            if (!initialized) {\n                (observationTimestamp, , , ) = pool.observations(0);\n            }\n\n            secondsAgo = uint32(block.timestamp) - observationTimestamp;\n        }\n    }\n}"
    },
    {
      "filename": "core/src/libraries/Oracle.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\nimport {FixedPointMathLib as SoladyMath} from \"solady/utils/FixedPointMathLib.sol\";\nimport {IUniswapV3Pool} from \"v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport {UNISWAP_AVG_WINDOW} from \"./constants/Constants.sol\";\nimport {Q16} from \"./constants/Q.sol\";\nimport {TickMath} from \"./TickMath.sol\";\n\n/// @title Oracle\n/// @notice Provides functions to integrate with V3 pool oracle\n/// @author Aloe Labs, Inc.\n/// @author Modified from [Uniswap](https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/OracleLibrary.sol)\nlibrary Oracle {\n    struct PoolData {\n        // the current price (from pool.slot0())\n        uint160 sqrtPriceX96;\n        // the current tick (from pool.slot0())\n        int24 currentTick;\n        // the mean sqrt(price) over some period (OracleLibrary.consult() to get arithmeticMeanTick, then use TickMath)\n        uint160 sqrtMeanPriceX96;\n        // the mean liquidity over some period (OracleLibrary.consult())\n        uint160 secondsPerLiquidityX128;\n        // the number of seconds to look back when getting mean tick & mean liquidity\n        uint32 oracleLookback;\n        // the liquidity depth at currentTick (from pool.liquidity())\n        uint128 tickLiquidity;\n    }\n\n    /**\n     * @notice Calculates time-weighted means of tick and liquidity for a given Uniswap V3 pool\n     * @param pool Address of the pool that we want to observe\n     * @param seed The indices of `pool.observations` where we start our search for the 30-minute-old (lowest 16 bits)\n     * and 60-minute-old (next 16 bits) observations. Determine these off-chain to make this method more efficient\n     * than Uniswap's binary search. If any of the highest 8 bits are set, we fallback to onchain binary search.\n     * @return data An up-to-date `PoolData` struct containing all fields except `oracleLookback` and `tickLiquidity`\n     * @return metric If the price was manipulated at any point in the past `UNISWAP_AVG_WINDOW` seconds, then at\n     * some point in that period, this value will spike. It may still be high now, or (if the attacker is smart and\n     * well-financed) it may have returned to nominal.\n     */\n    function consult(IUniswapV3Pool pool, uint40 seed) internal view returns (PoolData memory data, uint56 metric) {\n        uint16 observationIndex;\n        uint16 observationCardinality;\n        (data.sqrtPriceX96, data.currentTick, observationIndex, observationCardinality, , , ) = pool.slot0();\n\n        unchecked {\n            int56[] memory tickCumulatives = new int56[](3);\n            uint160[] memory secondsPerLiquidityCumulativeX128s = new uint160[](3);\n\n            if ((seed >> 32) > 0) {\n                uint32[] memory secondsAgos = new uint32[](3);\n                secondsAgos[0] = UNISWAP_AVG_WINDOW * 2;\n                secondsAgos[1] = UNISWAP_AVG_WINDOW;\n                secondsAgos[2] = 0;\n                (tickCumulatives, secondsPerLiquidityCumulativeX128s) = pool.observe(secondsAgos);\n            } else {\n                (tickCumulatives[0], ) = observe(\n                    pool,\n                    uint32(block.timestamp - UNISWAP_AVG_WINDOW * 2),\n                    seed >> 16,\n                    data.currentTick,\n                    observationIndex,\n                    observationCardinality\n                );\n                (tickCumulatives[1], secondsPerLiquidityCumulativeX128s[1]) = observe(\n                    pool,\n                    uint32(block.timestamp - UNISWAP_AVG_WINDOW),\n                    seed % Q16,\n                    data.currentTick,\n                    observationIndex,\n                    observationCardinality\n                );\n                (tickCumulatives[2], secondsPerLiquidityCumulativeX128s[2]) = observe(\n                    pool,\n                    uint32(block.timestamp),\n                    observationIndex,\n                    data.currentTick,\n                    observationIndex,\n                    observationCardinality\n                );\n            }\n\n            data.secondsPerLiquidityX128 =\n                secondsPerLiquidityCumulativeX128s[2] -\n                secondsPerLiquidityCumulativeX128s[1];\n\n            // Compute arithmetic mean tick over `UNISWAP_AVG_WINDOW`, always rounding down to -inf\n            int256 delta = tickCumulatives[2] - tickCumulatives[1];\n            int256 meanTick0ToW = delta / int32(UNISWAP_AVG_WINDOW);\n            assembly (\"memory-safe\") {\n                // Equivalent: if (delta < 0 && (delta % UNISWAP_AVG_WINDOW != 0)) meanTick0ToW--;\n                meanTick0ToW := sub(meanTick0ToW, and(slt(delta, 0), iszero(iszero(smod(delta, UNISWAP_AVG_WINDOW)))))\n            }\n            data.sqrtMeanPriceX96 = TickMath.getSqrtRatioAtTick(int24(meanTick0ToW));\n\n            // Compute arithmetic mean tick over the interval [-2w, 0)\n            int256 meanTick0To2W = (tickCumulatives[2] - tickCumulatives[0]) / int32(UNISWAP_AVG_WINDOW * 2);\n            // Compute arithmetic mean tick over the interval [-2w, -w]\n            int256 meanTickWTo2W = (tickCumulatives[1] - tickCumulatives[0]) / int32(UNISWAP_AVG_WINDOW);\n            //                                         i                 i-2w                       i-w               i-2w\n            //        meanTick0To2W - meanTickWTo2W = (∑ tick_n * dt_n - ∑ tick_n * dt_n) / (2T) - (∑ tick_n * dt_n - ∑ tick_n * dt_n) / T\n            //                                         n=0               n=0                        n=0               n=0\n            //\n            //                                        i                   i-w\n            // 2T * (meanTick0To2W - meanTickWTo2W) = ∑ tick_n * dt_n  - 2∑ tick_n * dt_n\n            //                                        n=i-2w              n=i-2w\n            //\n            //                                        i                   i-w\n            //                                      = ∑ tick_n * dt_n  -  ∑ tick_n * dt_n\n            //                                        n=i-w               n=i-2w\n            //\n            // Thus far all values have been \"true\". We now assume that some manipulated value `manip_n` is added to each `tick_n`\n            //\n            //                                        i                               i-w\n            //                                      = ∑ (tick_n + manip_n) * dt_n  -  ∑ (tick_n + manip_n) * dt_n\n            //                                        n=i-w                           n=i-2w\n            //\n            //                                        i                   i-w                 i                    i-w\n            //                                      = ∑ tick_n * dt_n  -  ∑ tick_n * dt_n  +  ∑ manip_n * dt_n  -  ∑ manip_n * dt_n\n            //                                        n=i-w               n=i-2w              n=i-w                n=i-2w\n            //\n            //        meanTick0To2W - meanTickWTo2W = (meanTick0ToW_true - meanTickWTo2W_true) / 2  +  (sumManip0ToW - sumManipWTo2W) / (2T)\n            //\n            // For short time periods and reasonable market conditions, (meanTick0ToW_true - meanTickWTo2W_true) ≈ 0\n            //\n            //                                      ≈ (sumManip0ToW - sumManipWTo2W) / (2T)\n            //\n            // The TWAP we care about (see a few lines down) is measured over the interval [-w, 0). Th"
    }
  ]
}