{
  "Title": "[G-07] Using `storage` instead of `memory` for structs/arrays saves gas",
  "Content": "When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/p1/Distributor.sol\n\n134:              Transfer memory t = transfers[i];\n\n```\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Distributor.sol#L134\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-01-reserve",
  "Code": [
    {
      "filename": "contracts/p1/Distributor.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"../interfaces/IDistributor.sol\";\nimport \"../interfaces/IMain.sol\";\nimport \"../libraries/Fixed.sol\";\nimport \"./mixins/Component.sol\";\n\ncontract DistributorP1 is ComponentP1, IDistributor {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using FixLib for uint192;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    EnumerableSet.AddressSet internal destinations;\n    mapping(address => RevenueShare) public distribution;\n\n    // ==== Invariants ====\n    // distribution is nonzero. (That is, distribution has at least one nonzero value)\n    //     (and thus this.totals() != {0, 0})\n    // distribution[FURNACE].rsrDist == 0\n    // distribution[ST_RSR].rTokenDist == 0\n    // distribution has no more than MAX_DESTINATIONS_ALLOWED key-value entries\n    // all distribution-share values are <= 10000\n\n    // ==== destinations:\n    // distribution[dest] != (0,0) if and only if dest in destinations\n\n    address public constant FURNACE = address(1);\n    address public constant ST_RSR = address(2);\n\n    uint8 public constant MAX_DESTINATIONS_ALLOWED = 100;\n\n    IERC20 private rsr;\n    IERC20 private rToken;\n    address private furnace;\n    address private stRSR;\n\n    function init(IMain main_, RevenueShare calldata dist) external initializer {\n        __Component_init(main_);\n\n        rsr = main_.rsr();\n        rToken = IERC20(address(main_.rToken()));\n        furnace = address(main_.furnace());\n        stRSR = address(main_.stRSR());\n\n        _ensureNonZeroDistribution(dist.rTokenDist, dist.rsrDist);\n        _setDistribution(FURNACE, RevenueShare(dist.rTokenDist, 0));\n        _setDistribution(ST_RSR, RevenueShare(0, dist.rsrDist));\n    }\n\n    /// Set the RevenueShare for destination `dest`. Destinations `FURNACE` and `ST_RSR` refer to\n    /// main.furnace() and main.stRSR().\n    /// @custom:governance\n    // checks: invariants hold in post-state\n    // effects:\n    //   destinations' = destinations.add(dest)\n    //   distribution' = distribution.set(dest, share)\n    function setDistribution(address dest, RevenueShare memory share) external governance {\n        _setDistribution(dest, share);\n        RevenueTotals memory revTotals = totals();\n        _ensureNonZeroDistribution(revTotals.rTokenTotal, revTotals.rsrTotal);\n    }\n\n    struct Transfer {\n        IERC20 erc20;\n        address addrTo;\n        uint256 amount;\n    }\n\n    /// Distribute revenue, in rsr or rtoken, per the distribution table.\n    /// Requires that this contract has an allowance of at least\n    /// `amount` tokens, from `from`, of the token at `erc20`.\n    /// @custom:interaction CEI\n    // let:\n    //   w = the map such that w[dest] = distribution[dest].{erc20}Shares\n    //   tokensPerShare = floor(amount / sum(values(w)))\n    //   addrOf(dest) = 1 -> furnace | 2 -> stRSR | x -> x\n    // checks:\n    //   erc20 is in {rsr, rToken}\n    //   sum(values(w)) > 0\n    // actions:\n    //   for dest where w[dest] != 0:\n    //     erc20.transferFrom(from, addrOf(dest), tokensPerShare * w[dest])\n    function distribute(\n        IERC20 erc20,\n        address from,\n        uint256 amount\n    ) external notPausedOrFrozen {\n        require(erc20 == rsr || erc20 == rToken, \"RSR or RToken\");\n        bool isRSR = erc20 == rsr; // if false: isRToken\n        uint256 tokensPerShare;\n        {\n            RevenueTotals memory revTotals = totals();\n            uint256 totalShares = isRSR ? revTotals.rsrTotal : revTotals.rTokenTotal;\n            require(totalShares > 0, \"nothing to distribute\");\n            tokensPerShare = amount / totalShares;\n        }\n\n        // Evenly distribute revenue tokens per distribution share.\n        // This rounds \"early\", and that's deliberate!\n\n        Transfer[] memory transfers = new Transfer[](destinations.length());\n        uint256 numTransfers;\n\n        for (uint256 i = 0; i < destinations.length(); ++i) {\n            address addrTo = destinations.at(i);\n\n            uint256 numberOfShares = isRSR\n                ? distribution[addrTo].rsrDist\n                : distribution[addrTo].rTokenDist;\n            if (numberOfShares == 0) continue;\n            uint256 transferAmt = tokensPerShare * numberOfShares;\n\n            if (addrTo == FURNACE) {\n                addrTo = furnace;\n            } else if (addrTo == ST_RSR) {\n                addrTo = stRSR;\n            }\n\n            transfers[numTransfers] = Transfer({\n                erc20: erc20,\n                addrTo: addrTo,\n                amount: transferAmt\n            });\n            numTransfers++;\n        }\n        emit RevenueDistributed(erc20, from, amount);\n\n        // == Interactions ==\n        for (uint256 i = 0; i < numTransfers; i++) {\n            Transfer memory t = transfers[i];\n            IERC20Upgradeable(address(t.erc20)).safeTransferFrom(from, t.addrTo, t.amount);\n        }\n    }\n\n    /// The rsr and rToken shareTotals\n    /// @return revTotals equals sum(distribution[d] for d in distribution)\n    function totals() public view returns (RevenueTotals memory revTotals) {\n        uint256 length = destinations.length();\n        for (uint256 i = 0; i < length; ++i) {\n            RevenueShare storage share = distribution[destinations.at(i)];\n            revTotals.rTokenTotal += share.rTokenDist;\n            revTotals.rsrTotal += share.rsrDist;\n        }\n    }\n\n    // ==== Internal ====\n\n    /// Set a distribution pair\n    // checks:\n    //   distribution'[FURNACE].rsrDist == 0\n    //   distribution'[ST_RSR].rTokenDist == 0\n    //   share.rsrDist <= 10000\n    //   size(destinations') <= MAX_DESTINATIONS_ALLOWED\n    // effects:\n    //   destinations' = destinations.add(dest)\n    //   distribution' = distribution.set(dest, share)\n    function _setDistribution(address dest, RevenueShare memory share) internal {\n        require(dest != address(0), \"dest cannot be zero\");\n        if (dest == FURNACE) require(share.rsrDist == 0, \"Furnace must get 0% of RSR\");\n        if (dest == ST_RSR) require(share.rTokenDist == 0, \"StRSR must get 0% of RToken\");\n        require(share.rsrDist <= 10000, \"RSR distribution too high\");\n        require(share.rTokenDist <= 10000, \"RToken distribution too high\");\n\n        if (share.rsrDist == 0 && share.rTokenDist == 0) {\n            destinations.remove(dest);\n        } else {\n            destinations.add(dest);\n            require(destinations.length() <= MAX_DESTINATIONS_ALLOWED, \"Too many destinations\");\n        }\n\n        distribution[dest] = share;\n        emit DistributionSet(dest, share.rTokenDist, share.rsrDist);\n    }\n\n    /// Ensures distribution values are non-zero\n    // checks: at least one of its arguments is nonzero\n    function _ensureNonZeroDistribution(uint24 rTokenDist, uint24 rsrDist) internal pure {\n        require(rTokenDist > 0 || rsrDist > 0, \"no distribution defined\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}"
    }
  ]
}