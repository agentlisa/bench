{
  "Title": "[M-32] Layerzero fee refund address is not handled correctly",
  "Content": "\nThe protocol aims to integrate with layerzero v2. To leverage layerzero infrastructure to send out cross-chain message, the user has to pay the native fee. If the user underpays the message fee, transaction reverts. If the user overpays the message fee, the excessive fee is refunded back.\n\nHowever, in the current implementation, the refund address is not compose correctly.\n\nIn `MagnetarBaseModule.sol`, there is a function:\n\n```\n   function _lzCustomWithdraw(\n        address _asset,\n        LZSendParam memory _lzSendParam,\n        uint128 _lzSendGas,\n        uint128 _lzSendVal,\n        uint128 _lzComposeGas,\n        uint128 _lzComposeVal,\n        uint16 _lzComposeMsgType\n    ) private {\n        PrepareLzCallReturn memory prepareLzCallReturn = _prepareLzSend(_asset, _lzSendParam, _lzSendGas, _lzSendVal);\n\n        TapiocaOmnichainEngineHelper _toeHelper = new TapiocaOmnichainEngineHelper();\n        PrepareLzCallReturn memory prepareLzCallReturn2 = _toeHelper.prepareLzCall(\n            ITapiocaOmnichainEngine(_asset),\n            PrepareLzCallData({\n                dstEid: _lzSendParam.sendParam.dstEid,\n                recipient: _lzSendParam.sendParam.to,\n                amountToSendLD: 0,\n                minAmountToCreditLD: 0,\n                msgType: _lzComposeMsgType,\n                composeMsgData: ComposeMsgData({\n                    index: 0,\n                    gas: _lzComposeGas,\n                    value: prepareLzCallReturn.msgFee.nativeFee.toUint128(),\n                    data: _lzSendParam.sendParam.composeMsg,\n                    prevData: bytes(\"\"),\n                    prevOptionsData: bytes(\"\")\n                }),\n                lzReceiveGas: _lzSendGas + _lzComposeGas,\n                lzReceiveValue: _lzComposeVal\n            })\n        );\n\n        if (msg.value < prepareLzCallReturn2.msgFee.nativeFee) {\n            revert Magnetar_GasMismatch(prepareLzCallReturn2.msgFee.nativeFee, msg.value);\n        }\n\n        IOftSender(_asset).sendPacket{value: prepareLzCallReturn2.msgFee.nativeFee}(\n            prepareLzCallReturn2.lzSendParam, prepareLzCallReturn2.composeMsg\n        );\n    }\n```\n\nFirst, we are [creating a temp `TapiocaOmnichainEngineHelper` contract](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/Magnetar/modules/MagnetarBaseModule.sol#L142), then calling `prepareLzCall` to compose the data type. The function is long, but the important thing is [that the `refundAddress` is set to `address(msg.sender)`](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/tapiocaOmnichainEngine/extension/TapiocaOmnichainEngineHelper.sol#L190).\n\n    lzSendParam_ = LZSendParam({\n        sendParam: sendParam_,\n        fee: msgFee_,\n        extraOptions: oftMsgOptions_,\n        refundAddress: address(msg.sender)\n    });\n\n    prepareLzCallReturn_ = PrepareLzCallReturn({\n        composeMsg: composeMsg_,\n        composeOptions: composeOptions_,\n        sendParam: sendParam_,\n        msgFee: msgFee_,\n        lzSendParam: lzSendParam_,\n        oftMsgOptions: oftMsgOptions_\n    });\n\nWho is `msg.sender`?\n\nIn this case:\n- User calls contract A,\n- Contract A creates contract B,\n- Contract A calls contract B `prepareLzCall` method.\n- Inside the `prepareLzCall` function call, `msg.sender` will be address contract A.\n\nHowever, that is not what we want. The refunded fee should go to original `msg.sender` who triggered the withdraw and paid the native fee.\n\nA simple POC can be ran:\n\n```\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Helper {\n    function prepare() public returns (address) {\n        return msg.sender;\n    }\n}\n\ncontract Magnetar {\n\n    function compose() public returns (address) {\n        Helper help = new Helper();\n        return help.prepare();\n    }\n}\n\ncontract CounterTest is Test {\n\n    using stdStorage for StdStorage;\n    StdStorage stdlib;\n\n    function setUp() public {\n\n    }\n\n    function testWhoSend() public {\n\n        address user = vm.addr(1234);\n\n        vm.startPrank(user);\n        \n        Magnetar mag = new Magnetar();\n\n        address refundAddress = mag.compose();\n\n        console.log(\"refund address is user\", refundAddress == user);\n        console.log(\"refund address is contract\", refundAddress == address(mag));\n    }\n\n}\n```\n\nIf we run the code with:\n\n    forge test -vv\n\nWe are getting:\n\n```\nRunning 1 test for test/Counter.t.sol:CounterTest\n[PASS] testWhoSend() (gas: 196196)\nLogs:\n  refund address is user false\n  refund address is contract true\n```\n\nThen, because the refund address is incorrectly set to contract, the original user lose refund layerzero fee. Consider that users always need to overpay the fee to send messsage. The cumulative loss of refund fee will be high and make the user lose fees.\n\n### Recommended Mitigation Steps\n\nSet the layerzero refund address to a user input address:\n\n    lzSendParam_ = LZSendParam({\n        sendParam: sendParam_,\n        fee: msgFee_,\n        extraOptions: oftMsgOptions_,\n        refundAddress: refundAddress // change here\n    });\n\n    prepareLzCallReturn_ = PrepareLzCallReturn({\n        composeMsg: composeMsg_,\n        composeOptions: composeOptions_,\n        sendParam: sendParam_,\n        msgFee: msgFee_,\n        lzSendParam: lzSendParam_,\n        oftMsgOptions: oftMsgOptions_\n    });\n\n### Assessed type\n\nToken-Transfer\n\n**[0xRektora (Tapioca) confirmed](https://github.com/code-423n4/2024-02-tapioca-findings/issues/10#issuecomment-2016882001)**\n\n**[cryptotechmaker (Tapioca) commented](https://github.com/code-423n4/2024-02-tapioca-findings/issues/10#issuecomment-2039789308):**\n > Main PR [here](https://github.com/Tapioca-DAO/tapioca-periph/pull/220).\n >\n> Secondary PRs [here](https://github.com/Tapioca-DAO/tap-token/pull/182), [here](https://github.com/Tapioca-DAO/Tapioca-bar/pull/382) and [here](https://github.com/Tapioca-DAO/TapiocaZ/pull/191).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-tapioca",
  "Code": [
    {
      "filename": "contracts/Magnetar/modules/MagnetarBaseModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// LZ\nimport {OFTMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTMsgCodec.sol\";\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {\n    PrepareLzCallData,\n    PrepareLzCallReturn,\n    ComposeMsgData\n} from \"tapioca-periph/tapiocaOmnichainEngine/extension/TapiocaOmnichainEngineHelper.sol\";\nimport {TapiocaOmnichainEngineHelper} from\n    \"tapioca-periph/tapiocaOmnichainEngine/extension/TapiocaOmnichainEngineHelper.sol\";\nimport {ITapiocaOmnichainEngine, LZSendParam} from \"tapioca-periph/interfaces/periph/ITapiocaOmnichainEngine.sol\";\nimport {MagnetarWithdrawData} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IOftSender} from \"tapioca-periph/interfaces/oft/IOftSender.sol\";\nimport {IPearlmit} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {MagnetarStorage} from \"../MagnetarStorage.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nabstract contract MagnetarBaseModule is Ownable, MagnetarStorage {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n\n    error Magnetar_GasMismatch(uint256 expected, uint256 received);\n    error Magnetar_TargetNotWhitelisted(address target);\n    error Magnetar_ExtractTokenFail();\n\n    constructor() MagnetarStorage(IPearlmit(address(0))) {}\n\n    /// =====================\n    /// Internal\n    /// =====================\n    function _withdrawToChain(MagnetarWithdrawData memory data) internal {\n        if (!cluster.isWhitelisted(0, address(data.yieldBox))) {\n            revert Magnetar_TargetNotWhitelisted(address(data.yieldBox));\n        }\n        IYieldBox _yieldBox = IYieldBox(data.yieldBox);\n\n        // perform a same chain withdrawal\n        if (data.lzSendParams.sendParam.dstEid == 0) {\n            _withdrawHere(_yieldBox, data.assetId, data.lzSendParams.sendParam.to, data.lzSendParams.sendParam.amountLD);\n            return;\n        }\n\n        // perform a cross chain withdrawal\n        (, address asset,,) = _yieldBox.assets(data.assetId);\n        if (!cluster.isWhitelisted(0, asset)) {\n            revert Magnetar_TargetNotWhitelisted(asset);\n        }\n\n        _yieldBox.withdraw(data.assetId, address(this), address(this), data.lzSendParams.sendParam.amountLD, 0);\n        // TODO: decide about try-catch here\n        if (data.unwrap) {\n            _lzCustomWithdraw(\n                asset,\n                data.lzSendParams,\n                data.sendGas,\n                data.sendVal,\n                data.composeGas,\n                data.composeVal,\n                data.composeMsgType\n            );\n        } else {\n            _lzWithdraw(asset, data.lzSendParams, data.sendGas, data.sendVal);\n        }\n    }\n\n    function _setApprovalForYieldBox(address _target, IYieldBox _yieldBox) internal {\n        bool isApproved = _yieldBox.isApprovedForAll(address(this), _target);\n        if (!isApproved) {\n            _yieldBox.setApprovalForAll(_target, true);\n        }\n    }\n\n    function _revertYieldBoxApproval(address _target, IYieldBox _yieldBox) internal {\n        bool isApproved = _yieldBox.isApprovedForAll(address(this), _target);\n        if (isApproved) {\n            _yieldBox.setApprovalForAll(_target, false);\n        }\n    }\n\n    function _extractTokens(address _from, address _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = IERC20(_token).balanceOf(address(this));\n        // IERC20(_token).safeTransferFrom(_from, address(this), _amount);\n        bool isErr = pearlmit.transferFromERC20(_from, address(this), address(_token), _amount);\n        if (isErr) revert Magnetar_ExtractTokenFail();\n        uint256 balanceAfter = IERC20(_token).balanceOf(address(this));\n        if (balanceAfter <= balanceBefore) revert Magnetar_ExtractTokenFail();\n        return balanceAfter - balanceBefore;\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n    function _withdrawHere(IYieldBox _yieldBox, uint256 _assetId, bytes32 _to, uint256 _amount) private {\n        _yieldBox.withdraw(_assetId, address(this), OFTMsgCodec.bytes32ToAddress(_to), _amount, 0);\n    }\n\n    function _lzWithdraw(address _asset, LZSendParam memory _lzSendParam, uint128 _lzSendGas, uint128 _lzSendVal)\n        private\n    {\n        PrepareLzCallReturn memory prepareLzCallReturn = _prepareLzSend(_asset, _lzSendParam, _lzSendGas, _lzSendVal);\n\n        if (msg.value < prepareLzCallReturn.msgFee.nativeFee) {\n            revert Magnetar_GasMismatch(prepareLzCallReturn.msgFee.nativeFee, msg.value);\n        }\n\n        IOftSender(_asset).sendPacket{value: prepareLzCallReturn.msgFee.nativeFee}(\n            prepareLzCallReturn.lzSendParam, prepareLzCallReturn.composeMsg\n        );\n    }\n\n    function _lzCustomWithdraw(\n        address _asset,\n        LZSendParam memory _lzSendParam,\n        uint128 _lzSendGas,\n        uint128 _lzSendVal,\n        uint128 _lzComposeGas,\n        uint128 _lzComposeVal,\n        uint16 _lzComposeMsgType\n    ) private {\n        PrepareLzCallReturn memory prepareLzCallReturn = _prepareLzSend(_asset, _lzSendParam, _lzSendGas, _lzSendVal);\n\n        TapiocaOmnichainEngineHelper _toeHelper = new TapiocaOmnichainEngineHelper();\n        PrepareLzCallReturn memory prepareLzCallReturn2 = _toeHelper.prepareLzCall(\n            ITapiocaOmnichainEngine(_asset),\n            PrepareLzCallData({\n                dstEid: _lzSendParam.sendParam.dstEid,\n                recipient: _lzSendParam.sendParam.to,\n                amountToSendLD: 0,\n                minAmountToCreditLD: 0,\n                msgType: _lzComposeMsgType,\n                composeMsgData: ComposeMsgData({\n                    index: 0,\n                    gas: _lzComposeGas,\n                    value: prepareLzCallReturn.msgFee.nativeFee.toUint128(),\n                    data: _lzSendParam.sendParam.composeMsg,\n                    prevData: bytes(\"\"),\n                    prevOptionsData: bytes(\"\")\n                }),\n                lzReceiveGas: _lzSendGas + _lzComposeGas,\n                lzReceiveValue: _lzComposeVal\n            })\n        );\n\n        if (msg.value < prepareLzCallReturn2.msgFee.nativeFee) {\n            revert Magnetar_GasMismatch(prepareLzCallReturn2.msgFee.nativeFee, msg.value);\n        }\n\n        IOftSender(_asset).sendPacket{value: prepareLzCallReturn2.msgFee.nativeFee}(\n            prepareLzCallReturn2.lzSendParam, prepareLzCallReturn2.composeMsg\n        );\n    }\n\n    function _prepareLzSend(address _asset, LZSendParam memory _lzSendParam, uint128 _lzSendGas, uint128 _lzSendVal)\n        private\n        returns (PrepareLzCallReturn memory prepareLzCallReturn)\n    {\n        TapiocaOmnichainEngineHelper _toeHelper = new TapiocaOmnichainEngineHelper();\n        prepareLzCallReturn = _toeHelper.prepareLzCall(\n            ITapiocaOmnichainEngine(_asset),\n            PrepareLzCallData({\n                dstEid: _lzSendParam.sendParam.dstEid,\n                recipient: _lzSendParam.sendParam.to,\n                amountToSendLD: _lzSendParam.sendParam.amountLD,\n                minAmountToCreditLD: _lzSendParam.sendParam.minAmountLD,\n                msgType: 1, // SEND\n                composeMsgData: ComposeMsgData({\n                    index: 0,\n                    gas: 0,\n                    value: 0,\n                    data: bytes(\"\"),\n                    prevData: bytes(\"\"),\n                    prevOptionsData: bytes(\"\")\n                }),\n                lzReceiveGas: _lzSendGas,\n                lzReceiveValue: _lzSendVal\n            })\n        );\n    }\n}"
    }
  ]
}