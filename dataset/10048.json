{
  "Title": "[M-10] Convenience contract fails to function if asset or collateral is an ERC20 token with fees",
  "Content": "_Submitted by Ruhum_\n\nThere are ERC20 tokens that collect fees with each transfer. If the asset or collateral used in a pair is of that type, the Convenience contract fails to function. It always sends the flat amount specified in the function's parameter. If the token collects fees, the amount the Pair contract receives is less than it expects to get and reverts the transaction.\n\n#### Proof of Concept\n\nThe function used to trigger the callback function and verify the received value: <https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L50>\n\nConvenience contract's callback function uses the amount specified in `collateralIn` in the transfer function: <https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L535>\n\nIf the token collects fees, the value the Pair contract receives will be less than `collateralIn`. The following require statement will fail: <https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L52>\n\nThe same thing applies to all the other callback functions in the library.\n\nThis issue doesn't impact the Pair contract itself. Because of the safety checks for each callback, the contract always receives the amount it expects or the transaction is reverted. Meaning, the user has to adapt and cover the fees themselves. The convenience contract doesn't do that and thus always fails.\n\nThe only issue would be outgoing transfers. For example, if a borrower pays back their debt, the pair contract receives the correct amount. But, the borrower will receive less collateral because of the fees. Since there's no such check in those cases:\n<https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L374>\n\n\n**[Mathepreneur (Timeswap) acknowledged](https://github.com/code-423n4/2022-01-timeswap-findings/issues/93):**\n > Hi what projects out there are using this fee mechanism in their transfer function? And what do you think is the mitigation for this? \n> \n > Almost all tokens don't have this fee implementation. If someone wants to utilize this, they can create their own convenience contract to interact with Timeswap V1 Core\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-01-timeswap-findings/issues/93#issuecomment-1021384932):**\n > Would be worth documenting the behavior for fee on transfer tokens and also expected behavior for rebasing tokens as well.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-01-timeswap",
  "Code": [
    {
      "filename": "Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IPair} from '../interfaces/IPair.sol';\nimport {ITimeswapMintCallback} from '../interfaces/callback/ITimeswapMintCallback.sol';\nimport {ITimeswapLendCallback} from '../interfaces/callback/ITimeswapLendCallback.sol';\nimport {ITimeswapBorrowCallback} from '../interfaces/callback/ITimeswapBorrowCallback.sol';\nimport {ITimeswapPayCallback} from '../interfaces/callback/ITimeswapPayCallback.sol';\nimport {SafeBalance} from './SafeBalance.sol';\nimport {SafeCast} from './SafeCast.sol';\n\nlibrary Callback {\n    using SafeBalance for IERC20;\n    using SafeCast for uint256;\n\n    function mint(\n        IERC20 asset,\n        IERC20 collateral,\n        uint112 assetIn,\n        uint112 collateralIn,\n        bytes calldata data\n    ) internal {\n        uint256 assetReserve = asset.safeBalance();\n        uint256 collateralReserve = collateral.safeBalance();\n        ITimeswapMintCallback(msg.sender).timeswapMintCallback(assetIn, collateralIn, data);\n        uint256 _assetReserve = asset.safeBalance();\n        uint256 _collateralReserve = collateral.safeBalance();\n        require(_assetReserve >= assetReserve + assetIn, 'E304');\n        require(_collateralReserve >= collateralReserve + collateralIn, 'E305');\n    }\n\n    function lend(\n        IERC20 asset,\n        uint112 assetIn,\n        bytes calldata data\n    ) internal {\n        uint256 assetReserve = asset.safeBalance();\n        ITimeswapLendCallback(msg.sender).timeswapLendCallback(assetIn, data);\n        uint256 _assetReserve = asset.safeBalance();\n        require(_assetReserve >= assetReserve + assetIn, 'E304');\n    }\n\n    function borrow(\n        IERC20 collateral,\n        uint112 collateralIn,\n        bytes calldata data\n    ) internal {\n        uint256 collateralReserve = collateral.safeBalance();\n        ITimeswapBorrowCallback(msg.sender).timeswapBorrowCallback(collateralIn, data);\n        uint256 _collateralReserve = collateral.safeBalance();\n        require(_collateralReserve >= collateralReserve + collateralIn, 'E305');\n    }\n    \n    function pay(\n        IERC20 asset,\n        uint128 assetIn,\n        bytes calldata data\n    ) internal {\n        uint256 assetReserve = asset.safeBalance();\n        ITimeswapPayCallback(msg.sender).timeswapPayCallback(assetIn, data);\n        uint256 _assetReserve = asset.safeBalance();\n        require(_assetReserve >= assetReserve + assetIn, 'E304');\n    }\n}"
    },
    {
      "filename": "Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IConvenience} from './interfaces/IConvenience.sol';\nimport {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';\nimport {IWETH} from './interfaces/IWETH.sol';\nimport {IDue} from './interfaces/IDue.sol';\nimport {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ITimeswapMintCallback} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/callback/ITimeswapMintCallback.sol';\nimport {ITimeswapLendCallback} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/callback/ITimeswapLendCallback.sol';\nimport {ITimeswapBorrowCallback} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/callback/ITimeswapBorrowCallback.sol';\nimport {Mint} from './libraries/Mint.sol';\nimport {Burn} from './libraries/Burn.sol';\nimport {Lend} from './libraries/Lend.sol';\nimport {Withdraw} from './libraries/Withdraw.sol';\nimport {Borrow} from './libraries/Borrow.sol';\nimport {Pay} from './libraries/Pay.sol';\nimport {SafeTransfer} from './libraries/SafeTransfer.sol';\nimport {DeployNative} from './libraries/DeployNative.sol';\n\n/// @title Timeswap Convenience\n/// @author Timeswap Labs\n/// @notice It is recommnded to use this contract to interact with Timeswap Core contract.\n/// @notice All error messages are abbreviated and can be found in the documentation.\ncontract TimeswapConvenience is IConvenience {\n    using SafeTransfer for IERC20;\n    using Mint for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));\n    using Burn for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));\n    using Lend for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));\n    using Withdraw for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));\n    using Borrow for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));\n    using Pay for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));\n    using DeployNative for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));\n\n    /* ===== MODEL ===== */\n\n    /// @inheritdoc IConvenience\n    IFactory public immutable override factory;\n    /// @inheritdoc IConvenience\n    IWETH public immutable override weth;\n\n    /// @dev Stores the addresses of the Liquidty, Bond, Insurance, Collateralized Debt token contracts.\n    mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native))) private natives;\n\n    /* ===== VIEW ===== */\n\n    /// @inheritdoc IConvenience\n    function getNative(\n        IERC20 asset,\n        IERC20 collateral,\n        uint256 maturity\n    ) external view override returns (Native memory) {\n        return natives[asset][collateral][maturity];\n    }\n\n    /* ===== INIT ===== */\n\n    /// @dev Initializes the Convenience contract.\n    /// @param _factory The address of factory contract used by this contract.\n    /// @param _weth The address of the Wrapped ETH contract.\n    constructor(IFactory _factory, IWETH _weth) {\n        factory = _factory;\n        weth = _weth;\n    }\n\n    /* ===== UPDATE ===== */\n\n    receive() external payable {}\n\n    /// @inheritdoc IConvenience\n    function newLiquidity(NewLiquidity calldata params)\n        external\n        override\n        returns (\n            uint256 liquidityOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        (liquidityOut, id, dueOut) = natives.newLiquidity(this, factory, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function newLiquidityETHAsset(NewLiquidityETHAsset calldata params)\n        external\n        payable\n        override\n        returns (\n            uint256 liquidityOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        (liquidityOut, id, dueOut) = natives.newLiquidityETHAsset(this, factory, weth, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function newLiquidityETHCollateral(NewLiquidityETHCollateral calldata params)\n        external\n        payable\n        override\n        returns (\n            uint256 liquidityOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        (liquidityOut, id, dueOut) = natives.newLiquidityETHCollateral(this, factory, weth, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function liquidityGivenAsset(LiquidityGivenAsset calldata params)\n        external\n        override\n        returns (\n            uint256 liquidityOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        (liquidityOut, id, dueOut) = natives.liquidityGivenAsset(this, factory, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function liquidityGivenAssetETHAsset(LiquidityGivenAssetETHAsset calldata params)\n        external\n        payable\n        override\n        returns (\n            uint256 liquidityOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        (liquidityOut, id, dueOut) = natives.liquidityGivenAssetETHAsset(this, factory, weth, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function liquidityGivenAssetETHCollateral(LiquidityGivenAssetETHCollateral calldata params)\n        external\n        payable\n        override\n        returns (\n            uint256 liquidityOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        (liquidityOut, id, dueOut) = natives.liquidityGivenAssetETHCollateral(this, factory, weth, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function liquidityGivenDebt(LiquidityGivenDebt calldata params)\n        external\n        override\n        returns (\n            uint256 liquidityOut,\n            uint112 assetIn,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        (liquidityOut, assetIn, id, dueOut) = natives.liquidityGivenDebt(this, factory, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function liquidityGivenDebtETHAsset(LiquidityGivenDebtETHAsset calldata params)\n        external\n        payable\n        override\n        returns (\n            uint256 liquidityOut,\n            uint112 assetIn,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        (liquidityOut, assetIn, id, dueOut) = natives.liquidityGivenDebtETHAsset(this, factory, weth, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function liquidityGivenDebtETHCollateral(LiquidityGivenDebtETHCollateral calldata params)\n        external\n        payable\n        override\n        returns (\n            uint256 liquidityOut,\n            uint112 assetIn,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        (liquidityOut, assetIn, id, dueOut) = natives.liquidityGivenDebtETHCollateral(this, factory, weth, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function liquidityGivenCollateral(LiquidityGivenCollateral calldata params)\n        external\n        override\n        returns (\n            uint256 liquidityOut,\n            uint112 assetIn,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        (liquidityOut, assetIn, id, dueOut) = natives.liquidityGivenCollateral(this, factory, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function liquidityGivenCollateralETHAsset(LiquidityGivenCollateralETHAsset calldata params)\n        external\n        payable\n        override\n        returns (\n            uint256 liquidityOut,\n            uint112 assetIn,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        (liquidityOut, assetIn, id, dueOut) = natives.liquidityGivenCollateralETHAsset(this, factory, weth, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function liquidityGivenCollateralETHCollateral(LiquidityGivenCollateralETHCollateral calldata params)\n        external\n        payable\n        override\n        returns (\n            uint256 liquidityOut,\n            uint112 assetIn,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        (liquidityOut, assetIn, id, dueOut) = natives.liquidityGivenCollateralETHCollateral(\n            this,\n            factory,\n            weth,\n            params\n        );\n    }\n\n    /// @inheritdoc IConvenience\n    function removeLiquidity(RemoveLiquidity calldata params)\n        external\n        override\n        returns (IPair.Tokens memory tokensOut)\n    {\n        tokensOut = natives.removeLiquidity(factory, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function removeLiquidityETHAsset(RemoveLiquidityETHAsset calldata params)\n        external\n        override\n        returns (IPair.Tokens memory tokensOut)\n    {\n        tokensOut = natives.removeLiquidityETHAsset(factory, weth, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function removeLiquidityETHCollateral(RemoveLiquidityETHCollateral calldata params)\n        external\n        override\n        returns (IPair.Tokens memory tokensOut)\n    {\n        tokensOut = natives.removeLiquidityETHCollateral(factory, weth, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function lendGivenBond(LendGivenBond calldata params) external override returns (IPair.Claims memory claimsOut) {\n        claimsOut = natives.lendGivenBond(this, factory, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function lendGivenBondETHAsset(LendGivenBondETHAsset calldata params)\n        external\n        payable\n        override\n        returns (IPair.Claims memory claimsOut)\n    {\n        claimsOut = natives.lendGivenBondETHAsset(this, factory, weth, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function lendGivenBondETHCollateral(LendGivenBondETHCollateral calldata params)\n        external\n        payable\n        override\n        returns (IPair.Claims memory claimsOut)\n    {\n        claimsOut = natives.lendGivenBondETHCollateral(this, factory, weth, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function lendGivenInsurance(LendGivenInsurance calldata params)\n        external\n        override\n        returns (IPair.Claims memory claimsOut)\n    {\n        claimsOut = natives.lendGivenInsurance(this, factory, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function lendGivenInsuranceETHAsset(LendGivenInsuranceETHAsset calldata params)\n        external\n        payable\n        override\n        returns (IPair.Claims memory claimsOut)\n    {\n        claimsOut = natives.lendGivenInsuranceETHAsset(this, factory, weth, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function lendGivenInsuranceETHCollateral(LendGivenInsuranceETHCollateral calldata params)\n        external\n        override\n        returns (IPair.Claims memory claimsOut)\n    {\n        claimsOut = natives.lendGivenInsuranceETHCollateral(this, factory, weth, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function lendGivenPercent(LendGivenPercent calldata params)\n        external\n        override\n        returns (IPair.Claims memory claimsOut)\n    {\n        claimsOut = natives.lendGivenPercent(this, factory, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function lendGivenPercentETHAsset(LendGivenPercentETHAsset calldata params)\n        external\n        payable\n        override\n        returns (IPair.Claims memory claimsOut)\n    {\n        claimsOut = natives.lendGivenPercentETHAsset(this, factory, weth, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function lendGivenPercentETHCollateral(LendGivenPercentETHCollateral calldata params)\n        external\n        override\n        returns (IPair.Claims memory claimsOut)\n    {\n        claimsOut = natives.lendGivenPercentETHCollateral(this, factory, weth, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function collect(Collect calldata params) external override returns (IPair.Tokens memory tokensOut) {\n        tokensOut = natives.collect(factory, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function collectETHAsset(CollectETHAsset calldata params)\n        external\n        override\n        returns (IPair.Tokens memory tokensOut)\n    {\n        tokensOut = natives.collectETHAsset(factory, weth, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function collectETHCollateral(CollectETHCollateral calldata params)\n        external\n        override\n        returns (IPair.Tokens memory tokensOut)\n    {\n        tokensOut = natives.collectETHCollateral(factory, weth, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function borrowGivenDebt(BorrowGivenDebt calldata params)\n        external\n        override\n        returns (uint256 id, IPair.Due memory dueOut)\n    {\n        (id, dueOut) = natives.borrowGivenDebt(this, factory, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function borrowGivenDebtETHAsset(BorrowGivenDebtETHAsset calldata params)\n        external\n        override\n        returns (uint256 id, IPair.Due memory dueOut)\n    {\n        (id, dueOut) = natives.borrowGivenDebtETHAsset(this, factory, weth, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function borrowGivenDebtETHCollateral(BorrowGivenDebtETHCollateral calldata params)\n        external\n        payable\n        override\n        returns (uint256 id, IPair.Due memory dueOut)\n    {\n        (id, dueOut) = natives.borrowGivenDebtETHCollateral(this, factory, weth, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function borrowGivenCollateral(BorrowGivenCollateral calldata params)\n        external\n        override\n        returns (uint256 id, IPair.Due memory dueOut)\n    {\n        (id, dueOut) = natives.borrowGivenCollateral(this, factory, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function borrowGivenCollateralETHAsset(BorrowGivenCollateralETHAsset calldata params)\n        external\n        override\n        returns (uint256 id, IPair.Due memory dueOut)\n    {\n        (id, dueOut) = natives.borrowGivenCollateralETHAsset(this, factory, weth, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function borrowGivenCollateralETHCollateral(BorrowGivenCollateralETHCollateral calldata params)\n        external\n        payable\n        override\n        returns (uint256 id, IPair.Due memory dueOut)\n    {\n        (id, dueOut) = natives.borrowGivenCollateralETHCollateral(this, factory, weth, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function borrowGivenPercent(BorrowGivenPercent calldata params)\n        external\n        override\n        returns (uint256 id, IPair.Due memory dueOut)\n    {\n        (id, dueOut) = natives.borrowGivenPercent(this, factory, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function borrowGivenPercentETHAsset(BorrowGivenPercentETHAsset calldata params)\n        external\n        override\n        returns (uint256 id, IPair.Due memory dueOut)\n    {\n        (id, dueOut) = natives.borrowGivenPercentETHAsset(this, factory, weth, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function borrowGivenPercentETHCollateral(BorrowGivenPercentETHCollateral calldata params)\n        external\n        payable\n        override\n        returns (uint256 id, IPair.Due memory dueOut)\n    {\n        (id, dueOut) = natives.borrowGivenPercentETHCollateral(this, factory, weth, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function repay(Repay memory params) external override returns (uint128 assetIn, uint128 collateralOut) {\n        (assetIn, collateralOut) = natives.pay(factory, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function repayETHAsset(RepayETHAsset memory params)\n        external\n        payable\n        override\n        returns (uint128 assetIn, uint128 collateralOut)\n    {\n        (assetIn, collateralOut) = natives.payETHAsset(factory, weth, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function repayETHCollateral(RepayETHCollateral memory params)\n        external\n        override\n        returns (uint128 assetIn, uint128 collateralOut)\n    {\n        (assetIn, collateralOut) = natives.payETHCollateral(factory, weth, params);\n    }\n\n    /// @inheritdoc IConvenience\n    function deployNative(Deploy memory params) external override {\n        natives.deploy(this, factory, params);\n    }\n\n    /// @inheritdoc ITimeswapMintCallback\n    function timeswapMintCallback(\n        uint112 assetIn,\n        uint112 collateralIn,\n        bytes calldata data\n    ) external override {\n        (IERC20 asset, IERC20 collateral, address assetFrom, address collateralFrom) = abi.decode(\n            data,\n            (IERC20, IERC20, address, address)\n        );\n        IPair pair = factory.getPair(asset, collateral);\n\n        require(msg.sender == address(pair), 'E701');\n\n        if (assetFrom == address(this)) {\n            weth.deposit{value: assetIn}();\n            asset.safeTransfer(pair, assetIn);\n        } else {\n            asset.safeTransferFrom(assetFrom, pair, assetIn);\n        }\n\n        if (collateralFrom == address(this)) {\n            weth.deposit{value: collateralIn}();\n            collateral.safeTransfer(pair, collateralIn);\n        } else {\n            collateral.safeTransferFrom(collateralFrom, pair, collateralIn);\n        }\n    }\n\n    /// @inheritdoc ITimeswapLendCallback\n    function timeswapLendCallback(uint112 assetIn, bytes calldata data) external override {\n        (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address));\n        IPair pair = factory.getPair(asset, collateral);\n\n        require(msg.sender == address(pair), 'E701');\n\n        if (from == address(this)) {\n            weth.deposit{value: assetIn}();\n            asset.safeTransfer(pair, assetIn);\n        } else {\n            asset.safeTransferFrom(from, pair, assetIn);\n        }\n    }\n\n    /// @inheritdoc ITimeswapBorrowCallback\n    function timeswapBorrowCallback(uint112 collateralIn, bytes calldata data) external override {\n        (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address));\n        IPair pair = factory.getPair(asset, collateral);\n        require(msg.sender == address(pair), 'E701');\n        if (from == address(this)) {\n            weth.deposit{value: collateralIn}();\n            collateral.safeTransfer(pair, collateralIn);\n        } else {\n            collateral.safeTransferFrom(from, pair, collateralIn);\n        }\n    }\n\n    /// @inheritdoc IConvenience\n    function collateralizedDebtCallback(\n        IPair pair,\n        uint256 maturity,\n        uint128 assetIn,\n        bytes calldata data\n    ) external override {\n        (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address));\n\n        IDue collateralizedDebt = natives[asset][collateral][maturity].collateralizedDebt;\n\n        require(msg.sender == address(collateralizedDebt), 'E701');\n\n        if (from == address(this)) {\n            weth.deposit{value: assetIn}();\n            asset.safeTransfer(pair, assetIn);\n        } else {\n            asset.safeTransferFrom(from, pair, assetIn);\n        }\n    }\n}"
    },
    {
      "filename": "Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IPair} from '../interfaces/IPair.sol';\nimport {ITimeswapMintCallback} from '../interfaces/callback/ITimeswapMintCallback.sol';\nimport {ITimeswapLendCallback} from '../interfaces/callback/ITimeswapLendCallback.sol';\nimport {ITimeswapBorrowCallback} from '../interfaces/callback/ITimeswapBorrowCallback.sol';\nimport {ITimeswapPayCallback} from '../interfaces/callback/ITimeswapPayCallback.sol';\nimport {SafeBalance} from './SafeBalance.sol';\nimport {SafeCast} from './SafeCast.sol';\n\nlibrary Callback {\n    using SafeBalance for IERC20;\n    using SafeCast for uint256;\n\n    function mint(\n        IERC20 asset,\n        IERC20 collateral,\n        uint112 assetIn,\n        uint112 collateralIn,\n        bytes calldata data\n    ) internal {\n        uint256 assetReserve = asset.safeBalance();\n        uint256 collateralReserve = collateral.safeBalance();\n        ITimeswapMintCallback(msg.sender).timeswapMintCallback(assetIn, collateralIn, data);\n        uint256 _assetReserve = asset.safeBalance();\n        uint256 _collateralReserve = collateral.safeBalance();\n        require(_assetReserve >= assetReserve + assetIn, 'E304');\n        require(_collateralReserve >= collateralReserve + collateralIn, 'E305');\n    }\n\n    function lend(\n        IERC20 asset,\n        uint112 assetIn,\n        bytes calldata data\n    ) internal {\n        uint256 assetReserve = asset.safeBalance();\n        ITimeswapLendCallback(msg.sender).timeswapLendCallback(assetIn, data);\n        uint256 _assetReserve = asset.safeBalance();\n        require(_assetReserve >= assetReserve + assetIn, 'E304');\n    }\n\n    function borrow(\n        IERC20 collateral,\n        uint112 collateralIn,\n        bytes calldata data\n    ) internal {\n        uint256 collateralReserve = collateral.safeBalance();\n        ITimeswapBorrowCallback(msg.sender).timeswapBorrowCallback(collateralIn, data);\n        uint256 _collateralReserve = collateral.safeBalance();\n        require(_collateralReserve >= collateralReserve + collateralIn, 'E305');\n    }\n    \n    function pay(\n        IERC20 asset,\n        uint128 assetIn,\n        bytes calldata data\n    ) internal {\n        uint256 assetReserve = asset.safeBalance();\n        ITimeswapPayCallback(msg.sender).timeswapPayCallback(assetIn, data);\n        uint256 _assetReserve = asset.safeBalance();\n        require(_assetReserve >= assetReserve + assetIn, 'E304');\n    }\n}"
    },
    {
      "filename": "Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IPair} from './interfaces/IPair.sol';\nimport {IFactory} from './interfaces/IFactory.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {MintMath} from './libraries/MintMath.sol';\nimport {BurnMath} from './libraries/BurnMath.sol';\nimport {LendMath} from './libraries/LendMath.sol';\nimport {WithdrawMath} from './libraries/WithdrawMath.sol';\nimport {BorrowMath} from './libraries/BorrowMath.sol';\nimport {PayMath} from './libraries/PayMath.sol';\nimport {SafeTransfer} from './libraries/SafeTransfer.sol';\nimport {Array} from './libraries/Array.sol';\nimport {Callback} from './libraries/Callback.sol';\nimport {BlockNumber} from './libraries/BlockNumber.sol';\n\n/// @title Timeswap Pair\n/// @author Timeswap Labs\n/// @notice It is recommnded to use Timeswap Convenience to interact with this contract.\n/// @notice All error messages are coded and can be found in the documentation.\ncontract TimeswapPair is IPair {\n    using SafeTransfer for IERC20;\n    using Array for Due[];\n\n    /* ===== MODEL ===== */\n\n    /// @inheritdoc IPair\n    IFactory public immutable override factory;\n    /// @inheritdoc IPair\n    IERC20 public immutable override asset;\n    /// @inheritdoc IPair\n    IERC20 public immutable override collateral;\n    /// @inheritdoc IPair\n    uint16 public immutable override fee;\n    /// @inheritdoc IPair\n    uint16 public immutable override protocolFee;\n\n    /// @dev Stores the individual states of each Pool.\n    mapping(uint256 => Pool) private pools;\n\n    /// @dev Stores the access state for reentrancy guard.\n    uint256 private locked;\n\n    /* ===== VIEW =====*/\n\n    /// @inheritdoc IPair\n    function constantProduct(uint256 maturity)\n        external\n        view\n        override\n        returns (\n            uint112 x,\n            uint112 y,\n            uint112 z\n        )\n    {\n        State memory state = pools[maturity].state;\n        return (state.x, state.y, state.z);\n    }\n\n    /// @inheritdoc IPair\n    function totalReserves(uint256 maturity) external view override returns (Tokens memory) {\n        return pools[maturity].state.reserves;\n    }\n\n    /// @inheritdoc IPair\n    function totalLiquidity(uint256 maturity) external view override returns (uint256) {\n        return pools[maturity].state.totalLiquidity;\n    }\n\n    /// @inheritdoc IPair\n    function liquidityOf(uint256 maturity, address owner) external view override returns (uint256) {\n        return pools[maturity].liquidities[owner];\n    }\n\n    /// @inheritdoc IPair\n    function totalClaims(uint256 maturity) external view override returns (Claims memory) {\n        return pools[maturity].state.totalClaims;\n    }\n\n    /// @inheritdoc IPair\n    function claimsOf(uint256 maturity, address owner) external view override returns (Claims memory) {\n        return pools[maturity].claims[owner];\n    }\n\n    /// @inheritdoc IPair\n    function totalDebtCreated(uint256 maturity) external view override returns (uint120) {\n        return pools[maturity].state.totalDebtCreated;\n    }\n\n    /// @inheritdoc IPair\n    function dueOf(uint256 maturity, address owner, uint256 id) external view override returns (Due memory) {\n        return pools[maturity].dues[owner][id];\n    }\n\n    /* ===== INIT ===== */\n\n    /// @dev Initializes the Pair contract.\n    /// @dev Called by the Timeswap factory contract.\n    /// @param _asset The address of the ERC20 being lent and borrowed.\n    /// @param _collateral The address of the ERC20 as the collateral.\n    /// @param _fee The chosen fee rate.\n    /// @param _protocolFee The chosen protocol fee rate.\n    constructor(\n        IERC20 _asset,\n        IERC20 _collateral,\n        uint16 _fee,\n        uint16 _protocolFee\n    ) {\n        factory = IFactory(msg.sender);\n        asset = _asset;\n        collateral = _collateral;\n        fee = _fee;\n        protocolFee = _protocolFee;\n    }\n\n    /* ===== MODIFIER ===== */\n\n    /// @dev The modifier for reentrancy guard.\n    modifier lock() {\n        require(locked == 0, 'E211');\n        locked = 1;\n        _;\n        locked = 0;\n    }\n\n    /* ===== UPDATE ===== */\n\n    /// @inheritdoc IPair\n    function mint(\n        uint256 maturity,\n        address liquidityTo,\n        address dueTo,\n        uint112 xIncrease,\n        uint112 yIncrease,\n        uint112 zIncrease,\n        bytes calldata data\n    )\n        external\n        override\n        lock\n        returns (\n            uint256 liquidityOut,\n            uint256 id,\n            Due memory dueOut\n        )\n    {\n        require(block.timestamp < maturity, 'E202');\n        require(maturity - block.timestamp < 0x100000000, 'E208');\n        require(liquidityTo != address(0) && dueTo != address(0), 'E201');\n        require(liquidityTo != address(this) && dueTo != address(this), 'E204');\n        require(xIncrease > 0 && yIncrease > 0 && zIncrease > 0, 'E205');\n        \n        Pool storage pool = pools[maturity];\n\n        if (pool.state.totalLiquidity == 0) {\n            uint256 liquidityTotal = MintMath.getLiquidityTotal(xIncrease);\n            liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);\n\n            pool.state.totalLiquidity += liquidityTotal;\n            pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut;\n        } else {\n            uint256 liquidityTotal = MintMath.getLiquidityTotal(pool.state, xIncrease, yIncrease, zIncrease);\n            liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);\n\n            pool.state.totalLiquidity += liquidityTotal;\n            pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut;\n        }\n        require(liquidityOut > 0, 'E212');\n        pool.liquidities[liquidityTo] += liquidityOut;\n\n        dueOut.debt = MintMath.getDebt(maturity, xIncrease, yIncrease);\n        dueOut.collateral = MintMath.getCollateral(maturity, zIncrease);\n        dueOut.startBlock = BlockNumber.get();\n\n        Callback.mint(asset, collateral, xIncrease, dueOut.collateral, data);\n\n        id = pool.dues[dueTo].insert(dueOut);\n\n        pool.state.reserves.asset += xIncrease;\n        pool.state.reserves.collateral += dueOut.collateral;\n        pool.state.totalDebtCreated += dueOut.debt;\n\n        pool.state.x += xIncrease;\n        pool.state.y += yIncrease;\n        pool.state.z += zIncrease;\n\n        emit Sync(maturity, pool.state.x, pool.state.y, pool.state.z);\n        emit Mint(maturity, msg.sender, liquidityTo, dueTo, xIncrease, liquidityOut, id, dueOut);\n    }\n\n    /// @inheritdoc IPair\n    function burn(\n        uint256 maturity,\n        address assetTo,\n        address collateralTo,\n        uint256 liquidityIn\n    ) external override lock returns (Tokens memory tokensOut) {\n        require(block.timestamp >= maturity, 'E203');\n        require(assetTo != address(0) && collateralTo != address(0), 'E201');\n        require(assetTo != address(this) && collateralTo != address(this), 'E204');\n        require(liquidityIn > 0, 'E205');\n\n        Pool storage pool = pools[maturity];\n\n        tokensOut.asset = BurnMath.getAsset(pool.state, liquidityIn);\n        tokensOut.collateral = BurnMath.getCollateral(pool.state, liquidityIn);\n\n        pool.state.totalLiquidity -= liquidityIn;\n\n        pool.liquidities[msg.sender] -= liquidityIn;\n\n        pool.state.reserves.asset -= tokensOut.asset;\n        pool.state.reserves.collateral -= tokensOut.collateral;\n\n        if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset);\n        if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral);\n\n        emit Burn(maturity, msg.sender, assetTo, collateralTo, liquidityIn, tokensOut);\n    }\n\n    /// @inheritdoc IPair\n    function lend(\n        uint256 maturity,\n        address bondTo,\n        address insuranceTo,\n        uint112 xIncrease,\n        uint112 yDecrease,\n        uint112 zDecrease,\n        bytes calldata data\n    ) external override lock returns (Claims memory claimsOut) {\n        require(block.timestamp < maturity, 'E202');\n        require(bondTo != address(0) && insuranceTo != address(0), 'E201');\n        require(bondTo != address(this) && insuranceTo != address(this), 'E204');\n        require(xIncrease > 0, 'E205');\n\n        Pool storage pool = pools[maturity];\n        require(pool.state.totalLiquidity > 0, 'E206');\n\n        LendMath.check(pool.state, xIncrease, yDecrease, zDecrease, fee);\n\n        claimsOut.bond = LendMath.getBond(maturity, xIncrease, yDecrease);\n        claimsOut.insurance = LendMath.getInsurance(maturity, pool"
    }
  ]
}