{
  "Title": "Unhandled DoS when access to Chainlik oracle is blocked",
  "Content": "# Unhandled DoS when access to Chainlik oracle is blocked\n\n### Severity\nMedium Risk\n\n## Summary\n\nIn certain exceptional scenarios, oracles may become temporarily unavailable. As a result, invoking the `latestRoundData` function could potentially revert without a proper error handling.\n\n## Vulnerability Details\n\nSteadefi documentation gives special focus on Chainlink price feed dependency, (https://github.com/Cyfrin/2023-10-SteadeFi/tree/main \"Additional Context\"). The concern stems from the potential for Chainlink multisignature entities to deliberately block the access to the price feed. In such a situation, using the `latestRoundData` function could lead to an unexpected revert.\n\nIn certain extraordinary situations, Chainlink has already proactively suspended particular oracles. To illustrate, in the case of the UST collapse incident, Chainlink chose to temporarily halt the UST/ETH price oracle to prevent the propagation of incorrect data to various protocols.\n\nAdditionally, this danger has been highlighted and very well documented by OpenZeppelin in https://blog.openzeppelin.com/secure-smart-contract-guidelines-the-dangers-of-price-oracles. For our current scenario:\n\n*\"While currently there’s no whitelisting mechanism to allow or disallow contracts from reading prices, powerful multisigs can tighten these access controls. In other words, the multisigs can immediately block access to price feeds at will. Therefore, to prevent denial of service scenarios, it is recommended to query ChainLink price feeds using a defensive approach with Solidity’s try/catch structure. In this way, if the call to the price feed fails, the caller contract is still in control and can handle any errors safely and explicitly\".*\n\nAs a result and taking into consideration the recommendation from OpenZepplin, it is essential to thoroughly tackle this matter within the codebase, as it directly relates to many functionalities of the system which are based on the oracle's output.\n\nAnother example to check this vulnerability can be consulted in https://solodit.xyz/issues/m-18-protocols-usability-becomes-very-limited-when-access-to-chainlink-oracle-data-feed-is-blocked-code4rena-inverse-finance-inverse-finance-contest-git \n\n## Proof of Concept\n\nAs previously discussed, to mitigate the potential risks related to a denial-of-service situation, it is recommended to implement a try-catch mechanism when querying Chainlink prices in the `_getChainlinkResponse` function within `ChainlinkARBOracle.sol` (link to code below). By adopting this approach, in case there's a failure in invoking the price feed, the caller contract retains control and can effectively handle any errors securely and explicitly.\n\nhttps://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/oracles/ChainlinkARBOracle.sol#L188-L194\n\n```\n\n (\n      uint80 _latestRoundId,\n      int256 _latestAnswer,\n      /* uint256 _startedAt */,\n      uint256 _latestTimestamp,\n      /* uint80 _answeredInRound */\n    ) = AggregatorV3Interface(_feed).latestRoundData();\n\n```\n\n## Impact\n\nIn the event of a malfunction or cessation of operation of a configured Oracle feed, attempting to check for the `latestRoundData` will result in a revert that must be managed manually by the system.\n\n## Tools Used\n\nManual review\n\n## Recommendations\n\nWrap the invocation of the `latestRoundData()` function within a `try-catch` structure rather than directly calling it. In situations where the function call triggers a revert, the catch block can be utilized to trigger an alternative oracle or handle the error in a manner that aligns with the system's requirements.",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/oracles/ChainlinkARBOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { Errors } from \"../utils/Errors.sol\";\n\ncontract ChainlinkARBOracle is Ownable2Step, Pausable {\n  using SafeCast for int256;\n\n  /* ======================= STRUCTS ========================= */\n\n  struct ChainlinkResponse {\n    uint80 roundId;\n    int256 answer;\n    uint256 timestamp;\n    bool success;\n    uint8 decimals;\n  }\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n  uint256 public constant SEQUENCER_GRACE_PERIOD_TIME = 1 hours;\n\n  /* ==================== STATE VARIABLES ==================== */\n\n  // Chainlink Arbitrum sequencer feed address\n  AggregatorV3Interface internal sequencerUptimeFeed;\n\n  /* ======================= MAPPINGS ======================== */\n\n  // Mapping of token to Chainlink USD price feed\n  mapping(address => address) public feeds;\n  // Mapping of token to maximum delay allowed (in seconds) of last price update\n  mapping(address => uint256) public maxDelays;\n  // Mapping of token to maximum % deviation allowed (in 1e18) of last price update\n  mapping(address => uint256) public maxDeviations;\n\n  /* ====================== CONSTRUCTOR ====================== */\n\n  /**\n    * @param sequencerFeed  Chainlink Arbitrum sequencer feed address\n  */\n  constructor(address sequencerFeed) Ownable(msg.sender) {\n    if (sequencerFeed == address(0)) revert Errors.ZeroAddressNotAllowed();\n\n    sequencerUptimeFeed = AggregatorV3Interface(sequencerFeed);\n  }\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Get token price from Chainlink feed\n    * @param token Token address\n    * @return price Asset price in int256\n    * @return decimals Price decimals in uint8\n  */\n  function consult(address token) public view whenNotPaused returns (int256, uint8) {\n    address _feed = feeds[token];\n\n    if (_feed == address(0)) revert Errors.NoTokenPriceFeedAvailable();\n\n    ChainlinkResponse memory chainlinkResponse = _getChainlinkResponse(_feed);\n    ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(_feed, chainlinkResponse.roundId);\n\n    if (_chainlinkIsFrozen(chainlinkResponse, token)) revert Errors.FrozenTokenPriceFeed();\n    if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse, token)) revert Errors.BrokenTokenPriceFeed();\n\n    return (chainlinkResponse.answer, chainlinkResponse.decimals);\n  }\n\n  /**\n    * @notice Get token price from Chainlink feed returned in 1e18\n    * @param token Token address\n    * @return price in 1e18\n  */\n  function consultIn18Decimals(address token) external view whenNotPaused returns (uint256) {\n    (int256 _answer, uint8 _decimals) = consult(token);\n\n    return _answer.toUint256() * 1e18 / (10 ** _decimals);\n  }\n\n  /* ================== INTERNAL FUNCTIONS =================== */\n\n  /**\n    * @notice Check if Chainlink oracle is not working as expected\n    * @param currentResponse Current Chainlink response\n    * @param prevResponse Previous Chainlink response\n    * @param token Token address\n    * @return Status of check in boolean\n  */\n  function _chainlinkIsBroken(\n    ChainlinkResponse memory currentResponse,\n    ChainlinkResponse memory prevResponse,\n    address token\n  ) internal view returns (bool) {\n    return _badChainlinkResponse(currentResponse) ||\n           _badChainlinkResponse(prevResponse) ||\n           _badPriceDeviation(currentResponse, prevResponse, token);\n  }\n\n  /**\n    * @notice Checks to see if Chainlink oracle is returning a bad response\n    * @param response Chainlink response\n    * @return Status of check in boolean\n  */\n  function _badChainlinkResponse(ChainlinkResponse memory response) internal view returns (bool) {\n    // Check for response call reverted\n    if (!response.success) { return true; }\n    // Check for an invalid roundId that is 0\n    if (response.roundId == 0) { return true; }\n    // Check for an invalid timeStamp that is 0, or in the future\n    if (response.timestamp == 0 || response.timestamp > block.timestamp) { return true; }\n    // Check for non-positive price\n    if (response.answer == 0) { return true; }\n\n    return false;\n  }\n\n  /**\n    * @notice Check to see if Chainlink oracle response is frozen/too stale\n    * @param response Chainlink response\n    * @param token Token address\n    * @return Status of check in boolean\n  */\n  function _chainlinkIsFrozen(ChainlinkResponse memory response, address token) internal view returns (bool) {\n    return (block.timestamp - response.timestamp) > maxDelays[token];\n  }\n\n  /**\n    * @notice Check to see if Chainlink oracle current response's price price deviation\n    * is too large compared to previous response's price\n    * @param currentResponse Current Chainlink response\n    * @param prevResponse Previous Chainlink response\n    * @param token Token address\n    * @return Status of check in boolean\n  */\n  function _badPriceDeviation(\n    ChainlinkResponse memory currentResponse,\n    ChainlinkResponse memory prevResponse,\n    address token\n  ) internal view returns (bool) {\n    // Check for a deviation that is too large\n    uint256 _deviation;\n\n    if (currentResponse.answer > prevResponse.answer) {\n      _deviation = uint256(currentResponse.answer - prevResponse.answer) * SAFE_MULTIPLIER / uint256(prevResponse.answer);\n    } else {\n      _deviation = uint256(prevResponse.answer - currentResponse.answer) * SAFE_MULTIPLIER / uint256(prevResponse.answer);\n    }\n\n    return _deviation > maxDeviations[token];\n  }\n\n  /**\n    * @notice Get latest Chainlink response\n    * @param _feed Chainlink oracle feed address\n    * @return ChainlinkResponse\n  */\n  function _getChainlinkResponse(address _feed) internal view returns (ChainlinkResponse memory) {\n    ChainlinkResponse memory _chainlinkResponse;\n\n    _chainlinkResponse.decimals = AggregatorV3Interface(_feed).decimals();\n\n    // Arbitrum sequencer uptime feed\n    (\n      /* uint80 _roundID*/,\n      int256 _answer,\n      uint256 _startedAt,\n      /* uint256 _updatedAt */,\n      /* uint80 _answeredInRound */\n    ) = sequencerUptimeFeed.latestRoundData();\n\n    // Answer == 0: Sequencer is up\n    // Answer == 1: Sequencer is down\n    bool _isSequencerUp = _answer == 0;\n    if (!_isSequencerUp) revert Errors.SequencerDown();\n\n    // Make sure the grace period has passed after the\n    // sequencer is back up.\n    uint256 _timeSinceUp = block.timestamp - _startedAt;\n    if (_timeSinceUp <= SEQUENCER_GRACE_PERIOD_TIME) revert Errors.GracePeriodNotOver();\n\n    (\n      uint80 _latestRoundId,\n      int256 _latestAnswer,\n      /* uint256 _startedAt */,\n      uint256 _latestTimestamp,\n      /* uint80 _answeredInRound */\n    ) = AggregatorV3Interface(_feed).latestRoundData();\n\n    _chainlinkResponse.roundId = _latestRoundId;\n    _chainlinkResponse.answer = _latestAnswer;\n    _chainlinkResponse.timestamp = _latestTimestamp;\n    _chainlinkResponse.success = true;\n\n    return _chainlinkResponse;\n  }\n\n  /**\n    * @notice Get previous round's Chainlink response from current round\n    * @param _feed Chainlink oracle feed address\n    * @param _currentRoundId Current roundId from current Chainlink response\n    * @return ChainlinkResponse\n  */\n  function _getPrevChainlinkResponse(address _feed, uint80 _currentRoundId) internal view returns (ChainlinkResponse memory) {\n    ChainlinkResponse memory _prevChainlinkResponse;\n\n    (\n      uint80 _roundId,\n      int256 _answer,\n      /* uint256 _startedAt */,\n      uint256 _timestamp,\n      /* uint80 _answeredInRound */\n    ) = AggregatorV3Interface(_feed).getRoundData(_currentRoundId - 1);\n\n    _prevChainlinkResponse.roundId = _roundId;\n    _prevChainlinkResponse.answer = _answer;\n    _prevChainlinkResponse.timestamp = _timestamp;\n    _prevChainlinkResponse.success = true;\n\n    return _prevChainlinkResponse;\n  }\n\n  /* ================= RESTRICTED FUNCTIONS ================== */\n\n  /**\n    * @notice Add Chainlink price feed for token\n    * @param token Token address\n    * @param feed Chainlink price feed address\n  */\n  function addTokenPriceFeed(address token, address feed) external onlyOwner {\n    if (token == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feed == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feeds[token] != address(0)) revert Errors.TokenPriceFeedAlreadySet();\n\n    feeds[token] = feed;\n  }\n\n  /**\n    * @notice Add Chainlink max delay for token\n    * @param token Token address\n    * @param maxDelay  Max delay allowed in seconds\n  */\n  function addTokenMaxDelay(address token, uint256 maxDelay) external onlyOwner {\n    if (token == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feeds[token] == address(0)) revert Errors.NoTokenPriceFeedAvailable();\n    if (maxDelay < 0) revert Errors.TokenPriceFeedMaxDelayMustBeGreaterOrEqualToZero();\n\n    maxDelays[token] = maxDelay;\n  }\n\n  /**\n    * @notice Add Chainlink max deviation for token\n    * @param token Token address\n    * @param maxDeviation  Max deviation allowed in seconds\n  */\n  function addTokenMaxDeviation(address token, uint256 maxDeviation) external onlyOwner {\n    if (token == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feeds[token] == address(0)) revert Errors.NoTokenPriceFeedAvailable();\n    if (maxDeviation < 0) revert Errors.TokenPriceFeedMaxDeviationMustBeGreaterOrEqualToZero();\n\n    maxDeviations[token] = maxDeviation;\n  }\n\n  /**\n    * @notice Emergency pause of this oracle\n  */\n  function emergencyPause() external onlyOwner whenNotPaused {\n    _pause();\n  }\n\n  /**\n    * @notice Emergency resume of this oracle\n  */\n  function emergencyResume() external onlyOwner whenPaused {\n    _unpause();\n  }\n}"
    }
  ]
}