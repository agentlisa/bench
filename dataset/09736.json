{
  "Title": "[M-09] Spreads can be minted with a deactivated oracle",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/FundsCalculator.sol#L91-L117\n\n\n# Vulnerability details\n\n## Impact\n\nWhen deactivateOracle() is called for an oracle in OracleRegistry it is still available for option spreads minting.\n\nThis way a user can continue to mint new options within spreads that rely on an oracle that was deactivated. As economic output of spreads is close to vanilla options, so all users who already posses an option linked to a deactivated oracle can surpass this deactivation, being able to mint new options linked to it as a part of option spreads.\n\n## Proof of Concept\n\nOracle active state is checked with isOracleActive() during option creation in validateOptionParameters() and during option minting in _mintOptionsPosition().\n\nIt isn't checked during spreads creation:\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/FundsCalculator.sol#L91-L117\n\nIn other words besides vanilla option minting and creation all spectrum of operations is available for the deactivated oracle assets, including spreads minting, which economically is reasonably close to vanilla minting.\n\n## Recommended Mitigation Steps\n\nIf oracle deactivation is meant to transfer all related assets to the close only state then consider requiring oracle to be active on spreads minting as well in the same way it's done for vanilla option minting:\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/Controller.sol#L188-L197\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-03-rolla-contest",
  "Code": [
    {
      "filename": "quant-protocol/contracts/libraries/FundsCalculator.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"./QuantMath.sol\";\nimport \"../options/QToken.sol\";\nimport \"../interfaces/IPriceRegistry.sol\";\n\n/// @title For calculating collateral requirements and payouts for options and spreads\n/// in a fixed point format\n/// @author Rolla\nlibrary FundsCalculator {\n    using QuantMath for uint256;\n    using QuantMath for int256;\n    using QuantMath for QuantMath.FixedPointInt;\n\n    struct OptionPayoutInput {\n        QuantMath.FixedPointInt strikePrice;\n        QuantMath.FixedPointInt expiryPrice;\n        QuantMath.FixedPointInt amount;\n    }\n\n    /// @notice Calculates payout of an option post-expiry from a qToken address\n    /// @param _qToken the address of the qToken (option) which is being exercised\n    /// @param _amount the amount of the qToken which is being exercised\n    /// @param _optionsDecimals option decimals constant. qTokens have 18 decimals\n    /// @param _strikeAssetDecimals the amount of decimals the strike asset has\n    /// @param _expiryPrice the expiry price of the option with the amount of decimals\n    /// @return payoutToken the address of the payout token\n    /// @return payoutAmount the amount to be payed out as a fixed point type\n    function getPayout(\n        address _qToken,\n        uint256 _amount,\n        uint8 _optionsDecimals,\n        uint8 _strikeAssetDecimals,\n        IPriceRegistry.PriceWithDecimals memory _expiryPrice\n    )\n        internal\n        view\n        returns (\n            address payoutToken,\n            QuantMath.FixedPointInt memory payoutAmount\n        )\n    {\n        QToken qToken = QToken(_qToken);\n        bool isCall = qToken.isCall();\n\n        payoutToken = isCall ? qToken.underlyingAsset() : qToken.strikeAsset();\n\n        payoutAmount = getPayoutAmount(\n            isCall,\n            qToken.strikePrice(),\n            _amount,\n            _optionsDecimals,\n            _strikeAssetDecimals,\n            _expiryPrice\n        );\n    }\n\n    /// @notice Calculates the collateral required to mint an option or a spread\n    /// @param _qTokenToMint the desired qToken\n    /// @param _qTokenForCollateral for spreads, this is the address of the qtoken to be used as collateral.\n    /// for options, no collateral is provided so the zero address should be passed.\n    /// @param _optionsAmount the amount of options/spread to mint\n    /// @param _optionsDecimals option decimals constant. qTokens have 18 decimals\n    /// @param _underlyingDecimals the amount of decimals the underlying asset has\n    /// @param _strikeAssetDecimals the amount of decimals the strike asset has\n    /// @return collateral the address of the collateral token required\n    /// @return collateralAmount the collateral amount required as a fixed point type\n    function getCollateralRequirement(\n        address _qTokenToMint,\n        address _qTokenForCollateral,\n        uint256 _optionsAmount,\n        uint8 _optionsDecimals,\n        uint8 _underlyingDecimals,\n        uint8 _strikeAssetDecimals\n    )\n        internal\n        view\n        returns (\n            address collateral,\n            QuantMath.FixedPointInt memory collateralAmount\n        )\n    {\n        QToken qTokenToMint = QToken(_qTokenToMint);\n        uint256 qTokenToMintStrikePrice = qTokenToMint.strikePrice();\n\n        uint256 qTokenForCollateralStrikePrice;\n\n        // check if we're getting the collateral requirement for a spread\n        if (_qTokenForCollateral != address(0)) {\n            QToken qTokenForCollateral = QToken(_qTokenForCollateral);\n            qTokenForCollateralStrikePrice = qTokenForCollateral.strikePrice();\n\n            // Check that expiries match\n            require(\n                qTokenToMint.expiryTime() == qTokenForCollateral.expiryTime(),\n                \"Controller: Can't create spreads from options with different expiries\"\n            );\n\n            // Check that the underlyings match\n            require(\n                qTokenToMint.underlyingAsset() ==\n                    qTokenForCollateral.underlyingAsset(),\n                \"Controller: Can't create spreads from options with different underlying assets\"\n            );\n\n            // Check that the option types match\n            require(\n                qTokenToMint.isCall() == qTokenForCollateral.isCall(),\n                \"Controller: Can't create spreads from options with different types\"\n            );\n\n            // Check that the options have a matching oracle\n            require(\n                qTokenToMint.oracle() == qTokenForCollateral.oracle(),\n                \"Controller: Can't create spreads from options with different oracles\"\n            );\n        } else {\n            // we're not getting the collateral requirement for a spread\n            qTokenForCollateralStrikePrice = 0;\n        }\n\n        collateralAmount = getOptionCollateralRequirement(\n            qTokenToMintStrikePrice,\n            qTokenForCollateralStrikePrice,\n            _optionsAmount,\n            qTokenToMint.isCall(),\n            _optionsDecimals,\n            _underlyingDecimals,\n            _strikeAssetDecimals\n        );\n\n        collateral = qTokenToMint.isCall()\n            ? qTokenToMint.underlyingAsset()\n            : qTokenToMint.strikeAsset();\n    }\n\n    /// @notice Calculates payout of an option post-expiry from qToken attributes\n    /// @param _isCall true if the option is a call, false for a put\n    /// @param _strikePrice the strike price of the option\n    /// @param _amount the amount of options being exercised\n    /// @param _optionsDecimals option decimals constant. qTokens have 18 decimals\n    /// @param _strikeAssetDecimals the amount of decimals the strike asset has\n    /// @param _expiryPrice the expiry price of the option with the amount of decimals\n    /// @return payoutAmount the amount to be payed out as a fixed point type\n    function getPayoutAmount(\n        bool _isCall,\n        uint256 _strikePrice,\n        uint256 _amount,\n        uint8 _optionsDecimals,\n        uint8 _strikeAssetDecimals,\n        IPriceRegistry.PriceWithDecimals memory _expiryPrice\n    ) internal pure returns (QuantMath.FixedPointInt memory payoutAmount) {\n        FundsCalculator.OptionPayoutInput memory payoutInput = FundsCalculator\n            .OptionPayoutInput(\n                _strikePrice.fromScaledUint(_strikeAssetDecimals),\n                _expiryPrice.price.fromScaledUint(_expiryPrice.decimals),\n                _amount.fromScaledUint(_optionsDecimals)\n            );\n\n        if (_isCall) {\n            payoutAmount = getPayoutForCall(payoutInput);\n        } else {\n            payoutAmount = getPayoutForPut(payoutInput);\n        }\n    }\n\n    /// @notice Calculates payout of a call given option payout inputs of strike, expiry and amount\n    /// @param payoutInput strike, expiry and amount as fixed points\n    /// @return payoutAmount the amount to be payed out as a fixed point type\n    function getPayoutForCall(\n        FundsCalculator.OptionPayoutInput memory payoutInput\n    ) internal pure returns (QuantMath.FixedPointInt memory payoutAmount) {\n        payoutAmount = payoutInput.expiryPrice.isGreaterThan(\n            payoutInput.strikePrice\n        )\n            ? payoutInput\n                .expiryPrice\n                .sub(payoutInput.strikePrice)\n                .mul(payoutInput.amount)\n                .div(payoutInput.expiryPrice)\n            : int256(0).fromUnscaledInt();\n    }\n\n    /// @notice Calculates payout of a put given option payout inputs of strike, expiry and amount\n    /// @param payoutInput strike, expiry and amount as fixed points\n    /// @return payoutAmount the amount to be payed out as a fixed point type\n    function getPayoutForPut(\n        FundsCalculator.OptionPayoutInput memory payoutInput\n    ) internal pure returns (QuantMath.FixedPointInt memory payoutAmount) {\n        payoutAmount = payoutInput.strikePrice.isGreaterThan(\n            payoutInput.expiryPrice\n        )\n            ? (payoutInput.strikePrice.sub(payoutInput.expiryPrice)).mul(\n                payoutInput.amount\n            )\n            : int256(0).fromUnscaledInt();\n    }\n\n    /// @notice Calculates the collateral required to mint an option or spread\n    /// @param _qTokenToMintStrikePrice the strike price of the qToken being minted \n    /// @param _qTokenForCollateralStrikePrice the strike price of the qToken being used as\n    /// collateral in the case of a spread\n    /// @param _optionsAmount the amount of options/spread being minted\n    /// @param _qTokenToMintIsCall whether or not the token to mint is a call. if a spread,\n    /// the qToken as collateral is implicitly also a call. and for minting a put, the \n    /// qToken as collateral is implicitly also a put\n    /// @param _optionsDecimals option decimals constant. qTokens have 18 decimals\n    /// @param _underlyingDecimals the amount of decimals the underlying asset has\n    /// @param _strikeAssetDecimals the amount of decimals the strike asset has\n    /// @return collateralAmount the collateral amount required as a fixed point type    \n    function getOptionCollateralRequirement(\n        uint256 _qTokenToMintStrikePrice,\n        uint256 _qTokenForCollateralStrikePrice,\n        uint256 _optionsAmount,\n        bool _qTokenToMintIsCall,\n        uint8 _optionsDecimals,\n        uint8 _underlyingDecimals,\n        uint8 _strikeAssetDecimals\n    ) internal pure returns (QuantMath.FixedPointInt memory collateralAmount) {\n        QuantMath.FixedPointInt memory collateralPerOption;\n        if (_qTokenToMintIsCall) {\n            collateralPerOption = getCallCollateralRequirement(\n                _qTokenToMintStrikePrice,\n                _qTokenForCollateralStrikePrice,\n                _underlyingDecimals,\n                _strikeAssetDecimals\n            );\n        } else {\n            collateralPerOption = getPutCollateralRequirement(\n                _qTokenToMintStrikePrice,\n                _qTokenForCollateralStrikePrice,\n                _strikeAssetDecimals\n            );\n        }\n\n        collateralAmount = _optionsAmount.fromScaledUint(_optionsDecimals).mul(\n            collateralPerOption\n        );\n    }\n\n    /// @notice Calculates the collateral required to mint a single PUT option or PUT spread\n    /// @param _qTokenToMintStrikePrice the strike price of the PUT qToken being minted \n    /// @param _qTokenForCollateralStrikePrice the strike price of the PUT qToken being used as\n    /// collateral in the case of a spread\n    /// @param _strikeAssetDecimals the amount of decimals the strike asset has\n    /// @return collateralPerOption the collateral amount required per option as a fixed point type\n    function getPutCollateralRequirement(\n        uint256 _qTokenToMintStrikePrice,\n        uint256 _qTokenForCollateralStrikePrice,\n        uint8 _strikeAssetDecimals\n    )\n        internal\n        pure\n        returns (QuantMath.FixedPointInt memory collateralPerOption)\n    {\n        QuantMath.FixedPointInt\n            memory mintStrikePrice = _qTokenToMintStrikePrice.fromScaledUint(\n                _strikeAssetDecimals\n            );\n        QuantMath.FixedPointInt\n            memory collateralStrikePrice = _qTokenForCollateralStrikePrice\n                .fromScaledUint(_strikeAssetDecimals);\n\n        // Initially (non-spread) required collateral is the long strike price\n        collateralPerOption = mintStrikePrice;\n\n        if (_qTokenForCollateralStrikePrice > 0) {\n            collateralPerOption = mintStrikePrice.isGreaterThan(\n                collateralStrikePrice\n            )\n                ? mintStrikePrice.sub(collateralStrikePrice) // Put Credit Spread\n                : int256(0).fromUnscaledInt(); // Put Debit Spread\n        }\n    }\n\n    /// @notice Calculates the collateral required to mint a single CALL option or CALL spread\n    /// @param _qTokenToMintStrikePrice the strike price of the CALL qToken being minted \n    /// @param _qTokenForCollateralStrikePrice the strike price of the CALL qToken being\n    /// used as collateral in the case of a spread\n    /// @param _underlyingDecimals the amount of decimals the underlying asset has\n    /// @param _strikeAssetDecimals the amount of decimals the strike asset has\n    /// @return collateralPerOption the collateral amount required per option as a fixed point type\n    function getCallCollateralRequirement(\n        uint256 _qTokenToMintStrikePrice,\n        uint256 _qTokenForCollateralStrikePrice,\n        uint8 _underlyingDecimals,\n        uint8 _strikeAssetDecimals\n    )\n        internal\n        pure\n        returns (QuantMath.FixedPointInt memory collateralPerOption)\n    {\n        QuantMath.FixedPointInt\n            memory mintStrikePrice = _qTokenToMintStrikePrice.fromScaledUint(\n                _strikeAssetDecimals\n            );\n        QuantMath.FixedPointInt\n            memory collateralStrikePrice = _qTokenForCollateralStrikePrice\n                .fromScaledUint(_strikeAssetDecimals);\n\n        // Initially (non-spread) required collateral is the long strike price\n        collateralPerOption = (10**_underlyingDecimals).fromScaledUint(\n            _underlyingDecimals\n        );\n\n        if (_qTokenForCollateralStrikePrice > 0) {\n            collateralPerOption = mintStrikePrice.isGreaterThanOrEqual(\n                collateralStrikePrice\n            )\n                ? int256(0).fromUnscaledInt() // Call Debit Spread\n                : (collateralStrikePrice.sub(mintStrikePrice)).div(\n                    collateralStrikePrice\n                ); // Call Credit Spread\n        }\n    }\n}"
    }
  ]
}