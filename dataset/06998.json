{
  "Title": "[M-14] lastFeeOperationTime is not modified correctly in function _updateLastFeeOpTime(), resulting a much slower decay model for borrowing base rate",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Core/contracts/TroveManager.sol#L1500-L1507\n\n\n# Vulnerability details\n\n## Impact\nDetailed description of the impact of this finding.\n``lastFeeOperationTime`` is not modified correctly in function ``_updateLastFeeOpTime()``. As a result, ``decayBaseRateFromBorrowing()``  will decay the base rate more slowly than expected (worst case half slower). \n\nSince borrowing base rate is so fundamental to the protocol, I would rate this finding as H.\n\n## Proof of Concept\nProvide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.\n\nWe show how ``decayBaseRateFromBorrowing()``  will decay the base rate more slowly than expected because of the wrong modification of ``lastFeeOperationTime`` in ``_updateLastFeeOpTime()``:\n\n1) ``decayBaseRateFromBorrowing()``  calls ``_calcDecayedBaseRate()`` to calculate the decayed base rate based how many minutes elapsed since last recorded ``lastFeeOperationTime``. \n\n```javascript\nfunction decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        uint decayedBaseRate = _calcDecayedBaseRate();\n        assert(decayedBaseRate <= DECIMAL_PRECISION);  // The baseRate can decay to 0\n\n        baseRate = decayedBaseRate;\n        emit BaseRateUpdated(decayedBaseRate);\n\n        _updateLastFeeOpTime();\n    }\n\n   function _calcDecayedBaseRate() internal view returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);\n    }\n\n function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\n }\n```\n\n2) ``decayBaseRateFromBorrowing()``  then calls ``_updateLastFeeOpTime()`` to set ``lastFeeOperationTime`` to the current time if at least 1 minute pass. \n\n```javascript\n function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n            emit LastFeeOpTimeUpdated(block.timestamp);\n        }\n    }\n```\n\n3) The problem with such an update of ``lastFeeOperationTime`` is, if 1.999 minutes had passed, the base rate will only decay for 1 minute, at the same time, 1.999 minutes will be added on``lastFeeOperationTime``. In other words, in a worst scenario, for every 1.999 minutes, the base rate will only decay for 1 minute. Therefore, the base rate will decay more slowly then expected. \n\n4) The borrowing base rate is very fundamental to the whole protocol. Any small deviation is  accumulative. In the worse case, the decay speed will slow down by half; on average, it will be 0.75 slower. \n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nUsing  the effective elapsed time that is consumed by the model so far to revise ``lastFeeOperationTime``.\n\n```diff\n function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n-            lastFeeOperationTime = block.timestamp;\n+            lastFeeOperationTime += _minutesPassedSinceLastFeeOp()*SECONDS_IN_ONE_MINUTE;\n            emit LastFeeOpTimeUpdated(block.timestamp);\n        }\n    }\n```\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-02-ethos-reserve-contest",
  "Code": [
    {
      "filename": "Ethos-Core/contracts/TroveManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.6.11;\n\nimport \"./Interfaces/ICollateralConfig.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IStabilityPool.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ILUSDToken.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/ILQTYStaking.sol\";\nimport \"./Interfaces/IRedemptionHelper.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\n// import \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/IERC20.sol\";\n\ncontract TroveManager is LiquityBase, /*Ownable,*/ CheckContract, ITroveManager {\n    // string constant public NAME = \"TroveManager\";\n\n    address public owner;\n\n    // --- Connected contract declarations ---\n\n    address public borrowerOperationsAddress;\n\n    ICollateralConfig public collateralConfig;\n\n    IStabilityPool public override stabilityPool;\n\n    address gasPoolAddress;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILUSDToken public override lusdToken;\n\n    IERC20 public override lqtyToken;\n\n    ILQTYStaking public override lqtyStaking;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    IRedemptionHelper public override redemptionHelper;\n\n    // --- Data structures ---\n\n    uint constant public SECONDS_IN_ONE_MINUTE = 60;\n    /*\n     * Half-life of 12h. 12h = 720 min\n     * (1/2) = d^720 => d = (1/2)^(1/720)\n     */\n    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;\n    uint constant public override REDEMPTION_FEE_FLOOR = DECIMAL_PRECISION / 1000 * 5; // 0.5%\n    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%\n\n    /*\n    * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption.\n    * Corresponds to (1 / ALPHA) in the white paper.\n    */\n    uint constant public BETA = 2;\n\n    uint public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new LUSD issuance)\n    uint public lastFeeOperationTime;\n\n    enum Status {\n        nonExistent,\n        active,\n        closedByOwner,\n        closedByLiquidation,\n        closedByRedemption\n    }\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint debt;\n        uint coll;\n        uint stake;\n        Status status;\n        uint128 arrayIndex;\n    }\n\n    // user => (collateral type => trove)\n    mapping (address => mapping (address => Trove)) public Troves;\n\n    mapping (address => uint) public totalStakes;\n\n    // Snapshot of the value of totalStakes for each collateral, taken immediately after the latest liquidation\n    mapping (address => uint) public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    mapping (address => uint) public totalCollateralSnapshot;\n\n    /*\n    * L_Collateral and L_LUSDDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n    *\n    * A collateral gain of ( stake * [L_Collateral - L_Collateral(0)] )\n    * A LUSDDebt increase  of ( stake * [L_LUSDDebt - L_LUSDDebt(0)] )\n    *\n    * Where L_Collateral(0) and L_LUSDDebt(0) are snapshots of L_Collateral and L_LUSDDebt for the active Trove taken at the instant the stake was made\n    */\n    mapping (address => uint) public L_Collateral;\n    mapping (address => uint) public L_LUSDDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    // user => (collateral type => reward snapshot))\n    mapping (address => mapping (address => RewardSnapshot)) public rewardSnapshots;\n\n    // Object containing the Collateral and LUSD snapshots for a given active trove\n    struct RewardSnapshot { uint collAmount; uint LUSDDebt;}\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    // collateral type => array of trove owners\n    mapping (address => address[]) public TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    mapping (address => uint) public lastCollateralError_Redistribution;\n    mapping (address => uint) public lastLUSDDebtError_Redistribution;\n\n    /*\n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: \"CompilerError: Stack too deep\".\n    **/\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint256 collDecimals;\n        uint256 collCCR;\n        uint256 collMCR;\n        uint price;\n        uint LUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint liquidatedDebt;\n        uint liquidatedColl;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        uint collToLiquidate;\n        uint pendingDebtReward;\n        uint pendingCollReward;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint remainingLUSDInStabPool;\n        uint i;\n        uint ICR;\n        uint TCR;\n        address user;\n        bool backToNormalMode;\n        uint entireSystemDebt;\n        uint entireSystemColl;\n        uint256 collDecimals;\n        uint256 collCCR;\n        uint256 collMCR;\n    }\n\n    struct LiquidationValues {\n        uint entireTroveDebt;\n        uint entireTroveColl;\n        uint collGasCompensation;\n        uint LUSDGasCompensation;\n        uint debtToOffset;\n        uint collToSendToSP;\n        uint debtToRedistribute;\n        uint collToRedistribute;\n        uint collSurplus;\n    }\n\n    struct LiquidationTotals {\n        uint totalCollInSequence;\n        uint totalDebtInSequence;\n        uint totalCollGasCompensation;\n        uint totalLUSDGasCompensation;\n        uint totalDebtToOffset;\n        uint totalCollToSendToSP;\n        uint totalDebtToRedistribute;\n        uint totalCollToRedistribute;\n        uint totalCollSurplus;\n    }\n\n    // --- Events ---\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event CollateralConfigAddressChanged(address _newCollateralConfigAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event LUSDTokenAddressChanged(address _newLUSDTokenAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event LQTYTokenAddressChanged(address _lqtyTokenAddress);\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\n    event RedemptionHelperAddressChanged(address _redemptionHelperAddress);\n\n    event Liquidation(address _collateral, uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _LUSDGasCompensation);\n    event TroveUpdated(address indexed _borrower, address _collateral, uint _debt, uint _coll, uint _stake, TroveManagerOperation _operation);\n    event TroveLiquidated(address indexed _borrower, address _collateral, uint _debt, uint _coll, TroveManagerOperation _operation);\n    event BaseRateUpdated(uint _baseRate);\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\n    event TotalStakesUpdated(address _collateral, uint _newTotalStakes);\n    event SystemSnapshotsUpdated(address _collateral, uint _totalStakesSnapshot, uint _totalCollateralSnapshot);\n    event LTermsUpdated(address _collateral, uint _L_Collateral, uint _L_LUSDDebt);\n    event TroveSnapshotsUpdated(address _collateral, uint _L_Collateral, uint _L_LUSDDebt);\n    event TroveIndexUpdated(address _borrower, address _collateral, uint _newIndex);\n    event Redemption(\n        address _collateral,\n        uint _attemptedLUSDAmount,\n        uint _actualLUSDAmount,\n        uint _collSent,\n        uint _collFee\n    );\n\n     enum TroveManagerOperation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        redeemCollateral\n    }\n\n    constructor() public {\n        // makeshift ownable implementation to circumvent contract size limit\n        owner = msg.sender;\n    }\n\n    // --- Dependency setter ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _collateralConfigAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _lusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _lqtyTokenAddress,\n        address _lqtyStakingAddress,\n        address _redemptionHelperAddress\n    )\n        external\n        override\n    {\n        require(msg.sender == owner);\n\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_collateralConfigAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_lusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_lqtyTokenAddress);\n        checkContract(_lqtyStakingAddress);\n        checkContract(_redemptionHelperAddress);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        collateralConfig = ICollateralConfig(_collateralConfigAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lqtyToken = IERC20(_lqtyTokenAddress);\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n        redemptionHelper = IRedemptionHelper(_redemptionHelperAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit CollateralConfigAddressChanged(_collateralConfigAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LQTYTokenAddressChanged(_lqtyTokenAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n        emit RedemptionHelperAddressChanged(_redemptionHelperAddress);\n\n        owner = address(0);\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount(address _collateral) external view override returns (uint) {\n        return TroveOwners[_collateral].length;\n    }\n\n    function getTroveFromTroveOwnersArray(address _collateral, uint _index) external view override returns (address) {\n        return TroveOwners[_collateral][_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.\n    function liquidate(address _borrower, address _collateral) external override {\n        _requireTroveIsActive(_borrower, _collateral);\n\n        address[] memory borrowers = new address[](1);\n        borrowers[0] = _borrower;\n        batchLiquidateTroves(_collateral, borrowers);\n    }\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _collateral,\n        address _borrower,\n        uint _LUSDInStabPool\n    )\n        internal\n        returns (LiquidationValues memory singleLiquidation)\n    {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n\n        (singleLiquidation.entireTroveDebt,\n        singleLiquidation.entireTroveColl,\n        vars.pendingDebtReward,\n        vars.pendingCollReward) = getEntireDebtAndColl(_borrower, _collateral);\n\n        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _collateral, vars.pendingDebtReward, vars.pendingCollReward);\n        _removeStake(_borrower, _collateral);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(singleLiquidation.entireTroveColl);\n        singleLiquidation.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        uint collToLiquidate = singleLiquidation.entireTroveColl.sub(singleLiquidation.collGasCompensation);\n\n        (singleLiquidation.debtToOffset,\n        singleLiquidation.collToSendToSP,\n        singleLiquidation.debtToRedistribute,\n        singleLiquidation.collToRedistribute) = _getOffsetAndRedistributionVals(singleLiquidation.entireTroveDebt, collToLiquidate, _LUSDInStabPool);\n\n        _closeTrove(_borrower, _collateral, Status.closedByLiquidation);\n        emit TroveLiquidated(_borrower, _collateral, singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, TroveManagerOperation.liquidateInNormalMode);\n        emit TroveUpdated(_borrower, _collateral, 0, 0, 0, TroveManagerOperation.liquidateInNormalMode);\n        return singleLiquidation;\n    }\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _collateral,\n        address _borrower,\n        uint _ICR,\n        uint _LUSDInStabPool,\n        uint _TCR,\n        uint _price,\n        uint256 _MCR\n    )\n        internal\n        returns (LiquidationValues memory singleLiquidation)\n    {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n        if (TroveOwners[_collateral].length <= 1) {return singleLiquidation;} // don't liquidate if last trove\n        (singleLiquidation.entireTroveDebt,\n        singleLiquidation.entireTroveColl,\n        vars.pendingDebtReward,\n        vars.pendingCollReward) = getEntireDebtAndColl(_borrower, _collateral);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(singleLiquidation.entireTroveColl);\n        singleLiquidation.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        vars.collToLiquidate = singleLiquidation.entireTroveColl.sub(singleLiquidation.collGasCompensation);\n\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR <= _100pct) {\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _collateral, vars.pendingDebtReward, vars.pendingCollReward);\n            _removeStake(_borrower, _collateral);\n           \n            singleLiquidation.debtToOffset = 0;\n            singleLiquidation.collToSendToSP = 0;\n            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;\n            singleLiquidation.collToRedistribute = vars.collToLiquidate;\n\n            _closeTrove(_borrower, _collateral, Status.closedByLiquidation);\n            emit TroveLiquidated(_borrower, _collateral, singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n            emit TroveUpdated(_borrower, _collateral, 0, 0, 0, TroveManagerOperation.liquidateInRecoveryMode);\n            \n        // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\n        } else if ((_ICR > _100pct) && (_ICR < _MCR)) {\n             _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _collateral, vars.pendingDebtReward, vars.pendingCollReward);\n            _removeStake(_borrower, _collateral);\n\n            (singleLiquidation.debtToOffset,\n            singleLiquidation.collToSendToSP,\n            singleLiquidation.debtToRedistribute,\n            singleLiquidation.collToRedistribute) = _getOffsetAndRedistributionVals(singleLiquidation.entireTroveDebt, vars.collToLiquidate, _LUSDInStabPool);\n\n            _closeTrove(_borrower, _collateral, Status.closedByLiquidation);\n            emit TroveLiquidated(_borrower, _collateral, singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n            emit TroveUpdated(_borrower, _collateral, 0, 0, 0, TroveManagerOperation.liquidateInRecoveryMode);\n        /*\n        * If MCR <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\n        * and there is LUSD in the Stability Pool, only offset, with no redistribution,\n        * but at a capped rate of MCR and only if the whole debt can be liquidated.\n        * The remainder due to the capped rate will be claimable as collateral surplus.\n        */\n        } else if ((_ICR >= _MCR) && (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _LUSDInStabPool)) {\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _collateral, vars.pendingDebtReward, vars.pendingCollReward);\n            assert(_LUSDInStabPool != 0);\n\n            _removeStake(_borrower, _collateral);\n            uint collDecimals = collateralConfig.getCollateralDecimals(_collateral);\n            singleLiquidation = _getCappedOffsetVals(singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, _price, _MCR, collDecimals);\n\n            _closeTrove(_borrower, _collateral, Status.closedByLiquidation);\n            if (singleLiquidation.collSurplus > 0) {\n                collSurplusPool.accountSurplus(_borrower, _collateral, singleLiquidation.collSurplus);\n            }\n\n            emit TroveLiquidated(_borrower, _collateral, singleLiquidation.entireTroveDebt, singleLiquidation.collToSendToSP, TroveManagerOperation.liquidateInRecoveryMode);\n            emit TroveUpdated(_borrower, _collateral, 0, 0, 0, TroveManagerOperation.liquidateInRecoveryMode);\n\n        } else { // if (_ICR >= _MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _LUSDInStabPool))\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        return singleLiquidation;\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be\n    * redistributed to active troves.\n    */\n    function _getOffsetAndRedistributionVals\n    (\n        uint _debt,\n        uint _coll,\n        uint _LUSDInStabPool\n    )\n        internal\n        pure\n        returns (uint debtToOffset, uint collToSendToSP, uint debtToRedistribute, uint collToRedistribute)\n    {\n        if (_LUSDInStabPool > 0) {\n        /*\n        * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n        * between all active troves.\n        *\n        *  If the trove's debt is larger than the deposited LUSD in the Stability Pool:\n        *\n        *  - Offset an amount of the trove's debt equal to the LUSD in the Stability Pool\n        *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n        *\n        */\n            debtToOffset = LiquityMath._min(_debt, _LUSDInStabPool);\n            collToSendToSP = _coll.mul(debtToOffset).div(_debt);\n            debtToRedistribute = _debt.sub(debtToOffset);\n            collToRedistribute = _coll.sub(collToSendToSP);\n        } else {\n            debtToOffset = 0;\n            collToSendToSP = 0;\n            debtToRedistribute = _debt;\n            collToRedistribute = _coll;\n        }\n    }\n\n    /*\n    *  Get its offset coll/debt and ETH gas comp, and close the trove.\n    */\n    function _getCappedOffsetVals\n    (\n        uint _entireTroveDebt,\n        uint _entireTroveColl,\n        uint _price,\n        uint256 _MCR,\n        uint _collDecimals\n    )\n        internal\n        pure\n        returns (LiquidationValues memory singleLiquidation)\n    {\n        singleLiquidation.entireTroveDebt = _entireTroveDebt;\n        singleLiquidation.entireTroveColl = _entireTroveColl;\n        uint cappedCollPortion = _entireTroveDebt.mul(_MCR).div(_price);\n        if (_collDecimals < LiquityMath.CR_CALCULATION_DECIMALS) {\n            cappedCollPortion = cappedCollPortion.div(10 ** (LiquityMath.CR_CALCULATION_DECIMALS - _collDecimals));\n        } else if (_collDecimals > LiquityMath.CR_CALCULATION_DECIMALS) {\n            cappedCollPortion = cappedCollPortion.mul(10 ** (_collDecimals - LiquityMath.CR_CALCULATION_DECIMALS));\n        }\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(cappedCollPortion);\n        singleLiquidation.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n\n        singleLiquidation.debtToOffset = _entireTroveDebt;\n        singleLiquidation.collToSendToSP = cappedCollPortion.sub(singleLiquidation.collGasCompensation);\n        singleLiquidation.collSurplus = _entireTroveColl.sub(cappedCollPortion);\n        singleLiquidation.debtToRedistribute = 0;\n        singleLiquidation.collToRedistribute = 0;\n    }\n\n    /*\n    * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\n    * starting from the one with the lowest collateral ratio in the system, and moving upwards\n    */\n    function liquidateTroves(address _collateral, uint _n) external override {\n        IActivePool activePoolCached = activePool;\n        IDefaultPool defaultPoolCached = defaultPool;\n        IStabilityPool stabilityPoolCached = stabilityPool;\n\n        LocalVariables_OuterLiquidationFunction memory vars;\n        LiquidationTotals memory totals;\n\n        vars.collCCR = collateralConfig.getCollateralCCR(_collateral);\n        vars.collDecimals = collateralConfig.getCollateralDecimals(_collateral);\n        vars.collMCR = collateralConfig.getCollateralMCR(_collateral);\n        vars.price = priceFeed.fetchPrice(_collateral);\n        vars.LUSDInStabPool = stabilityPoolCached.getTotalLUSDDeposits();\n        vars.recoveryModeAtStart = _checkRecoveryMode(_collateral, vars.price, vars.collCCR, vars.collDecimals);\n\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\n        if (vars.recoveryModeAtStart) {\n            totals = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(\n                activePoolCached,\n                defaultPoolCached,\n                sortedTroves,\n                _collateral,\n                vars.price,\n                vars.LUSDInStabPool,\n                _n\n            );\n        } else { // if !vars.recoveryModeAtStart\n            totals = _getTotalsFromLiquidateTrovesSequence_NormalMode(\n                activePoolCached,\n                defaultPoolCached,\n                _collateral,\n                vars.price,\n                vars.collMCR,\n                vars.LUSDInStabPool,\n                _n\n            );\n        }\n\n        require(totals.totalDebtInSequence > 0);\n\n        // Move liquidated collateral and LUSD to the appropriate pools\n        stabilityPoolCached.offset(_collateral, totals.totalDebtToOffset, totals.totalCollToSendToSP);\n        _redistributeDebtAndColl(\n            activePoolCached,\n            defaultPoolCached,\n            _collateral,\n            totals.totalDebtToRedistribute,\n            totals.totalCollToRedistribute,\n            vars.collDecimals\n        );\n        if (totals.totalCollSurplus > 0) {\n            activePoolCached.sendCollateral(_collateral, address(collSurplusPool), totals.totalCollSurplus);\n        }\n\n        // Update system snapshots\n        _updateSystemSnapshots_excludeCollRemainder(activePoolCached, _collateral, totals.totalCollGasCompensation);\n\n        vars.liquidatedDebt = totals.totalDebtInSequence;\n        vars.liquidatedColl = totals.totalCollInSequence.sub(totals.totalCollGasCompensation).sub(totals.totalCollSurplus);\n        emit Liquidation(_collateral, vars.liquidatedDebt, vars.liquidatedColl, totals.totalCollGasCompensation, totals.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(activePoolCached, _collateral, msg.sender, totals.totalLUSDGasCompensation, totals.totalCollGasCompensation);\n    }\n\n    /*\n    * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode\n    (\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        ISortedTroves _sortedTroves,\n        address _collateral,\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory totals)\n    {\n        LocalVariables_LiquidationSequence memory vars;\n        vars.collDecimals = collateralConfig.getCollateralDecimals(_collateral);\n        vars.collCCR = collateralConfig.getCollateralCCR(_collateral);\n        vars.collMCR = collateralConfig.getCollateralMCR(_collateral);\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingLUSDInStabPool = _LUSDInStabPool;\n        vars.backToNormalMode = false;\n        vars.entireSystemDebt = getEntireSystemDebt(_collateral);\n        vars.entireSystemColl = getEntireSystemColl(_collateral);\n\n        vars.user = _sortedTroves.getLast(_collateral);\n        address firstUser = _sortedTroves.getFirst(_collateral);\n        for (vars.i = 0; vars.i < _n && vars.user != firstUser; vars.i++) {\n            // we need to cache it, because current user is likely going to be deleted\n            address nextUser = _sortedTroves.getPrev(_collateral, vars.user);\n\n            vars.ICR = getCurrentICR(vars.user, _collateral, _price);\n\n            if (!vars.backToNormalMode) {\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\n                if (vars.ICR >= vars.collMCR && vars.remainingLUSDInStabPool == 0) { break; }\n\n                vars.TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt, _price, vars.collDecimals);\n\n                singleLiquidation = _liquidateRecoveryMode(\n                    _activePool,\n                    _defaultPool,\n                    _collateral,\n                    vars.user,\n                    vars.ICR,\n                    vars.remainingLUSDInStabPool,\n                    vars.TCR,\n                    _price,\n                    vars.collMCR\n                );\n\n                // Update aggregate trackers\n                vars.remainingLUSDInStabPool = vars.remainingLUSDInStabPool.sub(singleLiquidation.debtToOffset);\n                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);\n                vars.entireSystemColl = vars.entireSystemColl.\n                    sub(singleLiquidation.collToSendToSP).\n                    sub(singleLiquidation.collGasCompensation).\n                    sub(singleLiquidation.collSurplus);\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(\n                    vars.entireSystemColl,\n                    vars.entireSystemDebt,\n                    _price,\n                    vars.collDecimals,\n                    vars.collCCR\n                );\n            }\n            else if (vars.backToNormalMode && vars.ICR < vars.collMCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _activePool,\n                    _defaultPool,\n                    _collateral,\n                    vars.user,\n                    vars.remainingLUSDInStabPool\n                );\n\n                vars.remainingLUSDInStabPool = vars.remainingLUSDInStabPool.sub(singleLiquidation.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n            }  else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            vars.user = nextUser;\n        }\n    }\n\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode\n    (\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _collateral,\n        uint _price,\n        uint256 _MCR,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory totals)\n    {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n        ISortedTroves sortedTrovesCached = sortedTroves;\n\n        vars.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        for (vars.i = 0; vars.i < _n; vars.i++) {\n            vars.user = sortedTrovesCached.getLast(_collateral);\n            vars.ICR = getCurrentICR(vars.user, _collateral, _price);\n\n            if (vars.ICR < _MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _activePool,\n                    _defaultPool,\n                    _collateral,\n                    vars.user,\n                    vars.remainingLUSDInStabPool\n                );\n\n                vars.remainingLUSDInStabPool = vars.remainingLUSDInStabPool.sub(singleLiquidation.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n            } else break;  // break if the loop reaches a Trove with ICR >= MCR\n        }\n    }\n\n    /*\n    * Attempt to liquidate a custom list of troves (for the specified collateral) provided by the caller.\n    */\n    function batchLiquidateTroves(address _collateral, address[] memory _troveArray) public override {\n        require(_troveArray.length != 0);\n\n        IActivePool activePoolCached = activePool;\n        IDefaultPool defaultPoolCached = defaultPool;\n        IStabilityPool stabilityPoolCached = stabilityPool;\n\n        LocalVariables_OuterLiquidationFunction memory vars;\n        LiquidationTotals memory totals;\n\n        vars.collDecimals = collateralConfig.getCollateralDecimals(_collateral);\n        vars.collCCR = collateralConfig.getCollateralCCR(_collateral);\n        vars.collMCR = collateralConfig.getCollateralMCR(_collateral);\n        vars.price = priceFeed.fetchPrice(_collateral);\n        vars.LUSDInStabPool = stabilityPoolCached.getTotalLUSDDeposits();\n        vars.recoveryModeAtStart = _checkRecoveryMode(_collateral, vars.price, vars.collCCR, vars.collDecimals);\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (vars.recoveryModeAtStart) {\n            totals = _getTotalFromBatchLiquidate_RecoveryMode(\n                activePoolCached,\n                defaultPoolCached,\n                _collateral,\n                vars.price,\n                vars.LUSDInStabPool,\n                _troveArray\n            );\n        } else {  //  if !vars.recoveryModeAtStart\n            totals = _getTotalsFromBatchLiquidate_NormalMode(\n                activePoolCached,\n                defaultPoolCached,\n                _collateral,\n                vars.price,\n                vars.collMCR,\n                vars.LUSDInStabPool,\n                _troveArray\n            );\n        }\n\n        require(totals.totalDebtInSequence > 0);\n\n        // Move liquidated collateral and LUSD to the appropriate pools\n        stabilityPoolCached.offset(_collateral, totals.totalDebtToOffset, totals.totalCollToSendToSP);\n        _redistributeDebtAndColl(\n            activePoolCached,\n            defaultPoolCached,\n            _collateral,\n            totals.totalDebtToRedistribute,\n            totals.totalCollToRedistribute,\n            vars.collDecimals\n        );\n        if (totals.totalCollSurplus > 0) {\n            activePoolCached.sendCollateral(_collateral, address(collSurplusPool), totals.totalCollSurplus);\n        }\n\n        // Update system snapshots\n        _updateSystemSnapshots_excludeCollRemainder(activePoolCached, _collateral, totals.totalCollGasCompensation);\n\n        vars.liquidatedDebt = totals.totalDebtInSequence;\n        vars.liquidatedColl = totals.totalCollInSequence.sub(totals.totalCollGasCompensation).sub(totals.totalCollSurplus);\n        emit Liquidation(_collateral, vars.liquidatedDebt, vars.liquidatedColl, totals.totalCollGas"
    }
  ]
}