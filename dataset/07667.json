{
  "Title": "[M-25] Incorrect checking in _assertUserHasEnoughGiantLPToClaimVaultLP",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L93-L97\n\n\n# Vulnerability details\n\n## Impact\nThe batch operations of `withdrawDETH()` in GiantSavETHVaultPool.sol and `withdrawLPTokens()` in GiantPoolBase.sol are meaningless because they will fail whenever more than one lpToken is passed.\nEach user can perform `withdrawDETH()` or `withdrawLPTokens()` with one LPToken only once a day.\n\n## Proof of Concept\n\nBoth the `withdrawDETH()` in GiantSavETHVaultPool.sol and `withdrawLPTokens()` in GiantPoolBase.sol will call `GiantPoolBase._assertUserHasEnoughGiantLPToClaimVaultLP(lpToken, amount)` and `lpTokenETH.burn(msg.sender, amount)`:\n\nThere is a require in `_assertUserHasEnoughGiantLPToClaimVaultLP()`:\n```\nrequire(lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, \"Too new\");\n```\n\nAt the same time, `lpTokenETH.burn(msg.sender, amount)` will update `lastInteractedTimestamp[msg.sender]` to latest block timestamp in `_afterTokenTransfer()` of GiantLP.sol.\n\nSo, a user can perform `withdrawDETH` or `withdrawLPTokens` of one LPToken only once a day, others more will fail by `_assertUserHasEnoughGiantLPToClaimVaultLP()`.\n\n## Tools Used\nVS Code\n\n## Recommended Mitigation Steps\n\nThe LPToken being operated on should be checked for lastInteractedTimestamp rather than lpTokenETH.\n\n```\ndiff --git a/contracts/liquid-staking/GiantPoolBase.sol b/contracts/liquid-staking/GiantPoolBase.sol\nindex 8a8ff70..5c009d9 100644\n--- a/contracts/liquid-staking/GiantPoolBase.sol\n+++ b/contracts/liquid-staking/GiantPoolBase.sol\n@@ -93,7 +93,7 @@ contract GiantPoolBase is ReentrancyGuard {\n     function _assertUserHasEnoughGiantLPToClaimVaultLP(LPToken _token, uint256 _amount) internal view {\n         require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");\n         require(_token.balanceOf(address(this)) >= _amount, \"Pool does not own specified LP\");\n-        require(lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, \"Too new\");\n+        require(_token.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, \"Too new\");\n     }\n\n     /// @dev Allow an inheriting contract to have a hook for performing operations post depositing ETH\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
  "Code": [
    {
      "filename": "contracts/liquid-staking/GiantPoolBase.sol",
      "content": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\n\ncontract GiantPoolBase is ReentrancyGuard {\n\n    /// @notice Emitted when an account deposits Ether into the giant pool\n    event ETHDeposited(address indexed sender, uint256 amount);\n\n    /// @notice Emitted when giant LP is burnt to recover ETH\n    event LPBurnedForETH(address indexed sender, uint256 amount);\n\n    /// @notice Emitted when giant LP is burnt to receive LP from a specific vault\n    event LPSwappedForVaultLP(address indexed vaultLPToken, address indexed sender, uint256 amount);\n\n    /// @notice Minimum amount of Ether that can be deposited into the contract\n    uint256 public constant MIN_STAKING_AMOUNT = 0.001 ether;\n\n    /// @notice Total amount of ETH sat idle ready for either withdrawal or depositing into a liquid staking network\n    uint256 public idleETH;\n\n    /// @notice LP token representing all ETH deposited and any ETH converted into savETH vault LP tokens from any liquid staking network\n    GiantLP public lpTokenETH;\n\n    /// @notice Address of the liquid staking derivative factory that provides a source of truth on individual networks that can be funded\n    LSDNFactory public liquidStakingDerivativeFactory;\n\n    /// @notice Add ETH to the ETH LP pool at a rate of 1:1. LPs can always pull out at same rate.\n    function depositETH(uint256 _amount) public payable {\n        require(msg.value >= MIN_STAKING_AMOUNT, \"Minimum not supplied\");\n        require(msg.value == _amount, \"Value equal to amount\");\n\n        // The ETH capital has not yet been deployed to a liquid staking network\n        idleETH += msg.value;\n\n        // Mint giant LP at ratio of 1:1\n        lpTokenETH.mint(msg.sender, msg.value);\n\n        // If anything extra needs to be done\n        _onDepositETH();\n\n        emit ETHDeposited(msg.sender, msg.value);\n    }\n\n    /// @notice Allow a user to chose to burn their LP tokens for ETH only if the requested amount is idle and available from the contract\n    /// @param _amount of LP tokens user is burning in exchange for same amount of ETH\n    function withdrawETH(uint256 _amount) external nonReentrant {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");\n        require(lpTokenETH.balanceOf(msg.sender) >= _amount, \"Invalid balance\");\n        require(idleETH >= _amount, \"Come back later or withdraw less ETH\");\n\n        idleETH -= _amount;\n\n        lpTokenETH.burn(msg.sender, _amount);\n        (bool success,) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Failed to transfer ETH\");\n\n        emit LPBurnedForETH(msg.sender, _amount);\n    }\n\n    /// @notice Allow a user to chose to withdraw vault LP tokens by burning their giant LP tokens. 1 Giant LP == 1 vault LP\n    /// @param _lpTokens List of LP tokens being owned and being withdrawn from the giant pool\n    /// @param _amounts List of amounts of giant LP being burnt in exchange for vault LP\n    function withdrawLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external {\n        uint256 amountOfTokens = _lpTokens.length;\n        require(amountOfTokens > 0, \"Empty arrays\");\n        require(amountOfTokens == _amounts.length, \"Inconsistent array lengths\");\n\n        _onWithdraw(_lpTokens);\n\n        for (uint256 i; i < amountOfTokens; ++i) {\n            LPToken token = _lpTokens[i];\n            uint256 amount = _amounts[i];\n\n            _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);\n\n            // Burn giant LP from user before sending them an LP token from this pool\n            lpTokenETH.burn(msg.sender, amount);\n\n            // Giant LP tokens in this pool are 1:1 exchangeable with external savETH vault LP\n            token.transfer(msg.sender, amount);\n\n            emit LPSwappedForVaultLP(address(token), msg.sender, amount);\n        }\n    }\n\n    /// @dev Check the msg.sender has enough giant LP to burn and that the pool has enough savETH vault LP\n    function _assertUserHasEnoughGiantLPToClaimVaultLP(LPToken _token, uint256 _amount) internal view {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");\n        require(_token.balanceOf(address(this)) >= _amount, \"Pool does not own specified LP\");\n        require(lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, \"Too new\");\n    }\n\n    /// @dev Allow an inheriting contract to have a hook for performing operations post depositing ETH\n    function _onDepositETH() internal virtual {}\n\n    /// @dev Allow an inheriting contract to have a hook for performing operations during withdrawal of LP tokens when burning giant LP\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal virtual {}\n}"
    }
  ]
}