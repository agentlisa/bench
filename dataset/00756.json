{
  "Title": "Incorrect Check in BalancerFlashloanDirectMintHandler",
  "Content": "In the [`receiveFlashLoan` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/flash/handlers/base/BalancerFlashloanDirectMintHandler.sol#L161) of the `BalancerFlashLoanDirectMindHandler` contract, there is a [check comparing the LST amount minted to the maximum WETH-denominated debt](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/flash/handlers/base/BalancerFlashloanDirectMintHandler.sol#L184).\n\n\nThis check is incorrect as it compares two different tokens' amounts. It happens to work for the current collaterals as they have 18 decimals and are more valuable than WETH, so a certain value of LST will generally be less than the corresponding value of WETH. However, in the case that the LST loses value, or a new LST is onboarded with more LST corresponding to a certain amount of WETH, this check may fail, causing the [`flashLeverageWeth` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/flash/handlers/base/BalancerFlashloanDirectMintHandler.sol#L99) to be uncallable.\n\n\nIn addition, note that the intention of this check is redundant with [the check on line 129](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/flash/handlers/base/BalancerFlashloanDirectMintHandler.sol#L129), where both variables being compared are denominated in WETH, and prevents the `maxResultingDebt` from being exceeded.\n\n\nConsider removing the identified check to avoid failure in the described cases and to improve the readability and maintainability of the code.\n\n\n***Update:** Resolved in [pull request #24](https://github.com/Ion-Protocol/ion-protocol/pull/24).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/flash/handlers/base/BalancerFlashloanDirectMintHandler.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IonHandlerBase } from \"./IonHandlerBase.sol\";\n\nimport { IVault, IERC20 as IERC20Balancer } from \"@balancer-labs/v2-interfaces/contracts/vault/IVault.sol\";\nimport { IFlashLoanRecipient } from \"@balancer-labs/v2-interfaces/contracts/vault/IFlashLoanRecipient.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nIVault constant VAULT = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n\n/**\n * @dev There are a couple things to consider here from a security perspective. The\n * first one is that the flashloan callback must only be callable from the\n * Balancer vault. This ensures that nobody can pass arbitrary data to the\n * callback. The second one is that the flashloan must only be initialized from\n * this contract. This is a trickier one to enforce since Balancer flashloans\n * are not EIP-3156 compliant and do not pass on the initiator through the\n * callback. To get around this, an inverse reentrancy lock of sorts is used.\n * The lock is set to 2 when a flashloan is initiated and set to 1 once the\n * callback execution terminates. If the lock is not 2 when the callback is\n * called, then the flashloan was not initiated by this contract and the tx is\n * reverted.\n *\n * This contract currently deposits directly into LST contract 1:1. It should be\n * noted that a more favorable trade could be possible via DEXs.\n */\nabstract contract BalancerFlashloanDirectMintHandler is IonHandlerBase, IFlashLoanRecipient {\n    using SafeERC20 for IERC20;\n\n    error ReceiveCallerNotVault(address unauthorizedCaller);\n    error FlashLoanedTooManyTokens(uint256 amountTokens);\n    error FlashloanedInvalidToken(address tokenAddress);\n    error ExternalBalancerFlashloanNotAllowed();\n\n    uint256 private flashloanInitiated = 1;\n\n    /**\n     * @notice Code assumes Balancer flashloans remain free\n     * @param initialDeposit in collateral terms\n     * @param resultingAdditionalCollateral in collateral terms\n     * @param maxResultingDebt in WETH terms. While it is unlikely that the\n     * exchange rate changes from when a transaction is submitted versus when it\n     * is executed, it is still possible so we want to allow for a bound here,\n     * even though it doesn't pose the same level of threat as slippage.\n     */\n    function flashLeverageCollateral(\n        uint256 initialDeposit,\n        uint256 resultingAdditionalCollateral,\n        uint256 maxResultingDebt\n    )\n        external\n    {\n        LST_TOKEN.safeTransferFrom(msg.sender, address(this), initialDeposit);\n\n        uint256 amountToLeverage = resultingAdditionalCollateral - initialDeposit; // in collateral terms\n\n        IERC20Balancer[] memory addresses = new IERC20Balancer[](1);\n        addresses[0] = IERC20Balancer(address(LST_TOKEN));\n\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = amountToLeverage;\n\n        if (amounts[0] == 0) {\n            // AmountToBorrow.IS_MAX because we don't want to create any new debt here\n            _depositAndBorrow(msg.sender, address(this), resultingAdditionalCollateral, 0, AmountToBorrow.IS_MAX);\n            return;\n        }\n\n        uint256 wethRequiredForRepayment = _getEthAmountInForLstAmountOut(amountToLeverage);\n        if (wethRequiredForRepayment > maxResultingDebt) {\n            revert FlashloanRepaymentTooExpensive(wethRequiredForRepayment, maxResultingDebt);\n        }\n\n        // Prevents attackers from initiating flashloan and passing malicious data through callback\n        flashloanInitiated = 2;\n\n        VAULT.flashLoan(\n            IFlashLoanRecipient(address(this)),\n            addresses,\n            amounts,\n            abi.encode(msg.sender, initialDeposit, resultingAdditionalCollateral, maxResultingDebt)\n        );\n\n        flashloanInitiated = 1;\n    }\n\n    /**\n     * @notice Code assumes Balancer flashloans remain free\n     * @param initialDeposit in collateral terms\n     * @param resultingAdditionalCollateral in collateral terms\n     * @param maxResultingDebt in WETH terms. While it is unlikely that the\n     * exchange rate changes from when a transaction is submitted versus when it\n     * is executed, it is still possible so we want to allow for a bound here,\n     * even though it doesn't pose the same level of threat as slippage.\n     */\n    function flashLeverageWeth(\n        uint256 initialDeposit,\n        uint256 resultingAdditionalCollateral,\n        uint256 maxResultingDebt\n    )\n        external\n        payable\n    {\n        LST_TOKEN.safeTransferFrom(msg.sender, address(this), initialDeposit);\n\n        IERC20Balancer[] memory addresses = new IERC20Balancer[](1);\n        addresses[0] = IERC20Balancer(address(WETH));\n\n        uint256 amountLst = resultingAdditionalCollateral - initialDeposit; // in collateral terms\n        uint256 amountWethToFlashloan = _getEthAmountInForLstAmountOut(amountLst);\n\n        if (amountWethToFlashloan == 0) {\n            // AmountToBorrow.IS_MAX because we don't want to create any new debt here\n            _depositAndBorrow(msg.sender, address(this), resultingAdditionalCollateral, 0, AmountToBorrow.IS_MAX);\n            return;\n        }\n\n        // It is technically possible to accrue slight dust amounts more of debt\n        // than maxResultingDebt because you may need to borrow slightly more at\n        // the IonPool level to receieve the desired amount of WETH. This is\n        // because the IonPool will round in its favor and always gives out dust\n        // amounts less of WETH than the debt accrued to the position. However,\n        // this will always be bounded by the rate of the ilk at the time\n        // divided by RAY and will NEVER be subject to slippage, which is what\n        // we really want to protect against.\n        if (amountWethToFlashloan > maxResultingDebt) {\n            revert FlashloanRepaymentTooExpensive(amountWethToFlashloan, maxResultingDebt);\n        }\n\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = amountWethToFlashloan;\n\n        flashloanInitiated = 2;\n\n        VAULT.flashLoan(\n            IFlashLoanRecipient(address(this)),\n            addresses,\n            amounts,\n            abi.encode(msg.sender, initialDeposit, resultingAdditionalCollateral, maxResultingDebt)\n        );\n\n        flashloanInitiated = 1;\n    }\n\n    /**\n     * @notice Code assumes Balancer flashloans remain free.\n     * @dev This function is intended to never be called directly. It should\n     * only be called by the Balancer VAULT during a flashloan initiated by this\n     * contract. This callback logic only handles the creation of leverage\n     * positions by minting. Since not all tokens have withdrawable liquidity\n     * via the LST protocol directly, deleverage through the protocol will need\n     * to be implemented in the inheriting contract.\n     *\n     * @param tokens Array of tokens flash loaned\n     * @param amounts amounts flash loaned\n     * @param userData arbitrary data passed from initiator of flash loan\n     */\n    function receiveFlashLoan(\n        IERC20Balancer[] memory tokens,\n        uint256[] memory amounts,\n        uint256[] memory,\n        bytes memory userData\n    )\n        external\n        override\n    {\n        if (tokens.length > 1) revert FlashLoanedTooManyTokens(tokens.length);\n        if (msg.sender != address(VAULT)) revert ReceiveCallerNotVault(msg.sender);\n        if (flashloanInitiated != 2) revert ExternalBalancerFlashloanNotAllowed();\n\n        IERC20Balancer token = tokens[0];\n        (address user, uint256 initialDeposit, uint256 resultingAdditionalCollateral, uint256 maxResultingDebt) =\n            abi.decode(userData, (address, uint256, uint256, uint256));\n\n        // Flashloaned WETH needs to be converted into collateral asset\n        if (address(token) == address(WETH)) {\n            uint256 collateralFromDeposit = _depositWethForLst(amounts[0]);\n\n            // Sanity checks\n            assert(collateralFromDeposit + initialDeposit == resultingAdditionalCollateral);\n            assert(collateralFromDeposit <= maxResultingDebt);\n\n            // AmountToBorrow.IS_MIN because we want to make sure enough is borrowed to cover flashloan\n            _depositAndBorrow(user, address(this), resultingAdditionalCollateral, amounts[0], AmountToBorrow.IS_MIN);\n\n            WETH.transfer(address(VAULT), amounts[0]);\n        } else {\n            if (address(LST_TOKEN) != address(token)) revert FlashloanedInvalidToken(address(token));\n\n            uint256 wethToBorrow = _getEthAmountInForLstAmountOut(amounts[0]);\n\n            // Sanity checks\n            assert(amounts[0] + initialDeposit == resultingAdditionalCollateral);\n            assert(wethToBorrow <= maxResultingDebt);\n\n            // AmountToBorrow.IS_MIN because we want to make sure enough is borrowed to cover flashloan\n            _depositAndBorrow(user, address(this), resultingAdditionalCollateral, wethToBorrow, AmountToBorrow.IS_MIN);\n\n            // Convert borrowed WETH back to collateral token\n            uint256 tokenAmountReceived = _depositWethForLst(wethToBorrow);\n\n            LST_TOKEN.safeTransfer(address(VAULT), tokenAmountReceived);\n        }\n    }\n\n    /**\n     * @dev Unwraps weth into eth and deposits into lst contract\n     * @param amountWeth to deposit\n     * @return amountLst received\n     */\n    function _depositWethForLst(uint256 amountWeth) internal virtual returns (uint256);\n\n    function _getEthAmountInForLstAmountOut(uint256 amountLst) internal view virtual returns (uint256);\n}"
    },
    {
      "filename": "src/flash/handlers/base/BalancerFlashloanDirectMintHandler.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IonHandlerBase } from \"./IonHandlerBase.sol\";\n\nimport { IVault, IERC20 as IERC20Balancer } from \"@balancer-labs/v2-interfaces/contracts/vault/IVault.sol\";\nimport { IFlashLoanRecipient } from \"@balancer-labs/v2-interfaces/contracts/vault/IFlashLoanRecipient.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nIVault constant VAULT = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n\n/**\n * @dev There are a couple things to consider here from a security perspective. The\n * first one is that the flashloan callback must only be callable from the\n * Balancer vault. This ensures that nobody can pass arbitrary data to the\n * callback. The second one is that the flashloan must only be initialized from\n * this contract. This is a trickier one to enforce since Balancer flashloans\n * are not EIP-3156 compliant and do not pass on the initiator through the\n * callback. To get around this, an inverse reentrancy lock of sorts is used.\n * The lock is set to 2 when a flashloan is initiated and set to 1 once the\n * callback execution terminates. If the lock is not 2 when the callback is\n * called, then the flashloan was not initiated by this contract and the tx is\n * reverted.\n *\n * This contract currently deposits directly into LST contract 1:1. It should be\n * noted that a more favorable trade could be possible via DEXs.\n */\nabstract contract BalancerFlashloanDirectMintHandler is IonHandlerBase, IFlashLoanRecipient {\n    using SafeERC20 for IERC20;\n\n    error ReceiveCallerNotVault(address unauthorizedCaller);\n    error FlashLoanedTooManyTokens(uint256 amountTokens);\n    error FlashloanedInvalidToken(address tokenAddress);\n    error ExternalBalancerFlashloanNotAllowed();\n\n    uint256 private flashloanInitiated = 1;\n\n    /**\n     * @notice Code assumes Balancer flashloans remain free\n     * @param initialDeposit in collateral terms\n     * @param resultingAdditionalCollateral in collateral terms\n     * @param maxResultingDebt in WETH terms. While it is unlikely that the\n     * exchange rate changes from when a transaction is submitted versus when it\n     * is executed, it is still possible so we want to allow for a bound here,\n     * even though it doesn't pose the same level of threat as slippage.\n     */\n    function flashLeverageCollateral(\n        uint256 initialDeposit,\n        uint256 resultingAdditionalCollateral,\n        uint256 maxResultingDebt\n    )\n        external\n    {\n        LST_TOKEN.safeTransferFrom(msg.sender, address(this), initialDeposit);\n\n        uint256 amountToLeverage = resultingAdditionalCollateral - initialDeposit; // in collateral terms\n\n        IERC20Balancer[] memory addresses = new IERC20Balancer[](1);\n        addresses[0] = IERC20Balancer(address(LST_TOKEN));\n\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = amountToLeverage;\n\n        if (amounts[0] == 0) {\n            // AmountToBorrow.IS_MAX because we don't want to create any new debt here\n            _depositAndBorrow(msg.sender, address(this), resultingAdditionalCollateral, 0, AmountToBorrow.IS_MAX);\n            return;\n        }\n\n        uint256 wethRequiredForRepayment = _getEthAmountInForLstAmountOut(amountToLeverage);\n        if (wethRequiredForRepayment > maxResultingDebt) {\n            revert FlashloanRepaymentTooExpensive(wethRequiredForRepayment, maxResultingDebt);\n        }\n\n        // Prevents attackers from initiating flashloan and passing malicious data through callback\n        flashloanInitiated = 2;\n\n        VAULT.flashLoan(\n            IFlashLoanRecipient(address(this)),\n            addresses,\n            amounts,\n            abi.encode(msg.sender, initialDeposit, resultingAdditionalCollateral, maxResultingDebt)\n        );\n\n        flashloanInitiated = 1;\n    }\n\n    /**\n     * @notice Code assumes Balancer flashloans remain free\n     * @param initialDeposit in collateral terms\n     * @param resultingAdditionalCollateral in collateral terms\n     * @param maxResultingDebt in WETH terms. While it is unlikely that the\n     * exchange rate changes from when a transaction is submitted versus when it\n     * is executed, it is still possible so we want to allow for a bound here,\n     * even though it doesn't pose the same level of threat as slippage.\n     */\n    function flashLeverageWeth(\n        uint256 initialDeposit,\n        uint256 resultingAdditionalCollateral,\n        uint256 maxResultingDebt\n    )\n        external\n        payable\n    {\n        LST_TOKEN.safeTransferFrom(msg.sender, address(this), initialDeposit);\n\n        IERC20Balancer[] memory addresses = new IERC20Balancer[](1);\n        addresses[0] = IERC20Balancer(address(WETH));\n\n        uint256 amountLst = resultingAdditionalCollateral - initialDeposit; // in collateral terms\n        uint256 amountWethToFlashloan = _getEthAmountInForLstAmountOut(amountLst);\n\n        if (amountWethToFlashloan == 0) {\n            // AmountToBorrow.IS_MAX because we don't want to create any new debt here\n            _depositAndBorrow(msg.sender, address(this), resultingAdditionalCollateral, 0, AmountToBorrow.IS_MAX);\n            return;\n        }\n\n        // It is technically possible to accrue slight dust amounts more of debt\n        // than maxResultingDebt because you may need to borrow slightly more at\n        // the IonPool level to receieve the desired amount of WETH. This is\n        // because the IonPool will round in its favor and always gives out dust\n        // amounts less of WETH than the debt accrued to the position. However,\n        // this will always be bounded by the rate of the ilk at the time\n        // divided by RAY and will NEVER be subject to slippage, which is what\n        // we really want to protect against.\n        if (amountWethToFlashloan > maxResultingDebt) {\n            revert FlashloanRepaymentTooExpensive(amountWethToFlashloan, maxResultingDebt);\n        }\n\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = amountWethToFlashloan;\n\n        flashloanInitiated = 2;\n\n        VAULT.flashLoan(\n            IFlashLoanRecipient(address(this)),\n            addresses,\n            amounts,\n            abi.encode(msg.sender, initialDeposit, resultingAdditionalCollateral, maxResultingDebt)\n        );\n\n        flashloanInitiated = 1;\n    }\n\n    /**\n     * @notice Code assumes Balancer flashloans remain free.\n     * @dev This function is intended to never be called directly. It should\n     * only be called by the Balancer VAULT during a flashloan initiated by this\n     * contract. This callback logic only handles the creation of leverage\n     * positions by minting. Since not all tokens have withdrawable liquidity\n     * via the LST protocol directly, deleverage through the protocol will need\n     * to be implemented in the inheriting contract.\n     *\n     * @param tokens Array of tokens flash loaned\n     * @param amounts amounts flash loaned\n     * @param userData arbitrary data passed from initiator of flash loan\n     */\n    function receiveFlashLoan(\n        IERC20Balancer[] memory tokens,\n        uint256[] memory amounts,\n        uint256[] memory,\n        bytes memory userData\n    )\n        external\n        override\n    {\n        if (tokens.length > 1) revert FlashLoanedTooManyTokens(tokens.length);\n        if (msg.sender != address(VAULT)) revert ReceiveCallerNotVault(msg.sender);\n        if (flashloanInitiated != 2) revert ExternalBalancerFlashloanNotAllowed();\n\n        IERC20Balancer token = tokens[0];\n        (address user, uint256 initialDeposit, uint256 resultingAdditionalCollateral, uint256 maxResultingDebt) =\n            abi.decode(userData, (address, uint256, uint256, uint256));\n\n        // Flashloaned WETH needs to be converted into collateral asset\n        if (address(token) == address(WETH)) {\n            uint256 collateralFromDeposit = _depositWethForLst(amounts[0]);\n\n            // Sanity checks\n            assert(collateralFromDeposit + initialDeposit == resultingAdditionalCollateral);\n            assert(collateralFromDeposit <= maxResultingDebt);\n\n            // AmountToBorrow.IS_MIN because we want to make sure enough is borrowed to cover flashloan\n            _depositAndBorrow(user, address(this), resultingAdditionalCollateral, amounts[0], AmountToBorrow.IS_MIN);\n\n            WETH.transfer(address(VAULT), amounts[0]);\n        } else {\n            if (address(LST_TOKEN) != address(token)) revert FlashloanedInvalidToken(address(token));\n\n            uint256 wethToBorrow = _getEthAmountInForLstAmountOut(amounts[0]);\n\n            // Sanity checks\n            assert(amounts[0] + initialDeposit == resultingAdditionalCollateral);\n            assert(wethToBorrow <= maxResultingDebt);\n\n            // AmountToBorrow.IS_MIN because we want to make sure enough is borrowed to cover flashloan\n            _depositAndBorrow(user, address(this), resultingAdditionalCollateral, wethToBorrow, AmountToBorrow.IS_MIN);\n\n            // Convert borrowed WETH back to collateral token\n            uint256 tokenAmountReceived = _depositWethForLst(wethToBorrow);\n\n            LST_TOKEN.safeTransfer(address(VAULT), tokenAmountReceived);\n        }\n    }\n\n    /**\n     * @dev Unwraps weth into eth and deposits into lst contract\n     * @param amountWeth to deposit\n     * @return amountLst received\n     */\n    function _depositWethForLst(uint256 amountWeth) internal virtual returns (uint256);\n\n    function _getEthAmountInForLstAmountOut(uint256 amountLst) internal view virtual returns (uint256);\n}"
    },
    {
      "filename": "src/flash/handlers/base/BalancerFlashloanDirectMintHandler.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IonHandlerBase } from \"./IonHandlerBase.sol\";\n\nimport { IVault, IERC20 as IERC20Balancer } from \"@balancer-labs/v2-interfaces/contracts/vault/IVault.sol\";\nimport { IFlashLoanRecipient } from \"@balancer-labs/v2-interfaces/contracts/vault/IFlashLoanRecipient.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nIVault constant VAULT = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n\n/**\n * @dev There are a couple things to consider here from a security perspective. The\n * first one is that the flashloan callback must only be callable from the\n * Balancer vault. This ensures that nobody can pass arbitrary data to the\n * callback. The second one is that the flashloan must only be initialized from\n * this contract. This is a trickier one to enforce since Balancer flashloans\n * are not EIP-3156 compliant and do not pass on the initiator through the\n * callback. To get around this, an inverse reentrancy lock of sorts is used.\n * The lock is set to 2 when a flashloan is initiated and set to 1 once the\n * callback execution terminates. If the lock is not 2 when the callback is\n * called, then the flashloan was not initiated by this contract and the tx is\n * reverted.\n *\n * This contract currently deposits directly into LST contract 1:1. It should be\n * noted that a more favorable trade could be possible via DEXs.\n */\nabstract contract BalancerFlashloanDirectMintHandler is IonHandlerBase, IFlashLoanRecipient {\n    using SafeERC20 for IERC20;\n\n    error ReceiveCallerNotVault(address unauthorizedCaller);\n    error FlashLoanedTooManyTokens(uint256 amountTokens);\n    error FlashloanedInvalidToken(address tokenAddress);\n    error ExternalBalancerFlashloanNotAllowed();\n\n    uint256 private flashloanInitiated = 1;\n\n    /**\n     * @notice Code assumes Balancer flashloans remain free\n     * @param initialDeposit in collateral terms\n     * @param resultingAdditionalCollateral in collateral terms\n     * @param maxResultingDebt in WETH terms. While it is unlikely that the\n     * exchange rate changes from when a transaction is submitted versus when it\n     * is executed, it is still possible so we want to allow for a bound here,\n     * even though it doesn't pose the same level of threat as slippage.\n     */\n    function flashLeverageCollateral(\n        uint256 initialDeposit,\n        uint256 resultingAdditionalCollateral,\n        uint256 maxResultingDebt\n    )\n        external\n    {\n        LST_TOKEN.safeTransferFrom(msg.sender, address(this), initialDeposit);\n\n        uint256 amountToLeverage = resultingAdditionalCollateral - initialDeposit; // in collateral terms\n\n        IERC20Balancer[] memory addresses = new IERC20Balancer[](1);\n        addresses[0] = IERC20Balancer(address(LST_TOKEN));\n\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = amountToLeverage;\n\n        if (amounts[0] == 0) {\n            // AmountToBorrow.IS_MAX because we don't want to create any new debt here\n            _depositAndBorrow(msg.sender, address(this), resultingAdditionalCollateral, 0, AmountToBorrow.IS_MAX);\n            return;\n        }\n\n        uint256 wethRequiredForRepayment = _getEthAmountInForLstAmountOut(amountToLeverage);\n        if (wethRequiredForRepayment > maxResultingDebt) {\n            revert FlashloanRepaymentTooExpensive(wethRequiredForRepayment, maxResultingDebt);\n        }\n\n        // Prevents attackers from initiating flashloan and passing malicious data through callback\n        flashloanInitiated = 2;\n\n        VAULT.flashLoan(\n            IFlashLoanRecipient(address(this)),\n            addresses,\n            amounts,\n            abi.encode(msg.sender, initialDeposit, resultingAdditionalCollateral, maxResultingDebt)\n        );\n\n        flashloanInitiated = 1;\n    }\n\n    /**\n     * @notice Code assumes Balancer flashloans remain free\n     * @param initialDeposit in collateral terms\n     * @param resultingAdditionalCollateral in collateral terms\n     * @param maxResultingDebt in WETH terms. While it is unlikely that the\n     * exchange rate changes from when a transaction is submitted versus when it\n     * is executed, it is still possible so we want to allow for a bound here,\n     * even though it doesn't pose the same level of threat as slippage.\n     */\n    function flashLeverageWeth(\n        uint256 initialDeposit,\n        uint256 resultingAdditionalCollateral,\n        uint256 maxResultingDebt\n    )\n        external\n        payable\n    {\n        LST_TOKEN.safeTransferFrom(msg.sender, address(this), initialDeposit);\n\n        IERC20Balancer[] memory addresses = new IERC20Balancer[](1);\n        addresses[0] = IERC20Balancer(address(WETH));\n\n        uint256 amountLst = resultingAdditionalCollateral - initialDeposit; // in collateral terms\n        uint256 amountWethToFlashloan = _getEthAmountInForLstAmountOut(amountLst);\n\n        if (amountWethToFlashloan == 0) {\n            // AmountToBorrow.IS_MAX because we don't want to create any new debt here\n            _depositAndBorrow(msg.sender, address(this), resultingAdditionalCollateral, 0, AmountToBorrow.IS_MAX);\n            return;\n        }\n\n        // It is technically possible to accrue slight dust amounts more of debt\n        // than maxResultingDebt because you may need to borrow slightly more at\n        // the IonPool level to receieve the desired amount of WETH. This is\n        // because the IonPool will round in its favor and always gives out dust\n        // amounts less of WETH than the debt accrued to the position. However,\n        // this will always be bounded by the rate of the ilk at the time\n        // divided by RAY and will NEVER be subject to slippage, which is what\n        // we really want to protect against.\n        if (amountWethToFlashloan > maxResultingDebt) {\n            revert FlashloanRepaymentTooExpensive(amountWethToFlashloan, maxResultingDebt);\n        }\n\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = amountWethToFlashloan;\n\n        flashloanInitiated = 2;\n\n        VAULT.flashLoan(\n            IFlashLoanRecipient(address(this)),\n            addresses,\n            amounts,\n            abi.encode(msg.sender, initialDeposit, resultingAdditionalCollateral, maxResultingDebt)\n        );\n\n        flashloanInitiated = 1;\n    }\n\n    /**\n     * @notice Code assumes Balancer flashloans remain free.\n     * @dev This function is intended to never be called directly. It should\n     * only be called by the Balancer VAULT during a flashloan initiated by this\n     * contract. This callback logic only handles the creation of leverage\n     * positions by minting. Since not all tokens have withdrawable liquidity\n     * via the LST protocol directly, deleverage through the protocol will need\n     * to be implemented in the inheriting contract.\n     *\n     * @param tokens Array of tokens flash loaned\n     * @param amounts amounts flash loaned\n     * @param userData arbitrary data passed from initiator of flash loan\n     */\n    function receiveFlashLoan(\n        IERC20Balancer[] memory tokens,\n        uint256[] memory amounts,\n        uint256[] memory,\n        bytes memory userData\n    )\n        external\n        override\n    {\n        if (tokens.length > 1) revert FlashLoanedTooManyTokens(tokens.length);\n        if (msg.sender != address(VAULT)) revert ReceiveCallerNotVault(msg.sender);\n        if (flashloanInitiated != 2) revert ExternalBalancerFlashloanNotAllowed();\n\n        IERC20Balancer token = tokens[0];\n        (address user, uint256 initialDeposit, uint256 resultingAdditionalCollateral, uint256 maxResultingDebt) =\n            abi.decode(userData, (address, uint256, uint256, uint256));\n\n        // Flashloaned WETH needs to be converted into collateral asset\n        if (address(token) == address(WETH)) {\n            uint256 collateralFromDeposit = _depositWethForLst(amounts[0]);\n\n            // Sanity checks\n            assert(collateralFromDeposit + initialDeposit == resultingAdditionalCollateral);\n            assert(collateralFromDeposit <= maxResultingDebt);\n\n            // AmountToBorrow.IS_MIN because we want to make sure enough is borrowed to cover flashloan\n            _depositAndBorrow(user, address(this), resultingAdditionalCollateral, amounts[0], AmountToBorrow.IS_MIN);\n\n            WETH.transfer(address(VAULT), amounts[0]);\n        } else {\n            if (address(LST_TOKEN) != address(token)) revert FlashloanedInvalidToken(address(token));\n\n            uint256 wethToBorrow = _getEthAmountInForLstAmountOut(amounts[0]);\n\n            // Sanity checks\n            assert(amounts[0] + initialDeposit == resultingAdditionalCollateral);\n            assert(wethToBorrow <= maxResultingDebt);\n\n            // AmountToBorrow.IS_MIN because we want to make sure enough is borrowed to cover flashloan\n            _depositAndBorrow(user, address(this), resultingAdditionalCollateral, wethToBorrow, AmountToBorrow.IS_MIN);\n\n            // Convert borrowed WETH back to collateral token\n            uint256 tokenAmountReceived = _depositWethForLst(wethToBorrow);\n\n            LST_TOKEN.safeTransfer(address(VAULT), tokenAmountReceived);\n        }\n    }\n\n    /**\n     * @dev Unwraps weth into eth and deposits into lst contract\n     * @param amountWeth to deposit\n     * @return amountLst received\n     */\n    function _depositWethForLst(uint256 amountWeth) internal virtual returns (uint256);\n\n    function _getEthAmountInForLstAmountOut(uint256 amountLst) internal view virtual returns (uint256);\n}"
    }
  ]
}