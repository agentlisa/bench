{
  "Title": "M-3: Adversary can overwrite function selector in _patchAmountAndCall due to inline assembly lack of overflow protection",
  "Content": "# Issue M-3: Adversary can overwrite function selector in _patchAmountAndCall due to inline assembly lack of overflow protection \n\nSource: https://github.com/sherlock-audit/2023-10-real-wagmi-judging/issues/82 \n\n## Found by \n0x52\n\nWhen using inline assembly, the standard [overflow/underflow protections do not apply](https://faizannehal.medium.com/how-solidity-0-8-protect-against-integer-underflow-overflow-and-how-they-can-still-happen-7be22c4ab92f). This allows an adversary to specify a swapAmountInDataIndex which after multiplication and addition allows them to overwrite the function selector. Using a created token in a UniV3 LP pair they can manufacture any value for swapAmountInDataValue.\n\n## Vulnerability Detail\n\n```The use of YUL or inline assembly in a solidity smart contract also makes integer overflow/ underflow possible even if the compiler version of solidity is 0.8. In YUL programming language, integer underflow & overflow is possible in the same way as Solidity and it does not check automatically for it as YUL is a low-level language that is mostly used for making the code more optimized, which does this by omitting many opcodes. Because of its low-level nature, YUL does not perform many security checks therefore it is recommended to use as little of it as possible in your smart contracts.``` \n\n[Source](https://faizannehal.medium.com/how-solidity-0-8-protect-against-integer-underflow-overflow-and-how-they-can-still-happen-7be22c4ab92f)\n\nInline assembly lacks overflow/underflow protections, which opens the possibility of this exploit.\n\n[ExternalCall.sol#L27-L38](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/main/wagmi-leverage/contracts/libraries/ExternalCall.sol#L27-L38)\n\n            if gt(swapAmountInDataValue, 0) {\n                mstore(add(add(ptr, 0x24), mul(swapAmountInDataIndex, 0x20)), swapAmountInDataValue)\n            }\n            success := call(\n                maxGas,\n                target,\n                0, //value\n                ptr, //Inputs are stored at location ptr\n                data.length,\n                0,\n                0\n            )\n\nIn the code above we see that `swapAmountInDataValue` is stored at `ptr + 36 (0x24) + swapAmountInDataIndex * 32 (0x20)`. The addition of 36 (0x24) in this scenario should prevent the function selector from being overwritten because of the extra 4 bytes (using 36 instead of 32). This is not the case though because `mul(swapAmountInDataIndex, 0x20)` can overflow since it is a uint256. This allows the attacker to target any part of the memory they choose by selectively overflowing to make it write to the desired position.\n\nAs shown above, overwriting the function selector is possible although most of the time this value would be a complete nonsense since swapAmountInDataValue is calculated elsewhere and isn't user supplied. This also has a work around. By creating their own token and adding it as LP to a UniV3 pool, swapAmountInDataValue can be carefully manipulated to any value. This allows the attacker to selectively overwrite the function selector with any value they chose. This bypasses function selectors restrictions and opens calls to dangerous functions. \n\n## Impact\n\nAttacker can bypass function restrictions and call dangerous/unintended functions\n\n## Code Snippet\n\n[ExternalCall.sol#L14-L47](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/main/wagmi-leverage/contracts/libraries/ExternalCall.sol#L14-L47)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nLimit `swapAmountInDataIndex` to a reasonable value such as uint128.max, preventing any overflow.\n\n\n\n## Discussion\n\n**fann95**\n\nI don't think this is a realistic scenario. You won't be able to get the offset to the function selector by overflowing the results of the multiplication or addition here. Using which index can you get the mload(0x40) ?\n\n**Czar102**\n\nI think overwriting the selector could be done if the `swapAmountInDataIndex` was `k * 2 ** 251 - 2` for any integer `k`. This is because `swapAmountInDataIndex * 0x20 =  k * 2 ** 251 * 2 ** 5 - 2 * 2 ** 5 = k * 2 ** 256 - 64 = - 64` mod `2 ** 256`. Changing memory at a pointer with such modification would collide with the selector at 4 least significant bytes and would write 28 bytes to previously allocated memory (memory corruption).\nMy recommendation would be to limit `swapAmountInDataIndex` to `div(data.length, 0x20)`. Then, one would be able to write `swapAmountInDataValue` at any correct index in the calldata or right behind the calldata, if that amount is not to show up in the function call.\n\n**fann95**\n\nFixed: https://github.com/RealWagmi/wagmi-leverage/commit/b568b21ae07587ee784bba2c25c7562207a4b027\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/118",
  "Code": [
    {
      "filename": "wagmi-leverage/contracts/libraries/ExternalCall.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nlibrary ExternalCall {\n    /**\n     * @dev Executes a call to the `target` address with the given `data`, gas limit `maxGas`, and optional patching of a swapAmount value.\n     * @param target The address of the contract or external function to call.\n     * @param data The calldata to include in the call.\n     * @param maxGas The maximum amount of gas to be used for the call. If set to 0, it uses the remaining gas.\n     * @param swapAmountInDataIndex The index at which to patch the `swapAmountInDataValue` in the calldata.\n     * @param swapAmountInDataValue The value to be patched at the specified index in the calldata. Can be 0 to skip patching.\n     * @return success A boolean indicating whether the call was successful.\n     */\n    function _patchAmountAndCall(\n        address target,\n        bytes calldata data,\n        uint256 maxGas,\n        uint256 swapAmountInDataIndex,\n        uint256 swapAmountInDataValue\n    ) internal returns (bool success) {\n        if (maxGas == 0) {\n            maxGas = gasleft();\n        }\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, data.offset, data.length)\n            if gt(swapAmountInDataValue, 0) {\n                mstore(add(add(ptr, 0x24), mul(swapAmountInDataIndex, 0x20)), swapAmountInDataValue)\n            }\n            success := call(\n                maxGas,\n                target,\n                0, //value\n                ptr, //Inputs are stored at location ptr\n                data.length,\n                0,\n                0\n            )\n\n            if and(not(success), and(gt(returndatasize(), 0), lt(returndatasize(), 256))) {\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n\n            mstore(0x40, add(ptr, data.length)) // Set storage pointer to empty space\n        }\n    }\n\n    /**\n     * @dev Reads the first 4 bytes from the given `swapData` parameter and returns them as a bytes4 value.\n     * @param swapData The calldata containing the data to read the first 4 bytes from.\n     * @return result The first 4 bytes of the `swapData` as a bytes4 value.\n     */\n    function _readFirstBytes4(bytes calldata swapData) internal pure returns (bytes4 result) {\n        // Read the bytes4 from array memory\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, swapData.offset, 32)\n            result := mload(ptr)\n            // Solidity does not require us to clean the trailing bytes.\n            // We do it anyway\n            result := and(\n                result,\n                0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\n            )\n        }\n        return result;\n    }\n}"
    },
    {
      "filename": "wagmi-leverage/contracts/libraries/ExternalCall.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nlibrary ExternalCall {\n    /**\n     * @dev Executes a call to the `target` address with the given `data`, gas limit `maxGas`, and optional patching of a swapAmount value.\n     * @param target The address of the contract or external function to call.\n     * @param data The calldata to include in the call.\n     * @param maxGas The maximum amount of gas to be used for the call. If set to 0, it uses the remaining gas.\n     * @param swapAmountInDataIndex The index at which to patch the `swapAmountInDataValue` in the calldata.\n     * @param swapAmountInDataValue The value to be patched at the specified index in the calldata. Can be 0 to skip patching.\n     * @return success A boolean indicating whether the call was successful.\n     */\n    function _patchAmountAndCall(\n        address target,\n        bytes calldata data,\n        uint256 maxGas,\n        uint256 swapAmountInDataIndex,\n        uint256 swapAmountInDataValue\n    ) internal returns (bool success) {\n        if (maxGas == 0) {\n            maxGas = gasleft();\n        }\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, data.offset, data.length)\n            if gt(swapAmountInDataValue, 0) {\n                mstore(add(add(ptr, 0x24), mul(swapAmountInDataIndex, 0x20)), swapAmountInDataValue)\n            }\n            success := call(\n                maxGas,\n                target,\n                0, //value\n                ptr, //Inputs are stored at location ptr\n                data.length,\n                0,\n                0\n            )\n\n            if and(not(success), and(gt(returndatasize(), 0), lt(returndatasize(), 256))) {\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n\n            mstore(0x40, add(ptr, data.length)) // Set storage pointer to empty space\n        }\n    }\n\n    /**\n     * @dev Reads the first 4 bytes from the given `swapData` parameter and returns them as a bytes4 value.\n     * @param swapData The calldata containing the data to read the first 4 bytes from.\n     * @return result The first 4 bytes of the `swapData` as a bytes4 value.\n     */\n    function _readFirstBytes4(bytes calldata swapData) internal pure returns (bytes4 result) {\n        // Read the bytes4 from array memory\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, swapData.offset, 32)\n            result := mload(ptr)\n            // Solidity does not require us to clean the trailing bytes.\n            // We do it anyway\n            result := and(\n                result,\n                0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\n            )\n        }\n        return result;\n    }\n}"
    }
  ]
}