{
  "Title": "[13] Add a Timelock to Critical Parameter Change",
  "Content": "\nIt is a good practice to give time for users to react and adjust to critical changes with a mandatory time window between them. The first step merely broadcasts to users that a particular change is coming, and the second step commits that change after a suitable waiting period. This allows users that do not accept the change to withdraw within the grace period. A timelock provides more guarantees and reduces the level of trust required, thus decreasing risk for users. It also indicates that the project is legitimate (less risk of a malicious Owner making any malicious or ulterior intention). Specifically, privileged roles could use front running to make malicious changes just ahead of incoming transactions, or purely accidental negative effects could occur due to the unfortunate timing of changes. \n\nConsider extending the timelock feature beyond contract ownership management to business critical functions. Here are some of the instances entailed:\n\nhttps://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/LooksRareAggregator.sol#L132\n\n```\n    function addFunction(address proxy, bytes4 selector) external onlyOwner {\n```\nhttps://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/LooksRareAggregator.sol#L143\n\n```\n    function removeFunction(address proxy, bytes4 selector) external onlyOwner {\n```\nhttps://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/LooksRareAggregator.sol#L153-L157\n\n```\n    function setFee(\n        address proxy,\n        uint256 bp,\n        address recipient\n    ) external onlyOwner {\n```\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-11-looksrare",
  "Code": [
    {
      "filename": "contracts/LooksRareAggregator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"./ReentrancyGuard.sol\";\nimport {LowLevelERC20Approve} from \"./lowLevelCallers/LowLevelERC20Approve.sol\";\nimport {LowLevelERC721Transfer} from \"./lowLevelCallers/LowLevelERC721Transfer.sol\";\nimport {LowLevelERC1155Transfer} from \"./lowLevelCallers/LowLevelERC1155Transfer.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport {LooksRareProxy} from \"./proxies/LooksRareProxy.sol\";\nimport {BasicOrder, TokenTransfer} from \"./libraries/OrderStructs.sol\";\nimport {TokenRescuer} from \"./TokenRescuer.sol\";\nimport {TokenReceiver} from \"./TokenReceiver.sol\";\nimport {ILooksRareAggregator} from \"./interfaces/ILooksRareAggregator.sol\";\nimport {BasicOrder, FeeData, TokenTransfer} from \"./libraries/OrderStructs.sol\";\nimport {LooksRareProxy} from \"./proxies/LooksRareProxy.sol\";\nimport {TokenReceiver} from \"./TokenReceiver.sol\";\nimport {TokenRescuer} from \"./TokenRescuer.sol\";\n\n/**\n * @title LooksRareAggregator\n * @notice This contract allows NFT sweepers to buy NFTs from different marketplaces\n *         by passing high-level structs + low-level bytes as calldata.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract LooksRareAggregator is\n    ILooksRareAggregator,\n    TokenRescuer,\n    TokenReceiver,\n    ReentrancyGuard,\n    LowLevelERC20Approve,\n    LowLevelERC721Transfer,\n    LowLevelERC1155Transfer\n{\n    /**\n     * @notice Transactions that only involve ETH orders should be submitted to this contract\n     *         directly. Transactions that involve ERC20 orders should be submitted to the contract\n     *         ERC20EnabledLooksRareAggregator and it will call this contract's execution function.\n     *         The purpose is to prevent a malicious proxy from stealing users' ERC20 tokens if\n     *         this contract's ownership is compromised. By not providing any allowances to this\n     *         aggregator, even if a malicious proxy is added, it cannot call\n     *         token.transferFrom(victim, attacker, amount) inside the proxy within the context of the\n     *         aggregator.\n     */\n    address public erc20EnabledLooksRareAggregator;\n    mapping(address => mapping(bytes4 => bool)) private _proxyFunctionSelectors;\n    mapping(address => FeeData) private _proxyFeeData;\n\n    /**\n     * @inheritdoc ILooksRareAggregator\n     */\n    function execute(\n        TokenTransfer[] calldata tokenTransfers,\n        TradeData[] calldata tradeData,\n        address originator,\n        address recipient,\n        bool isAtomic\n    ) external payable nonReentrant {\n        if (recipient == address(0)) revert ZeroAddress();\n        uint256 tradeDataLength = tradeData.length;\n        if (tradeDataLength == 0) revert InvalidOrderLength();\n\n        uint256 tokenTransfersLength = tokenTransfers.length;\n        if (tokenTransfersLength == 0) {\n            originator = msg.sender;\n        } else if (msg.sender != erc20EnabledLooksRareAggregator) {\n            revert UseERC20EnabledLooksRareAggregator();\n        }\n\n        for (uint256 i; i < tradeDataLength; ) {\n            TradeData calldata singleTradeData = tradeData[i];\n            if (!_proxyFunctionSelectors[singleTradeData.proxy][singleTradeData.selector]) revert InvalidFunction();\n\n            (bytes memory proxyCalldata, bool maxFeeBpViolated) = _encodeCalldataAndValidateFeeBp(\n                singleTradeData,\n                recipient,\n                isAtomic\n            );\n            if (maxFeeBpViolated) {\n                if (isAtomic) {\n                    revert FeeTooHigh();\n                } else {\n                    unchecked {\n                        ++i;\n                    }\n                    continue;\n                }\n            }\n            (bool success, bytes memory returnData) = singleTradeData.proxy.delegatecall(proxyCalldata);\n\n            if (!success) {\n                if (isAtomic) {\n                    if (returnData.length > 0) {\n                        assembly {\n                            let returnDataSize := mload(returnData)\n                            revert(add(32, returnData), returnDataSize)\n                        }\n                    } else {\n                        revert TradeExecutionFailed();\n                    }\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (tokenTransfersLength > 0) _returnERC20TokensIfAny(tokenTransfers, originator);\n        _returnETHIfAny(originator);\n\n        emit Sweep(originator);\n    }\n\n    /**\n     * @notice Enable making ERC20 trades by setting the ERC20 enabled LooksRare aggregator\n     * @dev Must be called by the current owner. It can only be set once to prevent\n     *      a malicious aggregator from being set in case of an ownership compromise.\n     * @param _erc20EnabledLooksRareAggregator The ERC20 enabled LooksRare aggregator's address\n     */\n    function setERC20EnabledLooksRareAggregator(address _erc20EnabledLooksRareAggregator) external onlyOwner {\n        if (erc20EnabledLooksRareAggregator != address(0)) revert AlreadySet();\n        erc20EnabledLooksRareAggregator = _erc20EnabledLooksRareAggregator;\n        emit ERC20EnabledLooksRareAggregatorSet();\n    }\n\n    /**\n     * @notice Enable calling the specified proxy's trade function\n     * @dev Must be called by the current owner\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     */\n    function addFunction(address proxy, bytes4 selector) external onlyOwner {\n        _proxyFunctionSelectors[proxy][selector] = true;\n        emit FunctionAdded(proxy, selector);\n    }\n\n    /**\n     * @notice Disable calling the specified proxy's trade function\n     * @dev Must be called by the current owner\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     */\n    function removeFunction(address proxy, bytes4 selector) external onlyOwner {\n        delete _proxyFunctionSelectors[proxy][selector];\n        emit FunctionRemoved(proxy, selector);\n    }\n\n    /**\n     * @param proxy Proxy to apply the fee to\n     * @param bp Fee basis point\n     * @param recipient Fee recipient\n     */\n    function setFee(\n        address proxy,\n        uint256 bp,\n        address recipient\n    ) external onlyOwner {\n        if (bp > 10000) revert FeeTooHigh();\n        _proxyFeeData[proxy].bp = bp;\n        _proxyFeeData[proxy].recipient = recipient;\n\n        emit FeeUpdated(proxy, bp, recipient);\n    }\n\n    /**\n     * @notice Approve marketplaces to transfer ERC20 tokens from the aggregator\n     * @param marketplace The marketplace address to approve\n     * @param currency The ERC20 token address to approve\n     * @param amount The amount of ERC20 token to approve\n     */\n    function approve(\n        address marketplace,\n        address currency,\n        uint256 amount\n    ) external onlyOwner {\n        _executeERC20Approve(currency, marketplace, amount);\n    }\n\n    /**\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     * @return Whether the marketplace proxy's function can be called from the aggregator\n     */\n    function supportsProxyFunction(address proxy, bytes4 selector) external view returns (bool) {\n        return _proxyFunctionSelectors[proxy][selector];\n    }\n\n    /**\n     * @notice Rescue any of the contract's trapped ERC721 tokens\n     * @dev Must be called by the current owner\n     * @param collection The address of the ERC721 token to rescue from the contract\n     * @param tokenId The token ID of the ERC721 token to rescue from the contract\n     * @param to Send the contract's specified ERC721 token ID to this address\n     */\n    function rescueERC721(\n        address collection,\n        address to,\n        uint256 tokenId\n    ) external onlyOwner {\n        _executeERC721TransferFrom(collection, address(this), to, tokenId);\n    }\n\n    /**\n     * @notice Rescue any of the contract's trapped ERC1155 tokens\n     * @dev Must be called by the current owner\n     * @param collection The address of the ERC1155 token to rescue from the contract\n     * @param tokenIds The token IDs of the ERC1155 token to rescue from the contract\n     * @param amounts The amount of each token ID to rescue\n     * @param to Send the contract's specified ERC1155 token ID to this address\n     */\n    function rescueERC1155(\n        address collection,\n        address to,\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts\n    ) external onlyOwner {\n        _executeERC1155SafeBatchTransferFrom(collection, address(this), to, tokenIds, amounts);\n    }\n\n    receive() external payable {}\n\n    function _encodeCalldataAndValidateFeeBp(\n        TradeData calldata singleTradeData,\n        address recipient,\n        bool isAtomic\n    ) private view returns (bytes memory proxyCalldata, bool maxFeeBpViolated) {\n        FeeData memory feeData = _proxyFeeData[singleTradeData.proxy];\n        maxFeeBpViolated = singleTradeData.maxFeeBp < feeData.bp;\n        proxyCalldata = abi.encodeWithSelector(\n            singleTradeData.selector,\n            singleTradeData.orders,\n            singleTradeData.ordersExtraData,\n            singleTradeData.extraData,\n            recipient,\n            isAtomic,\n            feeData.bp,\n            feeData.recipient\n        );\n    }\n\n    function _returnERC20TokensIfAny(TokenTransfer[] calldata tokenTransfers, address recipient) private {\n        uint256 tokenTransfersLength = tokenTransfers.length;\n        for (uint256 i; i < tokenTransfersLength; ) {\n            uint256 balance = IERC20(tokenTransfers[i].currency).balanceOf(address(this));\n            if (balance > 0) _executeERC20DirectTransfer(tokenTransfers[i].currency, recipient, balance);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/LooksRareAggregator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"./ReentrancyGuard.sol\";\nimport {LowLevelERC20Approve} from \"./lowLevelCallers/LowLevelERC20Approve.sol\";\nimport {LowLevelERC721Transfer} from \"./lowLevelCallers/LowLevelERC721Transfer.sol\";\nimport {LowLevelERC1155Transfer} from \"./lowLevelCallers/LowLevelERC1155Transfer.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport {LooksRareProxy} from \"./proxies/LooksRareProxy.sol\";\nimport {BasicOrder, TokenTransfer} from \"./libraries/OrderStructs.sol\";\nimport {TokenRescuer} from \"./TokenRescuer.sol\";\nimport {TokenReceiver} from \"./TokenReceiver.sol\";\nimport {ILooksRareAggregator} from \"./interfaces/ILooksRareAggregator.sol\";\nimport {BasicOrder, FeeData, TokenTransfer} from \"./libraries/OrderStructs.sol\";\nimport {LooksRareProxy} from \"./proxies/LooksRareProxy.sol\";\nimport {TokenReceiver} from \"./TokenReceiver.sol\";\nimport {TokenRescuer} from \"./TokenRescuer.sol\";\n\n/**\n * @title LooksRareAggregator\n * @notice This contract allows NFT sweepers to buy NFTs from different marketplaces\n *         by passing high-level structs + low-level bytes as calldata.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract LooksRareAggregator is\n    ILooksRareAggregator,\n    TokenRescuer,\n    TokenReceiver,\n    ReentrancyGuard,\n    LowLevelERC20Approve,\n    LowLevelERC721Transfer,\n    LowLevelERC1155Transfer\n{\n    /**\n     * @notice Transactions that only involve ETH orders should be submitted to this contract\n     *         directly. Transactions that involve ERC20 orders should be submitted to the contract\n     *         ERC20EnabledLooksRareAggregator and it will call this contract's execution function.\n     *         The purpose is to prevent a malicious proxy from stealing users' ERC20 tokens if\n     *         this contract's ownership is compromised. By not providing any allowances to this\n     *         aggregator, even if a malicious proxy is added, it cannot call\n     *         token.transferFrom(victim, attacker, amount) inside the proxy within the context of the\n     *         aggregator.\n     */\n    address public erc20EnabledLooksRareAggregator;\n    mapping(address => mapping(bytes4 => bool)) private _proxyFunctionSelectors;\n    mapping(address => FeeData) private _proxyFeeData;\n\n    /**\n     * @inheritdoc ILooksRareAggregator\n     */\n    function execute(\n        TokenTransfer[] calldata tokenTransfers,\n        TradeData[] calldata tradeData,\n        address originator,\n        address recipient,\n        bool isAtomic\n    ) external payable nonReentrant {\n        if (recipient == address(0)) revert ZeroAddress();\n        uint256 tradeDataLength = tradeData.length;\n        if (tradeDataLength == 0) revert InvalidOrderLength();\n\n        uint256 tokenTransfersLength = tokenTransfers.length;\n        if (tokenTransfersLength == 0) {\n            originator = msg.sender;\n        } else if (msg.sender != erc20EnabledLooksRareAggregator) {\n            revert UseERC20EnabledLooksRareAggregator();\n        }\n\n        for (uint256 i; i < tradeDataLength; ) {\n            TradeData calldata singleTradeData = tradeData[i];\n            if (!_proxyFunctionSelectors[singleTradeData.proxy][singleTradeData.selector]) revert InvalidFunction();\n\n            (bytes memory proxyCalldata, bool maxFeeBpViolated) = _encodeCalldataAndValidateFeeBp(\n                singleTradeData,\n                recipient,\n                isAtomic\n            );\n            if (maxFeeBpViolated) {\n                if (isAtomic) {\n                    revert FeeTooHigh();\n                } else {\n                    unchecked {\n                        ++i;\n                    }\n                    continue;\n                }\n            }\n            (bool success, bytes memory returnData) = singleTradeData.proxy.delegatecall(proxyCalldata);\n\n            if (!success) {\n                if (isAtomic) {\n                    if (returnData.length > 0) {\n                        assembly {\n                            let returnDataSize := mload(returnData)\n                            revert(add(32, returnData), returnDataSize)\n                        }\n                    } else {\n                        revert TradeExecutionFailed();\n                    }\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (tokenTransfersLength > 0) _returnERC20TokensIfAny(tokenTransfers, originator);\n        _returnETHIfAny(originator);\n\n        emit Sweep(originator);\n    }\n\n    /**\n     * @notice Enable making ERC20 trades by setting the ERC20 enabled LooksRare aggregator\n     * @dev Must be called by the current owner. It can only be set once to prevent\n     *      a malicious aggregator from being set in case of an ownership compromise.\n     * @param _erc20EnabledLooksRareAggregator The ERC20 enabled LooksRare aggregator's address\n     */\n    function setERC20EnabledLooksRareAggregator(address _erc20EnabledLooksRareAggregator) external onlyOwner {\n        if (erc20EnabledLooksRareAggregator != address(0)) revert AlreadySet();\n        erc20EnabledLooksRareAggregator = _erc20EnabledLooksRareAggregator;\n        emit ERC20EnabledLooksRareAggregatorSet();\n    }\n\n    /**\n     * @notice Enable calling the specified proxy's trade function\n     * @dev Must be called by the current owner\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     */\n    function addFunction(address proxy, bytes4 selector) external onlyOwner {\n        _proxyFunctionSelectors[proxy][selector] = true;\n        emit FunctionAdded(proxy, selector);\n    }\n\n    /**\n     * @notice Disable calling the specified proxy's trade function\n     * @dev Must be called by the current owner\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     */\n    function removeFunction(address proxy, bytes4 selector) external onlyOwner {\n        delete _proxyFunctionSelectors[proxy][selector];\n        emit FunctionRemoved(proxy, selector);\n    }\n\n    /**\n     * @param proxy Proxy to apply the fee to\n     * @param bp Fee basis point\n     * @param recipient Fee recipient\n     */\n    function setFee(\n        address proxy,\n        uint256 bp,\n        address recipient\n    ) external onlyOwner {\n        if (bp > 10000) revert FeeTooHigh();\n        _proxyFeeData[proxy].bp = bp;\n        _proxyFeeData[proxy].recipient = recipient;\n\n        emit FeeUpdated(proxy, bp, recipient);\n    }\n\n    /**\n     * @notice Approve marketplaces to transfer ERC20 tokens from the aggregator\n     * @param marketplace The marketplace address to approve\n     * @param currency The ERC20 token address to approve\n     * @param amount The amount of ERC20 token to approve\n     */\n    function approve(\n        address marketplace,\n        address currency,\n        uint256 amount\n    ) external onlyOwner {\n        _executeERC20Approve(currency, marketplace, amount);\n    }\n\n    /**\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     * @return Whether the marketplace proxy's function can be called from the aggregator\n     */\n    function supportsProxyFunction(address proxy, bytes4 selector) external view returns (bool) {\n        return _proxyFunctionSelectors[proxy][selector];\n    }\n\n    /**\n     * @notice Rescue any of the contract's trapped ERC721 tokens\n     * @dev Must be called by the current owner\n     * @param collection The address of the ERC721 token to rescue from the contract\n     * @param tokenId The token ID of the ERC721 token to rescue from the contract\n     * @param to Send the contract's specified ERC721 token ID to this address\n     */\n    function rescueERC721(\n        address collection,\n        address to,\n        uint256 tokenId\n    ) external onlyOwner {\n        _executeERC721TransferFrom(collection, address(this), to, tokenId);\n    }\n\n    /**\n     * @notice Rescue any of the contract's trapped ERC1155 tokens\n     * @dev Must be called by the current owner\n     * @param collection The address of the ERC1155 token to rescue from the contract\n     * @param tokenIds The token IDs of the ERC1155 token to rescue from the contract\n     * @param amounts The amount of each token ID to rescue\n     * @param to Send the contract's specified ERC1155 token ID to this address\n     */\n    function rescueERC1155(\n        address collection,\n        address to,\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts\n    ) external onlyOwner {\n        _executeERC1155SafeBatchTransferFrom(collection, address(this), to, tokenIds, amounts);\n    }\n\n    receive() external payable {}\n\n    function _encodeCalldataAndValidateFeeBp(\n        TradeData calldata singleTradeData,\n        address recipient,\n        bool isAtomic\n    ) private view returns (bytes memory proxyCalldata, bool maxFeeBpViolated) {\n        FeeData memory feeData = _proxyFeeData[singleTradeData.proxy];\n        maxFeeBpViolated = singleTradeData.maxFeeBp < feeData.bp;\n        proxyCalldata = abi.encodeWithSelector(\n            singleTradeData.selector,\n            singleTradeData.orders,\n            singleTradeData.ordersExtraData,\n            singleTradeData.extraData,\n            recipient,\n            isAtomic,\n            feeData.bp,\n            feeData.recipient\n        );\n    }\n\n    function _returnERC20TokensIfAny(TokenTransfer[] calldata tokenTransfers, address recipient) private {\n        uint256 tokenTransfersLength = tokenTransfers.length;\n        for (uint256 i; i < tokenTransfersLength; ) {\n            uint256 balance = IERC20(tokenTransfers[i].currency).balanceOf(address(this));\n            if (balance > 0) _executeERC20DirectTransfer(tokenTransfers[i].currency, recipient, balance);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/LooksRareAggregator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"./ReentrancyGuard.sol\";\nimport {LowLevelERC20Approve} from \"./lowLevelCallers/LowLevelERC20Approve.sol\";\nimport {LowLevelERC721Transfer} from \"./lowLevelCallers/LowLevelERC721Transfer.sol\";\nimport {LowLevelERC1155Transfer} from \"./lowLevelCallers/LowLevelERC1155Transfer.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport {LooksRareProxy} from \"./proxies/LooksRareProxy.sol\";\nimport {BasicOrder, TokenTransfer} from \"./libraries/OrderStructs.sol\";\nimport {TokenRescuer} from \"./TokenRescuer.sol\";\nimport {TokenReceiver} from \"./TokenReceiver.sol\";\nimport {ILooksRareAggregator} from \"./interfaces/ILooksRareAggregator.sol\";\nimport {BasicOrder, FeeData, TokenTransfer} from \"./libraries/OrderStructs.sol\";\nimport {LooksRareProxy} from \"./proxies/LooksRareProxy.sol\";\nimport {TokenReceiver} from \"./TokenReceiver.sol\";\nimport {TokenRescuer} from \"./TokenRescuer.sol\";\n\n/**\n * @title LooksRareAggregator\n * @notice This contract allows NFT sweepers to buy NFTs from different marketplaces\n *         by passing high-level structs + low-level bytes as calldata.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract LooksRareAggregator is\n    ILooksRareAggregator,\n    TokenRescuer,\n    TokenReceiver,\n    ReentrancyGuard,\n    LowLevelERC20Approve,\n    LowLevelERC721Transfer,\n    LowLevelERC1155Transfer\n{\n    /**\n     * @notice Transactions that only involve ETH orders should be submitted to this contract\n     *         directly. Transactions that involve ERC20 orders should be submitted to the contract\n     *         ERC20EnabledLooksRareAggregator and it will call this contract's execution function.\n     *         The purpose is to prevent a malicious proxy from stealing users' ERC20 tokens if\n     *         this contract's ownership is compromised. By not providing any allowances to this\n     *         aggregator, even if a malicious proxy is added, it cannot call\n     *         token.transferFrom(victim, attacker, amount) inside the proxy within the context of the\n     *         aggregator.\n     */\n    address public erc20EnabledLooksRareAggregator;\n    mapping(address => mapping(bytes4 => bool)) private _proxyFunctionSelectors;\n    mapping(address => FeeData) private _proxyFeeData;\n\n    /**\n     * @inheritdoc ILooksRareAggregator\n     */\n    function execute(\n        TokenTransfer[] calldata tokenTransfers,\n        TradeData[] calldata tradeData,\n        address originator,\n        address recipient,\n        bool isAtomic\n    ) external payable nonReentrant {\n        if (recipient == address(0)) revert ZeroAddress();\n        uint256 tradeDataLength = tradeData.length;\n        if (tradeDataLength == 0) revert InvalidOrderLength();\n\n        uint256 tokenTransfersLength = tokenTransfers.length;\n        if (tokenTransfersLength == 0) {\n            originator = msg.sender;\n        } else if (msg.sender != erc20EnabledLooksRareAggregator) {\n            revert UseERC20EnabledLooksRareAggregator();\n        }\n\n        for (uint256 i; i < tradeDataLength; ) {\n            TradeData calldata singleTradeData = tradeData[i];\n            if (!_proxyFunctionSelectors[singleTradeData.proxy][singleTradeData.selector]) revert InvalidFunction();\n\n            (bytes memory proxyCalldata, bool maxFeeBpViolated) = _encodeCalldataAndValidateFeeBp(\n                singleTradeData,\n                recipient,\n                isAtomic\n            );\n            if (maxFeeBpViolated) {\n                if (isAtomic) {\n                    revert FeeTooHigh();\n                } else {\n                    unchecked {\n                        ++i;\n                    }\n                    continue;\n                }\n            }\n            (bool success, bytes memory returnData) = singleTradeData.proxy.delegatecall(proxyCalldata);\n\n            if (!success) {\n                if (isAtomic) {\n                    if (returnData.length > 0) {\n                        assembly {\n                            let returnDataSize := mload(returnData)\n                            revert(add(32, returnData), returnDataSize)\n                        }\n                    } else {\n                        revert TradeExecutionFailed();\n                    }\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (tokenTransfersLength > 0) _returnERC20TokensIfAny(tokenTransfers, originator);\n        _returnETHIfAny(originator);\n\n        emit Sweep(originator);\n    }\n\n    /**\n     * @notice Enable making ERC20 trades by setting the ERC20 enabled LooksRare aggregator\n     * @dev Must be called by the current owner. It can only be set once to prevent\n     *      a malicious aggregator from being set in case of an ownership compromise.\n     * @param _erc20EnabledLooksRareAggregator The ERC20 enabled LooksRare aggregator's address\n     */\n    function setERC20EnabledLooksRareAggregator(address _erc20EnabledLooksRareAggregator) external onlyOwner {\n        if (erc20EnabledLooksRareAggregator != address(0)) revert AlreadySet();\n        erc20EnabledLooksRareAggregator = _erc20EnabledLooksRareAggregator;\n        emit ERC20EnabledLooksRareAggregatorSet();\n    }\n\n    /**\n     * @notice Enable calling the specified proxy's trade function\n     * @dev Must be called by the current owner\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     */\n    function addFunction(address proxy, bytes4 selector) external onlyOwner {\n        _proxyFunctionSelectors[proxy][selector] = true;\n        emit FunctionAdded(proxy, selector);\n    }\n\n    /**\n     * @notice Disable calling the specified proxy's trade function\n     * @dev Must be called by the current owner\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     */\n    function removeFunction(address proxy, bytes4 selector) external onlyOwner {\n        delete _proxyFunctionSelectors[proxy][selector];\n        emit FunctionRemoved(proxy, selector);\n    }\n\n    /**\n     * @param proxy Proxy to apply the fee to\n     * @param bp Fee basis point\n     * @param recipient Fee recipient\n     */\n    function setFee(\n        address proxy,\n        uint256 bp,\n        address recipient\n    ) external onlyOwner {\n        if (bp > 10000) revert FeeTooHigh();\n        _proxyFeeData[proxy].bp = bp;\n        _proxyFeeData[proxy].recipient = recipient;\n\n        emit FeeUpdated(proxy, bp, recipient);\n    }\n\n    /**\n     * @notice Approve marketplaces to transfer ERC20 tokens from the aggregator\n     * @param marketplace The marketplace address to approve\n     * @param currency The ERC20 token address to approve\n     * @param amount The amount of ERC20 token to approve\n     */\n    function approve(\n        address marketplace,\n        address currency,\n        uint256 amount\n    ) external onlyOwner {\n        _executeERC20Approve(currency, marketplace, amount);\n    }\n\n    /**\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     * @return Whether the marketplace proxy's function can be called from the aggregator\n     */\n    function supportsProxyFunction(address proxy, bytes4 selector) external view returns (bool) {\n        return _proxyFunctionSelectors[proxy][selector];\n    }\n\n    /**\n     * @notice Rescue any of the contract's trapped ERC721 tokens\n     * @dev Must be called by the current owner\n     * @param collection The address of the ERC721 token to rescue from the contract\n     * @param tokenId The token ID of the ERC721 token to rescue from the contract\n     * @param to Send the contract's specified ERC721 token ID to this address\n     */\n    function rescueERC721(\n        address collection,\n        address to,\n        uint256 tokenId\n    ) external onlyOwner {\n        _executeERC721TransferFrom(collection, address(this), to, tokenId);\n    }\n\n    /**\n     * @notice Rescue any of the contract's trapped ERC1155 tokens\n     * @dev Must be called by the current owner\n     * @param collection The address of the ERC1155 token to rescue from the contract\n     * @param tokenIds The token IDs of the ERC1155 token to rescue from the contract\n     * @param amounts The amount of each token ID to rescue\n     * @param to Send the contract's specified ERC1155 token ID to this address\n     */\n    function rescueERC1155(\n        address collection,\n        address to,\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts\n    ) external onlyOwner {\n        _executeERC1155SafeBatchTransferFrom(collection, address(this), to, tokenIds, amounts);\n    }\n\n    receive() external payable {}\n\n    function _encodeCalldataAndValidateFeeBp(\n        TradeData calldata singleTradeData,\n        address recipient,\n        bool isAtomic\n    ) private view returns (bytes memory proxyCalldata, bool maxFeeBpViolated) {\n        FeeData memory feeData = _proxyFeeData[singleTradeData.proxy];\n        maxFeeBpViolated = singleTradeData.maxFeeBp < feeData.bp;\n        proxyCalldata = abi.encodeWithSelector(\n            singleTradeData.selector,\n            singleTradeData.orders,\n            singleTradeData.ordersExtraData,\n            singleTradeData.extraData,\n            recipient,\n            isAtomic,\n            feeData.bp,\n            feeData.recipient\n        );\n    }\n\n    function _returnERC20TokensIfAny(TokenTransfer[] calldata tokenTransfers, address recipient) private {\n        uint256 tokenTransfersLength = tokenTransfers.length;\n        for (uint256 i; i < tokenTransfersLength; ) {\n            uint256 balance = IERC20(tokenTransfers[i].currency).balanceOf(address(this));\n            if (balance > 0) _executeERC20DirectTransfer(tokenTransfers[i].currency, recipient, balance);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    }
  ]
}