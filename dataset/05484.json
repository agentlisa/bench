{
  "Title": "[M-02] Lack of slippage control on `LRTDepositPool.depositAsset`",
  "Content": "\nThe [depositAsset](https://github.com/code-423n4/2023-11-kelp/blob/c5fdc2e62c5e1d78769f44d6e34a6fb9e40c00f0/src/LRTDepositPool.sol#L119C14-L119C26) function of the [LRTDepositPool](https://github.com/code-423n4/2023-11-kelp/blob/c5fdc2e62c5e1d78769f44d6e34a6fb9e40c00f0/src/LRTDepositPool.sol#L19C10-L19C24) contract, enables users to deposit assets into the protocol, getting [RSETH](https://github.com/code-423n4/2023-11-kelp/blob/c5fdc2e62c5e1d78769f44d6e34a6fb9e40c00f0/src/RSETH.sol#L14C10-L14C15) tokens in return. The function doesn't have any type of slippage control; this is relevant in the context of the [depositAsset](https://github.com/code-423n4/2023-11-kelp/blob/c5fdc2e62c5e1d78769f44d6e34a6fb9e40c00f0/src/LRTDepositPool.sol#L119C14-L119C26) function, since the amount of tokens received by the user is determined by an interaction with an oracle, meaning that the amount received in return may vary indefinitely while the request is waiting to be executed.\n\n*Also the users will have no defense against price manipulations attacks, if they where to be found after the protocol's deployment.*\n\n### Proof of Concept\n\nAs can be observed by looking at its parameters and implementation, the [depositAsset](https://github.com/code-423n4/2023-11-kelp/blob/c5fdc2e62c5e1d78769f44d6e34a6fb9e40c00f0/src/LRTDepositPool.sol#L119C14-L119C26) function of the [LRTDepositPool](https://github.com/code-423n4/2023-11-kelp/blob/c5fdc2e62c5e1d78769f44d6e34a6fb9e40c00f0/src/LRTDepositPool.sol#L19C10-L19C24) contract, doesn't have any type of slippage protection:\n\n        function depositAsset(\n            address asset,\n            uint256 depositAmount\n        )\n            external\n            whenNotPaused\n            nonReentrant\n            onlySupportedAsset(asset)\n        {\n            // checks\n            if (depositAmount == 0) {\n                revert InvalidAmount();\n            }\n            if (depositAmount > getAssetCurrentLimit(asset)) {\n                revert MaximumDepositLimitReached();\n            }\n\n            if (!IERC20(asset).transferFrom(msg.sender, address(this), depositAmount)) {\n                revert TokenTransferFailed();\n            }\n\n            // interactions\n            uint256 rsethAmountMinted = _mintRsETH(asset, depositAmount);\n\n            emit AssetDeposit(asset, depositAmount, rsethAmountMinted);\n        }\n\nMeaning that users have no control over how many [RSETH](https://github.com/code-423n4/2023-11-kelp/blob/c5fdc2e62c5e1d78769f44d6e34a6fb9e40c00f0/src/RSETH.sol#L14C10-L14C15) tokens they will get in return for depositing in the contract.\n\nThe amount of tokens to be minted, with respect to the deposited amount, is determined by the [getRsETHAmountToMint](https://github.com/code-423n4/2023-11-kelp/blob/c5fdc2e62c5e1d78769f44d6e34a6fb9e40c00f0/src/LRTDepositPool.sol#L95) function of the same contract (inside of [\\_mintRsETH](https://github.com/code-423n4/2023-11-kelp/blob/c5fdc2e62c5e1d78769f44d6e34a6fb9e40c00f0/src/LRTDepositPool.sol#L151)):\n\n        function getRsETHAmountToMint(\n            address asset,\n            uint256 amount\n        )\n            public\n            view\n            override\n            returns (uint256 rsethAmountToMint)\n        {\n            // setup oracle contract\n            address lrtOracleAddress = lrtConfig.getContract(LRTConstants.LRT_ORACLE);\n            ILRTOracle lrtOracle = ILRTOracle(lrtOracleAddress);\n\n            // calculate rseth amount to mint based on asset amount and asset exchange rate\n            rsethAmountToMint = (amount * lrtOracle.getAssetPrice(asset)) / lrtOracle.getRSETHPrice();\n        }\n\nAs can be observed, this function uses two oracle interactions to determine how many tokens to mint, [getAssetPrice](https://github.com/code-423n4/2023-11-kelp/blob/c5fdc2e62c5e1d78769f44d6e34a6fb9e40c00f0/src/LRTOracle.sol#L45) and [getRSETHPrice](https://github.com/code-423n4/2023-11-kelp/blob/c5fdc2e62c5e1d78769f44d6e34a6fb9e40c00f0/src/LRTOracle.sol#L52) (with [getRSETHPrice](https://github.com/code-423n4/2023-11-kelp/blob/c5fdc2e62c5e1d78769f44d6e34a6fb9e40c00f0/src/LRTOracle.sol#L52) internally calling [getAssetPrice](https://github.com/code-423n4/2023-11-kelp/blob/c5fdc2e62c5e1d78769f44d6e34a6fb9e40c00f0/src/LRTOracle.sol#L45) as well).\n\nThe [getAssetPrice](https://github.com/code-423n4/2023-11-kelp/blob/c5fdc2e62c5e1d78769f44d6e34a6fb9e40c00f0/src/LRTOracle.sol#L45) function queries the external oracle for the asset price:\n\n        function getAssetPrice(address asset) public view onlySupportedAsset(asset) returns (uint256) {\n            return IPriceFetcher(assetPriceOracle[asset]).getAssetPrice(asset);\n        }\n\nMeaning that the user has no way to predict how many [RSETH](https://github.com/code-423n4/2023-11-kelp/blob/c5fdc2e62c5e1d78769f44d6e34a6fb9e40c00f0/src/RSETH.sol#L14C10-L14C15) they will get back at the moment of minting, as the price could be updated while the request is in the mempool.\n\nHere is a very simple foundry script that shows that an oracle price modification, can largely impact the amount of tokens received in return by the user (implying that the [depositAsset](https://github.com/code-423n4/2023-11-kelp/blob/c5fdc2e62c5e1d78769f44d6e34a6fb9e40c00f0/src/LRTDepositPool.sol#L119C14-L119C26) function has no protection against it).\n\n<details>\n\nPlace it in the `test` folder to preserve dependencies:\n\n    // SPDX-License-Identifier: UNLICENSED\n\n    pragma solidity 0.8.21;\n\n    import { BaseTest } from \"./BaseTest.t.sol\";\n    import { LRTDepositPool } from \"src/LRTDepositPool.sol\";\n    import { RSETHTest, ILRTConfig, UtilLib, LRTConstants } from \"./RSETHTest.t.sol\";\n    import { ILRTDepositPool } from \"src/interfaces/ILRTDepositPool.sol\";\n\n    import { TransparentUpgradeableProxy } from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n    import { ProxyAdmin } from \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\n\n    import \"forge-std/console.sol\";\n\n    contract LRTOracleMock {\n\n        uint256 assetPrice = 1e18;\n\n        function setAssetPrice(uint256 newPrice) external {\n            assetPrice = newPrice;\n        }\n\n        function getAssetPrice(address) external view returns (uint256) {\n            return assetPrice;\n        }\n\n        function getRSETHPrice() external pure returns (uint256) {\n            return 1e18;\n        }\n    }\n\n    contract MockNodeDelegator {\n        function getAssetBalance(address) external pure returns (uint256) {\n            return 1e18;\n        }\n    }\n\n    contract LRTDepositPoolTest is BaseTest, RSETHTest {\n        LRTDepositPool public lrtDepositPool;\n        LRTOracleMock public mockOracle;\n\n        function setUp() public virtual override(RSETHTest, BaseTest) {\n            super.setUp();\n\n            // deploy LRTDepositPool\n            ProxyAdmin proxyAdmin = new ProxyAdmin();\n            LRTDepositPool contractImpl = new LRTDepositPool();\n            TransparentUpgradeableProxy contractProxy = new TransparentUpgradeableProxy(\n                address(contractImpl),\n                address(proxyAdmin),\n                \"\"\n            );\n\n            lrtDepositPool = LRTDepositPool(address(contractProxy));\n            mockOracle = new LRTOracleMock();\n\n            // initialize RSETH. LRTCOnfig is already initialized in RSETHTest\n            rseth.initialize(address(admin), address(lrtConfig));\n            vm.startPrank(admin);\n            // add rsETH to LRT config\n            lrtConfig.setRSETH(address(rseth));\n            // add oracle to LRT config\n            lrtConfig.setContract(LRTConstants.LRT_ORACLE, address(mockOracle));\n\n            // add minter role for rseth to lrtDepositPool\n            rseth.grantRole(rseth.MINTER_ROLE(), address(lrtDepositPool));\n\n            vm.stopPrank();\n        }\n    }\n\n    contract LRTDepositPoolDepositAsset is LRTDepositPoolTest {\n        address public rETHAddress;\n\n        function setUp() public override {\n            super.setUp();\n\n            // initialize LRTDepositPool\n            lrtDepositPool.initialize(address(lrtConfig));\n\n            rETHAddress = address(rETH);\n\n            // add manager role within LRTConfig\n            vm.startPrank(admin);\n            lrtConfig.grantRole(LRTConstants.MANAGER, manager);\n            vm.stopPrank();\n        }\n\n\n        function test_OracleCanModifyAssetMinted() external {\n            \n            vm.prank(alice);\n            rETH.approve(address(lrtDepositPool), 2 ether);\n            vm.prank(bob);\n            rETH.approve(address(lrtDepositPool), 2 ether); \n\n            uint256 aliceDepositTime = block.timestamp;\n            vm.prank(alice);\n            lrtDepositPool.depositAsset(rETHAddress, 2 ether);\n\n            mockOracle.setAssetPrice(1e17);\n\n            uint256 bobDepositTime = block.timestamp;\n            vm.prank(bob);\n            lrtDepositPool.depositAsset(rETHAddress, 2 ether);\n\n            uint256 aliceBalanceAfter = rseth.balanceOf(address(alice));\n            uint256 bobBalanceAfter = rseth.balanceOf(address(bob));\n            \n            console.log(aliceBalanceAfter);\n            console.log(bobBalanceAfter);    \n\n            console.log(aliceDepositTime);\n            console.log(bobDepositTime); \n\n            assertEq(aliceDepositTime, bobDepositTime);\n            assertGt(aliceBalanceAfter, bobBalanceAfter);\n\n        }\n\n    }\n\n</details>\n\n### Recommended Mitigation Steps\n\nAn additional parameter could be added to the [depositAsset](https://github.com/code-423n4/2023-11-kelp/blob/c5fdc2e62c5e1d78769f44d6e34a6fb9e40c00f0/src/LRTDepositPool.sol#L119C14-L119C26) function, to let users decide the minimum amount of tokens to be received, with a relative check after minting.\n\n**[gus (Kelp) confirmed](https://github.com/code-423n4/2023-11-kelp-findings/issues/148#issuecomment-1825369647)**\n\n**[manoj9april (Kelp) disagreed with severity and commented](https://github.com/code-423n4/2023-11-kelp-findings/issues/148#issuecomment-1837411885):**\n > Slippage control makes more sense in DEXes. But in staking protocols, where prices are mostly stable and users can reject if it txn takes longer time.<br>\n> But it is a useful recommendation.<br>\n> I think we can move it to QA.\n\n**[0xDjango (judge) commented](https://github.com/code-423n4/2023-11-kelp-findings/issues/148#issuecomment-1839011720):**\n > Sticking with medium. There is no protection for the user in the current implementation. `minShares` checks are commonly implemented in staking contracts.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-11-kelp",
  "Code": [
    {
      "filename": "src/LRTDepositPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport { UtilLib } from \"./utils/UtilLib.sol\";\nimport { LRTConstants } from \"./utils/LRTConstants.sol\";\n\nimport { LRTConfigRoleChecker, ILRTConfig } from \"./utils/LRTConfigRoleChecker.sol\";\nimport { IRSETH } from \"./interfaces/IRSETH.sol\";\nimport { ILRTOracle } from \"./interfaces/ILRTOracle.sol\";\nimport { INodeDelegator } from \"./interfaces/INodeDelegator.sol\";\nimport { ILRTDepositPool } from \"./interfaces/ILRTDepositPool.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @title LRTDepositPool - Deposit Pool Contract for LSTs\n/// @notice Handles LST asset deposits\ncontract LRTDepositPool is ILRTDepositPool, LRTConfigRoleChecker, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    uint256 public maxNodeDelegatorCount;\n\n    address[] public nodeDelegatorQueue;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract\n    /// @param lrtConfigAddr LRT config address\n    function initialize(address lrtConfigAddr) external initializer {\n        UtilLib.checkNonZeroAddress(lrtConfigAddr);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        maxNodeDelegatorCount = 10;\n        lrtConfig = ILRTConfig(lrtConfigAddr);\n        emit UpdatedLRTConfig(lrtConfigAddr);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            view functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice gets the total asset present in protocol\n    /// @param asset Asset address\n    /// @return totalAssetDeposit total asset present in protocol\n    function getTotalAssetDeposits(address asset) public view override returns (uint256 totalAssetDeposit) {\n        (uint256 assetLyingInDepositPool, uint256 assetLyingInNDCs, uint256 assetStakedInEigenLayer) =\n            getAssetDistributionData(asset);\n        return (assetLyingInDepositPool + assetLyingInNDCs + assetStakedInEigenLayer);\n    }\n\n    /// @notice gets the current limit of asset deposit\n    /// @param asset Asset address\n    /// @return currentLimit Current limit of asset deposit\n    function getAssetCurrentLimit(address asset) public view override returns (uint256) {\n        return lrtConfig.depositLimitByAsset(asset) - getTotalAssetDeposits(asset);\n    }\n\n    /// @dev get node delegator queue\n    /// @return nodeDelegatorQueue Array of node delegator contract addresses\n    function getNodeDelegatorQueue() external view override returns (address[] memory) {\n        return nodeDelegatorQueue;\n    }\n\n    /// @dev provides asset amount distribution data among depositPool, NDCs and eigenLayer\n    /// @param asset the asset to get the total amount of\n    /// @return assetLyingInDepositPool asset amount lying in this LRTDepositPool contract\n    /// @return assetLyingInNDCs asset amount sum lying in all NDC contract\n    /// @return assetStakedInEigenLayer asset amount staked in eigen layer through all NDCs\n    function getAssetDistributionData(address asset)\n        public\n        view\n        override\n        onlySupportedAsset(asset)\n        returns (uint256 assetLyingInDepositPool, uint256 assetLyingInNDCs, uint256 assetStakedInEigenLayer)\n    {\n        // Question: is here the right place to have this? Could it be in LRTConfig?\n        assetLyingInDepositPool = IERC20(asset).balanceOf(address(this));\n\n        uint256 ndcsCount = nodeDelegatorQueue.length;\n        for (uint256 i; i < ndcsCount;) {\n            assetLyingInNDCs += IERC20(asset).balanceOf(nodeDelegatorQueue[i]);\n            assetStakedInEigenLayer += INodeDelegator(nodeDelegatorQueue[i]).getAssetBalance(asset);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice View amount of rsETH to mint for given asset amount\n    /// @param asset Asset address\n    /// @param amount Asset amount\n    /// @return rsethAmountToMint Amount of rseth to mint\n    function getRsETHAmountToMint(\n        address asset,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (uint256 rsethAmountToMint)\n    {\n        // setup oracle contract\n        address lrtOracleAddress = lrtConfig.getContract(LRTConstants.LRT_ORACLE);\n        ILRTOracle lrtOracle = ILRTOracle(lrtOracleAddress);\n\n        // calculate rseth amount to mint based on asset amount and asset exchange rate\n        rsethAmountToMint = (amount * lrtOracle.getAssetPrice(asset)) / lrtOracle.getRSETHPrice();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            write functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice helps user stake LST to the protocol\n    /// @param asset LST asset address to stake\n    /// @param depositAmount LST asset amount to stake\n    function depositAsset(\n        address asset,\n        uint256 depositAmount\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        onlySupportedAsset(asset)\n    {\n        // checks\n        if (depositAmount == 0) {\n            revert InvalidAmount();\n        }\n        if (depositAmount > getAssetCurrentLimit(asset)) {\n            revert MaximumDepositLimitReached();\n        }\n\n        if (!IERC20(asset).transferFrom(msg.sender, address(this), depositAmount)) {\n            revert TokenTransferFailed();\n        }\n\n        // interactions\n        uint256 rsethAmountMinted = _mintRsETH(asset, depositAmount);\n\n        emit AssetDeposit(asset, depositAmount, rsethAmountMinted);\n    }\n\n    /// @dev private function to mint rseth. It calculates rseth amount to mint based on asset amount and asset exchange\n    /// rates from oracle\n    /// @param _asset Asset address\n    /// @param _amount Asset amount to mint rseth\n    /// @return rsethAmountToMint Amount of rseth minted\n    function _mintRsETH(address _asset, uint256 _amount) private returns (uint256 rsethAmountToMint) {\n        (rsethAmountToMint) = getRsETHAmountToMint(_asset, _amount);\n\n        address rsethToken = lrtConfig.rsETH();\n        // mint rseth for user\n        IRSETH(rsethToken).mint(msg.sender, rsethAmountToMint);\n    }\n\n    /// @notice add new node delegator contract addresses\n    /// @dev only callable by LRT manager\n    /// @param nodeDelegatorContracts Array of NodeDelegator contract addresses\n    function addNodeDelegatorContractToQueue(address[] calldata nodeDelegatorContracts) external onlyLRTAdmin {\n        uint256 length = nodeDelegatorContracts.length;\n        if (nodeDelegatorQueue.length + length > maxNodeDelegatorCount) {\n            revert MaximumNodeDelegatorCountReached();\n        }\n\n        for (uint256 i; i < length;) {\n            UtilLib.checkNonZeroAddress(nodeDelegatorContracts[i]);\n            nodeDelegatorQueue.push(nodeDelegatorContracts[i]);\n            emit NodeDelegatorAddedinQueue(nodeDelegatorContracts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice transfers asset lying in this DepositPool to node delegator contract\n    /// @dev only callable by LRT manager\n    /// @param ndcIndex Index of NodeDelegator contract address in nodeDelegatorQueue\n    /// @param asset Asset address\n    /// @param amount Asset amount to transfer\n    function transferAssetToNodeDelegator(\n        uint256 ndcIndex,\n        address asset,\n        uint256 amount\n    )\n        external\n        nonReentrant\n        onlyLRTManager\n        onlySupportedAsset(asset)\n    {\n        address nodeDelegator = nodeDelegatorQueue[ndcIndex];\n        if (!IERC20(asset).transfer(nodeDelegator, amount)) {\n            revert TokenTransferFailed();\n        }\n    }\n\n    /// @notice update max node delegator count\n    /// @dev only callable by LRT admin\n    /// @param maxNodeDelegatorCount_ Maximum count of node delegator\n    function updateMaxNodeDelegatorCount(uint256 maxNodeDelegatorCount_) external onlyLRTAdmin {\n        maxNodeDelegatorCount = maxNodeDelegatorCount_;\n        emit MaxNodeDelegatorCountUpdated(maxNodeDelegatorCount);\n    }\n\n    /// @dev Triggers stopped state. Contract must not be paused.\n    function pause() external onlyLRTManager {\n        _pause();\n    }\n\n    /// @dev Returns to normal state. Contract must be paused\n    function unpause() external onlyLRTAdmin {\n        _unpause();\n    }\n}"
    },
    {
      "filename": "src/LRTDepositPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport { UtilLib } from \"./utils/UtilLib.sol\";\nimport { LRTConstants } from \"./utils/LRTConstants.sol\";\n\nimport { LRTConfigRoleChecker, ILRTConfig } from \"./utils/LRTConfigRoleChecker.sol\";\nimport { IRSETH } from \"./interfaces/IRSETH.sol\";\nimport { ILRTOracle } from \"./interfaces/ILRTOracle.sol\";\nimport { INodeDelegator } from \"./interfaces/INodeDelegator.sol\";\nimport { ILRTDepositPool } from \"./interfaces/ILRTDepositPool.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @title LRTDepositPool - Deposit Pool Contract for LSTs\n/// @notice Handles LST asset deposits\ncontract LRTDepositPool is ILRTDepositPool, LRTConfigRoleChecker, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    uint256 public maxNodeDelegatorCount;\n\n    address[] public nodeDelegatorQueue;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract\n    /// @param lrtConfigAddr LRT config address\n    function initialize(address lrtConfigAddr) external initializer {\n        UtilLib.checkNonZeroAddress(lrtConfigAddr);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        maxNodeDelegatorCount = 10;\n        lrtConfig = ILRTConfig(lrtConfigAddr);\n        emit UpdatedLRTConfig(lrtConfigAddr);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            view functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice gets the total asset present in protocol\n    /// @param asset Asset address\n    /// @return totalAssetDeposit total asset present in protocol\n    function getTotalAssetDeposits(address asset) public view override returns (uint256 totalAssetDeposit) {\n        (uint256 assetLyingInDepositPool, uint256 assetLyingInNDCs, uint256 assetStakedInEigenLayer) =\n            getAssetDistributionData(asset);\n        return (assetLyingInDepositPool + assetLyingInNDCs + assetStakedInEigenLayer);\n    }\n\n    /// @notice gets the current limit of asset deposit\n    /// @param asset Asset address\n    /// @return currentLimit Current limit of asset deposit\n    function getAssetCurrentLimit(address asset) public view override returns (uint256) {\n        return lrtConfig.depositLimitByAsset(asset) - getTotalAssetDeposits(asset);\n    }\n\n    /// @dev get node delegator queue\n    /// @return nodeDelegatorQueue Array of node delegator contract addresses\n    function getNodeDelegatorQueue() external view override returns (address[] memory) {\n        return nodeDelegatorQueue;\n    }\n\n    /// @dev provides asset amount distribution data among depositPool, NDCs and eigenLayer\n    /// @param asset the asset to get the total amount of\n    /// @return assetLyingInDepositPool asset amount lying in this LRTDepositPool contract\n    /// @return assetLyingInNDCs asset amount sum lying in all NDC contract\n    /// @return assetStakedInEigenLayer asset amount staked in eigen layer through all NDCs\n    function getAssetDistributionData(address asset)\n        public\n        view\n        override\n        onlySupportedAsset(asset)\n        returns (uint256 assetLyingInDepositPool, uint256 assetLyingInNDCs, uint256 assetStakedInEigenLayer)\n    {\n        // Question: is here the right place to have this? Could it be in LRTConfig?\n        assetLyingInDepositPool = IERC20(asset).balanceOf(address(this));\n\n        uint256 ndcsCount = nodeDelegatorQueue.length;\n        for (uint256 i; i < ndcsCount;) {\n            assetLyingInNDCs += IERC20(asset).balanceOf(nodeDelegatorQueue[i]);\n            assetStakedInEigenLayer += INodeDelegator(nodeDelegatorQueue[i]).getAssetBalance(asset);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice View amount of rsETH to mint for given asset amount\n    /// @param asset Asset address\n    /// @param amount Asset amount\n    /// @return rsethAmountToMint Amount of rseth to mint\n    function getRsETHAmountToMint(\n        address asset,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (uint256 rsethAmountToMint)\n    {\n        // setup oracle contract\n        address lrtOracleAddress = lrtConfig.getContract(LRTConstants.LRT_ORACLE);\n        ILRTOracle lrtOracle = ILRTOracle(lrtOracleAddress);\n\n        // calculate rseth amount to mint based on asset amount and asset exchange rate\n        rsethAmountToMint = (amount * lrtOracle.getAssetPrice(asset)) / lrtOracle.getRSETHPrice();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            write functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice helps user stake LST to the protocol\n    /// @param asset LST asset address to stake\n    /// @param depositAmount LST asset amount to stake\n    function depositAsset(\n        address asset,\n        uint256 depositAmount\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        onlySupportedAsset(asset)\n    {\n        // checks\n        if (depositAmount == 0) {\n            revert InvalidAmount();\n        }\n        if (depositAmount > getAssetCurrentLimit(asset)) {\n            revert MaximumDepositLimitReached();\n        }\n\n        if (!IERC20(asset).transferFrom(msg.sender, address(this), depositAmount)) {\n            revert TokenTransferFailed();\n        }\n\n        // interactions\n        uint256 rsethAmountMinted = _mintRsETH(asset, depositAmount);\n\n        emit AssetDeposit(asset, depositAmount, rsethAmountMinted);\n    }\n\n    /// @dev private function to mint rseth. It calculates rseth amount to mint based on asset amount and asset exchange\n    /// rates from oracle\n    /// @param _asset Asset address\n    /// @param _amount Asset amount to mint rseth\n    /// @return rsethAmountToMint Amount of rseth minted\n    function _mintRsETH(address _asset, uint256 _amount) private returns (uint256 rsethAmountToMint) {\n        (rsethAmountToMint) = getRsETHAmountToMint(_asset, _amount);\n\n        address rsethToken = lrtConfig.rsETH();\n        // mint rseth for user\n        IRSETH(rsethToken).mint(msg.sender, rsethAmountToMint);\n    }\n\n    /// @notice add new node delegator contract addresses\n    /// @dev only callable by LRT manager\n    /// @param nodeDelegatorContracts Array of NodeDelegator contract addresses\n    function addNodeDelegatorContractToQueue(address[] calldata nodeDelegatorContracts) external onlyLRTAdmin {\n        uint256 length = nodeDelegatorContracts.length;\n        if (nodeDelegatorQueue.length + length > maxNodeDelegatorCount) {\n            revert MaximumNodeDelegatorCountReached();\n        }\n\n        for (uint256 i; i < length;) {\n            UtilLib.checkNonZeroAddress(nodeDelegatorContracts[i]);\n            nodeDelegatorQueue.push(nodeDelegatorContracts[i]);\n            emit NodeDelegatorAddedinQueue(nodeDelegatorContracts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice transfers asset lying in this DepositPool to node delegator contract\n    /// @dev only callable by LRT manager\n    /// @param ndcIndex Index of NodeDelegator contract address in nodeDelegatorQueue\n    /// @param asset Asset address\n    /// @param amount Asset amount to transfer\n    function transferAssetToNodeDelegator(\n        uint256 ndcIndex,\n        address asset,\n        uint256 amount\n    )\n        external\n        nonReentrant\n        onlyLRTManager\n        onlySupportedAsset(asset)\n    {\n        address nodeDelegator = nodeDelegatorQueue[ndcIndex];\n        if (!IERC20(asset).transfer(nodeDelegator, amount)) {\n            revert TokenTransferFailed();\n        }\n    }\n\n    /// @notice update max node delegator count\n    /// @dev only callable by LRT admin\n    /// @param maxNodeDelegatorCount_ Maximum count of node delegator\n    function updateMaxNodeDelegatorCount(uint256 maxNodeDelegatorCount_) external onlyLRTAdmin {\n        maxNodeDelegatorCount = maxNodeDelegatorCount_;\n        emit MaxNodeDelegatorCountUpdated(maxNodeDelegatorCount);\n    }\n\n    /// @dev Triggers stopped state. Contract must not be paused.\n    function pause() external onlyLRTManager {\n        _pause();\n    }\n\n    /// @dev Returns to normal state. Contract must be paused\n    function unpause() external onlyLRTAdmin {\n        _unpause();\n    }\n}"
    },
    {
      "filename": "src/RSETH.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport { UtilLib } from \"./utils/UtilLib.sol\";\nimport { LRTConfigRoleChecker, ILRTConfig } from \"./utils/LRTConfigRoleChecker.sol\";\n\nimport { ERC20Upgradeable, Initializable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { AccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\n/// @title rsETH token Contract\n/// @author Stader Labs\n/// @notice The ERC20 contract for the rsETH token\ncontract RSETH is\n    Initializable,\n    LRTConfigRoleChecker,\n    ERC20Upgradeable,\n    PausableUpgradeable,\n    AccessControlUpgradeable\n{\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract\n    /// @param admin Admin address\n    /// @param lrtConfigAddr LRT config address\n    function initialize(address admin, address lrtConfigAddr) external initializer {\n        UtilLib.checkNonZeroAddress(admin);\n        UtilLib.checkNonZeroAddress(lrtConfigAddr);\n\n        __ERC20_init(\"rsETH\", \"rsETH\");\n        __Pausable_init();\n        __AccessControl_init();\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        lrtConfig = ILRTConfig(lrtConfigAddr);\n        emit UpdatedLRTConfig(lrtConfigAddr);\n    }\n\n    /// @notice Mints rsETH when called by an authorized caller\n    /// @param to the account to mint to\n    /// @param amount the amount of rsETH to mint\n    function mint(address to, uint256 amount) external onlyRole(MINTER_ROLE) whenNotPaused {\n        _mint(to, amount);\n    }\n\n    /// @notice Burns rsETH when called by an authorized caller\n    /// @param account the account to burn from\n    /// @param amount the amount of rsETH to burn\n    function burnFrom(address account, uint256 amount) external onlyRole(BURNER_ROLE) whenNotPaused {\n        _burn(account, amount);\n    }\n\n    /// @dev Triggers stopped state.\n    /// @dev Only callable by LRT config manager. Contract must NOT be paused.\n    function pause() external onlyLRTManager {\n        _pause();\n    }\n\n    /// @notice Returns to normal state.\n    /// @dev Only callable by the rsETH admin. Contract must be paused\n    function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _unpause();\n    }\n\n    /// @notice Updates the LRT config contract\n    /// @dev only callable by the rsETH admin\n    /// @param _lrtConfig the new LRT config contract\n    function updateLRTConfig(address _lrtConfig) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        UtilLib.checkNonZeroAddress(_lrtConfig);\n        lrtConfig = ILRTConfig(_lrtConfig);\n        emit UpdatedLRTConfig(_lrtConfig);\n    }\n}"
    },
    {
      "filename": "src/LRTDepositPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport { UtilLib } from \"./utils/UtilLib.sol\";\nimport { LRTConstants } from \"./utils/LRTConstants.sol\";\n\nimport { LRTConfigRoleChecker, ILRTConfig } from \"./utils/LRTConfigRoleChecker.sol\";\nimport { IRSETH } from \"./interfaces/IRSETH.sol\";\nimport { ILRTOracle } from \"./interfaces/ILRTOracle.sol\";\nimport { INodeDelegator } from \"./interfaces/INodeDelegator.sol\";\nimport { ILRTDepositPool } from \"./interfaces/ILRTDepositPool.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @title LRTDepositPool - Deposit Pool Contract for LSTs\n/// @notice Handles LST asset deposits\ncontract LRTDepositPool is ILRTDepositPool, LRTConfigRoleChecker, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    uint256 public maxNodeDelegatorCount;\n\n    address[] public nodeDelegatorQueue;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract\n    /// @param lrtConfigAddr LRT config address\n    function initialize(address lrtConfigAddr) external initializer {\n        UtilLib.checkNonZeroAddress(lrtConfigAddr);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        maxNodeDelegatorCount = 10;\n        lrtConfig = ILRTConfig(lrtConfigAddr);\n        emit UpdatedLRTConfig(lrtConfigAddr);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            view functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice gets the total asset present in protocol\n    /// @param asset Asset address\n    /// @return totalAssetDeposit total asset present in protocol\n    function getTotalAssetDeposits(address asset) public view override returns (uint256 totalAssetDeposit) {\n        (uint256 assetLyingInDepositPool, uint256 assetLyingInNDCs, uint256 assetStakedInEigenLayer) =\n            getAssetDistributionData(asset);\n        return (assetLyingInDepositPool + assetLyingInNDCs + assetStakedInEigenLayer);\n    }\n\n    /// @notice gets the current limit of asset deposit\n    /// @param asset Asset address\n    /// @return currentLimit Current limit of asset deposit\n    function getAssetCurrentLimit(address asset) public view override returns (uint256) {\n        return lrtConfig.depositLimitByAsset(asset) - getTotalAssetDeposits(asset);\n    }\n\n    /// @dev get node delegator queue\n    /// @return nodeDelegatorQueue Array of node delegator contract addresses\n    function getNodeDelegatorQueue() external view override returns (address[] memory) {\n        return nodeDelegatorQueue;\n    }\n\n    /// @dev provides asset amount distribution data among depositPool, NDCs and eigenLayer\n    /// @param asset the asset to get the total amount of\n    /// @return assetLyingInDepositPool asset amount lying in this LRTDepositPool contract\n    /// @return assetLyingInNDCs asset amount sum lying in all NDC contract\n    /// @return assetStakedInEigenLayer asset amount staked in eigen layer through all NDCs\n    function getAssetDistributionData(address asset)\n        public\n        view\n        override\n        onlySupportedAsset(asset)\n        returns (uint256 assetLyingInDepositPool, uint256 assetLyingInNDCs, uint256 assetStakedInEigenLayer)\n    {\n        // Question: is here the right place to have this? Could it be in LRTConfig?\n        assetLyingInDepositPool = IERC20(asset).balanceOf(address(this));\n\n        uint256 ndcsCount = nodeDelegatorQueue.length;\n        for (uint256 i; i < ndcsCount;) {\n            assetLyingInNDCs += IERC20(asset).balanceOf(nodeDelegatorQueue[i]);\n            assetStakedInEigenLayer += INodeDelegator(nodeDelegatorQueue[i]).getAssetBalance(asset);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice View amount of rsETH to mint for given asset amount\n    /// @param asset Asset address\n    /// @param amount Asset amount\n    /// @return rsethAmountToMint Amount of rseth to mint\n    function getRsETHAmountToMint(\n        address asset,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (uint256 rsethAmountToMint)\n    {\n        // setup oracle contract\n        address lrtOracleAddress = lrtConfig.getContract(LRTConstants.LRT_ORACLE);\n        ILRTOracle lrtOracle = ILRTOracle(lrtOracleAddress);\n\n        // calculate rseth amount to mint based on asset amount and asset exchange rate\n        rsethAmountToMint = (amount * lrtOracle.getAssetPrice(asset)) / lrtOracle.getRSETHPrice();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            write functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice helps user stake LST to the protocol\n    /// @param asset LST asset address to stake\n    /// @param depositAmount LST asset amount to stake\n    function depositAsset(\n        address asset,\n        uint256 depositAmount\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        onlySupportedAsset(asset)\n    {\n        // checks\n        if (depositAmount == 0) {\n            revert InvalidAmount();\n        }\n        if (depositAmount > getAssetCurrentLimit(asset)) {\n            revert MaximumDepositLimitReached();\n        }\n\n        if (!IERC20(asset).transferFrom(msg.sender, address(this), depositAmount)) {\n            revert TokenTransferFailed();\n        }\n\n        // interactions\n        uint256 rsethAmountMinted = _mintRsETH(asset, depositAmount);\n\n        emit AssetDeposit(asset, depositAmount, rsethAmountMinted);\n    }\n\n    /// @dev private function to mint rseth. It calculates rseth amount to mint based on asset amount and asset exchange\n    /// rates from oracle\n    /// @param _asset Asset address\n    /// @param _amount Asset amount to mint rseth\n    /// @return rsethAmountToMint Amount of rseth minted\n    function _mintRsETH(address _asset, uint256 _amount) private returns (uint256 rsethAmountToMint) {\n        (rsethAmountToMint) = getRsETHAmountToMint(_asset, _amount);\n\n        address rsethToken = lrtConfig.rsETH();\n        // mint rseth for user\n        IRSETH(rsethToken).mint(msg.sender, rsethAmountToMint);\n    }\n\n    /// @notice add new node delegator contract addresses\n    /// @dev only callable by LRT manager\n    /// @param nodeDelegatorContracts Array of NodeDelegator contract addresses\n    function addNodeDelegatorContractToQueue(address[] calldata nodeDelegatorContracts) external onlyLRTAdmin {\n        uint256 length = nodeDelegatorContracts.length;\n        if (nodeDelegatorQueue.length + length > maxNodeDelegatorCount) {\n            revert MaximumNodeDelegatorCountReached();\n        }\n\n        for (uint256 i; i < length;) {\n            UtilLib.checkNonZeroAddress(nodeDelegatorContracts[i]);\n            nodeDelegatorQueue.push(nodeDelegatorContracts[i]);\n            emit NodeDelegatorAddedinQueue(nodeDelegatorContracts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice transfers asset lying in this DepositPool to node delegator contract\n    /// @dev only callable by LRT manager\n    /// @param ndcIndex Index of NodeDelegator contract address in nodeDelegatorQueue\n    /// @param asset Asset address\n    /// @param amount Asset amount to transfer\n    function transferAssetToNodeDelegator(\n        uint256 ndcIndex,\n        address asset,\n        uint256 amount\n    )\n        external\n        nonReentrant\n        onlyLRTManager\n        onlySupportedAsset(asset)\n    {\n        address nodeDelegator = nodeDelegatorQueue[ndcIndex];\n        if (!IERC20(asset).transfer(nodeDelegator, amount)) {\n            revert TokenTransferFailed();\n        }\n    }\n\n    /// @notice update max node delegator count\n    /// @dev only callable by LRT admin\n    /// @param maxNodeDelegatorCount_ Maximum count of node delegator\n    function updateMaxNodeDelegatorCount(uint256 maxNodeDelegatorCount_) external onlyLRTAdmin {\n        maxNodeDelegatorCount = maxNodeDelegatorCount_;\n        emit MaxNodeDelegatorCountUpdated(maxNodeDelegatorCount);\n    }\n\n    /// @dev Triggers stopped state. Contract must not be paused.\n    function pause() external onlyLRTManager {\n        _pause();\n    }\n\n    /// @dev Returns to normal state. Contract must be paused\n    function unpause() external onlyLRTAdmin {\n        _unpause();\n    }\n}"
    },
    {
      "filename": "src/LRTOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport { UtilLib } from \"./utils/UtilLib.sol\";\nimport { LRTConstants } from \"./utils/LRTConstants.sol\";\nimport { LRTConfigRoleChecker, ILRTConfig } from \"./utils/LRTConfigRoleChecker.sol\";\n\nimport { IRSETH } from \"./interfaces/IRSETH.sol\";\nimport { IPriceFetcher } from \"./interfaces/IPriceFetcher.sol\";\nimport { ILRTOracle } from \"./interfaces/ILRTOracle.sol\";\nimport { ILRTDepositPool } from \"./interfaces/ILRTDepositPool.sol\";\nimport { INodeDelegator } from \"./interfaces/INodeDelegator.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\n/// @title LRTOracle Contract\n/// @notice oracle contract that calculates the exchange rate of assets\ncontract LRTOracle is ILRTOracle, LRTConfigRoleChecker, PausableUpgradeable {\n    mapping(address asset => address priceOracle) public override assetPriceOracle;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract\n    /// @param lrtConfigAddr LRT config address\n    function initialize(address lrtConfigAddr) external initializer {\n        UtilLib.checkNonZeroAddress(lrtConfigAddr);\n        __Pausable_init();\n\n        lrtConfig = ILRTConfig(lrtConfigAddr);\n        emit UpdatedLRTConfig(lrtConfigAddr);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            view functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Provides Asset/ETH exchange rate\n    /// @dev reads from priceFetcher interface which may fetch price from any supported oracle\n    /// @param asset the asset for which exchange rate is required\n    /// @return assetPrice exchange rate of asset\n    function getAssetPrice(address asset) public view onlySupportedAsset(asset) returns (uint256) {\n        return IPriceFetcher(assetPriceOracle[asset]).getAssetPrice(asset);\n    }\n\n    /// @notice Provides RSETH/ETH exchange rate\n    /// @dev calculates based on stakedAsset value received from eigen layer\n    /// @return rsETHPrice exchange rate of RSETH\n    function getRSETHPrice() external view returns (uint256 rsETHPrice) {\n        address rsETHTokenAddress = lrtConfig.rsETH();\n        uint256 rsEthSupply = IRSETH(rsETHTokenAddress).totalSupply();\n\n        if (rsEthSupply == 0) {\n            return 1 ether;\n        }\n\n        uint256 totalETHInPool;\n        address lrtDepositPoolAddr = lrtConfig.getContract(LRTConstants.LRT_DEPOSIT_POOL);\n\n        address[] memory supportedAssets = lrtConfig.getSupportedAssetList();\n        uint256 supportedAssetCount = supportedAssets.length;\n\n        for (uint16 asset_idx; asset_idx < supportedAssetCount;) {\n            address asset = supportedAssets[asset_idx];\n            uint256 assetER = getAssetPrice(asset);\n\n            uint256 totalAssetAmt = ILRTDepositPool(lrtDepositPoolAddr).getTotalAssetDeposits(asset);\n            totalETHInPool += totalAssetAmt * assetER;\n\n            unchecked {\n                ++asset_idx;\n            }\n        }\n\n        return totalETHInPool / rsEthSupply;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            write functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev add/update the price oracle of any supported asset\n    /// @dev only LRTManager is allowed\n    /// @param asset asset address for which oracle price needs to be added/updated\n    function updatePriceOracleFor(\n        address asset,\n        address priceOracle\n    )\n        extern"
    }
  ]
}