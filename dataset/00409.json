{
  "Title": "H-4: Unupdated totalBorrow After BigBang Liquidation",
  "Content": "# Issue H-4: Unupdated totalBorrow After BigBang Liquidation \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/49 \n\n## Found by \nbin2chen, cergyk, duc, hyh\n## Summary\nDuring the liquidation process, BigBang only reduces the user's `userBorrowPart[user]`, but fails to update the global `totalBorrow`. Consequently, all subsequent debt calculations are incorrect.\n\n## Vulnerability Detail\nCurrently, the implementation relies on the `BBLiquidation._updateBorrowAndCollateralShare()` method to calculate user debt repayment and collateral collection. \nThe code snippet is as follows:\n```solidity\n    function _liquidateUser(\n        address user,\n        uint256 maxBorrowPart,\n        IMarketLiquidatorReceiver _liquidatorReceiver,\n        bytes calldata _liquidatorReceiverData,\n        uint256 _exchangeRate,\n        uint256 minLiquidationBonus\n    ) private {\n        uint256 callerReward = _getCallerReward(user, _exchangeRate);\n\n        (uint256 borrowAmount,, uint256 collateralShare) =\n@>          _updateBorrowAndCollateralShare(user, maxBorrowPart, minLiquidationBonus, _exchangeRate);\n@>      totalCollateralShare = totalCollateralShare > collateralShare ? totalCollateralShare - collateralShare : 0;\n        uint256 borrowShare = yieldBox.toShare(assetId, borrowAmount, true);\n\n        (uint256 returnedShare,) =\n            _swapCollateralWithAsset(collateralShare, _liquidatorReceiver, _liquidatorReceiverData);\n        if (returnedShare < borrowShare) revert AmountNotValid();\n\n        (uint256 feeShare, uint256 callerShare) = _extractLiquidationFees(returnedShare, borrowShare, callerReward);\n\n        IUsdo(address(asset)).burn(address(this), borrowAmount);\n\n        address[] memory _users = new address[](1);\n        _users[0] = user;\n        emit Liquidated(msg.sender, _users, callerShare, feeShare, borrowAmount, collateralShare);\n    }\n\n    function _updateBorrowAndCollateralShare(\n        address user,\n        uint256 maxBorrowPart,\n        uint256 minLiquidationBonus, // min liquidation bonus to accept (default 0)\n        uint256 _exchangeRate\n    ) private returns (uint256 borrowAmount, uint256 borrowPart, uint256 collateralShare) {\n        if (_exchangeRate == 0) revert ExchangeRateNotValid();\n\n        // get collateral amount in asset's value\n        uint256 collateralPartInAsset = (\n            yieldBox.toAmount(collateralId, userCollateralShare[user], false) * EXCHANGE_RATE_PRECISION\n        ) / _exchangeRate;\n\n        // compute closing factor (liquidatable amount)\n        uint256 borrowPartWithBonus =\n            computeClosingFactor(userBorrowPart[user], collateralPartInAsset, FEE_PRECISION_DECIMALS);\n\n        // limit liquidable amount before bonus to the current debt\n        uint256 userTotalBorrowAmount = totalBorrow.toElastic(userBorrowPart[user], true);\n        borrowPartWithBonus = borrowPartWithBonus > userTotalBorrowAmount ? userTotalBorrowAmount : borrowPartWithBonus;\n\n        // check the amount to be repaid versus liquidator supplied limit\n        borrowPartWithBonus = borrowPartWithBonus > maxBorrowPart ? maxBorrowPart : borrowPartWithBonus;\n        borrowAmount = borrowPartWithBonus;\n\n        // compute part units, preventing rounding dust when liquidation is full\n        borrowPart = borrowAmount == userTotalBorrowAmount\n            ? userBorrowPart[user]\n            : totalBorrow.toBase(borrowPartWithBonus, false);\n        if (borrowPart == 0) revert Solvent();\n\n        if (liquidationBonusAmount > 0) {\n            borrowPartWithBonus = borrowPartWithBonus + (borrowPartWithBonus * liquidationBonusAmount) / FEE_PRECISION;\n        }\n\n        if (collateralPartInAsset < borrowPartWithBonus) {\n            if (collateralPartInAsset <= userTotalBorrowAmount) {\n                revert BadDebt();\n            }\n            // If current debt is covered by collateral fully\n            // then there is some liquidation bonus,\n            // so liquidation can proceed if liquidator's minimum is met\n            if (minLiquidationBonus > 0) {\n                // `collateralPartInAsset > borrowAmount` as `borrowAmount <= userTotalBorrowAmount`\n                uint256 effectiveBonus = ((collateralPartInAsset - borrowAmount) * FEE_PRECISION) / borrowAmount;\n                if (effectiveBonus < minLiquidationBonus) {\n                    revert InsufficientLiquidationBonus();\n                }\n                collateralShare = userCollateralShare[user];\n            } else {\n                revert InsufficientLiquidationBonus();\n            }\n        } else {\n            collateralShare =\n                yieldBox.toShare(collateralId, (borrowPartWithBonus * _exchangeRate) / EXCHANGE_RATE_PRECISION, false);\n            if (collateralShare > userCollateralShare[user]) {\n                revert NotEnoughCollateral();\n            }\n        }\n\n@>      userBorrowPart[user] -= borrowPart;\n@>      userCollateralShare[user] -= collateralShare;\n    }\n\n\n```\nThe methods mentioned above update the user-specific variables `userBorrowPart[user]` and `userCollateralShare[user]` within the `_updateBorrowAndCollateralShare()` method. \nAdditionally, the global variable `totalCollateralShare` is updated within the `_liquidateUser()` method.\n\nHowever, there's another crucial global variable, `totalBorrow`, which remains unaltered throughout the entire liquidation process.\n\nFailure to update `totalBorrow` during liquidation will result in incorrect subsequent loan-related calculations.\n\nNote: SGL Liquidation has the same issues\n\n## Impact\n\nThe lack of an update to `totalBorrow` during liquidation leads to inaccuracies in subsequent loan-related calculations. \nFor instance, this affects interest accumulation and the amount of interest due.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BBLiquidation.sol#L218-L228\n## Tool used\n\nManual Review\n\n## Recommendation\n\n```diff\n    function _liquidateUser(\n        address user,\n        uint256 maxBorrowPart,\n        IMarketLiquidatorReceiver _liquidatorReceiver,\n        bytes calldata _liquidatorReceiverData,\n        uint256 _exchangeRate,\n        uint256 minLiquidationBonus\n    ) private {\n        uint256 callerReward = _getCallerReward(user, _exchangeRate);\n\n-       (uint256 borrowAmount,, uint256 collateralShare) =\n+       (uint256 borrowAmount,uint256 borrowPart, uint256 collateralShare) =\n            _updateBorrowAndCollateralShare(user, maxBorrowPart, minLiquidationBonus, _exchangeRate);\n        totalCollateralShare = totalCollateralShare > collateralShare ? totalCollateralShare - collateralShare : 0;\n+       totalBorrow.elastic -= borrowAmount.toUint128();\n+       totalBorrow.base -= borrowPart.toUint128();\n```\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  the totalBorrow should be updated; medium(9)\n\n\n\n**cryptotechmaker**\n\nFixed in https://github.com/Tapioca-DAO/Tapioca-bar/pull/354\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/Tapioca-bar/pull/354.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/contracts/markets/bigBang/BBLiquidation.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\n// Tapioca\nimport {IMarketLiquidatorReceiver} from \"tapioca-periph/interfaces/bar/IMarketLiquidatorReceiver.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {IUsdo} from \"tapioca-periph/interfaces/oft/IUsdo.sol\";\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\nimport {BBCommon} from \"./BBCommon.sol\";\n\n// solhint-disable max-line-length\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract BBLiquidation is BBCommon {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n    using SafeCast for uint256;\n    using SafeApprove for address;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error NothingToLiquidate();\n    error LengthMismatch();\n    error ForbiddenAction();\n    error OnCollateralReceiverFailed();\n    error BadDebt();\n    error NotEnoughCollateral();\n    error Solvent();\n    error AmountNotValid();\n    error InsufficientLiquidationBonus();\n    error NotAuthorized();\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n\n    function liquidateBadDebt(\n        address user,\n        address from,\n        address receiver,\n        IMarketLiquidatorReceiver liquidatorReceiver,\n        bytes calldata liquidatorReceiverData,\n        bool swapCollateral\n    ) external onlyOwner {\n        _updateOracleRateForLiquidations();\n\n        //check from whitelist status\n        {\n            bool isWhitelisted = ICluster(penrose.cluster()).isWhitelisted(0, from);\n            if (!isWhitelisted) revert NotAuthorized();\n        }\n\n        // accrue before liquidation\n        _accrue();\n        penrose.reAccrueBigBangMarkets();\n\n        // compute borrow amount with bonus\n        uint256 elasticPart = totalBorrow.toElastic(userBorrowPart[user], false);\n        uint256 borrowAmountWithBonus = elasticPart + (elasticPart * liquidationMultiplier) / FEE_PRECISION;\n        uint256 requiredCollateral =\n            yieldBox.toShare(collateralId, (borrowAmountWithBonus * exchangeRate) / EXCHANGE_RATE_PRECISION, false);\n\n        uint256 collateralShare = userCollateralShare[user];\n        if (requiredCollateral < collateralShare) revert ForbiddenAction();\n\n        // update totalBorrow\n        uint256 borrowAmount = totalBorrow.toElastic(userBorrowPart[user], true);\n        totalBorrow.elastic -= borrowAmount.toUint128();\n        totalBorrow.base -= userBorrowPart[user].toUint128();\n\n        // update totalCollateralShare\n        totalCollateralShare -= collateralShare;\n\n        // set user share & part to 0\n        userCollateralShare[user] = 0;\n        userBorrowPart[user] = 0;\n\n        // burn debt amount from `from`\n        IUsdo(address(asset)).burn(from, borrowAmount);\n\n        // swap collateral with asset and send it to `owner`\n        if (swapCollateral) {\n            (, uint256 returnedAmount) =\n                _swapCollateralWithAsset(collateralShare, liquidatorReceiver, liquidatorReceiverData);\n            asset.safeTransfer(receiver, returnedAmount);\n        } else {\n            uint256 collateralAmount = yieldBox.toAmount(collateralId, collateralShare, false);\n            yieldBox.withdraw(collateralId, address(this), receiver, collateralAmount, 0);\n        }\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n\n    /// @notice Entry point for liquidations.\n    /// @param users An array of user addresses.\n    /// @param maxBorrowParts A one-to-one mapping to `users`, contains maximum (partial) borrow amounts (to liquidate) of the respective user\n    /// @param minLiquidationBonuses minimum liquidation bonus acceptable\n    /// @param liquidatorReceivers IMarketLiquidatorReceiver array\n    /// @param liquidatorReceiverDatas IMarketLiquidatorReceiver datas\n    function liquidate(\n        address[] calldata users,\n        uint256[] calldata maxBorrowParts,\n        uint256[] calldata minLiquidationBonuses,\n        IMarketLiquidatorReceiver[] calldata liquidatorReceivers,\n        bytes[] calldata liquidatorReceiverDatas\n    ) external optionNotPaused(PauseType.Liquidation) nonReentrant {\n        if (users.length == 0) revert NothingToLiquidate();\n        if (users.length != maxBorrowParts.length) revert LengthMismatch();\n        if (users.length != liquidatorReceivers.length) revert LengthMismatch();\n        if (liquidatorReceiverDatas.length != liquidatorReceivers.length) {\n            revert LengthMismatch();\n        }\n\n        _updateOracleRateForLiquidations();\n\n        _accrue();\n        penrose.reAccrueBigBangMarkets();\n\n        _closedLiquidation(\n            users, maxBorrowParts, minLiquidationBonuses, liquidatorReceivers, liquidatorReceiverDatas, exchangeRate\n        );\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _swapCollateralWithAsset(\n        uint256 _collateralShare,\n        IMarketLiquidatorReceiver _liquidatorReceiver,\n        bytes memory _liquidatorReceiverData\n    ) private returns (uint256 returnedShare, uint256 returnedAmount) {\n        uint256 collateralAmount = yieldBox.toAmount(collateralId, _collateralShare, false);\n        yieldBox.withdraw(collateralId, address(this), address(_liquidatorReceiver), collateralAmount, 0);\n\n        uint256 assetBalanceBefore = asset.balanceOf(address(this));\n        //msg.sender should be validated against `initiator` on IMarketLiquidatorReceiver\n        _liquidatorReceiver.onCollateralReceiver(\n            msg.sender, address(collateral), address(asset), collateralAmount, _liquidatorReceiverData\n        );\n        uint256 assetBalanceAfter = asset.balanceOf(address(this));\n\n        returnedAmount = assetBalanceAfter - assetBalanceBefore;\n        if (returnedAmount == 0) revert OnCollateralReceiverFailed();\n        returnedShare = yieldBox.toShare(assetId, returnedAmount, false);\n    }\n\n    function _updateBorrowAndCollateralShare(\n        address user,\n        uint256 maxBorrowPart,\n        uint256 minLiquidationBonus, // min liquidation bonus to accept (default 0)\n        uint256 _exchangeRate\n    ) private returns (uint256 borrowAmount, uint256 borrowPart, uint256 collateralShare) {\n        if (_exchangeRate == 0) revert ExchangeRateNotValid();\n\n        // get collateral amount in asset's value\n        uint256 collateralPartInAsset = (\n            yieldBox.toAmount(collateralId, userCollateralShare[user], false) * EXCHANGE_RATE_PRECISION\n        ) / _exchangeRate;\n\n        // compute closing factor (liquidatable amount)\n        uint256 borrowPartWithBonus =\n            computeClosingFactor(userBorrowPart[user], collateralPartInAsset, FEE_PRECISION_DECIMALS);\n\n        // limit liquidable amount before bonus to the current debt\n        uint256 userTotalBorrowAmount = totalBorrow.toElastic(userBorrowPart[user], true);\n        borrowPartWithBonus = borrowPartWithBonus > userTotalBorrowAmount ? userTotalBorrowAmount : borrowPartWithBonus;\n\n        // check the amount to be repaid versus liquidator supplied limit\n        borrowPartWithBonus = borrowPartWithBonus > maxBorrowPart ? maxBorrowPart : borrowPartWithBonus;\n        borrowAmount = borrowPartWithBonus;\n\n        // compute part units, preventing rounding dust when liquidation is full\n        borrowPart = borrowAmount == userTotalBorrowAmount\n            ? userBorrowPart[user]\n            : totalBorrow.toBase(borrowPartWithBonus, false);\n        if (borrowPart == 0) revert Solvent();\n\n        if (liquidationBonusAmount > 0) {\n            borrowPartWithBonus = borrowPartWithBonus + (borrowPartWithBonus * liquidationBonusAmount) / FEE_PRECISION;\n        }\n\n        if (collateralPartInAsset < borrowPartWithBonus) {\n            if (collateralPartInAsset <= userTotalBorrowAmount) {\n                revert BadDebt();\n            }\n            // If current debt is covered by collateral fully\n            // then there is some liquidation bonus,\n            // so liquidation can proceed if liquidator's minimum is met\n            if (minLiquidationBonus > 0) {\n                // `collateralPartInAsset > borrowAmount` as `borrowAmount <= userTotalBorrowAmount`\n                uint256 effectiveBonus = ((collateralPartInAsset - borrowAmount) * FEE_PRECISION) / borrowAmount;\n                if (effectiveBonus < minLiquidationBonus) {\n                    revert InsufficientLiquidationBonus();\n                }\n                collateralShare = userCollateralShare[user];\n            } else {\n                revert InsufficientLiquidationBonus();\n            }\n        } else {\n            collateralShare =\n                yieldBox.toShare(collateralId, (borrowPartWithBonus * _exchangeRate) / EXCHANGE_RATE_PRECISION, false);\n            if (collateralShare > userCollateralShare[user]) {\n                revert NotEnoughCollateral();\n            }\n        }\n\n        userBorrowPart[user] -= borrowPart;\n        userCollateralShare[user] -= collateralShare;\n    }\n\n    function _extractLiquidationFees(uint256 returnedShare, uint256 borrowShare, uint256 callerReward)\n        private\n        returns (uint256 feeShare, uint256 callerShare)\n    {\n        uint256 extraShare = returnedShare > borrowShare ? returnedShare - borrowShare : 0;\n        callerShare = (extraShare * callerReward) / FEE_PRECISION; //  y%  of profit goes to caller.\n        feeShare = extraShare - callerShare; // rest of the profit goes to fee.\n\n        //protocol fees should be kept in the contract as we do a yieldBox.depositAsset when we are extracting the fees using `refreshPenroseFees`\n        if (callerShare > 0) {\n            address(asset).safeApprove(address(yieldBox), type(uint256).max);\n            yieldBox.depositAsset(assetId, address(this), msg.sender, 0, callerShare);\n        }\n        address(asset).safeApprove(address(yieldBox), 0);\n    }\n\n    function _liquidateUser(\n        address user,\n        uint256 maxBorrowPart,\n        IMarketLiquidatorReceiver _liquidatorReceiver,\n        bytes calldata _liquidatorReceiverData,\n        uint256 _exchangeRate,\n        uint256 minLiquidationBonus\n    ) private {\n        uint256 callerReward = _getCallerReward(user, _exchangeRate);\n\n        (uint256 borrowAmount,, uint256 collateralShare) =\n            _updateBorrowAndCollateralShare(user, maxBorrowPart, minLiquidationBonus, _exchangeRate);\n        totalCollateralShare = totalCollateralShare > collateralShare ? totalCollateralShare - collateralShare : 0;\n\n        uint256 borrowShare = yieldBox.toShare(assetId, borrowAmount, true);\n\n        (uint256 returnedShare,) =\n            _swapCollateralWithAsset(collateralShare, _liquidatorReceiver, _liquidatorReceiverData);\n        if (returnedShare < borrowShare) revert AmountNotValid();\n\n        (uint256 feeShare, uint256 callerShare) = _extractLiquidationFees(returnedShare, borrowShare, callerReward);\n\n        IUsdo(address(asset)).burn(address(this), borrowAmount);\n\n        address[] memory _users = new address[](1);\n        _users[0] = user;\n        emit Liquidated(msg.sender, _users, callerShare, feeShare, borrowAmount, collateralShare);\n    }\n\n    struct __ClosedLiquidationCalldata {\n        address user;\n        uint256 maxBorrowPart;\n        uint256 minLiquidationBonus;\n        IMarketLiquidatorReceiver liquidatorReceiver;\n    }\n    /// @notice Handles the liquidation of users' balances, once the users' amount of collateral is too low.\n    /// @dev Closed liquidations Only, 90% of extra shares goes to caller and 10% to protocol\n\n    function _closedLiquidation(\n        address[] calldata users,\n        uint256[] calldata maxBorrowParts,\n        uint256[] calldata minLiquidationBonuses,\n        IMarketLiquidatorReceiver[] calldata liquidatorReceivers,\n        bytes[] calldata liquidatorReceiverDatas,\n        uint256 _exchangeRate\n    ) private {\n        uint256 liquidatedCount = 0;\n        uint256 arrLength = users.length;\n\n        __ClosedLiquidationCalldata memory calldata_; // Stack too deep fix\n\n        for (uint256 i; i < arrLength;) {\n            calldata_.user = users[i];\n            calldata_.maxBorrowPart = maxBorrowParts[i];\n            calldata_.minLiquidationBonus = minLiquidationBonuses[i];\n            calldata_.liquidatorReceiver = liquidatorReceivers[i];\n\n            if (!_isSolvent(calldata_.user, _exchangeRate, true)) {\n                liquidatedCount++;\n                _liquidateUser(\n                    calldata_.user,\n                    calldata_.maxBorrowPart,\n                    calldata_.liquidatorReceiver,\n                    liquidatorReceiverDatas[i],\n                    _exchangeRate,\n                    calldata_.minLiquidationBonus\n                );\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        require(liquidatedCount != 0, \"BB: no users found\");\n    }\n}"
    }
  ]
}