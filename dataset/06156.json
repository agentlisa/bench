{
  "Title": "[M-06] Deployer wallet retains ability to spoof validated senders after ownership transfer",
  "Content": "\n### Lines of code\n<https://github.com/code-423n4/2023-07-axelar/blob/9f642fe854eb11ad9f18fe028e5a8353c258e926/contracts/its/remote-address-validator/RemoteAddressValidator.sol#L72-L74><br>\n<https://github.com/code-423n4/2023-07-axelar/blob/9f642fe854eb11ad9f18fe028e5a8353c258e926/contracts/its/remote-address-validator/RemoteAddressValidator.sol#L83>\n\n### Impact\n\nThe InterchainTokenService is deployed using [create3](<https://github.com/code-423n4/2023-07-axelar/blob/9f642fe854eb11ad9f18fe028e5a8353c258e926/scripts/deploy.js#L60-L64>). This means, that its address depends on the address of the deployer wallet, the address of the `Create3Deployer` contract, and the salt that is extracted from a deployment key.\n\nIt should be feasible for the same deployer wallet to deploy a `Create3Deployer` with the same address on a new chain and use the same deployment key to deploy a contract with the same address as the `InterchainTokenService`, but with arbitrary implementation. A team member has confirmed on Discord that \"the address will be the `interchainTokenServiceAddress` which is constant across EVM chains.\". However, at deployment time, only a subset of all the possible EVM chains will be supported, and more may be added in the future. When that happens, it is possible that the original deployer wallet is compromised or no longer available.\n\nOn the other hand, the `addTrustedAddress` function validates that the sender is the owner of the `RemoteAddressValidator` contract. This owner is originally the deployer wallet, but ownership may be transferred (and it would be a good practice to transfer it to a more secure governance multisig immediately after deployment). After ownership transfer, the previous owner should not be allowed to add trusted addresses.\n\nHowever, the `validateSender` function will treat any address that is the same as the current chain's `InterchainTokenService` as valid. A malicious contract deployed by the deployer wallet after the ownership transfer could be treated as valid and would have the ability to deploy token managers and standardized tokens, or perform arbitrary token transfers. This is a form of centralization risk but is also a serious privilege escalation, as it should be possible to strip the deployer of the ability to perform these actions. This gives them virtually unlimited power even after an ownership transfer.\n\n### Proof of Concept\n\n- A deployer account is used to deploy all contracts on chain A.\n- Ownership of the `RemoteAddressValidator` and all other contracts is transferred to governance multisigs. After this point, the deployer should have no ability to add trusted addresses.\n- The deployer account is compromised (which is easier to do than compromising a governance multisig), or a team member with access to the deployer account becomes compromised or malicious.\n- The deployer repeats the same steps used for the deployment, starting from the same wallet nonce on chain B, but replaces the `InterchainTokenService` contract with a contract that allows arbitrary messages, e.g. by adding this function to a regular `InterchainTokenService`:\n\n```\n\n        function callContract(\n            string calldata destinationChain,\n            bytes memory payload,\n            uint256 gasValue,\n            address refundTo\n        ) external onlyOwner {\n            _callContract(destinationChain, payload, gasValue, refundTo);\n        }\n```\n\n- The deployer then uses this contract to send a payload with `SELECTOR_SEND_TOKEN` and using the deployer address as destination to the `InterchainTokenService` on chain A.\n- When running `validateSender` on the `RemoteAddressValidator` on chain A, this check will pass and the address will be treated as valid:\n\n```\n\n\n\n            if (sourceAddressHash == interchainTokenServiceAddressHash) {\n                return true;\n            }\n```\n\nTherefore, the tokens will be transferred to the deployer address on chain A.\n\n### Recommended Mitigation Steps\n\nThe assumption that the `InterchainTokenService` address is valid in any chain is dangerous because of how the contract is created and the possibility that new EVM chains may exist in the future. A deployer EOA should not have this amount of permission for an indefinite time. I would recommend breaking that assumption and requiring that all addresses are added as trusted addresses explicitly.\n\nA check can therefore be added to only treat the interchain token service's address as valid if the source chain is also the same chain where the `RemoteAddressValidator` is deployed. The following diff shows a way to do this:\n\n```diff\ndiff --git a/contracts/its/remote-address-validator/RemoteAddressValidator.sol b/contracts/its/remote-address-validator/RemoteAddressValidator.sol\nindex bb101e5..c2e5382 100644\n--- a/contracts/its/remote-address-validator/RemoteAddressValidator.sol\n+++ b/contracts/its/remote-address-validator/RemoteAddressValidator.sol\n@@ -4,6 +4,7 @@ pragma solidity ^0.8.0;\n import { IRemoteAddressValidator } from '../interfaces/IRemoteAddressValidator.sol';\n import { AddressToString } from '../../gmp-sdk/util/AddressString.sol';\n import { Upgradable } from '../../gmp-sdk/upgradable/Upgradable.sol';\n+import { StringToBytes32 } from '../../gmp-sdk/util/Bytes32String.sol';\n \n /**\n  * @title RemoteAddressValidator\n@@ -11,23 +12,25 @@ import { Upgradable } from '../../gmp-sdk/upgradable/Upgradable.sol';\n  */\n contract RemoteAddressValidator is IRemoteAddressValidator, Upgradable {\n     using AddressToString for address;\n+    using StringToBytes32 for string;\n \n     mapping(string => bytes32) public remoteAddressHashes;\n     mapping(string => string) public remoteAddresses;\n     address public immutable interchainTokenServiceAddress;\n     bytes32 public immutable interchainTokenServiceAddressHash;\n     mapping(string => bool) public supportedByGateway;\n-\n+    bytes32 public immutable currentChainName;\n     bytes32 private constant CONTRACT_ID = keccak256('remote-address-validator');\n \n     /**\n      * @dev Constructs the RemoteAddressValidator contract, both array parameters must be equal in length\n      * @param _interchainTokenServiceAddress Address of the interchain token service\n      */\n-    constructor(address _interchainTokenServiceAddress) {\n+    constructor(address _interchainTokenServiceAddress, string memory _chainName) {\n         if (_interchainTokenServiceAddress == address(0)) revert ZeroAddress();\n         interchainTokenServiceAddress = _interchainTokenServiceAddress;\n         interchainTokenServiceAddressHash = keccak256(bytes(_lowerCase(interchainTokenServiceAddress.toString())));\n+        currentChainName = _chainName.toBytes32();\n     }\n \n     /**\n@@ -69,7 +72,7 @@ contract RemoteAddressValidator is IRemoteAddressValidator, Upgradable {\n     function validateSender(string calldata sourceChain, string calldata sourceAddress) external view returns (bool) {\n         string memory sourceAddressLC = _lowerCase(sourceAddress);\n         bytes32 sourceAddressHash = keccak256(bytes(sourceAddressLC));\n-        if (sourceAddressHash == interchainTokenServiceAddressHash) {\n+        if (sourceAddressHash == interchainTokenServiceAddressHash && sourceChain.toBytes32() == currentChainName) {\n             return true;\n         }\n         return sourceAddressHash == remoteAddressHashes[sourceChain];\n```\n\n### Assessed type\n\nAccess Control\n\n**[pcarranzav (warden) commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/267#issuecomment-1712132762):**\n> @berndartmueller - I'd like to point out this one, which was marked as duplicate of [Issue 348](https://github.com/code-423n4/2023-07-axelar-findings/issues/348) which is marked as invalid.\n> The argumentation in my submission is different, as it is framed as a privilege escalation of the deployer wallet, which persists after ownership transfer and in the hypothetical of a new EVM chain being added to the Axelar network.\n> \n> This modifies the trust assumptions of the protocol, as users can reasonably expect to trust the multisig Owner, but not a deployer EOA, for an indefinite time. In the closed issue, @deanamiel commented \"It would be impossible to deploy a different contract at this address because the address will depend on the deployer address and salt.\" However, there is a different level of \"impossible\" when comparing an EOA to a multisig and users now need to trust that nobody with access to that EOA is compromised or that it is disposed of properly.\n> \n> The probability of this being exploited is low (requires deployer EOA compromise and new chain added to the network), but the impact would be *huge*, which is why I honestly believe it warrants a Medium severity and is a valid finding to surface in the report so that users are aware.\n\n**[berndartmueller (judge) commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/267#issuecomment-1713738431):**\n> @pcarranzav - thanks for pointing this out! I've marked your submission as the primary report due to pointing out the deployer privilege escalation. But I also consider #348 a duplicate, as the recommended fix would also fix the underlying issue.\n> \n> Overall, I agree with the outlined privilege escalation. Even though the likelihood of this to happen is low, the impact would be critical. Thus, I consider medium severity to be appropriate.\n\n**[deanamiel (Axelar) acknowledged and commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/267#issuecomment-1716452626):**\n > We acknowledge the severity, and while we’ve considered using a deployer multisig contract which reduces this risk, our operations team is planning on whitelisting explicitly to minimize the impact of the deployer or a non-whitelisted chain being compromised. Note that `RemoteAddressValidator` is deployed on the destination chain, so the recommendation to compare the source chain to the chain in remote address validator won’t work.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-axelar",
  "Code": [
    {
      "filename": "contracts/its/remote-address-validator/RemoteAddressValidator.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport { IRemoteAddressValidator } from '../interfaces/IRemoteAddressValidator.sol';\nimport { AddressToString } from '../../gmp-sdk/util/AddressString.sol';\nimport { Upgradable } from '../../gmp-sdk/upgradable/Upgradable.sol';\n\n/**\n * @title RemoteAddressValidator\n * @dev Manages and validates remote addresses, keeps track of addresses supported by the Axelar gateway contract\n */\ncontract RemoteAddressValidator is IRemoteAddressValidator, Upgradable {\n    using AddressToString for address;\n\n    mapping(string => bytes32) public remoteAddressHashes;\n    mapping(string => string) public remoteAddresses;\n    address public immutable interchainTokenServiceAddress;\n    bytes32 public immutable interchainTokenServiceAddressHash;\n    mapping(string => bool) public supportedByGateway;\n\n    bytes32 private constant CONTRACT_ID = keccak256('remote-address-validator');\n\n    /**\n     * @dev Constructs the RemoteAddressValidator contract, both array parameters must be equal in length\n     * @param _interchainTokenServiceAddress Address of the interchain token service\n     */\n    constructor(address _interchainTokenServiceAddress) {\n        if (_interchainTokenServiceAddress == address(0)) revert ZeroAddress();\n        interchainTokenServiceAddress = _interchainTokenServiceAddress;\n        interchainTokenServiceAddressHash = keccak256(bytes(_lowerCase(interchainTokenServiceAddress.toString())));\n    }\n\n    /**\n     * @notice Getter for the contract id.\n     */\n    function contractId() external pure returns (bytes32) {\n        return CONTRACT_ID;\n    }\n\n    function _setup(bytes calldata params) internal override {\n        (string[] memory trustedChainNames, string[] memory trustedAddresses) = abi.decode(params, (string[], string[]));\n        uint256 length = trustedChainNames.length;\n        if (length != trustedAddresses.length) revert LengthMismatch();\n        for (uint256 i; i < length; ++i) {\n            addTrustedAddress(trustedChainNames[i], trustedAddresses[i]);\n        }\n    }\n\n    /**\n     * @dev Converts a string to lower case\n     * @param s Input string to be converted\n     * @return string lowercase version of the input string\n     */\n    function _lowerCase(string memory s) internal pure returns (string memory) {\n        uint256 length = bytes(s).length;\n        for (uint256 i; i < length; i++) {\n            uint8 b = uint8(bytes(s)[i]);\n            if ((b >= 65) && (b <= 70)) bytes(s)[i] = bytes1(b + uint8(32));\n        }\n        return s;\n    }\n\n    /**\n     * @dev Validates that the sender is a valid interchain token service address\n     * @param sourceChain Source chain of the transaction\n     * @param sourceAddress Source address of the transaction\n     * @return bool true if the sender is validated, false otherwise\n     */\n    function validateSender(string calldata sourceChain, string calldata sourceAddress) external view returns (bool) {\n        string memory sourceAddressLC = _lowerCase(sourceAddress);\n        bytes32 sourceAddressHash = keccak256(bytes(sourceAddressLC));\n        if (sourceAddressHash == interchainTokenServiceAddressHash) {\n            return true;\n        }\n        return sourceAddressHash == remoteAddressHashes[sourceChain];\n    }\n\n    /**\n     * @dev Adds a trusted interchain token service address for the specified chain\n     * @param chain Chain name of the interchain token service\n     * @param addr Interchain token service address to be added\n     */\n    function addTrustedAddress(string memory chain, string memory addr) public onlyOwner {\n        if (bytes(chain).length == 0) revert ZeroStringLength();\n        if (bytes(addr).length == 0) revert ZeroStringLength();\n        remoteAddressHashes[chain] = keccak256(bytes(_lowerCase(addr)));\n        remoteAddresses[chain] = addr;\n        emit TrustedAddressAdded(chain, addr);\n    }\n\n    /**\n     * @dev Removes a trusted interchain token service address\n     * @param chain Chain name of the interchain token service to be removed\n     */\n    function removeTrustedAddress(string calldata chain) external onlyOwner {\n        if (bytes(chain).length == 0) revert ZeroStringLength();\n        remoteAddressHashes[chain] = bytes32(0);\n        remoteAddresses[chain] = '';\n        emit TrustedAddressRemoved(chain);\n    }\n\n    /**\n     * @dev Adds chains that are supported by the Axelar gateway\n     * @param chainNames List of chain names to be added as supported\n     */\n    function addGatewaySupportedChains(string[] calldata chainNames) external onlyOwner {\n        uint256 length = chainNames.length;\n        for (uint256 i; i < length; ++i) {\n            string calldata chainName = chainNames[i];\n            supportedByGateway[chainName] = true;\n            emit GatewaySupportedChainAdded(chainName);\n        }\n    }\n\n    /**\n     * @dev Removes chains that are no longer supported by the Axelar gateway\n     * @param chainNames List of chain names to be removed as supported\n     */\n    function removeGatewaySupportedChains(string[] calldata chainNames) external onlyOwner {\n        uint256 length = chainNames.length;\n        for (uint256 i; i < length; ++i) {\n            string calldata chainName = chainNames[i];\n            supportedByGateway[chainName] = false;\n            emit GatewaySupportedChainRemoved(chainName);\n        }\n    }\n\n    /**\n     * @dev Fetches the interchain token service address for the specified chain\n     * @param chainName Name of the chain\n     * @return remoteAddress Interchain token service address for the specified chain\n     */\n    function getRemoteAddress(string calldata chainName) external view returns (string memory remoteAddress) {\n        remoteAddress = remoteAddresses[chainName];\n        if (bytes(remoteAddress).length == 0) {\n            remoteAddress = interchainTokenServiceAddress.toString();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/its/remote-address-validator/RemoteAddressValidator.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport { IRemoteAddressValidator } from '../interfaces/IRemoteAddressValidator.sol';\nimport { AddressToString } from '../../gmp-sdk/util/AddressString.sol';\nimport { Upgradable } from '../../gmp-sdk/upgradable/Upgradable.sol';\n\n/**\n * @title RemoteAddressValidator\n * @dev Manages and validates remote addresses, keeps track of addresses supported by the Axelar gateway contract\n */\ncontract RemoteAddressValidator is IRemoteAddressValidator, Upgradable {\n    using AddressToString for address;\n\n    mapping(string => bytes32) public remoteAddressHashes;\n    mapping(string => string) public remoteAddresses;\n    address public immutable interchainTokenServiceAddress;\n    bytes32 public immutable interchainTokenServiceAddressHash;\n    mapping(string => bool) public supportedByGateway;\n\n    bytes32 private constant CONTRACT_ID = keccak256('remote-address-validator');\n\n    /**\n     * @dev Constructs the RemoteAddressValidator contract, both array parameters must be equal in length\n     * @param _interchainTokenServiceAddress Address of the interchain token service\n     */\n    constructor(address _interchainTokenServiceAddress) {\n        if (_interchainTokenServiceAddress == address(0)) revert ZeroAddress();\n        interchainTokenServiceAddress = _interchainTokenServiceAddress;\n        interchainTokenServiceAddressHash = keccak256(bytes(_lowerCase(interchainTokenServiceAddress.toString())));\n    }\n\n    /**\n     * @notice Getter for the contract id.\n     */\n    function contractId() external pure returns (bytes32) {\n        return CONTRACT_ID;\n    }\n\n    function _setup(bytes calldata params) internal override {\n        (string[] memory trustedChainNames, string[] memory trustedAddresses) = abi.decode(params, (string[], string[]));\n        uint256 length = trustedChainNames.length;\n        if (length != trustedAddresses.length) revert LengthMismatch();\n        for (uint256 i; i < length; ++i) {\n            addTrustedAddress(trustedChainNames[i], trustedAddresses[i]);\n        }\n    }\n\n    /**\n     * @dev Converts a string to lower case\n     * @param s Input string to be converted\n     * @return string lowercase version of the input string\n     */\n    function _lowerCase(string memory s) internal pure returns (string memory) {\n        uint256 length = bytes(s).length;\n        for (uint256 i; i < length; i++) {\n            uint8 b = uint8(bytes(s)[i]);\n            if ((b >= 65) && (b <= 70)) bytes(s)[i] = bytes1(b + uint8(32));\n        }\n        return s;\n    }\n\n    /**\n     * @dev Validates that the sender is a valid interchain token service address\n     * @param sourceChain Source chain of the transaction\n     * @param sourceAddress Source address of the transaction\n     * @return bool true if the sender is validated, false otherwise\n     */\n    function validateSender(string calldata sourceChain, string calldata sourceAddress) external view returns (bool) {\n        string memory sourceAddressLC = _lowerCase(sourceAddress);\n        bytes32 sourceAddressHash = keccak256(bytes(sourceAddressLC));\n        if (sourceAddressHash == interchainTokenServiceAddressHash) {\n            return true;\n        }\n        return sourceAddressHash == remoteAddressHashes[sourceChain];\n    }\n\n    /**\n     * @dev Adds a trusted interchain token service address for the specified chain\n     * @param chain Chain name of the interchain token service\n     * @param addr Interchain token service address to be added\n     */\n    function addTrustedAddress(string memory chain, string memory addr) public onlyOwner {\n        if (bytes(chain).length == 0) revert ZeroStringLength();\n        if (bytes(addr).length == 0) revert ZeroStringLength();\n        remoteAddressHashes[chain] = keccak256(bytes(_lowerCase(addr)));\n        remoteAddresses[chain] = addr;\n        emit TrustedAddressAdded(chain, addr);\n    }\n\n    /**\n     * @dev Removes a trusted interchain token service address\n     * @param chain Chain name of the interchain token service to be removed\n     */\n    function removeTrustedAddress(string calldata chain) external onlyOwner {\n        if (bytes(chain).length == 0) revert ZeroStringLength();\n        remoteAddressHashes[chain] = bytes32(0);\n        remoteAddresses[chain] = '';\n        emit TrustedAddressRemoved(chain);\n    }\n\n    /**\n     * @dev Adds chains that are supported by the Axelar gateway\n     * @param chainNames List of chain names to be added as supported\n     */\n    function addGatewaySupportedChains(string[] calldata chainNames) external onlyOwner {\n        uint256 length = chainNames.length;\n        for (uint256 i; i < length; ++i) {\n            string calldata chainName = chainNames[i];\n            supportedByGateway[chainName] = true;\n            emit GatewaySupportedChainAdded(chainName);\n        }\n    }\n\n    /**\n     * @dev Removes chains that are no longer supported by the Axelar gateway\n     * @param chainNames List of chain names to be removed as supported\n     */\n    function removeGatewaySupportedChains(string[] calldata chainNames) external onlyOwner {\n        uint256 length = chainNames.length;\n        for (uint256 i; i < length; ++i) {\n            string calldata chainName = chainNames[i];\n            supportedByGateway[chainName] = false;\n            emit GatewaySupportedChainRemoved(chainName);\n        }\n    }\n\n    /**\n     * @dev Fetches the interchain token service address for the specified chain\n     * @param chainName Name of the chain\n     * @return remoteAddress Interchain token service address for the specified chain\n     */\n    function getRemoteAddress(string calldata chainName) external view returns (string memory remoteAddress) {\n        remoteAddress = remoteAddresses[chainName];\n        if (bytes(remoteAddress).length == 0) {\n            remoteAddress = interchainTokenServiceAddress.toString();\n        }\n    }\n}"
    },
    {
      "filename": "scripts/deploy.js",
      "content": "const { ethers } = require('hardhat');\nconst { Contract } = ethers;\nconst { defaultAbiCoder } = ethers.utils;\nconst InterchainTokenServiceProxy = require('../artifacts/contracts/its/proxies/InterchainTokenServiceProxy.sol/InterchainTokenServiceProxy.json');\nconst { deployCreate3Contract, getCreate3Address } = require('@axelar-network/axelar-gmp-sdk-solidity');\nconst Create3Deployer = require('../artifacts/contracts/gmp-sdk/deploy/Create3Deployer.sol/Create3Deployer.json');\n\nasync function deployContract(wallet, contractName, args = []) {\n    const factory = await ethers.getContractFactory(contractName, wallet);\n    const contract = await factory.deploy(...args);\n\n    return contract;\n}\n\nasync function deployRemoteAddressValidator(wallet, interchainTokenServiceAddress) {\n    const remoteAddressValidatorImpl = await deployContract(wallet, 'RemoteAddressValidator', [interchainTokenServiceAddress]);\n    const params = defaultAbiCoder.encode(['string[]', 'string[]'], [[], []]);\n\n    const remoteAddressValidatorProxy = await deployContract(wallet, 'RemoteAddressValidatorProxy', [\n        remoteAddressValidatorImpl.address,\n        wallet.address,\n        params,\n    ]);\n    const remoteAddressValidator = new Contract(remoteAddressValidatorProxy.address, remoteAddressValidatorImpl.interface, wallet);\n    return remoteAddressValidator;\n}\n\nasync function deployMockGateway(wallet) {\n    const gateway = await deployContract(wallet, 'MockAxelarGateway');\n    return gateway;\n}\n\nasync function deployGasService(wallet) {\n    const gasService = await deployContract(wallet, 'AxelarGasService', [wallet.address]);\n    return gasService;\n}\n\nasync function deployInterchainTokenService(\n    wallet,\n    create3DeployerAddress,\n    tokenManagerDeployerAddress,\n    standardizedTokenDeployerAddress,\n    gatewayAddress,\n    gasServiceAddress,\n    remoteAddressValidatorAddress,\n    tokenManagerImplementations,\n    chainName,\n    deploymentKey,\n    operatorAddress = wallet.address,\n) {\n    const implementation = await deployContract(wallet, 'InterchainTokenService', [\n        tokenManagerDeployerAddress,\n        standardizedTokenDeployerAddress,\n        gatewayAddress,\n        gasServiceAddress,\n        remoteAddressValidatorAddress,\n        tokenManagerImplementations,\n        chainName,\n    ]);\n    const proxy = await deployCreate3Contract(create3DeployerAddress, wallet, InterchainTokenServiceProxy, deploymentKey, [\n        implementation.address,\n        wallet.address,\n        operatorAddress,\n    ]);\n    const service = new Contract(proxy.address, implementation.interface, wallet);\n    return service;\n}\n\nasync function deployTokenManagerImplementations(wallet, interchainTokenServiceAddress) {\n    const implementations = [];\n\n    for (const type of ['LockUnlock', 'MintBurn', 'LiquidityPool']) {\n        const impl = await deployContract(wallet, `TokenManager${type}`, [interchainTokenServiceAddress]);\n        implementations.push(impl);\n    }\n\n    return implementations;\n}\n\nasync function deployAll(wallet, chainName, deploymentKey = 'interchainTokenService') {\n    const create3DeployerFactory = await ethers.getContractFactory(Create3Deployer.abi, Create3Deployer.bytecode, wallet);\n    const create3Deployer = await create3DeployerFactory.deploy().then((d) => d.deployed());\n    const gateway = await deployMockGateway(wallet);\n    const gasService = await deployGasService(wallet);\n    const tokenManagerDeployer = await deployContract(wallet, 'TokenManagerDeployer', [create3Deployer.address]);\n    const standardizedTokenLockUnlock = await deployContract(wallet, 'StandardizedTokenLockUnlock');\n    const standardizedTokenMintBurn = await deployContract(wallet, 'StandardizedTokenMintBurn');\n    const standardizedTokenDeployer = await deployContract(wallet, 'StandardizedTokenDeployer', [\n        create3Deployer.address,\n        standardizedTokenLockUnlock.address,\n        standardizedTokenMintBurn.address,\n    ]);\n    const interchainTokenServiceAddress = await getCreate3Address(create3Deployer.address, wallet, deploymentKey);\n    const remoteAddressValidator = await deployRemoteAddressValidator(wallet, interchainTokenServiceAddress);\n    const tokenManagerImplementations = await deployTokenManagerImplementations(wallet, interchainTokenServiceAddress);\n\n    const service = await deployInterchainTokenService(\n        wallet,\n        create3Deployer.address,\n        tokenManagerDeployer.address,\n        standardizedTokenDeployer.address,\n        gateway.address,\n        gasService.address,\n        remoteAddressValidator.address,\n        tokenManagerImplementations.map((impl) => impl.address),\n        chainName,\n        deploymentKey,\n    );\n    return [service, gateway, gasService];\n}\n\nmodule.exports = {\n    deployContract,\n    deployRemoteAddressValidator,\n    deployMockGateway,\n    deployGasService,\n    deployInterchainTokenService,\n    deployAll,\n};"
    }
  ]
}