{
  "Title": "An attacker can steal the StabilityPool depositors profit",
  "Content": "##### Description\nThe liquidation flow of the protocol is supposed to be as follows:\n- users open troves and join `StabilityPool`\n- anyone calls liquidation that iterates the given troves and liquidates them one by one\n- in `StabilityPool` there are more collateral tokens\n\nBy using a flash loan, any user can bypass the provision of liquidity to the protocol for a long time and steal some of the `StabilityPool` provider's profit taking the following steps:\n1. An attacker gets a flash mint (https://github.com/prisma-fi/prisma-contracts/blob/52b26b8a2f1904b048754d5443e08d2144610b92/contracts/core/DebtToken.sol#L199).\n2. The attacker makes a deposit `mkUSD` to `StabilityPool`.\n3. The attacker calls the [`liquidateTroves`](https://github.com/prisma-fi/prisma-contracts/blob/52b26b8a2f1904b048754d5443e08d2144610b92/contracts/core/LiquidationManager.sol#L143) function to liquidate the troves.\n4. The attacker calls [`withdrawFromSP`](https://github.com/prisma-fi/prisma-contracts/blob/52b26b8a2f1904b048754d5443e08d2144610b92/contracts/core/StabilityPool.sol#L241)\n5. The attacker gets profit and returns the flash loan.\n\nThe attack's impact:\n- loss of profit from liquidations by `StabilityPool` providers;\n- decreased motivation to use the Stability Pool which may cause mkUSD to unpeg.\n\n##### Recommendation\nWe recommend that you use the time factor to prevent flash loan attacks.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/core/DebtToken.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { OFT, IERC20, ERC20 } from \"@layerzerolabs/solidity-examples/contracts/token/oft/OFT.sol\";\nimport { IERC3156FlashBorrower } from \"@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport \"../interfaces/IPrismaCore.sol\";\n\n/**\n    @title Prisma Debt Token \"acUSD\"\n    @notice CDP minted against collateral deposits within `TroveManager`.\n            This contract has a 1:n relationship with multiple deployments of `TroveManager`,\n            each of which hold one collateral type which may be used to mint this token.\n */\ncontract DebtToken is OFT {\n    string public constant version = \"1\";\n\n    // --- ERC 3156 Data ---\n    bytes32 private constant _RETURN_VALUE = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    uint256 public constant FLASH_LOAN_FEE = 9; // 1 = 0.0001%\n\n    // --- Data for EIP2612 ---\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant permitTypeHash = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    // keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    bytes32 private constant _TYPE_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n\n    mapping(address => uint256) private _nonces;\n\n    // --- Addresses ---\n    IPrismaCore private immutable _prismaCore;\n    address public immutable stabilityPoolAddress;\n    address public immutable borrowerOperationsAddress;\n    address public immutable factory;\n    address public immutable gasPool;\n\n    mapping(address => bool) public troveManager;\n\n    // Amount of debt to be locked in gas pool on opening troves\n    uint256 public immutable DEBT_GAS_COMPENSATION;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _stabilityPoolAddress,\n        address _borrowerOperationsAddress,\n        IPrismaCore prismaCore_,\n        address _layerZeroEndpoint,\n        address _factory,\n        address _gasPool,\n        uint256 _gasCompensation\n    ) OFT(_name, _symbol, _layerZeroEndpoint) {\n        stabilityPoolAddress = _stabilityPoolAddress;\n        _prismaCore = prismaCore_;\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        factory = _factory;\n        gasPool = _gasPool;\n\n        DEBT_GAS_COMPENSATION = _gasCompensation;\n\n        bytes32 hashedName = keccak256(bytes(_name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(_TYPE_HASH, hashedName, hashedVersion);\n    }\n\n    function enableCollateral(address _troveManager) external {\n        require(msg.sender == factory, \"!Factory\");\n        troveManager[_troveManager] = true;\n    }\n\n    // --- Functions for intra-Prisma calls ---\n\n    function mintWithGasCompensation(address _account, uint256 _amount) external returns (bool) {\n        require(msg.sender == borrowerOperationsAddress);\n        _mint(_account, _amount);\n        _mint(gasPool, DEBT_GAS_COMPENSATION);\n\n        return true;\n    }\n\n    function burnWithGasCompensation(address _account, uint256 _amount) external returns (bool) {\n        require(msg.sender == borrowerOperationsAddress);\n        _burn(_account, _amount);\n        _burn(gasPool, DEBT_GAS_COMPENSATION);\n\n        return true;\n    }\n\n    function mint(address _account, uint256 _amount) external {\n        require(\n            msg.sender == borrowerOperationsAddress || troveManager[msg.sender],\n            \"DebtToken: Caller is not BorrowerOperations\"\n        );\n        _mint(_account, _amount);\n    }\n\n    function burn(address _account, uint256 _amount) external {\n        require(\n            troveManager[msg.sender],\n            \"Debt: Caller is neither BorrowerOperations nor TroveManager nor StabilityPool\"\n        );\n        _burn(_account, _amount);\n    }\n\n    function sendToSP(address _sender, uint256 _amount) external {\n        require(msg.sender == stabilityPoolAddress, \"Debt: Caller is not the StabilityPool\");\n        _transfer(_sender, msg.sender, _amount);\n    }\n\n    function returnFromPool(address _poolAddress, address _receiver, uint256 _amount) external {\n        require(\n            msg.sender == stabilityPoolAddress || troveManager[msg.sender],\n            \"Debt: Caller is neither TroveManager nor StabilityPool\"\n        );\n        _transfer(_poolAddress, _receiver, _amount);\n    }\n\n    // --- External functions ---\n\n    function transfer(address recipient, uint256 amount) public override(IERC20, ERC20) returns (bool) {\n        _requireValidRecipient(recipient);\n        return super.transfer(recipient, amount);\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override(IERC20, ERC20) returns (bool) {\n        _requireValidRecipient(recipient);\n        return super.transferFrom(sender, recipient, amount);\n    }\n\n    // --- ERC 3156 Functions ---\n\n    /**\n     * @dev Returns the maximum amount of tokens available for loan.\n     * @param token The address of the token that is requested.\n     * @return The amount of token that can be loaned.\n     */\n    function maxFlashLoan(address token) public view returns (uint256) {\n        return token == address(this) ? 2 ** 128 - 1 : 0;\n    }\n\n    /**\n     * @dev Returns the fee applied when doing flash loans. This function calls\n     * the {_flashFee} function which returns the fee applied when doing flash\n     * loans.\n     * @param token The token to be flash loaned.\n     * @param amount The amount of tokens to be loaned.\n     * @return The fees applied to the corresponding flash loan.\n     */\n    function flashFee(address token, uint256 amount) external view returns (uint256) {\n        return token == address(this) ? _flashFee(amount) : 0;\n    }\n\n    /**\n     * @dev Returns the fee applied when doing flash loans. By default this\n     * implementation has 0 fees. This function can be overloaded to make\n     * the flash loan mechanism deflationary.\n     * @param amount The amount of tokens to be loaned.\n     * @return The fees applied to the corresponding flash loan.\n     */\n    function _flashFee(uint256 amount) internal pure returns (uint256) {\n        return (amount * FLASH_LOAN_FEE) / 10000;\n    }\n\n    /**\n     * @dev Performs a flash loan. New tokens are minted and sent to the\n     * `receiver`, who is required to implement the {IERC3156FlashBorrower}\n     * interface. By the end of the flash loan, the receiver is expected to own\n     * amount + fee tokens and have them approved back to the token contract itself so\n     * they can be burned.\n     * @param receiver The receiver of the flash loan. Should implement the\n     * {IERC3156FlashBorrower-onFlashLoan} interface.\n     * @param token The token to be flash loaned. Only `address(this)` is\n     * supported.\n     * @param amount The amount of tokens to be loaned.\n     * @param data An arbitrary datafield that is passed to the receiver.\n     * @return `true` if the flash loan was successful.\n     */\n    // This function can reenter, but it doesn't pose a risk because it always preserves the property that the amount\n    // minted at the beginning is always recovered and burned at the end, or else the entire function will revert.\n    // slither-disable-next-line reentrancy-no-eth\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool) {\n        require(token == address(this), \"ERC20FlashMint: wrong token\");\n        require(amount <= maxFlashLoan(token), \"ERC20FlashMint: amount exceeds maxFlashLoan\");\n        uint256 fee = _flashFee(amount);\n        _mint(address(receiver), amount);\n        require(\n            receiver.onFlashLoan(msg.sender, token, amount, fee, data) == _RETURN_VALUE,\n            \"ERC20FlashMint: invalid return value\"\n        );\n        _spendAllowance(address(receiver), address(this), amount + fee);\n        _burn(address(receiver), amount);\n        _transfer(address(receiver), _prismaCore.feeReceiver(), fee);\n        return true;\n    }\n\n    // --- EIP 2612 Functionality ---\n\n    function domainSeparator() public view returns (bytes32) {\n        if (block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"Debt: expired deadline\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator(),\n                keccak256(abi.encode(permitTypeHash, owner, spender, amount, _nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress == owner, \"Debt: invalid signature\");\n        _approve(owner, spender, amount);\n    }\n\n    function nonces(address owner) external view returns (uint256) {\n        // FOR EIP 2612\n        return _nonces[owner];\n    }\n\n    // --- Internal operations ---\n\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 name_, bytes32 version_) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, name_, version_, block.chainid, address(this)));\n    }\n\n    // --- 'require' functions ---\n\n    function _requireValidRecipient(address _recipient) internal view {\n        require(\n            _recipient != address(0) && _recipient != address(this),\n            \"Debt: Cannot transfer tokens directly to the Debt token contract or the zero address\"\n        );\n        require(\n            _recipient != stabilityPoolAddress && !troveManager[_recipient] && _recipient != borrowerOperationsAddress,\n            \"Debt: Cannot transfer tokens directly to the StabilityPool, TroveManager or BorrowerOps\"\n        );\n    }\n}"
    },
    {
      "filename": "contracts/core/LiquidationManager.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IStabilityPool.sol\";\nimport \"../interfaces/ISortedTroves.sol\";\nimport \"../interfaces/IBorrowerOperations.sol\";\nimport \"../interfaces/ITroveManager.sol\";\nimport \"../dependencies/PrismaMath.sol\";\nimport \"../dependencies/PrismaBase.sol\";\n\n/**\n    @title Prisma Liquidation Manager\n    @notice Based on Liquity's `TroveManager`\n            https://github.com/liquity/dev/blob/main/packages/contracts/contracts/TroveManager.sol\n\n            This contract has a 1:n relationship with `TroveManager`, handling liquidations\n            for every active collateral within the system.\n\n            Anyone can call to liquidate an eligible trove at any time. There is no requirement\n            that liquidations happen in order according to trove ICRs. There are three ways that\n            a liquidation can occur:\n\n            1. ICR <= 100\n               The trove's entire debt and collateral is redistributed between remaining active troves.\n\n            2. 100 < ICR < MCR\n               The trove is liquidated using stability pool deposits. The collateral is distributed\n               amongst stability pool depositors. If the stability pool's balance is insufficient to\n               completely repay the trove, the remaining debt and collateral is redistributed between\n               the remaining active troves.\n\n            3. MCR <= ICR < TCR && TCR < CCR\n               The trove is liquidated using stability pool deposits. Collateral equal to 110% of\n               the value of the debt is distributed between stability pool depositors. The remaining\n               collateral is left claimable by the trove owner.\n */\ncontract LiquidationManager is PrismaBase {\n    IStabilityPool public immutable stabilityPool;\n    IBorrowerOperations public immutable borrowerOperations;\n    address public immutable factory;\n\n    mapping(IERC20 => ITroveManager) internal _trovesContracts;\n\n    /*\n     * --- Variable container structs for liquidations ---\n     *\n     * These structs are used to hold, return and assign variables inside the liquidation functions,\n     * in order to avoid the error: \"CompilerError: Stack too deep\".\n     **/\n\n    struct LiquidationValues {\n        uint256 entireTroveDebt;\n        uint256 entireTroveColl;\n        uint256 collGasCompensation;\n        uint256 debtGasCompensation;\n        uint256 debtToOffset;\n        uint256 collToSendToSP;\n        uint256 debtToRedistribute;\n        uint256 collToRedistribute;\n        uint256 collSurplus;\n    }\n\n    struct LiquidationTotals {\n        uint256 totalCollInSequence;\n        uint256 totalDebtInSequence;\n        uint256 totalCollGasCompensation;\n        uint256 totalDebtGasCompensation;\n        uint256 totalDebtToOffset;\n        uint256 totalCollToSendToSP;\n        uint256 totalDebtToRedistribute;\n        uint256 totalCollToRedistribute;\n        uint256 totalCollSurplus;\n    }\n\n    event TroveUpdated(\n        address indexed _borrower,\n        uint256 _debt,\n        uint256 _coll,\n        uint256 _stake,\n        TroveManagerOperation _operation\n    );\n    event TroveLiquidated(address indexed _borrower, uint256 _debt, uint256 _coll, TroveManagerOperation _operation);\n    event Liquidation(\n        uint256 _liquidatedDebt,\n        uint256 _liquidatedColl,\n        uint256 _collGasCompensation,\n        uint256 _debtGasCompensation\n    );\n    event TroveUpdated(address indexed _borrower, uint256 _debt, uint256 _coll, uint256 stake, uint8 operation);\n    event TroveLiquidated(address indexed _borrower, uint256 _debt, uint256 _coll, uint8 operation);\n\n    enum TroveManagerOperation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        redeemCollateral\n    }\n\n    constructor(\n        IStabilityPool _stabilityPoolAddress,\n        IBorrowerOperations _borrowerOperations,\n        address _factory,\n        uint256 _gasCompensation\n    ) PrismaBase(_gasCompensation) {\n        stabilityPool = _stabilityPoolAddress;\n        borrowerOperations = _borrowerOperations;\n        factory = _factory;\n    }\n\n    function enableCollateral(address _troveManager, IERC20 _collateral) external {\n        require(msg.sender == factory, \"Not factory\");\n        _trovesContracts[_collateral] = ITroveManager(_troveManager);\n    }\n\n    // --- Trove Liquidation functions ---\n\n    /**\n        @notice Liquidate a single trove\n        @dev Reverts if the trove is not active, or cannot be liquidated\n        @param collateral Collateral type to perform liquidation against\n        @param borrower Borrower address to liquidate\n     */\n    function liquidate(IERC20 collateral, address borrower) external {\n        ITroveManager troveManager = _trovesContracts[collateral];\n\n        require(troveManager.getTroveStatus(borrower) == 1, \"TroveManager: Trove does not exist or is closed\");\n\n        address[] memory borrowers = new address[](1);\n        borrowers[0] = borrower;\n        batchLiquidateTroves(collateral, borrowers);\n    }\n\n    /**\n        @notice Liquidate a sequence of troves\n        @dev Iterates through troves starting with the lowest ICR\n        @param collateral Collateral type to perform liquidations against\n        @param maxTrovesToLiquidate The maximum number of troves to liquidate\n        @param maxICR Maximum ICR to liquidate. Should be set to MCR if the system\n                      is not in recovery mode, to minimize gas costs for this call.\n     */\n    function liquidateTroves(IERC20 collateral, uint256 maxTrovesToLiquidate, uint256 maxICR) external {\n        ITroveManager troveManager = _trovesContracts[collateral];\n        troveManager.updateBalances();\n\n        IStabilityPool stabilityPoolCached = stabilityPool;\n        ISortedTroves sortedTrovesCached = ISortedTroves(troveManager.sortedTroves());\n\n        LiquidationValues memory singleLiquidation;\n        LiquidationTotals memory totals;\n\n        uint trovesRemaining = maxTrovesToLiquidate;\n        uint troveCount = troveManager.getTroveOwnersCount();\n        uint price = troveManager.fetchPrice();\n        uint debtInStabPool = stabilityPoolCached.getTotalDebtTokenDeposits();\n        bool sunsetting = troveManager.sunsetting();\n\n        while (trovesRemaining > 0 && troveCount > 1) {\n            address account = sortedTrovesCached.getLast();\n            uint ICR = troveManager.getCurrentICR(account, price);\n            if (ICR > maxICR) {\n                // set to 0 to ensure the next if block evaluates false\n                trovesRemaining = 0;\n                break;\n            }\n            if (ICR <= _100pct) {\n                singleLiquidation = _liquidateWithoutSP(troveManager, account);\n                _applyLiquidationValuesToTotals(totals, singleLiquidation);\n            } else if (ICR < MCR) {\n                singleLiquidation = _liquidateNormalMode(troveManager, account, debtInStabPool, sunsetting);\n                debtInStabPool -= singleLiquidation.debtToOffset;\n                _applyLiquidationValuesToTotals(totals, singleLiquidation);\n            } else break; // break if the loop reaches a Trove with ICR >= MCR\n            unchecked {\n                --trovesRemaining;\n                --troveCount;\n            }\n        }\n        if (trovesRemaining > 0 && !sunsetting && troveCount > 1) {\n            (uint entireSystemColl, uint entireSystemDebt) = borrowerOperations.getGlobalSystemBalances();\n            entireSystemColl -= totals.totalCollToSendToSP * price;\n            entireSystemDebt -= totals.totalDebtToOffset;\n            address nextAccount = sortedTrovesCached.getLast();\n            while (trovesRemaining > 0 && troveCount > 1) {\n                uint ICR = troveManager.getCurrentICR(nextAccount, price);\n                if (ICR > maxICR) break;\n                unchecked {\n                    --trovesRemaining;\n                }\n                address account = nextAccount;\n                nextAccount = sortedTrovesCached.getPrev(account);\n\n                singleLiquidation = _tryLiquidateWithCap(\n                    troveManager,\n                    account,\n                    ICR,\n                    debtInStabPool,\n                    PrismaMath._computeCR(entireSystemColl, entireSystemDebt),\n                    price\n                );\n                if (singleLiquidation.debtToOffset == 0) continue;\n                debtInStabPool -= singleLiquidation.debtToOffset;\n                entireSystemColl -= (singleLiquidation.collToSendToSP + singleLiquidation.collSurplus) * price;\n                entireSystemDebt -= singleLiquidation.debtToOffset;\n                _applyLiquidationValuesToTotals(totals, singleLiquidation);\n                unchecked {\n                    --troveCount;\n                }\n            }\n        }\n\n        require(totals.totalDebtInSequence > 0, \"TroveManager: nothing to liquidate\");\n        if (totals.totalDebtToOffset > 0 || totals.totalCollToSendToSP > 0) {\n            // Move liquidated collateral and Debt to the appropriate pools\n            stabilityPoolCached.offset(address(collateral), totals.totalDebtToOffset, totals.totalCollToSendToSP);\n            troveManager.decreaseDebtAndSendCollateral(\n                address(stabilityPoolCached),\n                totals.totalDebtToOffset,\n                totals.totalCollToSendToSP\n            );\n        }\n        troveManager.finalizeLiquidation(\n            msg.sender,\n            totals.totalDebtToRedistribute,\n            totals.totalCollToRedistribute,\n            totals.totalCollSurplus,\n            totals.totalDebtGasCompensation,\n            totals.totalCollGasCompensation\n        );\n\n        emit Liquidation(\n            totals.totalDebtInSequence,\n            totals.totalCollInSequence - totals.totalCollGasCompensation - totals.totalCollSurplus,\n            totals.totalCollGasCompensation,\n            totals.totalDebtGasCompensation\n        );\n    }\n\n    /**\n        @notice Liquidate a custom list of troves\n        @dev Reverts if there is not a single trove that can be liquidated\n        @param collateral Collateral type to perform liquidations against\n        @param _troveArray List of borrower addresses to liquidate. Troves that were already\n                           liquidated, or cannot be liquidated, are ignored.\n     */\n    /*\n     * Attempt to liquidate a custom list of troves provided by the caller.\n     */\n    function batchLiquidateTroves(IERC20 collateral, address[] memory _troveArray) public {\n        ITroveManager troveManager = _trovesContracts[collateral];\n        require(_troveArray.length != 0, \"TroveManager: Calldata address array must not be empty\");\n        troveManager.updateBalances();\n\n        LiquidationValues memory singleLiquidation;\n        LiquidationTotals memory totals;\n\n        IStabilityPool stabilityPoolCached = stabilityPool;\n        uint debtInStabPool = stabilityPoolCached.getTotalDebtTokenDeposits();\n        uint price = troveManager.fetchPrice();\n        bool sunsetting = troveManager.sunsetting();\n        uint troveCount = troveManager.getTroveOwnersCount();\n        uint length = _troveArray.length;\n        uint troveIter;\n\n        while (troveIter < length && troveCount > 1) {\n            // first iteration round, when all liquidated troves have ICR < MCR we do not need to track TCR\n            address account = _troveArray[troveIter];\n\n            // closed / non-existent troves return an ICR of type(uint).max and are ignored\n            uint ICR = troveManager.getCurrentICR(account, price);\n            if (ICR <= _100pct) {\n                singleLiquidation = _liquidateWithoutSP(troveManager, account);\n            } else if (ICR < MCR) {\n                singleLiquidation = _liquidateNormalMode(troveManager, account, debtInStabPool, sunsetting);\n                debtInStabPool -= singleLiquidation.debtToOffset;\n            } else {\n                // As soon as we find a trove with ICR >= MCR we need to start tracking the global TCR with the next loop\n                break;\n            }\n            _applyLiquidationValuesToTotals(totals, singleLiquidation);\n            unchecked {\n                ++troveIter;\n                --troveCount;\n            }\n        }\n\n        if (troveIter < length && troveCount > 1) {\n            // second iteration round, if we receive a trove with ICR > MCR and need to track TCR\n            (uint256 entireSystemColl, uint256 entireSystemDebt) = borrowerOperations.getGlobalSystemBalances();\n            entireSystemColl -= totals.totalCollToSendToSP * price;\n            entireSystemDebt -= totals.totalDebtToOffset;\n            while (troveIter < length && troveCount > 1) {\n                address account = _troveArray[troveIter];\n                uint ICR = troveManager.getCurrentICR(account, price);\n                unchecked {\n                    ++troveIter;\n                }\n                if (ICR <= _100pct) {\n                    singleLiquidation = _liquidateWithoutSP(troveManager, account);\n                } else if (ICR < MCR) {\n                    singleLiquidation = _liquidateNormalMode(troveManager, account, debtInStabPool, sunsetting);\n                } else {\n                    if (sunsetting) continue;\n                    uint256 TCR = PrismaMath._computeCR(entireSystemColl, entireSystemDebt);\n                    singleLiquidation = _tryLiquidateWithCap(troveManager, account, ICR, debtInStabPool, TCR, price);\n                    if (singleLiquidation.debtToOffset == 0) continue;\n                }\n\n                debtInStabPool -= singleLiquidation.debtToOffset;\n                entireSystemColl -= (singleLiquidation.collToSendToSP + singleLiquidation.collSurplus) * price;\n                entireSystemDebt -= singleLiquidation.debtToOffset;\n                _applyLiquidationValuesToTotals(totals, singleLiquidation);\n                unchecked {\n                    --troveCount;\n                }\n            }\n        }\n\n        require(totals.totalDebtInSequence > 0, \"TroveManager: nothing to liquidate\");\n\n        if (totals.totalDebtToOffset > 0 || totals.totalCollToSendToSP > 0) {\n            // Move liquidated collateral and Debt to the appropriate pools\n            stabilityPoolCached.offset(address(collateral), totals.totalDebtToOffset, totals.totalCollToSendToSP);\n            troveManager.decreaseDebtAndSendCollateral(\n                address(stabilityPoolCached),\n                totals.totalDebtToOffset,\n                totals.totalCollToSendToSP\n            );\n        }\n        troveManager.finalizeLiquidation(\n            msg.sender,\n            totals.totalDebtToRedistribute,\n            totals.totalCollToRedistribute,\n            totals.totalCollSurplus,\n            totals.totalDebtGasCompensation,\n            totals.totalCollGasCompensation\n        );\n\n        emit Liquidation(\n            totals.totalDebtInSequence,\n            totals.totalCollInSequence - totals.totalCollGasCompensation - totals.totalCollSurplus,\n            totals.totalCollGasCompensation,\n            totals.totalDebtGasCompensation\n        );\n    }\n\n    /**\n        @dev Perform a \"normal\" liquidation, where 100% < ICR < 110%. The trove\n             is liquidated as much as possible using the stability pool. Any\n             remaining debt and collateral are redistributed between active troves.\n     */\n    function _liquidateNormalMode(\n        ITroveManager troveManager,\n        address _borrower,\n        uint256 _debtInStabPool,\n        bool sunsetting\n    ) internal returns (LiquidationValues memory singleLiquidation) {\n        uint pendingDebtReward;\n        uint pendingCollReward;\n\n        (\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl,\n            pendingDebtReward,\n            pendingCollReward\n        ) = troveManager.getEntireDebtAndColl(_borrower);\n\n        troveManager.movePendingTroveRewardsToActiveBalances(pendingDebtReward, pendingCollReward);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(singleLiquidation.entireTroveColl);\n        singleLiquidation.debtGasCompensation = DEBT_GAS_COMPENSATION;\n        uint256 collToLiquidate = singleLiquidation.entireTroveColl - singleLiquidation.collGasCompensation;\n\n        (\n            singleLiquidation.debtToOffset,\n            singleLiquidation.collToSendToSP,\n            singleLiquidation.debtToRedistribute,\n            singleLiquidation.collToRedistribute\n        ) = _getOffsetAndRedistributionVals(\n            singleLiquidation.entireTroveDebt,\n            collToLiquidate,\n            _debtInStabPool,\n            sunsetting\n        );\n\n        troveManager.closeTroveByLiquidation(_borrower);\n        emit TroveLiquidated(\n            _borrower,\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl,\n            TroveManagerOperation.liquidateInNormalMode\n        );\n        emit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.liquidateInNormalMode);\n        return singleLiquidation;\n    }\n\n    /**\n        @dev Attempt to liquidate a single trove in recovery mode.\n             If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\n             and there is Debt in the Stability Pool, only offset, with no redistribution,\n             but at a capped rate of 1.1 and only if the whole debt can be liquidated.\n             The remainder due to the capped rate will be claimable as collateral surplus.\n     */\n    function _tryLiquidateWithCap(\n        ITroveManager troveManager,\n        address _borrower,\n        uint _ICR,\n        uint256 _debtInStabPool,\n        uint _TCR,\n        uint256 _price\n    ) internal returns (LiquidationValues memory singleLiquidation) {\n        if ((_ICR >= _TCR) || (_TCR >= CCR)) {\n            // do not liquidate\n            return singleLiquidation;\n        }\n\n        uint entireTroveDebt;\n        uint entireTroveColl;\n        uint pendingDebtReward;\n        uint pendingCollReward;\n\n        (entireTroveDebt, entireTroveColl, pendingDebtReward, pendingCollReward) = troveManager.getEntireDebtAndColl(\n            _borrower\n        );\n\n        if (entireTroveDebt > _debtInStabPool) {\n            // do not liquidate if the entire trove cannot be liquidated via SP\n            return singleLiquidation;\n        }\n\n        troveManager.movePendingTroveRewardsToActiveBalances(pendingDebtReward, pendingCollReward);\n\n        singleLiquidation.entireTroveDebt = entireTroveDebt;\n        singleLiquidation.entireTroveColl = entireTroveColl;\n        uint256 collToOffset = (entireTroveDebt * MCR) / _price;\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(collToOffset);\n        singleLiquidation.debtGasCompensation = DEBT_GAS_COMPENSATION;\n\n        singleLiquidation.debtToOffset = entireTroveDebt;\n        singleLiquidation.collToSendToSP = collToOffset - singleLiquidation.collGasCompensation;\n\n        troveManager.closeTroveByLiquidation(_borrower);\n\n        uint256 collSurplus = entireTroveColl - collToOffset;\n        if (collSurplus > 0) {\n            singleLiquidation.collSurplus = collSurplus;\n            troveManager.addCollateralSurplus(_borrower, collSurplus);\n        }\n\n        emit TroveLiquidated(\n            _borrower,\n            entireTroveDebt,\n            singleLiquidation.collToSendToSP,\n            TroveManagerOperation.liquidateInRecoveryMode\n        );\n        emit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.liquidateInRecoveryMode);\n\n        return singleLiquidation;\n    }\n\n    /**\n        @dev Liquidate a trove without using the stability pool. All debt and collateral\n             are distributed porportionally between the remaining active troves.\n     */\n    function _liquidateWithoutSP(\n        ITroveManager troveManager,\n        address _borrower\n    ) internal returns (LiquidationValues memory singleLiquidation) {\n        uint pendingDebtReward;\n        uint pendingCollReward;\n\n        (\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl,\n            pendingDebtReward,\n            pendingCollReward\n        ) = troveManager.getEntireDebtAndColl(_borrower);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(singleLiquidation.entireTroveColl);\n        singleLiquidation.debtGasCompensation = DEBT_GAS_COMPENSATION;\n        troveManager.movePendingTroveRewardsToActiveBalances(pendingDebtReward, pendingCollReward);\n\n        singleLiquidation.debtToOffset = 0;\n        singleLiquidation.collToSendToSP = 0;\n        singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;\n        singleLiquidation.collToRedistribute =\n            singleLiquidation.entireTroveColl -\n            singleLiquidation.collGasCompensation;\n\n        troveManager.closeTroveByLiquidation(_borrower);\n        emit TroveLiquidated(\n            _borrower,\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl,\n            TroveManagerOperation.liquidateInRecoveryMode\n        );\n        emit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.liquidateInRecoveryMode);\n        return singleLiquidation;\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be\n     * redistributed to active troves.\n     */\n    function _getOffsetAndRedistributionVals(\n        uint256 _debt,\n        uint256 _coll,\n        uint256 _debtInStabPool,\n        bool sunsetting\n    )\n        internal\n        pure\n        returns (uint256 debtToOffset, uint256 collToSendToSP, uint256 debtToRedistribute, uint256 collToRedistribute)\n    {\n        if (_debtInStabPool > 0 && !sunsetting) {\n            /*\n             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n             *"
    }
  ]
}