{
  "Title": "[L-03] Return values of ",
  "Content": "<h2 id=\"l-03-return-values-of-transfertransferfrom-not-checked\" style=\"position:relative;\"><a href=\"#l-03-return-values-of-transfertransferfrom-not-checked\" aria-label=\"l 03 return values of transfertransferfrom not checked permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-03] Return values of <code>transfer()</code>/<code>transferFrom()</code> not checked</h2>\n<p>Not all <code>IERC20</code> implementations <code>revert()</code> when thereâ€™s a failure in <code>transfer()</code>/<code>transferFrom()</code>. The function signature has a <code>boolean</code> return value and they indicate errors that way instead. By not checking the return value, operations that should have marked as failed, may potentially go through without actually making a payment</p>\n<p><em>There are 4 instances of this issue:</em></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"18\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">Basket</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">   #</span><span class=\"mtk7\">1</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">87</span><span class=\"mtk1\">:           </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_token</span><span class=\"mtk1\">).</span><span class=\"mtk11\">transfer</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">, </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_token</span><span class=\"mtk1\">).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">)));</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L87\">https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L87</a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"19\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">Basket</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">   #</span><span class=\"mtk7\">2</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">94</span><span class=\"mtk1\">:               </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_tokens</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">]).</span><span class=\"mtk11\">transfer</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">, </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_tokens</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">]).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">)));</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L94\">https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L94</a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"20\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">NibblVault</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">   #</span><span class=\"mtk7\">3</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">517</span><span class=\"mtk1\">:          </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_asset</span><span class=\"mtk1\">).</span><span class=\"mtk11\">transfer</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_to</span><span class=\"mtk1\">, </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_asset</span><span class=\"mtk1\">).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">)));</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L517\">https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L517</a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"21\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">NibblVault</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">   #</span><span class=\"mtk7\">4</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">526</span><span class=\"mtk1\">:              </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_assets</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">]).</span><span class=\"mtk11\">transfer</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_to</span><span class=\"mtk1\">, </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_assets</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">]).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">)));</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L526\">https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L526</a></p>\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-06-nibbl-contest",
  "Code": [
    {
      "filename": "contracts/Basket.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { ERC721, IERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC165, ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { IBasket } from \"./Interfaces/IBasket.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n/**\n * Mint a single ERC721 which can hold NFTs\n */\ncontract Basket is IBasket, ERC721(\"NFT Basket\", \"NFTB\"), Initializable {\n\n    event DepositERC721(address indexed token, uint256 tokenId, address indexed from);\n    event WithdrawERC721(address indexed token, uint256 tokenId, address indexed to);\n    event DepositERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event DepositERC1155Bulk(address indexed token, uint256[] tokenId, uint256[] amount, address indexed from);\n    event WithdrawERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event WithdrawETH(address indexed who);\n    event WithdrawERC20(address indexed token, address indexed who);\n\n    function initialise(address _curator) external override initializer {\n        _mint(_curator, 0);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, IERC165) returns (bool) {\n        return\n            super.supportsInterface(interfaceId) || interfaceId == type(IBasket).interfaceId;\n    }\n\n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).safeTransferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n\n    function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC721(_tokens[i]).safeTransferFrom(address(this), _to, _tokenId[i]);\n            emit WithdrawERC721(_tokens[i], _tokenId[i], _to);\n        }\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721Unsafe(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).transferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC1155(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        uint256 _balance = IERC1155(_token).balanceOf(address(this),  _tokenId);\n        IERC1155(_token).safeTransferFrom(address(this), _to, _tokenId, _balance, \"0\");\n        emit WithdrawERC1155(_token, _tokenId, _balance, _to);\n    }\n\n    function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 _balance = IERC1155(_tokens[i]).balanceOf(address(this),  _tokenIds[i]);\n            IERC1155(_tokens[i]).safeTransferFrom(address(this), _to, _tokenIds[i], _balance, \"0\");\n            emit WithdrawERC1155(_tokens[i], _tokenIds[i], _balance, _to);\n        }\n    }\n\n    /// @notice withdraw ETH in the case a held NFT earned ETH (ie. euler beats)\n    function withdrawETH(address payable _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        _to.transfer(address(this).balance);\n        emit WithdrawETH(_to);\n    }\n\n    /// @notice withdraw ERC20 in the case a held NFT earned ERC20\n    function withdrawERC20(address _token) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this)));\n        emit WithdrawERC20(_token, msg.sender);\n    }\n\n    function withdrawMultipleERC20(address[] memory _tokens) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC20(_tokens[i]).transfer(msg.sender, IERC20(_tokens[i]).balanceOf(address(this)));\n            emit WithdrawERC20(_tokens[i], msg.sender);\n        }\n    }\n\n    function onERC721Received(address, address from, uint256 id, bytes memory) external override returns(bytes4) {\n        emit DepositERC721(msg.sender, id, from);\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address from, uint256 id, uint256 amount, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155(msg.sender, id, amount, from);\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155Bulk(msg.sender, ids, amounts, from);\n        return this.onERC1155BatchReceived.selector;\n    }\n    \n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/Basket.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { ERC721, IERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC165, ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { IBasket } from \"./Interfaces/IBasket.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n/**\n * Mint a single ERC721 which can hold NFTs\n */\ncontract Basket is IBasket, ERC721(\"NFT Basket\", \"NFTB\"), Initializable {\n\n    event DepositERC721(address indexed token, uint256 tokenId, address indexed from);\n    event WithdrawERC721(address indexed token, uint256 tokenId, address indexed to);\n    event DepositERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event DepositERC1155Bulk(address indexed token, uint256[] tokenId, uint256[] amount, address indexed from);\n    event WithdrawERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event WithdrawETH(address indexed who);\n    event WithdrawERC20(address indexed token, address indexed who);\n\n    function initialise(address _curator) external override initializer {\n        _mint(_curator, 0);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, IERC165) returns (bool) {\n        return\n            super.supportsInterface(interfaceId) || interfaceId == type(IBasket).interfaceId;\n    }\n\n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).safeTransferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n\n    function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC721(_tokens[i]).safeTransferFrom(address(this), _to, _tokenId[i]);\n            emit WithdrawERC721(_tokens[i], _tokenId[i], _to);\n        }\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721Unsafe(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).transferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC1155(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        uint256 _balance = IERC1155(_token).balanceOf(address(this),  _tokenId);\n        IERC1155(_token).safeTransferFrom(address(this), _to, _tokenId, _balance, \"0\");\n        emit WithdrawERC1155(_token, _tokenId, _balance, _to);\n    }\n\n    function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 _balance = IERC1155(_tokens[i]).balanceOf(address(this),  _tokenIds[i]);\n            IERC1155(_tokens[i]).safeTransferFrom(address(this), _to, _tokenIds[i], _balance, \"0\");\n            emit WithdrawERC1155(_tokens[i], _tokenIds[i], _balance, _to);\n        }\n    }\n\n    /// @notice withdraw ETH in the case a held NFT earned ETH (ie. euler beats)\n    function withdrawETH(address payable _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        _to.transfer(address(this).balance);\n        emit WithdrawETH(_to);\n    }\n\n    /// @notice withdraw ERC20 in the case a held NFT earned ERC20\n    function withdrawERC20(address _token) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this)));\n        emit WithdrawERC20(_token, msg.sender);\n    }\n\n    function withdrawMultipleERC20(address[] memory _tokens) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC20(_tokens[i]).transfer(msg.sender, IERC20(_tokens[i]).balanceOf(address(this)));\n            emit WithdrawERC20(_tokens[i], msg.sender);\n        }\n    }\n\n    function onERC721Received(address, address from, uint256 id, bytes memory) external override returns(bytes4) {\n        emit DepositERC721(msg.sender, id, from);\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address from, uint256 id, uint256 amount, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155(msg.sender, id, amount, from);\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155Bulk(msg.sender, ids, amounts, from);\n        return this.onERC1155BatchReceived.selector;\n    }\n    \n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/NibblVault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\n\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { BancorFormula } from \"./Bancor/BancorFormula.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { NibblVaultFactory } from \"./NibblVaultFactory.sol\";\nimport { Twav } from \"./Twav/Twav.sol\";\nimport { EIP712Base } from \"./Utilities/EIP712Base.sol\";\nimport { INibblVault } from \"./Interfaces/INibblVault.sol\";\n\n/// @title Vault to lock NFTs and fractionalize ERC721 to ERC20.\n/// @dev This contract uses Bancor Formula to create an automated market for fractionalized ERC20s.\n/// @dev This contract creates 2 bonding curves, referred to as primary curve and secondary curve.\n/// @dev The primary curve has fixed specifications and reserveRatio.\n/// @dev The secondary curve is dynamic and has a variable reserveRatio, which depends on initial conditions given by the curator and the fee accumulated by the curve.\ncontract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base {\n\n    /// @notice Scale for calculations to avoid rounding errors\n    uint256 private constant SCALE = 1_000_000; \n\n    /// @notice Reserve ratio of primary curve \n    /// @dev primaryReserveRatio has been multiplied with SCALE\n    /// @dev primaryReserveRatio lies between 0 and 1_000_000, 500_000 is equivalent to 50% reserve ratio\n    uint32 private constant primaryReserveRatio = 200_000; //20%\n    \n    /// @notice The premium percentage above the buyoutBid at which the buyout is rejected\n    /// @dev REJECTION_PREMIUM has been multiplied with SCALE\n    /// @dev REJECTION_PREMIUM lies between 0 and 1_000_000, i.e. 100_000 means 10%\n    /// @dev if REJECTION_PREMIUM is 15% and the buyoutBid is 100, then the buyout is rejected when the valuation reaches 115\n    uint256 private constant REJECTION_PREMIUM = 150_000; //15%\n\n    /// @notice The days until which a buyout bid is valid, if the bid isn't rejected in buyout duration time, its automatically considered boughtOut\n    uint256 private constant BUYOUT_DURATION = 5 days; \n\n    /// @notice The percentage of fee that goes for liquidity in lower curve until its reserve ratio becomes equal to primaryReserveRatio\n    uint256 private constant CURVE_FEE = 4_000;\n\n    /// @notice minimum reserve ratio that the secondary curve can have initially \n    uint256 private constant MIN_SECONDARY_RESERVE_RATIO = 50_000;\n\n    /// @notice minimum curator fee that the curator will get on adding minimal liquidity to the secondary curve\n    uint256 private constant MIN_CURATOR_FEE = 5_000; //0.5%\n\n    /// @notice minimum reserve balance that the secondary curve can have initially \n    uint256 private constant MIN_SECONDARY_RESERVE_BALANCE = 1e9;\n\n    bytes32 private constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n\n    /// @notice The reserve ratio of the secondary curve.\n    /// @dev secondaryReserveRatio has been multiplied with SCALE\n    /// @dev secondary reserve ratio is dynamic and it can be <= primaryReserveRatio\n    uint32 public secondaryReserveRatio;\n\n    /// @notice address of the factory contract\n    address payable public factory;\n\n    /// @notice address of the original NFT owner\n    address public curator; \n\n    /// @notice token address of the NFT being deposited in the vault\n    address public assetAddress;\n\n    /// @notice token ID of the NFT being deposited in the vault  \n    uint256 public assetID;\n\n    /// @notice address which triggered the buyout\n    address public bidder; \n\n    /// @notice initial price of the fractional ERC20 Token set by the curator\n    uint256 public initialTokenPrice;\n\n    /// @notice fictitious primary reserve balance, this is used for calculation purposes of trading on primary bonding curve.\n    /// @dev This variable defines the amount of reserve token that should be in the secondary curve if secondaryReserveRatio == primaryReserveRatio\n    /// @dev This variable also defines the amount of reserve token that should be in the primary curve if the primary curve started from 0 and went till initialTokenSupply \n    uint256 public fictitiousPrimaryReserveBalance;\n\n    /// @notice the valuation at which the buyout is rejected.\n    uint256 public buyoutRejectionValuation; \n    \n    /// @notice deposit made by bidder to initiate buyout \n    /// @dev buyoutValuationDeposit = currentValuation - ((reserveTokens in primary curve) + (reserveTokens in secondary curve))\n    uint256 public buyoutValuationDeposit; \n    \n    /// @notice initial token supply minted by curator\n    uint256 public initialTokenSupply; \n    \n    /// @notice reserve balance of the primary curve\n    uint256 public primaryReserveBalance;\n    \n    /// @notice reserve balance of the secondary curve\n    uint256 public secondaryReserveBalance;\n    \n    /// @notice total value of unclaimed fees accrued to the curator via trading on the bonding curve\n    uint256 public feeAccruedCurator; \n    \n    /// @notice the time at which the current buyout ends\n    uint256 public buyoutEndTime; \n    \n    /// @notice valuation at which the buyout was triggered\n    uint256 public buyoutBid;\n\n    /// @notice percentage of trading fee on the bonding curve that goes to the curator\n    uint256 public curatorFee;\n\n    /// @notice total value of unclaimed buyout bids\n    uint256 public totalUnsettledBids; \n\n    /// @notice minimum time after which buyout can be triggered\n    uint256 public minBuyoutTime;\n\n    /// @notice mapping of buyout bidders and their respective unsettled bids\n    mapping(address => uint256) public unsettledBids; \n    mapping(address => uint256) public nonces; \n    \n    enum Status {initialized, buyout}\n\n    ///@notice current status of vault\n    Status public status;\n\n    ///@notice reenterancy guard\n    uint256 private unlocked = 2;\n\n    modifier lock() {\n        require(unlocked == 1, 'NibblVault: LOCKED');\n        unlocked = 2;\n        _;\n        unlocked = 1;\n    }\n\n\n    /// @notice To check if buyout hasn't succeeded\n    /// @dev Check for the case when buyoutTime has not passed or buyout has been rejected\n    modifier notBoughtOut() {\n        require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out');\n        _;\n    }\n\n    /// @notice To check if buyout has succeeded\n    /// @dev For the case when buyoutTime has passed and buyout has not been rejected\n    modifier boughtOut() {\n        require(status == Status.buyout, \"NibblVault: status != buyout\");\n        require(buyoutEndTime <= block.timestamp, \"NibblVault: buyoutEndTime <= now\");\n        _;\n    }\n\n    /// @notice To check if system isn't paused\n    /// @dev pausablity implemented in factory\n    modifier whenNotPaused() {\n        require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused');\n        _;\n    }\n\n    /// @notice the function to initialize proxy vault parameters\n    /// @param _tokenName name of the fractionalized ERC20 token to be created\n    /// @param _tokenSymbol symbol of the fractionalized ERC20 token\n    /// @param _assetAddress address of the ERC721 being fractionalized\n    /// @param _assetID tokenId of the ERC721 being fractionalized\n    /// @param _curator owner of the asset getting fractionalized\n    /// @param _initialTokenSupply desired initial supply to be minted to curator\n    /// @param _initialTokenPrice desired initial token price set by curator \n    /// @param  _minBuyoutTime minimum time after which buyout can be triggered \n    /// @dev valuation = price * supply\n    /// @dev reserveBalance = valuation * reserveRatio\n    /// @dev Reserve Ratio = Reserve Token Balance / (Continuous Token Supply x Continuous Token Price)\n    /// @dev curatorFee is proportional to initialLiquidity added by user. \n    /// @dev curatorFee can be maximum of 2 * MinimumCuratorFee.\n\n    function initialize(\n        string memory _tokenName, \n        string memory _tokenSymbol, \n        address _assetAddress,\n        uint256 _assetID,\n        address _curator,\n        uint256 _initialTokenSupply,\n        uint256 _initialTokenPrice,\n        uint256 _minBuyoutTime\n    ) external override initializer payable {\n        uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));\n        require(_secondaryReserveRatio <= primaryReserveRatio, \"NibblVault: Excess initial funds\");\n        require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, \"NibblVault: secResRatio too low\");\n        INIT_EIP712(\"NibblVault\", \"1\");\n        __ERC20_init(_tokenName, _tokenSymbol);\n        unlocked = 1;\n        initialTokenPrice=_initialTokenPrice;\n        factory = payable(msg.sender);\n        assetAddress = _assetAddress;\n        assetID = _assetID;\n        curator = _curator;\n        initialTokenSupply = _initialTokenSupply;\n        uint _primaryReserveBalance = (primaryReserveRatio * _initialTokenSupply * _initialTokenPrice) / (SCALE * 1e18);\n        primaryReserveBalance = _primaryReserveBalance;\n        fictitiousPrimaryReserveBalance = _primaryReserveBalance;\n        secondaryReserveBalance = msg.value;\n        secondaryReserveRatio = _secondaryReserveRatio;\n        //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n        curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n        minBuyoutTime = _minBuyoutTime;\n        _mint(_curator, _initialTokenSupply);\n    }\n\n    /// @notice Function used to charge fee on trades\n    /// @dev There are 3 different fees charged - admin, curator and curve\n    /// @dev Admin fee percentage is fetched from the factory contract and the fee charged is transferred to factory contract\n    /// @dev Curator fee is fetched from curatorFee variable and total fee accrued is stored in feeAccruedCurator variable\n    /// @dev Curve fee is fetched from the CURVE_FEE variable and is added to the secondaryReserveBalance variable\n    /// @param _amount amount to charge fee on either a buy or sell order, fee is charged in reserve token\n    /// @return the amount after fee is deducted\n    function _chargeFee(uint256 _amount) private returns(uint256) {\n        address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        uint256 _feeCurve = (_amount * CURVE_FEE) / SCALE ;\n        feeAccruedCurator += _feeCurator;\n        //_maxSecondaryBalanceIncrease: is the max amount of secondary reserve balance that can be added to the vault\n        //_maxSecondaryBalanceIncrease cannot be more than fictitiousPrimaryReserveBalance\n        uint256 _maxSecondaryBalanceIncrease = fictitiousPrimaryReserveBalance - secondaryReserveBalance;\n        // _feeCurve can't be higher than _maxSecondaryBalanceIncrease\n        _feeCurve = _maxSecondaryBalanceIncrease > _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance\n        secondaryReserveBalance += _feeCurve;\n        secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade \n        if(_adminFeeAmt > 0) {\n            safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n        }\n        return _amount - (_feeAdmin + _feeCurator + _feeCurve);\n    }\n\n    /// @notice Function to charge fee in secondary curve\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @param _amount amount to charge fee on trade order, fee is charged in reserve token\n    /// @return amount of tokens after fee is deducted\n    function _chargeFeeSecondaryCurve(uint256 _amount) private returns(uint256) {\n       address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        feeAccruedCurator += _feeCurator;\n        if(_adminFeeAmt > 0) {\n            safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n        }\n        return _amount - (_feeAdmin + _feeCurator);\n    }\n\n    /// @notice Maximum number of reserve tokens that can be held on SecondaryCurve at current secondary reserve ratio\n    /// @dev The max continous tokens on SecondaryCurve is equal to initialTokenSupply\n    /// @dev Reserve Token Balance = Reserve Ratio * (Continuous Token Supply x Continuous Token Price)\n    function getMaxSecondaryCurveBalance() private view returns(uint256){\n            return ((secondaryReserveRatio * initialTokenSupply * initialTokenPrice) / (1e18 * SCALE));\n    }\n\n    /// @notice gives current valuation of the system\n    /// @dev valuation = price * supply\n    /// @dev fictitiousPrimaryReserveBalance doesn't denote any actual reserve balance its just for calculation purpose\n    /// @dev Actual reserve balance in primary curve = primaryReserveBalance - fictitiousPrimaryReserveBalance\n    /// @dev Total reserve balance = Actual reserve balance in primary curve + secondaryReserveBalance\n    /// @dev Total reserve balance = (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance\n    /// @dev Valuation = (Continuous Token Supply x Continuous Token Price) = Reserve Token Balance / Reserve Ratio\n    /// @dev Valuation = If current supply is on seconday curve we use secondaryReserveBalance and secondaryReserveRatio to calculate valuation else we use primary reserve ratio and balance\n    /// @return Current valuation of the system\n    function getCurrentValuation() private view returns(uint256) {\n            return totalSupply() < initialTokenSupply ? (secondaryReserveBalance * SCALE /secondaryReserveRatio) : ((primaryReserveBalance) * SCALE  / primaryReserveRatio);\n    }\n\n    /// @notice function to buy tokens on the primary curve\n    /// @param _amount amount of reserve tokens to buy continous tokens\n    /// @dev This is executed when current supply >= initial supply\n    /// @dev _amount is charged with fee\n    /// @dev _purchaseReturn is minted to _to\n    /// @return _purchaseReturn Purchase return\n    function _buyPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {\n        uint256 _amountIn = _chargeFee(_amount);\n        uint256 _primaryReserveBalance = primaryReserveBalance;\n        _purchaseReturn = _calculatePurchaseReturn(_totalSupply, _primaryReserveBalance, primaryReserveRatio, _amountIn);\n        primaryReserveBalance = _primaryReserveBalance + _amountIn;\n    }\n    /// @notice function to buy tokens on secondary curve\n    /// @param _amount amount of reserve tokens to buy continous tokens\n    /// @dev This is executed when current supply < initial supply\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @dev _purchaseReturn is minted to _to\n    /// @return _purchaseReturn Purchase return\n    function _buySecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {\n        uint256 _amountIn = _chargeFeeSecondaryCurve(_amount);\n        uint _secondaryReserveBalance = secondaryReserveBalance;\n        _purchaseReturn = _calculatePurchaseReturn(_totalSupply, _secondaryReserveBalance, secondaryReserveRatio, _amountIn);\n        secondaryReserveBalance = _secondaryReserveBalance + _amountIn;\n    }\n\n    /// @notice The function to buy fractional tokens for reserveTokens\n    /// @dev TWAV is updated only if buyout is active and only on first buy or sell txs of block.\n    /// @dev It internally calls _buyPrimaryCurve or _buySecondaryCurve or both depending on the buyAmount and current supply\n    /// @dev if current totalSupply < initialTokenSupply AND _amount to buy tokens for is greater than (maxSecondaryCurveBalance - currentSecondaryCurveBalance) then buy happens on secondary curve and primary curve both\n    /// @param _minAmtOut Minimum amount of continuous token user receives, else the tx fails.\n    /// @param _to Address to mint the purchase return to\n    function buy(uint256 _minAmtOut, address _to) external override payable notBoughtOut lock whenNotPaused returns(uint256 _purchaseReturn) {\n        //Make update on the first tx of the block\n        if (status == Status.buyout) {\n            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n            if (_blockTimestamp != lastBlockTimeStamp) {\n                _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n                _rejectBuyout();\n            }\n        }\n        uint256 _initialTokenSupply = initialTokenSupply;\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply >= _initialTokenSupply) {\n            _purchaseReturn = _buyPrimaryCurve(msg.value, _totalSupply);\n        } else {\n            uint256 _lowerCurveDiff = getMaxSecondaryCurveBalance() - secondaryReserveBalance;\n            if (_lowerCurveDiff >= msg.value) {\n                _purchaseReturn = _buySecondaryCurve(msg.value, _totalSupply);\n            } else {\n                //Gas Optimization\n                _purchaseReturn = _initialTokenSupply - _totalSupply;\n                secondaryReserveBalance += _lowerCurveDiff;\n                // _purchaseReturn = _buySecondaryCurve(_to, _lowerCurveDiff);\n                _purchaseReturn += _buyPrimaryCurve(msg.value - _lowerCurveDiff, _totalSupply + _purchaseReturn);\n            } \n        }\n        require(_minAmtOut <= _purchaseReturn, \"NibblVault: Return too low\");\n        _mint(_to, _purchaseReturn);\n        emit Buy(msg.sender, _purchaseReturn, msg.value);\n    }\n\n    /// @notice The function to sell fractional tokens on primary curve\n    /// @dev Executed when currentSupply > initialSupply\n    /// @dev _amount is charged with fee\n    /// @param _amount Amount of tokens to be sold on primary curve\n    /// @return _saleReturn Sale Return\n    function _sellPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn) {\n        uint _primaryReserveBalance = primaryReserveBalance;\n        _saleReturn = _calculateSaleReturn(_totalSupply, _primaryReserveBalance, primaryReserveRatio, _amount);\n        primaryReserveBalance = _primaryReserveBalance - _saleReturn;\n        _saleReturn = _chargeFee(_saleReturn);\n    }\n\n    /// @notice The function to sell fractional tokens on secondary curve\n    /// @dev Executed when current supply <= initial supply\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @param _amount Amount of tokens to be sold on SecondaryCurve\n    ///  @return _saleReturn Sale Return\n    function _sellSecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn){\n        uint _secondaryReserveBalance = secondaryReserveBalance;\n        _saleReturn = _calculateSaleReturn(_totalSupply, _secondaryReserveBalance, secondaryReserveRatio, _amount);\n        secondaryReserveBalance = _secondaryReserveBalance - _saleReturn;\n        require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, \"NibblVault: Excess sell\");\n        _saleReturn = _chargeFeeSecondaryCurve(_saleReturn);\n    }\n\n    /// @notice The function to sell fractional tokens for reserve token\n    /// @dev TWAV is updated only if buyout is active and only on first buy or sell txs of block.\n    /// @dev internally calls _sellPrimaryCurve or _sellSecondaryCurve or both depending on the sellAmount and current supply\n    /// @dev if totalSupply > initialTokenSupply AND _amount to sell is greater than (_amtIn > totalSupply - initialTokenSupply) then sell happens on primary curve and secondary curve both\n    /// @param _amtIn Continous Tokens to be sold\n    /// @param _minAmtOut Minimum amount of reserve token user receives, else the tx fails.\n    /// @param _to Address to recieve the reserve token to\n    function sell(uint256 _amtIn, uint256 _minAmtOut, address payable _to) external override notBoughtOut whenNotPaused ret"
    }
  ]
}