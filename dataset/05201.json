{
  "Title": "[M-10] A huge loss of funds for all the users who try to remove liquidity after swapping got disabled at manipulated price.",
  "Content": "\n<https://github.com/code-423n4/2024-02-hydradx/blob/603187123a20e0cb8a7ea85c6a6d718429caad8d/HydraDX-node/pallets/omnipool/src/lib.rs#L1330-L1360><br>\n<https://github.com/code-423n4/2024-02-hydradx/blob/603187123a20e0cb8a7ea85c6a6d718429caad8d/HydraDX-node/pallets/omnipool/src/lib.rs#L759-L764>\n\n### Impact\n\nThis vulnerability will lead to huge loss of funds for liquidity providers that want to withdraw their liquidity if the safe withdrawal is enabled. The loss of funds can be 100% of the liquidity provider's shares.\n\n### Proof of Concept\n\n**Normal Scenario of manipulating price and disabling removing or adding liquidity:**\n\nIf the price of certain asset got manipulated, there is an ensure function exist in the `remove_liquidity()` and `add_liquidity()`, so the function should revert in case of the price of an asset got manipulated.\n\n```rust\n                        T::PriceBarrier::ensure_price(\n                                &who,\n                                T::HubAssetId::get(),\n                                asset,\n                                EmaPrice::new(asset_state.hub_reserve, asset_state.reserve),\n                        )\n                        .map_err(|_| Error::<T>::PriceDifferenceTooHigh)?;\n```\n\nThis `ensure_price()` function checks that the difference between spot price and oracle price is not too high, so it has critical role to prevent the profitability from this manipulation.\n\nThere is also another security parameter which is the Tradability state which can prevent removing or adding liquidity. There is also `withdrawal_fee`, which is used to make manipulating price not profitable, and it can prevent the attacker from getting any of assets if the price difference is too high.\n\n**Important assumption:**\n\nThe assumption is that the withdrawal can be done safely without checking the price difference because the swapping of this asset got disabled so the price is stable, as shown [here](https://github.com/code-423n4/2024-02-hydradx/blob/603187123a20e0cb8a7ea85c6a6d718429caad8d/HydraDX-node/pallets/omnipool/src/lib.rs#L743).\n\n```rust\n                        let safe_withdrawal = asset_state.tradable.is_safe_withdrawal();\n\n        pub(crate) fn is_safe_withdrawal(&self) -> bool {\n                *self == Tradability::ADD_LIQUIDITY | Tradability::REMOVE_LIQUIDITY || *self == Tradability::REMOVE_LIQUIDITY\n        }\n}\n```\n\n**Edge case:**\n\nDue to the fact that there is not limitation on setting tradability states to any asset except the `hub_asset`, the tradability state can be set to prevent swapping on asset at manipulated price, by making the tradability state only contain `remove` and `add` liquidity flags, when the difference between spot price and the oracle price is too high.\n\nIn such cases, the `remove_liquidity()` function will not revert with price error because the function `ensure-price()` will not work, but it will pass and the `withdrawal_fee` will be equal to 1. So 100% of the liquidity to be removed will be taken from the user as fees and will be distributed on the other liquidity providers.\n\n**How this vulnerability can be applied:**\n\n1. The price of asset got manipulated and the difference between spot and oracle price is too high.\n2. The tradability state of the asset has been set to `remove` and `add` liquidity only (`buying` and `selling` are disabled).\n3. Any user trying to remove his liquidity will be taken as fees and there is no asset will be transferred to the user and the transaction will not revert, since there is no slippage (safety) parameter that can be set by the user to ensure that amount comes from this transaction is equal to what is expected.\n\nThe normal scenario here is that the `remove_liquidity` function should revert instead of taking all user assets as `withdrawal_fee`.\n\nThe code that calculates the withdrawal fee is:\n\n```rust\npub fn calculate_withdrawal_fee(\n        spot_price: FixedU128,\n        oracle_price: FixedU128,\n        min_withdrawal_fee: Permill,\n) -> FixedU128 {\n        let price_diff = if oracle_price <= spot_price {\n                spot_price.saturating_sub(oracle_price)\n        } else {\n                oracle_price.saturating_sub(spot_price)\n        };\n\n\n        let min_fee: FixedU128 = min_withdrawal_fee.into();\n        debug_assert!(min_fee <= FixedU128::one());\n\n\n        if oracle_price.is_zero() {\n                return min_fee;\n        }\n\n        // fee can be set to 100% \n  ->    price_diff.div(oracle_price).clamp(min_fee, FixedU128::one())\n}\n```\n\nThe delta assets that send to the user will be zero in case that `withdrawal_fee` is 1.\n\n```rust\n        // fee_complement = 0 ; \n        let fee_complement = FixedU128::one().saturating_sub(withdrawal_fee);\n\n\n        // Apply withdrawal fee\n        let delta_reserve = fee_complement.checked_mul_int(delta_reserve)?;\n        let delta_hub_reserve = fee_complement.checked_mul_int(delta_hub_reserve)?;\n        let hub_transferred = fee_complement.checked_mul_int(hub_transferred)?;\n\n\n        let delta_imbalance = calculate_delta_imbalance(delta_hub_reserve, imbalance, total_hub_reserve)?; \n```\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nThis vulnerability can be mitigated by only one step:\n\nCheck that the price is in the allowed `Range` before disabling the swapping and allow `remove` and `add` liquidity on any asset. This mitigation will make sure that the `safe_withdrawal` is set to true, except if the price in the `Range` so the price is actually stable and safe to withdraw liquidity on this price.\n\n<https://github.com/code-423n4/2024-02-hydradx/blob/603187123a20e0cb8a7ea85c6a6d718429caad8d/HydraDX-node/pallets/omnipool/src/lib.rs#L1330-L1361>\n\nConsider modifying `set_asset_tradable_state()` function to ensure that if the state is set to preventing swapping, then ensure the price:\n\n```rust\n                pub fn set_asset_tradable_state(\n                        origin: OriginFor<T>,\n                        asset_id: T::AssetId,\n                        state: Tradability,\n                ) -> DispatchResult {\n                        T::TechnicalOrigin::ensure_origin(origin)?;\n\n\n                        if asset_id == T::HubAssetId::get() {\n                                // At the moment, omnipool does not allow adding/removing liquidity of hub asset.\n                                // Although BUY is not supported yet, we can allow the new state to be set to SELL/BUY.\n                                ensure!(\n                                        !state.contains(Tradability::ADD_LIQUIDITY) && !state.contains(Tradability::REMOVE_LIQUIDITY),\n                                        Error::<T>::InvalidHubAssetTradableState\n                                );\n\n\n                                HubAssetTradability::<T>::mutate(|value| -> DispatchResult {\n                                        *value = state;\n                                        Self::deposit_event(Event::TradableStateUpdated { asset_id, state });\n                                        Ok(())\n                                })\n                        } else {\n\n                                Assets::<T>::try_mutate(asset_id, |maybe_asset| -> DispatchResult {\n                                        let asset_state = maybe_asset.as_mut().ok_or(Error::<T>::AssetNotFound)?;\n+ if (state == Tradability::ADD_LIQUIDITY | Tradability::REMOVE_LIQUIDITY || state == Tradability::REMOVE_LIQUIDITY){\n+\n+      T::PriceBarrier::ensure_price(\n+\t\t\t\t\t&who,\n+\t\t\t\t\tT::HubAssetId::get(),\n+\t\t\t\t\tasset_id,\n+\t\t\t\t\tEmaPrice::new(asset_state.hub_reserve, asset_state.reserve),\n+\t\t\t\t)\n+\t\t\t\t.map_err(|_| Error::<T>::PriceDifferenceTooHigh)?;}\n\n                                        asset_state.tradable = state;\n                                        Self::deposit_event(Event::TradableStateUpdated { asset_id, state });\n\n\n                                        Ok(())\n                                })\n                        }\n                }\n```\n\n### Assessed type\n\nInvalid Validation\n\n**[Lambda (judge) decreased severity to Low and commented](https://github.com/code-423n4/2024-02-hydradx-findings/issues/22#issuecomment-1985621735):**\n > Intended behaviour/design that this check is not performed in this state which can only be set by the `AuthorityOrigin`, downgrading to QA.\n\n**[castle_chain (warden) commented](https://github.com/code-423n4/2024-02-hydradx-findings/issues/22#issuecomment-1993479372):**\n > @Lambda,\n> 1. This finding points to the vulnerable function `set_asset_tradable_state`, because it does not check that the price of the oracle is not too far from the spot price before activate the `safe mode` so it can be front-run by attackers. \n> 2. The impact of the 100% of the liquidity withdrawn by the user will be taken as the `withdrawal_fee`, the impact of the Issue [#93](https://github.com/code-423n4/2024-02-hydradx-findings/issues/93) is just a 1% due to the absence of the slippage parameter. \n\n**[Lambda (judge) increased severity to Medium and commented](https://github.com/code-423n4/2024-02-hydradx-findings/issues/22#issuecomment-1998469201):**\n> The issue demonstrates that there can be edge cases where a very high fee is charged, therefore, upgrading it to a medium.\n\n**[enthusiastmartin (HydraDX) acknowledged](https://github.com/code-423n4/2024-02-hydradx-findings/issues/22#issuecomment-2034435094)**\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2024-02-hydradx-findings/issues/22).*\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-hydradx",
  "Code": [
    {
      "filename": "HydraDX-node/pallets/omnipool/src/lib.rs",
      "content": "// Copyright (C) 2020-2022  Intergalactic, Limited (GIB).\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! # Omnipool pallet\n//!\n//! Omnipool implementation\n//!\n//! ## Overview\n//!\n//! Omnipool is type of AMM where all assets are pooled together into one single pool.\n//!\n//! Each asset is internally paired with so called Hub Asset ( LRNA ). When a liquidity is provided, corresponding\n//! amount of hub asset is minted. When a liquidity is removed, corresponding amount of hub asset is burned.\n//!\n//! Liquidity provider can provide any asset of their choice to the Omnipool and in return\n//! they will receive pool shares for this single asset.\n//!\n//! The position is represented as a NFT token which stores the amount of shares distributed\n//! and the price of the asset at the time of provision.\n//!\n//! For traders this means that they can benefit from non-fragmented liquidity.\n//! They can send any token to the pool using the swap mechanism\n//! and in return they will receive the token of their choice in the appropriate quantity.\n//!\n//! Omnipool is implemented with concrete Balance type: u128.\n//!\n//! ### Imbalance mechanism\n//! The Imbalance mechanism is designed to stabilize the value of LRNA. By design it is a weak and passive mechanism,\n//! and is specifically meant to deal with one cause of LRNA volatility: LRNA being sold back to the pool.\n//!\n//! Imbalance is always negative, internally represented by a special type `SimpleImbalance` which uses unsigned integer and boolean flag.\n//! This was done initially because of the intention that in future imbalance can also become positive.\n//!\n//! ### Omnipool Hooks\n//!\n//! Omnipool pallet supports multiple hooks which are triggerred on certain operations:\n//! - on_liquidity_changed - called when liquidity is added or removed from the pool\n//! - on_trade - called when trade is executed\n//! - on_trade_fee - called after successful trade with fee amount that can be taken out of the pool if needed.\n//!\n//! This is currently used to update on-chain oracle and in the circuit breaker.\n//!\n//! ## Terminology\n//!\n//! * **LP:**  liquidity provider\n//! * **Position:**  a moment when LP added liquidity to the pool. It stores amount,shares and price at the time\n//!  of provision\n//! * **Hub Asset:** dedicated 'hub' token for trade executions (LRNA)\n//! * **Native Asset:** governance token\n//! * **Imbalance:** Tracking of hub asset imbalance.\n//!\n//! ## Assumptions\n//!\n//! Below are assumptions that must be held when using this pallet.\n//!\n//! * Initial liquidity of new token being added to Omnipool must be transferred manually to pool account prior to calling add_token.\n//! * All tokens added to the pool must be first registered in Asset Registry.\n//!\n//! ## Interface\n//!\n//! ### Dispatchable Functions\n//!\n//! * `add_token` - Adds token to the pool. Initial liquidity must be transffered to pool account prior to calling add_token.\n//! * `add_liquidity` - Adds liquidity of selected asset to the pool. Mints corresponding position NFT.\n//! * `remove_liquidity` - Removes liquidity of selected position from the pool. Partial withdrawals are allowed.\n//! * `sell` - Trades an asset in for asset out by selling given amount of asset in.\n//! * `buy` - Trades an asset in for asset out by buying given amount of asset out.\n//! * `set_asset_tradable_state` - Updates asset's tradable state with new flags. This allows/forbids asset operation such SELL,BUY,ADD or  REMOVE liquidtityy.\n//! * `refund_refused_asset` - Refunds the initial liquidity amount sent to pool account prior to add_token if the token has been refused to be added.\n//! * `sacrifice_position` - Destroys a position and position's shares become protocol's shares.\n//! * `withdraw_protocol_liquidity` - Withdraws protocol's liquidity from the pool. Used to withdraw liquidity from sacrificed position.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse frame_support::pallet_prelude::{DispatchResult, Get};\nuse frame_support::require_transactional;\nuse frame_support::PalletId;\nuse frame_support::{ensure, transactional};\nuse sp_runtime::traits::{AccountIdConversion, AtLeast32BitUnsigned, One};\nuse sp_runtime::traits::{CheckedAdd, CheckedSub, Zero};\nuse sp_std::ops::{Add, Sub};\nuse sp_std::prelude::*;\n\nuse frame_support::traits::tokens::nonfungibles::{Create, Inspect, Mutate};\nuse hydra_dx_math::omnipool::types::{AssetStateChange, BalanceUpdate, I129};\nuse hydradx_traits::Registry;\nuse orml_traits::{GetByKey, MultiCurrency};\nuse scale_info::TypeInfo;\nuse sp_runtime::{ArithmeticError, DispatchError, FixedPointNumber, FixedU128, Permill};\n\n#[cfg(test)]\nmod tests;\n\npub mod provider;\npub mod router_execution;\npub mod traits;\npub mod types;\npub mod weights;\n\nuse crate::traits::{AssetInfo, OmnipoolHooks};\nuse crate::types::{AssetReserveState, AssetState, Balance, Position, SimpleImbalance, Tradability};\npub use pallet::*;\npub use weights::WeightInfo;\n\n/// NFT class id type of provided nft implementation\npub type NFTCollectionIdOf<T> =\n\t<<T as Config>::NFTHandler as Inspect<<T as frame_system::Config>::AccountId>>::CollectionId;\n\n#[frame_support::pallet]\npub mod pallet {\n\tuse super::*;\n\tuse crate::traits::{AssetInfo, ExternalPriceProvider, OmnipoolHooks, ShouldAllow};\n\tuse crate::types::{Position, Price, Tradability};\n\tuse codec::HasCompact;\n\tuse frame_support::pallet_prelude::*;\n\tuse frame_support::traits::DefensiveOption;\n\tuse frame_system::pallet_prelude::*;\n\tuse hydra_dx_math::ema::EmaPrice;\n\tuse hydra_dx_math::omnipool::types::{BalanceUpdate, I129};\n\tuse orml_traits::GetByKey;\n\tuse sp_runtime::ArithmeticError;\n\n\t#[pallet::pallet]\n\tpub struct Pallet<T>(_);\n\n\t#[pallet::config]\n\tpub trait Config: frame_system::Config {\n\t\t/// The overarching event type.\n\t\ttype RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;\n\n\t\t/// Asset type.\n\t\ttype AssetId: Member\n\t\t\t+ Parameter\n\t\t\t+ Default\n\t\t\t+ Copy\n\t\t\t+ HasCompact\n\t\t\t+ MaybeSerializeDeserialize\n\t\t\t+ MaxEncodedLen\n\t\t\t+ TypeInfo;\n\n\t\t/// Multi currency mechanism\n\t\ttype Currency: MultiCurrency<Self::AccountId, CurrencyId = Self::AssetId, Balance = Balance>;\n\n\t\t/// Origin that can add token, refund refused asset and withdraw protocol liquidity.\n\t\ttype AuthorityOrigin: EnsureOrigin<Self::RuntimeOrigin>;\n\n\t\t/// Origin that can change asset's tradability and weight.\n\t\ttype TechnicalOrigin: EnsureOrigin<Self::RuntimeOrigin>;\n\n\t\t/// Asset Registry mechanism - used to check if asset is correctly registered in asset registry\n\t\ttype AssetRegistry: Registry<Self::AssetId, Vec<u8>, Balance, DispatchError>;\n\n\t\t/// Native Asset ID\n\t\t#[pallet::constant]\n\t\ttype HdxAssetId: Get<Self::AssetId>;\n\n\t\t/// Hub Asset ID\n\t\t#[pallet::constant]\n\t\ttype HubAssetId: Get<Self::AssetId>;\n\n\t\t/// Dynamic fee support - returns (Asset Fee, Protocol Fee) for given asset\n\t\ttype Fee: GetByKey<Self::AssetId, (Permill, Permill)>;\n\n\t\t/// Minimum withdrawal fee\n\t\t#[pallet::constant]\n\t\ttype MinWithdrawalFee: Get<Permill>;\n\n\t\t/// Minimum trading limit\n\t\t#[pallet::constant]\n\t\ttype MinimumTradingLimit: Get<Balance>;\n\n\t\t/// Minimum pool liquidity which can be added\n\t\t#[pallet::constant]\n\t\ttype MinimumPoolLiquidity: Get<Balance>;\n\n\t\t/// Max fraction of asset reserve to sell in single transaction\n\t\t#[pallet::constant]\n\t\ttype MaxInRatio: Get<u128>;\n\n\t\t/// Max fraction of asset reserve to buy in single transaction\n\t\t#[pallet::constant]\n\t\ttype MaxOutRatio: Get<u128>;\n\n\t\t/// Position identifier type\n\t\ttype PositionItemId: Member + Parameter + Default + Copy + HasCompact + AtLeast32BitUnsigned + MaxEncodedLen;\n\n\t\t/// Collection id type\n\t\ttype CollectionId: TypeInfo + MaxEncodedLen;\n\n\t\t/// Non fungible class id\n\t\t#[pallet::constant]\n\t\ttype NFTCollectionId: Get<NFTCollectionIdOf<Self>>;\n\n\t\t/// Non fungible handling - mint,burn, check owner\n\t\ttype NFTHandler: Mutate<Self::AccountId>\n\t\t\t+ Create<Self::AccountId>\n\t\t\t+ Inspect<Self::AccountId, ItemId = Self::PositionItemId, CollectionId = Self::CollectionId>;\n\n\t\t/// Weight information for extrinsics in this pallet.\n\t\ttype WeightInfo: WeightInfo;\n\n\t\t/// Hooks are actions executed on add_liquidity, sell or buy.\n\t\ttype OmnipoolHooks: OmnipoolHooks<\n\t\t\tSelf::RuntimeOrigin,\n\t\t\tSelf::AccountId,\n\t\t\tSelf::AssetId,\n\t\t\tBalance,\n\t\t\tError = DispatchError,\n\t\t>;\n\n\t\t/// Safety mechanism when adding and removing liquidity. Determines how much price can change between spot price and oracle price.\n\t\ttype PriceBarrier: ShouldAllow<Self::AccountId, Self::AssetId, EmaPrice>;\n\n\t\t/// Oracle price provider. Provides price for given asset. Used in remove liquidity to support calculation of dynamic withdrawal fee.\n\t\ttype ExternalPriceOracle: ExternalPriceProvider<Self::AssetId, EmaPrice, Error = DispatchError>;\n\t}\n\n\t#[pallet::storage]\n\t/// State of an asset in the omnipool\n\t#[pallet::getter(fn assets)]\n\tpub(super) type Assets<T: Config> = StorageMap<_, Blake2_128Concat, T::AssetId, AssetState<Balance>>;\n\n\t#[pallet::storage]\n\t/// Imbalance of hub asset\n\t#[pallet::getter(fn current_imbalance)]\n\tpub(super) type HubAssetImbalance<T: Config> = StorageValue<_, SimpleImbalance<Balance>, ValueQuery>;\n\n\t// LRNA is only allowed to be sold\n\t#[pallet::type_value]\n\tpub fn DefaultHubAssetTradability() -> Tradability {\n\t\tTradability::SELL\n\t}\n\n\t#[pallet::storage]\n\t/// Tradable state of hub asset.\n\tpub(super) type HubAssetTradability<T: Config> =\n\t\tStorageValue<_, Tradability, ValueQuery, DefaultHubAssetTradability>;\n\n\t#[pallet::storage]\n\t/// LP positions. Maps NFT instance id to corresponding position\n\t#[pallet::getter(fn positions)]\n\tpub(super) type Positions<T: Config> =\n\t\tStorageMap<_, Blake2_128Concat, T::PositionItemId, Position<Balance, T::AssetId>>;\n\n\t#[pallet::storage]\n\t#[pallet::getter(fn next_position_id)]\n\t/// Position ids sequencer\n\tpub(super) type NextPositionId<T: Config> = StorageValue<_, T::PositionItemId, ValueQuery>;\n\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(crate) fn deposit_event)]\n\tpub enum Event<T: Config> {\n\t\t/// An asset was added to Omnipool\n\t\tTokenAdded {\n\t\t\tasset_id: T::AssetId,\n\t\t\tinitial_amount: Balance,\n\t\t\tinitial_price: Price,\n\t\t},\n\t\t/// An asset was removed from Omnipool\n\t\tTokenRemoved {\n\t\t\tasset_id: T::AssetId,\n\t\t\tamount: Balance,\n\t\t\thub_withdrawn: Balance,\n\t\t},\n\t\t/// Liquidity of an asset was added to Omnipool.\n\t\tLiquidityAdded {\n\t\t\twho: T::AccountId,\n\t\t\tasset_id: T::AssetId,\n\t\t\tamount: Balance,\n\t\t\tposition_id: T::PositionItemId,\n\t\t},\n\t\t/// Liquidity of an asset was removed from Omnipool.\n\t\tLiquidityRemoved {\n\t\t\twho: T::AccountId,\n\t\t\tposition_id: T::PositionItemId,\n\t\t\tasset_id: T::AssetId,\n\t\t\tshares_removed: Balance,\n\t\t\tfee: FixedU128,\n\t\t},\n\t\t/// PRotocol Liquidity was removed from Omnipool.\n\t\tProtocolLiquidityRemoved {\n\t\t\twho: T::AccountId,\n\t\t\tasset_id: T::AssetId,\n\t\t\tamount: Balance,\n\t\t\thub_amount: Balance,\n\t\t\tshares_removed: Balance,\n\t\t},\n\t\t/// Sell trade executed.\n\t\tSellExecuted {\n\t\t\twho: T::AccountId,\n\t\t\tasset_in: T::AssetId,\n\t\t\tasset_out: T::AssetId,\n\t\t\tamount_in: Balance,\n\t\t\tamount_out: Balance,\n\t\t\thub_amount_in: Balance,\n\t\t\thub_amount_out: Balance,\n\t\t\tasset_fee_amount: Balance,\n\t\t\tprotocol_fee_amount: Balance,\n\t\t},\n\t\t/// Buy trade executed.\n\t\tBuyExecuted {\n\t\t\twho: T::AccountId,\n\t\t\tasset_in: T::AssetId,\n\t\t\tasset_out: T::AssetId,\n\t\t\tamount_in: Balance,\n\t\t\tamount_out: Balance,\n\t\t\thub_amount_in: Balance,\n\t\t\thub_amount_out: Balance,\n\t\t\tasset_fee_amount: Balance,\n\t\t\tprotocol_fee_amount: Balance,\n\t\t},\n\t\t/// LP Position was created and NFT instance minted.\n\t\tPositionCreated {\n\t\t\tposition_id: T::PositionItemId,\n\t\t\towner: T::AccountId,\n\t\t\tasset: T::AssetId,\n\t\t\tamount: Balance,\n\t\t\tshares: Balance,\n\t\t\tprice: Price,\n\t\t},\n\t\t/// LP Position was destroyed and NFT instance burned.\n\t\tPositionDestroyed {\n\t\t\tposition_id: T::PositionItemId,\n\t\t\towner: T::AccountId,\n\t\t},\n\t\t/// LP Position was updated.\n\t\tPositionUpdated {\n\t\t\tposition_id: T::PositionItemId,\n\t\t\towner: T::AccountId,\n\t\t\tasset: T::AssetId,\n\t\t\tamount: Balance,\n\t\t\tshares: Balance,\n\t\t\tprice: Price,\n\t\t},\n\t\t/// Asset's tradable state has been updated.\n\t\tTradableStateUpdated { asset_id: T::AssetId, state: Tradability },\n\n\t\t/// Amount has been refunded for asset which has not been accepted to add to omnipool.\n\t\tAssetRefunded {\n\t\t\tasset_id: T::AssetId,\n\t\t\tamount: Balance,\n\t\t\trecipient: T::AccountId,\n\t\t},\n\n\t\t/// Asset's weight cap has been updated.\n\t\tAssetWeightCapUpdated { asset_id: T::AssetId, cap: Permill },\n\t}\n\n\t#[pallet::error]\n\t#[cfg_attr(test, derive(PartialEq, Eq))]\n\tpub enum Error<T> {\n\t\t/// Balance too low\n\t\tInsufficientBalance,\n\t\t/// Asset is already in omnipool\n\t\tAssetAlreadyAdded,\n\t\t/// Asset is not in omnipool\n\t\tAssetNotFound,\n\t\t/// Failed to add token to Omnipool due to insufficient initial liquidity.\n\t\tMissingBalance,\n\t\t/// Invalid initial asset price.\n\t\tInvalidInitialAssetPrice,\n\t\t/// Slippage protection - minimum limit has not been reached.\n\t\tBuyLimitNotReached,\n\t\t/// Slippage protection - maximum limit has been exceeded.\n\t\tSellLimitExceeded,\n\t\t/// Position has not been found.\n\t\tPositionNotFound,\n\t\t/// Insufficient shares in position\n\t\tInsufficientShares,\n\t\t/// Asset is not allowed to be traded.\n\t\tNotAllowed,\n\t\t/// Signed account is not owner of position instance.\n\t\tForbidden,\n\t\t/// Asset weight cap has been exceeded.\n\t\tAssetWeightCapExceeded,\n\t\t/// Asset is not registered in asset registry\n\t\tAssetNotRegistered,\n\t\t/// Provided liquidity is below minimum allowed limit\n\t\tInsufficientLiquidity,\n\t\t/// Traded amount is below minimum allowed limit\n\t\tInsufficientTradingAmount,\n\t\t/// Sell or buy with same asset ids is not allowed.\n\t\tSameAssetTradeNotAllowed,\n\t\t/// LRNA update after trade results in positive value.\n\t\tHubAssetUpdateError,\n\t\t/// Imbalance results in positive value.\n\t\tPositiveImbalance,\n\t\t/// Amount of shares provided cannot be 0.\n\t\tInvalidSharesAmount,\n\t\t/// Hub asset is only allowed to be sold.\n\t\tInvalidHubAssetTradableState,\n\t\t/// Asset is not allowed to be refunded.\n\t\tAssetRefundNotAllowed,\n\t\t/// Max fraction of asset to buy has been exceeded.\n\t\tMaxOutRatioExceeded,\n\t\t/// Max fraction of asset to sell has been exceeded.\n\t\tMaxInRatioExceeded,\n\t\t/// Max allowed price difference has been exceeded.\n\t\tPriceDifferenceTooHigh,\n\t\t/// Invalid oracle price - division by zero.\n\t\tInvalidOraclePrice,\n\t\t/// Failed to calculate withdrawal fee.\n\t\tInvalidWithdrawalFee,\n\t\t/// More than allowed amount of fee has been transferred.\n\t\tFeeOverdraft,\n\t\t/// Token cannot be removed from Omnipool due to shares still owned by other users.\n\t\tSharesRemaining,\n\t\t/// Token cannot be removed from Omnipool because asset is not frozen.\n\t\tAssetNotFrozen,\n\t\t/// Calculated amount out from sell trade is zero.\n\t\tZeroAmountOut,\n\t}\n\n\t#[pallet::call]\n\timpl<T: Config> Pallet<T> {\n\t\t/// Add new token to omnipool in quantity `amount` at price `initial_price`\n\t\t///\n\t\t/// Initial liquidity must be transferred to pool's account for this new token manually prior to calling `add_token`.\n\t\t///\n\t\t/// Initial liquidity is pool's account balance of the token.\n\t\t///\n\t\t/// Position NFT token is minted for `position_owner`.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `asset`: The identifier of the new asset added to the pool. Must be registered in Asset registry\n\t\t/// - `initial_price`: Initial price\n\t\t/// - `position_owner`: account id for which share are distributed in form on NFT\n\t\t/// - `weight_cap`: asset weight cap\n\t\t///\n\t\t/// Emits `TokenAdded` event when successful.\n\t\t///\n\t\t#[pallet::call_index(1)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::add_token().saturating_add(T::OmnipoolHooks::on_liquidity_changed_weight()))]\n\t\t#[transactional]\n\t\tpub fn add_token(\n\t\t\torigin: OriginFor<T>,\n\t\t\tasset: T::AssetId,\n\t\t\tinitial_price: Price,\n\t\t\tweight_cap: Permill,\n\t\t\tposition_owner: T::AccountId,\n\t\t) -> DispatchResult {\n\t\t\tT::AuthorityOrigin::ensure_origin(origin.clone())?;\n\n\t\t\tensure!(!Assets::<T>::contains_key(asset), Error::<T>::AssetAlreadyAdded);\n\n\t\t\tensure!(T::AssetRegistry::exists(asset), Error::<T>::AssetNotRegistered);\n\n\t\t\tensure!(initial_price > FixedU128::zero(), Error::<T>::InvalidInitialAssetPrice);\n\n\t\t\t// ensure collection is created, we can simply ignore the error if it was already created.\n\t\t\tlet _ = T::NFTHandler::create_collection(\n\t\t\t\t&T::NFTCollectionId::get(),\n\t\t\t\t&Self::protocol_account(),\n\t\t\t\t&Self::protocol_account(),\n\t\t\t);\n\n\t\t\tlet amount = T::Currency::free_balance(asset, &Self::protocol_account());\n\n\t\t\tensure!(\n\t\t\t\tamount >= T::MinimumPoolLiquidity::get() && amount > 0,\n\t\t\t\tError::<T>::MissingBalance\n\t\t\t);\n\n\t\t\tlet hub_reserve = initial_price.checked_mul_int(amount).ok_or(ArithmeticError::Overflow)?;\n\n\t\t\t// Initial state of asset\n\t\t\tlet state = AssetState::<Balance> {\n\t\t\t\thub_reserve,\n\t\t\t\tshares: amount,\n\t\t\t\tprotocol_shares: Balance::zero(),\n\t\t\t\tcap: FixedU128::from(weight_cap).into_inner(),\n\t\t\t\ttradable: Tradability::default(),\n\t\t\t};\n\n\t\t\tlet lp_position = Position::<Balance, T::AssetId> {\n\t\t\t\tasset_id: asset,\n\t\t\t\tamount,\n\t\t\t\tshares: amount,\n\t\t\t\tprice: (initial_price.into_inner(), FixedU128::DIV),\n\t\t\t};\n\n\t\t\tlet instance_id = Self::create_and_mint_position_instance(&position_owner)?;\n\n\t\t\t<Positions<T>>::insert(instance_id, lp_position);\n\n\t\t\tSelf::deposit_event(Event::PositionCreated {\n\t\t\t\tposition_id: instance_id,\n\t\t\t\towner: position_owner,\n\t\t\t\tasset,\n\t\t\t\tamount,\n\t\t\t\tshares: amount,\n\t\t\t\tprice: initial_price,\n\t\t\t});\n\n\t\t\tlet current_imbalance = <HubAssetImbalance<T>>::get();\n\t\t\tlet current_hub_asset_liquidity =\n\t\t\t\tT::Currency::free_balance(T::HubAssetId::get(), &Self::protocol_account());\n\n\t\t\tlet delta_imbalance = hydra_dx_math::omnipool::calculate_delta_imbalance(\n\t\t\t\thub_reserve,\n\t\t\t\tI129 {\n\t\t\t\t\tvalue: current_imbalance.value,\n\t\t\t\t\tnegative: current_imbalance.negative,\n\t\t\t\t},\n\t\t\t\tcurrent_hub_asset_liquidity,\n\t\t\t)\n\t\t\t.ok_or(ArithmeticError::Overflow)?;\n\n\t\t\tSelf::update_imbalance(BalanceUpdate::Decrease(delta_imbalance))?;\n\n\t\t\tlet delta_hub_reserve = BalanceUpdate::Increase(hub_reserve);\n\t\t\tSelf::update_hub_asset_liquidity(&delta_hub_reserve)?;\n\n\t\t\tlet reserve = T::Currency::free_balance(asset, &Self::protocol_account());\n\n\t\t\tlet reserve_state: AssetReserveState<_> = (state.clone(), reserve).into();\n\t\t\tlet changes = AssetStateChange {\n\t\t\t\tdelta_hub_reserve,\n\t\t\t\tdelta_reserve: BalanceUpdate::Increase(reserve),\n\t\t\t\tdelta_shares: BalanceUpdate::Increase(amount),\n\t\t\t\tdelta_protocol_shares: BalanceUpdate::Increase(Balance::zero()),\n\t\t\t};\n\t\t\tT::OmnipoolHooks::on_liquidity_changed(\n\t\t\t\torigin,\n\t\t\t\tAssetInfo::new(asset, &AssetReserveState::default(), &reserve_state, &changes, false),\n\t\t\t)?;\n\n\t\t\t<Assets<T>>::insert(asset, state);\n\n\t\t\tSelf::deposit_event(Event::TokenAdded {\n\t\t\t\tasset_id: asset,\n\t\t\t\tinitial_amount: amount,\n\t\t\t\tinitial_price,\n\t\t\t});\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Add liquidity of asset `asset` in quantity `amount` to Omnipool\n\t\t///\n\t\t/// `add_liquidity` adds specified asset amount to Omnipool and in exchange gives the origin\n\t\t/// corresponding shares amount in form of NFT at current price.\n\t\t///\n\t\t/// Asset's tradable state must contain ADD_LIQUIDITY flag, otherwise `NotAllowed` error is returned.\n\t\t///\n\t\t/// NFT is minted using NTFHandler which implements non-fungibles traits from frame_support.\n\t\t///\n\t\t/// Asset weight cap must be respected, otherwise `AssetWeightExceeded` error is returned.\n\t\t/// Asset weight is ratio between new HubAsset reserve and total reserve of Hub asset in Omnipool.\n\t\t///\n\t\t/// Add liquidity fails if price difference between spot price and oracle price is higher than allowed by `PriceBarrier`.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `asset`: The identifier of the new asset added to the pool. Must be already in the pool\n\t\t/// - `amount`: Amount of asset added to omnipool\n\t\t///\n\t\t/// Emits `LiquidityAdded` event when successful.\n\t\t///\n\t\t#[pallet::call_index(2)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::add_liquidity()\n\t\t\t.saturating_add(T::OmnipoolHooks::on_liquidity_changed_weight()\n\t\t\t.saturating_add(T::ExternalPriceOracle::get_price_weight()))\n\t\t)]\n\t\t#[transactional]\n\t\tpub fn add_liquidity(origin: OriginFor<T>, asset: T::AssetId, amount: Balance) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin.clone())?;\n\n\t\t\tensure!(\n\t\t\t\tamount >= T::MinimumPoolLiquidity::get(),\n\t\t\t\tError::<T>::InsufficientLiquidity\n\t\t\t);\n\n\t\t\tensure!(\n\t\t\t\tT::Currency::ensure_can_withdraw(asset, &who, amount).is_ok(),\n\t\t\t\tError::<T>::InsufficientBalance\n\t\t\t);\n\n\t\t\tlet asset_state = Self::load_asset_state(asset)?;\n\n\t\t\tensure!(\n\t\t\t\tasset_state.tradable.contains(Tradability::ADD_LIQUIDITY),\n\t\t\t\tError::<T>::NotAllowed\n\t\t\t);\n\n\t\t\tT::PriceBarrier::ensure_price(\n\t\t\t\t&who,\n\t\t\t\tT::HubAssetId::get(),\n\t\t\t\tasset,\n\t\t\t\tEmaPrice::new(asset_state.hub_reserve, asset_state.reserve),\n\t\t\t)\n\t\t\t.map_err(|_| Error::<T>::PriceDifferenceTooHigh)?;\n\n\t\t\tlet current_imbalance = <HubAssetImbalance<T>>::get();\n\t\t\tlet current_hub_asset_liquidity =\n\t\t\t\tT::Currency::free_balance(T::HubAssetId::get(), &Self::protocol_account());\n\n\t\t\t//\n\t\t\t// Calculate add liquidity state changes\n\t\t\t//\n\t\t\tlet state_changes = hydra_dx_math::omnipool::calculate_add_liquidity_state_changes(\n\t\t\t\t&(&asset_state).into(),\n\t\t\t\tamount,\n\t\t\t\tI129 {\n\t\t\t\t\tvalue: current_imbalance.value,\n\t\t\t\t\tnegative: current_imbalance.negative,\n\t\t\t\t},\n\t\t\t\tcurrent_hub_asset_liquidity,\n\t\t\t)\n\t\t\t.ok_or(ArithmeticError::Overflow)?;\n\n\t\t\tlet new_asset_state = asset_state\n\t\t\t\t.clone()\n\t\t\t\t.delta_update(&state_changes.asset)\n\t\t\t\t.ok_or(ArithmeticError::Overflow)?;\n\n\t\t\tlet hub_reserve_ratio = FixedU128::checked_from_rational(\n\t\t\t\tnew_asset_state.hub_reserve,\n\t\t\t\tT::Currency::free_balance(T::HubAssetId::get(), &Self::protocol_account())\n\t\t\t\t\t.checked_add(*state_changes.asset.delta_hub_reserve)\n\t\t\t\t\t.ok_or(ArithmeticError::Overflow)?,\n\t\t\t)\n\t\t\t.ok_or(ArithmeticError::DivisionByZero)?;\n\n\t\t\tensure!(\n\t\t\t\thub_reserve_ratio <= new_asset_state.weight_cap(),\n\t\t\t\tError::<T>::AssetWeightCapExceeded\n\t\t\t);\n\n\t\t\t// Create LP position with given shares\n\t\t\tlet lp_position = Position::<Balance, T::AssetId> {\n\t\t\t\tasset_id: asset,\n\t\t\t\tamount,\n\t\t\t\tshares: *state_changes.asset.delta_shares,\n\t\t\t\t// Note: position needs price after asset state is updated.\n\t\t\t\tprice: (new_asset_state.hub_reserve, new_asset_state.reserve),\n\t\t\t};\n\n\t\t\tlet instance_id = Self::create_and_mint_position_instance(&who)?;\n\n\t\t\t<Positions<T>>::insert(instance_id, lp_position);\n\n\t\t\tSelf::deposit_event(Event::PositionCreated {\n\t\t\t\tposition_id: instance_id,\n\t\t\t\towner: who.clone(),\n\t\t\t\tasset,\n\t\t\t\tamount,\n\t\t\t\tshares: *state_changes.asset.delta_shares,\n\t\t\t\tprice: new_asset_state.price().ok_or(ArithmeticError::DivisionByZero)?,\n\t\t\t});\n\n\t\t\tT::Currency::transfer(\n\t\t\t\tasset,\n\t\t\t\t&who,\n\t\t\t\t&Self::protocol_account(),\n\t\t\t\t*state_changes.asset.delta_reserve,\n\t\t\t)?;\n\n\t\t\tdebug_assert_eq!(*state_changes.asset.delta_reserve, amount);\n\n\t\t\t// Callback hook info\n\t\t\tlet info: AssetInfo<T::AssetId, Balance> =\n\t\t\t\tAssetInfo::new(asset, &asset_state, &new_asset_state, &state_changes.asset, false);\n\n\t\t\tSelf::update_imbalance(state_changes.delta_imbalance)?;\n\n\t\t\tSelf::update_hub_asset_liquidity(&state_changes.asset.delta_hub_reserve)?;\n\n\t\t\tSelf::set_asset_state(asset, new_asset_state);\n\n\t\t\tSelf::deposit_event(Event::LiquidityAdded {\n\t\t\t\twho,\n\t\t\t\tasset_id: asset,\n\t\t\t\tamount,\n\t\t\t\tposition_id: instance_id,\n\t\t\t});\n\n\t\t\tT::OmnipoolHooks::on_liquidity_changed(origin, info)?;\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Remove liquidity of asset `asset` in quantity `amount` from Omnipool\n\t\t///\n\t\t/// `remove_liquidity` removes specified shares amount from given PositionId (NFT instance).\n\t\t///\n\t\t/// Asset's tradable state must contain REMOVE_LIQUIDITY flag, otherwise `NotAllowed` error is returned.\n\t\t///\n\t\t/// if all shares from given position are removed, position is destroyed and NFT is burned.\n\t\t///\n\t\t/// Remove liquidity fails if price difference between spot price and oracle price is higher than allowed by `PriceBarrier`.\n\t\t///\n\t\t/// Dynamic withdrawal fee is applied if withdrawal is not safe. It is calculated using spot price and external price oracle.\n\t\t/// Withdrawal is considered safe when trading is disabled.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `position_id`: The identifier of position which liquidity is removed from.\n\t\t/// - `amount`: Amount of shares removed from omnipool\n\t\t///\n\t\t/// Emits `LiquidityRemoved` event when successful.\n\t\t///\n\t\t#[pallet::call_index(3)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::remove_liquidity().saturating_add(T::OmnipoolHooks::on_liquidity_changed_weight()))]\n\t\t#[transactional]\n\t\tpub fn remove_liquidity(\n\t\t\torigin: OriginFor<T>,\n\t\t\tposition_id: T::PositionItemId,\n\t\t\tamount: Balance,\n\t\t) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin.clone())?;\n\n\t\t\tensure!(amount > Balance::zero(), Error::<T>::InvalidSharesAmount);\n\n\t\t\tensure!(\n\t\t\t\tT::NFTHandler::owner(&T::NFTCollectionId::get(), &position_id) == Some(who.clone()),\n\t\t\t\tError::<T>::Forbidden\n\t\t\t);\n\n\t\t\tlet position = Positions::<T>::get(position_id).ok_or(Error::<T>::PositionNotFound)?;\n\n\t\t\tensure!(position.shares >= amount, Error::<T>::InsufficientShares);\n\n\t\t\tlet asset_id = position.asset_id;\n\n\t\t\tlet asset_state = Self::load_asset_state(asset_id)?;\n\n\t\t\tensure!(\n\t\t\t\tasset_state.tradable.contains(Tradability::REMOVE_LIQUIDITY),\n\t\t\t\tError::<T>::NotAllowed\n\t\t\t);\n\n\t\t\tlet safe_withdrawal = asset_state.tradable.is_safe_withdrawal();\n\t\t\t// Skip price check if safe withdrawal - trading disabled.\n\t\t\tif !safe_withdrawal {\n\t\t\t\tT::PriceBarrier::ensure_price(\n\t\t\t\t\t&who,\n\t\t\t\t\tT::HubAssetId::get(),\n\t\t\t\t\tasset_id,\n\t\t\t\t\tEmaPrice::new(asset_state.hub_reserve, asset_state.reserve),\n\t\t\t\t)\n\t\t\t\t.map_err(|_| Error::<T>::PriceDifferenceTooHigh)?;\n\t\t\t}\n\t\t\tlet ext_asset_price = T::ExternalPriceOracle::get_price(T::HubAssetId::get(), asset_id)?;\n\n\t\t\tif ext_asset_price.is_zero() {\n\t\t\t\treturn Err(Error::<T>::InvalidOraclePrice.into());\n\t\t\t}\n\t\t\tlet withdrawal_fee = hydra_dx_math::omnipool::calculate_withdrawal_fee(\n\t\t\t\tasset_state.price().ok_or(ArithmeticError::DivisionByZero)?,\n\t\t\t\tFixedU128::checked_from_rational(ext_asset_price.n, ext_asset_price.d)\n\t\t\t\t\t.defensive_ok_or(Error::<T>::InvalidOraclePrice)?,\n\t\t\t\tT::MinWithdrawalFee::get(),\n\t\t\t);\n\n\t\t\tlet current_imbalance = <HubAssetImbalance<T>>::get();\n\t\t\tlet current_hub_asset_liquidity =\n\t\t\t\tT::Currency::free_balance(T::HubAssetId::get(), &Self::protocol_account());\n\n\t\t\t//\n\t\t\t// calculate state changes of remove liquidity\n\t\t\t//\n\t\t\tlet state_changes = hydra_dx_math::omnipool::calculate_remove_liquidity_state_changes(\n\t\t\t\t&(&asset_state).into(),\n\t\t\t\tamount,\n\t\t\t\t&(&position).into(),\n\t\t\t\tI129 {\n\t\t\t\t\tvalue: current_imbalance.value,\n\t\t\t\t\tnegative: current_imbalance.negative,\n\t\t\t\t},\n\t\t\t\tcurrent_hub_asset_liquidity,\n\t\t\t\twithdrawal_fee,\n\t\t\t)\n\t\t\t.ok_or(ArithmeticError::Overflow)?;\n\n\t\t\tlet new_asset_state = asset_state\n\t\t\t\t.clone()\n\t\t\t\t.delta_update(&state_changes.asset)\n\t\t\t\t.ok_or(ArithmeticError::Overflow)?;\n\n\t\t\t// Update position state\n\t\t\tlet updated_position = position\n\t\t\t\t.delta_update(\n\t\t\t\t\t&state_changes.delta_position_reserve,\n\t\t\t\t\t&state_changes.delta_position_shares,\n\t\t\t\t)\n\t\t\t\t.ok_or(ArithmeticError::Overflow)?;\n\n\t\t\tT::Currency::transfer(\n\t\t\t\tasset_id,\n\t\t\t\t&Self::protocol_account(),\n\t\t\t\t&who,\n\t\t\t\t*state_changes.asset.delta_reserve,\n\t\t\t)?;\n\n\t\t\tSelf::update_imbalance(state_changes.delta_imbalance)?;\n\n\t\t\t// burn only difference between delta hub and lp hub amount.\n\t\t\tSelf::update_hub_asset_liquidity(\n\t\t\t\t&state_changes\n\t\t\t\t\t.asset\n\t\t\t\t\t.delta_hub_reserve\n\t\t\t\t\t.merge(BalanceUpdate::Increase(state_changes.lp_hub_amount))\n\t\t\t\t\t.ok_or(ArithmeticError::Overflow)?,\n\t\t\t)?;\n\n\t\t\t// LP receives some hub asset\n\t\t\tSelf::process_hub_amount(state_changes.lp_hub_amount, &who)?;\n\n\t\t\tif updated_position.shares == Balance::zero() {\n\t\t\t\t// All liquidity removed, remove position and burn NFT instance\n\n\t\t\t\t<Positions<T>>::remove(position_id);\n\t\t\t\tT::NFTHandler::burn(&T::NFTCollectionId::get(), &position_id, Some(&who))?;\n\n\t\t\t\tSelf::deposit_event(Event::PositionDestroyed {\n\t\t\t\t\tposition_id,\n\t\t\t\t\towner: who.clone(),\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tSelf::deposit_event(Event::PositionUpdated {\n\t\t\t\t\tposition_id,\n\t\t\t\t\towner: who.clone(),\n\t\t\t\t\tasset: asset_id,\n\t\t\t\t\tamount: updated_position.amount,\n\t\t\t\t\tshares: updated_position.shares,\n\t\t\t\t\tprice: updated_position\n\t\t\t\t\t\t.price_from_rational()\n\t\t\t\t\t\t.ok_or(ArithmeticError::DivisionByZero)?,\n\t\t\t\t});\n\n\t\t\t\t<Positions<T>>::insert(position_id, updated_position);\n\t\t\t}\n\n\t\t\t// Callback hook info\n\t\t\tlet info: AssetInfo<T::AssetId, Balance> = AssetInfo::new(\n\t\t\t\tasset_id,\n\t\t\t\t&asset_state,\n\t\t\t\t&new_asset_state,\n\t\t\t\t&state_changes.asset,\n\t\t\t\tsafe_withdrawal,\n\t\t\t);\n\n\t\t\tSelf::set_asset_state(asset_id, new_asset_state);\n\n\t\t\tSelf::deposit_event(Event::LiquidityRemoved {\n\t\t\t\twho,\n\t\t\t\tposition_id,\n\t\t\t\tasset_id,\n\t\t\t\tshares_removed: amount,\n\t\t\t\tfee: withdrawal_fee,\n\t\t\t});\n\n\t\t\tT::OmnipoolHooks::on_liquidity_changed(origin, info)?;\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Sacrifice LP position in favor of pool.\n\t\t///\n\t\t/// A position is destroyed and liquidity owned by LP becomes pool owned liquidity.\n\t\t///\n\t\t/// Only owner of position can perform this action.\n\t\t///\n\t\t/// Emits `PositionDestroyed`.\n\t\t#[pallet::call_index(4)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::sacrifice_position())]\n\t\t#[transactional]\n\t\tpub fn sacrifice_position(origin: OriginFor<T>, position_id: T::PositionItemId) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin)?;\n\n\t\t\tlet position = Positions::<T>::get(position_id).ok_or(Error::<T>::PositionNotFound)?;\n\n\t\t\tensure!(\n\t\t\t\tT::NFTHandler::owner(&T::NFTCollectionId::get(), &position_id) == Some(who.clone()),\n\t\t\t\tError::<T>::Forbidden\n\t\t\t);\n\n\t\t\tAssets::<T>::try_mutate(position.asset_id, |maybe_asset| -> DispatchResult {\n\t\t\t\tlet asset_state = maybe_asset.as_mut().ok_or(Error::<T>::AssetNotFound)?;\n\n\t\t\t\tasset_state.protocol_shares = asset_state\n\t\t\t\t\t.protocol_shares\n\t\t\t\t\t.checked_add(position.shares)\n\t\t\t\t\t.ok_or(ArithmeticError::Overflow)?;\n\n\t\t\t\tOk(())\n\t\t\t})?;\n\n\t\t\t// Destroy position and burn NFT\n\t\t\t<Positions<T>>::remove(position_id);\n\t\t\tT::NFTHandler::burn(&T::NFTCollectionId::get(), &position_id, Some(&who))?;\n\n\t\t\tSelf::deposit_event(Event::PositionDestroyed {\n\t\t\t\tposition_id,\n\t\t\t\towner: who,\n\t\t\t});\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Execute a swap of `asset_in` for `asset_out`.\n\t\t///\n\t\t/// Price is determined by the Omnipool.\n\t\t///\n\t\t/// Hub asset is traded separately.\n\t\t///\n\t\t/// Asset's tradable states must contain SELL flag for asset_in and BUY flag for asset_out, otherwise `NotAllowed` error is returned.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `asset_in`: ID of asset sold to the pool\n\t\t/// - `asset_out`: ID of asset bought from the pool\n\t\t/// - `amount`: Amount of asset sold\n\t\t/// - `min_buy_amount`: Minimum amount required to receive\n\t\t///\n\t\t/// Emits `SellExecuted` event when successful.\n\t\t///\n\t\t#[pallet::call_index(5)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::sell()\n\t\t\t.saturating_add(T::OmnipoolHooks::on_trade_weight())\n\t\t\t.saturating_add(T::OmnipoolHooks::on_liquidity_changed_weight())\n\t\t)]\n\t\t#[transactional]\n\t\tpub fn sell(\n\t\t\torigin: OriginFor<T>,\n\t\t\tasset_in: T::AssetId,\n\t\t\tasset_out: T::AssetId,\n\t\t\tamount: Balance,\n\t\t\tmin_buy_amount: Balance,\n\t\t) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin.clone())?;\n\n\t\t\tensure!(asset_in != asset_out, Error::<T>::SameAssetTradeNotAllowed);\n\n\t\t\tensure!(\n\t\t\t\tamount >= T::MinimumTradingLimit::get(),\n\t\t\t\tError::<T>::InsufficientTradingAmount\n\t\t\t);\n\n\t\t\tensure!(\n\t\t\t\tT::Currency::ensure_can_withdraw(asset_in, &who, amount).is_ok(),\n\t\t\t\tError::<T>::InsufficientBalance\n\t\t\t);\n\n\t\t\t// Special handling when one of the asset is Hub Asset\n\t\t\t// Math is simplified and asset_in is actually part of asset_out state in this case\n\t\t\tif asset_in == T::HubAssetId::get() {\n\t\t\t\treturn Self::sell_hub_asset(origin, &who, asset_out, amount, min_buy_amount);\n\t\t\t}\n\n\t\t\tif asset_out == T::HubAssetId::get() {\n\t\t\t\treturn Self::sell_asset_for_hub_asset(&who, asset_in, amount, min_buy_amount);\n\t\t\t}\n\n\t\t\tlet asset_in_state = Self::load_asset_state(asset_in)?;\n\t\t\tlet asset_out_state = Self::load_asset_state(asset_out)?;\n\n\t\t\tensure!(\n\t\t\t\tSelf::allow_assets(&asset_in_state, &asset_out_state),\n\t\t\t\tError::<T>::NotAllowed\n\t\t\t);\n\n\t\t\tensure!(\n\t\t\t\tamount\n\t\t\t\t\t<= asset_in_state\n\t\t\t\t\t\t.reserve\n\t\t\t\t\t\t.checked_div(T::MaxInRatio::get())\n\t\t\t\t\t\t.ok_or(ArithmeticError::DivisionByZero)?, // Note: this can only fail if MaxInRatio is zero.\n\t\t\t\tError::<T>::MaxInRatioExceeded\n\t\t\t);\n\n\t\t\tlet current_imbalance = <HubAssetImbalance<T>>::get();\n\n\t\t\tlet (asset_fee, _) = T::Fee::get(&asset_out);\n\t\t\tlet (_, protocol_fee) = T::"
    }
  ]
}