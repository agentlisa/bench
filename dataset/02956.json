{
  "Title": "Variable outside store",
  "Content": "In contrast to most of the code base, the [last policy identifier](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/policy/Policy.sol#L32) is saved directly in the `Policy` contract. However, to maintain continuity and prevent conflicts, any new version will [need to import](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/policy/Policy.sol#L35) the old value.\n\n\nConsider saving it in the `Store` contract.\n\n\n**Update:** *Fixed as of commit `1826fa97f1b325d40b0b3446b384dac35074540f` in [pull request #168](https://github.com/neptune-mutual-blue/protocol/pull/168).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/core/policy/Policy.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"../../dependencies/BokkyPooBahsDateTimeLibrary.sol\";\nimport \"../../interfaces/IStore.sol\";\nimport \"../../interfaces/ICxTokenFactory.sol\";\nimport \"../../interfaces/ICxToken.sol\";\nimport \"../../interfaces/IPolicy.sol\";\nimport \"../../libraries/CoverUtilV1.sol\";\nimport \"../../libraries/RegistryLibV1.sol\";\nimport \"../../libraries/ProtoUtilV1.sol\";\nimport \"../../libraries/PolicyHelperV1.sol\";\nimport \"../../libraries/RoutineInvokerLibV1.sol\";\nimport \"../Recoverable.sol\";\n\n/**\n * @title Policy Contract\n * @dev The policy contract enables you to a purchase cover\n */\ncontract Policy is IPolicy, Recoverable {\n  using PolicyHelperV1 for IStore;\n  using ProtoUtilV1 for bytes;\n  using ProtoUtilV1 for IStore;\n  using CoverUtilV1 for IStore;\n  using RegistryLibV1 for IStore;\n  using NTransferUtilV2 for IERC20;\n  using ValidationLibV1 for IStore;\n  using RoutineInvokerLibV1 for IStore;\n  using StrategyLibV1 for IStore;\n\n  uint256 public lastPolicyId;\n\n  constructor(IStore store, uint256 _lastPolicyId) Recoverable(store) {\n    lastPolicyId = _lastPolicyId;\n  }\n\n  /**\n   * @dev Purchase cover for the specified amount. <br /> <br />\n   * When you purchase covers, you receive equal amount of cxTokens back.\n   * You need the cxTokens to claim the cover when resolution occurs.\n   * Each unit of cxTokens are fully redeemable at 1:1 ratio to the given\n   * stablecoins (like wxDai, DAI, USDC, or BUSD) based on the chain.\n   *\n   * https://docs.neptunemutual.com/covers/purchasing-covers\n   *\n   * ## Payouts and Incident Date\n   *\n   * @custom:note Please take note of the following key differences:\n   *\n   * **Event Date or Observed Date**\n   *\n   * The date and time the event took place in the real world.\n   * It is also referred to as the **event date**.\n   *\n   * **Incident Date**\n   *\n   * The incident date is the timestamp at which an event report is submitted.\n   * Only if the incident date falls within your coverage period\n   * and resolution is in your favor, will you receive a claims payout.\n   *\n   * **Claim Period**\n   *\n   * In contrast to most DeFi cover protocols, Neptune Mutual has no waiting period\n   * between submitting a claim and receiving payout. You can access the claims feature\n   * to immediately receive a payout if a cover is successfully resolved as Incident Happened.\n   *\n   * Please note that after an incident is resolved, there is usually a 7-day claim period.\n   * Any claim submitted after the claim period expiry is automatically denied.\n   *\n   * @custom:warning Warning:\n   *\n   * Please thoroughly review the cover rules, cover exclusions,\n   * and standard exclusions before purchasing a cover.\n   *\n   * If the resolution does not go in your favour, you will not be able to\n   * submit a claim or receive a payout.\n   *\n   * By using the this function on our UI, directly via a smart contract call,\n   * through an explorer service such as Etherscan,\n   * through an SDK and/or API, or in any other way,\n   * you are fully aware, fully understand, and accept the risk\n   * of getting your claim(s) denied.\n   *\n   * @custom:suppress-acl This is a publicly accessible feature\n   *\n   *\n   * @param onBehalfOf Enter an address you would like to send the claim tokens (cxTokens) to.\n   * @param coverKey Enter the cover key you wish to purchase the policy for\n   * @param coverDuration Enter the number of months to cover. Accepted values: 1-3.\n   * @param amountToCover Enter the amount of the stablecoin to cover.\n   */\n  function purchaseCover(\n    address onBehalfOf,\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 coverDuration,\n    uint256 amountToCover,\n    bytes32 referralCode\n  ) external override nonReentrant returns (address, uint256) {\n    // @todo: When the POT system is replaced with NPM tokens in the future, upgrade this contract\n    // and uncomment the following line\n    // require(IERC20(s.getNpmTokenAddress()).balanceOf(msg.sender) >= 1 ether, \"No NPM balance\");\n    require(coverKey > 0, \"Invalid cover key\");\n    require(onBehalfOf != address(0), \"Invalid `onBehalfOf`\");\n    require(amountToCover > 0, \"Enter an amount\");\n    require(coverDuration > 0 && coverDuration <= ProtoUtilV1.MAX_POLICY_DURATION, \"Invalid cover duration\");\n\n    s.mustNotBePaused();\n    s.mustNotExceedProposalThreshold(amountToCover);\n    s.mustBeSupportedProductOrEmpty(coverKey, productKey);\n    s.mustHaveNormalProductStatus(coverKey, productKey);\n    s.mustNotHavePolicyDisabled(coverKey, productKey);\n    s.senderMustBeWhitelistedIfRequired(coverKey, productKey, onBehalfOf);\n\n    lastPolicyId += 1;\n\n    (ICxToken cxToken, uint256 fee, uint256 platformFee) = s.purchaseCoverInternal(onBehalfOf, coverKey, productKey, coverDuration, amountToCover);\n\n    emit CoverPurchased(coverKey, productKey, onBehalfOf, address(cxToken), fee, platformFee, amountToCover, cxToken.expiresOn(), referralCode, lastPolicyId);\n    return (address(cxToken), lastPolicyId);\n  }\n\n  /**\n   * @dev Gets cxToken and its expiry address by the supplied arguments.\n   *\n   * Warning: this function does not validate the cover and product key supplied.\n   *\n   * @param coverKey Enter the cover key\n   * @param productKey Enter the cover key\n   * @param coverDuration Enter the cover's policy duration. Valid values: 1-3.\n   *\n   */\n  function getCxToken(\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 coverDuration\n  ) external view override returns (address cxToken, uint256 expiryDate) {\n    require(coverDuration > 0 && coverDuration <= ProtoUtilV1.MAX_POLICY_DURATION, \"Invalid cover duration\");\n\n    return s.getCxTokenInternal(coverKey, productKey, coverDuration);\n  }\n\n  /**\n   * @dev Returns cxToken address by the cover key, product key, and expiry date.\n   *\n   * Warning: this function does not validate the cover and product key supplied.\n   *\n   * @param coverKey Enter the cover key\n   * @param productKey Enter the cover key\n   * @param expiryDate Enter the cxToken's expiry date\n   *\n   */\n  function getCxTokenByExpiryDate(\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 expiryDate\n  ) external view override returns (address cxToken) {\n    return s.getCxTokenByExpiryDateInternal(coverKey, productKey, expiryDate);\n  }\n\n  /**\n   * @dev Gets the expiry date based on cover duration\n   * @param today Enter the current timestamp\n   * @param coverDuration Enter the number of months to cover. Accepted values: 1-3.\n   *\n   */\n  function getExpiryDate(uint256 today, uint256 coverDuration) external pure override returns (uint256) {\n    return CoverUtilV1.getExpiryDateInternal(today, coverDuration);\n  }\n\n  /**\n   * @dev Gets the sum total of cover commitment that has not expired yet.\n   *\n   * Warning: this function does not validate the cover and product key supplied.\n   *\n   */\n  function getCommitment(bytes32 coverKey, bytes32 productKey) external view override returns (uint256) {\n    uint256 precision = s.getStablecoinPrecision();\n    return s.getActiveLiquidityUnderProtection(coverKey, productKey, precision);\n  }\n\n  /**\n   * @dev Gets the available liquidity in the pool.\n   *\n   * Warning: this function does not validate the cover key supplied.\n   *\n   */\n  function getAvailableLiquidity(bytes32 coverKey) external view override returns (uint256) {\n    return s.getStablecoinOwnedByVaultInternal(coverKey);\n  }\n\n  /**\n   * @dev Gets the cover fee info for the given cover key, duration, and amount\n   *\n   * Warning: this function does not validate the cover key supplied.\n   *\n   * @param coverKey Enter the cover key\n   * @param coverDuration Enter the number of months to cover. Accepted values: 1-3.\n   * @param amountToCover Enter the amount of the stablecoin to cover.\n   *\n   */\n  function getCoverFeeInfo(\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 coverDuration,\n    uint256 amountToCover\n  )\n    external\n    view\n    override\n    returns (\n      uint256 fee,\n      uint256 utilizationRatio,\n      uint256 totalAvailableLiquidity,\n      uint256 floor,\n      uint256 ceiling,\n      uint256 rate\n    )\n  {\n    return s.calculatePolicyFeeInternal(coverKey, productKey, coverDuration, amountToCover);\n  }\n\n  /**\n   * @dev Returns the values of the given cover key\n   *\n   * Warning: this function does not validate the cover key supplied.\n   *\n   * @param _values[0] The total amount in the cover pool\n   * @param _values[1] The total commitment amount\n   * @param _values[2] Reassurance amount\n   * @param _values[3] Reassurance pool weight\n   * @param _values[4] Count of products under this cover\n   * @param _values[5] Leverage\n   * @param _values[6] Cover product efficiency weight\n   *\n   */\n  function getCoverPoolSummary(bytes32 coverKey, bytes32 productKey) external view override returns (uint256[] memory _values) {\n    return s.getCoverPoolSummaryInternal(coverKey, productKey);\n  }\n\n  /**\n   * @dev Version number of this contract\n   */\n  function version() external pure override returns (bytes32) {\n    return \"v0.1\";\n  }\n\n  /**\n   * @dev Name of this contract\n   */\n  function getName() external pure override returns (bytes32) {\n    return ProtoUtilV1.CNAME_POLICY;\n  }\n}"
    }
  ]
}