{
  "Title": "If a user transfers NFT, they can lose rewards",
  "Content": "##### Description\nIf the user transfer NFT before calling `collectRewards`, they will lose accrued rewards\nhttps://github.com/cryptoalgebra/Algebra/blob/7290fad656bfa89db3743c52af631154f6a8a2d5/src/tokenomics/contracts/FarmingCenter.sol#L113-L115.\n\n##### Recommendation\nWe recommend adding a check to the transfer function that rewards were collected before the transfer.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/tokenomics/contracts/FarmingCenter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.17;\n\nimport './interfaces/IFarmingCenter.sol';\n\nimport '@cryptoalgebra/core/contracts/interfaces/IAlgebraPool.sol';\nimport '@cryptoalgebra/core/contracts/interfaces/IERC20Minimal.sol';\nimport '@cryptoalgebra/periphery/contracts/interfaces/IPositionFollower.sol';\nimport '@cryptoalgebra/periphery/contracts/interfaces/INonfungiblePositionManager.sol';\nimport '@cryptoalgebra/periphery/contracts/base/Multicall.sol';\n\nimport './libraries/IncentiveId.sol';\n\n/// @title Algebra main farming contract\n/// @dev Manages farmings and performs entry, exit and other actions.\ncontract FarmingCenter is IFarmingCenter, IPositionFollower, Multicall {\n  IAlgebraEternalFarming public immutable override eternalFarming;\n  INonfungiblePositionManager public immutable override nonfungiblePositionManager;\n\n  /// @dev saves addresses of virtual pools for pool\n  mapping(address => address) public override virtualPoolAddresses;\n\n  /// @dev deposits[tokenId] => incentiveId\n  mapping(uint256 => bytes32) public override deposits;\n  mapping(bytes32 => IncentiveKey) public incentiveKeys;\n\n  constructor(IAlgebraEternalFarming _eternalFarming, INonfungiblePositionManager _nonfungiblePositionManager) {\n    eternalFarming = _eternalFarming;\n    nonfungiblePositionManager = _nonfungiblePositionManager;\n  }\n\n  modifier isOwner(uint256 tokenId) {\n    require(nonfungiblePositionManager.ownerOf(tokenId) == msg.sender, 'not owner of token');\n    _;\n  }\n\n  /// @inheritdoc IFarmingCenter\n  function enterFarming(IncentiveKey memory key, uint256 tokenId) external override isOwner(tokenId) {\n    bytes32 incentiveId = IncentiveId.compute(key);\n    if (address(incentiveKeys[incentiveId].pool) == address(0)) incentiveKeys[incentiveId] = key;\n\n    require(deposits[tokenId] == bytes32(0), 'token already farmed');\n    deposits[tokenId] = incentiveId;\n    nonfungiblePositionManager.switchFarmingStatus(tokenId, true);\n\n    IAlgebraEternalFarming(eternalFarming).enterFarming(key, tokenId);\n  }\n\n  /// @inheritdoc IFarmingCenter\n  function exitFarming(IncentiveKey memory key, uint256 tokenId) external override isOwner(tokenId) {\n    _exitFarming(key, tokenId, msg.sender);\n  }\n\n  function _exitFarming(IncentiveKey memory key, uint256 tokenId, address tokenOwner) private {\n    require(deposits[tokenId] == IncentiveId.compute(key), 'invalid incentiveId');\n    deposits[tokenId] = bytes32(0);\n    nonfungiblePositionManager.switchFarmingStatus(tokenId, false);\n\n    IAlgebraEternalFarming(eternalFarming).exitFarming(key, tokenId, tokenOwner);\n  }\n\n  /// @inheritdoc IPositionFollower\n  function applyLiquidityDelta(uint256 tokenId, int256 liquidityDelta) external override {\n    liquidityDelta; // reserved for future versions\n    _updatePosition(tokenId);\n  }\n\n  // function for compatibility with older versions of NonfungiblePositionManager\n  function increaseLiquidity(uint256 tokenId, uint256 liquidityDelta) external {\n    liquidityDelta; // reserved for future versions\n    _updatePosition(tokenId);\n  }\n\n  // function for compatibility with older versions of NonfungiblePositionManager\n  function decreaseLiquidity(uint256 tokenId, uint256 liquidityDelta) external returns (bool success) {\n    liquidityDelta; // reserved for future versions\n    _updatePosition(tokenId);\n    return true;\n  }\n\n  function _updatePosition(uint256 tokenId) private {\n    require(msg.sender == address(nonfungiblePositionManager), 'only nonfungiblePosManager');\n\n    bytes32 _eternalIncentiveId = deposits[tokenId];\n    if (_eternalIncentiveId != bytes32(0)) {\n      address tokenOwner = nonfungiblePositionManager.ownerOf(tokenId);\n      (, , , , , , uint128 liquidity, , , , ) = nonfungiblePositionManager.positions(tokenId);\n\n      IncentiveKey memory key = incentiveKeys[_eternalIncentiveId];\n\n      if (liquidity == 0) {\n        _exitFarming(key, tokenId, tokenOwner);\n      } else {\n        IAlgebraEternalFarming(eternalFarming).exitFarming(key, tokenId, tokenOwner);\n        IAlgebraEternalFarming(eternalFarming).enterFarming(key, tokenId); // enter with new liquidity value\n      }\n    }\n  }\n\n  /// @inheritdoc IPositionFollower\n  function burnPosition(uint256 tokenId) external override returns (bool success) {\n    require(msg.sender == address(nonfungiblePositionManager), 'only nonfungiblePosManager');\n    bytes32 _eternalIncentiveId = deposits[tokenId];\n\n    if (_eternalIncentiveId != bytes32(0)) {\n      IncentiveKey memory key = incentiveKeys[_eternalIncentiveId];\n      _exitFarming(key, tokenId, nonfungiblePositionManager.ownerOf(tokenId));\n    }\n    return true;\n  }\n\n  /// @inheritdoc IFarmingCenter\n  function collectRewards(IncentiveKey memory key, uint256 tokenId) external override isOwner(tokenId) returns (uint256 reward, uint256 bonusReward) {\n    (reward, bonusReward) = eternalFarming.collectRewards(key, tokenId, msg.sender);\n  }\n\n  /// @inheritdoc IFarmingCenter\n  function claimReward(IERC20Minimal rewardToken, address to, uint256 amountRequested) external override returns (uint256 reward) {\n    unchecked {\n      if (amountRequested != 0) reward += eternalFarming.claimRewardFrom(rewardToken, msg.sender, to, amountRequested);\n    }\n  }\n\n  /// @inheritdoc IFarmingCenter\n  function connectVirtualPool(IAlgebraPool pool, address newVirtualPool) external override {\n    require(msg.sender == address(eternalFarming), 'only farming can call this');\n    pool.setIncentive(newVirtualPool);\n    virtualPoolAddresses[address(pool)] = newVirtualPool;\n  }\n}"
    }
  ]
}