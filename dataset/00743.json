{
  "Title": "Protocol Liquidations Are Not Pausable",
  "Content": "When the [`liquidate` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/Liquidation.sol#L162) is called during a safe pause, the function reverts during the call to the [`repayBadDebt` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/Liquidation.sol#L252) in the `IonPool` contract. However, during a [protocol liquidation](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/Liquidation.sol#L212-L220), this call does not happen as the function [returns early](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/Liquidation.sol#L220) and therefore liquidations will be successful. Allowing liquidations to occur when the `IonPool` contract is in a safe pause state may result in unfair liquidations for users as they are unable to alter their position to make their loans healthy.\n\n\nConsider disallowing protocol liquidations when the `IonPool` is in a safe pause state to prevent unfairly liquidating vaults.\n\n\n***Update:** Resolved in [pull request #36](https://github.com/Ion-Protocol/ion-protocol/pull/36). A single pause has been implemented which now pauses all liquidations.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/Liquidation.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { WadRayMath, RAY } from \"./libraries/math/WadRayMath.sol\";\nimport { IonPool } from \"src/IonPool.sol\";\nimport { ReserveOracle } from \"src/oracles/reserve/ReserveOracle.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\ncontract Liquidation {\n    using SafeERC20 for IERC20;\n    using WadRayMath for uint256;\n    using SafeCast for uint256;\n\n    error LiquidationThresholdCannotBeZero();\n    error ExchangeRateCannotBeZero();\n    error VaultIsNotUnsafe(uint256 healthRatio);\n    error InvalidReserveOraclesLength(uint256 length);\n    error InvalidLiquidationThresholdsLength(uint256 length);\n\n    // --- Parameters ---\n\n    uint256 public immutable TARGET_HEALTH; // [ray] ex) 1.25e27 is 125%\n    uint256 public immutable BASE_DISCOUNT; // [ray] ex) 0.02e27 is 2%\n\n    uint256 public immutable MAX_DISCOUNT_0; // [ray] ex) 0.2e27 is 20% \n    uint256 public immutable MAX_DISCOUNT_1; \n    uint256 public immutable MAX_DISCOUNT_2; \n\n    // liquidation thresholds\n    uint256 public immutable LIQUIDATION_THRESHOLD_0; // [ray] liquidation threshold for ilkIndex 0\n    uint256 public immutable LIQUIDATION_THRESHOLD_1; // [ray]\n    uint256 public immutable LIQUIDATION_THRESHOLD_2; // [ray]\n\n    // exchange rates\n    address public immutable RESERVE_ORACLE_0; // reserve oracle providing exchange rate for ilkIndex 0\n    address public immutable RESERVE_ORACLE_1;\n    address public immutable RESERVE_ORACLE_2;\n\n    address public immutable PROTOCOL; // receives confiscated vault debt and collateral\n\n    IonPool public immutable POOL;\n    IERC20 public immutable UNDERLYING;\n\n    // --- Events ---\n    event Liquidate(address indexed kpr, uint8 indexed ilkIndex, uint256 repay, uint256 gemOut);\n\n    constructor(\n        address _ionPool,\n        address _protocol,\n        address[] memory _reserveOracles,\n        uint256[] memory _liquidationThresholds,\n        uint256 _targetHealth,\n        uint256 _reserveFactor,\n        uint256[] memory _maxDiscount\n    ) {\n        IonPool ionPool_ = IonPool(_ionPool);\n        POOL = ionPool_;\n        PROTOCOL = _protocol;\n\n        uint256 ilkCount = POOL.ilkCount();\n        if (_reserveOracles.length != ilkCount) {\n            revert InvalidReserveOraclesLength(_reserveOracles.length);\n        }\n        if (_liquidationThresholds.length != ilkCount) {\n            revert InvalidLiquidationThresholdsLength(_liquidationThresholds.length);\n        }\n\n        TARGET_HEALTH = _targetHealth;\n        BASE_DISCOUNT = _reserveFactor;\n\n        MAX_DISCOUNT_0 = _maxDiscount[0]; \n        MAX_DISCOUNT_1 = _maxDiscount[1]; \n        MAX_DISCOUNT_2 = _maxDiscount[2]; \n\n        IERC20 underlying = ionPool_.underlying();\n        underlying.approve(address(ionPool_), type(uint256).max); // approve ionPool to transfer the UNDERLYING asset\n        UNDERLYING = underlying;\n\n        LIQUIDATION_THRESHOLD_0 = _liquidationThresholds[0];\n        LIQUIDATION_THRESHOLD_1 = _liquidationThresholds[1];\n        LIQUIDATION_THRESHOLD_2 = _liquidationThresholds[2];\n\n        RESERVE_ORACLE_0 = _reserveOracles[0];\n        RESERVE_ORACLE_1 = _reserveOracles[1];\n        RESERVE_ORACLE_2 = _reserveOracles[2];\n    }\n\n    struct Configs {\n        uint256 liquidationThreshold; \n        uint256 maxDiscount; \n        address reserveOracle; \n    }\n    /**\n     * @notice Returns the exchange rate and liquidation threshold for the given ilkIndex.\n     */\n    function _getConfigs(uint8 ilkIndex)\n        internal\n        view\n        returns (Configs memory configs)\n    {\n        address reserveOracle;\n        if (ilkIndex == 0) {\n            configs.reserveOracle = RESERVE_ORACLE_0;\n            configs.liquidationThreshold = LIQUIDATION_THRESHOLD_0;\n            configs.maxDiscount = MAX_DISCOUNT_0; \n        } else if (ilkIndex == 1) {\n            configs.reserveOracle = RESERVE_ORACLE_1;\n            configs.liquidationThreshold = LIQUIDATION_THRESHOLD_1;\n            configs.maxDiscount = MAX_DISCOUNT_1;\n        } else if (ilkIndex == 2) {\n            configs.reserveOracle = RESERVE_ORACLE_2;\n            configs.liquidationThreshold = LIQUIDATION_THRESHOLD_2;\n            configs.maxDiscount = MAX_DISCOUNT_2;\n        }\n    }\n\n    /**\n     * @notice Internal helper function for calculating the repay amount. \n     * @param debtValue [rad] totalDebt\n     * @param collateralValue [rad] collateral * exchangeRate * liquidationThreshold\n     * @param liquidationThreshold [ray]\n     * @param discount [ray]\n     * @return repay [rad]\n     */\n    function _getRepayAmt(\n        uint256 debtValue,\n        uint256 collateralValue,\n        uint256 liquidationThreshold,\n        uint256 discount\n    )\n        internal\n        view\n        returns (uint256 repay)\n    {\n        // repayNum = (targetHealth * totalDebt - collateral * exchangeRate * liquidationThreshold)\n        // repayDen = (targetHealth - (liquidationThreshold / (1 - discount)))\n        // repay = repayNum / repayDen\n\n        // round up repay in protocol favor for safer post-liquidation position\n        uint256 repayNum = debtValue.rayMulUp(TARGET_HEALTH) - collateralValue; // [rad] - [rad] = [rad]\n        uint256 repayDen = TARGET_HEALTH - liquidationThreshold.rayDivUp(RAY - discount); // [ray]\n        repay = repayNum.rayDivUp(repayDen); // [rad] * RAY / [ray] = [rad]\n    }\n\n    struct LiquidateArgs {\n        uint256 repay;\n        uint256 gemOut;\n        uint256 dart;\n        uint256 fee;\n        uint256 price;\n    }\n\n    /**\n     * @notice Executes collateral sale and repayment of debt by liquidators.\n     * @param ilkIndex index of the collateral in IonPool\n     * @param vault the position to be liquidated\n     * @param kpr payer of the debt and receiver of the collateral\n     */\n    function liquidate(uint8 ilkIndex, address vault, address kpr) external {\n        LiquidateArgs memory liquidateArgs;\n\n        Configs memory configs = _getConfigs(ilkIndex);\n\n        // exchangeRate is reported in uint72 in [wad], but should be converted to uint256 [ray]\n        uint256 exchangeRate = uint256(ReserveOracle(configs.reserveOracle).currentExchangeRate()).scaleUpToRay(18);\n        (uint256 collateral, uint256 normalizedDebt) = POOL.vault(ilkIndex, vault);\n        uint256 rate = POOL.rate(ilkIndex);\n\n        if (exchangeRate == 0) {\n            revert ExchangeRateCannotBeZero();\n        }\n        if (configs.liquidationThreshold == 0) {\n            revert LiquidationThresholdCannotBeZero();\n        }\n\n        // collateralValue = collateral * exchangeRate * liquidationThreshold\n        // debtValue = normalizedDebt * rate\n        // healthRatio = collateralValue / debtValue\n        // collateralValue = [wad] * [ray] * [ray] / RAY = [rad]\n        // debtValue = [wad] * [ray] = [rad]\n        // healthRatio = [rad] * RAY / [rad] = [ray]\n        // round down in protocol favor\n        uint256 collateralValue = (collateral * exchangeRate).rayMulDown(configs.liquidationThreshold);\n        {\n            uint256 healthRatio = collateralValue.rayDivDown(normalizedDebt * rate); // round down in protocol favor\n            if (healthRatio >= RAY) {\n                revert VaultIsNotUnsafe(healthRatio);\n            }\n\n            uint256 discount = BASE_DISCOUNT + (RAY - healthRatio); // [ray] + ([ray] - [ray])\n            discount = discount <= configs.maxDiscount ? discount : configs.maxDiscount; // cap discount to maxDiscount\n            liquidateArgs.price = exchangeRate.rayMulUp(RAY - discount); // ETH price per LST, round up in protocol\n                // favor\n            liquidateArgs.repay = _getRepayAmt(normalizedDebt * rate, collateralValue, configs.liquidationThreshold, discount);\n        }\n\n        // First branch: protocol liquidation\n        //    if repay > total debt, more debt needs to be paid off than available to go back to target health\n        //    Move exactly all collateral and debt to the protocol.\n        // Second branch: resulting debt is below dust\n        //    There is enough collateral to cover the debt and go back to target health,\n        //    but it would leave a debt amount less than dust.\n        //    Force keeper to pay off all debt including dust and readjust the amount of collateral to sell.\n        //    Resulting debt should always be zero.\n        // Third branch: partial liquidation to target health ratio\n        //    There is enough collateral to be sold to pay off debt.\n        //    Liquidator pays portion of the debt and receives collateral.\n        //    The resulting health ratio should equal target health.\n        if (liquidateArgs.repay > normalizedDebt * rate) {\n            // [rad] > [rad]\n            liquidateArgs.dart = normalizedDebt; // [wad]\n            liquidateArgs.gemOut = collateral; // [wad]\n            POOL.confiscateVault(\n                ilkIndex, vault, PROTOCOL, PROTOCOL, -int256(liquidateArgs.gemOut), -int256(liquidateArgs.dart)\n            );\n            emit Liquidate(kpr, ilkIndex, liquidateArgs.dart, liquidateArgs.gemOut);\n            return; // early return\n        } else if (normalizedDebt * rate - liquidateArgs.repay < POOL.dust(ilkIndex)) {\n            // [rad] - [rad] < [rad]\n            liquidateArgs.repay = normalizedDebt * rate; // bound repay to total debt\n            liquidateArgs.dart = normalizedDebt; // pay off all debt including dust\n            liquidateArgs.gemOut = normalizedDebt * rate / liquidateArgs.price; // round down in protocol favor\n        } else {\n            // if (normalizedDebt * rate - liquidateArgs.repay >= dust) do partial liquidation\n            // round up in protocol favor\n            liquidateArgs.dart = liquidateArgs.repay / rate; // [rad] / [ray] = [wad]\n            if (liquidateArgs.repay % rate > 0) ++liquidateArgs.dart; // round up in protocol favor\n            // round down in protocol favor\n            liquidateArgs.gemOut = liquidateArgs.repay / liquidateArgs.price; // readjust amount of collateral\n            liquidateArgs.repay = liquidateArgs.dart * rate; // 27 decimals precision loss on original repay\n        }\n\n        // below code is only reached for dust or partial liquidations\n\n        // exact amount to be transferred in `_transferWeth`\n        uint256 transferAmt = (liquidateArgs.repay / RAY);\n        if (liquidateArgs.repay % RAY > 0) ++transferAmt; // round up in protocol favor\n\n        // transfer WETH from keeper to this contract\n        UNDERLYING.safeTransferFrom(msg.sender, address(this), transferAmt);\n\n        // take the debt to pay off and the collateral to sell from the vault\n        // kpr gets the gemOut\n        POOL.confiscateVault(\n            ilkIndex, vault, kpr, address(this), -(liquidateArgs.gemOut.toInt256()), -(liquidateArgs.dart.toInt256())\n        );\n\n        // pay off the unbacked debt\n        POOL.repayBadDebt(address(this), liquidateArgs.repay);\n\n        emit Liquidate(kpr, ilkIndex, liquidateArgs.dart, liquidateArgs.gemOut);\n    }\n}"
    }
  ]
}