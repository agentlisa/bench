{
  "Title": "[G-17] A modifier used only once and not being inherited should be inlined to save gas",
  "Content": "\nWhen a modifier is used only once and is not inherited by any other contracts, inlining it can reduce gas costs. Inlining means that the modifier's code is directly inserted into the function where it is applied, rather than creating a separate function call for the modifier.\n\nBy inlining the modifier, you avoid the overhead of the additional function call, which results in lower gas consumption. This optimization is especially useful when the modifier's code is short or simple.\n\n<details> \n\n```solidity\nFile: /src/talos/boost-aggregator/BoostAggregator.sol\n190      modifier onlyWhitelisted(address from) {\n        if (!whitelistedAddresses[from]) revert Unauthorized();\n        _;\n    }\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/talos/boost-aggregator/BoostAggregator.sol#L190\n\n```solidity\nFile: /src/ulysses-omnichain/BranchPort.sol\n423      modifier lock() {\n        require(_unlocked == 1);\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchPort.sol#L423\n\n```solidity\nFile: /src/gauges/factories/BribesFactory.sol \n105         modifier onlyGaugeFactory() {\n        if (!gaugeManager.activeGaugeFactories(BaseV2GaugeFactory(msg.sender))) {\n            revert Unauthorized();\n        }\n        _;\n    }\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/BribesFactory.sol#L105\n\n```solidity\nFile: /src/hermes/tokens/bHermesBoost.sol\n32      modifier onlybHermes() {\n        if (msg.sender != bHermes) revert NotbHermes();\n        _;\n    }\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/hermes/tokens/bHermesBoost.sol#L32\n\n```solidity\nFile: /src/hermes/tokens/bHermesGauges.sol\n39       modifier onlybHermes() {\n        if (msg.sender != bHermes) revert NotbHermes();\n        _;\n    }\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/hermes/tokens/bHermesGauges.sol#L39\n\n```solidity\nFile: src/ulysses-omnichain/factories/ERC20hTokenBranchFactory.sol\n75     modifier requiresCoreRouter() {\n        if (msg.sender != localCoreRouterAddress) revert UnrecognizedCoreRouter();\n        _;\n    }\n\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/factories/ERC20hTokenBranchFactory.sol#L75\n\n```solidity\nFile:   src/ulysses-omnichain/factories/ERC20hTokenRootFactory.sol\n74      modifier requiresCoreRouter() {\n        if (msg.sender != coreRootRouterAddress && msg.sender != rootPortAddress) {\n            revert UnrecognizedCoreRouter();\n        }\n        _;\n    }\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/factories/ERC20hTokenRootFactory.sol#L74\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/talos/boost-aggregator/BoostAggregator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {INonfungiblePositionManager} from \"@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol\";\n\nimport {bHermesBoost} from \"@hermes/tokens/bHermesBoost.sol\";\nimport {UniswapV3Staker} from \"@v3-staker/UniswapV3Staker.sol\";\n\nimport {IBoostAggregator} from \"../interfaces/IBoostAggregator.sol\";\n\n/// @title Boost Aggregator for Uniswap V3 NFTs\ncontract BoostAggregator is Ownable, IBoostAggregator {\n    using SafeTransferLib for address;\n\n    /*//////////////////////////////////////////////////////////////\n                        BOOST AGGREGATOR STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBoostAggregator\n    INonfungiblePositionManager public immutable nonfungiblePositionManager;\n\n    /// @inheritdoc IBoostAggregator\n    UniswapV3Staker public immutable uniswapV3Staker;\n\n    /// @inheritdoc IBoostAggregator\n    bHermesBoost public immutable hermesGaugeBoost;\n\n    /// @inheritdoc IBoostAggregator\n    ERC20 public immutable hermes;\n\n    /// @inheritdoc IBoostAggregator\n    mapping(address => address) public userToRewardsDepot;\n\n    /// @inheritdoc IBoostAggregator\n    mapping(uint256 => address) public tokenIdToUser;\n\n    /// @inheritdoc IBoostAggregator\n    mapping(uint256 => uint256) public tokenIdRewards;\n\n    /// @inheritdoc IBoostAggregator\n    mapping(address => bool) public whitelistedAddresses;\n\n    /// @inheritdoc IBoostAggregator\n    uint256 public protocolRewards;\n\n    /// @inheritdoc IBoostAggregator\n    uint256 public protocolFee = 2000; // 20%\n    // divisioner for protocol fee\n    uint256 private constant DIVISIONER = 10000;\n\n    /**\n     * @notice Creates a new BoostAggregator\n     * @param _uniswapV3Staker The UniswapV3Staker contract\n     * @param _hermes The hermes token contract\n     * @param _owner The owner of this contract\n     */\n    constructor(UniswapV3Staker _uniswapV3Staker, ERC20 _hermes, address _owner) {\n        _initializeOwner(_owner);\n        uniswapV3Staker = _uniswapV3Staker;\n        hermesGaugeBoost = uniswapV3Staker.hermesGaugeBoost();\n        nonfungiblePositionManager = uniswapV3Staker.nonfungiblePositionManager();\n        hermes = _hermes;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL HOOKS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721Receiver\n    /// @dev msg.sender not validated to be nonfungiblePositionManager in order to allow\n    ///      whitelisted addresses to retrieve NFTs incorrectly sent to this contract\n    function onERC721Received(address, address from, uint256 tokenId, bytes calldata)\n        external\n        override\n        onlyWhitelisted(from)\n        returns (bytes4)\n    {\n        // update tokenIdRewards prior to staking\n        tokenIdRewards[tokenId] = uniswapV3Staker.tokenIdRewards(tokenId);\n        // map tokenId to user\n        tokenIdToUser[tokenId] = from;\n        // stake NFT to Uniswap V3 Staker\n        nonfungiblePositionManager.safeTransferFrom(address(this), address(uniswapV3Staker), tokenId);\n\n        return this.onERC721Received.selector;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        REWARD DEPOTS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBoostAggregator\n    function setOwnRewardsDepot(address rewardsDepot) external {\n        userToRewardsDepot[msg.sender] = rewardsDepot;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            UNSTAKE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBoostAggregator\n    function unstakeAndWithdraw(uint256 tokenId) external {\n        address user = tokenIdToUser[tokenId];\n        if (user != msg.sender) revert NotTokenIdOwner();\n\n        // unstake NFT from Uniswap V3 Staker\n        uniswapV3Staker.unstakeToken(tokenId);\n\n        uint256 pendingRewards = uniswapV3Staker.tokenIdRewards(tokenId) - tokenIdRewards[tokenId];\n\n        if (pendingRewards > DIVISIONER) {\n            uint256 newProtocolRewards = (pendingRewards * protocolFee) / DIVISIONER;\n            /// @dev protocol rewards stay in stake contract\n            protocolRewards += newProtocolRewards;\n            pendingRewards -= newProtocolRewards;\n\n            address rewardsDepot = userToRewardsDepot[user];\n            if (rewardsDepot != address(0)) {\n                // claim rewards to user's rewardsDepot\n                uniswapV3Staker.claimReward(rewardsDepot, pendingRewards);\n            } else {\n                // claim rewards to user\n                uniswapV3Staker.claimReward(user, pendingRewards);\n            }\n        }\n\n        // withdraw rewards from Uniswap V3 Staker\n        uniswapV3Staker.withdrawToken(tokenId, user, \"\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBoostAggregator\n    function addWhitelistedAddress(address user) external onlyOwner {\n        whitelistedAddresses[user] = true;\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function removeWhitelistedAddress(address user) external onlyOwner {\n        delete whitelistedAddresses[user];\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function setProtocolFee(uint256 _protocolFee) external onlyOwner {\n        if (_protocolFee > DIVISIONER) revert FeeTooHigh();\n        protocolFee = _protocolFee;\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function withdrawProtocolFees(address to) external onlyOwner {\n        uniswapV3Staker.claimReward(to, protocolRewards);\n        delete protocolRewards;\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function withdrawAllGaugeBoost(address to) external onlyOwner {\n        /// @dev May run out of gas.\n        hermesGaugeBoost.decrementAllGaugesAllBoost();\n        address(hermesGaugeBoost).safeTransfer(to, hermesGaugeBoost.balanceOf(address(this)));\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function withdrawGaugeBoost(address to, uint256 amount) external onlyOwner {\n        /// @dev May run out of gas.\n        hermesGaugeBoost.decrementAllGaugesBoost(amount);\n        hermesGaugeBoost.updateUserBoost(address(this));\n        address(hermesGaugeBoost).safeTransfer(to, amount);\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function decrementGaugesBoostIndexed(uint256 boost, uint256 offset, uint256 num) external onlyOwner {\n        hermesGaugeBoost.decrementGaugesBoostIndexed(boost, offset, num);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Only whitelisted addresses\n    /// @param from The address who the NFT is being transferred from\n    modifier onlyWhitelisted(address from) {\n        if (!whitelistedAddresses[from]) revert Unauthorized();\n        _;\n    }\n}"
    },
    {
      "filename": "src/ulysses-omnichain/BranchPort.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IPortStrategy} from \"./interfaces/IPortStrategy.sol\";\nimport {IBranchPort} from \"./interfaces/IBranchPort.sol\";\n\nimport {ERC20hTokenBranch} from \"./token/ERC20hTokenBranch.sol\";\n\n/// @title Branch Port - Omnichain Token Management Contract\ncontract BranchPort is Ownable, IBranchPort {\n    using SafeTransferLib for address;\n\n    /// @notice Local Core Branch Router Address.\n    address public coreBranchRouterAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                        BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from Underlying Address to isUnderlying (bool).\n    mapping(address => bool) public isBridgeAgent;\n\n    /// @notice Branch Routers deployed in branc chain.\n    address[] public bridgeAgents;\n\n    /// @notice Number of Branch Routers deployed in current chain.\n    uint256 public bridgeAgentsLenght;\n\n    /*///////////////////////////////////////////////////////////////\n                    BRIDGE AGENT FACTORIES STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from Underlying Address to isUnderlying (bool).\n    mapping(address => bool) public isBridgeAgentFactory;\n\n    /// @notice Branch Routers deployed in branc chain.\n    address[] public bridgeAgentFactories;\n\n    /// @notice Number of Branch Routers deployed in current chain.\n    uint256 public bridgeAgentFactoriesLenght;\n\n    /*///////////////////////////////////////////////////////////////\n                        PORT STRATEGY STATE\n    //////////////////////////////////////////////////////////////*/\n    /// Strategy Tokens\n\n    /// @notice Mapping returns true if Strategy Token Address is active for usage in Port Strategies.\n    mapping(address => bool) public isStrategyToken;\n\n    /// @notice List of Tokens whitelisted for usage in Port Strategies.\n    address[] public strategyTokens;\n\n    /// @notice Number of Port Strategies deployed in current branch chain.\n    uint256 public strategyTokensLenght;\n\n    /// @notice Mapping returns a given token's total debt incurred by Port Strategies.\n    mapping(address => uint256) public getStrategyTokenDebt;\n\n    /// @notice Mapping returns the minimum ratio of a given Strategy Token the Port should hold.\n    mapping(address => uint256) public getMinimumTokenReserveRatio;\n\n    /// Port Strategies\n\n    /// @notice Mapping returns true if Port Startegy is allowed to manage a given Strategy Token. Strategy => Token => bool.\n    mapping(address => mapping(address => bool)) public isPortStrategy;\n\n    /// @notice Port Strategy Addresses deployed in current branch chain.\n    address[] public portStrategies;\n\n    /// @notice Number of Port Strategies deployed in current branch chain.\n    uint256 public portStrategiesLenght;\n\n    /// @notice Mapping returns the amount of Strategy Token debt a given Port Startegy has.  Strategy => Token => uint256.\n    mapping(address => mapping(address => uint256)) public getPortStrategyTokenDebt;\n\n    /// @notice Mapping returns the last time a given Port Strategy managed a given Strategy Token. Strategy => Token => uint256.\n    mapping(address => mapping(address => uint256)) public lastManaged;\n\n    /// @notice Mapping returns the time limit a given Port Strategy must wait before managing a Strategy Token. Strategy => Token => uint256.\n    mapping(address => mapping(address => uint256)) public strategyDailyLimitAmount;\n\n    /// @notice Mapping returns the amount of a Strategy Token a given Port Strategy can manage.\n    mapping(address => mapping(address => uint256)) public strategyDailyLimitRemaining;\n\n    uint256 internal constant DIVISIONER = 1e4;\n    uint256 internal constant MIN_RESERVE_RATIO = 3e3;\n\n    constructor(address _owner) {\n        require(_owner != address(0), \"Owner is zero address\");\n        _initializeOwner(_owner);\n    }\n\n    function initialize(address _coreBranchRouter, address _bridgeAgentFactory) external virtual onlyOwner {\n        require(coreBranchRouterAddress == address(0), \"Contract already initialized\");\n        require(!isBridgeAgentFactory[_bridgeAgentFactory], \"Contract already initialized\");\n\n        require(_coreBranchRouter != address(0), \"CoreBranchRouter is zero address\");\n        require(_bridgeAgentFactory != address(0), \"BridgeAgentFactory is zero address\");\n\n        coreBranchRouterAddress = _coreBranchRouter;\n        isBridgeAgentFactory[_bridgeAgentFactory] = true;\n        bridgeAgentFactories.push(_bridgeAgentFactory);\n        bridgeAgentFactoriesLenght++;\n    }\n\n    /// @notice Function being overrriden to prevent mistakenly renouncing ownership.\n    function renounceOwnership() public payable override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns amount of Strategy Tokens\n     *   @param _token Address of a given Strategy Token.\n     *   @return uint256 excess reserves\n     */\n    function _excessReserves(address _token) internal view returns (uint256) {\n        uint256 currBalance = ERC20(_token).balanceOf(address(this));\n        uint256 minReserves = _minimumReserves(currBalance, _token);\n        return currBalance > minReserves ? currBalance - minReserves : 0;\n    }\n\n    /**\n     * @notice Returns amount of Strategy Tokens needed to reach minimum reserves\n     *   @param _token Address of a given Strategy Token.\n     *   @return uint256 excess reserves\n     */\n    function _reservesLacking(address _token) internal view returns (uint256) {\n        uint256 currBalance = ERC20(_token).balanceOf(address(this));\n        uint256 minReserves = _minimumReserves(currBalance, _token);\n        return currBalance < minReserves ? minReserves - currBalance : 0;\n    }\n\n    /**\n     * @notice Internal function to return the minimum amount of reserves of a given Strategy Token the Port should hold.\n     *   @param _currBalance Current balance of a given Strategy Token.\n     *   @param _token Address of a given Strategy Token.\n     *   @return uint256 minimum reserves\n     */\n    function _minimumReserves(uint256 _currBalance, address _token) internal view returns (uint256) {\n        return ((_currBalance + getStrategyTokenDebt[_token]) * getMinimumTokenReserveRatio[_token]) / DIVISIONER;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        PORT STRATEGY FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function manage(address _token, uint256 _amount) external requiresPortStrategy(_token) {\n        if (_amount > _excessReserves(_token)) revert InsufficientReserves();\n\n        _checkTimeLimit(_token, _amount);\n\n        getStrategyTokenDebt[_token] += _amount;\n        getPortStrategyTokenDebt[msg.sender][_token] += _amount;\n\n        _token.safeTransfer(msg.sender, _amount);\n\n        emit DebtCreated(msg.sender, _token, _amount);\n    }\n\n    /// @inheritdoc IBranchPort\n    function replenishReserves(address _strategy, address _token, uint256 _amount) external lock {\n        if (!isStrategyToken[_token]) revert UnrecognizedStrategyToken();\n        if (!isPortStrategy[_strategy][_token]) revert UnrecognizedPortStrategy();\n\n        uint256 reservesLacking = _reservesLacking(_token);\n\n        uint256 amountToWithdraw = _amount < reservesLacking ? _amount : reservesLacking;\n\n        IPortStrategy(_strategy).withdraw(address(this), _token, amountToWithdraw);\n\n        getPortStrategyTokenDebt[_strategy][_token] -= amountToWithdraw;\n        getStrategyTokenDebt[_token] -= amountToWithdraw;\n\n        emit DebtRepaid(_strategy, _token, amountToWithdraw);\n    }\n\n    /**\n     * @notice Internal function to check if a Port Strategy has reached its daily management limit.\n     *   @param _token address being managed.\n     *   @param _amount of token being requested.\n     */\n    function _checkTimeLimit(address _token, uint256 _amount) internal {\n        if (block.timestamp - lastManaged[msg.sender][_token] >= 1 days) {\n            strategyDailyLimitRemaining[msg.sender][_token] = strategyDailyLimitAmount[msg.sender][_token];\n        }\n        strategyDailyLimitRemaining[msg.sender][_token] -= _amount;\n        lastManaged[msg.sender][_token] = block.timestamp;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function withdraw(address _recipient, address _underlyingAddress, uint256 _deposit)\n        external\n        virtual\n        requiresBridgeAgent\n    {\n        _underlyingAddress.safeTransfer(\n            _recipient, _denormalizeDecimals(_deposit, ERC20(_underlyingAddress).decimals())\n        );\n    }\n\n    /// @inheritdoc IBranchPort\n    function bridgeIn(address _recipient, address _localAddress, uint256 _amount)\n        external\n        virtual\n        requiresBridgeAgent\n    {\n        ERC20hTokenBranch(_localAddress).mint(_recipient, _amount);\n    }\n\n    /// @inheritdoc IBranchPort\n    function bridgeInMultiple(address _recipient, address[] memory _localAddresses, uint256[] memory _amounts)\n        external\n        virtual\n        requiresBridgeAgent\n    {\n        for (uint256 i = 0; i < _localAddresses.length;) {\n            ERC20hTokenBranch(_localAddresses[i]).mint(_recipient, _amounts[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc IBranchPort\n    function bridgeOut(\n        address _depositor,\n        address _localAddress,\n        address _underlyingAddress,\n        uint256 _amount,\n        uint256 _deposit\n    ) external virtual requiresBridgeAgent {\n        if (_amount - _deposit > 0) {\n            _localAddress.safeTransferFrom(_depositor, address(this), _amount - _deposit);\n            ERC20hTokenBranch(_localAddress).burn(_amount - _deposit);\n        }\n        if (_deposit > 0) {\n            _underlyingAddress.safeTransferFrom(\n                _depositor, address(this), _denormalizeDecimals(_deposit, ERC20(_underlyingAddress).decimals())\n            );\n        }\n    }\n\n    /// @inheritdoc IBranchPort\n    function bridgeOutMultiple(\n        address _depositor,\n        address[] memory _localAddresses,\n        address[] memory _underlyingAddresses,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits\n    ) external virtual requiresBridgeAgent {\n        for (uint256 i = 0; i < _localAddresses.length;) {\n            if (_deposits[i] > 0) {\n                _underlyingAddresses[i].safeTransferFrom(\n                    _depositor,\n                    address(this),\n                    _denormalizeDecimals(_deposits[i], ERC20(_underlyingAddresses[i]).decimals())\n                );\n            }\n            if (_amounts[i] - _deposits[i] > 0) {\n                _localAddresses[i].safeTransferFrom(_depositor, address(this), _amounts[i] - _deposits[i]);\n                ERC20hTokenBranch(_localAddresses[i]).burn(_amounts[i] - _deposits[i]);\n            }\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    BRIDGE AGENT FACTORIES FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function addBridgeAgent(address _bridgeAgent) external requiresBridgeAgentFactory {\n        isBridgeAgent[_bridgeAgent] = true;\n        bridgeAgents.push(_bridgeAgent);\n        bridgeAgentsLenght++;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function setCoreRouter(address _newCoreRouter) external requiresCoreRouter {\n        require(coreBranchRouterAddress != address(0), \"CoreRouter address is zero\");\n        require(_newCoreRouter != address(0), \"New CoreRouter address is zero\");\n        coreBranchRouterAddress = _newCoreRouter;\n    }\n\n    /// @inheritdoc IBranchPort\n    function addBridgeAgentFactory(address _newBridgeAgentFactory) external requiresCoreRouter {\n        isBridgeAgentFactory[_newBridgeAgentFactory] = true;\n        bridgeAgentFactories.push(_newBridgeAgentFactory);\n        bridgeAgentFactoriesLenght++;\n\n        emit BridgeAgentFactoryAdded(_newBridgeAgentFactory);\n    }\n\n    /// @inheritdoc IBranchPort\n    function toggleBridgeAgentFactory(address _newBridgeAgentFactory) external requiresCoreRouter {\n        isBridgeAgentFactory[_newBridgeAgentFactory] = !isBridgeAgentFactory[_newBridgeAgentFactory];\n\n        emit BridgeAgentFactoryToggled(_newBridgeAgentFactory);\n    }\n\n    /// @inheritdoc IBranchPort\n    function toggleBridgeAgent(address _bridgeAgent) external requiresCoreRouter {\n        isBridgeAgent[_bridgeAgent] = !isBridgeAgent[_bridgeAgent];\n\n        emit BridgeAgentToggled(_bridgeAgent);\n    }\n\n    /// @inheritdoc IBranchPort\n    function addStrategyToken(address _token, uint256 _minimumReservesRatio) external requiresCoreRouter {\n        if (_minimumReservesRatio >= DIVISIONER) revert InvalidMinimumReservesRatio();\n        strategyTokens.push(_token);\n        strategyTokensLenght++;\n        getMinimumTokenReserveRatio[_token] = _minimumReservesRatio;\n        isStrategyToken[_token] = true;\n\n        emit StrategyTokenAdded(_token, _minimumReservesRatio);\n    }\n\n    /// @inheritdoc IBranchPort\n    function toggleStrategyToken(address _token) external requiresCoreRouter {\n        isStrategyToken[_token] = !isStrategyToken[_token];\n\n        emit StrategyTokenToggled(_token);\n    }\n\n    /// @inheritdoc IBranchPort\n    function addPortStrategy(address _portStrategy, address _token, uint256 _dailyManagementLimit)\n        external\n        requiresCoreRouter\n    {\n        if (!isStrategyToken[_token]) revert UnrecognizedStrategyToken();\n        portStrategies.push(_portStrategy);\n        portStrategiesLenght++;\n        strategyDailyLimitAmount[_portStrategy][_token] = _dailyManagementLimit;\n        isPortStrategy[_portStrategy][_token] = true;\n\n        emit PortStrategyAdded(_portStrategy, _token, _dailyManagementLimit);\n    }\n\n    /// @inheritdoc IBranchPort\n    function togglePortStrategy(address _portStrategy, address _token) external requiresCoreRouter {\n        isPortStrategy[_portStrategy][_token] = !isPortStrategy[_portStrategy][_token];\n\n        emit PortStrategyToggled(_portStrategy, _token);\n    }\n\n    /// @inheritdoc IBranchPort\n    function updatePortStrategy(address _portStrategy, address _token, uint256 _dailyManagementLimit)\n        external\n        requiresCoreRouter\n    {\n        strategyDailyLimitAmount[_portStrategy][_token] = _dailyManagementLimit;\n\n        emit PortStrategyUpdated(_portStrategy, _token, _dailyManagementLimit);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Internal function that denormalizes an input from 18 decimal places.\n     * @param _amount amount of tokens\n     * @param _decimals number of decimal places\n     */\n    function _denormalizeDecimals(uint256 _amount, uint8 _decimals) internal pure returns (uint256) {\n        return _decimals == 18 ? _amount : _amount * 1 ether / (10 ** _decimals);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Modifier that verifies msg sender is the Branch Chain's Core Root Router.\n    modifier requiresCoreRouter() {\n        if (msg.sender != coreBranchRouterAddress) revert UnrecognizedCore();\n        _;\n    }\n\n    /// @notice Modifier that verifies msg sender is an active Bridge Agent.\n    modifier requiresBridgeAgent() {\n        if (!isBridgeAgent[msg.sender]) revert UnrecognizedBridgeAgent();\n        _;\n    }\n\n    /// @notice Modifier that verifies msg sender is an active Bridge Agent Factory.\n    modifier requiresBridgeAgentFactory() {\n        if (!isBridgeAgentFactory[msg.sender]) revert UnrecognizedBridgeAgentFactory();\n        _;\n    }\n\n    /// @notice Modifier that require msg sender to be an active Port Strategy\n    modifier requiresPortStrategy(address _token) {\n        if (!isPortStrategy[msg.sender][_token]) revert UnrecognizedPortStrategy();\n        _;\n    }\n\n    uint256 internal _unlocked = 1;\n\n    /// @notice Modifier for a simple re-entrancy check.\n    modifier lock() {\n        require(_unlocked == 1);\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n}"
    },
    {
      "filename": "src/gauges/factories/BribesFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {BaseV2Gauge} from \"@gauges/BaseV2Gauge.sol\";\n\nimport {FlywheelBoosterGaugeWeight} from \"@rewards/booster/FlywheelBoosterGaugeWeight.sol\";\nimport {FlywheelBribeRewards} from \"@rewards/rewards/FlywheelBribeRewards.sol\";\nimport {FlywheelCore} from \"@rewards/FlywheelCoreStrategy.sol\";\n\nimport {BaseV2GaugeFactory, BaseV2GaugeManager} from \"./BaseV2GaugeManager.sol\";\nimport {IBribesFactory} from \"../interfaces/IBribesFactory.sol\";\n\n/// @title Gauge Bribes Factory\ncontract BribesFactory is Ownable, IBribesFactory {\n    /*///////////////////////////////////////////////////////////////\n                        BRIBES FACTORY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBribesFactory\n    uint256 public immutable rewardsCycleLength;\n\n    FlywheelBoosterGaugeWeight private immutable flywheelGaugeWeightBooster;\n\n    /// @inheritdoc IBribesFactory\n    FlywheelCore[] public bribeFlywheels;\n\n    /// @inheritdoc IBribesFactory\n    mapping(FlywheelCore => uint256) public bribeFlywheelIds;\n\n    /// @inheritdoc IBribesFactory\n    mapping(FlywheelCore => bool) public activeBribeFlywheels;\n\n    /// @inheritdoc IBribesFactory\n    mapping(address => FlywheelCore) public flywheelTokens;\n\n    /// @inheritdoc IBribesFactory\n    BaseV2GaugeManager public immutable gaugeManager;\n\n    /**\n     * @notice Creates a new bribes factory\n     * @param _gaugeManager Gauge Factory manager\n     * @param _flywheelGaugeWeightBooster Flywheel Gauge Weight Booster\n     * @param _rewardsCycleLength Rewards Cycle Length\n     * @param _owner Owner of this contract\n     */\n    constructor(\n        BaseV2GaugeManager _gaugeManager,\n        FlywheelBoosterGaugeWeight _flywheelGaugeWeightBooster,\n        uint256 _rewardsCycleLength,\n        address _owner\n    ) {\n        _initializeOwner(_owner);\n        gaugeManager = _gaugeManager;\n        flywheelGaugeWeightBooster = _flywheelGaugeWeightBooster;\n        rewardsCycleLength = _rewardsCycleLength;\n    }\n\n    /// @inheritdoc IBribesFactory\n    function getBribeFlywheels() external view returns (FlywheelCore[] memory) {\n        return bribeFlywheels;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        CREATE BRIBE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBribesFactory\n    function addGaugetoFlywheel(address gauge, address bribeToken) external onlyGaugeFactory {\n        if (address(flywheelTokens[bribeToken]) == address(0)) createBribeFlywheel(bribeToken);\n\n        flywheelTokens[bribeToken].addStrategyForRewards(ERC20(gauge));\n    }\n\n    /// @inheritdoc IBribesFactory\n    function createBribeFlywheel(address bribeToken) public {\n        if (address(flywheelTokens[bribeToken]) != address(0)) revert BribeFlywheelAlreadyExists();\n\n        FlywheelCore flywheel = new FlywheelCore(\n            bribeToken,\n            FlywheelBribeRewards(address(0)),\n            flywheelGaugeWeightBooster,\n            address(this)\n        );\n\n        flywheelTokens[bribeToken] = flywheel;\n\n        uint256 id = bribeFlywheels.length;\n        bribeFlywheels.push(flywheel);\n        bribeFlywheelIds[flywheel] = id;\n        activeBribeFlywheels[flywheel] = true;\n\n        flywheel.setFlywheelRewards(address(new FlywheelBribeRewards(flywheel, rewardsCycleLength)));\n\n        emit BribeFlywheelCreated(bribeToken, flywheel);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    modifier onlyGaugeFactory() {\n        if (!gaugeManager.activeGaugeFactories(BaseV2GaugeFactory(msg.sender))) {\n            revert Unauthorized();\n        }\n        _;\n    }\n}"
    },
    {
      "filename": "src/hermes/tokens/bHermesBoost.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {ERC20Boost} from \"@ERC20/ERC20Boost.sol\";\n\nimport {IbHermesUnderlying} from \"../interfaces/IbHermesUnderlying.sol\";\n\n/**\n * @title bHermesBoost: Earns rights to boosted Hermes yield\n *  @author Maia DAO (https://github.com/Maia-DAO)\n *  @notice An ERC20 with an embedded attachment mechanism to\n *          keep track of boost allocations to gauges.\n */\ncontract bHermesBoost is ERC20Boost, IbHermesUnderlying {\n    /// @inheritdoc IbHermesUnderlying\n    address public immutable bHermes;\n\n    constructor(address _owner) ERC20(\"bHermes Boost\", \"bHERMES-B\", 18) {\n        _initializeOwner(_owner);\n        bHermes = msg.sender;\n    }\n\n    /// @inheritdoc IbHermesUnderlying\n    function mint(address to, uint256 amount) external onlybHermes {\n        _mint(to, amount);\n    }\n\n    modifier onlybHermes() {\n        if (msg.sender != bHermes) revert NotbHermes();\n        _;\n    }\n}"
    },
    {
      "filename": "src/hermes/tokens/bHermesGauges.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20Gauges} from \"@ERC20/ERC20Gauges.sol\";\n\nimport {IbHermesUnderlying} from \"../interfaces/IbHermesUnderlying.sol\";\n\n/**\n * @title bHermesGauges: Directs Hermes emissions.\n * @author Maia DAO (https://github.com/Maia-DAO)\n *  @notice Represents the underlying emission direction power of a bHermes token.\n *          bHermesGauges is an ERC-4626 compliant bHermes token which:\n *          votes on bribes rewards allocation for Hermes gauges in a\n *          manipulation-resistant manner.\n *\n *          The bHermes owner/authority ONLY control the maximum number\n *          and approved overrides of gauges and delegates, as well as the live gauge list.\n */\ncontract bHermesGauges is ERC20Gauges, IbHermesUnderlying {\n    /// @inheritdoc IbHermesUnderlying\n    address public immutable bHermes;\n\n    constructor(address _owner, uint32 _rewardsCycleLength, uint32 _incrementFreezeWindow)\n        ERC20Gauges(_rewardsCycleLength, _incrementFreezeWindow)\n        ERC20(\"bHermes Gauges\", \"bHERMES-G\", 18)\n    {\n        _initializeOwner(_owner);\n        bHermes = msg.sender;\n    }\n\n    /// @inheritdoc IbHermesUnderlying\n    function mint(address to, uint256 amount) external onlybHermes {\n        _mint(to, amount);\n    }\n\n    modifier onlybHermes() {\n        if (msg.sender != bHermes) revert NotbHermes();\n        _;\n    }\n}"
    },
    {
      "filename": "src/ulysses-omnichain/factories/ERC20hTokenBranchFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20} from \"../token/ERC20hTokenBranch.sol\";\n\nimport {IERC20hTokenBranchFactory, ERC20hTokenBranch} from \"../interfaces/IERC20hTokenBranchFactory.sol\";\n\n/// @title ERC20hTokenBranch Factory Contract\ncontract ERC20hTokenBranchFactory is Ownable, IERC20hTokenBranchFactory {\n    /// @notice Local Network Identifier.\n    uint24 public immutable localChainId;\n\n    /// @notice Local Port Address\n    address immutable localPortAddress;\n\n    /// @notice Local Branch Core Router Address responsible for the addition of new tokens to the system.\n    address localCoreRouterAddress;\n\n    /// @notice Local hTokens deployed in current chain.\n    ERC20hTokenBranch[] public hTokens;\n\n    /// @notice Number of hTokens deployed in current chain.\n    uint256 public hTokensLenght;\n\n    constructor(uint24 _localChainId, address _localPortAddress) {\n        require(_localPortAddress != address(0), \"Port address cannot be 0\");\n\n        localChainId = _localChainId;\n        localPortAddress = _localPortAddress;\n        _initializeOwner(msg.sender);\n    }\n\n    function initialize(address _wrappedNativeTokenAddress, address _coreRouter) external onlyOwner {\n        require(_coreRouter != address(0), \"CoreRouter address cannot be 0\");\n\n        ERC20hTokenBranch newToken = new ERC20hTokenBranch(\n            ERC20(_wrappedNativeTokenAddress).n"
    }
  ]
}