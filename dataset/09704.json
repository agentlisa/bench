{
  "Title": "[M-09] Should prevent users from sending more native tokens in the `startBridgeTokensViaCBridge` function",
  "Content": "_Submitted by shw, also found by hickuphh3, hyh, Picodes, and pmerkleplant_\n\nWhen a user bridges a native token via the `startBridgeTokensViaCBridge` function of `CBridgeFacet`, the contract checks whether `msg.value >= _cBridgeData.amount` holds. In other words, if a user accidentally sends more native tokens than he has to, the contract accepts it but only bridges the `_cBridgeData.amount` amount of tokens. The rest of the tokens are left in the contract and can be recovered by anyone (see another submission for details).\n\nNotice that in the similar functions of other facets (e.g., `AnyswapFacet`, `HopFacet`), the provided native token is ensured to be the exact bridged amount, which effectively prevents the above scenario of loss of funds.\n\n### Proof of Concept\n\n[CBridgeFacet.sol#L68](https://github.com/code-423n4/2022-03-lifinance/blob/main/src/Facets/CBridgeFacet.sol#L68)\n\n### Recommended Mitigation Steps\n\nConsider changing `>=` to `==` at line 68.\n\n**[H3xept (Li.Fi) commented](https://github.com/code-423n4/2022-03-lifinance-findings/issues/207#issuecomment-1085690955):**\n > Fixed by lifinance/lifi-contracts@bb21af9a30ea73393101fc80efaa3a1f7cf25bd1\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-03-lifinance-findings/issues/207#issuecomment-1100717383):**\n > Sponsor confirmed with fix.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-03-lifinance",
  "Code": [
    {
      "filename": "src/Facets/CBridgeFacet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ICBridge } from \"../Interfaces/ICBridge.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title CBridge Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for bridging through CBridge\n */\ncontract CBridgeFacet is ILiFi, Swapper {\n    /* ========== Storage ========== */\n\n    bytes32 internal constant NAMESPACE = keccak256(\"com.lifi.facets.cbridge2\");\n    struct Storage {\n        address cBridge;\n        uint64 cBridgeChainId;\n    }\n\n    /* ========== Types ========== */\n\n    struct CBridgeData {\n        address receiver;\n        address token;\n        uint256 amount;\n        uint64 dstChainId;\n        uint64 nonce;\n        uint32 maxSlippage;\n    }\n\n    /* ========== Init ========== */\n\n    /**\n     * @notice Initializes local variables for the CBridge facet\n     * @param _cBridge address of the canonical CBridge router contract\n     * @param _chainId chainId of this deployed contract\n     */\n    function initCbridge(address _cBridge, uint64 _chainId) external {\n        Storage storage s = getStorage();\n        LibDiamond.enforceIsContractOwner();\n        s.cBridge = _cBridge;\n        s.cBridgeChainId = _chainId;\n        emit Inited(s.cBridge, s.cBridgeChainId);\n    }\n\n    /* ========== Public Bridge Functions ========== */\n\n    /**\n     * @notice Bridges tokens via CBridge\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _cBridgeData data specific to CBridge\n     */\n    function startBridgeTokensViaCBridge(LiFiData memory _lifiData, CBridgeData calldata _cBridgeData) public payable {\n        if (_cBridgeData.token != address(0)) {\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);\n\n            LibAsset.transferFromERC20(_cBridgeData.token, msg.sender, address(this), _cBridgeData.amount);\n\n            require(\n                LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance == _cBridgeData.amount,\n                \"ERR_INVALID_AMOUNT\"\n            );\n        } else {\n            require(msg.value >= _cBridgeData.amount, \"ERR_INVALID_AMOUNT\");\n        }\n\n        _startBridge(_cBridgeData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Performs a swap before bridging via CBridge\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData an array of swap related data for performing swaps before bridging\n     * @param _cBridgeData data specific to CBridge\n     */\n    function swapAndStartBridgeTokensViaCBridge(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        CBridgeData memory _cBridgeData\n    ) public payable {\n        if (_cBridgeData.token != address(0)) {\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);\n\n            // Swap\n            _executeSwaps(_lifiData, _swapData);\n\n            uint256 _postSwapBalance = LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _cBridgeData.amount = _postSwapBalance;\n        } else {\n            uint256 _fromBalance = address(this).balance;\n\n            // Swap\n            _executeSwaps(_lifiData, _swapData);\n\n            uint256 _postSwapBalance = address(this).balance - _fromBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _cBridgeData.amount = _postSwapBalance;\n        }\n\n        _startBridge(_cBridgeData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /* ========== Internal Functions ========== */\n\n    /*\n     * @dev Conatains the business logic for the bridge via CBridge\n     * @param _cBridgeData data specific to CBridge\n     */\n    function _startBridge(CBridgeData memory _cBridgeData) internal {\n        Storage storage s = getStorage();\n        address bridge = _bridge();\n\n        // Do CBridge stuff\n        require(s.cBridgeChainId != _cBridgeData.dstChainId, \"Cannot bridge to the same network.\");\n\n        if (LibAsset.isNativeAsset(_cBridgeData.token)) {\n            ICBridge(bridge).sendNative(\n                _cBridgeData.receiver,\n                _cBridgeData.amount,\n                _cBridgeData.dstChainId,\n                _cBridgeData.nonce,\n                _cBridgeData.maxSlippage\n            );\n        } else {\n            // Give CBridge approval to bridge tokens\n            LibAsset.approveERC20(IERC20(_cBridgeData.token), bridge, _cBridgeData.amount);\n            // solhint-disable check-send-result\n            ICBridge(bridge).send(\n                _cBridgeData.receiver,\n                _cBridgeData.token,\n                _cBridgeData.amount,\n                _cBridgeData.dstChainId,\n                _cBridgeData.nonce,\n                _cBridgeData.maxSlippage\n            );\n        }\n    }\n\n    /*\n     * @dev Public view function for the CBridge router address\n     * @returns the router address\n     */\n    function _bridge() internal view returns (address) {\n        Storage storage s = getStorage();\n        return s.cBridge;\n    }\n\n    /**\n     * @dev fetch local storage\n     */\n    function getStorage() internal pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}"
    }
  ]
}