{
  "Title": "Secondary short liquidation reverts due to arithmetic underflow in volatile market conditions",
  "Content": "# Secondary short liquidation reverts due to arithmetic underflow in volatile market conditions\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallSecondaryFacet.sol#L177\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallSecondaryFacet.sol#L177</a>\n\n\n## Summary\n\nThe `ercDebtAtOraclePrice` is calculated based on the cached Oracle price, which is not updated with the retrieved, potentially fresh spot price due to the 15-minute staleness limit at the beginning of the secondary liquidation call. This results in the `ercDebtAtOraclePrice` being greater than the short's available collateral, resulting in an underflow error when attempting to subtract the calculated `ercDebtAtOraclePrice` from the `m.short.collateral`.\n\n## Vulnerability Details\n\nShorts with a collateral ratio below `secondaryLiquidationCR`, i.e., 150% by default, can be liquidated in batches via the secondary liquidation mechanism, executed via the `MarginCallSecondaryFacet.liquidateSecondary` function.\n\nAll shorts within the batch are iterated, and for each short, important values are kept in memory within the `MTypes.MarginCallSecondary` struct, evaluated in the `_setMarginCallStruct` function. The collateral ratio, `m.cRatio`, is [calculated via the `LibShortRecord.getCollateralRatioSpotPrice` function](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallSecondaryFacet.sol#L144), based on the given oracle price.\n\nThe Oracle price is determined by the [`LibOracle.getSavedOrSpotOraclePrice` function in line 47](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallSecondaryFacet.sol#L47), which either [returns the current spot price if the cached price is stale (older than 15 min) or the cached price](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOracle.sol#L153-L159).\n\n```solidity\n153: function getSavedOrSpotOraclePrice(address asset) internal view returns (uint256) {\n154:     if (LibOrders.getOffsetTime() - getTime(asset) < 15 minutes) {\n155:         return getPrice(asset);\n156:     } else {\n157:         return getOraclePrice(asset);\n158:     }\n159: }\n```\n\nFurther on, the liquidation proceeds in the `_secondaryLiquidationHelper` function. [If the short's `cRatio` is greater than 100% in line 166](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallSecondaryFacet.sol#L166), the remaining collateral (i.e., the collateral minus the debt) is refunded. It is either refunded to the shorter if the `cRatio` is greater than 110% (`m.minimumCR`), or, otherwise, to the TAPP (`address(this)`).\n\n[contracts/facets/MarginCallSecondaryFacet.sol#L177](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallSecondaryFacet.sol#L177)\n\n```solidity\n162: function _secondaryLiquidationHelper(MTypes.MarginCallSecondary memory m) private {\n163:     // @dev when cRatio <= 1 liquidator eats loss, so it's expected that only TAPP would call\n164:     m.liquidatorCollateral = m.short.collateral;\n165:\n166:     if (m.cRatio > 1 ether) {\n167:         uint88 ercDebtAtOraclePrice =\n168:             m.short.ercDebt.mulU88(LibOracle.getPrice(m.asset)); // eth\n169:         m.liquidatorCollateral = ercDebtAtOraclePrice;\n170:\n171:         // if cRatio > 110%, shorter gets remaining collateral\n172:         // Otherwise they take a penalty, and remaining goes to the pool\n173:         address remainingCollateralAddress =\n174:             m.cRatio > m.minimumCR ? m.shorter : address(this);\n175:\n176:         s.vaultUser[m.vault][remainingCollateralAddress].ethEscrowed +=\n177: âŒ          m.short.collateral - ercDebtAtOraclePrice;\n178:     }\n179:\n180:     LibShortRecord.disburseCollateral(\n181:         m.asset,\n182:         m.shorter,\n183:         m.short.collateral,\n184:         m.short.zethYieldRate,\n185:         m.short.updatedAt\n186:     );\n187:     LibShortRecord.deleteShortRecord(m.asset, m.shorter, m.short.id);\n188: }\n```\n\nThe value of the debt, `ercDebtAtOraclePrice`, [is calculated based on the currently **cached** price](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallSecondaryFacet.sol#L167-L168), as the [`LibOracle.getPrice` function returns the stored price](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOracle.sol#L147-L150).\n\n> [!NOTE]\n> The initially retrieved Oracle price at the beginning of the liquidation call, returned by the `LibOracle.getSavedOrSpotOraclePrice` function, [**does not** store the retrieved spot price in storage if the cached price is stale](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOracle.sol#L153-L159).\n\nConsequently, there are potentially two different asset prices used. The asset's spot price and the cached, stale oracle price.\n\nConsider the case where there is a significant difference between the spot price and the cached price. This would calculate the `m.cRatio` based on the spot price and the `ercDebtAtOraclePrice` based on the cached price.\n\n**This is demonstrated in the following example:**\n\nConsider the following liquidateable short position (_simplified, ignores decimal precision for this demonstration_):\n\n| Collateral | Debt       | Collateralization Ratio (based on spot price) | Price ETH/USD | Spot Price TOKEN/ETH | Cached Price TOKEN/ETH |\n| ---------- | ---------- | --------------------------------------------- | ------------- | -------------------- | ---------------------- |\n| 1 ETH      | 1400 TOKEN | $${1 \\over {1400 * 0.0005}} \\approx 142\\\\%$$  | 2000          | 0.0005               | 0.00075                |\n\nCalculating the `ercDebtAtOraclePrice` with the cached oracle price `0.00075` for TOKEN/ETH, returned by the `LibOracle.getPrice` function, results in:\n\n$$\n\\begin{align}\nercDebtAtOraclePrice &= debt \\cdot price \\\\\n&= 1400 \\cdot 0.00075 \\\\\n&= 1.05 \\text{ ETH}\n\\end{align}\n$$\n\nThe resulting debt value, quoted in ETH, is `1.05 ETH`, which is larger than the short's available collateral, `m.short.collateral = 1 ETH`.\n\nThis results in an arithmetic underflow error [attempting to subtract the calculated `ercDebtAtOraclePrice` from `m.short.collateral` in line 177](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallSecondaryFacet.sol#L177).\n\n**Specifically, this scenario occurs in the following situation:**\n\n1. A user opens a short position with a collateral of $1 \\text{ ETH}$ and a debt of $1400 \\text{ TOKEN}$ at TOKEN/ETH price of $0.00014286 \\text{ ETH}$ -> Debt in ETH: $1400 * 0.00014286 = 0.2 \\text{ ETH}$ -> CR = $1/0.2 = 500\\\\%$\n2. The spot (oracle) price of TOKEN/ETH increases from $0.00014286 \\text{ ETH}$ to $0.00075 \\text{ ETH}$ -> Debt in ETH: $1400 * 0.00075 = 1.05 \\text{ ETH}$ -> CR = $1 / 1.05 \\approx 95\\\\%$ (eligible for secondary liquidation - _also for primary liquidation due to < 110%_)\n3. New orders for the TOKEN asset are added to the order book, leading to the oracle price being updated/cached to $0.00075 \\text{ ETH}$ per TOKEN\n4. ~15min after the price got updated and cached, the TOKEN/ETH spot price decreases from $0.00075 \\text{ ETH}$ to $0.0005 \\text{ ETH}$. The CR improves -> CR = $1/(1400 * 0.0005) \\approx 142\\\\%$\n5. Secondary liquidation is attempted to liquidate the short ([primary short liquidation is not possible due to the 110% CR limit](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallPrimaryFacet.sol#L357))\n6. During the secondary liquidation call, `m.cRatio` is **calculated based on the recent spot price** (in step 4, due to cached price older than 15min) of $0.0005 \\text{ ETH}$ -> Debt in ETH: $1400 * 0.0005 = 0.7 \\text{ ETH}$ -> CR = $ 1 / 0.7 \\approx 142\\\\%$\n7. In line 168, `ercDebtAtOraclePrice` is calculated based on the **previously cached oracle price** of $0.00075 \\text{ ETH}$ -> $1400 * 0.00075 = 1.05 \\text{ ETH}$\n8. In line 176, `m.short.collateral` is subtracted by `ercDebtAtOraclePrice` -> $1 - 1.05= -0.05 \\text{ ETH}$ -> arithmetic underflow error -> **reverts!**\n\n## Impact\n\nThe secondary short liquidation mechanism reverts in certain market situations, forcing liquidators to wait for the CR to decrease further to be able to use the primary liquidation mechanism. This puts the overall collateral ratio and, thus the asset peg under pressure as liquidations can not be executed in a timely manner.\n\n## Tools Used\n\nManual Review\n\n## Recommendations\n\nConsider also using the minimum of the `m.short.collateral` and `ercDebtAtOraclePrice` values, as similarly done in [lines 204-205](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallSecondaryFacet.sol#L205).\n",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/facets/MarginCallSecondaryFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {IAsset} from \"interfaces/IAsset.sol\";\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {STypes, MTypes, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract MarginCallSecondaryFacet is Modifiers {\n    using LibShortRecord for STypes.ShortRecord;\n    using U256 for uint256;\n    using U88 for uint88;\n    using U80 for uint80;\n\n    /**\n     * @notice Liquidates short using liquidator's ercEscrowed or wallet\n     * @dev Secondary liquidation function. Doesn't need flag\n     * @dev Must liquidate all of the debt. No partial (unless TAPP short)\n     *\n     * @param asset The market that will be impacted\n     * @param batches Array of shorters and shortRecordIds to liquidate\n     * @param liquidateAmount Amount of ercDebt to liquidate\n     * @param isWallet Liquidate using wallet balance when true, ercEscrowed when false\n     *\n     */\n\n    //@dev If you want to liquidated more than uint88.max worth of erc in shorts, you must call liquidateSecondary multiple times\n    function liquidateSecondary(\n        address asset,\n        MTypes.BatchMC[] memory batches,\n        uint88 liquidateAmount,\n        bool isWallet\n    ) external onlyValidAsset(asset) isNotFrozen(asset) nonReentrant {\n        STypes.AssetUser storage AssetUser = s.assetUser[asset][msg.sender];\n        MTypes.MarginCallSecondary memory m;\n        uint256 minimumCR = LibAsset.minimumCR(asset);\n        uint256 oraclePrice = LibOracle.getSavedOrSpotOraclePrice(asset);\n        uint256 secondaryLiquidationCR = LibAsset.secondaryLiquidationCR(asset);\n\n        uint88 liquidatorCollateral;\n        uint88 liquidateAmountLeft = liquidateAmount;\n        for (uint256 i; i < batches.length;) {\n            m = _setMarginCallStruct(\n                asset, batches[i].shorter, batches[i].shortId, minimumCR, oraclePrice\n            );\n\n            unchecked {\n                ++i;\n            }\n\n            // If ineligible, skip to the next shortrecord instead of reverting\n            if (\n                m.shorter == msg.sender || m.cRatio > secondaryLiquidationCR\n                    || m.short.status == SR.Cancelled\n                    || m.short.id >= s.assetUser[asset][m.shorter].shortRecordId\n                    || m.short.id < Constants.SHORT_STARTING_ID\n                    || (m.shorter != address(this) && liquidateAmountLeft < m.short.ercDebt)\n            ) {\n                continue;\n            }\n\n            bool partialTappLiquidation;\n            // Setup partial liquidation of TAPP short\n            if (m.shorter == address(this)) {\n                partialTappLiquidation = liquidateAmountLeft < m.short.ercDebt;\n                if (partialTappLiquidation) {\n                    m.short.ercDebt = liquidateAmountLeft;\n                }\n            }\n\n            // Determine which secondary liquidation method to use\n            if (isWallet) {\n                IAsset tokenContract = IAsset(asset);\n                uint256 walletBalance = tokenContract.balanceOf(msg.sender);\n                if (walletBalance < m.short.ercDebt) continue;\n                tokenContract.burnFrom(msg.sender, m.short.ercDebt);\n                assert(tokenContract.balanceOf(msg.sender) < walletBalance);\n            } else {\n                if (AssetUser.ercEscrowed < m.short.ercDebt) {\n                    continue;\n                }\n                AssetUser.ercEscrowed -= m.short.ercDebt;\n            }\n\n            if (partialTappLiquidation) {\n                // Partial liquidation of TAPP short\n                _secondaryLiquidationHelperPartialTapp(m);\n            } else {\n                // Full liquidation\n                _secondaryLiquidationHelper(m);\n            }\n\n            // Update in memory for final state change after loops\n            liquidatorCollateral += m.liquidatorCollateral;\n            liquidateAmountLeft -= m.short.ercDebt;\n            if (liquidateAmountLeft == 0) break;\n        }\n\n        if (liquidateAmount == liquidateAmountLeft) {\n            revert Errors.MarginCallSecondaryNoValidShorts();\n        }\n\n        // Update finalized state changes\n        s.asset[asset].ercDebt -= liquidateAmount - liquidateAmountLeft;\n        s.vaultUser[m.vault][msg.sender].ethEscrowed += liquidatorCollateral;\n        emit Events.LiquidateSecondary(asset, batches, msg.sender, isWallet);\n    }\n\n    /**\n     * @notice Sets the memory struct m with initial data\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter getting liquidated\n     * @param id id of short getting liquidated\n     *\n     * @return m Memory struct used throughout MarginCallPrimaryFacet.sol\n     */\n\n    function _setMarginCallStruct(\n        address asset,\n        address shorter,\n        uint8 id,\n        uint256 minimumCR,\n        uint256 oraclePrice\n    ) private returns (MTypes.MarginCallSecondary memory) {\n        LibShortRecord.updateErcDebt(asset, shorter, id);\n\n        MTypes.MarginCallSecondary memory m;\n        m.asset = asset;\n        m.short = s.shortRecords[asset][shorter][id];\n        m.vault = s.asset[asset].vault;\n        m.shorter = shorter;\n        m.minimumCR = minimumCR;\n        m.cRatio = m.short.getCollateralRatioSpotPrice(oraclePrice);\n        return m;\n    }\n\n    /**\n     * @notice Handles accounting for secondary liquidation methods (wallet and ercEscrowed)\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     *\n     */\n    // +----------------+---------------+---------+-------+\n    // |     Cratio     |  Liquidator   | Shorter | Pool  |\n    // +----------------+---------------+---------+-------+\n    // | >= 1.5         | (cannot call) | n/a     | n/a   |\n    // | 1.1 <= c < 1.5 | 1             | c - 1   | 0     |\n    // | 1.0 < c 1.1    | 1             | 0       | c - 1 |\n    // | c <= 1         | c             | 0       | 0     |\n    // +----------------+---------------+---------+-------+\n    function _secondaryLiquidationHelper(MTypes.MarginCallSecondary memory m) private {\n        // @dev when cRatio <= 1 liquidator eats loss, so it's expected that only TAPP would call\n        m.liquidatorCollateral = m.short.collateral;\n\n        if (m.cRatio > 1 ether) {\n            uint88 ercDebtAtOraclePrice =\n                m.short.ercDebt.mulU88(LibOracle.getPrice(m.asset)); // eth\n            m.liquidatorCollateral = ercDebtAtOraclePrice;\n\n            // if cRatio > 110%, shorter gets remaining collateral\n            // Otherwise they take a penalty, and remaining goes to the pool\n            address remainingCollateralAddress =\n                m.cRatio > m.minimumCR ? m.shorter : address(this);\n\n            s.vaultUser[m.vault][remainingCollateralAddress].ethEscrowed +=\n                m.short.collateral - ercDebtAtOraclePrice;\n        }\n\n        LibShortRecord.disburseCollateral(\n            m.asset,\n            m.shorter,\n            m.short.collateral,\n            m.short.zethYieldRate,\n            m.short.updatedAt\n        );\n        LibShortRecord.deleteShortRecord(m.asset, m.shorter, m.short.id);\n    }\n\n    function min88(uint256 a, uint88 b) private pure returns (uint88) {\n        if (a > type(uint88).max) revert Errors.InvalidAmount();\n        return a < b ? uint88(a) : b;\n    }\n\n    function _secondaryLiquidationHelperPartialTapp(MTypes.MarginCallSecondary memory m)\n        private\n    {\n        STypes.ShortRecord storage short =\n            s.shortRecords[m.asset][address(this)][m.short.id];\n        // Update erc balance\n        short.ercDebt -= m.short.ercDebt; // @dev m.short.ercDebt was updated earlier to equal erc filled\n        // Update eth balance\n        // If c-ratio < 1 then it's possible to lose eth owed over short collateral\n        m.liquidatorCollateral =\n            min88(m.short.ercDebt.mul(LibOracle.getPrice(m.asset)), m.short.collateral);\n        short.collateral -= m.liquidatorCollateral;\n        LibShortRecord.disburseCollateral(\n            m.asset,\n            m.shorter,\n            m.liquidatorCollateral,\n            m.short.zethYieldRate,\n            m.short.updatedAt\n        );\n    }\n}"
    },
    {
      "filename": "contracts/facets/MarginCallSecondaryFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {IAsset} from \"interfaces/IAsset.sol\";\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {STypes, MTypes, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract MarginCallSecondaryFacet is Modifiers {\n    using LibShortRecord for STypes.ShortRecord;\n    using U256 for uint256;\n    using U88 for uint88;\n    using U80 for uint80;\n\n    /**\n     * @notice Liquidates short using liquidator's ercEscrowed or wallet\n     * @dev Secondary liquidation function. Doesn't need flag\n     * @dev Must liquidate all of the debt. No partial (unless TAPP short)\n     *\n     * @param asset The market that will be impacted\n     * @param batches Array of shorters and shortRecordIds to liquidate\n     * @param liquidateAmount Amount of ercDebt to liquidate\n     * @param isWallet Liquidate using wallet balance when true, ercEscrowed when false\n     *\n     */\n\n    //@dev If you want to liquidated more than uint88.max worth of erc in shorts, you must call liquidateSecondary multiple times\n    function liquidateSecondary(\n        address asset,\n        MTypes.BatchMC[] memory batches,\n        uint88 liquidateAmount,\n        bool isWallet\n    ) external onlyValidAsset(asset) isNotFrozen(asset) nonReentrant {\n        STypes.AssetUser storage AssetUser = s.assetUser[asset][msg.sender];\n        MTypes.MarginCallSecondary memory m;\n        uint256 minimumCR = LibAsset.minimumCR(asset);\n        uint256 oraclePrice = LibOracle.getSavedOrSpotOraclePrice(asset);\n        uint256 secondaryLiquidationCR = LibAsset.secondaryLiquidationCR(asset);\n\n        uint88 liquidatorCollateral;\n        uint88 liquidateAmountLeft = liquidateAmount;\n        for (uint256 i; i < batches.length;) {\n            m = _setMarginCallStruct(\n                asset, batches[i].shorter, batches[i].shortId, minimumCR, oraclePrice\n            );\n\n            unchecked {\n                ++i;\n            }\n\n            // If ineligible, skip to the next shortrecord instead of reverting\n            if (\n                m.shorter == msg.sender || m.cRatio > secondaryLiquidationCR\n                    || m.short.status == SR.Cancelled\n                    || m.short.id >= s.assetUser[asset][m.shorter].shortRecordId\n                    || m.short.id < Constants.SHORT_STARTING_ID\n                    || (m.shorter != address(this) && liquidateAmountLeft < m.short.ercDebt)\n            ) {\n                continue;\n            }\n\n            bool partialTappLiquidation;\n            // Setup partial liquidation of TAPP short\n            if (m.shorter == address(this)) {\n                partialTappLiquidation = liquidateAmountLeft < m.short.ercDebt;\n                if (partialTappLiquidation) {\n                    m.short.ercDebt = liquidateAmountLeft;\n                }\n            }\n\n            // Determine which secondary liquidation method to use\n            if (isWallet) {\n                IAsset tokenContract = IAsset(asset);\n                uint256 walletBalance = tokenContract.balanceOf(msg.sender);\n                if (walletBalance < m.short.ercDebt) continue;\n                tokenContract.burnFrom(msg.sender, m.short.ercDebt);\n                assert(tokenContract.balanceOf(msg.sender) < walletBalance);\n            } else {\n                if (AssetUser.ercEscrowed < m.short.ercDebt) {\n                    continue;\n                }\n                AssetUser.ercEscrowed -= m.short.ercDebt;\n            }\n\n            if (partialTappLiquidation) {\n                // Partial liquidation of TAPP short\n                _secondaryLiquidationHelperPartialTapp(m);\n            } else {\n                // Full liquidation\n                _secondaryLiquidationHelper(m);\n            }\n\n            // Update in memory for final state change after loops\n            liquidatorCollateral += m.liquidatorCollateral;\n            liquidateAmountLeft -= m.short.ercDebt;\n            if (liquidateAmountLeft == 0) break;\n        }\n\n        if (liquidateAmount == liquidateAmountLeft) {\n            revert Errors.MarginCallSecondaryNoValidShorts();\n        }\n\n        // Update finalized state changes\n        s.asset[asset].ercDebt -= liquidateAmount - liquidateAmountLeft;\n        s.vaultUser[m.vault][msg.sender].ethEscrowed += liquidatorCollateral;\n        emit Events.LiquidateSecondary(asset, batches, msg.sender, isWallet);\n    }\n\n    /**\n     * @notice Sets the memory struct m with initial data\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter getting liquidated\n     * @param id id of short getting liquidated\n     *\n     * @return m Memory struct used throughout MarginCallPrimaryFacet.sol\n     */\n\n    function _setMarginCallStruct(\n        address asset,\n        address shorter,\n        uint8 id,\n        uint256 minimumCR,\n        uint256 oraclePrice\n    ) private returns (MTypes.MarginCallSecondary memory) {\n        LibShortRecord.updateErcDebt(asset, shorter, id);\n\n        MTypes.MarginCallSecondary memory m;\n        m.asset = asset;\n        m.short = s.shortRecords[asset][shorter][id];\n        m.vault = s.asset[asset].vault;\n        m.shorter = shorter;\n        m.minimumCR = minimumCR;\n        m.cRatio = m.short.getCollateralRatioSpotPrice(oraclePrice);\n        return m;\n    }\n\n    /**\n     * @notice Handles accounting for secondary liquidation methods (wallet and ercEscrowed)\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     *\n     */\n    // +----------------+---------------+---------+-------+\n    // |     Cratio     |  Liquidator   | Shorter | Pool  |\n    // +----------------+---------------+---------+-------+\n    // | >= 1.5         | (cannot call) | n/a     | n/a   |\n    // | 1.1 <= c < 1.5 | 1             | c - 1   | 0     |\n    // | 1.0 < c 1.1    | 1             | 0       | c - 1 |\n    // | c <= 1         | c             | 0       | 0     |\n    // +----------------+---------------+---------+-------+\n    function _secondaryLiquidationHelper(MTypes.MarginCallSecondary memory m) private {\n        // @dev when cRatio <= 1 liquidator eats loss, so it's expected that only TAPP would call\n        m.liquidatorCollateral = m.short.collateral;\n\n        if (m.cRatio > 1 ether) {\n            uint88 ercDebtAtOraclePrice =\n                m.short.ercDebt.mulU88(LibOracle.getPrice(m.asset)); // eth\n            m.liquidatorCollateral = ercDebtAtOraclePrice;\n\n            // if cRatio > 110%, shorter gets remaining collateral\n            // Otherwise they take a penalty, and remaining goes to the pool\n            address remainingCollateralAddress =\n                m.cRatio > m.minimumCR ? m.shorter : address(this);\n\n            s.vaultUser[m.vault][remainingCollateralAddress].ethEscrowed +=\n                m.short.collateral - ercDebtAtOraclePrice;\n        }\n\n        LibShortRecord.disburseCollateral(\n            m.asset,\n            m.shorter,\n            m.short.collateral,\n            m.short.zethYieldRate,\n            m.short.updatedAt\n        );\n        LibShortRecord.deleteShortRecord(m.asset, m.shorter, m.short.id);\n    }\n\n    function min88(uint256 a, uint88 b) private pure returns (uint88) {\n        if (a > type(uint88).max) revert Errors.InvalidAmount();\n        return a < b ? uint88(a) : b;\n    }\n\n    function _secondaryLiquidationHelperPartialTapp(MTypes.MarginCallSecondary memory m)\n        private\n    {\n        STypes.ShortRecord storage short =\n            s.shortRecords[m.asset][address(this)][m.short.id];\n        // Update erc balance\n        short.ercDebt -= m.short.ercDebt; // @dev m.short.ercDebt was updated earlier to equal erc filled\n        // Update eth balance\n        // If c-ratio < 1 then it's possible to lose eth owed over short collateral\n        m.liquidatorCollateral =\n            min88(m.short.ercDebt.mul(LibOracle.getPrice(m.asset)), m.short.collateral);\n        short.collateral -= m.liquidatorCollateral;\n        LibShortRecord.disburseCollateral(\n            m.asset,\n            m.shorter,\n            m.liquidatorCollateral,\n            m.short.zethYieldRate,\n            m.short.updatedAt\n        );\n    }\n}"
    },
    {
      "filename": "contracts/facets/MarginCallSecondaryFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {IAsset} from \"interfaces/IAsset.sol\";\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {STypes, MTypes, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract MarginCallSecondaryFacet is Modifiers {\n    using LibShortRecord for STypes.ShortRecord;\n    using U256 for uint256;\n    using U88 for uint88;\n    using U80 for uint80;\n\n    /**\n     * @notice Liquidates short using liquidator's ercEscrowed or wallet\n     * @dev Secondary liquidation function. Doesn't need flag\n     * @dev Must liquidate all of the debt. No partial (unless TAPP short)\n     *\n     * @param asset The market that will be impacted\n     * @param batches Array of shorters and shortRecordIds to liquidate\n     * @param liquidateAmount Amount of ercDebt to liquidate\n     * @param isWallet Liquidate using wallet balance when true, ercEscrowed when false\n     *\n     */\n\n    //@dev If you want to liquidated more than uint88.max worth of erc in shorts, you must call liquidateSecondary multiple times\n    function liquidateSecondary(\n        address asset,\n        MTypes.BatchMC[] memory batches,\n        uint88 liquidateAmount,\n        bool isWallet\n    ) external onlyValidAsset(asset) isNotFrozen(asset) nonReentrant {\n        STypes.AssetUser storage AssetUser = s.assetUser[asset][msg.sender];\n        MTypes.MarginCallSecondary memory m;\n        uint256 minimumCR = LibAsset.minimumCR(asset);\n        uint256 oraclePrice = LibOracle.getSavedOrSpotOraclePrice(asset);\n        uint256 secondaryLiquidationCR = LibAsset.secondaryLiquidationCR(asset);\n\n        uint88 liquidatorCollateral;\n        uint88 liquidateAmountLeft = liquidateAmount;\n        for (uint256 i; i < batches.length;) {\n            m = _setMarginCallStruct(\n                asset, batches[i].shorter, batches[i].shortId, minimumCR, oraclePrice\n            );\n\n            unchecked {\n                ++i;\n            }\n\n            // If ineligible, skip to the next shortrecord instead of reverting\n            if (\n                m.shorter == msg.sender || m.cRatio > secondaryLiquidationCR\n                    || m.short.status == SR.Cancelled\n                    || m.short.id >= s.assetUser[asset][m.shorter].shortRecordId\n                    || m.short.id < Constants.SHORT_STARTING_ID\n                    || (m.shorter != address(this) && liquidateAmountLeft < m.short.ercDebt)\n            ) {\n                continue;\n            }\n\n            bool partialTappLiquidation;\n            // Setup partial liquidation of TAPP short\n            if (m.shorter == address(this)) {\n                partialTappLiquidation = liquidateAmountLeft < m.short.ercDebt;\n                if (partialTappLiquidation) {\n                    m.short.ercDebt = liquidateAmountLeft;\n                }\n            }\n\n            // Determine which secondary liquidation method to use\n            if (isWallet) {\n                IAsset tokenContract = IAsset(asset);\n                uint256 walletBalance = tokenContract.balanceOf(msg.sender);\n                if (walletBalance < m.short.ercDebt) continue;\n                tokenContract.burnFrom(msg.sender, m.short.ercDebt);\n                assert(tokenContract.balanceOf(msg.sender) < walletBalance);\n            } else {\n                if (AssetUser.ercEscrowed < m.short.ercDebt) {\n                    continue;\n                }\n                AssetUser.ercEscrowed -= m.short.ercDebt;\n            }\n\n            if (partialTappLiquidation) {\n                // Partial liquidation of TAPP short\n                _secondaryLiquidationHelperPartialTapp(m);\n            } else {\n                // Full liquidation\n                _secondaryLiquidationHelper(m);\n            }\n\n            // Update in memory for final state change after loops\n            liquidatorCollateral += m.liquidatorCollateral;\n            liquidateAmountLeft -= m.short.ercDebt;\n            if (liquidateAmountLeft == 0) break;\n        }\n\n        if (liquidateAmount == liquidateAmountLeft) {\n            revert Errors.MarginCallSecondaryNoValidShorts();\n        }\n\n        // Update finalized state changes\n        s.asset[asset].ercDebt -= liquidateAmount - liquidateAmountLeft;\n        s.vaultUser[m.vault][msg.sender].ethEscrowed += liquidatorCollateral;\n        emit Events.LiquidateSecondary(asset, batches, msg.sender, isWallet);\n    }\n\n    /**\n     * @notice Sets the memory struct m with initial data\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter getting liquidated\n     * @param id id of short getting liquidated\n     *\n     * @return m Memory struct used throughout MarginCallPrimaryFacet.sol\n     */\n\n    function _setMarginCallStruct(\n        address asset,\n        address shorter,\n        uint8 id,\n        uint256 minimumCR,\n        uint256 oraclePrice\n    ) private returns (MTypes.MarginCallSecondary memory) {\n        LibShortRecord.updateErcDebt(asset, shorter, id);\n\n        MTypes.MarginCallSecondary memory m;\n        m.asset = asset;\n        m.short = s.shortRecords[asset][shorter][id];\n        m.vault = s.asset[asset].vault;\n        m.shorter = shorter;\n        m.minimumCR = minimumCR;\n        m.cRatio = m.short.getCollateralRatioSpotPrice(oraclePrice);\n        return m;\n    }\n\n    /**\n     * @notice Handles accounting for secondary liquidation methods (wallet and ercEscrowed)\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     *\n     */\n    // +----------------+---------------+---------+-------+\n    // |     Cratio     |  Liquidator   | Shorter | Pool  |\n    // +----------------+---------------+---------+-------+\n    // | >= 1.5         | (cannot call) | n/a     | n/a   |\n    // | 1.1 <= c < 1.5 | 1             | c - 1   | 0     |\n    // | 1.0 < c 1.1    | 1             | 0       | c - 1 |\n    // | c <= 1         | c             | 0       | 0     |\n    // +----------------+---------------+---------+-------+\n    function _secondaryLiquidationHelper(MTypes.MarginCallSecondary memory m) private {\n        // @dev when cRatio <= 1 liquidator eats loss, so it's expected that only TAPP would call\n        m.liquidatorCollateral = m.short.collateral;\n\n        if (m.cRatio > 1 ether) {\n            uint88 ercDebtAtOraclePrice =\n                m.short.ercDebt.mulU88(LibOracle.getPrice(m.asset)); // eth\n            m.liquidatorCollateral = ercDebtAtOraclePrice;\n\n            // if cRatio > 110%, shorter gets remaining collateral\n            // Otherwise they take a penalty, and remaining goes to the pool\n            address remainingCollateralAddress =\n                m.cRatio > m.minimumCR ? m.shorter : address(this);\n\n            s.vaultUser[m.vault][remainingCollateralAddress].ethEscrowed +=\n                m.short.collateral - ercDebtAtOraclePrice;\n        }\n\n        LibShortRecord.disburseCollateral(\n            m.asset,\n            m.shorter,\n            m.short.collateral,\n            m.short.zethYieldRate,\n            m.short.updatedAt\n        );\n        LibShortRecord.deleteShortRecord(m.asset, m.shorter, m.short.id);\n    }\n\n    function min88(uint256 a, uint88 b) private pure returns (uint88) {\n        if (a > type(uint88).max) revert Errors.InvalidAmount();\n        return a < b ? uint88(a) : b;\n    }\n\n    function _secondaryLiquidationHelperPartialTapp(MTypes.MarginCallSecondary memory m)\n        private\n    {\n        STypes.ShortRecord storage short =\n            s.shortRecords[m.asset][address(this)][m.short.id];\n        // Update erc balance\n        short.ercDebt -= m.short.ercDebt; // @dev m.short.ercDebt was updated earlier to equal erc filled\n        // Update eth balance\n        // If c-ratio < 1 then it's possible to lose eth owed over short collateral\n        m.liquidatorCollateral =\n            min88(m.short.ercDebt.mul(LibOracle.getPrice(m.asset)), m.short.collateral);\n        short.collateral -= m.liquidatorCollateral;\n        LibShortRecord.disburseCollateral(\n            m.asset,\n            m.shorter,\n            m.liquidatorCollateral,\n            m.short.zethYieldRate,\n            m.short.updatedAt\n        );\n    }\n}"
    },
    {
      "filename": "contracts/facets/MarginCallSecondaryFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {IAsset} from \"interfaces/IAsset.sol\";\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {STypes, MTypes, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract MarginCallSecondaryFacet is Modifiers {\n    using LibShortRecord for STypes.ShortRecord;\n    using U256 for uint256;\n    using U88 for uint88;\n    using U80 for uint80;\n\n    /**\n     * @notice Liquidates short using liquidator's ercEscrowed or wallet\n     * @dev Secondary liquidation function. Doesn't need flag\n     * @dev Must liquidate all of the debt. No partial (unless TAPP short)\n     *\n     * @param asset The market that will be impacted\n     * @param batches Array of shorters and shortRecordIds to liquidate\n     * @param liquidateAmount Amount of ercDebt to liquidate\n     * @param isWallet Liquidate using wallet balance when true, ercEscrowed when false\n     *\n     */\n\n    //@dev If you want to liquidated more than uint88.max worth of erc in shorts, you must call liquidateSecondary multiple times\n    function liquidateSecondary(\n        address asset,\n        MTypes.BatchMC[] memory batches,\n        uint88 liquidateAmount,\n        bool isWallet\n    ) external onlyValidAsset(asset) isNotFrozen(asset) nonReentrant {\n        STypes.AssetUser storage AssetUser = s.assetUser[asset][msg.sender];\n        MTypes.MarginCallSecondary memory m;\n        uint256 minimumCR = LibAsset.minimumCR(asset);\n        uint256 oraclePrice = LibOracle.getSavedOrSpotOraclePrice(asset);\n        uint256 secondaryLiquidationCR = LibAsset.secondaryLiquidationCR(asset);\n\n        uint88 liquidatorCollateral;\n        uint88 liquidateAmountLeft = liquidateAmount;\n        for (uint256 i; i < batches.length;) {\n            m = _setMarginCallStruct(\n                asset, batches[i].shorter, batches[i].shortId, minimumCR, oraclePrice\n            );\n\n            unchecked {\n                ++i;\n            }\n\n            // If ineligible, skip to the next shortrecord instead of reverting\n            if (\n                m.shorter == msg.sender || m.cRatio > secondaryLiquidationCR\n                    || m.short.status == SR.Cancelled\n                    || m.short.id >= s.assetUser[asset][m.shorter].shortRecordId\n                    || m.short.id < Constants.SHORT_STARTING_ID\n                    || (m.shorter != address(this) && liquidateAmountLeft < m.short.ercDebt)\n            ) {\n                continue;\n            }\n\n            bool partialTappLiquidation;\n            // Setup partial liquidation of TAPP short\n            if (m.shorter == address(this)) {\n                partialTappLiquidation = liquidateAmountLeft < m.short.ercDebt;\n                if (partialTappLiquidation) {\n                    m.short.ercDebt = liquidateAmountLeft;\n                }\n            }\n\n            // Determine which secondary liquidation method to use\n            if (isWallet) {\n                IAsset tokenContract = IAsset(asset);\n                uint256 walletBalance = tokenContract.balanceOf(msg.sender);\n                if (walletBalance < m.short.ercDebt) continue;\n                tokenContract.burnFrom(msg.sender, m.short.ercDebt);\n                assert(tokenContract.balanceOf(msg.sender) < walletBalance);\n            } else {\n                if (AssetUser.ercEscrowed < m.short.ercDebt) {\n                    continue;\n                }\n                AssetUser.ercEscrowed -= m.short.ercDebt;\n            }\n\n            if (partialTappLiquidation) {\n                // Partial liquidation of TAPP short\n                _secondaryLiquidationHelperPartialTapp(m);\n            } else {\n                // Full liquidation\n                _secondaryLiquidationHelper(m);\n            }\n\n            // Update in memory for final state change after loops\n            liquidatorCollateral += m.liquidatorCollateral;\n            liquidateAmountLeft -= m.short.ercDebt;\n            if (liquidateAmountLeft == 0) break;\n        }\n\n        if (liquidateAmount == liquidateAmountLeft) {\n            revert Errors.MarginCallSecondaryNoValidShorts();\n        }\n\n        // Update finalized state changes\n        s.asset[asset].ercDebt -= liquidateAmount - liquidateAmountLeft;\n        s.vaultUser[m.vault][msg.sender].ethEscrowed += liquidatorCollateral;\n        emit Events.LiquidateSecondary(asset, batches, msg.sender, isWallet);\n    }\n\n    /**\n     * @notice Sets the memory struct m with initial data\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter getting liquidated\n     * @param id id of short getting liquidated\n     *\n     * @return m Memory struct used throughout MarginCallPrimaryFacet.sol\n     */\n\n    function _setMarginCallStruct(\n        address asset,\n        address shorter,\n        uint8 id,\n        uint256 minimumCR,\n        uint256 oraclePrice\n    ) private returns (MTypes.MarginCallSecondary memory) {\n        LibShortRecord.updateErcDebt(asset, shorter, id);\n\n        MTypes.MarginCallSecondary memory m;\n        m.asset = asset;\n        m.short = s.shortRecords[asset][shorter][id];\n        m.vault = s.asset[asset].vault;\n        m.shorter = shorter;\n        m.minimumCR = minimumCR;\n        m.cRatio = m.short.getCollateralRatioSpotPrice(oraclePrice);\n        return m;\n    }\n\n    /**\n     * @notice Handles accounting for secondary liquidation methods (wallet and ercEscrowed)\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     *\n     */\n    // +----------------+---------------+---------+-------+\n    // |     Cratio     |  Liquidator   | Shorter | Pool  |\n    // +----------------+---------------+---------+-------+\n    // | >= 1.5         | (cannot call) | n/a     | n/a   |\n    // | 1.1 <= c < 1.5 | 1             | c - 1   | 0     |\n    // | 1.0 < c 1.1    | 1             | 0       | c - 1 |\n    // | c <= 1         | c             | 0       | 0     |\n    // +----------------+---------------+---------+-------+\n    function _secondaryLiquidationHelper(MTypes.MarginCallSecondary memory m) private {\n        // @dev when cRatio <= 1"
    }
  ]
}