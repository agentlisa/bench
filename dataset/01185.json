{
  "Title": "Lack of slippage protection when removing liquidity from BEAN:3CRV MetaPool and adding liquidity to BEAN:ETH Well could result in loss of funds due to sandwich attack",
  "Content": "Currently, the second and third steps of the *Migration Process*, as provided in BIP-38 specification, are not included in the scope of this BIP. The primary risk associated with these steps is the swap of BEAN:3CRV LP Tokens for BEAN:ETH Well LP Tokens, given the size of the swap to be performed. Sandwiching of the transaction that executes this swap could result in loss of funds. Therefore, the use of reasonable slippage parameters is essential to prevent this. It is understood that the current use of zero [slippage parameters](https://github.com/BeanstalkFarms/Beanstalk/blob/12c608a22535e3a1fe379db1153185fe43851ea7/protocol/scripts/beanEthMigration.js#L26) within the `beanEthMigration.js` migration script when removing liquidity from the MetaPool and [adding liquidity](https://github.com/BeanstalkFarms/Beanstalk/blob/12c608a22535e3a1fe379db1153185fe43851ea7/protocol/scripts/beanEthMigration.js#L39) to the Well is only intended for testing purposes. The swap path from 3CRV -> WETH will either be executed manually via the BCM on a DEX aggregator with MEV protection or via an OTC swap, and the BCM will ensure the proper use of slippage parameters when removing/adding liquidity. It is essential that this is the case.\n\n**Beanstalk Farms:** This script is only expected to be used to mock the migration to aid in testing. The expectation is that it will never be used to execute code on mainnet and thus no slippage parameter is added.\n\n**Cyfrin:** Acknowledged.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/scripts/beanEthMigration.js",
      "content": "const { BEAN_ETH_WELL, BEAN_3_CURVE, STABLE_FACTORY, USDT, TRI_CRYPTO_POOL, CURVE_REGISTRY, WETH, BEAN, BEANSTALK, THREE_CURVE, THREE_POOL, CRYPTO_REGISTRY, UNRIPE_LP } = require(\"../test/utils/constants\");\nconst { toX } = require(\"../test/utils/helpers\");\nconst { getBeanstalk, impersonateBeanstalkOwner } = require(\"../utils\");\nconst { bipMigrateUnripeBean3CrvToBeanEth } = require(\"./bips\");\n\nasync function finishBeanEthMigration(verbose = false) {\n    const owner = await impersonateBeanstalkOwner()\n\n    await hre.network.provider.send(\"hardhat_setBalance\", [owner.address, \"0x152D02C7E14AF6800000\"]);\n\n    const beanstalk = await getBeanstalk()\n    const well = await ethers.getContractAt('IWell', BEAN_ETH_WELL)\n    const bean3CrvToken = await ethers.getContractAt('IERC20', BEAN_3_CURVE);\n    const threeCrvToken = await ethers.getContractAt('IERC20', THREE_CURVE);\n    const bean = await ethers.getContractAt('IERC20', BEAN);\n    const weth = await ethers.getContractAt('IWETH', WETH);\n    const beanEthToken = await ethers.getContractAt('IERC20', BEAN_ETH_WELL);\n    const usdt = await ethers.getContractAt('IERC20', USDT);\n    let balance = await beanstalk.getExternalBalance(owner.address, BEAN_3_CURVE)\n    if (verbose) console.log(`Bean 3 Crv Balance: ${balance}`)\n    await bean3CrvToken.connect(owner).approve(BEANSTALK, balance);\n    await beanstalk.connect(owner).removeLiquidity(\n        BEAN_3_CURVE,\n        STABLE_FACTORY,\n        balance,\n        ['0', '0'],\n        '0',\n        '0'\n    )\n\n    let balances = await well.getReserves();\n    const beanBalance = await beanstalk.getExternalBalance(owner.address, BEAN)\n    const wethBalance = balances[1].div(balances[0]).mul(beanBalance)\n    await weth.connect(owner).deposit({value: wethBalance})\n    await bean.connect(owner).approve(BEAN_ETH_WELL, beanBalance);\n    await weth.connect(owner).approve(BEAN_ETH_WELL, wethBalance);\n    await well.connect(owner).addLiquidity(\n        [beanBalance , wethBalance],\n        '0',\n        owner.address,\n        ethers.constants.MaxUint256\n    )\n\n    balance = await beanstalk.getExternalBalance(owner.address, BEAN_ETH_WELL)\n    await beanEthToken.connect(owner).approve(BEANSTALK, balance);\n    await beanstalk.connect(owner).addMigratedUnderlying(UNRIPE_LP, balance);\n    if (verbose) console.log(`Unripe LP Underlying Balance: ${await beanstalk.getTotalUnderlying(UNRIPE_LP)}`)\n\n    balances = await well.getReserves();\n    if (verbose) console.log(`Well Bean Balance: ${balances[0]}`);\n    if (verbose) console.log(`Well WETH Balance: ${balances[1]}`);\n}\n\nasync function migrateBean3CrvToBeanEth() {\n    await bipMigrateUnripeBean3CrvToBeanEth()\n    await finishBeanEthMigration()\n}\n\nexports.finishBeanEthMigration = finishBeanEthMigration;\nexports.migrateBean3CrvToBeanEth = migrateBean3CrvToBeanEth;"
    }
  ]
}