{
  "Title": "[01]",
  "Content": "\nThe critical parameters in `initialize(...)` are not set safely:\n\n*   `s.governor` should be set to `msg.sender`, because a wrong governor address will result in loss of access to all other parts, and later changing the governor to the correct address.\n*   `_l2BootloaderBytecodeHash` should be validated like `L2ContractHelper.validateBytecodeHash(_l2BootloaderBytecodeHash)` as in `GovernanceFacet`\n*   `_l2DefaultAccountBytecodeHash` should be validated like `L2ContractHelper.validateBytecodeHash(_l2DefaultAccountBytecodeHash)` as in `GovernanceFacet`\n\n[DiamondInit.sol#L39](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/DiamondInit.sol#L39)<br>\n[DiamondInit.sol#L58](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/DiamondInit.sol#L58)<br>\n[DiamondInit.sol#L59](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/DiamondInit.sol#L59)<br>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-10-zksync",
  "Code": [
    {
      "filename": "ethereum/contracts/zksync/DiamondInit.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"../common/interfaces/IAllowList.sol\";\nimport \"./interfaces/IExecutor.sol\";\nimport \"./libraries/Diamond.sol\";\nimport \"./facets/Base.sol\";\nimport \"./Config.sol\";\n\n/// @author Matter Labs\n/// @dev The contract is used only once to initialize the diamond proxy.\n/// @dev The deployment process takes care of this contract's initialization.\ncontract DiamondInit is Base {\n    constructor() reentrancyGuardInitializer {}\n\n    /// @notice zkSync contract initialization\n    /// @param _verifier address of Verifier contract\n    /// @param _governor address who can manage the contract\n    /// @param _validator address who can make blocks\n    /// @param _genesisBlockHash Block hash of the genesis (initial) block\n    /// @param _genesisIndexRepeatedStorageChanges The serial number of the shortcut storage key for genesis block\n    /// @param _genesisBlockCommitment The zk-proof commitment for the genesis block\n    /// @return Magic 32 bytes, which indicates that the contract logic is expected to be used as a diamond proxy initializer\n    function initialize(\n        Verifier _verifier,\n        address _governor,\n        address _validator,\n        bytes32 _genesisBlockHash,\n        uint64 _genesisIndexRepeatedStorageChanges,\n        bytes32 _genesisBlockCommitment,\n        IAllowList _allowList,\n        VerifierParams calldata _verifierParams,\n        bool _zkPorterIsAvailable,\n        bytes32 _l2BootloaderBytecodeHash,\n        bytes32 _l2DefaultAccountBytecodeHash\n    ) external reentrancyGuardInitializer returns (bytes32) {\n        s.verifier = _verifier;\n        s.governor = _governor;\n        s.validators[_validator] = true;\n\n        // We need to initialize the state hash because it is used in the commitment of the next block\n        IExecutor.StoredBlockInfo memory storedBlockZero = IExecutor.StoredBlockInfo(\n            0,\n            _genesisBlockHash,\n            _genesisIndexRepeatedStorageChanges,\n            0,\n            EMPTY_STRING_KECCAK,\n            DEFAULT_L2_LOGS_TREE_ROOT_HASH,\n            0,\n            _genesisBlockCommitment\n        );\n\n        s.storedBlockHashes[0] = keccak256(abi.encode(storedBlockZero));\n        s.allowList = _allowList;\n        s.verifierParams = _verifierParams;\n        s.zkPorterIsAvailable = _zkPorterIsAvailable;\n        s.l2BootloaderBytecodeHash = _l2BootloaderBytecodeHash;\n        s.l2DefaultAccountBytecodeHash = _l2DefaultAccountBytecodeHash;\n\n        return Diamond.DIAMOND_INIT_SUCCESS_RETURN_VALUE;\n    }\n}"
    },
    {
      "filename": "ethereum/contracts/zksync/DiamondInit.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"../common/interfaces/IAllowList.sol\";\nimport \"./interfaces/IExecutor.sol\";\nimport \"./libraries/Diamond.sol\";\nimport \"./facets/Base.sol\";\nimport \"./Config.sol\";\n\n/// @author Matter Labs\n/// @dev The contract is used only once to initialize the diamond proxy.\n/// @dev The deployment process takes care of this contract's initialization.\ncontract DiamondInit is Base {\n    constructor() reentrancyGuardInitializer {}\n\n    /// @notice zkSync contract initialization\n    /// @param _verifier address of Verifier contract\n    /// @param _governor address who can manage the contract\n    /// @param _validator address who can make blocks\n    /// @param _genesisBlockHash Block hash of the genesis (initial) block\n    /// @param _genesisIndexRepeatedStorageChanges The serial number of the shortcut storage key for genesis block\n    /// @param _genesisBlockCommitment The zk-proof commitment for the genesis block\n    /// @return Magic 32 bytes, which indicates that the contract logic is expected to be used as a diamond proxy initializer\n    function initialize(\n        Verifier _verifier,\n        address _governor,\n        address _validator,\n        bytes32 _genesisBlockHash,\n        uint64 _genesisIndexRepeatedStorageChanges,\n        bytes32 _genesisBlockCommitment,\n        IAllowList _allowList,\n        VerifierParams calldata _verifierParams,\n        bool _zkPorterIsAvailable,\n        bytes32 _l2BootloaderBytecodeHash,\n        bytes32 _l2DefaultAccountBytecodeHash\n    ) external reentrancyGuardInitializer returns (bytes32) {\n        s.verifier = _verifier;\n        s.governor = _governor;\n        s.validators[_validator] = true;\n\n        // We need to initialize the state hash because it is used in the commitment of the next block\n        IExecutor.StoredBlockInfo memory storedBlockZero = IExecutor.StoredBlockInfo(\n            0,\n            _genesisBlockHash,\n            _genesisIndexRepeatedStorageChanges,\n            0,\n            EMPTY_STRING_KECCAK,\n            DEFAULT_L2_LOGS_TREE_ROOT_HASH,\n            0,\n            _genesisBlockCommitment\n        );\n\n        s.storedBlockHashes[0] = keccak256(abi.encode(storedBlockZero));\n        s.allowList = _allowList;\n        s.verifierParams = _verifierParams;\n        s.zkPorterIsAvailable = _zkPorterIsAvailable;\n        s.l2BootloaderBytecodeHash = _l2BootloaderBytecodeHash;\n        s.l2DefaultAccountBytecodeHash = _l2DefaultAccountBytecodeHash;\n\n        return Diamond.DIAMOND_INIT_SUCCESS_RETURN_VALUE;\n    }\n}"
    },
    {
      "filename": "ethereum/contracts/zksync/DiamondInit.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"../common/interfaces/IAllowList.sol\";\nimport \"./interfaces/IExecutor.sol\";\nimport \"./libraries/Diamond.sol\";\nimport \"./facets/Base.sol\";\nimport \"./Config.sol\";\n\n/// @author Matter Labs\n/// @dev The contract is used only once to initialize the diamond proxy.\n/// @dev The deployment process takes care of this contract's initialization.\ncontract DiamondInit is Base {\n    constructor() reentrancyGuardInitializer {}\n\n    /// @notice zkSync contract initialization\n    /// @param _verifier address of Verifier contract\n    /// @param _governor address who can manage the contract\n    /// @param _validator address who can make blocks\n    /// @param _genesisBlockHash Block hash of the genesis (initial) block\n    /// @param _genesisIndexRepeatedStorageChanges The serial number of the shortcut storage key for genesis block\n    /// @param _genesisBlockCommitment The zk-proof commitment for the genesis block\n    /// @return Magic 32 bytes, which indicates that the contract logic is expected to be used as a diamond proxy initializer\n    function initialize(\n        Verifier _verifier,\n        address _governor,\n        address _validator,\n        bytes32 _genesisBlockHash,\n        uint64 _genesisIndexRepeatedStorageChanges,\n        bytes32 _genesisBlockCommitment,\n        IAllowList _allowList,\n        VerifierParams calldata _verifierParams,\n        bool _zkPorterIsAvailable,\n        bytes32 _l2BootloaderBytecodeHash,\n        bytes32 _l2DefaultAccountBytecodeHash\n    ) external reentrancyGuardInitializer returns (bytes32) {\n        s.verifier = _verifier;\n        s.governor = _governor;\n        s.validators[_validator] = true;\n\n        // We need to initialize the state hash because it is used in the commitment of the next block\n        IExecutor.StoredBlockInfo memory storedBlockZero = IExecutor.StoredBlockInfo(\n            0,\n            _genesisBlockHash,\n            _genesisIndexRepeatedStorageChanges,\n            0,\n            EMPTY_STRING_KECCAK,\n            DEFAULT_L2_LOGS_TREE_ROOT_HASH,\n            0,\n            _genesisBlockCommitment\n        );\n\n        s.storedBlockHashes[0] = keccak256(abi.encode(storedBlockZero));\n        s.allowList = _allowList;\n        s.verifierParams = _verifierParams;\n        s.zkPorterIsAvailable = _zkPorterIsAvailable;\n        s.l2BootloaderBytecodeHash = _l2BootloaderBytecodeHash;\n        s.l2DefaultAccountBytecodeHash = _l2DefaultAccountBytecodeHash;\n\n        return Diamond.DIAMOND_INIT_SUCCESS_RETURN_VALUE;\n    }\n}"
    }
  ]
}