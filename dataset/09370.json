{
  "Title": "[M-01] `xERC4626.sol` Some users may not be able to withdraw until `rewardsCycleEnd` the due to underflow in `beforeWithdraw()`",
  "Content": "_Submitted by WatchPug_\n\n[xERC4626.sol#L65-L68](https://github.com/fei-protocol/ERC4626/blob/2b2baba0fc480326a89251716f52d2cfa8b09230/src/xERC4626.sol#L65-L68)<br>\n\n```solidity\nfunction beforeWithdraw(uint256 amount, uint256 shares) internal virtual override {\n    super.beforeWithdraw(amount, shares);\n    storedTotalAssets -= amount;\n}\n```\n\n[xERC4626.sol#L78-L87](https://github.com/fei-protocol/ERC4626/blob/2b2baba0fc480326a89251716f52d2cfa8b09230/src/xERC4626.sol#L78-L87)<br>\n\n```solidity\nfunction syncRewards() public virtual {\n    uint192 lastRewardAmount_ = lastRewardAmount;\n    uint32 timestamp = block.timestamp.safeCastTo32();\n\n    if (timestamp < rewardsCycleEnd) revert SyncError();\n\n    uint256 storedTotalAssets_ = storedTotalAssets;\n    uint256 nextRewards = asset.balanceOf(address(this)) - storedTotalAssets_ - lastRewardAmount_;\n\n    storedTotalAssets = storedTotalAssets_ + lastRewardAmount_; // SSTORE\n    ...\n```\n\n`storedTotalAssets` is a cached value of total assets which will only include the `unlockedRewards` when the whole cycle ends.\n\nThis makes it possible for `storedTotalAssets -= amount` to revert when the withdrawal amount exceeds `storedTotalAssets`, as the withdrawal amount may include part of the `unlockedRewards` in the current cycle.\n\n### Proof of Concept\n\nGiven:\n\n*   rewardsCycleLength = 100 days\n\n1.  Alice `deposit()` 100 TRIBE tokens;\n2.  The owner transferred 100 TRIBE tokens as rewards and called `syncRewards()`;\n3.  1 day later, Alice `redeem()` with all shares, the transaction will revert at `xERC4626.beforeWithdraw()`.\n\nAlice's shares worth 101 TRIBE at this moment, but `storedTotalAssets` = 100, making `storedTotalAssets -= amount` reverts due to underflow.\n\n4.  Bob `deposit()` 1 TRIBE tokens;\n5.  Alice `withdraw()` 101 TRIBE tokens, `storedTotalAssets` becomes `0`;\n6.  Bob can't even withdraw 1 wei of TRIBE token, as `storedTotalAssets` is now `0`.\n\nIf there are no new deposits, both Alice and Bob won't be able to withdraw any of their funds until `rewardsCycleEnd`.\n\n### Recommended Mitigation Steps\n\nConsider changing to:\n\n```solidity\nfunction beforeWithdraw(uint256 amount, uint256 shares) internal virtual override {\n    super.beforeWithdraw(amount, shares);\n    uint256 _storedTotalAssets = storedTotalAssets;\n    if (amount >= _storedTotalAssets) {\n        uint256 _totalAssets = totalAssets();\n        // _totalAssets - _storedTotalAssets == unlockedRewards\n        lastRewardAmount -= _totalAssets - _storedTotalAssets;\n        lastSync = block.timestamp;\n        storedTotalAssets = _totalAssets - amount;\n    } else {\n        storedTotalAssets = _storedTotalAssets - amount;\n    }\n}\n```\n\n**[Joeysantoro (xTRIBE) confirmed, but disagreed with High severity, and commented](https://github.com/code-423n4/2022-04-xtribe-findings/issues/48#issuecomment-1125544449):**\n > This is a valid issue, although the risk is probably medium as the affected user could simply wait until the end of the cycle, and this would only occur in an extreme complete withdrawal of the contract.\n> \n> As a soft mitigation, I would prefer to simply override maxWithdraw to return `storedTotalAssets_`.\n\n**[0xean (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-04-xtribe-findings/issues/48#issuecomment-1132031068):**\n > I agree with the sponsor here. Assets are not directly lost. \n> \n> `\n> 3 — High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n> `\n> \n> `\n> 2 — Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> `\n> \n> So a medium severity seems more appropriate. \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-04-xtribe-contest",
  "Code": [
    {
      "filename": "src/xERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Rewards logic inspired by xERC20 (https://github.com/ZeframLou/playpen/blob/main/src/xERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"solmate/mixins/ERC4626.sol\";\nimport \"solmate/utils/SafeCastLib.sol\";\n\nimport \"./interfaces/IxERC4626.sol\";\n\n/** \n @title  An xERC4626 Single Staking Contract\n @notice This contract allows users to autocompound rewards denominated in an underlying reward token. \n         It is fully compatible with [ERC4626](https://eips.ethereum.org/EIPS/eip-4626) allowing for DeFi composability.\n         It maintains balances using internal accounting to prevent instantaneous changes in the exchange rate.\n         NOTE: an exception is at contract creation, when a reward cycle begins before the first deposit. After the first deposit, exchange rate updates smoothly.\n\n         Operates on \"cycles\" which distribute the rewards surplus over the internal balance to users linearly over the remainder of the cycle window.\n*/\nabstract contract xERC4626 is IxERC4626, ERC4626 {\n    using SafeCastLib for *;\n\n    /// @notice the maximum length of a rewards cycle\n    uint32 public immutable rewardsCycleLength;\n\n    /// @notice the effective start of the current cycle\n    uint32 public lastSync;\n\n    /// @notice the end of the current cycle. Will always be evenly divisible by `rewardsCycleLength`.\n    uint32 public rewardsCycleEnd;\n\n    /// @notice the amount of rewards distributed in a the most recent cycle.\n    uint192 public lastRewardAmount;\n\n    uint256 internal storedTotalAssets;\n\n    constructor(uint32 _rewardsCycleLength) {\n        rewardsCycleLength = _rewardsCycleLength;\n        // seed initial rewardsCycleEnd\n        rewardsCycleEnd = (block.timestamp.safeCastTo32() / rewardsCycleLength) * rewardsCycleLength;\n    }\n\n    /// @notice Compute the amount of tokens available to share holders.\n    ///         Increases linearly during a reward distribution period from the sync call, not the cycle start.\n    function totalAssets() public view override returns (uint256) {\n        // cache global vars\n        uint256 storedTotalAssets_ = storedTotalAssets;\n        uint192 lastRewardAmount_ = lastRewardAmount;\n        uint32 rewardsCycleEnd_ = rewardsCycleEnd;\n        uint32 lastSync_ = lastSync;\n\n        if (block.timestamp >= rewardsCycleEnd_) {\n            // no rewards or rewards fully unlocked\n            // entire reward amount is available\n            return storedTotalAssets_ + lastRewardAmount_;\n        }\n\n        // rewards not fully unlocked\n        // add unlocked rewards to stored total\n        uint256 unlockedRewards = (lastRewardAmount_ * (block.timestamp - lastSync_)) / (rewardsCycleEnd_ - lastSync_);\n        return storedTotalAssets_ + unlockedRewards;\n    }\n\n    // Update storedTotalAssets on withdraw/redeem\n    function beforeWithdraw(uint256 amount, uint256 shares) internal virtual override {\n        super.beforeWithdraw(amount, shares);\n        storedTotalAssets -= amount;\n    }\n\n    // Update storedTotalAssets on deposit/mint\n    function afterDeposit(uint256 amount, uint256 shares) internal virtual override {\n        storedTotalAssets += amount;\n        super.afterDeposit(amount, shares);\n    }\n\n    /// @notice Distributes rewards to xERC4626 holders.\n    /// All surplus `asset` balance of the contract over the internal balance becomes queued for the next cycle.\n    function syncRewards() public virtual {\n        uint192 lastRewardAmount_ = lastRewardAmount;\n        uint32 timestamp = block.timestamp.safeCastTo32();\n\n        if (timestamp < rewardsCycleEnd) revert SyncError();\n\n        uint256 storedTotalAssets_ = storedTotalAssets;\n        uint256 nextRewards = asset.balanceOf(address(this)) - storedTotalAssets_ - lastRewardAmount_;\n\n        storedTotalAssets = storedTotalAssets_ + lastRewardAmount_; // SSTORE\n\n        uint32 end = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength;\n\n        // Combined single SSTORE\n        lastRewardAmount = nextRewards.safeCastTo192();\n        lastSync = timestamp;\n        rewardsCycleEnd = end;\n\n        emit NewRewardsCycle(end, nextRewards);\n    }\n}"
    },
    {
      "filename": "src/xERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Rewards logic inspired by xERC20 (https://github.com/ZeframLou/playpen/blob/main/src/xERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"solmate/mixins/ERC4626.sol\";\nimport \"solmate/utils/SafeCastLib.sol\";\n\nimport \"./interfaces/IxERC4626.sol\";\n\n/** \n @title  An xERC4626 Single Staking Contract\n @notice This contract allows users to autocompound rewards denominated in an underlying reward token. \n         It is fully compatible with [ERC4626](https://eips.ethereum.org/EIPS/eip-4626) allowing for DeFi composability.\n         It maintains balances using internal accounting to prevent instantaneous changes in the exchange rate.\n         NOTE: an exception is at contract creation, when a reward cycle begins before the first deposit. After the first deposit, exchange rate updates smoothly.\n\n         Operates on \"cycles\" which distribute the rewards surplus over the internal balance to users linearly over the remainder of the cycle window.\n*/\nabstract contract xERC4626 is IxERC4626, ERC4626 {\n    using SafeCastLib for *;\n\n    /// @notice the maximum length of a rewards cycle\n    uint32 public immutable rewardsCycleLength;\n\n    /// @notice the effective start of the current cycle\n    uint32 public lastSync;\n\n    /// @notice the end of the current cycle. Will always be evenly divisible by `rewardsCycleLength`.\n    uint32 public rewardsCycleEnd;\n\n    /// @notice the amount of rewards distributed in a the most recent cycle.\n    uint192 public lastRewardAmount;\n\n    uint256 internal storedTotalAssets;\n\n    constructor(uint32 _rewardsCycleLength) {\n        rewardsCycleLength = _rewardsCycleLength;\n        // seed initial rewardsCycleEnd\n        rewardsCycleEnd = (block.timestamp.safeCastTo32() / rewardsCycleLength) * rewardsCycleLength;\n    }\n\n    /// @notice Compute the amount of tokens available to share holders.\n    ///         Increases linearly during a reward distribution period from the sync call, not the cycle start.\n    function totalAssets() public view override returns (uint256) {\n        // cache global vars\n        uint256 storedTotalAssets_ = storedTotalAssets;\n        uint192 lastRewardAmount_ = lastRewardAmount;\n        uint32 rewardsCycleEnd_ = rewardsCycleEnd;\n        uint32 lastSync_ = lastSync;\n\n        if (block.timestamp >= rewardsCycleEnd_) {\n            // no rewards or rewards fully unlocked\n            // entire reward amount is available\n            return storedTotalAssets_ + lastRewardAmount_;\n        }\n\n        // rewards not fully unlocked\n        // add unlocked rewards to stored total\n        uint256 unlockedRewards = (lastRewardAmount_ * (block.timestamp - lastSync_)) / (rewardsCycleEnd_ - lastSync_);\n        return storedTotalAssets_ + unlockedRewards;\n    }\n\n    // Update storedTotalAssets on withdraw/redeem\n    function beforeWithdraw(uint256 amount, uint256 shares) internal virtual override {\n        super.beforeWithdraw(amount, shares);\n        storedTotalAssets -= amount;\n    }\n\n    // Update storedTotalAssets on deposit/mint\n    function afterDeposit(uint256 amount, uint256 shares) internal virtual override {\n        storedTotalAssets += amount;\n        super.afterDeposit(amount, shares);\n    }\n\n    /// @notice Distributes rewards to xERC4626 holders.\n    /// All surplus `asset` balance of the contract over the internal balance becomes queued for the next cycle.\n    function syncRewards() public virtual {\n        uint192 lastRewardAmount_ = lastRewardAmount;\n        uint32 timestamp = block.timestamp.safeCastTo32();\n\n        if (timestamp < rewardsCycleEnd) revert SyncError();\n\n        uint256 storedTotalAssets_ = storedTotalAssets;\n        uint256 nextRewards = asset.balanceOf(address(this)) - storedTotalAssets_ - lastRewardAmount_;\n\n        storedTotalAssets = storedTotalAssets_ + lastRewardAmount_; // SSTORE\n\n        uint32 end = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength;\n\n        // Combined single SSTORE\n        lastRewardAmount = nextRewards.safeCastTo192();\n        lastSync = timestamp;\n        rewardsCycleEnd = end;\n\n        emit NewRewardsCycle(end, nextRewards);\n    }\n}"
    }
  ]
}