{
  "Title": "[N-12] Not using the named return variables anywhere in the function is confusing",
  "Content": "Consider changing the variable to be an unnamed one\n\n*There are 2 instances of this issue:*\n```solidity\nFile: protocol/contracts/tokenomics/FeeBurner.sol   #1\n\n/// @audit received\n43        function burnToTarget(address[] memory tokens_, address targetLpToken_)\n44            public\n45            payable\n46            override\n47:           returns (uint256 received)\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L43-L47\n\n```solidity\nFile: protocol/contracts/tokenomics/FeeBurner.sol   #2\n\n/// @audit received\n96        function _depositInPool(address underlying_, ILiquidityPool pool_)\n97            internal\n98:           returns (uint256 received)\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L96-L98\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-backd",
  "Code": [
    {
      "filename": "protocol/contracts/tokenomics/FeeBurner.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../libraries/AddressProviderHelpers.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/UncheckedMath.sol\";\nimport \"../../interfaces/pool/ILiquidityPool.sol\";\nimport \"../../interfaces/IFeeBurner.sol\";\nimport \"../../interfaces/ISwapperRouter.sol\";\nimport \"../../interfaces/IAddressProvider.sol\";\n\n/**\n * The Fee Burner converts all of the callers Backd LP Tokens to a single target Backd LP Token.\n * It first burns the Pool LP Tokens for the Pool underlying.\n * Then it swaps all the underlyings for the target Pool underlying.\n * Finally it deposits the Pool underlying into the target Pool to get the target LP Token.\n */\ncontract FeeBurner is IFeeBurner {\n    using SafeERC20 for IERC20;\n    using UncheckedMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    address private constant _WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH\n\n    IAddressProvider private immutable _addressProvider; // Address Provider, used for getting pools and swapper router\n\n    event Burned(address targetLpToken, uint256 amountBurned); // Emmited after a successfull burn to target lp token\n\n    constructor(address addressProvider_) {\n        _addressProvider = IAddressProvider(addressProvider_);\n    }\n\n    receive() external payable {} // Recieve function for withdrawing from Backd ETH Pool\n\n    /**\n     * @notice Converts callers Tokens to target Backd LP Token for the given tokens_.\n     * @param tokens_ The Tokens to convert to the targetLpToken_.\n     * @param targetLpToken_ The LP Token that should be received.\n     * @return received The amount of the target LP Token received.\n     */\n    function burnToTarget(address[] memory tokens_, address targetLpToken_)\n        public\n        payable\n        override\n        returns (uint256 received)\n    {\n        require(tokens_.length != 0, \"No tokens to burn\");\n\n        // Swapping tokens for WETH\n        ILiquidityPool targetPool_ = _addressProvider.getPoolForToken(targetLpToken_);\n        address targetUnderlying_ = targetPool_.getUnderlying();\n        ISwapperRouter swapperRouter_ = _swapperRouter();\n        bool burningEth_;\n        for (uint256 i; i < tokens_.length; i = i.uncheckedInc()) {\n            IERC20 token_ = IERC20(tokens_[i]);\n\n            // Handling ETH\n            if (address(token_) == address(0)) {\n                if (msg.value == 0) continue;\n                burningEth_ = true;\n                swapperRouter_.swapAll{value: msg.value}(address(token_), _WETH);\n                continue;\n            }\n\n            // Handling ERC20\n            uint256 tokenBalance_ = token_.balanceOf(msg.sender);\n            if (tokenBalance_ == 0) continue;\n            token_.safeTransferFrom(msg.sender, address(this), tokenBalance_);\n            if (address(token_) == targetUnderlying_) continue;\n            _approve(address(token_), address(swapperRouter_));\n            swapperRouter_.swap(address(token_), _WETH, tokenBalance_);\n        }\n        require(burningEth_ || msg.value == 0, Error.INVALID_VALUE);\n\n        // Swapping WETH for target underlying\n        _approve(_WETH, address(swapperRouter_));\n        swapperRouter_.swapAll(_WETH, targetUnderlying_);\n\n        // Depositing target underlying into target pool\n        uint256 targetLpTokenBalance_ = _depositInPool(targetUnderlying_, targetPool_);\n\n        // Transfering LP tokens back to sender\n        IERC20(targetLpToken_).safeTransfer(msg.sender, targetLpTokenBalance_);\n        emit Burned(targetLpToken_, targetLpTokenBalance_);\n        return targetLpTokenBalance_;\n    }\n\n    /**\n     * @dev Deposits underlying into pool to receive LP Tokens.\n     * @param underlying_ The underlying of the pool.\n     * @param pool_ The pool to deposit into.\n     * @return received The amount of LP Tokens received.\n     */\n    function _depositInPool(address underlying_, ILiquidityPool pool_)\n        internal\n        returns (uint256 received)\n    {\n        // Handling ETH deposits\n        if (underlying_ == address(0)) {\n            uint256 ethBalance_ = address(this).balance;\n            return pool_.deposit{value: ethBalance_}(ethBalance_);\n        }\n\n        // Handling ERC20 deposits\n        _approve(underlying_, address(pool_));\n        return pool_.deposit(IERC20(underlying_).balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Approves infinite spending for the given spender.\n     * @param token_ The token to approve for.\n     * @param spender_ The spender to approve.\n     */\n    function _approve(address token_, address spender_) internal {\n        if (IERC20(token_).allowance(address(this), spender_) > 0) return;\n        IERC20(token_).safeApprove(spender_, type(uint256).max);\n    }\n\n    /**\n     * @dev Gets the swapper router.\n     * @return The swapper router.\n     */\n    function _swapperRouter() internal view returns (ISwapperRouter) {\n        return _addressProvider.getSwapperRouter();\n    }\n}"
    },
    {
      "filename": "protocol/contracts/tokenomics/FeeBurner.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../libraries/AddressProviderHelpers.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/UncheckedMath.sol\";\nimport \"../../interfaces/pool/ILiquidityPool.sol\";\nimport \"../../interfaces/IFeeBurner.sol\";\nimport \"../../interfaces/ISwapperRouter.sol\";\nimport \"../../interfaces/IAddressProvider.sol\";\n\n/**\n * The Fee Burner converts all of the callers Backd LP Tokens to a single target Backd LP Token.\n * It first burns the Pool LP Tokens for the Pool underlying.\n * Then it swaps all the underlyings for the target Pool underlying.\n * Finally it deposits the Pool underlying into the target Pool to get the target LP Token.\n */\ncontract FeeBurner is IFeeBurner {\n    using SafeERC20 for IERC20;\n    using UncheckedMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    address private constant _WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH\n\n    IAddressProvider private immutable _addressProvider; // Address Provider, used for getting pools and swapper router\n\n    event Burned(address targetLpToken, uint256 amountBurned); // Emmited after a successfull burn to target lp token\n\n    constructor(address addressProvider_) {\n        _addressProvider = IAddressProvider(addressProvider_);\n    }\n\n    receive() external payable {} // Recieve function for withdrawing from Backd ETH Pool\n\n    /**\n     * @notice Converts callers Tokens to target Backd LP Token for the given tokens_.\n     * @param tokens_ The Tokens to convert to the targetLpToken_.\n     * @param targetLpToken_ The LP Token that should be received.\n     * @return received The amount of the target LP Token received.\n     */\n    function burnToTarget(address[] memory tokens_, address targetLpToken_)\n        public\n        payable\n        override\n        returns (uint256 received)\n    {\n        require(tokens_.length != 0, \"No tokens to burn\");\n\n        // Swapping tokens for WETH\n        ILiquidityPool targetPool_ = _addressProvider.getPoolForToken(targetLpToken_);\n        address targetUnderlying_ = targetPool_.getUnderlying();\n        ISwapperRouter swapperRouter_ = _swapperRouter();\n        bool burningEth_;\n        for (uint256 i; i < tokens_.length; i = i.uncheckedInc()) {\n            IERC20 token_ = IERC20(tokens_[i]);\n\n            // Handling ETH\n            if (address(token_) == address(0)) {\n                if (msg.value == 0) continue;\n                burningEth_ = true;\n                swapperRouter_.swapAll{value: msg.value}(address(token_), _WETH);\n                continue;\n            }\n\n            // Handling ERC20\n            uint256 tokenBalance_ = token_.balanceOf(msg.sender);\n            if (tokenBalance_ == 0) continue;\n            token_.safeTransferFrom(msg.sender, address(this), tokenBalance_);\n            if (address(token_) == targetUnderlying_) continue;\n            _approve(address(token_), address(swapperRouter_));\n            swapperRouter_.swap(address(token_), _WETH, tokenBalance_);\n        }\n        require(burningEth_ || msg.value == 0, Error.INVALID_VALUE);\n\n        // Swapping WETH for target underlying\n        _approve(_WETH, address(swapperRouter_));\n        swapperRouter_.swapAll(_WETH, targetUnderlying_);\n\n        // Depositing target underlying into target pool\n        uint256 targetLpTokenBalance_ = _depositInPool(targetUnderlying_, targetPool_);\n\n        // Transfering LP tokens back to sender\n        IERC20(targetLpToken_).safeTransfer(msg.sender, targetLpTokenBalance_);\n        emit Burned(targetLpToken_, targetLpTokenBalance_);\n        return targetLpTokenBalance_;\n    }\n\n    /**\n     * @dev Deposits underlying into pool to receive LP Tokens.\n     * @param underlying_ The underlying of the pool.\n     * @param pool_ The pool to deposit into.\n     * @return received The amount of LP Tokens received.\n     */\n    function _depositInPool(address underlying_, ILiquidityPool pool_)\n        internal\n        returns (uint256 received)\n    {\n        // Handling ETH deposits\n        if (underlying_ == address(0)) {\n            uint256 ethBalance_ = address(this).balance;\n            return pool_.deposit{value: ethBalance_}(ethBalance_);\n        }\n\n        // Handling ERC20 deposits\n        _approve(underlying_, address(pool_));\n        return pool_.deposit(IERC20(underlying_).balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Approves infinite spending for the given spender.\n     * @param token_ The token to approve for.\n     * @param spender_ The spender to approve.\n     */\n    function _approve(address token_, address spender_) internal {\n        if (IERC20(token_).allowance(address(this), spender_) > 0) return;\n        IERC20(token_).safeApprove(spender_, type(uint256).max);\n    }\n\n    /**\n     * @dev Gets the swapper router.\n     * @return The swapper router.\n     */\n    function _swapperRouter() internal view returns (ISwapperRouter) {\n        return _addressProvider.getSwapperRouter();\n    }\n}"
    }
  ]
}