{
  "Title": "[L-07] Oracle assumes asset has 18 decimals",
  "Content": "\nhttps://github.com/code-423n4/2023-09-ondo/blob/main/contracts/rwaOracles/RWADynamicOracle.sol#L282\n\nThe `roundUpTo8()` implementation assumes the asset has 18 decimals, as the rounding is done using `1e10` (since `18 - 8 = 10`). It is recommended to use a constant to properly state this dependency and for a better understanding. \n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-09-ondo",
  "Code": [
    {
      "filename": "contracts/rwaOracles/RWADynamicOracle.sol",
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/rwaOracles/IRWAOracle.sol\";\nimport \"contracts/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"contracts/external/openzeppelin/contracts/security/Pausable.sol\";\n\ncontract RWADynamicOracle is IRWAOracle, AccessControlEnumerable, Pausable {\n  uint256 public constant DAY = 1 days;\n\n  Range[] public ranges;\n\n  bytes32 public constant SETTER_ROLE = keccak256(\"SETTER_ROLE\");\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n  constructor(\n    address admin,\n    address setter,\n    address pauser,\n    uint256 firstRangeStart,\n    uint256 firstRangeEnd,\n    uint256 dailyIR,\n    uint256 startPrice\n  ) {\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    _grantRole(PAUSER_ROLE, pauser);\n    _grantRole(SETTER_ROLE, setter);\n\n    if (firstRangeStart >= firstRangeEnd) revert InvalidRange();\n    uint256 trueStart = (startPrice * ONE) / dailyIR;\n    ranges.push(Range(firstRangeStart, firstRangeEnd, dailyIR, trueStart));\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                         Public Functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Function which returns the daily price of USDY given the range previously set\n   *\n   * @return price      The current price of USDY\n   * @return timestamp  The current timestamp of the call\n   */\n  function getPriceData()\n    external\n    view\n    returns (uint256 price, uint256 timestamp)\n  {\n    price = getPrice();\n    timestamp = block.timestamp;\n  }\n\n  /**\n   * @notice Function which returns the daily price of USDY given the range previously set\n   *\n   * @return price The current price of USDY\n   *\n   * @dev The Ranges are not intended to be set more than 2 ranges in advance\n   *      from the current range\n   */\n  function getPrice() public view whenNotPaused returns (uint256 price) {\n    uint256 length = ranges.length;\n    for (uint256 i = 0; i < length; ++i) {\n      Range storage range = ranges[(length - 1) - i];\n      if (range.start <= block.timestamp) {\n        if (range.end <= block.timestamp) {\n          return derivePrice(range, range.end - 1);\n        } else {\n          return derivePrice(range, block.timestamp);\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice External helper function used to simulate the derivation of the prices returned\n   *         from the oracle, given a range and a timestamp\n   *\n   * @dev If you are simulating the first range, you MUST set `startTime` and `rangeStartPrice`\n   * @dev If you are simulating a range > 1st then `startTime` and `rangeStartPrice` values\n   *      remain unused.\n   *\n   * @param blockTimeStamp  The unixTimestamp of the point in time you wish to simulate\n   * @param dailyIR         The daily Interest Rate for the range to simulate\n   * @param endTime         The end time for the range to simulate\n   * @param startTime       The start time for the range to simulate\n   * @param rangeStartPrice The start price for the range to simulate\n   *\n   */\n  function simulateRange(\n    uint256 blockTimeStamp,\n    uint256 dailyIR,\n    uint256 endTime,\n    uint256 startTime,\n    uint256 rangeStartPrice\n  ) external view returns (uint256 price) {\n    uint256 length = ranges.length;\n    Range[] memory rangeList = new Range[](length + 1);\n    for (uint256 i = 0; i < length; ++i) {\n      rangeList[i] = ranges[i];\n    }\n    if (startTime == ranges[0].start) {\n      uint256 trueStart = (rangeStartPrice * ONE) / dailyIR;\n      rangeList[length] = Range(startTime, endTime, dailyIR, trueStart);\n    } else {\n      Range memory lastRange = ranges[ranges.length - 1];\n      uint256 prevClosePrice = derivePrice(lastRange, lastRange.end - 1);\n      rangeList[length] = Range(\n        lastRange.end,\n        endTime,\n        dailyIR,\n        prevClosePrice\n      );\n    }\n    for (uint256 i = 0; i < length + 1; ++i) {\n      Range memory range = rangeList[(length) - i];\n      if (range.start <= blockTimeStamp) {\n        if (range.end <= blockTimeStamp) {\n          return derivePrice(range, range.end - 1);\n        } else {\n          return derivePrice(range, blockTimeStamp);\n        }\n      }\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        Admin Functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Function that allows for an admin to set a given price range for USDY\n   *\n   * @param endTimestamp        The timestamp for the range to end\n   * @param dailyInterestRate   The daily interest rate during said range\n   */\n  function setRange(\n    uint256 endTimestamp,\n    uint256 dailyInterestRate\n  ) external onlyRole(SETTER_ROLE) {\n    Range memory lastRange = ranges[ranges.length - 1];\n\n    // Check that the endTimestamp is greater than the last range's end time\n    if (lastRange.end >= endTimestamp) revert InvalidRange();\n\n    uint256 prevClosePrice = derivePrice(lastRange, lastRange.end - 1);\n    ranges.push(\n      Range(lastRange.end, endTimestamp, dailyInterestRate, prevClosePrice)\n    );\n    emit RangeSet(\n      ranges.length - 1,\n      lastRange.end,\n      endTimestamp,\n      dailyInterestRate,\n      prevClosePrice\n    );\n  }\n\n  /**\n   * @notice Function that allows for an admin to override a previously set range\n   *\n   * @param indexToModify           The index of the range that we want to change\n   * @param newStart                The new start time for the updated range\n   * @param newEnd                  The new end time for the updated range\n   * @param newDailyIR              The new daily interest rate for the range to update\n   * @param newPrevRangeClosePrice  The previous ranges close price\n   *\n   * @dev This function enforces that the range being overriden does not\n   *      overlap with any other set ranges\n   * @dev If closed ranges are updated, the result is a stale value for `prevRangeClosePrice`\n   */\n  function overrideRange(\n    uint256 indexToModify,\n    uint256 newStart,\n    uint256 newEnd,\n    uint256 newDailyIR,\n    uint256 newPrevRangeClosePrice\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Check that the ranges start and end time are less than each other\n    if (newStart >= newEnd) revert InvalidRange();\n\n    uint256 rangeLength = ranges.length;\n    // Case 1: The range being modified is the first range\n    if (indexToModify == 0) {\n      // If the length of ranges is greater than 1,\n      // Ensure that the newEnd time is not greater than the start time of the next range\n      if (rangeLength > 1 && newEnd > ranges[indexToModify + 1].start)\n        revert InvalidRange();\n    }\n    // Case 2: The range being modified is the last range\n    else if (indexToModify == rangeLength - 1) {\n      // Ensure that the newStart time is not less than the end time of the previous range\n      if (newStart < ranges[indexToModify - 1].end) revert InvalidRange();\n    }\n    // Case 3: The range being modified is between first and last range\n    else {\n      // Ensure that the newStart time is less than the end time of the previous range\n      if (newStart < ranges[indexToModify - 1].end) revert InvalidRange();\n      // Ensure that the newEnd time is not greater than the start time of the next range\n      if (newEnd > ranges[indexToModify + 1].start) revert InvalidRange();\n    }\n\n    // Update range\n    if (indexToModify == 0) {\n      uint256 trueStart = (newPrevRangeClosePrice * ONE) / newDailyIR;\n      ranges[indexToModify] = Range(newStart, newEnd, newDailyIR, trueStart);\n    } else {\n      ranges[indexToModify] = Range(\n        newStart,\n        newEnd,\n        newDailyIR,\n        newPrevRangeClosePrice\n      );\n    }\n    emit RangeOverriden(\n      indexToModify,\n      newStart,\n      newEnd,\n      newDailyIR,\n      newPrevRangeClosePrice\n    );\n  }\n\n  /**\n   * @notice Function to pause the oracle\n   */\n  function pauseOracle() external onlyRole(PAUSER_ROLE) {\n    _pause();\n  }\n\n  /**\n   * @notice Function to unpause the oracle\n   */\n  function unpauseOracle() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _unpause();\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        Internal Functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Internal helper function used to derive the price of USDY\n   *\n   * @param currentRange The current range to derive the price of USDY from\n   * @param currentTime  The current unixTimestamp of the blockchain\n   */\n  function derivePrice(\n    Range memory currentRange,\n    uint256 currentTime\n  ) internal pure returns (uint256 price) {\n    uint256 elapsedDays = (currentTime - currentRange.start) / DAY;\n    return\n      roundUpTo8(\n        _rmul(\n          _rpow(currentRange.dailyInterestRate, elapsedDays + 1, ONE),\n          currentRange.prevRangeClosePrice\n        )\n      );\n  }\n\n  /**\n   * @notice internal function that will round derived price to the 8th decimal\n   *         and will round 5 up\n   *\n   * @param value The value to round\n   */\n  function roundUpTo8(uint256 value) internal pure returns (uint256) {\n    uint256 remainder = value % 1e10;\n    if (remainder >= 0.5e10) {\n      value += 1e10;\n    }\n    value -= remainder;\n    return value;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    Structs, Events and Errors\n  //////////////////////////////////////////////////////////////*/\n\n  struct Range {\n    uint256 start;\n    uint256 end;\n    uint256 dailyInterestRate;\n    uint256 prevRangeClosePrice;\n  }\n\n  /**\n   * @notice Event emitted when a range has been set\n   *\n   * @param start             The start time for the range\n   * @param end               The end time for the range\n   * @param dailyInterestRate The daily interest rate for the range\n   */\n  event RangeSet(\n    uint256 indexed index,\n    uint256 start,\n    uint256 end,\n    uint256 dailyInterestRate,\n    uint256 prevRangeClosePrice\n  );\n\n  /**\n   * @notice Event emitted when a previously set range is overriden\n   *\n   * @param index                  The index of the range being modified\n   * @param newStart               The new start time for the modified range\n   * @param newEnd                 The new end time for the modified range\n   * @param newDailyInterestRate   The new dailyInterestRate for the modified range\n   * @param newPrevRangeClosePrice The new prevRangeClosePrice for the modified range\n   */\n  event RangeOverriden(\n    uint256 indexed index,\n    uint256 newStart,\n    uint256 newEnd,\n    uint256 newDailyInterestRate,\n    uint256 newPrevRangeClosePrice\n  );\n\n  error InvalidPrice();\n  error InvalidRange();\n  error PriceNotSet();\n\n  /*//////////////////////////////////////////////////////////////\n                Interest calculation helper functions\n  //////////////////////////////////////////////////////////////*/\n\n  // Copied from https://github.com/makerdao/dss/blob/master/src/jug.sol\n  uint256 private constant ONE = 10 ** 27;\n\n  function _rpow(\n    uint256 x,\n    uint256 n,\n    uint256 base\n  ) internal pure returns (uint256 z) {\n    assembly {\n      switch x\n      case 0 {\n        switch n\n        case 0 {\n          z := base\n        }\n        default {\n          z := 0\n        }\n      }\n      default {\n        switch mod(n, 2)\n        case 0 {\n          z := base\n        }\n        default {\n          z := x\n        }\n        let half := div(base, 2) // for rounding.\n        for {\n          n := div(n, 2)\n        } n {\n          n := div(n, 2)\n        } {\n          let xx := mul(x, x)\n          if iszero(eq(div(xx, x), x)) {\n            revert(0, 0)\n          }\n          let xxRound := add(xx, half)\n          if lt(xxRound, xx) {\n            revert(0, 0)\n          }\n          x := div(xxRound, base)\n          if mod(n, 2) {\n            let zx := mul(z, x)\n            if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\n              revert(0, 0)\n            }\n            let zxRound := add(zx, half)\n            if lt(zxRound, zx) {\n              revert(0, 0)\n            }\n            z := div(zxRound, base)\n          }\n        }\n      }\n    }\n  }\n\n  function _rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    z = _mul(x, y) / ONE;\n  }\n\n  function _mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    require(y == 0 || (z = x * y) / y == x);\n  }\n}"
    }
  ]
}