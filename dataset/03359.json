{
  "Title": "Incorrect calculation of borrowed amount",
  "Content": "##### Description\nTotal borrowed amount increases unequally, so total borrowed amount on credit accounts would be less than `totalBorrowed` on a `PoolService` which would lead to incorrect calcultaions for LP of a `PoolService`:\nhttps://github.com/Gearbox-protocol/gearbox-contracts/blob/0ac33ba87212ce056ac6b6357ad74161d417158a/contracts/credit/CreditManager.sol#L661\n##### Recommendation\nWe recommend to change calculation of borrowed amount for credit accounts.",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/credit/CreditManager.sol",
      "content": "// SPDX-License-Identifier: BSL-1.1\n// Gearbox. Generalized leverage protocol that allows to take leverage and then use it across other DeFi protocols and platforms in a composable way.\n// (c) Gearbox.fi, 2021\npragma solidity ^0.7.4;\npragma abicoder v2;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {PercentageMath} from \"../libraries/math/PercentageMath.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {IAccountFactory} from \"../interfaces/IAccountFactory.sol\";\nimport {ICreditAccount} from \"../interfaces/ICreditAccount.sol\";\nimport {IPoolService} from \"../interfaces/IPoolService.sol\";\nimport {IWETHGateway} from \"../interfaces/IWETHGateway.sol\";\nimport {ICreditManager} from \"../interfaces/ICreditManager.sol\";\nimport {ICreditFilter} from \"../interfaces/ICreditFilter.sol\";\nimport {CreditAccount} from \"./CreditAccount.sol\";\nimport {AddressProvider} from \"../core/AddressProvider.sol\";\nimport {ACLTrait} from \"../core/ACLTrait.sol\";\n\nimport {Constants} from \"../libraries/helpers/Constants.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {DataTypes} from \"../libraries/data/Types.sol\";\n\nimport \"hardhat/console.sol\";\n\n/// @title Credit Manager\n/// @notice It encapsulates business logic for managing credit accounts\n///\n/// More info: https://dev.gearbox.fi/developers/credit/credit_manager\ncontract CreditManager is ICreditManager, ACLTrait, ReentrancyGuard {\n    using SafeMath for uint256;\n    using PercentageMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    // Minimal amount for open credit account\n    uint256 public override minAmount;\n\n    //  Maximum amount for open credit account\n    uint256 public override maxAmount;\n\n    // Maximum leveraged factor allowed for this pool\n    uint256 public override maxLeverageFactor;\n\n    // Minimal allowed Hf after increasing borrow amount\n    uint256 public override minHealthFactor;\n\n    // Mapping between borrowers'/farmers' address and credit account\n    mapping(address => address) public override creditAccounts;\n\n    // Address provider\n    AddressProvider public addressProvider;\n\n    // Account manager - provides credit accounts to pool\n    IAccountFactory internal _accountFactory;\n\n    // Credit Manager filter\n    ICreditFilter public override creditFilter;\n\n    // Underlying token address\n    address public override underlyingToken;\n\n    // Address of connected pool\n    address public override poolService;\n\n    // Address of WETH token\n    address public wethAddress;\n\n    // Address of WETH Gateway\n    address public wethGateway;\n\n    // Default swap contracts - uses for automatic close\n    address public defaultSwapContract;\n\n    uint256 public override feeSuccess;\n\n    uint256 public override feeInterest;\n\n    uint256 public override feeLiquidation;\n\n    uint256 public override liquidationDiscount;\n\n    //\n    // MODIFIERS\n    //\n\n    /// @dev Restricts actions for users with opened credit accounts only\n    modifier allowedAdaptersOnly(address targetContract) {\n        require(\n            creditFilter.contractToAdapter(targetContract) == msg.sender,\n            Errors.CM_TARGET_CONTRACT_iS_NOT_ALLOWED\n        );\n        _;\n    }\n\n    /// @dev Constructor\n    /// @param _addressProvider Address Repository for upgradable contract model\n    /// @param _minAmount Minimal amount for open credit account\n    /// @param _maxAmount Maximum amount for open credit account\n    /// @param _maxLeverage Maximum allowed leverage factor\n    /// @param _poolService Address of pool service\n    /// @param _creditFilterAddress CreditFilter address. It should be finalised\n    /// @param _defaultSwapContract Default IUniswapV2Router02 contract to change assets in case of closing account\n    constructor(\n        address _addressProvider,\n        uint256 _minAmount,\n        uint256 _maxAmount,\n        uint256 _maxLeverage,\n        address _poolService,\n        address _creditFilterAddress,\n        address _defaultSwapContract\n    ) ACLTrait(_addressProvider) {\n        addressProvider = AddressProvider(_addressProvider); // T:[CM-1]\n        poolService = _poolService; // T:[CM-1]\n        underlyingToken = IPoolService(_poolService).underlyingToken(); // T:[CM-1]\n\n        wethAddress = addressProvider.getWethToken(); // T:[CM-1]\n        wethGateway = addressProvider.getWETHGateway(); // T:[CM-1]\n        defaultSwapContract = _defaultSwapContract; // T:[CM-1]\n        _accountFactory = IAccountFactory(addressProvider.getAccountFactory()); // T:[CM-1]\n\n        setParams(\n            _minAmount,\n            _maxAmount,\n            _maxLeverage,\n            Constants.FEE_SUCCESS,\n            Constants.FEE_INTEREST,\n            Constants.FEE_LIQUIDATION,\n            Constants.LIQUIDATION_DISCOUNTED_SUM\n        ); // T:[CM-1]\n\n        creditFilter = ICreditFilter(_creditFilterAddress); // T:[CM-1]\n    }\n\n    //\n    // CREDIT ACCOUNT MANAGEMENT\n    //\n\n    /**\n     * @dev Opens credit account and provides credit funds.\n     * - Opens credit account (take it from account factory^1)\n     * - Transfers trader /farmers initial funds to credit account\n     * - Transfers borrowed leveraged amount from pool (= amount x leverageFactor) calling lendCreditAccount() on connected Pool contract.\n     * - Emits OpenCreditAccount event\n     * Function reverts if user has already opened position\n     *\n     * More info: https://dev.gearbox.fi/developers/credit/credit_manager#open-credit-account\n     *\n     * @param amount Borrowers own funds\n     * @param onBehalfOf The address that we open credit account. Same as msg.sender if the user wants to open it for  his own wallet,\n     *  or a different address if the beneficiary is a different wallet\n     * @param leverageFactor Multiplier to borrowers own funds\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function openCreditAccount(\n        uint256 amount,\n        address onBehalfOf,\n        uint256 leverageFactor,\n        uint256 referralCode\n    )\n        external\n        override\n        whenNotPaused // T:[CM-39]\n        nonReentrant\n    {\n        // Checks that amount is in limits\n        require(\n            amount >= minAmount && amount <= maxAmount,\n            Errors.CM_INCORRECT_AMOUNT\n        ); // T:[CM-2]\n\n        // Checks that user \"onBehalfOf\" has no opened accounts\n        require(\n            !hasOpenedCreditAccount(onBehalfOf),\n            Errors.CM_YOU_HAVE_ALREADY_OPEN_CREDIT_ACCOUNT\n        ); // T:[CM-3]\n\n        // Checks that leverage factor is in limits\n        require(\n            leverageFactor > 0 && leverageFactor <= maxLeverageFactor,\n            Errors.CM_INCORRECT_LEVERAGE_FACTOR\n        ); // T:[CM-4]\n\n        // borrowedAmount = amount * leverageFactor\n        uint256 borrowedAmount = amount.mul(leverageFactor).div(\n            Constants.LEVERAGE_DECIMALS\n        ); // T:[CM-7]\n\n        // Get Reusable Credit account creditAccount\n        address creditAccount = _accountFactory.takeCreditAccount(); // T:[CM-5]\n\n        // Initializes enabled tokens for the account. Enabled tokens is a bit mask which\n        // holds information which tokens were used by user\n        creditFilter.initEnabledTokens(creditAccount); // T:[CM-5]\n\n        // Transfer pool tokens to new credit account\n        IPoolService(poolService).lendCreditAccount(\n            borrowedAmount,\n            creditAccount\n        ); // T:[CM-7]\n\n        // Transfer borrower own fund to credit account\n        IERC20(underlyingToken).safeTransferFrom(\n            msg.sender,\n            creditAccount,\n            amount\n        ); // T:[CM-6]\n\n        // Set parameters for new credit account\n        ICreditAccount(creditAccount).setGenericParameters(\n            borrowedAmount,\n            IPoolService(poolService).calcLinearCumulative_RAY()\n        ); // T:[CM-7]\n\n        // link credit account address with borrower address\n        creditAccounts[onBehalfOf] = creditAccount; // T:[CM-5]\n\n        // emit new event\n        emit OpenCreditAccount(\n            msg.sender,\n            onBehalfOf,\n            creditAccount,\n            amount,\n            borrowedAmount,\n            referralCode\n        ); // T:[CM-8]\n    }\n\n    /**\n     * @dev Closes credit account\n     * - Swaps all assets to underlying one using default swap protocol\n     * - Pays borrowed amount + interest accrued + fees back to the pool by calling repayCreditAccount\n     * - Transfers remaining funds to the trader / farmer\n     * - Closes the credit account and return it to account factory\n     * - Emits CloseCreditAccount event\n     *\n     * More info: https://dev.gearbox.fi/developers/credit/credit_manager#close-credit-account\n     *\n     * @param to Address to send remaining funds\n     * @param paths Exchange type data which provides paths + amountMinOut\n     */\n    function closeCreditAccount(address to, DataTypes.Exchange[] calldata paths)\n        external\n        override\n        whenNotPaused // T:[CM-39]\n        nonReentrant\n    {\n        address creditAccount = getCreditAccountOrRevert(msg.sender); // T: [CM-9, 44]\n\n        // Converts all assets to underlying one. _convertAllAssetsToUnderlying is virtual\n        _convertAllAssetsToUnderlying(creditAccount, paths); // T: [CM-44]\n\n        // total value equals underlying assets after converting all assets\n        uint256 totalValue = IERC20(underlyingToken).balanceOf(creditAccount); // T: [CM-44]\n\n        (, uint256 remainingFunds) = _closeCreditAccountImpl(\n            creditAccount,\n            Constants.OPERATION_CLOSURE,\n            totalValue,\n            msg.sender,\n            address(0),\n            to\n        ); // T: [CM-44]\n\n        emit CloseCreditAccount(msg.sender, to, remainingFunds); // T: [CM-44]\n    }\n\n    /**\n     * @dev Liquidates credit account\n     * - Transfers discounted total credit account value from liquidators account\n     * - Pays borrowed funds + interest + fees back to pool, than transfers remaining funds to credit account owner\n     * - Transfer all assets from credit account to liquidator (\"to\") account\n     * - Returns credit account to factory\n     * - Emits LiquidateCreditAccount event\n     *\n     * More info: https://dev.gearbox.fi/developers/credit/credit_manager#liquidate-credit-account\n     *\n     * @param borrower Borrower address\n     * @param to Address to transfer all assets from credit account\n     */\n    function liquidateCreditAccount(\n        address borrower,\n        address to,\n        bool force\n    )\n        external\n        override\n        whenNotPaused // T:[CM-39]\n        nonReentrant\n    {\n        address creditAccount = getCreditAccountOrRevert(borrower); // T: [CM-9]\n\n        // transfers assets to \"to\" address and compute total value (tv) & threshold weighted value (twv)\n        (uint256 totalValue, uint256 tvw) = _transferAssetsTo(\n            creditAccount,\n            to,\n            force\n        ); // T:[CM-13, 16, 17]\n\n        // Checks that current Hf < 1\n        require(\n            tvw <\n                creditFilter\n                .calcCreditAccountAccruedInterest(creditAccount)\n                .mul(PercentageMath.PERCENTAGE_FACTOR),\n            Errors.CM_CAN_LIQUIDATE_WITH_SUCH_HEALTH_FACTOR\n        ); // T:[CM-13, 16, 17]\n\n        // Liquidate credit account\n        (, uint256 remainingFunds) = _closeCreditAccountImpl(\n            creditAccount,\n            Constants.OPERATION_LIQUIDATION,\n            totalValue,\n            borrower,\n            msg.sender,\n            to\n        ); // T:[CM-13]\n\n        emit LiquidateCreditAccount(borrower, msg.sender, remainingFunds); // T:[CM-13]\n    }\n\n    /// @dev Repays credit account\n    /// More info: https://dev.gearbox.fi/developers/credit/credit_manager#repay-credit-account\n    ///\n    /// @param to Address to send credit account assets\n    function repayCreditAccount(address to)\n        external\n        override\n        whenNotPaused // T:[CM-39]\n        nonReentrant\n    {\n        _repayCreditAccountImpl(msg.sender, to); // T:[CM-17]\n    }\n\n    /// @dev Repay credit account with ETH. Restricted to be called by WETH Gateway only\n    ///\n    /// @param borrower Address of borrower\n    /// @param to Address to send credit account assets\n    function repayCreditAccountETH(address borrower, address to)\n        external\n        override\n        whenNotPaused // T:[CM-39]\n        nonReentrant\n        returns (uint256)\n    {\n        // Checks that msg.sender is WETH Gateway\n        require(msg.sender == wethGateway, Errors.CM_WETH_GATEWAY_ONLY); // T:[CM-38]\n\n        // Difference with usual Repay is that there is borrower in repay implementation call\n        return _repayCreditAccountImpl(borrower, to); // T:[WG-11]\n    }\n\n    /// @dev Implements logic for repay credit accounts\n    ///\n    /// @param borrower Borrower address\n    /// @param to Address to transfer assets from credit account\n    function _repayCreditAccountImpl(address borrower, address to)\n        internal\n        returns (uint256)\n    {\n        address creditAccount = getCreditAccountOrRevert(borrower);\n        (uint256 totalValue, ) = _transferAssetsTo(creditAccount, to, false); // T:[CM-17, 23]\n\n        (uint256 amountToPool, ) = _closeCreditAccountImpl(\n            creditAccount,\n            Constants.OPERATION_REPAY,\n            totalValue,\n            borrower,\n            borrower,\n            to\n        ); // T:[CM-17]\n\n        emit RepayCreditAccount(borrower, to); // T:[CM-18]\n        return amountToPool;\n    }\n\n    /// @dev Implementation for all closing account procedures\n    function _closeCreditAccountImpl(\n        address creditAccount,\n        uint8 operation,\n        uint256 totalValue,\n        address borrower,\n        address liquidator,\n        address to\n    ) internal returns (uint256, uint256) {\n        bool isLiquidated = operation == Constants.OPERATION_LIQUIDATION;\n\n        (\n            uint256 borrowedAmount,\n            uint256 amountToPool,\n            uint256 remainingFunds,\n            uint256 profit,\n            uint256 loss\n        ) = _calcClosePayments(creditAccount, totalValue, isLiquidated); // T:[CM-11, 15, 17]\n\n        if (operation == Constants.OPERATION_CLOSURE) {\n            ICreditAccount(creditAccount).safeTransfer(\n                underlyingToken,\n                poolService,\n                amountToPool\n            ); // T:[CM-11]\n\n            // close operation with loss is not allowed\n            require(loss <= 1, Errors.CM_CANT_CLOSE_WITH_LOSS); // T:[CM-42]\n\n            // transfer remaining funds to borrower\n            _safeTokenTransfer(\n                creditAccount,\n                underlyingToken,\n                to,\n                remainingFunds,\n                false\n            ); // T:[CM-11]\n        }\n        // LIQUIDATION\n        else if (operation == Constants.OPERATION_LIQUIDATION) {\n            // repay amount to pool\n            IERC20(underlyingToken).safeTransferFrom(\n                liquidator,\n                poolService,\n                amountToPool\n            ); // T:[CM-14]\n\n            // transfer remaining funds to borrower\n            IERC20(underlyingToken).safeTransferFrom(\n                liquidator,\n                borrower,\n                remainingFunds\n            ); //T:[CM-14]\n        }\n        // REPAY\n        else {\n            // repay amount to pool\n            IERC20(underlyingToken).safeTransferFrom(\n                msg.sender, // msg.sender in case of WETH Gateway\n                poolService,\n                amountToPool\n            ); // T:[CM-17]\n        }\n\n        // Return creditAccount\n        _accountFactory.returnCreditAccount(creditAccount); // T:[CM-21]\n\n        // Release memory\n        delete creditAccounts[borrower]; // T:[CM-27]\n\n        // Transfer pool tokens to new credit account\n        IPoolService(poolService).repayCreditAccount(\n            borrowedAmount,\n            profit,\n            loss\n        ); // T:[CM-11, 15]\n\n        return (amountToPool, remainingFunds); // T:[CM-11]\n    }\n\n    /// @dev Collects data and call calc payments pure function during closure procedures\n    /// @param creditAccount Credit account address\n    /// @param totalValue Credit account total value\n    /// @param isLiquidated True if calculations needed for liquidation\n    function _calcClosePayments(\n        address creditAccount,\n        uint256 totalValue,\n        bool isLiquidated\n    )\n        public\n        view\n        returns (\n            uint256 _borrowedAmount,\n            uint256 amountToPool,\n            uint256 remainingFunds,\n            uint256 profit,\n            uint256 loss\n        )\n    {\n        // Gets credit account parameters\n        (\n            uint256 borrowedAmount,\n            uint256 cumulativeIndexAtCreditAccountOpen_RAY\n        ) = getCreditAccountParameters(creditAccount); // T:[CM-13]\n\n        return\n            _calcClosePaymentsPure(\n                totalValue,\n                isLiquidated,\n                borrowedAmount,\n                cumulativeIndexAtCreditAccountOpen_RAY,\n                IPoolService(poolService).calcLinearCumulative_RAY()\n            );\n    }\n\n    /// @dev Computes all close parameters based on data\n    /// @param totalValue Credit account total value\n    /// @param isLiquidated True if calculations needed for liquidation\n    /// @param borrowedAmount Credit account borrow amount\n    /// @param cumulativeIndexAtCreditAccountOpen_RAY Cumulative index at opening credit account in RAY format\n    /// @param cumulativeIndexNow_RAY Current value of cumulative index in RAY format\n    function _calcClosePaymentsPure(\n        uint256 totalValue,\n        bool isLiquidated,\n        uint256 borrowedAmount,\n        uint256 cumulativeIndexAtCreditAccountOpen_RAY,\n        uint256 cumulativeIndexNow_RAY\n    )\n        public\n        view\n        returns (\n            uint256 _borrowedAmount,\n            uint256 amountToPool,\n            uint256 remainingFunds,\n            uint256 profit,\n            uint256 loss\n        )\n    {\n        uint256 totalFunds = isLiquidated\n            ? totalValue.mul(liquidationDiscount).div(\n                PercentageMath.PERCENTAGE_FACTOR\n            )\n            : totalValue; // T:[CM-45]\n\n        _borrowedAmount = borrowedAmount; // T:[CM-45]\n\n        uint256 borrowedAmountWithInterest = borrowedAmount\n        .mul(cumulativeIndexNow_RAY)\n        .div(cumulativeIndexAtCreditAccountOpen_RAY); // T:[CM-45]\n\n        if (totalFunds < borrowedAmountWithInterest) {\n            amountToPool = totalFunds.sub(1); // T:[CM-45]\n            loss = borrowedAmountWithInterest.sub(amountToPool); // T:[CM-45]\n        } else {\n            amountToPool = isLiquidated\n                ? totalFunds.percentMul(feeLiquidation).add(\n                    borrowedAmountWithInterest\n                )\n                : totalFunds\n                .sub(borrowedAmountWithInterest)\n                .percentMul(feeSuccess)\n                .add(borrowedAmountWithInterest)\n                .add(\n                    borrowedAmountWithInterest.sub(borrowedAmount).percentMul(\n                        feeInterest\n                    )\n                ); // T:[CM-45]\n\n            amountToPool = totalFunds >= amountToPool\n                ? amountToPool\n                : totalFunds; // T:[CM-45]\n            profit = amountToPool.sub(borrowedAmountWithInterest); // T:[CM-45]\n            remainingFunds = totalFunds > amountToPool\n                ? totalFunds.sub(amountToPool).sub(1)\n                : 0; // T:[CM-45]\n        }\n    }\n\n    /// @dev Transfers all assets from borrower credit account to \"to\" account and converts WETH => ETH if applicable\n    /// @param creditAccount  Credit account address\n    /// @param to Address to transfer all assets to\n    function _transferAssetsTo(\n        address creditAccount,\n        address to,\n        bool force\n    ) internal returns (uint256 totalValue, uint256 totalWeightedValue) {\n        totalValue = 0;\n        totalWeightedValue = 0;\n\n        uint256 tokenMask;\n        uint256 enabledTokens = creditFilter.enabledTokens(creditAccount);\n\n        for (uint256 i = 0; i < creditFilter.allowedTokensCount(); i++) {\n            tokenMask = 1 << i;\n            if (enabledTokens & tokenMask > 0) {\n                (\n                    address token,\n                    uint256 amount,\n                    uint256 tv,\n                    uint256 tvw\n                ) = creditFilter.getCreditAccountTokenById(creditAccount, i); // T:[CM-14, 17, 22, 23]\n                if (amount > 1) {\n                    _safeTokenTransfer(\n                        creditAccount,\n                        token,\n                        to,\n                        amount.sub(1),\n                        force\n                    ); // T:[CM-14, 17, 22, 23]\n\n                    totalValue += tv;\n                    totalWeightedValue += tvw;\n                } // Michael Egorov gas efficiency trick\n            }\n        }\n    }\n\n    /// @dev Transfers token to particular address from credit account and converts WETH => ETH if applicable\n    /// @param creditAccount Address of credit account\n    /// @param token Token address\n    /// @param to Address to transfer asset\n    /// @param amount Amount to be transferred\n    /// @param force If true it will skip reverts of safeTransfer function. Used for force liquidation if there is\n    /// a blocked token on creditAccount\n    function _safeTokenTransfer(\n        address creditAccount,\n        address token,\n        address to,\n        uint256 amount,\n        bool force\n    ) internal {\n        if (token != wethAddress) {\n            try\n                ICreditAccount(creditAccount).safeTransfer(token, to, amount) // T:[CM-14, 17]\n            {} catch {\n                require(force, Errors.CM_TRANSFER_FAILED); // T:[CM-50]\n            }\n        } else {\n            ICreditAccount(creditAccount).safeTransfer(\n                token,\n                wethGateway,\n                amount\n            ); // T:[CM-22, 23]\n            IWETHGateway(wethGateway).unwrapWETH(to, amount); // T:[CM-22, 23]\n        }\n    }\n\n    /// @dev Increases borrowed amount by transferring additional funds from\n    /// the pool if after that HealthFactor > minHealth\n    /// More info: https://dev.gearbox.fi/developers/credit/credit_manager#increase-borrowed-amount\n    ///\n    /// @param amount Amount to increase borrowed amount\n    function increaseBorrowedAmount(uint256 amount)\n        external\n        override\n        whenNotPaused // T:[CM-39]\n        nonReentrant\n    {\n        address creditAccount = getCreditAccountOrRevert(msg.sender); // T: [CM-9, 30]\n\n        (\n            uint256 borrowedAmount,\n            uint256 cumulativeIndexAtOpen\n        ) = getCreditAccountParameters(creditAccount); // T:[CM-30]\n\n        require(\n            borrowedAmount.add(amount) <\n                maxAmount.mul(maxLeverageFactor).div(\n                    Constants.LEVERAGE_DECIMALS\n                ),\n            Errors.CM_INCORRECT_AMOUNT\n        ); // T:[CM-51]\n\n        uint256 timeDiscountedAmount = amount.mul(cumulativeIndexAtOpen).div(\n            IPoolService(poolService).calcLinearCumulative_RAY()\n        ); // T:[CM-30]\n\n        // Increase _totalBorrowed, it used to compute forecasted interest\n        IPoolService(poolService).lendCreditAccount(amount, creditAccount); // T:[CM-29]\n\n        // Set parameters for new credit account\n        ICreditAccount(creditAccount).updateBorrowedAmount(\n            borrowedAmount.add(timeDiscountedAmount)\n        ); // T:[CM-30]\n\n        require(\n            creditFilter.calcCreditAccountHealthFactor(creditAccount) >=\n                minHealthFactor,\n            Errors.CM_CAN_UPDATE_WITH_SUCH_HEALTH_FACTOR\n        ); // T:[CM-28]\n\n        emit IncreaseBorrowedAmount(msg.sender, amount); // T:[CM-29]\n    }\n\n    /// @dev Adds collateral to borrower's credit account\n    /// @param onBehalfOf Address of borrower to add funds\n    /// @param token Token address\n    /// @param amount Amount to add\n    function addCollateral(\n        address onBehalfOf,\n        address token,\n        uint256 amount\n    )\n        external\n        override\n        whenNotPaused // T:[CM-39]\n        nonReentrant\n    {\n        address creditAccount = getCreditAccountOrRevert(onBehalfOf); // T: [CM-9]\n        creditFilter.checkAndEnableToken(creditAccount, token); // T:[CM-48]\n        IERC20(token).safeTransferFrom(msg.sender, creditAccount, amount); // T:[CM-48]\n        emit AddCollateral(onBehalfOf, token, amount); // T: [CM-48]\n    }\n\n    /// @dev Sets fees. Restricted for configurator role only\n    /// @param _minAmount Minimum amount to open account\n    /// @param _maxAmount Maximum amount to open account\n    /// @param _maxLeverageFactor Maximum leverage factor\n    /// @param _feeSuccess Success fee multiplier (for (totalValue - borrowAmount))\n    /// @param _feeInterest Interest fee multiplier\n    /// @param _feeLiquidation Liquidation fee multiplier (for totalValue)\n    /// @param _liquidationDiscount Liquidation premium multiplier (= PERCENTAGE_FACTOR - premium)\n    function setParams(\n        uint256 _minAmount,\n        uint256 _maxAmount,\n        uint256 _maxLeverageFactor,\n        uint256 _feeSuccess,\n        uint256 _feeInterest,\n        uint256 _feeLiquidation,\n        uint256 _liquidationDiscount\n    )\n        public\n        configuratorOnly // T:[CM-36]\n    {\n        require(_minAmount <= _maxAmount, Errors.CM_INCORRECT_LIMITS); // T:[CM-34]\n\n        minAmount = _minAmount; // T:[CM-32]\n        maxAmount = _maxAmount; // T:[CM-32]\n\n        maxLeverageFactor = _maxLeverageFactor;\n\n        feeSuccess = _feeSuccess; // T:[CM-37]\n        feeInterest = _feeInterest; // T:[CM-37]\n        feeLiquidation = _feeLiquidation; // T:[CM-37]\n        liquidationDiscount = _liquidationDiscount; // T:[CM-37]\n\n        // Compute minHealthFactor: https://dev.gearbox.fi/developers/credit/credit_manager#increase-borrow-amount\n        minHealthFactor = liquidationDiscount\n        .sub(feeLiquidation)\n        .mul(maxLeverageFactor.add(Constants.LEVERAGE_DECIMALS))\n        .div(maxLeverageFactor); // T:[CM-41]\n\n        if (address(creditFilter) != address(0)) {\n            creditFilter.updateUnderlyingTokenLiquidationThreshold(); // T:[CM-49]\n        }\n\n        emit NewParameters(\n            minAmount,\n            maxAmount,\n            maxLeverageFactor,\n            feeSuccess,\n            feeInterest,\n            feeLiquidation,\n            liquidationDiscount\n        ); // T:[CM-37]\n    }\n\n    /// @dev Approves credit account for 3rd party contract\n    /// @param targetContract Contract to check allowance\n    /// @param token Token address of contract\n    function approve(address targetContract, address token)\n        external\n        override\n        whenNotPaused // T:[CM-39]\n        nonReentrant\n    {\n        address creditAccount = getCreditAccountOrRevert(msg.sender);\n\n        // Checks that targetContract is allowed - it has non-zero address adapter\n        require(\n            creditFilter.contractToAdapter(targetContract) != address(0),\n            Errors.CM_TARGET_CONTRACT_iS_NOT_ALLOWED\n        );\n        _provideCreditAccountAllowance(creditAccount, targetContract, token);\n    }\n\n    /// @dev Approve tokens for credit accounts. Restricted for adapters only\n    /// @param creditAccount Credit account address\n    /// @param targetContract Contract to check allowance\n    /// @param token Token address of contract\n    function provideCreditAccountAllowance(\n        address creditAccount,\n        address targetContract,\n        address token\n    )\n        external\n        override\n        allowedAdaptersOnly(targetContract) // T:[CM-46]\n        whenNotPaused // T:[CM-39]\n        nonReentrant\n    {\n        _provideCreditAccountAllowance(creditAccount, targetContract, token); // T:[CM-35]\n    }\n\n    /// @dev Checks that credit account has enough allowance for operation by comparing existing one with x10 times more than needed\n    /// @param creditAccount Credit account address\n    /// @param toContract Contract to check allowance\n    /// @param token Token address of contract\n    function _provideCreditAccountAllowance(\n        address creditAccount,\n        address toContract,\n        address token\n    ) internal {\n        // Get 10x reserve in allowance\n        if (\n            IERC20(token).allowance(creditAccount, toContract) <\n            Constants.MAX_INT_4\n        ) {\n            ICreditAccount(creditAccount).approveToken(token, toContract); // T:[CM-35]\n        }\n    }\n\n    /// @dev Converts all assets to underlying one using uniswap V2 protocol\n    /// @param creditAccount Credit Account address\n    /// @param paths Exchange type data which provides paths + amountMinOut\n    function _convertAllAssetsToUnderlying(\n        address creditAccount,\n        DataTypes.Exchange[] calldata paths\n    ) internal {\n        uint256 tokenMask;\n        uint256 enabledTokens = creditFilter.enabledTokens(creditAccount); // T: [CM-44]\n\n        for (uint256 i = 1; i < creditFilter.allowedTokensCount(); i++) {\n            tokenMask = 1 << i;\n            if (enabledTokens & tokenMask > 0) {\n                (address tokenAddr, uint256 amount, , ) = creditFilter\n                .getCreditAccountTokenById(creditAccount, i); // T: [CM-44]\n\n                if (amount > 0) {\n                    _provideCreditAccountAllowance(\n                        creditAccount,\n                        defaultSwapContract,\n                        tokenAddr\n                    ); // T: [CM-44]\n\n                    address[] memory currentPath = paths[i].path;\n                    currentPath[0] = tokenAddr;\n                    currentPath[paths[i].path.length - 1] = underlyingToken;\n\n                    bytes memory data = abi.encodeWithSelector(\n                        bytes4(0x38ed1739), // \"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\",\n                        amount,\n                        paths[i].amountOutMin, // T: [CM-45]\n                        currentPath,\n                        creditAccount,\n                        block.timestamp\n                    ); // T: [CM-44]\n\n                    CreditAccount(creditAccount).execute(\n                        defaultSwapContract,\n                        data\n                    ); // T: [CM-44]\n                }\n            }\n        }\n    }\n\n    /// @dev Executes filtered order on credit account which is connected with particular borrower\n    /// @param borrower Borrower address\n    /// @param target Target smart-contract\n    /// @param data Call data for call\n    function executeOrder(\n        address borrower,\n        address target,\n        bytes memory data\n    )\n        external\n        override\n        allowedAdaptersOnly(target) // T:[CM-46]\n        whenNotPaused // T:[CM-39]\n        nonReentrant\n        returns (bytes memory)\n    {\n        address creditAccount = getCreditAccountOrRevert(borrower); // T:[CM-9]\n        emit ExecuteOrder(borrower, target);\n        return CreditAccount(creditAccount).execute(target, data); // : [CM-47]\n    }\n\n    //\n    // GETTERS\n    //\n\n    /// @dev Returns true if the borrower has opened a credit account\n    /// @param borrower Borrower account\n    function hasOpenedCreditAccount(address borrower)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return creditAccounts[borrower] != address(0); // T:[CM-26]\n    }\n\n    /// @dev Returns address of borrower's credit account and reverts of borrower has no one.\n    /// @param borrower Borrower address\n    function getCreditAccountOrRevert(address borrower)\n        public\n        view\n        override\n        returns (address)\n    {\n        address result = creditAccounts[borrower]; // T: [CM-9]\n        require(result != address(0), Errors.CM_NO_OPEN_ACCOUNT); // T: [CM-9]\n        return result;\n    }\n\n    /// @dev Calculates repay / liquidation amount\n    /// repay amount = borrow amount + interest accrued + fee amount\n    ///\n    /// More info: https://dev.gearbox.fi/developers/credit/economy#repay\n    /// https://dev.gearbox.fi/developers/credit/economy#liquidate\n    /// @param borrower Borrower address\n    /// @param isLiquidated True if"
    }
  ]
}