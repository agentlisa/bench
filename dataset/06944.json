{
  "Title": "[H-01] `LotteryMath.calculateNewProfit` returns wrong profit when there is no jackpot winner",
  "Content": "\n<https://github.com/code-423n4/2023-03-wenwin/blob/main/src/LotteryMath.sol#L50-L53>\n\n<https://github.com/code-423n4/2023-03-wenwin/blob/main/src/Lottery.sol#L216-L223>\n\n<https://github.com/code-423n4/2023-03-wenwin/blob/main/src/Lottery.sol#L238-L247>\n\n### Impact\n\n`LotteryMath.calculateNewProfit` returns the wrong profit when there is no jackpot winner, and the library function is used when we update `currentNetProfit` of `Lottery` contract.\n\n```solidity\n        currentNetProfit = LotteryMath.calculateNewProfit(\n            currentNetProfit,\n            ticketsSold[drawFinalized],\n            ticketPrice,\n            jackpotWinners > 0,\n            fixedReward(selectionSize),\n            expectedPayout\n        );\n```\n\n`Lottery.currentNetProfit` is used during reward calculation, so it can ruin the main functionality of this protocol.\n\n```solidity\n    function drawRewardSize(uint128 drawId, uint8 winTier) private view returns (uint256 rewardSize) {\n        return LotteryMath.calculateReward(\n            currentNetProfit,\n            fixedReward(winTier), \n            fixedReward(selectionSize),\n            ticketsSold[drawId],\n            winTier == selectionSize,\n            expectedPayout\n        );\n    }\n```\n\n### Proof of Concept\n\nIn `LotteryMath.calculateNewProfit`, `expectedRewardsOut` is calculated as follows:\n\n```solidity\n        uint256 expectedRewardsOut = jackpotWon\n            ? calculateReward(oldProfit, fixedJackpotSize, fixedJackpotSize, ticketsSold, true, expectedPayout)\n            : calculateMultiplier(calculateExcessPot(oldProfit, fixedJackpotSize), ticketsSold, expectedPayout)\n                * ticketsSold * expectedPayout;\n```\n\nThe calculation is not correct when there is no jackpot winner. When `jackpotWon` is false, `ticketsSold * expectedPayout` is the total payout in reward token, and then we need to apply a multiplier to the total payout, and the multiplier is `calculateMultiplier(calculateExcessPot(oldProfit, fixedJackpotSize), ticketsSold, expectedPayout)`.\n\nThe calculation result is `expectedRewardsOut`, and it is also in reward token, so we should use `PercentageMath` instead of multiplying directly.\n\nFor coded PoC, I added this function in `LotteryMath.sol` and imported `forge-std/console.sol` for console log.\n\n```solidity\n    function testCalculateNewProfit() public {\n        int256 oldProfit = 0;\n        uint256 ticketsSold = 1;\n        uint256 ticketPrice = 5 ether;\n        uint256 fixedJackpotSize = 1_000_000e18; // don't affect the profit when oldProfit is 0, use arbitrary value\n        uint256 expectedPayout = 38e16;\n        int256 newProfit = LotteryMath.calculateNewProfit(oldProfit, ticketsSold, ticketPrice, false, fixedJackpotSize, expectedPayout );\n\n        uint256 TICKET_PRICE_TO_POT = 70_000;\n        uint256 ticketsSalesToPot = PercentageMath.getPercentage(ticketsSold * ticketPrice, TICKET_PRICE_TO_POT);\n        int256 expectedProfit = oldProfit + int256(ticketsSalesToPot);\n        uint256 expectedRewardsOut = ticketsSold * expectedPayout; // full percent because oldProfit is 0\n        expectedProfit -= int256(expectedRewardsOut);\n        \n        console.log(\"Calculated value (Decimal 15):\");\n        console.logInt(newProfit / 1e15); // use decimal 15 for output purpose\n\n        console.log(\"Expected value (Decimal 15):\");\n        console.logInt(expectedProfit / 1e15);\n    }\n```\n\nThe result is as follows:\n\n      Calculated value (Decimal 15):\n      -37996500\n      Expected value (Decimal 15):\n      3120\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nUse `PercentageMath` instead of multiplying directly.\n\n```solidity\n        uint256 expectedRewardsOut = jackpotWon\n            ? calculateReward(oldProfit, fixedJackpotSize, fixedJackpotSize, ticketsSold, true, expectedPayout)\n            : (ticketsSold * expectedPayout).getPercentage(\n                calculateMultiplier(calculateExcessPot(oldProfit, fixedJackpotSize), ticketsSold, expectedPayout)\n            )\n```\n\n**[rand0c0des (Wenwin) confirmed](https://github.com/code-423n4/2023-03-wenwin-findings/issues/219)** \n\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2023-03-wenwin-contest",
  "Code": [
    {
      "filename": "src/LotteryMath.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// slither-disable-next-line solc-version\npragma solidity 0.8.19;\n\nimport \"src/interfaces/ILottery.sol\";\nimport \"src/PercentageMath.sol\";\n\n/// @dev Implementation of lottery jackpot and fees calculations\nlibrary LotteryMath {\n    using PercentageMath for uint256;\n    using PercentageMath for int256;\n\n    /// @dev percentage of ticket price being paid for staking reward\n    uint256 public constant STAKING_REWARD = 20 * PercentageMath.ONE_PERCENT;\n    /// @dev percentage of ticket price being paid to frontend operator\n    uint256 public constant FRONTEND_REWARD = 10 * PercentageMath.ONE_PERCENT;\n    /// @dev Percentage of the ticket price that goes to the pot\n    uint256 public constant TICKET_PRICE_TO_POT = PercentageMath.PERCENTAGE_BASE - STAKING_REWARD - FRONTEND_REWARD;\n    /// @dev safety margin used to calculate excess pot, in percentage\n    uint256 public constant SAFETY_MARGIN = 67 * PercentageMath.ONE_PERCENT;\n    /// @dev Percentage of excess pot reserved for bonus\n    uint256 public constant EXCESS_BONUS_ALLOCATION = 50 * PercentageMath.ONE_PERCENT;\n    /// @dev Number of lottery draws per year\n    uint128 public constant DRAWS_PER_YEAR = 52;\n\n    /// @dev Calculates new cumulative net profit and excess pot\n    /// To be called when the draw is finalized\n    /// @param oldProfit Current cumulative net profit, calculated when previous draw was finalized\n    /// @param ticketsSold Number of tickets sold for the draw that is currently finalized\n    /// @param ticketPrice One ticket price expressed in reward token\n    /// @param jackpotWon True if jackpot is won in this round\n    /// @param fixedJackpotSize Fixed jackpot price\n    /// @param expectedPayout Expected payout to players per ticket, expressed in `rewardToken`\n    /// @return newProfit New value for the cumulative net profit after the draw is finalised\n    function calculateNewProfit(\n        int256 oldProfit,\n        uint256 ticketsSold,\n        uint256 ticketPrice,\n        bool jackpotWon,\n        uint256 fixedJackpotSize,\n        uint256 expectedPayout\n    )\n        internal\n        pure\n        returns (int256 newProfit)\n    {\n        uint256 ticketsSalesToPot = (ticketsSold * ticketPrice).getPercentage(TICKET_PRICE_TO_POT);\n        newProfit = oldProfit + int256(ticketsSalesToPot);\n\n        uint256 expectedRewardsOut = jackpotWon\n            ? calculateReward(oldProfit, fixedJackpotSize, fixedJackpotSize, ticketsSold, true, expectedPayout)\n            : calculateMultiplier(calculateExcessPot(oldProfit, fixedJackpotSize), ticketsSold, expectedPayout)\n                * ticketsSold * expectedPayout;\n\n        newProfit -= int256(expectedRewardsOut);\n    }\n\n    /// @dev Calculates excess pot based on netProfit\n    /// @param netProfit Current net profit of the lottery\n    /// @param fixedJackpotSize Fixed portion of the jackpot\n    /// @return excessPot Resulting excess pot\n    function calculateExcessPot(int256 netProfit, uint256 fixedJackpotSize) internal pure returns (uint256 excessPot) {\n        int256 excessPotInt = netProfit.getPercentageInt(SAFETY_MARGIN);\n        excessPotInt -= int256(fixedJackpotSize);\n        excessPot = excessPotInt > 0 ? uint256(excessPotInt) : 0;\n    }\n\n    /// @dev Calculates multiplier to be used when calculating non jackpot rewards\n    /// @param excessPot Excess pot, calculated when previous draw was finalized\n    /// @param ticketsSold Number of tickets sold in the current draw\n    /// @param expectedPayout Expected payout to players per ticket, expressed in `rewardToken`\n    /// @return bonusMulti Multiplier to be used when calculating rewards, with `PERCENTAGE_BASE` precision\n    function calculateMultiplier(\n        uint256 excessPot,\n        uint256 ticketsSold,\n        uint256 expectedPayout\n    )\n        internal\n        pure\n        returns (uint256 bonusMulti)\n    {\n        bonusMulti = PercentageMath.PERCENTAGE_BASE;\n        if (excessPot > 0 && ticketsSold > 0) {\n            bonusMulti += (excessPot * EXCESS_BONUS_ALLOCATION) / (ticketsSold * expectedPayout);\n        }\n    }\n\n    /// @dev Calculates reward for the winning ticket\n    /// @param netProfit Current cumulative net profit, calculated when previous draw was finalized\n    /// @param fixedReward Fixed reward for particular tier of the winning ticket\n    /// @param fixedJackpot Fixed portion of the jackpot\n    /// @param ticketsSold Number of tickets sold in the current draw\n    /// @param isJackpot If it is jackpot reward\n    /// @param expectedPayout Expected payout to players per ticket, expressed in `rewardToken`\n    /// @return reward Reward size for the winning ticket\n    function calculateReward(\n        int256 netProfit,\n        uint256 fixedReward,\n        uint256 fixedJackpot,\n        uint256 ticketsSold,\n        bool isJackpot,\n        uint256 expectedPayout\n    )\n        internal\n        pure\n        returns (uint256 reward)\n    {\n        uint256 excess = calculateExcessPot(netProfit, fixedJackpot);\n        reward = isJackpot\n            ? fixedReward + excess.getPercentage(EXCESS_BONUS_ALLOCATION)\n            : fixedReward.getPercentage(calculateMultiplier(excess, ticketsSold, expectedPayout));\n    }\n\n    /// @dev Calculate frontend rewards amount for specific tickets sold\n    /// @param ticketPrice One lottery ticket price\n    /// @param ticketsSold Amount of tickets sold since last fee payout\n    /// @param rewardType Type of the reward we are calculating\n    /// @return dueRewards Total due rewards for the particular reward\n    function calculateRewards(\n        uint256 ticketPrice,\n        uint256 ticketsSold,\n        LotteryRewardType rewardType\n    )\n        internal\n        pure\n        returns (uint256 dueRewards)\n    {\n        uint256 rewardPercentage = (rewardType == LotteryRewardType.FRONTEND) ? FRONTEND_REWARD : STAKING_REWARD;\n        dueRewards = (ticketsSold * ticketPrice).getPercentage(rewardPercentage);\n    }\n}"
    },
    {
      "filename": "src/Lottery.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// slither-disable-next-line solc-version\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"src/ReferralSystem.sol\";\nimport \"src/RNSourceController.sol\";\nimport \"src/staking/Staking.sol\";\nimport \"src/LotterySetup.sol\";\nimport \"src/TicketUtils.sol\";\n\n/// @dev Lottery contract\n/// It runs `selectionSize` / `selectionMax` type of lottery.\n/// User buys the ticket by selecting total of `selectionSize` numbers from [1, selectionMax] range.\n/// Ticket price is paid each time user buys a ticket.\n/// Part of the price is staking reward, which is claimable to `stakingRewardRecipient`.\n/// Part of the price is frontend reward which is claimable by frontend operators selling the ticket.\n/// All fees, as well as rewards are paid in `rewardToken`.\n/// All prizes are dynamic and dependant on the actual ticket sales.\ncontract Lottery is ILottery, Ticket, LotterySetup, ReferralSystem, RNSourceController {\n    using SafeERC20 for IERC20;\n    using TicketUtils for uint256;\n\n    uint256 private claimedStakingRewardAtTicketId;\n    mapping(address => uint256) private frontendDueTicketSales;\n    mapping(uint128 => mapping(uint120 => uint256)) private unclaimedCount;\n\n    address public immutable override stakingRewardRecipient;\n\n    uint256 public override lastDrawFinalTicketId;\n\n    bool public override drawExecutionInProgress;\n    uint128 public override currentDraw;\n\n    mapping(uint128 => uint120) public override winningTicket;\n    mapping(uint128 => mapping(uint8 => uint256)) public override winAmount;\n\n    mapping(uint128 => uint256) public override ticketsSold;\n    int256 public override currentNetProfit;\n\n    /// @dev Checks if ticket is a valid ticket, and reverts if invalid\n    /// @param ticket Ticket being checked\n    modifier requireValidTicket(uint256 ticket) {\n        if (!ticket.isValidTicket(selectionSize, selectionMax)) {\n            revert InvalidTicket();\n        }\n        _;\n    }\n\n    /// @dev Checks if we are not executing draw already.\n    modifier whenNotExecutingDraw() {\n        if (drawExecutionInProgress) {\n            revert DrawAlreadyInProgress();\n        }\n        _;\n    }\n\n    /// @dev Checks if draw is being executed right now.\n    modifier onlyWhenExecutingDraw() {\n        if (!drawExecutionInProgress) {\n            revert DrawNotInProgress();\n        }\n        _;\n    }\n\n    /// @dev Checks that ticket owner is caller of the function. Reverts if not called by ticket owner.\n    /// @param ticketId Ticket id we are checking owner for.\n    modifier onlyTicketOwner(uint256 ticketId) {\n        if (ownerOf(ticketId) != msg.sender) {\n            revert UnauthorizedClaim(ticketId, msg.sender);\n        }\n        _;\n    }\n\n    /// @dev Constructs a new lottery contract.\n    /// @param lotterySetupParams Setup parameter for the lottery.\n    /// @param playerRewardFirstDraw Rewards for players in native token for first draw.\n    /// @param playerRewardDecreasePerDraw Decrease of rewards for players per each draw.\n    /// @param rewardsToReferrersPerDraw Percentage of native token rewards going to players.\n    /// @param maxRNFailedAttempts Maximum number of consecutive failed attempts for random number source.\n    /// @param maxRNRequestDelay Time considered as maximum delay for RN request.\n    // solhint-disable-next-line code-complexity\n    constructor(\n        LotterySetupParams memory lotterySetupParams,\n        uint256 playerRewardFirstDraw,\n        uint256 playerRewardDecreasePerDraw,\n        uint256[] memory rewardsToReferrersPerDraw,\n        uint256 maxRNFailedAttempts,\n        uint256 maxRNRequestDelay\n    )\n        Ticket()\n        LotterySetup(lotterySetupParams)\n        ReferralSystem(playerRewardFirstDraw, playerRewardDecreasePerDraw, rewardsToReferrersPerDraw)\n        RNSourceController(maxRNFailedAttempts, maxRNRequestDelay)\n    {\n        stakingRewardRecipient = address(\n            new Staking(\n            this,\n            lotterySetupParams.token,\n            nativeToken,\n            \"Staked LOT\",\n            \"stLOT\"\n            )\n        );\n\n        nativeToken.safeTransfer(msg.sender, ILotteryToken(address(nativeToken)).INITIAL_SUPPLY());\n    }\n\n    function buyTickets(\n        uint128[] calldata drawIds,\n        uint120[] calldata tickets,\n        address frontend,\n        address referrer\n    )\n        external\n        override\n        requireJackpotInitialized\n        returns (uint256[] memory ticketIds)\n    {\n        if (drawIds.length != tickets.length) {\n            revert DrawsAndTicketsLenMismatch(drawIds.length, tickets.length);\n        }\n        ticketIds = new uint256[](tickets.length);\n        for (uint256 i = 0; i < drawIds.length; ++i) {\n            ticketIds[i] = registerTicket(drawIds[i], tickets[i], frontend, referrer);\n        }\n        referralRegisterTickets(currentDraw, referrer, msg.sender, tickets.length);\n        frontendDueTicketSales[frontend] += tickets.length;\n        rewardToken.safeTransferFrom(msg.sender, address(this), ticketPrice * tickets.length);\n    }\n\n    function executeDraw() external override whenNotExecutingDraw {\n        // slither-disable-next-line timestamp\n        if (block.timestamp < drawScheduledAt(currentDraw)) {\n            revert ExecutingDrawTooEarly();\n        }\n        returnUnclaimedJackpotToThePot();\n        drawExecutionInProgress = true;\n        requestRandomNumber();\n        emit StartedExecutingDraw(currentDraw);\n    }\n\n    function unclaimedRewards(LotteryRewardType rewardType) external view override returns (uint256 rewards) {\n        uint256 dueTicketsSold = (rewardType == LotteryRewardType.FRONTEND)\n            ? frontendDueTicketSales[msg.sender]\n            : nextTicketId - claimedStakingRewardAtTicketId;\n        rewards = LotteryMath.calculateRewards(ticketPrice, dueTicketsSold, rewardType);\n    }\n\n    function claimRewards(LotteryRewardType rewardType) external override returns (uint256 claimedAmount) {\n        address beneficiary = (rewardType == LotteryRewardType.FRONTEND) ? msg.sender : stakingRewardRecipient;\n        claimedAmount = LotteryMath.calculateRewards(ticketPrice, dueTicketsSoldAndReset(beneficiary), rewardType);\n\n        emit ClaimedRewards(beneficiary, claimedAmount, rewardType);\n        rewardToken.safeTransfer(beneficiary, claimedAmount);\n    }\n\n    function claimable(uint256 ticketId) external view override returns (uint256 claimableAmount, uint8 winTier) {\n        TicketInfo memory ticketInfo = ticketsInfo[ticketId];\n        if (!ticketInfo.claimed) {\n            uint120 _winningTicket = winningTicket[ticketInfo.drawId];\n            winTier = TicketUtils.ticketWinTier(ticketInfo.combination, _winningTicket, selectionSize, selectionMax);\n            if (block.timestamp <= ticketRegistrationDeadline(ticketInfo.drawId + LotteryMath.DRAWS_PER_YEAR)) {\n                claimableAmount = winAmount[ticketInfo.drawId][winTier];\n            }\n        }\n    }\n\n    function claimWinningTickets(uint256[] calldata ticketIds) external override returns (uint256 claimedAmount) {\n        uint256 totalTickets = ticketIds.length;\n        for (uint256 i = 0; i < totalTickets; ++i) {\n            claimedAmount += claimWinningTicket(ticketIds[i]);\n        }\n        rewardToken.safeTransfer(msg.sender, claimedAmount);\n    }\n\n    /// @dev Registers the ticket in the system. To be called when user is buying the ticket.\n    /// @param drawId Draw identifier ticket is bought for.\n    /// @param ticket Combination packed as uint120.\n    function registerTicket(\n        uint128 drawId,\n        uint120 ticket,\n        address frontend,\n        address referrer\n    )\n        private\n        beforeTicketRegistrationDeadline(drawId)\n        requireValidTicket(ticket)\n        returns (uint256 ticketId)\n    {\n        ticketId = mint(msg.sender, drawId, ticket);\n        unclaimedCount[drawId][ticket]++;\n        ticketsSold[drawId]++;\n        emit NewTicket(currentDraw, ticketId, drawId, msg.sender, ticket, frontend, referrer);\n    }\n\n    /// @dev Finalizes the draw after getting random number from source.\n    /// Calculates the winning ticket. Splits jackpot rewards if there are matching tickets.\n    /// Stores claimable amounts for each win tier and calculates net profit.\n    /// Triggers referral system's mint for current draw to split the incentives.\n    /// @param randomNumber The number that is received from source.\n    function receiveRandomNumber(uint256 randomNumber) internal override onlyWhenExecutingDraw {\n        uint120 _winningTicket = TicketUtils.reconstructTicket(randomNumber, selectionSize, selectionMax);\n        uint128 drawFinalized = currentDraw++;\n        uint256 jackpotWinners = unclaimedCount[drawFinalized][_winningTicket];\n\n        if (jackpotWinners > 0) {\n            winAmount[drawFinalized][selectionSize] = drawRewardSize(drawFinalized, selectionSize) / jackpotWinners;\n        } else {\n            for (uint8 winTier = 1; winTier < selectionSize; ++winTier) {\n                winAmount[drawFinalized][winTier] = drawRewardSize(drawFinalized, winTier);\n            }\n        }\n\n        currentNetProfit = LotteryMath.calculateNewProfit(\n            currentNetProfit,\n            ticketsSold[drawFinalized],\n            ticketPrice,\n            jackpotWinners > 0,\n            fixedReward(selectionSize),\n            expectedPayout\n        );\n        winningTicket[drawFinalized] = _winningTicket;\n        drawExecutionInProgress = false;\n\n        uint256 ticketsSoldDuringDraw = nextTicketId - lastDrawFinalTicketId;\n        lastDrawFinalTicketId = nextTicketId;\n        referralDrawFinalize(drawFinalized, ticketsSoldDuringDraw);\n\n        emit FinishedExecutingDraw(drawFinalized, randomNumber, _winningTicket);\n    }\n\n    function currentRewardSize(uint8 winTier) public view override returns (uint256 rewardSize) {\n        return drawRewardSize(currentDraw, winTier);\n    }\n\n    function drawRewardSize(uint128 drawId, uint8 winTier) private view returns (uint256 rewardSize) {\n        return LotteryMath.calculateReward(\n            currentNetProfit,\n            fixedReward(winTier),\n            fixedReward(selectionSize),\n            ticketsSold[drawId],\n            winTier == selectionSize,\n            expectedPayout\n        );\n    }\n\n    function dueTicketsSoldAndReset(address beneficiary) private returns (uint256 dueTickets) {\n        if (beneficiary == stakingRewardRecipient) {\n            dueTickets = nextTicketId - claimedStakingRewardAtTicketId;\n            claimedStakingRewardAtTicketId = nextTicketId;\n        } else {\n            dueTickets = frontendDueTicketSales[beneficiary];\n            frontendDueTicketSales[beneficiary] = 0;\n        }\n    }\n\n    function claimWinningTicket(uint256 ticketId) private onlyTicketOwner(ticketId) returns (uint256 claimedAmount) {\n        uint256 winTier;\n        (claimedAmount, winTier) = this.claimable(ticketId);\n        if (claimedAmount == 0) {\n            revert NothingToClaim(ticketId);\n        }\n\n        unclaimedCount[ticketsInfo[ticketId].drawId][ticketsInfo[ticketId].combination]--;\n        markAsClaimed(ticketId);\n        emit ClaimedTicket(msg.sender, ticketId, claimedAmount);\n    }\n\n    function returnUnclaimedJackpotToThePot() private {\n        if (currentDraw >= LotteryMath.DRAWS_PER_YEAR) {\n            uint128 drawId = currentDraw - LotteryMath.DRAWS_PER_YEAR;\n            uint256 unclaimedJackpotTickets = unclaimedCount[drawId][winningTicket[drawId]];\n            currentNetProfit += int256(unclaimedJackpotTickets * winAmount[drawId][selectionSize]);\n        }\n    }\n\n    function requireFinishedDraw(uint128 drawId) internal view override {\n        if (drawId >= currentDraw) {\n            revert DrawNotFinished(drawId);\n        }\n    }\n\n    function mintNativeTokens(address mintTo, uint256 amount) internal override {\n        ILotteryToken(address(nativeToken)).mint(mintTo, amount);\n    }\n}"
    },
    {
      "filename": "src/Lottery.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// slither-disable-next-line solc-version\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"src/ReferralSystem.sol\";\nimport \"src/RNSourceController.sol\";\nimport \"src/staking/Staking.sol\";\nimport \"src/LotterySetup.sol\";\nimport \"src/TicketUtils.sol\";\n\n/// @dev Lottery contract\n/// It runs `selectionSize` / `selectionMax` type of lottery.\n/// User buys the ticket by selecting total of `selectionSize` numbers from [1, selectionMax] range.\n/// Ticket price is paid each time user buys a ticket.\n/// Part of the price is staking reward, which is claimable to `stakingRewardRecipient`.\n/// Part of the price is frontend reward which is claimable by frontend operators selling the ticket.\n/// All fees, as well as rewards are paid in `rewardToken`.\n/// All prizes are dynamic and dependant on the actual ticket sales.\ncontract Lottery is ILottery, Ticket, LotterySetup, ReferralSystem, RNSourceController {\n    using SafeERC20 for IERC20;\n    using TicketUtils for uint256;\n\n    uint256 private claimedStakingRewardAtTicketId;\n    mapping(address => uint256) private frontendDueTicketSales;\n    mapping(uint128 => mapping(uint120 => uint256)) private unclaimedCount;\n\n    address public immutable override stakingRewardRecipient;\n\n    uint256 public override lastDrawFinalTicketId;\n\n    bool public override drawExecutionInProgress;\n    uint128 public override currentDraw;\n\n    mapping(uint128 => uint120) public override winningTicket;\n    mapping(uint128 => mapping(uint8 => uint256)) public override winAmount;\n\n    mapping(uint128 => uint256) public override ticketsSold;\n    int256 public override currentNetProfit;\n\n    /// @dev Checks if ticket is a valid ticket, and reverts if invalid\n    /// @param ticket Ticket being checked\n    modifier requireValidTicket(uint256 ticket) {\n        if (!ticket.isValidTicket(selectionSize, selectionMax)) {\n            revert InvalidTicket();\n        }\n        _;\n    }\n\n    /// @dev Checks if we are not executing draw already.\n    modifier whenNotExecutingDraw() {\n        if (drawExecutionInProgress) {\n            revert DrawAlreadyInProgress();\n        }\n        _;\n    }\n\n    /// @dev Checks if draw is being executed right now.\n    modifier onlyWhenExecutingDraw() {\n        if (!drawExecutionInProgress) {\n            revert DrawNotInProgress();\n        }\n        _;\n    }\n\n    /// @dev Checks that ticket owner is caller of the function. Reverts if not called by ticket owner.\n    /// @param ticketId Ticket id we are checking owner for.\n    modifier onlyTicketOwner(uint256 ticketId) {\n        if (ownerOf(ticketId) != msg.sender) {\n            revert UnauthorizedClaim(ticketId, msg.sender);\n        }\n        _;\n    }\n\n    /// @dev Constructs a new lottery contract.\n    /// @param lotterySetupParams Setup parameter for the lottery.\n    /// @param playerRewardFirstDraw Rewards for players in native token for first draw.\n    /// @param playerRewardDecreasePerDraw Decrease of rewards for players per each draw.\n    /// @param rewardsToReferrersPerDraw Percentage of native token rewards going to players.\n    /// @param maxRNFailedAttempts Maximum number of consecutive failed attempts for random number source.\n    /// @param maxRNRequestDelay Time considered as maximum delay for RN request.\n    // solhint-disable-next-line code-complexity\n    constructor(\n        LotterySetupParams memory lotterySetupParams,\n        uint256 playerRewardFirstDraw,\n        uint256 playerRewardDecreasePerDraw,\n        uint256[] memory rewardsToReferrersPerDraw,\n        uint256 maxRNFailedAttempts,\n        uint256 maxRNRequestDelay\n    )\n        Ticket()\n        LotterySetup(lotterySetupParams)\n        ReferralSystem(playerRewardFirstDraw, playerRewardDecreasePerDraw, rewardsToReferrersPerDraw)\n        RNSourceController(maxRNFailedAttempts, maxRNRequestDelay)\n    {\n        stakingRewardRecipient = address(\n            new Staking(\n            this,\n            lotterySetupParams.token,\n            nativeToken,\n            \"Staked LOT\",\n            \"stLOT\"\n            )\n        );\n\n        nativeToken.safeTransfer(msg.sender, ILotteryToken(address(nativeToken)).INITIAL_SUPPLY());\n    }\n\n    function buyTickets(\n        uint128[] calldata drawIds,\n        uint120[] calldata tickets,\n        address frontend,\n        address referrer\n    )\n        external\n        override\n        requireJackpotInitialized\n        returns (uint256[] memory ticketIds)\n    {\n        if (drawIds.length != tickets.length) {\n            revert DrawsAndTicketsLenMismatch(drawIds.length, tickets.length);\n        }\n        ticketIds = new uint256[](tickets.length);\n        for (uint256 i = 0; i < drawIds.length; ++i) {\n            ticketIds[i] = registerTicket(drawIds[i], tickets[i], frontend, referrer);\n        }\n        referralRegisterTickets(currentDraw, referrer, msg.sender, tickets.length);\n        frontendDueTicketSales[frontend] += tickets.length;\n        rewardToken.safeTransferFrom(msg.sender, address(this), ticketPrice * tickets.length);\n    }\n\n    function executeDraw() external override whenNotExecutingDraw {\n        // slither-disable-next-line timestamp\n        if (block.timestamp < drawScheduledAt(currentDraw)) {\n            revert ExecutingDrawTooEarly();\n        }\n        returnUnclaimedJackpotToThePot();\n        drawExecutionInProgress = true;\n        requestRandomNumber();\n        emit StartedExecutingDraw(currentDraw);\n    }\n\n    function unclaimedRewards(LotteryRewardType rewardType) external view override returns (uint256 rewards) {\n        uint256 dueTicketsSold = (rewardType == LotteryRewardType.FRONTEND)\n            ? frontendDueTicketSales[msg.sender]\n            : nextTicketId - claimedStakingRewardAtTicketId;\n        rewards = LotteryMath.calculateRewards(ticketPrice, dueTicketsSold, rewardType);\n    }\n\n    function claimRewards(LotteryRewardType rewardType) external override returns (uint256 claimedAmount) {\n        address beneficiary = (rewardType == LotteryRewardType.FRONTEND) ? msg.sender : stakingRewardRecipient;\n        claimedAmount = LotteryMath.calculateRewards(ticketPrice, dueTicketsSoldAndReset(beneficiary), rewardType);\n\n        emit ClaimedRewards(beneficiary, claimedAmount, rewardType);\n        rewardToken.safeTransfer(beneficiary, claimedAmount);\n    }\n\n    function claimable(uint256 ticketId) external view override returns (uint256 claimableAmount, uint8 winTier) {\n        TicketInfo memory ticketInfo = ticketsInfo[ticketId];\n        if (!ticketInfo.claimed) {\n            uint120 _winningTicket = winningTicket[ticketInfo.drawId];\n            winTier = TicketUtils.ticketWinTier(ticketInfo.combination, _winningTicket, selectionSize, selectionMax);\n            if (block.timestamp <= ticketRegistrationDeadline(ticketInfo.drawId + LotteryMath.DRAWS_PER_YEAR)) {\n                claimableAmount = winAmount[ticketInfo.drawId][winTier];\n            }\n        }\n    }\n\n    function claimWinningTickets(uint256[] calldata ticketIds) external override returns (uint256 claimedAmount) {\n        uint256 totalTickets = ticketIds.length;\n        for (uint256 i = 0; i < totalTickets; ++i) {\n            claimedAmount += claimWinningTicket(ticketIds[i]);\n        }\n        rewardToken.safeTransfer(msg.sender, claimedAmount);\n    }\n\n    /// @dev Registers the ticket in the system. To be called when user is buying the ticket.\n    /// @param drawId Draw identifier ticket is bought for.\n    /// @param ticket Combination packed as uint120.\n    function registerTicket(\n        uint128 drawId,\n        uint120 ticket,\n        address frontend,\n        address referrer\n    )\n        private\n        beforeTicketRegistrationDeadline(drawId)\n        requireValidTicket(ticket)\n        returns (uint256 ticketId)\n    {\n        ticketId = mint(msg.sender, drawId, ticket);\n        unclaimedCount[drawId][ticket]++;\n        ticketsSold[drawId]++;\n        emit NewTicket(currentDraw, ticketId, drawId, msg.sender, ticket, frontend, referrer);\n    }\n\n    /// @dev Finalizes the draw after getting random number from source.\n    /// Calculates the winning ticket. Splits jackpot rewards if there are matching tickets.\n    /// Stores claimable amounts for each win tier and calculates net profit.\n    /// Triggers referral system's mint for current draw to split the incentives.\n    /// @param randomNumber The number that is received from source.\n    function receiveRandomNumber(uint256 randomNumber) internal override onlyWhenExecutingDraw {\n        uint120 _winningTicket = TicketUtils.reconstructTicket(randomNumber, selectionSize, selectionMax);\n        uint128 drawFinalized = currentDraw++;\n        uint256 jackpotWinners = unclaimedCount[drawFinalized][_winningTicket];\n\n        if (jackpotWinners > 0) {\n            winAmount[drawFinalized][selectionSize] = drawRewardSize(drawFinalized, selectionSize) / jackpotWinners;\n        } else {\n            for (uint8 winTier = 1; winTier < selectionSize; ++winTier) {\n                winAmount[drawFinalized][winTier] = drawRewardSize(drawFinalized, winTier);\n            }\n        }\n\n        currentNetProfit = LotteryMath.calculateNewProfit(\n            currentNetProfit,\n            ticketsSold[drawFinalized],\n            ticketPrice,\n            jackpotWinners > 0,\n            fixedReward(selectionSize),\n            expectedPayout\n        );\n        winningTicket[drawFinalized] = _winningTicket;\n        drawExecutionInProgress = false;\n\n        uint256 ticketsSoldDuringDraw = nextTicketId - lastDrawFinalTicketId;\n        lastDrawFinalTicketId = nextTicketId;\n        referralDrawFinalize(drawFinalized, ticketsSoldDuringDraw);\n\n        emit FinishedExecutingDraw(drawFinalized, randomNumber, _winningTicket);\n    }\n\n    function currentRewardSize(uint8 winTier) public view override returns (uint256 rewardSize) {\n        return drawRewardSize(currentDraw, winTier);\n    }\n\n    function drawRewardSize(uint128 drawId, uint8 winTier) private view returns (uint256 rewardSize) {\n        return LotteryMath.calculateReward(\n            currentNetProfit,\n            fixedReward(winTier),\n            fixedReward(selectionSize),\n            ticketsSold[drawId],\n            winTier == selectionSize,\n            expectedPayout\n        );\n    }\n\n    function dueTicketsSoldAndReset(address beneficiary) private returns (uint256 dueTickets) {\n        if (beneficiary == stakingRewardRecipient) {\n            dueTickets = nextTicketId - claimedStakingRewardAtTicketId;\n            claimedStakingRewardAtTicketId = nextTicketId;\n        } else {\n            dueTickets = frontendDueTicketSales[beneficiary];\n            frontendDueTicketSales[beneficiary] = 0;\n        }\n    }\n\n    function claimWinningTicket(uint256 ticketId) private onlyTicketOwner(ticketId) returns (uint256 claimedAmount) {\n        uint256 winTier;\n        (claimedAmount, winTier) = this.claimable(ticketId);\n        if (claimedAmount == 0) {\n            revert NothingToClaim(ticketId);\n        }\n\n        unclaimedCount[ticketsInfo[ticketId].drawId][ticketsInfo[ticketId].combination]--;\n        markAsClaimed(ticketId);\n        emit ClaimedTicket(msg.sender, ticketId, claimedAmount);\n    }\n\n    function returnUnclaimedJackpotToThePot() private {\n        if (currentDraw >= LotteryMath.DRAWS_PER_YEAR) {\n            uint128 drawId = currentDraw - LotteryMath.DRAWS_PER_YEAR;\n            uint256 unclaimedJackpotTickets = unclaimedCount[drawId][winningTicket[drawId]];\n            currentNetProfit += int256(unclaimedJackpotTickets * winAmount[drawId][selectionSize]);\n        }\n    }\n\n    function requireFinishedDraw(uint128 drawId) internal view override {\n        if (drawId >= currentDraw) {\n            revert DrawNotFinished(drawId);\n        }\n    }\n\n    function mintNativeTokens(address mintTo, uint256 amount) internal override {\n        ILotteryToken(address(nativeToken)).mint(mintTo, amount);\n    }\n}"
    }
  ]
}