{
  "Title": "M-24: Variable opening fee will always be wrongly computed if collateral is not a stablecoin",
  "Content": "# Issue M-24: Variable opening fee will always be wrongly computed if collateral is not a stablecoin \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/119 \n\n## Found by \n0xadrii, Tendency\n## Summary\n\nBorrowing fees will be computed wrongly because of a combination of hardcoded values and a wrongly implemented setter function.\n\n## Vulnerability Detail\n\nTapioca applies a linearly scaling creation fee to open a new CDP in Big Bang markets. This is done via the internal `_computeVariableOpeningFee()` function every time a new borrow is performed.\n\nIn order to compute the variable fee, the exchange rate will be queried. This rate is important in order to understand the current price of USDO related to the collateral asset. \n\n- If `_exchangeRate >= minMintFeeStart`, then `minMintFee` will be applied.\n- If `_exchangeRate <= maxMintFeeStart`, then `maxMintFee` will be applied\n- Otherwise, a proportional percentage will be applied to compue the fee\n\nAs per the comment in the code snippet shows below, Tapioca wrongly assumes that the exchange rate will always be `USDO <> USDC`, when in reality the actual collateral will dictate the exchange rate returned. \n\nIt is also important to note the fact that contrary to what one would assume, `maxMintFeeStart` is assumed to be smaller than `minMintFeeStart` in order to perform the calculations:\n\n```solidity\n// BBLendingCommon.sol\n\nfunction _computeVariableOpeningFee(uint256 amount) internal returns (uint256) {\n        if (amount == 0) return 0; \n \n        //get asset <> USDC price ( USDO <> USDC ) \n        (bool updated, uint256 _exchangeRate) = assetOracle.get(oracleData); \n        if (!updated) revert OracleCallFailed();\n   \n        if (_exchangeRate >= minMintFeeStart) { \n            return (amount * minMintFee) / FEE_PRECISION;\n        }\n        if (_exchangeRate <= maxMintFeeStart) { \n            return (amount * maxMintFee) / FEE_PRECISION;\n        }\n     \n        uint256 fee = maxMintFee\n            - (((_exchangeRate - maxMintFeeStart) * (maxMintFee - minMintFee)) / (minMintFeeStart - maxMintFeeStart)); \n \n        if (fee > maxMintFee) return (amount * maxMintFee) / FEE_PRECISION;\n        if (fee < minMintFee) return (amount * minMintFee) / FEE_PRECISION;\n\n        if (fee > 0) {\n            return (amount * fee) / FEE_PRECISION;\n        }\n        return 0;\n    }\n```\n\nIt is also important to note that `minMintFeeStart` and `maxMintFeeStart` are hardcoded when being initialized inside `BigBang.sol` (as mentioned, `maxMintFeeStart` is smaller than `minMintFeeStart`):\n\n```solidity\n// BigBang.sol\n\nfunction _initCoreStorage(\n        IPenrose _penrose,\n        IERC20 _collateral,\n        uint256 _collateralId,\n        ITapiocaOracle _oracle,\n        uint256 _exchangeRatePrecision,\n        uint256 _collateralizationRate,\n        uint256 _liquidationCollateralizationRate,\n        ILeverageExecutor _leverageExecutor\n    ) private {\n        ...\n        \n        maxMintFeeStart = 975000000000000000; // 0.975 *1e18\n        minMintFeeStart = 1000000000000000000; // 1*1e18\n\n        ...\n    } \n```\n\nWhile the values hardcoded initially to values that are coherent for a USDO <> stablecoin exchange rate, these values won’t make sense if we find ourselves fetching an exchcange rate of an asset not stable.\n\nLet’s say the collateral asset is ETH. If ETH is at 4000$, then the exchange rate will return a value of 0,00025. This will make the computation inside `_computeVariableOpeningFee()` always apply the maximum fee when borrowing because `_exchangeRate` is always smaller than `maxMintFeeStart` by default.\n\nAlthough this has an easy fix (changing the values stored in `maxMintFeeStart` and  `minMintFeeStart`), this can’t be properly done because the `setMinAndMaxMintRange()` function wrongly assumes that `minMintFeeStart` must be smaller than `maxMintFeeStart` (against what the actual calculations dictate in the `_computeVariableOpeningFee()`): \n\n```solidity\n// BigBang.sol\n\nfunction setMinAndMaxMintRange(uint256 _min, uint256 _max) external onlyOwner {\n        emit UpdateMinMaxMintRange(minMintFeeStart, _min, maxMintFeeStart, _max);\n\n        if (_min >= _max) revert NotValid(); \n\n        minMintFeeStart = _min;\n        maxMintFeeStart = _max;\n    } \n```\n\nThis will make it impossible to properly update the `maxMintFeeStart` and `minMintFeeStart` to have proper values because if it is enforced that `maxMintFeeStart` > than `minMintFeeStart`, then `_computeVariableOpeningFee()` will always enter the first `if (_exchangeRate >= minMintFeeStart)` and wrongly return the minimum fee.\n\n## Impact\n\nMedium. Although this looks like a bug that doesn’t have a big impact in the protocol, it actually does. The fees will always be wrongly applied for collaterals different from stablecoins, and applying these kind of fees when borrowing is one of the core mechanisms to keep USDO peg, as described in [Tapioca’s documentation](https://docs.tapioca.xyz/tapioca/core-technologies/big-bang#variable-usdo-creation-fee). If this mechanisms doesn’t work properly, users won’t be properly incentivized to borrow/repay considering the different market conditions that might take place and affect USDO’s peg to $1.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BBLendingCommon.sol#L87-L91\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BigBang.sol#L194-L195\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe mitigation for this is straightforward. Change the `setMinAndMaxMintRange()` function so that `_max` is enforced to be smaller than `_min`:\n\n```diff\n// BigBang.sol\n\nfunction setMinAndMaxMintRange(uint256 _min, uint256 _max) external onlyOwner {\n        emit UpdateMinMaxMintRange(minMintFeeStart, _min, maxMintFeeStart, _max);\n\n-        if (_min >= _max) revert NotValid(); \n+        if (_max >= _min) revert NotValid(); \n\n        minMintFeeStart = _min;\n        maxMintFeeStart = _max;\n    } \n```\n\nAlso, I would recommend not to hardcode the values of `maxMintFeeStart` and `minMintFeeStart` and pass them as parameter instead, inside `_initCoreStorage()` , as they should always be different considering the collateral configured for that market.\n\n\n\n## Discussion\n\n**cryptotechmaker**\n\nLow; the `assetOracle` is different from the `oracle` state var which is represented by the market's collateral. The `assetOracle` checks the USDO price against USDC\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/Tapioca-bar/pull/374.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/contracts/markets/bigBang/BBLendingCommon.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\n// Tapioca\nimport {IUsdo} from \"tapioca-periph/interfaces/oft/IUsdo.sol\";\nimport {BBCommon} from \"./BBCommon.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract BBLendingCommon is BBCommon {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error BorrowCapReached();\n    error OracleCallFailed();\n    error NothingToRepay();\n    error RepayAmountNotValid();\n    error AllowanceNotValid();\n\n    // ************************** //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _addCollateral(address from, address to, bool skim, uint256 amount, uint256 share) internal {\n        if (share == 0) {\n            share = yieldBox.toShare(collateralId, amount, false);\n        }\n        userCollateralShare[to] += share;\n        uint256 oldTotalCollateralShare = totalCollateralShare;\n        totalCollateralShare = oldTotalCollateralShare + share;\n        _addTokens(from, collateralId, share, oldTotalCollateralShare, skim);\n        emit LogAddCollateral(skim ? address(yieldBox) : from, to, share);\n    }\n\n    /// @dev Concrete implementation of `removeCollateral`.\n    function _removeCollateral(address from, address to, uint256 share) internal {\n        userCollateralShare[from] -= share;\n        totalCollateralShare -= share;\n        emit LogRemoveCollateral(from, to, share);\n        yieldBox.transfer(address(this), to, collateralId, share);\n    }\n\n    /// @dev Concrete implementation of `borrow`.\n    function _borrow(address from, address to, uint256 amount, uint256 feeAmount)\n        internal\n        returns (uint256 part, uint256 share)\n    {\n        (totalBorrow, part) = totalBorrow.add(amount + feeAmount, true);\n\n        if (totalBorrowCap > 0) {\n            if (totalBorrow.elastic > totalBorrowCap) revert BorrowCapReached();\n        }\n\n        userBorrowPart[from] += part;\n        emit LogBorrow(from, to, amount, feeAmount, part);\n\n        //mint USDO\n        IUsdo(address(asset)).mint(address(this), amount);\n\n        //deposit borrowed amount to user\n        share = _depositAmountToYb(asset, to, assetId, amount);\n    }\n\n    function _computeVariableOpeningFee(uint256 amount) internal returns (uint256) {\n        if (amount == 0) return 0;\n\n        //get asset <> USDC price ( USDO <> USDC )\n        (bool updated, uint256 _exchangeRate) = assetOracle.get(oracleData);\n        if (!updated) revert OracleCallFailed();\n\n        if (_exchangeRate >= minMintFeeStart) {\n            return (amount * minMintFee) / FEE_PRECISION;\n        }\n        if (_exchangeRate <= maxMintFeeStart) {\n            return (amount * maxMintFee) / FEE_PRECISION;\n        }\n\n        uint256 fee = maxMintFee\n            - (((_exchangeRate - maxMintFeeStart) * (maxMintFee - minMintFee)) / (minMintFeeStart - maxMintFeeStart));\n\n        if (fee > maxMintFee) return (amount * maxMintFee) / FEE_PRECISION;\n        if (fee < minMintFee) return (amount * minMintFee) / FEE_PRECISION;\n\n        if (fee > 0) {\n            return (amount * fee) / FEE_PRECISION;\n        }\n        return 0;\n    }\n\n    /// @dev Concrete implementation of `repay`.\n    function _repay(address from, address to, uint256 part) internal returns (uint256 amount) {\n        if (part > userBorrowPart[to]) {\n            part = userBorrowPart[to];\n        }\n        if (part == 0) revert NothingToRepay();\n\n        // @dev check allowance\n        if (msg.sender != from) {\n            uint256 partInAmount;\n            Rebase memory _totalBorrow = totalBorrow;\n            (_totalBorrow, partInAmount) = _totalBorrow.sub(part, false);\n            uint256 allowanceShare =\n                _computeAllowanceAmountInAsset(to, exchangeRate, partInAmount, _safeDecimals(asset));\n            if (allowanceShare == 0) revert AllowanceNotValid();\n            _allowedBorrow(from, allowanceShare);\n        }\n\n        // @dev sub `part` of totalBorrow\n        (totalBorrow, amount) = totalBorrow.sub(part, true);\n        userBorrowPart[to] -= part;\n\n        // @dev amount includes the opening & accrued fees\n        yieldBox.withdraw(assetId, from, address(this), amount, 0);\n\n        // @dev burn USDO\n        IUsdo(address(asset)).burn(address(this), amount);\n\n        emit LogRepay(from, to, amount, part);\n    }\n\n    function _safeDecimals(IERC20 token) internal view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567)); //decimals() selector\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/bigBang/BigBang.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\n// Tapioca\nimport {ILeverageExecutor} from \"tapioca-periph/interfaces/bar/ILeverageExecutor.sol\";\nimport {ITapiocaOracle} from \"tapioca-periph/interfaces/periph/ITapiocaOracle.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IPearlmit} from \"tapioca-periph/interfaces/periph/IPearlmit.sol\";\nimport {IPenrose} from \"tapioca-periph/interfaces/bar/IPenrose.sol\";\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\nimport {BBLiquidation} from \"./BBLiquidation.sol\";\nimport {BBCollateral} from \"./BBCollateral.sol\";\nimport {BBLeverage} from \"./BBLeverage.sol\";\nimport {BBCommon} from \"./BBCommon.sol\";\nimport {BBBorrow} from \"./BBBorrow.sol\";\n\n// solhint-disable max-line-length\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract BigBang is BBCommon {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n    using SafeApprove for address;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error BadPair();\n    error DebtRatesNotValid();\n    error MaxDebtRateNotValid();\n    error NotValid();\n    error ModuleNotSet();\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    /// @notice enum representing each type of module associated with a Singularity market\n    /// @dev modules are contracts that holds a portion of the market's logic\n    enum Module {\n        Base,\n        Borrow,\n        Collateral,\n        Liquidation,\n        Leverage\n    }\n    /// @notice returns the liquidation module\n\n    BBLiquidation public liquidationModule;\n    /// @notice returns the borrow module\n    BBBorrow public borrowModule;\n    /// @notice returns the collateral module\n    BBCollateral public collateralModule;\n    /// @notice returns the leverage module\n    BBLeverage public leverageModule;\n\n    struct _InitMemoryData {\n        IPenrose _penrose;\n        IERC20 _collateral;\n        uint256 _collateralId;\n        ITapiocaOracle _oracle;\n        uint256 _exchangeRatePrecision;\n        uint256 _collateralizationRate;\n        uint256 _liquidationCollateralizationRate;\n        ILeverageExecutor _leverageExecutor;\n    }\n\n    struct _InitMemoryModulesData {\n        address _liquidationModule;\n        address _borrowModule;\n        address _collateralModule;\n        address _leverageModule;\n    }\n\n    struct _InitMemoryDebtData {\n        uint256 _debtRateAgainstEth;\n        uint256 _debtRateMin;\n        uint256 _debtRateMax;\n    }\n\n    /// @notice The init function that acts as a constructor\n    function init(bytes calldata initData) external onlyOnce {\n        (\n            _InitMemoryModulesData memory initModulesData,\n            _InitMemoryDebtData memory initDebtData,\n            _InitMemoryData memory initMemoryData\n        ) = abi.decode(initData, (_InitMemoryModulesData, _InitMemoryDebtData, _InitMemoryData));\n\n        _initModules(\n            initModulesData._liquidationModule,\n            initModulesData._borrowModule,\n            initModulesData._collateralModule,\n            initModulesData._leverageModule\n        );\n        _initCoreStorage(\n            initMemoryData._penrose,\n            initMemoryData._collateral,\n            initMemoryData._collateralId,\n            initMemoryData._oracle,\n            initMemoryData._exchangeRatePrecision,\n            initMemoryData._collateralizationRate,\n            initMemoryData._liquidationCollateralizationRate,\n            initMemoryData._leverageExecutor\n        );\n        _initDebtStorage(initDebtData._debtRateAgainstEth, initDebtData._debtRateMin, initDebtData._debtRateMax);\n    }\n\n    function _initModules(\n        address _liquidationModule,\n        address _borrowModule,\n        address _collateralModule,\n        address _leverageModule\n    ) private {\n        liquidationModule = BBLiquidation(_liquidationModule);\n        collateralModule = BBCollateral(_collateralModule);\n        borrowModule = BBBorrow(_borrowModule);\n        leverageModule = BBLeverage(_leverageModule);\n    }\n\n    function _initDebtStorage(uint256 _debtRateAgainstEth, uint256 _debtRateMin, uint256 _debtRateMax) private {\n        isMainMarket = collateralId == penrose.mainAssetId();\n        if (!isMainMarket) {\n            if (minDebtRate != 0 && maxDebtRate != 0) {\n                if (_debtRateMin >= _debtRateMax) revert DebtRatesNotValid();\n                if (_debtRateMax > 1e18) revert MaxDebtRateNotValid();\n            }\n            debtRateAgainstEthMarket = _debtRateAgainstEth;\n            maxDebtRate = _debtRateMax;\n            minDebtRate = _debtRateMin;\n        }\n    }\n\n    function _initCoreStorage(\n        IPenrose _penrose,\n        IERC20 _collateral,\n        uint256 _collateralId,\n        ITapiocaOracle _oracle,\n        uint256 _exchangeRatePrecision,\n        uint256 _collateralizationRate,\n        uint256 _liquidationCollateralizationRate,\n        ILeverageExecutor _leverageExecutor\n    ) private {\n        penrose = _penrose;\n        pearlmit = IPearlmit(_penrose.pearlmit());\n        yieldBox = IYieldBox(_penrose.yieldBox());\n\n        address _asset = penrose.usdoToken();\n\n        if (address(_collateral) == address(0)) revert BadPair();\n        if (address(_asset) == address(0)) revert BadPair();\n        if (address(_oracle) == address(0)) revert BadPair();\n        if (_collateralizationRate > FEE_PRECISION) revert NotValid();\n        if (_liquidationCollateralizationRate > FEE_PRECISION) {\n            revert NotValid();\n        }\n        asset = IERC20(_asset);\n        assetId = penrose.usdoAssetId();\n        collateral = _collateral;\n        collateralId = _collateralId;\n        oracle = _oracle;\n        updateExchangeRate();\n        protocolFee = 10000; // 10%; used for accrual\n        collateralizationRate = _collateralizationRate > 0 ? _collateralizationRate : 75000;\n        liquidationCollateralizationRate =\n            _liquidationCollateralizationRate > 0 ? _liquidationCollateralizationRate : 80000;\n\n        if (liquidationCollateralizationRate < collateralizationRate) {\n            revert NotValid();\n        }\n\n        EXCHANGE_RATE_PRECISION = _exchangeRatePrecision > 0 ? _exchangeRatePrecision : 1e18;\n\n        minLiquidatorReward = 8e4;\n        maxLiquidatorReward = 9e4;\n        liquidationBonusAmount = 1e4;\n        liquidationMultiplier = 12000; //12%\n\n        rateValidDuration = 24 hours;\n        minMintFee = 0;\n        maxMintFee = 1000; // 1%\n        maxMintFeeStart = 975000000000000000; // 0.975 *1e18\n        minMintFeeStart = 1000000000000000000; // 1*1e18\n\n        leverageExecutor = _leverageExecutor;\n\n        _transferOwnership(address(penrose));\n        conservator = address(penrose);\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n\n    /// @notice Allows batched call to BingBang.\n    /// @param calls An array encoded call data.\n    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n    function execute(Module[] calldata modules, bytes[] calldata calls, bool revertOnFail)\n        external\n        nonReentrant\n        returns (bool[] memory successes, bytes[] memory results)\n    {\n        successes = new bool[](calls.length);\n        results = new bytes[](calls.length);\n        if (modules.length != calls.length) revert NotValid();\n        unchecked {\n            for (uint256 i; i < calls.length; i++) {\n                (bool success, bytes memory result) = _extractModule(modules[i]).delegatecall(calls[i]);\n\n                if (!success && revertOnFail) {\n                    revert(abi.decode(_getRevertMsg(result), (string)));\n                }\n                successes[i] = success;\n                results[i] = !success ? _getRevertMsg(result) : result;\n            }\n        }\n    }\n\n    // ************************* //\n    // *** OWNER FUNCTIONS ***** //\n    // ************************* //\n    /// @notice updates the pause state of the contract\n    /// @dev can only be called by the conservator\n    /// @param val the new value\n    function updatePause(PauseType _type, bool val) external {\n        require(msg.sender == conservator, \"Market: unauthorized\");\n        require(val != pauseOptions[_type], \"Market: same state\");\n        emit PausedUpdated(_type, pauseOptions[_type], val);\n        pauseOptions[_type] = val;\n    }\n\n    /// @notice updates the pause state of the contract for all types\n    /// @param val the new val\n    function updatePauseAll(bool val) external {\n        require(msg.sender == conservator, \"Market: unauthorized\");\n\n        pauseOptions[PauseType.Borrow] = val;\n        pauseOptions[PauseType.Repay] = val;\n        pauseOptions[PauseType.AddCollateral] = val;\n        pauseOptions[PauseType.RemoveCollateral] = val;\n        pauseOptions[PauseType.Liquidation] = val;\n        pauseOptions[PauseType.LeverageBuy] = val;\n        pauseOptions[PauseType.LeverageSell] = val;\n\n        emit PausedUpdated(PauseType.Borrow, pauseOptions[PauseType.Borrow], val);\n        emit PausedUpdated(PauseType.Repay, pauseOptions[PauseType.Repay], val);\n        emit PausedUpdated(PauseType.AddCollateral, pauseOptions[PauseType.AddCollateral], val);\n        emit PausedUpdated(PauseType.RemoveCollateral, pauseOptions[PauseType.RemoveCollateral], val);\n        emit PausedUpdated(PauseType.Liquidation, pauseOptions[PauseType.Liquidation], val);\n        emit PausedUpdated(PauseType.LeverageBuy, pauseOptions[PauseType.LeverageBuy], val);\n        emit PausedUpdated(PauseType.LeverageSell, pauseOptions[PauseType.LeverageSell], val);\n    }\n\n    /// @notice sets min and max mint range\n    /// @dev can only be called by the owner\n    /// @param _min the new min start\n    /// @param _max the new max start\n    function setMinAndMaxMintRange(uint256 _min, uint256 _max) external onlyOwner {\n        emit UpdateMinMaxMintRange(minMintFeeStart, _min, maxMintFeeStart, _max);\n\n        if (_min >= _max) revert NotValid();\n\n        minMintFeeStart = _min;\n        maxMintFeeStart = _max;\n    }\n\n    /// @notice sets min and max mint fee\n    /// @dev can only be called by the owner\n    /// @param _min the new min fee\n    /// @param _max the new max fee\n    function setMinAndMaxMintFee(uint256 _min, uint256 _max) external onlyOwner {\n        emit UpdateMinMaxMintFee(minMintFee, _min, maxMintFee, _max);\n        if (_min >= _max) revert NotValid();\n        minMintFee = _min;\n        maxMintFee = _max;\n    }\n\n    /// @notice updates asset's oracle info\n    /// @dev can only be called by the owner\n    /// @param _oracle the new ITapiocaOracle address\n    /// @param _oracleData the new ITapiocaOracle data\n    function setAssetOracle(address _oracle, bytes calldata _oracleData) external onlyOwner {\n        if (_oracle != address(0)) {\n            emit AssetOracleUpdated(address(assetOracle), _oracle);\n            assetOracle = ITapiocaOracle(_oracle);\n        }\n        if (_oracleData.length > 0) {\n            assetOracleData = _oracleData;\n            emit AssetOracleDataUpdated();\n        }\n    }\n\n    /// @notice rescues unused ETH from the contract\n    /// @param amount the amount to rescue\n    /// @param to the recipient\n    function rescueEth(uint256 amount, address to) external onlyOwner {\n        (bool success,) = to.call{value: amount}(\"\");\n        if (!success) revert TransferFailed();\n    }\n\n    /// @notice Transfers fees to penrose\n    /// @dev can only be called by the owner\n    /// @return feeShares the amount of fees in shares withdrawn under Penrose\n    function refreshPenroseFees() external onlyOwner returns (uint256 feeShares) {\n        uint256 fees = asset.balanceOf(address(this));\n        feeShares = yieldBox.toShare(assetId, fees, false);\n        if (feeShares > 0) {\n            address(asset).safeApprove(address(yieldBox), fees);\n            yieldBox.depositAsset(assetId, address(this), msg.sender, 0, feeShares);\n        }\n    }\n\n    /// @notice sets BigBang specific configuration\n    /// @dev values are updated only if > 0 or not address(0)\n    /// @param _minDebtRate the minimum debt rate (5000000000000000 is 0.5%)\n    /// @param _maxDebtRate the maximum debt rate (50000000000000000 is 5%)\n    /// @param _debtRateAgainstEthMarket the debt ratio against the main BB market (200000000000000000 is 20%)\n    /// @param _liquidationMultiplier the liquidation bonus percentage (12000 is 12%)\n    function setBigBangConfig(\n        uint256 _minDebtRate,\n        uint256 _maxDebtRate,\n        uint256 _debtRateAgainstEthMarket,\n        uint256 _liquidationMultiplier\n    ) external onlyOwner {\n        isMainMarket = collateralId == penrose.mainAssetId();\n\n        if (!isMainMarket) {\n            _accrue();\n            if (_minDebtRate > 0) {\n                if (_minDebtRate >= maxDebtRate) revert DebtRatesNotValid();\n                emit MinDebtRateUpdated(minDebtRate, _minDebtRate);\n                minDebtRate = _minDebtRate;\n            }\n\n            if (_maxDebtRate > 0) {\n                if (_maxDebtRate <= minDebtRate) revert DebtRatesNotValid();\n                if (_maxDebtRate > 1e18) revert DebtRatesNotValid();\n                emit MaxDebtRateUpdated(maxDebtRate, _maxDebtRate);\n                maxDebtRate = _maxDebtRate;\n            }\n\n            if (_debtRateAgainstEthMarket > 0) {\n                emit DebtRateAgainstEthUpdated(debtRateAgainstEthMarket, _debtRateAgainstEthMarket);\n                debtRateAgainstEthMarket = _debtRateAgainstEthMarket;\n            }\n\n            if (_liquidationMultiplier > 0) {\n                if (_liquidationMultiplier >= FEE_PRECISION) revert NotValid();\n                emit LiquidationMultiplierUpdated(liquidationMultiplier, _liquidationMultiplier);\n                liquidationMultiplier = _liquidationMultiplier;\n            }\n        }\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _extractModule(Module _module) private view returns (address) {\n        address module;\n        if (_module == Module.Base) {\n            module = address(this);\n        } else if (_module == Module.Borrow) {\n            module = address(borrowModule);\n        } else if (_module == Module.Collateral) {\n            module = address(collateralModule);\n        } else if (_module == Module.Liquidation) {\n            module = address(liquidationModule);\n        } else if (_module == Module.Leverage) {\n            module = address(leverageModule);\n        }\n\n        if (module == address(0)) revert ModuleNotSet();\n\n        return module;\n    }\n\n    function _executeModule(Module _module, bytes memory _data) private returns (bytes memory returnData) {\n        bool success = true;\n\n        (success, returnData) = _extractModule(_module).delegatecall(_data);\n        if (!success) {\n            revert(abi.decode(_getRevertMsg(returnData), (string)));\n        }\n    }\n\n    receive() external payable {}\n}"
    }
  ]
}