{
  "Title": "M-1: In case of stock split and reverse split, the Dshare token holder will gain or loss his Dshare token value",
  "Content": "# Issue M-1: In case of stock split and reverse split, the Dshare token holder will gain or loss his Dshare token value \n\nSource: https://github.com/sherlock-audit/2023-06-dinari-judging/issues/29 \n\n## Found by \nast3ros\n## Summary\n\nStock split and reverse split may cause the token accounting to be inaccurate.\n\n## Vulnerability Detail\n\nStock split and reverse split are very common in the stock market. There are many examples here: https://companiesmarketcap.com/amazon/stock-splits/\n\nFor instance, in a 2-for-1 stock split, a shareholder receives an additional share for each share held. However, the DShare token holder still holds only one DShare token after the split. If a DShare token holder owns 100 DShare tokens before the split, he will still own 100 DShare tokens after the split. However, he should own 200 DShare tokens after the split.\n\nCurrently, users can buy 1 DShare token at the current market price of the underlying share. https://sbt.dinari.com/tokens\n\nThis means that after the stock split, a new Dshare token holder can buy a Dshare at half the price of the previous Dshare token holder. This is unfair to the previous Dshare token holder. In other words, the original Dshare token holder will lose 50% of his Dshare token value after the stock split.\n\nThe same logic applies to stock reverse split.\n\n## Impact\n\nThe Dshare token holder will gain or loss his Dshare token value after the stock split or reverse split.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-dinari/blob/50eb49260ab54e02748c2f6382fd95284d271f06/sbt-contracts/src/BridgedERC20.sol#L13\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe Operator should have a mechanism to mint or burn DShare tokens of holders when the underlying share is split or reverse split.\n\n\n\n## Discussion\n\n**jaketimothy**\n\nWhile this would be catastrophic if unaddressed, our current - admittedly undocumented - approach is to halt and cancel all orders for assets at the end of the day the split is announced. Then deploy a new token with a burn->mint migration contract at the appropriate split ratio, add the new token to the issuers, and re-enable orders with the new token.\n\nThis accounts for various scenarios where the original tokens may be locked in other contracts without Dinari having to push airdrop transactions for every split - or maintaining burn privileges on all owners/holders.\n\n**ctf-sec**\n\nThe amazon last stock split is 20 years ago. I think this report is out of scope\n\n> The Operator should have a mechanism to mint or burn DShare tokens of holders when the underlying share is split or reverse split.\n\nThe operator is a privileged central party that can do that.\n\n**Oot2k**\n\nI still think this issue is valid. \nStock splits happen fairly often, for example Tesla in 2020 and 2022.\nI think this is a valid medium, because the offchain system was not mentioned anywhere and there still can be issues when deploying a token manually.\nThere wont be direct loss of funds, but protocols that integrate with dinari will have problems (Dex, lending etc.)\n\n**ctf-sec**\n\nWhile the stock and offline logic is out of scope,\n\n> In 2-for-1 stock split, a shareholder receives an additional share for each share held\n\nIn the current implementation, this would require the admin [mint stock for user](https://github.com/sherlock-audit/2023-06-dinari/blob/50eb49260ab54e02748c2f6382fd95284d271f06/sbt-contracts/src/BridgedERC20.sol#L113)\n\nIn a stock reverse split,\n\nIn the current implementation, admin can't [burn stock for user](https://github.com/sherlock-audit/2023-06-dinari/blob/50eb49260ab54e02748c2f6382fd95284d271f06/sbt-contracts/src/BridgedERC20.sol#L120)\n\n```solidity\n  function burn(uint256 value) external virtual onlyRole(BURNER_ROLE) {\n        _burn(msg.sender, value);\n    }\n```\n\nif the implementation is \n\n```solidity\n  function burn(address from, uint256 value) external virtual onlyRole(BURNER_ROLE) {\n        _burn(from, value);\n    }\n```\n\nI would agree this is a low severity and out of scope finding,\n\nbut since the admin can't actually burn for user,\n\nthis can be valid medium, severity is definitely not high :)\n\n**thangtranth**\n\nEscalate\n\nI believe this issue is a high severity because:\n\n- Impact: As the sponsor mentioned, the impact is catastrophic if unaddressed. It breaks the invariant 1 share : 1 token of the protocol. Some token holders will unfairly lose/gain X times the value. In addition, protocols that integrate with Dinari will have problems. It is not considered an acceptable risk\n\n- Frequency: Stock splits and reverse splits are very common events. Because Dinari covers many publicly traded securities, not just one stock, the frequency of the events should be counted using the whole stock market, not frequency of one stock. There are events happening every month. https://www.marketbeat.com/stock-splits/history/\n\n- The mechanism that the sponsor mentioned was not available anywhere during the contest: from the contest README to the white paper. It is new information that came after the contest was finished.\n\n- As the lead Watson pointed out, even the workaround of owner minting and burning directly to users does not work, because the admin cannot burn other users’ tokens. And I don’t think using the mint and burn functions in the token contract and minting manually to each user is a good solution.\n\n**sherlock-admin**\n\n > Escalate\n> \n> I believe this issue is a high severity because:\n> \n> - Impact: As the sponsor mentioned, the impact is catastrophic if unaddressed. It breaks the invariant 1 share : 1 token of the protocol. Some token holders will unfairly lose/gain X times the value. In addition, protocols that integrate with Dinari will have problems. It is not considered an acceptable risk\n> \n> - Frequency: Stock splits and reverse splits are very common events. Because Dinari covers many publicly traded securities, not just one stock, the frequency of the events should be counted using the whole stock market, not frequency of one stock. There are events happening every month. https://www.marketbeat.com/stock-splits/history/\n> \n> - The mechanism that the sponsor mentioned was not available anywhere during the contest: from the contest README to the white paper. It is new information that came after the contest was finished.\n> \n> - As the lead Watson pointed out, even the workaround of owner minting and burning directly to users does not work, because the admin cannot burn other users’ tokens. And I don’t think using the mint and burn functions in the token contract and minting manually to each user is a good solution.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\n> Escalate\n> \n> I believe this issue is a high severity because:\n> \n> * Impact: As the sponsor mentioned, the impact is catastrophic if unaddressed. It breaks the invariant 1 share : 1 token of the protocol. Some token holders will unfairly lose/gain X times the value. In addition, protocols that integrate with Dinari will have problems. It is not considered an acceptable risk\n> * Frequency: Stock splits and reverse splits are very common events. Because Dinari covers many publicly traded securities, not just one stock, the frequency of the events should be counted using the whole stock market, not frequency of one stock. There are events happening every month. https://www.marketbeat.com/stock-splits/history/\n> * The mechanism that the sponsor mentioned was not available anywhere during the contest: from the contest README to the white paper. It is new information that came after the contest was finished.\n> * As the lead Watson pointed out, even the workaround of owner minting and burning directly to users does not work, because the admin cannot burn other users’ tokens. And I don’t think using the mint and burn functions in the token contract and minting manually to each user is a good solution.\n\nI find it difficult to think this is a high severity issue, stock just don't split every day. How does the sponsor handle the stock split is not in scope of auditing, severity at most medium if not out of scope, we could say, if the stock company rug and delisted, all dShare lose its value... this is expected, which is not in scope of the auditing as well\n\nhttps://docs.sherlock.xyz/audits/judging/judging\n\n> Medium: There is a viable scenario (even if unlikely) that could cause the protocol to enter a state where a material amount of funds can be lost. The attack path is possible with assumptions that either mimic on-chain conditions or reflect conditions that have a reasonable chance of becoming true in the future.\n\nand\n\n> As the lead Watson pointed out, even the workaround of owner minting and burning directly to users does not work, because the admin cannot burn other users’ tokens. And I don’t think using the mint and burn functions in the token contract and minting manually to each user is a good solution\n\nthere is no mention about this in the original report\n\nand\n\nI really feel like not dispute as low and out of scope and argue a medium is already what I can do the best for this report because this report does show creativity. \n\nhttps://www.marketplace.org/2022/02/11/whats-a-stock-split-anyway/\n\n![image](https://github.com/sherlock-audit/2023-06-dinari-judging/assets/114844362/f7cbfb19-457f-4dc4-93bb-162f71831e55)\n\n\n\n\n\n\n**ctf-sec**\n\nbtw the while the resolving the escalation is one story, the fix is another.\n\n@jaketimothy \n\nMaybe can use this\n\nhttps://docs.openzeppelin.com/contracts/3.x/api/token/erc20#ERC20Snapshot\n\nImplement as rebasing token to modify the ERC20 token balance can help as well!\n\nAgree this is not a easy fix.\n\n**jaketimothy**\n\nThank you for sharing @ctf-sec. I'm racking my brain trying to avoid rebasing token. \n\n**Oot2k**\n\nStocksplits are known well in advance, so trading can be haltet and shares converted. I still think all offchain fixes are not recommended which means this is a valid medium issue. \n\n**jaketimothy**\n\nFixed in \n- https://github.com/dinaricrypto/sbt-contracts/pull/135\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nGiven that this is an external condition that is well-known beforehand. This issue can be fairly considered a valid medium because the code cannot handle the stock-split situation and the off-chain/on-chain solutions were not previously present. \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [thangtranth](https://github.com/sherlock-audit/2023-06-dinari-judging/issues/29/#issuecomment-1630988049): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/98",
  "Code": [
    {
      "filename": "sbt-contracts/src/BridgedERC20.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\nimport {ERC20} from \"solady/src/tokens/ERC20.sol\";\nimport {AccessControlDefaultAdminRules} from\n    \"openzeppelin-contracts/contracts/access/AccessControlDefaultAdminRules.sol\";\nimport {ITransferRestrictor} from \"./ITransferRestrictor.sol\";\n\n/// @notice Core token contract for bridged assets.\n/// @author Dinari (https://github.com/dinaricrypto/sbt-contracts/blob/main/src/BridgedERC20.sol)\n/// ERC20 with minter, burner, and blacklist\n/// Uses solady ERC20 which allows EIP-2612 domain separator with `name` changes\ncontract BridgedERC20 is ERC20, AccessControlDefaultAdminRules {\n    /// ------------------ Events ------------------ ///\n\n    /// @dev Emitted when `name` is set\n    event NameSet(string name);\n    /// @dev Emitted when `symbol` is set\n    event SymbolSet(string symbol);\n    /// @dev Emitted when `disclosures` URI is set\n    event DisclosuresSet(string disclosures);\n    /// @dev Emitted when transfer restrictor contract is set\n    event TransferRestrictorSet(ITransferRestrictor indexed transferRestrictor);\n\n    /// ------------------ Constants ------------------ ///\n\n    /// @notice Role for approved minters\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    /// @notice Role for approved burners\n    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n\n    /// ------------------ State ------------------ ///\n\n    /// @dev Token name\n    string private _name;\n    /// @dev Token symbol\n    string private _symbol;\n\n    /// @notice URI to disclosure information\n    string public disclosures;\n    /// @notice Contract to restrict transfers\n    ITransferRestrictor public transferRestrictor;\n\n    /// ------------------ Initialization ------------------ ///\n\n    /// @notice Initialize token\n    /// @param owner Owner of contract\n    /// @param name_ Token name\n    /// @param symbol_ Token symbol\n    /// @param disclosures_ URI to disclosure information\n    /// @param transferRestrictor_ Contract to restrict transfers\n    constructor(\n        address owner,\n        string memory name_,\n        string memory symbol_,\n        string memory disclosures_,\n        ITransferRestrictor transferRestrictor_\n    ) AccessControlDefaultAdminRules(0, owner) {\n        _name = name_;\n        _symbol = symbol_;\n        disclosures = disclosures_;\n        transferRestrictor = transferRestrictor_;\n    }\n\n    /// ------------------ Getters ------------------ ///\n\n    /// @notice Returns the name of the token\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /// @notice Returns the symbol of the token\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /// ------------------ Setters ------------------ ///\n\n    /// @notice Set token name\n    /// @dev Only callable by owner\n    function setName(string calldata name_) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _name = name_;\n        emit NameSet(name_);\n    }\n\n    /// @notice Set token symbol\n    /// @dev Only callable by owner\n    function setSymbol(string calldata symbol_) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _symbol = symbol_;\n        emit SymbolSet(symbol_);\n    }\n\n    /// @notice Set disclosures URI\n    /// @dev Only callable by owner\n    function setDisclosures(string calldata disclosures_) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        disclosures = disclosures_;\n        emit DisclosuresSet(disclosures_);\n    }\n\n    /// @notice Set transfer restrictor contract\n    /// @dev Only callable by owner\n    function setTransferRestrictor(ITransferRestrictor restrictor) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        transferRestrictor = restrictor;\n        emit TransferRestrictorSet(restrictor);\n    }\n\n    /// ------------------ Minting and Burning ------------------ ///\n\n    /// @notice Mint tokens\n    /// @param to Address to mint tokens to\n    /// @param value Amount of tokens to mint\n    /// @dev Only callable by approved minter\n    function mint(address to, uint256 value) external virtual onlyRole(MINTER_ROLE) {\n        _mint(to, value);\n    }\n\n    /// @notice Burn tokens\n    /// @param value Amount of tokens to burn\n    /// @dev Only callable by approved burner\n    function burn(uint256 value) external virtual onlyRole(BURNER_ROLE) {\n        _burn(msg.sender, value);\n    }\n\n    /// ------------------ Transfers ------------------ ///\n\n    /// @inheritdoc ERC20\n    function _beforeTokenTransfer(address from, address to, uint256) internal virtual override {\n        // Restrictions ignored for minting and burning\n        // If transferRestrictor is not set, no restrictions are applied\n        if (from == address(0) || to == address(0) || address(transferRestrictor) == address(0)) {\n            return;\n        }\n\n        // Check transfer restrictions\n        transferRestrictor.requireNotRestricted(from, to);\n    }\n}"
    },
    {
      "filename": "sbt-contracts/src/BridgedERC20.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\nimport {ERC20} from \"solady/src/tokens/ERC20.sol\";\nimport {AccessControlDefaultAdminRules} from\n    \"openzeppelin-contracts/contracts/access/AccessControlDefaultAdminRules.sol\";\nimport {ITransferRestrictor} from \"./ITransferRestrictor.sol\";\n\n/// @notice Core token contract for bridged assets.\n/// @author Dinari (https://github.com/dinaricrypto/sbt-contracts/blob/main/src/BridgedERC20.sol)\n/// ERC20 with minter, burner, and blacklist\n/// Uses solady ERC20 which allows EIP-2612 domain separator with `name` changes\ncontract BridgedERC20 is ERC20, AccessControlDefaultAdminRules {\n    /// ------------------ Events ------------------ ///\n\n    /// @dev Emitted when `name` is set\n    event NameSet(string name);\n    /// @dev Emitted when `symbol` is set\n    event SymbolSet(string symbol);\n    /// @dev Emitted when `disclosures` URI is set\n    event DisclosuresSet(string disclosures);\n    /// @dev Emitted when transfer restrictor contract is set\n    event TransferRestrictorSet(ITransferRestrictor indexed transferRestrictor);\n\n    /// ------------------ Constants ------------------ ///\n\n    /// @notice Role for approved minters\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    /// @notice Role for approved burners\n    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n\n    /// ------------------ State ------------------ ///\n\n    /// @dev Token name\n    string private _name;\n    /// @dev Token symbol\n    string private _symbol;\n\n    /// @notice URI to disclosure information\n    string public disclosures;\n    /// @notice Contract to restrict transfers\n    ITransferRestrictor public transferRestrictor;\n\n    /// ------------------ Initialization ------------------ ///\n\n    /// @notice Initialize token\n    /// @param owner Owner of contract\n    /// @param name_ Token name\n    /// @param symbol_ Token symbol\n    /// @param disclosures_ URI to disclosure information\n    /// @param transferRestrictor_ Contract to restrict transfers\n    constructor(\n        address owner,\n        string memory name_,\n        string memory symbol_,\n        string memory disclosures_,\n        ITransferRestrictor transferRestrictor_\n    ) AccessControlDefaultAdminRules(0, owner) {\n        _name = name_;\n        _symbol = symbol_;\n        disclosures = disclosures_;\n        transferRestrictor = transferRestrictor_;\n    }\n\n    /// ------------------ Getters ------------------ ///\n\n    /// @notice Returns the name of the token\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /// @notice Returns the symbol of the token\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /// ------------------ Setters ------------------ ///\n\n    /// @notice Set token name\n    /// @dev Only callable by owner\n    function setName(string calldata name_) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _name = name_;\n        emit NameSet(name_);\n    }\n\n    /// @notice Set token symbol\n    /// @dev Only callable by owner\n    function setSymbol(string calldata symbol_) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _symbol = symbol_;\n        emit SymbolSet(symbol_);\n    }\n\n    /// @notice Set disclosures URI\n    /// @dev Only callable by owner\n    function setDisclosures(string calldata disclosures_) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        disclosures = disclosures_;\n        emit DisclosuresSet(disclosures_);\n    }\n\n    /// @notice Set transfer restrictor contract\n    /// @dev Only callable by owner\n    function setTransferRestrictor(ITransferRestrictor restrictor) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        transferRestrictor = restrictor;\n        emit TransferRestrictorSet(restrictor);\n    }\n\n    /// ------------------ Minting and Burning ------------------ ///\n\n    /// @notice Mint tokens\n    /// @param to Address to mint tokens to\n    /// @param value Amount of tokens to mint\n    /// @dev Only callable by approved minter\n    function mint(address to, uint256 value) external virtual onlyRole(MINTER_ROLE) {\n        _mint(to, value);\n    }\n\n    /// @notice Burn tokens\n    /// @param value Amount of tokens to burn\n    /// @dev Only callable by approved burner\n    function burn(uint256 value) external virtual onlyRole(BURNER_ROLE) {\n        _burn(msg.sender, value);\n    }\n\n    /// ------------------ Transfers ------------------ ///\n\n    /// @inheritdoc ERC20\n    function _beforeTokenTransfer(address from, address to, uint256) internal virtual override {\n        // Restrictions ignored for minting and burning\n        // If transferRestrictor is not set, no restrictions are applied\n        if (from == address(0) || to == address(0) || address(transferRestrictor) == address(0)) {\n            return;\n        }\n\n        // Check transfer restrictions\n        transferRestrictor.requireNotRestricted(from, to);\n    }\n}"
    },
    {
      "filename": "sbt-contracts/src/BridgedERC20.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\nimport {ERC20} from \"solady/src/tokens/ERC20.sol\";\nimport {AccessControlDefaultAdminRules} from\n    \"openzeppelin-contracts/contracts/access/AccessControlDefaultAdminRules.sol\";\nimport {ITransferRestrictor} from \"./ITransferRestrictor.sol\";\n\n/// @notice Core token contract for bridged assets.\n/// @author Dinari (https://github.com/dinaricrypto/sbt-contracts/blob/main/src/BridgedERC20.sol)\n/// ERC20 with minter, burner, and blacklist\n/// Uses solady ERC20 which allows EIP-2612 domain separator with `name` changes\ncontract BridgedERC20 is ERC20, AccessControlDefaultAdminRules {\n    /// ------------------ Events ------------------ ///\n\n    /// @dev Emitted when `name` is set\n    event NameSet(string name);\n    /// @dev Emitted when `symbol` is set\n    event SymbolSet(string symbol);\n    /// @dev Emitted when `disclosures` URI is set\n    event DisclosuresSet(string disclosures);\n    /// @dev Emitted when transfer restrictor contract is set\n    event TransferRestrictorSet(ITransferRestrictor indexed transferRestrictor);\n\n    /// ------------------ Constants ------------------ ///\n\n    /// @notice Role for approved minters\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    /// @notice Role for approved burners\n    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n\n    /// ------------------ State ------------------ ///\n\n    /// @dev Token name\n    string private _name;\n    /// @dev Token symbol\n    string private _symbol;\n\n    /// @notice URI to disclosure information\n    string public disclosures;\n    /// @notice Contract to restrict transfers\n    ITransferRestrictor public transferRestrictor;\n\n    /// ------------------ Initialization ------------------ ///\n\n    /// @notice Initialize token\n    /// @param owner Owner of contract\n    /// @param name_ Token name\n    /// @param symbol_ Token symbol\n    /// @param disclosures_ URI to disclosure information\n    /// @param transferRestrictor_ Contract to restrict transfers\n    constructor(\n        address owner,\n        string memory name_,\n        string memory symbol_,\n        string memory disclosures_,\n        ITransferRestrictor transferRestrictor_\n    ) AccessControlDefaultAdminRules(0, owner) {\n        _name = name_;\n        _symbol = symbol_;\n        disclosures = disclosures_;\n        transferRestrictor = transferRestrictor_;\n    }\n\n    /// ------------------ Getters ------------------ ///\n\n    /// @notice Returns the name of the token\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /// @notice Returns the symbol of the token\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /// ------------------ Setters ------------------ ///\n\n    /// @notice Set token name\n    /// @dev Only callable by owner\n    function setName(string calldata name_) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _name = name_;\n        emit NameSet(name_);\n    }\n\n    /// @notice Set token symbol\n    /// @dev Only callable by owner\n    function setSymbol(string calldata symbol_) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _symbol = symbol_;\n        emit SymbolSet(symbol_);\n    }\n\n    /// @notice Set disclosures URI\n    /// @dev Only callable by owner\n    function setDisclosures(string calldata disclosures_) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        disclosures = disclosures_;\n        emit DisclosuresSet(disclosures_);\n    }\n\n    /// @notice Set transfer restrictor contract\n    /// @dev Only callable by owner\n    function setTransferRestrictor(ITransferRestrictor restrictor) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        transferRestrictor = restrictor;\n        emit TransferRestrictorSet(restrictor);\n    }\n\n    /// ------------------ Minting and Burning ------------------ ///\n\n    /// @notice Mint tokens\n    /// @param to Address to mint tokens to\n    /// @param value Amount of tokens to mint\n    /// @dev Only callable by approved minter\n    function mint(address to, uint256 value) external virtual onlyRole(MINTER_ROLE) {\n        _mint(to, value);\n    }\n\n    /// @notice Burn tokens\n    /// @param value Amount of tokens to burn\n    /// @dev Only callable by approved burner\n    function burn(uint256 value) external virtual onlyRole(BURNER_ROLE) {\n        _burn(msg.sender, value);\n    }\n\n    /// ------------------ Transfers ------------------ ///\n\n    /// @inheritdoc ERC20\n    function _beforeTokenTransfer(address from, address to, uint256) internal virtual override {\n        // Restrictions ignored for minting and burning\n        // If transferRestrictor is not set, no restrictions are applied\n        if (from == address(0) || to == address(0) || address(transferRestrictor) == address(0)) {\n            return;\n        }\n\n        // Check transfer restrictions\n        transferRestrictor.requireNotRestricted(from, to);\n    }\n}"
    }
  ]
}