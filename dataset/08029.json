{
  "Title": "[H-06]  A majority attack can steal precious NFT from the party by crafting and chaining two proposals",
  "Content": "# Lines of code\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/proposals/ProposalExecutionEngine.sol#L116\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/proposals/FractionalizeProposal.sol#L54-L62\n\n\n# Vulnerability details\n\n## Description\nThe PartyGovernance system has many defenses in place to protect against a majority holder stealing the NFT. Majority cannot exfiltrate the ETH gained from selling precious NFT via any proposal, and it's impossible to sell NFT for any asset except ETH. If the party were to be compensated via an ERC20 token, majority could pass an ArbitraryCallsProposal to transfer these tokens to an attacker wallet. Unfortunately, FractionalizeProposal is vulnerable to this attack. Attacker/s could pass two proposals and wait for them to be ready for execution. Firstly, a FractionalizeProposal to fractionalize the NFT and mint totalVotingPower amount of ERC20 tokens of the created vault. Secondly, an ArbitraryCallsProposal to transfer the entire ERC20 token supply to an attacker address. At this point, attacker can call vault.redeem() to burn the outstanding token supply and receive the NFT back.\n\n## Impact\nA 51% majority could steal the precious NFT from the party and leave it empty.\n\n## Proof of Concept\nThe only non-trivial component of this attack is that the created vault, whose tokens we wish to transfer out, has an undetermined address until VAULT_FACTORY.mint() is called, which creates it. The opcode which creates the vault contract is CREATE, which calculates the address with ```keccak256(VAULT_FACTORY, nonce)```. Nonce will keep changing while new, unrelated NFTs are fractionalized. The attack needs to prepare both FractionalizedProposal and ArbitraryCallsProposal ahead of time, so that they could be chained immediately, meaning there would be no time for other members to call distribute() on the party, which would store the fractionalized tokens safely in the distributor.\nIn order to solve this chicken and the egg problem, we will use a technique taken from traditional low-level exploitation called heap feng shui. \n\nFirstly, calculate off-chain, the rate new NFTs are fractionalized, and multiple by a safety factor (like 1.2X), and multiply again by the proposal execution delay. This number, added to the current VAULT_FACTORY nonce, will be our target_nonce. Calculate ```target_vault = keccak256(VAULT_FACTORY, target_nonce)```, ```before_target_vault = keccak256(VAULT_FACTORY, target_nonce-1)```\n\nFirstly, we will create a contract which has an attack function that:\n1. Loop while before_target_vault != created_vault:\n\t• Mint new dummy attacker_NFT\n\t• created_vault = VAULT_FACTORY.mint(attacker_NFT…)\n2. Call execute() on the FractionalizedProposal  // We will feed the execute() parameters to the contract in a separate contract setter. Note that this is guaranteed to create target_vault on the correct address.\n3. Call execute() on the ArbitraryCallsProposal\n\nThen, we propose the two proposals:\n1. Propose a FractionalizedProposal, with any list price and the precious NFT as parameter\n2. Propose an ArbitraryCallsProposal, with target = target_vault, data = transfer(ATTACKER, totalVotingPower)\n\nThen, we set the execute() parameters passed in step 2 and 3 of the attack contract using the proposalID allocated for them. \n\nThen, we wait for execution delay to finish.\n\nFinally, run the attack() function prepared earlier. This will increment the VAULT_FACTORY nonce until it is the one we count on during the ArbitraryCallsProposal. Pass enough gas to be able to burn enough nonces.\n\nAt this point, attacker has all the vault tokens, so he may call vault.redeem() and receive the precious NFT.\n\n## Tools Used\nManual audit.\n\n## Recommended Mitigation Steps\n1. Enforce a minimum cooldown between proposals. This will mitigate additional weaknesses of the proposal structure. Here, this will give users the opportunity to call distribute() to put the vault tokens safe in distributor.\n2. A specific fix here would be to call distribute() at the end of FractionalizeProposal so that there is no window to steal the funds.\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-09-partydao-contest",
  "Code": [
    {
      "filename": "contracts/proposals/ProposalExecutionEngine.sol",
      "content": "// SPDX-License-Identifier: Beta Software\npragma solidity ^0.8;\n\nimport \"../utils/Implementation.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../globals/IGlobals.sol\";\n\nimport \"./IProposalExecutionEngine.sol\";\nimport \"./ListOnOpenseaProposal.sol\";\nimport \"./ListOnZoraProposal.sol\";\nimport \"./FractionalizeProposal.sol\";\nimport \"./ArbitraryCallsProposal.sol\";\nimport \"./LibProposal.sol\";\nimport \"./ProposalStorage.sol\";\n\n/// @notice Upgradable implementation of proposal execution logic for parties that use it.\n/// @dev This contract will be delegatecall'ed into by `Party` proxy instances.\ncontract ProposalExecutionEngine is\n    IProposalExecutionEngine,\n    Implementation,\n    ProposalStorage,\n    ListOnOpenseaProposal,\n    ListOnZoraProposal,\n    FractionalizeProposal,\n    ArbitraryCallsProposal\n{\n    using LibRawResult for bytes;\n\n    error UnsupportedProposalTypeError(uint32 proposalType);\n\n    // The types of proposals supported.\n    // The first 4 bytes of a proposal's `proposalData` determine the proposal\n    // type.\n    // WARNING: This should be append-only.\n    enum ProposalType {\n        Invalid,\n        ListOnOpensea,\n        ListOnZora,\n        Fractionalize,\n        ArbitraryCalls,\n        UpgradeProposalEngineImpl,\n        // Append new proposal types here.\n        NumProposalTypes\n    }\n\n    // Explicit storage bucket for \"private\" state owned by the `ProposalExecutionEngine`.\n    // See `_getStorage()` for how this is addressed.\n    //\n    // Read this for more context on the pattern motivating this:\n    // https://github.com/dragonfly-xyz/useful-solidity-patterns/tree/main/patterns/explicit-storage-buckets\n    struct Storage {\n        // The hash of the next `progressData` for the current `InProgress`\n        // proposal. This is updated to the hash of the next `progressData` every\n        // time a proposal is executed. This enforces that the next call to\n        // `executeProposal()` receives the correct `progressData`.\n        // If there is no current `InProgress` proposal, this will be 0x0.\n        bytes32 nextProgressDataHash;\n        // The proposal ID of the current, in progress proposal being executed.\n        // `InProgress` proposals need to have `executeProposal()` called on them\n        // multiple times until they complete. Only one proposal may be\n        // in progress at a time, meaning no other proposals can be executed\n        // if this value is nonzero.\n        uint256 currentInProgressProposalId;\n    }\n\n    event ProposalEngineImplementationUpgraded(address oldImpl, address newImpl);\n\n    error ZeroProposalIdError();\n    error MalformedProposalDataError();\n    error ProposalExecutionBlockedError(uint256 proposalId, uint256 currentInProgressProposalId);\n    error ProposalProgressDataInvalidError(bytes32 actualProgressDataHash, bytes32 expectedProgressDataHash);\n    error ProposalNotInProgressError(uint256 proposalId);\n    error UnexpectedProposalEngineImplementationError(IProposalExecutionEngine actualImpl, IProposalExecutionEngine expectedImpl);\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and it’s address will never change.\n    IGlobals private immutable _GLOBALS;\n    // Storage slot for `Storage`.\n    // Use a constant, non-overlapping slot offset for the storage bucket.\n    uint256 private constant _STORAGE_SLOT = uint256(keccak256('ProposalExecutionEngine.Storage'));\n\n    // Set immutables.\n    constructor(\n        IGlobals globals,\n        IOpenseaExchange seaport,\n        IOpenseaConduitController seaportConduitController,\n        IZoraAuctionHouse zoraAuctionHouse,\n        IFractionalV1VaultFactory fractionalVaultFactory\n    )\n        ListOnOpenseaProposal(globals, seaport, seaportConduitController)\n        ListOnZoraProposal(globals, zoraAuctionHouse)\n        FractionalizeProposal(fractionalVaultFactory)\n    {\n        _GLOBALS = globals;\n    }\n\n    // Used by `Party` to setup the execution engine.\n    // Currently does nothing, but may be changed in future versions.\n    function initialize(address oldImpl, bytes calldata initializeData)\n        external\n        override\n        onlyDelegateCall\n    { /* NOOP */ }\n\n    /// @notice Get the current `InProgress` proposal ID.\n    /// @dev With this version, only one proposal may be in progress at a time.\n    function getCurrentInProgressProposalId()\n        external\n        view\n        returns (uint256 id)\n    {\n        return _getStorage().currentInProgressProposalId;\n    }\n\n    /// @inheritdoc IProposalExecutionEngine\n    function executeProposal(ExecuteProposalParams memory params)\n        external\n        onlyDelegateCall\n        returns (bytes memory nextProgressData)\n    {\n        // Must have a valid proposal ID.\n        if (params.proposalId == 0) {\n            revert ZeroProposalIdError();\n        }\n        Storage storage stor = _getStorage();\n        uint256 currentInProgressProposalId = stor.currentInProgressProposalId;\n        if (currentInProgressProposalId == 0) {\n            // No proposal is currently in progress.\n            // Mark this proposal as the one in progress.\n            stor.currentInProgressProposalId = params.proposalId;\n        } else if (currentInProgressProposalId != params.proposalId) {\n            // Only one proposal can be in progress at a time.\n            revert ProposalExecutionBlockedError(\n                params.proposalId,\n                currentInProgressProposalId\n            );\n        }\n        {\n            bytes32 nextProgressDataHash = stor.nextProgressDataHash;\n            if (nextProgressDataHash == 0) { // Expecting no progress data.\n                // This is the state if there is no current `InProgress` proposal.\n                assert(currentInProgressProposalId == 0);\n                if (params.progressData.length != 0) {\n                    revert ProposalProgressDataInvalidError(\n                        keccak256(params.progressData),\n                        nextProgressDataHash\n                    );\n                }\n            } else { // Expecting progress data.\n                bytes32 progressDataHash = keccak256(params.progressData);\n                // Progress data must match the one stored.\n                if (nextProgressDataHash != progressDataHash) {\n                    revert ProposalProgressDataInvalidError(\n                        progressDataHash,\n                        nextProgressDataHash\n                    );\n                }\n            }\n            // Temporarily set the expected next progress data hash to an\n            // unachievable constant to act as a reentrancy guard.\n            stor.nextProgressDataHash = bytes32(type(uint256).max);\n        }\n\n        // Note that we do not enforce that the proposal has not been executed\n        // (and completed) before in this contract. That is enforced by PartyGovernance.\n\n        // Execute the proposal.\n        ProposalType pt;\n        (pt, params.proposalData) = _extractProposalType(params.proposalData);\n        nextProgressData = _execute(pt, params);\n\n        // If progress data is empty, the proposal is complete.\n        if (nextProgressData.length == 0) {\n            stor.currentInProgressProposalId = 0;\n            stor.nextProgressDataHash = 0;\n        } else {\n            // Remember the next progress data.\n            stor.nextProgressDataHash = keccak256(nextProgressData);\n        }\n    }\n\n    /// @inheritdoc IProposalExecutionEngine\n    function cancelProposal(uint256 proposalId)\n        external\n        onlyDelegateCall\n    {\n        // Must be a valid proposal ID.\n        if (proposalId == 0) {\n            revert ZeroProposalIdError();\n        }\n        Storage storage stor = _getStorage();\n        {\n            // Must be the current InProgress proposal.\n            uint256 currentInProgressProposalId = stor.currentInProgressProposalId;\n            if (currentInProgressProposalId != proposalId) {\n                revert ProposalNotInProgressError(proposalId);\n            }\n        }\n        // Clear the current InProgress proposal ID and next progress data.\n        stor.currentInProgressProposalId = 0;\n        stor.nextProgressDataHash = 0;\n    }\n\n    // Switch statement used to execute the right proposal.\n    function _execute(ProposalType pt, ExecuteProposalParams memory params)\n        internal\n        virtual\n        returns (bytes memory nextProgressData)\n    {\n        if (pt == ProposalType.ListOnOpensea) {\n            nextProgressData = _executeListOnOpensea(params);\n        } else if (pt == ProposalType.ListOnZora) {\n            nextProgressData = _executeListOnZora(params);\n        } else if (pt == ProposalType.Fractionalize) {\n            nextProgressData = _executeFractionalize(params);\n        } else if (pt == ProposalType.ArbitraryCalls) {\n            nextProgressData = _executeArbitraryCalls(params);\n        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {\n            _executeUpgradeProposalsImplementation(params.proposalData);\n        } else {\n            revert UnsupportedProposalTypeError(uint32(pt));\n        }\n    }\n\n    // Destructively pops off the first 4 bytes of `proposalData` to determine\n    // the type. This modifies `proposalData` and returns the updated\n    // pointer to it.\n    function _extractProposalType(bytes memory proposalData)\n        private\n        pure\n        returns (ProposalType proposalType, bytes memory offsetProposalData)\n    {\n        // First 4 bytes is proposal type. While the proposal type could be\n        // stored in just 1 byte, this makes it easier to encode with\n        // `abi.encodeWithSelector`.\n        if (proposalData.length < 4) {\n            revert MalformedProposalDataError();\n        }\n        assembly {\n            // By reading 4 bytes into the length prefix, the leading 4 bytes\n            // of the data will be in the lower bits of the read word.\n            proposalType := and(mload(add(proposalData, 4)), 0xffffffff)\n            mstore(add(proposalData, 4), sub(mload(proposalData), 4))\n            offsetProposalData := add(proposalData, 4)\n        }\n        require(proposalType != ProposalType.Invalid);\n        require(uint8(proposalType) < uint8(ProposalType.NumProposalTypes));\n    }\n\n    // Upgrade implementation to the latest version.\n    function _executeUpgradeProposalsImplementation(bytes memory proposalData)\n        private\n    {\n        (address expectedImpl, bytes memory initData) =\n            abi.decode(proposalData, (address, bytes));\n        // Always upgrade to latest implementation stored in `_GLOBALS`.\n        IProposalExecutionEngine newImpl = IProposalExecutionEngine(\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)\n        );\n        if (expectedImpl != address(newImpl)) {\n            revert UnexpectedProposalEngineImplementationError(\n                newImpl,\n                IProposalExecutionEngine(expectedImpl)\n            );\n        }\n        _initProposalImpl(newImpl, initData);\n        emit ProposalEngineImplementationUpgraded(address(IMPL), expectedImpl);\n    }\n\n    // Retrieve the explicit storage bucket for the ProposalExecutionEngine logic.\n    function _getStorage() internal pure returns (Storage storage stor) {\n        uint256 slot = _STORAGE_SLOT;\n        assembly { stor.slot := slot }\n    }\n}"
    },
    {
      "filename": "contracts/proposals/FractionalizeProposal.sol",
      "content": "// SPDX-License-Identifier: Beta Software\npragma solidity ^0.8;\n\nimport \"../tokens/IERC721.sol\";\nimport \"../party/PartyGovernance.sol\";\n\nimport \"./IProposalExecutionEngine.sol\";\nimport \"./vendor/FractionalV1.sol\";\n\n// Implements fractionalizing an NFT to ERC20s on Fractional V1. Inherited by the `ProposalExecutionEngine`.\n// This contract will be delegatecall'ed into by `Party` proxy instances.\ncontract FractionalizeProposal {\n    struct FractionalizeProposalData {\n        // The ERC721 token contract to fractionalize.\n        IERC721 token;\n        // The ERC721 token ID to fractionalize.\n        uint256 tokenId;\n        // The starting list price for the fractional vault.\n        uint256 listPrice;\n    }\n\n    event FractionalV1VaultCreated(\n        IERC721 indexed token,\n        uint256 indexed tokenId,\n        uint256 vaultId,\n        IERC20 vault,\n        uint256 listPrice\n    );\n\n    /// @notice Deployment of https://github.com/fractional-company/contracts/blob/master/src/ERC721TokenVault.sol.\n    IFractionalV1VaultFactory public immutable VAULT_FACTORY;\n\n    // Set the `VAULT_FACTORY`.\n    constructor(IFractionalV1VaultFactory vaultFactory) {\n        VAULT_FACTORY = vaultFactory;\n    }\n\n    // Fractionalize an NFT held by this party on Fractional V1.\n    function _executeFractionalize(\n        IProposalExecutionEngine.ExecuteProposalParams memory params\n    )\n        internal\n        returns (bytes memory nextProgressData)\n    {\n        // Decode the proposal data.\n        FractionalizeProposalData memory data =\n            abi.decode(params.proposalData, (FractionalizeProposalData));\n        // The supply of fractional vault ERC20 tokens will be equal to the total\n        // voting power of the party.\n        uint256 supply =\n            PartyGovernance(address(this)).getGovernanceValues().totalVotingPower;\n        // Create a vault around the NFT.\n        data.token.approve(address(VAULT_FACTORY), data.tokenId);\n        uint256 vaultId = VAULT_FACTORY.mint(\n            IERC721(address(this)).name(),\n            IERC721(address(this)).symbol(),\n            data.token,\n            data.tokenId,\n            supply,\n            data.listPrice,\n            0\n        );\n        // Get the vault we just created.\n        IFractionalV1Vault vault = VAULT_FACTORY.vaults(vaultId);\n        // Check that we now hold the correct amount of fractional tokens.\n        // Should always succeed.\n        assert(vault.balanceOf(address(this)) == supply);\n        // Remove ourselves as curator.\n        vault.updateCurator(address(0));\n        emit FractionalV1VaultCreated(\n            data.token,\n            data.tokenId,\n            vaultId,\n            vault,\n            data.listPrice\n        );\n        // Nothing left to do.\n        return \"\";\n    }\n}"
    }
  ]
}