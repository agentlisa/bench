{
  "Title": "[L-07] `abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()`",
  "Content": "\nUse `abi.encode()` instead which will pad items to 32 bytes, which will [prevent hash collisions](https://docs.soliditylang.org/en/v0.8.13/abi-spec.html#non-standard-packed-mode) (e.g. `abi.encodePacked(0x123,0x456)` => `0x123456` => `abi.encodePacked(0x1,0x23456)`, but `abi.encode(0x123,0x456)` => `0x0...1230...456`). \"Unless there is a compelling reason, `abi.encode` should be preferred\". If there is only one argument to `abi.encodePacked()` it can often be cast to `bytes()` or `bytes32()` [instead](https://ethereum.stackexchange.com/questions/30912/how-to-compare-strings-in-solidity#answer-82739).\n\n```solidity\nFile: contracts/actions/topup/handlers/CTokenRegistry.sol   #1\n\n67                 keccak256(abi.encodePacked(ctoken.symbol())) == keccak256(abi.encodePacked(\"cETH\"))\n```\n\n<https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CTokenRegistry.sol#L67>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-04-backd-contest",
  "Code": [
    {
      "filename": "backd/contracts/actions/topup/handlers/CTokenRegistry.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"../../../../interfaces/vendor/CToken.sol\";\nimport \"../../../../interfaces/vendor/Comptroller.sol\";\nimport \"../../../../libraries/Errors.sol\";\n\ncontract CTokenRegistry {\n    Comptroller public immutable comptroller;\n\n    address public constant COMPTROLLER_MAINNET_ADDRESS =\n        address(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);\n\n    mapping(address => address) internal _underlyingToCToken;\n\n    constructor(address comptrollerAddress) {\n        comptroller = Comptroller(comptrollerAddress);\n        _updateCTokenMapping();\n    }\n\n    /**\n     * @notice Tries to read the CToken contract address for a given underlying token address\n     * If not found, tries to fetch it from the Comptroller contract and fails if\n     * cannot find it in the comptroller either\n     */\n    function fetchCToken(address underlying) external returns (CToken) {\n        CToken ctoken = getCToken(underlying, false);\n        if (address(ctoken) != address(0)) {\n            return CToken(ctoken);\n        }\n\n        _updateCTokenMapping();\n        return getCToken(underlying, true);\n    }\n\n    /**\n     * @notice Reads the CToken contract address for a given underlying token address\n     * or fails if not found\n     */\n    function getCToken(address underlying) external view returns (CToken) {\n        return getCToken(underlying, true);\n    }\n\n    /**\n     * @notice Reads the CToken contract address for a given underlying token address\n     * If `ensureExists` is `true`, fails if not found, otherwise returns address 0\n     */\n    function getCToken(address underlying, bool ensureExists) public view returns (CToken) {\n        CToken ctoken = CToken(_underlyingToCToken[underlying]);\n        if (ensureExists && (address(ctoken) == address(0) || !_isCTokenUsable(ctoken))) {\n            revert(Error.UNDERLYING_NOT_SUPPORTED);\n        }\n        return ctoken;\n    }\n\n    /**\n     * @dev Updates the CToken mapping by fetching information from the Comptroller contract\n     */\n    function _updateCTokenMapping() internal {\n        CToken[] memory ctokens = comptroller.getAllMarkets();\n        for (uint256 i = 0; i < ctokens.length; i++) {\n            CToken ctoken = ctokens[i];\n            if (!_isCTokenUsable(ctoken)) {\n                continue;\n            }\n            if (\n                keccak256(abi.encodePacked(ctoken.symbol())) == keccak256(abi.encodePacked(\"cETH\"))\n            ) {\n                _underlyingToCToken[address(0)] = address(ctoken);\n            } else {\n                _underlyingToCToken[ctoken.underlying()] = address(ctoken);\n            }\n        }\n    }\n\n    function _isCTokenUsable(CToken ctoken) internal view returns (bool) {\n        (bool listed, , ) = comptroller.markets(address(ctoken));\n        // NOTE: comptroller.isDeprecated is not available on Kovan\n        bool deprecated = address(comptroller) == COMPTROLLER_MAINNET_ADDRESS &&\n            comptroller.isDeprecated(ctoken);\n        return listed && !deprecated;\n    }\n}"
    }
  ]
}