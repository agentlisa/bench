{
  "Title": "[H05] AAVE inconsistency",
  "Content": "The `AaveStrategy` contract uses the [version 2 interface](https://docs.aave.com/developers/v/2.0/) in anticipation of a future reconfiguration of the investment strategies. However, we identified two inconsistencies:\n\n\n* the strategy [attempts to grant an allowance](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/strategies/AaveStrategy.sol#L186) to the non-existent Lending Pool Core, instead of the Lending Pool, which would make the strategy unusable and prevent OUSD token mints whenever the strategy is in use.\n* the strategy uses the [outdated `redeem` function](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/strategies/AaveStrategy.sol#L129) in the `withdrawAll` function, which is called when [the strategy is removed](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/vault/VaultAdmin.sol#L189).\n\n\nWhen this was raised with the Origin team they indicated that they had already identified and addressed the first inconsistency in a subsequent commit. Consider using the new interface when withdrawing all tokens.\n\n\n**Update:** *Fixed in [commit 650913e](https://github.com/OriginProtocol/origin-dollar/commit/650913e027900a3ecbb85c14ac269b043c2a7239).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/contracts/strategies/AaveStrategy.sol",
      "content": "pragma solidity 0.5.11;\n\n/**\n * @title OUSD Aave Strategy\n * @notice Investment strategy for investing stablecoins via Aave\n * @author Origin Protocol Inc\n */\nimport \"./IAave.sol\";\nimport {\n    IERC20,\n    InitializableAbstractStrategy\n} from \"../utils/InitializableAbstractStrategy.sol\";\n\nimport { IAaveStakedToken } from \"./IAaveStakeToken.sol\";\nimport { IAaveIncentivesController } from \"./IAaveIncentivesController.sol\";\n\ncontract AaveStrategy is InitializableAbstractStrategy {\n    uint16 constant referralCode = 92;\n\n    IAaveIncentivesController incentivesController;\n    IAaveStakedToken stkAave;\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as AAVE needs several extra\n     * addresses for the rewards program.\n     * @param _platformAddress Address of the AAVE pool\n     * @param _vaultAddress Address of the vault\n     * @param _rewardTokenAddress Address of the AAVE token\n     * @param _assets Addresses of supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     * @param _incentivesAddress Address of the AAVE incentives controller\n     * @param _stkAaveAddress Address of the stkAave contract\n     */\n    function initialize(\n        address _platformAddress, // AAVE pool\n        address _vaultAddress,\n        address _rewardTokenAddress, // AAVE\n        address[] calldata _assets,\n        address[] calldata _pTokens,\n        address _incentivesAddress,\n        address _stkAaveAddress\n    ) external onlyGovernor initializer {\n        incentivesController = IAaveIncentivesController(_incentivesAddress);\n        stkAave = IAaveStakedToken(_stkAaveAddress);\n        InitializableAbstractStrategy._initialize(\n            _platformAddress,\n            _vaultAddress,\n            _rewardTokenAddress,\n            _assets,\n            _pTokens\n        );\n    }\n\n    /**\n     * @dev Deposit asset into Aave\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     * @return amountDeposited Amount of asset that was deposited\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @dev Deposit asset into Aave\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     * @return amountDeposited Amount of asset that was deposited\n     */\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_amount > 0, \"Must deposit something\");\n        IAaveAToken aToken = _getATokenFor(_asset);\n        emit Deposit(_asset, address(aToken), _amount);\n        _getLendingPool().deposit(_asset, _amount, address(this), referralCode);\n    }\n\n    /**\n     * @dev Deposit the entire balance of any supported asset into Aave\n     */\n    function depositAll() external onlyVault nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            uint256 balance = IERC20(assetsMapped[i]).balanceOf(address(this));\n            if (balance > 0) {\n                _deposit(assetsMapped[i], balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Withdraw asset from Aave\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     * @return amountWithdrawn Amount of asset that was withdrawn\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external onlyVault nonReentrant {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n\n        IAaveAToken aToken = _getATokenFor(_asset);\n        emit Withdrawal(_asset, address(aToken), _amount);\n        uint256 actual = _getLendingPool().withdraw(\n            _asset,\n            _amount,\n            address(this)\n        );\n        require(actual >= _amount, \"Did not withdraw enough\");\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll() external onlyVaultOrGovernor nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            // Redeem entire balance of aToken\n            IAaveAToken aToken = _getATokenFor(assetsMapped[i]);\n            uint256 balance = aToken.balanceOf(address(this));\n            if (balance > 0) {\n                aToken.redeem(balance);\n                // Transfer entire balance to Vault\n                IERC20 asset = IERC20(assetsMapped[i]);\n                asset.safeTransfer(\n                    vaultAddress,\n                    asset.balanceOf(address(this))\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        returns (uint256 balance)\n    {\n        // Balance is always with token aToken decimals\n        IAaveAToken aToken = _getATokenFor(_asset);\n        balance = aToken.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) external view returns (bool) {\n        return assetToPToken[_asset] != address(0);\n    }\n\n    /**\n     * @dev Approve the spending of all assets by their corresponding aToken,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens() external onlyGovernor nonReentrant {\n        uint256 assetCount = assetsMapped.length;\n        address lendingPoolVault = _getLendingPoolCore();\n        // approve the pool to spend the bAsset\n        for (uint256 i = 0; i < assetCount; i++) {\n            address asset = assetsMapped[i];\n            // Safe approval\n            IERC20(asset).safeApprove(lendingPoolVault, 0);\n            IERC20(asset).safeApprove(lendingPoolVault, uint256(-1));\n        }\n    }\n\n    /**\n     * @dev Internal method to respond to the addition of new asset / aTokens\n     *      We need to approve the aToken and give it permission to spend the asset\n     * @param _asset Address of the asset to approve\n     * @param _aToken This aToken has the approval approval\n     */\n    function _abstractSetPToken(address _asset, address _aToken) internal {\n        address lendingPoolVault = _getLendingPoolCore();\n        IERC20(_asset).safeApprove(lendingPoolVault, 0);\n        IERC20(_asset).safeApprove(lendingPoolVault, uint256(-1));\n    }\n\n    /**\n     * @dev Get the aToken wrapped in the ICERC20 interface for this asset.\n     *      Fails if the pToken doesn't exist in our mappings.\n     * @param _asset Address of the asset\n     * @return Corresponding aToken to this asset\n     */\n    function _getATokenFor(address _asset) internal view returns (IAaveAToken) {\n        address aToken = assetToPToken[_asset];\n        require(aToken != address(0), \"aToken does not exist\");\n        return IAaveAToken(aToken);\n    }\n\n    /**\n     * @dev Get the current address of the Aave lending pool, which is the gateway to\n     *      depositing.\n     * @return Current lending pool implementation\n     */\n    function _getLendingPool() internal view returns (IAaveLendingPool) {\n        address lendingPool = ILendingPoolAddressesProvider(platformAddress)\n            .getLendingPool();\n        require(lendingPool != address(0), \"Lending pool does not exist\");\n        return IAaveLendingPool(lendingPool);\n    }\n\n    /**\n     * @dev Get the current address of the Aave lending pool core, which stores all the\n     *      reserve tokens in its vault.\n     * @return Current lending pool core address\n     */\n    function _getLendingPoolCore() internal view returns (address payable) {\n        address payable lendingPoolCore = ILendingPoolAddressesProvider(\n            platformAddress\n        )\n            .getLendingPoolCore();\n        require(\n            lendingPoolCore != address(uint160(address(0))),\n            \"Lending pool core does not exist\"\n        );\n        return lendingPoolCore;\n    }\n\n    /**\n     * @dev Collect stkAave, convert it to AAVE send to Vault.\n     */\n    function collectRewardToken() external onlyVault nonReentrant {\n        if (address(stkAave) == address(0)) {\n            return;\n        }\n\n        // Check staked AAVE cooldown timer\n        uint256 cooldown = stkAave.stakersCooldowns(address(this));\n        uint256 windowStart = cooldown + stkAave.COOLDOWN_SECONDS();\n        uint256 windowEnd = windowStart + stkAave.UNSTAKE_WINDOW();\n        uint256 currentTimestamp = now;\n\n        // If inside the unlock window, then we can redeem stkAave\n        // for AAVE and send it to the vault.\n        if (currentTimestamp > windowStart && currentTimestamp < windowEnd) {\n            // Redeem to AAVE\n            uint256 stkAaveBalance = stkAave.balanceOf(address(this));\n            if (stkAaveBalance > rewardLiquidationThreshold) {\n                stkAave.redeem(address(this), stkAaveBalance);\n            }\n            // Transfer AAVE to vaultAddress\n            uint256 aaveBalance = IERC20(rewardTokenAddress).balanceOf(\n                address(this)\n            );\n            if (aaveBalance > 0) {\n                IERC20(rewardTokenAddress).safeTransfer(\n                    vaultAddress,\n                    aaveBalance\n                );\n            }\n        }\n\n        // If we were past the start of the window,\n        // or if the cooldown counter is not running,\n        // then start the unlock cooldown.\n        if (currentTimestamp > windowStart || cooldown == 0) {\n            uint256 pendingRewards = incentivesController.getRewardsBalance(\n                assetsMapped,\n                address(this)\n            );\n            if (pendingRewards > 0) {\n                // claimRewards() may pause or push the cooldown time\n                // into the future. It needs to be run after any rewards would be\n                // collected, but before the cooldown is restarted.\n                uint256 collected = incentivesController.claimRewards(\n                    assetsMapped,\n                    pendingRewards,\n                    address(this)\n                );\n                require(collected == pendingRewards, \"AAVE reward difference\");\n            }\n            // Cooldown call reverts if no stkAave balance\n            if (stkAave.balanceOf(address(this)) > 0) {\n                stkAave.cooldown();\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/contracts/strategies/AaveStrategy.sol",
      "content": "pragma solidity 0.5.11;\n\n/**\n * @title OUSD Aave Strategy\n * @notice Investment strategy for investing stablecoins via Aave\n * @author Origin Protocol Inc\n */\nimport \"./IAave.sol\";\nimport {\n    IERC20,\n    InitializableAbstractStrategy\n} from \"../utils/InitializableAbstractStrategy.sol\";\n\nimport { IAaveStakedToken } from \"./IAaveStakeToken.sol\";\nimport { IAaveIncentivesController } from \"./IAaveIncentivesController.sol\";\n\ncontract AaveStrategy is InitializableAbstractStrategy {\n    uint16 constant referralCode = 92;\n\n    IAaveIncentivesController incentivesController;\n    IAaveStakedToken stkAave;\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as AAVE needs several extra\n     * addresses for the rewards program.\n     * @param _platformAddress Address of the AAVE pool\n     * @param _vaultAddress Address of the vault\n     * @param _rewardTokenAddress Address of the AAVE token\n     * @param _assets Addresses of supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     * @param _incentivesAddress Address of the AAVE incentives controller\n     * @param _stkAaveAddress Address of the stkAave contract\n     */\n    function initialize(\n        address _platformAddress, // AAVE pool\n        address _vaultAddress,\n        address _rewardTokenAddress, // AAVE\n        address[] calldata _assets,\n        address[] calldata _pTokens,\n        address _incentivesAddress,\n        address _stkAaveAddress\n    ) external onlyGovernor initializer {\n        incentivesController = IAaveIncentivesController(_incentivesAddress);\n        stkAave = IAaveStakedToken(_stkAaveAddress);\n        InitializableAbstractStrategy._initialize(\n            _platformAddress,\n            _vaultAddress,\n            _rewardTokenAddress,\n            _assets,\n            _pTokens\n        );\n    }\n\n    /**\n     * @dev Deposit asset into Aave\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     * @return amountDeposited Amount of asset that was deposited\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @dev Deposit asset into Aave\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     * @return amountDeposited Amount of asset that was deposited\n     */\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_amount > 0, \"Must deposit something\");\n        IAaveAToken aToken = _getATokenFor(_asset);\n        emit Deposit(_asset, address(aToken), _amount);\n        _getLendingPool().deposit(_asset, _amount, address(this), referralCode);\n    }\n\n    /**\n     * @dev Deposit the entire balance of any supported asset into Aave\n     */\n    function depositAll() external onlyVault nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            uint256 balance = IERC20(assetsMapped[i]).balanceOf(address(this));\n            if (balance > 0) {\n                _deposit(assetsMapped[i], balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Withdraw asset from Aave\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     * @return amountWithdrawn Amount of asset that was withdrawn\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external onlyVault nonReentrant {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n\n        IAaveAToken aToken = _getATokenFor(_asset);\n        emit Withdrawal(_asset, address(aToken), _amount);\n        uint256 actual = _getLendingPool().withdraw(\n            _asset,\n            _amount,\n            address(this)\n        );\n        require(actual >= _amount, \"Did not withdraw enough\");\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll() external onlyVaultOrGovernor nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            // Redeem entire balance of aToken\n            IAaveAToken aToken = _getATokenFor(assetsMapped[i]);\n            uint256 balance = aToken.balanceOf(address(this));\n            if (balance > 0) {\n                aToken.redeem(balance);\n                // Transfer entire balance to Vault\n                IERC20 asset = IERC20(assetsMapped[i]);\n                asset.safeTransfer(\n                    vaultAddress,\n                    asset.balanceOf(address(this))\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        returns (uint256 balance)\n    {\n        // Balance is always with token aToken decimals\n        IAaveAToken aToken = _getATokenFor(_asset);\n        balance = aToken.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) external view returns (bool) {\n        return assetToPToken[_asset] != address(0);\n    }\n\n    /**\n     * @dev Approve the spending of all assets by their corresponding aToken,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens() external onlyGovernor nonReentrant {\n        uint256 assetCount = assetsMapped.length;\n        address lendingPoolVault = _getLendingPoolCore();\n        // approve the pool to spend the bAsset\n        for (uint256 i = 0; i < assetCount; i++) {\n            address asset = assetsMapped[i];\n            // Safe approval\n            IERC20(asset).safeApprove(lendingPoolVault, 0);\n            IERC20(asset).safeApprove(lendingPoolVault, uint256(-1));\n        }\n    }\n\n    /**\n     * @dev Internal method to respond to the addition of new asset / aTokens\n     *      We need to approve the aToken and give it permission to spend the asset\n     * @param _asset Address of the asset to approve\n     * @param _aToken This aToken has the approval approval\n     */\n    function _abstractSetPToken(address _asset, address _aToken) internal {\n        address lendingPoolVault = _getLendingPoolCore();\n        IERC20(_asset).safeApprove(lendingPoolVault, 0);\n        IERC20(_asset).safeApprove(lendingPoolVault, uint256(-1));\n    }\n\n    /**\n     * @dev Get the aToken wrapped in the ICERC20 interface for this asset.\n     *      Fails if the pToken doesn't exist in our mappings.\n     * @param _asset Address of the asset\n     * @return Corresponding aToken to this asset\n     */\n    function _getATokenFor(address _asset) internal view returns (IAaveAToken) {\n        address aToken = assetToPToken[_asset];\n        require(aToken != address(0), \"aToken does not exist\");\n        return IAaveAToken(aToken);\n    }\n\n    /**\n     * @dev Get the current address of the Aave lending pool, which is the gateway to\n     *      depositing.\n     * @return Current lending pool implementation\n     */\n    function _getLendingPool() internal view returns (IAaveLendingPool) {\n        address lendingPool = ILendingPoolAddressesProvider(platformAddress)\n            .getLendingPool();\n        require(lendingPool != address(0), \"Lending pool does not exist\");\n        return IAaveLendingPool(lendingPool);\n    }\n\n    /**\n     * @dev Get the current address of the Aave lending pool core, which stores all the\n     *      reserve tokens in its vault.\n     * @return Current lending pool core address\n     */\n    function _getLendingPoolCore() internal view returns (address payable) {\n        address payable lendingPoolCore = ILendingPoolAddressesProvider(\n            platformAddress\n        )\n            .getLendingPoolCore();\n        require(\n            lendingPoolCore != address(uint160(address(0))),\n            \"Lending pool core does not exist\"\n        );\n        return lendingPoolCore;\n    }\n\n    /**\n     * @dev Collect stkAave, convert it to AAVE send to Vault.\n     */\n    function collectRewardToken() external onlyVault nonReentrant {\n        if (address(stkAave) == address(0)) {\n            return;\n        }\n\n        // Check staked AAVE cooldown timer\n        uint256 cooldown = stkAave.stakersCooldowns(address(this));\n        uint256 windowStart = cooldown + stkAave.COOLDOWN_SECONDS();\n        uint256 windowEnd = windowStart + stkAave.UNSTAKE_WINDOW();\n        uint256 currentTimestamp = now;\n\n        // If inside the unlock window, then we can redeem stkAave\n        // for AAVE and send it to the vault.\n        if (currentTimestamp > windowStart && currentTimestamp < windowEnd) {\n            // Redeem to AAVE\n            uint256 stkAaveBalance = stkAave.balanceOf(address(this));\n            if (stkAaveBalance > rewardLiquidationThreshold) {\n                stkAave.redeem(address(this), stkAaveBalance);\n            }\n            // Transfer AAVE to vaultAddress\n            uint256 aaveBalance = IERC20(rewardTokenAddress).balanceOf(\n                address(this)\n            );\n            if (aaveBalance > 0) {\n                IERC20(rewardTokenAddress).safeTransfer(\n                    vaultAddress,\n                    aaveBalance\n                );\n            }\n        }\n\n        // If we were past the start of the window,\n        // or if the cooldown counter is not running,\n        // then start the unlock cooldown.\n        if (currentTimestamp > windowStart || cooldown == 0) {\n            uint256 pendingRewards = incentivesController.getRewardsBalance(\n                assetsMapped,\n                address(this)\n            );\n            if (pendingRewards > 0) {\n                // claimRewards() may pause or push the cooldown time\n                // into the future. It needs to be run after any rewards would be\n                // collected, but before the cooldown is restarted.\n                uint256 collected = incentivesController.claimRewards(\n                    assetsMapped,\n                    pendingRewards,\n                    address(this)\n                );\n                require(collected == pendingRewards, \"AAVE reward difference\");\n            }\n            // Cooldown call reverts if no stkAave balance\n            if (stkAave.balanceOf(address(this)) > 0) {\n                stkAave.cooldown();\n            }\n        }\n    }\n}"
    }
  ]
}