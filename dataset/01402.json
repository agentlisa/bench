{
  "Title": "H-3: Liquidations miss delegate call to swapper",
  "Content": "# Issue H-3: Liquidations miss delegate call to swapper \n\nSource: https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/205 \n\n## Found by \n0x007, 0x3b, 0x73696d616f, 0xDjango, 0xJuda, 0xSurena, 0xTheC0der, 0xbepresent, 0xvj, ADM, Angry\\_Mustache\\_Man, Ch\\_301, Kalyan-Singh, MrjoryStewartBaxter, berndartmueller, bin2chen, duc, lil.eth, lodelux, nobody2018, p0wd3r, pengun, rvierdiiev, saidam017, shaka, talfao, xiaoming90\n\nLiquidationRow acts as an orchestrator of claiming process. It liquidates tokens across vaults using the **liquidateVaultsForToken** function. This function has a flaw and will revert. Swapper contract is called during the function call, but tokens are not transferred to it nor tokens are transferred back from the swapper to the calling contract. Based on other parts of the codebase the problem is that swapper should be invoked with a low-level delegatecall instead of a normal call.\n\n## Vulnerability Detail\n\nThe LiquidationRow contract is an orchestrator for the claiming process. It is primarily used to collect rewards for vaults. It has a method called **liquidateVaultsForToken**. Based on docs this method is for: *Conducts the liquidation process for a specific token across a list of vaults, performing the necessary balance adjustments, initiating the swap process via the asyncSwapper, taking a fee from the received amount, and queues the remaining swapped tokens in the MainRewarder associated with each vault.*\n\n```solidity\nfunction liquidateVaultsForToken(\n    address fromToken,\n    address asyncSwapper,\n    IDestinationVault[] memory vaultsToLiquidate,\n    SwapParams memory params\n) external nonReentrant hasRole(Roles.LIQUIDATOR_ROLE) onlyWhitelistedSwapper(asyncSwapper) {\n    uint256 gasBefore = gasleft();\n\n    (uint256 totalBalanceToLiquidate, uint256[] memory vaultsBalances) =\n        _prepareForLiquidation(fromToken, vaultsToLiquidate);\n    _performLiquidation(\n        gasBefore, fromToken, asyncSwapper, vaultsToLiquidate, params, totalBalanceToLiquidate, vaultsBalances\n    );\n}\n```\n\n> [https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/liquidation/LiquidationRow.sol#L167C5-L180C6](https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/liquidation/LiquidationRow.sol#L167C5-L180C6)\n\nThe second part of the function is performing the liquidation by calling **_performLiquidation**. A problem is at the beginning of it. IAsyncSwapper is called to swap tokens.\n\n```solidity\nfunction _performLiquidation(\n    uint256 gasBefore,\n    address fromToken,\n    address asyncSwapper,\n    IDestinationVault[] memory vaultsToLiquidate,\n    SwapParams memory params,\n    uint256 totalBalanceToLiquidate,\n    uint256[] memory vaultsBalances\n) private {\n    uint256 length = vaultsToLiquidate.length;\n    // the swapper checks that the amount received is greater or equal than the params.buyAmount\n    uint256 amountReceived = IAsyncSwapper(asyncSwapper).swap(params);\n    // ...\n}\n```\n\n> [https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/liquidation/LiquidationRow.sol#L251C8-L251C75](https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/liquidation/LiquidationRow.sol#L251C8-L251C75)\n\nAs you can see the LiquidationRow doesn't transfer the tokens to swapper and swapper doesn't pul them either ([swap function here](https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/liquidation/BaseAsyncSwapper.sol#L19C5-L64C6)). Because of this the function reverses.\n\nI noticed that there is no transfer back to LiquidationRow from Swapper either. Tokens can't get in or out.\n\nWhen I searched the codebase, I found that Swapper is being called on another place using the delegatecall method. This way it can operate with the tokens of the caller. The call can be found here - [LMPVaultRouter.sol:swapAndDepositToVault](https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/LMPVaultRouter.sol#L53C8-L55C11). So I think that instead of missing transfer, the problem is actually in the way how swapper is called.\n\n## Impact\n\nRewards collected through LiquidationRow **claimsVaultRewards** get stuck in the contract. Liquidation can't be called because it reverts when Swapper tries to work with tokens it doesn't possess.\n\n## Code Snippet\n\n[https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/liquidation/LiquidationRow.sol#L167C5-L180C6](https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/liquidation/LiquidationRow.sol#L167C5-L180C6)\n\n[https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/liquidation/LiquidationRow.sol#L251C8-L251C75](https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/liquidation/LiquidationRow.sol#L251C8-L251C75)\n\n[https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/liquidation/BaseAsyncSwapper.sol#L19C5-L64C6](https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/liquidation/BaseAsyncSwapper.sol#L19C5-L64C6)\n\n[https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/LMPVaultRouter.sol#L53C8-L55C11](https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/LMPVaultRouter.sol#L53C8-L55C11)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange the async swapper call from the normal function call to the low-level delegatecall function the same way it is done in LMPVaultRouter.sol:swapAndDepositToVault.\n\nI would like to address that AsyncSwapperMock in LiquidationRow.t.sol is a poorly written mock and should be updated to represent how the AsyncSwapper work. It would be nice to update the test suite for LiquidationRow because its current state won't catch this. If you check the LiquidationRow.t.sol tests, the mock swap function only mints tokens, no need to use delegatecall. This is why tests missed this vulnerability.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/101",
  "Code": [
    {
      "filename": "v2-core-audit-2023-07-14/src/liquidation/LiquidationRow.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\npragma solidity 0.8.17;\n\nimport { IERC20 } from \"openzeppelin-contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"openzeppelin-contracts/security/ReentrancyGuard.sol\";\nimport { EnumerableSet } from \"openzeppelin-contracts/utils/structs/EnumerableSet.sol\";\nimport { Address } from \"openzeppelin-contracts/utils/Address.sol\";\n\nimport { ISystemRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { IAsyncSwapper, SwapParams } from \"src/interfaces/liquidation/IAsyncSwapper.sol\";\nimport { ILiquidationRow } from \"src/interfaces/liquidation/ILiquidationRow.sol\";\nimport { IDestinationVault } from \"src/interfaces/vault/IDestinationVault.sol\";\nimport { IMainRewarder } from \"src/interfaces/rewarders/IMainRewarder.sol\";\nimport { IDestinationVaultRegistry } from \"src/interfaces/vault/IDestinationVaultRegistry.sol\";\nimport { SystemComponent } from \"src/SystemComponent.sol\";\nimport { LibAdapter } from \"src/libs/LibAdapter.sol\";\nimport { SecurityBase } from \"src/security/SecurityBase.sol\";\nimport { Roles } from \"src/libs/Roles.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\n\ncontract LiquidationRow is ILiquidationRow, ReentrancyGuard, SystemComponent, SecurityBase {\n    using Address for address;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice An instance of the DestinationVaultRegistry contract.\n    IDestinationVaultRegistry internal immutable destinationVaultRegistry;\n\n    EnumerableSet.AddressSet private rewardTokens;\n\n    /// @notice Whitelisted swapper for liquidating vaults for token\n    EnumerableSet.AddressSet private whitelistedSwappers;\n\n    /// @notice Mapping to store the balance amount for each vault for each token\n    mapping(address => mapping(address => uint256)) private balances;\n\n    /// @notice Mapping to store the total balance for each token\n    mapping(address => uint256) private totalTokenBalances;\n\n    /// @notice Mapping to store the list of vaults for each token\n    mapping(address => EnumerableSet.AddressSet) private tokenVaults;\n\n    /// @notice Fee in basis points (bps). 1 bps is 0.01%\n    uint256 public feeBps = 0;\n\n    /// @notice Address to receive the fees\n    address public feeReceiver;\n\n    uint256 public constant MAX_PCT = 10_000;\n\n    constructor(ISystemRegistry _systemRegistry)\n        SystemComponent(_systemRegistry)\n        SecurityBase(address(_systemRegistry.accessController()))\n    {\n        destinationVaultRegistry = _systemRegistry.destinationVaultRegistry();\n\n        // System registry must be properly initialized first\n        Errors.verifyNotZero(address(destinationVaultRegistry), \"destinationVaultRegistry\");\n    }\n\n    /// @notice Restricts access to whitelisted swappers\n    modifier onlyWhitelistedSwapper(address swapper) {\n        if (!whitelistedSwappers.contains(swapper)) {\n            revert Errors.AccessDenied();\n        }\n        _;\n    }\n\n    /// @inheritdoc ILiquidationRow\n    function addToWhitelist(address swapper) external hasRole(Roles.LIQUIDATOR_ROLE) {\n        Errors.verifyNotZero(swapper, \"swapper\");\n        if (!whitelistedSwappers.add(swapper)) revert Errors.ItemExists();\n        emit SwapperAdded(swapper);\n    }\n\n    /// @inheritdoc ILiquidationRow\n    function removeFromWhitelist(address swapper) external hasRole(Roles.LIQUIDATOR_ROLE) {\n        if (!whitelistedSwappers.remove(swapper)) revert Errors.ItemNotFound();\n        emit SwapperRemoved(swapper);\n    }\n\n    /// @inheritdoc ILiquidationRow\n    function isWhitelisted(address swapper) external view returns (bool) {\n        return whitelistedSwappers.contains(swapper);\n    }\n\n    /// @inheritdoc ILiquidationRow\n    function setFeeAndReceiver(address _feeReceiver, uint256 _feeBps) external hasRole(Roles.LIQUIDATOR_ROLE) {\n        // feeBps should be less than or equal to MAX_PCT (100%) to prevent overflows\n        if (_feeBps > MAX_PCT) revert FeeTooHigh();\n\n        feeBps = _feeBps;\n        // slither-disable-next-line missing-zero-check\n        feeReceiver = _feeReceiver;\n    }\n\n    function calculateFee(uint256 amount) public view returns (uint256) {\n        return (amount * feeBps) / MAX_PCT;\n    }\n\n    /// @inheritdoc ILiquidationRow\n    function claimsVaultRewards(IDestinationVault[] memory vaults)\n        external\n        nonReentrant\n        hasRole(Roles.LIQUIDATOR_ROLE)\n    {\n        if (vaults.length == 0) revert Errors.InvalidParam(\"vaults\");\n\n        for (uint256 i = 0; i < vaults.length; ++i) {\n            uint256 gasBefore = gasleft();\n            IDestinationVault vault = vaults[i];\n\n            destinationVaultRegistry.verifyIsRegistered(address(vault));\n\n            (uint256[] memory amounts, address[] memory tokens) = vault.collectRewards();\n\n            uint256 tokensLength = tokens.length;\n            for (uint256 j = 0; j < tokensLength; ++j) {\n                address token = tokens[j];\n                uint256 amount = amounts[j];\n                if (amount > 0 && token != address(0)) {\n                    // slither-disable-next-line reentrancy-no-eth\n                    _increaseBalance(address(token), address(vault), amount);\n                }\n            }\n            uint256 gasUsed = gasBefore - gasleft();\n            emit GasUsedForVault(address(vault), gasUsed, bytes32(\"claim\"));\n        }\n    }\n\n    /// @inheritdoc ILiquidationRow\n    function balanceOf(address tokenAddress, address vaultAddress) external view returns (uint256) {\n        return balances[tokenAddress][vaultAddress];\n    }\n\n    /// @inheritdoc ILiquidationRow\n    function totalBalanceOf(address tokenAddress) external view returns (uint256) {\n        return totalTokenBalances[tokenAddress];\n    }\n\n    /// @inheritdoc ILiquidationRow\n    function getTokens() external view returns (address[] memory) {\n        return rewardTokens.values();\n    }\n\n    /// @inheritdoc ILiquidationRow\n    function getVaultsForToken(address tokenAddress) external view returns (address[] memory) {\n        return tokenVaults[tokenAddress].values();\n    }\n\n    /**\n     * @notice Conducts the liquidation process for a specific token across a list of vaults,\n     * performing the necessary balance adjustments, initiating the swap process via the asyncSwapper,\n     * taking a fee from the received amount, and queues the remaining swapped tokens in the MainRewarder associated\n     * with\n     * each vault.\n     * @dev This function calls the _prepareForLiquidation and _performLiquidation functions. These helper functions\n     * were created to avoid a \"stack too deep\" error. These functions should only be used within the context of this\n     * function.\n     * @param fromToken The token that needs to be liquidated\n     * @param asyncSwapper The address of the async swapper contract\n     * @param vaultsToLiquidate The list of vaults that need to be liquidated\n     * @param params Parameters for the async swap\n     */\n    function liquidateVaultsForToken(\n        address fromToken,\n        address asyncSwapper,\n        IDestinationVault[] memory vaultsToLiquidate,\n        SwapParams memory params\n    ) external nonReentrant hasRole(Roles.LIQUIDATOR_ROLE) onlyWhitelistedSwapper(asyncSwapper) {\n        uint256 gasBefore = gasleft();\n\n        (uint256 totalBalanceToLiquidate, uint256[] memory vaultsBalances) =\n            _prepareForLiquidation(fromToken, vaultsToLiquidate);\n        _performLiquidation(\n            gasBefore, fromToken, asyncSwapper, vaultsToLiquidate, params, totalBalanceToLiquidate, vaultsBalances\n        );\n    }\n\n    /**\n     * @notice Calculates the total balance to liquidate, adjusts the contract state accordingly and calculates fees\n     * @dev This function is part of a workaround for the \"stack too deep\" error and is meant to be used with\n     * _performLiquidation. It is not designed to be used standalone, but as part of the liquidateVaultsForToken\n     * function\n     * @param fromToken The token that needs to be liquidated\n     * @param vaultsToLiquidate The list of vaults that need to be liquidated\n     * @return totalBalanceToLiquidate The total balance that needs to be liquidated\n     * @return vaultsBalances The balances of the vaults\n     */\n    function _prepareForLiquidation(\n        address fromToken,\n        IDestinationVault[] memory vaultsToLiquidate\n    ) private returns (uint256, uint256[] memory) {\n        uint256 length = vaultsToLiquidate.length;\n\n        uint256 totalBalanceToLiquidate = 0;\n        uint256[] memory vaultsBalances = new uint256[](length);\n\n        for (uint256 i = 0; i < length; ++i) {\n            address vaultAddress = address(vaultsToLiquidate[i]);\n            uint256 vaultBalance = balances[fromToken][vaultAddress];\n            totalBalanceToLiquidate += vaultBalance;\n            vaultsBalances[i] = vaultBalance;\n            // Update the total balance for the token\n            totalTokenBalances[fromToken] -= vaultBalance;\n            // Update the balance for the vault and token\n            balances[fromToken][vaultAddress] = 0;\n            // Remove the vault from the token vaults list\n            if (!tokenVaults[fromToken].remove(vaultAddress)) revert Errors.ItemNotFound();\n        }\n\n        if (totalBalanceToLiquidate == 0) {\n            revert NothingToLiquidate();\n        }\n\n        // Check if the token still has any other vaults\n        if (tokenVaults[fromToken].length() == 0) {\n            if (!rewardTokens.remove(fromToken)) revert Errors.ItemNotFound();\n        }\n\n        return (totalBalanceToLiquidate, vaultsBalances);\n    }\n\n    /**\n     * @notice Performs the actual liquidation process, handles the async swap, calculates and transfers the fees,\n     * and queues the remaining swapped tokens in the MainRewarder associated with each vault.\n     * @dev This function is part of a workaround for the \"stack too deep\" error and is meant to be used with\n     * _prepareForLiquidation. It's not designed to be used standalone, but as part of the liquidateVaultsForToken\n     * function\n     * @param gasBefore Amount of gas when the liquidliquidateVaultsForToken function was called\n     * @param fromToken The token that needs to be liquidated\n     * @param asyncSwapper The address of the async swapper contract\n     * @param vaultsToLiquidate The list of vaults that need to be liquidated\n     * @param params Parameters for the async swap\n     * @param totalBalanceToLiquidate The total balance that needs to be liquidated\n     * @param vaultsBalances The balances of the vaults\n     */\n    function _performLiquidation(\n        uint256 gasBefore,\n        address fromToken,\n        address asyncSwapper,\n        IDestinationVault[] memory vaultsToLiquidate,\n        SwapParams memory params,\n        uint256 totalBalanceToLiquidate,\n        uint256[] memory vaultsBalances\n    ) private {\n        uint256 length = vaultsToLiquidate.length;\n        // the swapper checks that the amount received is greater or equal than the params.buyAmount\n        uint256 amountReceived = IAsyncSwapper(asyncSwapper).swap(params);\n\n        // if the fee feature is turned on, send the fee to the fee receiver\n        if (feeReceiver != address(0) && feeBps > 0) {\n            uint256 fee = calculateFee(amountReceived);\n            emit FeesTransfered(feeReceiver, amountReceived, fee);\n\n            // adjust the amount received after deducting the fee\n            amountReceived -= fee;\n            // transfer fee to the fee receiver\n            IERC20(params.buyTokenAddress).safeTransfer(feeReceiver, fee);\n        }\n\n        uint256 gasUsedPerVault = (gasBefore - gasleft()) / vaultsToLiquidate.length;\n        for (uint256 i = 0; i < length; ++i) {\n            IDestinationVault vaultAddress = vaultsToLiquidate[i];\n            IMainRewarder mainRewarder = IMainRewarder(vaultAddress.rewarder());\n\n            if (mainRewarder.rewardToken() != params.buyTokenAddress) {\n                revert InvalidRewardToken();\n            }\n\n            uint256 amount = amountReceived * vaultsBalances[i] / totalBalanceToLiquidate;\n\n            // approve main rewarder to pull the tokens\n            LibAdapter._approve(IERC20(params.buyTokenAddress), address(mainRewarder), amount);\n            mainRewarder.queueNewRewards(amount);\n\n            emit VaultLiquidated(address(vaultAddress), fromToken, params.buyTokenAddress, amount);\n            emit GasUsedForVault(address(vaultAddress), gasUsedPerVault, bytes32(\"liquidation\"));\n        }\n    }\n\n    /**\n     * @notice Update the balance of a specific token and vault\n     * @param tokenAddress The address of the token\n     * @param vaultAddress The address of the vault\n     * @param balance The amount of the token to be updated\n     */\n    function _increaseBalance(address tokenAddress, address vaultAddress, uint256 balance) internal {\n        Errors.verifyNotZero(balance, \"balance\");\n\n        uint256 currentBalance = balances[tokenAddress][vaultAddress];\n        uint256 totalBalance = totalTokenBalances[tokenAddress];\n        uint256 newTotalBalance = totalBalance + balance;\n\n        // ensure that this contract has enough balance to cover the new total balance\n        uint256 balanceOfToken = IERC20(tokenAddress).balanceOf(address(this));\n        if (newTotalBalance > balanceOfToken) {\n            /**\n             * @dev This should never happen, but just in case. The error is raised if the updated total balance of a\n             * specific token in the contract is greater than the actual balance of that token held by the\n             * contract.\n             * The calling contract should transfer the funds first before updating the balance.\n             */\n\n            revert Errors.InsufficientBalance(tokenAddress);\n        }\n\n        // if currentBalance is 0, then the vault is not yet added to the token vaults list\n        if (currentBalance == 0) {\n            if (!tokenVaults[tokenAddress].add(vaultAddress)) revert Errors.ItemExists();\n\n            if (totalBalance == 0) {\n                if (!rewardTokens.add(tokenAddress)) revert Errors.ItemExists();\n            }\n        }\n\n        // Update the total balance for the token\n        totalTokenBalances[tokenAddress] = newTotalBalance;\n        // Update the balance for the vault and token\n        balances[tokenAddress][vaultAddress] = currentBalance + balance;\n\n        emit BalanceUpdated(tokenAddress, vaultAddress, currentBalance + balance);\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/liquidation/LiquidationRow.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\npragma solidity 0.8.17;\n\nimport { IERC20 } from \"openzeppelin-contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"openzeppelin-contracts/security/ReentrancyGuard.sol\";\nimport { EnumerableSet } from \"openzeppelin-contracts/utils/structs/EnumerableSet.sol\";\nimport { Address } from \"openzeppelin-contracts/utils/Address.sol\";\n\nimport { ISystemRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { IAsyncSwapper, SwapParams } from \"src/interfaces/liquidation/IAsyncSwapper.sol\";\nimport { ILiquidationRow } from \"src/interfaces/liquidation/ILiquidationRow.sol\";\nimport { IDestinationVault } from \"src/interfaces/vault/IDestinationVault.sol\";\nimport { IMainRewarder } from \"src/interfaces/rewarders/IMainRewarder.sol\";\nimport { IDestinationVaultRegistry } from \"src/interfaces/vault/IDestinationVaultRegistry.sol\";\nimport { SystemComponent } from \"src/SystemComponent.sol\";\nimport { LibAdapter } from \"src/libs/LibAdapter.sol\";\nimport { SecurityBase } from \"src/security/SecurityBase.sol\";\nimport { Roles } from \"src/libs/Roles.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\n\ncontract LiquidationRow is ILiquidationRow, ReentrancyGuard, SystemComponent, SecurityBase {\n    using Address for address;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice An instance of the DestinationVaultRegistry contract.\n    IDestinationVaultRegistry internal immutable destinationVaultRegistry;\n\n    EnumerableSet.AddressSet private rewardTokens;\n\n    /// @notice Whitelisted swapper for liquidating vaults for token\n    EnumerableSet.AddressSet private whitelistedSwappers;\n\n    /// @notice Mapping to store the balance amount for each vault for each token\n    mapping(address => mapping(address => uint256)) private balances;\n\n    /// @notice Mapping to store the total balance for each token\n    mapping(address => uint256) private totalTokenBalances;\n\n    /// @notice Mapping to store the list of vaults for each token\n    mapping(address => EnumerableSet.AddressSet) private tokenVaults;\n\n    /// @notice Fee in basis points (bps). 1 bps is 0.01%\n    uint256 public feeBps = 0;\n\n    /// @notice Address to receive the fees\n    address public feeReceiver;\n\n    uint256 public constant MAX_PCT = 10_000;\n\n    constructor(ISystemRegistry _systemRegistry)\n        SystemComponent(_systemRegistry)\n        SecurityBase(address(_systemRegistry.accessController()))\n    {\n        destinationVaultRegistry = _systemRegistry.destinationVaultRegistry();\n\n        // System registry must be properly initialized first\n        Errors.verifyNotZero(address(destinationVaultRegistry), \"destinationVaultRegistry\");\n    }\n\n    /// @notice Restricts access to whitelisted swappers\n    modifier onlyWhitelistedSwapper(address swapper) {\n        if (!whitelistedSwappers.contains(swapper)) {\n            revert Errors.AccessDenied();\n        }\n        _;\n    }\n\n    /// @inheritdoc ILiquidationRow\n    function addToWhitelist(address swapper) external hasRole(Roles.LIQUIDATOR_ROLE) {\n        Errors.verifyNotZero(swapper, \"swapper\");\n        if (!whitelistedSwappers.add(swapper)) revert Errors.ItemExists();\n        emit SwapperAdded(swapper);\n    }\n\n    /// @inheritdoc ILiquidationRow\n    function removeFromWhitelist(address swapper) external hasRole(Roles.LIQUIDATOR_ROLE) {\n        if (!whitelistedSwappers.remove(swapper)) revert Errors.ItemNotFound();\n        emit SwapperRemoved(swapper);\n    }\n\n    /// @inheritdoc ILiquidationRow\n    function isWhitelisted(address swapper) external view returns (bool) {\n        return whitelistedSwappers.contains(swapper);\n    }\n\n    /// @inheritdoc ILiquidationRow\n    function setFeeAndReceiver(address _feeReceiver, uint256 _feeBps) external hasRole(Roles.LIQUIDATOR_ROLE) {\n        // feeBps should be less than or equal to MAX_PCT (100%) to prevent overflows\n        if (_feeBps > MAX_PCT) revert FeeTooHigh();\n\n        feeBps = _feeBps;\n        // slither-disable-next-line missing-zero-check\n        feeReceiver = _feeReceiver;\n    }\n\n    function calculateFee(uint256 amount) public view returns (uint256) {\n        return (amount * feeBps) / MAX_PCT;\n    }\n\n    /// @inheritdoc ILiquidationRow\n    function claimsVaultRewards(IDestinationVault[] memory vaults)\n        external\n        nonReentrant\n        hasRole(Roles.LIQUIDATOR_ROLE)\n    {\n        if (vaults.length == 0) revert Errors.InvalidParam(\"vaults\");\n\n        for (uint256 i = 0; i < vaults.length; ++i) {\n            uint256 gasBefore = gasleft();\n            IDestinationVault vault = vaults[i];\n\n            destinationVaultRegistry.verifyIsRegistered(address(vault));\n\n            (uint256[] memory amounts, address[] memory tokens) = vault.collectRewards();\n\n            uint256 tokensLength = tokens.length;\n            for (uint256 j = 0; j < tokensLength; ++j) {\n                address token = tokens[j];\n                uint256 amount = amounts[j];\n                if (amount > 0 && token != address(0)) {\n                    // slither-disable-next-line reentrancy-no-eth\n                    _increaseBalance(address(token), address(vault), amount);\n                }\n            }\n            uint256 gasUsed = gasBefore - gasleft();\n            emit GasUsedForVault(address(vault), gasUsed, bytes32(\"claim\"));\n        }\n    }\n\n    /// @inheritdoc ILiquidationRow\n    function balanceOf(address tokenAddress, address vaultAddress) external view returns (uint256) {\n        return balances[tokenAddress][vaultAddress];\n    }\n\n    /// @inheritdoc ILiquidationRow\n    function totalBalanceOf(address tokenAddress) external view returns (uint256) {\n        return totalTokenBalances[tokenAddress];\n    }\n\n    /// @inheritdoc ILiquidationRow\n    function getTokens() external view returns (address[] memory) {\n        return rewardTokens.values();\n    }\n\n    /// @inheritdoc ILiquidationRow\n    function getVaultsForToken(address tokenAddress) external view returns (address[] memory) {\n        return tokenVaults[tokenAddress].values();\n    }\n\n    /**\n     * @notice Conducts the liquidation process for a specific token across a list of vaults,\n     * performing the necessary balance adjustments, initiating the swap process via the asyncSwapper,\n     * taking a fee from the received amount, and queues the remaining swapped tokens in the MainRewarder associated\n     * with\n     * each vault.\n     * @dev This function calls the _prepareForLiquidation and _performLiquidation functions. These helper functions\n     * were created to avoid a \"stack too deep\" error. These functions should only be used within the context of this\n     * function.\n     * @param fromToken The token that needs to be liquidated\n     * @param asyncSwapper The address of the async swapper contract\n     * @param vaultsToLiquidate The list of vaults that need to be liquidated\n     * @param params Parameters for the async swap\n     */\n    function liquidateVaultsForToken(\n        address fromToken,\n        address asyncSwapper,\n        IDestinationVault[] memory vaultsToLiquidate,\n        SwapParams memory params\n    ) external nonReentrant hasRole(Roles.LIQUIDATOR_ROLE) onlyWhitelistedSwapper(asyncSwapper) {\n        uint256 gasBefore = gasleft();\n\n        (uint256 totalBalanceToLiquidate, uint256[] memory vaultsBalances) =\n            _prepareForLiquidation(fromToken, vaultsToLiquidate);\n        _performLiquidation(\n            gasBefore, fromToken, asyncSwapper, vaultsToLiquidate, params, totalBalanceToLiquidate, vaultsBalances\n        );\n    }\n\n    /**\n     * @notice Calculates the total balance to liquidate, adjusts the contract state accordingly and calculates fees\n     * @dev This function is part of a workaround for the \"stack too deep\" error and is meant to be used with\n     * _performLiquidation. It is not designed to be used standalone, but as part of the liquidateVaultsForToken\n     * function\n     * @param fromToken The token that needs to be liquidated\n     * @param vaultsToLiquidate The list of vaults that need to be liquidated\n     * @return totalBalanceToLiquidate The total balance that needs to be liquidated\n     * @return vaultsBalances The balances of the vaults\n     */\n    function _prepareForLiquidation(\n        address fromToken,\n        IDestinationVault[] memory vaultsToLiquidate\n    ) private returns (uint256, uint256[] memory) {\n        uint256 length = vaultsToLiquidate.length;\n\n        uint256 totalBalanceToLiquidate = 0;\n        uint256[] memory vaultsBalances = new uint256[](length);\n\n        for (uint256 i = 0; i < length; ++i) {\n            address vaultAddress = address(vaultsToLiquidate[i]);\n            uint256 vaultBalance = balances[fromToken][vaultAddress];\n            totalBalanceToLiquidate += vaultBalance;\n            vaultsBalances[i] = vaultBalance;\n            // Update the total balance for the token\n            totalTokenBalances[fromToken] -= vaultBalance;\n            // Update the balance for the vault and token\n            balances[fromToken][vaultAddress] = 0;\n            // Remove the vault from the token vaults list\n            if (!tokenVaults[fromToken].remove(vaultAddress)) revert Errors.ItemNotFound();\n        }\n\n        if (totalBalanceToLiquidate == 0) {\n            revert NothingToLiquidate();\n        }\n\n        // Check if the token still has any other vaults\n        if (tokenVaults[fromToken].length() == 0) {\n            if (!rewardTokens.remove(fromToken)) revert Errors.ItemNotFound();\n        }\n\n        return (totalBalanceToLiquidate, vaultsBalances);\n    }\n\n    /**\n     * @notice Performs the actual liquidation process, handles the async swap, calculates and transfers the fees,\n     * and queues the remaining swapped tokens in the MainRewarder associated with each vault.\n     * @dev This function is part of a workaround for the \"stack too deep\" error and is meant to be used with\n     * _prepareForLiquidation. It's not designed to be used standalone, but as part of the liquidateVaultsForToken\n     * function\n     * @param gasBefore Amount of gas when the liquidliquidateVaultsForToken function was called\n     * @param fromToken The token that needs to be liquidated\n     * @param asyncSwapper The address of the async swapper contract\n     * @param vaultsToLiquidate The list of vaults that need to be liquidated\n     * @param params Parameters for the async swap\n     * @param totalBalanceToLiquidate The total balance that needs to be liquidated\n     * @param vaultsBalances The balances of the vaults\n     */\n    function _performLiquidation(\n        uint256 gasBefore,\n        address fromToken,\n        address asyncSwapper,\n        IDestinationVault[] memory vaultsToLiquidate,\n        SwapParams memory params,\n        uint256 totalBalanceToLiquidate,\n        uint256[] memory vaultsBalances\n    ) private {\n        uint256 length = vaultsToLiquidate.length;\n        // the swapper checks that the amount received is greater or equal than the params.buyAmount\n        uint256 amountReceived = IAsyncSwapper(asyncSwapper).swap(params);\n\n        // if the fee feature is turned on, send the fee to the fee receiver\n        if (feeReceiver != address(0) && feeBps > 0) {\n            uint256 fee = calculateFee(amountReceived);\n            emit FeesTransfered(feeReceiver, amountReceived, fee);\n\n            // adjust the amount received after deducting the fee\n            amountReceived -= fee;\n            // transfer fee to the fee receiver\n            IERC20(params.buyTokenAddress).safeTransfer(feeReceiver, fee);\n        }\n\n        uint256 gasUsedPerVault = (gasBefore - gasleft()) / vaultsToLiquidate.length;\n        for (uint256 i = 0; i < length; ++i) {\n            IDestinationVault vaultAddress = vaultsToLiquidate[i];\n            IMainRewarder mainRewarder = IMainRewarder(vaultAddress.rewarder());\n\n            if (mainRewarder.rewardToken() != params.buyTokenAddress) {\n                revert InvalidRewardToken();\n            }\n\n            uint256 amount = amountReceived * vaultsBalances[i] / totalBalanceToLiquidate;\n\n            // approve main rewarder to pull the tokens\n            LibAdapter._approve(IERC20(params.buyTokenAddress), address(mainRewarder), amount);\n            mainRewarder.queueNewRewards(amount);\n\n            emit VaultLiquidated(address(vaultAddress), fromToken, params.buyTokenAddress, amount);\n            emit GasUsedForVault(address(vaultAddress), gasUsedPerVault, bytes32(\"liquidation\"));\n        }\n    }\n\n    /**\n     * @notice Update the balance of a specific token and vault\n     * @param tokenAddress The address of the token\n     * @param vaultAddress The address of the vault\n     * @param balance The amount of the token to be updated\n     */\n    function _increaseBalance(address tokenAddress, address vaultAddress, uint256 balance) internal {\n        Errors.verifyNotZero(balance, \"balance\");\n\n        uint256 currentBalance = balances[tokenAddress][vaultAddress];\n        uint256 totalBalance = totalTokenBalances[tokenAddress];\n        uint256 newTotalBalance = totalBalance + balance;\n\n        // ensure that this contract has enough balance to cover the new total balance\n        uint256 balanceOfToken = IERC20(tokenAddress).balanceOf(address(this));\n        if (newTotalBalance > balanceOfToken) {\n            /**\n             * @dev This should never happen, but just in case. The error is raised if the updated total balance of a\n             * specific token in the contract is greater than the actual balance of that token held by the\n             * contract.\n             * The calling contract should transfer the funds first before updating the balance.\n             */\n\n            revert Errors.InsufficientBalance(tokenAddress);\n        }\n\n        // if currentBalance is 0, then the vault is not yet added to the token vaults list\n        if (currentBalance == 0) {\n            if (!tokenVaults[tokenAddress].add(vaultAddress)) revert Errors.ItemExists();\n\n            if (totalBalance == 0) {\n                if (!rewardTokens.add(tokenAddress)) revert Errors.ItemExists();\n            }\n        }\n\n        // Update the total balance for the token\n        totalTokenBalances[tokenAddress] = newTotalBalance;\n        // Update the balance for the vault and token\n        balances[tokenAddress][vaultAddress] = currentBalance + balance;\n\n        emit BalanceUpdated(tokenAddress, vaultAddress, currentBalance + balance);\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/liquidation/BaseAsyncSwapper.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\npragma solidity 0.8.17;\n\nimport { IERC20 } from \"openzeppelin-contracts/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuard } from \"openzeppelin-contracts/security/ReentrancyGuard.sol\";\nimport { LibAdapter } from \"src/libs/LibAdapter.sol\";\nimport { IAsyncSwapper, SwapParams } from \"src/interfaces/liquidation/IAsyncSwapper.sol\";\n\ncontract BaseAsyncSwapper is IAsyncSwapper, ReentrancyGuard {\n    // solhint-disable-next-line var-name-mixedcase\n    address public immutable AGGREGATOR;\n\n    constructor(address aggregator) {\n        if (aggregator == address(0)) revert TokenAddressZero();\n        AGGREGATOR = aggregator;\n    }\n\n    function swap(SwapParams memory swapParams) public virtual nonReentrant returns (uint256 buyTokenAmountReceived) {\n        if (swapParams.buyTokenAddress == address(0)) revert TokenAddressZero();\n        if (swapParams.sellTokenAddress == address(0)) revert TokenAddressZero();\n        if (swapParams.sellAmount == 0) revert InsufficientSellAmount();\n        if (swapParams.buyAmount == 0) revert InsufficientBuyAmount();\n\n        IERC20 sellToken = IERC20(swapParams.sellTokenAddress);\n        IERC20 buyToken = IERC20(swapParams.buyTokenAddress);\n\n        uint256 sellTokenBalance = sellToken.balanceOf(address(this));\n\n        if (sellTokenBalance < swapParams.sellAmount) {\n            revert InsufficientBalance(sellTokenBalance, swapParams.sellAmount);\n        }\n\n        LibAdapter._approve(sellToken, AGGREGATOR, swapParams.sellAmount);\n\n        uint256 buyTokenBalanceBefore = buyToken.balanceOf(address(this));\n\n        // we don't need the returned value, we calculate the buyTokenAmountReceived ourselves\n        // slither-disable-start low-level-calls,unchecked-lowlevel\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success,) = AGGREGATOR.call(swapParams.data);\n        // slither-disable-end low-level-calls,unchecked-lowlevel\n\n        if (!success) {\n            revert SwapFailed();\n        }\n\n        uint256 buyTokenBalanceAfter = buyToken.balanceOf(address(this));\n        buyTokenAmountReceived = buyTokenBalanceAfter - buyTokenBalanceBefore;\n\n        if (buyTokenAmountReceived < swapParams.buyAmount) {\n            revert InsufficientBuyAmountReceived(buyTokenAmountReceived, swapParams.buyAmount);\n        }\n\n        emit Swapped(\n            swapParams.sellTokenAddress,\n            swapParams.buyTokenAddress,\n            swapParams.sellAmount,\n            swapParams.buyAmount,\n            buyTokenAmountReceived\n        );\n\n        return buyTokenAmountReceived;\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/vault/LMPVaultRouter.sol",
      "content": "// forked from https://github.com/fei-protocol/ERC4626/blob/main/src/ERC4626Router.sol\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\nimport { IERC20, SafeERC20 } from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Address } from \"openzeppelin-contracts/utils/Address.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\nimport { ISystemRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { ILMPVault, ILMPVaultRouter } from \"src/interfaces/vault/ILMPVaultRouter.sol\";\nimport { SwapParams } from \"src/interfaces/liquidation/IAsyncSwapper.sol\";\nimport { LMPVaultRouterBase } from \"src/vault/LMPVaultRouterBase.sol\";\n\n/// @title ERC46"
    }
  ]
}