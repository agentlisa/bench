{
  "Title": "M-2: Gas usage of cross-chain messages is undercounted, causing discrepancy between L1 and L2 and impacting intrinsic gas calculation",
  "Content": "# Issue M-2: Gas usage of cross-chain messages is undercounted, causing discrepancy between L1 and L2 and impacting intrinsic gas calculation \n\nSource: https://github.com/sherlock-audit/2023-03-optimism-judging/issues/88 \n\n## Found by \nJeiwan\n\n## Summary\nGas consumption of messages sent via [CrossDomainMessenger](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol#L114) (including both [L1CrossDomainMessenger](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/L1/L1CrossDomainMessenger.sol#L16) and [L2CrossDomainMessenger](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/L2/L2CrossDomainMessenger.sol#L18)) is calculated incorrectly: the gas usage of the \"relayMessage\" wrapper is not counted. As a result, the actual gas consumption of sending a message will be higher than expected. Users will pay less for gas on L1, and L2 blocks may be filled earlier than expected. This will also affect gas metering via [ResourceMetering](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/L1/ResourceMetering.sol#L15): metered gas will be lower than actual consumed gas, and the EIP-1559-like gas pricing mechanism won't reflect the actual demand for gas.\n## Vulnerability Detail\nThe [CrossDomainMessenger.sendMessage](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol#L247) function is used to send cross-chain messages. Users are required to set the `_minGasLimit` argument, which is the expected amount of gas that the message will consume on the other chain. The function also [computes](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol#L258) the amount of gas required to pass the message to the other chain: this is done in the [baseGas](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol#L258) function, which [computes the byte-wise cost of the message](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol#L432). `CrossDomainMessenger` also allows users to replay their messages on the destination chain if they failed: to allow this, the contract [wraps user messages in `relayMessage` calls](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol#L260-L268). This increases the size of messages, but the `baseGas` call above counts gas usage of only the original, not wrapped in the `relayMessage` call, message.\n\nThis contradicts the [intrinsic gas calculation in `op-geth`](https://github.com/ethereum-optimism/op-geth/blob/optimism/core/state_transition.go#L75-L108), which calculates gas of an entire message data:\n```go\ndataLen := uint64(len(data))\n// Bump the required gas by the amount of transactional data\nif dataLen > 0 {\n    ...\n}\n```\nThus, there's a discrepancy between the contract and the node, which will result in the node consuming more gas than users paid for.\n\nThis behaviour also disagrees with how the migration process works:\n1. when [migrating pre-Bedrock withdrawals](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/op-chain-ops/crossdomain/migrate.go#L55), `data` is the [entire messages](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/op-chain-ops/crossdomain/migrate.go#L73-L81), including the `relayMessage` calldata;\n1. the gas limit of migrated messages is [computed on the entire data](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/op-chain-ops/crossdomain/migrate.go#L86).\n\nTaking into account the logic of paying cross-chain messages' gas consumption on L1, I think the implementation in the migration code is correct and the implementation in `CrossDomainMessenger` is wrong: users should pay for sending the entire cross-chain message, not just the calldata that will be execute on the recipient on the other chain.\n## Impact\nSince the `CrossDomainMessenger` contract is recommended to be used as the main cross-chain messaging contract and since it's used by both L1 and L2 bridges (when bridging [ETH](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/universal/StandardBridge.sol#L377-L387) or [ERC20 tokens](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/universal/StandardBridge.sol#L427-L442)), the undercounted gas will have a broad impact on the system. It'll create a discrepancy in gas usage and payment on L1 and L2: on L1, users will pay for less gas than actually will be consumed by cross-chain messages.\n\nAlso, since messages sent from L1 to L2 (via [OptimismPortal.depositTransaction](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L426)) are priced using an EIP-1559-like mechanism (via [ResourceMetering._metered](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/L1/ResourceMetering.sol#L92)), the mechanism will fail to detect the actual demand for gas and will generally set lower gas prices, while actual gas consumption will be higher.\n\nThe following bytes are excluded from gas usage counting:\n1. the [4 bytes of the `relayMessage` selector](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol#L261);\n1. the [32 bytes of the message nonce](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol#L262);\n1. the [address of the sender](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol#L263) (20 bytes);\n1. the [address of the recipient](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol#L264) (20 bytes);\n1. the [amount of ETH sent with the message](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol#L265) (32 bytes);\n1. the [minimal gas limit of the nested message](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol#L266) (32 bytes).\n\nThus, every cross-chain message sent via the bridge or the messenger will contain 140 bytes that won't be paid by users. The bytes will however be processed by the node and accounted in the gas consumption.\n## Code Snippet\n1. CrossDomainMessenger.sendMessage sends cross-chain messages:\nhttps://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol#L247\n1. `CrossDomainMessenger.sendMessage` wraps cross-chain messages in `relayMessage` calls:\nhttps://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol#L260-L268\n1. The gas limit counting of cross-chain messages includes only the length of the nested message and doesn't include the `relayMessage` wrapping:\nhttps://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol#L258\n1. When pre-Bedrock withdrawals are migrated, gas limit calculation does include the `relayMessage` wrapping:\nhttps://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/op-chain-ops/crossdomain/migrate.go#L73-L86\n## Tool used\nManual Review\n## Recommendation\nWhen counting gas limit in the `CrossDomainMessenger.sendMessage` function, consider counting the entire message, including the `relayMessage` calldata wrapping. Consider a change like that:\n```diff\ndiff --git a/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol b/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol\nindex f67021010..5239feefd 100644\n--- a/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol\n+++ b/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol\n@@ -253,19 +253,20 @@ abstract contract CrossDomainMessenger is\n         // message is the amount of gas requested by the user PLUS the base gas value. We want to\n         // guarantee the property that the call to the target contract will always have at least\n         // the minimum gas limit specified by the user.\n+        bytes memory wrappedMessage = abi.encodeWithSelector(\n+            this.relayMessage.selector,\n+            messageNonce(),\n+            msg.sender,\n+            _target,\n+            msg.value,\n+            _minGasLimit,\n+            _message\n+        );\n         _sendMessage(\n             OTHER_MESSENGER,\n-            baseGas(_message, _minGasLimit),\n+            baseGas(wrappedMessage, _minGasLimit),\n             msg.value,\n-            abi.encodeWithSelector(\n-                this.relayMessage.selector,\n-                messageNonce(),\n-                msg.sender,\n-                _target,\n-                msg.value,\n-                _minGasLimit,\n-                _message\n-            )\n+            wrappedMessage\n         );\n\n         emit SentMessage(_target, msg.sender, _message, messageNonce(), _minGasLimit);\n```\n\n\n\n## Discussion\n\n**hrishibhat**\n\nSponsor comment:\nThis should improve gas estimation but is low in severity since it does not affect usage or impact the intended functionality.\n\n**GalloDaSballo**\n\nWould judge in the same way as #77 the incorrect math can lead to an issue\n\n**GalloDaSballo**\n\nI see this as logically equivalent to #77 so I believe it should be awarded as Med\n\n**GalloDaSballo**\n\nThis can also be quantified as \n`140 * 16 = 2240`\nAll l1 -> l2 tx are underpriced by that amount (roughly 10% of fixed base cost)\n\n**GalloDaSballo**\n\nCan see this being escalated against because it's \"only\" 10% incorrect, but find hard to argue against the math not being correct\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/63",
  "Code": [
    {
      "filename": "packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\n\n/**\n * @custom:legacy\n * @title CrossDomainMessengerLegacySpacer0\n * @notice Contract only exists to add a spacer to the CrossDomainMessenger where the\n *         libAddressManager variable used to exist. Must be the first contract in the inheritance\n *         tree of the CrossDomainMessenger.\n */\ncontract CrossDomainMessengerLegacySpacer0 {\n    /**\n     * @custom:legacy\n     * @custom:spacer libAddressManager\n     * @notice Spacer for backwards compatibility.\n     */\n    address private spacer_0_0_20;\n}\n\n/**\n * @custom:legacy\n * @title CrossDomainMessengerLegacySpacer1\n * @notice Contract only exists to add a spacer to the CrossDomainMessenger where the\n *         PausableUpgradable and OwnableUpgradeable variables used to exist. Must be\n *         the third contract in the inheritance tree of the CrossDomainMessenger.\n */\ncontract CrossDomainMessengerLegacySpacer1 {\n    /**\n     * @custom:legacy\n     * @custom:spacer __gap\n     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin\n     *         ContextUpgradable via OwnableUpgradeable.\n     *\n     */\n    uint256[50] private spacer_1_0_1600;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer _owner\n     * @notice Spacer for backwards compatibility.\n     *         Come from OpenZeppelin OwnableUpgradeable.\n     */\n    address private spacer_51_0_20;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer __gap\n     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin\n     *         ContextUpgradable via PausableUpgradable.\n     */\n    uint256[49] private spacer_52_0_1568;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer _paused\n     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin\n     *         PausableUpgradable.\n     */\n    bool private spacer_101_0_1;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer __gap\n     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin\n     *         PausableUpgradable.\n     */\n    uint256[49] private spacer_102_0_1568;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer ReentrancyGuardUpgradeable's `_status` field.\n     * @notice Spacer for backwards compatibility\n     */\n    uint256 private spacer_151_0_32;\n\n    /**\n     * @custom:spacer ReentrancyGuardUpgradeable\n     * @notice Spacer for backwards compatibility\n     */\n    uint256[49] private __gap_reentrancy_guard;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer blockedMessages\n     * @notice Spacer for backwards compatibility.\n     */\n    mapping(bytes32 => bool) private spacer_201_0_32;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer relayedMessages\n     * @notice Spacer for backwards compatibility.\n     */\n    mapping(bytes32 => bool) private spacer_202_0_32;\n}\n\n/**\n * @custom:upgradeable\n * @title CrossDomainMessenger\n * @notice CrossDomainMessenger is a base contract that provides the core logic for the L1 and L2\n *         cross-chain messenger contracts. It's designed to be a universal interface that only\n *         needs to be extended slightly to provide low-level message passing functionality on each\n *         chain it's deployed on. Currently only designed for message passing between two paired\n *         chains and does not support one-to-many interactions.\n *\n *         Any changes to this contract MUST result in a semver bump for contracts that inherit it.\n */\nabstract contract CrossDomainMessenger is\n    CrossDomainMessengerLegacySpacer0,\n    Initializable,\n    CrossDomainMessengerLegacySpacer1\n{\n    /**\n     * @notice Current message version identifier.\n     */\n    uint16 public constant MESSAGE_VERSION = 1;\n\n    /**\n     * @notice Constant overhead added to the base gas for a message.\n     */\n    uint64 public constant MIN_GAS_CONSTANT_OVERHEAD = 200_000;\n\n    /**\n     * @notice Numerator for dynamic overhead added to the base gas for a message.\n     */\n    uint64 public constant MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR = 1016;\n\n    /**\n     * @notice Denominator for dynamic overhead added to the base gas for a message.\n     */\n    uint64 public constant MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR = 1000;\n\n    /**\n     * @notice Extra gas added to base gas for each byte of calldata in a message.\n     */\n    uint64 public constant MIN_GAS_CALLDATA_OVERHEAD = 16;\n\n    /**\n     * @notice Address of the paired CrossDomainMessenger contract on the other chain.\n     */\n    address public immutable OTHER_MESSENGER;\n\n    /**\n     * @notice Mapping of message hashes to boolean receipt values. Note that a message will only\n     *         be present in this mapping if it has successfully been relayed on this chain, and\n     *         can therefore not be relayed again.\n     */\n    mapping(bytes32 => bool) public successfulMessages;\n\n    /**\n     * @notice Address of the sender of the currently executing message on the other chain. If the\n     *         value of this variable is the default value (0x00000000...dead) then no message is\n     *         currently being executed. Use the xDomainMessageSender getter which will throw an\n     *         error if this is the case.\n     */\n    address internal xDomainMsgSender;\n\n    /**\n     * @notice Nonce for the next message to be sent, without the message version applied. Use the\n     *         messageNonce getter which will insert the message version into the nonce to give you\n     *         the actual nonce to be used for the message.\n     */\n    uint240 internal msgNonce;\n\n    /**\n     * @notice Mapping of message hashes to a boolean if and only if the message has failed to be\n     *         executed at least once. A message will not be present in this mapping if it\n     *         successfully executed on the first attempt.\n     */\n    mapping(bytes32 => bool) public failedMessages;\n\n    /**\n     * @notice A mapping of hashes to reentrancy locks.\n     */\n    mapping(bytes32 => bool) internal reentrancyLocks;\n\n    /**\n     * @notice Reserve extra slots in the storage layout for future upgrades.\n     *         A gap size of 41 was chosen here, so that the first slot used in a child contract\n     *         would be a multiple of 50.\n     */\n    uint256[41] private __gap;\n\n    /**\n     * @notice Emitted whenever a message is sent to the other chain.\n     *\n     * @param target       Address of the recipient of the message.\n     * @param sender       Address of the sender of the message.\n     * @param message      Message to trigger the recipient address with.\n     * @param messageNonce Unique nonce attached to the message.\n     * @param gasLimit     Minimum gas limit that the message can be executed with.\n     */\n    event SentMessage(\n        address indexed target,\n        address sender,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n\n    /**\n     * @notice Additional event data to emit, required as of Bedrock. Cannot be merged with the\n     *         SentMessage event without breaking the ABI of this contract, this is good enough.\n     *\n     * @param sender Address of the sender of the message.\n     * @param value  ETH value sent along with the message to the recipient.\n     */\n    event SentMessageExtension1(address indexed sender, uint256 value);\n\n    /**\n     * @notice Emitted whenever a message is successfully relayed on this chain.\n     *\n     * @param msgHash Hash of the message that was relayed.\n     */\n    event RelayedMessage(bytes32 indexed msgHash);\n\n    /**\n     * @notice Emitted whenever a message fails to be relayed on this chain.\n     *\n     * @param msgHash Hash of the message that failed to be relayed.\n     */\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /**\n     * @param _otherMessenger Address of the messenger on the paired chain.\n     */\n    constructor(address _otherMessenger) {\n        OTHER_MESSENGER = _otherMessenger;\n    }\n\n    /**\n     * @notice Sends a message to some target address on the other chain. Note that if the call\n     *         always reverts, then the message will be unrelayable, and any ETH sent will be\n     *         permanently locked. The same will occur if the target on the other chain is\n     *         considered unsafe (see the _isUnsafeTarget() function).\n     *\n     * @param _target      Target contract or wallet address.\n     * @param _message     Message to trigger the target address with.\n     * @param _minGasLimit Minimum gas limit that the message can be executed with.\n     */\n    function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _minGasLimit\n    ) external payable {\n        // Triggers a message to the other messenger. Note that the amount of gas provided to the\n        // message is the amount of gas requested by the user PLUS the base gas value. We want to\n        // guarantee the property that the call to the target contract will always have at least\n        // the minimum gas limit specified by the user.\n        _sendMessage(\n            OTHER_MESSENGER,\n            baseGas(_message, _minGasLimit),\n            msg.value,\n            abi.encodeWithSelector(\n                this.relayMessage.selector,\n                messageNonce(),\n                msg.sender,\n                _target,\n                msg.value,\n                _minGasLimit,\n                _message\n            )\n        );\n\n        emit SentMessage(_target, msg.sender, _message, messageNonce(), _minGasLimit);\n        emit SentMessageExtension1(msg.sender, msg.value);\n\n        unchecked {\n            ++msgNonce;\n        }\n    }\n\n    /**\n     * @notice Relays a message that was sent by the other CrossDomainMessenger contract. Can only\n     *         be executed via cross-chain call from the other messenger OR if the message was\n     *         already received once and is currently being replayed.\n     *\n     * @param _nonce       Nonce of the message being relayed.\n     * @param _sender      Address of the user who sent the message.\n     * @param _target      Address that the message is targeted at.\n     * @param _value       ETH value to send with the message.\n     * @param _minGasLimit Minimum amount of gas that the message can be executed with.\n     * @param _message     Message to send to the target.\n     */\n    function relayMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _minGasLimit,\n        bytes calldata _message\n    ) external payable {\n        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\n        require(\n            version < 2,\n            \"CrossDomainMessenger: only version 0 or 1 messages are supported at this time\"\n        );\n\n        // If the message is version 0, then it's a migrated legacy withdrawal. We therefore need\n        // to check that the legacy version of the message has not already been relayed.\n        if (version == 0) {\n            bytes32 oldHash = Hashing.hashCrossDomainMessageV0(_target, _sender, _message, _nonce);\n            require(\n                successfulMessages[oldHash] == false,\n                \"CrossDomainMessenger: legacy withdrawal already relayed\"\n            );\n        }\n\n        // We use the v1 message hash as the unique identifier for the message because it commits\n        // to the value and minimum gas limit of the message.\n        bytes32 versionedHash = Hashing.hashCrossDomainMessageV1(\n            _nonce,\n            _sender,\n            _target,\n            _value,\n            _minGasLimit,\n            _message\n        );\n\n        // Check if the reentrancy lock for the `versionedHash` is already set.\n        if (reentrancyLocks[versionedHash]) {\n            revert(\"ReentrancyGuard: reentrant call\");\n        }\n        // Trigger the reentrancy lock for `versionedHash`\n        reentrancyLocks[versionedHash] = true;\n\n        if (_isOtherMessenger()) {\n            // These properties should always hold when the message is first submitted (as\n            // opposed to being replayed).\n            assert(msg.value == _value);\n            assert(!failedMessages[versionedHash]);\n        } else {\n            require(\n                msg.value == 0,\n                \"CrossDomainMessenger: value must be zero unless message is from a system address\"\n            );\n\n            require(\n                failedMessages[versionedHash],\n                \"CrossDomainMessenger: message cannot be replayed\"\n            );\n        }\n\n        require(\n            _isUnsafeTarget(_target) == false,\n            \"CrossDomainMessenger: cannot send message to blocked system address\"\n        );\n\n        require(\n            successfulMessages[versionedHash] == false,\n            \"CrossDomainMessenger: message has already been relayed\"\n        );\n\n        xDomainMsgSender = _sender;\n        bool success = SafeCall.callWithMinGas(_target, _minGasLimit, _value, _message);\n        xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\n\n        if (success) {\n            successfulMessages[versionedHash] = true;\n            emit RelayedMessage(versionedHash);\n        } else {\n            failedMessages[versionedHash] = true;\n            emit FailedRelayedMessage(versionedHash);\n\n            // Revert in this case if the transaction was triggered by the estimation address. This\n            // should only be possible during gas estimation or we have bigger problems. Reverting\n            // here will make the behavior of gas estimation change such that the gas limit\n            // computed will be the amount required to relay the message, even if that amount is\n            // greater than the minimum gas limit specified by the user.\n            if (tx.origin == Constants.ESTIMATION_ADDRESS) {\n                revert(\"CrossDomainMessenger: failed to relay message\");\n            }\n        }\n\n        // Clear the reentrancy lock for `versionedHash`\n        reentrancyLocks[versionedHash] = false;\n    }\n\n    /**\n     * @notice Retrieves the address of the contract or wallet that initiated the currently\n     *         executing message on the other chain. Will throw an error if there is no message\n     *         currently being executed. Allows the recipient of a call to see who triggered it.\n     *\n     * @return Address of the sender of the currently executing message on the other chain.\n     */\n    function xDomainMessageSender() external view returns (address) {\n        require(\n            xDomainMsgSender != Constants.DEFAULT_L2_SENDER,\n            \"CrossDomainMessenger: xDomainMessageSender is not set\"\n        );\n\n        return xDomainMsgSender;\n    }\n\n    /**\n     * @notice Retrieves the next message nonce. Message version will be added to the upper two\n     *         bytes of the message nonce. Message version allows us to treat messages as having\n     *         different structures.\n     *\n     * @return Nonce of the next message to be sent, with added message version.\n     */\n    function messageNonce() public view returns (uint256) {\n        return Encoding.encodeVersionedNonce(msgNonce, MESSAGE_VERSION);\n    }\n\n    /**\n     * @notice Computes the amount of gas required to guarantee that a given message will be\n     *         received on the other chain without running out of gas. Guaranteeing that a message\n     *         will not run out of gas is important because this ensures that a message can always\n     *         be replayed on the other chain if it fails to execute completely.\n     *\n     * @param _message     Message to compute the amount of required gas for.\n     * @param _minGasLimit Minimum desired gas limit when message goes to target.\n     *\n     * @return Amount of gas required to guarantee message receipt.\n     */\n    function baseGas(bytes calldata _message, uint32 _minGasLimit) public pure returns (uint64) {\n        // We peform the following math on uint64s to avoid overflow errors. Multiplying the\n        // by MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR would otherwise limit the _minGasLimit to\n        // type(uint32).max / MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR ~= 4.2m.\n        return\n            // Dynamic overhead\n            ((uint64(_minGasLimit) * MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR) /\n                MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR) +\n            // Calldata overhead\n            (uint64(_message.length) * MIN_GAS_CALLDATA_OVERHEAD) +\n            // Constant overhead\n            MIN_GAS_CONSTANT_OVERHEAD;\n    }\n\n    /**\n     * @notice Intializer.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __CrossDomainMessenger_init() internal onlyInitializing {\n        xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\n    }\n\n    /**\n     * @notice Sends a low-level message to the other messenger. Needs to be implemented by child\n     *         contracts because the logic for this depends on the network where the messenger is\n     *         being deployed.\n     *\n     * @param _to       Recipient of the message on the other chain.\n     * @param _gasLimit Minimum gas limit the message can be executed with.\n     * @param _value    Amount of ETH to send with the message.\n     * @param _data     Message data.\n     */\n    function _sendMessage(\n        address _to,\n        uint64 _gasLimit,\n        uint256 _value,\n        bytes memory _data\n    ) internal virtual;\n\n    /**\n     * @notice Checks whether the message is coming from the other messenger. Implemented by child\n     *         contracts because the logic for this depends on the network where the messenger is\n     *         being deployed.\n     *\n     * @return Whether the message is coming from the other messenger.\n     */\n    function _isOtherMessenger() internal view virtual returns (bool);\n\n    /**\n     * @notice Checks whether a given call target is a system address that could cause the\n     *         messenger to peform an unsafe action. This is NOT a mechanism for blocking user\n     *         addresses. This is ONLY used to prevent the execution of messages to specific\n     *         system addresses that could cause security issues, e.g., having the\n     *         CrossDomainMessenger send messages to itself.\n     *\n     * @param _target Address of the contract to check.\n     *\n     * @return Whether or not the address is an unsafe system address.\n     */\n    function _isUnsafeTarget(address _target) internal view virtual returns (bool);\n}"
    },
    {
      "filename": "packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\n\n/**\n * @custom:legacy\n * @title CrossDomainMessengerLegacySpacer0\n * @notice Contract only exists to add a spacer to the CrossDomainMessenger where the\n *         libAddressManager variable used to exist. Must be the first contract in the inheritance\n *         tree of the CrossDomainMessenger.\n */\ncontract CrossDomainMessengerLegacySpacer0 {\n    /**\n     * @custom:legacy\n     * @custom:spacer libAddressManager\n     * @notice Spacer for backwards compatibility.\n     */\n    address private spacer_0_0_20;\n}\n\n/**\n * @custom:legacy\n * @title CrossDomainMessengerLegacySpacer1\n * @notice Contract only exists to add a spacer to the CrossDomainMessenger where the\n *         PausableUpgradable and OwnableUpgradeable variables used to exist. Must be\n *         the third contract in the inheritance tree of the CrossDomainMessenger.\n */\ncontract CrossDomainMessengerLegacySpacer1 {\n    /**\n     * @custom:legacy\n     * @custom:spacer __gap\n     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin\n     *         ContextUpgradable via OwnableUpgradeable.\n     *\n     */\n    uint256[50] private spacer_1_0_1600;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer _owner\n     * @notice Spacer for backwards compatibility.\n     *         Come from OpenZeppelin OwnableUpgradeable.\n     */\n    address private spacer_51_0_20;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer __gap\n     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin\n     *         ContextUpgradable via PausableUpgradable.\n     */\n    uint256[49] private spacer_52_0_1568;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer _paused\n     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin\n     *         PausableUpgradable.\n     */\n    bool private spacer_101_0_1;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer __gap\n     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin\n     *         PausableUpgradable.\n     */\n    uint256[49] private spacer_102_0_1568;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer ReentrancyGuardUpgradeable's `_status` field.\n     * @notice Spacer for backwards compatibility\n     */\n    uint256 private spacer_151_0_32;\n\n    /**\n     * @custom:spacer ReentrancyGuardUpgradeable\n     * @notice Spacer for backwards compatibility\n     */\n    uint256[49] private __gap_reentrancy_guard;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer blockedMessages\n     * @notice Spacer for backwards compatibility.\n     */\n    mapping(bytes32 => bool) private spacer_201_0_32;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer relayedMessages\n     * @notice Spacer for backwards compatibility.\n     */\n    mapping(bytes32 => bool) private spacer_202_0_32;\n}\n\n/**\n * @custom:upgradeable\n * @title CrossDomainMessenger\n * @notice CrossDomainMessenger is a base contract that provides the core logic for the L1 and L2\n *         cross-chain messenger contracts. It's designed to be a universal interface that only\n *         needs to be extended slightly to provide low-level message passing functionality on each\n *         chain it's deployed on. Currently only designed for message passing between two paired\n *         chains and does not support one-to-many interactions.\n *\n *         Any changes to this contract MUST result in a semver bump for contracts that inherit it.\n */\nabstract contract CrossDomainMessenger is\n    CrossDomainMessengerLegacySpacer0,\n    Initializable,\n    CrossDomainMessengerLegacySpacer1\n{\n    /**\n     * @notice Current message version identifier.\n     */\n    uint16 public constant MESSAGE_VERSION = 1;\n\n    /**\n     * @notice Constant overhead added to the base gas for a message.\n     */\n    uint64 public constant MIN_GAS_CONSTANT_OVERHEAD = 200_000;\n\n    /**\n     * @notice Numerator for dynamic overhead added to the base gas for a message.\n     */\n    uint64 public constant MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR = 1016;\n\n    /**\n     * @notice Denominator for dynamic overhead added to the base gas for a message.\n     */\n    uint64 public constant MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR = 1000;\n\n    /**\n     * @notice Extra gas added to base gas for each byte of calldata in a message.\n     */\n    uint64 public constant MIN_GAS_CALLDATA_OVERHEAD = 16;\n\n    /**\n     * @notice Address of the paired CrossDomainMessenger contract on the other chain.\n     */\n    address public immutable OTHER_MESSENGER;\n\n    /**\n     * @notice Mapping of message hashes to boolean receipt values. Note that a message will only\n     *         be present in this mapping if it has successfully been relayed on this chain, and\n     *         can therefore not be relayed again.\n     */\n    mapping(bytes32 => bool) public successfulMessages;\n\n    /**\n     * @notice Address of the sender of the currently executing message on the other chain. If the\n     *         value of this variable is the default value (0x00000000...dead) then no message is\n     *         currently being executed. Use the xDomainMessageSender getter which will throw an\n     *         error if this is the case.\n     */\n    address internal xDomainMsgSender;\n\n    /**\n     * @notice Nonce for the next message to be sent, without the message version applied. Use the\n     *         messageNonce getter which will insert the message version into the nonce to give you\n     *         the actual nonce to be used for the message.\n     */\n    uint240 internal msgNonce;\n\n    /**\n     * @notice Mapping of message hashes to a boolean if and only if the message has failed to be\n     *         executed at least once. A message will not be present in this mapping if it\n     *         successfully executed on the first attempt.\n     */\n    mapping(bytes32 => bool) public failedMessages;\n\n    /**\n     * @notice A mapping of hashes to reentrancy locks.\n     */\n    mapping(bytes32 => bool) internal reentrancyLocks;\n\n    /**\n     * @notice Reserve extra slots in the storage layout for future upgrades.\n     *         A gap size of 41 was chosen here, so that the first slot used in a child contract\n     *         would be a multiple of 50.\n     */\n    uint256[41] private __gap;\n\n    /**\n     * @notice Emitted whenever a message is sent to the other chain.\n     *\n     * @param target       Address of the recipient of the message.\n     * @param sender       Address of the sender of the message.\n     * @param message      Message to trigger the recipient address with.\n     * @param messageNonce Unique nonce attached to the message.\n     * @param gasLimit     Minimum gas limit that the message can be executed with.\n     */\n    event SentMessage(\n        address indexed target,\n        address sender,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n\n    /**\n     * @notice Additional event data to emit, required as of Bedrock. Cannot be merged with the\n     *         SentMessage event without breaking the ABI of this contract, this is good enough.\n     *\n     * @param sender Address of the sender of the message.\n     * @param value  ETH value sent along with the message to the recipient.\n     */\n    event SentMessageExtension1(address indexed sender, uint256 value);\n\n    /**\n     * @notice Emitted whenever a message is successfully relayed on this chain.\n     *\n     * @param msgHash Hash of the message that was relayed.\n     */\n    event RelayedMessage(bytes32 indexed msgHash);\n\n    /**\n     * @notice Emitted whenever a message fails to be relayed on this chain.\n     *\n     * @param msgHash Hash of the message that failed to be relayed.\n     */\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /**\n     * @param _otherMessenger Address of the messenger on the paired chain.\n     */\n    constructor(address _otherMessenger) {\n        OTHER_MESSENGER = _otherMessenger;\n    }\n\n    /**\n     * @notice Sends a message to some target address on the other chain. Note that if the call\n     *         always reverts, then the message will be unrelayable, and any ETH sent will be\n     *         permanently locked. The same will occur if the target on the other chain is\n     *         considered unsafe (see the _isUnsafeTarget() function).\n     *\n     * @param _target      Target contract or wallet address.\n     * @param _message     Message to trigger the target address with.\n     * @param _minGasLimit Minimum gas limit that the message can be executed with.\n     */\n    function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _minGasLimit\n    ) external payable {\n        // Triggers a message to the other messenger. Note that the amount of gas provided to the\n        // message is the amount of gas requested by the user PLUS the base gas value. We want to\n        // guarantee the property that the call to the target contract will always have at least\n        // the minimum gas limit specified by the user.\n        _sendMessage(\n            OTHER_MESSENGER,\n            baseGas(_message, _minGasLimit),\n            msg.value,\n            abi.encodeWithSelector(\n                this.relayMessage.selector,\n                messageNonce(),\n                msg.sender,\n                _target,\n                msg.value,\n                _minGasLimit,\n                _message\n            )\n        );\n\n        emit SentMessage(_target, msg.sender, _message, messageNonce(), _minGasLimit);\n        emit SentMessageExtension1(msg.sender, msg.value);\n\n        unchecked {\n            ++msgNonce;\n        }\n    }\n\n    /**\n     * @notice Relays a message that was sent by the other CrossDomainMessenger contract. Can only\n     *         be executed via cross-chain call from the other messenger OR if the message was\n     *         already received once and is currently being replayed.\n     *\n     * @param _nonce       Nonce of the message being relayed.\n     * @param _sender      Address of the user who sent the message.\n     * @param _target      Address that the message is targeted at.\n     * @param _value       ETH value to send with the message.\n     * @param _minGasLimit Minimum amount of gas that the message can be executed with.\n     * @param _message     Message to send to the target.\n     */\n    function relayMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _minGasLimit,\n        bytes calldata _message\n    ) external payable {\n        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\n        require(\n            version < 2,\n            \"CrossDomainMessenger: only version 0 or 1 messages are supported at this time\"\n        );\n\n        // If the message is version 0, then it's a migrated legacy withdrawal. We therefore need\n        // to check that the legacy version of the message has not already been relayed.\n        if (version == 0) {\n            bytes32 oldHash = Hashing.hashCrossDomainMessageV0(_target, _sender, _message, _nonce);\n            require(\n                successfulMessages[oldHash] == false,\n                \"CrossDomainMessenger: legacy withdrawal already relayed\"\n            );\n        }\n\n        // We use the v1 message hash as the unique identifier for the message because it commits\n        // to the value and minimum gas limit of the message.\n        bytes32 versionedHash = Hashing.hashCrossDomainMessageV1(\n            _nonce,\n            _sender,\n            _target,\n            _value,\n            _minGasLimit,\n            _message\n        );\n\n        // Check if the reentrancy lock for the `versionedHash` is already set.\n        if (reentrancyLocks[versionedHash]) {\n            revert(\"ReentrancyGuard: reentrant call\");\n        }\n        // Trigger the reentrancy lock for `versionedHash`\n        reentrancyLocks[versionedHash] = true;\n\n        if (_isOtherMessenger()) {\n            // These properties should always hold when the message is first submitted (as\n            // opposed to being replayed).\n            assert(msg.value == _value);\n            assert(!failedMessages[versionedHash]);\n        } else {\n            require(\n                msg.value == 0,\n                \"CrossDomainMessenger: value must be zero unless message is from a system address\"\n            );\n\n            require(\n                failedMessages[versionedHash],\n                \"CrossDomainMessenger: message cannot be replayed\"\n            );\n        }\n\n        require(\n            _isUnsafeTarget(_target) == false,\n            \"CrossDomainMessenger: cannot send message to blocked system address\"\n        );\n\n        require(\n            successfulMessages[versionedHash] == false,\n            \"CrossDomainMessenger: message has already been relayed\"\n        );\n\n        xDomainMsgSender = _sender;\n        bool success = SafeCall.callWithMinGas(_target, _minGasLimit, _value, _message);\n        xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\n\n        if (success) {\n            successfulMessages[versionedHash] = true;\n            emit RelayedMessage(versionedHash);\n        } else {\n            failedMessages[versionedHash] = true;\n            emit FailedRelayedMessage(versionedHash);\n\n            // Revert in this case if the transaction was triggered by the estimation address. This\n            // should only be possible during gas estimation or we have bigger problems. Reverting\n            // here will make the behavior of gas estimation change such that the gas limit\n            // computed will be the amount required to relay the message, even if that amount is\n            // greater than the minimum gas limit specified by the user."
    }
  ]
}