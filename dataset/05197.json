{
  "Title": "[M-06] complete liquidity removal will result in permanent disable of the liquidity addition and prevent minting shares for the liquidity providers.",
  "Content": "\n<https://github.com/code-423n4/2024-02-hydradx/blob/603187123a20e0cb8a7ea85c6a6d718429caad8d/HydraDX-node/pallets/omnipool/src/lib.rs#L612-L621>\n\n### Impact\n\nThis vulnerability will lead to prevent any liquidity provider from adding liquidity and prevent them from minting new shares; so this is considered a huge loss of funds for the users and the protocol.\n\n1. No New Liquidity - Users can no longer add liquidity to the pool, hindering its growth and potential.\n2. Complete liquidity removal shuts down the pool, preventing any future activity.\n3. Financial losses for the protocol - It loses the benefits of increased liquidity and potential fees from user activity.\n\n### Proof of Concept\n\nAdding a new token to the omnipool requires an initial liquidity deposit. This initial deposit mints the first batch of shares. Subsequent liquidity additions mint new shares proportionally to the existing total shares, ensuring a fair distribution based on the pool's current size.\n\nIn the function `remove_liquidity` it is allowed to remove all amount of liquidity from the pool, which means burning all amount of the shares from the pool, as shown [here](https://github.com/code-423n4/2024-02-hydradx/blob/603187123a20e0cb8a7ea85c6a6d718429caad8d/HydraDX-node/pallets/omnipool/src/lib.rs#L773-L790).\n\n```rust\n                        let state_changes = hydra_dx_math::omnipool::calculate_remove_liquidity_state_changes(\n                                &(&asset_state).into(),\n                                amount,\n                                &(&position).into(),\n                                I129 {\n                                        value: current_imbalance.value,\n                                        negative: current_imbalance.negative,\n                                },\n                                current_hub_asset_liquidity,\n                                withdrawal_fee,\n                        )\n                        .ok_or(ArithmeticError::Overflow)?;\n\n\n                        let new_asset_state = asset_state\n                                .clone()\n                                .delta_update(&state_changes.asset)\n                                .ok_or(ArithmeticError::Overflow)?;\n```\n\nThe function `calculate_remove_liquidity_state_changes` calculates the shares to be burnt and the `delta_update` function removes them.\n\nIf all liquidity shares have been removed from any pool, protocol shares and user shares are removed, making the `asset_reserve` equal to zero and `shares` equal to zero, which will prevent any liquidity from been added because the function `add_liquidity` does not handle the situation where there is no liquidity in the pool. As shown in the `add_liquidity` function, it calls `calculate_add_liquidity_state_changes` which calculates the shares to be minted to the LP as shown [here](https://github.com/code-423n4/2024-02-hydradx/blob/603187123a20e0cb8a7ea85c6a6d718429caad8d/HydraDX-node/math/src/omnipool/math.rs#L267-L269).\n\n```rust\n        let delta_shares_hp = shares_hp\n                .checked_mul(amount_hp)\n                .and_then(|v| v.checked_div(reserve_hp))?;\n```\n\nThe state of the pool after all liquidity have been removed `asset_reserve = 0, shares = 0`. Since there is no liquidity in the pool so the `reserve_hp` will be equal to zero, so this part will always return error, so this function will always revert.\n\nEven if any user donates some assets to prevent this function from reverting, the liquidity provider will always receive zero shares, since the `delta_shares_hp` will always equal to zero, which is considered loss of funds for the user and the protocol.\n\nThe bad state that will cause this vulnerability:<br>\n**Token has been added to the pool but all liquidity has been removed from it**.\n\n### Coded Poc\n\nConsider adding this test in `remove_liquidity.rs` test [file](https://github.com/code-423n4/2024-02-hydradx/blob/main/HydraDX-node/pallets/omnipool/src/tests/remove_liquidity.rs), and then run it to see the logs:\n\n```rust\n#[test]\nfn full_liquidity_removal_then_add_liquidity() {\n\tExtBuilder::default()\n\t\t.with_endowed_accounts(vec![\n\t\t\t(Omnipool::protocol_account(), DAI, 1000 * ONE),\n\t\t\t(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),\n\t\t\t(LP2, 1_000, 2000 * ONE),\n\t\t\t(LP1, 1_000, 5000 * ONE),\n\t\t])\n\t\t.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))\n\t\t.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// let token_amount = 2000 * ONE;\n\n\t\t\tlet liq_added = 400 * ONE;\n\t\t\tlet lp1_position_id = <NextPositionId<Test>>::get();\n\t\t\tassert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));\n\n\t\t\tlet liq_removed = 400 * ONE;\n\t\t\tprintln!(\n\t\t\t\t\"asset state before liquidity removal {:?} \",\n\t\t\t\tOmnipool::load_asset_state(1000).unwrap()\n\t\t\t);\n\n\t\t\tassert_ok!(Omnipool::remove_liquidity(\n\t\t\t\tRuntimeOrigin::signed(LP1),\n\t\t\t\tlp1_position_id,\n\t\t\t\tliq_removed\n\t\t\t));\n\n\t\t\tassert!(\n\t\t\t\tPositions::<Test>::get(lp1_position_id).is_none(),\n\t\t\t\t\"Position still found\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tget_mock_minted_position(lp1_position_id).is_none(),\n\t\t\t\t\"Position instance was not burned\"\n\t\t\t);\n\t\t\tlet pos = Positions::<Test>::get(2);\n\t\t\tprintln!(\" the lp2_position before all liquidity removal: {:?}\", pos.unwrap());\n\t\t\t// lp2 remove his all initial liquidity\n\t\t\tassert_ok!(Omnipool::remove_liquidity(RuntimeOrigin::signed(LP2), 2, 2000 * ONE));\n\t\t\tlet lp2_position = lp1_position_id - 1;\n\n\t\t\tassert!(Positions::<Test>::get(lp2_position).is_none(), \"Position still found\");\n\n\t\t\tprintln!(\n\t\t\t\t\"the final state after all liquidity has been removed: {:?} \",\n\t\t\t\tOmnipool::load_asset_state(1000).unwrap()\n\t\t\t);\n\t\t\tlet liq_added = 400 * ONE;\n\t\t\tassert_noop!(\n\t\t\t\tOmnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added),\n\t\t\t\tArithmeticError::Overflow\n\t\t\t);\n\t\t\t// this makes sure that there is no position created after\n\t\t\tassert!(Positions::<Test>::get(lp2_position).is_none(), \"Position still found\");\n\n\t\t\tprintln!(\n\t\t\t\t\"the new state after liquidity provision reverted: {:?}\",\n\t\t\t\tOmnipool::load_asset_state(1000).unwrap()\n\t\t\t);\n\t\t});\n}\n```\n\nThe logs will be:\n\n```rust\nrunning 1 test\nasset state before liquidity removal AssetReserveState { reserve: 2400000000000000, hub_reserve: 1560000000000000, shares: 2400000000000000, protocol_shares: 0, cap: 1000000000000000000, tradable: SELL | BUY | ADD_LIQUIDITY | REMOVE_LIQUIDITY } \n the lp2_position before all liquidity removal: Position { asset_id: 1000, amount: 2000000000000000, shares: 2000000000000000, price: (650000000000000000, 1000000000000000000) }\nthe final state after all liquidity has been removed: AssetReserveState { reserve: 0, hub_reserve: 0, shares: 0, protocol_shares: 0, cap: 1000000000000000000, tradable: SELL | BUY | ADD_LIQUIDITY | REMOVE_LIQUIDITY } \nthe new state after liquidity provision reverted: AssetReserveState { reserve: 0, hub_reserve: 0, shares: 0, protocol_shares: 0, cap: 1000000000000000000, tradable: SELL | BUY | ADD_LIQUIDITY | REMOVE_LIQUIDITY }\n```\n\nThis illustrates that the `add_liquidity` function failed after `lp2` and `lp1` removed their entire liquidity from the pool.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nAdd a special behaviour to the function `add_liquidity` to handle the situation of no initial liquidity. The mitigation can be done by:\n\n* When the pool initially has no shares (total shares equal zero), newly added assets from a liquidity provider trigger the minting of shares in an amount equal to the added asset value\n\nAs happening in the function `add_token()` [here](https://github.com/code-423n4/2024-02-hydradx/blob/603187123a20e0cb8a7ea85c6a6d718429caad8d/HydraDX-node/pallets/omnipool/src/lib.rs#L532).\n\n```rust\n                                delta_shares: BalanceUpdate::Increase(amount),\n```\n\n### Assessed type\n\nContext\n\n**[Lambda (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-02-hydradx-findings/issues/75#issuecomment-1985613497):**\n > The warden identified that the complete removal of liquidity can be problematic, although from a different angle and without mentioning the full impact. Giving partial credit for this.\n\n**[castle_chain (warden) commented](https://github.com/code-423n4/2024-02-hydradx-findings/issues/75#issuecomment-1993046598):**\n > @Lambda - I am requesting that this issue be considered as a solo medium for the following reasons:\n> \n> Firstly, this was marked as a duplicate of Issue [#86](https://github.com/code-423n4/2024-02-hydradx-findings/issues/86). However, Issue #86 has nothing to do with this finding for these reasons:\n>* Issue #86 refers to an issue in the stableswap pallet, not the omnipool. **This finding, on the other hand, refers to an issue in the omnipool pallet.**\n>* While removing all liquidity from a pool in the stableswap will always fail according to Issue #86, removing all liquidity from a pool in the omnipool pallet will succeed, but it will cause a permanent DoS (Denial-of-Service) attack on the pool by permanently disabling liquidity addition due to the division by zero which will throw overflow error mentioned in the submitted report and the PoC.\n>\n> As demonstrated, these are two distinct issues. Issue #86 has an impact of (temporary) locked funds, according to the judge's comment:\n> > This can lead to (temporary) locked funds in edge cases, so Medium is appropriate here.\n> \t  \n> **In contrast, my report highlights a permanent DoS impact to the function `add_liquidity`, `sell`,and `buy`.**\n> \t\t \n> So the two findings have two completely different locations, two different impacts, and two different affected functions:\n> \n> | Category      | Issue 86 | Issue 75 (current) |\n> |------------------|-------------------|--------------|\n> | Location (pallet)       | stableswap           | omnipool       |\n> | Impact         | temporary DoS            | permanent  DoS     |\n> | Can complete liquidity removal be done ?   | no ( this is the problem )    | yes ( this is the cause of the problem )|\n> | Affected function  (disabled function)     | remove_liquidity_one_asset   (liquidity removal always failed)     | add_liquidity (liquidity addition always failed)   |\n> | Root cause       | overflow          | overflow   |\n> | Mitigation      | allow multi-asset withdrawal in the staple swap pallet      | handle the situation of no liquidity exists in the pool   |\n> \n> The judge mentioned that the report did not mention the full impact. While I described it in the impact section, let me clarify:\n>\n> ### The full impact mentioned in the report: permanent disable of liquidity addition `==` permanent DoS of the function `add_liquidity`. \n> Since this is an edge case, which can simply happen, that causes a permanent DoS forever, it does not require an attacker or an attack to be triggered and cause damage to the protocol. **However, an attacker could trigger this edge case as the PoC test got performed, you can consider the `LP2` as the attacker, who can withdraw all the liquidity that he possessed leaving the pool in DoS state.** The DoS can also happen without an attacker, simply by users removing all liquidity from the pool.\n> \n> I mentioned complete liquidity removal to encompass all scenarios where this issue can cause a DoS and disable liquidity addition and trading. Therefore, I stated:\n> \n> > If all liquidity shares have been removed from any pool.\n> \n> This includes:\n> * A single malicious user possessing all the liquidity shares of the pool and removing them (attack or normal action), the user `LP2` mentioned in the PoC can be the attacker. \n> * All liquidity providers removing their liquidity (normal action).\n> \n> ### POC for the attack done by a malicious user\n> \n> Please consider running my submitted PoC to check that the attack flow got executed successfully, you can also consider `LP2` as the `position_owner`. \n> \n> **The attacker also can be the `position_owner` which is untrusted entity, or another malicious user, or as normal action done by the liquidity providers; the `position_owner`, who is the initial liquidity provider, can perform this attack and DoS the entire pool after adding the token by the `authority_origin` immediately.**\n>\n> The attack flow:\n> 1. The `asset_a` got added by calling the `add_token` function this function mint the `shares` of the initial liquidity to the `position_owner` as shown [here](https://github.com/code-423n4/2024-02-hydradx/blob/603187123a20e0cb8a7ea85c6a6d718429caad8d/HydraDX-node/pallets/omnipool/src/lib.rs#L487-L496).\n> 2. The `position_owner` removed all his liquidity from the pool and burnt his all shares by calling the function `remove_liquidity` [here](https://github.com/code-423n4/2024-02-hydradx/blob/603187123a20e0cb8a7ea85c6a6d718429caad8d/HydraDX-node/pallets/omnipool/src/lib.rs#L716-L720), passing the amount of `shares` minted to him as the `amount` to this function and removed all the liquidity from the pool. \n> 3. After the entire liquidity removal, all liquidity providers will be prevented from adding liquidity to the `asset_a` pool, due to the fact that the reserve of the `asset_a` of the pool now is equal to zero as I tested in my coded POC. The function `add_liquidity` will always revert due to division by zero error, because the division performed, as shown here:\n>\n> ```rust \n>         let delta_shares_hp = shares_hp\n>                 .checked_mul(amount_hp)\n>                 .and_then(|v| v.checked_div(reserve_hp))?;\n> ```\n>\n> ### Lock of funds risk if someone sends some amount of asset to the pool after the entire liquidity has been removed. \n>  As mentioned, there is also another DoS and lock of funds of the liquidity providers, if the entire liquidity removal of `asset_a` happens and then any user send some amount of `asset_a` to the pool, this will allow the execution of the function `add_liquidity`, but it will returns zero amount of `shares` to the LP, so it will cause lock of funds for the liquidity provider forever. \n> \n> The impact I mentioned in the report clearly demonstrates the impact on both the protocol and the users. The first two impacts clearly emphasize the DoS that will occur and the third describes the financial losses of the protocol.\n> \n> **Therefore, this finding suffices medium, as per the severity guidelines Med requires \"Assets not at direct risk, but the function of the protocol or its availability could be impacted\".**\n> \n> When writing the proof-of-concept which submitted during the audit, I focused on demonstrating how this edge case can occur. This provides the sponsor with a clear explanation of how to mitigate this issue and pinpoint the location of the error. Therefore, the PoC includes an `assert_noop` statement to ensure that calling the `add_liquidity()` function after the entire liquidity has been removed from the pool, it will revert with the error `ArithmeticError::Overflow`, which indicates an error in the function `calculate_add_liquidity_state_changes`.\n>\n> Due to this, the function `add_liquidity` will always revert, meaning the pool will always be empty, so **the trading will also got disabled forever, which is considered a DoS attack.** \n\n**[castle_chain (warden) commented](https://github.com/code-423n4/2024-02-hydradx-findings/issues/75#issuecomment-1993060305):**\n> I am providing this additional PoC to prove that sending any non-zero amount of any asset after the entire liquidity removal from the omnipool will cause lock of all funds forever to all liquidity providers.\n> \n> ### PoC to test `add_liquidity` after all the liquidity had been removed and the `asset_reserve` is not empty\n> \n> This DoS attack will happen when the entire liquidity got removed from the pool of `asset_a`, and the*attacker sends minimum non-zero amount of `asset_a ` to the omnipool pallet account.\n> \n> Consider adding this test in `remove_liquidity.rs` test [file](https://github.com/code-423n4/2024-02-hydradx/blob/main/HydraDX-node/pallets/omnipool/src/tests/remove_liquidity.rs), and then run it to see the logs.\n>\n> The PoC is commented with all the details of the attack:\n> 1. LP2 provided 2000 units of `asset_a` by the function `with_token` of the test. the pool state  and the LP2 position are now: \n>\n> ```rust \n> asset state before liquidity removal AssetReserveState {\n> \treserve: 2000000000000000, hub_reserve: 1300000000000000,\n> \tshares: 2000000000000000, protocol_shares: 0\n> \t\n> \tthe lp2_position before all liquidity removal:\n> \tPosition { asset_id: 1000, amount: 2000000000000000,\n> \t\tshares: 2000000000000000\n> ```\n>\n> 2. The LP2 removed his entire liquidity from the pool, so the pool state now is:\n>\n> ```rust\n> the final state after all liquidity has been removed:\n> AssetReserveState { reserve: 0, hub_reserve: 0\n> \t, shares: 0, protocol_shares: 0\n> ```\n>\n> 3. The attacker `LP1` sends one unit of `asset_a` to the pool, and the `LP2` adds liquidity of `400` units of `asset_a`. This will result in asset state of `asset_a` in the omnipool to be `400 + 1 = 401`, and the shares allocated and minted to `LP2` position will be zero.\n>\n> ```rust \n>  the lp2_position  after adding liquidity of 400 units of asset_a: \n> Position { asset_id: 1000, amount: 400000000000000\n> \t,shares: 0\t\n> \t\n> \tthe new state after liquidity provision had done but NO shares got minted to LP2:\n> \tAssetReserveState { reserve: 401000000000000,\n> \t\thub_reserve: 0, shares: 0, protocol_shares: 0\n> ```\n> As shown, the total shares in the pool is equal to zero, and the position shares of the `LP2` is equal to zero, which is consider a permanent lock of funds. \n> \n> ### PoC \n>\n> ```rust \n> #[test]\n> fn full_liquidity_removal_then_add_liquidity() {\n> \tExtBuilder::default()\n> \t\t.with_endowed_accounts(vec![\n> \t\t\t(Omnipool::protocol_account(), DAI, 1000 * ONE),\n> \t\t\t(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),\n> \t\t\t(LP2, 1_000, 2000 * ONE),\n> \t\t\t(LP1, 1_000, 5000 * ONE),\n> \t\t])\n> \t\t.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))\n> \t\t.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE) // this is the first liquidity addition done by the LP2\n> \t\t.build()\n> \t\t.execute_with(|| {\n> \t\t\tlet asset_a = 1_000;\n> \t\t\t// how to perform this DoS attack.\n> \t\t\t// lp2 provides 2000 units of asset_a, and remove all of them\n> \t\t\t// lp1 send some assets to the pool\n> \t\t\t// this will prevent the function add_liquidity from the revert\n> \t\t\t// lp2 will add liquidity of 400 units of asset_a and will receive zero shares.\n> \n> \t\t\t// the lp2 position is the last position which is the (next position id - 1)\n> \t\t\tlet lp2_position_id = <NextPositionId<Test>>::get() - 1;\n> \t\t\t// get asset_a state.\n> \t\t\tprintln!(\n> \t\t\t\t\"asset state before the entire liquidity removal {:?} \",\n> \t\t\t\tOmnipool::load_asset_state(asset_a).unwrap()\n> \t\t\t);\n> \t\t\tlet pos = Positions::<Test>::get(lp2_position_id);\n> \t\t\tprintln!(\" the lp2_position before all liquidity removal: {:?}\", pos.unwrap());\n> \t\t\t// lp2 remove his all  liquidity from the pool\n> \t\t\tassert_ok!(Omnipool::remove_liquidity(RuntimeOrigin::signed(LP2), 2, 2000 * ONE));\n> \t\t\t// this makes sure that all liquidity were removed, and the position get destroyed\n> \t\t\tassert!(\n> \t\t\t\tPositions::<Test>::get(lp2_position_id).is_none(),\n> \t\t\t\t\"Position still found\"\n> \t\t\t);\n> \t\t\t// state of asset_a after the entire liquidity removal\n> \t\t\tprintln!(\n> \t\t\t\t\"the final state after all liquidity has been removed: {:?} \",\n> \t\t\t\tOmnipool::load_asset_state(asset_a).unwrap()\n> \t\t\t);\n> \t\t\t// the attacker LP1 send 1 unit of asset_a to the pool \n> \t\t\tTokens::transfer(RuntimeOrigin::signed(LP1), Omnipool::protocol_account(), asset_a, ONE);\n> \t\t\tlet liq_added = 400 * ONE;\n> \t\t\t// the LP2 added liquidity to the pool \n> \t\t\tassert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP2), asset_a, liq_added));\n> \t\t\t// get the new position of the LP2 \n> \t\t\tlet new_lp2_position_id = <NextPositionId<Test>>::get() - 1;\n> \n> \t\t\tlet pos = Positions::<Test>::get(new_lp2_position_id);\n> \t\t\tprintln!(\n> \t\t\t\t\" the lp2_position  after adding liquidity of 400 units of asset_a: {:?}\",\n> \t\t\t\tpos.unwrap()\n> \t\t\t);\n> \t\t\tprintln!(\n> \t\t\t\t\"the new state after liquidity provision had done but NO shares got minted to LP2: {:?}\",\n> \t\t\t\tOmnipool::load_asset_state(asset_a).unwrap()\n> \t\t\t);\n> \t\t});\n> }\n> ```\n> You can run the test and see the Logs that I used to explain the attack flow: \n>\n> ```rust  \n> running 1 test\n> asset state before the entire liquidity removal AssetReserveState { reserve: 2000000000000000, hub_reserve: 1300000000000000, shares: 2000000000000000, protocol_shares: 0, cap: 1000000000000000000, tradable: SELL | BUY | ADD_LIQUIDITY | REMOVE_LIQUIDITY } \n>  the lp2_position before all liquidity removal: Position { asset_id: 1000, amount: 2000000000000000, shares: 2000000000000000, price: (650000000000000000, 1000000000000000000) }\n> the final state after all liquidity has been removed: AssetReserveState { reserve: 0, hub_reserve: 0, shares: 0, protocol_shares: 0, cap: 1000000000000000000, tradable: SELL | BUY | ADD_LIQUIDITY | REMOVE_LIQUIDITY } \n>  the lp2_position  after adding liquidity of 400 units of asset_a: Position { asset_id: 1000, amount: 400000000000000, shares: 0, price: (0, 401000000000000) }\n> the new state after liquidity provision had done but NO shares got minted to LP2: AssetReserveState { reserve: 401000000000000, hub_reserve: 0, shares: 0, protocol_shares: 0, cap: 1000000000000000000, tradable: SELL | BUY | ADD_LIQUIDITY | REMOVE_LIQUIDITY }\n> ```\n>\n> The two issues can be mitigated by the same mitigation steps, as I mentioned in the submitted report.\n\n**[Lambda (judge) commented](https://github.com/code-423n4/2024-02-hydradx-findings/issues/75#issuecomment-1998358003):**\n > This was indeed wrongly duplicated. The warden displayed an edge case that impacts the correct functioning of the protocol. Although it is rare and might or might not occur in practice (because the owner of the initial liquidity needs to remove their position), it is possible in the current code base.\n\n**[enthusiastmartin (HydraDX) disputed and commented](https://github.com/code-423n4/2024-02-hydradx-findings/issues/75#issuecomment-2034437741):**\n> This is desired behavior. If all liquidity has been removed from a pool, then there is no spot price, so we cannot allow anyone to add liquidity in that token. We must go through the process of adding the token to Omnipool all over again, as if it was new token entirely.\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2024-02-hydradx-findings/issues/75).*\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-hydradx",
  "Code": [
    {
      "filename": "HydraDX-node/pallets/omnipool/src/lib.rs",
      "content": "// Copyright (C) 2020-2022  Intergalactic, Limited (GIB).\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! # Omnipool pallet\n//!\n//! Omnipool implementation\n//!\n//! ## Overview\n//!\n//! Omnipool is type of AMM where all assets are pooled together into one single pool.\n//!\n//! Each asset is internally paired with so called Hub Asset ( LRNA ). When a liquidity is provided, corresponding\n//! amount of hub asset is minted. When a liquidity is removed, corresponding amount of hub asset is burned.\n//!\n//! Liquidity provider can provide any asset of their choice to the Omnipool and in return\n//! they will receive pool shares for this single asset.\n//!\n//! The position is represented as a NFT token which stores the amount of shares distributed\n//! and the price of the asset at the time of provision.\n//!\n//! For traders this means that they can benefit from non-fragmented liquidity.\n//! They can send any token to the pool using the swap mechanism\n//! and in return they will receive the token of their choice in the appropriate quantity.\n//!\n//! Omnipool is implemented with concrete Balance type: u128.\n//!\n//! ### Imbalance mechanism\n//! The Imbalance mechanism is designed to stabilize the value of LRNA. By design it is a weak and passive mechanism,\n//! and is specifically meant to deal with one cause of LRNA volatility: LRNA being sold back to the pool.\n//!\n//! Imbalance is always negative, internally represented by a special type `SimpleImbalance` which uses unsigned integer and boolean flag.\n//! This was done initially because of the intention that in future imbalance can also become positive.\n//!\n//! ### Omnipool Hooks\n//!\n//! Omnipool pallet supports multiple hooks which are triggerred on certain operations:\n//! - on_liquidity_changed - called when liquidity is added or removed from the pool\n//! - on_trade - called when trade is executed\n//! - on_trade_fee - called after successful trade with fee amount that can be taken out of the pool if needed.\n//!\n//! This is currently used to update on-chain oracle and in the circuit breaker.\n//!\n//! ## Terminology\n//!\n//! * **LP:**  liquidity provider\n//! * **Position:**  a moment when LP added liquidity to the pool. It stores amount,shares and price at the time\n//!  of provision\n//! * **Hub Asset:** dedicated 'hub' token for trade executions (LRNA)\n//! * **Native Asset:** governance token\n//! * **Imbalance:** Tracking of hub asset imbalance.\n//!\n//! ## Assumptions\n//!\n//! Below are assumptions that must be held when using this pallet.\n//!\n//! * Initial liquidity of new token being added to Omnipool must be transferred manually to pool account prior to calling add_token.\n//! * All tokens added to the pool must be first registered in Asset Registry.\n//!\n//! ## Interface\n//!\n//! ### Dispatchable Functions\n//!\n//! * `add_token` - Adds token to the pool. Initial liquidity must be transffered to pool account prior to calling add_token.\n//! * `add_liquidity` - Adds liquidity of selected asset to the pool. Mints corresponding position NFT.\n//! * `remove_liquidity` - Removes liquidity of selected position from the pool. Partial withdrawals are allowed.\n//! * `sell` - Trades an asset in for asset out by selling given amount of asset in.\n//! * `buy` - Trades an asset in for asset out by buying given amount of asset out.\n//! * `set_asset_tradable_state` - Updates asset's tradable state with new flags. This allows/forbids asset operation such SELL,BUY,ADD or  REMOVE liquidtityy.\n//! * `refund_refused_asset` - Refunds the initial liquidity amount sent to pool account prior to add_token if the token has been refused to be added.\n//! * `sacrifice_position` - Destroys a position and position's shares become protocol's shares.\n//! * `withdraw_protocol_liquidity` - Withdraws protocol's liquidity from the pool. Used to withdraw liquidity from sacrificed position.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse frame_support::pallet_prelude::{DispatchResult, Get};\nuse frame_support::require_transactional;\nuse frame_support::PalletId;\nuse frame_support::{ensure, transactional};\nuse sp_runtime::traits::{AccountIdConversion, AtLeast32BitUnsigned, One};\nuse sp_runtime::traits::{CheckedAdd, CheckedSub, Zero};\nuse sp_std::ops::{Add, Sub};\nuse sp_std::prelude::*;\n\nuse frame_support::traits::tokens::nonfungibles::{Create, Inspect, Mutate};\nuse hydra_dx_math::omnipool::types::{AssetStateChange, BalanceUpdate, I129};\nuse hydradx_traits::Registry;\nuse orml_traits::{GetByKey, MultiCurrency};\nuse scale_info::TypeInfo;\nuse sp_runtime::{ArithmeticError, DispatchError, FixedPointNumber, FixedU128, Permill};\n\n#[cfg(test)]\nmod tests;\n\npub mod provider;\npub mod router_execution;\npub mod traits;\npub mod types;\npub mod weights;\n\nuse crate::traits::{AssetInfo, OmnipoolHooks};\nuse crate::types::{AssetReserveState, AssetState, Balance, Position, SimpleImbalance, Tradability};\npub use pallet::*;\npub use weights::WeightInfo;\n\n/// NFT class id type of provided nft implementation\npub type NFTCollectionIdOf<T> =\n\t<<T as Config>::NFTHandler as Inspect<<T as frame_system::Config>::AccountId>>::CollectionId;\n\n#[frame_support::pallet]\npub mod pallet {\n\tuse super::*;\n\tuse crate::traits::{AssetInfo, ExternalPriceProvider, OmnipoolHooks, ShouldAllow};\n\tuse crate::types::{Position, Price, Tradability};\n\tuse codec::HasCompact;\n\tuse frame_support::pallet_prelude::*;\n\tuse frame_support::traits::DefensiveOption;\n\tuse frame_system::pallet_prelude::*;\n\tuse hydra_dx_math::ema::EmaPrice;\n\tuse hydra_dx_math::omnipool::types::{BalanceUpdate, I129};\n\tuse orml_traits::GetByKey;\n\tuse sp_runtime::ArithmeticError;\n\n\t#[pallet::pallet]\n\tpub struct Pallet<T>(_);\n\n\t#[pallet::config]\n\tpub trait Config: frame_system::Config {\n\t\t/// The overarching event type.\n\t\ttype RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;\n\n\t\t/// Asset type.\n\t\ttype AssetId: Member\n\t\t\t+ Parameter\n\t\t\t+ Default\n\t\t\t+ Copy\n\t\t\t+ HasCompact\n\t\t\t+ MaybeSerializeDeserialize\n\t\t\t+ MaxEncodedLen\n\t\t\t+ TypeInfo;\n\n\t\t/// Multi currency mechanism\n\t\ttype Currency: MultiCurrency<Self::AccountId, CurrencyId = Self::AssetId, Balance = Balance>;\n\n\t\t/// Origin that can add token, refund refused asset and withdraw protocol liquidity.\n\t\ttype AuthorityOrigin: EnsureOrigin<Self::RuntimeOrigin>;\n\n\t\t/// Origin that can change asset's tradability and weight.\n\t\ttype TechnicalOrigin: EnsureOrigin<Self::RuntimeOrigin>;\n\n\t\t/// Asset Registry mechanism - used to check if asset is correctly registered in asset registry\n\t\ttype AssetRegistry: Registry<Self::AssetId, Vec<u8>, Balance, DispatchError>;\n\n\t\t/// Native Asset ID\n\t\t#[pallet::constant]\n\t\ttype HdxAssetId: Get<Self::AssetId>;\n\n\t\t/// Hub Asset ID\n\t\t#[pallet::constant]\n\t\ttype HubAssetId: Get<Self::AssetId>;\n\n\t\t/// Dynamic fee support - returns (Asset Fee, Protocol Fee) for given asset\n\t\ttype Fee: GetByKey<Self::AssetId, (Permill, Permill)>;\n\n\t\t/// Minimum withdrawal fee\n\t\t#[pallet::constant]\n\t\ttype MinWithdrawalFee: Get<Permill>;\n\n\t\t/// Minimum trading limit\n\t\t#[pallet::constant]\n\t\ttype MinimumTradingLimit: Get<Balance>;\n\n\t\t/// Minimum pool liquidity which can be added\n\t\t#[pallet::constant]\n\t\ttype MinimumPoolLiquidity: Get<Balance>;\n\n\t\t/// Max fraction of asset reserve to sell in single transaction\n\t\t#[pallet::constant]\n\t\ttype MaxInRatio: Get<u128>;\n\n\t\t/// Max fraction of asset reserve to buy in single transaction\n\t\t#[pallet::constant]\n\t\ttype MaxOutRatio: Get<u128>;\n\n\t\t/// Position identifier type\n\t\ttype PositionItemId: Member + Parameter + Default + Copy + HasCompact + AtLeast32BitUnsigned + MaxEncodedLen;\n\n\t\t/// Collection id type\n\t\ttype CollectionId: TypeInfo + MaxEncodedLen;\n\n\t\t/// Non fungible class id\n\t\t#[pallet::constant]\n\t\ttype NFTCollectionId: Get<NFTCollectionIdOf<Self>>;\n\n\t\t/// Non fungible handling - mint,burn, check owner\n\t\ttype NFTHandler: Mutate<Self::AccountId>\n\t\t\t+ Create<Self::AccountId>\n\t\t\t+ Inspect<Self::AccountId, ItemId = Self::PositionItemId, CollectionId = Self::CollectionId>;\n\n\t\t/// Weight information for extrinsics in this pallet.\n\t\ttype WeightInfo: WeightInfo;\n\n\t\t/// Hooks are actions executed on add_liquidity, sell or buy.\n\t\ttype OmnipoolHooks: OmnipoolHooks<\n\t\t\tSelf::RuntimeOrigin,\n\t\t\tSelf::AccountId,\n\t\t\tSelf::AssetId,\n\t\t\tBalance,\n\t\t\tError = DispatchError,\n\t\t>;\n\n\t\t/// Safety mechanism when adding and removing liquidity. Determines how much price can change between spot price and oracle price.\n\t\ttype PriceBarrier: ShouldAllow<Self::AccountId, Self::AssetId, EmaPrice>;\n\n\t\t/// Oracle price provider. Provides price for given asset. Used in remove liquidity to support calculation of dynamic withdrawal fee.\n\t\ttype ExternalPriceOracle: ExternalPriceProvider<Self::AssetId, EmaPrice, Error = DispatchError>;\n\t}\n\n\t#[pallet::storage]\n\t/// State of an asset in the omnipool\n\t#[pallet::getter(fn assets)]\n\tpub(super) type Assets<T: Config> = StorageMap<_, Blake2_128Concat, T::AssetId, AssetState<Balance>>;\n\n\t#[pallet::storage]\n\t/// Imbalance of hub asset\n\t#[pallet::getter(fn current_imbalance)]\n\tpub(super) type HubAssetImbalance<T: Config> = StorageValue<_, SimpleImbalance<Balance>, ValueQuery>;\n\n\t// LRNA is only allowed to be sold\n\t#[pallet::type_value]\n\tpub fn DefaultHubAssetTradability() -> Tradability {\n\t\tTradability::SELL\n\t}\n\n\t#[pallet::storage]\n\t/// Tradable state of hub asset.\n\tpub(super) type HubAssetTradability<T: Config> =\n\t\tStorageValue<_, Tradability, ValueQuery, DefaultHubAssetTradability>;\n\n\t#[pallet::storage]\n\t/// LP positions. Maps NFT instance id to corresponding position\n\t#[pallet::getter(fn positions)]\n\tpub(super) type Positions<T: Config> =\n\t\tStorageMap<_, Blake2_128Concat, T::PositionItemId, Position<Balance, T::AssetId>>;\n\n\t#[pallet::storage]\n\t#[pallet::getter(fn next_position_id)]\n\t/// Position ids sequencer\n\tpub(super) type NextPositionId<T: Config> = StorageValue<_, T::PositionItemId, ValueQuery>;\n\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(crate) fn deposit_event)]\n\tpub enum Event<T: Config> {\n\t\t/// An asset was added to Omnipool\n\t\tTokenAdded {\n\t\t\tasset_id: T::AssetId,\n\t\t\tinitial_amount: Balance,\n\t\t\tinitial_price: Price,\n\t\t},\n\t\t/// An asset was removed from Omnipool\n\t\tTokenRemoved {\n\t\t\tasset_id: T::AssetId,\n\t\t\tamount: Balance,\n\t\t\thub_withdrawn: Balance,\n\t\t},\n\t\t/// Liquidity of an asset was added to Omnipool.\n\t\tLiquidityAdded {\n\t\t\twho: T::AccountId,\n\t\t\tasset_id: T::AssetId,\n\t\t\tamount: Balance,\n\t\t\tposition_id: T::PositionItemId,\n\t\t},\n\t\t/// Liquidity of an asset was removed from Omnipool.\n\t\tLiquidityRemoved {\n\t\t\twho: T::AccountId,\n\t\t\tposition_id: T::PositionItemId,\n\t\t\tasset_id: T::AssetId,\n\t\t\tshares_removed: Balance,\n\t\t\tfee: FixedU128,\n\t\t},\n\t\t/// PRotocol Liquidity was removed from Omnipool.\n\t\tProtocolLiquidityRemoved {\n\t\t\twho: T::AccountId,\n\t\t\tasset_id: T::AssetId,\n\t\t\tamount: Balance,\n\t\t\thub_amount: Balance,\n\t\t\tshares_removed: Balance,\n\t\t},\n\t\t/// Sell trade executed.\n\t\tSellExecuted {\n\t\t\twho: T::AccountId,\n\t\t\tasset_in: T::AssetId,\n\t\t\tasset_out: T::AssetId,\n\t\t\tamount_in: Balance,\n\t\t\tamount_out: Balance,\n\t\t\thub_amount_in: Balance,\n\t\t\thub_amount_out: Balance,\n\t\t\tasset_fee_amount: Balance,\n\t\t\tprotocol_fee_amount: Balance,\n\t\t},\n\t\t/// Buy trade executed.\n\t\tBuyExecuted {\n\t\t\twho: T::AccountId,\n\t\t\tasset_in: T::AssetId,\n\t\t\tasset_out: T::AssetId,\n\t\t\tamount_in: Balance,\n\t\t\tamount_out: Balance,\n\t\t\thub_amount_in: Balance,\n\t\t\thub_amount_out: Balance,\n\t\t\tasset_fee_amount: Balance,\n\t\t\tprotocol_fee_amount: Balance,\n\t\t},\n\t\t/// LP Position was created and NFT instance minted.\n\t\tPositionCreated {\n\t\t\tposition_id: T::PositionItemId,\n\t\t\towner: T::AccountId,\n\t\t\tasset: T::AssetId,\n\t\t\tamount: Balance,\n\t\t\tshares: Balance,\n\t\t\tprice: Price,\n\t\t},\n\t\t/// LP Position was destroyed and NFT instance burned.\n\t\tPositionDestroyed {\n\t\t\tposition_id: T::PositionItemId,\n\t\t\towner: T::AccountId,\n\t\t},\n\t\t/// LP Position was updated.\n\t\tPositionUpdated {\n\t\t\tposition_id: T::PositionItemId,\n\t\t\towner: T::AccountId,\n\t\t\tasset: T::AssetId,\n\t\t\tamount: Balance,\n\t\t\tshares: Balance,\n\t\t\tprice: Price,\n\t\t},\n\t\t/// Asset's tradable state has been updated.\n\t\tTradableStateUpdated { asset_id: T::AssetId, state: Tradability },\n\n\t\t/// Amount has been refunded for asset which has not been accepted to add to omnipool.\n\t\tAssetRefunded {\n\t\t\tasset_id: T::AssetId,\n\t\t\tamount: Balance,\n\t\t\trecipient: T::AccountId,\n\t\t},\n\n\t\t/// Asset's weight cap has been updated.\n\t\tAssetWeightCapUpdated { asset_id: T::AssetId, cap: Permill },\n\t}\n\n\t#[pallet::error]\n\t#[cfg_attr(test, derive(PartialEq, Eq))]\n\tpub enum Error<T> {\n\t\t/// Balance too low\n\t\tInsufficientBalance,\n\t\t/// Asset is already in omnipool\n\t\tAssetAlreadyAdded,\n\t\t/// Asset is not in omnipool\n\t\tAssetNotFound,\n\t\t/// Failed to add token to Omnipool due to insufficient initial liquidity.\n\t\tMissingBalance,\n\t\t/// Invalid initial asset price.\n\t\tInvalidInitialAssetPrice,\n\t\t/// Slippage protection - minimum limit has not been reached.\n\t\tBuyLimitNotReached,\n\t\t/// Slippage protection - maximum limit has been exceeded.\n\t\tSellLimitExceeded,\n\t\t/// Position has not been found.\n\t\tPositionNotFound,\n\t\t/// Insufficient shares in position\n\t\tInsufficientShares,\n\t\t/// Asset is not allowed to be traded.\n\t\tNotAllowed,\n\t\t/// Signed account is not owner of position instance.\n\t\tForbidden,\n\t\t/// Asset weight cap has been exceeded.\n\t\tAssetWeightCapExceeded,\n\t\t/// Asset is not registered in asset registry\n\t\tAssetNotRegistered,\n\t\t/// Provided liquidity is below minimum allowed limit\n\t\tInsufficientLiquidity,\n\t\t/// Traded amount is below minimum allowed limit\n\t\tInsufficientTradingAmount,\n\t\t/// Sell or buy with same asset ids is not allowed.\n\t\tSameAssetTradeNotAllowed,\n\t\t/// LRNA update after trade results in positive value.\n\t\tHubAssetUpdateError,\n\t\t/// Imbalance results in positive value.\n\t\tPositiveImbalance,\n\t\t/// Amount of shares provided cannot be 0.\n\t\tInvalidSharesAmount,\n\t\t/// Hub asset is only allowed to be sold.\n\t\tInvalidHubAssetTradableState,\n\t\t/// Asset is not allowed to be refunded.\n\t\tAssetRefundNotAllowed,\n\t\t/// Max fraction of asset to buy has been exceeded.\n\t\tMaxOutRatioExceeded,\n\t\t/// Max fraction of asset to sell has been exceeded.\n\t\tMaxInRatioExceeded,\n\t\t/// Max allowed price difference has been exceeded.\n\t\tPriceDifferenceTooHigh,\n\t\t/// Invalid oracle price - division by zero.\n\t\tInvalidOraclePrice,\n\t\t/// Failed to calculate withdrawal fee.\n\t\tInvalidWithdrawalFee,\n\t\t/// More than allowed amount of fee has been transferred.\n\t\tFeeOverdraft,\n\t\t/// Token cannot be removed from Omnipool due to shares still owned by other users.\n\t\tSharesRemaining,\n\t\t/// Token cannot be removed from Omnipool because asset is not frozen.\n\t\tAssetNotFrozen,\n\t\t/// Calculated amount out from sell trade is zero.\n\t\tZeroAmountOut,\n\t}\n\n\t#[pallet::call]\n\timpl<T: Config> Pallet<T> {\n\t\t/// Add new token to omnipool in quantity `amount` at price `initial_price`\n\t\t///\n\t\t/// Initial liquidity must be transferred to pool's account for this new token manually prior to calling `add_token`.\n\t\t///\n\t\t/// Initial liquidity is pool's account balance of the token.\n\t\t///\n\t\t/// Position NFT token is minted for `position_owner`.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `asset`: The identifier of the new asset added to the pool. Must be registered in Asset registry\n\t\t/// - `initial_price`: Initial price\n\t\t/// - `position_owner`: account id for which share are distributed in form on NFT\n\t\t/// - `weight_cap`: asset weight cap\n\t\t///\n\t\t/// Emits `TokenAdded` event when successful.\n\t\t///\n\t\t#[pallet::call_index(1)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::add_token().saturating_add(T::OmnipoolHooks::on_liquidity_changed_weight()))]\n\t\t#[transactional]\n\t\tpub fn add_token(\n\t\t\torigin: OriginFor<T>,\n\t\t\tasset: T::AssetId,\n\t\t\tinitial_price: Price,\n\t\t\tweight_cap: Permill,\n\t\t\tposition_owner: T::AccountId,\n\t\t) -> DispatchResult {\n\t\t\tT::AuthorityOrigin::ensure_origin(origin.clone())?;\n\n\t\t\tensure!(!Assets::<T>::contains_key(asset), Error::<T>::AssetAlreadyAdded);\n\n\t\t\tensure!(T::AssetRegistry::exists(asset), Error::<T>::AssetNotRegistered);\n\n\t\t\tensure!(initial_price > FixedU128::zero(), Error::<T>::InvalidInitialAssetPrice);\n\n\t\t\t// ensure collection is created, we can simply ignore the error if it was already created.\n\t\t\tlet _ = T::NFTHandler::create_collection(\n\t\t\t\t&T::NFTCollectionId::get(),\n\t\t\t\t&Self::protocol_account(),\n\t\t\t\t&Self::protocol_account(),\n\t\t\t);\n\n\t\t\tlet amount = T::Currency::free_balance(asset, &Self::protocol_account());\n\n\t\t\tensure!(\n\t\t\t\tamount >= T::MinimumPoolLiquidity::get() && amount > 0,\n\t\t\t\tError::<T>::MissingBalance\n\t\t\t);\n\n\t\t\tlet hub_reserve = initial_price.checked_mul_int(amount).ok_or(ArithmeticError::Overflow)?;\n\n\t\t\t// Initial state of asset\n\t\t\tlet state = AssetState::<Balance> {\n\t\t\t\thub_reserve,\n\t\t\t\tshares: amount,\n\t\t\t\tprotocol_shares: Balance::zero(),\n\t\t\t\tcap: FixedU128::from(weight_cap).into_inner(),\n\t\t\t\ttradable: Tradability::default(),\n\t\t\t};\n\n\t\t\tlet lp_position = Position::<Balance, T::AssetId> {\n\t\t\t\tasset_id: asset,\n\t\t\t\tamount,\n\t\t\t\tshares: amount,\n\t\t\t\tprice: (initial_price.into_inner(), FixedU128::DIV),\n\t\t\t};\n\n\t\t\tlet instance_id = Self::create_and_mint_position_instance(&position_owner)?;\n\n\t\t\t<Positions<T>>::insert(instance_id, lp_position);\n\n\t\t\tSelf::deposit_event(Event::PositionCreated {\n\t\t\t\tposition_id: instance_id,\n\t\t\t\towner: position_owner,\n\t\t\t\tasset,\n\t\t\t\tamount,\n\t\t\t\tshares: amount,\n\t\t\t\tprice: initial_price,\n\t\t\t});\n\n\t\t\tlet current_imbalance = <HubAssetImbalance<T>>::get();\n\t\t\tlet current_hub_asset_liquidity =\n\t\t\t\tT::Currency::free_balance(T::HubAssetId::get(), &Self::protocol_account());\n\n\t\t\tlet delta_imbalance = hydra_dx_math::omnipool::calculate_delta_imbalance(\n\t\t\t\thub_reserve,\n\t\t\t\tI129 {\n\t\t\t\t\tvalue: current_imbalance.value,\n\t\t\t\t\tnegative: current_imbalance.negative,\n\t\t\t\t},\n\t\t\t\tcurrent_hub_asset_liquidity,\n\t\t\t)\n\t\t\t.ok_or(ArithmeticError::Overflow)?;\n\n\t\t\tSelf::update_imbalance(BalanceUpdate::Decrease(delta_imbalance))?;\n\n\t\t\tlet delta_hub_reserve = BalanceUpdate::Increase(hub_reserve);\n\t\t\tSelf::update_hub_asset_liquidity(&delta_hub_reserve)?;\n\n\t\t\tlet reserve = T::Currency::free_balance(asset, &Self::protocol_account());\n\n\t\t\tlet reserve_state: AssetReserveState<_> = (state.clone(), reserve).into();\n\t\t\tlet changes = AssetStateChange {\n\t\t\t\tdelta_hub_reserve,\n\t\t\t\tdelta_reserve: BalanceUpdate::Increase(reserve),\n\t\t\t\tdelta_shares: BalanceUpdate::Increase(amount),\n\t\t\t\tdelta_protocol_shares: BalanceUpdate::Increase(Balance::zero()),\n\t\t\t};\n\t\t\tT::OmnipoolHooks::on_liquidity_changed(\n\t\t\t\torigin,\n\t\t\t\tAssetInfo::new(asset, &AssetReserveState::default(), &reserve_state, &changes, false),\n\t\t\t)?;\n\n\t\t\t<Assets<T>>::insert(asset, state);\n\n\t\t\tSelf::deposit_event(Event::TokenAdded {\n\t\t\t\tasset_id: asset,\n\t\t\t\tinitial_amount: amount,\n\t\t\t\tinitial_price,\n\t\t\t});\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Add liquidity of asset `asset` in quantity `amount` to Omnipool\n\t\t///\n\t\t/// `add_liquidity` adds specified asset amount to Omnipool and in exchange gives the origin\n\t\t/// corresponding shares amount in form of NFT at current price.\n\t\t///\n\t\t/// Asset's tradable state must contain ADD_LIQUIDITY flag, otherwise `NotAllowed` error is returned.\n\t\t///\n\t\t/// NFT is minted using NTFHandler which implements non-fungibles traits from frame_support.\n\t\t///\n\t\t/// Asset weight cap must be respected, otherwise `AssetWeightExceeded` error is returned.\n\t\t/// Asset weight is ratio between new HubAsset reserve and total reserve of Hub asset in Omnipool.\n\t\t///\n\t\t/// Add liquidity fails if price difference between spot price and oracle price is higher than allowed by `PriceBarrier`.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `asset`: The identifier of the new asset added to the pool. Must be already in the pool\n\t\t/// - `amount`: Amount of asset added to omnipool\n\t\t///\n\t\t/// Emits `LiquidityAdded` event when successful.\n\t\t///\n\t\t#[pallet::call_index(2)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::add_liquidity()\n\t\t\t.saturating_add(T::OmnipoolHooks::on_liquidity_changed_weight()\n\t\t\t.saturating_add(T::ExternalPriceOracle::get_price_weight()))\n\t\t)]\n\t\t#[transactional]\n\t\tpub fn add_liquidity(origin: OriginFor<T>, asset: T::AssetId, amount: Balance) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin.clone())?;\n\n\t\t\tensure!(\n\t\t\t\tamount >= T::MinimumPoolLiquidity::get(),\n\t\t\t\tError::<T>::InsufficientLiquidity\n\t\t\t);\n\n\t\t\tensure!(\n\t\t\t\tT::Currency::ensure_can_withdraw(asset, &who, amount).is_ok(),\n\t\t\t\tError::<T>::InsufficientBalance\n\t\t\t);\n\n\t\t\tlet asset_state = Self::load_asset_state(asset)?;\n\n\t\t\tensure!(\n\t\t\t\tasset_state.tradable.contains(Tradability::ADD_LIQUIDITY),\n\t\t\t\tError::<T>::NotAllowed\n\t\t\t);\n\n\t\t\tT::PriceBarrier::ensure_price(\n\t\t\t\t&who,\n\t\t\t\tT::HubAssetId::get(),\n\t\t\t\tasset,\n\t\t\t\tEmaPrice::new(asset_state.hub_reserve, asset_state.reserve),\n\t\t\t)\n\t\t\t.map_err(|_| Error::<T>::PriceDifferenceTooHigh)?;\n\n\t\t\tlet current_imbalance = <HubAssetImbalance<T>>::get();\n\t\t\tlet current_hub_asset_liquidity =\n\t\t\t\tT::Currency::free_balance(T::HubAssetId::get(), &Self::protocol_account());\n\n\t\t\t//\n\t\t\t// Calculate add liquidity state changes\n\t\t\t//\n\t\t\tlet state_changes = hydra_dx_math::omnipool::calculate_add_liquidity_state_changes(\n\t\t\t\t&(&asset_state).into(),\n\t\t\t\tamount,\n\t\t\t\tI129 {\n\t\t\t\t\tvalue: current_imbalance.value,\n\t\t\t\t\tnegative: current_imbalance.negative,\n\t\t\t\t},\n\t\t\t\tcurrent_hub_asset_liquidity,\n\t\t\t)\n\t\t\t.ok_or(ArithmeticError::Overflow)?;\n\n\t\t\tlet new_asset_state = asset_state\n\t\t\t\t.clone()\n\t\t\t\t.delta_update(&state_changes.asset)\n\t\t\t\t.ok_or(ArithmeticError::Overflow)?;\n\n\t\t\tlet hub_reserve_ratio = FixedU128::checked_from_rational(\n\t\t\t\tnew_asset_state.hub_reserve,\n\t\t\t\tT::Currency::free_balance(T::HubAssetId::get(), &Self::protocol_account())\n\t\t\t\t\t.checked_add(*state_changes.asset.delta_hub_reserve)\n\t\t\t\t\t.ok_or(ArithmeticError::Overflow)?,\n\t\t\t)\n\t\t\t.ok_or(ArithmeticError::DivisionByZero)?;\n\n\t\t\tensure!(\n\t\t\t\thub_reserve_ratio <= new_asset_state.weight_cap(),\n\t\t\t\tError::<T>::AssetWeightCapExceeded\n\t\t\t);\n\n\t\t\t// Create LP position with given shares\n\t\t\tlet lp_position = Position::<Balance, T::AssetId> {\n\t\t\t\tasset_id: asset,\n\t\t\t\tamount,\n\t\t\t\tshares: *state_changes.asset.delta_shares,\n\t\t\t\t// Note: position needs price after asset state is updated.\n\t\t\t\tprice: (new_asset_state.hub_reserve, new_asset_state.reserve),\n\t\t\t};\n\n\t\t\tlet instance_id = Self::create_and_mint_position_instance(&who)?;\n\n\t\t\t<Positions<T>>::insert(instance_id, lp_position);\n\n\t\t\tSelf::deposit_event(Event::PositionCreated {\n\t\t\t\tposition_id: instance_id,\n\t\t\t\towner: who.clone(),\n\t\t\t\tasset,\n\t\t\t\tamount,\n\t\t\t\tshares: *state_changes.asset.delta_shares,\n\t\t\t\tprice: new_asset_state.price().ok_or(ArithmeticError::DivisionByZero)?,\n\t\t\t});\n\n\t\t\tT::Currency::transfer(\n\t\t\t\tasset,\n\t\t\t\t&who,\n\t\t\t\t&Self::protocol_account(),\n\t\t\t\t*state_changes.asset.delta_reserve,\n\t\t\t)?;\n\n\t\t\tdebug_assert_eq!(*state_changes.asset.delta_reserve, amount);\n\n\t\t\t// Callback hook info\n\t\t\tlet info: AssetInfo<T::AssetId, Balance> =\n\t\t\t\tAssetInfo::new(asset, &asset_state, &new_asset_state, &state_changes.asset, false);\n\n\t\t\tSelf::update_imbalance(state_changes.delta_imbalance)?;\n\n\t\t\tSelf::update_hub_asset_liquidity(&state_changes.asset.delta_hub_reserve)?;\n\n\t\t\tSelf::set_asset_state(asset, new_asset_state);\n\n\t\t\tSelf::deposit_event(Event::LiquidityAdded {\n\t\t\t\twho,\n\t\t\t\tasset_id: asset,\n\t\t\t\tamount,\n\t\t\t\tposition_id: instance_id,\n\t\t\t});\n\n\t\t\tT::OmnipoolHooks::on_liquidity_changed(origin, info)?;\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Remove liquidity of asset `asset` in quantity `amount` from Omnipool\n\t\t///\n\t\t/// `remove_liquidity` removes specified shares amount from given PositionId (NFT instance).\n\t\t///\n\t\t/// Asset's tradable state must contain REMOVE_LIQUIDITY flag, otherwise `NotAllowed` error is returned.\n\t\t///\n\t\t/// if all shares from given position are removed, position is destroyed and NFT is burned.\n\t\t///\n\t\t/// Remove liquidity fails if price difference between spot price and oracle price is higher than allowed by `PriceBarrier`.\n\t\t///\n\t\t/// Dynamic withdrawal fee is applied if withdrawal is not safe. It is calculated using spot price and external price oracle.\n\t\t/// Withdrawal is considered safe when trading is disabled.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `position_id`: The identifier of position which liquidity is removed from.\n\t\t/// - `amount`: Amount of shares removed from omnipool\n\t\t///\n\t\t/// Emits `LiquidityRemoved` event when successful.\n\t\t///\n\t\t#[pallet::call_index(3)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::remove_liquidity().saturating_add(T::OmnipoolHooks::on_liquidity_changed_weight()))]\n\t\t#[transactional]\n\t\tpub fn remove_liquidity(\n\t\t\torigin: OriginFor<T>,\n\t\t\tposition_id: T::PositionItemId,\n\t\t\tamount: Balance,\n\t\t) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin.clone())?;\n\n\t\t\tensure!(amount > Balance::zero(), Error::<T>::InvalidSharesAmount);\n\n\t\t\tensure!(\n\t\t\t\tT::NFTHandler::owner(&T::NFTCollectionId::get(), &position_id) == Some(who.clone()),\n\t\t\t\tError::<T>::Forbidden\n\t\t\t);\n\n\t\t\tlet position = Positions::<T>::get(position_id).ok_or(Error::<T>::PositionNotFound)?;\n\n\t\t\tensure!(position.shares >= amount, Error::<T>::InsufficientShares);\n\n\t\t\tlet asset_id = position.asset_id;\n\n\t\t\tlet asset_state = Self::load_asset_state(asset_id)?;\n\n\t\t\tensure!(\n\t\t\t\tasset_state.tradable.contains(Tradability::REMOVE_LIQUIDITY),\n\t\t\t\tError::<T>::NotAllowed\n\t\t\t);\n\n\t\t\tlet safe_withdrawal = asset_state.tradable.is_safe_withdrawal();\n\t\t\t// Skip price check if safe withdrawal - trading disabled.\n\t\t\tif !safe_withdrawal {\n\t\t\t\tT::PriceBarrier::ensure_price(\n\t\t\t\t\t&who,\n\t\t\t\t\tT::HubAssetId::get(),\n\t\t\t\t\tasset_id,\n\t\t\t\t\tEmaPrice::new(asset_state.hub_reserve, asset_state.reserve),\n\t\t\t\t)\n\t\t\t\t.map_err(|_| Error::<T>::PriceDifferenceTooHigh)?;\n\t\t\t}\n\t\t\tlet ext_asset_price = T::ExternalPriceOracle::get_price(T::HubAssetId::get(), asset_id)?;\n\n\t\t\tif ext_asset_price.is_zero() {\n\t\t\t\treturn Err(Error::<T>::InvalidOraclePrice.into());\n\t\t\t}\n\t\t\tlet withdrawal_fee = hydra_dx_math::omnipool::calculate_withdrawal_fee(\n\t\t\t\tasset_state.price().ok_or(ArithmeticError::DivisionByZero)?,\n\t\t\t\tFixedU128::checked_from_rational(ext_asset_price.n, ext_asset_price.d)\n\t\t\t\t\t.defensive_ok_or(Error::<T>::InvalidOraclePrice)?,\n\t\t\t\tT::MinWithdrawalFee::get(),\n\t\t\t);\n\n\t\t\tlet current_imbalance = <HubAssetImbalance<T>>::get();\n\t\t\tlet current_hub_asset_liquidity =\n\t\t\t\tT::Currency::free_balance(T::HubAssetId::get(), &Self::protocol_account());\n\n\t\t\t//\n\t\t\t// calculate state changes of remove liquidity\n\t\t\t//\n\t\t\tlet state_changes = hydra_dx_math::omnipool::calculate_remove_liquidity_state_changes(\n\t\t\t\t&(&asset_state).into(),\n\t\t\t\tamount,\n\t\t\t\t&(&position).into(),\n\t\t\t\tI129 {\n\t\t\t\t\tvalue: current_imbalance.value,\n\t\t\t\t\tnegative: current_imbalance.negative,\n\t\t\t\t},\n\t\t\t\tcurrent_hub_asset_liquidity,\n\t\t\t\twithdrawal_fee,\n\t\t\t)\n\t\t\t.ok_or(ArithmeticError::Overflow)?;\n\n\t\t\tlet new_asset_state = asset_state\n\t\t\t\t.clone()\n\t\t\t\t.delta_update(&state_changes.asset)\n\t\t\t\t.ok_or(ArithmeticError::Overflow)?;\n\n\t\t\t// Update position state\n\t\t\tlet updated_position = position\n\t\t\t\t.delta_update(\n\t\t\t\t\t&state_changes.delta_position_reserve,\n\t\t\t\t\t&state_changes.delta_position_shares,\n\t\t\t\t)\n\t\t\t\t.ok_or(ArithmeticError::Overflow)?;\n\n\t\t\tT::Currency::transfer(\n\t\t\t\tasset_id,\n\t\t\t\t&Self::protocol_account(),\n\t\t\t\t&who,\n\t\t\t\t*state_changes.asset.delta_reserve,\n\t\t\t)?;\n\n\t\t\tSelf::update_imbalance(state_changes.delta_imbalance)?;\n\n\t\t\t// burn only difference between delta hub and lp hub amount.\n\t\t\tSelf::update_hub_asset_liquidity(\n\t\t\t\t&state_changes\n\t\t\t\t\t.asset\n\t\t\t\t\t.delta_hub_reserve\n\t\t\t\t\t.merge(BalanceUpdate::Increase(state_changes.lp_hub_amount))\n\t\t\t\t\t.ok_or(ArithmeticError::Overflow)?,\n\t\t\t)?;\n\n\t\t\t// LP receives some hub asset\n\t\t\tSelf::process_hub_amount(state_changes.lp_hub_amount, &who)?;\n\n\t\t\tif updated_position.shares == Balance::zero() {\n\t\t\t\t// All liquidity removed, remove position and burn NFT instance\n\n\t\t\t\t<Positions<T>>::remove(position_id);\n\t\t\t\tT::NFTHandler::burn(&T::NFTCollectionId::get(), &position_id, Some(&who))?;\n\n\t\t\t\tSelf::deposit_event(Event::PositionDestroyed {\n\t\t\t\t\tposition_id,\n\t\t\t\t\towner: who.clone(),\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tSelf::deposit_event(Event::PositionUpdated {\n\t\t\t\t\tposition_id,\n\t\t\t\t\towner: who.clone(),\n\t\t\t\t\tasset: asset_id,\n\t\t\t\t\tamount: updated_position.amount,\n\t\t\t\t\tshares: updated_position.shares,\n\t\t\t\t\tprice: updated_position\n\t\t\t\t\t\t.price_from_rational()\n\t\t\t\t\t\t.ok_or(ArithmeticError::DivisionByZero)?,\n\t\t\t\t});\n\n\t\t\t\t<Positions<T>>::insert(position_id, updated_position);\n\t\t\t}\n\n\t\t\t// Callback hook info\n\t\t\tlet info: AssetInfo<T::AssetId, Balance> = AssetInfo::new(\n\t\t\t\tasset_id,\n\t\t\t\t&asset_state,\n\t\t\t\t&new_asset_state,\n\t\t\t\t&state_changes.asset,\n\t\t\t\tsafe_withdrawal,\n\t\t\t);\n\n\t\t\tSelf::set_asset_state(asset_id, new_asset_state);\n\n\t\t\tSelf::deposit_event(Event::LiquidityRemoved {\n\t\t\t\twho,\n\t\t\t\tposition_id,\n\t\t\t\tasset_id,\n\t\t\t\tshares_removed: amount,\n\t\t\t\tfee: withdrawal_fee,\n\t\t\t});\n\n\t\t\tT::OmnipoolHooks::on_liquidity_changed(origin, info)?;\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Sacrifice LP position in favor of pool.\n\t\t///\n\t\t/// A position is destroyed and liquidity owned by LP becomes pool owned liquidity.\n\t\t///\n\t\t/// Only owner of position can perform this action.\n\t\t///\n\t\t/// Emits `PositionDestroyed`.\n\t\t#[pallet::call_index(4)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::sacrifice_position())]\n\t\t#[transactional]\n\t\tpub fn sacrifice_position(origin: OriginFor<T>, position_id: T::PositionItemId) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin)?;\n\n\t\t\tlet position = Positions::<T>::get(position_id).ok_or(Error::<T>::PositionNotFound)?;\n\n\t\t\tensure!(\n\t\t\t\tT::NFTHandler::owner(&T::NFTCollectionId::get(), &position_id) == Some(who.clone()),\n\t\t\t\tError::<T>::Forbidden\n\t\t\t);\n\n\t\t\tAssets::<T>::try_mutate(position.asset_id, |maybe_asset| -> DispatchResult {\n\t\t\t\tlet asset_state = maybe_asset.as_mut().ok_or(Error::<T>::AssetNotFound)?;\n\n\t\t\t\tasset_state.protocol_shares = asset_state\n\t\t\t\t\t.protocol_shares\n\t\t\t\t\t.checked_add(position.shares)\n\t\t\t\t\t.ok_or(ArithmeticError::Overflow)?;\n\n\t\t\t\tOk(())\n\t\t\t})?;\n\n\t\t\t// Destroy position and burn NFT\n\t\t\t<Positions<T>>::remove(position_id);\n\t\t\tT::NFTHandler::burn(&T::NFTCollectionId::get(), &position_id, Some(&who))?;\n\n\t\t\tSelf::deposit_event(Event::PositionDestroyed {\n\t\t\t\tposition_id,\n\t\t\t\towner: who,\n\t\t\t});\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Execute a swap of `asset_in` for `asset_out`.\n\t\t///\n\t\t/// Price is determined by the Omnipool.\n\t\t///\n\t\t/// Hub asset is traded separately.\n\t\t///\n\t\t/// Asset's tradable states must contain SELL flag for asset_in and BUY flag for asset_out, otherwise `NotAllowed` error is returned.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `asset_in`: ID of asset sold to the pool\n\t\t/// - `asset_out`: ID of asset bought from the pool\n\t\t/// - `amount`: Amount of asset sold\n\t\t/// - `min_buy_amount`: Minimum amount required to receive\n\t\t///\n\t\t/// Emits `SellExecuted` event when successful.\n\t\t///\n\t\t#[pallet::call_index(5)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::sell()\n\t\t\t.saturating_add(T::OmnipoolHooks::on_trade_weight())\n\t\t\t.saturating_add(T::OmnipoolHooks::on_liquidity_changed_weight())\n\t\t)]\n\t\t#[transactional]\n\t\tpub fn sell(\n\t\t\torigin: OriginFor<T>,\n\t\t\tasset_in: T::AssetId,\n\t\t\tasset_out: T::AssetId,\n\t\t\tamount: Balance,\n\t\t\tmin_buy_amount: Balance,\n\t\t) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin.clone())?;\n\n\t\t\tensure!(asset_in != asset_out, Error::<T>::SameAssetTradeNotAllowed);\n\n\t\t\tensure!(\n\t\t\t\tamount >= T::MinimumTradingLimit::get(),\n\t\t\t\tError::<T>::InsufficientTradingAmount\n\t\t\t);\n\n\t\t\tensure!(\n\t\t\t\tT::Currency::ensure_can_withdraw(asset_in, &who, amount).is_ok(),\n\t\t\t\tError::<T>::InsufficientBalance\n\t\t\t);\n\n\t\t\t// Special handling when one of the asset is Hub Asset\n\t\t\t// Math is simplified and asset_in is actually part of asset_out state in this case\n\t\t\tif asset_in == T::HubAssetId::get() {\n\t\t\t\treturn Self::sell_hub_asset(origin, &who, asset_out, amount, min_buy_amount);\n\t\t\t}\n\n\t\t\tif asset_out == T::HubAssetId::get() {\n\t\t\t\treturn Self::sell_asset_for_hub_asset(&who, asset_in, amount, min_buy_amount);\n\t\t\t}\n\n\t\t\tlet asset_in_state = Self::load_asset_state(asset_in)?;\n\t\t\tlet asset_out_state = Self::load_asset_state(asset_out)?;\n\n\t\t\tensure!(\n\t\t\t\tSelf::allow_assets(&asset_in_state, &asset_out_state),\n\t\t\t\tError::<T>::NotAllowed\n\t\t\t);\n\n\t\t\tensure!(\n\t\t\t\tamount\n\t\t\t\t\t<= asset_in_state\n\t\t\t\t\t\t.reserve\n\t\t\t\t\t\t.checked_div(T::MaxInRatio::get())\n\t\t\t\t\t\t.ok_or(ArithmeticError::DivisionByZero)?, // Note: this can only fail if MaxInRatio is zero.\n\t\t\t\tError::<T>::MaxInRatioExceeded\n\t\t\t);\n\n\t\t\tlet current_imbalance = <HubAssetImbalance<T>>::get();\n\n\t\t\tlet (asset_fee, _) = T::Fee::get(&asset_out);\n\t\t\tlet (_, protocol_fee) = T::"
    }
  ]
}