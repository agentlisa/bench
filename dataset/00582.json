{
  "Title": "An attacker can steal the StabilityPool depositors profit",
  "Content": "##### Description\nThe liquidation flow of the protocol is supposed to be as follows:\n- users open troves and join `StabilityPool`\n- anyone calls the `liquidateTroves` function that iterates the given troves and liquidates them one by one\n- `StabilityPool` depositors move collateral gains to their troves and increase the `StabilityPool` ThUSD balance by getting more ThUSD.\n\nBy using a flash loan any user can bypass the provision of liquidity to the protocol for a long time and steal some of the `StabilityPool` provider's profit taking the following steps:\n1. Let's wait for liquidation opportunities. The following notions are to be introduced: Lsum is the total liquidatable amount of ThUSD and FLusd is the amount of ThUSD that can be accumulated after depositing flashloaned collateral to the protocol; FLfee is the fees the attacker should pay for opening a trove, SPusd is the total ThUSD amount in `StabilityPool`.\nThe conditions for an attack are:\n Lsum < SPusd + FLusd\n FLfee < Lsum * FLusd / SPusd\n2. An attacker gets a flash loan and swaps the Lsum equivalent of the collateral token to ThUSD.\n3. The attacker makes a deposit of all remaining collateral tokens to `StabilityPool`.\n4. The attacker calls the [`TroveManager::liquidateTroves`](https://github.com/Threshold-USD/dev/blob/800c6c19e44628dfda3cecaea6eedcb498bf0bf3/packages/contracts/contracts/TroveManager.sol#L464) function to liquidate the troves. If the CR system is lower than 150%, the amount of liqudated troves can be significantly bigger.\n5. The attacker calls [`withdrawFromSP`](https://github.com/Threshold-USD/dev/blob/800c6c19e44628dfda3cecaea6eedcb498bf0bf3/packages/contracts/contracts/StabilityPool.sol#L283) then ['withdrawCollateralGainToTrove'](https://github.com/Threshold-USD/dev/blob/800c6c19e44628dfda3cecaea6eedcb498bf0bf3/packages/contracts/contracts/StabilityPool.sol#L310) of `StabilityPool` to move collateral to the attacker's trove. The CR System here has to be more than 150%.\n   The attacker's trove here contains the initial collateral and collateral gain.\n6. The attacker closes the trove providing the rest of ThUSD plus the Lsum equivalent from step 1.\n7. The attacker returns the flash loan.\n\nThe attack's impact:\n- loss of profit from liquidations by `StabilityPool` providers\n- decreased motivation to use the Stability Pool which may cause Threshold USD to unpeg\n\n##### Recommendation\nWe recommend that you use the time factor to prevent flash loan attacks.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "packages/contracts/contracts/TroveManager.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IStabilityPool.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ITHUSDToken.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/IPCV.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {\n\n    string constant public NAME = \"TroveManager\";\n\n    // --- Connected contract declarations ---\n\n    address public borrowerOperationsAddress;\n\n    IStabilityPool public override stabilityPool;\n\n    address gasPoolAddress;\n\n    ICollSurplusPool collSurplusPool;\n\n    ITHUSDToken public override thusdToken;\n\n    IPCV public override pcv;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    // --- Data structures ---\n\n    uint256 constant public SECONDS_IN_ONE_MINUTE = 60;\n    /*\n     * Half-life of 12h. 12h = 720 min\n     * (1/2) = d^720 => d = (1/2)^(1/720)\n     */\n    uint256 constant public MINUTE_DECAY_FACTOR = 999037758833783000;\n    uint256 constant public REDEMPTION_FEE_FLOOR = DECIMAL_PRECISION / 1000 * 5; // 0.5%\n    uint256 constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%\n\n    /*\n    * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption.\n    * Corresponds to (1 / ALPHA) in the white paper.\n    */\n    uint256 constant public BETA = 2;\n\n    uint256 public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new THUSD issuance)\n    uint256 public lastFeeOperationTime;\n\n    enum Status {\n        nonExistent,\n        active,\n        closedByOwner,\n        closedByLiquidation,\n        closedByRedemption\n    }\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint256 debt;\n        uint256 coll;\n        uint256 stake;\n        Status status;\n        uint128 arrayIndex;\n    }\n\n    mapping (address => Trove) public Troves;\n\n    uint256 public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint256 public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint256 public totalCollateralSnapshot;\n\n    /*\n    * L_Collateral and L_THUSDDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n    *\n    * An collateral gain of ( stake * [L_Collateral - L_Collateral(0)] )\n    * A THUSDDebt increase  of ( stake * [L_THUSDDebt - L_THUSDDebt(0)] )\n    *\n    * Where L_Collateral(0) and L_THUSDDebt(0) are snapshots of L_Collateral and L_THUSDDebt for the active Trove taken at the instant the stake was made\n    */\n    uint256 public L_Collateral;\n    uint256 public L_THUSDDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the collateral and THUSD snapshots for a given active trove\n    struct RewardSnapshot { uint256 collateral; uint256 THUSDDebt;}\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] public TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    uint256 public lastCollateralError_Redistribution;\n    uint256 public lastTHUSDDebtError_Redistribution;\n\n    /*\n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: \"CompilerError: Stack too deep\".\n    **/\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint256 price;\n        uint256 THUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint256 liquidatedDebt;\n        uint256 liquidatedColl;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        uint256 collToLiquidate;\n        uint256 pendingDebtReward;\n        uint256 pendingCollReward;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint256 remainingTHUSDInStabPool;\n        uint256 i;\n        uint256 ICR;\n        address user;\n        bool backToNormalMode;\n        uint256 entireSystemDebt;\n        uint256 entireSystemColl;\n    }\n\n    struct LiquidationValues {\n        uint256 entireTroveDebt;\n        uint256 entireTroveColl;\n        uint256 collGasCompensation;\n        uint256 THUSDGasCompensation;\n        uint256 debtToOffset;\n        uint256 collToSendToSP;\n        uint256 debtToRedistribute;\n        uint256 collToRedistribute;\n        uint256 collSurplus;\n    }\n\n    struct LiquidationTotals {\n        uint256 totalCollInSequence;\n        uint256 totalDebtInSequence;\n        uint256 totalCollGasCompensation;\n        uint256 totalTHUSDGasCompensation;\n        uint256 totalDebtToOffset;\n        uint256 totalCollToSendToSP;\n        uint256 totalDebtToRedistribute;\n        uint256 totalCollToRedistribute;\n        uint256 totalCollSurplus;\n    }\n\n    struct ContractsCache {\n        IActivePool activePool;\n        IDefaultPool defaultPool;\n        ITHUSDToken thusdToken;\n        IPCV pcv;\n        ISortedTroves sortedTroves;\n        ICollSurplusPool collSurplusPool;\n        address gasPoolAddress;\n    }\n    // --- Variable container structs for redemptions ---\n\n    struct RedemptionTotals {\n        uint256 remainingTHUSD;\n        uint256 totalTHUSDToRedeem;\n        uint256 totalCollateralDrawn;\n        uint256 collateralFee;\n        uint256 collateralToSendToRedeemer;\n        uint256 decayedBaseRate;\n        uint256 price;\n        uint256 totalTHUSDSupplyAtStart;\n    }\n\n    struct SingleRedemptionValues {\n        uint256 THUSDLot;\n        uint256 collateralLot;\n        bool cancelledPartial;\n    }\n\n    // --- Events ---\n    event TroveUpdated(address indexed _borrower, uint256 _debt, uint256 _coll, uint256 _stake, TroveManagerOperation _operation);\n    event TroveLiquidated(address indexed _borrower, uint256 _debt, uint256 _coll, TroveManagerOperation _operation);\n\n    enum TroveManagerOperation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        redeemCollateral\n    }\n\n\n    // --- Dependency setter ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _thusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _pcvAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_thusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_pcvAddress);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        thusdToken = ITHUSDToken(_thusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        pcv = IPCV(_pcvAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit THUSDTokenAddressChanged(_thusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit PCVAddressChanged(_pcvAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(uint256 _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.\n    function liquidate(address _borrower) external override {\n        _requireTroveIsActive(_borrower);\n\n        address[] memory borrowers = new address[](1);\n        borrowers[0] = _borrower;\n        batchLiquidateTroves(borrowers);\n    }\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower,\n        uint256 _THUSDInStabPool\n    )\n        internal\n        returns (LiquidationValues memory singleLiquidation)\n    {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n\n        (singleLiquidation.entireTroveDebt,\n        singleLiquidation.entireTroveColl,\n        vars.pendingDebtReward,\n        vars.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\n        _removeStake(_borrower);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(singleLiquidation.entireTroveColl);\n        singleLiquidation.THUSDGasCompensation = THUSD_GAS_COMPENSATION;\n        uint256 collToLiquidate = singleLiquidation.entireTroveColl - singleLiquidation.collGasCompensation;\n\n        (singleLiquidation.debtToOffset,\n        singleLiquidation.collToSendToSP,\n        singleLiquidation.debtToRedistribute,\n        singleLiquidation.collToRedistribute) = _getOffsetAndRedistributionVals(singleLiquidation.entireTroveDebt, collToLiquidate, _THUSDInStabPool);\n\n        _closeTrove(_borrower, Status.closedByLiquidation);\n        emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, TroveManagerOperation.liquidateInNormalMode);\n        emit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.liquidateInNormalMode);\n        return singleLiquidation;\n    }\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower,\n        uint256 _ICR,\n        uint256 _THUSDInStabPool,\n        uint256 _TCR,\n        uint256 _price\n    )\n        internal\n        returns (LiquidationValues memory singleLiquidation)\n    {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n        if (TroveOwners.length <= 1) {return singleLiquidation;} // don't liquidate if last trove\n        (singleLiquidation.entireTroveDebt,\n        singleLiquidation.entireTroveColl,\n        vars.pendingDebtReward,\n        vars.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(singleLiquidation.entireTroveColl);\n        singleLiquidation.THUSDGasCompensation = THUSD_GAS_COMPENSATION;\n        vars.collToLiquidate = singleLiquidation.entireTroveColl - singleLiquidation.collGasCompensation;\n\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR <= _100pct) {\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\n            _removeStake(_borrower);\n\n            singleLiquidation.debtToOffset = 0;\n            singleLiquidation.collToSendToSP = 0;\n            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;\n            singleLiquidation.collToRedistribute = vars.collToLiquidate;\n\n            _closeTrove(_borrower, Status.closedByLiquidation);\n            emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n            emit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.liquidateInRecoveryMode);\n\n        // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\n             _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\n            _removeStake(_borrower);\n\n            (singleLiquidation.debtToOffset,\n            singleLiquidation.collToSendToSP,\n            singleLiquidation.debtToRedistribute,\n            singleLiquidation.collToRedistribute) = _getOffsetAndRedistributionVals(singleLiquidation.entireTroveDebt, vars.collToLiquidate, _THUSDInStabPool);\n\n            _closeTrove(_borrower, Status.closedByLiquidation);\n            emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n            emit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.liquidateInRecoveryMode);\n        /*\n        * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\n        * and there is THUSD in the Stability Pool, only offset, with no redistribution,\n        * but at a capped rate of 1.1 and only if the whole debt can be liquidated.\n        * The remainder due to the capped rate will be claimable as collateral surplus.\n        */\n        } else if ((_ICR >= MCR) && (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _THUSDInStabPool)) {\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\n            assert(_THUSDInStabPool != 0);\n\n            _removeStake(_borrower);\n            singleLiquidation = _getCappedOffsetVals(singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, _price);\n\n            _closeTrove(_borrower, Status.closedByLiquidation);\n            if (singleLiquidation.collSurplus > 0) {\n                collSurplusPool.accountSurplus(_borrower, singleLiquidation.collSurplus);\n            }\n\n            emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.collToSendToSP, TroveManagerOperation.liquidateInRecoveryMode);\n            emit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.liquidateInRecoveryMode);\n\n        } else { // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _THUSDInStabPool))\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        return singleLiquidation;\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be\n    * redistributed to active troves.\n    */\n    function _getOffsetAndRedistributionVals\n    (\n        uint256 _debt,\n        uint256 _coll,\n        uint256 _THUSDInStabPool\n    )\n        internal\n        pure\n        returns (uint256 debtToOffset, uint256 collToSendToSP, uint256 debtToRedistribute, uint256 collToRedistribute)\n    {\n        if (_THUSDInStabPool > 0) {\n        /*\n        * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n        * between all active troves.\n        *\n        *  If the trove's debt is larger than the deposited THUSD in the Stability Pool:\n        *\n        *  - Offset an amount of the trove's debt equal to the THUSD in the Stability Pool\n        *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n        *\n        */\n            debtToOffset = LiquityMath._min(_debt, _THUSDInStabPool);\n            collToSendToSP = _coll * debtToOffset / _debt;\n            debtToRedistribute = _debt - debtToOffset;\n            collToRedistribute = _coll - collToSendToSP;\n        } else {\n            debtToOffset = 0;\n            collToSendToSP = 0;\n            debtToRedistribute = _debt;\n            collToRedistribute = _coll;\n        }\n    }\n\n    /*\n    *  Get its offset coll/debt and collateral gas comp, and close the trove.\n    */\n    function _getCappedOffsetVals\n    (\n        uint256 _entireTroveDebt,\n        uint256 _entireTroveColl,\n        uint256 _price\n    )\n        internal\n        pure\n        returns (LiquidationValues memory singleLiquidation)\n    {\n        singleLiquidation.entireTroveDebt = _entireTroveDebt;\n        singleLiquidation.entireTroveColl = _entireTroveColl;\n        uint256 cappedCollPortion = _entireTroveDebt * MCR / _price;\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(cappedCollPortion);\n        singleLiquidation.THUSDGasCompensation = THUSD_GAS_COMPENSATION;\n\n        singleLiquidation.debtToOffset = _entireTroveDebt;\n        singleLiquidation.collToSendToSP = cappedCollPortion - singleLiquidation.collGasCompensation;\n        singleLiquidation.collSurplus = _entireTroveColl - cappedCollPortion;\n        singleLiquidation.debtToRedistribute = 0;\n        singleLiquidation.collToRedistribute = 0;\n    }\n\n    /*\n    * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\n    * starting from the one with the lowest collateral ratio in the system, and moving upwards\n    */\n    function liquidateTroves(uint256 _n) external override {\n        ContractsCache memory contractsCache = ContractsCache(\n            activePool,\n            defaultPool,\n            ITHUSDToken(address(0)),\n            IPCV(address(0)),\n            sortedTroves,\n            ICollSurplusPool(address(0)),\n            address(0)\n        );\n        IStabilityPool stabilityPoolCached = stabilityPool;\n\n        LocalVariables_OuterLiquidationFunction memory vars;\n\n        LiquidationTotals memory totals;\n\n        vars.price = priceFeed.fetchPrice();\n        vars.THUSDInStabPool = stabilityPoolCached.getTotalTHUSDDeposits();\n        vars.recoveryModeAtStart = _checkRecoveryMode(vars.price);\n\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\n        if (vars.recoveryModeAtStart) {\n            totals = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(contractsCache, vars.price, vars.THUSDInStabPool, _n);\n        } else { // if !vars.recoveryModeAtStart\n            totals = _getTotalsFromLiquidateTrovesSequence_NormalMode(contractsCache.activePool, contractsCache.defaultPool, vars.price, vars.THUSDInStabPool, _n);\n        }\n\n        require(totals.totalDebtInSequence > 0, \"TroveManager: nothing to liquidate\");\n\n        // Move liquidated collateral and THUSD to the appropriate pools\n        stabilityPoolCached.offset(totals.totalDebtToOffset, totals.totalCollToSendToSP);\n        _redistributeDebtAndColl(contractsCache.activePool, contractsCache.defaultPool, totals.totalDebtToRedistribute, totals.totalCollToRedistribute);\n        if (totals.totalCollSurplus > 0) {\n            contractsCache.activePool.sendCollateral(address(collSurplusPool), totals.totalCollSurplus);\n        }\n\n        // Update system snapshots\n        _updateSystemSnapshots_excludeCollRemainder(contractsCache.activePool, totals.totalCollGasCompensation);\n\n        vars.liquidatedDebt = totals.totalDebtInSequence;\n        vars.liquidatedColl = totals.totalCollInSequence - totals.totalCollGasCompensation - totals.totalCollSurplus;\n        emit Liquidation(vars.liquidatedDebt, vars.liquidatedColl, totals.totalCollGasCompensation, totals.totalTHUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(contractsCache.activePool, msg.sender, totals.totalTHUSDGasCompensation, totals.totalCollGasCompensation);\n    }\n\n    /*\n    * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode\n    (\n        ContractsCache memory _contractsCache,\n        uint256 _price,\n        uint256 _THUSDInStabPool,\n        uint256 _n\n    )\n        internal\n        returns(LiquidationTotals memory totals)\n    {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingTHUSDInStabPool = _THUSDInStabPool;\n        vars.backToNormalMode = false;\n        vars.entireSystemDebt = getEntireSystemDebt();\n        vars.entireSystemColl = getEntireSystemColl();\n\n        vars.user = _contractsCache.sortedTroves.getLast();\n        address firstUser = _contractsCache.sortedTroves.getFirst();\n        for (vars.i = 0; vars.i < _n && vars.user != firstUser; vars.i++) {\n            // we need to cache it, because current user is likely going to be deleted\n            address nextUser = _contractsCache.sortedTroves.getPrev(vars.user);\n\n            vars.ICR = getCurrentICR(vars.user, _price);\n\n            if (!vars.backToNormalMode) {\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\n                if (vars.ICR >= MCR && vars.remainingTHUSDInStabPool == 0) { break; }\n\n                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt, _price);\n\n                singleLiquidation = _liquidateRecoveryMode(_contractsCache.activePool, _contractsCache.defaultPool, vars.user, vars.ICR, vars.remainingTHUSDInStabPool, TCR, _price);\n\n                // Update aggregate trackers\n                vars.remainingTHUSDInStabPool -= singleLiquidation.debtToOffset;\n                vars.entireSystemDebt -= singleLiquidation.debtToOffset;\n                vars.entireSystemColl -= singleLiquidation.collToSendToSP\n                    + singleLiquidation.collGasCompensation\n                    + singleLiquidation.collSurplus;\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(vars.entireSystemColl, vars.entireSystemDebt, _price);\n            }\n            else if (vars.backToNormalMode && vars.ICR < MCR) {\n                singleLiquidation = _liquidateNormalMode(_contractsCache.activePool, _contractsCache.defaultPool, vars.user, vars.remainingTHUSDInStabPool);\n\n                vars.remainingTHUSDInStabPool -= singleLiquidation.debtToOffset;\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n            }  else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            vars.user = nextUser;\n        }\n    }\n\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode\n    (\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _price,\n        uint256 _THUSDInStabPool,\n        uint256 _n\n    )\n        internal\n        returns(LiquidationTotals memory totals)\n    {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n        ISortedTroves sortedTrovesCached = sortedTroves;\n\n        vars.remainingTHUSDInStabPool = _THUSDInStabPool;\n\n        for (vars.i = 0; vars.i < _n; vars.i++) {\n            vars.user = sortedTrovesCached.getLast();\n            vars.ICR = getCurrentICR(vars.user, _price);\n\n            if (vars.ICR < MCR) {\n                singleLiquidation = _liquidateNormalMode(_activePool, _defaultPool, vars.user, vars.remainingTHUSDInStabPool);\n\n                vars.remainingTHUSDInStabPool -= singleLiquidation.debtToOffset;\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n            } else break;  // break if the loop reaches a Trove with ICR >= MCR\n        }\n    }\n\n    /*\n    * Attempt to liquidate a custom list of troves provided by the caller.\n    */\n    function batchLiquidateTroves(address[] memory _troveArray) public override {\n        require(_troveArray.length != 0, \"TroveManager: Calldata address array must not be empty\");\n\n        IActivePool activePoolCached = activePool;\n        IDefaultPool defaultPoolCached = defaultPool;\n        IStabilityPool stabilityPoolCached = stabilityPool;\n\n        LocalVariables_OuterLiquidationFunction memory vars;\n        LiquidationTotals memory totals;\n\n        vars.price = priceFeed.fetchPrice();\n        vars.THUSDInStabPool = stabilityPoolCached.getTotalTHUSDDeposits();\n        vars.recoveryModeAtStart = _checkRecoveryMode(vars.price);\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (vars.recoveryModeAtStart) {\n            totals = _getTotalFromBatchLiquidate_RecoveryMode(activePoolCached, defaultPoolCached, vars.price, vars.THUSDInStabPool, _troveArray);\n        } else {  //  if !vars.recoveryModeAtStart\n            totals = _getTotalsFromBatchLiquidate_NormalMode(activePoolCached, defaultPoolCached, vars.price, vars.THUSDInStabPool, _troveArray);\n        }\n\n        require(totals.totalDebtInSequence > 0, \"TroveManager: nothing to liquidate\");\n\n        // Move liquidated collateral and THUSD to the appropriate pools\n        stabilityPoolCached.offset(totals.totalDebtToOffset, totals.totalCollToSendToSP);\n        _redistributeDebtAndColl(activePoolCached, defaultPoolCached, totals.totalDebtToRedistribute, totals.totalCollToRedistribute);\n        if (totals.totalCollSurplus > 0) {\n            activePoolCached.sendCollateral(address(collSurplusPool), totals.totalCollSurplus);\n        }\n\n        // Update system snapshots\n        _updateSystemSnapshots_excludeCollRemainder(activePoolCached, totals.totalCollGasCompensation);\n\n        vars.liquidatedDebt = totals.totalDebtInSequence;\n        vars.liquidatedColl = totals.totalCollInSequence - totals.totalCollGasCompensation - totals.totalCollSurplus;\n        emit Liquidation(vars.liquidatedDebt, vars.liquidatedColl, totals.totalCollGasCompensation, totals.totalTHUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(activePoolCached, msg.sender, totals.totalTHUSDGasCompensation, totals.totalCollGasCompensation);\n    }\n\n    /*\n    * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalFromBatchLiquidate_RecoveryMode\n    (\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _price,\n        uint256 _THUSDInStabPool,\n        address[] memory _troveArray\n    )\n        internal\n        returns(LiquidationTotals memory totals)\n    {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingTHUSDInStabPool = _THUSDInStabPool;\n        vars.backToNormalMode = false;\n        vars.entireSystemDebt = getEntireSystemDebt();\n        vars.entireSystemColl = getEntireSystemColl();\n\n        for (vars.i = 0; vars.i < _troveArray.length; vars.i++) {\n            vars.user = _troveArray[vars.i];\n            // Skip non-active troves\n            if (Troves[vars.user].status != Status.active) { continue; }\n            vars.ICR = getCurrentICR(vars.user, _price);\n\n            if (!vars.backToNormalMode) {\n\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (vars.ICR >= MCR && vars.remainingTHUSDInStabPool == 0) { continue; }\n\n                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt, _price);\n\n                singleLiquidation = _liquidateRecoveryMode(_activePool, _defaultPool, vars.user, vars.ICR, vars.remainingTHUSDInStabPool, TCR, _price);\n\n                // Update aggregate trackers\n                vars.remainingTHUSDInStabPool -= singleLiquidation.debtToOffset;\n                vars.entireSystemDebt -= singleLiquidation.debtToOffset;\n                vars.entireSystemColl -= singleLiquidation.collToSendToSP\n                    + singleLiquidation.collGasCompensation\n                    + singleLiquidation.collSurplus;\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(vars.entireSystemColl, vars.entireSystemDebt, _price);\n            }\n\n            else if (vars.backToNormalMode && vars.ICR < MCR) {\n                singleLiquidation = _liquidateNormalMode(_activePool, _defaultPool, vars.user, vars.remainingTHUSDInStabPool);\n                vars.remainingTHUSDInStabPool -= singleLiquidation.debtToOffset;\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n            } else continue; // In Normal Mode skip troves with ICR >= MCR\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode\n    (\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _price,\n        uint256 _THUSDInStabPool,\n        address[] memory _troveArray\n    )\n        internal\n        returns(LiquidationTotals memory totals)\n    {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingTHUSDInStabPool = _THUSDInStabPool;\n\n        for (vars.i = 0; vars.i < _troveArray.length; vars.i++) {\n            vars.user = _troveArray[vars.i];\n            vars.ICR = getCurrentICR(vars.user, _price);\n\n            if (vars.ICR < MCR) {\n                singleLiquidation = _liquidateNormalMode(_activePool, _defaultPool, vars.user, vars.remainingTHUSDInStabPool);\n                vars.remainingTHUSDInStabPool -= singleLiquidation.debtToOffset;\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    function _addLiquidationValuesToTotals(LiquidationTotals memory oldTotals, LiquidationValues memory singleLiquidation)\n    internal pure returns(LiquidationTotals memory newTotals) {\n\n        // Tally all the values with their respective running totals\n        newTotals.totalCollGasCompensation = oldTotals.totalCollGasCompensation + singleLiquidation.collGasCompensation;\n        newTotals.totalTHUSDGasCompensation = oldTotals.totalTHUSDGasCompensation + singleLiquidation.THUSDGasCompensation;\n        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence + singleLiquidation.entireTroveDebt;\n        newTotals.totalCollInSequence = oldTotals.totalCollInSequence + singleLiquidation.entireTroveColl;\n        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset + singleLiquidation.debtToOffset;\n        newTotals.totalCollToSendToSP = oldTotals.totalCollToSendToSP + singleLiquidation.collToSendToSP;\n        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute + singleLiquidation.debtToRedistribute;\n        newTotals.totalCollToRedistribute = oldTotals.totalCollToRedistribute + singleLiquidation.collToRedistribute;\n        newTotals.totalCollSurplus = oldTotals.totalCollSurplus + singleLiquidation.collSurplus;\n\n        return newTotals;\n    }\n\n    function _sendGasCompensation(IActivePool _activePool, address _liquidator, uint256 _THUSD, uint256 _collateral) internal {\n        if (_THUSD > 0) {\n            thusdToken.returnFromPool(gasPoolAddress, _liquidator, _THUSD);\n        }\n\n        if (_collateral > 0) {\n            _activePool.sendCollateral(_liquidator, _collateral);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTrove"
    }
  ]
}