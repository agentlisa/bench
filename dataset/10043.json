{
  "Title": "[M-05] XSS via SVG Construction contract",
  "Content": "_Submitted by thank_you, also found by 0x1f8b_\n\nSVG is a unique type of image file format that is often susceptible to Cross-site scripting. If a malicious user is able to inject malicious Javascript into a SVG file, then any user who views the SVG on a website will be susceptible to XSS. This can lead stolen cookies, Denial of Service attacks, and more.\n\nThe `NFTTokenURIScaffold` contract generates a SVG via the `NFTSVG.constructSVG` function. One of the arguments used by the `NFTSVG.constructSVG` function is `svgTitle` which represents the ERC20 symbols of both the asset and collateral ERC20 tokens. When generating an ERC20 contract, a malicious user can set malicious XSS as the ERC20 symbol.\n\nThese set of circumstances leads to XSS when the SVG is loaded on any website.\n\n#### Proof of Concept\n\n1.  Hacker generates an ERC20 token with a symbol that contains malicious Javascript.\n2.  Hacker generates a TimeSwap Pair with an asset or collateral that matches the malicious ERC20 token created in Step 1.\n3.  When `NFTTokenURIScaffold#constructTokenURI` is called, a SVG is generated. This process works such that when generating the SVG the tainted ERC20 symbol created in Step 1 is [passed](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L90) to the `NFTSVG.constructSVG` function [here](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L102). This function returns a SVG [containing](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTSVG.sol#L27) the tainted ERC20 symbol.\n4.  When the SVG is loaded on any site such as OpenSea, any user viewing that SVG will load the malicious Javascript from within the SVG and result in a XSS attack.\n\n\n#### Recommended Mitigation Steps\n\nCreating a SVG file inside of a Solidity contract is novel and thus requires the entity creating a SVG file to sanitize any potential user-input that goes into generating the SVG file.\n\nAs of this time there are no known Solidity libraries that sanitize text to prevent an XSS attack. The easiest solution is to remove all user-input data from the SVG file or not generate the SVG at all.\n\n\n**[Mathepreneur (Timeswap) confirmed](https://github.com/code-423n4/2022-01-timeswap-findings/issues/131):**\n > We plan to add Safety String library.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-01-timeswap",
  "Code": [
    {
      "filename": "Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeMetadata} from './SafeMetadata.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\nimport {DateTime} from './DateTime.sol';\nimport './Base64.sol';\nimport {NFTSVG} from './NFTSVG.sol';\n\n\nlibrary NFTTokenURIScaffold {\n    using SafeMetadata for IERC20;\n    using Strings for uint256;\n\n    function tokenURI(\n        uint256 id,\n        IPair pair,\n        IPair.Due memory due,\n        uint256 maturity\n    ) public view returns (string memory) {\n\n        string memory uri = constructTokenSVG(\n            address(pair.asset()),\n            address(pair.collateral()),\n            id.toString(),\n            weiToPrecisionString(due.debt, pair.asset().safeDecimals()),\n            weiToPrecisionString(due.collateral, pair.collateral().safeDecimals()),\n            getReadableDateString(maturity),\n            maturity\n        );\n\n\n        string memory description = string(abi.encodePacked('This collateralized debt position represents a debt of ', weiToPrecisionString(due.debt, pair.asset().safeDecimals()), ' ', pair.asset().safeSymbol(), ' borrowed against a collateral of ', weiToPrecisionString(due.collateral, pair.collateral().safeDecimals()), ' ', pair.collateral().safeSymbol(), '. This position will expire on ', maturity.toString(), ' unix epoch time.\\\\nThe owner of this NFT has the option to pay the debt before maturity time to claim the locked collateral. In case the owner choose to default on the debt payment, the collateral will be forfeited'));\n        description = string(abi.encodePacked(description, '\\\\n\\\\nAsset Address: ', addressToString(address(pair.asset())), '\\\\nCollateral Address: ', addressToString(address(pair.collateral())), '\\\\nDebt Required: ', weiToPrecisionLongString(due.debt, pair.asset().safeDecimals()), ' ', IERC20(pair.asset()).safeSymbol(), '\\\\nCollateral Locked: ', weiToPrecisionLongString(due.collateral, pair.collateral().safeDecimals()), ' ', IERC20(pair.collateral()).safeSymbol()));\n\n\n        string memory name = \"Timeswap Collateralized Debt\";\n\n        return (constructTokenURI(name, description, uri));\n    }\n\n\n    function constructTokenURI(\n        string memory name,\n        string memory description,\n        string memory imageSVG\n    ) internal pure returns (string memory) {\n\n        return\n            string(\n                abi.encodePacked(\n                    'data:application/json;base64,',\n                    Base64.encode(\n                        bytes(\n                            abi.encodePacked(\n                                '{\"name\":\"',\n                                name,\n                                '\", \"description\":\"',\n                                description,\n                                '\", \"image\": \"',\n                                'data:image/svg+xml;base64,',\n                                Base64.encode(bytes(imageSVG)),\n                                '\"}'\n                            )\n                        )\n                    )\n                )\n            );\n    }\n\n\n\n    function constructTokenSVG (\n        address asset,\n        address collateral,\n        string memory tokenId,\n        string memory assetAmount, \n        string memory collateralAmount, \n        string memory maturityDate,\n        uint256 maturityTimestamp\n    ) internal view returns (string memory) {\n\n       \n\n        /// TODO - finalize SVG\n        NFTSVG.SVGParams memory params = NFTSVG.SVGParams({\n            tokenId: tokenId,\n            svgTitle: string(abi.encodePacked(parseSymbol(IERC20(asset).safeSymbol()), '/', parseSymbol(IERC20(collateral).safeSymbol()))),\n            assetInfo: string(abi.encodePacked(parseSymbol(IERC20(asset).safeSymbol()), ': ', addressToString(asset))),\n            collateralInfo: string(abi.encodePacked(parseSymbol(IERC20(collateral).safeSymbol()), ': ', addressToString(collateral))),\n            debtRequired: string(abi.encodePacked(assetAmount, ' ', parseSymbol(IERC20(asset).safeSymbol()))),\n            collateralLocked: string(abi.encodePacked(collateralAmount, ' ', parseSymbol(IERC20(collateral).safeSymbol()))),\n            maturityDate: maturityDate,\n            isMatured: block.timestamp > maturityTimestamp,\n            maturityTimestampString: maturityTimestamp.toString(),\n            tokenColors: getSVGCData(asset, collateral)\n\n        });\n\n        return NFTSVG.constructSVG(params);\n    }\n\n    function weiToPrecisionLongString(uint256 weiAmt, uint256 decimal) public pure returns (string memory) {\n        if (decimal == 0) {\n            return string(abi.encodePacked(weiAmt.toString(), '.00'));\n        }\n\n        uint256 significantDigits = weiAmt/(10 ** decimal);\n        uint256 precisionDigits = weiAmt % (10 ** (decimal));\n        \n        if (precisionDigits == 0) {\n            return string(abi.encodePacked(significantDigits.toString(), '.00'));\n        }\n\n        string memory precisionDigitsString = toStringTrimmed(precisionDigits);\n        uint lengthDiff = decimal - bytes(precisionDigits.toString()).length;\n        for(uint i = 0; i < lengthDiff; i++) {\n            precisionDigitsString = string(abi.encodePacked('0', precisionDigitsString));\n        }\n\n        return string(abi.encodePacked(significantDigits.toString(), '.', precisionDigitsString));\n    }\n    \n    function weiToPrecisionString(uint256 weiAmt, uint256 decimal) public pure returns (string memory) {\n        if (decimal == 0) {\n            return string(abi.encodePacked(weiAmt.toString(), '.00'));\n        }\n\n        uint256 significantDigits = weiAmt/(10 ** decimal);\n        if (significantDigits > 10 ** 9) {\n            string memory weiAmtString = weiAmt.toString();\n            uint len = bytes(weiAmtString).length - 9;\n            weiAmt = weiAmt / (10 ** len);\n            return string(abi.encodePacked(weiAmt.toString(), '...'));\n        }\n        uint256 precisionDigits = weiAmt % (10 ** (decimal));\n        precisionDigits = precisionDigits/(10 ** (decimal - 4));\n        \n        if (precisionDigits == 0) {\n            return string(abi.encodePacked(significantDigits.toString(), '.00'));\n        }\n\n        string memory precisionDigitsString = toStringTrimmed(precisionDigits);\n        uint lengthDiff = 4 - bytes(precisionDigits.toString()).length;\n        for(uint i = 0; i < lengthDiff; i++) {\n            precisionDigitsString = string(abi.encodePacked('0', precisionDigitsString));\n        }\n\n        return string(abi.encodePacked(significantDigits.toString(), '.', precisionDigitsString));\n    }\n    \n    function toStringTrimmed(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        uint256 flag;\n        while (temp != 0) {\n            if (temp % 10 == 0 && flag == 0) {\n                temp /= 10;\n                continue;\n            } else if (temp % 10 != 0 && flag == 0) {\n                flag++;\n                digits++;\n            } else {\n                digits++;\n            }\n            \n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        flag = 0;\n        while (value != 0) {\n            if (value % 10 == 0 && flag == 0) {\n                value /= 10;\n                continue;\n            } else if (value % 10 != 0 && flag == 0) {\n                flag++;\n                digits -= 1;\n                buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            } else {\n                digits -= 1;\n                buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            }\n            \n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    function addressToString(address _addr) public pure returns (string memory) {\n        bytes memory data = abi.encodePacked(_addr);\n        bytes memory alphabet = '0123456789abcdef';\n\n        bytes memory str = new bytes(2 + data.length * 2);\n        str[0] = '0';\n        str[1] = 'x';\n        for (uint256 i = 0; i < data.length; i++) {\n            str[2 + i * 2] = alphabet[uint256(uint8(data[i] >> 4))];\n            str[3 + i * 2] = alphabet[uint256(uint8(data[i] & 0x0f))];\n        }\n        return string(str);\n    }\n\n\n    function getSlice(uint256 begin, uint256 end, string memory text) public pure returns (string memory) {\n        bytes memory a = new bytes(end-begin+1);\n        for(uint i=0;i<=end-begin;i++){\n            a[i] = bytes(text)[i+begin-1];\n        }\n        return string(a);    \n    }\n    \n    function parseSymbol(string memory symbol) public pure returns (string memory) {\n        if (bytes(symbol).length > 5) {\n            return getSlice(1, 5, symbol);\n        }\n        return symbol;\n    }\n\n    function getMonthString(uint256 _month) public pure returns (string memory) {\n        string[12] memory months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n        return months[_month];\n    }\n\n    function getReadableDateString(uint256 timestamp) public pure returns (string memory) {\n        \n        (uint year, uint month, uint day, uint hour, uint minute, uint second) = DateTime.timestampToDateTime(timestamp);\n        \n        string memory result = string(abi.encodePacked(\n            day.toString(),\n            ' ',\n            getMonthString(month - 1),\n            ' ',\n            year.toString(),\n            ', ',\n            padWithZero(hour),\n            ':',\n            padWithZero(minute),\n            ':',\n            padWithZero(second),\n            ' UTC'\n        ));\n        return result;\n    }\n\n    function padWithZero(uint value) public pure returns (string memory) {\n        if (value < 10) {\n            return string(abi.encodePacked('0', value.toString()));\n        }\n        return value.toString();\n    }\n\n    function getLightColor(address token) public pure returns (string memory) {\n        string[15] memory lightColors = [\n            'F7BAF7',\n            'F7C8BA',\n            'FAE2BE',\n            'BAE1F7',\n            'EBF7BA',\n            'CEF7BA',\n            'CED2EF',\n            'CABAF7',\n            'BAF7E5',\n            'BACFF7',\n            'F7BAE3',\n            'F7E9BA',\n            'E0BAF7',\n            'F7BACF',\n            'FFFFFF'\n        ];\n        uint160 tokenValue = uint160(token) % 15;\n        return(lightColors[tokenValue]);\n    }\n\n    function getDarkColor(address token) public pure returns (string memory) {\n\n        string[15] memory darkColors = [\n            'DF51EC',\n            'EC7651',\n            'ECAE51',\n            '51B4EC',\n            'A4C327',\n            '59C327',\n            '5160EC',\n            '7951EC',\n            '27C394',\n            '5185EC',\n            'EC51B8',\n            'F4CB3A',\n            'B151EC',\n            'EC5184',\n            'C5C0C2'\n        ];\n        uint160 tokenValue = uint160(token) % 15;\n        return(darkColors[tokenValue]);\n    }\n\n    function getSVGCData(address asset, address collateral) public pure returns (string memory) {\n            string memory token0LightColor = string(abi.encodePacked('.C{fill:#', getLightColor(asset), '}'));\n            string memory token0DarkColor = string(abi.encodePacked('.D{fill:#', getDarkColor(asset), '}'));\n            string memory token1LightColor = string(abi.encodePacked('.E{fill:#', getLightColor(collateral), '}'));\n            string memory token1DarkColor = string(abi.encodePacked('.F{fill:#', getDarkColor(collateral), '}'));\n\n            return string(abi.encodePacked(token0LightColor, token0DarkColor, token1LightColor, token1DarkColor));\n    }\n\n\n}"
    }
  ]
}