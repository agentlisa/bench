{
  "Title": "[G-03] Combine multiple for loop",
  "Content": "Whenever possible, it's best to avoid running several for loops one after the other. Most of the time, they can be combined. This avoids certain initialization and counting operations. It's even more interesting when you can take advantage of values that have already been calculated (in this case, a sum of lengths).\n\n*2 instances*\n\n- [L2SecurityCouncilMgmtFactory.sol#L107-L121](https://github.com/arbitrumfoundation/governance/blob/c18de53820c505fc459f766c1b224810eaeaabc5/src/security-council-mgmt/factories/L2SecurityCouncilMgmtFactory.sol#L107-L121) \n\n```diff\n+\t\tuint256 totalCohortLength = dp.firstCohort.length + dp.secondCohort.length;\n-       if (owners.length != (dp.firstCohort.length + dp.secondCohort.length)) {\n+       if  (owners.length !=  (totalCohortLength))  {\n            revert InvalidCohortsSize(owners.length, dp.firstCohort.length, dp.secondCohort.length);\n        }\n\n-        for (uint256 i = 0; i < dp.firstCohort.length; i++) {\n-            if (!govChainEmergencySCSafe.isOwner(dp.firstCohort[i])) {\n-                revert AddressNotInCouncil(owners, dp.firstCohort[i]);\n-            }\n-        }\n\n-        for (uint256 i = 0; i < dp.secondCohort.length; i++) {\n-            if (!govChainEmergencySCSafe.isOwner(dp.secondCohort[i])) {\n-                revert AddressNotInCouncil(owners, dp.secondCohort[i]);\n-           }\n-       }\n+\t\tfor (uint256 i = 0; i < totalCohortLength; i++) {\n+\t\t\taddress cohortMember; \n+\t\t\tif (i < dp.firstCohort.length) { \n+\t\t\t\tcohortMember = dp.firstCohort[i]; \n+\t\t\t} \n+\t\t\telse { \n+\t\t\t\tcohortMember = dp.secondCohort[i - dp.firstCohort.length];\n+\t\t\t} \n+\t\t\tif (!govChainEmergencySCSafe.isOwner(cohortMember)) { \n+\t\t\t\trevert AddressNotInCouncil(owners, cohortMember); \n+\t\t\t} \n+\t\t}\n```\n\nApplying this optimisation, those changes appear in the snapshot:\n\n```\ntestE2E() (gas: -38080 (-0.046%))\ntestSecurityCouncilManagerDeployment() (gas: -38605 (-0.129%))\ntestNomineeElectionGovDeployment() (gas: -38605 (-0.129%))\ntestRemovalGovDeployment() (gas: -38605 (-0.129%))\ntestMemberElectionGovDeployment() (gas: -38605 (-0.129%))\ntestOnlyOwnerCanDeploy() (gas: -38667 (-0.154%))\nOverall gas change: -231167 (-0.016%)\n```\n\n- [SecurityCouncilMemberSyncAction.sol#L60-L72](https://github.com/arbitrumfoundation/governance/blob/c18de53820c505fc459f766c1b224810eaeaabc5/src/security-council-mgmt/SecurityCouncilMemberSyncAction.sol#L60-L72)\n\n```diff\n-        for (uint256 i = 0; i < _updatedMembers.length; i++) {\n-            address member = _updatedMembers[i];\n-            if (!securityCouncil.isOwner(member)) {\n-                _addMember(securityCouncil, member, threshold);\n-            }\n-        }\n-        \n-        for (uint256 i = 0; i < previousOwners.length; i++) {\n-            address owner = previousOwners[i];\n-            if (!SecurityCouncilMgmtUtils.isInArray(owner, _updatedMembers)) {\n-                _removeMember(securityCouncil, owner, threshold);\n-            }\n-        }\n\n+        for (uint256 i = 0; i < _updatedMembers.length || i < previousOwners.length; i++) {\n+            if (i < _updatedMembers.length) {\n+                address member = _updatedMembers[i];\n+                if (!securityCouncil.isOwner(member)) {\n+                    _addMember(securityCouncil, member, threshold);\n+                }\n+            }\n+            \n+            if (i < previousOwners.length) {\n+                address owner = previousOwners[i];\n+                if (!SecurityCouncilMgmtUtils.isInArray(owner, _updatedMembers)) {\n+                    _removeMember(securityCouncil, owner, threshold);\n+                }\n+            }\n+        }\n\n```\n\nApplying this optimisation, those changes appear in the snapshot:\n\n```\ntestNonces() (gas: -944 (-0.011%))\ntestE2E() (gas: -52904 (-0.064%))\nOverall gas change: -53848 (-0.004%)\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-08-arbitrum",
  "Code": [
    {
      "filename": "src/security-council-mgmt/factories/L2SecurityCouncilMgmtFactory.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../governors/SecurityCouncilMemberElectionGovernor.sol\";\nimport \"../governors/SecurityCouncilNomineeElectionGovernor.sol\";\nimport \"../SecurityCouncilManager.sol\";\nimport \"../governors/SecurityCouncilMemberRemovalGovernor.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport \"../interfaces/ISecurityCouncilManager.sol\";\nimport \"../interfaces/IGnosisSafe.sol\";\nimport \"../../ArbitrumTimelock.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/utils/IVotesUpgradeable.sol\";\nimport \"../../UpgradeExecRouteBuilder.sol\";\nimport \"../Common.sol\";\n\nstruct DeployParams {\n    ChainAndUpExecLocation[] upgradeExecutors;\n    address govChainEmergencySecurityCouncil;\n    address l1ArbitrumTimelock;\n    address l2CoreGovTimelock;\n    address govChainProxyAdmin;\n    address[] secondCohort;\n    address[] firstCohort;\n    address l2UpgradeExecutor;\n    address arbToken;\n    uint256 l1TimelockMinDelay;\n    uint256 removalGovVotingDelay;\n    uint256 removalGovVotingPeriod;\n    uint256 removalGovQuorumNumerator;\n    uint256 removalGovProposalThreshold;\n    uint256 removalGovVoteSuccessNumerator;\n    uint64 removalGovMinPeriodAfterQuorum;\n    uint256 removalProposalExpirationBlocks;\n    SecurityCouncilData[] securityCouncils;\n    Date firstNominationStartDate;\n    uint256 nomineeVettingDuration;\n    address nomineeVetter;\n    uint256 nomineeQuorumNumerator;\n    uint256 nomineeVotingPeriod;\n    uint256 memberVotingPeriod;\n    uint256 fullWeightDuration;\n}\n\nstruct ContractImplementations {\n    address nomineeElectionGovernor;\n    address memberElectionGovernor;\n    address securityCouncilManager;\n    address securityCouncilMemberRemoverGov;\n}\n\n/// @notice Factory for deploying L2 Security Council management contracts.\n/// Prerequisites: core Arb DAO governance contracts, and a SecurityCouncilMemberSyncAction deployed for each governed security council (on each corresponding chain)\ncontract L2SecurityCouncilMgmtFactory is Ownable {\n    event ContractsDeployed(DeployedContracts deployedContracts);\n\n    // contracts deployed by factory\n    struct DeployedContracts {\n        SecurityCouncilNomineeElectionGovernor nomineeElectionGovernor;\n        SecurityCouncilMemberElectionGovernor memberElectionGovernor;\n        ISecurityCouncilManager securityCouncilManager;\n        SecurityCouncilMemberRemovalGovernor securityCouncilMemberRemoverGov;\n        UpgradeExecRouteBuilder upgradeExecRouteBuilder;\n    }\n\n    error AddressNotInCouncil(address[] securityCouncil, address account);\n    error InvalidCohortsSize(uint256 councilSize, uint256 firstCohortSize, uint256 secondCohortSize);\n\n    /// @dev deploys a transparent proxy for the given implementation contract\n    function _deployProxy(address proxyAdmin, address impl, bytes memory initData)\n        internal\n        returns (address)\n    {\n        return address(new TransparentUpgradeableProxy(impl, proxyAdmin, initData));\n    }\n\n    /// @notice deploys the L2 Security Council management contracts\n    /// @param  dp the deployment parameters\n    /// @param  impls contract implementations to deploy proxies for\n    function deploy(DeployParams memory dp, ContractImplementations memory impls)\n        external\n        onlyOwner\n        returns (DeployedContracts memory)\n    {\n        if (!Address.isContract(dp.govChainEmergencySecurityCouncil)) {\n            revert NotAContract(dp.govChainEmergencySecurityCouncil);\n        }\n\n        if (!Address.isContract(dp.govChainProxyAdmin)) {\n            revert NotAContract(dp.govChainProxyAdmin);\n        }\n\n        if (!Address.isContract(dp.l2UpgradeExecutor)) {\n            revert NotAContract(dp.l2UpgradeExecutor);\n        }\n\n        if (!Address.isContract(dp.arbToken)) {\n            revert NotAContract(dp.arbToken);\n        }\n\n        if (dp.nomineeVetter == address(0)) {\n            revert ZeroAddress();\n        }\n        IGnosisSafe govChainEmergencySCSafe = IGnosisSafe(dp.govChainEmergencySecurityCouncil);\n        address[] memory owners = govChainEmergencySCSafe.getOwners();\n        if (owners.length != (dp.firstCohort.length + dp.secondCohort.length)) {\n            revert InvalidCohortsSize(owners.length, dp.firstCohort.length, dp.secondCohort.length);\n        }\n\n        for (uint256 i = 0; i < dp.firstCohort.length; i++) {\n            if (!govChainEmergencySCSafe.isOwner(dp.firstCohort[i])) {\n                revert AddressNotInCouncil(owners, dp.firstCohort[i]);\n            }\n        }\n\n        for (uint256 i = 0; i < dp.secondCohort.length; i++) {\n            if (!govChainEmergencySCSafe.isOwner(dp.secondCohort[i])) {\n                revert AddressNotInCouncil(owners, dp.secondCohort[i]);\n            }\n        }\n\n        DeployedContracts memory deployedContracts;\n\n        // deploy nominee election governor\n        deployedContracts.nomineeElectionGovernor = SecurityCouncilNomineeElectionGovernor(\n            payable(_deployProxy(dp.govChainProxyAdmin, impls.nomineeElectionGovernor, \"\"))\n        );\n\n        // deploy member election governor\n        deployedContracts.memberElectionGovernor = SecurityCouncilMemberElectionGovernor(\n            payable(_deployProxy(dp.govChainProxyAdmin, impls.memberElectionGovernor, \"\"))\n        );\n\n        // deploy security council manager\n        deployedContracts.securityCouncilManager = SecurityCouncilManager(\n            _deployProxy(dp.govChainProxyAdmin, impls.securityCouncilManager, \"\")\n        );\n\n        // deploy security council member remover gov\n        deployedContracts.securityCouncilMemberRemoverGov = SecurityCouncilMemberRemovalGovernor(\n            payable(_deployProxy(dp.govChainProxyAdmin, impls.securityCouncilMemberRemoverGov, \"\"))\n        );\n\n        // create council manager roles\n        address[] memory memberRemovers = new address[](2);\n        memberRemovers[0] = address(deployedContracts.securityCouncilMemberRemoverGov);\n        memberRemovers[1] = dp.govChainEmergencySecurityCouncil;\n        SecurityCouncilManagerRoles memory roles = SecurityCouncilManagerRoles({\n            admin: dp.l2UpgradeExecutor,\n            cohortUpdator: address(deployedContracts.memberElectionGovernor),\n            memberAdder: dp.govChainEmergencySecurityCouncil,\n            memberRemovers: memberRemovers,\n            memberRotator: dp.govChainEmergencySecurityCouncil,\n            memberReplacer: dp.govChainEmergencySecurityCouncil\n        });\n\n        deployedContracts.upgradeExecRouteBuilder = new UpgradeExecRouteBuilder({\n            _upgradeExecutors: dp.upgradeExecutors,\n            _l1ArbitrumTimelock: dp.l1ArbitrumTimelock,\n            _l1TimelockMinDelay: dp.l1TimelockMinDelay\n        });\n\n        // init the deployed contracts\n        _initElectionGovernors(\n            dp,\n            deployedContracts.securityCouncilManager,\n            deployedContracts.nomineeElectionGovernor,\n            deployedContracts.memberElectionGovernor\n        );\n\n        deployedContracts.securityCouncilManager.initialize({\n            _firstCohort: dp.firstCohort,\n            _secondCohort: dp.secondCohort,\n            _securityCouncils: dp.securityCouncils,\n            _roles: roles,\n            _l2CoreGovTimelock: payable(dp.l2CoreGovTimelock),\n            _router: deployedContracts.upgradeExecRouteBuilder\n        });\n\n        _initRemovalGov(\n            dp,\n            deployedContracts.securityCouncilManager,\n            deployedContracts.securityCouncilMemberRemoverGov\n        );\n\n        emit ContractsDeployed(deployedContracts);\n        return deployedContracts;\n    }\n\n    /// @dev initializes the removal governor\n    function _initRemovalGov(\n        DeployParams memory dp,\n        ISecurityCouncilManager _securityCouncilManager,\n        SecurityCouncilMemberRemovalGovernor securityCouncilMemberRemoverGov\n    ) internal {\n        securityCouncilMemberRemoverGov.initialize({\n            _securityCouncilManager: _securityCouncilManager,\n            _voteSuccessNumerator: dp.removalGovVoteSuccessNumerator,\n            _token: IVotesUpgradeable(dp.arbToken),\n            _owner: dp.l2UpgradeExecutor,\n            _votingDelay: dp.removalGovVotingDelay,\n            _votingPeriod: dp.removalGovVotingPeriod,\n            _quorumNumerator: dp.removalGovQuorumNumerator,\n            _proposalThreshold: dp.removalGovProposalThreshold,\n            _minPeriodAfterQuorum: dp.removalGovMinPeriodAfterQuorum,\n            _proposalExpirationBlocks: dp.removalProposalExpirationBlocks\n        });\n    }\n\n    /// @dev initializes the election governors\n    function _initElectionGovernors(\n        DeployParams memory dp,\n        ISecurityCouncilManager securityCouncilManager,\n        SecurityCouncilNomineeElectionGovernor nomineeElectionGovernor,\n        SecurityCouncilMemberElectionGovernor memberElectionGovernor\n    ) internal {\n        nomineeElectionGovernor.initialize(\n            SecurityCouncilNomineeElectionGovernor.InitParams({\n                firstNominationStartDate: dp.firstNominationStartDate,\n                nomineeVettingDuration: dp.nomineeVettingDuration,\n                nomineeVetter: dp.nomineeVetter,\n                securityCouncilManager: securityCouncilManager,\n                securityCouncilMemberElectionGovernor: memberElectionGovernor,\n                token: IVotesUpgradeable(dp.arbToken),\n                owner: dp.l2UpgradeExecutor,\n                quorumNumeratorValue: dp.nomineeQuorumNumerator,\n                votingPeriod: dp.nomineeVotingPeriod\n            })\n        );\n\n        memberElectionGovernor.initialize({\n            _nomineeElectionGovernor: nomineeElectionGovernor,\n            _securityCouncilManager: securityCouncilManager,\n            _token: IVotesUpgradeable(dp.arbToken),\n            _owner: dp.l2UpgradeExecutor,\n            _votingPeriod: dp.memberVotingPeriod,\n            _fullWeightDuration: dp.fullWeightDuration\n        });\n    }\n}"
    },
    {
      "filename": "src/security-council-mgmt/SecurityCouncilMemberSyncAction.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.16;\n\nimport \"./interfaces/IGnosisSafe.sol\";\nimport \"./SecurityCouncilMgmtUtils.sol\";\nimport \"../gov-action-contracts/execution-record/ActionExecutionRecord.sol\";\n\n/// @notice Action contract for updating security council members. Used by the security council management system.\n///         Expected to be delegate called into by an Upgrade Executor\ncontract SecurityCouncilMemberSyncAction is ActionExecutionRecord {\n    error PreviousOwnerNotFound(address targetOwner, address securityCouncil);\n    error ExecFromModuleError(bytes data, address securityCouncil);\n\n    event UpdateNonceTooLow(\n        address indexed securityCouncil, uint256 currrentNonce, uint256 providedNonce\n    );\n\n    /// @dev Used in the gnosis safe as the first entry in their ownership linked list\n    address public constant SENTINEL_OWNERS = address(0x1);\n\n    constructor(KeyValueStore _store)\n        ActionExecutionRecord(_store, \"SecurityCouncilMemberSyncAction\")\n    {}\n\n    /// @notice Updates members of security council multisig to match provided array\n    /// @dev    This function contains O(n^2) operations, so doesnt scale for large numbers of members. Expected count is 12, which is acceptable.\n    ///         Gnosis OwnerManager handles reverting if address(0) is passed to remove/add owner\n    /// @param _securityCouncil The security council to update\n    /// @param _updatedMembers  The new list of members. The Security Council will be updated to have this exact list of members\n    /// @return res indicates whether an update took place\n    function perform(address _securityCouncil, address[] memory _updatedMembers, uint256 _nonce)\n        external\n        returns (bool res)\n    {\n        // make sure that _nonce is greater than the last nonce\n        // we do this to ensure that a previous update does not occur after a later one\n        // the mechanism just checks greater, not n+1, because the Security Council Manager always\n        // sends the latest full list of members so it doesn't matter if some updates are missed\n        // Additionally a retryable ticket could be used to execute the update, and since tickets\n        // expire if not executed after some time, then allowing updates to be skipped means that the\n        // system will not be blocked if a retryable ticket is expires\n        uint256 updateNonce = getUpdateNonce(_securityCouncil);\n        if (_nonce <= updateNonce) {\n            // when nonce is too now, we simply return, we don't revert.\n            // this way an out of date update will actual execute, rather than remaining in an unexecuted state forever\n            emit UpdateNonceTooLow(_securityCouncil, updateNonce, _nonce);\n            return false;\n        }\n\n        // store the nonce as a record of execution\n        // use security council as the key to ensure that updates to different security councils are kept separate\n        _setUpdateNonce(_securityCouncil, _nonce);\n\n        IGnosisSafe securityCouncil = IGnosisSafe(_securityCouncil);\n        // preserve current threshold, the safe ensures that the threshold is never lower than the member count\n        uint256 threshold = securityCouncil.getThreshold();\n\n        address[] memory previousOwners = securityCouncil.getOwners();\n\n        for (uint256 i = 0; i < _updatedMembers.length; i++) {\n            address member = _updatedMembers[i];\n            if (!securityCouncil.isOwner(member)) {\n                _addMember(securityCouncil, member, threshold);\n            }\n        }\n\n        for (uint256 i = 0; i < previousOwners.length; i++) {\n            address owner = previousOwners[i];\n            if (!SecurityCouncilMgmtUtils.isInArray(owner, _updatedMembers)) {\n                _removeMember(securityCouncil, owner, threshold);\n            }\n        }\n        return true;\n    }\n\n    function _addMember(IGnosisSafe securityCouncil, address _member, uint256 _threshold)\n        internal\n    {\n        _execFromModule(\n            securityCouncil,\n            abi.encodeWithSelector(IGnosisSafe.addOwnerWithThreshold.selector, _member, _threshold)\n        );\n    }\n\n    function _removeMember(IGnosisSafe securityCouncil, address _member, uint256 _threshold)\n        internal\n    {\n        address previousOwner = getPrevOwner(securityCouncil, _member);\n        _execFromModule(\n            securityCouncil,\n            abi.encodeWithSelector(\n                IGnosisSafe.removeOwner.selector, previousOwner, _member, _threshold\n            )\n        );\n    }\n\n    function getPrevOwner(IGnosisSafe securityCouncil, address _owner)\n        public\n        view\n        returns (address)\n    {\n        // owners are stored as a linked list and removal requires the previous owner\n        address[] memory owners = securityCouncil.getOwners();\n        address previousOwner = SENTINEL_OWNERS;\n        for (uint256 i = 0; i < owners.length; i++) {\n            address currentOwner = owners[i];\n            if (currentOwner == _owner) {\n                return previousOwner;\n            }\n            previousOwner = currentOwner;\n        }\n        revert PreviousOwnerNotFound({\n            targetOwner: _owner,\n            securityCouncil: address(securityCouncil)\n        });\n    }\n\n    function getUpdateNonce(address securityCouncil) public view returns (uint256) {\n        return _get(uint160(securityCouncil));\n    }\n\n    function _setUpdateNonce(address securityCouncil, uint256 nonce) internal {\n        _set(uint160(securityCouncil), nonce);\n    }\n\n    /// @notice Execute provided operation via gnosis safe's trusted execTransactionFromModule entry point\n    function _execFromModule(IGnosisSafe securityCouncil, bytes memory data) internal {\n        if (\n            !securityCouncil.execTransactionFromModule(\n                address(securityCouncil), 0, data, OpEnum.Operation.Call\n            )\n        ) {\n            revert ExecFromModuleError({data: data, securityCouncil: address(securityCouncil)});\n        }\n    }\n}"
    }
  ]
}