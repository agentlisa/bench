{
  "Title": "[L-01] Weight of one being used as zero not documented",
  "Content": "<h2 id=\"l-01-weight-of-one-being-used-as-zero-not-documented\" style=\"position:relative;\"><a href=\"#l-01-weight-of-one-being-used-as-zero-not-documented\" aria-label=\"l 01 weight of one being used as zero not documented permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-01] Weight of one being used as zero not documented</h2>\n<p>The comments and code below say that a weight of one is being used as a weight of zero. If a project is mature, or eventually becomes mature, a weight of one may in fact be a useful weighting, and the project owners will become very confused when they are unable to receive funds with this weighting.</p>\n<p><em>There is 1 instance of this issue:</em></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"22\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">JBFundingCycleStore</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">   #</span><span class=\"mtk7\">1</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">467</span><span class=\"mtk1\">        </span><span class=\"mtk3\">// A weight of 1 is treated as a weight of 0.</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">468</span><span class=\"mtk1\">        </span><span class=\"mtk3\">// This is to allow a weight of 0 (default) to represent inheriting the discounted weight of the previous funding cycle.</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">469</span><span class=\"mtk1\">        </span><span class=\"mtk12\">_weight</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_weight</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">470</span><span class=\"mtk1\">          ? (</span><span class=\"mtk12\">_weight</span><span class=\"mtk1\"> == </span><span class=\"mtk7\">1</span><span class=\"mtk1\"> ? </span><span class=\"mtk7\">0</span><span class=\"mtk1\"> : </span><span class=\"mtk12\">_weight</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">471</span><span class=\"mtk1\">:         : </span><span class=\"mtk11\">_deriveWeightFrom</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_baseFundingCycle</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_start</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p><a href=\"https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBFundingCycleStore.sol#L467-L471\">https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBFundingCycleStore.sol#L467-L471</a></p>\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-07-juicebox-v2-contest",
  "Code": [
    {
      "filename": "contracts/JBFundingCycleStore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport '@paulrberg/contracts/math/PRBMath.sol';\nimport './abstract/JBControllerUtility.sol';\nimport './libraries/JBConstants.sol';\n\n/** \n  @notice \n  Manages funding cycle configurations and scheduling.\n\n  @dev\n  Adheres to -\n  IJBTokenStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\n\n  @dev\n  Inherits from -\n  JBControllerUtility: Includes convenience functionality for checking if the message sender is the current controller of the project whose data is being manipulated.\n*/\ncontract JBFundingCycleStore is IJBFundingCycleStore, JBControllerUtility {\n  //*********************************************************************//\n  // --------------------------- custom errors ------------------------- //\n  //*********************************************************************//\n  error INVALID_DISCOUNT_RATE();\n  error INVALID_DURATION();\n  error INVALID_WEIGHT();\n  error INVALID_BALLOT();\n  error NO_SAME_BLOCK_RECONFIGURATION();\n\n  //*********************************************************************//\n  // --------------------- private stored properties ------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice\n    Stores the user defined properties of each funding cycle, packed into one storage slot.\n\n    _projectId The ID of the project to get properties of.\n    _configuration The funding cycle configuration to get properties of.\n  */\n  mapping(uint256 => mapping(uint256 => uint256)) private _packedUserPropertiesOf;\n\n  /** \n    @notice\n    Stores the properties added by the mechanism to manage and schedule each funding cycle, packed into one storage slot.\n    \n    _projectId The ID of the project to get instrinsic properties of.\n    _configuration The funding cycle configuration to get properties of.\n  */\n  mapping(uint256 => mapping(uint256 => uint256)) private _packedIntrinsicPropertiesOf;\n\n  /** \n    @notice\n    Stores the metadata for each funding cycle configuration, packed into one storage slot.\n\n    _projectId The ID of the project to get metadata of.\n    _configuration The funding cycle configuration to get metadata of.\n  */\n  mapping(uint256 => mapping(uint256 => uint256)) private _metadataOf;\n\n  //*********************************************************************//\n  // --------------------- public stored properties -------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice \n    The latest funding cycle configuration for each project.\n\n    _projectId The ID of the project to get the latest funding cycle configuration of.\n  */\n  mapping(uint256 => uint256) public override latestConfigurationOf;\n\n  //*********************************************************************//\n  // ------------------------- external views -------------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice \n    Get the funding cycle with the given configuration for the specified project.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n    @param _configuration The configuration of the funding cycle to get.\n\n    @return fundingCycle The funding cycle.\n  */\n  function get(uint256 _projectId, uint256 _configuration)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle)\n  {\n    return _getStructFor(_projectId, _configuration);\n  }\n\n  /**\n    @notice \n    The latest funding cycle to be configured for the specified project, and its current ballot state.\n\n    @param _projectId The ID of the project to get the latest configured funding cycle of.\n\n    @return fundingCycle The project's queued funding cycle.\n    @return ballotState The state of the ballot for the reconfiguration.\n  */\n  function latestConfiguredOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBBallotState ballotState)\n  {\n    // Get a reference to the latest funding cycle configuration.\n    uint256 _fundingCycleConfiguration = latestConfigurationOf[_projectId];\n\n    // Resolve the funding cycle for the latest configuration.\n    fundingCycle = _getStructFor(_projectId, _fundingCycleConfiguration);\n\n    // Resolve the ballot state.\n    ballotState = _ballotStateOf(\n      _projectId,\n      fundingCycle.configuration,\n      fundingCycle.start,\n      fundingCycle.basedOn\n    );\n  }\n\n  /**\n    @notice \n    The funding cycle that's next up for the specified project.\n\n    @dev\n    If a queued funding cycle of the project is not found, returns an empty funding cycle with all properties set to 0.\n\n    @param _projectId The ID of the project to get the queued funding cycle of.\n\n    @return fundingCycle The project's queued funding cycle.\n  */\n  function queuedOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle)\n  {\n    // If the project does not have a funding cycle, return an empty struct.\n    if (latestConfigurationOf[_projectId] == 0) return _getStructFor(0, 0);\n\n    // Get a reference to the configuration of the standby funding cycle.\n    uint256 _standbyFundingCycleConfiguration = _standbyOf(_projectId);\n\n    // If it exists, return its funding cycle if it is approved.\n    if (_standbyFundingCycleConfiguration > 0) {\n      fundingCycle = _getStructFor(_projectId, _standbyFundingCycleConfiguration);\n\n      if (_isApproved(_projectId, fundingCycle)) return fundingCycle;\n\n      // Resolve the funding cycle for the latest configured funding cycle.\n      fundingCycle = _getStructFor(_projectId, fundingCycle.basedOn);\n    } else {\n      // Resolve the funding cycle for the latest configured funding cycle.\n      fundingCycle = _getStructFor(_projectId, latestConfigurationOf[_projectId]);\n\n      // If the latest funding cycle starts in the future, it must start in the distant future\n      // since its not in standby. In this case base the queued cycles on the base cycle.\n      if (fundingCycle.start > block.timestamp)\n        fundingCycle = _getStructFor(_projectId, fundingCycle.basedOn);\n    }\n\n    // There's no queued if the current has a duration of 0.\n    if (fundingCycle.duration == 0) return _getStructFor(0, 0);\n\n    // Check to see if this funding cycle's ballot is approved.\n    // If so, return a funding cycle based on it.\n    if (_isApproved(_projectId, fundingCycle)) return _mockFundingCycleBasedOn(fundingCycle, false);\n\n    // Get the funding cycle of its base funding cycle, which carries the last approved configuration.\n    fundingCycle = _getStructFor(_projectId, fundingCycle.basedOn);\n\n    // There's no queued if the base, which must still be the current, has a duration of 0.\n    if (fundingCycle.duration == 0) return _getStructFor(0, 0);\n\n    // Return a mock of the next up funding cycle.\n    return _mockFundingCycleBasedOn(fundingCycle, false);\n  }\n\n  /**\n    @notice \n    The funding cycle that is currently active for the specified project.\n\n    @dev\n    If a current funding cycle of the project is not found, returns an empty funding cycle with all properties set to 0.\n\n    @param _projectId The ID of the project to get the current funding cycle of.\n\n    @return fundingCycle The project's current funding cycle.\n  */\n  function currentOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle)\n  {\n    // If the project does not have a funding cycle, return an empty struct.\n    if (latestConfigurationOf[_projectId] == 0) return _getStructFor(0, 0);\n\n    // Get a reference to the configuration of the eligible funding cycle.\n    uint256 _fundingCycleConfiguration = _eligibleOf(_projectId);\n\n    // Keep a reference to the eligible funding cycle.\n    JBFundingCycle memory _fundingCycle;\n\n    // If an eligible funding cycle exists...\n    if (_fundingCycleConfiguration > 0) {\n      // Resolve the funding cycle for the eligible configuration.\n      _fundingCycle = _getStructFor(_projectId, _fundingCycleConfiguration);\n\n      // Check to see if this funding cycle's ballot is approved.\n      // If so, return it.\n      if (_isApproved(_projectId, _fundingCycle)) return _fundingCycle;\n\n      // If it hasn't been approved, set the funding cycle configuration to be the configuration of the funding cycle that it's based on,\n      // which carries the last approved configuration.\n      _fundingCycleConfiguration = _fundingCycle.basedOn;\n    } else {\n      // No upcoming funding cycle found that is eligible to become active,\n      // so use the last configuration.\n      _fundingCycleConfiguration = latestConfigurationOf[_projectId];\n\n      // Get the funding cycle for the latest ID.\n      _fundingCycle = _getStructFor(_projectId, _fundingCycleConfiguration);\n\n      // If it's not approved or if it hasn't yet started, get a reference to the funding cycle that the latest is based on, which has the latest approved configuration.\n      if (!_isApproved(_projectId, _fundingCycle) || block.timestamp < _fundingCycle.start)\n        _fundingCycleConfiguration = _fundingCycle.basedOn;\n    }\n\n    // If there is not funding cycle to base the current one on, there can't be a current one.\n    if (_fundingCycleConfiguration == 0) return _getStructFor(0, 0);\n\n    // The funding cycle to base a current one on.\n    _fundingCycle = _getStructFor(_projectId, _fundingCycleConfiguration);\n\n    // If the base has no duration, it's still the current one.\n    if (_fundingCycle.duration == 0) return _fundingCycle;\n\n    // Return a mock of the current funding cycle.\n    return _mockFundingCycleBasedOn(_fundingCycle, true);\n  }\n\n  /** \n    @notice \n    The current ballot state of the project.\n\n    @param _projectId The ID of the project to check the ballot state of.\n\n    @return The project's current ballot's state.\n  */\n  function currentBallotStateOf(uint256 _projectId) external view override returns (JBBallotState) {\n    // Get a reference to the latest funding cycle configuration.\n    uint256 _fundingCycleConfiguration = latestConfigurationOf[_projectId];\n\n    // Resolve the funding cycle for the latest configuration.\n    JBFundingCycle memory _fundingCycle = _getStructFor(_projectId, _fundingCycleConfiguration);\n\n    return\n      _ballotStateOf(\n        _projectId,\n        _fundingCycle.configuration,\n        _fundingCycle.start,\n        _fundingCycle.basedOn\n      );\n  }\n\n  //*********************************************************************//\n  // -------------------------- constructor ---------------------------- //\n  //*********************************************************************//\n\n  /** \n    @param _directory A contract storing directories of terminals and controllers for each project.\n  */\n  // solhint-disable-next-line no-empty-blocks\n  constructor(IJBDirectory _directory) JBControllerUtility(_directory) {}\n\n  //*********************************************************************//\n  // ---------------------- external transactions ---------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice \n    Configures the next eligible funding cycle for the specified project.\n\n    @dev\n    Only a project's current controller can configure its funding cycles.\n\n    @param _projectId The ID of the project being configured.\n    @param _data The funding cycle configuration data.\n    @param _metadata Arbitrary extra data to associate with this funding cycle configuration that's not used within.\n    @param _mustStartAtOrAfter The time before which the initialized funding cycle cannot start.\n\n    @return The funding cycle that the configuration will take effect during.\n  */\n  function configureFor(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    uint256 _metadata,\n    uint256 _mustStartAtOrAfter\n  ) external override onlyController(_projectId) returns (JBFundingCycle memory) {\n    // Duration must fit in a uint64.\n    if (_data.duration > type(uint64).max) revert INVALID_DURATION();\n\n    // Discount rate must be less than or equal to 100%.\n    if (_data.discountRate > JBConstants.MAX_DISCOUNT_RATE) revert INVALID_DISCOUNT_RATE();\n\n    // Weight must fit into a uint88.\n    if (_data.weight > type(uint88).max) revert INVALID_WEIGHT();\n\n    // Ballot should be a valid contract, supporting the correct interface\n    if(_data.ballot != IJBFundingCycleBallot(address(0))) {\n\n      address _ballot = address(_data.ballot);\n      uint32 _size;\n      assembly {\n        _size := extcodesize(_ballot) // No contract at the address ?\n      }\n      if (_size == 0) revert INVALID_BALLOT();\n\n      try _data.ballot.supportsInterface(type(IJBFundingCycleBallot).interfaceId) returns (bool _supports) {\n        if(!_supports) revert INVALID_BALLOT(); // Contract exists at the address but with the wrong interface\n      } catch {\n        revert INVALID_BALLOT(); // No ERC165 support\n      }\n    }\n\n    // The configuration timestamp is now.\n    uint256 _configuration = block.timestamp;\n\n    // Set up a reconfiguration by configuring intrinsic properties.\n    _configureIntrinsicPropertiesFor(\n      _projectId,\n      _configuration,\n      _data.weight,\n      // Must start on or after the current timestamp.\n      _mustStartAtOrAfter > block.timestamp ? _mustStartAtOrAfter : block.timestamp\n    );\n\n    // Efficiently stores a funding cycles provided user defined properties.\n    // If all user config properties are zero, no need to store anything as the default value will have the same outcome.\n    if (\n      _data.ballot != IJBFundingCycleBallot(address(0)) ||\n      _data.duration > 0 ||\n      _data.discountRate > 0\n    ) {\n      // ballot in bits 0-159 bytes.\n      uint256 packed = uint160(address(_data.ballot));\n\n      // duration in bits 160-223 bytes.\n      packed |= _data.duration << 160;\n\n      // discountRate in bits 224-255 bytes.\n      packed |= _data.discountRate << 224;\n\n      // Set in storage.\n      _packedUserPropertiesOf[_projectId][_configuration] = packed;\n    }\n\n    // Set the metadata if needed.\n    if (_metadata > 0) _metadataOf[_projectId][_configuration] = _metadata;\n\n    emit Configure(_configuration, _projectId, _data, _metadata, _mustStartAtOrAfter, msg.sender);\n\n    // Return the funding cycle for the new configuration.\n    return _getStructFor(_projectId, _configuration);\n  }\n\n  //*********************************************************************//\n  // --------------------- private helper functions -------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice \n    Updates the configurable funding cycle for this project if it exists, otherwise creates one.\n\n    @param _projectId The ID of the project to find a configurable funding cycle for.\n    @param _configuration The time at which the funding cycle was configured.\n    @param _weight The weight to store in the configured funding cycle.\n    @param _mustStartAtOrAfter The time before which the initialized funding cycle can't start.\n  */\n  function _configureIntrinsicPropertiesFor(\n    uint256 _projectId,\n    uint256 _configuration,\n    uint256 _weight,\n    uint256 _mustStartAtOrAfter\n  ) private {\n    // If there's not yet a funding cycle for the project, initialize one.\n    if (latestConfigurationOf[_projectId] == 0)\n      // Use an empty funding cycle as the base.\n      return\n        _initFor(_projectId, _getStructFor(0, 0), _configuration, _mustStartAtOrAfter, _weight);\n\n    // Get the active funding cycle's configuration.\n    uint256 _currentConfiguration = _eligibleOf(_projectId);\n\n    // If an eligible funding cycle does not exist, get a reference to the latest funding cycle configuration for the project.\n    if (_currentConfiguration == 0)\n      // Get the latest funding cycle's configuration.\n      _currentConfiguration = latestConfigurationOf[_projectId];\n\n    // Get a reference to the funding cycle.\n    JBFundingCycle memory _baseFundingCycle = _getStructFor(_projectId, _currentConfiguration);\n\n    if (!_isApproved(_projectId, _baseFundingCycle) || block.timestamp < _baseFundingCycle.start)\n      // If it hasn't been approved or hasn't yet started, set the ID to be the funding cycle it's based on,\n      // which carries the latest approved configuration.\n      _baseFundingCycle = _getStructFor(_projectId, _baseFundingCycle.basedOn);\n\n    // The configuration can't be the same as the base configuration.\n    if (_baseFundingCycle.configuration == _configuration) revert NO_SAME_BLOCK_RECONFIGURATION();\n\n    // The time after the ballot of the provided funding cycle has expired.\n    // If the provided funding cycle has no ballot, return the current timestamp.\n    uint256 _timestampAfterBallot = _baseFundingCycle.ballot == IJBFundingCycleBallot(address(0))\n      ? 0\n      : _configuration + _baseFundingCycle.ballot.duration();\n\n    _initFor(\n      _projectId,\n      _baseFundingCycle,\n      _configuration,\n      // Can only start after the ballot.\n      _timestampAfterBallot > _mustStartAtOrAfter ? _timestampAfterBallot : _mustStartAtOrAfter,\n      _weight\n    );\n  }\n\n  /**\n    @notice \n    Initializes a funding cycle with the specified properties.\n\n    @param _projectId The ID of the project to which the funding cycle being initialized belongs.\n    @param _baseFundingCycle The funding cycle to base the initialized one on.\n    @param _configuration The configuration of the funding cycle being initialized.\n    @param _mustStartAtOrAfter The time before which the initialized funding cycle cannot start.\n    @param _weight The weight to give the newly initialized funding cycle.\n  */\n  function _initFor(\n    uint256 _projectId,\n    JBFundingCycle memory _baseFundingCycle,\n    uint256 _configuration,\n    uint256 _mustStartAtOrAfter,\n    uint256 _weight\n  ) private {\n    // If there is no base, initialize a first cycle.\n    if (_baseFundingCycle.number == 0) {\n      // The first number is 1.\n      uint256 _number = 1;\n\n      // Set fresh intrinsic properties.\n      _packAndStoreIntrinsicPropertiesOf(\n        _configuration,\n        _projectId,\n        _number,\n        _weight,\n        _baseFundingCycle.configuration,\n        _mustStartAtOrAfter\n      );\n    } else {\n      // Derive the correct next start time from the base.\n      uint256 _start = _deriveStartFrom(_baseFundingCycle, _mustStartAtOrAfter);\n\n      // A weight of 1 is treated as a weight of 0.\n      // This is to allow a weight of 0 (default) to represent inheriting the discounted weight of the previous funding cycle.\n      _weight = _weight > 0\n        ? (_weight == 1 ? 0 : _weight)\n        : _deriveWeightFrom(_baseFundingCycle, _start);\n\n      // Derive the correct number.\n      uint256 _number = _deriveNumberFrom(_baseFundingCycle, _start);\n\n      // Update the intrinsic properties.\n      _packAndStoreIntrinsicPropertiesOf(\n        _configuration,\n        _projectId,\n        _number,\n        _weight,\n        _baseFundingCycle.configuration,\n        _start\n      );\n    }\n\n    // Set the project's latest funding cycle configuration.\n    latestConfigurationOf[_projectId] = _configuration;\n\n    emit Init(_configuration, _projectId, _baseFundingCycle.configuration);\n  }\n\n  /**\n    @notice \n    Efficiently stores a funding cycle's provided intrinsic properties.\n\n    @param _configuration The configuration of the funding cycle to pack and store.\n    @param _projectId The ID of the project to which the funding cycle belongs.\n    @param _number The number of the funding cycle.\n    @param _weight The weight of the funding cycle.\n    @param _basedOn The configuration of the base funding cycle.\n    @param _start The start time of this funding cycle.\n  */\n  function _packAndStoreIntrinsicPropertiesOf(\n    uint256 _configuration,\n    uint256 _projectId,\n    uint256 _number,\n    uint256 _weight,\n    uint256 _basedOn,\n    uint256 _start\n  ) private {\n    // weight in bits 0-87.\n    uint256 packed = _weight;\n\n    // basedOn in bits 88-143.\n    packed |= _basedOn << 88;\n\n    // start in bits 144-199.\n    packed |= _start << 144;\n\n    // number in bits 200-255.\n    packed |= _number << 200;\n\n    // Store the packed value.\n    _packedIntrinsicPropertiesOf[_projectId][_configuration] = packed;\n  }\n\n  /**\n    @notice \n    The project's stored funding cycle that hasn't yet started and should be used next, if one exists.\n\n    @dev\n    A value of 0 is returned if no funding cycle was found.\n\n    @dev\n    Assumes the project has a latest configuration.\n    \n    @param _projectId The ID of a project to look through for a standby cycle.\n\n    @return configuration The configuration of the standby funding cycle if one exists, or 0 if one doesn't exist.\n  */\n  function _standbyOf(uint256 _projectId) private view returns (uint256 configuration) {\n    // Get a reference to the project's latest funding cycle.\n    configuration = latestConfigurationOf[_projectId];\n\n    // Get the necessary properties for the latest funding cycle.\n    JBFundingCycle memory _fundingCycle = _getStructFor(_projectId, configuration);\n\n    // There is no upcoming funding cycle if the latest funding cycle has already started.\n    if (block.timestamp >= _fundingCycle.start) return 0;\n\n    // If this is the first funding cycle, it is queued.\n    if (_fundingCycle.number == 1) return configuration;\n\n    // Get the necessary properties for the base funding cycle.\n    JBFundingCycle memory _baseFundingCycle = _getStructFor(_projectId, _fundingCycle.basedOn);\n\n    // If the latest configuration doesn't start until after another base cycle, return 0.\n    if (\n      _baseFundingCycle.duration > 0 &&\n      block.timestamp < _fundingCycle.start - _baseFundingCycle.duration\n    ) return 0;\n  }\n\n  /**\n    @notice \n    The project's stored funding cycle that has started and hasn't yet expired.\n    \n    @dev\n    A value of 0 is returned if no funding cycle was found.\n\n    @dev\n    Assumes the project has a latest configuration.\n\n    @param _projectId The ID of the project to look through.\n\n    @return configuration The configuration of an eligible funding cycle if one exists, or 0 if one doesn't exist.\n  */\n  function _eligibleOf(uint256 _projectId) private view returns (uint256 configuration) {\n    // Get a reference to the project's latest funding cycle.\n    configuration = latestConfigurationOf[_projectId];\n\n    // Get the latest funding cycle.\n    JBFundingCycle memory _fundingCycle = _getStructFor(_projectId, configuration);\n\n    // If the latest is expired, return an empty funding cycle.\n    // A duration of 0 cannot be expired.\n    if (\n      _fundingCycle.duration > 0 && block.timestamp >= _fundingCycle.start + _fundingCycle.duration\n    ) return 0;\n\n    // Return the funding cycle's configuration if it has started.\n    if (block.timestamp >= _fundingCycle.start) return _fundingCycle.configuration;\n\n    // Get a reference to the cycle's base configuration.\n    JBFundingCycle memory _baseFundingCycle = _getStructFor(_projectId, _fundingCycle.basedOn);\n\n    // If the base cycle isn't eligible, the project has no eligible cycle.\n    // A duration of 0 is always eligible.\n    if (\n      _baseFundingCycle.duration > 0 &&\n      block.timestamp >= _baseFundingCycle.start + _baseFundingCycle.duration\n    ) return 0;\n\n    // Return the configuration that the latest funding cycle is based on.\n    configuration = _fundingCycle.basedOn;\n  }\n\n  /** \n    @notice \n    A view of the funding cycle that would be created based on the provided one if the project doesn't make a reconfiguration.\n\n    @dev\n    Returns an empty funding cycle if there can't be a mock funding cycle based on the provided one.\n\n    @dev\n    Assumes a funding cycle with a duration of 0 will never be asked to be the base of a mock.\n\n    @param _baseFundingCycle The funding cycle that the resulting funding cycle should follow.\n    @param _allowMidCycle A flag indicating if the mocked funding cycle is allowed to already be mid cycle.\n\n    @return A mock of what the next funding cycle will be.\n  */\n  function _mockFundingCycleBasedOn(JBFundingCycle memory _baseFundingCycle, bool _allowMidCycle)\n    private\n    view\n    returns (JBFundingCycle memory)\n  {\n    // Get the distance of the current time to the start of the next possible funding cycle.\n    // If the returned mock cycle must not yet have started, the start time of the mock must be in the future.\n    uint256 _mustStartAtOrAfter = !_allowMidCycle\n      ? block.timestamp + 1\n      : block.timestamp - _baseFundingCycle.duration + 1;\n\n    // Derive what the start time should be.\n    uint256 _start = _deriveStartFrom(_baseFundingCycle, _mustStartAtOrAfter);\n\n    // Derive what the number should be.\n    uint256 _number = _deriveNumberFrom(_baseFundingCycle, _start);\n\n    return\n      JBFundingCycle(\n        _number,\n        _baseFundingCycle.configuration,\n        _baseFundingCycle.basedOn,\n        _start,\n        _baseFundingCycle.duration,\n        _deriveWeightFrom(_baseFundingCycle, _start),\n        _baseFundingCycle.discountRate,\n        _baseFundingCycle.ballot,\n        _baseFundingCycle.metadata\n      );\n  }\n\n  /** \n    @notice \n    The date that is the nearest multiple of the specified funding cycle's duration from its end.\n\n    @param _baseFundingCycle The funding cycle to base the calculation on.\n    @param _mustStartAtOrAfter A date that the derived start must be on or come after.\n\n    @return start The next start time.\n  */\n  function _deriveStartFrom(JBFundingCycle memory _baseFundingCycle, uint256 _mustStartAtOrAfter)\n    private\n    pure\n    returns (uint256 start)\n  {\n    // A subsequent cycle to one with a duration of 0 should start as soon as possible.\n    if (_baseFundingCycle.duration == 0) return _mustStartAtOrAfter;\n\n    // The time when the funding cycle immediately after the specified funding cycle starts.\n    uint256 _nextImmediateStart = _baseFundingCycle.start + _baseFundingCycle.duration;\n\n    // If the next immediate start is now or in the future, return it.\n    if (_nextImmediateStart >= _mustStartAtOrAfter) return _nextImmediateStart;\n\n    // The amount of seconds since the `_mustStartAtOrAfter` time which results in a start time that might satisfy the specified constraints.\n    uint256 _timeFromImmediateStartMultiple = (_mustStartAtOrAfter - _nextImmediateStart) %\n      _baseFundingCycle.duration;\n\n    // A reference to the first possible start timestamp.\n    start = _mustStartAtOrAfter - _timeFromImmediateStartMultiple;\n\n    // Add increments of duration as necessary to satisfy the threshold.\n    while (_mustStartAtOrAfter > start) start = start + _baseFundingCycle.duration;\n  }\n\n  /** \n    @notice \n    The accumulated weight change since the specified funding cycle.\n\n    @param _baseFundingCycle The funding cycle to base the calculation on.\n    @param _start The start time of the funding cycle to derive a number for.\n\n    @return weight The derived weight, as a fixed point number with 18 decimals.\n  */\n  function _deriveWeightFrom(JBFundingCycle memory _baseFundingCycle, uint256 _start)\n    private\n    pure\n    returns (uint256 weight)\n  {\n    // A subsequent cycle to one with a duration of 0 should have the next possible weight.\n    if (_baseFundingCycle.duration == 0)\n      return\n        PRBMath.mulDiv(\n          _baseFundingCycle.weight,\n          JBConstants.MAX_DISCOUNT_RATE - _baseFundingCycle.discountRate,\n          JBConstants.MAX_DISCOUNT_RATE\n        );\n\n    // The weight should be based off the base funding cycle's weight.\n    weight = _baseFundingCycle.weight;\n\n    // If the discount is 0, the weight doesn't change.\n    if (_baseFundingCycle.discountRate == 0) return weight;\n\n    // The difference between the start of the base funding cycle and the proposed start.\n    uint256 _startDistance = _start - _baseFundingCycle.start;\n\n    // Apply the base funding cycle's discount rate for each cycle that has passed.\n    uint256 _discountMultiple = _startDistance / _baseFundingCycle.duration;\n\n    for (uint256 i = 0; i < _discountMultiple; i++) {\n      // The number of times to apply the discount rate.\n      // Base the new weight on the specified funding cycle's weight.\n      weight = PRBMath.mulDiv(\n        weight,\n        JBConstants.MAX_DISCOUNT_RATE - _baseFundingCycle.discountRate,\n        JBConstants.MAX_DISCOUNT_RATE\n      );\n      // The calculation doesn't need to continue if the weight is 0.\n      if (weight == 0) break;\n    }\n  }\n\n  /** \n    @notice \n    The number of the next funding cycle given the specified funding cycle.\n\n    @param _baseFundingCycle The funding cycle to base the calculation on.\n    @param _start The start time of the funding cycle to derive a number for.\n\n    @return The funding cycle number.\n  */\n  function _deriveNumberFrom(JBFundingCycle memory _baseFundingCycle, uint256 _start)\n    private\n    pure\n    returns (uint256)\n  {\n    // A subsequent cycle to one with a duration of 0 should be the next number.\n    if (_baseFundingCycle.duration == 0) return _baseFundingCycle.number + 1;\n\n    // The difference between the start of the base funding cycle and the proposed start.\n    uint256 _startDistance = _start - _baseFundingCycle.start;\n\n    // Find the number of base cycles that fit in the start distance.\n    return _baseFundingCycle.number + (_startDistance / _baseFundingCycle.duration);\n  }\n\n  /** \n    @notice \n    Checks to see if the provided funding cycle is approved according to the correct ballot.\n\n    @param _projectId The ID of the project to which the funding cycle belongs. \n    @param _fundingCycle The funding cycle to get an approval flag for.\n\n    @return The approval flag.\n  */\n  function _isApproved(uint256 _projectId, JBFundingCycle memory _fundingCycle)\n    private\n    view\n    returns (bool)\n  {\n    return\n      _ballotStateOf(\n        _projectId,\n        _fundingCycle.configuration,\n        _fundingCycle.start,\n        _fundingCycle.basedOn\n      ) == JBBallotState.Approved;\n  }\n\n  /**\n    @notice \n    A project's latest funding cycle configuration approval status.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n    @param _configuration The funding cycle configuration to get the ballot state of.\n    @param _start The start time of the funding cycle configuration to get the ballot state of.\n    @param _ballotFundingCycleConfiguration The configuration of the funding cycle which is configured with the ballot that should be used.\n\n    @return The ballot state of the project.\n  */\n  function _ballotStateOf(\n    uint256 _projectId,\n    uint256 _configuration,\n    uint256 _start,\n    uint256 _ballotFundingCycleConfiguration\n  ) private view returns (JBBallotState) {\n    // If there is no ballot funding cycle, implicitly approve.\n    if (_ballotFundingCycleConfiguration == 0) return JBBallotState.Approved;\n\n    // Get the ballot funding cycle.\n    JBFundingCycle memory _ballotFundingCycle = _getStructFor(\n      _projectId,\n      _ballotFundingCycleConfiguration\n    );\n\n    // If there is no ballot, the ID is auto approved.\n    // Otherwise if the ballot's duration hasn't passed, its still active.\n    // Otherwise, return the ballot's state.\n    if (_ballotFundingCycle.ballot == IJBFundingCycleBallot(address(0)))\n      return JBBallotState.Approved;\n    else if (_ballotFundingCycle.ballot.duration() >= block.timestamp - _configuration)\n      return JBBallotState.Active;\n    else return _ballotFundingCycle.ballot.stateOf(_projectId, _configuration, _start);\n  }\n\n  /**\n    @notice \n    Unpack a funding cycle's packed stored values into an easy-to-work-with funding cycle struct.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n    @param _configuration The funding cycle configuration to get the full struct for.\n\n    @return fundingCycle A funding cycle struct.\n  */\n  function _getStructFor(uint256 _projectId, uint256 _configuration)\n    private\n    view\n    returns (JBFundingCycle memory fundingCycle)\n  {\n    // Return an empty funding cycle if the configuration specified is 0.\n    if (_configuration == 0) return fundingCycle;\n\n    fundingCycle.configuration = _configuration;\n\n    uint256 _packedIntrinsicProperties = _packedIntrinsicPropertiesOf[_projectId][_configuration];\n\n    // weight in bits 0-87 bits.\n    fundingCycle.weight = uint256(uint88(_packedIntrinsicProperties));\n    // basedOn in bits 88-143 bits.\n    fundingCycle.basedOn = uint256(uint56(_packedIntrinsicProperties >> 88));\n    // start in bits 144-199 bits.\n    fundingCycle.start = uint256(uint56(_packedIntrinsicProperties >> 144));\n    // number in bits 20"
    }
  ]
}