{
  "Title": "Bootloader Uses Incorrect Value for System Contract Upgrade Log Key",
  "Content": "The [`SystemLogKey` enum](https://github.com/matter-labs/era-contracts/blob/abcbaf390a30c09eb53ae83d84bebab95a8003f7/l1-contracts/contracts/zksync/interfaces/IExecutor.sol#L8-L19) is employed by the L2 system contracts to distinguish between logs. As per its definition, the value assigned to [`EXPECTED_SYSTEM_CONTRACT_UPGRADE_TX_HASH_KEY`](https://github.com/matter-labs/era-contracts/blob/abcbaf390a30c09eb53ae83d84bebab95a8003f7/l1-contracts/contracts/zksync/interfaces/IExecutor.sol#L18) is `9`. However, in the [`bootloader.yul` file](https://github.com/matter-labs/era-contracts/blob/abcbaf390a30c09eb53ae83d84bebab95a8003f7/system-contracts/bootloader/bootloader.yul), the [`protocolUpgradeTxHashKey` function](https://github.com/matter-labs/era-contracts/blob/abcbaf390a30c09eb53ae83d84bebab95a8003f7/system-contracts/bootloader/bootloader.yul#L3657) associated with `EXPECTED_SYSTEM_CONTRACT_UPGRADE_TX_HASH_KEY` returns the value `7`. This inconsistency may lead to unexpected behavior during the processing of L2-to-L1 logs.\n\n\nConsider changing the return value of the `protocolUpgradeTxHashKey` function to the correct value matching `EXPECTED_SYSTEM_CONTRACT_UPGRADE_TX_HASH_KEY`, which is `9`.\n\n\n***Update:** Resolved in [pull request #178](https://github.com/matter-labs/era-contracts/pull/178) at commit [88d22b5](https://github.com/matter-labs/era-contracts/commit/88d22b52b50d13cb2b21fa68afc85b3807595e9b).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "l1-contracts/contracts/zksync/interfaces/IExecutor.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {IBase} from \"./IBase.sol\";\n\n/// @dev Enum used by L2 System Contracts to differentiate logs.\nenum SystemLogKey {\n    L2_TO_L1_LOGS_TREE_ROOT_KEY,\n    TOTAL_L2_TO_L1_PUBDATA_KEY,\n    STATE_DIFF_HASH_KEY,\n    PACKED_BATCH_AND_L2_BLOCK_TIMESTAMP_KEY,\n    PREV_BATCH_HASH_KEY,\n    CHAINED_PRIORITY_TXN_HASH_KEY,\n    NUMBER_OF_LAYER_1_TXS_KEY,\n    BLOB_ONE_HASH_KEY,\n    BLOB_TWO_HASH_KEY,\n    EXPECTED_SYSTEM_CONTRACT_UPGRADE_TX_HASH_KEY\n}\n\n/// @dev Enum used to determine the source of pubdata. At first we will support calldata and blobs but this can be extended.\nenum PubdataSource {\n    Calldata,\n    Blob\n}\n\nstruct LogProcessingOutput {\n    uint256 numberOfLayer1Txs;\n    bytes32 chainedPriorityTxsHash;\n    bytes32 previousBatchHash;\n    bytes32 pubdataHash;\n    bytes32 stateDiffHash;\n    bytes32 l2LogsTreeRoot;\n    uint256 packedBatchAndL2BlockTimestamp;\n    bytes32 blob1Hash;\n    bytes32 blob2Hash;\n}\n\n/// @dev Offset used to pull Address From Log. Equal to 4 (bytes for isService)\nuint256 constant L2_LOG_ADDRESS_OFFSET = 4;\n\n/// @dev Offset used to pull Key From Log. Equal to 4 (bytes for isService) + 20 (bytes for address)\nuint256 constant L2_LOG_KEY_OFFSET = 24;\n\n/// @dev Offset used to pull Value From Log. Equal to 4 (bytes for isService) + 20 (bytes for address) + 32 (bytes for key)\nuint256 constant L2_LOG_VALUE_OFFSET = 56;\n\n/// @dev BLS Modulus value defined in EIP-4844 and the magic value returned from a successful call to the\n/// point evaluation precompile\nuint256 constant BLS_MODULUS = 52435875175126190479447740508185965837690552500527637822603658699938581184513;\n\n/// @dev Packed pubdata commitments.\n/// @dev Format: list of: opening point (16 bytes) || claimed value (32 bytes) || commitment (48 bytes) || proof (48 bytes)) = 144 bytes\nuint256 constant PUBDATA_COMMITMENT_SIZE = 144;\n\n/// @dev Offset in pubdata commitment of blobs for claimed value\nuint256 constant PUBDATA_COMMITMENT_CLAIMED_VALUE_OFFSET = 16;\n\n/// @dev Offset in pubdata commitment of blobs for kzg commitment\nuint256 constant PUBDATA_COMMITMENT_COMMITMENT_OFFSET = 48;\n\n/// @dev Max number of blobs currently supported\nuint256 constant MAX_NUMBER_OF_BLOBS = 2;\n\n/// @title The interface of the zkSync Executor contract capable of processing events emitted in the zkSync protocol.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface IExecutor is IBase {\n    /// @notice Rollup batch stored data\n    /// @param batchNumber Rollup batch number\n    /// @param batchHash Hash of L2 batch\n    /// @param indexRepeatedStorageChanges The serial number of the shortcut index that's used as a unique identifier for storage keys that were used twice or more\n    /// @param numberOfLayer1Txs Number of priority operations to be processed\n    /// @param priorityOperationsHash Hash of all priority operations from this batch\n    /// @param l2LogsTreeRoot Root hash of tree that contains L2 -> L1 messages from this batch\n    /// @param timestamp Rollup batch timestamp, have the same format as Ethereum batch constant\n    /// @param commitment Verified input for the zkSync circuit\n    struct StoredBatchInfo {\n        uint64 batchNumber;\n        bytes32 batchHash;\n        uint64 indexRepeatedStorageChanges;\n        uint256 numberOfLayer1Txs;\n        bytes32 priorityOperationsHash;\n        bytes32 l2LogsTreeRoot;\n        uint256 timestamp;\n        bytes32 commitment;\n    }\n\n    /// @notice Data needed to commit new batch\n    /// @param batchNumber Number of the committed batch\n    /// @param timestamp Unix timestamp denoting the start of the batch execution\n    /// @param indexRepeatedStorageChanges The serial number of the shortcut index that's used as a unique identifier for storage keys that were used twice or more\n    /// @param newStateRoot The state root of the full state tree\n    /// @param numberOfLayer1Txs Number of priority operations to be processed\n    /// @param priorityOperationsHash Hash of all priority operations from this batch\n    /// @param bootloaderHeapInitialContentsHash Hash of the initial contents of the bootloader heap. In practice it serves as the commitment to the transactions in the batch.\n    /// @param eventsQueueStateHash Hash of the events queue state. In practice it serves as the commitment to the events in the batch.\n    /// @param systemLogs concatenation of all L2 -> L1 system logs in the batch\n    /// @param pubdataCommitments Packed pubdata commitments/data.\n    /// @dev pubdataCommitments format: This will always start with a 1 byte pubdataSource flag. Current allowed values are 0 (calldata) or 1 (blobs)\n    ///                             kzg: list of: opening point (16 bytes) || claimed value (32 bytes) || commitment (48 bytes) || proof (48 bytes) = 144 bytes\n    ///                             calldata: pubdataCommitments.length - 1 bytes of pubdata\n    /// @dev For 2 blobs we will be sending 288 bytes of calldata instead of the full amount for pubdata.\n    struct CommitBatchInfo {\n        uint64 batchNumber;\n        uint64 timestamp;\n        uint64 indexRepeatedStorageChanges;\n        bytes32 newStateRoot;\n        uint256 numberOfLayer1Txs;\n        bytes32 priorityOperationsHash;\n        bytes32 bootloaderHeapInitialContentsHash;\n        bytes32 eventsQueueStateHash;\n        bytes systemLogs;\n        bytes pubdataCommitments;\n    }\n\n    /// @notice Recursive proof input data (individual commitments are constructed onchain)\n    struct ProofInput {\n        uint256[] recursiveAggregationInput;\n        uint256[] serializedProof;\n    }\n\n    /// @notice Function called by the operator to commit new batches. It is responsible for:\n    /// - Verifying the correctness of their timestamps.\n    /// - Processing their L2->L1 logs.\n    /// - Storing batch commitments.\n    /// @param _lastCommittedBatchData Stored data of the last committed batch.\n    /// @param _newBatchesData Data of the new batches to be committed.\n    function commitBatches(\n        StoredBatchInfo calldata _lastCommittedBatchData,\n        CommitBatchInfo[] calldata _newBatchesData\n    ) external;\n\n    /// @notice Batches commitment verification.\n    /// @dev Only verifies batch commitments without any other processing.\n    /// @param _prevBatch Stored data of the last committed batch.\n    /// @param _committedBatches Stored data of the committed batches.\n    /// @param _proof The zero knowledge proof.\n    function proveBatches(\n        StoredBatchInfo calldata _prevBatch,\n        StoredBatchInfo[] calldata _committedBatches,\n        ProofInput calldata _proof\n    ) external;\n\n    /// @notice The function called by the operator to finalize (execute) batches. It is responsible for:\n    /// - Processing all pending operations (commpleting priority requests).\n    /// - Finalizing this batch (i.e. allowing to withdraw funds from the system)\n    /// @param _batchesData Data of the batches to be executed.\n    function executeBatches(StoredBatchInfo[] calldata _batchesData) external;\n\n    /// @notice Reverts unexecuted batches\n    /// @param _newLastBatch batch number after which batches should be reverted\n    /// NOTE: Doesn't delete the stored data about batches, but only decreases\n    /// counters that are responsible for the number of batches\n    function revertBatches(uint256 _newLastBatch) external;\n\n    /// @notice Event emitted when a batch is committed\n    /// @dev It has the name \"BlockCommit\" and not \"BatchCommit\" due to backward compatibility considerations\n    event BlockCommit(uint256 indexed batchNumber, bytes32 indexed batchHash, bytes32 indexed commitment);\n\n    /// @notice Event emitted when batches are verified\n    /// @dev It has the name \"BlocksVerification\" and not \"BatchesVerification\" due to backward compatibility considerations\n    event BlocksVerification(uint256 indexed previousLastVerifiedBatch, uint256 indexed currentLastVerifiedBatch);\n\n    /// @notice Event emitted when a batch is executed\n    /// @dev It has the name \"BlockExecution\" and not \"BatchExecution\" due to backward compatibility considerations\n    event BlockExecution(uint256 indexed batchNumber, bytes32 indexed batchHash, bytes32 indexed commitment);\n\n    /// @notice Event emitted when batches are reverted\n    /// @dev It has the name \"BlocksRevert\" and not \"BatchesRevert\" due to backward compatibility considerations\n    event BlocksRevert(uint256 totalBatchesCommitted, uint256 totalBatchesVerified, uint256 totalBatchesExecuted);\n}"
    }
  ]
}