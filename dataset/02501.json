{
  "Title": "H-6: Executing funded standard proposals can be prevented by a proposal slate with duplicate proposals",
  "Content": "# Issue H-6: Executing funded standard proposals can be prevented by a proposal slate with duplicate proposals \n\nSource: https://github.com/sherlock-audit/2023-01-ajna-judging/issues/119 \n\n## Found by \nberndartmueller\n\n## Summary\n\nAnyone can propose a slate of standard proposals to be funded in a distribution period with the `StandardFunding.checkSlate` function. The proposal slate can contain duplicate proposal ids, which, if the slate is the top slate, can be used to prevent a standard proposal from being executed (funded).\n\n## Vulnerability Detail\n\nA funded standard proposal is executed by calling the `StandardFunding.executeStandard` function. A proposal is considered successfully funded if its state returned by the `GrantFund.state` function is `IGovernor.ProposalState.Succeeded`. This is the case if `StandardFunding._standardFundingVoteSucceeded` returns `true`.\n\n`StandardFunding._standardFundingVoteSucceeded` checks if the given proposal id is included in the currently funded proposal slate.\n\nHowever, as mentioned in the beginning, the proposal slate can contain duplicate proposal ids. A slate can therefore be maximized (in regard to the allocated budget) with the same proposal id. Worst case, this \"malicious\" slate can not be replaced with a correct slate, as the allocated budget of a correct slate can not exceed the allocated budget of the malicious slate.\n\nIn this case, the `StandardFunding.executeStandard` function will not execute the proposal, which is not included in the \"malicious\" proposal slate.\n\n## Impact\n\nStandard proposals can be prevented from being funded in a distribution period.\n\n## Code Snippet\n\n[ecosystem-coordination/src/grants/base/StandardFunding.sol#L198-L219](https://github.com/sherlock-audit/2023-01-ajna/blob/main/ecosystem-coordination/src/grants/base/StandardFunding.sol#L198-L219)\n\n```solidity\n198: for (uint i = 0; i < proposalIds_.length; ) {\n199:     // check if Proposal is in the topTenProposals list\n200:     if (_findProposalIndex(proposalIds_[i], topTenProposals[distributionId_]) == -1) return false;\n201:\n202:     Proposal memory proposal = standardFundingProposals[proposalIds_[i]];\n203:\n204:     // account for qvBudgetAllocated possibly being negative\n205:     if (proposal.qvBudgetAllocated < 0) return false;\n206:\n207:     // update counters\n208:     sum += uint256(proposal.qvBudgetAllocated);\n209:     totalTokensRequested += proposal.tokensRequested;\n210:\n211:     // check if slate of proposals exceeded budget constraint ( 90% of GBC )\n212:     if (totalTokensRequested > (gbc * 9 / 10)) {\n213:         return false;\n214:     }\n215:\n216:     unchecked {\n217:         ++i;\n218:     }\n219: }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider checking for duplicate proposal ids in the `checkSlate` function.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/32",
  "Code": [
    {
      "filename": "ecosystem-coordination/src/grants/base/StandardFunding.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { IERC20 }      from \"@oz/token/ERC20/IERC20.sol\";\nimport { SafeERC20 }   from \"@oz/token/ERC20/utils/SafeERC20.sol\";\nimport { Checkpoints } from \"@oz/utils/Checkpoints.sol\";\n\nimport { Funding } from \"./Funding.sol\";\n\nimport { IStandardFunding } from \"../interfaces/IStandardFunding.sol\";\n\nimport { Maths } from \"../libraries/Maths.sol\";\n\nabstract contract StandardFunding is Funding, IStandardFunding {\n\n    using Checkpoints for Checkpoints.History;\n    using SafeERC20 for IERC20;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /**\n     * @notice Maximum percentage of tokens that can be distributed by the treasury in a quarter.\n     * @dev Stored as a Wad percentage.\n     */\n    uint256 internal constant GLOBAL_BUDGET_CONSTRAINT = 0.02 * 1e18;\n\n    /**\n     * @notice Length of the distribution period in blocks.\n     * @dev    Equivalent to the number of blocks in 90 days. Blocks come every 12 seconds.\n     */\n    uint256 internal constant DISTRIBUTION_PERIOD_LENGTH = 648000; // 90 days\n\n    /**\n     * @notice ID of the current distribution period.\n     * @dev Used to access information on the status of an ongoing distribution.\n     * @dev Updated at the start of each quarter.\n     */\n    Checkpoints.History internal distributionIdCheckpoints;\n\n    /**\n     * @notice Mapping of quarterly distributions from the grant fund.\n     * @dev distributionId => QuarterlyDistribution\n     */\n    mapping(uint256 => QuarterlyDistribution) internal distributions;\n\n    /**\n     * @dev Mapping of all proposals that have ever been submitted to the grant fund for screening.\n     * @dev proposalId => Proposal\n     */\n    mapping(uint256 => Proposal) internal standardFundingProposals;\n\n    /**\n     * @dev Mapping of distributionId to a sorted array of 10 proposalIds with the most votes in the screening period.\n     * @dev distribution.id => proposalId[]\n     * @dev A new array is created for each distribution period\n     */\n    mapping(uint256 => uint256[]) internal topTenProposals;\n\n    /**\n     * @notice Mapping of quarterly distributions to a hash of a proposal slate to a list of funded proposals.\n     * @dev distributionId => slate hash => proposalId[]\n     */\n    mapping(uint256 => mapping(bytes32 => uint256[])) internal fundedProposalSlates;\n\n    /**\n     * @notice Mapping of quarterly distributions to voters to a Quadratic Voter info struct.\n     * @dev distributionId => voter address => QuadraticVoter \n     */\n    mapping (uint256 => mapping(address => QuadraticVoter)) internal quadraticVoters;\n\n    /**\n     * @notice Mapping of distributionId to whether surplus funds from distribution updated into treasury\n     * @dev distributionId => bool\n    */\n    mapping (uint256 => bool) internal isSurplusFundsUpdated;\n\n    /**\n     * @notice Mapping of distributionId to user address to whether user has claimed his delegate reward\n     * @dev distributionId => address => bool\n    */\n    mapping (uint256 => mapping (address => bool)) public hasClaimedReward;\n\n    /*****************************************/\n    /*** Distribution Management Functions ***/\n    /*****************************************/\n\n    /// @inheritdoc IStandardFunding\n    function getSlateHash(uint256[] calldata proposalIds_) external pure returns (bytes32) {\n        return keccak256(abi.encode(proposalIds_));\n    }\n\n    /**\n     * @notice Set a new DistributionPeriod Id.\n     * @dev    Increments the previous Id nonce by 1, and sets a checkpoint at the calling block.number.\n     * @return newId_ The new distribution period Id.\n     */\n    function _setNewDistributionId() private returns (uint256 newId_) {\n        // retrieve current distribution Id\n        uint256 currentDistributionId = distributionIdCheckpoints.latest();\n\n        // set the current block number as the checkpoint for the current block\n        (, newId_) = distributionIdCheckpoints.push(currentDistributionId + 1);\n    }\n\n    /**\n     * @notice Updates Treasury with surplus funds from distribution.\n     * @param distributionId_ distribution Id of updating distribution \n     */\n    function _updateTreasury(uint256 distributionId_) private {\n        QuarterlyDistribution memory currentDistribution =  distributions[distributionId_];\n        uint256[] memory fundingProposalIds = fundedProposalSlates[distributionId_][currentDistribution.fundedSlateHash];\n        uint256 totalTokensRequested;\n        for (uint i = 0; i < fundingProposalIds.length; ) {\n            Proposal memory proposal = standardFundingProposals[fundingProposalIds[i]];\n            totalTokensRequested += proposal.tokensRequested;\n            unchecked {\n                ++i;\n            }\n        }\n        // update treasury with non distributed tokens\n        treasury += (currentDistribution.fundsAvailable - totalTokensRequested);\n        isSurplusFundsUpdated[distributionId_] = true;\n    }\n\n    /// @inheritdoc IStandardFunding\n    function startNewDistributionPeriod() external returns (uint256 newDistributionId_) {\n        // check that there isn't currently an active distribution period\n        uint256 currentDistributionId = distributionIdCheckpoints.latest();\n        if (block.number <= distributions[currentDistributionId].endBlock) revert DistributionPeriodStillActive();\n\n        // update Treasury with unused funds from last two distributions\n        {   \n            // Check if any last distribution exists and its challenge period is over\n            if ( currentDistributionId > 0 && (block.number > distributions[currentDistributionId].endBlock + 50400)) {\n                // Add unused funds from last distribution to treasury\n                _updateTreasury(currentDistributionId);\n            }\n\n            // checks if any second last distribution exist and its unused funds are not added into treasury\n            if ( currentDistributionId > 1 && !isSurplusFundsUpdated[currentDistributionId - 1]) {\n                // Add unused funds from second last distribution to treasury\n                _updateTreasury(currentDistributionId - 1);\n            }\n        }\n\n        // set the distribution period to start at the current block\n        uint256 startBlock = block.number;\n        uint256 endBlock = startBlock + DISTRIBUTION_PERIOD_LENGTH;\n\n        // set new value for currentDistributionId\n        newDistributionId_ = _setNewDistributionId();\n\n        // create QuarterlyDistribution struct\n        QuarterlyDistribution storage newDistributionPeriod = distributions[newDistributionId_];\n        newDistributionPeriod.id              = newDistributionId_;\n        newDistributionPeriod.startBlock      = startBlock;\n        newDistributionPeriod.endBlock        = endBlock;\n        uint256 gbc                           = Maths.wmul(treasury, GLOBAL_BUDGET_CONSTRAINT);  \n        newDistributionPeriod.fundsAvailable  = gbc;\n\n        // update treasury\n        treasury -= gbc;\n\n        emit QuarterlyDistributionStarted(newDistributionId_, startBlock, endBlock);\n    }\n\n    /**\n     * @notice Calculates the sum of quadratic budgets allocated to a list of proposals.\n     * @param  proposalIdSubset_ Array of proposal Ids to sum.\n     * @return sum_ The sum of the budget across the given proposals.\n     */\n    function _sumBudgetAllocated(uint256[] memory proposalIdSubset_) internal view returns (uint256 sum_) {\n        for (uint i = 0; i < proposalIdSubset_.length;) {\n            sum_ += uint256(standardFundingProposals[proposalIdSubset_[i]].qvBudgetAllocated);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc IStandardFunding\n    function checkSlate(uint256[] calldata proposalIds_, uint256 distributionId_) external returns (bool) {\n        QuarterlyDistribution storage currentDistribution = distributions[distributionId_];\n\n        // check that the function is being called within the challenge period\n        if (block.number <= currentDistribution.endBlock || block.number > currentDistribution.endBlock + 50400) {\n            return false;\n        }\n\n        uint256 gbc = currentDistribution.fundsAvailable;\n        uint256 sum = 0;\n        uint256 totalTokensRequested = 0;\n\n        for (uint i = 0; i < proposalIds_.length; ) {\n            // check if Proposal is in the topTenProposals list\n            if (_findProposalIndex(proposalIds_[i], topTenProposals[distributionId_]) == -1) return false;\n\n            Proposal memory proposal = standardFundingProposals[proposalIds_[i]];\n\n            // account for qvBudgetAllocated possibly being negative\n            if (proposal.qvBudgetAllocated < 0) return false;\n\n            // update counters\n            sum += uint256(proposal.qvBudgetAllocated);\n            totalTokensRequested += proposal.tokensRequested;\n\n            // check if slate of proposals exceeded budget constraint ( 90% of GBC )\n            if (totalTokensRequested > (gbc * 9 / 10)) {\n                return false;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // get pointers for comparing proposal slates\n        bytes32 currentSlateHash = currentDistribution.fundedSlateHash;\n        bytes32 newSlateHash     = keccak256(abi.encode(proposalIds_));\n\n        // check if slate of proposals is new top slate\n        bool newTopSlate = currentSlateHash == 0 ||\n            (currentSlateHash!= 0 && sum > _sumBudgetAllocated(fundedProposalSlates[distributionId_][currentSlateHash]));\n\n        if (newTopSlate) {\n            uint256[] storage existingSlate = fundedProposalSlates[distributionId_][newSlateHash];\n            for (uint i = 0; i < proposalIds_.length; ) {\n                // update list of proposals to fund\n                existingSlate.push(proposalIds_[i]);\n\n                unchecked {\n                    ++i;\n                }\n            }\n\n            // update hash to point to the new leading slate of proposals\n            currentDistribution.fundedSlateHash = newSlateHash;\n            emit FundedSlateUpdated(distributionId_, newSlateHash);\n        }\n\n        return newTopSlate;\n    }\n\n    /// @inheritdoc IStandardFunding\n    function claimDelegateReward(uint256 distributionId_) external returns(uint256 rewardClaimed_) {\n        // Revert if delegatee didn't vote in screening stage \n        if(!hasVotedScreening[distributionId_][msg.sender]) revert DelegateRewardInvalid();\n\n        QuarterlyDistribution memory currentDistribution = distributions[distributionId_];\n\n        // Check if Challenge Period is still active \n        if(block.number < currentDistribution.endBlock + 50400) revert ChallengePeriodNotEnded();\n\n        // check rewards haven't already been claimed\n        if(hasClaimedReward[distributionId_][msg.sender]) revert RewardAlreadyClaimed();\n\n        QuadraticVoter memory voter = quadraticVoters[distributionId_][msg.sender];\n\n        // Total number of quadratic votes delegatee has voted\n        uint256 quadraticVotesUsed = voter.votingWeight - uint256(voter.budgetRemaining);\n\n        uint256 gbc = currentDistribution.fundsAvailable;\n\n        // delegateeReward = 10 % of GBC distributed as per delegatee Vote share    \n        rewardClaimed_ = Maths.wdiv(Maths.wmul(gbc, quadraticVotesUsed), currentDistribution.quadraticVotesCast) / 10;\n\n        emit DelegateRewardClaimed(msg.sender, distributionId_, rewardClaimed_);\n\n        hasClaimedReward[distributionId_][msg.sender] = true;\n\n        // transfer rewards to delegatee\n        IERC20(ajnaTokenAddress).safeTransfer(msg.sender, rewardClaimed_);\n    }\n\n    /**************************/\n    /*** Proposal Functions ***/\n    /**************************/\n\n    /// @inheritdoc IStandardFunding\n    function executeStandard(address[] memory targets_, uint256[] memory values_, bytes[] memory calldatas_, bytes32 descriptionHash_) external nonReentrant returns (uint256 proposalId_) {\n        proposalId_ = hashProposal(targets_, values_, calldatas_, descriptionHash_);\n        Proposal memory proposal = standardFundingProposals[proposalId_];\n\n        // check that the distribution period has ended, and one week has passed to enable competing slates to be checked\n        if (block.number <= distributions[proposal.distributionId].endBlock + 50400) revert ExecuteProposalInvalid();\n\n        super.execute(targets_, values_, calldatas_, descriptionHash_);\n        standardFundingProposals[proposalId_].executed = true;\n    }\n\n    /// @inheritdoc IStandardFunding\n    function proposeStandard(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        string memory description_\n    ) external returns (uint256 proposalId_) {\n        proposalId_ = hashProposal(targets_, values_, calldatas_, keccak256(bytes(description_)));\n\n        // check for duplicate proposals\n        if (standardFundingProposals[proposalId_].proposalId != 0) revert ProposalAlreadyExists();\n\n        QuarterlyDistribution memory currentDistribution = distributions[distributionIdCheckpoints.latest()];\n\n        // cannot add new proposal after end of screening period\n        // screening period ends 72000 blocks before end of distribution period, ~ 80 days.\n        if (block.number > currentDistribution.endBlock - 72000) revert ScreeningPeriodEnded();\n\n        // check params have matching lengths\n        if (targets_.length != values_.length || targets_.length != calldatas_.length || targets_.length == 0) revert InvalidProposal();\n\n        // store new proposal information\n        Proposal storage newProposal = standardFundingProposals[proposalId_];\n        newProposal.proposalId       = proposalId_;\n        newProposal.distributionId   = currentDistribution.id;\n\n        // check proposal parameters are valid and update tokensRequested\n        newProposal.tokensRequested  = _validateCallDatas(targets_, values_, calldatas_);\n\n        emit ProposalCreated(\n            proposalId_,\n            msg.sender,\n            targets_,\n            values_,\n            new string[](targets_.length),\n            calldatas_,\n            block.number,\n            distributions[newProposal.distributionId].endBlock,\n            description_);\n    }\n\n    /************************/\n    /*** Voting Functions ***/\n    /************************/\n\n    /**\n     * @notice Vote on a proposal in the funding stage of the Distribution Period.\n     * @dev    Votes can be allocated to multiple proposals, quadratically, for or against.\n     * @param  proposal_ The current proposal being voted upon.\n     * @param  account_  The voting account.\n     * @param  voter_    The voter data struct tracking available votes.\n     * @param  budgetAllocation_ The amount of votes being allocated to the proposal.\n     * @return budgetAllocated_ The amount of votes allocated to the proposal.\n     */\n    function _fundingVote(Proposal storage proposal_, address account_, QuadraticVoter storage voter_, int256 budgetAllocation_) internal returns (uint256 budgetAllocated_) {\n\n        uint256 currentDistributionId = distributionIdCheckpoints.latest();\n        QuarterlyDistribution storage currentDistribution = distributions[currentDistributionId];\n\n        uint8  support = 1;\n        uint256 proposalId = proposal_.proposalId;\n\n        // case where voter is voting against the proposal\n        if (budgetAllocation_ < 0) {\n            support = 0;\n\n            // update voter budget remaining\n            voter_.budgetRemaining += budgetAllocation_;\n        }\n        // voter is voting in support of the proposal\n        else {\n            // update voter budget remaining\n            voter_.budgetRemaining -= budgetAllocation_;\n        }\n        // update total vote cast\n        currentDistribution.quadraticVotesCast += uint256(Maths.abs(budgetAllocation_));\n\n        // update proposal vote tracking\n        proposal_.qvBudgetAllocated += budgetAllocation_;\n\n        // update top ten proposals\n        uint256[] memory topTen = topTenProposals[proposal_.distributionId];\n        uint256 proposalIndex = uint256(_findProposalIndex(proposalId, topTen));\n        standardFundingProposals[topTen[proposalIndex]].qvBudgetAllocated = proposal_.qvBudgetAllocated;\n\n        // emit VoteCast instead of VoteCastWithParams to maintain compatibility with Tally\n        budgetAllocated_ = uint256(Maths.abs(budgetAllocation_));\n        emit VoteCast(account_, proposalId, support, budgetAllocated_, \"\");\n    }\n\n    /**\n     * @notice Vote on a proposal in the screening stage of the Distribution Period.\n     * @param account_                The voting account.\n     * @param proposal_               The current proposal being voted upon.\n     * @param votes_                  The amount of votes being cast.\n     * @return                        The amount of votes cast.\n     */\n    function _screeningVote(address account_, Proposal storage proposal_, uint256 votes_) internal returns (uint256) {\n        if (hasVotedScreening[proposal_.distributionId][account_]) revert AlreadyVoted();\n\n        uint256[] storage currentTopTenProposals = topTenProposals[proposal_.distributionId];\n\n        // update proposal votes counter\n        proposal_.votesReceived += votes_;\n\n        // check if proposal was already screened\n        int indexInArray = _findProposalIndex(proposal_.proposalId, currentTopTenProposals);\n        uint256 screenedProposalsLength = currentTopTenProposals.length;\n\n        // check if the proposal should be added to the top ten list for the first time\n        if (screenedProposalsLength < 10 && indexInArray == -1) {\n            currentTopTenProposals.push(proposal_.proposalId);\n\n            // sort top ten proposals\n            _insertionSortProposalsByVotes(currentTopTenProposals);\n        }\n        else {\n            // proposal is already in the array\n            if (indexInArray != -1) {\n                currentTopTenProposals[uint256(indexInArray)] = proposal_.proposalId;\n\n                // sort top ten proposals\n                _insertionSortProposalsByVotes(currentTopTenProposals);\n            }\n            // proposal isn't already in the array\n            else if(standardFundingProposals[currentTopTenProposals[screenedProposalsLength - 1]].votesReceived < proposal_.votesReceived) {\n                // replace least supported proposal with the new proposal\n                currentTopTenProposals.pop();\n                currentTopTenProposals.push(proposal_.proposalId);\n\n                // sort top ten proposals\n                _insertionSortProposalsByVotes(currentTopTenProposals);\n            }\n        }\n\n        // record voters vote\n        hasVotedScreening[proposal_.distributionId][account_] = true;\n\n        // vote for the given proposal\n        return super._castVote(proposal_.proposalId, account_, 1, \"\", \"\");\n    }\n\n    /**\n     * @notice Check to see if a proposal is in the current funded slate hash of proposals.\n     * @param  proposalId_ The proposalId to check.\n     * @return             True if the proposal is in the it's distribution period's slate hash.\n     */\n    function _standardFundingVoteSucceeded(uint256 proposalId_) internal view returns (bool) {\n        Proposal memory proposal = standardFundingProposals[proposalId_];\n        uint256 distributionId = proposal.distributionId;\n        return _findProposalIndex(proposalId_, fundedProposalSlates[distributionId][distributions[distributionId].fundedSlateHash]) != -1;\n    }\n\n    /**************************/\n    /*** External Functions ***/\n    /**************************/\n\n    /// @inheritdoc IStandardFunding\n    function getDistributionIdAtBlock(uint256 blockNumber) external view returns (uint256) {\n        return distributionIdCheckpoints.getAtBlock(blockNumber);\n    }\n\n    /// @inheritdoc IStandardFunding\n    function getDistributionId() external view returns (uint256) {\n        return distributionIdCheckpoints.latest();\n    }\n\n    /// @inheritdoc IStandardFunding\n    function getDistributionPeriodInfo(uint256 distributionId_) external view returns (uint256, uint256, uint256, uint256, uint256, bytes32) {\n        QuarterlyDistribution memory distribution = distributions[distributionId_];\n        return (\n            distribution.id,\n            distribution.quadraticVotesCast,\n            distribution.startBlock,\n            distribution.endBlock,\n            distribution.fundsAvailable,\n            distribution.fundedSlateHash\n        );\n    }\n\n    /// @inheritdoc IStandardFunding\n    function getFundedProposalSlate(uint256 distributionId_, bytes32 slateHash_) external view returns (uint256[] memory) {\n        return fundedProposalSlates[distributionId_][slateHash_];\n    }\n\n    /// @inheritdoc IStandardFunding\n    function getProposalInfo(uint256 proposalId_) external view returns (uint256, uint256, uint256, uint256, int256, bool) {\n        Proposal memory proposal = standardFundingProposals[proposalId_];\n        return (\n            proposal.proposalId,\n            proposal.distributionId,\n            proposal.votesReceived,\n            proposal.tokensRequested,\n            proposal.qvBudgetAllocated,\n            proposal.executed\n        );\n    }\n\n    /// @inheritdoc IStandardFunding\n    function getTopTenProposals(uint256 distributionId_) external view returns (uint256[] memory) {\n        return topTenProposals[distributionId_];\n    }\n\n    /// @inheritdoc IStandardFunding\n    function getVoterInfo(uint256 distributionId_, address account_) external view returns (uint256, int256) {\n        QuadraticVoter memory voter = quadraticVoters[distributionId_][account_];\n        return (\n            voter.votingWeight,\n            voter.budgetRemaining\n        );\n    }\n\n    /// @inheritdoc IStandardFunding\n    function maximumQuarterlyDistribution() external view returns (uint256) {\n        return Maths.wmul(treasury, GLOBAL_BUDGET_CONSTRAINT);\n    }\n\n    /*************************/\n    /*** Sorting Functions ***/\n    /*************************/\n\n    /**\n     * @notice Identify where in an array of proposalIds the proposal exists.\n     * @return index_ The index of the proposalId in the array, else -1.\n     */\n    function _findProposalIndex(uint256 proposalId, uint256[] memory array) internal pure returns (int256 index_) {\n        index_ = -1; // default value indicating proposalId not in the array\n\n        for (int256 i = 0; i < int256(array.length);) {\n            //slither-disable-next-line incorrect-equality\n            if (array[uint256(i)] == proposalId) {\n                index_ = i;\n                break;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Sort the 10 proposals which will make it through screening and move on to the funding round.\n     * @dev    Implements the descending insertion sort algorithm.\n     */\n    function _insertionSortProposalsByVotes(uint256[] storage arr) internal {\n        for (int i = 1; i < int(arr.length); i++) {\n            Proposal memory key = standardFundingProposals[arr[uint(i)]];\n            int j = i;\n\n            while (j > 0 && key.votesReceived > standardFundingProposals[arr[uint(j - 1)]].votesReceived) {\n                // swap values if left item < right item\n                uint256 temp = arr[uint(j - 1)];\n                arr[uint(j - 1)] = arr[uint(j)];\n                arr[uint(j)] = temp;\n\n                j--;\n            }\n        }\n    }\n\n}"
    }
  ]
}