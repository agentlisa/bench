{
  "Title": "[H03] Incentive to support the peg decays with volatility",
  "Content": "The `FEI` protocol incentivizes supporting the peg by minting extra `FEI` to users that buy `FEI` from the Uniswap pool. The incentive is a function of the growth rate, the time since the peg was last restored, and the distance from the peg. A [`struct`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/UniswapIncentive.sol#L18-L23) containing a `blockNo`, `weight`, `growthRate`, and `active` flag tracks this info in the [`timeWeightInfo` variable](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/UniswapIncentive.sol#L25). The [`timeWeightInfo.growthRate`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/orchestration/CoreOrchestrator.sol#L143) is initialized as `333`, and only updated through governance.\n\n\nThe updated weight and price deviations are inputs to the [`updateTimeWeight` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/UniswapIncentive.sol#L212-L238), which updates the `timeWeightInfo.weight` through the [`_setTimeWeight` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/UniswapIncentive.sol#L240-L250). Whenever a buy is performed, the price deviation and updated weight is factored into the [`calculateBuyIncentiveMultiplier` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/UniswapIncentive.sol#L192-L204) to determine the incentive, whereas the `weight` is not factored into the [`calculateSellPenaltyMultiplier` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/UniswapIncentive.sol#L206-L210) which calculates the disincentive for selling. Upon each transaction, [`incentivize`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/UniswapIncentive.sol#L46-L61) is called, which calls either [`incentivizeBuy`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/UniswapIncentive.sol#L161-L174) or [`incentivizeSell`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/UniswapIncentive.sol#L176-L190) depending on the direction of the trade. Regardless of the direction, [`updateTimeWeight`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/UniswapIncentive.sol#L212-L238) is called, but this function [differs for buy and sell transactions](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/UniswapIncentive.sol#L229-L233), with an asymmetric effect that reduces the incentive for buyers when there is price volatility below parity.\n\n\nSuppose, for example, the protocol starts at parity, which sets the `weight` to `0`. Then the following sequence of transactions occur:\n\n\n1. A large sell pushes the price down to `0.9`. First [`getTimeWeight`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/UniswapIncentive.sol#L84-L92) will be called, and return `0`, because no blocks have passed since the peg was last at parity. In the same transaction, `updateTimeWeight` is called with parameters `weight = 0`, `initialDeviation = 0`, `finalDeviation = 0.1`. As a result, `updateTimeWeight` calls `_setTimeWeight` to update `timeWeightInfo.weight` to `0` and `timeWeightInfo.blockNo` to the current block height.\n2. Next, a hundred blocks later, a ‘partial’ buy is submitted, which would bring the price up to `0.95`. First, `getTimeWeight` will be called. The `blockDelta` will now be `100`, and the `timeWeightInfo.growthRate` remains `333`. The [product (`33300`) is added to the previously stored `timeWeightInfo.weight` (`0`)](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/UniswapIncentive.sol#L90-L91), and the sum of `33300` is returned. In the same buy transaction, `updateTimeWeight` will be called, and passed the parameters: `weight = 33300`, `initialDeviation = 0.10`, and `finalDeviation = 0.05`. Since the peg was only partially restored, [`updateTimeWeight` reduces the weight by `remainingRatio = finalDeviation / initialDeviation = 0.5`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/UniswapIncentive.sol#L229-L233). Then, when `_setTimeWeight` is called, `timeWeightInfo.weight` is updated to `33300 * 0.5 = 16650`, and the current block height is stored in `timeWeightInfo.blockNo`.\n3. One block later, another sell happens, pushing the price back down to `0.9`. This time, when `getTimeWeight` is called, the `blockDelta` will be `1` and `timeWeightInfo.weight` will be `16650`, so the function returns a weight of `16650 + 1 * 333 = 16983`. In the same sell transaction, `_setTimeWeight` is called, updating `timeWeightInfo.weight` to `16983` and updating `timeWeightInfo.blockNo`.\n4. One block later, with the price back down to `0.9`, suppose a buyer makes a purchase of any size. When `getTimeWeight` is called, the `blockDelta` is `1`, and the `timeWeightInfo.weight` is `16983`, so the function returns `16983 + 1 * 333 = 17316`.\n\n\nThe weight is factored into the incentive for buyers. The higher the weight, the greater the incentive. When the first buyer submitted an order where the initial price was `0.9`, the weight was `33300`. When the second buyer submitted an order two blocks later with the same initial price of `0.9`, the incentive had dropped to `17316`. This is because partial buys reduce the `timeWeightInfo.weight` by the ratio of the partial buy, but sells do *not* increase the `timeWeightInfo.weight` by the inverse ratio. Buyers only realize the full incentive if the *first* buyer makes a purchase that *fully* restores the peg to parity, or if sells never happen after partial buys. Otherwise, the incentive for buyers to support the peg decays with price volatility below parity.\n\n\nIf the incentive decays such that buyers are no longer incentivized to support the peg, the [`PCVController`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pcv/EthUniswapPCVController.sol) would have to step in to re-establish parity using [`forceReweight`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pcv/EthUniswapPCVController.sol#L59-L61).\n\n\nConsider updating the sell functions to re-incentivize subsequent buying to support the peg.\n\n\n**Update:** *Acknowledged. The Fei Team states that this is an expected behavior of the protocol.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/token/UniswapIncentive.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"./IUniswapIncentive.sol\";\nimport \"../utils/SafeMath32.sol\";\nimport \"../refs/UniRef.sol\";\nimport \"../oracle/IOracle.sol\";\n\n/// @title IUniswapIncentive implementation\n/// @author Fei Protocol\ncontract UniswapIncentive is IUniswapIncentive, UniRef {\n\tusing Decimal for Decimal.D256;\n    using SafeMath32 for uint32;\n    using SafeCast for uint;\n\n    struct TimeWeightInfo {\n        uint32 blockNo;\n        uint32 weight;\n        uint32 growthRate;\n        bool active;\n    }\n\n    TimeWeightInfo private timeWeightInfo;\n\n    uint32 public constant override TIME_WEIGHT_GRANULARITY = 100_000;\n\n    mapping(address => bool) private _exempt;\n\n    /// @notice UniswapIncentive constructor\n    /// @param _core Fei Core to reference\n    /// @param _oracle Oracle to reference\n    /// @param _pair Uniswap Pair to incentivize\n    /// @param _router Uniswap Router\n\tconstructor(\n        address _core, \n        address _oracle, \n        address _pair, \n        address _router,\n        uint32 _growthRate\n    ) public UniRef(_core, _pair, _router, _oracle) {\n        _setTimeWeight(0, _growthRate, false);    \n    }\n\n    function incentivize(\n    \taddress sender, \n    \taddress receiver, \n    \taddress, \n    \tuint amountIn\n    ) external override onlyFei {\n        updateOracle();\n\n    \tif (isPair(sender)) {\n    \t\tincentivizeBuy(receiver, amountIn);\n    \t}\n\n    \tif (isPair(receiver)) {\n    \t\tincentivizeSell(sender, amountIn);\n    \t}\n    }\n\n    function setExemptAddress(address account, bool isExempt) external override onlyGovernor {\n    \t_exempt[account] = isExempt;\n        emit ExemptAddressUpdate(account, isExempt);\n    }\n\n    function setTimeWeightGrowth(uint32 growthRate) external override onlyGovernor {\n        TimeWeightInfo memory tw = timeWeightInfo;\n        timeWeightInfo = TimeWeightInfo(tw.blockNo, tw.weight, growthRate, tw.active);\n        emit GrowthRateUpdate(growthRate);\n    }\n\n    function setTimeWeight(uint32 weight, uint32 growth, bool active) external override onlyGovernor {\n        _setTimeWeight(weight, growth, active);\n        // TimeWeightInfo memory tw = timeWeightInfo;\n        // timeWeightInfo = TimeWeightInfo(blockNo, tw.weight, tw.growthRate, tw.active);\n    }\n\n    function getGrowthRate() public view override returns (uint32) {\n        return timeWeightInfo.growthRate;\n    }\n\n    function getTimeWeight() public view override returns (uint32) {\n        TimeWeightInfo memory tw = timeWeightInfo;\n        if (!tw.active) {\n            return 0;\n        }\n\n        uint32 blockDelta = block.number.toUint32().sub(tw.blockNo);\n        return tw.weight.add(blockDelta * tw.growthRate);\n    }\n\n    function isTimeWeightActive() public view override returns (bool) {\n    \treturn timeWeightInfo.active;\n    }\n\n    function isExemptAddress(address account) public view override returns (bool) {\n    \treturn _exempt[account];\n    }\n\n    function isIncentiveParity() public view override returns (bool) {\n        uint32 weight = getTimeWeight();\n        require(weight != 0, \"UniswapIncentive: Incentive zero or not active\");\n\n        (Decimal.D256 memory price,,) = getUniswapPrice();\n        Decimal.D256 memory deviation = calculateDeviation(price, peg());\n        require(!deviation.equals(Decimal.zero()), \"UniswapIncentive: Price already at or above peg\");\n\n        Decimal.D256 memory incentive = calculateBuyIncentiveMultiplier(deviation, weight);\n        Decimal.D256 memory penalty = calculateSellPenaltyMultiplier(deviation);\n        return incentive.equals(penalty);\n    }\n\n    function getBuyIncentive(uint amount) public view override returns(\n        uint incentive, \n        uint32 weight,\n        Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation\n    ) {\n        (initialDeviation, finalDeviation) = getPriceDeviations(-1 * int256(amount));\n        weight = getTimeWeight();\n\n        if (initialDeviation.equals(Decimal.zero())) {\n            return (0, weight, initialDeviation, finalDeviation);\n        }\n\n        uint incentivizedAmount = amount;\n        if (finalDeviation.equals(Decimal.zero())) {\n            incentivizedAmount = getAmountToPegFei();\n        }\n\n        Decimal.D256 memory multiplier = calculateBuyIncentiveMultiplier(initialDeviation, weight);\n        incentive = multiplier.mul(incentivizedAmount).asUint256();\n        return (incentive, weight, initialDeviation, finalDeviation);\n    }\n\n    function getSellPenalty(uint amount) public view override returns(\n        uint penalty, \n        Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation\n    ) {\n        (initialDeviation, finalDeviation) = getPriceDeviations(int256(amount));\n\n        if (finalDeviation.equals(Decimal.zero())) {\n            return (0, initialDeviation, finalDeviation);\n        }\n\n        uint incentivizedAmount = amount;\n        if (initialDeviation.equals(Decimal.zero())) {\n            uint amountToPeg = getAmountToPegFei();\n            require(amount >= amountToPeg, \"UniswapIncentive: Underflow\");\n            incentivizedAmount = amount - amountToPeg;\n        }\n\n        Decimal.D256 memory multiplier = calculateSellPenaltyMultiplier(finalDeviation); \n        penalty = multiplier.mul(incentivizedAmount).asUint256(); \n        return (penalty, initialDeviation, finalDeviation);   \n    }\n\n    function incentivizeBuy(address target, uint amountIn) internal ifMinterSelf {\n    \tif (isExemptAddress(target)) {\n    \t\treturn;\n    \t}\n\n        (uint incentive, uint32 weight,\n        Decimal.D256 memory initialDeviation, \n        Decimal.D256 memory finalDeviation) = getBuyIncentive(amountIn);\n\n        updateTimeWeight(initialDeviation, finalDeviation, weight);\n        if (incentive != 0) {\n            fei().mint(target, incentive);         \n        }\n    }\n\n    function incentivizeSell(address target, uint amount) internal ifBurnerSelf {\n    \tif (isExemptAddress(target)) {\n    \t\treturn;\n    \t}\n\n        (uint penalty, Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation) = getSellPenalty(amount);\n\n        uint32 weight = getTimeWeight();\n        updateTimeWeight(initialDeviation, finalDeviation, weight);\n\n        if (penalty != 0) {\n            fei().burnFrom(target, penalty);\n        }\n    }\n\n    function calculateBuyIncentiveMultiplier(\n        Decimal.D256 memory deviation,\n        uint32 weight\n    ) internal pure returns (Decimal.D256 memory) {\n        Decimal.D256 memory correspondingPenalty = calculateSellPenaltyMultiplier(deviation);\n        Decimal.D256 memory buyMultiplier = deviation.mul(uint(weight)).div(uint(TIME_WEIGHT_GRANULARITY));\n        \n        if (correspondingPenalty.lessThan(buyMultiplier)) {\n            return correspondingPenalty;\n        }\n        \n        return buyMultiplier;\n    }\n\n    function calculateSellPenaltyMultiplier(\n        Decimal.D256 memory deviation\n    ) internal pure returns (Decimal.D256 memory) {\n        return deviation.mul(deviation).mul(100); // m^2 * 100\n    }\n\n    function updateTimeWeight (\n        Decimal.D256 memory initialDeviation, \n        Decimal.D256 memory finalDeviation, \n        uint32 currentWeight\n    ) internal {\n        // Reset after completion\n        if (finalDeviation.equals(Decimal.zero())) {\n            _setTimeWeight(0, getGrowthRate(), false);\n            return;\n        } \n        // Init\n        if (initialDeviation.equals(Decimal.zero())) {\n            _setTimeWeight(0, getGrowthRate(), true);\n            return;\n        }\n\n        uint updatedWeight = uint(currentWeight);\n        // Partial buy\n        if (initialDeviation.greaterThan(finalDeviation)) {\n            Decimal.D256 memory remainingRatio = finalDeviation.div(initialDeviation);\n            updatedWeight = remainingRatio.mul(uint(currentWeight)).asUint256();\n        }\n        \n        uint maxWeight = finalDeviation.mul(100).mul(uint(TIME_WEIGHT_GRANULARITY)).asUint256(); // m^2*100 (sell) = t*m (buy) \n        updatedWeight = Math.min(updatedWeight, maxWeight);\n        _setTimeWeight(updatedWeight.toUint32(), getGrowthRate(), true);\n    }\n\n    function _setTimeWeight(uint32 weight, uint32 growthRate, bool active) internal {\n        uint32 currentGrowth = getGrowthRate();\n\n        uint32 blockNo = block.number.toUint32();\n\n        timeWeightInfo = TimeWeightInfo(blockNo, weight, growthRate, active);\n\n        emit TimeWeightUpdate(weight, active);   \n        if (currentGrowth != growthRate) {\n            emit GrowthRateUpdate(growthRate);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/token/UniswapIncentive.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"./IUniswapIncentive.sol\";\nimport \"../utils/SafeMath32.sol\";\nimport \"../refs/UniRef.sol\";\nimport \"../oracle/IOracle.sol\";\n\n/// @title IUniswapIncentive implementation\n/// @author Fei Protocol\ncontract UniswapIncentive is IUniswapIncentive, UniRef {\n\tusing Decimal for Decimal.D256;\n    using SafeMath32 for uint32;\n    using SafeCast for uint;\n\n    struct TimeWeightInfo {\n        uint32 blockNo;\n        uint32 weight;\n        uint32 growthRate;\n        bool active;\n    }\n\n    TimeWeightInfo private timeWeightInfo;\n\n    uint32 public constant override TIME_WEIGHT_GRANULARITY = 100_000;\n\n    mapping(address => bool) private _exempt;\n\n    /// @notice UniswapIncentive constructor\n    /// @param _core Fei Core to reference\n    /// @param _oracle Oracle to reference\n    /// @param _pair Uniswap Pair to incentivize\n    /// @param _router Uniswap Router\n\tconstructor(\n        address _core, \n        address _oracle, \n        address _pair, \n        address _router,\n        uint32 _growthRate\n    ) public UniRef(_core, _pair, _router, _oracle) {\n        _setTimeWeight(0, _growthRate, false);    \n    }\n\n    function incentivize(\n    \taddress sender, \n    \taddress receiver, \n    \taddress, \n    \tuint amountIn\n    ) external override onlyFei {\n        updateOracle();\n\n    \tif (isPair(sender)) {\n    \t\tincentivizeBuy(receiver, amountIn);\n    \t}\n\n    \tif (isPair(receiver)) {\n    \t\tincentivizeSell(sender, amountIn);\n    \t}\n    }\n\n    function setExemptAddress(address account, bool isExempt) external override onlyGovernor {\n    \t_exempt[account] = isExempt;\n        emit ExemptAddressUpdate(account, isExempt);\n    }\n\n    function setTimeWeightGrowth(uint32 growthRate) external override onlyGovernor {\n        TimeWeightInfo memory tw = timeWeightInfo;\n        timeWeightInfo = TimeWeightInfo(tw.blockNo, tw.weight, growthRate, tw.active);\n        emit GrowthRateUpdate(growthRate);\n    }\n\n    function setTimeWeight(uint32 weight, uint32 growth, bool active) external override onlyGovernor {\n        _setTimeWeight(weight, growth, active);\n        // TimeWeightInfo memory tw = timeWeightInfo;\n        // timeWeightInfo = TimeWeightInfo(blockNo, tw.weight, tw.growthRate, tw.active);\n    }\n\n    function getGrowthRate() public view override returns (uint32) {\n        return timeWeightInfo.growthRate;\n    }\n\n    function getTimeWeight() public view override returns (uint32) {\n        TimeWeightInfo memory tw = timeWeightInfo;\n        if (!tw.active) {\n            return 0;\n        }\n\n        uint32 blockDelta = block.number.toUint32().sub(tw.blockNo);\n        return tw.weight.add(blockDelta * tw.growthRate);\n    }\n\n    function isTimeWeightActive() public view override returns (bool) {\n    \treturn timeWeightInfo.active;\n    }\n\n    function isExemptAddress(address account) public view override returns (bool) {\n    \treturn _exempt[account];\n    }\n\n    function isIncentiveParity() public view override returns (bool) {\n        uint32 weight = getTimeWeight();\n        require(weight != 0, \"UniswapIncentive: Incentive zero or not active\");\n\n        (Decimal.D256 memory price,,) = getUniswapPrice();\n        Decimal.D256 memory deviation = calculateDeviation(price, peg());\n        require(!deviation.equals(Decimal.zero()), \"UniswapIncentive: Price already at or above peg\");\n\n        Decimal.D256 memory incentive = calculateBuyIncentiveMultiplier(deviation, weight);\n        Decimal.D256 memory penalty = calculateSellPenaltyMultiplier(deviation);\n        return incentive.equals(penalty);\n    }\n\n    function getBuyIncentive(uint amount) public view override returns(\n        uint incentive, \n        uint32 weight,\n        Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation\n    ) {\n        (initialDeviation, finalDeviation) = getPriceDeviations(-1 * int256(amount));\n        weight = getTimeWeight();\n\n        if (initialDeviation.equals(Decimal.zero())) {\n            return (0, weight, initialDeviation, finalDeviation);\n        }\n\n        uint incentivizedAmount = amount;\n        if (finalDeviation.equals(Decimal.zero())) {\n            incentivizedAmount = getAmountToPegFei();\n        }\n\n        Decimal.D256 memory multiplier = calculateBuyIncentiveMultiplier(initialDeviation, weight);\n        incentive = multiplier.mul(incentivizedAmount).asUint256();\n        return (incentive, weight, initialDeviation, finalDeviation);\n    }\n\n    function getSellPenalty(uint amount) public view override returns(\n        uint penalty, \n        Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation\n    ) {\n        (initialDeviation, finalDeviation) = getPriceDeviations(int256(amount));\n\n        if (finalDeviation.equals(Decimal.zero())) {\n            return (0, initialDeviation, finalDeviation);\n        }\n\n        uint incentivizedAmount = amount;\n        if (initialDeviation.equals(Decimal.zero())) {\n            uint amountToPeg = getAmountToPegFei();\n            require(amount >= amountToPeg, \"UniswapIncentive: Underflow\");\n            incentivizedAmount = amount - amountToPeg;\n        }\n\n        Decimal.D256 memory multiplier = calculateSellPenaltyMultiplier(finalDeviation); \n        penalty = multiplier.mul(incentivizedAmount).asUint256(); \n        return (penalty, initialDeviation, finalDeviation);   \n    }\n\n    function incentivizeBuy(address target, uint amountIn) internal ifMinterSelf {\n    \tif (isExemptAddress(target)) {\n    \t\treturn;\n    \t}\n\n        (uint incentive, uint32 weight,\n        Decimal.D256 memory initialDeviation, \n        Decimal.D256 memory finalDeviation) = getBuyIncentive(amountIn);\n\n        updateTimeWeight(initialDeviation, finalDeviation, weight);\n        if (incentive != 0) {\n            fei().mint(target, incentive);         \n        }\n    }\n\n    function incentivizeSell(address target, uint amount) internal ifBurnerSelf {\n    \tif (isExemptAddress(target)) {\n    \t\treturn;\n    \t}\n\n        (uint penalty, Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation) = getSellPenalty(amount);\n\n        uint32 weight = getTimeWeight();\n        updateTimeWeight(initialDeviation, finalDeviation, weight);\n\n        if (penalty != 0) {\n            fei().burnFrom(target, penalty);\n        }\n    }\n\n    function calculateBuyIncentiveMultiplier(\n        Decimal.D256 memory deviation,\n        uint32 weight\n    ) internal pure returns (Decimal.D256 memory) {\n        Decimal.D256 memory correspondingPenalty = calculateSellPenaltyMultiplier(deviation);\n        Decimal.D256 memory buyMultiplier = deviation.mul(uint(weight)).div(uint(TIME_WEIGHT_GRANULARITY));\n        \n        if (correspondingPenalty.lessThan(buyMultiplier)) {\n            return correspondingPenalty;\n        }\n        \n        return buyMultiplier;\n    }\n\n    function calculateSellPenaltyMultiplier(\n        Decimal.D256 memory deviation\n    ) internal pure returns (Decimal.D256 memory) {\n        return deviation.mul(deviation).mul(100); // m^2 * 100\n    }\n\n    function updateTimeWeight (\n        Decimal.D256 memory initialDeviation, \n        Decimal.D256 memory finalDeviation, \n        uint32 currentWeight\n    ) internal {\n        // Reset after completion\n        if (finalDeviation.equals(Decimal.zero())) {\n            _setTimeWeight(0, getGrowthRate(), false);\n            return;\n        } \n        // Init\n        if (initialDeviation.equals(Decimal.zero())) {\n            _setTimeWeight(0, getGrowthRate(), true);\n            return;\n        }\n\n        uint updatedWeight = uint(currentWeight);\n        // Partial buy\n        if (initialDeviation.greaterThan(finalDeviation)) {\n            Decimal.D256 memory remainingRatio = finalDeviation.div(initialDeviation);\n            updatedWeight = remainingRatio.mul(uint(currentWeight)).asUint256();\n        }\n        \n        uint maxWeight = finalDeviation.mul(100).mul(uint(TIME_WEIGHT_GRANULARITY)).asUint256(); // m^2*100 (sell) = t*m (buy) \n        updatedWeight = Math.min(updatedWeight, maxWeight);\n        _setTimeWeight(updatedWeight.toUint32(), getGrowthRate(), true);\n    }\n\n    function _setTimeWeight(uint32 weight, uint32 growthRate, bool active) internal {\n        uint32 currentGrowth = getGrowthRate();\n\n        uint32 blockNo = block.number.toUint32();\n\n        timeWeightInfo = TimeWeightInfo(blockNo, weight, growthRate, active);\n\n        emit TimeWeightUpdate(weight, active);   \n        if (currentGrowth != growthRate) {\n            emit GrowthRateUpdate(growthRate);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/token/UniswapIncentive.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"./IUniswapIncentive.sol\";\nimport \"../utils/SafeMath32.sol\";\nimport \"../refs/UniRef.sol\";\nimport \"../oracle/IOracle.sol\";\n\n/// @title IUniswapIncentive implementation\n/// @author Fei Protocol\ncontract UniswapIncentive is IUniswapIncentive, UniRef {\n\tusing Decimal for Decimal.D256;\n    using SafeMath32 for uint32;\n    using SafeCast for uint;\n\n    struct TimeWeightInfo {\n        uint32 blockNo;\n        uint32 weight;\n        uint32 growthRate;\n        bool active;\n    }\n\n    TimeWeightInfo private timeWeightInfo;\n\n    uint32 public constant override TIME_WEIGHT_GRANULARITY = 100_000;\n\n    mapping(address => bool) private _exempt;\n\n    /// @notice UniswapIncentive constructor\n    /// @param _core Fei Core to reference\n    /// @param _oracle Oracle to reference\n    /// @param _pair Uniswap Pair to incentivize\n    /// @param _router Uniswap Router\n\tconstructor(\n        address _core, \n        address _oracle, \n        address _pair, \n        address _router,\n        uint32 _growthRate\n    ) public UniRef(_core, _pair, _router, _oracle) {\n        _setTimeWeight(0, _growthRate, false);    \n    }\n\n    function incentivize(\n    \taddress sender, \n    \taddress receiver, \n    \taddress, \n    \tuint amountIn\n    ) external override onlyFei {\n        updateOracle();\n\n    \tif (isPair(sender)) {\n    \t\tincentivizeBuy(receiver, amountIn);\n    \t}\n\n    \tif (isPair(receiver)) {\n    \t\tincentivizeSell(sender, amountIn);\n    \t}\n    }\n\n    function setExemptAddress(address account, bool isExempt) external override onlyGovernor {\n    \t_exempt[account] = isExempt;\n        emit ExemptAddressUpdate(account, isExempt);\n    }\n\n    function setTimeWeightGrowth(uint32 growthRate) external override onlyGovernor {\n        TimeWeightInfo memory tw = timeWeightInfo;\n        timeWeightInfo = TimeWeightInfo(tw.blockNo, tw.weight, growthRate, tw.active);\n        emit GrowthRateUpdate(growthRate);\n    }\n\n    function setTimeWeight(uint32 weight, uint32 growth, bool active) external override onlyGovernor {\n        _setTimeWeight(weight, growth, active);\n        // TimeWeightInfo memory tw = timeWeightInfo;\n        // timeWeightInfo = TimeWeightInfo(blockNo, tw.weight, tw.growthRate, tw.active);\n    }\n\n    function getGrowthRate() public view override returns (uint32) {\n        return timeWeightInfo.growthRate;\n    }\n\n    function getTimeWeight() public view override returns (uint32) {\n        TimeWeightInfo memory tw = timeWeightInfo;\n        if (!tw.active) {\n            return 0;\n        }\n\n        uint32 blockDelta = block.number.toUint32().sub(tw.blockNo);\n        return tw.weight.add(blockDelta * tw.growthRate);\n    }\n\n    function isTimeWeightActive() public view override returns (bool) {\n    \treturn timeWeightInfo.active;\n    }\n\n    function isExemptAddress(address account) public view override returns (bool) {\n    \treturn _exempt[account];\n    }\n\n    function isIncentiveParity() public view override returns (bool) {\n        uint32 weight = getTimeWeight();\n        require(weight != 0, \"UniswapIncentive: Incentive zero or not active\");\n\n        (Decimal.D256 memory price,,) = getUniswapPrice();\n        Decimal.D256 memory deviation = calculateDeviation(price, peg());\n        require(!deviation.equals(Decimal.zero()), \"UniswapIncentive: Price already at or above peg\");\n\n        Decimal.D256 memory incentive = calculateBuyIncentiveMultiplier(deviation, weight);\n        Decimal.D256 memory penalty = calculateSellPenaltyMultiplier(deviation);\n        return incentive.equals(penalty);\n    }\n\n    function getBuyIncentive(uint amount) public view override returns(\n        uint incentive, \n        uint32 weight,\n        Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation\n    ) {\n        (initialDeviation, finalDeviation) = getPriceDeviations(-1 * int256(amount));\n        weight = getTimeWeight();\n\n        if (initialDeviation.equals(Decimal.zero())) {\n            return (0, weight, initialDeviation, finalDeviation);\n        }\n\n        uint incentivizedAmount = amount;\n        if (finalDeviation.equals(Decimal.zero())) {\n            incentivizedAmount = getAmountToPegFei();\n        }\n\n        Decimal.D256 memory multiplier = calculateBuyIncentiveMultiplier(initialDeviation, weight);\n        incentive = multiplier.mul(incentivizedAmount).asUint256();\n        return (incentive, weight, initialDeviation, finalDeviation);\n    }\n\n    function getSellPenalty(uint amount) public view override returns(\n        uint penalty, \n        Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation\n    ) {\n        (initialDeviation, finalDeviation) = getPriceDeviations(int256(amount));\n\n        if (finalDeviation.equals(Decimal.zero())) {\n            return (0, initialDeviation, finalDeviation);\n        }\n\n        uint incentivizedAmount = amount;\n        if (initialDeviation.equals(Decimal.zero())) {\n            uint amountToPeg = getAmountToPegFei();\n            require(amount >= amountToPeg, \"UniswapIncentive: Underflow\");\n            incentivizedAmount = amount - amountToPeg;\n        }\n\n        Decimal.D256 memory multiplier = calculateSellPenaltyMultiplier(finalDeviation); \n        penalty = multiplier.mul(incentivizedAmount).asUint256(); \n        return (penalty, initialDeviation, finalDeviation);   \n    }\n\n    function incentivizeBuy(address target, uint amountIn) internal ifMinterSelf {\n    \tif (isExemptAddress(target)) {\n    \t\treturn;\n    \t}\n\n        (uint incentive, uint32 weight,\n        Decimal.D256 memory initialDeviation, \n        Decimal.D256 memory finalDeviation) = getBuyIncentive(amountIn);\n\n        updateTimeWeight(initialDeviation, finalDeviation, weight);\n        if (incentive != 0) {\n            fei().mint(target, incentive);         \n        }\n    }\n\n    function incentivizeSell(address target, uint amount) internal ifBurnerSelf {\n    \tif (isExemptAddress(target)) {\n    \t\treturn;\n    \t}\n\n        (uint penalty, Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation) = getSellPenalty(amount);\n\n        uint32 weight = getTimeWeight();\n        updateTimeWeight(initialDeviation, finalDeviation, weight);\n\n        if (penalty != 0) {\n            fei().burnFrom(target, penalty);\n        }\n    }\n\n    function calculateBuyIncentiveMultiplier(\n        Decimal.D256 memory deviation,\n        uint32 weight\n    ) internal pure returns (Decimal.D256 memory) {\n        Decimal.D256 memory correspondingPenalty = calculateSellPenaltyMultiplier(deviation);\n        Decimal.D256 memory buyMultiplier = deviation.mul(uint(weight)).div(uint(TIME_WEIGHT_GRANULARITY));\n        \n        if (correspondingPenalty.lessThan(buyMultiplier)) {\n            return correspondingPenalty;\n        }\n        \n        return buyMultiplier;\n    }\n\n    function calculateSellPenaltyMultiplier(\n        Decimal.D256 memory deviation\n    ) internal pure returns (Decimal.D256 memory) {\n        return deviation.mul(deviation).mul(100); // m^2 * 100\n    }\n\n    function updateTimeWeight (\n        Decimal.D256 memory initialDeviation, \n        Decimal.D256 memory finalDeviation, \n        uint32 currentWeight\n    ) internal {\n        // Reset after completion\n        if (finalDeviation.equals(Decimal.zero())) {\n            _setTimeWeight(0, getGrowthRate(), false);\n            return;\n        } \n        // Init\n        if (initialDeviation.equals(Decimal.zero())) {\n            _setTimeWeight(0, getGrowthRate(), true);\n            return;\n        }\n\n        uint updatedWeight = uint(currentWeight);\n        // Partial buy\n        if (initialDeviation.greaterThan(finalDeviation)) {\n            Decimal.D256 memory remainingRatio = finalDeviation.div(initialDeviation);\n            updatedWeight = remainingRatio.mul(uint(currentWeight)).asUint256();\n        }\n        \n        uint maxWeight = finalDeviation.mul(100).mul(uint(TIME_WEIGHT_GRANULARITY)).asUint256(); // m^2*100 (sell) = t*m (buy) \n        updatedWeight = Math.min(updatedWeight, maxWeight);\n        _setTimeWeight(updatedWeight.toUint32(), getGrowthRate(), true);\n    }\n\n    function _setTimeWeight(uint32 weight, uint32 growthRate, bool active) internal {\n        uint32 currentGrowth = getGrowthRate();\n\n        uint32 blockNo = block.number.toUint32();\n\n        timeWeightInfo = TimeWeightInfo(blockNo, weight, growthRate, active);\n\n        emit TimeWeightUpdate(weight, active);   \n        if (currentGrowth != growthRate) {\n            emit GrowthRateUpdate(growthRate);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/token/UniswapIncentive.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"./IUniswapIncentive.sol\";\nimport \"../utils/SafeMath32.sol\";\nimport \"../refs/UniRef.sol\";\nimport \"../oracle/IOracle.sol\";\n\n/// @title IUniswapIncentive implementation\n/// @author Fei Protocol\ncontract UniswapIncentive is IUniswapIncentive, UniRef {\n\tusing Decimal for Decimal.D256;\n    using SafeMath32 for uint32;\n    using SafeCast for uint;\n\n    struct TimeWeightInfo {\n        uint32 blockNo;\n        uint32 weight;\n        uint32 growthRate;\n        bool active;\n    }\n\n    TimeWeightInfo private timeWeightInfo;\n\n    uint32 public constant override TIME_WEIGHT_GRANULARITY = 100_000;\n\n    mapping(address => bool) private _exempt;\n\n    /// @notice UniswapIncentive constructor\n    /// @param _core Fei Core to reference\n    /// @param _oracle Oracle to reference\n    /// @param _pair Uniswap Pair to incentivize\n    /// @param _router Uniswap Router\n\tconstructor(\n        address _core, \n        address _oracle, \n        address _pair, \n        address _router,\n        uint32 _growthRate\n    ) public UniRef(_core, _pair, _router, _oracle) {\n        _setTimeWeight(0, _growthRate, false);    \n    }\n\n    function incentivize(\n    \taddress sender, \n    \taddress receiver, \n    \taddress, \n    \tuint amountIn\n    ) external override onlyFei {\n        updateOracle();\n\n    \tif (isPair(sender)) {\n    \t\tincentivizeBuy(receiver, amountIn);\n    \t}\n\n    \tif (isPair(receiver)) {\n    \t\tincentivizeSell(sender, amountIn);\n    \t}\n    }\n\n    function setExemptAddress(address account, bool isExempt) external override onlyGovernor {\n    \t_exempt[account] = isExempt;\n        emit ExemptAddressUpdate(account, isExempt);\n    }\n\n    function setTimeWeightGrowth(uint32 growthRate) external override onlyGovernor {\n        TimeWeightInfo memory tw = timeWeightInfo;\n        timeWeightInfo = TimeWeightInfo(tw.blockNo, tw.weight, growthRate, tw.active);\n        emit GrowthRateUpdate(growthRate);\n    }\n\n    function setTimeWeight(uint32 weight, uint32 growth, bool active) external override onlyGovernor {\n        _setTimeWeight(weight, growth, active);\n        // TimeWeightInfo memory tw = timeWeightInfo;\n        // timeWeightInfo = TimeWeightInfo(blockNo, tw.weight, tw.growthRate, tw.active);\n    }\n\n    function getGrowthRate() public view override returns (uint32) {\n        return timeWeightInfo.growthRate;\n    }\n\n    function getTimeWeight() public view override returns (uint32) {\n        TimeWeightInfo memory tw = timeWeightInfo;\n        if (!tw.active) {\n            return 0;\n        }\n\n        uint32 blockDelta = block.number.toUint32().sub(tw.blockNo);\n        return tw.weight.add(blockDelta * tw.growthRate);\n    }\n\n    function isTimeWeightActive() public view override returns (bool) {\n    \treturn timeWeightInfo.active;\n    }\n\n    function isExemptAddress(address account) public view override returns (bool) {\n    \treturn _exempt[account];\n    }\n\n    function isIncentiveParity() public view override returns (bool) {\n        uint32 weight = getTimeWeight();\n        require(weight != 0, \"UniswapIncentive: Incentive zero or not active\");\n\n        (Decimal.D256 memory price,,) = getUniswapPrice();\n        Decimal.D256 memory deviation = calculateDeviation(price, peg());\n        require(!deviation.equals(Decimal.zero()), \"UniswapIncentive: Price already at or above peg\");\n\n        Decimal.D256 memory incentive = calculateBuyIncentiveMultiplier(deviation, weight);\n        Decimal.D256 memory penalty = calculateSellPenaltyMultiplier(deviation);\n        return incentive.equals(penalty);\n    }\n\n    function getBuyIncentive(uint amount) public view override returns(\n        uint incentive, \n        uint32 weight,\n        Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation\n    ) {\n        (initialDeviation, finalDeviation) = getPriceDeviations(-1 * int256(amount));\n        weight = getTimeWeight();\n\n        if (initialDeviation.equals(Decimal.zero())) {\n            return (0, weight, initialDeviation, finalDeviation);\n        }\n\n        uint incentivizedAmount = amount;\n        if (finalDeviation.equals(Decimal.zero())) {\n            incentivizedAmount = getAmountToPegFei();\n        }\n\n        Decimal.D256 memory multiplier = calculateBuyIncentiveMultiplier(initialDeviation, weight);\n        incentive = multiplier.mul(incentivizedAmount).asUint256();\n        return (incentive, weight, initialDeviation, finalDeviation);\n    }\n\n    function getSellPenalty(uint amount) public view override returns(\n        uint penalty, \n        Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation\n    ) {\n        (initialDeviation, finalDeviation) = getPriceDeviations(int256(amount));\n\n        if (finalDeviation.equals(Decimal.zero())) {\n            return (0, initialDeviation, finalDeviation);\n        }\n\n        uint incentivizedAmount = amount;\n        if (initialDeviation.equals(Decimal.zero())) {\n            uint amountToPeg = getAmountToPegFei();\n            require(amount >= amountToPeg, \"UniswapIncentive: Underflow\");\n            incentivizedAmount = amount - amountToPeg;\n        }\n\n        Decimal.D256 memory multiplier = calculateSellPenaltyMultiplier(finalDeviation); \n        penalty = multiplier.mul(incentivizedAmount).asUint256(); \n        return (penalty, initialDeviation, finalDeviation);   \n    }\n\n    function incentivizeBuy(address target, uint amountIn) internal ifMinterSelf {\n    \tif (isExemptAddress(target)) {\n    \t\treturn;\n    \t}\n\n        (uint incentive, uint32 weight,\n        Decimal.D256 memory initialDeviation, \n        Decimal.D256 memory finalDeviation) = getBuyIncentive(amountIn);\n\n        updateTimeWeight(initialDeviation, finalDeviation, weight);\n        if (incentive != 0) {\n            fei().mint(target, incentive);         \n        }\n    }\n\n    function incentivizeSell(address target, uint amount) internal ifBurnerSelf {\n    \tif (isExemptAddress(target)) {\n    \t\treturn;\n    \t}\n\n        (uint penalty, Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation) = getSellPenalty(amount);\n\n        uint32 weight = getTimeWeight();\n        updateTimeWeight(initialDeviation, finalDeviation, weight);\n\n        if (penalty != 0) {\n            fei().burnFrom(target, penalty);\n        }\n    }\n\n    function calculateBuyIncentiveMultiplier(\n        Decimal.D256 memory deviation,\n        uint32 weight\n    ) internal pure returns (Decimal.D256 memory) {\n        Decimal.D256 memory correspondingPenalty = calculat"
    }
  ]
}