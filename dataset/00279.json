{
  "Title": "Access-controlled functions cannot be called when L2 sequencers are down",
  "Content": "**Description:** Given that rollups such as [Optimism](https://docs.optimism.io/chain/differences#address-aliasing) and [Arbitrum](https://docs.arbitrum.io/arbos/l1-to-l2-messaging#address-aliasing) offer methods for forced transaction inclusion, it is important that the aliased sender address is also [checked](https://solodit.xyz/issues/m-8-operator-is-blocked-when-sequencer-is-down-on-arbitrum-sherlock-none-index-git) within access control modifiers when verifying the sender holds a permissioned role to allow the functions to which they are applied to be called even in the event of sequencer downtime. The most pertinent examples include:\n\n* [`PausableOwnable::_checkOwnerOrPauser`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/libraries/PausableOwnable.sol#L17-L24), which is called in the [`onlyOwnerOrPauser`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/libraries/PausableOwnable.sol#L9-L15) modifier, which itself is applied to [`PausableOwnable::transferPauserCapability`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/libraries/PausableOwnable.sol#L31-L39) and, more importantly, [`NttManagerState::pause`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/NttManager/NttManagerState.sol#L188-L191).\n* [`OwnableUpgradeable::_checkOwner`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/libraries/external/OwnableUpgradeable.sol#L83-L90) which is called in the [`onlyOwner`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/libraries/external/OwnableUpgradeable.sol#L67-L73) modifier, which itself is applied to [`OwnableUpgradeable::transferOwnership`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/libraries/external/OwnableUpgradeable.sol#L92-L101), [`NttManagerState::upgrade`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/NttManager/NttManagerState.sol#L183-L186), [`NttManagerState::transferOwnership`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/NttManager/NttManagerState.sol#L193-L203), [`NttManagerState::setTransceiver`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/NttManager/NttManagerState.sol#L205-L228), [`NttManagerState::removeTransceiver`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/NttManager/NttManagerState.sol#L230-L242), [`NttManagerState::setThreshold`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/NttManager/NttManagerState.sol#L244-L257), [`NttManagerState::setPeer`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/NttManager/NttManagerState.sol#L259-L281), [`NttManagerState::setOutboundLimit`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/NttManager/NttManagerState.sol#L283-L286), [`NttManagerState::setInboundLimit`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/NttManager/NttManagerState.sol#L288-L291), and [`Transceiver::upgrade`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/Transceiver/Transceiver.sol#L66-L68).\n* The [`onlyRelayer`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/Transceiver/WormholeTransceiver/WormholeTransceiverState.sol#L274-L279) modifier which is applied to [`WormholeTransceiver::receiveWormholeMessages`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/Transceiver/WormholeTransceiver/WormholeTransceiver.sol#L64-L105).\n\n**Impact:** Failure to consider the aliased sender address prevents the execution of admin or otherwise permissioned functionality on a chain where transactions are batched by a centralized L2 sequencer. Since this functionality could be time-sensitive, such as the urgent pausing of the protocol or the relaying of NTT messages, this issue has the potential to have a high impact with reasonable likelihood.\n\n**Proof of Concept:** While potentially unlikely, a possible scenario could include:\n\n1. An attacker identifies an exploit in the NTT Manager’s protocol on the source chain and plans to bridge stolen funds to the Ethereum mainnet. Assume the source chain is an L2 rollup that batches transactions for publishing onto the L1 chain via a centralized sequencer.\n2. The L2 sequencer goes down; however, transactions can still be executed via forced inclusion on the L1 chain. The Attacker could either have forced or waited for this to happen.\n3. The Attacker exploits the protocol and initiates a native token transfer, kicking off the 24-hour rate limit duration. Assume the outbound rate limit is hit on the L2, but the inbound limit is not exceeded on the Ethereum mainnet.\n4. Access-controlled functions are not callable since they do not check the aliased sender address, so admin transactions cannot be force-included from L1, e.g. pause the protocol.\n5. The rate limit duration passes, and the sequencer is still down – the attacker completes the outbound transfer (assuming attestations are made) and relays the message on the Ethereum mainnet.\n\n**Recommended Mitigation:** Validation of the sender address against permissioned owner/pauser/relayer roles should also consider the aliased equivalents to allow access-controlled functionality to be executed via forced inclusion. Another relevant precaution for the exploit case described above is to reduce the inbound rate limit of the affected chain to zero, which should work to mitigate this issue so long as the transaction can be successfully executed on the destination (i.e. it is not also an L2 rollup simultaneously experiencing sequencer downtime).\n\n**Wormhole Foundation:** There hasn’t been an extensive L2 sequencer downtime event lasting more than a few hours. We think it’s unlikely an attacker would hold on to a vulnerability to coincide with a downtime event, and we have the rate limiter to cap impact with the assumption the downtime doesn’t last longer than a few hours.\n\n**Cyfrin:** Acknowledged.\n\n\\clearpage",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "evm/src/libraries/PausableOwnable.sol",
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity >=0.8.8 <0.9.0;\n\nimport \"./PausableUpgradeable.sol\";\nimport \"./external/OwnableUpgradeable.sol\";\n\nabstract contract PausableOwnable is PausableUpgradeable, OwnableUpgradeable {\n    /*\n     * @dev Modifier to allow only the Pauser and the Owner to access pausing functionality\n     */\n    modifier onlyOwnerOrPauser() {\n        _checkOwnerOrPauser(owner());\n        _;\n    }\n\n    /*\n     * @dev Modifier to allow only the Pauser to access some functionality\n     */\n    function _checkOwnerOrPauser(address owner) internal view {\n        if (pauser() != msg.sender && owner != msg.sender) {\n            revert InvalidPauser(msg.sender);\n        }\n    }\n\n    function __PausedOwnable_init(address initialPauser, address owner) internal onlyInitializing {\n        __Paused_init(initialPauser);\n        __Ownable_init(owner);\n    }\n\n    /**\n     * @dev Transfers the ability to pause to a new account (`newPauser`).\n     */\n    function transferPauserCapability(address newPauser) public virtual onlyOwnerOrPauser {\n        PauserStorage storage $ = _getPauserStorage();\n        address oldPauser = $._pauser;\n        $._pauser = newPauser;\n        emit PauserTransferred(oldPauser, newPauser);\n    }\n}"
    },
    {
      "filename": "evm/src/libraries/external/OwnableUpgradeable.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n// COPIED FROM OPENZEPPELIN v5.0.1\n// COPIED TO CHANGE SOLC FROM ^0.8.20 TO ^0.8.19\n\npragma solidity ^0.8.19;\n\nimport {ContextUpgradeable} from \"./ContextUpgradeable.sol\";\nimport {Initializable} from \"./Initializable.sol\";\nimport \"../../interfaces/IOwnableUpgradeable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable, IOwnableUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation =\n        0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}"
    },
    {
      "filename": "evm/src/Transceiver/WormholeTransceiver/WormholeTransceiverState.sol",
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity >=0.8.8 <0.9.0;\n\nimport \"wormhole-solidity-sdk/WormholeRelayerSDK.sol\";\nimport \"wormhole-solidity-sdk/libraries/BytesParsing.sol\";\nimport \"wormhole-solidity-sdk/interfaces/IWormhole.sol\";\n\nimport \"../../libraries/TransceiverHelpers.sol\";\nimport \"../../libraries/TransceiverStructs.sol\";\n\nimport \"../../interfaces/IWormholeTransceiver.sol\";\nimport \"../../interfaces/IWormholeTransceiverState.sol\";\nimport \"../../interfaces/ISpecialRelayer.sol\";\nimport \"../../interfaces/INttManager.sol\";\n\nimport \"../Transceiver.sol\";\n\nabstract contract WormholeTransceiverState is IWormholeTransceiverState, Transceiver {\n    using BytesParsing for bytes;\n\n    // ==================== Immutables ===============================================\n    uint8 public immutable consistencyLevel;\n    IWormhole public immutable wormhole;\n    IWormholeRelayer public immutable wormholeRelayer;\n    ISpecialRelayer public immutable specialRelayer;\n    uint256 immutable wormholeTransceiver_evmChainId;\n    uint256 public immutable gasLimit;\n\n    // ==================== Constants ================================================\n\n    /// @dev Prefix for all TransceiverMessage payloads\n    ///      This is 0x99'E''W''H'\n    /// @notice Magic string (constant value set by messaging provider) that idenfies the payload as an transceiver-emitted payload.\n    ///         Note that this is not a security critical field. It's meant to be used by messaging providers to identify which messages are Transceiver-related.\n    bytes4 constant WH_TRANSCEIVER_PAYLOAD_PREFIX = 0x9945FF10;\n\n    /// @dev Prefix for all Wormhole transceiver initialisation payloads\n    ///      This is bytes4(keccak256(\"WormholeTransceiverInit\"))\n    bytes4 constant WH_TRANSCEIVER_INIT_PREFIX = 0x9c23bd3b;\n\n    /// @dev Prefix for all Wormhole peer registration payloads\n    ///      This is bytes4(keccak256(\"WormholePeerRegistration\"))\n    bytes4 constant WH_PEER_REGISTRATION_PREFIX = 0x18fc67c2;\n\n    constructor(\n        address nttManager,\n        address wormholeCoreBridge,\n        address wormholeRelayerAddr,\n        address specialRelayerAddr,\n        uint8 _consistencyLevel,\n        uint256 _gasLimit\n    ) Transceiver(nttManager) {\n        wormhole = IWormhole(wormholeCoreBridge);\n        wormholeRelayer = IWormholeRelayer(wormholeRelayerAddr);\n        specialRelayer = ISpecialRelayer(specialRelayerAddr);\n        wormholeTransceiver_evmChainId = block.chainid;\n        consistencyLevel = _consistencyLevel;\n        gasLimit = _gasLimit;\n    }\n\n    enum RelayingType {\n        Standard,\n        Special,\n        Manual\n    }\n\n    function _initialize() internal override {\n        super._initialize();\n        _initializeTransceiver();\n    }\n\n    function _initializeTransceiver() internal {\n        TransceiverStructs.TransceiverInit memory init = TransceiverStructs.TransceiverInit({\n            transceiverIdentifier: WH_TRANSCEIVER_INIT_PREFIX,\n            nttManagerAddress: toWormholeFormat(nttManager),\n            nttManagerMode: INttManager(nttManager).getMode(),\n            tokenAddress: toWormholeFormat(nttManagerToken),\n            tokenDecimals: INttManager(nttManager).tokenDecimals()\n        });\n        wormhole.publishMessage(0, TransceiverStructs.encodeTransceiverInit(init), consistencyLevel);\n    }\n\n    function _checkImmutables() internal view override {\n        super._checkImmutables();\n        assert(this.wormhole() == wormhole);\n        assert(this.wormholeRelayer() == wormholeRelayer);\n        assert(this.specialRelayer() == specialRelayer);\n        assert(this.consistencyLevel() == consistencyLevel);\n    }\n\n    // =============== Storage ===============================================\n\n    bytes32 private constant WORMHOLE_CONSUMED_VAAS_SLOT =\n        bytes32(uint256(keccak256(\"whTransceiver.consumedVAAs\")) - 1);\n\n    bytes32 private constant WORMHOLE_PEERS_SLOT =\n        bytes32(uint256(keccak256(\"whTransceiver.peers\")) - 1);\n\n    bytes32 private constant WORMHOLE_RELAYING_ENABLED_CHAINS_SLOT =\n        bytes32(uint256(keccak256(\"whTransceiver.relayingEnabledChains\")) - 1);\n\n    bytes32 private constant SPECIAL_RELAYING_ENABLED_CHAINS_SLOT =\n        bytes32(uint256(keccak256(\"whTransceiver.specialRelayingEnabledChains\")) - 1);\n\n    bytes32 private constant WORMHOLE_EVM_CHAIN_IDS =\n        bytes32(uint256(keccak256(\"whTransceiver.evmChainIds\")) - 1);\n\n    // =============== Storage Setters/Getters ========================================\n\n    function _getWormholeConsumedVAAsStorage()\n        internal\n        pure\n        returns (mapping(bytes32 => bool) storage $)\n    {\n        uint256 slot = uint256(WORMHOLE_CONSUMED_VAAS_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    function _getWormholePeersStorage()\n        internal\n        pure\n        returns (mapping(uint16 => bytes32) storage $)\n    {\n        uint256 slot = uint256(WORMHOLE_PEERS_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    function _getWormholeRelayingEnabledChainsStorage()\n        internal\n        pure\n        returns (mapping(uint16 => uint256) storage $)\n    {\n        uint256 slot = uint256(WORMHOLE_RELAYING_ENABLED_CHAINS_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    function _getSpecialRelayingEnabledChainsStorage()\n        internal\n        pure\n        returns (mapping(uint16 => uint256) storage $)\n    {\n        uint256 slot = uint256(SPECIAL_RELAYING_ENABLED_CHAINS_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    function _getWormholeEvmChainIdsStorage()\n        internal\n        pure\n        returns (mapping(uint16 => uint256) storage $)\n    {\n        uint256 slot = uint256(WORMHOLE_EVM_CHAIN_IDS);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    // =============== Public Getters ======================================================\n\n    /// @inheritdoc IWormholeTransceiverState\n    function isVAAConsumed(bytes32 hash) public view returns (bool) {\n        return _getWormholeConsumedVAAsStorage()[hash];\n    }\n\n    /// @inheritdoc IWormholeTransceiverState\n    function getWormholePeer(uint16 chainId) public view returns (bytes32) {\n        return _getWormholePeersStorage()[chainId];\n    }\n\n    /// @inheritdoc IWormholeTransceiverState\n    function isWormholeRelayingEnabled(uint16 chainId) public view returns (bool) {\n        return toBool(_getWormholeRelayingEnabledChainsStorage()[chainId]);\n    }\n\n    /// @inheritdoc IWormholeTransceiverState\n    function isSpecialRelayingEnabled(uint16 chainId) public view returns (bool) {\n        return toBool(_getSpecialRelayingEnabledChainsStorage()[chainId]);\n    }\n\n    /// @inheritdoc IWormholeTransceiverState\n    function isWormholeEvmChain(uint16 chainId) public view returns (bool) {\n        return toBool(_getWormholeEvmChainIdsStorage()[chainId]);\n    }\n\n    // =============== Admin ===============================================================\n\n    /// @inheritdoc IWormholeTransceiverState\n    function setWormholePeer(uint16 peerChainId, bytes32 peerContract) external onlyOwner {\n        if (peerChainId == 0) {\n            revert InvalidWormholeChainIdZero();\n        }\n        if (peerContract == bytes32(0)) {\n            revert InvalidWormholePeerZeroAddress();\n        }\n\n        bytes32 oldPeerContract = _getWormholePeersStorage()[peerChainId];\n\n        // We don't want to allow updating a peer since this adds complexity in the accountant\n        // If the owner makes a mistake with peer registration they should deploy a new Wormhole\n        // transceiver and register this new transceiver with the NttManager\n        if (oldPeerContract != bytes32(0)) {\n            revert PeerAlreadySet(peerChainId, oldPeerContract);\n        }\n\n        _getWormholePeersStorage()[peerChainId] = peerContract;\n\n        // Publish a message for this transceiver registration\n        TransceiverStructs.TransceiverRegistration memory registration = TransceiverStructs\n            .TransceiverRegistration({\n            transceiverIdentifier: WH_PEER_REGISTRATION_PREFIX,\n            transceiverChainId: peerChainId,\n            transceiverAddress: peerContract\n        });\n        wormhole.publishMessage(\n            0, TransceiverStructs.encodeTransceiverRegistration(registration), consistencyLevel\n        );\n\n        emit SetWormholePeer(peerChainId, peerContract);\n    }\n\n    /// @inheritdoc IWormholeTransceiverState\n    function setIsWormholeEvmChain(uint16 chainId) external onlyOwner {\n        if (chainId == 0) {\n            revert InvalidWormholeChainIdZero();\n        }\n        _getWormholeEvmChainIdsStorage()[chainId] = TRUE;\n\n        emit SetIsWormholeEvmChain(chainId);\n    }\n\n    /// @inheritdoc IWormholeTransceiverState\n    function setIsWormholeRelayingEnabled(uint16 chainId, bool isEnabled) external onlyOwner {\n        if (chainId == 0) {\n            revert InvalidWormholeChainIdZero();\n        }\n        _getWormholeRelayingEnabledChainsStorage()[chainId] = toWord(isEnabled);\n\n        emit SetIsWormholeRelayingEnabled(chainId, isEnabled);\n    }\n\n    /// @inheritdoc IWormholeTransceiverState\n    function setIsSpecialRelayingEnabled(uint16 chainId, bool isEnabled) external onlyOwner {\n        if (chainId == 0) {\n            revert InvalidWormholeChainIdZero();\n        }\n        _getSpecialRelayingEnabledChainsStorage()[chainId] = toWord(isEnabled);\n\n        emit SetIsSpecialRelayingEnabled(chainId, isEnabled);\n    }\n\n    // ============= Internal ===============================================================\n\n    function _checkInvalidRelayingConfig(uint16 chainId) internal view returns (bool) {\n        return isWormholeRelayingEnabled(chainId) && !isWormholeEvmChain(chainId);\n    }\n\n    function _shouldRelayViaStandardRelaying(uint16 chainId) internal view returns (bool) {\n        return isWormholeRelayingEnabled(chainId) && isWormholeEvmChain(chainId);\n    }\n\n    function _setVAAConsumed(bytes32 hash) internal {\n        _getWormholeConsumedVAAsStorage()[hash] = true;\n    }\n\n    // =============== MODIFIERS ===============================================\n\n    modifier onlyRelayer() {\n        if (msg.sender != address(wormholeRelayer)) {\n            revert CallerNotRelayer(msg.sender);\n        }\n        _;\n    }\n}"
    }
  ]
}