{
  "Title": "[04] CALLING `ExtraordinaryFunding.proposeExtraordinary` AND `StandardFunding.proposeStandard` FUNCTIONS CAN REVERT AND WASTE GAS",
  "Content": "Calling the following `ExtraordinaryFunding.proposeExtraordinary` and `StandardFunding.proposeStandard` functions will call the `Funding._validateCallDatas` function below. Calling the `Funding._validateCallDatas` function will revert if `targets_[i] != ajnaTokenAddress || values_[i] != 0` is true. Hence, the `ExtraordinaryFunding.proposeExtraordinary` and `StandardFunding.proposeStandard` functions cannot be used to create proposals for calling addresses other than `ajnaTokenAddress` or sending ETH. When users are unaware of this, they could believe that proposals for general purposes can be created and executed; yet, because calling `ExtraordinaryFunding.proposeExtraordinary` and `StandardFunding.proposeStandard` functions with `targets_` being not `ajnaTokenAddress` or `values_` being positive revert, these users would waste their gas for nothing. To avoid confusion and disputes, please consider updating the `ExtraordinaryFunding.proposeExtraordinary` and `StandardFunding.proposeStandard` functions so `targets_` and `values_` would only be `ajnaTokenAddress` and 0 and not be specified by users.\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/ExtraordinaryFunding.sol#L85-L124\n```solidity\n    function proposeExtraordinary(\n        uint256 endBlock_,\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        string memory description_) external override returns (uint256 proposalId_) {\n        ...\n        uint128 totalTokensRequested = _validateCallDatas(targets_, values_, calldatas_);\n        ...\n    }\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L366-L404\n```solidity\n    function proposeStandard(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        string memory description_\n    ) external override returns (uint256 proposalId_) {\n        ...\n        newProposal.tokensRequested = _validateCallDatas(targets_, values_, calldatas_); // check proposal parameters are valid and update tokensRequested\n        ...\n    }\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/Funding.sol#L103-L141\n```solidity\n    function _validateCallDatas(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_\n    ) internal view returns (uint128 tokensRequested_) {\n\n        // check params have matching lengths\n        if (targets_.length == 0 || targets_.length != values_.length || targets_.length != calldatas_.length) revert InvalidProposal();\n\n        for (uint256 i = 0; i < targets_.length;) {\n\n            // check targets and values params are valid\n            if (targets_[i] != ajnaTokenAddress || values_[i] != 0) revert InvalidProposal();\n            ...\n        }\n    }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-05-ajna",
  "Code": [
    {
      "filename": "ajna-grants/src/grants/base/ExtraordinaryFunding.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { IERC20 }   from \"@oz/token/ERC20/IERC20.sol\";\nimport { SafeCast } from \"@oz/utils/math/SafeCast.sol\";\n\nimport { Funding } from \"./Funding.sol\";\n\nimport { IExtraordinaryFunding } from \"../interfaces/IExtraordinaryFunding.sol\";\n\nimport { Maths } from \"../libraries/Maths.sol\";\n\nabstract contract ExtraordinaryFunding is Funding, IExtraordinaryFunding {\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /**\n     * @notice The maximum length of a proposal's voting period, in blocks.\n     */\n    uint256 internal constant MAX_EFM_PROPOSAL_LENGTH = 216_000; // number of blocks in one month\n\n    /**\n     * @notice Keccak hash of a prefix string for extraordinary funding mechanism\n     */\n    bytes32 internal constant DESCRIPTION_PREFIX_HASH_EXTRAORDINARY = keccak256(bytes(\"Extraordinary Funding: \"));\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /**\n     * @notice Mapping of extant extraordinary funding proposals.\n     * @dev proposalId => ExtraordinaryFundingProposal.\n     */\n    mapping (uint256 => ExtraordinaryFundingProposal) internal _extraordinaryFundingProposals;\n\n    /**\n     * @notice The list of extraordinary funding proposalIds that have been executed.\n     */\n    uint256[] internal _fundedExtraordinaryProposals;\n\n    /**\n     * @notice Mapping checking if a voter has voted on a given proposal.\n     * @dev proposalId => address => bool.\n     */\n    mapping(uint256 => mapping(address => bool)) public hasVotedExtraordinary;\n\n    /**************************/\n    /*** Proposal Functions ***/\n    /**************************/\n\n    /// @inheritdoc IExtraordinaryFunding\n    function executeExtraordinary(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        bytes32 descriptionHash_\n    ) external nonReentrant override returns (uint256 proposalId_) {\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, descriptionHash_)));\n\n        ExtraordinaryFundingProposal storage proposal = _extraordinaryFundingProposals[proposalId_];\n\n        // since we are casting from uint128 to uint256, we can safely assume that the value will not overflow\n        uint256 tokensRequested = uint256(proposal.tokensRequested);\n\n        // check proposal is succesful and hasn't already been executed\n        if (proposal.executed || !_extraordinaryProposalSucceeded(proposalId_, tokensRequested)) revert ExecuteExtraordinaryProposalInvalid();\n\n        _fundedExtraordinaryProposals.push(proposalId_);\n\n        // update proposal state\n        proposal.executed = true;\n\n        // update treasury\n        treasury -= tokensRequested;\n\n        // execute proposal's calldata\n        _execute(proposalId_, targets_, values_, calldatas_);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function proposeExtraordinary(\n        uint256 endBlock_,\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        string memory description_) external override returns (uint256 proposalId_) {\n\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, keccak256(bytes(description_)))));\n\n        ExtraordinaryFundingProposal storage newProposal = _extraordinaryFundingProposals[proposalId_];\n\n        // check if proposal already exists (proposal id not 0)\n        if (newProposal.proposalId != 0) revert ProposalAlreadyExists();\n\n        // check proposal length is within limits of 1 month maximum\n        if (block.number + MAX_EFM_PROPOSAL_LENGTH < endBlock_) revert InvalidProposal();\n\n        uint128 totalTokensRequested = _validateCallDatas(targets_, values_, calldatas_);\n\n        // check tokens requested are available for claiming from the treasury\n        if (uint256(totalTokensRequested) > _getSliceOfTreasury(Maths.WAD - _getMinimumThresholdPercentage())) revert InvalidProposal();\n\n        // store newly created proposal\n        newProposal.proposalId      = proposalId_;\n        newProposal.startBlock      = SafeCast.toUint128(block.number);\n        newProposal.endBlock        = SafeCast.toUint128(endBlock_);\n        newProposal.tokensRequested = totalTokensRequested;\n\n        emit ProposalCreated(\n            proposalId_,\n            msg.sender,\n            targets_,\n            values_,\n            new string[](targets_.length),\n            calldatas_,\n            block.number,\n            endBlock_,\n            description_\n        );\n    }\n\n    /************************/\n    /*** Voting Functions ***/\n    /************************/\n\n    /// @inheritdoc IExtraordinaryFunding\n    function voteExtraordinary(\n        uint256 proposalId_\n    ) external override returns (uint256 votesCast_) {\n        // revert if msg.sender already voted on proposal\n        if (hasVotedExtraordinary[proposalId_][msg.sender]) revert AlreadyVoted();\n\n        ExtraordinaryFundingProposal storage proposal = _extraordinaryFundingProposals[proposalId_];\n        // revert if proposal is inactive\n        if (proposal.startBlock > block.number || proposal.endBlock < block.number || proposal.executed) {\n            revert ExtraordinaryFundingProposalInactive();\n        }\n\n        // check voting power at snapshot block and update proposal votes\n        votesCast_ = _getVotesExtraordinary(msg.sender, proposalId_);\n        proposal.votesReceived += SafeCast.toUint120(votesCast_);\n\n        // record that voter has voted on this extraordinary funding proposal\n        hasVotedExtraordinary[proposalId_][msg.sender] = true;\n\n        emit VoteCast(\n            msg.sender,\n            proposalId_,\n            1,\n            votesCast_,\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Check if a proposal for extraordinary funding has succeeded.\n     * @param  proposalId_ The ID of the proposal being checked.\n     * @return Boolean indicating whether the proposal has succeeded.\n     */\n    function _extraordinaryProposalSucceeded(\n        uint256 proposalId_,\n        uint256 tokensRequested_\n    ) internal view returns (bool) {\n        uint256 votesReceived          = uint256(_extraordinaryFundingProposals[proposalId_].votesReceived);\n        uint256 minThresholdPercentage = _getMinimumThresholdPercentage();\n\n        return\n            // succeeded if proposal's votes received doesn't exceed the minimum threshold required\n            (votesReceived >= tokensRequested_ + _getSliceOfNonTreasury(minThresholdPercentage))\n            &&\n            // succeeded if tokens requested are available for claiming from the treasury\n            (tokensRequested_ <= _getSliceOfTreasury(Maths.WAD - minThresholdPercentage))\n        ;\n    }\n\n    /********************************/\n    /*** Internal View Functions ****/\n    /********************************/\n\n    /**\n     * @notice Get the current ProposalState of a given proposal.\n     * @dev    Used by GrantFund.state() for analytics compatability purposes.\n     * @param  proposalId_ The ID of the proposal being checked.\n     * @return The proposals status in the ProposalState enum.\n     */\n    function _getExtraordinaryProposalState(uint256 proposalId_) internal view returns (ProposalState) {\n        ExtraordinaryFundingProposal memory proposal = _extraordinaryFundingProposals[proposalId_];\n\n        bool voteSucceeded = _extraordinaryProposalSucceeded(proposalId_, uint256(proposal.tokensRequested));\n\n        if (proposal.executed)                                        return ProposalState.Executed;\n        else if (proposal.endBlock >= block.number && !voteSucceeded) return ProposalState.Active;\n        else if (voteSucceeded)                                       return ProposalState.Succeeded;\n        else                                                          return ProposalState.Defeated;\n    }\n\n    /**\n     * @notice Get the minimum percentage of ajna tokens required for a proposal to pass.\n     * @dev    The minimum threshold increases according to the number of funded EFM proposals.\n     * @return The minimum threshold percentage, as a WAD.\n     */\n    function _getMinimumThresholdPercentage() internal view returns (uint256) {\n        // default minimum threshold is 50\n        if (_fundedExtraordinaryProposals.length == 0) {\n            return 0.5 * 1e18;\n        }\n        // minimum threshold increases according to the number of funded EFM proposals\n        else {\n            return 0.5 * 1e18 + (_fundedExtraordinaryProposals.length * (0.05 * 1e18));\n        }\n    }\n\n    /**\n     * @notice Get the number of ajna tokens equivalent to a given percentage.\n     * @param percentage_ The percentage of the Non treasury to retrieve, in WAD.\n     * @return The number of tokens, in WAD.\n     */\n    function _getSliceOfNonTreasury(\n        uint256 percentage_\n    ) internal view returns (uint256) {\n        uint256 totalAjnaSupply = IERC20(ajnaTokenAddress).totalSupply();\n        return Maths.wmul(totalAjnaSupply - treasury, percentage_);\n    }\n\n    /**\n     * @notice Get the number of ajna tokens equivalent to a given percentage.\n     * @param percentage_ The percentage of the treasury to retrieve, in WAD.\n     * @return The number of tokens, in WAD.\n     */\n    function _getSliceOfTreasury(\n        uint256 percentage_\n    ) internal view returns (uint256) {\n        return Maths.wmul(treasury, percentage_);\n    }\n\n    /**\n     * @notice Get the voting power available to a voter for a given proposal.\n     * @param  account_        The address of the voter to check.\n     * @param  proposalId_     The ID of the proposal being voted on.\n     * @return votes_          The number of votes available to be cast in voteExtraordinary.\n     */\n    function _getVotesExtraordinary(address account_, uint256 proposalId_) internal view returns (uint256 votes_) {\n        if (proposalId_ == 0) revert ExtraordinaryFundingProposalInactive();\n\n        uint256 startBlock = _extraordinaryFundingProposals[proposalId_].startBlock;\n\n        votes_ = _getVotesAtSnapshotBlocks(\n            account_,\n            startBlock - VOTING_POWER_SNAPSHOT_DELAY,\n            startBlock\n        );\n    }\n\n    /********************************/\n    /*** External View Functions ****/\n    /********************************/\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getMinimumThresholdPercentage() external view returns (uint256) {\n        return _getMinimumThresholdPercentage();\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getSliceOfNonTreasury(\n        uint256 percentage_\n    ) external view override returns (uint256) {\n        return _getSliceOfNonTreasury(percentage_);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getSliceOfTreasury(\n        uint256 percentage_\n    ) external view override returns (uint256) {\n        return _getSliceOfTreasury(percentage_);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getExtraordinaryProposalInfo(\n        uint256 proposalId_\n    ) external view override returns (uint256, uint128, uint128, uint128, uint120, bool) {\n        return (\n            _extraordinaryFundingProposals[proposalId_].proposalId,\n            _extraordinaryFundingProposals[proposalId_].startBlock,\n            _extraordinaryFundingProposals[proposalId_].endBlock,\n            _extraordinaryFundingProposals[proposalId_].tokensRequested,\n            _extraordinaryFundingProposals[proposalId_].votesReceived,\n            _extraordinaryFundingProposals[proposalId_].executed\n        );\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getExtraordinaryProposalSucceeded(uint256 proposalId_) external view override returns (bool) {\n        // since we are casting from uint128 to uint256, we can safely assume that the value will not overflow\n        uint256 tokensRequested = uint256(_extraordinaryFundingProposals[proposalId_].tokensRequested);\n\n        return _extraordinaryProposalSucceeded(proposalId_, tokensRequested);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getVotesExtraordinary(address account_, uint256 proposalId_) external view override returns (uint256) {\n        if (hasVotedExtraordinary[proposalId_][account_]) return 0;\n        return _getVotesExtraordinary(account_, proposalId_);\n    }\n\n}"
    },
    {
      "filename": "ajna-grants/src/grants/base/StandardFunding.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { IERC20 }    from \"@oz/token/ERC20/IERC20.sol\";\nimport { SafeCast }  from \"@oz/utils/math/SafeCast.sol\";\nimport { SafeERC20 } from \"@oz/token/ERC20/utils/SafeERC20.sol\";\n\nimport { Funding } from \"./Funding.sol\";\n\nimport { IStandardFunding } from \"../interfaces/IStandardFunding.sol\";\n\nimport { Maths } from \"../libraries/Maths.sol\";\n\nabstract contract StandardFunding is Funding, IStandardFunding {\n\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /**\n     * @notice Maximum percentage of tokens that can be distributed by the treasury in a quarter.\n     * @dev Stored as a Wad percentage.\n     */\n    uint256 internal constant GLOBAL_BUDGET_CONSTRAINT = 0.03 * 1e18;\n\n    /**\n     * @notice Length of the challengephase of the distribution period in blocks.\n     * @dev    Roughly equivalent to the number of blocks in 7 days.\n     * @dev    The period in which funded proposal slates can be checked in updateSlate.\n     */\n    uint256 internal constant CHALLENGE_PERIOD_LENGTH = 50400;\n\n    /**\n     * @notice Length of the distribution period in blocks.\n     * @dev    Roughly equivalent to the number of blocks in 90 days.\n     */\n    uint48 internal constant DISTRIBUTION_PERIOD_LENGTH = 648000;\n\n    /**\n     * @notice Length of the funding phase of the distribution period in blocks.\n     * @dev    Roughly equivalent to the number of blocks in 10 days.\n     */\n    uint256 internal constant FUNDING_PERIOD_LENGTH = 72000;\n\n    /**\n     * @notice Keccak hash of a prefix string for standard funding mechanism\n     */\n    bytes32 internal constant DESCRIPTION_PREFIX_HASH_STANDARD = keccak256(bytes(\"Standard Funding: \"));\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /**\n     * @notice ID of the current distribution period.\n     * @dev Used to access information on the status of an ongoing distribution.\n     * @dev Updated at the start of each quarter.\n     * @dev Monotonically increases by one per period.\n     */\n    uint24 internal _currentDistributionId = 0;\n\n    /**\n     * @notice Mapping of quarterly distributions from the grant fund.\n     * @dev distributionId => QuarterlyDistribution\n     */\n    mapping(uint24 => QuarterlyDistribution) internal _distributions;\n\n    /**\n     * @dev Mapping of all proposals that have ever been submitted to the grant fund for screening.\n     * @dev proposalId => Proposal\n     */\n    mapping(uint256 => Proposal) internal _standardFundingProposals;\n\n    /**\n     * @dev Mapping of distributionId to a sorted array of 10 proposalIds with the most votes in the screening period.\n     * @dev distribution.id => proposalId[]\n     * @dev A new array is created for each distribution period\n     */\n    mapping(uint256 => uint256[]) internal _topTenProposals;\n\n    /**\n     * @notice Mapping of a hash of a proposal slate to a list of funded proposals.\n     * @dev slate hash => proposalId[]\n     */\n    mapping(bytes32 => uint256[]) internal _fundedProposalSlates;\n\n    /**\n     * @notice Mapping of quarterly distributions to voters to a Quadratic Voter info struct.\n     * @dev distributionId => voter address => QuadraticVoter \n     */\n    mapping(uint256 => mapping(address => QuadraticVoter)) internal _quadraticVoters;\n\n    /**\n     * @notice Mapping of distributionId to whether surplus funds from distribution updated into treasury\n     * @dev distributionId => bool\n    */\n    mapping(uint256 => bool) internal _isSurplusFundsUpdated;\n\n    /**\n     * @notice Mapping of distributionId to user address to whether user has claimed his delegate reward\n     * @dev distributionId => address => bool\n    */\n    mapping(uint256 => mapping(address => bool)) public hasClaimedReward;\n\n    /**\n     * @notice Mapping of distributionId to user address to total votes cast on screening stage proposals.\n     * @dev distributionId => address => uint256\n    */\n    mapping(uint256 => mapping(address => uint256)) public screeningVotesCast;\n\n    /**************************************************/\n    /*** Distribution Management Functions External ***/\n    /**************************************************/\n\n    /// @inheritdoc IStandardFunding\n    function startNewDistributionPeriod() external override returns (uint24 newDistributionId_) {\n        uint24  currentDistributionId       = _currentDistributionId;\n        uint256 currentDistributionEndBlock = _distributions[currentDistributionId].endBlock;\n\n        // check that there isn't currently an active distribution period\n        if (block.number <= currentDistributionEndBlock) revert DistributionPeriodStillActive();\n\n        // update Treasury with unused funds from last two distributions\n        {\n            // Check if any last distribution exists and its challenge stage is over\n            if (currentDistributionId > 0 && (block.number > _getChallengeStageEndBlock(currentDistributionEndBlock))) {\n                // Add unused funds from last distribution to treasury\n                _updateTreasury(currentDistributionId);\n            }\n\n            // checks if any second last distribution exist and its unused funds are not added into treasury\n            if (currentDistributionId > 1 && !_isSurplusFundsUpdated[currentDistributionId - 1]) {\n                // Add unused funds from second last distribution to treasury\n                _updateTreasury(currentDistributionId - 1);\n            }\n        }\n\n        // set the distribution period to start at the current block\n        uint48 startBlock = SafeCast.toUint48(block.number);\n        uint48 endBlock = startBlock + DISTRIBUTION_PERIOD_LENGTH;\n\n        // set new value for currentDistributionId\n        newDistributionId_ = _setNewDistributionId();\n\n        // create QuarterlyDistribution struct\n        QuarterlyDistribution storage newDistributionPeriod = _distributions[newDistributionId_];\n        newDistributionPeriod.id              = newDistributionId_;\n        newDistributionPeriod.startBlock      = startBlock;\n        newDistributionPeriod.endBlock        = endBlock;\n        uint256 gbc                           = Maths.wmul(treasury, GLOBAL_BUDGET_CONSTRAINT);\n        newDistributionPeriod.fundsAvailable  = SafeCast.toUint128(gbc);\n\n        // decrease the treasury by the amount that is held for allocation in the new distribution period\n        treasury -= gbc;\n\n        emit QuarterlyDistributionStarted(\n            newDistributionId_,\n            startBlock,\n            endBlock\n        );\n    }\n\n    /**************************************************/\n    /*** Distribution Management Functions Internal ***/\n    /**************************************************/\n\n    /**\n     * @notice Get the block number at which this distribution period's challenge stage ends.\n     * @param  endBlock_ The end block of quarterly distribution to get the challenge stage end block for.\n     * @return The block number at which this distribution period's challenge stage ends.\n    */\n    function _getChallengeStageEndBlock(\n        uint256 endBlock_\n    ) internal pure returns (uint256) {\n        return endBlock_ + CHALLENGE_PERIOD_LENGTH;\n    }\n\n    /**\n     * @notice Get the block number at which this distribution period's screening stage ends.\n     * @param  endBlock_ The end block of quarterly distribution to get the screening stage end block for.\n     * @return The block number at which this distribution period's screening stage ends.\n    */\n    function _getScreeningStageEndBlock(\n        uint256 endBlock_\n    ) internal pure returns (uint256) {\n        return endBlock_ - FUNDING_PERIOD_LENGTH;\n    }\n\n    /**\n     * @notice Updates Treasury with surplus funds from distribution.\n     * @dev    Counters incremented in an unchecked block due to being bounded by array length of at most 10.\n     * @param distributionId_ distribution Id of updating distribution \n     */\n    function _updateTreasury(\n        uint24 distributionId_\n    ) private {\n        bytes32 fundedSlateHash = _distributions[distributionId_].fundedSlateHash;\n        uint256 fundsAvailable  = _distributions[distributionId_].fundsAvailable;\n\n        uint256[] memory fundingProposalIds = _fundedProposalSlates[fundedSlateHash];\n\n        uint256 totalTokensRequested;\n        uint256 numFundedProposals = fundingProposalIds.length;\n\n        for (uint i = 0; i < numFundedProposals; ) {\n            Proposal memory proposal = _standardFundingProposals[fundingProposalIds[i]];\n\n            totalTokensRequested += proposal.tokensRequested;\n\n            unchecked { ++i; }\n        }\n\n        // readd non distributed tokens to the treasury\n        treasury += (fundsAvailable - totalTokensRequested);\n\n        _isSurplusFundsUpdated[distributionId_] = true;\n    }\n\n    /**\n     * @notice Set a new DistributionPeriod Id.\n     * @dev    Increments the previous Id nonce by 1.\n     * @return newId_ The new distribution period Id.\n     */\n    function _setNewDistributionId() private returns (uint24 newId_) {\n        newId_ = _currentDistributionId += 1;\n    }\n\n    /************************************/\n    /*** Delegation Rewards Functions ***/\n    /************************************/\n\n    /// @inheritdoc IStandardFunding\n    function claimDelegateReward(\n        uint24 distributionId_\n    ) external override returns(uint256 rewardClaimed_) {\n        // Revert if delegatee didn't vote in screening stage\n        if(screeningVotesCast[distributionId_][msg.sender] == 0) revert DelegateRewardInvalid();\n\n        QuarterlyDistribution memory currentDistribution = _distributions[distributionId_];\n\n        // Check if Challenge Period is still active\n        if(block.number < _getChallengeStageEndBlock(currentDistribution.endBlock)) revert ChallengePeriodNotEnded();\n\n        // check rewards haven't already been claimed\n        if(hasClaimedReward[distributionId_][msg.sender]) revert RewardAlreadyClaimed();\n\n        QuadraticVoter memory voter = _quadraticVoters[distributionId_][msg.sender];\n\n        // calculate rewards earned for voting\n        rewardClaimed_ = _getDelegateReward(currentDistribution, voter);\n\n        hasClaimedReward[distributionId_][msg.sender] = true;\n\n        emit DelegateRewardClaimed(\n            msg.sender,\n            distributionId_,\n            rewardClaimed_\n        );\n\n        // transfer rewards to delegatee\n        IERC20(ajnaTokenAddress).safeTransfer(msg.sender, rewardClaimed_);\n    }\n\n    /**\n     * @notice Calculate the delegate rewards that have accrued to a given voter, in a given distribution period.\n     * @dev    Voter must have voted in both the screening and funding stages, and is proportional to their share of votes across the stages.\n     * @param  currentDistribution_ Struct of the distribution period to calculat rewards for.\n     * @param  voter_               Struct of the funding stages voter.\n     * @return rewards_             The delegate rewards accrued to the voter.\n     */\n    function _getDelegateReward(\n        QuarterlyDistribution memory currentDistribution_,\n        QuadraticVoter memory voter_\n    ) internal pure returns (uint256 rewards_) {\n        // calculate the total voting power available to the voter that was allocated in the funding stage\n        uint256 votingPowerAllocatedByDelegatee = voter_.votingPower - voter_.remainingVotingPower;\n\n        // if none of the voter's voting power was allocated, they receive no rewards\n        if (votingPowerAllocatedByDelegatee == 0) return 0;\n\n        // calculate reward\n        // delegateeReward = 10 % of GBC distributed as per delegatee Voting power allocated\n        rewards_ = Maths.wdiv(\n            Maths.wmul(\n                currentDistribution_.fundsAvailable,\n                votingPowerAllocatedByDelegatee\n            ),\n            currentDistribution_.fundingVotePowerCast\n        ) / 10;\n    }\n\n    /***********************************/\n    /*** Proposal Functions External ***/\n    /***********************************/\n\n    /// @inheritdoc IStandardFunding\n    function updateSlate(\n        uint256[] calldata proposalIds_,\n        uint24 distributionId_\n    ) external override returns (bool newTopSlate_) {\n        QuarterlyDistribution storage currentDistribution = _distributions[distributionId_];\n\n        // store number of proposals for reduced gas cost of iterations\n        uint256 numProposalsInSlate = proposalIds_.length;\n\n        // check the each proposal in the slate is valid, and get the sum of the proposals fundingVotesReceived\n        uint256 sum = _validateSlate(distributionId_, currentDistribution.endBlock, currentDistribution.fundsAvailable, proposalIds_, numProposalsInSlate);\n\n        // get pointers for comparing proposal slates\n        bytes32 currentSlateHash = currentDistribution.fundedSlateHash;\n        bytes32 newSlateHash     = keccak256(abi.encode(proposalIds_));\n\n        // check if slate of proposals is better than the existing slate, and is thus the new top slate\n        newTopSlate_ = currentSlateHash == 0 ||\n            (currentSlateHash!= 0 && sum > _sumProposalFundingVotes(_fundedProposalSlates[currentSlateHash]));\n\n        // if slate of proposals is new top slate, update state\n        if (newTopSlate_) {\n            uint256[] storage existingSlate = _fundedProposalSlates[newSlateHash];\n\n            for (uint i = 0; i < numProposalsInSlate; ) {\n\n                // update list of proposals to fund\n                existingSlate.push(proposalIds_[i]);\n\n                unchecked { ++i; }\n            }\n\n            // update hash to point to the new leading slate of proposals\n            currentDistribution.fundedSlateHash = newSlateHash;\n\n            emit FundedSlateUpdated(\n                distributionId_,\n                newSlateHash\n            );\n        }\n    }\n\n    /// @inheritdoc IStandardFunding\n    function executeStandard(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        bytes32 descriptionHash_\n    ) external nonReentrant override returns (uint256 proposalId_) {\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_STANDARD, descriptionHash_)));\n        Proposal storage proposal = _standardFundingProposals[proposalId_];\n\n        uint24 distributionId = proposal.distributionId;\n\n        // check that the distribution period has ended, and one week has passed to enable competing slates to be checked\n        if (block.number <= _getChallengeStageEndBlock(_distributions[distributionId].endBlock)) revert ExecuteProposalInvalid();\n\n        // check proposal is succesful and hasn't already been executed\n        if (!_standardFundingVoteSucceeded(proposalId_) || proposal.executed) revert ProposalNotSuccessful();\n\n        proposal.executed = true;\n\n        _execute(proposalId_, targets_, values_, calldatas_);\n    }\n\n    /// @inheritdoc IStandardFunding\n    function proposeStandard(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        string memory description_\n    ) external override returns (uint256 proposalId_) {\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_STANDARD, keccak256(bytes(description_)))));\n\n        Proposal storage newProposal = _standardFundingProposals[proposalId_];\n\n        // check for duplicate proposals\n        if (newProposal.proposalId != 0) revert ProposalAlreadyExists();\n\n        QuarterlyDistribution memory currentDistribution = _distributions[_currentDistributionId];\n\n        // cannot add new proposal after end of screening period\n        // screening period ends 72000 blocks before end of distribution period, ~ 80 days.\n        if (block.number > _getScreeningStageEndBlock(currentDistribution.endBlock)) revert ScreeningPeriodEnded();\n\n        // store new proposal information\n        newProposal.proposalId      = proposalId_;\n        newProposal.distributionId  = currentDistribution.id;\n        newProposal.tokensRequested = _validateCallDatas(targets_, values_, calldatas_); // check proposal parameters are valid and update tokensRequested\n\n        // revert if proposal requested more tokens than are available in the distribution period\n        if (newProposal.tokensRequested > (currentDistribution.fundsAvailable * 9 / 10)) revert InvalidProposal();\n\n        emit ProposalCreated(\n            proposalId_,\n            msg.sender,\n            targets_,\n            values_,\n            new string[](targets_.length),\n            calldatas_,\n            block.number,\n            currentDistribution.endBlock,\n            description_\n        );\n    }\n\n    /***********************************/\n    /*** Proposal Functions Internal ***/\n    /***********************************/\n\n    /**\n     * @notice Check the validity of a potential slate of proposals to execute, and sum the slate's fundingVotesReceived.\n     * @dev    Only iterates through a maximum of 10 proposals that made it through both voting stages.\n     * @dev    Counters incremented in an unchecked block due to being bounded by array length.\n     * @param  distributionId_                   Id of the distribution period to check the slate for.\n     * @param  endBlock                          End block of the distribution period.\n     * @param  distributionPeriodFundsAvailable_ Funds available for distribution in the distribution period.\n     * @param  proposalIds_                      Array of proposal Ids to check.\n     * @param  numProposalsInSlate_              Number of proposals in the slate.\n     * @return sum_                              The total funding votes received by all proposals in the proposed slate.\n     */\n    function _validateSlate(uint24 distributionId_, uint256 endBlock, uint256 distributionPeriodFundsAvailable_, uint256[] calldata proposalIds_, uint256 numProposalsInSlate_) internal view returns (uint256 sum_) {\n        // check that the function is being called within the challenge period\n        if (block.number <= endBlock || block.number > _getChallengeStageEndBlock(endBlock)) {\n            revert InvalidProposalSlate();\n        }\n\n        // check that the slate has no duplicates\n        if (_hasDuplicates(proposalIds_)) revert InvalidProposalSlate();\n\n        uint256 gbc = distributionPeriodFundsAvailable_;\n        uint256 totalTokensRequested = 0;\n\n        // check each proposal in the slate is valid\n        for (uint i = 0; i < numProposalsInSlate_; ) {\n            Proposal memory proposal = _standardFundingProposals[proposalIds_[i]];\n\n            // check if Proposal is in the topTenProposals list\n            if (_findProposalIndex(proposalIds_[i], _topTenProposals[distributionId_]) == -1) revert InvalidProposalSlate();\n\n            // account for fundingVotesReceived possibly being negative\n            if (proposal.fundingVotesReceived < 0) revert InvalidProposalSlate();\n\n            // update counters\n            sum_ += uint128(proposal.fundingVotesReceived); // since we are converting from int128 to uint128, we can safely assume that the value will not overflow\n            totalTokensRequested += proposal.tokensRequested;\n\n            // check if slate of proposals exceeded budget constraint ( 90% of GBC )\n            if (totalTokensRequested > (gbc * 9 / 10)) {\n                revert InvalidProposalSlate();\n            }\n\n            unchecked { ++i; }\n        }\n    }\n\n    /**\n     * @notice Check an array of proposalIds for duplicate IDs.\n     * @dev    Only iterates through a maximum of 10 proposals that made it through the screening round.\n     * @dev    Counters incremented in an unchecked block due to being bounded by array length.\n     * @param  proposalIds_ Array of proposal Ids to check.\n     * @return Boolean indicating the presence of a duplicate. True if it has a duplicate; false if not.\n     */\n    function _hasDuplicates(\n        uint256[] calldata proposalIds_\n    ) internal pure returns (bool) {\n        uint256 numProposals = proposalIds_.length;\n\n        for (uint i = 0; i < numProposals; ) {\n            for (uint j = i + 1; j < numProposals;"
    }
  ]
}