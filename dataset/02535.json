{
  "Title": "M-1: Tokens not owned by an account can be added as an asset to the account",
  "Content": "# Issue M-1: Tokens not owned by an account can be added as an asset to the account \n\nSource: https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/26 \n\n## Found by \nBahurum\n\n## Summary\nIn the controllers `RewardRouterController`, `RewardRouterV2Controller` and `DNGMXVaultController` the function `canCall` can return in `tokenIn` a token address that has actually not been received by the account. If the account did not have the token before, than the token is added to the asset list of the account even if the account does not hold the token at all.\n\n## Vulnerability Detail\n\n- in `RewardRouterController`: in `canCallCompound()`, `WETH` is added to `tokensIn` but no tokens are sent to the account as a result of the call to the Reward Router's function `compound()`\n- in `RewardRouterV2Controller`: in `canCallRedeem()` the token redeemed is added to `tokensIn`, but the router's function `unstakeAndRedeemGlp()` allows to send the tokens to a 3rd party receiver instead of the caller. In such a case, nop tokens are sent to the account.\n- in `DNGMXVaultController`: in `canWithdraw()` the token redeemed is added to `tokensIn`, but the DN GMX vault's functions `redeemToken()` and `withdrawToken()` allow to send the tokens to a 3rd party receiver instead of the caller. In such a case, nop tokens are sent to the account.\n\n## Impact\nThere can be tokens in the list of assets of an account that the account doesn't actually hold. Note that this does not pose any issues for the calculation of collateral.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-01-sentiment/blob/main/controller-55/src/gmx/RewardRouterController.sol#L67\n\nhttps://github.com/sherlock-audit/2023-01-sentiment/blob/main/controller-55/src/gmx/RewardRouterV2Controller.sol#L88\n\nhttps://github.com/sherlock-audit/2023-01-sentiment/blob/main/controller-55/src/gmx/RewardRouterV2Controller.sol#L88\n\n## Tool used\n\nManual Review\n\n## Recommendation\nNo particular reccommendation.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/37",
  "Code": [
    {
      "filename": "controller-55/src/gmx/RewardRouterController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {IController} from \"../core/IController.sol\";\n\n/**\n    @title Reward Router Controller for claiming and compounding rewards\n    @dev arbi:0xA906F338CB21815cBc4Bc87ace9e68c87eF8d8F1\n*/\ncontract RewardRouterController is IController {\n\n    /* -------------------------------------------------------------------------- */\n    /*                              STORAGE VARIABLES                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice compound()\n    bytes4 constant compound = 0xf69e2046;\n\n    /// @notice claimFees()\n    bytes4 constant claimFees = 0xd294f093;\n\n    /// @notice WETH\n    address[] WETH;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 CONSTRUCTOR                                */\n    /* -------------------------------------------------------------------------- */\n\n    constructor(address _WETH) {\n        WETH.push(_WETH);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    function canCall(address, bool, bytes calldata data)\n        external\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        bytes4 sig = bytes4(data);\n\n        if (sig == compound) return canCallCompound();\n        if (sig == claimFees) return canCallClaimFees();\n\n        return (false, new address[](0), new address[](0));\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    function canCallClaimFees()\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        return (true, WETH, new address[](0));\n    }\n\n    function canCallCompound()\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        return (true, WETH, new address[](0));\n    }\n}"
    },
    {
      "filename": "controller-55/src/gmx/RewardRouterV2Controller.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {IController} from \"../core/IController.sol\";\n\n/**\n    @title Reward Router V2 Controller for minting and redeeming GLP\n    @dev arbi:0xB95DB5B167D75e6d04227CfFFA61069348d271F5\n*/\ncontract RewardRouterV2Controller is IController {\n\n    /* -------------------------------------------------------------------------- */\n    /*                              STORAGE VARIABLES                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice mintAndStakeGlpETH(uint256 _minUsdg,uint256 _minGlp)\n    bytes4 constant mintAndStakeGlpETH = 0x53a8aa03;\n\n    /// @notice mintAndStakeGlp(address _token,uint256 _amount,uint256 _minUsdg,uint256 _minGlp)\n    bytes4 constant mintAndStakeGlp = 0x364e2311;\n\n    /// @notice unstakeAndRedeemGlp(address _tokenOut,uint256 _glpAmount,uint256 _minOut,address _receiver)\n    bytes4 constant unstakeAndRedeemGlp = 0x0f3aa554;\n\n    /// @notice unstakeAndRedeemGlpETH(uint256,uint256,address)\n    bytes4 constant unstakeAndRedeemGlpETH = 0xabb5e5e2;\n\n    /// @notice Staked GLP: 0x5402B5F40310bDED796c7D0F3FF6683f5C0cFfdf\n    address[] sGLP;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 CONSTRUCTOR                                */\n    /* -------------------------------------------------------------------------- */\n\n    constructor(address _SGLP) {\n        sGLP.push(_SGLP);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    function canCall(address, bool useEth, bytes calldata data)\n        external\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        bytes4 sig = bytes4(data);\n\n        if (sig == mintAndStakeGlp) return canCallMint(data[4:]);\n        if (sig == mintAndStakeGlpETH) return canCallMintEth(useEth);\n        if (sig == unstakeAndRedeemGlp) return canCallRedeem(data[4:]);\n        if (sig == unstakeAndRedeemGlpETH) return canCallRedeemEth();\n\n        return (false, new address[](0), new address[](0));\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    function canCallMint(bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address[] memory tokensOut = new address[](1);\n        (tokensOut[0],,,) = abi.decode(data, (address, uint256, uint256, uint256));\n\n        return (true, sGLP, tokensOut);\n    }\n\n    function canCallMintEth(bool useEth)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        if (!useEth) return (false, new address[](0), new address[](0));\n        return (true, sGLP, new address[](0));\n    }\n\n    function canCallRedeem(bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address[] memory tokensIn = new address[](1);\n        (tokensIn[0],,,) = abi.decode(data, (address, uint256, uint256, uint256));\n\n        return (true, tokensIn, sGLP);\n    }\n\n    function canCallRedeemEth()\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        return (true, new address[](0), sGLP);\n    }\n}"
    },
    {
      "filename": "controller-55/src/gmx/RewardRouterV2Controller.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {IController} from \"../core/IController.sol\";\n\n/**\n    @title Reward Router V2 Controller for minting and redeeming GLP\n    @dev arbi:0xB95DB5B167D75e6d04227CfFFA61069348d271F5\n*/\ncontract RewardRouterV2Controller is IController {\n\n    /* -------------------------------------------------------------------------- */\n    /*                              STORAGE VARIABLES                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice mintAndStakeGlpETH(uint256 _minUsdg,uint256 _minGlp)\n    bytes4 constant mintAndStakeGlpETH = 0x53a8aa03;\n\n    /// @notice mintAndStakeGlp(address _token,uint256 _amount,uint256 _minUsdg,uint256 _minGlp)\n    bytes4 constant mintAndStakeGlp = 0x364e2311;\n\n    /// @notice unstakeAndRedeemGlp(address _tokenOut,uint256 _glpAmount,uint256 _minOut,address _receiver)\n    bytes4 constant unstakeAndRedeemGlp = 0x0f3aa554;\n\n    /// @notice unstakeAndRedeemGlpETH(uint256,uint256,address)\n    bytes4 constant unstakeAndRedeemGlpETH = 0xabb5e5e2;\n\n    /// @notice Staked GLP: 0x5402B5F40310bDED796c7D0F3FF6683f5C0cFfdf\n    address[] sGLP;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 CONSTRUCTOR                                */\n    /* -------------------------------------------------------------------------- */\n\n    constructor(address _SGLP) {\n        sGLP.push(_SGLP);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    function canCall(address, bool useEth, bytes calldata data)\n        external\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        bytes4 sig = bytes4(data);\n\n        if (sig == mintAndStakeGlp) return canCallMint(data[4:]);\n        if (sig == mintAndStakeGlpETH) return canCallMintEth(useEth);\n        if (sig == unstakeAndRedeemGlp) return canCallRedeem(data[4:]);\n        if (sig == unstakeAndRedeemGlpETH) return canCallRedeemEth();\n\n        return (false, new address[](0), new address[](0));\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    function canCallMint(bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address[] memory tokensOut = new address[](1);\n        (tokensOut[0],,,) = abi.decode(data, (address, uint256, uint256, uint256));\n\n        return (true, sGLP, tokensOut);\n    }\n\n    function canCallMintEth(bool useEth)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        if (!useEth) return (false, new address[](0), new address[](0));\n        return (true, sGLP, new address[](0));\n    }\n\n    function canCallRedeem(bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address[] memory tokensIn = new address[](1);\n        (tokensIn[0],,,) = abi.decode(data, (address, uint256, uint256, uint256));\n\n        return (true, tokensIn, sGLP);\n    }\n\n    function canCallRedeemEth()\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        return (true, new address[](0), sGLP);\n    }\n}"
    }
  ]
}