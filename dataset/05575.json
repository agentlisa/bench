{
  "Title": "[M-04] Mismatch between the SAFE generated debt and the amount of the system tokens minted for the user",
  "Content": "\n<https://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/actions/BasicActions.sol#L94-L115> \n\n<https://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/actions/BasicActions.sol#L31-L47>\n\n*   When the user generates a debt against his collateral (when he locks a collateral first) in `BasicActions.generateDebt`:\n\n    *   First the user requests a debt of a value `_deltaWad`.\n\n    *   Then this requested value is modified by the `_getGeneratedDeltaDebt` function: where the requested debt by the user is updated by comparing the coin balance of the SAFE (which is minted when the user generates a debt) with the requested debt; if the requested debt exceeds the coin balance of the SAFE; the requested debt value is modified by calculating the needed `deltaDebt` that would be enough to exit wad amount of COIN tokens with the current coins balance of the SAFE.\n\n    *   Then a debt is going to be generated for the SAFE with this modified debt value (by updating the SAFE's collateralization by the `SAFEEngine`):\n\n        ```solidity\n        _modifySAFECollateralization(\n              _manager,\n              _safeId,\n              0,\n              _getGeneratedDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler, _deltaWad)\n            );\n        ```\n\n    *   Then the user (EOA) will be minted system tokens of a value equals to the original value requested by him not the updated value generated by the `_getGeneratedDeltaDebt` function, and this is done via `_exitSystemCoins` function which will in turn call the `__coinJoin.exit` function:\n\n        ```solidity\n        _exitSystemCoins(_coinJoin, _deltaWad * RAY);\n        ```\n\n*   So as can be seen; the values doesn't match; as the modified `_deltaDebt` that is used to update the `safe.generatedDebt` (via `BasicActions._modifySAFECollateralization` function) might be of a value lesser/larger (depending on the rate and coins balance of the safe) than the actual minted tokens; so when the user wants to repay the SAFE debt his minted tokens might not be enough to do so.\n\n### Proof of Concept\n\n[BasicActions.\\_generateDebt function](https://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/actions/BasicActions.sol#L94-L115)\n\n```solidity\nfunction _generateDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) internal {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    // Generates debt in the SAFE\n    _modifySAFECollateralization(\n      _manager,\n      _safeId,\n      0,\n      _getGeneratedDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler, _deltaWad) //  @audit : will not equal the input _deltaWad\n    );\n\n    // Moves the COIN amount to user's address\n    _collectAndExitCoins(_manager, _coinJoin, _safeId, _deltaWad);// @audit : _deltaWad is different from the one used to generate dabt in safeEngine\n  }\n```\n\n[BasicActions.\\_getGeneratedDeltaDebt function](https://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/actions/BasicActions.sol#L31-L47)\n\n```solidity\n  function _getGeneratedDeltaDebt(\n    address _safeEngine,\n    bytes32 _cType,\n    address _safeHandler,\n    uint256 _deltaWad\n  ) internal view returns (int256 _deltaDebt) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _coinAmount = ISAFEEngine(_safeEngine).coinBalance(_safeHandler);\n\n    // If there was already enough COIN in the safeEngine balance, just exits it without adding more debt\n    if (_coinAmount < _deltaWad * RAY) {\n      // Calculates the needed deltaDebt so together with the existing coins in the safeEngine is enough to exit wad amount of COIN tokens\n      _deltaDebt = ((_deltaWad * RAY - _coinAmount) / _rate).toInt();\n      // This is neeeded due lack of precision. It might need to sum an extra deltaDebt wei (for the given COIN wad amount)\n      _deltaDebt = uint256(_deltaDebt) * _rate < _deltaWad * RAY ? _deltaDebt + 1 : _deltaDebt;\n    }\n  }\n```\n### Recommended Mitigation Steps\n\nUpdate `_generateDebt` function to use the same modified `_deltaWad` value for generating debt and minting system tokens:\n\n```diff\nfunction _generateDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) internal {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n+   int256 _UpdatedDeltaDebt=_getGeneratedDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler, _deltaWad);\n\n    // Generates debt in the SAFE\n    _modifySAFECollateralization(\n      _manager,\n      _safeId,\n      0,\n-     _getGeneratedDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler, _deltaWad)\n+     _UpdatedDeltaDebt\n    );\n\n    // Moves the COIN amount to user's address\n-   _collectAndExitCoins(_manager, _coinJoin, _safeId, _deltaWad);\n+   _collectAndExitCoins(_manager, _coinJoin, _safeId, _UpdatedDeltaDebt);\n  }\n```\n\n**[pi0neerpat (OpenDollar) confirmed](https://github.com/code-423n4/2023-10-opendollar-findings/issues/371#issuecomment-1787839429)**\n\n**[MiloTruck (Judge) commented](https://github.com/code-423n4/2023-10-opendollar-findings/issues/371#issuecomment-1792581760):**\n > In `_generateDebt()`, `_collectAndExitCoins()` is called to transfer system coins equivalent to the requested amount of collateral instead of the actual amount used for debt. This will cause the function to revert should `_deltaWad` be higher than the amount of collateral the user has in his safe to generate debt. \n> \n> Since this is a case of the function not working as intended, I believe medium severity is appropriate.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-opendollar",
  "Code": [
    {
      "filename": "src/contracts/proxies/actions/BasicActions.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {ODSafeManager} from '@contracts/proxies/ODSafeManager.sol';\nimport {ODProxy} from '@contracts/proxies/ODProxy.sol';\n\nimport {ISAFEEngine} from '@interfaces/ISAFEEngine.sol';\nimport {ICoinJoin} from '@interfaces/utils/ICoinJoin.sol';\nimport {ITaxCollector} from '@interfaces/ITaxCollector.sol';\nimport {ICollateralJoin} from '@interfaces/utils/ICollateralJoin.sol';\nimport {IERC20Metadata} from '@openzeppelin/token/ERC20/extensions/IERC20Metadata.sol';\nimport {IBasicActions} from '@interfaces/proxies/actions/IBasicActions.sol';\n\nimport {Math, WAD, RAY, RAD} from '@libraries/Math.sol';\n\nimport {CommonActions} from '@contracts/proxies/actions/CommonActions.sol';\n\n/**\n * @title  BasicActions\n * @notice This contract defines the actions that can be executed to manage a SAFE\n */\ncontract BasicActions is CommonActions, IBasicActions {\n  using Math for uint256;\n\n  // --- Internal functions ---\n\n  /**\n   * @notice Gets delta debt generated for delta wad (always positive)\n   * @dev    Total SAFE debt minus available safeHandler COIN balance\n   */\n  function _getGeneratedDeltaDebt(\n    address _safeEngine,\n    bytes32 _cType,\n    address _safeHandler,\n    uint256 _deltaWad\n  ) internal view returns (int256 _deltaDebt) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _coinAmount = ISAFEEngine(_safeEngine).coinBalance(_safeHandler);\n\n    // If there was already enough COIN in the safeEngine balance, just exits it without adding more debt\n    if (_coinAmount < _deltaWad * RAY) {\n      // Calculates the needed deltaDebt so together with the existing coins in the safeEngine is enough to exit wad amount of COIN tokens\n      _deltaDebt = ((_deltaWad * RAY - _coinAmount) / _rate).toInt();\n      // This is neeeded due lack of precision. It might need to sum an extra deltaDebt wei (for the given COIN wad amount)\n      _deltaDebt = uint256(_deltaDebt) * _rate < _deltaWad * RAY ? _deltaDebt + 1 : _deltaDebt;\n    }\n  }\n\n  /**\n   * @notice Gets repaid delta debt generated\n   * @dev    The rate adjusted debt of the SAFE\n   */\n  function _getRepaidDeltaDebt(\n    address _safeEngine,\n    bytes32 _cType,\n    address _safeHandler\n  ) internal view returns (int256 _deltaDebt) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _generatedDebt = ISAFEEngine(_safeEngine).safes(_cType, _safeHandler).generatedDebt;\n    uint256 _coinAmount = ISAFEEngine(_safeEngine).coinBalance(_safeHandler);\n\n    // Uses the whole coin balance in the safeEngine to reduce the debt\n    _deltaDebt = (_coinAmount / _rate).toInt();\n    // Checks the calculated deltaDebt is not higher than safe.generatedDebt (total debt), otherwise uses its value\n    _deltaDebt = uint256(_deltaDebt) <= _generatedDebt ? -_deltaDebt : -_generatedDebt.toInt();\n  }\n\n  /**\n   * @notice Gets repaid debt\n   * @dev    The rate adjusted SAFE's debt minus COIN balance available in usr's address\n   */\n  function _getRepaidDebt(\n    address _safeEngine,\n    address _usr,\n    bytes32 _cType,\n    address _safeHandler\n  ) internal view returns (uint256 _deltaWad) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _generatedDebt = ISAFEEngine(_safeEngine).safes(_cType, _safeHandler).generatedDebt;\n    uint256 _coinAmount = ISAFEEngine(_safeEngine).coinBalance(_usr);\n\n    // Uses the whole coin balance in the safeEngine to reduce the debt\n    uint256 _rad = _generatedDebt * _rate - _coinAmount;\n    // Calculates the equivalent COIN amount\n    _deltaWad = _rad / RAY;\n    // If the rad precision has some dust, it will need to request for 1 extra wad wei\n    _deltaWad = _deltaWad * RAY < _rad ? _deltaWad + 1 : _deltaWad;\n  }\n\n  /**\n   * @notice Generates debt\n   * @dev    Modifies the SAFE collateralization ratio, increasing the debt and sends the COIN amount to the user's address\n   */\n  function _generateDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) internal {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    // Generates debt in the SAFE\n    _modifySAFECollateralization(\n      _manager,\n      _safeId,\n      0,\n      _getGeneratedDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler, _deltaWad)\n    );\n\n    // Moves the COIN amount to user's address\n    _collectAndExitCoins(_manager, _coinJoin, _safeId, _deltaWad);\n  }\n\n  /**\n   * @notice Repays debt\n   * @dev    Joins COIN amount into the safeEngine and modifies the SAFE collateralization reducing the debt\n   */\n  function _repayDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) internal {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    // Joins COIN amount into the safeEngine\n    _joinSystemCoins(_coinJoin, _safeInfo.safeHandler, _deltaWad);\n\n    // Paybacks debt to the SAFE\n    _modifySAFECollateralization(\n      _manager, _safeId, 0, _getRepaidDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler)\n    );\n  }\n\n  /// @notice Routes the openSAFE call to the ODSafeManager contract\n  function _openSAFE(address _manager, bytes32 _cType, address _usr) internal returns (uint256 _safeId) {\n    _safeId = ODSafeManager(_manager).openSAFE(_cType, _usr);\n  }\n\n  /// @notice Routes the transferCollateral call to the ODSafeManager contract\n  function _transferCollateral(address _manager, uint256 _safeId, address _dst, uint256 _deltaWad) internal {\n    if (_deltaWad == 0) return;\n    ODSafeManager(_manager).transferCollateral(_safeId, _dst, _deltaWad);\n  }\n\n  /// @notice Routes the transferInternalCoins call to the ODSafeManager contract\n  function _transferInternalCoins(address _manager, uint256 _safeId, address _dst, uint256 _rad) internal {\n    ODSafeManager(_manager).transferInternalCoins(_safeId, _dst, _rad);\n  }\n\n  /// @notice Routes the modifySAFECollateralization call to the ODSafeManager contract\n  function _modifySAFECollateralization(\n    address _manager,\n    uint256 _safeId,\n    int256 _deltaCollateral,\n    int256 _deltaDebt\n  ) internal {\n    ODSafeManager(_manager).modifySAFECollateralization(_safeId, _deltaCollateral, _deltaDebt);\n  }\n\n  /**\n   * @notice Joins collateral and exits an amount of COIN\n   */\n  function _lockTokenCollateralAndGenerateDebt(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _collateralAmount,\n    uint256 _deltaWad\n  ) internal {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    // Takes token amount from user's wallet and joins into the safeEngine\n    _joinCollateral(_collateralJoin, _safeInfo.safeHandler, _collateralAmount);\n\n    // Locks token amount into the SAFE and generates debt\n    _modifySAFECollateralization(\n      _manager,\n      _safeId,\n      _collateralAmount.toInt(),\n      _getGeneratedDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler, _deltaWad)\n    );\n\n    // Exits and transfers COIN amount to the user's address\n    _collectAndExitCoins(_manager, _coinJoin, _safeId, _deltaWad);\n  }\n\n  /**\n   * @notice Transfers an amount of COIN to the proxy address and exits to the user's address\n   */\n  function _collectAndExitCoins(address _manager, address _coinJoin, uint256 _safeId, uint256 _deltaWad) internal {\n    // Moves the COIN amount to proxy's address\n    _transferInternalCoins(_manager, _safeId, address(this), _deltaWad * RAY);\n    // Exits the COIN amount to the user's address\n    _exitSystemCoins(_coinJoin, _deltaWad * RAY);\n  }\n\n  /**\n   * @notice Transfers an amount of collateral to the proxy address and exits collateral tokens to the user\n   */\n  function _collectAndExitCollateral(\n    address _manager,\n    address _collateralJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) internal {\n    // Moves the amount from the SAFE handler to proxy's address\n    _transferCollateral(_manager, _safeId, address(this), _deltaWad);\n    // Exits a rounded down amount of collateral\n    _exitCollateral(_collateralJoin, _deltaWad);\n  }\n\n  // --- Methods ---\n\n  /// @inheritdoc IBasicActions\n  function openSAFE(address _manager, bytes32 _cType, address _usr) external delegateCall returns (uint256 _safeId) {\n    return _openSAFE(_manager, _cType, _usr);\n  }\n\n  /// @inheritdoc IBasicActions\n  function generateDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) external delegateCall {\n    _generateDebt(_manager, _taxCollector, _coinJoin, _safeId, _deltaWad);\n  }\n\n  /// @inheritdoc IBasicActions\n  function repayDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) external delegateCall {\n    _repayDebt(_manager, _taxCollector, _coinJoin, _safeId, _deltaWad);\n  }\n\n  /// @inheritdoc IBasicActions\n  function lockTokenCollateral(\n    address _manager,\n    address _collateralJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) external delegateCall {\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n\n    // Takes token amount from user's wallet and joins into the safeEngine\n    _joinCollateral(_collateralJoin, _safeInfo.safeHandler, _deltaWad);\n\n    // Locks token amount in the safe\n    _modifySAFECollateralization(_manager, _safeId, _deltaWad.toInt(), 0);\n  }\n\n  /// @inheritdoc IBasicActions\n  function freeTokenCollateral(\n    address _manager,\n    address _collateralJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) external delegateCall {\n    // Unlocks token amount from the SAFE\n    _modifySAFECollateralization(_manager, _safeId, -_deltaWad.toInt(), 0);\n    // Transfers token amount to the user's address\n    _collectAndExitCollateral(_manager, _collateralJoin, _safeId, _deltaWad);\n  }\n\n  /// @inheritdoc IBasicActions\n  function repayAllDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId\n  ) external delegateCall {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    ISAFEEngine.SAFE memory _safeData = ISAFEEngine(_safeEngine).safes(_safeInfo.collateralType, _safeInfo.safeHandler);\n\n    // Joins COIN amount into the safeEngine\n    _joinSystemCoins(\n      _coinJoin,\n      address(this),\n      _getRepaidDebt(_safeEngine, address(this), _safeInfo.collateralType, _safeInfo.safeHandler)\n    );\n\n    // Paybacks debt to the SAFE (allowed because reducing debt of the SAFE)\n    ISAFEEngine(_safeEngine).modifySAFECollateralization({\n      _cType: _safeInfo.collateralType,\n      _safe: _safeInfo.safeHandler,\n      _collateralSource: address(this),\n      _debtDestination: address(this),\n      _deltaCollateral: 0,\n      _deltaDebt: -int256(_safeData.generatedDebt)\n    });\n  }\n\n  /// @inheritdoc IBasicActions\n  function lockTokenCollateralAndGenerateDebt(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    uint256 _safe,\n    uint256 _collateralAmount,\n    uint256 _deltaWad\n  ) external delegateCall {\n    _lockTokenCollateralAndGenerateDebt(\n      _manager, _taxCollector, _collateralJoin, _coinJoin, _safe, _collateralAmount, _deltaWad\n    );\n  }\n\n  /// @inheritdoc IBasicActions\n  function openLockTokenCollateralAndGenerateDebt(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    bytes32 _cType,\n    uint256 _collateralAmount,\n    uint256 _deltaWad\n  ) external delegateCall returns (uint256 _safe) {\n    _safe = _openSAFE(_manager, _cType, address(this));\n\n    _lockTokenCollateralAndGenerateDebt(\n      _manager, _taxCollector, _collateralJoin, _coinJoin, _safe, _collateralAmount, _deltaWad\n    );\n  }\n\n  /// @inheritdoc IBasicActions\n  function repayDebtAndFreeTokenCollateral(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _collateralWad,\n    uint256 _debtWad\n  ) external delegateCall {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    // Joins COIN amount into the safeEngine\n    _joinSystemCoins(_coinJoin, _safeInfo.safeHandler, _debtWad);\n\n    // Paybacks debt to the SAFE and unlocks token amount from it\n    _modifySAFECollateralization(\n      _manager,\n      _safeId,\n      -_collateralWad.toInt(),\n      _getRepaidDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler)\n    );\n\n    // Transfers token amount to the user's address\n    _collectAndExitCollateral(_manager, _collateralJoin, _safeId, _collateralWad);\n  }\n\n  /// @inheritdoc IBasicActions\n  function repayAllDebtAndFreeTokenCollateral(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _collateralWad\n  ) external delegateCall {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    ISAFEEngine.SAFE memory _safeData = ISAFEEngine(_safeEngine).safes(_safeInfo.collateralType, _safeInfo.safeHandler);\n\n    // Joins COIN amount into the safeEngine\n    _joinSystemCoins(\n      _coinJoin,\n      _safeInfo.safeHandler,\n      _getRepaidDebt(_safeEngine, _safeInfo.safeHandler, _safeInfo.collateralType, _safeInfo.safeHandler)\n    );\n\n    // Paybacks debt to the SAFE and unlocks token amount from it\n    _modifySAFECollateralization(_manager, _safeId, -_collateralWad.toInt(), -_safeData.generatedDebt.toInt());\n\n    // Transfers token amount to the user's address\n    _collectAndExitCollateral(_manager, _collateralJoin, _safeId, _collateralWad);\n  }\n}"
    },
    {
      "filename": "src/contracts/proxies/actions/BasicActions.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {ODSafeManager} from '@contracts/proxies/ODSafeManager.sol';\nimport {ODProxy} from '@contracts/proxies/ODProxy.sol';\n\nimport {ISAFEEngine} from '@interfaces/ISAFEEngine.sol';\nimport {ICoinJoin} from '@interfaces/utils/ICoinJoin.sol';\nimport {ITaxCollector} from '@interfaces/ITaxCollector.sol';\nimport {ICollateralJoin} from '@interfaces/utils/ICollateralJoin.sol';\nimport {IERC20Metadata} from '@openzeppelin/token/ERC20/extensions/IERC20Metadata.sol';\nimport {IBasicActions} from '@interfaces/proxies/actions/IBasicActions.sol';\n\nimport {Math, WAD, RAY, RAD} from '@libraries/Math.sol';\n\nimport {CommonActions} from '@contracts/proxies/actions/CommonActions.sol';\n\n/**\n * @title  BasicActions\n * @notice This contract defines the actions that can be executed to manage a SAFE\n */\ncontract BasicActions is CommonActions, IBasicActions {\n  using Math for uint256;\n\n  // --- Internal functions ---\n\n  /**\n   * @notice Gets delta debt generated for delta wad (always positive)\n   * @dev    Total SAFE debt minus available safeHandler COIN balance\n   */\n  function _getGeneratedDeltaDebt(\n    address _safeEngine,\n    bytes32 _cType,\n    address _safeHandler,\n    uint256 _deltaWad\n  ) internal view returns (int256 _deltaDebt) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _coinAmount = ISAFEEngine(_safeEngine).coinBalance(_safeHandler);\n\n    // If there was already enough COIN in the safeEngine balance, just exits it without adding more debt\n    if (_coinAmount < _deltaWad * RAY) {\n      // Calculates the needed deltaDebt so together with the existing coins in the safeEngine is enough to exit wad amount of COIN tokens\n      _deltaDebt = ((_deltaWad * RAY - _coinAmount) / _rate).toInt();\n      // This is neeeded due lack of precision. It might need to sum an extra deltaDebt wei (for the given COIN wad amount)\n      _deltaDebt = uint256(_deltaDebt) * _rate < _deltaWad * RAY ? _deltaDebt + 1 : _deltaDebt;\n    }\n  }\n\n  /**\n   * @notice Gets repaid delta debt generated\n   * @dev    The rate adjusted debt of the SAFE\n   */\n  function _getRepaidDeltaDebt(\n    address _safeEngine,\n    bytes32 _cType,\n    address _safeHandler\n  ) internal view returns (int256 _deltaDebt) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _generatedDebt = ISAFEEngine(_safeEngine).safes(_cType, _safeHandler).generatedDebt;\n    uint256 _coinAmount = ISAFEEngine(_safeEngine).coinBalance(_safeHandler);\n\n    // Uses the whole coin balance in the safeEngine to reduce the debt\n    _deltaDebt = (_coinAmount / _rate).toInt();\n    // Checks the calculated deltaDebt is not higher than safe.generatedDebt (total debt), otherwise uses its value\n    _deltaDebt = uint256(_deltaDebt) <= _generatedDebt ? -_deltaDebt : -_generatedDebt.toInt();\n  }\n\n  /**\n   * @notice Gets repaid debt\n   * @dev    The rate adjusted SAFE's debt minus COIN balance available in usr's address\n   */\n  function _getRepaidDebt(\n    address _safeEngine,\n    address _usr,\n    bytes32 _cType,\n    address _safeHandler\n  ) internal view returns (uint256 _deltaWad) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _generatedDebt = ISAFEEngine(_safeEngine).safes(_cType, _safeHandler).generatedDebt;\n    uint256 _coinAmount = ISAFEEngine(_safeEngine).coinBalance(_usr);\n\n    // Uses the whole coin balance in the safeEngine to reduce the debt\n    uint256 _rad = _generatedDebt * _rate - _coinAmount;\n    // Calculates the equivalent COIN amount\n    _deltaWad = _rad / RAY;\n    // If the rad precision has some dust, it will need to request for 1 extra wad wei\n    _deltaWad = _deltaWad * RAY < _rad ? _deltaWad + 1 : _deltaWad;\n  }\n\n  /**\n   * @notice Generates debt\n   * @dev    Modifies the SAFE collateralization ratio, increasing the debt and sends the COIN amount to the user's address\n   */\n  function _generateDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) internal {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    // Generates debt in the SAFE\n    _modifySAFECollateralization(\n      _manager,\n      _safeId,\n      0,\n      _getGeneratedDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler, _deltaWad)\n    );\n\n    // Moves the COIN amount to user's address\n    _collectAndExitCoins(_manager, _coinJoin, _safeId, _deltaWad);\n  }\n\n  /**\n   * @notice Repays debt\n   * @dev    Joins COIN amount into the safeEngine and modifies the SAFE collateralization reducing the debt\n   */\n  function _repayDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) internal {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    // Joins COIN amount into the safeEngine\n    _joinSystemCoins(_coinJoin, _safeInfo.safeHandler, _deltaWad);\n\n    // Paybacks debt to the SAFE\n    _modifySAFECollateralization(\n      _manager, _safeId, 0, _getRepaidDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler)\n    );\n  }\n\n  /// @notice Routes the openSAFE call to the ODSafeManager contract\n  function _openSAFE(address _manager, bytes32 _cType, address _usr) internal returns (uint256 _safeId) {\n    _safeId = ODSafeManager(_manager).openSAFE(_cType, _usr);\n  }\n\n  /// @notice Routes the transferCollateral call to the ODSafeManager contract\n  function _transferCollateral(address _manager, uint256 _safeId, address _dst, uint256 _deltaWad) internal {\n    if (_deltaWad == 0) return;\n    ODSafeManager(_manager).transferCollateral(_safeId, _dst, _deltaWad);\n  }\n\n  /// @notice Routes the transferInternalCoins call to the ODSafeManager contract\n  function _transferInternalCoins(address _manager, uint256 _safeId, address _dst, uint256 _rad) internal {\n    ODSafeManager(_manager).transferInternalCoins(_safeId, _dst, _rad);\n  }\n\n  /// @notice Routes the modifySAFECollateralization call to the ODSafeManager contract\n  function _modifySAFECollateralization(\n    address _manager,\n    uint256 _safeId,\n    int256 _deltaCollateral,\n    int256 _deltaDebt\n  ) internal {\n    ODSafeManager(_manager).modifySAFECollateralization(_safeId, _deltaCollateral, _deltaDebt);\n  }\n\n  /**\n   * @notice Joins collateral and exits an amount of COIN\n   */\n  function _lockTokenCollateralAndGenerateDebt(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _collateralAmount,\n    uint256 _deltaWad\n  ) internal {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    // Takes token amount from user's wallet and joins into the safeEngine\n    _joinCollateral(_collateralJoin, _safeInfo.safeHandler, _collateralAmount);\n\n    // Locks token amount into the SAFE and generates debt\n    _modifySAFECollateralization(\n      _manager,\n      _safeId,\n      _collateralAmount.toInt(),\n      _getGeneratedDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler, _deltaWad)\n    );\n\n    // Exits and transfers COIN amount to the user's address\n    _collectAndExitCoins(_manager, _coinJoin, _safeId, _deltaWad);\n  }\n\n  /**\n   * @notice Transfers an amount of COIN to the proxy address and exits to the user's address\n   */\n  function _collectAndExitCoins(address _manager, address _coinJoin, uint256 _safeId, uint256 _deltaWad) internal {\n    // Moves the COIN amount to proxy's address\n    _transferInternalCoins(_manager, _safeId, address(this), _deltaWad * RAY);\n    // Exits the COIN amount to the user's address\n    _exitSystemCoins(_coinJoin, _deltaWad * RAY);\n  }\n\n  /**\n   * @notice Transfers an amount of collateral to the proxy address and exits collateral tokens to the user\n   */\n  function _collectAndExitCollateral(\n    address _manager,\n    address _collateralJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) internal {\n    // Moves the amount from the SAFE handler to proxy's address\n    _transferCollateral(_manager, _safeId, address(this), _deltaWad);\n    // Exits a rounded down amount of collateral\n    _exitCollateral(_collateralJoin, _deltaWad);\n  }\n\n  // --- Methods ---\n\n  /// @inheritdoc IBasicActions\n  function openSAFE(address _manager, bytes32 _cType, address _usr) external delegateCall returns (uint256 _safeId) {\n    return _openSAFE(_manager, _cType, _usr);\n  }\n\n  /// @inheritdoc IBasicActions\n  function generateDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) external delegateCall {\n    _generateDebt(_manager, _taxCollector, _coinJoin, _safeId, _deltaWad);\n  }\n\n  /// @inheritdoc IBasicActions\n  function repayDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) external delegateCall {\n    _repayDebt(_manager, _taxCollector, _coinJoin, _safeId, _deltaWad);\n  }\n\n  /// @inheritdoc IBasicActions\n  function lockTokenCollateral(\n    address _manager,\n    address _collateralJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) external delegateCall {\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n\n    // Takes token amount from user's wallet and joins into the safeEngine\n    _joinCollateral(_collateralJoin, _safeInfo.safeHandler, _deltaWad);\n\n    // Locks token amount in the safe\n    _modifySAFECollateralization(_manager, _safeId, _deltaWad.toInt(), 0);\n  }\n\n  /// @inheritdoc IBasicActions\n  function freeTokenCollateral(\n    address _manager,\n    address _collateralJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) external delegateCall {\n    // Unlocks token amount from the SAFE\n    _modifySAFECollateralization(_manager, _safeId, -_deltaWad.toInt(), 0);\n    // Transfers token amount to the user's address\n    _collectAndExitCollateral(_manager, _collateralJoin, _safeId, _deltaWad);\n  }\n\n  /// @inheritdoc IBasicActions\n  function repayAllDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId\n  ) external delegateCall {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    ISAFEEngine.SAFE memory _safeData = ISAFEEngine(_safeEngine).safes(_safeInfo.collateralType, _safeInfo.safeHandler);\n\n    // Joins COIN amount into the safeEngine\n    _joinSystemCoins(\n      _coinJoin,\n      address(this),\n      _getRepaidDebt(_safeEngine, address(this), _safeInfo.collateralType, _safeInfo.safeHandler)\n    );\n\n    // Paybacks debt to the SAFE (allowed because reducing debt of the SAFE)\n    ISAFEEngine(_safeEngine).modifySAFECollateralization({\n      _cType: _safeInfo.collateralType,\n      _safe: _safeInfo.safeHandler,\n      _collateralSource: address(this),\n      _debtDestination: address(this),\n      _deltaCollateral: 0,\n      _deltaDebt: -int256(_safeData.generatedDebt)\n    });\n  }\n\n  /// @inheritdoc IBasicActions\n  function lockTokenCollateralAndGenerateDebt(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    uint256 _safe,\n    uint256 _collateralAmount,\n    uint256 _deltaWad\n  ) external delegateCall {\n    _lockTokenCollateralAndGenerateDebt(\n      _manager, _taxCollector, _collateralJoin, _coinJoin, _safe, _collateralAmount, _deltaWad\n    );\n  }\n\n  /// @inheritdoc IBasicActions\n  function openLockTokenCollateralAndGenerateDebt(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    bytes32 _cType,\n    uint256 _collateralAmount,\n    uint256 _deltaWad\n  ) external delegateCall returns (uint256 _safe) {\n    _safe = _openSAFE(_manager, _cType, address(this));\n\n    _lockTokenCollateralAndGenerateDebt(\n      _manager, _taxCollector, _collateralJoin, _coinJoin, _safe, _collateralAmount, _deltaWad\n    );\n  }\n\n  /// @inheritdoc IBasicActions\n  function repayDebtAndFreeTokenCollateral(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _collateralWad,\n    uint256 _debtWad\n  ) external delegateCall {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    // Joins COIN amount into the safeEngine\n    _joinSystemCoins(_coinJoin, _safeInfo.safeHandler, _debtWad);\n\n    // Paybacks debt to the SAFE and unlocks token amount from it\n    _modifySAFECollateralization(\n      _manager,\n      _safeId,\n      -_collateralWad.toInt(),\n      _getRepaidDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler)\n    );\n\n    // Transfers token amount to the user's address\n    _collectAndExitCollateral(_manager, _collateralJoin, _safeId, _collateralWad);\n  }\n\n  /// @inheritdoc IBasicActions\n  function repayAllDebtAndFreeTokenCollateral(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _collateralWad\n  ) external delegateCall {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    ISAFEEngine.SAFE memory _safeData = ISAFEEngine(_safeEngine).safes(_safeInfo.collateralType, _safeInfo.safeHandler);\n\n    // Joins COIN amount into the safeEngine\n    _joinSystemCoins(\n      _coinJoin,\n      _safeInfo.safeHandler,\n      _getRepaidDebt(_safeEngine, _safeInfo.safeHandler, _safeInfo.collateralType, _safeInfo.safeHandler)\n    );\n\n    // Paybacks debt to the SAFE and unlocks token amount from it\n    _modifySAFECollateralization(_manager, _safeId, -_collateralWad.toInt(), -_safeData.generatedDebt.toInt());\n\n    // Transfers token amount to the user's address\n    _collectAndExitCollateral(_manager, _collateralJoin, _safeId, _collateralWad);\n  }\n}"
    },
    {
      "filename": "src/contracts/proxies/actions/BasicActions.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {ODSafeManager} from '@contracts/proxies/ODSafeManager.sol';\nimport {ODProxy} from '@contracts/proxies/ODProxy.sol';\n\nimport {ISAFEEngine} from '@interfaces/ISAFEEngine.sol';\nimport {ICoinJoin} from '@interfaces/utils/ICoinJoin.sol';\nimport {ITaxCollector} from '@interfaces/ITaxCollector.sol';\nimport {ICollateralJoin} from '@interfaces/utils/ICollateralJoin.sol';\nimport {IERC20Metadata} from '@openzeppelin/token/ERC20/extensions/IERC20Metadata.sol';\nimport {IBasicActions} from '@interfaces/proxies/actions/IBasicActions.sol';\n\nimport {Math, WAD, RAY, RAD} from '@libraries/Math.sol';\n\nimport {CommonActions} from '@contracts/proxies/actions/CommonActions.sol';\n\n/**\n * @title  BasicActions\n * @notice This contract defines the actions that can be executed to manage a SAFE\n */\ncontract BasicActions is CommonActions, IBasicActions {\n  using Math for uint256;\n\n  // --- Internal functions ---\n\n  /**\n   * @notice Gets delta debt generated for delta wad (always positive)\n   * @dev    Total SAFE debt minus available safeHandler COIN balance\n   */\n  function _getGeneratedDeltaDebt(\n    address _safeEngine,\n    bytes32 _cType,\n    address _safeHandler,\n    uint256 _deltaWad\n  ) internal view returns (int256 _deltaDebt) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _coinAmount = ISAFEEngine(_safeEngine).coinBalance(_safeHandler);\n\n    // If there was already enough COIN in the safeEngine balance, just exits it without adding more debt\n    if (_coinAmount < _deltaWad * RAY) {\n      // Calculates the needed deltaDebt so together with the existing coins in the safeEngine is enough to exit wad amount of COIN tokens\n      _deltaDebt = ((_deltaWad * RAY - _coinAmount) / _rate).toInt();\n      // This is neeeded due lack of precision. It might need to sum an extra deltaDebt wei (for the given COIN wad amount)\n      _deltaDebt = uint256(_deltaDebt) * _rate < _deltaWad * RAY ? _deltaDebt + 1 : _deltaDebt;\n    }\n  }\n\n  /**\n   * @notice Gets repaid delta debt generated\n   * @dev    The rate adjusted debt of the SAFE\n   */\n  function _getRepaidDeltaDebt(\n    address _safeEngine,\n    bytes32 _cType,\n    address _safeHandler\n  ) internal view returns (int256 _deltaDebt) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _generatedDebt = ISAFEEngine(_safeEngine).safes(_cType, _safeHandler).generatedDebt;\n    uint256 _coinAmount = ISAFEEngine(_safeEngine).coinBalance(_safeHandler);\n\n    // Uses the whole coin balance in the safeEngine to reduce the debt\n    _deltaDebt = (_coinAmount / _rate).toInt();\n    // Checks the calculated deltaDebt is not higher than safe.generatedDebt (total debt), otherwise uses its value\n    _deltaDebt = uint256(_deltaDebt) <= _generatedDebt ? -_deltaDebt : -_generatedDebt.toInt();\n  }\n\n  /**\n   * @notice Gets repaid debt\n   * @dev    The rate adjusted SAFE's debt minus COIN balance available in usr's address\n   */\n  function _getRepaidDebt(\n    address _safeEngine,\n    address _usr,\n    bytes32 _cType,\n    address _safeHandler\n  ) internal view returns (uint256 _deltaWad) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _generatedDebt = ISAF"
    }
  ]
}