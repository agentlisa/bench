{
  "Title": "M-8: Insufficient oracle validation",
  "Content": "# Issue M-8: Insufficient oracle validation \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/174 \n\n## Found by \nBreeje, IllIllI, PRAISE, ShadowForce, rvierdiiev\n\n## Summary\n\nMost prices are provided by an off-chain oracle archive via signed prices, but a Chainlink oracle is still used for index prices. These prices are insufficiently validated.\n\n\n## Vulnerability Detail\n\nThere is no freshness check on the timestamp of the prices, so old prices may be used if [OCR](https://docs.chain.link/architecture-overview/off-chain-reporting) was unable to push an update in time\n\n\n## Impact\n\nOld prices mean traders will get wrong PnL values for their positions, leading to liquidations or getting more/less than they should, at the expense of other traders and the liquidity pools.\n\n\n## Code Snippet\n\nThe timestamp field is ignored, which means there's no way to check whether the price is recent enough:\n```solidity\n// File: gmx-synthetics/contracts/oracle/Oracle.sol : Oracle._setPricesFromPriceFeeds()   #1\n\n571                (\n572                    /* uint80 roundID */,\n573                    int256 _price,\n574                    /* uint256 startedAt */,\n575 @>                 /* uint256 timestamp */,\n576                    /* uint80 answeredInRound */\n577:                ) = priceFeed.latestRoundData();\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/oracle/Oracle.sol#L567-L587\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nAdd a staleness threshold number of seconds configuration parameter, and ensure that the price fetched is within that time range\n\n\n\n\n## Discussion\n\n**xvi10**\n\nFix in https://github.com/gmx-io/gmx-synthetics/pull/113\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/oracle/Oracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"../role/RoleModule.sol\";\n\nimport \"./OracleStore.sol\";\nimport \"./OracleUtils.sol\";\nimport \"./IPriceFeed.sol\";\nimport \"../price/Price.sol\";\n\nimport \"../chain/Chain.sol\";\nimport \"../data/DataStore.sol\";\nimport \"../data/Keys.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../event/EventUtils.sol\";\n\nimport \"../utils/Bits.sol\";\nimport \"../utils/Array.sol\";\nimport \"../utils/Precision.sol\";\nimport \"../utils/Cast.sol\";\n\n// @title Oracle\n// @dev Contract to validate and store signed values\ncontract Oracle is RoleModule {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableValues for EnumerableSet.AddressSet;\n    using Price for Price.Props;\n\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    // @dev SetPricesCache struct used in setPrices to avoid stack too deep errors\n    // @param prevMinOracleBlockNumber the previous oracle block number of the loop\n    // @param priceIndex the current price index to retrieve from compactedMinPrices and compactedMaxPrices\n    // to construct the minPrices and maxPrices array\n    // @param signatureIndex the current signature index to retrieve from the signatures array\n    // @param maxPriceAge the max allowed age of price values\n    // @param minPriceIndex the index of the min price in minPrices for the current signer\n    // @param maxPriceIndex the index of the max price in maxPrices for the current signer\n    // @param minPrices the min prices\n    // @param maxPrices the max prices\n    struct SetPricesCache {\n        OracleUtils.ReportInfo info;\n        uint256 minBlockConfirmations;\n        uint256 maxPriceAge;\n        uint256 prevMinOracleBlockNumber;\n        uint256 priceIndex;\n        uint256 signatureIndex;\n        uint256 minPriceIndex;\n        uint256 maxPriceIndex;\n        uint256[] minPrices;\n        uint256[] maxPrices;\n    }\n\n    bytes32 public immutable SALT;\n\n    uint256 public constant SIGNER_INDEX_LENGTH = 16;\n    // subtract 1 as the first slot is used to store number of signers\n    uint256 public constant MAX_SIGNERS = 256 / SIGNER_INDEX_LENGTH - 1;\n    // signer indexes are recorded in a signerIndexFlags uint256 value to check for uniqueness\n    uint256 public constant MAX_SIGNER_INDEX = 256;\n\n    OracleStore public oracleStore;\n\n    // tokensWithPrices stores the tokens with prices that have been set\n    // this is used in clearAllPrices to help ensure that all token prices\n    // set in setPrices are cleared after use\n    EnumerableSet.AddressSet internal tokensWithPrices;\n    // prices for the same token can be sent multiple times in one txn\n    // the prices can be for different block numbers\n    // the first occurrence of the token's price will be stored in primaryPrices\n    // the second occurrence will be stored in secondaryPrices\n    mapping(address => Price.Props) public primaryPrices;\n    mapping(address => Price.Props) public secondaryPrices;\n    // customPrices can be used to store custom price values\n    // these prices will be cleared in clearAllPrices\n    mapping(address => Price.Props) public customPrices;\n\n    error EmptyTokens();\n    error InvalidBlockNumber(uint256 blockNumber);\n    error InvalidMinMaxBlockNumber(uint256 minOracleBlockNumber, uint256 maxOracleBlockNumber);\n    error MaxPriceAgeExceeded(uint256 oracleTimestamp);\n    error MinOracleSigners(uint256 oracleSigners, uint256 minOracleSigners);\n    error MaxOracleSigners(uint256 oracleSigners, uint256 maxOracleSigners);\n    error BlockNumbersNotSorted(uint256 minOracleBlockNumber, uint256 prevMinOracleBlockNumber);\n    error MinPricesNotSorted(address token, uint256 price, uint256 prevPrice);\n    error MaxPricesNotSorted(address token, uint256 price, uint256 prevPrice);\n    error EmptyPriceFeedMultiplier(address token);\n    error EmptyFeedPrice(address token);\n    error MaxSignerIndex(uint256 signerIndex, uint256 maxSignerIndex);\n    error DuplicateSigner(uint256 signerIndex);\n    error InvalidOraclePrice(address token);\n    error InvalidSignerMinMaxPrice(uint256 minPrice, uint256 maxPrice);\n    error InvalidMedianMinMaxPrice(uint256 minPrice, uint256 maxPrice);\n    error NonEmptyTokensWithPrices(uint256 tokensWithPricesLength);\n    error EmptyPriceFeed(address token);\n    error PriceAlreadySet(address token, uint256 minPrice, uint256 maxPrice);\n\n    constructor(\n        RoleStore _roleStore,\n        OracleStore _oracleStore\n    ) RoleModule(_roleStore) {\n        oracleStore = _oracleStore;\n\n        // sign prices with only the chainid and oracle name so that there is\n        // less config required in the oracle nodes\n        SALT = keccak256(abi.encode(block.chainid, \"xget-oracle-v1\"));\n    }\n\n    // @dev validate and store signed prices\n    //\n    // The setPrices function is used to set the prices of tokens in the Oracle contract.\n    // It accepts an array of tokens and a signerInfo parameter. The signerInfo parameter\n    // contains information about the signers that have signed the transaction to set the prices.\n    // The first 16 bits of the signerInfo parameter contain the number of signers, and the following\n    // bits contain the index of each signer in the oracleStore. The function checks that the number\n    // of signers is greater than or equal to the minimum number of signers required, and that\n    // the signer indices are unique and within the maximum signer index. The function then calls\n    // _setPrices and _setPricesFromPriceFeeds to set the prices of the tokens.\n    //\n    // Oracle prices are signed as a value together with a precision, this allows\n    // prices to be compacted as uint32 values.\n    //\n    // The signed prices represent the price of one unit of the token using a value\n    // with 30 decimals of precision.\n    //\n    // Representing the prices in this way allows for conversions between token amounts\n    // and fiat values to be simplified, e.g. to calculate the fiat value of a given\n    // number of tokens the calculation would just be: `token amount * oracle price`,\n    // to calculate the token amount for a fiat value it would be: `fiat value / oracle price`.\n    //\n    // The trade-off of this simplicity in calculation is that tokens with a small USD\n    // price and a lot of decimals may have precision issues it is also possible that\n    // a token's price changes significantly and results in requiring higher precision.\n    //\n    // ## Example 1\n    //\n    // The price of ETH is 5000, and ETH has 18 decimals.\n    //\n    // The price of one unit of ETH is `5000 / (10 ^ 18), 5 * (10 ^ -15)`.\n    //\n    // To handle the decimals, multiply the value by `(10 ^ 30)`.\n    //\n    // Price would be stored as `5000 / (10 ^ 18) * (10 ^ 30) => 5000 * (10 ^ 12)`.\n    //\n    // For gas optimization, these prices are sent to the oracle in the form of a uint8\n    // decimal multiplier value and uint32 price value.\n    //\n    // If the decimal multiplier value is set to 8, the uint32 value would be `5000 * (10 ^ 12) / (10 ^ 8) => 5000 * (10 ^ 4)`.\n    //\n    // With this config, ETH prices can have a maximum value of `(2 ^ 32) / (10 ^ 4) => 4,294,967,296 / (10 ^ 4) => 429,496.7296` with 4 decimals of precision.\n    //\n    // ## Example 2\n    //\n    // The price of BTC is 60,000, and BTC has 8 decimals.\n    //\n    // The price of one unit of BTC is `60,000 / (10 ^ 8), 6 * (10 ^ -4)`.\n    //\n    // Price would be stored as `60,000 / (10 ^ 8) * (10 ^ 30) => 6 * (10 ^ 26) => 60,000 * (10 ^ 22)`.\n    //\n    // BTC prices maximum value: `(2 ^ 64) / (10 ^ 2) => 4,294,967,296 / (10 ^ 2) => 42,949,672.96`.\n    //\n    // Decimals of precision: 2.\n    //\n    // ## Example 3\n    //\n    // The price of USDC is 1, and USDC has 6 decimals.\n    //\n    // The price of one unit of USDC is `1 / (10 ^ 6), 1 * (10 ^ -6)`.\n    //\n    // Price would be stored as `1 / (10 ^ 6) * (10 ^ 30) => 1 * (10 ^ 24)`.\n    //\n    // USDC prices maximum value: `(2 ^ 64) / (10 ^ 6) => 4,294,967,296 / (10 ^ 6) => 4294.967296`.\n    //\n    // Decimals of precision: 6.\n    //\n    // ## Example 4\n    //\n    // The price of DG is 0.00000001, and DG has 18 decimals.\n    //\n    // The price of one unit of DG is `0.00000001 / (10 ^ 18), 1 * (10 ^ -26)`.\n    //\n    // Price would be stored as `1 * (10 ^ -26) * (10 ^ 30) => 1 * (10 ^ 3)`.\n    //\n    // DG prices maximum value: `(2 ^ 64) / (10 ^ 11) => 4,294,967,296 / (10 ^ 11) => 0.04294967296`.\n    //\n    // Decimals of precision: 11.\n    //\n    // ## Decimal Multiplier\n    //\n    // The formula to calculate what the decimal multiplier value should be set to:\n    //\n    // Decimals: 30 - (token decimals) - (number of decimals desired for precision)\n    //\n    // - ETH: 30 - 18 - 4 => 8\n    // - BTC: 30 - 8 - 2 => 20\n    // - USDC: 30 - 6 - 6 => 18\n    // - DG: 30 - 18 - 11 => 1\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param params OracleUtils.SetPricesParams\n    function setPrices(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        OracleUtils.SetPricesParams memory params\n    ) external onlyController {\n        if (tokensWithPrices.length() != 0) {\n            revert NonEmptyTokensWithPrices(tokensWithPrices.length());\n        }\n\n        if (params.tokens.length == 0) { revert EmptyTokens(); }\n\n        // first 16 bits of signer info contains the number of signers\n        address[] memory signers = new address[](params.signerInfo & Bits.BITMASK_16);\n\n        if (signers.length < dataStore.getUint(Keys.MIN_ORACLE_SIGNERS)) {\n            revert MinOracleSigners(signers.length, dataStore.getUint(Keys.MIN_ORACLE_SIGNERS));\n        }\n\n        if (signers.length > MAX_SIGNERS) {\n            revert MaxOracleSigners(signers.length, MAX_SIGNERS);\n        }\n\n        uint256 signerIndexFlags;\n\n        for (uint256 i = 0; i < signers.length; i++) {\n            uint256 signerIndex = params.signerInfo >> (16 + 16 * i) & Bits.BITMASK_16;\n\n            if (signerIndex >= MAX_SIGNER_INDEX) {\n                revert MaxSignerIndex(signerIndex, MAX_SIGNER_INDEX);\n            }\n\n            uint256 signerIndexBit = 1 << signerIndex;\n\n            if (signerIndexFlags & signerIndexBit != 0) {\n                revert DuplicateSigner(signerIndex);\n            }\n\n            signerIndexFlags = signerIndexFlags | signerIndexBit;\n\n            signers[i] = oracleStore.getSigner(signerIndex);\n        }\n\n        _setPrices(\n            dataStore,\n            eventEmitter,\n            signers,\n            params\n        );\n\n        _setPricesFromPriceFeeds(dataStore, eventEmitter, params.priceFeedTokens);\n    }\n\n    // @dev set the primary price\n    // @param token the token to set the price for\n    // @param price the price value to set to\n    function setPrimaryPrice(address token, Price.Props memory price) external onlyController {\n        primaryPrices[token] = price;\n    }\n\n    // @dev set the secondary price\n    // @param token the token to set the price for\n    // @param price the price value to set to\n    function setSecondaryPrice(address token, Price.Props memory price) external onlyController {\n        secondaryPrices[token] = price;\n    }\n\n    // @dev set a custom price\n    // @param token the token to set the price for\n    // @param price the price value to set to\n    function setCustomPrice(address token, Price.Props memory price) external onlyController {\n        customPrices[token] = price;\n    }\n\n    // @dev clear all prices\n    function clearAllPrices() external onlyController {\n        uint256 length = tokensWithPrices.length();\n        for (uint256 i = 0; i < length; i++) {\n            address token = tokensWithPrices.at(0);\n            delete primaryPrices[token];\n            delete secondaryPrices[token];\n            delete customPrices[token];\n            tokensWithPrices.remove(token);\n        }\n    }\n\n    // @dev get the length of tokensWithPrices\n    // @return the length of tokensWithPrices\n    function getTokensWithPricesCount() external view returns (uint256) {\n        return tokensWithPrices.length();\n    }\n\n    // @dev get the tokens of tokensWithPrices for the specified indexes\n    // @param start the start index, the value for this index will be included\n    // @param end the end index, the value for this index will not be included\n    // @return the tokens of tokensWithPrices for the specified indexes\n    function getTokensWithPrices(uint256 start, uint256 end) external view returns (address[] memory) {\n        return tokensWithPrices.valuesAt(start, end);\n    }\n\n    // @dev get the primary price of a token\n    // @param token the token to get the price for\n    // @return the primary price of a token\n    function getPrimaryPrice(address token) external view returns (Price.Props memory) {\n        if (token == address(0)) { return Price.Props(0, 0); }\n\n        Price.Props memory price = primaryPrices[token];\n        if (price.isEmpty()) {\n            revert OracleUtils.EmptyPrimaryPrice(token);\n        }\n\n        return price;\n    }\n\n    // @dev get the secondary price of a token\n    // @param token the token to get the price for\n    // @return the secondary price of a token\n    function getSecondaryPrice(address token) external view returns (Price.Props memory) {\n        if (token == address(0)) { return Price.Props(0, 0); }\n\n        Price.Props memory price = secondaryPrices[token];\n        if (price.isEmpty()) {\n            revert OracleUtils.EmptySecondaryPrice(token);\n        }\n\n        return price;\n    }\n\n    // @dev get the latest price of a token\n    // @param token the token to get the price for\n    // @return the latest price of a token\n    function getLatestPrice(address token) external view returns (Price.Props memory) {\n        if (token == address(0)) { return Price.Props(0, 0); }\n\n        Price.Props memory secondaryPrice = secondaryPrices[token];\n\n        if (!secondaryPrice.isEmpty()) {\n            return secondaryPrice;\n        }\n\n        Price.Props memory primaryPrice = primaryPrices[token];\n        if (!primaryPrice.isEmpty()) {\n            return primaryPrice;\n        }\n\n        revert OracleUtils.EmptyLatestPrice(token);\n    }\n\n    // @dev get the custom price of a token\n    // @param token the token to get the price for\n    // @return the custom price of a token\n    function getCustomPrice(address token) external view returns (Price.Props memory) {\n        Price.Props memory price = customPrices[token];\n        if (price.isEmpty()) {\n            revert OracleUtils.EmptyCustomPrice(token);\n        }\n        return price;\n    }\n\n    // @dev get the price feed address for a token\n    // @param dataStore DataStore\n    // @param token the token to get the price feed for\n    // @return the price feed for the token\n    function getPriceFeed(DataStore dataStore, address token) public view returns (IPriceFeed) {\n        address priceFeedAddress = dataStore.getAddress(Keys.priceFeedKey(token));\n        if (priceFeedAddress == address(0)) {\n            revert EmptyPriceFeed(token);\n        }\n\n        return IPriceFeed(priceFeedAddress);\n    }\n\n    // @dev get the stable price of a token\n    // @param dataStore DataStore\n    // @param token the token to get the price for\n    // @return the stable price of the token\n    function getStablePrice(DataStore dataStore, address token) public view returns (uint256) {\n        return dataStore.getUint(Keys.stablePriceKey(token));\n    }\n\n    // @dev get the multiplier value to convert the external price feed price to the price of 1 unit of the token\n    // represented with 30 decimals\n    // for example, if USDC has 6 decimals and a price of 1 USD, one unit of USDC would have a price of\n    // 1 / (10 ^ 6) * (10 ^ 30) => 1 * (10 ^ 24)\n    // if the external price feed has 8 decimals, the price feed price would be 1 * (10 ^ 8)\n    // in this case the priceFeedMultiplier should be 10 ^ 46\n    // the conversion of the price feed price would be 1 * (10 ^ 8) * (10 ^ 46) / (10 ^ 30) => 1 * (10 ^ 24)\n    // formula for decimals for price feed multiplier: 60 - (external price feed decimals) - (token decimals)\n    //\n    // @param dataStore DataStore\n    // @param token the token to get the price feed multiplier for\n    // @return the price feed multipler\n    function getPriceFeedMultiplier(DataStore dataStore, address token) public view returns (uint256) {\n        uint256 multiplier = dataStore.getUint(Keys.priceFeedMultiplierKey(token));\n\n        if (multiplier == 0) {\n            revert EmptyPriceFeedMultiplier(token);\n        }\n\n        return multiplier;\n    }\n\n    // @dev validate and set prices\n    // The _setPrices() function is a helper function that is called by the\n    // setPrices() function. It takes in several parameters: a DataStore contract\n    // instance, an EventEmitter contract instance, an array of signers, and an\n    // OracleUtils.SetPricesParams struct containing information about the tokens\n    // and their prices.\n    // The function first initializes a SetPricesCache struct to store some temporary\n    // values that will be used later in the function. It then loops through the array\n    // of tokens and sets the corresponding values in the cache struct. For each token,\n    // the function also loops through the array of signers and validates the signatures\n    // for the min and max prices for that token. If the signatures are valid, the\n    // function calculates the median min and max prices and sets them in the DataStore\n    // contract.\n    // Finally, the function emits an event to signal that the prices have been set.\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param signers the signers of the prices\n    // @param params OracleUtils.SetPricesParams\n    function _setPrices(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        address[] memory signers,\n        OracleUtils.SetPricesParams memory params\n    ) internal {\n        SetPricesCache memory cache;\n        cache.minBlockConfirmations = dataStore.getUint(Keys.MIN_ORACLE_BLOCK_CONFIRMATIONS);\n        cache.maxPriceAge = dataStore.getUint(Keys.MAX_ORACLE_PRICE_AGE);\n\n        for (uint256 i = 0; i < params.tokens.length; i++) {\n            cache.info.minOracleBlockNumber = OracleUtils.getUncompactedOracleBlockNumber(params.compactedMinOracleBlockNumbers, i);\n            cache.info.maxOracleBlockNumber = OracleUtils.getUncompactedOracleBlockNumber(params.compactedMaxOracleBlockNumbers, i);\n\n            if (cache.info.minOracleBlockNumber > cache.info.maxOracleBlockNumber) {\n                revert InvalidMinMaxBlockNumber(cache.info.minOracleBlockNumber, cache.info.maxOracleBlockNumber);\n            }\n\n            cache.info.oracleTimestamp = OracleUtils.getUncompactedOracleTimestamp(params.compactedOracleTimestamps, i);\n\n            if (cache.info.minOracleBlockNumber > Chain.currentBlockNumber()) {\n                revert InvalidBlockNumber(cache.info.minOracleBlockNumber);\n            }\n\n            if (cache.info.oracleTimestamp + cache.maxPriceAge < Chain.currentTimestamp()) {\n                revert MaxPriceAgeExceeded(cache.info.oracleTimestamp);\n            }\n\n            // block numbers must be in ascending order\n            if (cache.info.minOracleBlockNumber < cache.prevMinOracleBlockNumber) {\n                revert BlockNumbersNotSorted(cache.info.minOracleBlockNumber, cache.prevMinOracleBlockNumber);\n            }\n            cache.prevMinOracleBlockNumber = cache.info.minOracleBlockNumber;\n\n            cache.info.blockHash = bytes32(0);\n            if (Chain.currentBlockNumber() - cache.info.minOracleBlockNumber <= cache.minBlockConfirmations) {\n                cache.info.blockHash = Chain.getBlockHash(cache.info.minOracleBlockNumber);\n            }\n\n            cache.info.token = params.tokens[i];\n            cache.info.precision = 10 ** OracleUtils.getUncompactedDecimal(params.compactedDecimals, i);\n            cache.info.tokenOracleType = dataStore.getBytes32(Keys.oracleTypeKey(cache.info.token));\n\n            cache.minPrices = new uint256[](signers.length);\n            cache.maxPrices = new uint256[](signers.length);\n\n            for (uint256 j = 0; j < signers.length; j++) {\n                cache.priceIndex = i * signers.length + j;\n                cache.minPrices[j] = OracleUtils.getUncompactedPrice(params.compactedMinPrices, cache.priceIndex);\n                cache.maxPrices[j] = OracleUtils.getUncompactedPrice(params.compactedMaxPrices, cache.priceIndex);\n\n                if (j == 0) { continue; }\n\n                // validate that minPrices are sorted in ascending order\n                if (cache.minPrices[j - 1] > cache.minPrices[j]) {\n                    revert MinPricesNotSorted(cache.info.token, cache.minPrices[j], cache.minPrices[j - 1]);\n                }\n\n                // validate that maxPrices are sorted in ascending order\n                if (cache.maxPrices[j - 1] > cache.maxPrices[j]) {\n                    revert MaxPricesNotSorted(cache.info.token, cache.maxPrices[j], cache.maxPrices[j - 1]);\n                }\n            }\n\n            for (uint256 j = 0; j < signers.length; j++) {\n                cache.signatureIndex = i * signers.length + j;\n                cache.minPriceIndex = OracleUtils.getUncompactedPriceIndex(params.compactedMinPricesIndexes, cache.signatureIndex);\n                cache.maxPriceIndex = OracleUtils.getUncompactedPriceIndex(params.compactedMaxPricesIndexes, cache.signatureIndex);\n\n                if (cache.signatureIndex >= params.signatures.length) {\n                    Array.revertArrayOutOfBounds(params.signatures, cache.signatureIndex, \"signatures\");\n                }\n\n                if (cache.minPriceIndex >= cache.minPrices.length) {\n                    Array.revertArrayOutOfBounds(cache.minPrices, cache.minPriceIndex, \"minPrices\");\n                }\n\n                if (cache.maxPriceIndex >= cache.maxPrices.length) {\n                    Array.revertArrayOutOfBounds(cache.maxPrices, cache.maxPriceIndex, \"maxPrices\");\n                }\n\n                cache.info.minPrice = cache.minPrices[cache.minPriceIndex];\n                cache.info.maxPrice = cache.maxPrices[cache.maxPriceIndex];\n\n                if (cache.info.minPrice > cache.info.maxPrice) {\n                    revert InvalidSignerMinMaxPrice(cache.info.minPrice, cache.info.maxPrice);\n                }\n\n                OracleUtils.validateSigner(\n                    SALT,\n                    cache.info,\n                    params.signatures[cache.signatureIndex],\n                    signers[j]\n                );\n            }\n\n            uint256 medianMinPrice = Array.getMedian(cache.minPrices) * cache.info.precision;\n            uint256 medianMaxPrice = Array.getMedian(cache.maxPrices) * cache.info.precision;\n\n            if (medianMinPrice == 0 || medianMaxPrice == 0) {\n                revert InvalidOraclePrice(cache.info.token);\n            }\n\n            if (medianMinPrice > medianMaxPrice) {\n                revert InvalidMedianMinMaxPrice(medianMinPrice, medianMaxPrice);\n            }\n\n            if (primaryPrices[cache.info.token].isEmpty()) {\n                emitOraclePriceUpdated(eventEmitter, cache.info.token, medianMinPrice, medianMaxPrice, true, false);\n\n                primaryPrices[cache.info.token] = Price.Props(\n                    medianMinPrice,\n                    medianMaxPrice\n                );\n            } else {\n                emitOraclePriceUpdated(eventEmitter, cache.info.token, medianMinPrice, medianMaxPrice, false, false);\n\n                secondaryPrices[cache.info.token] = Price.Props(\n                    medianMinPrice,\n                    medianMaxPrice\n                );\n            }\n\n            tokensWithPrices.add(cache.info.token);\n        }\n    }\n\n    // @dev set prices using external price feeds to save costs for tokens with stable prices\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param priceFeedTokens the tokens to set the prices using the price feeds for\n    function _setPricesFromPriceFeeds(DataStore dataStore, EventEmitter eventEmitter, address[] memory priceFeedTokens) internal {\n        for (uint256 i = 0; i < priceFeedTokens.length; i++) {\n            address token = priceFeedTokens[i];\n\n            if (!primaryPrices[token].isEmpty()) {\n                revert PriceAlreadySet(token, primaryPrices[token].min, primaryPrices[token].max);\n            }\n\n            IPriceFeed priceFeed = getPriceFeed(dataStore, token);\n\n            (\n                /* uint80 roundID */,\n                int256 _price,\n                /* uint256 startedAt */,\n                /* uint256 timestamp */,\n                /* uint80 answeredInRound */\n            ) = priceFeed.latestRoundData();\n\n            uint256 price = SafeCast.toUint256(_price);\n            uint256 precision = getPriceFeedMultiplier(dataStore, token);\n\n            price = price * precision / Precision.FLOAT_PRECISION;\n\n            if (price == 0) {\n                revert EmptyFeedPrice(token);\n            }\n\n            uint256 stablePrice = getStablePrice(dataStore, token);\n\n            Price.Props memory priceProps;\n\n            if (stablePrice > 0) {\n                priceProps = Price.Props(\n                    price < stablePrice ? price : stablePrice,\n                    price < stablePrice ? stablePrice : price\n                );\n            } else {\n                priceProps = Price.Props(\n                    price,\n                    price\n                );\n            }\n\n            primaryPrices[token] = priceProps;\n\n            tokensWithPrices.add(token);\n\n            emitOraclePriceUpdated(eventEmitter, token, priceProps.min, priceProps.max, true, true);\n        }\n    }\n\n    function emitOraclePriceUpdated(\n        EventEmitter eventEmitter,\n        address token,\n        uint256 minPrice,\n        uint256 maxPrice,\n        bool isPrimary,\n        bool isPriceFeed\n    ) internal {\n        EventUtils.EventLogData memory eventData;\n\n        eventData.addressItems.initItems(1);\n        eventData.addressItems.setItem(0, \"token\", token);\n\n        eventData.uintItems.initItems(2);\n        eventData.uintItems.setItem(0, \"minPrice\", minPrice);\n        eventData.uintItems.setItem(1, \"maxPrice\", maxPrice);\n\n        eventData.boolItems.initItems(2);\n        eventData.boolItems.setItem(0, \"isPrimary\", isPrimary);\n        eventData.boolItems.setItem(1, \"isPriceFeed\", isPriceFeed);\n\n        eventEmitter.emitEventLog1(\n            \"InsufficientFundingFeePayment\",\n            Cast.toBytes32(token),\n            eventData\n        );\n\n    }\n}"
    }
  ]
}