{
  "Title": "[L15] Stable token may not be backed up in the reserve",
  "Content": "The [`Reserve` contract](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/stability/Reserve.sol#L18) implements the functionality that ensures the price-stability of the stable token with respect to their pegs.\n\n\nTo do that, a tax called [Tobin tax](https://docs.celo.org/celo-codebase/protocol/stability/tobin-tax) allows the protocol to transfer CELO assets into the reserve to preserve the amount of collateral needed for the peg.\n\n\nIf the CELO reserve ratio, [defined as the ratio of the current CELO reserve balance to total stable token valuation](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/stability/Reserve.sol#L456), is less than the [`tobinTaxReserveRatio` variable](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/stability/Reserve.sol#L39), then it will be applied a [`tobinTax` value](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/stability/Reserve.sol#L38) to raise the reserve’s balance of CELO assets.\n\n\nNevertheless, the `tobinTaxReserveRatio` variable’s value can be changed by the protocol when calling the [`setTobinTaxReserveRatio` function](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/stability/Reserve.sol#L141), where no further validation checks are made to the input parameter. Due to that, if the input parameter is less than 100%, then the collateral that the protocol will seek to ensure the peg with the stable token will not cover the totality of the token’s supply value.\n\n\nAlthough it is unlikely that a proposal could be passed, succeeded, and set a problematic value, the human component will allways be present, allowing possible mistaken values in the protocol.\n\n\nConsider either requiring a `tobinTaxReserveRatio` value greater than 100% or documenting the decision of being able to set lower ratios.\n\n\n***Update**: Acknowledged, and will not fix. The cLabs team’s response was:*\n\n\n\n> \n> It is true that the `TobinTax` represents the on-chain collateralization ratio, which is a problem in some scenarios:  \n> \n> – Not all CELO in the reserve is in the reserve contract, some could be held in custody, see https://celoreserve.org/\n> \n> \n> * Assuming all CELO in the reserve is in the smart contract, even if we know the target reserve ratio on-chain, there’s no guarantee that the target ratio is met, due to market volatility\n> \n> \n> Thus, it is difficult to fully automate when the tobin tax should kick in. Even if all the reserve assets are on chain (like using some wrapped version of BTC, ETH and DAI on Celo), we’d need oracles providing the price for all of them.\n> \n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/stability/Reserve.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IReserve.sol\";\nimport \"./interfaces/ISortedOracles.sol\";\n\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\n/**\n * @title Ensures price stability of StableTokens with respect to their pegs\n */\ncontract Reserve is\n  IReserve,\n  ICeloVersionedContract,\n  Ownable,\n  Initializable,\n  UsingRegistry,\n  ReentrancyGuard\n{\n  using SafeMath for uint256;\n  using FixidityLib for FixidityLib.Fraction;\n\n  struct TobinTaxCache {\n    uint128 numerator;\n    uint128 timestamp;\n  }\n\n  mapping(address => bool) public isToken;\n  address[] private _tokens;\n  TobinTaxCache public tobinTaxCache;\n  uint256 public tobinTaxStalenessThreshold;\n  uint256 public tobinTax;\n  uint256 public tobinTaxReserveRatio;\n  mapping(address => bool) public isSpender;\n\n  mapping(address => bool) public isOtherReserveAddress;\n  address[] public otherReserveAddresses;\n\n  bytes32[] public assetAllocationSymbols;\n  mapping(bytes32 => uint256) public assetAllocationWeights;\n\n  uint256 public lastSpendingDay;\n  uint256 public spendingLimit;\n  FixidityLib.Fraction private spendingRatio;\n\n  uint256 public frozenReserveGoldStartBalance;\n  uint256 public frozenReserveGoldStartDay;\n  uint256 public frozenReserveGoldDays;\n\n  event TobinTaxStalenessThresholdSet(uint256 value);\n  event DailySpendingRatioSet(uint256 ratio);\n  event TokenAdded(address indexed token);\n  event TokenRemoved(address indexed token, uint256 index);\n  event SpenderAdded(address indexed spender);\n  event SpenderRemoved(address indexed spender);\n  event OtherReserveAddressAdded(address indexed otherReserveAddress);\n  event OtherReserveAddressRemoved(address indexed otherReserveAddress, uint256 index);\n  event AssetAllocationSet(bytes32[] symbols, uint256[] weights);\n  event ReserveGoldTransferred(address indexed spender, address indexed to, uint256 value);\n  event TobinTaxSet(uint256 value);\n  event TobinTaxReserveRatioSet(uint256 value);\n\n  modifier isStableToken(address token) {\n    require(isToken[token], \"token addr was never registered\");\n    _;\n  }\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return The storage, major, minor, and patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 1, 0);\n  }\n\n  function() external payable {} // solhint-disable no-empty-blocks\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   * @param _tobinTaxStalenessThreshold The initial number of seconds to cache tobin tax value for.\n   * @param _spendingRatio The relative daily spending limit for the reserve spender.\n   * @param _frozenGold The balance of reserve gold that is frozen.\n   * @param _frozenDays The number of days during which the frozen gold thaws.\n   * @param _assetAllocationSymbols The symbols of the reserve assets.\n   * @param _assetAllocationWeights The reserve asset weights.\n   * @param _tobinTax The tobin tax value as a fixidity fraction.\n   * @param _tobinTaxReserveRatio When to turn on the tobin tax, as a fixidity fraction.\n   */\n  function initialize(\n    address registryAddress,\n    uint256 _tobinTaxStalenessThreshold,\n    uint256 _spendingRatio,\n    uint256 _frozenGold,\n    uint256 _frozenDays,\n    bytes32[] calldata _assetAllocationSymbols,\n    uint256[] calldata _assetAllocationWeights,\n    uint256 _tobinTax,\n    uint256 _tobinTaxReserveRatio\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setTobinTaxStalenessThreshold(_tobinTaxStalenessThreshold);\n    setDailySpendingRatio(_spendingRatio);\n    setFrozenGold(_frozenGold, _frozenDays);\n    setAssetAllocations(_assetAllocationSymbols, _assetAllocationWeights);\n    setTobinTax(_tobinTax);\n    setTobinTaxReserveRatio(_tobinTaxReserveRatio);\n  }\n\n  /**\n   * @notice Sets the number of seconds to cache the tobin tax value for.\n   * @param value The number of seconds to cache the tobin tax value for.\n   */\n  function setTobinTaxStalenessThreshold(uint256 value) public onlyOwner {\n    require(value > 0, \"value was zero\");\n    tobinTaxStalenessThreshold = value;\n    emit TobinTaxStalenessThresholdSet(value);\n  }\n\n  /**\n   * @notice Sets the tobin tax.\n   * @param value The tobin tax.\n   */\n  function setTobinTax(uint256 value) public onlyOwner {\n    require(FixidityLib.wrap(value).lte(FixidityLib.fixed1()), \"tobin tax cannot be larger than 1\");\n    tobinTax = value;\n    emit TobinTaxSet(value);\n  }\n\n  /**\n   * @notice Sets the reserve ratio at which the tobin tax sets in.\n   * @param value The reserve ratio at which the tobin tax sets in.\n   */\n  function setTobinTaxReserveRatio(uint256 value) public onlyOwner {\n    tobinTaxReserveRatio = value;\n    emit TobinTaxReserveRatioSet(value);\n  }\n\n  /**\n   * @notice Set the ratio of reserve that is spendable per day.\n   * @param ratio Spending ratio as unwrapped Fraction.\n   */\n  function setDailySpendingRatio(uint256 ratio) public onlyOwner {\n    spendingRatio = FixidityLib.wrap(ratio);\n    require(spendingRatio.lte(FixidityLib.fixed1()), \"spending ratio cannot be larger than 1\");\n    emit DailySpendingRatioSet(ratio);\n  }\n\n  /**\n   * @notice Get daily spending ratio.\n   * @return Spending ratio as unwrapped Fraction.\n   */\n  function getDailySpendingRatio() public view returns (uint256) {\n    return spendingRatio.unwrap();\n  }\n\n  /**\n   * @notice Sets the balance of reserve gold frozen from transfer.\n   * @param frozenGold The amount of cGLD frozen.\n   * @param frozenDays The number of days the frozen cGLD thaws over.\n   */\n  function setFrozenGold(uint256 frozenGold, uint256 frozenDays) public onlyOwner {\n    require(frozenGold <= address(this).balance, \"Cannot freeze more than balance\");\n    frozenReserveGoldStartBalance = frozenGold;\n    frozenReserveGoldStartDay = now / 1 days;\n    frozenReserveGoldDays = frozenDays;\n  }\n\n  /**\n   * @notice Sets target allocations for Celo Gold and a diversified basket of non-Celo assets.\n   * @param symbols The symbol of each asset in the Reserve portfolio.\n   * @param weights The weight for the corresponding asset as unwrapped Fixidity.Fraction.\n   */\n  function setAssetAllocations(bytes32[] memory symbols, uint256[] memory weights)\n    public\n    onlyOwner\n  {\n    require(symbols.length == weights.length, \"Array length mismatch\");\n    FixidityLib.Fraction memory sum = FixidityLib.wrap(0);\n    for (uint256 i = 0; i < weights.length; i = i.add(1)) {\n      sum = sum.add(FixidityLib.wrap(weights[i]));\n    }\n    require(sum.equals(FixidityLib.fixed1()), \"Sum of asset allocation must be 1\");\n    for (uint256 i = 0; i < assetAllocationSymbols.length; i = i.add(1)) {\n      delete assetAllocationWeights[assetAllocationSymbols[i]];\n    }\n    assetAllocationSymbols = symbols;\n    for (uint256 i = 0; i < symbols.length; i = i.add(1)) {\n      require(assetAllocationWeights[symbols[i]] == 0, \"Cannot set weight twice\");\n      assetAllocationWeights[symbols[i]] = weights[i];\n    }\n    require(assetAllocationWeights[\"cGLD\"] != 0, \"Must set cGLD asset weight\");\n    emit AssetAllocationSet(symbols, weights);\n  }\n\n  /**\n   * @notice Add a token that the reserve will stabilize.\n   * @param token The address of the token being stabilized.\n   * @return Returns true if the transaction succeeds.\n   */\n  function addToken(address token) external onlyOwner nonReentrant returns (bool) {\n    require(!isToken[token], \"token addr already registered\");\n    // Require an exchange rate between the new token and Gold exists.\n    address sortedOraclesAddress = registry.getAddressForOrDie(SORTED_ORACLES_REGISTRY_ID);\n    ISortedOracles sortedOracles = ISortedOracles(sortedOraclesAddress);\n    uint256 tokenAmount;\n    uint256 goldAmount;\n    (tokenAmount, goldAmount) = sortedOracles.medianRate(token);\n    require(goldAmount > 0, \"median rate returned 0 gold\");\n    isToken[token] = true;\n    _tokens.push(token);\n    emit TokenAdded(token);\n    return true;\n  }\n\n  /**\n   * @notice Remove a token that the reserve will no longer stabilize.\n   * @param token The address of the token no longer being stabilized.\n   * @param index The index of the token in _tokens.\n   * @return Returns true if the transaction succeeds.\n   */\n  function removeToken(address token, uint256 index)\n    external\n    onlyOwner\n    isStableToken(token)\n    returns (bool)\n  {\n    require(\n      index < _tokens.length && _tokens[index] == token,\n      \"index into tokens list not mapped to token\"\n    );\n    isToken[token] = false;\n    address lastItem = _tokens[_tokens.length.sub(1)];\n    _tokens[index] = lastItem;\n    _tokens.length = _tokens.length.sub(1);\n    emit TokenRemoved(token, index);\n    return true;\n  }\n\n  /**\n   * @notice Add a reserve address whose balance shall be included in the reserve ratio.\n   * @param reserveAddress The reserve address to add.\n   * @return Returns true if the transaction succeeds.\n   */\n  function addOtherReserveAddress(address reserveAddress)\n    external\n    onlyOwner\n    nonReentrant\n    returns (bool)\n  {\n    require(!isOtherReserveAddress[reserveAddress], \"reserve addr already added\");\n    isOtherReserveAddress[reserveAddress] = true;\n    otherReserveAddresses.push(reserveAddress);\n    emit OtherReserveAddressAdded(reserveAddress);\n    return true;\n  }\n\n  /**\n   * @notice Remove reserve address whose balance shall no longer be included in the reserve ratio.\n   * @param reserveAddress The reserve address to remove.\n   * @param index The index of the reserve address in otherReserveAddresses.\n   * @return Returns true if the transaction succeeds.\n   */\n  function removeOtherReserveAddress(address reserveAddress, uint256 index)\n    external\n    onlyOwner\n    returns (bool)\n  {\n    require(isOtherReserveAddress[reserveAddress], \"reserve addr was never added\");\n    require(\n      index < otherReserveAddresses.length && otherReserveAddresses[index] == reserveAddress,\n      \"index into reserve list not mapped to address\"\n    );\n    isOtherReserveAddress[reserveAddress] = false;\n    address lastItem = otherReserveAddresses[otherReserveAddresses.length.sub(1)];\n    otherReserveAddresses[index] = lastItem;\n    otherReserveAddresses.length = otherReserveAddresses.length.sub(1);\n    emit OtherReserveAddressRemoved(reserveAddress, index);\n    return true;\n  }\n\n  /**\n   * @notice Gives an address permission to spend Reserve funds.\n   * @param spender The address that is allowed to spend Reserve funds.\n   */\n  function addSpender(address spender) external onlyOwner {\n    isSpender[spender] = true;\n    emit SpenderAdded(spender);\n  }\n\n  /**\n   * @notice Takes away an address's permission to spend Reserve funds.\n   * @param spender The address that is to be no longer allowed to spend Reserve funds.\n   */\n  function removeSpender(address spender) external onlyOwner {\n    isSpender[spender] = false;\n    emit SpenderRemoved(spender);\n  }\n\n  /**\n   * @notice Transfer gold to a whitelisted address subject to reserve spending limits.\n   * @param to The address that will receive the gold.\n   * @param value The amount of gold to transfer.\n   * @return Returns true if the transaction succeeds.\n   */\n  function transferGold(address payable to, uint256 value) external returns (bool) {\n    require(isSpender[msg.sender], \"sender not allowed to transfer Reserve funds\");\n    require(isOtherReserveAddress[to], \"can only transfer to other reserve address\");\n    uint256 currentDay = now / 1 days;\n    if (currentDay > lastSpendingDay) {\n      uint256 balance = getUnfrozenReserveGoldBalance();\n      lastSpendingDay = currentDay;\n      spendingLimit = spendingRatio.multiply(FixidityLib.newFixed(balance)).fromFixed();\n    }\n    require(spendingLimit >= value, \"Exceeding spending limit\");\n    spendingLimit = spendingLimit.sub(value);\n    return _transferGold(to, value);\n  }\n\n  /**\n   * @notice Transfer unfrozen gold to any address.\n   * @param to The address that will receive the gold.\n   * @param value The amount of gold to transfer.\n   * @return Returns true if the transaction succeeds.\n   */\n  function _transferGold(address payable to, uint256 value) internal returns (bool) {\n    require(value <= getUnfrozenBalance(), \"Exceeding unfrozen reserves\");\n    to.transfer(value);\n    emit ReserveGoldTransferred(msg.sender, to, value);\n    return true;\n  }\n\n  /**\n   * @notice Transfer unfrozen gold to any address, used for one side of CP-DOTO.\n   * @param to The address that will receive the gold.\n   * @param value The amount of gold to transfer.\n   * @return Returns true if the transaction succeeds.\n   */\n  function transferExchangeGold(address payable to, uint256 value)\n    external\n    onlyRegisteredContract(EXCHANGE_REGISTRY_ID)\n    returns (bool)\n  {\n    return _transferGold(to, value);\n  }\n\n  /**\n   * @notice Returns the tobin tax, recomputing it if it's stale.\n   * @return The tobin tax amount as a fraction.\n   */\n  function getOrComputeTobinTax() external nonReentrant returns (uint256, uint256) {\n    // solhint-disable-next-line not-rely-on-time\n    if (now.sub(tobinTaxCache.timestamp) > tobinTaxStalenessThreshold) {\n      tobinTaxCache.numerator = uint128(computeTobinTax().unwrap());\n      tobinTaxCache.timestamp = uint128(now); // solhint-disable-line not-rely-on-time\n    }\n    return (uint256(tobinTaxCache.numerator), FixidityLib.fixed1().unwrap());\n  }\n\n  /**\n   * @notice Returns the list of stabilized token addresses.\n   * @return An array of addresses of stabilized tokens.\n   */\n  function getTokens() external view returns (address[] memory) {\n    return _tokens;\n  }\n\n  /**\n   * @notice Returns the list other addresses included in the reserve total.\n   * @return An array of other addresses included in the reserve total.\n   */\n  function getOtherReserveAddresses() external view returns (address[] memory) {\n    return otherReserveAddresses;\n  }\n\n  /**\n   * @notice Returns a list of token symbols that have been allocated.\n   * @return An array of token symbols that have been allocated.\n   */\n  function getAssetAllocationSymbols() external view returns (bytes32[] memory) {\n    return assetAllocationSymbols;\n  }\n\n  /**\n   * @notice Returns a list of weights used for the allocation of reserve assets.\n   * @return An array of a list of weights used for the allocation of reserve assets.\n   */\n  function getAssetAllocationWeights() external view returns (uint256[] memory) {\n    uint256[] memory weights = new uint256[](assetAllocationSymbols.length);\n    for (uint256 i = 0; i < assetAllocationSymbols.length; i = i.add(1)) {\n      weights[i] = assetAllocationWeights[assetAllocationSymbols[i]];\n    }\n    return weights;\n  }\n\n  /**\n   * @notice Returns the amount of unfrozen Celo Gold in the reserve.\n   * @return The total unfrozen Celo Gold in the reserve.\n   */\n  function getUnfrozenBalance() public view returns (uint256) {\n    uint256 balance = address(this).balance;\n    uint256 frozenReserveGold = getFrozenReserveGoldBalance();\n    return balance > frozenReserveGold ? balance.sub(frozenReserveGold) : 0;\n  }\n\n  /**\n   * @notice Returns the amount of Celo Gold included in the reserve.\n   * @return The Celo Gold amount included in the reserve.\n   */\n  function getReserveGoldBalance() public view returns (uint256) {\n    return address(this).balance.add(getOtherReserveAddressesGoldBalance());\n  }\n\n  /**\n   * @notice Returns the amount of Celo Gold included in other reserve addresses.\n   * @return The Celo Gold amount included in other reserve addresses.\n   */\n  function getOtherReserveAddressesGoldBalance() public view returns (uint256) {\n    uint256 reserveGoldBalance = 0;\n    for (uint256 i = 0; i < otherReserveAddresses.length; i = i.add(1)) {\n      reserveGoldBalance = reserveGoldBalance.add(otherReserveAddresses[i].balance);\n    }\n    return reserveGoldBalance;\n  }\n\n  /**\n   * @notice Returns the amount of unfrozen Celo Gold included in the reserve.\n   * @return The unfrozen Celo Gold amount included in the reserve.\n   */\n  function getUnfrozenReserveGoldBalance() public view returns (uint256) {\n    return getUnfrozenBalance().add(getOtherReserveAddressesGoldBalance());\n  }\n\n  /**\n   * @notice Returns the amount of frozen Celo Gold in the reserve.\n   * @return The total frozen Celo Gold in the reserve.\n   */\n  function getFrozenReserveGoldBalance() public view returns (uint256) {\n    uint256 currentDay = now / 1 days;\n    uint256 frozenDays = currentDay.sub(frozenReserveGoldStartDay);\n    if (frozenDays >= frozenReserveGoldDays) return 0;\n    return\n      frozenReserveGoldStartBalance.sub(\n        frozenReserveGoldStartBalance.mul(frozenDays).div(frozenReserveGoldDays)\n      );\n  }\n\n  /**\n   * @notice Computes the ratio of current reserve balance to total stable token valuation.\n   * @return Reserve ratio in a fixed point format.\n   */\n  function getReserveRatio() public view returns (uint256) {\n    address sortedOraclesAddress = registry.getAddressForOrDie(SORTED_ORACLES_REGISTRY_ID);\n    ISortedOracles sortedOracles = ISortedOracles(sortedOraclesAddress);\n    uint256 reserveGoldBalance = getUnfrozenReserveGoldBalance();\n    uint256 stableTokensValueInGold = 0;\n    FixidityLib.Fraction memory cgldWeight = FixidityLib.wrap(assetAllocationWeights[\"cGLD\"]);\n\n    for (uint256 i = 0; i < _tokens.length; i = i.add(1)) {\n      uint256 stableAmount;\n      uint256 goldAmount;\n      (stableAmount, goldAmount) = sortedOracles.medianRate(_tokens[i]);\n      uint256 stableTokenSupply = IERC20(_tokens[i]).totalSupply();\n      uint256 aStableTokenValueInGold = stableTokenSupply.mul(goldAmount).div(stableAmount);\n      stableTokensValueInGold = stableTokensValueInGold.add(aStableTokenValueInGold);\n    }\n    return\n      FixidityLib\n        .newFixed(reserveGoldBalance)\n        .divide(cgldWeight)\n        .divide(FixidityLib.newFixed(stableTokensValueInGold))\n        .unwrap();\n  }\n\n  /*\n   * Internal functions\n   */\n\n  /**\n   * @notice Computes a tobin tax based on the reserve ratio.\n   * @return The tobin tax expresesed as a fixidity fraction.\n   */\n  function computeTobinTax() private view returns (FixidityLib.Fraction memory) {\n    FixidityLib.Fraction memory ratio = FixidityLib.wrap(getReserveRatio());\n    if (ratio.gte(FixidityLib.wrap(tobinTaxReserveRatio))) {\n      return FixidityLib.wrap(0);\n    } else {\n      return FixidityLib.wrap(tobinTax);\n    }\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/stability/Reserve.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IReserve.sol\";\nimport \"./interfaces/ISortedOracles.sol\";\n\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\n/**\n * @title Ensures price stability of StableTokens with respect to their pegs\n */\ncontract Reserve is\n  IReserve,\n  ICeloVersionedContract,\n  Ownable,\n  Initializable,\n  UsingRegistry,\n  ReentrancyGuard\n{\n  using SafeMath for uint256;\n  using FixidityLib for FixidityLib.Fraction;\n\n  struct TobinTaxCache {\n    uint128 numerator;\n    uint128 timestamp;\n  }\n\n  mapping(address => bool) public isToken;\n  address[] private _tokens;\n  TobinTaxCache public tobinTaxCache;\n  uint256 public tobinTaxStalenessThreshold;\n  uint256 public tobinTax;\n  uint256 public tobinTaxReserveRatio;\n  mapping(address => bool) public isSpender;\n\n  mapping(address => bool) public isOtherReserveAddress;\n  address[] public otherReserveAddresses;\n\n  bytes32[] public assetAllocationSymbols;\n  mapping(bytes32 => uint256) public assetAllocationWeights;\n\n  uint256 public lastSpendingDay;\n  uint256 public spendingLimit;\n  FixidityLib.Fraction private spendingRatio;\n\n  uint256 public frozenReserveGoldStartBalance;\n  uint256 public frozenReserveGoldStartDay;\n  uint256 public frozenReserveGoldDays;\n\n  event TobinTaxStalenessThresholdSet(uint256 value);\n  event DailySpendingRatioSet(uint256 ratio);\n  event TokenAdded(address indexed token);\n  event TokenRemoved(address indexed token, uint256 index);\n  event SpenderAdded(address indexed spender);\n  event SpenderRemoved(address indexed spender);\n  event OtherReserveAddressAdded(address indexed otherReserveAddress);\n  event OtherReserveAddressRemoved(address indexed otherReserveAddress, uint256 index);\n  event AssetAllocationSet(bytes32[] symbols, uint256[] weights);\n  event ReserveGoldTransferred(address indexed spender, address indexed to, uint256 value);\n  event TobinTaxSet(uint256 value);\n  event TobinTaxReserveRatioSet(uint256 value);\n\n  modifier isStableToken(address token) {\n    require(isToken[token], \"token addr was never registered\");\n    _;\n  }\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return The storage, major, minor, and patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 1, 0);\n  }\n\n  function() external payable {} // solhint-disable no-empty-blocks\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   * @param _tobinTaxStalenessThreshold The initial number of seconds to cache tobin tax value for.\n   * @param _spendingRatio The relative daily spending limit for the reserve spender.\n   * @param _frozenGold The balance of reserve gold that is frozen.\n   * @param _frozenDays The number of days during which the frozen gold thaws.\n   * @param _assetAllocationSymbols The symbols of the reserve assets.\n   * @param _assetAllocationWeights The reserve asset weights.\n   * @param _tobinTax The tobin tax value as a fixidity fraction.\n   * @param _tobinTaxReserveRatio When to turn on the tobin tax, as a fixidity fraction.\n   */\n  function initialize(\n    address registryAddress,\n    uint256 _tobinTaxStalenessThreshold,\n    uint256 _spendingRatio,\n    uint256 _frozenGold,\n    uint256 _frozenDays,\n    bytes32[] calldata _assetAllocationSymbols,\n    uint256[] calldata _assetAllocationWeights,\n    uint256 _tobinTax,\n    uint256 _tobinTaxReserveRatio\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setTobinTaxStalenessThreshold(_tobinTaxStalenessThreshold);\n    setDailySpendingRatio(_spendingRatio);\n    setFrozenGold(_frozenGold, _frozenDays);\n    setAssetAllocations(_assetAllocationSymbols, _assetAllocationWeights);\n    setTobinTax(_tobinTax);\n    setTobinTaxReserveRatio(_tobinTaxReserveRatio);\n  }\n\n  /**\n   * @notice Sets the number of seconds to cache the tobin tax value for.\n   * @param value The number of seconds to cache the tobin tax value for.\n   */\n  function setTobinTaxStalenessThreshold(uint256 value) public onlyOwner {\n    require(value > 0, \"value was zero\");\n    tobinTaxStalenessThreshold = value;\n    emit TobinTaxStalenessThresholdSet(value);\n  }\n\n  /**\n   * @notice Sets the tobin tax.\n   * @param value The tobin tax.\n   */\n  function setTobinTax(uint256 value) public onlyOwner {\n    require(FixidityLib.wrap(value).lte(FixidityLib.fixed1()), \"tobin tax cannot be larger than 1\");\n    tobinTax = value;\n    emit TobinTaxSet(value);\n  }\n\n  /**\n   * @notice Sets the reserve ratio at which the tobin tax sets in.\n   * @param value The reserve ratio at which the tobin tax sets in.\n   */\n  function setTobinTaxReserveRatio(uint256 value) public onlyOwner {\n    tobinTaxReserveRatio = value;\n    emit TobinTaxReserveRatioSet(value);\n  }\n\n  /**\n   * @notice Set the ratio of reserve that is spendable per day.\n   * @param ratio Spending ratio as unwrapped Fraction.\n   */\n  function setDailySpendingRatio(uint256 ratio) public onlyOwner {\n    spendingRatio = FixidityLib.wrap(ratio);\n    require(spendingRatio.lte(FixidityLib.fixed1()), \"spending ratio cannot be larger than 1\");\n    emit DailySpendingRatioSet(ratio);\n  }\n\n  /**\n   * @notice Get daily spending ratio.\n   * @return Spending ratio as unwrapped Fraction.\n   */\n  function getDailySpendingRatio() public view returns (uint256) {\n    return spendingRatio.unwrap();\n  }\n\n  /**\n   * @notice Sets the balance of reserve gold frozen from transfer.\n   * @param frozenGold The amount of cGLD frozen.\n   * @param frozenDays The number of days the frozen cGLD thaws over.\n   */\n  function setFrozenGold(uint256 frozenGold, uint256 frozenDays) public onlyOwner {\n    require(frozenGold <= address(this).balance, \"Cannot freeze more than balance\");\n    frozenReserveGoldStartBalance = frozenGold;\n    frozenReserveGoldStartDay = now / 1 days;\n    frozenReserveGoldDays = frozenDays;\n  }\n\n  /**\n   * @notice Sets target allocations for Celo Gold and a diversified basket of non-Celo assets.\n   * @param symbols The symbol of each asset in the Reserve portfolio.\n   * @param weights The weight for the corresponding asset as unwrapped Fixidity.Fraction.\n   */\n  function setAssetAllocations(bytes32[] memory symbols, uint256[] memory weights)\n    public\n    onlyOwner\n  {\n    require(symbols.length == weights.length, \"Array length mismatch\");\n    FixidityLib.Fraction memory sum = FixidityLib.wrap(0);\n    for (uint256 i = 0; i < weights.length; i = i.add(1)) {\n      sum = sum.add(FixidityLib.wrap(weights[i]));\n    }\n    require(sum.equals(FixidityLib.fixed1()), \"Sum of asset allocation must be 1\");\n    for (uint256 i = 0; i < assetAllocationSymbols.length; i = i.add(1)) {\n      delete assetAllocationWeights[assetAllocationSymbols[i]];\n    }\n    assetAllocationSymbols = symbols;\n    for (uint256 i = 0; i < symbols.length; i = i.add(1)) {\n      require(assetAllocationWeights[symbols[i]] == 0, \"Cannot set weight twice\");\n      assetAllocationWeights[symbols[i]] = weights[i];\n    }\n    require(assetAllocationWeights[\"cGLD\"] != 0, \"Must set cGLD asset weight\");\n    emit AssetAllocationSet(symbols, weights);\n  }\n\n  /**\n   * @notice Add a token that the reserve will stabilize.\n   * @param token The address of the token being stabilized.\n   * @return Returns true if the transaction succeeds.\n   */\n  function addToken(address token) external onlyOwner nonReentrant returns (bool) {\n    require(!isToken[token], \"token addr already registered\");\n    // Require an exchange rate between the new token and Gold exists.\n    address sortedOraclesAddress = registry.getAddressForOrDie(SORTED_ORACLES_REGISTRY_ID);\n    ISortedOracles sortedOracles = ISortedOracles(sortedOraclesAddress);\n    uint256 tokenAmount;\n    uint256 goldAmount;\n    (tokenAmount, goldAmount) = sortedOracles.medianRate(token);\n    require(goldAmount > 0, \"median rate returned 0 gold\");\n    isToken[token] = true;\n    _tokens.push(token);\n    emit TokenAdded(token);\n    return true;\n  }\n\n  /**\n   * @notice Remove a token that the reserve will no longer stabilize.\n   * @param token The address of the token no longer being stabilized.\n   * @param index The index of the token in _tokens.\n   * @return Returns true if the transaction succeeds.\n   */\n  function removeToken(address token, uint256 index)\n    external\n    onlyOwner\n    isStableToken(token)\n    returns (bool)\n  {\n    require(\n      index < _tokens.length && _tokens[index] == token,\n      \"index into tokens list not mapped to token\"\n    );\n    isToken[token] = false;\n    address lastItem = _tokens[_tokens.length.sub(1)];\n    _tokens[index] = lastItem;\n    _tokens.length = _tokens.length.sub(1);\n    emit TokenRemoved(token, index);\n    return true;\n  }\n\n  /**\n   * @notice Add a reserve address whose balance shall be included in the reserve ratio.\n   * @param reserveAddress The reserve address to add.\n   * @return Returns true if the transaction succeeds.\n   */\n  function addOtherReserveAddress(address reserveAddress)\n    external\n    onlyOwner\n    nonReentrant\n    returns (bool)\n  {\n    require(!isOtherReserveAddress[reserveAddress], \"reserve addr already added\");\n    isOtherReserveAddress[reserveAddress] = true;\n    otherReserveAddresses.push(reserveAddress);\n    emit OtherReserveAddressAdded(reserveAddress);\n    return true;\n  }\n\n  /**\n   * @notice Remove reserve address whose balance shall no longer be included in the reserve ratio.\n   * @param reserveAddress The reserve address to remove.\n   * @param index The index of the reserve address in otherReserveAddresses.\n   * @return Returns true if the transaction succeeds.\n   */\n  function removeOtherReserveAddress(address reserveAddress, uint256 index)\n    external\n    onlyOwner\n    returns (bool)\n  {\n    require(isOtherReserveAddress[reserveAddress], \"reserve addr was never added\");\n    require(\n      index < otherReserveAddresses.length && otherReserveAddresses[index] == reserveAddress,\n      \"index into reserve list not mapped to address\"\n    );\n    isOtherReserveAddress[reserveAddress] = false;\n    address lastItem = otherReserveAddresses[otherReserveAddresses.length.sub(1)];\n    otherReserveAddresses[index] = lastItem;\n    otherReserveAddresses.length = otherReserveAddresses.length.sub(1);\n    emit OtherReserveAddressRemoved(reserveAddress, index);\n    return true;\n  }\n\n  /**\n   * @notice Gives an address permission to spend Reserve funds.\n   * @param spender The address that is allowed to spend Reserve funds.\n   */\n  function addSpender(address spender) external onlyOwner {\n    isSpender[spender] = true;\n    emit SpenderAdded(spender);\n  }\n\n  /**\n   * @notice Takes away an address's permission to spend Reserve funds.\n   * @param spender The address that is to be no longer allowed to spend Reserve funds.\n   */\n  function removeSpender(address spender) external onlyOwner {\n    isSpender[spender] = false;\n    emit SpenderRemoved(spender);\n  }\n\n  /**\n   * @notice Transfer gold to a whitelisted address subject to reserve spending limits.\n   * @param to The address that will receive the gold.\n   * @param value The amount of gold to transfer.\n   * @return Returns true if the transaction succeeds.\n   */\n  function transferGold(address payable to, uint256 value) external returns (bool) {\n    require(isSpender[msg.sender], \"sender not allowed to transfer Reserve funds\");\n    require(isOtherReserveAddress[to], \"can only transfer to other reserve address\");\n    uint256 currentDay = now / 1 days;\n    if (currentDay > lastSpendingDay) {\n      uint256 balance = getUnfrozenReserveGoldBalance();\n      lastSpendingDay = currentDay;\n      spendingLimit = spendingRatio.multiply(FixidityLib.newFixed(balance)).fromFixed();\n    }\n    require(spendingLimit >= value, \"Exceeding spending limit\");\n    spendingLimit = spendingLimit.sub(value);\n    return _transferGold(to, value);\n  }\n\n  /**\n   * @notice Transfer unfrozen gold to any address.\n   * @param to The address that will receive the gold.\n   * @param value The amount of gold to transfer.\n   * @return Returns true if the transaction succeeds.\n   */\n  function _transferGold(address payable to, uint256 value) internal returns (bool) {\n    require(value <= getUnfrozenBalance(), \"Exceeding unfrozen reserves\");\n    to.transfer(value);\n    emit ReserveGoldTransferred(msg.sender, to, value);\n    return true;\n  }\n\n  /**\n   * @notice Transfer unfrozen gold to any address, used for one side of CP-DOTO.\n   * @param to The address that will receive the gold.\n   * @param value The amount of gold to transfer.\n   * @return Returns true if the transaction succeeds.\n   */\n  function transferExchangeGold(address payable to, uint256 value)\n    external\n    onlyRegisteredContract(EXCHANGE_REGISTRY_ID)\n    returns (bool)\n  {\n    return _transferGold(to, value);\n  }\n\n  /**\n   * @notice Returns the tobin tax, recomputing it if it's stale.\n   * @return The tobin tax amount as a fraction.\n   */\n  function getOrComputeTobinTax() external nonReentrant returns (uint256, uint256) {\n    // solhint-disable-next-line not-rely-on-time\n    if (now.sub(tobinTaxCache.timestamp) > tobinTaxStalenessThreshold) {\n      tobinTaxCache.numerator = uint128(computeTobinTax().unwrap());\n      tobinTaxCache.timestamp = uint128(now); // solhint-disable-line not-rely-on-time\n    }\n    return (uint256(tobinTaxCache.numerator), FixidityLib.fixed1().unwrap());\n  }\n\n  /**\n   * @notice Returns the list of stabilized token addresses.\n   * @return An array of addresses of stabilized tokens.\n   */\n  function getTokens("
    }
  ]
}