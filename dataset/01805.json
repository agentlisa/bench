{
  "Title": "Inconsistent asset variables",
  "Content": "When initializing the `Generalized4626Strategy` contract, the generic asset variables [are set](https://github.com/OriginProtocol/origin-dollar/blob/508921bd39f988fa61b60cea372b910725ff7bd0/contracts/contracts/utils/InitializableAbstractStrategy.sol#L247-L248) and then the new token variables are [redundantly set](https://github.com/OriginProtocol/origin-dollar/blob/508921bd39f988fa61b60cea372b910725ff7bd0/contracts/contracts/strategies/Generalized4626Strategy.sol#L86-L87). If the contract is initialized with multiple asset pairs, or another asset/platform token pair is [added](https://github.com/OriginProtocol/origin-dollar/blob/508921bd39f988fa61b60cea372b910725ff7bd0/contracts/contracts/utils/InitializableAbstractStrategy.sol#L207), the existing `shareToken` and `assetToken` variables will be overwritten. On the other hand, if an asset is [removed](https://github.com/OriginProtocol/origin-dollar/blob/508921bd39f988fa61b60cea372b910725ff7bd0/contracts/contracts/utils/InitializableAbstractStrategy.sol#L219), the `shareToken` and `assetToken` will not be affected, and the contract will continue to allow deposits and withdrawals using those tokens. This can lead to inconsistencies in both directions, where the contract incorrectly appears to support unsupported assets or vice versa.\n\n\nA similar observation applies to the `ConvexEthMetaStrategy` contract, which has variables for [WETH](https://github.com/OriginProtocol/origin-dollar/blob/757ad13fa07ecdff058e55d9beff3c98d5d186a2/contracts/contracts/strategies/ConvexEthMetaStrategy.sol#L34) and the [LP token](https://github.com/OriginProtocol/origin-dollar/blob/757ad13fa07ecdff058e55d9beff3c98d5d186a2/contracts/contracts/strategies/ConvexEthMetaStrategy.sol#L32), even though they are also recorded as [the asset and platform token](https://github.com/OriginProtocol/origin-dollar/blob/757ad13fa07ecdff058e55d9beff3c98d5d186a2/contracts/contracts/strategies/ConvexEthMetaStrategy.sol#L84-L85). In this case, the redundant variable [will not be overwritten](https://github.com/OriginProtocol/origin-dollar/blob/757ad13fa07ecdff058e55d9beff3c98d5d186a2/contracts/contracts/strategies/ConvexEthMetaStrategy.sol#L348) if a new pair of tokens is added, but the other inconsistencies still apply.\n\n\nIn the interest of consistency and predictability, consider using the existing variables to track the asset and share tokens, instead of introducing new ones. The [`_abstractSetPToken` function](https://github.com/OriginProtocol/origin-dollar/blob/757ad13fa07ecdff058e55d9beff3c98d5d186a2/contracts/contracts/utils/InitializableAbstractStrategy.sol#L284) can be used to ensure there is at most one active asset-share token pair.\n\n\n***Update:** Acknowledged, not resolved. The Origin team stated:*\n\n\n\n> *Acknowledged. In `Generalized4626Strategy`, we feel that the redundancy in the variables improves the code's comprehensibility.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/contracts/utils/InitializableAbstractStrategy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\nabstract contract InitializableAbstractStrategy is Initializable, Governable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    event PTokenAdded(address indexed _asset, address _pToken);\n    event PTokenRemoved(address indexed _asset, address _pToken);\n    event Deposit(address indexed _asset, address _pToken, uint256 _amount);\n    event Withdrawal(address indexed _asset, address _pToken, uint256 _amount);\n    event RewardTokenCollected(\n        address recipient,\n        address rewardToken,\n        uint256 amount\n    );\n    event RewardTokenAddressesUpdated(\n        address[] _oldAddresses,\n        address[] _newAddresses\n    );\n    event HarvesterAddressesUpdated(\n        address _oldHarvesterAddress,\n        address _newHarvesterAddress\n    );\n\n    // Core address for the given platform\n    address public platformAddress;\n\n    address public vaultAddress;\n\n    // asset => pToken (Platform Specific Token Address)\n    mapping(address => address) public assetToPToken;\n\n    // Full list of all assets supported here\n    address[] internal assetsMapped;\n\n    // Deprecated: Reward token address\n    // slither-disable-next-line constable-states\n    address public _deprecated_rewardTokenAddress;\n\n    // Deprecated: now resides in Harvester's rewardTokenConfigs\n    // slither-disable-next-line constable-states\n    uint256 public _deprecated_rewardLiquidationThreshold;\n\n    // Address of the one address allowed to collect reward tokens\n    address public harvesterAddress;\n\n    // Reward token addresses\n    address[] public rewardTokenAddresses;\n    /* Reserved for future expansion. Used to be 100 storage slots\n     * and has decreased to accommodate:\n     * - harvesterAddress\n     * - rewardTokenAddresses\n     */\n    int256[98] private _reserved;\n\n    /**\n     * @dev Internal initialize function, to set up initial internal state\n     * @param _platformAddress Generic platform address\n     * @param _vaultAddress Address of the Vault\n     * @param _rewardTokenAddresses Address of reward token for platform\n     * @param _assets Addresses of initial supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     */\n    function initialize(\n        address _platformAddress,\n        address _vaultAddress,\n        address[] calldata _rewardTokenAddresses,\n        address[] calldata _assets,\n        address[] calldata _pTokens\n    ) external onlyGovernor initializer {\n        InitializableAbstractStrategy._initialize(\n            _platformAddress,\n            _vaultAddress,\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n    }\n\n    function _initialize(\n        address _platformAddress,\n        address _vaultAddress,\n        address[] calldata _rewardTokenAddresses,\n        address[] memory _assets,\n        address[] memory _pTokens\n    ) internal {\n        platformAddress = _platformAddress;\n        vaultAddress = _vaultAddress;\n        rewardTokenAddresses = _rewardTokenAddresses;\n\n        uint256 assetCount = _assets.length;\n        require(assetCount == _pTokens.length, \"Invalid input arrays\");\n        for (uint256 i = 0; i < assetCount; i++) {\n            _setPTokenAddress(_assets[i], _pTokens[i]);\n        }\n    }\n\n    /**\n     * @dev Collect accumulated reward token and send to Vault.\n     */\n    function collectRewardTokens() external virtual onlyHarvester nonReentrant {\n        _collectRewardTokens();\n    }\n\n    function _collectRewardTokens() internal {\n        for (uint256 i = 0; i < rewardTokenAddresses.length; i++) {\n            IERC20 rewardToken = IERC20(rewardTokenAddresses[i]);\n            uint256 balance = rewardToken.balanceOf(address(this));\n            emit RewardTokenCollected(\n                harvesterAddress,\n                rewardTokenAddresses[i],\n                balance\n            );\n            rewardToken.safeTransfer(harvesterAddress, balance);\n        }\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault.\n     */\n    modifier onlyVault() {\n        require(msg.sender == vaultAddress, \"Caller is not the Vault\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Harvester.\n     */\n    modifier onlyHarvester() {\n        require(msg.sender == harvesterAddress, \"Caller is not the Harvester\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault or Governor.\n     */\n    modifier onlyVaultOrGovernor() {\n        require(\n            msg.sender == vaultAddress || msg.sender == governor(),\n            \"Caller is not the Vault or Governor\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault, Governor, or Strategist.\n     */\n    modifier onlyVaultOrGovernorOrStrategist() {\n        require(\n            msg.sender == vaultAddress ||\n                msg.sender == governor() ||\n                msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Vault, Governor, or Strategist\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Set the reward token addresses.\n     * @param _rewardTokenAddresses Address array of the reward token\n     */\n    function setRewardTokenAddresses(address[] calldata _rewardTokenAddresses)\n        external\n        onlyGovernor\n    {\n        for (uint256 i = 0; i < _rewardTokenAddresses.length; i++) {\n            require(\n                _rewardTokenAddresses[i] != address(0),\n                \"Can not set an empty address as a reward token\"\n            );\n        }\n\n        emit RewardTokenAddressesUpdated(\n            rewardTokenAddresses,\n            _rewardTokenAddresses\n        );\n        rewardTokenAddresses = _rewardTokenAddresses;\n    }\n\n    /**\n     * @dev Get the reward token addresses.\n     * @return address[] the reward token addresses.\n     */\n    function getRewardTokenAddresses()\n        external\n        view\n        returns (address[] memory)\n    {\n        return rewardTokenAddresses;\n    }\n\n    /**\n     * @dev Provide support for asset by passing its pToken address.\n     *      This method can only be called by the system Governor\n     * @param _asset    Address for the asset\n     * @param _pToken   Address for the corresponding platform token\n     */\n    function setPTokenAddress(address _asset, address _pToken)\n        external\n        onlyGovernor\n    {\n        _setPTokenAddress(_asset, _pToken);\n    }\n\n    /**\n     * @dev Remove a supported asset by passing its index.\n     *      This method can only be called by the system Governor\n     * @param _assetIndex Index of the asset to be removed\n     */\n    function removePToken(uint256 _assetIndex) external onlyGovernor {\n        require(_assetIndex < assetsMapped.length, \"Invalid index\");\n        address asset = assetsMapped[_assetIndex];\n        address pToken = assetToPToken[asset];\n\n        if (_assetIndex < assetsMapped.length - 1) {\n            assetsMapped[_assetIndex] = assetsMapped[assetsMapped.length - 1];\n        }\n        assetsMapped.pop();\n        assetToPToken[asset] = address(0);\n\n        emit PTokenRemoved(asset, pToken);\n    }\n\n    /**\n     * @dev Provide support for asset by passing its pToken address.\n     *      Add to internal mappings and execute the platform specific,\n     * abstract method `_abstractSetPToken`\n     * @param _asset    Address for the asset\n     * @param _pToken   Address for the corresponding platform token\n     */\n    function _setPTokenAddress(address _asset, address _pToken) internal {\n        require(assetToPToken[_asset] == address(0), \"pToken already set\");\n        require(\n            _asset != address(0) && _pToken != address(0),\n            \"Invalid addresses\"\n        );\n\n        assetToPToken[_asset] = _pToken;\n        assetsMapped.push(_asset);\n\n        emit PTokenAdded(_asset, _pToken);\n\n        _abstractSetPToken(_asset, _pToken);\n    }\n\n    /**\n     * @dev Transfer token to governor. Intended for recovering tokens stuck in\n     *      strategy contracts, i.e. mistaken sends.\n     * @param _asset Address for the asset\n     * @param _amount Amount of the asset to transfer\n     */\n    function transferToken(address _asset, uint256 _amount)\n        public\n        onlyGovernor\n    {\n        IERC20(_asset).safeTransfer(governor(), _amount);\n    }\n\n    /**\n     * @dev Set the reward token addresses.\n     * @param _harvesterAddress Address of the harvester\n     */\n    function setHarvesterAddress(address _harvesterAddress)\n        external\n        onlyGovernor\n    {\n        harvesterAddress = _harvesterAddress;\n        emit HarvesterAddressesUpdated(harvesterAddress, _harvesterAddress);\n    }\n\n    /***************************************\n                 Abstract\n    ****************************************/\n\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        virtual;\n\n    function safeApproveAllTokens() external virtual;\n\n    /**\n     * @dev Deposit an amount of asset into the platform\n     * @param _asset               Address for the asset\n     * @param _amount              Units of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount) external virtual;\n\n    /**\n     * @dev Deposit balance of all supported assets into the platform\n     */\n    function depositAll() external virtual;\n\n    /**\n     * @dev Withdraw an amount of asset from the platform.\n     * @param _recipient         Address to which the asset should be sent\n     * @param _asset             Address of the asset\n     * @param _amount            Units of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external virtual;\n\n    /**\n     * @dev Withdraw all assets from strategy sending assets to Vault.\n     */\n    function withdrawAll() external virtual;\n\n    /**\n     * @dev Get the total asset value held in the platform.\n     *      This includes any interest that was generated since depositing.\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        virtual\n        returns (uint256 balance);\n\n    /**\n     * @dev Check if an asset is supported.\n     * @param _asset    Address of the asset\n     * @return bool     Whether asset is supported\n     */\n    function supportsAsset(address _asset) external view virtual returns (bool);\n}"
    },
    {
      "filename": "contracts/contracts/strategies/ConvexEthMetaStrategy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Curve 3Pool Strategy\n * @notice Investment strategy for investing stablecoins via Curve 3Pool\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { ICurveETHPoolV1 } from \"./ICurveETHPoolV1.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IWETH9 } from \"../interfaces/IWETH9.sol\";\nimport { IConvexDeposits } from \"./IConvexDeposits.sol\";\nimport { IRewardStaking } from \"./IRewardStaking.sol\";\n\ncontract ConvexEthMetaStrategy is InitializableAbstractStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 internal constant MAX_SLIPPAGE = 1e16; // 1%, same as the Curve UI\n    address internal constant ETH_ADDRESS =\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address internal cvxDepositorAddress;\n    IRewardStaking public cvxRewardStaker;\n    uint256 internal cvxDepositorPTokenId;\n    ICurveETHPoolV1 internal curvePool;\n    IERC20 internal lpToken;\n    IERC20 internal oeth;\n    IWETH9 internal weth;\n    // Ordered list of pool assets\n    uint128 internal oethCoinIndex;\n    uint128 internal ethCoinIndex;\n\n    // used to circumvent the stack too deep issue\n    struct InitialiseConfig {\n        address curvePoolAddress; //Address of the Curve pool\n        address vaultAddress; //Address of the vault\n        address cvxDepositorAddress; //Address of the Convex depositor(AKA booster) for this pool\n        address oethAddress; //Address of OETH token\n        address wethAddress; //Address of WETH token\n        address cvxRewardStakerAddress; //Address of the CVX rewards staker\n        address curvePoolLpToken; //Address of metapool LP token\n        uint256 cvxDepositorPTokenId; //Pid of the pool referred to by Depositor and staker\n    }\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as Curve strategies don't fit\n     * well within that abstraction.\n     * @param _rewardTokenAddresses Address of CRV & CVX\n     * @param _assets Addresses of supported assets. MUST be passed in the same\n     *                order as returned by coins on the pool contract, i.e.\n     *                WETH\n     * @param initConfig Various addresses and info for initialization state\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses, // CRV + CVX\n        address[] calldata _assets,\n        address[] calldata _pTokens,\n        InitialiseConfig calldata initConfig\n    ) external onlyGovernor initializer {\n        require(_assets.length == 1, \"Must have exactly one asset\");\n        // Should be set prior to abstract initialize call otherwise\n        // abstractSetPToken calls will fail\n        cvxDepositorAddress = initConfig.cvxDepositorAddress;\n        cvxRewardStaker = IRewardStaking(initConfig.cvxRewardStakerAddress);\n        cvxDepositorPTokenId = initConfig.cvxDepositorPTokenId;\n        lpToken = IERC20(initConfig.curvePoolLpToken);\n        curvePool = ICurveETHPoolV1(initConfig.curvePoolAddress);\n        oeth = IERC20(initConfig.oethAddress);\n        weth = IWETH9(initConfig.wethAddress);\n        ethCoinIndex = uint128(_getCoinIndex(ETH_ADDRESS));\n        oethCoinIndex = uint128(_getCoinIndex(initConfig.oethAddress));\n\n        super._initialize(\n            initConfig.curvePoolAddress,\n            initConfig.vaultAddress,\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n\n        /* needs to be called after super._initialize so that the platformAddress\n         * is correctly set\n         */\n        _approveBase();\n    }\n\n    /**\n     * @dev Deposit asset into the Curve ETH pool\n     * @param _weth Address of WETH\n     * @param _amount Amount of asset to deposit\n     */\n    function deposit(address _weth, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_weth, _amount);\n    }\n\n    function _deposit(address _weth, uint256 _wethAmount) internal {\n        require(_wethAmount > 0, \"Must deposit something\");\n        require(_weth == address(weth), \"Can only deposit WETH\");\n        weth.withdraw(_wethAmount);\n\n        emit Deposit(_weth, address(lpToken), _wethAmount);\n\n        // safe to cast since min value is at least 0\n        uint256 oethToAdd = uint256(\n            _max(\n                0,\n                int256(curvePool.balances(ethCoinIndex)) +\n                    int256(_wethAmount) -\n                    int256(curvePool.balances(oethCoinIndex))\n            )\n        );\n\n        /* Add so much OETH so that the pool ends up being balanced. And at minimum\n         * add as much OETH as WETH and at maximum twice as much OETH.\n         */\n        oethToAdd = Math.max(oethToAdd, _wethAmount);\n        oethToAdd = Math.min(oethToAdd, _wethAmount * 2);\n\n        /* Mint OETH with a strategy that attempts to contribute to stability of OETH/WETH pool. Try\n         * to mint so much OETH that after deployment of liquidity pool ends up being balanced.\n         *\n         * To manage unpredictability minimal OETH minted will always be at least equal or greater\n         * to WETH amount deployed. And never larger than twice the WETH amount deployed even if\n         * it would have a further beneficial effect on pool stability.\n         */\n        IVault(vaultAddress).mintForStrategy(oethToAdd);\n\n        uint256[2] memory _amounts;\n        _amounts[ethCoinIndex] = _wethAmount;\n        _amounts[oethCoinIndex] = oethToAdd;\n\n        uint256 valueInLpTokens = (_wethAmount + oethToAdd).divPrecisely(\n            curvePool.get_virtual_price()\n        );\n        uint256 minMintAmount = valueInLpTokens.mulTruncate(\n            uint256(1e18) - MAX_SLIPPAGE\n        );\n\n        uint256 balance = oeth.balanceOf(address(this));\n        // Do the deposit to Curve ETH pool\n        uint256 lpDeposited = curvePool.add_liquidity{ value: _wethAmount }(\n            _amounts,\n            minMintAmount\n        );\n\n        require(\n            IConvexDeposits(cvxDepositorAddress).deposit(\n                cvxDepositorPTokenId,\n                lpDeposited,\n                true // Deposit with staking\n            ),\n            \"Depositing LP to Convex not successful\"\n        );\n    }\n\n    /**\n     * @dev Deposit the entire balance of any supported asset into the Curve 3pool\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 balance = weth.balanceOf(address(this));\n        if (balance > 0) {\n            _deposit(address(weth), balance);\n        }\n    }\n\n    /**\n     * @dev Withdraw asset from Curve ETH pool\n     * @param _recipient Address to receive withdrawn asset\n     * @param _weth Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _weth,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_amount > 0, \"Invalid amount\");\n        require(_weth == address(weth), \"Can only withdraw WETH\");\n\n        emit Withdrawal(_weth, address(lpToken), _amount);\n\n        uint256 requiredLpTokens = calcTokenToBurn(_amount);\n\n        _lpWithdraw(requiredLpTokens);\n\n        /* math in requiredLpTokens should correctly calculate the amount of LP to remove\n         * in that the strategy receives enough WETH on balanced removal\n         */\n        uint256[2] memory _minWithdrawalAmounts = [uint256(0), uint256(0)];\n        _minWithdrawalAmounts[ethCoinIndex] = _amount;\n        curvePool.remove_liquidity(requiredLpTokens, _minWithdrawalAmounts);\n\n        // Burn OETH\n        IVault(vaultAddress).burnForStrategy(oeth.balanceOf(address(this)));\n        // Transfer WETH\n        weth.deposit{ value: _amount }();\n        weth.transfer(_recipient, _amount);\n    }\n\n    function calcTokenToBurn(uint256 _wethAmount)\n        internal\n        view\n        returns (uint256 lpToBurn)\n    {\n        /* The rate between coins in the pool determines the rate at which pool returns\n         * tokens when doing balanced removal (remove_liquidity call). And by knowing how much WETH\n         * we want we can determine how much of OETH we receive by removing liquidity.\n         *\n         * Because we are doing balanced removal we should be making profit when removing liquidity in a\n         * pool tilted to either side.\n         *\n         * Important: A downside is that the Strategist / Governor needs to be\n         * cognisant of not removing too much liquidity. And while the proposal to remove liquidity\n         * is being voted on the pool tilt might change so much that the proposal that has been valid while\n         * created is no longer valid.\n         */\n\n        uint256 poolWETHBalance = curvePool.balances(ethCoinIndex);\n        /* K is multiplied by 1e36 which is used for higher precision calculation of required\n         * pool LP tokens. Without it the end value can have rounding errors up to precision of\n         * 10 digits. This way we move the decimal point by 36 places when doing the calculation\n         * and again by 36 places when we are done with it.\n         */\n        uint256 k = (1e36 * lpToken.totalSupply()) / poolWETHBalance;\n        // simplifying below to: `uint256 diff = (_wethAmount - 1) * k` causes loss of precision\n        // prettier-ignore\n        // slither-disable-next-line divide-before-multiply\n        uint256 diff = poolWETHBalance * k -\n            (poolWETHBalance - _wethAmount - 1) * k;\n        lpToBurn = diff / 1e36;\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        uint256 gaugeTokens = cvxRewardStaker.balanceOf(address(this));\n        _lpWithdraw(gaugeTokens);\n\n        // Withdraws are proportional to assets held by 3Pool\n        uint256[2] memory minWithdrawAmounts = [uint256(0), uint256(0)];\n\n        // Remove liquidity\n        curvePool.remove_liquidity(\n            lpToken.balanceOf(address(this)),\n            minWithdrawAmounts\n        );\n\n        // Burn all OETH\n        uint256 oethBalance = oeth.balanceOf(address(this));\n        IVault(vaultAddress).burnForStrategy(oethBalance);\n\n        // Send all ETH and WETH on the contract, including extra\n        weth.deposit{ value: address(this).balance }();\n        weth.transfer(vaultAddress, weth.balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Collect accumulated CRV and CVX and send to Harvester.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        // Collect CRV and CVX\n        cvxRewardStaker.getReward();\n        _collectRewardTokens();\n    }\n\n    function _lpWithdraw(uint256 _wethAmount) internal {\n        // withdraw and unwrap with claim takes back the lpTokens\n        // and also collects the rewards for deposit\n        cvxRewardStaker.withdrawAndUnwrap(_wethAmount, true);\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        public\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == address(weth), \"Unsupported asset\");\n\n        // Eth balance needed here for the balance check that happens from vault during depositing.\n        balance += address(this).balance;\n        uint256 lpTokens = cvxRewardStaker.balanceOf(address(this));\n        if (lpTokens > 0) {\n            balance += (lpTokens * curvePool.get_virtual_price()) / 1e18;\n        }\n    }\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _asset == address(weth);\n    }\n\n    /**\n     * @dev Approve the spending of all assets by their corresponding pool tokens,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        _approveAsset(address(weth));\n        _approveAsset(address(oeth));\n    }\n\n    /**\n     * @dev Accept unwrapped WETH\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Call the necessary approvals for the Curve pool and gauge\n     * @param _asset Address of the asset\n     */\n    // solhint-disable-next-line no-unused-vars\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        override\n    {\n        _approveAsset(_asset);\n    }\n\n    function _approveAsset(address _asset) internal {\n        // approve curve pool for asset (required for adding liquidity)\n        IERC20(_asset).approve(platformAddress, type(uint256).max);\n    }\n\n    function _approveBase() internal {\n        // WETH was approved as a supported asset,\n        // so we need seperate OETH approve\n        _approveAsset(address(oeth));\n        lpToken.approve(cvxDepositorAddress, type(uint256).max);\n    }\n\n    /**\n     * @dev Get the index of the coin\n     */\n    function _getCoinIndex(address _asset) internal view returns (uint256) {\n        for (uint256 i = 0; i < 2; i++) {\n            if (curvePool.coins(i) == _asset) return i;\n        }\n        revert(\"Invalid curve pool asset\");\n    }\n\n    /**\n     * @dev Returns the largest of two numbers int256 version\n     */\n    function _max(int256 a, int256 b) internal pure returns (int256) {\n        return a >= b ? a : b;\n    }\n}"
    },
    {
      "filename": "contracts/contracts/utils/InitializableAbstractStrategy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\nabstract contract InitializableAbstractStrategy is Initializable, Governable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    event PTokenAdded(address indexed _asset, address _pToken);\n    event PTokenRemoved(address indexed _asset, address _pToken);\n    event Deposit(address indexed _asset, address _pToken, uint256 _amount);\n    event Withdrawal(address indexed _asset, address _pToken, uint256 _amount);\n    event RewardTokenCollected(\n        address recipient,\n        address rewardToken,\n        uint256 amount\n    );\n    event RewardTokenAddressesUpdated(\n        address[] _oldAddresses,\n        address[] _newAddresses\n    );\n    event HarvesterAddressesUpdated(\n        address _oldHarvesterAddress,\n        address _newHarvesterAddress\n    );\n\n    // Core address for the given platform\n    address public platformAddress;\n\n    address public vaultAddress;\n\n    // asset => pToken (Platform Specific Token Address)\n    mapping(address => address) public assetToPToken;\n\n    // Full list of all assets supported here\n    address[] internal assetsMapped;\n\n    // Deprecated: Reward token address\n    // slither-disable-next-line constable-states\n    address public _deprecated_rewardTokenAddress;\n\n    // Deprecated: now resides in Harvester's rewardTokenConfigs\n    // slither-disable-next-line constable-states\n    uint256 public _deprecated_rewardLiquidationThreshold;\n\n    // Address of the one address allowed to collect reward tokens\n    address public harvesterAddress;\n\n    // Reward token addresses\n    address[] public rewardTokenAddresses;\n    /* Reserved for future expansion. Used to be 100 storage slots\n     * and has decreased to accommodate:\n     * - harvesterAddress\n     * - rewardTokenAddresses\n     */\n    int256[98] private _reserved;\n\n    /**\n     * @dev Internal initialize function, to set up initial internal state\n     * @param _platformAddress Generic platform address\n     * @param _vaultAddress Address of the Vault\n     * @param _rewardTokenAddresses Address of reward token for platform\n     * @param _assets Addresses of initial supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     */\n    function initialize(\n        address _platformAddress,\n        address _vaultAddress,\n        address[] calldata _rewardTokenAddresses,\n        address[] calldata _assets,\n        address[] calldata _pTokens\n    ) external onlyGovernor initializer {\n        InitializableAbstractStrategy._initialize(\n            _platformAddress,\n            _vaultAddress,\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n    }\n\n    function _initialize(\n        address _platformAddress,\n        address _vaultAddress,\n        address[] calldata _rewardTokenAddresses,\n        address[] memory _assets,\n        address[] memory _pTokens\n    ) internal {\n        platformAddress = _platformAddress;\n        vaultAddress = _vaultAddress;\n        rewardTokenAddresses = _rewardTokenAddresses;\n\n        uint256 assetCount = _assets.length;\n        require(assetCount == _pTokens.length, \"Invalid input arrays\");\n        for (uint256 i = 0; i < assetCount; i++) {\n            _setPTokenAddress(_assets[i], _pTokens[i]);\n        }\n    }\n\n    /**\n     * @dev Collect accumulated reward token and send to Vault.\n     */\n    function collectRewardTokens() external virtual onlyHarvester nonReentrant {\n        _collectRewardTokens();\n    }\n\n    function _collectRewardTokens() internal {\n        for (uint256 i = 0; i < rewardTokenAddresses.length; i++) {\n            IERC20 rewardToken = IERC20(rewardTokenAddresses[i]);\n            uint256 balance = rewardToken.balanceOf(address(this));\n            emit RewardTokenCollected(\n                harvesterAddress,\n                rewardTokenAddresses[i],\n                balance\n            );\n            rewardToken.safeTransfer(harvesterAddress, balance);\n        }\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault.\n     */\n    modifier onlyVault() {\n        require(msg.sender == vaultAddress, \"Caller is not the Vault\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Harvester.\n     */\n    modifier onlyHarvester() {\n        require(msg.sender == harvesterAddress, \"Caller is not the Harvester\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault or Governor.\n     */\n    modifier onlyVaultOrGovernor() {\n        require(\n            msg.sender == vaultAddress || msg.sender == governor(),\n            \"Caller is not the Vault or Governor\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault, Governor, or Strategist.\n     */\n    modifier onlyVaultOrGovernorOrStrategist() {\n        require(\n            msg.sender == vaultAddress ||\n                msg.sender == governor() ||\n                msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Vault, Governor, or Strategist\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Set the reward token addresses.\n     * @param _rewardTokenAddresses Address array of the reward token\n     */\n    function setRewardTokenAddresses(address[] calldata _rewardTokenAddresses)\n        external\n        onlyGovernor\n    {\n        for (uint256 i = 0; i < _rewardTokenAddresses.length; i++) {\n            require(\n                _rewardTokenAddresses[i] != address(0),\n                \"Can not set an empty address as a reward token\"\n            );\n        }\n\n        emit RewardTokenAddressesUpdated(\n            rewardTokenAddresses,\n            _rewardTokenAddresses\n        );\n        rewardTokenAddresses = _rewardTokenAddresses;\n    }\n\n    /**\n     * @dev Get the reward token addresses.\n     * @return address[] the reward token addresses.\n     */\n    function getRewardTokenAddresses()\n        external\n        view\n        returns (address[] memory)\n    {\n        return rewardTokenAddresses;\n    }\n\n    /**\n     * @dev Provide support for asset by passing its pToken address.\n     *      This method can only be called by the system Governor\n     * @param _asset    Address for the asset\n     * @param _pToken   Address for the corresponding platform token\n     */\n    function setPTokenAddress(address _asset, address _pToken)\n        external\n        onlyGovernor\n    {\n        _setPTokenAddress(_asset, _pToken);\n    }\n\n    /**\n     * @dev Remove a supported asset by passing its index.\n     *      This method can only be called by the system Governor\n     * @param _assetIndex Index of the asset to be removed\n     */\n    function removePToken(uint256 _assetIndex) external onlyGovernor {\n        require(_assetIndex < assetsMapped.length, \"Invalid index\");\n        address asset = assetsMapped[_assetIndex];\n        address pToken = assetToPToken[asset];\n\n        if (_assetIndex < assetsMapped.length - 1) {\n            assetsMapped[_assetIndex] = assetsMapped[assetsMapped.length - 1];\n        }\n        assetsMapped.pop();\n        assetToPToken[asset] = address(0);\n\n        emit PTokenRemoved(asset, pToken);\n    }\n\n    /**\n     * @dev Provide support for asset by passing its pToken address.\n     *      Add to internal mappings and execute th"
    }
  ]
}