{
  "Title": "M-5: min withdraw of 5 VUSD is not enough to prevent DOS via VUSD.sol#withdraw(amount)",
  "Content": "# Issue M-5: min withdraw of 5 VUSD is not enough to prevent DOS via VUSD.sol#withdraw(amount) \n\nSource: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/81 \n\n## Found by \n0xbepresent, lil.eth, p-tsanev\n## Summary\n\nA vulnerability exists where a malicious user spam the contract with numerous withdrawal requests (e.g., 5,000). This would mean that genuine users who wish to withdraw their funds may find themselves unable to do so in a timely manner because the processing of their withdrawals could be delayed significantly.\n\n## Vulnerability Detail\nThe issue stems from the fact that there is no restriction on the number of withdrawal requests a single address can make. A malicious actor could repeatedly call the withdraw or withdrawTo function, each time with a small amount (min 5 VUSD), to clog the queue with their withdrawal requests.\n```solidity\n    //E Burn vusd from msg.sender and queue the withdrawal to \"to\" address\n    function _withdrawTo(address to, uint amount) internal {\n        //E check min amount\n        require(amount >= 5 * (10 ** 6), \"min withdraw is 5 vusd\"); //E @audit-info not enough to prevent grief\n        //E burn this amount from msg.sender\n        burn(amount); // burn vusd from msg.sender\n        //E push \n        withdrawals.push(Withdrawal(to, amount * 1e12));\n    }\n```\nGiven the maxWithdrawalProcesses is set to 100, and the withdrawal processing function processWithdrawals doesn't have any parameter to process from a specific index in the queue, only the first 100 requests in the queue would be processed at a time.\n```solidity\n    uint public maxWithdrawalProcesses = 100;\n    //E create array of future withdrawal that will be executed to return\n    function withdrawalQueue() external view returns(Withdrawal[] memory queue) {\n        //E check if more than 100 requests in withdrawals array\n        uint l = _min(withdrawals.length-start, maxWithdrawalProcesses);\n        queue = new Withdrawal[](l);\n\n        for (uint i = 0; i < l; i++) {\n            queue[i] = withdrawals[start+i];\n        }\n    }\n```\nIn the case of an attack, the first 100 withdrawal requests could be those of the attacker, meaning that the genuine users' requests would be stuck in the queue until all of the attacker's requests have been processed. Moreover the fact that we can only withdraw up to 1 day long when our withdraw request is good to go.\n\n## Impact\n\nThis could result in significant delays for genuine users wanting to withdraw their funds, undermining the contract's usability and users' trust in the platform.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/VUSD.sol#L88\n\n## Tool used\n\nManual Review\n\n## Recommendation\nEither limit number of withdrawal requests per address could be a first layer of defense even if it's not enough but I don't see the point why this limit is included so removing it could mitigate this.\nOtherwise you could implement a priority queue regarding amount to be withdrawn\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/72",
  "Code": [
    {
      "filename": "hubble-protocol/contracts/VUSD.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { ERC20PresetMinterPauserUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\";\nimport { IVUSD } from './Interfaces.sol';\n\n/**\n * @title VUSD is a wrapper over USDC (also the gas token). VUSD it the 0th collateral in the system and also the only coin accepted by the insurance fund.\n * @notice In Hubble Exchange docs/contracts etc, VUSD is interchangeably referred to as hUSD\n*/\ncontract VUSD is ERC20PresetMinterPauserUpgradeable, ReentrancyGuard, IVUSD {\n\n    uint8 private constant PRECISION = 6;\n    uint256 private constant SCALING_FACTOR = 1e12;\n\n    struct Withdrawal {\n        address usr;\n        uint amount;\n    }\n    Withdrawal[] public withdrawals;\n\n    /// @dev withdrawals will start processing at withdrawals[start]\n    uint public start;\n\n    /// @dev Constrained by block gas limit\n    uint public maxWithdrawalProcesses;\n\n    uint256[50] private __gap;\n\n    function initialize(string memory name, string memory symbol) public override virtual {\n        super.initialize(name, symbol); // has initializer modifier\n        _revokeRole(MINTER_ROLE, _msgSender()); // __ERC20PresetMinterPauser_init_unchained grants this but is not required\n        maxWithdrawalProcesses = 100;\n    }\n\n    /**\n    * @notice mint hUSD by depositing hubble gas token\n    * @dev keeping the function name same as v1 for compatibility\n    * @param to address to mint for\n    * @param amount amount to mint - precision 1e6\n    * msg.value has to be exactly 1e12 times `amount`\n    */\n    function mintWithReserve(address to, uint amount) external override payable whenNotPaused {\n        require(msg.value == amount * SCALING_FACTOR, \"vUSD: Insufficient amount transferred\");\n        _mint(to, amount);\n    }\n\n    function withdraw(uint amount) external override whenNotPaused {\n        _withdrawTo(_msgSender(), amount);\n    }\n\n    /**\n    * @notice Burn vusd from msg.sender and Q the withdrawal to `to`\n    * @dev no need to add onlyMarginAccountHelper modifier as vusd is burned from caller and sent to specified address\n    */\n    function withdrawTo(address to, uint amount) external override whenNotPaused {\n        _withdrawTo(to, amount);\n    }\n\n    /**\n     * @notice Process withdrawals in the queue. Sends gas token to the user.\n    */\n    function processWithdrawals() external override whenNotPaused nonReentrant {\n        uint reserve = address(this).balance;\n        require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this time: Not enough balance');\n        uint i = start;\n        while (i < withdrawals.length && (i - start) < maxWithdrawalProcesses) {\n            Withdrawal memory withdrawal = withdrawals[i];\n            if (reserve < withdrawal.amount) {\n                break;\n            }\n\n            (bool success, bytes memory data) = withdrawal.usr.call{value: withdrawal.amount}(\"\");\n            if (success) {\n                reserve -= withdrawal.amount;\n            } else {\n                emit WithdrawalFailed(withdrawal.usr, withdrawal.amount, data);\n            }\n            i += 1;\n        }\n        // re-entracy not possible, hence can update `start` at the end\n        start = i;\n    }\n\n    function withdrawalQueue() external view returns(Withdrawal[] memory queue) {\n        uint l = _min(withdrawals.length-start, maxWithdrawalProcesses);\n        queue = new Withdrawal[](l);\n\n        for (uint i = 0; i < l; i++) {\n            queue[i] = withdrawals[start+i];\n        }\n    }\n\n    function withdrawalQLength() external view returns (uint) {\n        return withdrawals.length;\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return PRECISION;\n    }\n\n    function setMaxWithdrawalProcesses(uint _maxWithdrawalProcesses) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have admin role\");\n        maxWithdrawalProcesses = _maxWithdrawalProcesses;\n    }\n\n    function _withdrawTo(address to, uint amount) internal {\n        require(amount >= 5 * (10 ** PRECISION), \"min withdraw is 5 vusd\");\n        burn(amount); // burn vusd from msg.sender\n        withdrawals.push(Withdrawal(to, amount * SCALING_FACTOR));\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}"
    }
  ]
}