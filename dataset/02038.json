{
  "Title": "Incorrect blacklisting of unsafe calls",
  "Content": "##### Description\nAccording to the current design, the users of `Rubic` perform the ERC20 `approve` to the `ERC20Proxy` contract, allowing the ERC20 [tokens to be spent without further confirmations](https://github.com/Cryptorubic/multi-proxy-rubic/blob/8843336c50ca43e5b5bbe970f17e284f63a96763/src/Periphery/ERC20Proxy.sol#L40). It is crucially important to disallow any unauthorized calls to this contract, otherwise the user's ERC20 tokens may be spent by an unauthorized party.\n\nThe `LibSwap` library implements mechanics to perform an arbitrary call to an arbitrary address. By design, calls to `ERC20Proxy` are [blacklisted](https://github.com/Cryptorubic/multi-proxy-rubic/blob/8843336c50ca43e5b5bbe970f17e284f63a96763/src/Libraries/LibSwap.sol#L32). However, the blacklisting is set up in the context of `RubicMultiProxy` and will not work in the context of `Executor`, which is also granted a permission to call `ERC20Proxy` for [`_processSwaps`](https://github.com/Cryptorubic/multi-proxy-rubic/blob/8843336c50ca43e5b5bbe970f17e284f63a96763/src/Periphery/Executor.sol#L174). Therefore, an attacker can force `Executor` to call `ERC20Proxy` (see the Critical.2 finding), perform an unauthorized `transferFrom` and withdraw the ERC20 tokens of any user who gave an ERC20 `approve` to the `Rubic`.\n\n##### Recommendation\nIt is recommended to use more fail-safe practices of managing the ERC20 `approve` as described below in the recommendation for the Medium.1 finding. Additionally, it is advised to fix the blacklist issue for the `LibSwap`.\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "src/Periphery/ERC20Proxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\n\n/// @title ERC20 Proxy\n/// @notice Proxy contract for safely transferring ERC20 tokens for swaps/executions\ncontract ERC20Proxy is Ownable {\n    /// Storage ///\n    mapping(address => bool) public authorizedCallers;\n\n    /// Errors ///\n    error UnAuthorized();\n\n    /// Events ///\n    event AuthorizationChanged(address indexed caller, bool authorized);\n\n    /// Constructor\n    constructor(address _owner) {\n        transferOwnership(_owner);\n    }\n\n    /// @notice Sets whether or not a specified caller is authorized to call this contract\n    /// @param caller the caller to change authorization for\n    /// @param authorized specifies whether the caller is authorized (true/false)\n    function setAuthorizedCaller(\n        address caller,\n        bool authorized\n    ) external onlyOwner {\n        authorizedCallers[caller] = authorized;\n        emit AuthorizationChanged(caller, authorized);\n    }\n\n    /// @notice Transfers tokens from one address to another specified address\n    /// @param tokenAddress the ERC20 contract address of the token to send\n    /// @param from the address to transfer from\n    /// @param to the address to transfer to\n    /// @param amount the amount of tokens to send\n    function transferFrom(\n        address tokenAddress,\n        address from,\n        address to,\n        uint256 amount\n    ) external {\n        if (!authorizedCallers[msg.sender]) revert UnAuthorized();\n\n        LibAsset.transferFromERC20(tokenAddress, from, to, amount);\n    }\n}"
    },
    {
      "filename": "src/Libraries/LibSwap.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { LibAsset } from \"./LibAsset.sol\";\nimport { LibUtil } from \"./LibUtil.sol\";\nimport { InvalidContract, NoSwapFromZeroBalance, InsufficientBalance, UnAuthorized } from \"../Errors/GenericErrors.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nlibrary LibSwap {\n    struct SwapData {\n        address callTo;\n        address approveTo;\n        address sendingAssetId;\n        address receivingAssetId;\n        uint256 fromAmount;\n        bytes callData;\n        bool requiresDeposit;\n    }\n\n    event AssetSwapped(\n        bytes32 transactionId,\n        address dex,\n        address fromAssetId,\n        address toAssetId,\n        uint256 fromAmount,\n        uint256 toAmount,\n        uint256 timestamp\n    );\n\n    function swap(bytes32 transactionId, SwapData memory _swap) internal {\n        if (!LibAsset.isContract(_swap.callTo)) revert InvalidContract();\n        if (_swap.callTo == address(LibAsset.getERC20proxy()))\n            revert UnAuthorized();\n        uint256 fromAmount = _swap.fromAmount;\n        if (fromAmount == 0) revert NoSwapFromZeroBalance();\n        uint256 nativeValue = LibAsset.isNativeAsset(_swap.sendingAssetId)\n            ? _swap.fromAmount\n            : 0;\n        uint256 initialSendingAssetBalance = LibAsset.getOwnBalance(\n            _swap.sendingAssetId\n        );\n        uint256 initialReceivingAssetBalance = LibAsset.getOwnBalance(\n            _swap.receivingAssetId\n        );\n\n        if (nativeValue == 0) {\n            LibAsset.maxApproveERC20(\n                IERC20(_swap.sendingAssetId),\n                _swap.approveTo,\n                _swap.fromAmount\n            );\n        }\n\n        if (initialSendingAssetBalance < _swap.fromAmount) {\n            revert InsufficientBalance(\n                _swap.fromAmount,\n                initialSendingAssetBalance\n            );\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory res) = _swap.callTo.call{\n            value: nativeValue\n        }(_swap.callData);\n        if (!success) {\n            string memory reason = LibUtil.getRevertMsg(res);\n            revert(reason);\n        }\n\n        uint256 newBalance = LibAsset.getOwnBalance(_swap.receivingAssetId);\n\n        emit AssetSwapped(\n            transactionId,\n            _swap.callTo,\n            _swap.sendingAssetId,\n            _swap.receivingAssetId,\n            _swap.fromAmount,\n            newBalance > initialReceivingAssetBalance\n                ? newBalance - initialReceivingAssetBalance\n                : newBalance,\n            block.timestamp\n        );\n    }\n}"
    }
  ]
}