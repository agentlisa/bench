{
  "Title": "H-3: Auction can potentially sell more contracts than it has collateral for.",
  "Content": "# Issue H-3: Auction can potentially sell more contracts than it has collateral for. \n\nSource: https://github.com/sherlock-audit/2022-09-knox-judging/issues/80 \n\n## Found by \nhansfriese, yixxas\n\n## Summary\n`auction.totalContracts` is determined by the amount of collateral the protocol has received. After an auction has ended, users are allowed to withdraw and what they receive depends on whether their orders have filled, or they receive a refund, or a mixture of both. However, wrong accounting in `_previewWithdraw()` can lead to the `fill` and `refund` value to be calculated wrongly.\n\n## Vulnerability Detail\nEach time a withdrawal is made, the order is removed from the order book as seen in L339 in `_previewWithdraw()`. Now, the issue here is in the line `totalContractsSold += data.size`. If a user with an order that is higher priced, that is with a lower index in the order book( since order book is in decreasing order based on price ), chooses to withdraw first, their order is removed from the order book. Now, the next user who does a withdraw will call this same function, but `totalContractsSold` is calculated from 0 again. This leads to problems and I illustrate with a simple example below.\n\n\nAssume,\n`auction.totalContracts = 10`\n\nAlice first `addLimitOrder()` with `price = 10`, `size = 10`.\nBob then `addLimitOrder()` with `price = 10`, 'size = 1'.\n\nNow order book have 2 orders.\n\n`processOrder()` is then called, since utilisation reaches a 100%, clearing price is set to 10 and all contracts are sold to Alice.\nNow, Alice does a withdraw first and withdraws successfully with `fill = 10, refund = 0`. Now Bob tries to withdraw, the previous order is removed from the order book, so when `i = 1`, it enters the `if (data.price64x64 >= lastPrice64x64)` check. This time, `if (totalContractsSold + data.size >= auction.totalContracts)` check does not pass since `totalContractsSold = 0, data.size = 1, auction.totalContracts = 10`. It will then enter the else part where `fill += data.size`. This means that additional contracts are being sold to Bob even though it has been previously sold to Alice which exceeds the limit that the collateral allows.\n\n## Impact\nAuction is selling more contracts than it has collateral for which creates plenty of liquidity problems / issues with risk as options are now \"naked\".\n\n## Code Snippet\n\n[AuctionInternal.sol#L279-L347](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/AuctionInternal.sol#L279-L347)\n```solidity\n    function _previewWithdraw(\n        AuctionStorage.Layout storage l,\n        bool isPreview,\n        uint64 epoch,\n        address buyer\n    ) private returns (uint256, uint256) {\n        ...\n        uint256 totalContractsSold;\n        ...\n        // traverse the order book and return orders placed by the buyer\n        for (uint256 i = 1; i <= length; i++) {\n            OrderBook.Data memory data = orderbook._getOrderById(next);\n            next = orderbook._getNextOrder(next);\n\n            if (data.buyer == buyer) {\n                if (\n                    lastPrice64x64 < type(int128).max &&\n                    data.price64x64 >= lastPrice64x64\n                ) {\n                    // if the auction has not been cancelled, and the order price is greater than or\n                    // equal to the last price, fill the order and calculate the refund amount\n                    uint256 paid = data.price64x64.mulu(data.size);\n                    uint256 cost = lastPrice64x64.mulu(data.size);\n\n                    if (\n                        totalContractsSold + data.size >= auction.totalContracts\n                    ) {\n                        // if part of the current order exceeds the total contracts available, partially\n                        // fill the order, and refund the remainder\n                        uint256 remainder =\n                            auction.totalContracts - totalContractsSold;\n\n                        cost = lastPrice64x64.mulu(remainder);\n                        fill += remainder;\n                    } else {\n                        // otherwise, fill the entire order\n                        fill += data.size;\n                    }\n\n                    // the refund takes the difference between the amount paid and the \"true\" cost of\n                    // of the order. the \"true\" cost can be calculated when the clearing price has been\n                    // set.\n                    refund += paid - cost;\n                } else {\n                    // if last price >= type(int128).max, auction has been cancelled, only send refund\n                    // if price < last price, the bid is too low, only send refund\n                    refund += data.price64x64.mulu(data.size);\n                }\n\n                if (!isPreview) {\n                    // when a withdrawal is made, remove the order from the order book\n                    orderbook._remove(data.id);\n                }\n            }\n\n            totalContractsSold += data.size;\n        }\n\n        return (refund, fill);\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThis problem arises due to how orders that have the same price as the clearing price, yet should not be filled due to exceeding the limit is not accounted for. A check in `_previewWithdraw()` needs to be done to prevent this edge case.\n\nI believe removing an order from the order book after withdrawal is done to prevent multiple withdrawals from the same user. If this is the case, we can use a mapping to check this instead, so that `totalContractsSold` remains accurate. We can then refund users once this exceeds `auction.totalContracts`.\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/4",
  "Code": [
    {
      "filename": "knox-contracts/contracts/auction/AuctionInternal.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@solidstate/contracts/access/ownable/OwnableInternal.sol\";\nimport \"@solidstate/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@solidstate/contracts/token/ERC20/IERC20.sol\";\nimport \"@solidstate/contracts/token/ERC20/metadata/IERC20Metadata.sol\";\nimport \"@solidstate/contracts/utils/IWETH.sol\";\nimport \"@solidstate/contracts/utils/SafeERC20.sol\";\n\nimport \"../libraries/OptionMath.sol\";\n\nimport \"../vendor/IPremiaPool.sol\";\n\nimport \"../vault/IVault.sol\";\n\nimport \"./AuctionStorage.sol\";\nimport \"./IAuctionEvents.sol\";\n\n/**\n * @title Knox Dutch Auction Internal Contract\n */\n\ncontract AuctionInternal is IAuctionEvents, OwnableInternal {\n    using ABDKMath64x64 for int128;\n    using ABDKMath64x64 for uint256;\n    using ABDKMath64x64Token for int128;\n    using ABDKMath64x64Token for uint256;\n    using AuctionStorage for AuctionStorage.Layout;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using OptionMath for uint256;\n    using OrderBook for OrderBook.Index;\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IWETH;\n\n    bool internal immutable isCall;\n    uint8 internal immutable baseDecimals;\n    uint8 internal immutable underlyingDecimals;\n\n    IERC20 public immutable ERC20;\n    IPremiaPool public immutable Pool;\n    IVault public immutable Vault;\n    IWETH public immutable WETH;\n\n    constructor(\n        bool _isCall,\n        address pool,\n        address vault,\n        address weth\n    ) {\n        isCall = _isCall;\n\n        Pool = IPremiaPool(pool);\n        IPremiaPool.PoolSettings memory settings = Pool.getPoolSettings();\n        address asset = isCall ? settings.underlying : settings.base;\n\n        baseDecimals = IERC20Metadata(settings.base).decimals();\n        underlyingDecimals = IERC20Metadata(settings.underlying).decimals();\n\n        ERC20 = IERC20(asset);\n        Vault = IVault(vault);\n        WETH = IWETH(weth);\n    }\n\n    /************************************************\n     *  ACCESS CONTROL\n     ***********************************************/\n\n    /**\n     * @dev Throws if called by any account other than the vault\n     */\n    modifier onlyVault() {\n        AuctionStorage.Layout storage l = AuctionStorage.layout();\n        require(msg.sender == address(Vault), \"!vault\");\n        _;\n    }\n\n    /**\n     * @dev Throws if limit orders are not allowed\n     * @param auction storage params\n     */\n    function _limitOrdersAllowed(AuctionStorage.Auction storage auction)\n        internal\n        view\n    {\n        require(\n            AuctionStorage.Status.INITIALIZED == auction.status,\n            \"status != initialized\"\n        );\n        _auctionHasNotEnded(auction);\n    }\n\n    /**\n     * @dev Throws if market orders are not allowed\n     * @param auction storage params\n     */\n    function _marketOrdersAllowed(AuctionStorage.Auction storage auction)\n        internal\n        view\n    {\n        require(\n            AuctionStorage.Status.INITIALIZED == auction.status,\n            \"status != initialized\"\n        );\n        _auctionHasStarted(auction);\n        _auctionHasNotEnded(auction);\n    }\n\n    /**\n     * @dev Throws if auction has not started.\n     * @param auction storage params\n     */\n    function _auctionHasStarted(AuctionStorage.Auction storage auction)\n        private\n        view\n    {\n        require(auction.startTime > 0, \"start time is not set\");\n        require(block.timestamp >= auction.startTime, \"auction not started\");\n    }\n\n    /**\n     * @dev Throws if auction has ended.\n     * @param auction storage params\n     */\n    function _auctionHasNotEnded(AuctionStorage.Auction storage auction)\n        private\n        view\n    {\n        require(auction.endTime > 0, \"end time is not set\");\n        require(block.timestamp <= auction.endTime, \"auction has ended\");\n    }\n\n    /************************************************\n     *  PRICING\n     ***********************************************/\n\n    /**\n     * @notice returns the last price paid during the auction\n     * @param auction storage params\n     * @return price as 64x64 fixed point number\n     */\n    function _lastPrice64x64(AuctionStorage.Auction storage auction)\n        internal\n        view\n        returns (int128)\n    {\n        return auction.lastPrice64x64;\n    }\n\n    /**\n     * @notice calculates the current price using the price curve function\n     * @param auction storage params\n     * @return price as 64x64 fixed point number\n     */\n    function _priceCurve64x64(AuctionStorage.Auction storage auction)\n        internal\n        view\n        returns (int128)\n    {\n        uint256 startTime = auction.startTime;\n        uint256 totalTime = auction.endTime - auction.startTime;\n\n        int128 maxPrice64x64 = auction.maxPrice64x64;\n        int128 minPrice64x64 = auction.minPrice64x64;\n\n        /**\n         *\n         * price curve equation:\n         * assumes max price is always greater than min price\n         * assumes the time remaining is in the range of 0 and 1\n         * ------------------------------\n         * time_remaning_percent(t) = (t - time_start) / time_total\n         * price(t) = max_price - time_remaning_percent(t) * (max_price - min_price)\n         *\n         */\n\n        if (block.timestamp <= startTime) return maxPrice64x64;\n\n        uint256 elapsed = block.timestamp - startTime;\n        int128 timeRemaining64x64 = elapsed.divu(totalTime);\n\n        int128 x = maxPrice64x64.sub(minPrice64x64);\n        int128 y = timeRemaining64x64.mul(x);\n        return maxPrice64x64.sub(y);\n    }\n\n    /**\n     * @notice returns the current price established by the price curve if the auction\n     * is still ongoing, otherwise the last price paid is returned\n     * @param auction storage params\n     * @return price as 64x64 fixed point number\n     */\n    function _clearingPrice64x64(AuctionStorage.Auction storage auction)\n        internal\n        view\n        returns (int128)\n    {\n        if (\n            auction.status == AuctionStorage.Status.FINALIZED ||\n            auction.status == AuctionStorage.Status.PROCESSED ||\n            auction.status == AuctionStorage.Status.CANCELLED\n        ) {\n            return _lastPrice64x64(auction);\n        }\n        return _priceCurve64x64(auction);\n    }\n\n    /************************************************\n     *  WITHDRAW\n     ***********************************************/\n\n    /**\n     * @notice withdraws any amount(s) owed to the buyer (fill and/or refund)\n     * @param l auction storage layout\n     * @param epoch epoch id\n     */\n    function _withdraw(AuctionStorage.Layout storage l, uint64 epoch) internal {\n        (uint256 refund, uint256 fill) =\n            _previewWithdraw(l, false, epoch, msg.sender);\n\n        l.epochsByBuyer[msg.sender].remove(epoch);\n\n        // fetches the exercised value of the options\n        (bool expired, uint256 exercisedAmount) =\n            _getExerciseAmount(l, epoch, fill);\n\n        if (expired) {\n            if (exercisedAmount > 0) {\n                // if expired ITM, adjust refund by the amount exercised\n                refund += exercisedAmount;\n            }\n\n            // set fill to 0, buyer will not receive any long tokens\n            fill = 0;\n        }\n\n        if (fill > 0) {\n            // transfers long tokens to msg.sender\n            Pool.safeTransferFrom(\n                address(this),\n                msg.sender,\n                l.auctions[epoch].longTokenId,\n                fill,\n                \"\"\n            );\n        }\n\n        if (refund > 0) {\n            // transfers refunded premium to msg.sender\n            ERC20.safeTransfer(msg.sender, refund);\n        }\n\n        emit OrderWithdrawn(epoch, msg.sender, refund, fill);\n    }\n\n    /**\n     * @notice calculates amount(s) owed to the buyer\n     * @param epoch epoch id\n     * @param buyer address of buyer\n     * @return amount refunded\n     * @return amount filled\n     */\n    function _previewWithdraw(uint64 epoch, address buyer)\n        internal\n        returns (uint256, uint256)\n    {\n        AuctionStorage.Layout storage l = AuctionStorage.layout();\n        return _previewWithdraw(l, true, epoch, buyer);\n    }\n\n    /**\n     * @notice traverses the orderbook and returns the refund and fill amounts\n     * @param l auction storage layout\n     * @param epoch epoch id\n     * @param buyer address of buyer\n     * @return amount refunded\n     * @return amount filled\n     */\n    function _previewWithdraw(\n        AuctionStorage.Layout storage l,\n        bool isPreview,\n        uint64 epoch,\n        address buyer\n    ) private returns (uint256, uint256) {\n        AuctionStorage.Auction storage auction = l.auctions[epoch];\n        OrderBook.Index storage orderbook = l.orderbooks[epoch];\n\n        uint256 refund;\n        uint256 fill;\n\n        int128 lastPrice64x64 = _clearingPrice64x64(auction);\n\n        uint256 totalContractsSold;\n        uint256 next = orderbook._head();\n        uint256 length = orderbook._length();\n\n        // traverse the order book and return orders placed by the buyer\n        for (uint256 i = 1; i <= length; i++) {\n            OrderBook.Data memory data = orderbook._getOrderById(next);\n            next = orderbook._getNextOrder(next);\n\n            if (data.buyer == buyer) {\n                if (\n                    lastPrice64x64 < type(int128).max &&\n                    data.price64x64 >= lastPrice64x64\n                ) {\n                    // if the auction has not been cancelled, and the order price is greater than or\n                    // equal to the last price, fill the order and calculate the refund amount\n                    uint256 paid = data.price64x64.mulu(data.size);\n                    uint256 cost = lastPrice64x64.mulu(data.size);\n\n                    if (\n                        totalContractsSold + data.size >= auction.totalContracts\n                    ) {\n                        // if part of the current order exceeds the total contracts available, partially\n                        // fill the order, and refund the remainder\n                        uint256 remainder =\n                            auction.totalContracts - totalContractsSold;\n\n                        cost = lastPrice64x64.mulu(remainder);\n                        fill += remainder;\n                    } else {\n                        // otherwise, fill the entire order\n                        fill += data.size;\n                    }\n\n                    // the refund takes the difference between the amount paid and the \"true\" cost of\n                    // of the order. the \"true\" cost can be calculated when the clearing price has been\n                    // set.\n                    refund += paid - cost;\n                } else {\n                    // if last price >= type(int128).max, auction has been cancelled, only send refund\n                    // if price < last price, the bid is too low, only send refund\n                    refund += data.price64x64.mulu(data.size);\n                }\n\n                if (!isPreview) {\n                    // when a withdrawal is made, remove the order from the order book\n                    orderbook._remove(data.id);\n                }\n            }\n\n            totalContractsSold += data.size;\n        }\n\n        return (refund, fill);\n    }\n\n    /************************************************\n     *  FINALIZE AUCTION\n     ***********************************************/\n\n    /**\n     * @notice traverses the orderbook and checks if the auction has reached 100% utilization\n     * @param l auction storage layout\n     * @param epoch epoch id\n     * @return true if the auction has reached 100% utilization\n     */\n    function _processOrders(AuctionStorage.Layout storage l, uint64 epoch)\n        private\n        returns (bool)\n    {\n        OrderBook.Index storage orderbook = l.orderbooks[epoch];\n        AuctionStorage.Auction storage auction = l.auctions[epoch];\n\n        uint256 next = orderbook._head();\n        uint256 length = orderbook._length();\n\n        uint256 totalContracts = _getTotalContracts(auction);\n\n        if (auction.totalContracts <= 0) {\n            // sets totalContracts if this is the first bid.\n            auction.totalContracts = totalContracts;\n        }\n\n        uint256 totalContractsSold;\n        int128 lastPrice64x64;\n\n        // traverse the order book and sum the contracts sold until the utilization == 100% or\n        // the end of the orderbook has been reached.\n        for (uint256 i = 1; i <= length; i++) {\n            OrderBook.Data memory data = orderbook._getOrderById(next);\n            next = orderbook._getNextOrder(next);\n\n            // orders in the order book are sorted by price in a descending order. if the\n            // order price < clearing price the last order which should be accepeted has\n            // been reached.\n            if (data.price64x64 < _clearingPrice64x64(auction)) break;\n\n            // checks if utilization >= 100%\n            if (totalContractsSold + data.size >= totalContracts) {\n                auction.lastPrice64x64 = data.price64x64;\n                auction.totalContractsSold = totalContracts;\n                return true;\n            }\n\n            totalContractsSold += data.size;\n            lastPrice64x64 = data.price64x64;\n        }\n\n        /**\n         * sets the last price reached in the order book equal to the last price paid in the auction.\n         *\n         *\n         * Orderbook | price curve == 96\n         * ---------\n         * id -  price\n         * 0  -  100\n         * 1  -  97 --- last price\n         * 2  -  95\n         * */\n\n        auction.lastPrice64x64 = lastPrice64x64;\n        auction.totalContractsSold = totalContractsSold;\n        return false;\n    }\n\n    /**\n     * @notice determines whether the auction has reached finality. the end criteria for the auction are\n     * met if the auction has reached 100% utilization or the end time has been exceeded.\n     * @param l auction storage layout\n     * @param auction storage params\n     * @param epoch epoch id\n     */\n    function _finalizeAuction(\n        AuctionStorage.Layout storage l,\n        AuctionStorage.Auction storage auction,\n        uint64 epoch\n    ) internal {\n        if (_processOrders(l, epoch) || block.timestamp > auction.endTime) {\n            auction.status = AuctionStorage.Status.FINALIZED;\n            emit AuctionStatusSet(epoch, auction.status);\n        }\n    }\n\n    /************************************************\n     *  VIEW\n     ***********************************************/\n\n    /**\n     * @notice calculates the total number of contracts that can be sold during the auction\n     * @param auction storage params\n     * @return total contracts available\n     */\n    function _getTotalContracts(AuctionStorage.Auction storage auction)\n        internal\n        view\n        returns (uint256)\n    {\n        if (auction.totalContracts <= 0) {\n            // if the total contracts has not been set for the auction, the vault contract\n            // will be queried and the amount will be determined from the collateral in the vault.\n\n            uint256 totalCollateral = Vault.totalCollateral();\n            int128 strike64x64 = auction.strike64x64;\n\n            return\n                totalCollateral.fromContractsToCollateral(\n                    isCall,\n                    baseDecimals,\n                    strike64x64\n                );\n        }\n\n        return auction.totalContracts;\n    }\n\n    /************************************************\n     *  PURCHASE HELPERS\n     ***********************************************/\n\n    /**\n     * @notice checks whether the limit order parameters are valid and returns the cost\n     * @param l auction storage layout\n     * @param price64x64 max price as 64x64 fixed point number\n     * @param size amount of contracts\n     * @return cost of the order given the size and price\n     */\n    function _validateLimitOrder(\n        AuctionStorage.Layout storage l,\n        int128 price64x64,\n        uint256 size\n    ) internal view returns (uint256) {\n        require(price64x64 > 0, \"price <= 0\");\n        require(size >= l.minSize, \"size < minimum\");\n\n        uint256 cost = price64x64.mulu(size);\n        return cost;\n    }\n\n    /**\n     * @notice checks whether the market order parameters are valid and returns the price and cost\n     * @param l auction storage layout\n     * @param auction storage params\n     * @param size amount of contracts\n     * @param maxCost max cost of buyer is willing to pay\n     * @return price established by the price curve\n     * @return cost of the order given the size and price\n     */\n    function _validateMarketOrder(\n        AuctionStorage.Layout storage l,\n        AuctionStorage.Auction storage auction,\n        uint256 size,\n        uint256 maxCost\n    ) internal view returns (int128, uint256) {\n        require(size >= l.minSize, \"size < minimum\");\n\n        int128 price64x64 = _priceCurve64x64(auction);\n        uint256 cost = price64x64.mulu(size);\n\n        require(maxCost >= cost, \"cost > maxCost\");\n        return (price64x64, cost);\n    }\n\n    /**\n     * @notice transfers the premium to the buyer if a refund is due, ortherwise, pull funds\n     * from buyer if funds are owed to the auction contract.\n     * @param credited amount already paid by the buyer\n     * @param cost total amount which must be paid by the buyer\n     * @param buyer account being debited or credited\n     */\n    function _transferAssets(\n        uint256 credited,\n        uint256 cost,\n        address buyer\n    ) internal {\n        if (credited > cost) {\n            // refund buyer the amount overpaid\n            ERC20.safeTransfer(buyer, credited - cost);\n        } else if (cost > credited) {\n            // an approve() by the msg.sender is required beforehand\n            ERC20.safeTransferFrom(buyer, address(this), cost - credited);\n        }\n    }\n\n    /**\n     * @notice checks whether the market order parameters are valid and returns the price and cost\n     * @param l auction storage layout\n     * @param auction storage params\n     * @param epoch epoch id\n     * @param price64x64 max price as 64x64 fixed point number\n     * @param size amount of contracts\n     * @param isLimitOrder true, if the order is a limit order\n     */\n    function _addOrder(\n        AuctionStorage.Layout storage l,\n        AuctionStorage.Auction storage auction,\n        uint64 epoch,\n        int128 price64x64,\n        uint256 size,\n        bool isLimitOrder\n    ) internal {\n        l.epochsByBuyer[msg.sender].add(epoch);\n\n        uint256 id = l.orderbooks[epoch]._insert(price64x64, size, msg.sender);\n\n        if (block.timestamp >= auction.startTime) {\n            _finalizeAuction(l, auction, epoch);\n        }\n\n        emit OrderAdded(epoch, id, msg.sender, price64x64, size, isLimitOrder);\n    }\n\n    /**\n     * @notice wraps ETH sent to the contract and credits the amount, if the collateral asset\n     * is not WETH, the transaction will revert\n     * @param amount total collateral deposited\n     * @return credited amount\n     */\n    function _wrapNativeToken(uint256 amount) internal returns (uint256) {\n        uint256 credit;\n\n        if (msg.value > 0) {\n            require(address(ERC20) == address(WETH), \"collateral != wETH\");\n\n            if (msg.value > amount) {\n                // if the ETH amount is greater than the amount needed, it will be sent\n                // back to the msg.sender\n                unchecked {\n                    (bool success, ) =\n                        payable(msg.sender).call{value: msg.value - amount}(\"\");\n\n                    require(success, \"ETH refund failed\");\n\n                    credit = amount;\n                }\n            } else {\n                credit = msg.value;\n            }\n\n            WETH.deposit{value: credit}();\n        }\n\n        return credit;\n    }\n\n    /**\n     * @notice pull token from user, send to exchangeHelper trigger a trade from\n     * ExchangeHelper, and credits the amount\n     * @param Exchange ExchangeHelper contract interface\n     * @param s swap arguments\n     * @param tokenOut token to swap for. should always equal to the collateral asset\n     * @return credited amount\n     */\n    function _swapForPoolTokens(\n        IExchangeHelper Exchange,\n        IExchangeHelper.SwapArgs calldata s,\n        address tokenOut\n    ) internal returns (uint256) {\n        if (msg.value > 0) {\n            require(s.tokenIn == address(WETH), \"tokenIn != wETH\");\n            WETH.deposit{value: msg.value}();\n            WETH.safeTransfer(address(Exchange), msg.value);\n        }\n\n        if (s.amountInMax > 0) {\n            IERC20(s.tokenIn).safeTransferFrom(\n                msg.sender,\n                address(Exchange),\n                s.amountInMax\n            );\n        }\n\n        uint256 amountCredited =\n            Exchange.swapWithToken(\n                s.tokenIn,\n                tokenOut,\n                s.amountInMax + msg.value,\n                s.callee,\n                s.allowanceTarget,\n                s.data,\n                s.refundAddress\n            );\n\n        require(\n            amountCredited >= s.amountOutMin,\n            \"not enough output from trade\"\n        );\n\n        return amountCredited;\n    }\n\n    /************************************************\n     * HELPERS\n     ***********************************************/\n\n    /**\n     * @notice cancels all orders and finalizes the auction\n     * @param auction the auction to cancel\n     */\n    function _cancel(AuctionStorage.Auction storage auction, uint64 epoch)\n        internal\n    {\n        auction.lastPrice64x64 = type(int128).max;\n        auction.status = AuctionStorage.Status.CANCELLED;\n        auction.totalPremiums = 0;\n        emit AuctionStatusSet(epoch, auction.status);\n    }\n\n    /**\n     * @notice calculates the expected proceeds of the option if it has expired\n     * @param epoch epoch id\n     * @param size amount of contracts\n     * @return true if the option has expired\n     * @return the exercised amount\n     */\n    function _getExerciseAmount(\n        AuctionStorage.Layout storage l,\n        uint64 epoch,\n        uint256 size\n    ) private view returns (bool, uint256) {\n        AuctionStorage.Auction storage auction = l.auctions[epoch];\n\n        uint64 expiry = auction.expiry;\n        int128 strike64x64 = auction.strike64x64;\n\n        if (block.timestamp < expiry) return (false, 0);\n\n        int128 spot64x64 = Pool.getPriceAfter64x64(expiry);\n        uint256 amount;\n\n        if (isCall && spot64x64 > strike64x64) {\n            amount = spot64x64.sub(strike64x64).div(spot64x64).mulu(size);\n        } else if (!isCall && strike64x64 > spot64x64) {\n            uint256 value = strike64x64.sub(spot64x64).mulu(size);\n\n            // converts the value to the base asset amount, this is particularly important where the\n            // the decimals of the underlying are different from the base (e.g. wBTC/DAI)\n            amount = OptionMath.toBaseTokenAmount(\n                underlyingDecimals,\n                baseDecimals,\n                value\n            );\n        }\n\n        return (true, amount);\n    }\n}"
    }
  ]
}