{
  "Title": "[H-12] TOFT `removeCollateral` can be used to steal all the balance",
  "Content": "\n[`removeCollateral`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/BaseTOFT.sol#L190) -> [`remove`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/BaseTOFT.sol#L512) message pathway can be used to steal all the balance of the [`TapiocaOFT`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/TapiocaOFT.sol) and [`mTapiocaOFT`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/mTapiocaOFT.sol) tokens in case when their underlying tokens is native.\nTOFTs that hold native tokens are deployed with [erc20 address](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/TapiocaOFT.sol#L35) set to address zero, so while [minting you need to transfer value](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/TapiocaOFT.sol#L74).\n\n### Proof of Concept\n\nThe attack needs to be executed by invoking the [`removeCollateral`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/BaseTOFT.sol#L190) function from any chain to chain on which the underlying balance resides, e.g. host chain of the TOFT.\nWhen the message is [received on the remote chain](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTMarketModule.sol#L204-L258), I have placed in the comments below what are the params that need to be passed to execute the attack.\n\n<details>\n\n```solidity\n    function remove(bytes memory _payload) public {\n    (\n        ,\n        ,\n        address to,\n        ,\n        ITapiocaOFT.IRemoveParams memory removeParams,\n        ICommonData.IWithdrawParams memory withdrawParams,\n        ICommonData.IApproval[] memory approvals\n    ) = abi.decode(\n        _payload,\n        (\n            uint16,\n            address,\n            address,\n            bytes32,\n            ITapiocaOFT.IRemoveParams,\n            ICommonData.IWithdrawParams,\n            ICommonData.IApproval[]\n        )\n    );\n    // approvals can be an empty array so this is skipped\n    if (approvals.length > 0) {\n        _callApproval(approvals);\n    }\n\n    // removeParams.market and removeParams.share don't matter \n    approve(removeParams.market, removeParams.share);\n    // removeParams.market just needs to be deployed by the attacker and do nothing, it is enough to implement IMarket interface\n    IMarket(removeParams.market).removeCollateral(\n        to,\n        to,\n        removeParams.share\n    );\n    \n    // withdrawParams.withdraw =  true to enter the if block\n    if (withdrawParams.withdraw) {\n        // Attackers removeParams.market contract needs to have yieldBox() function and it can return any address\n        address ybAddress = IMarket(removeParams.market).yieldBox();\n        // Attackers removeParams.market needs to have collateralId() function and it can return any uint256\n        uint256 assetId = IMarket(removeParams.market).collateralId();\n        \n        // removeParams.marketHelper is a malicious contract deployed by the attacker which is being transferred all the balance\n        // withdrawParams.withdrawLzFeeAmount needs to be precomputed by the attacker to match the balance of TapiocaOFT\n        IMagnetar(removeParams.marketHelper).withdrawToChain{\n                value: withdrawParams.withdrawLzFeeAmount // This is not validated on the sending side so it can be any value\n            }(\n            ybAddress,\n            to,\n            assetId,\n            withdrawParams.withdrawLzChainId,\n            LzLib.addressToBytes32(to),\n            IYieldBoxBase(ybAddress).toAmount(\n                assetId,\n                removeParams.share,\n                false\n            ),\n            removeParams.share,\n            withdrawParams.withdrawAdapterParams,\n            payable(to),\n            withdrawParams.withdrawLzFeeAmount\n        );\n    }\n}\n```\n\n</details>\n\nNeither `removeParams.marketHelper` or `withdrawParams.withdrawLzFeeAmount` are validated on the sending side so the former can be the address of a malicious contract and the latter can be the TOFT's balance of gas token.\n\nThis type of attack is possible because the `msg.sender` in `IMagnetar(removeParams.marketHelper).withdrawToChain` is the address of the TOFT contract which holds all the balances.\n\nThis is because:\n\n1.  Relayer submits the message to [`lzReceive`](https://github.com/Tapioca-DAO/tapioca-sdk-audit/blob/90d1e8a16ebe278e86720bc9b69596f74320e749/src/contracts/lzApp/LzApp.sol#L35) so he is the `msg.sender`.\n2.  Inside the [`_blockingLzReceive`](https://github.com/Tapioca-DAO/tapioca-sdk-audit/blob/90d1e8a16ebe278e86720bc9b69596f74320e749/src/contracts/lzApp/NonblockingLzApp.sol#L25) there is a call into its own public function so the `msg.sender` is the [address of the contract](https://github.com/Tapioca-DAO/tapioca-sdk-audit/blob/90d1e8a16ebe278e86720bc9b69596f74320e749/src/contracts/lzApp/NonblockingLzApp.sol#L39).\n3.  Inside the `_nonBlockingLzReceive` there is [delegatecall](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/BaseTOFT.sol#L411) into a corresponding module which preserves the `msg.sender` which is the address of the TOFT.\n4.  Inside the module there is a call to [withdrawToChain](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTMarketModule.sol#L239) and here the `msg.sender` is the address of the TOFT contract, so we can maliciously transfer all the balance of the TOFT.\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nIt's hard to recommend a simple fix since as I pointed out in my other issues the airdropping logic has many flaws.\nOne of the ways of tackling this issue is during the [`removeCollateral`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/BaseTOFT.sol#L190) to:\n\n*   Do not allow `adapterParams` params to be passed as bytes but rather as `gasLimit` and `airdroppedAmount`, from which you would encode either `adapterParamsV1` or `adapterParamsV2`.\n*   And then on the receiving side check and send with value only the amount the user has airdropped.\n\n**[0xRektora (Tapioca) confirmed and commented](https://github.com/code-423n4/2023-07-tapioca-findings/issues/1293#issuecomment-1703000096):**\n > Related to https://github.com/code-423n4/2023-07-tapioca-findings/issues/1290\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/tOFT/BaseTOFT.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"./BaseTOFTStorage.sol\";\n\n//TOFT MODULES\nimport \"./modules/BaseTOFTLeverageModule.sol\";\nimport \"./modules/BaseTOFTStrategyModule.sol\";\nimport \"./modules/BaseTOFTMarketModule.sol\";\nimport \"./modules/BaseTOFTOptionsModule.sol\";\n\n/// @title BaseTOFT contract \n/// @notice Common tOFT capabilitites\n/// @dev all LayerZero methods are defined here\ncontract BaseTOFT is BaseTOFTStorage, ERC20Permit {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    enum Module {\n        Leverage,\n        Strategy,\n        Market,\n        Options\n    }\n\n    /// @notice returns the leverage module\n    BaseTOFTLeverageModule public leverageModule;\n\n    /// @notice returns the Strategy module\n    BaseTOFTStrategyModule public strategyModule;\n\n    /// @notice returns the Market module\n    BaseTOFTMarketModule public marketModule;\n\n    /// @notice returns the Options module\n    BaseTOFTOptionsModule public optionsModule;\n\n    // ******************//\n    // *** MODIFIERS *** //\n    // ***************** //\n    /// @notice Require that the caller is on the host chain of the ERC20.\n    modifier onlyHostChain() {\n        require(block.chainid == hostChainID, \"TOFT_host\");\n        _;\n    }\n\n    constructor(\n        address _lzEndpoint,\n        address _erc20,\n        IYieldBoxBase _yieldBox,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal,\n        uint256 _hostChainID,\n        address payable _leverageModule,\n        address payable _strategyModule,\n        address payable _marketModule,\n        address payable _optionsModule\n    )\n        BaseTOFTStorage(\n            _lzEndpoint,\n            _erc20,\n            _yieldBox,\n            _name,\n            _symbol,\n            _decimal,\n            _hostChainID\n        )\n        ERC20Permit(string(abi.encodePacked(\"TapiocaOFT-\", _name)))\n    {\n        leverageModule = BaseTOFTLeverageModule(_leverageModule);\n        strategyModule = BaseTOFTStrategyModule(_strategyModule);\n        marketModule = BaseTOFTMarketModule(_marketModule);\n        optionsModule = BaseTOFTOptionsModule(_optionsModule);\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice decimal number of the ERC20\n    function decimals() public view override returns (uint8) {\n        if (_decimalCache == 0) return 18; //temporary fix for LZ _sharedDecimals check\n        return _decimalCache;\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice triggers a sendFrom to another layer from destination\n    /// @param lzDstChainId LZ destination id\n    /// @param airdropAdapterParams airdrop params\n    /// @param zroPaymentAddress ZRO payment address\n    /// @param amount amount to send back\n    /// @param sendFromData data needed to trigger sendFrom on destination\n    /// @param approvals approvals array\n    function triggerSendFrom(\n        uint16 lzDstChainId,\n        bytes calldata airdropAdapterParams,\n        address zroPaymentAddress,\n        uint256 amount,\n        ISendFrom.LzCallParams calldata sendFromData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Options,\n            abi.encodeWithSelector(\n                BaseTOFTOptionsModule.triggerSendFrom.selector,\n                lzDstChainId,\n                airdropAdapterParams,\n                zroPaymentAddress,\n                amount,\n                sendFromData,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice Exercise an oTAP position\n    /// @param optionsData oTap exerciseOptions data\n    /// @param lzData data needed for the cross chain transer\n    /// @param tapSendData needed for withdrawing Tap token\n    /// @param approvals array\n    function exerciseOption(\n        ITapiocaOptionsBrokerCrossChain.IExerciseOptionsData\n            calldata optionsData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZData calldata lzData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData\n            calldata tapSendData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Options,\n            abi.encodeWithSelector(\n                BaseTOFTOptionsModule.exerciseOption.selector,\n                optionsData,\n                lzData,\n                tapSendData,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice inits a multiHopSellCollateral call\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param swapData Swap data used on destination chain for swapping USDO to the underlying TOFT token\n    /// @param lzData LayerZero specific data\n    /// @param externalData External contracts used for the cross chain operation\n    /// @param airdropAdapterParams default or airdrop adapter params\n    /// @param approvals array\n    function initMultiSell(\n        address from,\n        uint256 share,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData,\n        bytes calldata airdropAdapterParams,\n        ICommonData.IApproval[] memory approvals\n    ) external payable {\n        _executeModule(\n            Module.Leverage,\n            abi.encodeWithSelector(\n                BaseTOFTLeverageModule.initMultiSell.selector,\n                from,\n                share,\n                swapData,\n                lzData,\n                externalData,\n                airdropAdapterParams,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice calls removeCollateral on another layer\n    /// @param from sending address\n    /// @param to receiver address\n    /// @param lzDstChainId LayerZero destination chain id\n    /// @param zroPaymentAddress LayerZero ZRO payment address\n    /// @param withdrawParams withdrawTo specific params\n    /// @param removeParams removeAsset specific params\n    /// @param approvals approvals specific params\n    /// @param adapterParams LZ adapter params\n    function removeCollateral(\n        address from,\n        address to,\n        uint16 lzDstChainId,\n        address zroPaymentAddress,\n        ICommonData.IWithdrawParams calldata withdrawParams,\n        ITapiocaOFT.IRemoveParams calldata removeParams,\n        ICommonData.IApproval[] calldata approvals,\n        bytes calldata adapterParams\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                BaseTOFTMarketModule.removeCollateral.selector,\n                from,\n                to,\n                lzDstChainId,\n                zroPaymentAddress,\n                withdrawParams,\n                removeParams,\n                approvals,\n                adapterParams\n            ),\n            false\n        );\n    }\n\n    /// @notice sends TOFT to a specific strategy available on another layer\n    /// @param from the sender address\n    /// @param to the receiver address\n    /// @param amount the transferred amount\n    /// @param assetId the destination YieldBox asset id\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param options the operation data\n    function sendToStrategy(\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share,\n        uint256 assetId,\n        uint16 lzDstChainId,\n        ICommonData.ISendOptions calldata options\n    ) external payable {\n        _executeModule(\n            Module.Strategy,\n            abi.encodeWithSelector(\n                BaseTOFTStrategyModule.sendToStrategy.selector,\n                from,\n                to,\n                amount,\n                share,\n                assetId,\n                lzDstChainId,\n                options\n            ),\n            false\n        );\n    }\n\n    /// @notice extracts TOFT from a specific strategy available on another layer\n    /// @param from the sender address\n    /// @param amount the transferred amount\n    /// @param assetId the destination YieldBox asset id\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param zroPaymentAddress LayerZero ZRO payment address\n    /// @param airdropAdapterParam the LayerZero aidrop adapter params\n    function retrieveFromStrategy(\n        address from,\n        uint256 amount,\n        uint256 share,\n        uint256 assetId,\n        uint16 lzDstChainId,\n        address zroPaymentAddress,\n        bytes memory airdropAdapterParam\n    ) external payable {\n        _executeModule(\n            Module.Strategy,\n            abi.encodeWithSelector(\n                BaseTOFTStrategyModule.retrieveFromStrategy.selector,\n                from,\n                amount,\n                share,\n                assetId,\n                lzDstChainId,\n                zroPaymentAddress,\n                airdropAdapterParam\n            ),\n            false\n        );\n    }\n\n    /// @notice sends TOFT to a specific chain and performs a borrow operation\n    /// @param from the sender address\n    /// @param to the receiver address\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param airdropAdapterParams the LayerZero aidrop adapter params\n    /// @param borrowParams the borrow operation data\n    /// @param withdrawParams the withdraw operation data\n    /// @param options the cross chain send operation data\n    /// @param approvals the cross chain approval operation data\n    function sendToYBAndBorrow(\n        address from,\n        address to,\n        uint16 lzDstChainId,\n        bytes calldata airdropAdapterParams,\n        ITapiocaOFT.IBorrowParams calldata borrowParams,\n        ICommonData.IWithdrawParams calldata withdrawParams,\n        ICommonData.ISendOptions calldata options,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                BaseTOFTMarketModule.sendToYBAndBorrow.selector,\n                from,\n                to,\n                lzDstChainId,\n                airdropAdapterParams,\n                borrowParams,\n                withdrawParams,\n                options,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice sends TOFT to a specific chain and performs a leverage down operation\n    /// @param amount the amount to use\n    /// @param leverageFor the receiver address\n    /// @param lzData LZ specific data\n    /// @param swapData ISwapper specific data\n    /// @param externalData external contracts used for the flow\n    function sendForLeverage(\n        uint256 amount,\n        address leverageFor,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData\n    ) external payable {\n        _executeModule(\n            Module.Leverage,\n            abi.encodeWithSelector(\n                BaseTOFTLeverageModule.sendForLeverage.selector,\n                amount,\n                leverageFor,\n                lzData,\n                swapData,\n                externalData\n            ),\n            false\n        );\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n\n    //---internal-\n    function _wrap(\n        address _fromAddress,\n        address _toAddress,\n        uint256 _amount\n    ) internal virtual {\n        if (_fromAddress != msg.sender) {\n            require(\n                allowance(_fromAddress, msg.sender) >= _amount,\n                \"TOFT_allowed\"\n            );\n        }\n        IERC20(erc20).safeTransferFrom(_fromAddress, address(this), _amount);\n        _mint(_toAddress, _amount);\n    }\n\n    function _wrapNative(address _toAddress) internal virtual {\n        require(msg.value > 0, \"TOFT_0\");\n        _mint(_toAddress, msg.value);\n    }\n\n    function _unwrap(address _toAddress, uint256 _amount) internal virtual {\n        _burn(msg.sender, _amount);\n\n        if (erc20 == address(0)) {\n            _safeTransferETH(_toAddress, _amount);\n        } else {\n            IERC20(erc20).safeTransfer(_toAddress, _amount);\n        }\n    }\n\n    //---private---\n    function _safeTransferETH(address to, uint256 amount) internal {\n        (bool sent, ) = to.call{value: amount}(\"\");\n        require(sent, \"TOFT_failed\");\n    }\n\n    function _extractModule(Module _module) private view returns (address) {\n        address module;\n        if (_module == Module.Leverage) {\n            module = address(leverageModule);\n        } else if (_module == Module.Strategy) {\n            module = address(strategyModule);\n        } else if (_module == Module.Market) {\n            module = address(marketModule);\n        } else if (_module == Module.Options) {\n            module = address(optionsModule);\n        }\n\n        if (module == address(0)) {\n            revert(\"TOFT_module\");\n        }\n\n        return module;\n    }\n\n    function _executeModule(\n        Module _module,\n        bytes memory _data,\n        bool _forwardRevert\n    ) private returns (bool success, bytes memory returnData) {\n        success = true;\n        address module = _extractModule(_module);\n\n        (success, returnData) = module.delegatecall(_data);\n        if (!success && !_forwardRevert) {\n            revert(_getRevertMsg(returnData));\n        }\n    }\n\n    function _executeOnDestination(\n        Module _module,\n        bytes memory _data,\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) private {\n        (bool success, bytes memory returnData) = _executeModule(\n            _module,\n            _data,\n            true\n        );\n        if (!success) {\n            _storeFailedMessage(\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload,\n                returnData\n            );\n        }\n    }\n\n    //---LZ---\n    function _nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual override {\n        uint256 packetType = _payload.toUint256(0);\n\n        if (packetType == PT_YB_SEND_STRAT) {\n            _executeOnDestination(\n                Module.Strategy,\n                abi.encodeWithSelector(\n                    BaseTOFTStrategyModule.strategyDeposit.selector,\n                    strategyModule,\n                    _srcChainId,\n                    _srcAddress,\n                    _nonce,\n                    _payload,\n                    IERC20(address(this))\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_YB_RETRIEVE_STRAT) {\n            _executeOnDestination(\n                Module.Strategy,\n                abi.encodeWithSelector(\n                    BaseTOFTStrategyModule.strategyWithdraw.selector,\n                    _srcChainId,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_LEVERAGE_MARKET_DOWN) {\n            _executeOnDestination(\n                Module.Leverage,\n                abi.encodeWithSelector(\n                    BaseTOFTLeverageModule.leverageDown.selector,\n                    leverageModule,\n                    _srcChainId,\n                    _srcAddress,\n                    _nonce,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_YB_SEND_SGL_BORROW) {\n            _executeOnDestination(\n                Module.Market,\n                abi.encodeWithSelector(\n                    BaseTOFTMarketModule.borrow.selector,\n                    marketModule,\n                    _srcChainId,\n                    _srcAddress,\n                    _nonce,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_MARKET_REMOVE_COLLATERAL) {\n            _executeOnDestination(\n                Module.Market,\n                abi.encodeWithSelector(\n                    BaseTOFTMarketModule.remove.selector,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_MARKET_MULTIHOP_SELL) {\n            _executeOnDestination(\n                Module.Leverage,\n                abi.encodeWithSelector(\n                    BaseTOFTLeverageModule.multiHop.selector,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_TAP_EXERCISE) {\n            _executeOnDestination(\n                Module.Options,\n                abi.encodeWithSelector(\n                    BaseTOFTOptionsModule.exercise.selector,\n                    _srcChainId,\n                    _srcAddress,\n                    _nonce,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_SEND_FROM) {\n            _executeOnDestination(\n                Module.Options,\n                abi.encodeWithSelector(\n                    BaseTOFTOptionsModule.sendFromDestination.selector,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else {\n            packetType = _payload.toUint8(0);\n            if (packetType == PT_SEND) {\n                _sendAck(_srcChainId, _srcAddress, _nonce, _payload);\n            } else if (packetType == PT_SEND_AND_CALL) {\n                _sendAndCallAck(_srcChainId, _srcAddress, _nonce, _payload);\n            } else {\n                revert(\"TOFT_packet\");\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/tOFT/TapiocaOFT.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\nimport \"./BaseTOFT.sol\";\n\n/*\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n*/\n\n/// @title tOFT contract\n/// @notice tOFT wrapper contract\n/// @dev transforms a normal ERC20 or the native gas token into an OFTV2 type contract\n///      - wrapping & unwrapping of the ERC20/the gas token can only happen on the host chain\ncontract TapiocaOFT is BaseTOFT {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n\n    /// @notice creates a new TapiocaOFT\n    /// @param _lzEndpoint LayerZero endpoint address\n    /// @param _erc20 true the underlying ERC20 address\n    /// @param _yieldBox the YieldBox address\n    /// @param _name the TOFT name\n    /// @param _symbol the TOFT symbol\n    /// @param _decimal the TOFT decimal\n    /// @param _hostChainID the TOFT host chain LayerZero id\n    constructor(\n        address _lzEndpoint,\n        address _erc20,\n        IYieldBoxBase _yieldBox,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal,\n        uint256 _hostChainID,\n        address payable _leverageModule,\n        address payable _strategyModule,\n        address payable _marketModule,\n        address payable _optionsModule\n    )\n        BaseTOFT(\n            _lzEndpoint,\n            _erc20,\n            _yieldBox,\n            _name,\n            _symbol,\n            _decimal,\n            _hostChainID,\n            _leverageModule,\n            _strategyModule,\n            _marketModule,\n            _optionsModule\n        )\n    {}\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice Wrap an ERC20 with a 1:1 ratio with a fee if existing.\n    /// @dev Since it can be executed only on the main chain, if an address exists on the OP chain it will not allowed to wrap.\n    /// @param _fromAddress The address to wrap from.\n    /// @param _toAddress The address to wrap the ERC20 to.\n    /// @param _amount The amount of ERC20 to wrap.\n    function wrap(\n        address _fromAddress,\n        address _toAddress,\n        uint256 _amount\n    ) external payable onlyHostChain {\n        if (erc20 == address(0)) {\n            _wrapNative(_toAddress);\n        } else {\n            _wrap(_fromAddress, _toAddress, _amount);\n        }\n    }\n\n    /// @notice Unwrap an ERC20/Native with a 1:1 ratio. Called only on host chain.\n    /// @param _toAddress The address to unwrap the tokens to.\n    /// @param _amount The amount of tokens to unwrap.\n\n    function unwrap(\n        address _toAddress,\n        uint256 _amount\n    ) external onlyHostChain {\n        _unwrap(_toAddress, _amount);\n    }\n}"
    },
    {
      "filename": "contracts/tOFT/BaseTOFT.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"./BaseTOFTStorage.sol\";\n\n//TOFT MODULES\nimport \"./modules/BaseTOFTLeverageModule.sol\";\nimport \"./modules/BaseTOFTStrategyModule.sol\";\nimport \"./modules/BaseTOFTMarketModule.sol\";\nimport \"./modules/BaseTOFTOptionsModule.sol\";\n\n/// @title BaseTOFT contract \n/// @notice Common tOFT capabilitites\n/// @dev all LayerZero methods are defined here\ncontract BaseTOFT is BaseTOFTStorage, ERC20Permit {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    enum Module {\n        Leverage,\n        Strategy,\n        Market,\n        Options\n    }\n\n    /// @notice returns the leverage module\n    BaseTOFTLeverageModule public leverageModule;\n\n    /// @notice returns the Strategy module\n    BaseTOFTStrategyModule public strategyModule;\n\n    /// @notice returns the Market module\n    BaseTOFTMarketModule public marketModule;\n\n    /// @notice returns the Options module\n    BaseTOFTOptionsModule public optionsModule;\n\n    // ******************//\n    // *** MODIFIERS *** //\n    // ***************** //\n    /// @notice Require that the caller is on the host chain of the ERC20.\n    modifier onlyHostChain() {\n        require(block.chainid == hostChainID, \"TOFT_host\");\n        _;\n    }\n\n    constructor(\n        address _lzEndpoint,\n        address _erc20,\n        IYieldBoxBase _yieldBox,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal,\n        uint256 _hostChainID,\n        address payable _leverageModule,\n        address payable _strategyModule,\n        address payable _marketModule,\n        address payable _optionsModule\n    )\n        BaseTOFTStorage(\n            _lzEndpoint,\n            _erc20,\n            _yieldBox,\n            _name,\n            _symbol,\n            _decimal,\n            _hostChainID\n        )\n        ERC20Permit(string(abi.encodePacked(\"TapiocaOFT-\", _name)))\n    {\n        leverageModule = BaseTOFTLeverageModule(_leverageModule);\n        strategyModule = BaseTOFTStrategyModule(_strategyModule);\n        marketModule = BaseTOFTMarketModule(_marketModule);\n        optionsModule = BaseTOFTOptionsModule(_optionsModule);\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice decimal number of the ERC20\n    function decimals() public view override returns (uint8) {\n        if (_decimalCache == 0) return 18; //temporary fix for LZ _sharedDecimals check\n        return _decimalCache;\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice triggers a sendFrom to another layer from destination\n    /// @param lzDstChainId LZ destination id\n    /// @param airdropAdapterParams airdrop params\n    /// @param zroPaymentAddress ZRO payment address\n    /// @param amount amount to send back\n    /// @param sendFromData data needed to trigger sendFrom on destination\n    /// @param approvals approvals array\n    function triggerSendFrom(\n        uint16 lzDstChainId,\n        bytes calldata airdropAdapterParams,\n        address zroPaymentAddress,\n        uint256 amount,\n        ISendFrom.LzCallParams calldata sendFromData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Options,\n            abi.encodeWithSelector(\n                BaseTOFTOptionsModule.triggerSendFrom.selector,\n                lzDstChainId,\n                airdropAdapterParams,\n                zroPaymentAddress,\n                amount,\n                sendFromData,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice Exercise an oTAP position\n    /// @param optionsData oTap exerciseOptions data\n    /// @param lzData data needed for the cross chain transer\n    /// @param tapSendData needed for withdrawing Tap token\n    /// @param approvals array\n    function exerciseOption(\n        ITapiocaOptionsBrokerCrossChain.IExerciseOptionsData\n            calldata optionsData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZData calldata lzData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData\n            calldata tapSendData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Options,\n            abi.encodeWithSelector(\n                BaseTOFTOptionsModule.exerciseOption.selector,\n                optionsData,\n                lzData,\n                tapSendData,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice inits a multiHopSellCollateral call\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param swapData Swap data used on destination chain for swapping USDO to the underlying TOFT token\n    /// @param lzData LayerZero specific data\n    /// @param externalData External contracts used for the cross chain operation\n    /// @param airdropAdapterParams default or airdrop adapter params\n    /// @param approvals array\n    function initMultiSell(\n        address from,\n        uint256 share,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData,\n        bytes calldata airdropAdapterParams,\n        ICommonData.IApproval[] memory approvals\n    ) external payable {\n        _executeModule(\n            Module.Leverage,\n            abi.encodeWithSelector(\n                BaseTOFTLeverageModule.initMultiSell.selector,\n                from,\n                share,\n                swapData,\n                lzData,\n                externalData,\n                airdropAdapterParams,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice calls removeCollateral on another layer\n    /// @param from sending address\n    /// @param to receiver address\n    /// @param lzDstChainId LayerZero destination chain id\n    /// @param zroPaymentAddress LayerZero ZRO payment address\n    /// @param withdrawParams withdrawTo specific params\n    /// @param removeParams removeAsset specific params\n    /// @param approvals approvals specific params\n    /// @param adapterParams LZ adapter params\n    function removeCollateral(\n        address from,\n        address to,\n        uint16 lzDstChainId,\n        address zroPaymentAddress,\n        ICommonData.IWithdrawParams calldata withdrawParams,\n        ITapiocaOFT.IRemoveParams calldata removeParams,\n        ICommonData.IApproval[] calldata approvals,\n        bytes calldata adapterParams\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                BaseTOFTMarketModule.removeCollateral.selector,\n                from,\n                to,\n                lzDstChainId,\n                zroPaymentAddress,\n                withdrawParams,\n                removeParams,\n                approvals,\n                adapterParams\n            ),\n            false\n        );\n    }\n\n    /// @notice sends TOFT to a specific strategy available on another layer\n    /// @param from the sender address\n    /// @param to the receiver address\n    /// @param amount the transferred amount\n    /// @param assetId the destination YieldBox asset id\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param options the operation data\n    function sendToStrategy(\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share,\n        uint256 assetId,\n        uint16 lzDstChainId,\n        ICommonData.ISendOptions calldata options\n    ) external payable {\n        _executeModule(\n            Module.Strategy,\n            abi.encodeWithSelector(\n                BaseTOFTStrategyModule.sendToStrategy.selector,\n                from,\n                to,\n                amount,\n                share,\n                assetId,\n                lzDstChainId,\n                options\n            ),\n            false\n        );\n    }\n\n    /// @notice extracts TOFT from a specific strategy available on another layer\n    /// @param from the sender address\n    /// @param amount the transferred amount\n    /// @param assetId the destination YieldBox asset id\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param zroPaymentAddress LayerZero ZRO payment address\n    /// @param airdropAdapterParam the LayerZero aidrop adapter params\n    function retrieveFromStrategy(\n        address from,\n        uint256 amount,\n        uint256 share,\n        uint256 assetId,\n        uint16 lzDstChainId,\n        address zroPaymentAddress,\n        bytes memory airdropAdapterParam\n    ) external payable {\n        _executeModule(\n            Module.Strategy,\n            abi.encodeWithSelector(\n                BaseTOFTStrategyModule.retrieveFromStrategy.selector,\n                from,\n                amount,\n                share,\n                assetId,\n                lzDstChainId,\n                zroPaymentAddress,\n                airdropAdapterParam\n            ),\n            false\n        );\n    }\n\n    /// @notice sends TOFT to a specific chain and performs a borrow operation\n    /// @param from the sender address\n    /// @param to the receiver address\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param airdropAdapterParams the LayerZero aidrop adapter params\n    /// @param borrowParams the borrow operation data\n    /// @param withdrawParams the withdraw operation data\n    /// @param options the cross chain send operation data\n    /// @param approvals the cross chain approval operation data\n    function sendToYBAndBorrow(\n        address from,\n        address to,\n        uint16 lzDstChainId,\n        bytes calldata airdropAdapterParams,\n        ITapiocaOFT.IBorrowParams calldata borrowParams,\n        ICommonData.IWithdrawParams calldata withdrawParams,\n        ICommonData.ISendOptions calldata options,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector("
    }
  ]
}