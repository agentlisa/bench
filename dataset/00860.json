{
  "Title": "Lack of Validation of PrivateOffer Initialization Parameters ✓ Fixed",
  "Content": "\n\n#### Resolution\n\n\n\n[Addressed](https://github.com/corpus-io/tokenize.it-smart-contracts/blob/19bd32b835ff24ff2c7decf70adbd8ac5968a931/contracts/PrivateOffer.sol#L73-L84) by adding extra validation of the parameters.\n\n\n#### Description\n\n\nThe `PrivateOffer` contract allows to create a customised deal for a specific investor.\nThe `initialize()` function receives parameters to set up the `PrivateOffer` accordingly.\n\n\nThe following parameters lack of validation during initialization:\n\n\n* `tokenAmount`\n* `token`\n* `currency`\n\n\n#### `tokenAmount`\n\n\n**contracts/PrivateOffer.sol:L81-L84**\n\n\n\n```\nuint256 currencyAmount = Math.ceilDiv(\n \\_arguments.tokenAmount \\* \\_arguments.tokenPrice,\n 10 \\*\\* \\_arguments.token.decimals()\n);\n\n```\n`tokenAmount` is not validated at all. It should be verified to be greater than zero.\n\n\n#### `token`\n\n\n`token` is not validated at all. It should be verified to be different than zero address.\n\n\n#### `currency`\n\n\n`currency` is not validated at all. The documentation mentions a restricted list of supported currencies. It should be enforced by checking this parameter against a whitelist of currency addresses.\n\n\n#### Recommendation\n\n\nEnhance the validation of the following parameters: `tokenAmount`, `token`, `currency`.\n\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/PrivateOffer.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.23;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./Token.sol\";\n/**\n * @notice Contains all information necessary to execute a PrivateOffer.\n */\nstruct PrivateOfferArguments {\n    /// address holding the currency. Must have given sufficient allowance to this contract.\n    address currencyPayer;\n    /// address receiving the tokens. Must have sufficient attributes in AllowList to be able to receive tokens or the TRANSFERER role.\n    address tokenReceiver;\n    /// address receiving the payment in currency.\n    address currencyReceiver;\n    /// amount of tokens to be bought.\n    uint256 tokenAmount;\n    /// price company and investor agreed on, see docs/price.md.\n    uint256 tokenPrice;\n    /// timestamp after which the invitation is no longer valid.\n    uint256 expiration;\n    /// currency used for payment\n    IERC20 currency;\n    /// token to be bought\n    Token token;\n}\n\n/**\n * @title PrivateOffer\n * @author malteish, cjentzsch\n * @notice This contract represents the offer to buy an amount of tokens at a preset price. It is created for a specific buyer and can only be claimed once and only by that buyer.\n *     All parameters of the invitation (currencyPayer, tokenReceiver, currencyReceiver, tokenAmount, tokenPrice, currency, token) are immutable (see description of CREATE2).\n *     It is likely a company will create many PrivateOffers for specific investors to buy their one token.\n *     The use of CREATE2 (https://docs.openzeppelin.com/cli/2.8/deploying-with-create2) enables this invitation to be privacy preserving until it is accepted through\n *     granting of an allowance to the PrivateOffer's future address and deployment of the PrivateOffer.\n * @dev This contract is deployed using CREATE2 (https://docs.openzeppelin.com/cli/2.8/deploying-with-create2), using a deploy factory. That makes the future address of this contract\n *     deterministic: it can be computed from the parameters of the invitation. This allows the company and buyer to grant allowances to the future address of this contract\n *     before it is deployed.\n *     The process of deploying this contract is as follows:\n *     1. Company and investor agree on the terms of the invitation (currencyPayer, tokenReceiver, currencyReceiver, tokenAmount, tokenPrice, currency, token)\n *         and a salt (used for deployment only).\n *     2. With the help of a deploy factory, the company computes the future address of the PrivateOffer contract.\n *     3. The company grants a token minting allowance of amount to the future address of the PrivateOffer contract.\n *     4. The investor grants a currency allowance of amount*tokenPrice / 10**tokenDecimals to the future address of the PrivateOffer contract, using their currencyPayer address.\n *     5. Finally, company, buyer or anyone else deploys the PrivateOffer contract using the deploy factory.\n *     Because all of the execution logic is in the constructor, the deployment of the PrivateOffer contract is the last step. During the deployment, the newly\n *     minted tokens will be transferred to the buyer and the currency will be transferred to the company's receiver address.\n */\ncontract PrivateOffer {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Emitted when a PrivateOffer is deployed. `currencyPayer` paid for `tokenAmount` tokens at `tokenPrice` per token. The tokens were minted to `tokenReceiver`.\n     *    The token is deployed at `token` and the currency is `currency`.\n     * @param currencyPayer address that paid the currency\n     * @param tokenReceiver address that received the tokens\n     * @param tokenAmount amount of tokens that were bought\n     * @param tokenPrice price company and investor agreed on, see docs/price.md.\n     * @param currency currency used for payment\n     * @param token contract of the token that was bought\n     */\n    event Deal(\n        address indexed currencyPayer,\n        address indexed tokenReceiver,\n        uint256 tokenAmount,\n        uint256 tokenPrice,\n        IERC20 currency,\n        Token indexed token\n    );\n\n    constructor(PrivateOfferArguments memory _arguments) {\n        require(_arguments.currencyPayer != address(0), \"_arguments.currencyPayer can not be zero address\");\n        require(_arguments.tokenReceiver != address(0), \"_arguments.tokenReceiver can not be zero address\");\n        require(_arguments.currencyReceiver != address(0), \"_arguments.currencyReceiver can not be zero address\");\n        require(_arguments.tokenPrice != 0, \"_arguments.tokenPrice can not be zero\"); // a simple mint from the token contract will do in that case\n        require(block.timestamp <= _arguments.expiration, \"Deal expired\");\n        require(_arguments.token != Token(address(0)), \"_arguments.token can not be zero address\");\n        require(_arguments.currency != IERC20(address(0)), \"_arguments.currency can not be zero address\");\n        require(_arguments.tokenAmount != 0, \"_arguments.tokenAmount can not be zero\");\n        require(\n            _arguments.token.allowList().map(address(_arguments.currency)) == TRUSTED_CURRENCY,\n            \"currency needs to be on the allowlist with TRUSTED_CURRENCY attribute\"\n        );\n\n        // rounding up to the next whole number. Investor is charged up to one currency bit more in case of a fractional currency bit.\n        uint256 currencyAmount = Math.ceilDiv(\n            _arguments.tokenAmount * _arguments.tokenPrice,\n            10 ** _arguments.token.decimals()\n        );\n\n        IFeeSettingsV2 feeSettings = _arguments.token.feeSettings();\n        uint256 fee = feeSettings.privateOfferFee(currencyAmount, address(_arguments.token));\n        if (fee != 0) {\n            _arguments.currency.safeTransferFrom(\n                _arguments.currencyPayer,\n                feeSettings.privateOfferFeeCollector(address(_arguments.token)),\n                fee\n            );\n        }\n        _arguments.currency.safeTransferFrom(\n            _arguments.currencyPayer,\n            _arguments.currencyReceiver,\n            (currencyAmount - fee)\n        );\n\n        _arguments.token.mint(_arguments.tokenReceiver, _arguments.tokenAmount);\n\n        emit Deal(\n            _arguments.currencyPayer,\n            _arguments.tokenReceiver,\n            _arguments.tokenAmount,\n            _arguments.tokenPrice,\n            _arguments.currency,\n            _arguments.token\n        );\n    }\n}"
    }
  ]
}