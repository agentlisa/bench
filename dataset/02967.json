{
  "Title": "M-4: Front run `distributeRewards()` can steal the newly added rewards",
  "Content": "# Issue M-4: Front run `distributeRewards()` can steal the newly added rewards \n\nSource: https://github.com/sherlock-audit/2022-10-merit-circle-judging/issues/106 \n\n## Found by \nWATCHPUG, hickuphh3, hyh\n\n## Summary\n\nA surge of pointsPerShare on each `distributeRewards()` call can be used by the attacker to steal part of the newly added rewards.\n\n## Vulnerability Detail\n\nEvery time the `distributeRewards()` gets called, there will be a surge of `pointsPerShare` for the existing stakeholders.\n\nThis enables a well-known attack vector, in which the attacker will deposit a huge amount of underlying tokens and take a large portion of the pool, then trigger the surge, and exit right after.\n\n## Impact\n\nWhile the existence of the `MIN_LOCK_DURATION` prevented the usage of flashloan, it's still possible for the attackers with sufficient funds or can acquire sufficient funds in other ways.\n\nIn which case, the attack is quite practical and effectively steal the major part of the newly added rewards\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-merit-circle/blob/main/merit-liquidity-mining/contracts/base/BasePool.sol#L95-L98\n\nhttps://github.com/sherlock-audit/2022-10-merit-circle/blob/main/merit-liquidity-mining/contracts/base/AbstractRewards.sol#L89-L99\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider using a `rewardRate`-based gradual release model, pioneered by Synthetix's StakingRewards contract.\n\nSee: https://github.com/Synthetixio/synthetix/blob/develop/contracts/StakingRewards.sol#L113-L132\n\n## Discussion\n\n**federava**\n\nRaising the MIN_LOCK_DURATION from 10 minutes to 1 day.\n\n**federava**\n\n[PR](https://github.com/Merit-Circle/merit-liquidity-mining/pull/14) from this issue\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/9",
  "Code": [
    {
      "filename": "merit-liquidity-mining/contracts/base/BasePool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport { IERC20Upgradeable as IERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { SafeERC20Upgradeable as SafeERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { ERC20VotesUpgradeable as ERC20Votes } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport { SafeCastUpgradeable as SafeCast } from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport { AccessControlEnumerableUpgradeable as AccessControlEnumerable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../interfaces/IBasePool.sol\";\nimport \"../interfaces/ITimeLockPool.sol\";\n\nimport \"./AbstractRewards.sol\";\nimport \"./BoringBatchable.sol\";\n\nabstract contract BasePool is Initializable, AccessControlEnumerable, ERC20Votes, AbstractRewards, IBasePool, BaseBoringBatchable {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    error MoreThanOneError();\n    error NoDepositTokenError();\n    error NotGovError();\n\n    IERC20 public depositToken;\n    IERC20 public rewardToken;\n    ITimeLockPool public escrowPool;\n    uint256 public escrowPortion; // how much is escrowed 1e18 == 100%\n    uint256 public escrowDuration; // escrow duration in seconds\n\n    bytes32 public constant GOV_ROLE = keccak256(\"GOV_ROLE\");\n\n    event RewardsClaimed(address indexed _from, address indexed _receiver, uint256 _escrowedAmount, uint256 _nonEscrowedAmount);\n\n    // Saves space calling _onlyGov instead having the code\n    modifier onlyGov() {\n        _onlyGov();\n        _;\n    }\n    \n    function _onlyGov() private view {\n        if (!hasRole(GOV_ROLE, _msgSender())) {\n            revert NotGovError();\n        }\n    }\n\n    function __BasePool_init(\n        string memory _name,\n        string memory _symbol,\n        address _depositToken,\n        address _rewardToken,\n        address _escrowPool,\n        uint256 _escrowPortion,\n        uint256 _escrowDuration\n    ) internal onlyInitializing {\n        __ERC20Permit_init(_name); // only initializes ERC712Permit\n        __ERC20_init(_name, _symbol); // unchained or not it only saves the variables\n        __AbstractRewards_init(balanceOf, totalSupply);\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        __AccessControlEnumerable_init();\n\n        if (_escrowPortion > 1e18) {\n            revert MoreThanOneError();\n        }\n        if (_depositToken == address(0)) {\n            revert NoDepositTokenError();\n        }\n        depositToken = IERC20(_depositToken);\n        rewardToken = IERC20(_rewardToken);\n        escrowPool = ITimeLockPool(_escrowPool);\n        escrowPortion = _escrowPortion;\n        escrowDuration = _escrowDuration;\n\n        if(_rewardToken != address(0) && _escrowPool != address(0)) {\n            IERC20(_rewardToken).safeApprove(_escrowPool, type(uint256).max);\n        }\n    }\n\n    function _mint(address _account, uint256 _amount) internal virtual override {\n\t\tsuper._mint(_account, _amount);\n        _correctPoints(_account, -(_amount.toInt256()));\n\t}\n\t\n\tfunction _burn(address _account, uint256 _amount) internal virtual override {\n\t\tsuper._burn(_account, _amount);\n        _correctPoints(_account, _amount.toInt256());\n\t}\n\n    function _transfer(address _from, address _to, uint256 _value) internal virtual override {\n\t\tsuper._transfer(_from, _to, _value);\n        _correctPointsForTransfer(_from, _to, _value);\n\t}\n\n    function distributeRewards(uint256 _amount) external override {\n        rewardToken.safeTransferFrom(_msgSender(), address(this), _amount);\n        _distributeRewards(_amount);\n    }\n\n    function claimRewards(address _receiver) external {\n        uint256 rewardAmount = _prepareCollect(_msgSender());\n        uint256 escrowedRewardAmount = rewardAmount * escrowPortion / 1e18;\n        uint256 nonEscrowedRewardAmount = rewardAmount - escrowedRewardAmount;\n\n        if(escrowedRewardAmount != 0 && address(escrowPool) != address(0)) {\n            escrowPool.deposit(escrowedRewardAmount, escrowDuration, _receiver);\n        }\n\n        // ignore dust\n        if(nonEscrowedRewardAmount > 1) {\n            rewardToken.safeTransfer(_receiver, nonEscrowedRewardAmount);\n        }\n\n        emit RewardsClaimed(_msgSender(), _receiver, escrowedRewardAmount, nonEscrowedRewardAmount);\n    }\n\n}"
    },
    {
      "filename": "merit-liquidity-mining/contracts/base/AbstractRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"../interfaces/IAbstractRewards.sol\";\nimport { SafeCastUpgradeable as SafeCast } from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Based on: https://github.com/indexed-finance/dividends/blob/master/contracts/base/AbstractDividends.sol\n * Renamed dividends to rewards.\n * @dev (OLD) Many functions in this contract were taken from this repository:\n * https://github.com/atpar/funds-distribution-token/blob/master/contracts/FundsDistributionToken.sol\n * which is an example implementation of ERC 2222, the draft for which can be found at\n * https://github.com/atpar/funds-distribution-token/blob/master/EIP-DRAFT.md\n *\n * This contract has been substantially modified from the original and does not comply with ERC 2222.\n * Many functions were renamed as \"rewards\" rather than \"funds\" and the core functionality was separated\n * into this abstract contract which can be inherited by anything tracking ownership of reward shares.\n */\nabstract contract AbstractRewards is Initializable, IAbstractRewards {\n  using SafeCast for uint128;\n  using SafeCast for uint256;\n  using SafeCast for int256;\n\n  error ZeroShareSupplyError();\n\n/* ========  Constants  ======== */\n  uint128 public constant POINTS_MULTIPLIER = type(uint128).max;\n\n/* ========  Internal Function References  ======== */\n  function(address) view returns (uint256) private getSharesOf;\n  function() view returns (uint256) private getTotalShares;\n\n/* ========  Storage  ======== */\n  uint256 public pointsPerShare;\n  mapping(address => int256) public pointsCorrection;\n  mapping(address => uint256) public withdrawnRewards;\n\n  function __AbstractRewards_init(\n    function(address) view returns (uint256) getSharesOf_,\n    function() view returns (uint256) getTotalShares_\n  ) internal onlyInitializing {\n    getSharesOf = getSharesOf_;\n    getTotalShares = getTotalShares_;\n  }\n\n/* ========  Public View Functions  ======== */\n  /**\n   * @dev Returns the total amount of rewards a given address is able to withdraw.\n   * @param _account Address of a reward recipient\n   * @return A uint256 representing the rewards `account` can withdraw\n   */\n  function withdrawableRewardsOf(address _account) public view override returns (uint256) {\n    return cumulativeRewardsOf(_account) - withdrawnRewards[_account];\n  }\n\n  /**\n   * @notice View the amount of rewards that an address has withdrawn.\n   * @param _account The address of a token holder.\n   * @return The amount of rewards that `account` has withdrawn.\n   */\n  function withdrawnRewardsOf(address _account) public view override returns (uint256) {\n    return withdrawnRewards[_account];\n  }\n\n  /**\n   * @notice View the amount of rewards that an address has earned in total.\n   * @dev accumulativeFundsOf(account) = withdrawableRewardsOf(account) + withdrawnRewardsOf(account)\n   * = (pointsPerShare * balanceOf(account) + pointsCorrection[account]) / POINTS_MULTIPLIER\n   * @param _account The address of a token holder.\n   * @return The amount of rewards that `account` has earned in total.\n   */\n  function cumulativeRewardsOf(address _account) public view override returns (uint256) {\n    return ((pointsPerShare * getSharesOf(_account)).toInt256() + pointsCorrection[_account]).toUint256() / POINTS_MULTIPLIER;\n  }\n\n/* ========  Dividend Utility Functions  ======== */\n\n  /** \n   * @notice Distributes rewards to token holders.\n   * @dev It reverts if the total shares is 0.\n   * It emits the `RewardsDistributed` event if the amount to distribute is greater than 0.\n   * About undistributed rewards:\n   *   In each distribution, there is a small amount which does not get distributed,\n   *   which is `(amount * POINTS_MULTIPLIER) % totalShares()`.\n   *   With a well-chosen `POINTS_MULTIPLIER`, the amount of funds that are not getting\n   *   distributed in a distribution can be less than 1 (base unit).\n   */\n  function _distributeRewards(uint256 _amount) internal {\n    uint256 shares = getTotalShares();\n    if (shares == 0) {\n      revert ZeroShareSupplyError();\n    }\n\n    if (_amount > 0) {\n      pointsPerShare = pointsPerShare + (_amount * POINTS_MULTIPLIER / shares);\n      emit RewardsDistributed(msg.sender, _amount);\n    }\n  }\n\n  /**\n   * @notice Prepares collection of owed rewards\n   * @dev It emits a `RewardsWithdrawn` event if the amount of withdrawn rewards is\n   * greater than 0.\n   */\n  function _prepareCollect(address _account) internal returns (uint256) {\n    uint256 _withdrawableDividend = withdrawableRewardsOf(_account);\n    if (_withdrawableDividend > 0) {\n      withdrawnRewards[_account] = withdrawnRewards[_account] + _withdrawableDividend;\n      emit RewardsWithdrawn(_account, _withdrawableDividend);\n    }\n    return _withdrawableDividend;\n  }\n\n  function _correctPointsForTransfer(address _from, address _to, uint256 _shares) internal {\n    int256 _magCorrection = (pointsPerShare * _shares).toInt256();\n    pointsCorrection[_from] = pointsCorrection[_from] + _magCorrection;\n    pointsCorrection[_to] = pointsCorrection[_to] - _magCorrection;\n  }\n\n  /**\n   * @dev Increases or decreases the points correction for `account` by\n   * `shares*pointsPerShare`.\n   */\n  function _correctPoints(address _account, int256 _shares) internal {\n    pointsCorrection[_account] = pointsCorrection[_account] + (_shares * (int256(pointsPerShare)));\n  }\n}"
    },
    {
      "filename": "contracts/StakingRewards.sol",
      "content": "pragma solidity ^0.5.16;\n\nimport \"openzeppelin-solidity-2.3.0/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity-2.3.0/contracts/token/ERC20/ERC20Detailed.sol\";\nimport \"openzeppelin-solidity-2.3.0/contracts/token/ERC20/SafeERC20.sol\";\nimport \"openzeppelin-solidity-2.3.0/contracts/utils/ReentrancyGuard.sol\";\n\n// Inheritance\nimport \"./interfaces/IStakingRewards.sol\";\nimport \"./RewardsDistributionRecipient.sol\";\nimport \"./Pausable.sol\";\n\n// https://docs.synthetix.io/contracts/source/contracts/stakingrewards\ncontract StakingRewards is IStakingRewards, RewardsDistributionRecipient, ReentrancyGuard, Pausable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    IERC20 public rewardsToken;\n    IERC20 public stakingToken;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public rewardsDuration = 7 days;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _owner,\n        address _rewardsDistribution,\n        address _rewardsToken,\n        address _stakingToken\n    ) public Owned(_owner) {\n        rewardsToken = IERC20(_rewardsToken);\n        stakingToken = IERC20(_stakingToken);\n        rewardsDistribution = _rewardsDistribution;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return block.timestamp < periodFinish ? block.timestamp : periodFinish;\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(_totalSupply)\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);\n    }\n\n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function stake(uint256 amount) external nonReentrant notPaused updateReward(msg.sender) {\n        require(amount > 0, \"Cannot stake 0\");\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) public nonReentrant updateReward(msg.sender) {\n        require(amount > 0, \"Cannot withdraw 0\");\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function getReward() public nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function notifyRewardAmount(uint256 reward) external onlyRewardsDistribution updateReward(address(0)) {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n\n        // Ensure the provided reward amount is not more than the balance in the contract.\n        // This keeps the reward rate in the right range, preventing overflows due to\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n        uint balance = rewardsToken.balanceOf(address(this));\n        require(rewardRate <= balance.div(rewardsDuration), \"Provided reward too high\");\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(rewardsDuration);\n        emit RewardAdded(reward);\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n        require(tokenAddress != address(stakingToken), \"Cannot withdraw the staking token\");\n        IERC20(tokenAddress).safeTransfer(owner, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n\n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        require(\n            block.timestamp > periodFinish,\n            \"Previous rewards period must be complete before changing the duration for the new period\"\n        );\n        rewardsDuration = _rewardsDuration;\n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event RewardsDurationUpdated(uint256 newDuration);\n    event Recovered(address token, uint256 amount);\n}"
    }
  ]
}