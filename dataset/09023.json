{
  "Title": "[L-02] Front-runable initializer",
  "Content": "\nThere is nothing preventing another account from calling the initializer before the contract owner. In the best case, the owner is forced to waste gas and re-deploy. In the worst case, the owner does not notice that his/her call reverts, and everyone starts using a contract under the control of an attacker\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/contracts/Bribe.sol   #1\n\n30     function setGauge(address _gauge) external {\n31       require(gauge == address(0), \"gauge already set\");\n32       gauge = _gauge;\n33:    }\n```\n\n<https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L30-L33>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-velodrome",
  "Code": [
    {
      "filename": "contracts/contracts/Bribe.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport './interfaces/IERC20.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IGauge.sol';\n\ncontract Bribe is IBribe {\n  uint internal constant DURATION = 5 days; // rewards are released over the voting period\n  uint internal constant BRIBE_LAG = 1 days;\n  uint internal constant COOLDOWN = 12 hours;\n  uint internal constant MAX_REWARD_TOKENS = 16;\n\n  address public gauge;\n  mapping(address => mapping(uint => uint)) public tokenRewardsPerEpoch;\n  address[] public rewards;\n  mapping(address => bool) public isReward;\n\n  event NotifyReward(address indexed from, address indexed reward, uint epoch, uint amount);\n\n  // simple re-entrancy check\n  uint internal _unlocked = 1;\n  modifier lock() {\n      require(_unlocked == 1);\n      _unlocked = 2;\n      _;\n      _unlocked = 1;\n  }\n\n  function setGauge(address _gauge) external {\n    require(gauge == address(0), \"gauge already set\");\n    gauge = _gauge;\n  }\n\n  function getEpochStart(uint timestamp) public view returns (uint) {\n    uint bribeStart = timestamp - (timestamp % (7 days)) + BRIBE_LAG;\n    uint bribeEnd = bribeStart + DURATION - COOLDOWN;\n    return timestamp < bribeEnd ? bribeStart : bribeStart + 7 days;\n  }\n\n  function notifyRewardAmount(address token, uint amount) external lock {\n      require(amount > 0);\n      if (!isReward[token]) {\n        require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n      }\n      // bribes kick in at the start of next bribe period\n      uint adjustedTstamp = getEpochStart(block.timestamp);\n      uint epochRewards = tokenRewardsPerEpoch[token][adjustedTstamp];\n\n      _safeTransferFrom(token, msg.sender, address(this), amount);\n      tokenRewardsPerEpoch[token][adjustedTstamp] = epochRewards + amount;\n\n      if (!isReward[token]) {\n          isReward[token] = true;\n          rewards.push(token);\n          IGauge(gauge).addBribeRewardToken(token);\n      }\n\n      emit NotifyReward(msg.sender, token, adjustedTstamp, amount);\n  }\n\n  function rewardsListLength() external view returns (uint) {\n      return rewards.length;\n  }\n\n  function addRewardToken(address token) external {\n    require(msg.sender == gauge);\n    if (!isReward[token]) {\n      require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n      isReward[token] = true;\n      rewards.push(token);\n    }\n  }\n\n  function swapOutRewardToken(uint i, address oldToken, address newToken) external {\n    require(msg.sender == gauge);\n    require(rewards[i] == oldToken);\n    isReward[oldToken] = false;\n    isReward[newToken] = true;\n    rewards[i] = newToken;\n  }\n\n  function deliverReward(address token, uint epochStart) external lock returns (uint) {\n    require(msg.sender == gauge);\n    uint rewardPerEpoch = tokenRewardsPerEpoch[token][epochStart];\n    if (rewardPerEpoch > 0) {\n      _safeTransfer(token, address(gauge), rewardPerEpoch);\n    }\n    return rewardPerEpoch;\n  }\n\n  function _safeTransfer(address token, address to, uint256 value) internal {\n      require(token.code.length > 0);\n      (bool success, bytes memory data) =\n      token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n      require(success && (data.length == 0 || abi.decode(data, (bool))));\n  }\n\n  function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\n      require(token.code.length > 0);\n      (bool success, bytes memory data) =\n      token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n      require(success && (data.length == 0 || abi.decode(data, (bool))));\n  }\n}"
    }
  ]
}