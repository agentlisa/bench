{
  "Title": "Unexpected Refund Recipient",
  "Content": "Any address [is able](https://github.com/protofire/safe-contracts/blob/17d9fd5491f7e63543f51082e733220adb17a832/contracts/GnosisSafeZk.sol#L122) to invoke a transaction on behalf of the `GnosisSafeZk` contract, provided the transaction has been [authorized by enough owners](https://github.com/protofire/safe-contracts/blob/17d9fd5491f7e63543f51082e733220adb17a832/contracts/GnosisSafeZk.sol#L145) and the relayer accepts the corresponding [gas refund parameters](https://github.com/protofire/safe-contracts/blob/17d9fd5491f7e63543f51082e733220adb17a832/contracts/GnosisSafeZk.sol#L117-L119). However, if no `refundRecipient` is specified, the `tx.origin` address [will receive the refund](https://github.com/protofire/safe-contracts/blob/17d9fd5491f7e63543f51082e733220adb17a832/contracts/GnosisSafeZk.sol#L204).\n\n\nThis makes sense on the EVM but on the zkEVM there is an important subtlety. If the initiator is an EOA (the default account), then it is set as the `tx.origin` value, so it will correctly receive the refund. However, if the initiator is another smart contract account, [the bootloader will be set as `tx.origin`](https://github.com/matter-labs/era-system-contracts/blob/main/bootloader/bootloader.yul#L1364) and it will incorrectly receive the refund.\n\n\nTo avoid loss of funds, consider enforcing that the `refundRecipient` is specified whenever `tx.origin` is the bootloader address.\n\n\n***Update:** Acknowledged, not resolved. The Matter Labs team stated:*\n\n\n\n> *We agree that this complicates the usage of custom accounts with multisig wallet. However, the cost of supporting different codebases is also very high and the issue affects only custom zkSync functionality.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/GnosisSafeZk.sol",
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./base/ModuleManager.sol\";\nimport \"./base/OwnerManager.sol\";\nimport \"./base/FallbackManager.sol\";\nimport \"./base/GuardManager.sol\";\nimport \"./common/EtherPaymentFallback.sol\";\nimport \"./common/Singleton.sol\";\nimport \"./common/SignatureDecoder.sol\";\nimport \"./common/SecuredTokenTransfer.sol\";\nimport \"./common/StorageAccessible.sol\";\nimport \"./interfaces/ISignatureValidator.sol\";\nimport \"./external/GnosisSafeMath.sol\";\n\n/// @title Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191.\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract GnosisSafeZk is\n    EtherPaymentFallback,\n    Singleton,\n    ModuleManager,\n    OwnerManager,\n    SignatureDecoder,\n    SecuredTokenTransfer,\n    ISignatureValidatorConstants,\n    FallbackManager,\n    StorageAccessible,\n    GuardManager\n{\n    using GnosisSafeMath for uint256;\n\n    string public constant VERSION = \"1.3.0\";\n\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // keccak256(\n    //     \"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 private constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\n\n    event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);\n    event ApproveHash(bytes32 indexed approvedHash, address indexed owner);\n    event SignMsg(bytes32 indexed msgHash);\n    event ExecutionFailure(bytes32 txHash, uint256 payment);\n    event ExecutionSuccess(bytes32 txHash, uint256 payment);\n\n    uint256 public nonce;\n    bytes32 private _deprecatedDomainSeparator;\n    // Mapping to keep track of all message hashes that have been approve by ALL REQUIRED owners\n    mapping(bytes32 => uint256) public signedMessages;\n    // Mapping to keep track of all hashes (message or transaction) that have been approve by ANY owners\n    mapping(address => mapping(bytes32 => uint256)) public approvedHashes;\n\n    // This constructor ensures that this contract can only be used as a master copy for Proxy contracts\n    constructor() {\n        // By setting the threshold it is not possible to call setup anymore,\n        // so we create a Safe with 0 owners and threshold 1.\n        // This is an unusable Safe, perfect for the singleton\n        threshold = 1;\n    }\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param _owners List of Safe owners.\n    /// @param _threshold Number of required confirmations for a Safe transaction.\n    /// @param to Contract address for optional delegate call.\n    /// @param data Data payload for optional delegate call.\n    /// @param fallbackHandler Handler for fallback calls to this contract\n    /// @param paymentToken Token that should be used for the payment (0 is ETH)\n    /// @param payment Value that should be paid\n    /// @param paymentReceiver Adddress that should receive the payment (or 0 if tx.origin)\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    ) external {\n        // setupOwners checks if the Threshold is already set, therefore preventing that this method is called twice\n        setupOwners(_owners, _threshold);\n        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\n        // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\n        setupModules(to, data);\n\n        if (payment > 0) {\n            // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)\n            // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment\n            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\n        }\n        emit SafeSetup(msg.sender, _owners, _threshold, to, fallbackHandler);\n    }\n\n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n    ///      Note: The fees are always transferred, even if the user transaction fails.\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @param safeTxGas Gas that should be used for the Safe transaction.\n    /// @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n    /// @param gasPrice Gas price that should be used for the payment calculation.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) public payable virtual returns (bool success) {\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData =\n                encodeTransactionData(\n                    // Transaction info\n                    to,\n                    value,\n                    data,\n                    operation,\n                    safeTxGas,\n                    // Payment info\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    // Signature info\n                    nonce\n                );\n            // Increase nonce and execute transaction.\n            nonce++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures);\n        }\n        address guard = getGuard();\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkTransaction(\n                    // Transaction info\n                    to,\n                    value,\n                    data,\n                    operation,\n                    safeTxGas,\n                    // Payment info\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    // Signature info\n                    signatures,\n                    msg.sender\n                );\n            }\n        }\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        require(gasleft() >= ((safeTxGas * 64) / 63).max(safeTxGas + 2500) + 500, \"GS010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            uint256 gasUsed = gasleft();\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than safeTxGas)\n            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than safeTxGas\n            success = execute(to, value, data, operation, gasPrice == 0 ? (gasleft() - 2500) : safeTxGas);\n            gasUsed = gasUsed.sub(gasleft());\n            // If no safeTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            require(success || safeTxGas != 0 || gasPrice != 0, \"GS013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            if (gasPrice > 0) {\n                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\n            }\n            if (success) emit ExecutionSuccess(txHash, payment);\n            else emit ExecutionFailure(txHash, payment);\n        }\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkAfterExecution(txHash, success);\n            }\n        }\n    }\n\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver\n    ) private returns (uint256 payment) {\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool sent, bytes memory data) = receiver.call{value: payment}(\"\");\n            require(sent, \"GS011\");\n            //require(receiver.send(payment), \"GS011\");\n        } else {\n            payment = gasUsed.add(baseGas).mul(gasPrice);\n            require(transferToken(gasToken, receiver, payment), \"GS012\");\n        }\n    }\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param data That should be signed (this is passed to an external validator contract)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures\n    ) public view {\n        // Load threshold to avoid multiple storage loads\n        uint256 _threshold = threshold;\n        // Check that a threshold is set\n        require(_threshold > 0, \"GS001\");\n        checkNSignatures(dataHash, data, signatures, _threshold);\n    }\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param data That should be signed (this is passed to an external validator contract)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     * @param requiredSignatures Amount of required valid signatures.\n     */\n    function checkNSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures,\n        uint256 requiredSignatures\n    ) public view {\n        // Check that the provided signature data is not too short\n        require(signatures.length >= requiredSignatures.mul(65), \"GS020\");\n        // There cannot be an owner with address 0.\n        address lastOwner = address(0);\n        address currentOwner;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n        for (i = 0; i < requiredSignatures; i++) {\n            (v, r, s) = signatureSplit(signatures, i);\n            if (v == 0) {\n                // If v is 0 then it is a contract signature\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n\n                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                require(uint256(s) >= requiredSignatures.mul(65), \"GS021\");\n\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n                require(uint256(s).add(32) <= signatures.length, \"GS022\");\n\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n                uint256 contractSignatureLen;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                }\n                require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, \"GS023\");\n\n                // Check signature\n                bytes memory contractSignature;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n                    contractSignature := add(add(signatures, s), 0x20)\n                }\n                require(ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"GS024\");\n            } else if (v == 1) {\n                // If v is 1 then it is an approved hash\n                // When handling approved hashes the address of the approver is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n                // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction\n                require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, \"GS025\");\n            } else if (v > 30) {\n                // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n                currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            } else {\n                // Default is the ecrecover flow with the provided data hash\n                // Use ecrecover with the messageHash for EOA signatures\n                currentOwner = ecrecover(dataHash, v, r, s);\n            }\n            require(currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS, \"GS026\");\n            lastOwner = currentOwner;\n        }\n    }\n\n    /// @dev Allows to estimate a Safe transaction.\n    ///      This method is only meant for estimation purpose, therefore the call will always revert and encode the result in the revert data.\n    ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\n    /// @notice Deprecated in favor of common/StorageAccessible.sol and will be removed in next version.\n    function requiredTxGas(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external returns (uint256) {\n        uint256 startGas = gasleft();\n        // We don't provide an error message here, as we use it to return the estimate\n        require(execute(to, value, data, operation, gasleft()));\n        uint256 requiredGas = startGas - gasleft();\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /**\n     * @dev Marks a hash as approved. This can be used to validate a hash that is used by a signature.\n     * @param hashToApprove The hash that should be marked as approved for signatures that are verified by this contract.\n     */\n    function approveHash(bytes32 hashToApprove) external {\n        require(owners[msg.sender] != address(0), \"GS030\");\n        approvedHashes[msg.sender][hashToApprove] = 1;\n        emit ApproveHash(hashToApprove, msg.sender);\n    }\n\n    /// @dev Returns the chain id used by this contract.\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\n    }\n\n    /// @dev Returns the bytes that are hashed to be signed by owners.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param safeTxGas Gas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash bytes.\n    function encodeTransactionData(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes memory) {\n        bytes32 safeTxHash =\n            keccak256(\n                abi.encode(\n                    SAFE_TX_TYPEHASH,\n                    to,\n                    value,\n                    keccak256(data),\n                    operation,\n                    safeTxGas,\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    _nonce\n                )\n            );\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\n    }\n\n    /// @dev Returns hash to be signed by owners.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param safeTxGas Fas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash.\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes32) {\n        return keccak256(encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce));\n    }\n}"
    },
    {
      "filename": "bootloader/bootloader.yul",
      "content": "object \"Bootloader\" {\n    code {\n    }\n    object \"Bootloader_deployed\" {\n        code {\n            {{CODE_START_PLACEHOLDER}}\n\n            ////////////////////////////////////////////////////////////////////////////\n            //                      Function Declarations\n            ////////////////////////////////////////////////////////////////////////////\n\n            // While we definitely cannot control the gas price on L1,\n            // we need to check the operator does not provide any absurd numbers there\n            function MAX_ALLOWED_L1_GAS_PRICE() -> ret {\n                // 100k gwei\n                ret := 100000000000000\n            }\n\n            function MAX_ALLOWED_FAIR_L2_GAS_PRICE() -> ret {\n                // 10k gwei\n                ret := 10000000000000\n            }\n\n            /// @dev This method ensures that the prices provided by the operator\n            /// are not absurdly high\n            function validateOperatorProvidedPrices(l1GasPrice, fairL2GasPrice) {\n                if gt(l1GasPrice, MAX_ALLOWED_L1_GAS_PRICE()) {\n                    assertionError(\"L1 gas price too high\")\n                }\n\n                if gt(fairL2GasPrice, MAX_ALLOWED_FAIR_L2_GAS_PRICE()) {\n                    assertionError(\"L2 fair gas price too high\")\n                }\n            }\n\n            /// @dev Returns the baseFee for this batch based on the\n            /// L1 gas price and the fair L2 gas price.\n            function getBaseFee(l1GasPrice, fairL2GasPrice) -> baseFee, gasPricePerPubdata {\n                // By default, we want to provide the fair L2 gas price.\n                // That it means that the operator controls\n                // what the value of the baseFee will be. In the future, \n                // a better system, aided by EIP1559 should be added. \n\n                let pubdataBytePriceETH := safeMul(l1GasPrice, L1_GAS_PER_PUBDATA_BYTE(), \"aoa\")\n\n                baseFee := max(\n                    fairL2GasPrice,\n                    ceilDiv(pubdataBytePriceETH, MAX_L2_GAS_PER_PUBDATA())\n                )\n                gasPricePerPubdata := ceilDiv(pubdataBytePriceETH, baseFee)\n            }\n\n            /// @dev It should be always possible to submit a transaction \n            /// that consumes such amount of public data.\n            function GUARANTEED_PUBDATA_PER_TX() -> ret {\n                ret := {{GUARANTEED_PUBDATA_BYTES}}\n            }\n\n            /// @dev The maximal gasPerPubdata, which allows users to still be \n            /// able to send `GUARANTEED_PUBDATA_PER_TX` onchain.\n            function MAX_L2_GAS_PER_PUBDATA() -> ret {\n                ret := div(MAX_GAS_PER_TRANSACTION(), GUARANTEED_PUBDATA_PER_TX())\n            }\n\n            /// @dev The computational overhead for a batch.\n            /// It includes the combined price for 1 instance of all the circuits \n            /// (since they might be partially filled), the price for running\n            /// the common parts of the bootloader as well as general maintainance of the system.\n            function BATCH_OVERHEAD_L2_GAS() -> ret {\n                ret := {{BATCH_OVERHEAD_L2_GAS}}\n            }\n\n            /// @dev The overhead for the interaction with L1.\n            /// It should cover proof verification as well as other minor \n            /// overheads for committing/executing a transaction in a batch.\n            function BATCH_OVERHEAD_L1_GAS() -> ret {\n                ret := {{BATCH_OVERHEAD_L1_GAS}}\n            }\n\n            /// @dev The maximal number of gas available to the transaction\n            function MAX_GAS_PER_TRANSACTION() -> ret {\n                ret := {{MAX_GAS_PER_TRANSACTION}}\n            }\n\n            /// @dev The number of L1 gas needed to be spent for\n            /// L1 byte. While a single pubdata byte costs `16` gas, \n            /// we demand at least 17 to cover up for the costs of additional\n            /// hashing of it, etc.\n            function L1_GAS_PER_PUBDATA_BYTE() -> ret {\n                ret := 17\n            }\n\n            /// @dev The size of the bootloader memory that is to spent by the transaction's\n            /// encodings.\n            function BOOTLOADER_MEMORY_FOR_TXS() -> ret {\n                ret := {{BOOTLOADER_MEMORY_FOR_TXS}}\n            }\n\n            /// @dev Whether the batch is allowed to accept transactions with\n            /// gasPerPubdataByteLimit = 0. On mainnet, this is forbidden for safety reasons.\n            function FORBID_ZERO_GAS_PER_PUBDATA() -> ret {\n                ret := {{FORBID_ZERO_GAS_PER_PUBDATA}}\n            }\n            \n            /// @dev The maximum number of transactions per L1 batch.\n            function MAX_TRANSACTIONS_IN_BATCH() -> ret {\n                ret := {{MAX_TRANSACTIONS_IN_BATCH}}\n            }\n\n            /// @dev The slot from which the scratch space starts.\n            /// Scatch space is used for various temporary values\n            function SCRATCH_SPACE_BEGIN_SLOT() -> ret {\n                ret := 8\n            }\n\n            /// @dev The byte from which the scratch space starts.\n            /// Scratch space is used for various temporary values\n            function SCRATCH_SPACE_BEGIN_BYTE() -> ret {\n                ret := mul(SCRATCH_SPACE_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The first 32 slots are reserved for event emitting for the \n            /// debugging purposes\n            function SCRATCH_SPACE_SLOTS() -> ret {\n                ret := 32\n            }\n\n            /// @dev Slots reserved for saving the paymaster context\n            /// @dev The paymasters are allowed to consume at most \n            /// 32 slots (1024 bytes) for their context.\n            /// The 33 slots are required since the first one stores the length of the calldata.\n            function PAYMASTER_CONTEXT_SLOTS() -> ret {\n                ret := 33\n            }\n        \n            /// @dev Bytes reserved for saving the paymaster context\n            function PAYMASTER_CONTEXT_BYTES() -> ret {\n                ret := mul(PAYMASTER_CONTEXT_SLOTS(), 32)\n            }\n\n            /// @dev Slot from which the paymaster context starts\n            function PAYMASTER_CONTEXT_BEGIN_SLOT() -> ret {\n                ret := add(SCRATCH_SPACE_BEGIN_SLOT(), SCRATCH_SPACE_SLOTS())\n            }\n\n            /// @dev The byte from which the paymaster context starts\n            function PAYMASTER_CONTEXT_BEGIN_BYTE() -> ret {\n                ret := mul(PAYMASTER_CONTEXT_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev Each tx must have at least this amount of unused bytes before them to be able to \n            /// encode the postOp operation correctly.\n            function MAX_POSTOP_SLOTS() -> ret {\n                // Before the actual transaction encoding, the postOp contains 6 slots:\n                // 1. Context offset\n                // 2. Transaction offset\n                // 3. Transaction hash\n                // 4. Suggested signed hash\n                // 5. Transaction result\n                // 6. Maximum refunded gas\n                // And one more slot for the padding selector\n                ret := add(PAYMASTER_CONTEXT_SLOTS(), 7)\n            }\n\n            /// @dev Slots needed to store the canonical and signed hash for the current L2 transaction.\n            function CURRENT_L2_TX_HASHES_RESERVED_SLOTS() -> ret {\n                ret := 2\n            }\n\n            /// @dev Slot from which storing of the current canonical and signed hashes begins\n            function CURRENT_L2_TX_HASHES_BEGIN_SLOT() -> ret {\n                ret := add(PAYMASTER_CONTEXT_BEGIN_SLOT(), PAYMASTER_CONTEXT_SLOTS())\n            }\n\n            /// @dev The byte from which storing of the current canonical and signed hashes begins\n            function CURRENT_L2_TX_HASHES_BEGIN_BYTE() -> ret {\n                ret := mul(CURRENT_L2_TX_HASHES_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The maximum number of new factory deps that are allowed in a transaction\n            function MAX_NEW_FACTORY_DEPS() -> ret {\n                ret := 32\n            }\n\n            /// @dev Besides the factory deps themselves, we also need another 4 slots for: \n            /// selector, marker of whether the user should pay for the pubdata,\n            /// the offset for the encoding of the array as well as the length of the array.\n            function NEW_FACTORY_DEPS_RESERVED_SLOTS() -> ret {\n                ret := add(MAX_NEW_FACTORY_DEPS(), 4)\n            }\n\n            /// @dev The slot starting from which the factory dependencies are stored\n            function NEW_FACTORY_DEPS_BEGIN_SLOT() -> ret {\n                ret := add(CURRENT_L2_TX_HASHES_BEGIN_SLOT(), CURRENT_L2_TX_HASHES_RESERVED_SLOTS())\n            }\n\n            /// @dev The byte starting from which the factory dependencies are stored\n            function NEW_FACTORY_DEPS_BEGIN_BYTE() -> ret {\n                ret := mul(NEW_FACTORY_DEPS_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The slot starting from which the refunds provided by the operator are stored\n            function TX_OPERATOR_REFUND_BEGIN_SLOT() -> ret {\n                ret := add(NEW_FACTORY_DEPS_BEGIN_SLOT(), NEW_FACTORY_DEPS_RESERVED_SLOTS())\n            }\n\n            /// @dev The byte starting from which the refunds provided by the operator are stored\n            function TX_OPERATOR_REFUND_BEGIN_BYTE() -> ret {\n                ret := mul(TX_OPERATOR_REFUND_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The number of slots dedicated for the refunds for the transactions.\n            /// It is equal to the number of transactions in the batch.\n            function TX_OPERATOR_REFUNDS_SLOTS() -> ret {\n                ret := MAX_TRANSACTIONS_IN_BATCH()\n            }\n\n            /// @dev The slot starting from which the overheads proposed by the operator will be stored\n            function TX_SUGGESTED_OVERHEAD_BEGIN_SLOT() -> ret {\n                ret := add(TX_OPERATOR_REFUND_BEGIN_SLOT(), TX_OPERATOR_REFUNDS_SLOTS())\n            }\n\n            /// @dev The byte starting from which the overheads proposed by the operator will be stored\n            function TX_SUGGESTED_OVERHEAD_BEGIN_BYTE() -> ret {\n                ret := mul(TX_SUGGESTED_OVERHEAD_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The number of slots dedicated for the overheads for the transactions.\n            /// It is equal to the number of transactions in the batch.\n            function TX_SUGGESTED_OVERHEAD_SLOTS() -> ret {\n                ret := MAX_TRANSACTIONS_IN_BATCH()\n            }\n\n            /// @dev The slot starting from which the maximum number of gas that the operator \"trusts\"\n            /// the transaction to use for its execution is stored. Sometimes, the operator may know that\n            /// a certain transaction can be allowed more gas that what the protocol-level worst-case allows.\n            function TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT() -> ret {\n                ret := add(TX_SUGGESTED_OVERHEAD_BEGIN_SLOT(), TX_SUGGESTED_OVERHEAD_SLOTS())\n            }\n\n            /// @dev byte starting from which the maximum number of gas that the operator \"trusts\"\n            /// the transaction to use for its execution is stored. \n            function TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_BYTE() -> ret {\n                ret := mul(TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The number of slots dedicated for the trusted gas limits for the transactions.\n            /// It is equal to the number of transactions in the batch.\n            function TX_OPERATOR_TRUSTED_GAS_LIMIT_SLOTS() -> ret {\n                ret := MAX_TRANSACTIONS_IN_BATCH()\n            }\n\n            /// @dev The slot starting from the L2 block information for transactions is stored.\n            function TX_OPERATOR_L2_BLOCK_INFO_BEGIN_SLOT() -> ret {\n                ret := add(TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT(), TX_OPERATOR_TRUSTED_GAS_LIMIT_SLOTS())\n            }\n\n            /// @dev The byte starting from which the L2 block information for transactions is stored.\n            function TX_OPERATOR_L2_BLOCK_INFO_BEGIN_BYTE() -> ret {\n                ret := mul(TX_OPERATOR_L2_BLOCK_INFO_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The size of each of the L"
    }
  ]
}