{
  "Title": "Proposals can be deleted repeatedly",
  "Content": "In the [`OptimisticGovernor`](https://github.com/UMAprotocol/protocol/blob/fca8e24275e928f7ddf660b5651eb93b87f70afb/packages/core/contracts/zodiac/OptimisticGovernor.sol) contract there is no check that a proposal exists before it is deleted with the [`deleteProposal`](https://github.com/UMAprotocol/protocol/blob/fca8e24275e928f7ddf660b5651eb93b87f70afb/packages/core/contracts/zodiac/OptimisticGovernor.sol#L265) function. Similarly, a rejected proposal can be deleted repeatedly via the [`deleteRejectedProposal`](https://github.com/UMAprotocol/protocol/blob/fca8e24275e928f7ddf660b5651eb93b87f70afb/packages/core/contracts/zodiac/OptimisticGovernor.sol#L275) function.\n\n\nAlthough there is no clear economic incentive to do delete a proposal numerous times – in fact it will waste gas – the repeated emission of identical [`ProposalDeleted`](https://github.com/UMAprotocol/protocol/blob/fca8e24275e928f7ddf660b5651eb93b87f70afb/packages/core/contracts/zodiac/OptimisticGovernor.sol#L35) events could be confusing for parties monitoring for such events.\n\n\nConsider allowing proposals to be deleted only if they have not already been deleted.\n\n\n***Update:** Fixed as of commit `deeb7386be6d1f14c8999fe5316c9feb80b5d0d2` in [pull request #3918](https://github.com/UMAprotocol/protocol/pull/3918).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts/zodiac/OptimisticGovernor.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.6;\n\n// https://github.com/gnosis/zodiac/blob/master/contracts/core/Module.sol\nimport \"@gnosis.pm/zodiac/contracts/core/Module.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../oracle/implementation/Constants.sol\";\nimport \"../oracle/interfaces/FinderInterface.sol\";\nimport \"../oracle/interfaces/OptimisticOracleInterface.sol\";\nimport \"../oracle/implementation/OptimisticOracle.sol\";\nimport \"../common/implementation/Lockable.sol\";\nimport \"../common/interfaces/AddressWhitelistInterface.sol\";\nimport \"../oracle/interfaces/IdentifierWhitelistInterface.sol\";\nimport \"../common/implementation/AncillaryData.sol\";\nimport \"../oracle/interfaces/StoreInterface.sol\";\n\ncontract OptimisticGovernor is Module, Lockable {\n    using SafeERC20 for IERC20;\n\n    event OptimisticGovernorDeployed(address indexed owner, address indexed avatar, address target);\n\n    event TransactionsProposed(\n        uint256 indexed proposalId,\n        address indexed proposer,\n        uint256 indexed proposalTime,\n        Proposal proposal,\n        bytes explanation\n    );\n\n    event TransactionExecuted(uint256 indexed proposalId, uint256 indexed transactionIndex);\n\n    event ProposalDeleted(uint256 indexed proposalId);\n\n    // Since finder is set during setUp, you will need to deploy a new Optimistic Governor module if this address need to be changed in the future.\n    FinderInterface public finder;\n\n    IERC20 public collateral;\n    uint64 public liveness;\n    // Extra bond in addition to the final fee for the collateral type.\n    uint256 public bond;\n    string public rules;\n    // This will usually be \"ZODIAC\" but a deployer may want to create a more specific identifier.\n    bytes32 public identifier;\n    OptimisticOracleInterface public optimisticOracle;\n\n    struct Transaction {\n        address to;\n        uint256 value;\n        bytes data;\n        Enum.Operation operation;\n    }\n\n    struct Proposal {\n        Transaction[] transactions;\n        uint256 requestTime;\n    }\n\n    mapping(uint256 => bytes32) public proposalHashes;\n    uint256 public prevProposalId;\n\n    /**\n     * @notice Construct Optimistic Governor module.\n     * @param _finder Finder address.\n     * @param _owner Address of the owner.\n     * @param _collateral Address of the ERC20 collateral used for bonds.\n     * @param _bond Bond required (must be at least as large as final fee for collateral type).\n     * @param _rules Reference to the rules for the Gnosis Safe (e.g., IPFS hash or URI).\n     * @param _identifier The approved identifier to be used with the contract, usually \"ZODIAC\".\n     * @param _liveness The period, in seconds, in which a proposal can be disputed.\n     */\n    constructor(\n        address _finder,\n        address _owner,\n        address _collateral,\n        uint256 _bond,\n        string memory _rules,\n        bytes32 _identifier,\n        uint64 _liveness\n    ) {\n        bytes memory initializeParams = abi.encode(_finder, _owner, _collateral, _bond, _rules, _identifier, _liveness);\n        setUp(initializeParams);\n    }\n\n    function setUp(bytes memory initializeParams) public override initializer {\n        __Ownable_init();\n        (\n            address _finder,\n            address _owner,\n            address _collateral,\n            uint256 _bond,\n            string memory _rules,\n            bytes32 _identifier,\n            uint64 _liveness\n        ) = abi.decode(initializeParams, (address, address, address, uint256, string, bytes32, uint64));\n        finder = FinderInterface(_finder);\n        require(_getCollateralWhitelist().isOnWhitelist(address(_collateral)), \"bond token not supported\");\n        collateral = IERC20(_collateral);\n        bond = _bond;\n        rules = _rules;\n        require(_getIdentifierWhitelist().isIdentifierSupported(_identifier), \"identifier not supported\");\n        identifier = _identifier;\n        require(_liveness > 0, \"liveness can't be 0\");\n        liveness = _liveness;\n        setAvatar(_owner);\n        setTarget(_owner);\n        transferOwnership(_owner);\n        _sync();\n\n        emit OptimisticGovernorDeployed(_owner, avatar, target);\n    }\n\n    /**\n     * @notice Sets the bond amount for proposals.\n     * @param _bond amount of the bond token that will need to be paid for future proposals.\n     */\n    function setBond(uint256 _bond) public onlyOwner {\n        // Value of the bond required for proposals, in addition to the final fee.\n        bond = _bond;\n    }\n\n    /**\n     * @notice Sets the collateral token (and bond token) for future proposals.\n     * @param _collateral token that will be used for all bonds for the contract.\n     */\n    function setCollateral(IERC20 _collateral) public onlyOwner {\n        // ERC20 token to be used as collateral (must be approved by UMA Store contract).\n        require(_getCollateralWhitelist().isOnWhitelist(address(_collateral)), \"bond token not supported\");\n        collateral = _collateral;\n    }\n\n    /**\n     * @notice Sets the rules that will be used to evaluate future proposals.\n     * @param _rules string that outlines or references the location where the rules can be found.\n     */\n    function setRules(string memory _rules) public onlyOwner {\n        // Set reference to the rules for the avatar (e.g. an IPFS hash or URI).\n        rules = _rules;\n    }\n\n    /**\n     * @notice Sets the liveness for future proposals. This is the amount of delay before a proposal is approved by\n     * default.\n     * @param _liveness liveness to set in seconds.\n     */\n    function setLiveness(uint64 _liveness) public onlyOwner {\n        // Set liveness for disputing proposed transactions.\n        require(_liveness > 0, \"liveness can't be 0\");\n        liveness = _liveness;\n    }\n\n    /**\n     * @notice Sets the identifier for future proposals.\n     * @dev Changing this after a proposal is made but before it is executed will make it unexecutable.\n     * @param _identifier identifier to set.\n     */\n    function setIdentifier(bytes32 _identifier) public onlyOwner {\n        // Set identifier which is used along with the rules to determine if transactions are valid.\n        require(_getIdentifierWhitelist().isIdentifierSupported(_identifier), \"identifier not supported\");\n        identifier = _identifier;\n    }\n\n    /**\n     * @notice This pulls in the most up-to-date Optimistic Oracle.\n     * @dev If a new OptimisticOracle is added and this is run between a proposals introduction and execution, the\n     * proposal will become unexecutable.\n     */\n    function sync() public nonReentrant {\n        // Sync the oracle contract addresses as well as the final fee.\n        _sync();\n    }\n\n    /**\n     * @notice Makes a new proposal for transactions to be executed with an \"explanation\" argument.\n     * @param _transactions the transactions being proposed.\n     * @param _explanation Auxillary information that can be referenced to validate the proposal.\n     */\n    function proposeTransactions(Transaction[] memory _transactions, bytes memory _explanation) public nonReentrant {\n        // note: Optional explanation explains the intent of the transactions to make comprehension easier.\n        uint256 id = prevProposalId + 1;\n        prevProposalId = id;\n        uint256 time = getCurrentTime();\n        address proposer = msg.sender;\n\n        // Create proposal in memory to emit in an event.\n        Proposal memory proposal;\n        proposal.requestTime = time;\n\n        // Construct the ancillary data.\n        bytes memory ancillaryData = AncillaryData.appendKeyValueUint(\"\", \"id\", id);\n\n        // Add transactions to proposal in memory.\n        for (uint256 i = 0; i < _transactions.length; i++) {\n            require(_transactions[i].to != address(0), \"The `to` address cannot be 0x0\");\n            // If the transaction has any data with it the recipient must be a contract, not an EOA.\n            if (_transactions[i].data.length > 0) {\n                require(_isContract(_transactions[i].to), \"EOA can't accept tx with data\");\n            }\n        }\n        proposal.transactions = _transactions;\n\n        // proposalHashes[id] = keccak256(abi.encodePacked(proposalData));\n        proposalHashes[id] = keccak256(abi.encode(_transactions));\n\n        // Propose a set of transactions to the OO. If not disputed, they can be executed with executeProposal().\n        // docs: https://github.com/UMAprotocol/protocol/blob/master/packages/core/contracts/oracle/interfaces/OptimisticOracleInterface.sol\n        optimisticOracle.requestPrice(identifier, time, ancillaryData, collateral, 0);\n        uint256 totalBond = optimisticOracle.setBond(identifier, time, ancillaryData, bond);\n        optimisticOracle.setCustomLiveness(identifier, time, ancillaryData, liveness);\n\n        // Get the bond from the proposer and approve the bond and final fee to be used by the oracle.\n        collateral.safeTransferFrom(msg.sender, address(this), totalBond);\n        collateral.safeIncreaseAllowance(address(optimisticOracle), totalBond);\n\n        optimisticOracle.proposePriceFor(msg.sender, address(this), identifier, time, ancillaryData, int256(1e18));\n\n        emit TransactionsProposed(id, proposer, time, proposal, _explanation);\n    }\n\n    /**\n     * @notice Executes an approved proposal.\n     * @param _proposalId the id of the proposal being executed.\n     * @param _transactions the transactions being executed. These must exactly match those that were proposed.\n     * @param _originalTime the timestamp of the original proposal.\n     */\n    function executeProposal(\n        uint256 _proposalId,\n        Transaction[] memory _transactions,\n        uint256 _originalTime\n    ) public payable nonReentrant {\n        // Recreate the proposal hash from the inputs and check that it matches the stored proposal hash.\n        uint256 id = _proposalId;\n\n        // Construct the ancillary data.\n        bytes memory ancillaryData = AncillaryData.appendKeyValueUint(\"\", \"id\", id);\n\n        // This will reject the transaction if the proposal hash generated from the inputs does not match the stored proposal hash.\n        // require(proposalHashes[id] == keccak256(abi.encodePacked(proposalData)), \"proposal hash does not match\");\n        require(proposalHashes[id] == keccak256(abi.encode(_transactions)), \"proposal hash does not match\");\n\n        // Remove proposal hash so transactions can not be executed again.\n        delete proposalHashes[id];\n\n        // This will revert if the price has not settled.\n        int256 price = optimisticOracle.settleAndGetPrice(identifier, _originalTime, ancillaryData);\n        require(price == int256(1e18), \"Proposal was rejected\");\n\n        for (uint256 i = 0; i < _transactions.length; i++) {\n            Transaction memory transaction = _transactions[i];\n\n            require(\n                exec(transaction.to, transaction.value, transaction.data, transaction.operation),\n                \"Failed to execute the transaction\"\n            );\n            emit TransactionExecuted(_proposalId, i);\n        }\n    }\n\n    /**\n     * @notice Method to allow the owner to delete a particular proposal.\n     * @param _proposalId the id of the proposal being deleted.\n     */\n    function deleteProposal(uint256 _proposalId) public onlyOwner {\n        delete proposalHashes[_proposalId];\n        emit ProposalDeleted(_proposalId);\n    }\n\n    /**\n     * @notice Method to allow anyone to delete a proposal that was rejected.\n     * @param _proposalId the id of the proposal being deleted.\n     * @param _originalTime the id of the proposal being deleted.\n     */\n    function deleteRejectedProposal(uint256 _proposalId, uint256 _originalTime) public {\n        // Construct the ancillary data.\n        bytes memory ancillaryData = AncillaryData.appendKeyValueUint(\"\", \"id\", _proposalId);\n\n        // This will revert if the price has not settled.\n        int256 price = optimisticOracle.settleAndGetPrice(identifier, _originalTime, ancillaryData);\n\n        // Check that proposal was rejected.\n        require(price != int256(1e18), \"Proposal was not rejected\");\n\n        // Delete the proposal.\n        delete proposalHashes[_proposalId];\n        emit ProposalDeleted(_proposalId);\n    }\n\n    /**\n     * @notice Gets the current time for this contract.\n     * @dev This only exists so it can be overriden for testing.\n     */\n    function getCurrentTime() public view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    function _getOptimisticOracle() private view returns (OptimisticOracleInterface) {\n        return OptimisticOracleInterface(finder.getImplementationAddress(OracleInterfaces.OptimisticOracle));\n    }\n\n    function _isContract(address addr) private view returns (bool isContract) {\n        return addr.code.length > 0;\n    }\n\n    function _getCollateralWhitelist() internal view returns (AddressWhitelistInterface) {\n        return AddressWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist));\n    }\n\n    function _getIdentifierWhitelist() internal view returns (IdentifierWhitelistInterface) {\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\n    }\n\n    function _getStore() internal view returns (StoreInterface) {\n        return StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store));\n    }\n\n    function _sync() internal {\n        optimisticOracle = _getOptimisticOracle();\n    }\n}"
    }
  ]
}