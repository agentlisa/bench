{
  "Title": "M-4: Unable to withdraw extra rewards",
  "Content": "# Issue M-4: Unable to withdraw extra rewards \n\nSource: https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/565 \n\n## Found by \n0xGoodess, 0xdeadbeef, Ch\\_301, berndartmueller, xiaoming90\n\nUsers are unable to withdraw extra rewards due to staking of TOKE that is less than `MIN_STAKE_AMOUNT`, resulting in them being stuck in the contracts.\n\n## Vulnerability Detail\n\nSuppose Bob only has 9999 Wei TOKE tokens as main rewards and 100e18 DAI as extra rewards in this account.\n\nWhen attempting to get the rewards, the code will always get the main rewards, followed by the extra rewards, as shown below.\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/rewarders/MainRewarder.sol#L108\n\n```solidity\nFile: MainRewarder.sol\n108:     function _processRewards(address account, bool claimExtras) internal {\n109:         _getReward(account);\n110: \n111:         //also get rewards from linked rewards\n112:         if (claimExtras) {\n113:             for (uint256 i = 0; i < extraRewards.length; ++i) {\n114:                 IExtraRewarder(extraRewards[i]).getReward(account);\n115:             }\n116:         }\n117:     }\n```\n\nIf the main reward is TOKE, they will be staked to the `GPToke` at Line 376 below.\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/rewarders/AbstractRewarder.sol#L354\n\n```solidity\nFile: AbstractRewarder.sol\n354:     function _getReward(address account) internal {\n355:         Errors.verifyNotZero(account, \"account\");\n356: \n357:         uint256 reward = earned(account);\n358:         (IGPToke gpToke, address tokeAddress) = (systemRegistry.gpToke(), address(systemRegistry.toke()));\n359: \n360:         // slither-disable-next-line incorrect-equality\n361:         if (reward == 0) return;\n362: \n363:         rewards[account] = 0;\n364:         emit RewardPaid(account, reward);\n365: \n366:         // if NOT toke, or staking is turned off (by duration = 0), just send reward back\n367:         if (rewardToken != tokeAddress || tokeLockDuration == 0) {\n368:             IERC20(rewardToken).safeTransfer(account, reward);\n369:         } else {\n370:             // authorize gpToke to get our reward Toke\n371:             // slither-disable-next-line unused-return\n372:             IERC20(address(tokeAddress)).approve(address(gpToke), reward);\n373: \n374:             // stake Toke\n375:             gpToke.stake(reward, tokeLockDuration, account);\n376:         }\n377:     }\n```\n\nHowever, if the staked amount is less than the minimum stake amount (`MIN_STAKE_AMOUNT`), the function will revert.\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/staking/GPToke.sol#L98\n\n```solidity\nFile: GPToke.sol\n32:     uint256 public constant MIN_STAKE_AMOUNT = 10_000;\n..SNIP..\n098:     function _stake(uint256 amount, uint256 duration, address to) internal whenNotPaused {\n099:         //\n100:         // validation checks\n101:         //\n102:         if (to == address(0)) revert ZeroAddress();\n103:         if (amount < MIN_STAKE_AMOUNT) revert StakingAmountInsufficient();\n104:         if (amount > MAX_STAKE_AMOUNT) revert StakingAmountExceeded();\n```\n\nIn this case, Bob will not be able to redeem his 100 DAI reward when processing the reward. The code will always attempt to stake 9999 Wei Toke and revert because it fails to meet the minimum stake amount.\n\n## Impact\n\nThere is no guarantee that the users' TOKE rewards will always be larger than `MIN_STAKE_AMOUNT` as it depends on various factors such as the following:\n\n- The number of vault shares they hold. If they hold little shares, their TOKE reward will be insignificant\n- If their holding in the vault is small compared to the others and the entire vault, the TOKE reward they received will be insignificant\n- The timing they join the vault. If they join after the reward is distributed, they will not be entitled to it.\n\nAs such, the affected users will not be able to withdraw their extra rewards, and they will be stuck in the contract.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/rewarders/MainRewarder.sol#L108\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/rewarders/AbstractRewarder.sol#L354\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/staking/GPToke.sol#L98\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nTo remediate the issue, consider collecting TOKE and staking it to the `GPToke` contract only if it meets the minimum stake amount.\n\n```diff\nfunction _getReward(address account) internal {\n    Errors.verifyNotZero(account, \"account\");\n\n    uint256 reward = earned(account);\n    (IGPToke gpToke, address tokeAddress) = (systemRegistry.gpToke(), address(systemRegistry.toke()));\n\n    // slither-disable-next-line incorrect-equality\n    if (reward == 0) return;\n\n-    rewards[account] = 0;\n-    emit RewardPaid(account, reward);\n\n    // if NOT toke, or staking is turned off (by duration = 0), just send reward back\n    if (rewardToken != tokeAddress || tokeLockDuration == 0) {\n+\t\trewards[account] = 0;\n+\t\temit RewardPaid(account, reward);\n        IERC20(rewardToken).safeTransfer(account, reward);\n    } else {\n+    \tif (reward >= MIN_STAKE_AMOUNT) {\n+\t\t\trewards[account] = 0;\n+\t\t\temit RewardPaid(account, reward);\n+\n            // authorize gpToke to get our reward Toke\n            // slither-disable-next-line unused-return\n            IERC20(address(tokeAddress)).approve(address(gpToke), reward);\n\n            // stake Toke\n            gpToke.stake(reward, tokeLockDuration, account);\n+\t\t}\n    }\n}\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/101",
  "Code": [
    {
      "filename": "v2-core-audit-2023-07-14/src/rewarders/MainRewarder.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\npragma solidity 0.8.17;\n\nimport { IERC20 } from \"openzeppelin-contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"openzeppelin-contracts/security/ReentrancyGuard.sol\";\n\nimport { ISystemRegistry } from \"src/interfaces/ISystemRegistry.sol\";\n\nimport { IStakeTracking } from \"src/interfaces/rewarders/IStakeTracking.sol\";\nimport { IMainRewarder } from \"src/interfaces/rewarders/IMainRewarder.sol\";\nimport { IExtraRewarder } from \"src/interfaces/rewarders/IExtraRewarder.sol\";\nimport { AbstractRewarder } from \"src/rewarders/AbstractRewarder.sol\";\n\nimport { Roles } from \"src/libs/Roles.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\n\n/**\n * @title MainRewarder\n * @notice The MainRewarder contract extends the AbstractRewarder and\n * manages the distribution of main rewards along with additional rewards\n * from ExtraRewarder contracts.\n */\ncontract MainRewarder is AbstractRewarder, IMainRewarder, ReentrancyGuard {\n    /// @notice True if additional reward tokens/contracts are allowed to be added\n    /// @dev Destination Vaults should not allow extras. LMP should.\n    bool public immutable allowExtraRewards;\n\n    address[] public extraRewards;\n\n    error ExtraRewardsNotAllowed();\n\n    event ExtraRewardAdded(address reward);\n    event ExtraRewardsCleared();\n\n    constructor(\n        ISystemRegistry _systemRegistry,\n        address _stakeTracker,\n        address _rewardToken,\n        uint256 _newRewardRatio,\n        uint256 _durationInBlock,\n        bool _allowExtraRewards\n    ) AbstractRewarder(_systemRegistry, _stakeTracker, _rewardToken, _newRewardRatio, _durationInBlock) {\n        allowExtraRewards = _allowExtraRewards;\n    }\n\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    function addExtraReward(address reward) external hasRole(Roles.DV_REWARD_MANAGER_ROLE) {\n        if (!allowExtraRewards) {\n            revert ExtraRewardsNotAllowed();\n        }\n        Errors.verifyNotZero(reward, \"reward\");\n\n        extraRewards.push(reward);\n\n        emit ExtraRewardAdded(reward);\n    }\n\n    function getExtraRewarder(uint256 index) external view returns (IExtraRewarder rewarder) {\n        return IExtraRewarder(extraRewards[index]);\n    }\n\n    function clearExtraRewards() external hasRole(Roles.DV_REWARD_MANAGER_ROLE) {\n        delete extraRewards;\n\n        emit ExtraRewardsCleared();\n    }\n\n    function withdraw(address account, uint256 amount, bool claim) public onlyStakeTracker {\n        _updateReward(account);\n        _withdraw(account, amount);\n\n        for (uint256 i = 0; i < extraRewards.length; ++i) {\n            IExtraRewarder(extraRewards[i]).withdraw(account, amount);\n        }\n\n        if (claim) {\n            _processRewards(account, true);\n        }\n    }\n\n    function stake(address account, uint256 amount) public onlyStakeTracker {\n        _updateReward(account);\n        _stake(account, amount);\n\n        for (uint256 i = 0; i < extraRewards.length; ++i) {\n            IExtraRewarder(extraRewards[i]).stake(account, amount);\n        }\n    }\n\n    function getReward() external nonReentrant {\n        _updateReward(msg.sender);\n        _processRewards(msg.sender, true);\n    }\n\n    function getReward(address account, bool claimExtras) external nonReentrant {\n        if (msg.sender != address(stakeTracker) && msg.sender != account) {\n            revert Errors.AccessDenied();\n        }\n        _updateReward(account);\n        _processRewards(account, claimExtras);\n    }\n\n    function _processRewards(address account, bool claimExtras) internal {\n        _getReward(account);\n\n        //also get rewards from linked rewards\n        if (claimExtras) {\n            for (uint256 i = 0; i < extraRewards.length; ++i) {\n                IExtraRewarder(extraRewards[i]).getReward(account);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/rewarders/AbstractRewarder.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\npragma solidity 0.8.17;\n\nimport { IERC20 } from \"openzeppelin-contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { ISystemRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { SecurityBase } from \"src/security/SecurityBase.sol\";\n\nimport { IStakeTracking } from \"src/interfaces/rewarders/IStakeTracking.sol\";\nimport { IBaseRewarder } from \"src/interfaces/rewarders/IBaseRewarder.sol\";\n\nimport { IGPToke } from \"src/interfaces/staking/IGPToke.sol\";\n\nimport { Roles } from \"src/libs/Roles.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\n\n/**\n * @dev An abstract contract that serves as the base for rewarder contracts.\n * It implements common functionalities for reward distribution, including calculating rewards per token,\n * tracking user rewards, and handling stake-related operations.\n * Inherited by rewarder contracts, such as MainRewarder and ExtraRewarder.\n * The contract is inspired by the Convex contract but uses block-based duration instead of timestamp-based duration.\n * Unlike Convex, it does not own the LP token but it interacts with an external LP token contract.\n */\n\nabstract contract AbstractRewarder is IBaseRewarder, SecurityBase {\n    using SafeERC20 for IERC20;\n\n    /// @notice The duration of the reward period in blocks.\n    uint256 public durationInBlock;\n\n    ///  @notice It is used to determine if the new rewards should be distributed immediately or queued for later. If\n    /// the ratio of current rewards to the sum of new and queued rewards is less than newRewardRatio, the new rewards\n    /// are distributed immediately; otherwise, they are added to the queue.\n    uint256 public newRewardRatio;\n\n    /// @notice An instance of the system registry contract.\n    ISystemRegistry internal immutable systemRegistry;\n\n    /// @notice The address of the token to be distributed as rewards.\n    address public immutable rewardToken;\n\n    /// @notice An instance of the stake tracking contract, for managing staked tokens.\n    IStakeTracking public immutable stakeTracker;\n\n    /// @notice The block number when the current reward period ends.\n    uint256 public periodInBlockFinish;\n\n    /// @notice The rate of reward distribution per block.\n    uint256 public rewardRate;\n\n    /// @notice The block number when rewards were last updated.\n    uint256 public lastUpdateBlock;\n\n    /// @notice The amount of rewards distributed per staked token stored.\n    uint256 public rewardPerTokenStored;\n\n    /// @notice The amount of rewards waiting in the queue to be distributed.\n    uint256 public queuedRewards;\n\n    /// @notice The amount of current rewards being distributed.\n    uint256 public currentRewards;\n\n    /// @notice The total amount of rewards distributed historically.\n    uint256 public historicalRewards;\n\n    /// @notice The amount of reward per token paid to each user.\n    mapping(address => uint256) public userRewardPerTokenPaid;\n\n    /// @notice The amount of rewards for each user.\n    mapping(address => uint256) public rewards;\n\n    /// @notice The duration for locking the Toke token rewards.\n    uint256 public tokeLockDuration;\n\n    /// @notice Whitelisted addresses for queuing new rewards.\n    mapping(address => bool) public whitelistedAddresses;\n\n    /**\n     * @param _systemRegistry Address of the system registry.\n     * @param _stakeTracker Address of the stake tracker.\n     * @param _rewardToken Address of the reward token.\n     * @param _newRewardRate The new reward rate.\n     * @param _durationInBlock The duration of the reward period in blocks.\n     */\n    constructor(\n        ISystemRegistry _systemRegistry,\n        address _stakeTracker,\n        address _rewardToken,\n        uint256 _newRewardRate,\n        uint256 _durationInBlock\n    ) SecurityBase(address(_systemRegistry.accessController())) {\n        Errors.verifyNotZero(_stakeTracker, \"_stakeTracker\");\n        Errors.verifyNotZero(_rewardToken, \"_rewardToken\");\n\n        systemRegistry = _systemRegistry;\n        if (!systemRegistry.isRewardToken(_rewardToken)) {\n            revert Errors.InvalidParam(\"_rewardToken\");\n        }\n        rewardToken = _rewardToken;\n        stakeTracker = IStakeTracking(_stakeTracker);\n        newRewardRatio = _newRewardRate;\n        durationInBlock = _durationInBlock;\n    }\n\n    /// @notice Restricts access to the stake tracker only.\n    modifier onlyStakeTracker() {\n        if (msg.sender != address(stakeTracker)) {\n            revert Errors.AccessDenied();\n        }\n        _;\n    }\n\n    /// @notice Restricts access to whitelisted addresses or holders of the liquidator role.\n    modifier onlyWhitelisted() {\n        if (!whitelistedAddresses[msg.sender] && !_hasRole(Roles.LIQUIDATOR_ROLE, msg.sender)) {\n            revert Errors.AccessDenied();\n        }\n        _;\n    }\n\n    /**\n     * @notice Internal function that updates the user's rewards.\n     * @param account The address of the user to update the rewards for.\n     */\n    function _updateReward(address account) internal {\n        uint256 earnedRewards = 0;\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateBlock = lastBlockRewardApplicable();\n\n        if (account != address(0)) {\n            earnedRewards = earned(account);\n            rewards[account] = earnedRewards;\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n\n        emit UserRewardUpdated(account, earnedRewards, rewardPerTokenStored, lastUpdateBlock);\n    }\n\n    /**\n     * @notice Retrieves the total supply of staked tokens.\n     * @return The total supply of staked tokens.\n     */\n    function totalSupply() public view returns (uint256) {\n        return stakeTracker.totalSupply();\n    }\n\n    /**\n     * @notice Retrieves the balance of staked tokens for a specific account.\n     * @param account The address of the account to retrieve the balance for.\n     * @return The balance of staked tokens for the specified account.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return stakeTracker.balanceOf(account);\n    }\n\n    /**\n     * @notice Determines the last block number applicable for rewards calculation.\n     * @return The block number used for rewards calculation.\n     * @dev If the current block number is less than the period finish => current block number,\n     *      Else => the period finish block number.\n     */\n    function lastBlockRewardApplicable() public view returns (uint256) {\n        return block.number < periodInBlockFinish ? block.number : periodInBlockFinish;\n    }\n\n    /**\n     * @notice Calculates the current reward per token value.\n     * @return The reward per token value.\n     * @dev It takes into account the total supply, reward rate, and duration of the reward period.\n     */\n    function rewardPerToken() public view returns (uint256) {\n        uint256 total = totalSupply();\n        if (total == 0) {\n            return rewardPerTokenStored;\n        }\n\n        return rewardPerTokenStored + ((lastBlockRewardApplicable() - lastUpdateBlock) * rewardRate * 1e18 / total);\n    }\n\n    /**\n     * @notice Calculates the amount of rewards earned by an account.\n     * @dev\n     * The function calculates the earned rewards based on the balance of the account,\n     * the total supply of the staked tokens, the rewards per token and the last reward rate\n     * the user has been paid at. The reward rate is determined by the `rewardPerToken`\n     * function and is a measure of the amount of rewards distributed per staked token\n     * per block.\n     *\n     * The amount of earned rewards is calculated as follows:\n     * - First, it calculates the difference between the current reward per token and\n     *   the last reward rate the user was paid at, which gives the reward rate per token\n     *   since the user last claimed rewards.\n     * - This difference is multiplied by the balance of the account to find the total\n     *   amount of rewards the account has earned since it last claimed rewards.\n     * - Finally, the function adds the rewards that have not yet been claimed by the\n     *   user to find the total amount of earned rewards.\n     *\n     * @param account The address of the account to calculate the earned rewards for.\n     * @return The total amount of rewards that the account has earned.\n     */\n    function earned(address account) public view returns (uint256) {\n        return (balanceOf(account) * (rewardPerToken() - userRewardPerTokenPaid[account]) / 1e18) + rewards[account];\n    }\n\n    /**\n     * @notice Updates the duration of the reward period in blocks.\n     * @param _durationInBlock The new duration of the reward period in blocks.\n     */\n    function setDurationInBlock(uint256 _durationInBlock) external hasRole(Roles.DV_REWARD_MANAGER_ROLE) {\n        durationInBlock = _durationInBlock;\n        emit RewardDurationUpdated(_durationInBlock);\n    }\n\n    /**\n     * @notice Updates the new reward ratio.\n     * @param _newRewardRate The new reward ratio to determine the distribution of rewards.\n     */\n    function setNewRewardRate(uint256 _newRewardRate) external hasRole(Roles.DV_REWARD_MANAGER_ROLE) {\n        newRewardRatio = _newRewardRate;\n        emit NewRewardRateUpdated(_newRewardRate);\n    }\n\n    /**\n     * @notice Queues the specified amount of new rewards for distribution to stakers.\n     * @param newRewards The amount of new rewards.\n     * @dev First, the function transfers the new rewards from the caller to this contract,\n     *      ensuring that the deposited amount matches the declared rewards.\n     *      Then, irrespective of whether we're near the start or the end of a reward period, if the accrued rewards\n     *      are too large relative to the new rewards (i.e., queuedRatio is greater than newRewardRatio), the new\n     *      rewards will be added to the queue rather than being immediately distributed.\n     */\n    function queueNewRewards(uint256 newRewards) external onlyWhitelisted {\n        uint256 startingQueuedRewards = queuedRewards;\n        uint256 startingNewRewards = newRewards;\n\n        newRewards += startingQueuedRewards;\n\n        if (block.number >= periodInBlockFinish) {\n            notifyRewardAmount(newRewards);\n            queuedRewards = 0;\n        } else {\n            uint256 elapsedBlock = block.number - (periodInBlockFinish - durationInBlock);\n            uint256 currentAtNow = rewardRate * elapsedBlock;\n            uint256 queuedRatio = currentAtNow * 1000 / newRewards;\n\n            if (queuedRatio < newRewardRatio) {\n                notifyRewardAmount(newRewards);\n                queuedRewards = 0;\n            } else {\n                queuedRewards = newRewards;\n            }\n        }\n\n        emit QueuedRewardsUpdated(startingQueuedRewards, startingNewRewards, queuedRewards);\n\n        // Transfer the new rewards from the caller to this contract.\n        IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), newRewards);\n    }\n\n    /**\n     * @notice Notifies the contract about the amount of reward tokens to be distributed.\n     * @param reward The amount of reward tokens to be distributed.\n     * @dev The function updates the rewardRate, lastUpdateBlock, periodInBlockFinish, and historicalRewards.\n     *      It calculates the remaining reward based on the current block number and adjusts the reward rate\n     *      accordingly.\n     *\n     *      If the current block number is within the reward period, the remaining reward is added to the reward queue\n     *      and will be distributed gradually over the remaining duration.\n     *      If the current block number exceeds the reward period, the remaining reward is distributed immediately.\n     */\n    function notifyRewardAmount(uint256 reward) internal {\n        _updateReward(address(0));\n        historicalRewards += reward;\n\n        if (block.number < periodInBlockFinish) {\n            uint256 remaining = periodInBlockFinish - block.number;\n            // slither-disable-next-line divide-before-multiply\n            uint256 leftover = remaining * rewardRate;\n            reward += leftover;\n        }\n\n        rewardRate = reward / durationInBlock;\n        currentRewards = reward;\n        lastUpdateBlock = block.number;\n        periodInBlockFinish = block.number + durationInBlock;\n\n        emit RewardAdded(reward, rewardRate, lastUpdateBlock, periodInBlockFinish, historicalRewards);\n    }\n\n    /**\n     * @notice Sets the lock duration for staked Toke tokens.\n     * @dev If the lock duration is set to 0, it turns off the staking functionality for Toke tokens.\n     * @dev If the lock duration is greater than 0, it should be long enough to satisfy the minimum staking duration\n     * requirement of the gpToke contract.\n     * @param _tokeLockDuration The lock duration for staked Toke tokens.\n     */\n    function setTokeLockDuration(uint256 _tokeLockDuration) external hasRole(Roles.DV_REWARD_MANAGER_ROLE) {\n        // if duration is not set to 0 (that would turn off functionality), make sure it's long enough for gpToke\n        if (_tokeLockDuration > 0) {\n            Errors.verifyNotZero(address(systemRegistry.gpToke()), \"gpToke\");\n            if (_tokeLockDuration < systemRegistry.gpToke().minStakeDuration()) {\n                revert IGPToke.StakingDurationTooShort();\n            }\n        }\n\n        tokeLockDuration = _tokeLockDuration;\n        emit TokeLockDurationUpdated(_tokeLockDuration);\n    }\n\n    /**\n     * @notice Add an address to the whitelist.\n     * @param wallet The address to be added to the whitelist.\n     */\n    function addToWhitelist(address wallet) external override hasRole(Roles.DV_REWARD_MANAGER_ROLE) {\n        Errors.verifyNotZero(wallet, \"wallet\");\n        if (whitelistedAddresses[wallet]) {\n            revert Errors.ItemExists();\n        }\n        whitelistedAddresses[wallet] = true;\n\n        emit AddedToWhitelist(wallet);\n    }\n\n    /**\n     * @notice Remove an address from the whitelist.\n     * @param wallet The address to be removed from the whitelist.\n     */\n    function removeFromWhitelist(address wallet) external override hasRole(Roles.DV_REWARD_MANAGER_ROLE) {\n        if (!whitelistedAddresses[wallet]) {\n            revert Errors.ItemNotFound();\n        }\n\n        whitelistedAddresses[wallet] = false;\n\n        emit RemovedFromWhitelist(wallet);\n    }\n\n    /**\n     * @notice Check if an address is whitelisted.\n     * @param wallet The address to be checked.\n     * @return bool indicating if the address is whitelisted.\n     */\n    function isWhitelisted(address wallet) external view override returns (bool) {\n        return whitelistedAddresses[wallet];\n    }\n\n    /**\n     * @notice Internal function to distribute rewards to a specific account.\n     * @param account The address of the user to distribute rewards to.\n     */\n    function _getReward(address account) internal {\n        Errors.verifyNotZero(account, \"account\");\n\n        uint256 reward = earned(account);\n        (IGPToke gpToke, address tokeAddress) = (systemRegistry.gpToke(), address(systemRegistry.toke()));\n\n        // slither-disable-next-line incorrect-equality\n        if (reward == 0) return;\n\n        rewards[account] = 0;\n        emit RewardPaid(account, reward);\n\n        // if NOT toke, or staking is turned off (by duration = 0), just send reward back\n        if (rewardToken != tokeAddress || tokeLockDuration == 0) {\n            IERC20(rewardToken).safeTransfer(account, reward);\n        } else {\n            // authorize gpToke to get our reward Toke\n            // slither-disable-next-line unused-return\n            IERC20(address(tokeAddress)).approve(address(gpToke), reward);\n\n            // stake Toke\n            gpToke.stake(reward, tokeLockDuration, account);\n        }\n    }\n\n    /**\n     * @notice Internal function to handle withdrawals.\n     * @param account The address of the user to handle withdrawal.\n     * @dev This function primarily checks for valid parameters and emits an event.\n     *      It adopts a pattern established by Convex. It helps with:\n     *      - Identifying system errors (if a revert happens here, there is an issue within our system).\n     *      - Enhancing system monitoring capabilities through emitted events.\n     * @param amount The amount to be withdrawn.\n     */\n    function _withdraw(address account, uint256 amount) internal {\n        Errors.verifyNotZero(account, \"account\");\n        Errors.verifyNotZero(amount, \"amount\");\n\n        emit Withdrawn(account, amount);\n    }\n\n    /**\n     * @notice Internal function to handle staking.\n     * @dev This function primarily checks for valid parameters and emits an event.\n     *      It adopts a pattern established by Convex. It helps with:\n     *      - Identifying system errors (if a revert happens here, there is an issue within our system).\n     *      - Enhancing system monitoring capabilities through emitted events.\n     * @param account The address of the user to handle staking.\n     * @param amount The amount to be staked.\n     */\n    function _stake(address account, uint256 amount) internal {\n        Errors.verifyNotZero(account, \"account\");\n        Errors.verifyNotZero(amount, \"amount\");\n\n        emit Staked(account, amount);\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/staking/GPToke.sol",
      "content": "// solhint-disable not-rely-on-time\n// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\npragma solidity 0.8.17;\n\nimport { SafeERC20 } from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20Metadata } from \"openzeppelin-contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ERC20 } from \"openzeppelin-contracts/token/ERC20/ERC20.sol\";\nimport { ERC20Votes } from \"openzeppelin-contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport { ERC20Permit } from \"openzeppelin-contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport { Ownable } from \"openzeppelin-contracts/access/Ownable.sol\";\nimport { Pausable } from \"openzeppelin-contracts/security/Pausable.sol\";\n\nimport { PRBMathUD60x18 } from \"prb-math/contracts/PRBMathUD60x18.sol\";\n\nimport { IWETH9 } from \"src/interfaces/utils/IWETH9.sol\";\nimport { IGPToke } from \"src/interfaces/staking/IGPToke.sol\";\nimport { ISystemRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { SecurityBase } from \"src/security/SecurityBase.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\nimport { SystemComponent } from \"src/SystemComponent.sol\";\n\ncontract GPToke is IGPToke, ERC20Votes, Pausable, SystemComponent, SecurityBase {\n    using SafeERC20 for IERC20Metadata;\n    using SafeERC20 for IWETH9;\n\n    // variables\n    uint256 public immutable startEpoch;\n    uint256 public immutable minStakeDuration;\n    // solhint-disable-next-line const-name-snakecase\n    uint256 public maxStakeDuration = 1461 days; // default 4 years\n    uint256 public constant MIN_STAKE_AMOUNT = 10_000;\n    uint256 public constant MAX_STAKE_AMOUNT = 100e6 * 1e18; // default 100m toke\n\n    mapping(address => Lockup[]) public lockups;\n\n    uint256 private constant YEAR_BASE_BOOST = 18e17;\n    IERC20Metadata public immutable toke;\n\n    //\n    // Reward Vars\n    //\n    IWETH9 private immutable weth;\n\n    uint256 public constant REWARD_FACTOR = 1e12;\n\n    // tracks user's checkpointed reward debt per share\n    mapping(address => uint256) public rewardDebtPerShare;\n    // keeps track of rewards checkpointed / offloaded but not yet transferred\n    mapping(address => uint256) private unclaimedRewards;\n    // total current accumulated reward per share\n    uint256 public accRewardPerShare;\n\n    // See {IGPToke-totalRewardsEarned}\n    uint256 public totalRewardsEarned;\n    // See {IGPToke-totalRewardsClaimed}\n    uint256 public totalRewardsClaimed;\n    // See {IGPToke-rewardsClaimed}\n    mapping(address => uint256) public rewardsClaimed;\n\n    constructor(\n        ISystemRegistry _systemRegistry,\n        uint256 _startEpoch,\n        uint256 _minStakeDuration\n    )\n        SystemComponent(_systemRegistry)\n        ERC20(\"Staked Toke\", \"accToke\")\n        ERC20Permit(\"accToke\")\n        SecurityBase(address(_systemRegistry.accessController()))\n    {\n        startEpoch = _startEpoch;\n        minStakeDuration = _minStakeDuration;\n\n        toke = systemRegistry.toke();\n        weth = systemRegistry.weth();\n    }\n\n    // @dev short-circuit transfers\n    function transfer(address, uint256) public pure override returns (bool) {\n        revert TransfersDisabled();\n    }\n\n    // @dev short-circuit transfers\n    function transferFrom(address, address, uint256) public pure override returns (bool) {\n        revert TransfersDisabled();\n    }\n\n    /// @inheritdoc IGPToke\n    function stake(uint256 amount, uint256 duration, address to) external {\n        _stake(amount, duration, to);\n    }\n\n    /// @inheritdoc IGPToke\n    function stake(uint256 amount, uint256 duration) external {\n        _stake(amount, duration, msg.sender);\n    }\n\n    function _stake(uint256 amount, uint256 duration, address to) internal whenNotPaused {\n        //\n        // validation checks\n        //\n        if (to == address(0)) revert ZeroAddress();\n        if (amount < MIN_STAKE_AMOUNT) revert StakingAmountInsufficient();\n        if (amount > MAX_STAKE_AMOUNT) revert StakingAmountExceeded();\n\n        // duration checked inside previewPoints\n        (uint256 points, uint256 end) = previewPoints(amount, duration);\n\n        if (points + totalSupply() > type(uint192).max) {\n            revert StakingPointsExceeded();\n        }\n\n        // checkpoint rewards for caller\n        _collectRewards(to, false);\n\n        // save information for current lockup\n        lockups[to].push(Lockup({ amount: uint128(amount), end: uint128(end), points: points }));\n\n        // create points for user\n        _mint(to, points);\n\n        emit Stake(to, lockups[to].length - 1, amount, end, points);\n\n        // transfer staked toke in\n        toke.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    /// @inheritdoc IGPToke\n    function unstake(uint256 lockupId) external whenNotPaused {\n        if (lockupId >= lockups[msg.sender].length) revert LockupDoesNotExist();\n\n        // get staking information\n        Lockup memory lockup = lockups[msg.sender][lockupId];\n        uint256 amount = lockup.amount;\n        uint256 end = lockup.end;\n        uint256 points = lockup.points;\n\n        // slither-disable-next-line timestamp\n        if (block.timestamp < end) revert NotUnlockableYet();\n        if (end == 0) revert AlreadyUnlocked();\n\n        // checkpoint rewards\n        _collectRewards(msg.sender, false);\n\n        // remove stake\n        delete lockups[msg.sender][lockupId];\n\n        // wipe points\n        _burn(msg.sender, points);\n\n        emit Unstake(msg.sender, lockupId, amount, end, points);\n\n        // send staked toke back to user\n        toke.safeTransfer(msg.sender, amount);\n    }\n\n    /// @inheritdoc IGPToke\n    function extend(uint256 lockupId, uint256 duration) external whenNotPaused {\n        if (lockupId >= lockups[msg.sender].length) revert LockupDoesNotExist();\n\n        // before doing anything, make sure the rewards checkpoints are updated!\n        _collectRewards(msg.sender, false);\n\n        // duration checked inside previewPoints\n        Lockup storage lockup = lockups[msg.sender][lockupId];\n        uint256 oldAmount = lockup.amount;\n        uint256 oldEnd = lockup.end;\n        uint256 oldPoints = lockup.points;\n\n        (uint256 newPoints, uint256 newEnd) = previewPoints(oldAmount, duration);\n\n        if (newEnd <= oldEnd) revert ExtendDurationTooShort();\n        lockup.end = uint128(newEnd);\n        lockup.points = newPoints;\n        lockups[msg.sender][lockupId] = lockup;\n        // issue extra points for extension\n        _mint(msg.sender, newPoints - oldPoints);\n\n        emit Extend(msg.sender, lockupId, oldAmount, oldEnd, newEnd, oldPoints, newPoints);\n    }\n\n    /// @inheritdoc IGPToke\n    function previewPoints(uint256 amount, uint256 duration) public view returns (uint256 points, uint256 end) {\n        if (duration < minStakeDuration) revert StakingDurationTooShort();\n        if (duration > maxStakeDuration) revert StakingDurationTooLong();\n\n        // slither-disable-next-line timestamp\n        uint256 start = block.timestamp > startEpoch ? block.timestamp : startEpoch;\n        end = start + duration;\n\n        // calculate points based on duration from staking end date\n        uint256 endYearpoc = ((end - startEpoch) * 1e18) / 365 days;\n        uint256 multiplier = PRBMathUD60x18.pow(YEAR_BASE_BOOST, endYearpoc);\n\n        points = (amount * multiplier) / 1e18;\n    }\n\n    /// @inheritdoc IGPToke\n    function getLockups(address user) external view returns (Lockup[] memory) {\n        return lockups[user];\n    }\n\n    /// @notice Update max stake duration allowed\n    function setMaxStakeDuration(uint256 _maxStakeDuration) external onlyOwner {\n        uint256 old = maxStakeDuration;\n\n        maxStakeDuration = _maxStakeDuration;\n\n        emit SetMaxStakeDuration(old, _maxStakeDuration);\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /* **************************************************************************** */\n    /*\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*/\n    /* \t\t\t\t\t\t\t\t\tRewards\t\t\t\t\t\t\t\t\t\t*/\n    /*\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*/\n    /* **************************************************************************** */\n\n    /// @notice Allows an actor to deposit ETH as staking reward to be distributed to all staked participants\n    /// @param amount Amount of `WETH` to take from caller and deposit as reward for the stakers\n    function addWETHRewards(uint256 amount) external whenNotPaused {\n        Errors.verifyNotZero(amount, \"amount\");\n\n        uint256 supply = totalSupply();\n        Errors.verifyNotZero(supply, \"supply\");\n\n        totalRewardsEarned += amount;\n        accRewardPerShare += amount * REWARD_FACTOR / supply;\n\n        emit RewardsAdded(amount);\n\n        weth.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    /// @inheritdoc IGPToke\n    function previewRewards() external view returns (uint256 amount) {\n        return previewRewards(msg.sender);\n    }\n\n    /// @inheritdoc IGPToke\n    function previewRewards(address user) public view returns (uint256 amount) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            return unclaimedRewards[user];\n        }\n\n        // calculate reward per share by taking the current reward per share and subtracting what user already claimed\n        uint256 _netRewardsPerShare = accRewardPerShare - rewardDebtPerShare[user];\n\n        // calculate full reward user is entitled to by taking their recently earned and adding unclaimed checkpointed\n        return ((balanceOf(user) * _netRewardsPerShare) / REWARD_FACTOR) + unclaimedRewards[user];\n    }\n\n    /// @inheritdoc IGPToke\n    function collectRewards() external returns (uint256) {\n        return _collectRewards(msg.sender, true);\n    }\n\n    /// @dev See {IGPToke-collectRewards}.\n    function _collectRewards(address user, bool distribute) internal returns (uint256) {\n        // calculate user's new rewards per share (current minus claimed)\n        uint256 netRewardsPerShare = accRewardPerShare - rewardDebtPerShare[user];\n        // calculate amount of actual rewards\n        uint256 netRewards = (balanceOf(user) * netRewardsPerShare) / REWARD_FACTOR;\n        // get reference to user's pending (sandboxed) rewards\n        uint256 pendingRewards = unclaimedRewards[user];\n\n        // update checkpoint to current\n        rewardDebtPerShare[user] = accRewardPerShare;\n\n        // if nothing to claim, bail\n        if (netRewards == 0 && pendingRewards == 0) {\n            return 0;\n        }\n\n        if (distribute) {\n            //\n            // if asked for actual distribution, transfer all earnings\n            //\n\n            // reset sandboxed rewards\n            unclaimedRewards[user] = 0;\n\n            // get total amount by adding new rewards and previously sandboxed\n            uint256 totalClaiming = netRewards + pendingRewards;\n\n            // update running totals\n            totalRewardsClaimed += totalClaiming;\n            rewardsClaimed[user] += totalClaiming;\n\n            emit RewardsClaimed(user, totalClaiming);\n\n            // send rewards to user\n            weth.safeTransfer(user, totalClaiming);\n\n            // return total amount claimed"
    }
  ]
}