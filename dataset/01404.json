{
  "Title": "H-5: Curve V2 Vaults can be drained because CurveV2CryptoEthOracle can be reentered with WETH tokens",
  "Content": "# Issue H-5: Curve V2 Vaults can be drained because CurveV2CryptoEthOracle can be reentered with WETH tokens \n\nSource: https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/481 \n\n## Found by \n0x007, 0xVolodya, Kalyan-Singh\nCurveV2CryptoEthOracle assumes that Curve pools that could be reentered must have `0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE` token. But this is a wrong assumption cause tokens with WETH token could be reentered too.\n\n## Vulnerability Detail\n`CurveV2CryptoEthOracle.registerPool` takes `checkReentrancy` parameters and this should be True only for pools that have `0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE` tokens and this is validated [here](https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/oracles/providers/CurveV2CryptoEthOracle.sol#L122).\n```solidity\naddress public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n...\n\n// Only need ability to check for read-only reentrancy for pools containing native Eth.\nif (checkReentrancy) {\n    if (tokens[0] != ETH && tokens[1] != ETH) revert MustHaveEthForReentrancy();\n}\n```\n\nThis Oracle is meant for Curve V2 pools and the ones I've seen so far use WETH address instead of `0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE` (like Curve V1) and this applies to all pools listed by Tokemak. \n\nFor illustration, I'll use the same pool used to [test proper registration](https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/test/oracles/providers/CurveV2CryptoEthOracle.t.sol#L126-L136). The test is for `CRV_ETH_CURVE_V2_POOL` but this applies to other V2 pools including [rETH/ETH](https://etherscan.io/address/0x0f3159811670c117c372428d4e69ac32325e4d0f). The pool address for `CRV_ETH_CURVE_V2_POOL` is [0x8301AE4fc9c624d1D396cbDAa1ed877821D7C511](https://etherscan.io/address/0x8301AE4fc9c624d1D396cbDAa1ed877821D7C511#code) while token address is [0xEd4064f376cB8d68F770FB1Ff088a3d0F3FF5c4d](https://etherscan.io/address/0xEd4064f376cB8d68F770FB1Ff088a3d0F3FF5c4d).\n\nIf you interact with the pool, the coins are:\n0 - WETH - 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n1 - CRV - 0xD533a949740bb3306d119CC777fa900bA034cd52\n\n**So how can WETH be reentered?!**\nBecause Curve can accept ETH for WETH pools.\n\nA look at the [pool](https://etherscan.io/address/0x8301AE4fc9c624d1D396cbDAa1ed877821D7C511#code) again shows that Curve uses python kwargs and it includes a variable `use_eth` for `exchange`, `add_liquidity`, `remove_liquidity` and `remove_liquidity_one_coin`. \n\n```vyper\ndef exchange(i: uint256, j: uint256, dx: uint256, min_dy: uint256, use_eth: bool = False) -> uint256:\ndef add_liquidity(amounts: uint256[N_COINS], min_mint_amount: uint256, use_eth: bool = False) -> uint256:\ndef remove_liquidity(_amount: uint256, min_amounts: uint256[N_COINS], use_eth: bool = False):\ndef remove_liquidity_one_coin(token_amount: uint256, i: uint256, min_amount: uint256, use_eth: bool = False) -> uint256:\n```\n\nWhen `use_eth` is `true`, it would take `msg.value` instead of transfer WETH from user. And it would make a raw call instead of transfer WETH to user.\n\nIf raw call is sent to user, then they could reenter LMP vault and attack the protocol and it would be successful cause CurveV2CryptoEthOracle would not check for reentrancy in [getPriceInEth](https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/oracles/providers/CurveV2CryptoEthOracle.sol#L160-L163)\n\n```solidity\n// Checking for read only reentrancy scenario.\nif (poolInfo.checkReentrancy == 1) {\n    // This will fail in a reentrancy situation.\n    cryptoPool.claim_admin_fees();\n}\n```\n\nA profitable attack that could be used to drain the vault involves\n* Deposit shares at fair price\n* Remove liquidity on Curve and updateDebtReporting in LMPVault with view only reentrancy\n* Withdraw shares at unfair price\n\n## Impact\nThe protocol could be attacked with price manipulation using Curve read only reentrancy. The consequence would be fatal because `getPriceInEth` is used for evaluating debtValue and this evaluation decides shares and debt that would be burned in a withdrawal. Therefore, an inflated value allows attacker to withdraw too many asset for their shares. This could be abused to drain assets on LMPVault.\n\nThe attack is cheap, easy and could be bundled in as a flashloan attack. And it puts the whole protocol at risk cause a large portion of their deposit would be on Curve V2 pools with WETH token.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/oracles/providers/CurveV2CryptoEthOracle.sol#L121-L123\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/oracles/providers/CurveV2CryptoEthOracle.sol#L160-L163\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/test/oracles/providers/CurveV2CryptoEthOracle.t.sol#L126-L136\nhttps://etherscan.io/address/0x8301AE4fc9c624d1D396cbDAa1ed877821D7C511#code\n\n## Tool used\n\nManual Review\n\n## Recommendation\nIf CurveV2CryptoEthOracle is meant for CurveV2 pools with WETH (and no 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE), then change the ETH address to weth. As far as I can tell Curve V2 uses WETH address for ETH but this needs to be verified.\n\n```solidity\n-   if (tokens[0] != ETH && tokens[1] != ETH) revert MustHaveEthForReentrancy();\n+   if (tokens[0] != WETH && tokens[1] != WETH) revert MustHaveEthForReentrancy();\n```\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/101",
  "Code": [
    {
      "filename": "v2-core-audit-2023-07-14/src/oracles/providers/CurveV2CryptoEthOracle.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\n\npragma solidity 0.8.17;\n\nimport { SecurityBase } from \"src/security/SecurityBase.sol\";\nimport { IPriceOracle } from \"src/interfaces/oracles/IPriceOracle.sol\";\nimport { SystemComponent } from \"src/SystemComponent.sol\";\nimport { ISystemRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { ICurveResolver } from \"src/interfaces/utils/ICurveResolver.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\nimport { ICryptoSwapPool } from \"src/interfaces/external/curve/ICryptoSwapPool.sol\";\n\ncontract CurveV2CryptoEthOracle is SystemComponent, SecurityBase, IPriceOracle {\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    ICurveResolver public immutable curveResolver;\n\n    /**\n     * @notice Struct for neccessary information for single Curve pool.\n     * @param pool The address of the curve pool.\n     * @param checkReentrancy uint8 representing a boolean.  0 for false, 1 for true.\n     * @param tokentoPrice Address of the token being priced in the Curve pool.\n     */\n    struct PoolData {\n        address pool;\n        uint8 checkReentrancy;\n        address tokenToPrice;\n    }\n\n    /**\n     * @notice Emitted when token Curve pool is registered.\n     * @param lpToken Lp token that has been registered.\n     */\n    event TokenRegistered(address lpToken);\n\n    /**\n     * @notice Emitted when a Curve pool registration is removed.\n     * @param lpToken Lp token that has been unregistered.\n     */\n    event TokenUnregistered(address lpToken);\n\n    /**\n     * @notice Thrown when pool returned is not a v2 curve pool.\n     * @param curvePool Address of the pool that was attempted to be registered.\n     */\n    error NotCryptoPool(address curvePool);\n\n    /**\n     * @notice Thrown when wrong lp token is returned from CurveResolver.sol.\n     * @param providedLP Address of lp token provided in function call.\n     * @param queriedLP Address of lp tokens returned from resolver.\n     */\n    error ResolverMismatch(address providedLP, address queriedLP);\n\n    /**\n     * @notice Thrown when a Curve V2 Lp token is already registered.\n     * @param curveLpToken The address of the token attempted to be deployed.\n     */\n    error AlreadyRegistered(address curveLpToken);\n\n    /**\n     * @notice Thrown when lp token is not registered.\n     * @param curveLpToken Address of token expected to be registered.\n     */\n    error NotRegistered(address curveLpToken);\n\n    /**\n     * @notice Thrown when a pool with an invalid number of tokens is attempted to be registered.\n     * @param numTokens The number of tokens in the pool attempted to be registered.\n     */\n    error InvalidNumTokens(uint256 numTokens);\n\n    /**\n     * @notice Thrown when a pool that does not have native Eth as a token in the pair is registered\n     *      for a read only reentrancy check.\n     */\n    error MustHaveEthForReentrancy();\n\n    /**\n     * @notice Thrown when y and z values do not converge during square root calculation.\n     */\n    error SqrtError();\n\n    /// @notice Reverse mapping of LP token to pool info.\n    mapping(address => PoolData) public lpTokenToPool;\n\n    /**\n     * @param _systemRegistry Instance of system registry for this version of the system.\n     * @param _curveResolver Instance of Curve Resolver.\n     */\n    constructor(\n        ISystemRegistry _systemRegistry,\n        ICurveResolver _curveResolver\n    ) SystemComponent(_systemRegistry) SecurityBase(address(_systemRegistry.accessController())) {\n        Errors.verifyNotZero(address(_systemRegistry.rootPriceOracle()), \"rootPriceOracle\");\n        Errors.verifyNotZero(address(_curveResolver), \"_curveResolver\");\n\n        curveResolver = _curveResolver;\n    }\n\n    /**\n     * @notice Allows owner of system to register a pool.\n     * @param curvePool Address of CurveV2 pool.\n     * @param curveLpToken Address of LP token associated with v2 pool.\n     * @param checkReentrancy Whether to check read-only reentrancy on pool.\n     */\n    function registerPool(address curvePool, address curveLpToken, bool checkReentrancy) external onlyOwner {\n        Errors.verifyNotZero(curvePool, \"curvePool\");\n        Errors.verifyNotZero(curveLpToken, \"curveLpToken\");\n        if (lpTokenToPool[curveLpToken].pool != address(0)) revert AlreadyRegistered(curveLpToken);\n\n        (address[8] memory tokens, uint256 numTokens, address lpToken, bool isStableSwap) =\n            curveResolver.resolveWithLpToken(curvePool);\n\n        // Only two token pools compatible with this contract.\n        if (numTokens != 2) revert InvalidNumTokens(numTokens);\n        if (isStableSwap) revert NotCryptoPool(curvePool);\n        if (lpToken != curveLpToken) revert ResolverMismatch(curveLpToken, lpToken);\n\n        // Only need ability to check for read-only reentrancy for pools containing native Eth.\n        if (checkReentrancy) {\n            if (tokens[0] != ETH && tokens[1] != ETH) revert MustHaveEthForReentrancy();\n        }\n\n        /**\n         * Curve V2 pools always price second token in `coins` array in first token in `coins` array.  This means that\n         *    if `coins[0]` is Weth, and `coins[1]` is rEth, the price will be rEth as base and weth as quote.  Hence\n         *    to get lp price we will always want to use the second token in the array, priced in eth.\n         */\n        lpTokenToPool[lpToken] =\n            PoolData({ pool: curvePool, checkReentrancy: checkReentrancy ? 1 : 0, tokenToPrice: tokens[1] });\n\n        emit TokenRegistered(lpToken);\n    }\n\n    /**\n     * @notice Allows owner of system to unregister curve pool.\n     * @param curveLpToken Address of CurveV2 lp token to unregister.\n     */\n    function unregister(address curveLpToken) external onlyOwner {\n        Errors.verifyNotZero(curveLpToken, \"curveLpToken\");\n\n        if (lpTokenToPool[curveLpToken].pool == address(0)) revert NotRegistered(curveLpToken);\n\n        delete lpTokenToPool[curveLpToken];\n\n        emit TokenUnregistered(curveLpToken);\n    }\n\n    /// @inheritdoc IPriceOracle\n    function getPriceInEth(address token) external returns (uint256 price) {\n        Errors.verifyNotZero(token, \"token\");\n\n        PoolData memory poolInfo = lpTokenToPool[token];\n        if (poolInfo.pool == address(0)) revert NotRegistered(token);\n\n        ICryptoSwapPool cryptoPool = ICryptoSwapPool(poolInfo.pool);\n\n        // Checking for read only reentrancy scenario.\n        if (poolInfo.checkReentrancy == 1) {\n            // This will fail in a reentrancy situation.\n            cryptoPool.claim_admin_fees();\n        }\n\n        uint256 virtualPrice = cryptoPool.get_virtual_price();\n        uint256 assetPrice = systemRegistry.rootPriceOracle().getPriceInEth(poolInfo.tokenToPrice);\n\n        return (2 * virtualPrice * sqrt(assetPrice)) / 10 ** 18;\n    }\n\n    // solhint-disable max-line-length\n    // Adapted from CurveV2 pools, see here:\n    // https://github.com/curvefi/curve-crypto-contract/blob/d7d04cd9ae038970e40be850df99de8c1ff7241b/contracts/two/CurveCryptoSwap2.vy#L1330\n    function sqrt(uint256 x) private pure returns (uint256) {\n        if (x == 0) return 0;\n\n        uint256 z = (x + 10 ** 18) / 2;\n        uint256 y = x;\n\n        for (uint256 i = 0; i < 256;) {\n            if (z == y) {\n                return y;\n            }\n            y = z;\n            z = (x * 10 ** 18 / z + z) / 2;\n\n            unchecked {\n                ++i;\n            }\n        }\n        revert SqrtError();\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/test/oracles/providers/CurveV2CryptoEthOracle.t.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\n\npragma solidity 0.8.17;\n\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\nimport { Test } from \"forge-std/Test.sol\";\n\nimport {\n    CURVE_META_REGISTRY_MAINNET,\n    CRV_ETH_CURVE_V2_LP,\n    CRV_ETH_CURVE_V2_POOL,\n    THREE_CURVE_MAINNET,\n    STETH_WETH_CURVE_POOL,\n    CVX_ETH_CURVE_V2_LP,\n    STG_USDC_V2_POOL,\n    STG_USDC_CURVE_V2_LP,\n    CRV_MAINNET\n} from \"test/utils/Addresses.sol\";\n\nimport { CurveV2CryptoEthOracle } from \"src/oracles/providers/CurveV2CryptoEthOracle.sol\";\nimport { SystemRegistry } from \"src/SystemRegistry.sol\";\nimport { AccessController } from \"src/security/AccessController.sol\";\nimport { RootPriceOracle } from \"src/oracles/RootPriceOracle.sol\";\nimport { CurveResolverMainnet } from \"src/utils/CurveResolverMainnet.sol\";\nimport { ISystemRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { ICurveResolver } from \"src/interfaces/utils/ICurveResolver.sol\";\nimport { ICurveMetaRegistry } from \"src/interfaces/external/curve/ICurveMetaRegistry.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\n\ncontract CurveV2CryptoEthOracleTest is Test {\n    SystemRegistry public registry;\n    AccessController public accessControl;\n    RootPriceOracle public oracle;\n\n    CurveResolverMainnet public curveResolver;\n    CurveV2CryptoEthOracle public curveOracle;\n\n    event TokenRegistered(address lpToken);\n    event TokenUnregistered(address lpToken);\n\n    function setUp() external {\n        vm.createSelectFork(vm.envString(\"MAINNET_RPC_URL\"), 17_671_884);\n\n        registry = new SystemRegistry(address(1), address(2));\n\n        accessControl = new AccessController(address(registry));\n        registry.setAccessController(address(accessControl));\n\n        oracle = new RootPriceOracle(registry);\n        registry.setRootPriceOracle(address(oracle));\n\n        curveResolver = new CurveResolverMainnet(ICurveMetaRegistry(CURVE_META_REGISTRY_MAINNET));\n        curveOracle =\n            new CurveV2CryptoEthOracle(ISystemRegistry(address(registry)), ICurveResolver(address(curveResolver)));\n    }\n\n    // Constructor\n    function test_RevertRootPriceOracleZeroAddress() external {\n        SystemRegistry localRegistry = new SystemRegistry(address(1), address(2));\n        AccessController localAccessControl = new AccessController(address(localRegistry));\n        localRegistry.setAccessController(address(localAccessControl));\n\n        vm.expectRevert(abi.encodeWithSelector(Errors.ZeroAddress.selector, \"rootPriceOracle\"));\n        new CurveV2CryptoEthOracle(localRegistry, curveResolver);\n    }\n\n    function test_RevertCurveResolverAddressZero() external {\n        vm.expectRevert(abi.encodeWithSelector(Errors.ZeroAddress.selector, \"_curveResolver\"));\n        new CurveV2CryptoEthOracle(registry, ICurveResolver(address(0)));\n    }\n\n    function test_ProperlySetsState() external {\n        assertEq(address(curveOracle.curveResolver()), address(curveResolver));\n    }\n\n    // Register\n    function test_RevertNonOwnerRegister() external {\n        vm.prank(address(1));\n        vm.expectRevert(Errors.AccessDenied.selector);\n        curveOracle.registerPool(CRV_ETH_CURVE_V2_POOL, CRV_ETH_CURVE_V2_LP, false);\n    }\n\n    function test_RevertZeroAddressCurvePool() external {\n        vm.expectRevert(abi.encodeWithSelector(Errors.ZeroAddress.selector, \"curvePool\"));\n        curveOracle.registerPool(address(0), CRV_ETH_CURVE_V2_LP, false);\n    }\n\n    function test_ZeroAddressLpTokenRegistration() external {\n        vm.expectRevert(abi.encodeWithSelector(Errors.ZeroAddress.selector, \"curveLpToken\"));\n        curveOracle.registerPool(CRV_ETH_CURVE_V2_POOL, address(0), false);\n    }\n\n    function test_LpTokenAlreadyRegistered() external {\n        curveOracle.registerPool(CRV_ETH_CURVE_V2_POOL, CRV_ETH_CURVE_V2_LP, false);\n\n        vm.expectRevert(abi.encodeWithSelector(CurveV2CryptoEthOracle.AlreadyRegistered.selector, CRV_ETH_CURVE_V2_LP));\n        curveOracle.registerPool(CRV_ETH_CURVE_V2_POOL, CRV_ETH_CURVE_V2_LP, false);\n    }\n\n    function test_InvalidTokenNumber() external {\n        vm.expectRevert(abi.encodeWithSelector(CurveV2CryptoEthOracle.InvalidNumTokens.selector, 3));\n        curveOracle.registerPool(THREE_CURVE_MAINNET, CRV_ETH_CURVE_V2_LP, false);\n    }\n\n    function test_NotCryptoPool() external {\n        vm.expectRevert(abi.encodeWithSelector(CurveV2CryptoEthOracle.NotCryptoPool.selector, STETH_WETH_CURVE_POOL));\n        curveOracle.registerPool(STETH_WETH_CURVE_POOL, CRV_ETH_CURVE_V2_LP, false);\n    }\n\n    function test_LpTokenMistmatch() external {\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                CurveV2CryptoEthOracle.ResolverMismatch.selector, CVX_ETH_CURVE_V2_LP, CRV_ETH_CURVE_V2_LP\n            )\n        );\n        curveOracle.registerPool(CRV_ETH_CURVE_V2_POOL, CVX_ETH_CURVE_V2_LP, false);\n    }\n\n    function test_ReentrancyRegistration() external {\n        vm.expectRevert(CurveV2CryptoEthOracle.MustHaveEthForReentrancy.selector);\n        curveOracle.registerPool(STG_USDC_V2_POOL, STG_USDC_CURVE_V2_LP, true);\n    }\n\n    function test_ProperRegistration() external {\n        vm.expectEmit(false, false, false, true);\n        emit TokenRegistered(CRV_ETH_CURVE_V2_LP);\n\n        curveOracle.registerPool(CRV_ETH_CURVE_V2_POOL, CRV_ETH_CURVE_V2_LP, false);\n\n        (address pool, uint8 reentrancy, address priceToken) = curveOracle.lpTokenToPool(CRV_ETH_CURVE_V2_LP);\n        assertEq(pool, CRV_ETH_CURVE_V2_POOL);\n        assertEq(reentrancy, 0);\n        assertEq(priceToken, CRV_MAINNET);\n    }\n\n    // Unregister\n    function test_RevertNonOwnerUnRegister() external {\n        vm.prank(address(1));\n        vm.expectRevert(Errors.AccessDenied.selector);\n        curveOracle.unregister(CRV_ETH_CURVE_V2_LP);\n    }\n\n    function test_RevertZeroAddressUnRegister() external {\n        vm.expectRevert(abi.encodeWithSelector(Errors.ZeroAddress.selector, \"curveLpToken\"));\n        curveOracle.unregister(address(0));\n    }\n\n    function test_LpNotRegistered() external {\n        vm.expectRevert(abi.encodeWithSelector(CurveV2CryptoEthOracle.NotRegistered.selector, CRV_ETH_CURVE_V2_LP));\n        curveOracle.unregister(CRV_ETH_CURVE_V2_LP);\n    }\n\n    function test_ProperUnRegister() external {\n        // Register first\n        curveOracle.registerPool(CRV_ETH_CURVE_V2_POOL, CRV_ETH_CURVE_V2_LP, false);\n\n        vm.expectEmit(false, false, false, true);\n        emit TokenUnregistered(CRV_ETH_CURVE_V2_LP);\n\n        curveOracle.unregister(CRV_ETH_CURVE_V2_LP);\n\n        (address pool, uint8 reentrancy, address tokenToPrice) = curveOracle.lpTokenToPool(CRV_ETH_CURVE_V2_LP);\n        assertEq(pool, address(0));\n        assertEq(reentrancy, 0);\n        assertEq(tokenToPrice, address(0));\n    }\n\n    // getPriceInEth\n    // Actual pricing return functionality tested in `RootPriceOracleIntegrationTest.sol`\n    function test_RevertTokenZeroAddress() external {\n        vm.expectRevert(abi.encodeWithSelector(Errors.ZeroAddress.selector, \"token\"));\n        curveOracle.getPriceInEth(address(0));\n    }\n\n    function test_RevertTokenNotRegistered() external {\n        vm.expectRevert(abi.encodeWithSelector(CurveV2CryptoEthOracle.NotRegistered.selector, CRV_ETH_CURVE_V2_LP));\n        curveOracle.getPriceInEth(CRV_ETH_CURVE_V2_LP);\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/oracles/providers/CurveV2CryptoEthOracle.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\n\npragma solidity 0.8.17;\n\nimport { SecurityBase } from \"src/security/SecurityBase.sol\";\nimport { IPriceOracle } from \"src/interfaces/oracles/IPriceOracle.sol\";\nimport { SystemComponent } from \"src/SystemComponent.sol\";\nimport { ISystemRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { ICurveResolver } from \"src/interfaces/utils/ICurveResolver.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\nimport { ICryptoSwapPool } from \"src/interfaces/external/curve/ICryptoSwapPool.sol\";\n\ncontract CurveV2CryptoEthOracle is SystemComponent, SecurityBase, IPriceOracle {\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    ICurveResolver public immutable curveResolver;\n\n    /**\n     * @notice Struct for neccessary information for single Curve pool.\n     * @param pool The address of the curve pool.\n     * @param checkReentrancy uint8 representing a boolean.  0 for false, 1 for true.\n     * @param tokentoPrice Address of the token being priced in the Curve pool.\n     */\n    struct PoolData {\n        address pool;\n        uint8 checkReentrancy;\n        address tokenToPrice;\n    }\n\n    /**\n     * @notice Emitted when token Curve pool is registered.\n     * @param lpToken Lp token that has been registered.\n     */\n    event TokenRegistered(address lpToken);\n\n    /**\n     * @notice Emitted when a Curve pool registration is removed.\n     * @param lpToken Lp token that has been unregistered.\n     */\n    event TokenUnregistered(address lpToken);\n\n    /**\n     * @notice Thrown when pool returned is not a v2 curve pool.\n     * @param curvePool Address of the pool that was attempted to be registered.\n     */\n    error NotCryptoPool(address curvePool);\n\n    /**\n     * @notice Thrown when wrong lp token is returned from CurveResolver.sol.\n     * @param providedLP Address of lp token provided in function call.\n     * @param queriedLP Address of lp tokens returned from resolver.\n     */\n    error ResolverMismatch(address providedLP, address queriedLP);\n\n    /**\n     * @notice Thrown when a Curve V2 Lp token is already registered.\n     * @param curveLpToken The address of the token attempted to be deployed.\n     */\n    error AlreadyRegistered(address curveLpToken);\n\n    /**\n     * @notice Thrown when lp token is not registered.\n     * @param curveLpToken Address of token expected to be registered.\n     */\n    error NotRegistered(address curveLpToken);\n\n    /**\n     * @notice Thrown when a pool with an invalid number of tokens is attempted to be registered.\n     * @param numTokens The number of tokens in the pool attempted to be registered.\n     */\n    error InvalidNumTokens(uint256 numTokens);\n\n    /**\n     * @notice Thrown when a pool that does not have native Eth as a token in the pair is registered\n     *      for a read only reentrancy check.\n     */\n    error MustHaveEthForReentrancy();\n\n    /**\n     * @notice Thrown when y and z values do not converge during square root calculation.\n     */\n    error SqrtError();\n\n    /// @notice Reverse mapping of LP token to pool info.\n    mapping(address => PoolData) public lpTokenToPool;\n\n    /**\n     * @param _systemRegistry Instance of system registry for this version of the system.\n     * @param _curveResolver Instance of Curve Resolver.\n     */\n    constructor(\n        ISystemRegistry _systemRegistry,\n        ICurveResolver _curveResolver\n    ) SystemComponent(_systemRegistry) SecurityBase(address(_systemRegistry.accessController())) {\n        Errors.verifyNotZero(address(_systemRegistry.rootPriceOracle()), \"rootPriceOracle\");\n        Errors.verifyNotZero(address(_curveResolver), \"_curveResolver\");\n\n        curveResolver = _curveResolver;\n    }\n\n    /**\n     * @notice Allows owner of system to register a pool.\n     * @param curvePool Address of CurveV2 pool.\n     * @param curveLpToken Address of LP token associated with v2 pool.\n     * @param checkReentrancy Whether to check read-only reentrancy on pool.\n     */\n    function registerPool(address curvePool, address curveLpToken, bool checkReentrancy) external onlyOwner {\n        Errors.verifyNotZero(curvePool, \"curvePool\");\n        Errors.verifyNotZero(curveLpToken, \"curveLpToken\");\n        if (lpTokenToPool[curveLpToken].pool != address(0)) revert AlreadyRegistered(curveLpToken);\n\n        (address[8] memory tokens, uint256 numTokens, address lpToken, bool isStableSwap) =\n            curveResolver.resolveWithLpToken(curvePool);\n\n        // Only two token pools compatible with this contract.\n        if (numTokens != 2) revert InvalidNumTokens(numTokens);\n        if (isStableSwap) revert NotCryptoPool(curvePool);\n        if (lpToken != curveLpToken) revert ResolverMismatch(curveLpToken, lpToken);\n\n        // Only need ability to check for read-only reentrancy for pools containing native Eth.\n        if (checkReentrancy) {\n            if (tokens[0] != ETH && tokens[1] != ETH) revert MustHaveEthForReentrancy();\n        }\n\n        /**\n         * Curve V2 pools always price second token in `coins` array in first token in `coins` array.  This means that\n         *    if `coins[0]` is Weth, and `coins[1]` is rEth, the price will be rEth as base and weth as quote.  Hence\n         *    to get lp price we will always want to use the second token in the array, priced in eth.\n         */\n        lpTokenToPool[lpToken] =\n            PoolData({ pool: curvePool, checkReentrancy: checkReentrancy ? 1 : 0, tokenToPrice: tokens[1] });\n\n        emit TokenRegistered(lpToken);\n    }\n\n    /**\n     * @notice Allows owner of system to unregister curve pool.\n     * @param curveLpToken Address of CurveV2 lp token to unregister.\n     */\n    function unregister(address curveLpToken) external onlyOwner {\n        Errors.verifyNotZero(curveLpToken, \"curveLpToken\");\n\n        if (lpTokenToPool[curveLpToken].pool == address(0)) revert NotRegistered(curveLpToken);\n\n        delete lpTokenToPool[curveLpToken];\n\n        emit TokenUnregistered(curveLpToken);\n    }\n\n    /// @inheritdoc IPriceOracle\n    function getPriceInEth(address token) external returns (uint256 price) {\n        Errors.verifyNotZero(token, \"token\");\n\n        PoolData memory poolInfo = lpTokenToPool[token];\n        if (poolInfo.pool == address(0)) revert NotRegistered(token);\n\n        ICryptoSwapPool cryptoPool = ICryptoSwapPool(poolInfo.pool);\n\n        // Checking for read only reentrancy scenario.\n        if (poolInfo.checkReentrancy == 1) {\n            // This will fail in a reentrancy situation.\n            cryptoPool.claim_admin_fees();\n        }\n\n        uint256 virtualPrice = cryptoPool.get_virtual_price();\n        uint256 assetPrice = systemRegistry.rootPriceOracle().getPriceInEth(poolInfo.tokenToPrice);\n\n        return (2 * virtualPrice * sqrt(assetPrice)) / 10 ** 18;\n    }\n\n    // solhint-disable max-line-length\n    // Adapted from CurveV2 pools, see here:\n    // https://github.com/curvefi/curve-crypto-contract/blob/d7d04cd9ae038970e40be850df99de8c1ff7241b/contracts/two/CurveCryptoSwap2.vy#L1330\n    function sqrt(uint256 x) private pure returns (uint256) {\n        if (x == 0) return 0;\n\n        uint256 z = (x + 10 ** 18) / 2;\n        uint256 y = x;\n\n        for (uint256 i = 0; i < 256;) {\n            if (z == y) {\n                return y;\n            }\n            y = z;\n            z = (x * 10 ** 18 / z + z) / 2;\n\n            unchecked {\n                ++i;\n            }\n        }\n        revert SqrtError();\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/oracles/providers/CurveV2CryptoEthOracle.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\n\npragma solidity 0.8.17;\n\nimport { SecurityBase } from \"src/security/SecurityBase.sol\";\nimport { IPriceOracle } from \"src/interfaces/oracles/IPriceOracle.sol\";\nimport { SystemComponent } from \"src/SystemComponent.sol\";\nimport { ISystemRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { ICurveResolver } from \"src/interfaces/utils/ICurveResolver.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\nimport { ICryptoSwapPool } from \"src/interfaces/external/curve/ICryptoSwapPool.sol\";\n\ncontract CurveV2CryptoEthOracle is SystemComponent, SecurityBase, IPriceOracle {\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    ICurveResolver public immutable curveResolver;\n\n    /**\n     * @notice Struct for neccessary information for single Curve pool.\n     * @param pool The address of the curve pool.\n     * @param checkReentrancy uint8 representing a boolean.  0 for false, 1 for true.\n     * @param tokentoPrice Address of the token being priced in the Curve pool.\n     */\n    struct PoolData {\n        address pool;\n        uint8 checkReentrancy;\n        address tokenToPrice;\n    }\n\n    /**\n     * @notice Emitted when token Curve pool is registered.\n     * @param lpToken Lp token that has been registered.\n     */\n    event TokenRegistered(address lpToken);\n\n    /**\n     * @notice Emitted when a Curve pool registration is removed.\n     * @param lpToken Lp token that has been unregistered.\n     */\n    event TokenUnregistered(address lpToken);\n\n    /**\n     * @notice Thrown when pool returned is not a v2 curve pool.\n     * @param curvePool Address of the pool that was attempted to be registered.\n     */\n    error NotCryptoPool(address curvePool);\n\n    /**\n     * @notice Thrown when wrong lp token is returned from CurveResolver.sol.\n     * @param providedLP Address of lp token provided in function call.\n     * @param queriedLP Address of lp tokens returned from resolver.\n     */\n    error ResolverMismatch(address providedLP, address queriedLP);\n\n    /**\n     * @notice Thrown when a Curve V2 Lp token is already registered.\n     * @param curveLpToken The address of the token attempted to be deployed.\n     */\n    error AlreadyRegistered(address curveLpToken);\n\n    /**\n     * @notice Thrown when lp token is not registered.\n     * @param curveLpToken Address of token expected to be registered.\n     */\n    error NotRegistered(address curveLpToken);\n\n    /**\n     * @notice Thrown when a pool with an invalid number of tokens is attempted to be registered.\n     * @param numTokens The number of tokens in the pool attempted to be registered.\n     */\n    error InvalidNumTokens(uint256 numTokens);\n\n    /**\n     * @notice Thrown when a pool that does not have native Eth as a token in the pair is registered\n     *      for a read only reentrancy check.\n     */\n    error MustHaveEthForReentrancy();\n\n    /**\n     * @notice Thrown when y and z values do not converge during square root calculation.\n     */\n    error SqrtError();\n\n    /// @notice Reverse mapping of LP token to pool info.\n    mapping(address => PoolData) public lpTokenToPool;\n\n    /**\n     * @param _systemRegistry Instance of system registry for this version of the system.\n     * @param _curveResolver Instance of Curve Resolver.\n     */\n    constructor(\n        ISystemRegistry _systemRegistry,\n        ICurveResolver _curveResolver\n    ) SystemComponent(_systemRegistry) SecurityBase(address(_systemRegistry.accessController())) {\n        Errors.verifyNotZero(address(_systemRegistry.rootPriceOracle()), \"rootPriceOracle\");\n        Errors.verifyNotZero(address(_curveResolver), \"_curveResolver\");\n\n        curveResolver = _curveResolver;\n    }\n\n    /**\n     * @notice Allows owner of system to register a pool.\n     * @param curvePool Address of CurveV2 pool.\n     * @param curveLpToken Address of LP token associated with v2 pool.\n     * @param checkReentrancy Whether to check read-only reentrancy on pool.\n     */\n    function registerPool(address curvePool, address curveLpToken, bool checkReentrancy) external onlyOwner {\n        Errors.verifyNotZero(curvePool, \"curvePool\");\n        Errors.verifyNotZero(curveLpToken, \"curveLpToken\");\n        if (lpTokenToPool[curveLpToken].pool != address(0)) revert AlreadyRegistered(curveLpToken);\n\n        (address[8] memory tokens, uint256 numTokens, address lpToken, bool isStableSwap) =\n            curveResolver.resolveWithLpToken(curvePool);\n\n        // Only two token pools compatible with this contract.\n        if (numTokens != 2) revert InvalidNumTokens(numTokens);\n        if (isStableSwap) revert NotCryptoPool(curvePool);\n        if (lpToken != curveLpToken) revert ResolverMismatch(curveLpToken, lpToken);\n\n        // Only need ability to check for read-only reentrancy for pools containing native Eth.\n        if (checkReentrancy) {\n            if (tokens[0] != ETH && tokens[1] != ETH) revert MustHaveEthForReentrancy();\n        }\n\n        /**\n         * Curve V2 pools always price second token in `coins` array in first token in `coins` array.  This means that\n         *    if `coins[0]` is Weth, and `coins[1]` is rEth, the price will be rEth as base and weth as quote.  Hence\n         *    to get lp price we will always want to use the second token in the array, priced in eth.\n         */\n        lpTokenToPool[lpToken] =\n            PoolData({ pool: curvePool, checkReentrancy: checkReentrancy ? 1 : 0, tokenToPrice: tokens[1] });\n\n        emit TokenRegistered(lpToken);\n    }\n\n    /**\n     * @notice Allows owner of system to unregister curve pool.\n     * @param curveLpToken Address of CurveV2 lp token to unregister.\n     */\n    function unregister(address curveLpToken) external onlyOwner {\n        Errors.verifyNotZero(curveLpToken, \"curveLpToken\");\n\n        if (lpTokenToPool[curveLpToken].pool == address(0)) revert NotRegistered(curveLpToken);\n\n        delete lpTokenToPool[curveLpToken];\n\n        emit TokenUnregistered(curveLpToken);\n    }\n\n    /// @inheritdoc IPriceOracle\n    function getPriceInEth(address token) external returns (uint256 price) {\n        Errors.verifyNotZero(token, \"token\");\n\n        PoolData memory poolInfo = lpTokenToPool[token];\n        if (poolInfo.pool == address(0)) revert NotRegistered(token);\n\n        ICryptoSwapPool cryptoPool = ICryptoSwapPool(poolInfo.pool);\n\n        // Checking for read only reentrancy scenario.\n        if (poolInfo.checkReentrancy == 1) {\n            // This will fail in a reentrancy situation.\n            cryptoPool.claim_admin_fees();\n        }\n\n        uint256 virtualPrice = cryptoPool.get_virtual_price();\n        uint256 assetPrice = systemRegistry.rootPriceOracle().getPriceInEth(poolInfo.tokenToPrice);\n\n        return (2 * virtualPrice * sqrt(assetPrice)) / 10 ** 18;\n    }\n\n    // solhint-disable max-line-length\n    // Adapted from CurveV2 pools, see here:\n    // https://github.com/curvefi/curve-crypto-contract/blob/d7d04cd9ae038970e40be850df99de8c1ff7241b/contracts/two/CurveCryptoSwap2.vy#L1330\n    function sqrt(uint256 x) private pure returns (uint256) {\n        if (x == 0) return 0;\n\n        uint256 z = (x + 10 ** 18) / 2;\n        uint256 y = x;\n\n        for (uint256 i = 0; i < 256;) {\n            if (z == y) {\n                return y;\n            }\n            y = z;\n            z = (x * 10 ** 18 / z + z) / 2;\n\n            unchecked {\n                ++i;\n            }\n        }\n        revert SqrtError();\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/oracles/providers/CurveV2CryptoEthOracle.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\n\npragma solidity 0.8.17;\n\nimport { SecurityBase } from \"src/security/SecurityBase.sol\";\nimport { IPriceOracle } from \"src/interfaces/oracles/IPriceOracle.sol\";\nimport { SystemComponent } from \"src/SystemComponent.sol\";\nimport { ISystemRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { ICurveResolver } from \"src/interfaces/utils/ICurveResolver.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\nimport { ICryptoSwapPool } from \"src/interfaces/external/curve/ICryptoSwapPool.sol\";\n\ncontract CurveV2CryptoEthOracle is SystemComponent, SecurityBase, IPriceOracle {\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    ICurveResolver public immutable curveResolver;\n\n    /**\n     * @notice Struct for neccessary information for single Curve pool.\n     * @param pool The address of the curve pool.\n     * @param checkReentrancy uint8 representing a boolean.  0 for false, 1 for true.\n     * @param tokentoPrice Address of the token being priced in the Curve pool.\n     */\n    struct PoolData {\n        address pool;\n        uint8 checkReentrancy;\n        address tokenToPrice;\n    }\n\n    /**\n     * @notice Emitted when token Curve pool is registered.\n     * @param lpToken Lp token that has been registered.\n     */\n    event TokenRegistered(address lpToken);\n\n    /**\n     * @notice Emitted when a Curve pool registration is removed.\n     * @param lpToken Lp token that has been unregistered.\n     */\n    event TokenUnregistered(address lpToken);\n\n    /**\n     * @notice Thrown when pool returned is not a v2 curve pool.\n     * @param curvePool Address of the pool that was attempted to be registered.\n     */\n    error NotCryptoPool(address curvePool);\n\n    /**\n     * @notice Thrown when wrong lp token is returned from CurveResolver.sol.\n     * @param providedLP Address of lp token provided in function call.\n     * @param queriedLP Address of lp tokens returned from resolver.\n     */\n    error ResolverMismatch(address providedLP, address queriedLP);\n\n    /**\n     * @notice Thrown when a Curve V2 Lp token is already registered.\n     * @param curveLpToken The address of the token attempted to be deployed.\n     */\n    error AlreadyRegistered(address curveLpToken);\n\n    /**\n     * @notice Thrown when lp token is not registered.\n     * @param curveLpToken Address of token expected to be registered.\n     */"
    }
  ]
}