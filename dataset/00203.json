{
  "Title": "M-9: Time calculation issues with exponential decay",
  "Content": "# Issue M-9: Time calculation issues with exponential decay \n\nSource: https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/282 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nAMOW, SilverChariot\n## Summary\n[OCE_ZVE](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/lockers/OCE/OCE_ZVE.sol) is a locker that distributes rewards based on a exponential decay model. When a distribution starts, the whole balance of the contract should be unclaimable. As time moves forward, more and more of it should be unlocked for distributing. The calculations are made using the `lastDistribution` variable which is initially set in the constructor and then changed on each distribution. This is problematic because the \"idle\" periods where no distribution is happening will be considered as passed time when a real distribution starts.\n## Vulnerability Detail\nIn the [constructor](https://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/lockers/OCE/OCE_ZVE.sol#L73C1-L73C44), the lastDistribution variable is set to `block.timestamp`. \n```solidity\n        lastDistribution = block.timestamp;\n```\n\nWhen [forwardEmissions()](https://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/lockers/OCE/OCE_ZVE.sol#L131-L135) gets called, the calculation `block.timestamp - lastDistribution` will return a large value because the timer has started at the time of deployment.\n```solidity\n    function forwardEmissions() external nonReentrant {\n        uint zveBalance = IERC20(IZivoeGlobals_OCE_ZVE(GBL).ZVE()).balanceOf(address(this));\n        _forwardEmissions(zveBalance - decay(zveBalance, block.timestamp - lastDistribution));\n        lastDistribution = block.timestamp;\n    }\n```\nAs we can see in the [Figma file](https://www.figma.com/file/qjuQ0uGQl9QD7KeBwyf73d/Zivoe-Visualization?type=whiteboard&node-id=0-1), the OCE locker will be deployed at `Phase One` and funding will start after ITO ends, which is at least 30 days.\n\nThis results  in a wrong calculation and instead of decaying, a big amount of the rewards can be forwarded as soon as the distribution starts.\n\nThe issue persists for further distributions also. If distribution 1 ends on 1 January and the Zivoe team decides to start distribution 2 on 1 July, the rewards for 6 months will be claimable from the very beginning. Clearing the timestamp before a distribution starts is not an option because it requires at least `100e18` assets to be forwarded.\n```solidity\n        require(amount >= 100 ether, \"OCE_ZVE::_forwardEmissions amount < 100 ether\");\n```\n\n## Impact\nInstead of decaying, a big part of the rewards is claimable from the beginning.\n\n## Code Snippet\nPoC for [Test_OCE_ZVE](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-testing/src/TESTS_Lockers/Test_OCE_ZVE.sol)\n```solidity\n    function test_OCE_timer() public {\n        hevm.warp(block.timestamp + 365 days);\n        deal(address(ZVE), address(OCE_ZVE_Live), 20000e18);\n        OCE_ZVE_Live.forwardEmissions();  \n    }\n```\n\n\n## Tool used\nFoundry\n\n## Recommendation\nAdd a guarded function that start the distribution by updating the timestamp.\n```solidity\nfunction startDistribution() external {\n         require(\n            _msgSender() == IZivoeGlobals_OCE_ZVE(GBL).TLC(), \n            \"OCE_ZVE::startDistribution() _msgSender() != IZivoeGlobals_OCE_ZVE(GBL).TLC()\"\n        );\n        lastDistribution = block.timestamp;\n}\n```\n\n\n\n## Discussion\n\n**pseudonaut**\n\nforwardEmissions can be called prior to reset, not an issue\n\n**sherlock-admin3**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> medium, OCE_ZVE forwardEmission will start emission as if some large time has already passed due to absence of \"start emission\" function (to reset lastDistribution timestamp). While it's possible to reset it by calling `forwardEmission`, it requires a minimum of 100e18 tokens, which will have to be distributed to reset the timestamp, which is still a loss of funds. As this is mostly a 1-time action, the impact is limited.\n\n\n\n**panprog**\n\nKeeping this medium, because a distribution of 100e18 tokens is still required to reset the `lastDistribution` timestamp.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/280",
  "Code": [
    {
      "filename": "zivoe-core-foundry/src/lockers/OCE/OCE_ZVE.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"../../ZivoeLocker.sol\";\n\nimport \"../../../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n\ninterface IZivoeGlobals_OCE_ZVE {\n    /// @notice Returns the address of the ZivoeRewards ($zJTT) contract.\n    function stJTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewards ($zSTT) contract.\n    function stSTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewards ($ZVE) contract.\n    function stZVE() external view returns (address);\n\n    /// @notice Returns the address of the Timelock contract.\n    function TLC() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeToken contract.\n    function ZVE() external view returns (address);\n}\n\ninterface IZivoeRewards_OCE_ZVE {\n    /// @notice Deposits a reward to this contract for distribution.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @param reward The amount of the _rewardsToken to deposit.\n    function depositReward(address _rewardsToken, uint256 reward) external;\n}\n\n\n\n/// @notice This contract facilitates an exponential decay emissions schedule for $ZVE.\n///         This contract has the following responsibilities:\n///           - Handles accounting (with governable variables) to support emissions schedule.\n///           - Forwards $ZVE to all ZivoeRewards contracts at will (stZVE, stSTT, stJTT).\ncontract OCE_ZVE is ZivoeLocker, ReentrancyGuard {\n    \n    using SafeERC20 for IERC20;\n\n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    address public immutable GBL;           /// @dev The ZivoeGlobals contract.\n\n    uint256 public exponentialDecayPerSecond = RAY * 99999999 / 100000000;    /// @dev The rate of decay per second.\n    uint256 public lastDistribution;        /// @dev The block.timestamp value of last distribution.\n\n    /// @dev Determines distribution between rewards contract, in BIPS.\n    /// @dev Sum of distributionRatioBIPS[0], distributionRatioBIPS[1], and distributionRatioBIPS[2] must equal BIPS.\n    ///      distributionRatioBIPS[0] => stZVE\n    ///      distributionRatioBIPS[1] => stSTT\n    ///      distributionRatioBIPS[2] => stJTT\n    uint256[3] public distributionRatioBIPS;\n\n    uint256 private constant BIPS = 10000;\n    uint256 private constant RAY = 10 ** 27;\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initializes the OCE_ZVE contract.\n    /// @param DAO The administrator of this contract (intended to be ZivoeDAO).\n    /// @param _GBL The ZivoeGlobals contract.\n    constructor(address DAO, address _GBL) {\n        transferOwnershipAndLock(DAO);\n        GBL = _GBL;\n        lastDistribution = block.timestamp;\n\n        distributionRatioBIPS[0] = 3334;\n        distributionRatioBIPS[1] = 3333;\n        distributionRatioBIPS[2] = 3333;\n    }\n\n\n\n    // ------------\n    //    Events\n    // ------------\n\n    /// @notice Emitted during updateDistributionRatioBIPS().\n    /// @param  oldRatios The old distribution ratios.\n    /// @param  newRatios The new distribution ratios.\n    event UpdatedDistributionRatioBIPS(uint256[3] oldRatios, uint256[3] newRatios);\n\n    /// @notice Emitted during forwardEmissions().\n    /// @param  stZVE The amount of $ZVE emitted to the $ZVE rewards contract.\n    /// @param  stJTT The amount of $ZVE emitted to the $zJTT rewards contract.\n    /// @param  stSTT The amount of $ZVE emitted to the $zSTT rewards contract.\n    event EmissionsForwarded(uint256 stZVE, uint256 stJTT, uint256 stSTT);\n\n    /// @notice Emitted during updateExponentialDecayPerSecond().\n    /// @param  oldValue The old value of exponentialDecayPerSecond.\n    /// @param  newValue The new value of exponentialDecayPerSecond.\n    event UpdatedExponentialDecayPerSecond(uint256 oldValue, uint256 newValue);\n\n\n\n    // ---------------\n    //    Functions\n    // ---------------\n\n    /// @notice Permission for owner to call pushToLocker().\n    function canPush() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLocker().\n    function canPull() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLockerPartial().\n    function canPullPartial() public override pure returns (bool) { return true; }\n\n    /// @notice Allocates ZVE from the DAO to this locker for emissions.\n    /// @dev    Only callable by the DAO.\n    /// @param  asset The asset to push to this locker (in this case $ZVE).\n    /// @param  amount The amount of $ZVE to push to this locker.\n    /// @param  data Accompanying transaction data.\n    function pushToLocker(address asset, uint256 amount, bytes calldata data) external override onlyOwner {\n        require(\n            asset == IZivoeGlobals_OCE_ZVE(GBL).ZVE(), \n            \"OCE_ZVE::pushToLocker() asset != IZivoeGlobals_OCE_ZVE(GBL).ZVE()\"\n        );\n        IERC20(asset).safeTransferFrom(owner(), address(this), amount);\n    }\n\n    /// @notice Forwards $ZVE available for distribution.\n    function forwardEmissions() external nonReentrant {\n        uint zveBalance = IERC20(IZivoeGlobals_OCE_ZVE(GBL).ZVE()).balanceOf(address(this));\n        _forwardEmissions(zveBalance - decay(zveBalance, block.timestamp - lastDistribution));\n        lastDistribution = block.timestamp;\n    }\n\n    /// @notice This handles the accounting for forwarding ZVE to lockers privately.\n    /// @param amount The amount of $ZVE to distribute.\n    function _forwardEmissions(uint256 amount) private {\n        require(amount >= 100 ether, \"OCE_ZVE::_forwardEmissions amount < 100 ether\");\n\n        uint amountZero = amount * distributionRatioBIPS[0] / BIPS;\n        uint amountOne = amount * distributionRatioBIPS[1] / BIPS;\n        uint amountTwo = amount * distributionRatioBIPS[2] / BIPS;\n        address ZVE = IZivoeGlobals_OCE_ZVE(GBL).ZVE();\n        address stZVE = IZivoeGlobals_OCE_ZVE(GBL).stZVE();\n        address stSTT = IZivoeGlobals_OCE_ZVE(GBL).stSTT();\n        address stJTT = IZivoeGlobals_OCE_ZVE(GBL).stJTT();\n\n        emit EmissionsForwarded(amountZero, amountOne, amountTwo);\n\n        IERC20(ZVE).safeIncreaseAllowance(stZVE, amountZero);\n        IERC20(ZVE).safeIncreaseAllowance(stSTT, amountOne);\n        IERC20(ZVE).safeIncreaseAllowance(stJTT, amountTwo);\n        IZivoeRewards_OCE_ZVE(stZVE).depositReward(ZVE, amountZero);\n        IZivoeRewards_OCE_ZVE(stSTT).depositReward(ZVE, amountOne);\n        IZivoeRewards_OCE_ZVE(stJTT).depositReward(ZVE, amountTwo);\n    }\n    \n    /// @notice Updates the distribution between rewards contract, in BIPS.\n    /// @dev    The sum of distributionRatioBIPS[0], [1], and [2] must equal BIPS.\n    /// @param  _distributionRatioBIPS The updated values for the state variable distributionRatioBIPS.\n    function updateDistributionRatioBIPS(uint256[3] calldata _distributionRatioBIPS) external {\n        require(\n            _msgSender() == IZivoeGlobals_OCE_ZVE(GBL).TLC(), \n            \"OCE_ZVE::updateDistributionRatioBIPS() _msgSender() != IZivoeGlobals_OCE_ZVE(GBL).TLC()\"\n        );\n        require(\n            _distributionRatioBIPS[0] + _distributionRatioBIPS[1] + _distributionRatioBIPS[2] == BIPS,\n            \"OCE_ZVE::updateDistributionRatioBIPS() sum(_distributionRatioBIPS[0-2]) != BIPS\"\n        );\n\n        emit UpdatedDistributionRatioBIPS(distributionRatioBIPS, _distributionRatioBIPS);\n        distributionRatioBIPS[0] = _distributionRatioBIPS[0];\n        distributionRatioBIPS[1] = _distributionRatioBIPS[1];\n        distributionRatioBIPS[2] = _distributionRatioBIPS[2];\n    }\n\n    /// @notice Updates the exponentialDecayPerSecond variable with provided input.\n    /// @dev    For 1.0000% decrease per second, _exponentialDecayPerSecond would be (1 - 0.01) * RAY.\n    /// @dev    For 0.0001% decrease per second, _exponentialDecayPerSecond would be (1 - 0.000001) * RAY.\n    /// @param _exponentialDecayPerSecond The updated value for exponentialDecayPerSecond state variable.\n    function updateExponentialDecayPerSecond(uint256 _exponentialDecayPerSecond) external {\n        require(\n            _msgSender() == IZivoeGlobals_OCE_ZVE(GBL).TLC(), \n            \"OCE_ZVE::updateExponentialDecayPerSecond() _msgSender() != IZivoeGlobals_OCE_ZVE(GBL).TLC()\"\n        );\n        require(\n            _exponentialDecayPerSecond >= RAY * 99999998 / 100000000,\n            \"OCE_ZVE::updateExponentialDecayPerSecond() _exponentialDecayPerSecond > RAY * 99999998 / 100000000\"\n        );\n        emit UpdatedExponentialDecayPerSecond(exponentialDecayPerSecond, _exponentialDecayPerSecond);\n        exponentialDecayPerSecond = _exponentialDecayPerSecond; \n    }\n\n\n\n    // ----------\n    //    Math\n    // ----------\n\n    /// @notice Returns the amount remaining after a decay.\n    /// @param top The amount decaying.\n    /// @param dur The seconds of decay.\n    function decay(uint256 top, uint256 dur) public view returns (uint256) {\n        return rmul(top, rpow(exponentialDecayPerSecond, dur, RAY));\n    }\n\n    // rmul() and rpow() were ported from MakerDAO:\n    // https://github.com/makerdao/dss/blob/master/src/abaci.sol\n\n    /// @notice Multiplies two variables and returns value, truncated by RAY precision.\n    /// @param x First value to multiply.\n    /// @param y Second value to multiply.\n    /// @return z Resulting value of x * y, truncated by RAY precision.\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x * y;\n        require(y == 0 || z / y == x, \"OCE_ZVE::rmul() y != 0 && z / y != x\");\n        z = z / RAY;\n    }\n    \n    /**\n        @notice rpow(uint256 x, uint256 n, uint256 b), used for exponentiation in drip, is a fixed-point arithmetic \n                function that raises x to the power n. It is implemented in Solidity assembly as a repeated squaring \n                algorithm. x and the returned value are to be interpreted as fixed-point integers with scaling factor b. \n                For example, if b == 100, this specifies two decimal digits of precision and the normal decimal value \n                2.1 would be represented as 210; rpow(210, 2, 100) returns 441 (the two-decimal digit fixed-point \n                representation of 2.1^2 = 4.41). In the current implementation, 10^27 is passed for b, making x and \n                the rpow result both of type RAY in standard MCD fixed-point terminology. rpow's formal invariants \n                include \"no overflow\" as well as constraints on gas usage.\n        @param  x The base value.\n        @param  n The power to raise \"x\" by.\n        @param  b The scaling factor, a.k.a. resulting precision of \"z\".\n        @return z Resulting value of x^n, scaled by factor b.\n    */\n    function rpow(uint256 x, uint256 n, uint256 b) internal pure returns (uint256 z) {\n        assembly {\n            switch n case 0 { z := b }\n            default {\n                switch x case 0 { z := 0 }\n                default {\n                    switch mod(n, 2) case 0 { z := b } default { z := x }\n                    let half := div(b, 2)  // For rounding.\n                    for { n := div(n, 2) } n { n := div(n,2) } {\n                        let xx := mul(x, x)\n                        if shr(128, x) { revert(0,0) }\n                        let xxRound := add(xx, half)\n                        if lt(xxRound, xx) { revert(0,0) }\n                        x := div(xxRound, b)\n                        if mod(n,2) {\n                            let zx := mul(z, x)\n                            if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n                            let zxRound := add(zx, half)\n                            if lt(zxRound, zx) { revert(0,0) }\n                            z := div(zxRound, b)\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n}"
    },
    {
      "filename": "zivoe-core-foundry/src/lockers/OCE/OCE_ZVE.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"../../ZivoeLocker.sol\";\n\nimport \"../../../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n\ninterface IZivoeGlobals_OCE_ZVE {\n    /// @notice Returns the address of the ZivoeRewards ($zJTT) contract.\n    function stJTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewards ($zSTT) contract.\n    function stSTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewards ($ZVE) contract.\n    function stZVE() external view returns (address);\n\n    /// @notice Returns the address of the Timelock contract.\n    function TLC() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeToken contract.\n    function ZVE() external view returns (address);\n}\n\ninterface IZivoeRewards_OCE_ZVE {\n    /// @notice Deposits a reward to this contract for distribution.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @param reward The amount of the _rewardsToken to deposit.\n    function depositReward(address _rewardsToken, uint256 reward) external;\n}\n\n\n\n/// @notice This contract facilitates an exponential decay emissions schedule for $ZVE.\n///         This contract has the following responsibilities:\n///           - Handles accounting (with governable variables) to support emissions schedule.\n///           - Forwards $ZVE to all ZivoeRewards contracts at will (stZVE, stSTT, stJTT).\ncontract OCE_ZVE is ZivoeLocker, ReentrancyGuard {\n    \n    using SafeERC20 for IERC20;\n\n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    address public immutable GBL;           /// @dev The ZivoeGlobals contract.\n\n    uint256 public exponentialDecayPerSecond = RAY * 99999999 / 100000000;    /// @dev The rate of decay per second.\n    uint256 public lastDistribution;        /// @dev The block.timestamp value of last distribution.\n\n    /// @dev Determines distribution between rewards contract, in BIPS.\n    /// @dev Sum of distributionRatioBIPS[0], distributionRatioBIPS[1], and distributionRatioBIPS[2] must equal BIPS.\n    ///      distributionRatioBIPS[0] => stZVE\n    ///      distributionRatioBIPS[1] => stSTT\n    ///      distributionRatioBIPS[2] => stJTT\n    uint256[3] public distributionRatioBIPS;\n\n    uint256 private constant BIPS = 10000;\n    uint256 private constant RAY = 10 ** 27;\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initializes the OCE_ZVE contract.\n    /// @param DAO The administrator of this contract (intended to be ZivoeDAO).\n    /// @param _GBL The ZivoeGlobals contract.\n    constructor(address DAO, address _GBL) {\n        transferOwnershipAndLock(DAO);\n        GBL = _GBL;\n        lastDistribution = block.timestamp;\n\n        distributionRatioBIPS[0] = 3334;\n        distributionRatioBIPS[1] = 3333;\n        distributionRatioBIPS[2] = 3333;\n    }\n\n\n\n    // ------------\n    //    Events\n    // ------------\n\n    /// @notice Emitted during updateDistributionRatioBIPS().\n    /// @param  oldRatios The old distribution ratios.\n    /// @param  newRatios The new distribution ratios.\n    event UpdatedDistributionRatioBIPS(uint256[3] oldRatios, uint256[3] newRatios);\n\n    /// @notice Emitted during forwardEmissions().\n    /// @param  stZVE The amount of $ZVE emitted to the $ZVE rewards contract.\n    /// @param  stJTT The amount of $ZVE emitted to the $zJTT rewards contract.\n    /// @param  stSTT The amount of $ZVE emitted to the $zSTT rewards contract.\n    event EmissionsForwarded(uint256 stZVE, uint256 stJTT, uint256 stSTT);\n\n    /// @notice Emitted during updateExponentialDecayPerSecond().\n    /// @param  oldValue The old value of exponentialDecayPerSecond.\n    /// @param  newValue The new value of exponentialDecayPerSecond.\n    event UpdatedExponentialDecayPerSecond(uint256 oldValue, uint256 newValue);\n\n\n\n    // ---------------\n    //    Functions\n    // ---------------\n\n    /// @notice Permission for owner to call pushToLocker().\n    function canPush() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLocker().\n    function canPull() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLockerPartial().\n    function canPullPartial() public override pure returns (bool) { return true; }\n\n    /// @notice Allocates ZVE from the DAO to this locker for emissions.\n    /// @dev    Only callable by the DAO.\n    /// @param  asset The asset to push to this locker (in this case $ZVE).\n    /// @param  amount The amount of $ZVE to push to this locker.\n    /// @param  data Accompanying transaction data.\n    function pushToLocker(address asset, uint256 amount, bytes calldata data) external override onlyOwner {\n        require(\n            asset == IZivoeGlobals_OCE_ZVE(GBL).ZVE(), \n            \"OCE_ZVE::pushToLocker() asset != IZivoeGlobals_OCE_ZVE(GBL).ZVE()\"\n        );\n        IERC20(asset).safeTransferFrom(owner(), address(this), amount);\n    }\n\n    /// @notice Forwards $ZVE available for distribution.\n    function forwardEmissions() external nonReentrant {\n        uint zveBalance = IERC20(IZivoeGlobals_OCE_ZVE(GBL).ZVE()).balanceOf(address(this));\n        _forwardEmissions(zveBalance - decay(zveBalance, block.timestamp - lastDistribution));\n        lastDistribution = block.timestamp;\n    }\n\n    /// @notice This handles the accounting for forwarding ZVE to lockers privately.\n    /// @param amount The amount of $ZVE to distribute.\n    function _forwardEmissions(uint256 amount) private {\n        require(amount >= 100 ether, \"OCE_ZVE::_forwardEmissions amount < 100 ether\");\n\n        uint amountZero = amount * distributionRatioBIPS[0] / BIPS;\n        uint amountOne = amount * distributionRatioBIPS[1] / BIPS;\n        uint amountTwo = amount * distributionRatioBIPS[2] / BIPS;\n        address ZVE = IZivoeGlobals_OCE_ZVE(GBL).ZVE();\n        address stZVE = IZivoeGlobals_OCE_ZVE(GBL).stZVE();\n        address stSTT = IZivoeGlobals_OCE_ZVE(GBL).stSTT();\n        address stJTT = IZivoeGlobals_OCE_ZVE(GBL).stJTT();\n\n        emit EmissionsForwarded(amountZero, amountOne, amountTwo);\n\n        IERC20(ZVE).safeIncreaseAllowance(stZVE, amountZero);\n        IERC20(ZVE).safeIncreaseAllowance(stSTT, amountOne);\n        IERC20(ZVE).safeIncreaseAllowance(stJTT, amountTwo);\n        IZivoeRewards_OCE_ZVE(stZVE).depositReward(ZVE, amountZero);\n        IZivoeRewards_OCE_ZVE(stSTT).depositReward(ZVE, amountOne);\n        IZivoeRewards_OCE_ZVE(stJTT).depositReward(ZVE, amountTwo);\n    }\n    \n    /// @notice Updates the distribution between rewards contract, in BIPS.\n    /// @dev    The sum of distributionRatioBIPS[0], [1], and [2] must equal BIPS.\n    /// @param  _distributionRatioBIPS The updated values for the state variable distributionRatioBIPS.\n    function updateDistributionRatioBIPS(uint256[3] calldata _distributionRatioBIPS) external {\n        require(\n            _msgSender() == IZivoeGlobals_OCE_ZVE(GBL).TLC(), \n            \"OCE_ZVE::updateDistributionRatioBIPS() _msgSender() != IZivoeGlobals_OCE_ZVE(GBL).TLC()\"\n        );\n        require(\n            _distributionRatioBIPS[0] + _distributionRatioBIPS[1] + _distributionRatioBIPS[2] == BIPS,\n            \"OCE_ZVE::updateDistributionRatioBIPS() sum(_distributionRatioBIPS[0-2]) != BIPS\"\n        );\n\n        emit UpdatedDistributionRatioBIPS(distributionRatioBIPS, _distributionRatioBIPS);\n        distributionRatioBIPS[0] = _distributionRatioBIPS[0];\n        distributionRatioBIPS[1] = _distributionRatioBIPS[1];\n        distributionRatioBIPS[2] = _distributionRatioBIPS[2];\n    }\n\n    /// @notice Updates the exponentialDecayPerSecond variable with provided input.\n    /// @dev    For 1.0000% decrease per second, _exponentialDecayPerSecond would be (1 - 0.01) * RAY.\n    /// @dev    For 0.0001% decrease per second, _exponentialDecayPerSecond would be (1 - 0.000001) * RAY.\n    /// @param _exponentialDecayPerSecond The updated value for exponentialDecayPerSecond state variable.\n    function updateExponentialDecayPerSecond(uint256 _exponentialDecayPerSecond) external {\n        require(\n            _msgSender() == IZivoeGlobals_OCE_ZVE(GBL).TLC(), \n            \"OCE_ZVE::updateExponentialDecayPerSecond() _msgSender() != IZivoeGlobals_OCE_ZVE(GBL).TLC()\"\n        );\n        require(\n            _exponentialDecayPerSecond >= RAY * 99999998 / 100000000,\n            \"OCE_ZVE::updateExponentialDecayPerSecond() _exponentialDecayPerSecond > RAY * 99999998 / 100000000\"\n        );\n        emit UpdatedExponentialDecayPerSecond(exponentialDecayPerSecond, _exponentialDecayPerSecond);\n        exponentialDecayPerSecond = _exponentialDecayPerSecond; \n    }\n\n\n\n    // ----------\n    //    Math\n    // ----------\n\n    /// @notice Returns the amount remaining after a decay.\n    /// @param top The amount decaying.\n    /// @param dur The seconds of decay.\n    function decay(uint256 top, uint256 dur) public view returns (uint256) {\n        return rmul(top, rpow(exponentialDecayPerSecond, dur, RAY));\n    }\n\n    // rmul() and rpow() were ported from MakerDAO:\n    // https://github.com/makerdao/dss/blob/master/src/abaci.sol\n\n    /// @notice Multiplies two variables and returns value, truncated by RAY precision.\n    /// @param x First value to multiply.\n    /// @param y Second value to multiply.\n    /// @return z Resulting value of x * y, truncated by RAY precision.\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x * y;\n        require(y == 0 || z / y == x, \"OCE_ZVE::rmul() y != 0 && z / y != x\");\n        z = z / RAY;\n    }\n    \n    /**\n        @notice rpow(uint256 x, uint256 n, uint256 b), used for exponentiation in drip, is a fixed-point arithmetic \n                function that raises x to the power n. It is implemented in Solidity assembly as a repeated squaring \n                algorithm. x and the returned value are to be interpreted as fixed-point integers with scaling factor b. \n                For example, if b == 100, this specifies two decimal digits of precision and the normal decimal value \n                2.1 would be represented as 210; rpow(210, 2, 100) returns 441 (the two-decimal digit fixed-point \n                representation of 2.1^2 = 4.41). In the current implementation, 10^27 is passed for b, making x and \n                the rpow result both of type RAY in standard MCD fixed-point terminology. rpow's formal invariants \n                include \"no overflow\" as well as constraints on gas usage.\n        @param  x The base value.\n        @param  n The power to raise \"x\" by.\n        @param  b The scaling factor, a.k.a. resulting precision of \"z\".\n        @return z Resulting value of x^n, scaled by factor b.\n    */\n    function rpow(uint256 x, uint256 n, uint256 b) internal pure returns (uint256 z) {\n        assembly {\n            switch n case 0 { z := b }\n            default {\n                switch x case 0 { z := 0 }\n                default {\n                    switch mod(n, 2) case 0 { z := b } default { z := x }\n                    let half := div(b, 2)  // For rounding.\n                    for { n := div(n, 2) } n { n := div(n,2) } {\n                        let xx := mul(x, x)\n                        if shr(128, x) { revert(0,0) }\n                        let xxRound := add(xx, half)\n                        if lt(xxRound, xx) { revert(0,0) }\n                        x := div(xxRound, b)\n                        if mod(n,2) {\n                            let zx := mul(z, x)\n                            if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n                            let zxRound := add(zx, half)\n                            if lt(zxRound, zx) { revert(0,0) }\n                            z := div(zxRound, b)\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n}"
    }
  ]
}