{
  "Title": "[L04] Duplicated price per share calculations",
  "Content": "A vault is simultaneously an ERC20 token, and balances of accounts correspond to the number of shares users hold. These shares represent how much of the collateral held in a vault can be withdrawn by each user when the current round ends. Throughout the lifecycle of a vault, the amount of collateral that backs each share changes, and the vault calculates this rate by dividing the total amount of collateral by the total share supply.\n\n\nMultiple slightly different implementations of this calculation can be found throughout the codebase:\n\n\n* In [`updatePPS`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonDeltaVault.sol#L145-L156) of `RibbonDeltaVault`\n* In [`rollover`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/VaultLifecycle.sol#L120-L123) of `VaultLifecycle`\n* In [`pricePerShare`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol#L619-L621) and [`accountVaultBalance`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol#L569-L574) of `RibbonVault`\n\n\nEven though these are essentially equivalent to each other, having multiple different implementations for the same calculation leaves the project more prone to the introduction of errors. Refactors and changes made to some of these implementations might not get replicated over to the others.\n\n\nInstead of relying on multiple equivalent but separate ways of calculating the price per share, consider consolidating this calculation into only one function that can be reused throughout the codebase when needed.\n\n\n**Update**: *Fixed in [commit `4e7890a4a110e6b7aacac875e486106edd908c10` in PR#91](https://github.com/ribbon-finance/ribbon-v2/pull/91/commits/4e7890a4a110e6b7aacac875e486106edd908c10). Unrelated to the issue, the PR also removes the concept of an `initialSharePrice` from the system, a change which is outside the scope of this fix review.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/vaults/RibbonDeltaVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {DSMath} from \"../vendor/DSMath.sol\";\nimport {GnosisAuction} from \"../libraries/GnosisAuction.sol\";\nimport {OptionsDeltaVaultStorage} from \"../storage/OptionsVaultStorage.sol\";\nimport {Vault} from \"../libraries/Vault.sol\";\nimport {VaultLifecycle} from \"../libraries/VaultLifecycle.sol\";\nimport {ShareMath} from \"../libraries/ShareMath.sol\";\nimport {RibbonVault} from \"./base/RibbonVault.sol\";\nimport {IRibbonThetaVault} from \"../interfaces/IRibbonThetaVault.sol\";\nimport {IGnosisAuction} from \"../interfaces/IGnosisAuction.sol\";\n\ncontract RibbonDeltaVault is RibbonVault, DSMath, OptionsDeltaVaultStorage {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using ShareMath for Vault.DepositReceipt;\n\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    /************************************************\n     *  EVENTS\n     ***********************************************/\n\n    event OpenLong(\n        address indexed options,\n        uint256 purchaseAmount,\n        uint256 premium,\n        address manager\n    );\n\n    event CloseLong(\n        address indexed options,\n        uint256 profitAmount,\n        address manager\n    );\n\n    event NewOptionAllocationSet(\n        uint256 optionAllocationPct,\n        uint256 newOptionAllocationPct\n    );\n\n    event InstantWithdraw(address indexed account, uint256 share, uint16 round);\n\n    event PlaceAuctionBid(\n        uint256 auctionId,\n        address auctioningToken,\n        uint256 sellAmount,\n        uint256 buyAmount,\n        address bidder\n    );\n\n    /************************************************\n     *  CONSTRUCTOR & INITIALIZATION\n     ***********************************************/\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _weth is the Wrapped Ether contract\n     * @param _usdc is the USDC contract\n     * @param _gammaController is the contract address for opyn actions\n     * @param _marginPool is the contract address for providing collateral to opyn\n     * @param _gnosisEasyAuction is the contract address that facilitates gnosis auctions\n     */\n    constructor(\n        address _weth,\n        address _usdc,\n        address _gammaController,\n        address _marginPool,\n        address _gnosisEasyAuction\n    )\n        RibbonVault(\n            _weth,\n            _usdc,\n            _gammaController,\n            _marginPool,\n            _gnosisEasyAuction\n        )\n    {}\n\n    /**\n     * @notice Initializes the OptionVault contract with storage variables.\n     */\n    function initialize(\n        address _owner,\n        address _feeRecipient,\n        uint256 _managementFee,\n        uint256 _performanceFee,\n        string memory tokenName,\n        string memory tokenSymbol,\n        address _counterpartyThetaVault,\n        uint256 _optionAllocationPct,\n        Vault.VaultParams calldata _vaultParams\n    ) external initializer {\n        baseInitialize(\n            _owner,\n            _feeRecipient,\n            _managementFee,\n            _performanceFee,\n            tokenName,\n            tokenSymbol,\n            _vaultParams\n        );\n        require(\n            _counterpartyThetaVault != address(0),\n            \"!_counterpartyThetaVault\"\n        );\n        require(\n            IRibbonThetaVault(_counterpartyThetaVault).vaultParams().asset ==\n                vaultParams.asset,\n            \"!_counterpartyThetaVault: asset\"\n        );\n        require(\n            _optionAllocationPct > 0 && _optionAllocationPct < 10000,\n            \"!_optionAllocationPct\"\n        );\n        counterpartyThetaVault = IRibbonThetaVault(_counterpartyThetaVault);\n        optionAllocationPct = _optionAllocationPct;\n    }\n\n    /**\n     * @notice Updates the price per share of the current round. The current round\n     * pps will change right after call rollToNextOption as the gnosis auction contract\n     * takes custody of a % of `asset` tokens, and right after we claim the tokens from\n     * the action as we may recieve some of `asset` tokens back alongside the oToken,\n     * depending on the gnosis auction outcome. Finally it will change at the end of the week\n     * if the oTokens are ITM\n     */\n    modifier updatePPS(bool isWithdraw) {\n        if (!isWithdraw) {\n            _;\n        }\n\n        if (\n            !isWithdraw ||\n            roundPricePerShare[vaultState.round] <= PLACEHOLDER_UINT\n        ) {\n            uint256 pendingAmount = uint256(vaultState.totalPending);\n            uint256 currentBalance =\n                IERC20(vaultParams.asset).balanceOf(address(this));\n            uint256 roundStartBalance = currentBalance.sub(pendingAmount);\n\n            uint256 singleShare = 10**uint256(vaultParams.decimals);\n            roundPricePerShare[vaultState.round] = VaultLifecycle.getPPS(\n                totalSupply(),\n                roundStartBalance,\n                singleShare,\n                vaultParams.initialSharePrice\n            );\n        }\n\n        if (isWithdraw) {\n            _;\n        }\n    }\n\n    /************************************************\n     *  SETTERS\n     ***********************************************/\n\n    /**\n     * @notice Sets the new % allocation of funds towards options purchases ( 3 decimals. ex: 55 * 10 ** 2 is 55%)\n     * @param newOptionAllocationPct is the option % allocation\n     */\n    function setOptionAllocation(uint16 newOptionAllocationPct)\n        external\n        onlyOwner\n    {\n        // Needs to be less than 10%\n        require(\n            newOptionAllocationPct > 0 && newOptionAllocationPct < 1000,\n            \"Invalid allocation\"\n        );\n\n        emit NewOptionAllocationSet(\n            optionAllocationPct,\n            newOptionAllocationPct\n        );\n\n        optionAllocationPct = newOptionAllocationPct;\n    }\n\n    /**\n     * @notice Withdraws the assets on the vault using the outstanding `DepositReceipt.amount`\n     * @param share is the amount of shares to withdraw\n     */\n    function withdrawInstantly(uint256 share)\n        external\n        updatePPS(true)\n        nonReentrant\n    {\n        require(share > 0, \"!shares\");\n\n        uint256 sharesLeftForWithdrawal = _withdrawFromNewDeposit(share);\n\n        uint16 currentRound = vaultState.round;\n\n        // If we need to withdraw beyond current round deposit\n        if (sharesLeftForWithdrawal > 0) {\n            (uint256 heldByAccount, uint256 heldByVault) =\n                shareBalances(msg.sender);\n\n            require(\n                sharesLeftForWithdrawal <= heldByAccount.add(heldByVault),\n                \"Insufficient balance\"\n            );\n\n            if (heldByAccount < sharesLeftForWithdrawal) {\n                // Redeem all shares custodied by vault to user\n                _redeem(0, true);\n            }\n\n            // Burn shares\n            _burn(msg.sender, sharesLeftForWithdrawal);\n        }\n\n        emit InstantWithdraw(msg.sender, share, currentRound);\n\n        uint256 sharesToUnderlying =\n            ShareMath.sharesToUnderlying(\n                share,\n                roundPricePerShare[vaultState.round],\n                vaultParams.decimals\n            );\n        transferAsset(msg.sender, sharesToUnderlying);\n    }\n\n    /************************************************\n     *  VAULT OPERATIONS\n     ***********************************************/\n\n    /**\n     * @notice Closes the existing long position for the vault.\n     *         This allows all the users to withdraw if the next option is malicious.\n     */\n    function commitAndClose() external onlyOwner updatePPS(true) nonReentrant {\n        address oldOption = optionState.currentOption;\n\n        address counterpartyNextOption =\n            counterpartyThetaVault.optionState().nextOption;\n        require(counterpartyNextOption != address(0), \"!thetavaultclosed\");\n        optionState.nextOption = counterpartyNextOption;\n        optionState.nextOptionReadyAt = uint32(block.timestamp.add(delay));\n\n        optionState.currentOption = address(0);\n        vaultState.lastLockedAmount = balanceBeforePremium;\n\n        // redeem\n        if (oldOption != address(0)) {\n            uint256 profitAmount =\n                VaultLifecycle.settleLong(\n                    GAMMA_CONTROLLER,\n                    oldOption,\n                    vaultParams.asset\n                );\n            emit CloseLong(oldOption, profitAmount, msg.sender);\n        }\n    }\n\n    /**\n     * @notice Rolls the vault's funds into a new long position.\n     * @param optionPremium is the premium per token to pay in `asset`.\n       Same decimals as `asset` (ex: 1 * 10 ** 8 means 1 WBTC per oToken)\n     */\n    function rollToNextOption(uint256 optionPremium)\n        external\n        onlyOwner\n        updatePPS(false)\n        nonReentrant\n    {\n        (address newOption, uint256 lockedBalance) = _rollToNextOption();\n\n        balanceBeforePremium = uint104(lockedBalance);\n\n        GnosisAuction.BidDetails memory bidDetails;\n\n        bidDetails.auctionId = counterpartyThetaVault.optionAuctionID();\n        bidDetails.gnosisEasyAuction = GNOSIS_EASY_AUCTION;\n        bidDetails.oTokenAddress = newOption;\n        bidDetails.asset = vaultParams.asset;\n        bidDetails.assetDecimals = vaultParams.decimals;\n        bidDetails.lockedBalance = lockedBalance;\n        bidDetails.optionAllocationPct = optionAllocationPct;\n        bidDetails.optionPremium = optionPremium;\n        bidDetails.bidder = msg.sender;\n\n        // place bid\n        (uint256 sellAmount, uint256 buyAmount, uint64 userId) =\n            VaultLifecycle.placeBid(bidDetails);\n\n        auctionSellOrder.sellAmount = uint96(sellAmount);\n        auctionSellOrder.buyAmount = uint96(buyAmount);\n        auctionSellOrder.userId = userId;\n\n        emit OpenLong(newOption, buyAmount, sellAmount, msg.sender);\n    }\n\n    /**\n     * @notice Claims the delta vault's oTokens from latest auction\n     */\n    function claimAuctionOtokens() external updatePPS(false) nonReentrant {\n        VaultLifecycle.claimAuctionOtokens(\n            auctionSellOrder,\n            GNOSIS_EASY_AUCTION,\n            address(counterpartyThetaVault)\n        );\n    }\n\n    /**\n     * @notice Withdraws from the most recent deposit which has not been processed\n     * @param share is how many shares to withdraw in total\n     * @return the shares left to withdraw\n     */\n    function _withdrawFromNewDeposit(uint256 share) private returns (uint256) {\n        Vault.DepositReceipt storage depositReceipt =\n            depositReceipts[msg.sender];\n\n        // Immediately get what is in the pending deposits, without need for checking pps\n        if (\n            depositReceipt.round == vaultState.round &&\n            depositReceipt.amount > 0\n        ) {\n            uint256 receiptShares =\n                ShareMath.underlyingToShares(\n                    depositReceipt.amount,\n                    roundPricePerShare[depositReceipt.round],\n                    vaultParams.decimals\n                );\n            uint256 sharesWithdrawn = min(receiptShares, share);\n            // Subtraction underflow checks already ensure it is smaller than uint104\n            depositReceipt.amount = uint104(\n                ShareMath.sharesToUnderlying(\n                    uint256(receiptShares).sub(sharesWithdrawn),\n                    roundPricePerShare[depositReceipt.round],\n                    vaultParams.decimals\n                )\n            );\n            return share.sub(sharesWithdrawn);\n        }\n\n        return share;\n    }\n}"
    },
    {
      "filename": "contracts/libraries/VaultLifecycle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {Vault} from \"./Vault.sol\";\nimport {\n    IStrikeSelection,\n    IOptionsPremiumPricer\n} from \"../interfaces/IRibbon.sol\";\nimport {GnosisAuction} from \"./GnosisAuction.sol\";\nimport {\n    IOtokenFactory,\n    IOtoken,\n    IController,\n    GammaTypes\n} from \"../interfaces/GammaInterface.sol\";\nimport {IERC20Detailed} from \"../interfaces/IERC20Detailed.sol\";\nimport {\n    SupportsNonCompliantERC20\n} from \"../libraries/SupportsNonCompliantERC20.sol\";\n\nlibrary VaultLifecycle {\n    using SafeMath for uint256;\n    using SupportsNonCompliantERC20 for IERC20;\n\n    struct CloseParams {\n        address OTOKEN_FACTORY;\n        address USDC;\n        address currentOption;\n        uint256 delay;\n        uint16 lastStrikeOverride;\n        uint256 overriddenStrikePrice;\n    }\n\n    function commitAndClose(\n        address strikeSelection,\n        address optionsPremiumPricer,\n        uint256 premiumDiscount,\n        CloseParams calldata closeParams,\n        Vault.VaultParams storage vaultParams,\n        Vault.VaultState storage vaultState\n    )\n        external\n        returns (\n            address otokenAddress,\n            uint256 premium,\n            uint256 strikePrice,\n            uint256 delta\n        )\n    {\n        uint256 expiry;\n\n        // uninitialized state\n        if (closeParams.currentOption == address(0)) {\n            expiry = getNextFriday(block.timestamp);\n        } else {\n            expiry = getNextFriday(\n                IOtoken(closeParams.currentOption).expiryTimestamp()\n            );\n        }\n\n        IStrikeSelection selection = IStrikeSelection(strikeSelection);\n\n        bool isPut = vaultParams.isPut;\n        address underlying = vaultParams.underlying;\n        address asset = vaultParams.asset;\n\n        (strikePrice, delta) = closeParams.lastStrikeOverride ==\n            vaultState.round\n            ? (closeParams.overriddenStrikePrice, selection.delta())\n            : selection.getStrikePrice(expiry, isPut);\n\n        require(strikePrice != 0, \"!strikePrice\");\n\n        otokenAddress = getOrDeployOtoken(\n            closeParams,\n            underlying,\n            asset,\n            strikePrice,\n            expiry,\n            isPut\n        );\n\n        premium = GnosisAuction.getOTokenPremium(\n            otokenAddress,\n            optionsPremiumPricer,\n            premiumDiscount\n        );\n\n        require(premium > 0, \"!premium\");\n    }\n\n    function verifyOtoken(address otokenAddress, uint256 delay) private view {\n        require(otokenAddress != address(0), \"!otokenAddress\");\n\n        IOtoken otoken = IOtoken(otokenAddress);\n        uint256 readyAt = block.timestamp.add(delay);\n        require(otoken.expiryTimestamp() >= readyAt, \"Expiry before delay\");\n    }\n\n    function rollover(\n        uint256 currentSupply,\n        address asset,\n        uint8 decimals,\n        uint256 initialSharePrice,\n        uint256 pendingAmount,\n        uint128 queuedWithdrawShares\n    )\n        external\n        view\n        returns (\n            uint256 newLockedAmount,\n            uint256 newPricePerShare,\n            uint256 mintShares\n        )\n    {\n        uint256 currentBalance = IERC20(asset).balanceOf(address(this));\n        uint256 roundStartBalance = currentBalance.sub(pendingAmount);\n\n        uint256 singleShare = 10**uint256(decimals);\n\n        newPricePerShare = getPPS(\n            currentSupply,\n            roundStartBalance,\n            singleShare,\n            initialSharePrice\n        );\n\n        // After closing the short, if the options expire in-the-money\n        // vault pricePerShare would go down because vault's asset balance decreased.\n        // This ensures that the newly-minted shares do not take on the loss.\n        uint256 _mintShares =\n            pendingAmount.mul(singleShare).div(newPricePerShare);\n\n        uint256 newSupply = currentSupply.add(_mintShares);\n\n        uint256 queuedWithdrawAmount =\n            newSupply > 0\n                ? uint256(queuedWithdrawShares).mul(currentBalance).div(\n                    newSupply\n                )\n                : 0;\n\n        return (\n            currentBalance.sub(queuedWithdrawAmount),\n            newPricePerShare,\n            _mintShares\n        );\n    }\n\n    // https://github.com/opynfinance/GammaProtocol/blob/master/contracts/Otoken.sol#L70\n    uint256 private constant OTOKEN_DECIMALS = 10**8;\n\n    function createShort(\n        address gammaController,\n        address marginPool,\n        address oTokenAddress,\n        uint256 depositAmount\n    ) external returns (uint256) {\n        IController controller = IController(gammaController);\n        uint256 newVaultID =\n            (controller.getAccountVaultCounter(address(this))).add(1);\n\n        IOtoken oToken = IOtoken(oTokenAddress);\n        address collateralAsset = oToken.collateralAsset();\n\n        uint256 collateralDecimals =\n            uint256(IERC20Detailed(collateralAsset).decimals());\n        uint256 mintAmount;\n\n        if (oToken.isPut()) {\n            // For minting puts, there will be instances where the full depositAmount will not be used for minting.\n            // This is because of an issue with precision.\n            //\n            // For ETH put options, we are calculating the mintAmount (10**8 decimals) using\n            // the depositAmount (10**18 decimals), which will result in truncation of decimals when scaling down.\n            // As a result, there will be tiny amounts of dust left behind in the Opyn vault when minting put otokens.\n            //\n            // For simplicity's sake, we do not refund the dust back to the address(this) on minting otokens.\n            // We retain the dust in the vault so the calling contract can withdraw the\n            // actual locked amount + dust at settlement.\n            //\n            // To test this behavior, we can console.log\n            // MarginCalculatorInterface(0x7A48d10f372b3D7c60f6c9770B91398e4ccfd3C7).getExcessCollateral(vault)\n            // to see how much dust (or excess collateral) is left behind.\n            mintAmount = depositAmount\n                .mul(OTOKEN_DECIMALS)\n                .mul(DSWAD) // we use 10**18 to give extra precision\n                .div(\n                oToken.strikePrice().mul(10**(18 - (8 - collateralDecimals)))\n            );\n        } else {\n            mintAmount = depositAmount;\n            uint256 scaleBy = 10**(collateralDecimals.sub(8)); // oTokens have 8 decimals\n\n            if (mintAmount > scaleBy && collateralDecimals > 8) {\n                mintAmount = depositAmount.div(scaleBy); // scale down from 10**18 to 10**8\n            }\n        }\n\n        // double approve to fix non-compliant ERC20s\n        IERC20 collateralToken = IERC20(collateralAsset);\n        collateralToken.safeApprove(marginPool, depositAmount);\n\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](3);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.OpenVault,\n            address(this), // owner\n            address(this), // receiver -  we need this contract to receive so we can swap at the end\n            address(0), // asset, otoken\n            newVaultID, // vaultId\n            0, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[1] = IController.ActionArgs(\n            IController.ActionType.DepositCollateral,\n            address(this), // owner\n            address(this), // address to transfer from\n            collateralAsset, // deposited asset\n            newVaultID, // vaultId\n            depositAmount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[2] = IController.ActionArgs(\n            IController.ActionType.MintShortOption,\n            address(this), // owner\n            address(this), // address to transfer to\n            oTokenAddress, // deposited asset\n            newVaultID, // vaultId\n            mintAmount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        controller.operate(actions);\n\n        return mintAmount;\n    }\n\n    /**\n     * @notice Close the existing short otoken position. Currently this implementation is simple.\n     * It closes the most recent vault opened by the contract. This assumes that the contract will\n     * only have a single vault open at any given time. Since calling `closeShort` deletes vaults,\n     * this assumption should hold.\n     */\n    function settleShort(address gammaController) external returns (uint256) {\n        IController controller = IController(gammaController);\n\n        // gets the currently active vault ID\n        uint256 vaultID = controller.getAccountVaultCounter(address(this));\n\n        GammaTypes.Vault memory vault =\n            controller.getVault(address(this), vaultID);\n\n        require(vault.shortOtokens.length > 0, \"No short\");\n\n        IERC20 collateralToken = IERC20(vault.collateralAssets[0]);\n\n        uint256 startCollateralBalance =\n            collateralToken.balanceOf(address(this));\n\n        // If it is after expiry, we need to settle the short position using the normal way\n        // Delete the vault and withdraw all remaining collateral from the vault\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](1);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.SettleVault,\n            address(this), // owner\n            address(this), // address to transfer to\n            address(0), // not used\n            vaultID, // vaultId\n            0, // not used\n            0, // not used\n            \"\" // not used\n        );\n\n        controller.operate(actions);\n\n        uint256 endCollateralBalance = collateralToken.balanceOf(address(this));\n\n        return endCollateralBalance.sub(startCollateralBalance);\n    }\n\n    /**\n     * @notice Exercises the ITM option using existing long otoken position. Currently this implementation is simple.\n     * It calls the `Redeem` action to claim the payout.\n     */\n    function settleLong(\n        address gammaController,\n        address oldOption,\n        address asset\n    ) external returns (uint256) {\n        IController controller = IController(gammaController);\n\n        uint256 oldOptionBalance = IERC20(oldOption).balanceOf(address(this));\n\n        if (controller.getPayout(oldOption, oldOptionBalance) == 0) {\n            return 0;\n        }\n\n        uint256 startAssetBalance = IERC20(asset).balanceOf(address(this));\n\n        // If it is after expiry, we need to redeem the profits\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](1);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.Redeem,\n            address(0), // not used\n            address(this), // address to send profits to\n            oldOption, // address of otoken\n            0, // not used\n            oldOptionBalance, // otoken balance\n            0, // not used\n            \"\" // not used\n        );\n\n        controller.operate(actions);\n\n        uint256 endAssetBalance = IERC20(asset).balanceOf(address(this));\n\n        return endAssetBalance.sub(startAssetBalance);\n    }\n\n    /**\n     * @notice Burn the remaining oTokens left over from auction. Currently this implementation is simple.\n     * It burns oTokens from the most recent vault opened by the contract. This assumes that the contract will\n     * only have a single vault open at any given time.\n     */\n    function burnOtokens(address gammaController, uint256 amount)\n        external\n        returns (uint256)\n    {\n        IController controller = IController(gammaController);\n\n        // gets the currently active vault ID\n        uint256 vaultID = controller.getAccountVaultCounter(address(this));\n\n        GammaTypes.Vault memory vault =\n            controller.getVault(address(this), vaultID);\n\n        require(vault.shortOtokens.length > 0, \"No short\");\n\n        IERC20 collateralToken = IERC20(vault.collateralAssets[0]);\n\n        uint256 startCollateralBalance =\n            collateralToken.balanceOf(address(this));\n\n        // Burning all otokens that are left from the gnosis auction,\n        // then withdrawing the corresponding collateral amount from the vault\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](2);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.BurnShortOption,\n            address(this), // owner\n            address(this), // address to transfer to\n            address(vault.shortOtokens[0]), // otoken address\n            vaultID, // vaultId\n            amount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[1] = IController.ActionArgs(\n            IController.ActionType.WithdrawCollateral,\n            address(this), // owner\n            address(this), // address to transfer to\n            address(collateralToken), // withdrawn asset\n            vaultID, // vaultId\n            vault.collateralAmounts[0].mul(amount).div(vault.shortAmounts[0]), // amount\n            0, //index\n            \"\" //data\n        );\n\n        controller.operate(actions);\n\n        uint256 endCollateralBalance = collateralToken.balanceOf(address(this));\n\n        return endCollateralBalance.sub(startCollateralBalance);\n    }\n\n    function getOrDeployOtoken(\n        CloseParams calldata closeParams,\n        address underlying,\n        address collateralAsset,\n        uint256 strikePrice,\n        uint256 expiry,\n        bool isPut\n    ) internal returns (address) {\n        IOtokenFactory factory = IOtokenFactory(closeParams.OTOKEN_FACTORY);\n\n        address otokenFromFactory =\n            factory.getOtoken(\n                underlying,\n                closeParams.USDC,\n                collateralAsset,\n                strikePrice,\n                expiry,\n                isPut\n            );\n\n        if (otokenFromFactory != address(0)) {\n            return otokenFromFactory;\n        }\n\n        address otoken =\n            factory.createOtoken(\n                underlying,\n                closeParams.USDC,\n                collateralAsset,\n                strikePrice,\n                expiry,\n                isPut\n            );\n\n        verifyOtoken(otoken, closeParams.delay);\n\n        return otoken;\n    }\n\n    function startAuction(GnosisAuction.AuctionDetails calldata auctionDetails)\n        external\n        returns (uint256)\n    {\n        return GnosisAuction.startAuction(auctionDetails);\n    }\n\n    function placeBid(GnosisAuction.BidDetails calldata bidDetails)\n        external\n        returns (\n            uint256,\n            uint256,\n            uint64\n        )\n    {\n        return GnosisAuction.placeBid(bidDetails);\n    }\n\n    function claimAuctionOtokens(\n        Vault.AuctionSellOrder calldata auctionSellOrder,\n        address gnosisEasyAuction,\n        address counterpartyThetaVault\n    ) external {\n        GnosisAuction.claimAuctionOtokens(\n            auctionSellOrder,\n            gnosisEasyAuction,\n            counterpartyThetaVault\n        );\n    }\n\n    function verifyConstructorParams(\n        address owner,\n        address feeRecipient,\n        uint256 performanceFee,\n        string calldata tokenName,\n        string calldata tokenSymbol,\n        Vault.VaultParams calldata _vaultParams\n    ) external pure {\n        require(owner != address(0), \"!owner\");\n        require(feeRecipient != address(0), \"!feeRecipient\");\n        require(performanceFee > 0, \"!performanceFee\");\n        require(performanceFee < 10**8, \"performanceFee >= 100%\");\n        require(bytes(tokenName).length > 0, \"!tokenName\");\n        require(bytes(tokenSymbol).length > 0, \"!tokenSymbol\");\n\n        require(_vaultParams.asset != address(0), \"!asset\");\n        require(_vaultParams.underlying != address(0), \"!underlying\");\n        require(_vaultParams.minimumSupply > 0, \"!minimumSupply\");\n        require(_vaultParams.cap > 0, \"!cap\");\n        require(_vaultParams.initialSharePrice > 0, \"!initialSharePrice\");\n    }\n\n    /**\n     * @notice Gets the next options expiry timestamp\n     * @param currentExpiry is the expiry timestamp of the current option\n     * Reference: https://codereview.stackexchange.com/a/33532\n     * Examples:\n     * getNextFriday(week 1 thursday) -> week 1 friday\n     * getNextFriday(week 1 friday) -> week 2 friday\n     * getNextFriday(week 1 saturday) -> week 2 friday\n     */\n    function getNextFriday(uint256 currentExpiry)\n        internal\n        pure\n        returns (uint256)\n    {\n        // dayOfWeek = 0 (sunday) - 6 (saturday)\n        uint256 dayOfWeek = ((currentExpiry / 1 days) + 4) % 7;\n        uint256 nextFriday = currentExpiry + ((7 + 5 - dayOfWeek) % 7) * 1 days;\n        uint256 friday8am = nextFriday - (nextFriday % (24 hours)) + (8 hours);\n\n        // If the passed currentExpiry is day=Friday hour>8am, we simply increment it by a week to next Friday\n        if (currentExpiry >= friday8am) {\n            friday8am += 7 days;\n        }\n        return friday8am;\n    }\n\n    function getPPS(\n        uint256 currentSupply,\n        uint256 roundStartBalance,\n        uint256 singleShare,\n        uint256 initialSharePrice\n    ) internal pure returns (uint256 newPricePerShare) {\n        newPricePerShare = currentSupply > 0\n            ? singleShare.mul(roundStartBalance).div(currentSupply)\n            : initialSharePrice;\n    }\n\n    /***\n     * DSMath Copy paste\n     */\n\n    uint256 constant DSWAD = 10**18;\n\n    function dsadd(uint256 x, uint256 y) private pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function dsmul(uint256 x, uint256 y) private pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    //rounds to zero if x*y < WAD / 2\n    function dswdiv(uint256 x, uint256 y) private pure returns (uint256 z) {\n        z = dsadd(dsmul(x, DSWAD), y / 2) / y;\n    }\n}"
    },
    {
      "filename": "contracts/vaults/base/RibbonVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {GnosisAuction} from \"../../libraries/GnosisAuction.sol\";\nimport {OptionsVaultStorage} from \"../../storage/OptionsVaultStorage.sol\";\nimport {Vault} from \"../../libraries/Vault.sol\";\nimport {VaultLifecycle} from \"../../libraries/VaultLifecycle.sol\";\nimport {ShareMath} from \"../../libraries/ShareMath.sol\";\nimport {IOtoken} from \"../../interfaces/GammaInterface.sol\";\nimport {IWETH} from \"../../interfaces/IWETH.sol\";\nimport {IGnosisAuction} from \"../../interfaces/IGnosisAuction.sol\";\nimport {\n    IStrikeSelection,\n    IOptionsPremiumPricer\n} from \"../../interfaces/IRibbon.sol\";\n\ncontract RibbonVault is OptionsVaultStorage {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using ShareMath for Vault.DepositReceipt;\n\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    address public immutable WETH;\n    address public immutable USDC;\n\n    uint256 public constant delay = 1 hours;\n\n    uint256 public constant period = 7 days;\n\n    uint128 internal constant PLACEHOLDER_UINT = 1;\n\n    // Number of weeks per year = 52.142857 weeks * 10**6 = 52142857\n    // Dividing by weeks per year requires doing num.mul(10**6).div(WEEKS_PER_YEAR)\n    uint256 private constant WEEKS_PER_YEAR = 52142857;\n\n    // GAMMA_CONTROLLER is the top-level contract in Gamma protocol\n    // which allows users to perform multiple actions on their vaults\n    // and positions https://github.com/opynfinance/GammaProtocol/blob/master/contracts/Controller.sol\n    address public immutable GAMMA_CONTROLLER;\n\n    // MARGIN_POOL is Gamma protocol's collateral pool.\n    // Needed to approve collateral.safeTransferFrom for minting otokens.\n    // https://github.com/opynfinance/GammaProtocol/blob/master/contracts/MarginPool.sol\n    address public immutable MARGIN_POOL;\n\n    // GNOSIS_EASY_AUCTION is Gnosis protocol's contract for initiating auctions and placing bids\n    // https://github.com/gnosis/ido-contracts/blob/main/contracts/EasyAuction.sol\n    address public immutable GNOSIS_EASY_AUCTION;\n\n    /************************************************\n     *  EVENTS\n     *******************************"
    }
  ]
}