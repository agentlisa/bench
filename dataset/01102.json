{
  "Title": "Lack of swap sanitization could lead to user's collateral being stolen",
  "Content": "During the collateral swap process, the [swap function](https://github.com/widolabs/wido-contracts/blob/d96ef2dd6a7ff3d04c44ebe87994411d1f8c84e7/contracts/compound/libraries/LibCollateralSwap.sol#L62C9-L62C14) is supposed to exchange user's collateral to make up enough funds and repay the flash loan. However, the function never checks that the swap's output token is the same as the flash loan borrowed asset, and the contract only re-invests the surplus amount of the borrowed asset back into the user's Comet. In case users make the mistake of calling `swapCollateral` by swapping into the the wrong asset (other than the flash loan or deposit asset), the tokens can be stuck in the contract and malicious users can steal the tokens.\n\n\nFor example:\n\n\n* Alice sends a transaction that takes flash loan in `USDC`, but by mistake swaps the removed collateral into `USDT`. This should cause the transaction to fail, since there is not enough funds to repay the flash loan.\n* An attacker sees the transaction, and sends enough `USDC` to the protocol just before Alice's transaction to make her transaction pass.\n* After Alice's transaction passes, there are some amount of `USDT` left in the protocol from Alice's swap\n* The attacker now creates a vacuous transaction, specifying `USDT` as their flash loan asset. Since [line 65](https://github.com/widolabs/wido-contracts/blob/d96ef2dd6a7ff3d04c44ebe87994411d1f8c84e7/contracts/compound/libraries/LibCollateralSwap.sol#L65) of `LibCollateralSwap.sol` simply transfers all of the borrowed asset in the contract to the caller, the attacker will get all of the `USDT` that Alice wanted to swap for (less the value of the loan required to swap).\n\n\nConsider checking the swap destination token type is the same as the flash loan token type during the swap process to mitigate this attack vector.\n\n\n***Update**: Partially resolved in [pull request #37](https://github.com/widolabs/wido-contracts/pull/37/files) at commit [d66b097](https://github.com/widolabs/wido-contracts/commit/d66b0972caa4f5ffd658cbe05fc432b4c845704e). While the code checks if the swap has utilized the flash loan asset, the larger Wido swap contracts were out of scope and so the same attack vector may remain should the swap attempt to swap for multiple tokens.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/compound/libraries/LibCollateralSwap.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.7;\n\nimport {IERC20} from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IComet} from \"../interfaces/IComet.sol\";\n\nlibrary LibCollateralSwap {\n    using SafeMath for uint256;\n\n    error WidoRouterFailed();\n\n    struct Collateral {\n        address addr;\n        uint256 amount;\n    }\n\n    struct Signatures {\n        Signature allow;\n        Signature revoke;\n    }\n\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct WidoSwap {\n        address router;\n        address tokenManager;\n        bytes callData;\n    }\n\n    /// @dev Performs all the steps to swap collaterals on the Comet contract\n    function performCollateralSwap(\n        address borrowedAsset,\n        uint256 borrowedAmount,\n        uint256 fee,\n        bytes memory data\n    ) external {\n        // decode payload\n        (\n        address user,\n        IComet comet,\n        Collateral memory existingCollateral,\n        Signatures memory signatures,\n        WidoSwap memory swapDetails\n        ) = abi.decode(\n            data,\n            (address, IComet, Collateral, Signatures, WidoSwap)\n        );\n\n        // supply new collateral on behalf of user\n        _supplyTo(comet, user, borrowedAsset, borrowedAmount.sub(fee));\n\n        // withdraw existing collateral\n        _withdrawFrom(comet, user, existingCollateral, signatures);\n\n        // execute swap\n        _swap(existingCollateral, swapDetails);\n\n        // check amount of surplus collateral\n        uint256 surplusAmount = IERC20(borrowedAsset).balanceOf(address(this)) - borrowedAmount - fee;\n\n        // if positive slippage, supply extra to user\n        if (surplusAmount > 0) {\n            _supplyTo(comet, user, borrowedAsset, surplusAmount);\n        }\n    }\n\n    /// @dev Performs the swap of the collateral on the WidoRouter\n    function _swap(\n        Collateral memory collateral,\n        WidoSwap memory swap\n    ) internal {\n        // approve WidoTokenManager initial collateral to make the swap\n        IERC20(collateral.addr).approve(\n            swap.tokenManager,\n            collateral.amount\n        );\n\n        // execute swap\n        (bool success, bytes memory result) = swap.router.call(swap.callData);\n\n        if (!success) {\n            if (result.length < 68) revert WidoRouterFailed();\n            assembly {\n                result := add(result, 0x04)\n            }\n            revert(abi.decode(result, (string)));\n        }\n    }\n\n    /// @dev Supplies collateral on behalf of user\n    function _supplyTo(\n        IComet comet,\n        address user,\n        address asset,\n        uint256 amount\n    ) internal {\n        IERC20(asset).approve(address(comet), amount);\n        comet.supplyTo(user, asset, amount);\n    }\n\n    /// @dev This function withdraws the collateral from the user.\n    ///  It requires two consecutive EIP712 signatures to allow and revoke\n    ///  permissions to and from this contract.\n    function _withdrawFrom(\n        IComet comet,\n        address user,\n        Collateral memory collateral,\n        Signatures memory sigs\n    ) internal {\n        // get current nonce\n        uint256 nonce = comet.userNonce(user);\n        // allow the contract\n        _allowBySig(comet, user, true, nonce, sigs.allow);\n        // withdraw assets\n        comet.withdrawFrom(user, address(this), collateral.addr, collateral.amount);\n        // increment nonce\n        unchecked { nonce++; }\n        // revoke permission\n        _allowBySig(comet, user, false, nonce, sigs.revoke);\n    }\n\n    /// @dev Executes a single `allowBySig` operation on the Comet contract\n    function _allowBySig(\n        IComet comet,\n        address user,\n        bool allowed,\n        uint256 nonce,\n        Signature memory sig\n    ) internal {\n        comet.allowBySig(\n            user,\n            address(this),\n            allowed,\n            nonce,\n            10e9,\n            sig.v,\n            sig.r,\n            sig.s\n        );\n    }\n\n}"
    },
    {
      "filename": "contracts/compound/libraries/LibCollateralSwap.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.7;\n\nimport {IERC20} from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IComet} from \"../interfaces/IComet.sol\";\n\nlibrary LibCollateralSwap {\n    using SafeMath for uint256;\n\n    error WidoRouterFailed();\n\n    struct Collateral {\n        address addr;\n        uint256 amount;\n    }\n\n    struct Signatures {\n        Signature allow;\n        Signature revoke;\n    }\n\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct WidoSwap {\n        address router;\n        address tokenManager;\n        bytes callData;\n    }\n\n    /// @dev Performs all the steps to swap collaterals on the Comet contract\n    function performCollateralSwap(\n        address borrowedAsset,\n        uint256 borrowedAmount,\n        uint256 fee,\n        bytes memory data\n    ) external {\n        // decode payload\n        (\n        address user,\n        IComet comet,\n        Collateral memory existingCollateral,\n        Signatures memory signatures,\n        WidoSwap memory swapDetails\n        ) = abi.decode(\n            data,\n            (address, IComet, Collateral, Signatures, WidoSwap)\n        );\n\n        // supply new collateral on behalf of user\n        _supplyTo(comet, user, borrowedAsset, borrowedAmount.sub(fee));\n\n        // withdraw existing collateral\n        _withdrawFrom(comet, user, existingCollateral, signatures);\n\n        // execute swap\n        _swap(existingCollateral, swapDetails);\n\n        // check amount of surplus collateral\n        uint256 surplusAmount = IERC20(borrowedAsset).balanceOf(address(this)) - borrowedAmount - fee;\n\n        // if positive slippage, supply extra to user\n        if (surplusAmount > 0) {\n            _supplyTo(comet, user, borrowedAsset, surplusAmount);\n        }\n    }\n\n    /// @dev Performs the swap of the collateral on the WidoRouter\n    function _swap(\n        Collateral memory collateral,\n        WidoSwap memory swap\n    ) internal {\n        // approve WidoTokenManager initial collateral to make the swap\n        IERC20(collateral.addr).approve(\n            swap.tokenManager,\n            collateral.amount\n        );\n\n        // execute swap\n        (bool success, bytes memory result) = swap.router.call(swap.callData);\n\n        if (!success) {\n            if (result.length < 68) revert WidoRouterFailed();\n            assembly {\n                result := add(result, 0x04)\n            }\n            revert(abi.decode(result, (string)));\n        }\n    }\n\n    /// @dev Supplies collateral on behalf of user\n    function _supplyTo(\n        IComet comet,\n        address user,\n        address asset,\n        uint256 amount\n    ) internal {\n        IERC20(asset).approve(address(comet), amount);\n        comet.supplyTo(user, asset, amount);\n    }\n\n    /// @dev This function withdraws the collateral from the user.\n    ///  It requires two consecutive EIP712 signatures to allow and revoke\n    ///  permissions to and from this contract.\n    function _withdrawFrom(\n        IComet comet,\n        address user,\n        Collateral memory collateral,\n        Signatures memory sigs\n    ) internal {\n        // get current nonce\n        uint256 nonce = comet.userNonce(user);\n        // allow the contract\n        _allowBySig(comet, user, true, nonce, sigs.allow);\n        // withdraw assets\n        comet.withdrawFrom(user, address(this), collateral.addr, collateral.amount);\n        // increment nonce\n        unchecked { nonce++; }\n        // revoke permission\n        _allowBySig(comet, user, false, nonce, sigs.revoke);\n    }\n\n    /// @dev Executes a single `allowBySig` operation on the Comet contract\n    function _allowBySig(\n        IComet comet,\n        address user,\n        bool allowed,\n        uint256 nonce,\n        Signature memory sig\n    ) internal {\n        comet.allowBySig(\n            user,\n            address(this),\n            allowed,\n            nonce,\n            10e9,\n            sig.v,\n            sig.r,\n            sig.s\n        );\n    }\n\n}"
    }
  ]
}