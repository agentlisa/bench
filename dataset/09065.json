{
  "Title": "[18] `startAmount` and `endAmount` being different would severely limit partial orders",
  "Content": "\nLet $n$ and $d$ represent `numerator` and `denominator` respectively, where $n \\le d$. Similarly, $s$ and $e$ represent `startAmount` and `endAmount`. Assume that $s \\neq e$ and for the sake of simplicity let's assume that $n$ and $d$ are in reduced form (coprime, i.e., $\\operatorname{gcd}(n, d) = 1$).\n\nThen, the following conditions have to be true for an order (here $a \\mid b$ means $a$ divides $b$):\n-  $d \\mid s$: [AmountDeriver.sol#L155](https://github.com/ProjectOpenSea/seaport/blob/6c24d09fc4be9bbecf749e6a7a592c8f7b659405/contracts/lib/AmountDeriver.sol#L155).\n-  $d \\mid e$: [AmountDeriver.sol#L156](https://github.com/ProjectOpenSea/seaport/blob/6c24d09fc4be9bbecf749e6a7a592c8f7b659405/contracts/lib/AmountDeriver.sol#L156).\n\nThis severely limits the possibilities of an order. For example, if $\\operatorname{gcd}(s, e) = 1$, then a strict partial order is impossible--only a full fill (`1 / 1`) would ever get past such checks.\n\n### Proof of Concept\n**Context:** [Seaport.sol](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/Seaport.sol)\n\nAlice places a partial order with `startAmount = 1000` and `endAmount = 2001`. Because `1000` and `2001` are coprime, such an order can only be fully filled.\n\n### Recommended Mitigation Steps\n\nPartially fillable orders with `gcd(startAmount, endAmount) == 1` should ideally be disallowed. This may be done at the frontend to simplify the code.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-opensea-seaport",
  "Code": [
    {
      "filename": "contracts/lib/AmountDeriver.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n// prettier-ignore\nimport {\n    AmountDerivationErrors\n} from \"../interfaces/AmountDerivationErrors.sol\";\n\n/**\n * @title AmountDeriver\n * @author 0age\n * @notice AmountDeriver contains pure functions related to deriving item\n *         amounts based on partial fill quantity and on linear extrapolation\n *         based on current time when the start amount and end amount differ.\n */\ncontract AmountDeriver is AmountDerivationErrors {\n    /**\n     * @dev Internal pure function to derive the current amount of a given item\n     *      based on the current price, the starting price, and the ending\n     *      price. If the start and end prices differ, the current price will be\n     *      extrapolated on a linear basis.\n     *\n     * @param startAmount The starting amount of the item.\n     * @param endAmount   The ending amount of the item.\n     * @param elapsed     The time elapsed since the order's start time.\n     * @param remaining   The time left until the order's end time.\n     * @param duration    The total duration of the order.\n     * @param roundUp     A boolean indicating whether the resultant amount\n     *                    should be rounded up or down.\n     *\n     * @return The current amount.\n     */\n    function _locateCurrentAmount(\n        uint256 startAmount,\n        uint256 endAmount,\n        uint256 elapsed,\n        uint256 remaining,\n        uint256 duration,\n        bool roundUp\n    ) internal pure returns (uint256) {\n        // Only modify end amount if it doesn't already equal start amount.\n        if (startAmount != endAmount) {\n            // Leave extra amount to add for rounding at zero (i.e. round down).\n            uint256 extraCeiling = 0;\n\n            // If rounding up, set rounding factor to one less than denominator.\n            if (roundUp) {\n                // Skip underflow check: duration cannot be zero.\n                unchecked {\n                    extraCeiling = duration - 1;\n                }\n            }\n\n            // Aggregate new amounts weighted by time with rounding factor\n            // prettier-ignore\n            uint256 totalBeforeDivision = (\n                (startAmount * remaining) + (endAmount * elapsed) + extraCeiling\n            );\n\n            // Division performed with no zero check as duration cannot be zero.\n            uint256 newAmount;\n            assembly {\n                newAmount := div(totalBeforeDivision, duration)\n            }\n\n            // Return the current amount (expressed as endAmount internally).\n            return newAmount;\n        }\n\n        // Return the original amount (now expressed as endAmount internally).\n        return endAmount;\n    }\n\n    /**\n     * @dev Internal pure function to return a fraction of a given value and to\n     *      ensure the resultant value does not have any fractional component.\n     *      Note that this function assumes that zero will never be supplied as\n     *      the denominator parameter; invalid / undefined behavior will result\n     *      should a denominator of zero be provided.\n     *\n     * @param numerator   A value indicating the portion of the order that\n     *                    should be filled.\n     * @param denominator A value indicating the total size of the order. Note\n     *                    that this value cannot be equal to zero.\n     * @param value       The value for which to compute the fraction.\n     *\n     * @return newValue The value after applying the fraction.\n     */\n    function _getFraction(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 value\n    ) internal pure returns (uint256 newValue) {\n        // Return value early in cases where the fraction resolves to 1.\n        if (numerator == denominator) {\n            return value;\n        }\n\n        // Ensure fraction can be applied to the value with no remainder. Note\n        // that the denominator cannot be zero.\n        bool exact;\n        assembly {\n            // Ensure new value contains no remainder via mulmod operator.\n            // Credit to @hrkrshnn + @axic for proposing this optimal solution.\n            exact := iszero(mulmod(value, numerator, denominator))\n        }\n\n        // Ensure that division gave a final result with no remainder.\n        if (!exact) {\n            revert InexactFraction();\n        }\n\n        // Multiply the numerator by the value and ensure no overflow occurs.\n        uint256 valueTimesNumerator = value * numerator;\n\n        // Divide and check for remainder. Note that denominator cannot be zero.\n        assembly {\n            // Perform division without zero check.\n            newValue := div(valueTimesNumerator, denominator)\n        }\n    }\n\n    /**\n     * @dev Internal pure function to apply a fraction to a consideration\n     * or offer item.\n     *\n     * @param startAmount     The starting amount of the item.\n     * @param endAmount       The ending amount of the item.\n     * @param numerator       A value indicating the portion of the order that\n     *                        should be filled.\n     * @param denominator     A value indicating the total size of the order.\n     * @param elapsed         The time elapsed since the order's start time.\n     * @param remaining       The time left until the order's end time.\n     * @param duration        The total duration of the order.\n     *\n     * @return amount The received item to transfer with the final amount.\n     */\n    function _applyFraction(\n        uint256 startAmount,\n        uint256 endAmount,\n        uint256 numerator,\n        uint256 denominator,\n        uint256 elapsed,\n        uint256 remaining,\n        uint256 duration,\n        bool roundUp\n    ) internal pure returns (uint256 amount) {\n        // If start amount equals end amount, apply fraction to end amount.\n        if (startAmount == endAmount) {\n            // Apply fraction to end amount.\n            amount = _getFraction(numerator, denominator, endAmount);\n        } else {\n            // Otherwise, apply fraction to both and extrapolate final amount.\n            amount = _locateCurrentAmount(\n                _getFraction(numerator, denominator, startAmount),\n                _getFraction(numerator, denominator, endAmount),\n                elapsed,\n                remaining,\n                duration,\n                roundUp\n            );\n        }\n    }\n}"
    },
    {
      "filename": "contracts/lib/AmountDeriver.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n// prettier-ignore\nimport {\n    AmountDerivationErrors\n} from \"../interfaces/AmountDerivationErrors.sol\";\n\n/**\n * @title AmountDeriver\n * @author 0age\n * @notice AmountDeriver contains pure functions related to deriving item\n *         amounts based on partial fill quantity and on linear extrapolation\n *         based on current time when the start amount and end amount differ.\n */\ncontract AmountDeriver is AmountDerivationErrors {\n    /**\n     * @dev Internal pure function to derive the current amount of a given item\n     *      based on the current price, the starting price, and the ending\n     *      price. If the start and end prices differ, the current price will be\n     *      extrapolated on a linear basis.\n     *\n     * @param startAmount The starting amount of the item.\n     * @param endAmount   The ending amount of the item.\n     * @param elapsed     The time elapsed since the order's start time.\n     * @param remaining   The time left until the order's end time.\n     * @param duration    The total duration of the order.\n     * @param roundUp     A boolean indicating whether the resultant amount\n     *                    should be rounded up or down.\n     *\n     * @return The current amount.\n     */\n    function _locateCurrentAmount(\n        uint256 startAmount,\n        uint256 endAmount,\n        uint256 elapsed,\n        uint256 remaining,\n        uint256 duration,\n        bool roundUp\n    ) internal pure returns (uint256) {\n        // Only modify end amount if it doesn't already equal start amount.\n        if (startAmount != endAmount) {\n            // Leave extra amount to add for rounding at zero (i.e. round down).\n            uint256 extraCeiling = 0;\n\n            // If rounding up, set rounding factor to one less than denominator.\n            if (roundUp) {\n                // Skip underflow check: duration cannot be zero.\n                unchecked {\n                    extraCeiling = duration - 1;\n                }\n            }\n\n            // Aggregate new amounts weighted by time with rounding factor\n            // prettier-ignore\n            uint256 totalBeforeDivision = (\n                (startAmount * remaining) + (endAmount * elapsed) + extraCeiling\n            );\n\n            // Division performed with no zero check as duration cannot be zero.\n            uint256 newAmount;\n            assembly {\n                newAmount := div(totalBeforeDivision, duration)\n            }\n\n            // Return the current amount (expressed as endAmount internally).\n            return newAmount;\n        }\n\n        // Return the original amount (now expressed as endAmount internally).\n        return endAmount;\n    }\n\n    /**\n     * @dev Internal pure function to return a fraction of a given value and to\n     *      ensure the resultant value does not have any fractional component.\n     *      Note that this function assumes that zero will never be supplied as\n     *      the denominator parameter; invalid / undefined behavior will result\n     *      should a denominator of zero be provided.\n     *\n     * @param numerator   A value indicating the portion of the order that\n     *                    should be filled.\n     * @param denominator A value indicating the total size of the order. Note\n     *                    that this value cannot be equal to zero.\n     * @param value       The value for which to compute the fraction.\n     *\n     * @return newValue The value after applying the fraction.\n     */\n    function _getFraction(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 value\n    ) internal pure returns (uint256 newValue) {\n        // Return value early in cases where the fraction resolves to 1.\n        if (numerator == denominator) {\n            return value;\n        }\n\n        // Ensure fraction can be applied to the value with no remainder. Note\n        // that the denominator cannot be zero.\n        bool exact;\n        assembly {\n            // Ensure new value contains no remainder via mulmod operator.\n            // Credit to @hrkrshnn + @axic for proposing this optimal solution.\n            exact := iszero(mulmod(value, numerator, denominator))\n        }\n\n        // Ensure that division gave a final result with no remainder.\n        if (!exact) {\n            revert InexactFraction();\n        }\n\n        // Multiply the numerator by the value and ensure no overflow occurs.\n        uint256 valueTimesNumerator = value * numerator;\n\n        // Divide and check for remainder. Note that denominator cannot be zero.\n        assembly {\n            // Perform division without zero check.\n            newValue := div(valueTimesNumerator, denominator)\n        }\n    }\n\n    /**\n     * @dev Internal pure function to apply a fraction to a consideration\n     * or offer item.\n     *\n     * @param startAmount     The starting amount of the item.\n     * @param endAmount       The ending amount of the item.\n     * @param numerator       A value indicating the portion of the order that\n     *                        should be filled.\n     * @param denominator     A value indicating the total size of the order.\n     * @param elapsed         The time elapsed since the order's start time.\n     * @param remaining       The time left until the order's end time.\n     * @param duration        The total duration of the order.\n     *\n     * @return amount The received item to transfer with the final amount.\n     */\n    function _applyFraction(\n        uint256 startAmount,\n        uint256 endAmount,\n        uint256 numerator,\n        uint256 denominator,\n        uint256 elapsed,\n        uint256 remaining,\n        uint256 duration,\n        bool roundUp\n    ) internal pure returns (uint256 amount) {\n        // If start amount equals end amount, apply fraction to end amount.\n        if (startAmount == endAmount) {\n            // Apply fraction to end amount.\n            amount = _getFraction(numerator, denominator, endAmount);\n        } else {\n            // Otherwise, apply fraction to both and extrapolate final amount.\n            amount = _locateCurrentAmount(\n                _getFraction(numerator, denominator, startAmount),\n                _getFraction(numerator, denominator, endAmount),\n                elapsed,\n                remaining,\n                duration,\n                roundUp\n            );\n        }\n    }\n}"
    }
  ]
}