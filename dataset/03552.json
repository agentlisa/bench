{
  "Title": "[L06] Rewards can overflow buffer",
  "Content": "When allocating funds, the `VaultCore` contract first [ensures its internal buffer is full](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/vault/VaultCore.sol#L285) and then [determines the excess amount](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/vault/VaultCore.sol#L288) to invest. After [investing this amount](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/vault/VaultCore.sol#L318-L319) for each asset, it [harvests any rewards](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/vault/VaultCore.sol#L324-L347) from its previous investments and [converts them to USDT](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/vault/VaultAdmin.sol#L372-L377).\n\n\nThis implies that the reward balances, which can be arbitrarily large, remain in the vault and exceed the size of the buffer. This undermines the purpose of the buffer and is an unexpected behavior. Consider harvesting the rewards before determining and allocating the available funds.\n\n\n**Update:** *Fixed in [PR#690](https://github.com/OriginProtocol/origin-dollar/pull/690). The reward tokens are now harvested before allocating assets to the strategies.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/contracts/vault/VaultCore.sol",
      "content": "pragma solidity 0.5.11;\n\n/**\n * @title OUSD Vault Contract\n * @notice The Vault contract stores assets. On a deposit, OUSD will be minted\n           and sent to the depositor. On a withdrawal, OUSD will be burned and\n           assets will be sent to the withdrawer. The Vault accepts deposits of\n           interest form yield bearing strategies which will modify the supply\n           of OUSD.\n * @author Origin Protocol Inc\n */\n\nimport \"./VaultStorage.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IBuyback } from \"../interfaces/IBuyback.sol\";\n\ncontract VaultCore is VaultStorage {\n    uint256 constant MAX_UINT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /**\n     * @dev Verifies that the rebasing is not paused.\n     */\n    modifier whenNotRebasePaused() {\n        require(!rebasePaused, \"Rebasing paused\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the deposits are not paused.\n     */\n    modifier whenNotCapitalPaused() {\n        require(!capitalPaused, \"Capital paused\");\n        _;\n    }\n\n    /**\n     * @dev Deposit a supported asset and mint OUSD.\n     * @param _asset Address of the asset being deposited\n     * @param _amount Amount of the asset being deposited\n     * @param _minimumOusdAmount Minimum OUSD to mint\n     */\n    function mint(\n        address _asset,\n        uint256 _amount,\n        uint256 _minimumOusdAmount\n    ) external whenNotCapitalPaused nonReentrant {\n        require(assets[_asset].isSupported, \"Asset is not supported\");\n        require(_amount > 0, \"Amount must be greater than 0\");\n\n        uint256 price = IOracle(priceProvider).price(_asset);\n        if (price > 1e8) {\n            price = 1e8;\n        }\n        uint256 assetDecimals = Helpers.getDecimals(_asset);\n        uint256 unitAdjustedDeposit = _amount.scaleBy(int8(18 - assetDecimals));\n        uint256 priceAdjustedDeposit = _amount.mulTruncateScale(\n            price.scaleBy(int8(10)), // 18-8 because oracles have 8 decimals precision\n            10**assetDecimals\n        );\n\n        if (_minimumOusdAmount > 0) {\n            require(\n                priceAdjustedDeposit >= _minimumOusdAmount,\n                \"Mint amount lower than minimum\"\n            );\n        }\n\n        emit Mint(msg.sender, priceAdjustedDeposit);\n\n        // Rebase must happen before any transfers occur.\n        if (unitAdjustedDeposit >= rebaseThreshold && !rebasePaused) {\n            _rebase();\n        }\n\n        // Mint matching OUSD\n        oUSD.mint(msg.sender, priceAdjustedDeposit);\n\n        // Transfer the deposited coins to the vault\n        IERC20 asset = IERC20(_asset);\n        asset.safeTransferFrom(msg.sender, address(this), _amount);\n\n        if (unitAdjustedDeposit >= autoAllocateThreshold) {\n            _allocate();\n        }\n    }\n\n    /**\n     * @dev Mint for multiple assets in the same call.\n     * @param _assets Addresses of assets being deposited\n     * @param _amounts Amount of each asset at the same index in the _assets\n     *                 to deposit.\n     * @param _minimumOusdAmount Minimum OUSD to mint\n     */\n    function mintMultiple(\n        address[] calldata _assets,\n        uint256[] calldata _amounts,\n        uint256 _minimumOusdAmount\n    ) external whenNotCapitalPaused nonReentrant {\n        require(_assets.length == _amounts.length, \"Parameter length mismatch\");\n\n        uint256 unitAdjustedTotal = 0;\n        uint256 priceAdjustedTotal = 0;\n        uint256[] memory assetPrices = _getAssetPrices(false);\n        for (uint256 j = 0; j < _assets.length; j++) {\n            // In memoriam\n            require(assets[_assets[j]].isSupported, \"Asset is not supported\");\n            require(_amounts[j] > 0, \"Amount must be greater than 0\");\n            for (uint256 i = 0; i < allAssets.length; i++) {\n                if (_assets[j] == allAssets[i]) {\n                    uint256 assetDecimals = Helpers.getDecimals(allAssets[i]);\n                    uint256 price = assetPrices[i];\n                    if (price > 1e18) {\n                        price = 1e18;\n                    }\n                    unitAdjustedTotal = unitAdjustedTotal.add(\n                        _amounts[j].scaleBy(int8(18 - assetDecimals))\n                    );\n                    priceAdjustedTotal = priceAdjustedTotal.add(\n                        _amounts[j].mulTruncateScale(price, 10**assetDecimals)\n                    );\n                }\n            }\n        }\n\n        if (_minimumOusdAmount > 0) {\n            require(\n                priceAdjustedTotal >= _minimumOusdAmount,\n                \"Mint amount lower than minimum\"\n            );\n        }\n\n        emit Mint(msg.sender, priceAdjustedTotal);\n\n        // Rebase must happen before any transfers occur.\n        if (unitAdjustedTotal >= rebaseThreshold && !rebasePaused) {\n            _rebase();\n        }\n\n        oUSD.mint(msg.sender, priceAdjustedTotal);\n\n        for (uint256 i = 0; i < _assets.length; i++) {\n            IERC20 asset = IERC20(_assets[i]);\n            asset.safeTransferFrom(msg.sender, address(this), _amounts[i]);\n        }\n\n        if (unitAdjustedTotal >= autoAllocateThreshold) {\n            _allocate();\n        }\n    }\n\n    /**\n     * @dev Withdraw a supported asset and burn OUSD.\n     * @param _amount Amount of OUSD to burn\n     * @param _minimumUnitAmount Minimum stablecoin units to receive in return\n     */\n    function redeem(uint256 _amount, uint256 _minimumUnitAmount)\n        public\n        whenNotCapitalPaused\n        nonReentrant\n    {\n        _redeem(_amount, _minimumUnitAmount);\n    }\n\n    /**\n     * @dev Withdraw a supported asset and burn OUSD.\n     * @param _amount Amount of OUSD to burn\n     * @param _minimumUnitAmount Minimum stablecoin units to receive in return\n     */\n    function _redeem(uint256 _amount, uint256 _minimumUnitAmount) internal {\n        require(_amount > 0, \"Amount must be greater than 0\");\n\n        // Calculate redemption outputs\n        (\n            uint256[] memory outputs,\n            uint256 _backingValue\n        ) = _calculateRedeemOutputs(_amount);\n\n        // Check that OUSD is backed by enough assets\n        uint256 _totalSupply = oUSD.totalSupply();\n        if (maxSupplyDiff > 0) {\n            // Allow a max difference of maxSupplyDiff% between\n            // backing assets value and OUSD total supply\n            uint256 diff = _totalSupply.divPrecisely(_backingValue);\n            require(\n                (diff > 1e18 ? diff.sub(1e18) : uint256(1e18).sub(diff)) <=\n                    maxSupplyDiff,\n                \"Backing supply liquidity error\"\n            );\n        }\n\n        emit Redeem(msg.sender, _amount);\n\n        // Send outputs\n        for (uint256 i = 0; i < allAssets.length; i++) {\n            if (outputs[i] == 0) continue;\n\n            IERC20 asset = IERC20(allAssets[i]);\n\n            if (asset.balanceOf(address(this)) >= outputs[i]) {\n                // Use Vault funds first if sufficient\n                asset.safeTransfer(msg.sender, outputs[i]);\n            } else {\n                address strategyAddr = assetDefaultStrategies[allAssets[i]];\n                if (strategyAddr != address(0)) {\n                    // Nothing in Vault, but something in Strategy, send from there\n                    IStrategy strategy = IStrategy(strategyAddr);\n                    strategy.withdraw(msg.sender, allAssets[i], outputs[i]);\n                } else {\n                    // Cant find funds anywhere\n                    revert(\"Liquidity error\");\n                }\n            }\n        }\n\n        if (_minimumUnitAmount > 0) {\n            uint256 unitTotal = 0;\n            for (uint256 i = 0; i < outputs.length; i++) {\n                uint256 assetDecimals = Helpers.getDecimals(allAssets[i]);\n                unitTotal = unitTotal.add(\n                    outputs[i].scaleBy(int8(18 - assetDecimals))\n                );\n            }\n            require(\n                unitTotal >= _minimumUnitAmount,\n                \"Redeem amount lower than minimum\"\n            );\n        }\n\n        oUSD.burn(msg.sender, _amount);\n\n        // Until we can prove that we won't affect the prices of our assets\n        // by withdrawing them, this should be here.\n        // It's possible that a strategy was off on its asset total, perhaps\n        // a reward token sold for more or for less than anticipated.\n        if (_amount > rebaseThreshold && !rebasePaused) {\n            _rebase();\n        }\n    }\n\n    /**\n     * @notice Withdraw a supported asset and burn all OUSD.\n     * @param _minimumUnitAmount Minimum stablecoin units to receive in return\n     */\n    function redeemAll(uint256 _minimumUnitAmount)\n        external\n        whenNotCapitalPaused\n        nonReentrant\n    {\n        _redeem(oUSD.balanceOf(msg.sender), _minimumUnitAmount);\n    }\n\n    /**\n     * @notice Allocate unallocated funds on Vault to strategies.\n     * @dev Allocate unallocated funds on Vault to strategies.\n     **/\n    function allocate() public whenNotCapitalPaused nonReentrant {\n        _allocate();\n    }\n\n    /**\n     * @notice Allocate unallocated funds on Vault to strategies.\n     * @dev Allocate unallocated funds on Vault to strategies.\n     **/\n    function _allocate() internal {\n        uint256 vaultValue = _totalValueInVault();\n        // Nothing in vault to allocate\n        if (vaultValue == 0) return;\n        uint256 strategiesValue = _totalValueInStrategies();\n        // We have a method that does the same as this, gas optimisation\n        uint256 calculatedTotalValue = vaultValue.add(strategiesValue);\n\n        // We want to maintain a buffer on the Vault so calculate a percentage\n        // modifier to multiply each amount being allocated by to enforce the\n        // vault buffer\n        uint256 vaultBufferModifier;\n        if (strategiesValue == 0) {\n            // Nothing in Strategies, allocate 100% minus the vault buffer to\n            // strategies\n            vaultBufferModifier = uint256(1e18).sub(vaultBuffer);\n        } else {\n            vaultBufferModifier = vaultBuffer.mul(calculatedTotalValue).div(\n                vaultValue\n            );\n            if (1e18 > vaultBufferModifier) {\n                // E.g. 1e18 - (1e17 * 10e18)/5e18 = 8e17\n                // (5e18 * 8e17) / 1e18 = 4e18 allocated from Vault\n                vaultBufferModifier = uint256(1e18).sub(vaultBufferModifier);\n            } else {\n                // We need to let the buffer fill\n                return;\n            }\n        }\n        if (vaultBufferModifier == 0) return;\n\n        // Iterate over all assets in the Vault and allocate the the appropriate\n        // strategy\n        for (uint256 i = 0; i < allAssets.length; i++) {\n            IERC20 asset = IERC20(allAssets[i]);\n            uint256 assetBalance = asset.balanceOf(address(this));\n            // No balance, nothing to do here\n            if (assetBalance == 0) continue;\n\n            // Multiply the balance by the vault buffer modifier and truncate\n            // to the scale of the asset decimals\n            uint256 allocateAmount = assetBalance.mulTruncate(\n                vaultBufferModifier\n            );\n\n            address depositStrategyAddr = assetDefaultStrategies[address(\n                asset\n            )];\n\n            if (depositStrategyAddr != address(0) && allocateAmount > 0) {\n                IStrategy strategy = IStrategy(depositStrategyAddr);\n                // Transfer asset to Strategy and call deposit method to\n                // mint or take required action\n                asset.safeTransfer(address(strategy), allocateAmount);\n                strategy.deposit(address(asset), allocateAmount);\n            }\n        }\n\n        // Harvest for all reward tokens above reward liquidation threshold\n        for (uint256 i = 0; i < allStrategies.length; i++) {\n            IStrategy strategy = IStrategy(allStrategies[i]);\n            address rewardTokenAddress = strategy.rewardTokenAddress();\n            if (rewardTokenAddress != address(0)) {\n                uint256 liquidationThreshold = strategy\n                    .rewardLiquidationThreshold();\n                if (liquidationThreshold == 0) {\n                    // No threshold set, always harvest from strategy\n                    IVault(address(this)).harvest(allStrategies[i]);\n                } else {\n                    // Check balance against liquidation threshold\n                    // Note some strategies don't hold the reward token balance\n                    // on their contract so the liquidation threshold should be\n                    // set to 0\n                    IERC20 rewardToken = IERC20(rewardTokenAddress);\n                    uint256 rewardTokenAmount = rewardToken.balanceOf(\n                        allStrategies[i]\n                    );\n                    if (rewardTokenAmount >= liquidationThreshold) {\n                        IVault(address(this)).harvest(allStrategies[i]);\n                    }\n                }\n            }\n        }\n\n        // Trigger OGN Buyback\n        IBuyback(trusteeAddress).swap();\n    }\n\n    /**\n     * @dev Calculate the total value of assets held by the Vault and all\n     *      strategies and update the supply of OUSD.\n     */\n    function rebase() public whenNotRebasePaused nonReentrant {\n        _rebase();\n    }\n\n    /**\n     * @dev Calculate the total value of assets held by the Vault and all\n     *      strategies and update the supply of OUSD, optionaly sending a\n     *      portion of the yield to the trustee.\n     */\n    function _rebase() internal whenNotRebasePaused {\n        uint256 ousdSupply = oUSD.totalSupply();\n        if (ousdSupply == 0) {\n            return;\n        }\n        uint256 vaultValue = _totalValue();\n\n        // Yield fee collection\n        address _trusteeAddress = trusteeAddress; // gas savings\n        if (_trusteeAddress != address(0) && (vaultValue > ousdSupply)) {\n            uint256 yield = vaultValue.sub(ousdSupply);\n            uint256 fee = yield.mul(trusteeFeeBps).div(10000);\n            require(yield > fee, \"Fee must not be greater than yield\");\n            if (fee > 0) {\n                oUSD.mint(_trusteeAddress, fee);\n            }\n            emit YieldDistribution(_trusteeAddress, yield, fee);\n        }\n\n        // Only rachet OUSD supply upwards\n        ousdSupply = oUSD.totalSupply(); // Final check should use latest value\n        if (vaultValue > ousdSupply) {\n            oUSD.changeSupply(vaultValue);\n        }\n    }\n\n    /**\n     * @dev Determine the total value of assets held by the vault and its\n     *         strategies.\n     * @return uint256 value Total value in USD (1e18)\n     */\n    function totalValue() external view returns (uint256 value) {\n        value = _totalValue();\n    }\n\n    /**\n     * @dev Internal Calculate the total value of the assets held by the\n     *         vault and its strategies.\n     * @return uint256 value Total value in USD (1e18)\n     */\n    function _totalValue() internal view returns (uint256 value) {\n        return _totalValueInVault().add(_totalValueInStrategies());\n    }\n\n    /**\n     * @dev Internal to calculate total value of all assets held in Vault.\n     * @return uint256 Total value in ETH (1e18)\n     */\n    function _totalValueInVault() internal view returns (uint256 value) {\n        for (uint256 y = 0; y < allAssets.length; y++) {\n            IERC20 asset = IERC20(allAssets[y]);\n            uint256 assetDecimals = Helpers.getDecimals(allAssets[y]);\n            uint256 balance = asset.balanceOf(address(this));\n            if (balance > 0) {\n                value = value.add(balance.scaleBy(int8(18 - assetDecimals)));\n            }\n        }\n    }\n\n    /**\n     * @dev Internal to calculate total value of all assets held in Strategies.\n     * @return uint256 Total value in ETH (1e18)\n     */\n    function _totalValueInStrategies() internal view returns (uint256 value) {\n        for (uint256 i = 0; i < allStrategies.length; i++) {\n            value = value.add(_totalValueInStrategy(allStrategies[i]));\n        }\n    }\n\n    /**\n     * @dev Internal to calculate total value of all assets held by strategy.\n     * @param _strategyAddr Address of the strategy\n     * @return uint256 Total value in ETH (1e18)\n     */\n    function _totalValueInStrategy(address _strategyAddr)\n        internal\n        view\n        returns (uint256 value)\n    {\n        IStrategy strategy = IStrategy(_strategyAddr);\n        for (uint256 y = 0; y < allAssets.length; y++) {\n            uint256 assetDecimals = Helpers.getDecimals(allAssets[y]);\n            if (strategy.supportsAsset(allAssets[y])) {\n                uint256 balance = strategy.checkBalance(allAssets[y]);\n                if (balance > 0) {\n                    value = value.add(\n                        balance.scaleBy(int8(18 - assetDecimals))\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Get the balance of an asset held in Vault and all strategies.\n     * @param _asset Address of asset\n     * @return uint256 Balance of asset in decimals of asset\n     */\n    function checkBalance(address _asset) external view returns (uint256) {\n        return _checkBalance(_asset);\n    }\n\n    /**\n     * @notice Get the balance of an asset held in Vault and all strategies.\n     * @param _asset Address of asset\n     * @return uint256 Balance of asset in decimals of asset\n     */\n    function _checkBalance(address _asset)\n        internal\n        view\n        returns (uint256 balance)\n    {\n        IERC20 asset = IERC20(_asset);\n        balance = asset.balanceOf(address(this));\n        for (uint256 i = 0; i < allStrategies.length; i++) {\n            IStrategy strategy = IStrategy(allStrategies[i]);\n            if (strategy.supportsAsset(_asset)) {\n                balance = balance.add(strategy.checkBalance(_asset));\n            }\n        }\n    }\n\n    /**\n     * @notice Get the balance of all assets held in Vault and all strategies.\n     * @return uint256 Balance of all assets (1e18)\n     */\n    function _checkBalance() internal view returns (uint256 balance) {\n        for (uint256 i = 0; i < allAssets.length; i++) {\n            uint256 assetDecimals = Helpers.getDecimals(allAssets[i]);\n            balance = balance.add(\n                _checkBalance(allAssets[i]).scaleBy(int8(18 - assetDecimals))\n            );\n        }\n    }\n\n    /**\n     * @notice Calculate the outputs for a redeem function, i.e. the mix of\n     * coins that will be returned\n     */\n    function calculateRedeemOutputs(uint256 _amount)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        (\n            uint256[] memory outputs,\n            uint256 totalValue\n        ) = _calculateRedeemOutputs(_amount);\n        return outputs;\n    }\n\n    /**\n     * @notice Calculate the outputs for a redeem function, i.e. the mix of\n     * coins that will be returned.\n     * @return Array of amounts respective to the supported assets\n     */\n    function _calculateRedeemOutputs(uint256 _amount)\n        internal\n        view\n        returns (uint256[] memory outputs, uint256 totalBalance)\n    {\n        // We always give out coins in proportion to how many we have,\n        // Now if all coins were the same value, this math would easy,\n        // just take the percentage of each coin, and multiply by the\n        // value to be given out. But if coins are worth more than $1,\n        // then we would end up handing out too many coins. We need to\n        // adjust by the total value of coins.\n        //\n        // To do this, we total up the value of our coins, by their\n        // percentages. Then divide what we would otherwise give out by\n        // this number.\n        //\n        // Let say we have 100 DAI at $1.06  and 200 USDT at $1.00.\n        // So for every 1 DAI we give out, we'll be handing out 2 USDT\n        // Our total output ratio is: 33% * 1.06 + 66% * 1.00 = 1.02\n        //\n        // So when calculating the output, we take the percentage of\n        // each coin, times the desired output value, divided by the\n        // totalOutputRatio.\n        //\n        // For example, withdrawing: 30 OUSD:\n        // DAI 33% * 30 / 1.02 = 9.80 DAI\n        // USDT = 66 % * 30 / 1.02 = 19.60 USDT\n        //\n        // Checking these numbers:\n        // 9.80 DAI * 1.06 = $10.40\n        // 19.60 USDT * 1.00 = $19.60\n        //\n        // And so the user gets $10.40 + $19.60 = $30 worth of value.\n\n        uint256 assetCount = getAssetCount();\n        uint256[] memory assetPrices = _getAssetPrices(true);\n        uint256[] memory assetBalances = new uint256[](assetCount);\n        uint256[] memory assetDecimals = new uint256[](assetCount);\n        uint256 totalOutputRatio = 0;\n        outputs = new uint256[](assetCount);\n\n        // Calculate redeem fee\n        if (redeemFeeBps > 0) {\n            uint256 redeemFee = _amount.mul(redeemFeeBps).div(10000);\n            _amount = _amount.sub(redeemFee);\n        }\n\n        // Calculate assets balances and decimals once,\n        // for a large gas savings.\n        for (uint256 i = 0; i < allAssets.length; i++) {\n            uint256 balance = _checkBalance(allAssets[i]);\n            uint256 decimals = Helpers.getDecimals(allAssets[i]);\n            assetBalances[i] = balance;\n            assetDecimals[i] = decimals;\n            totalBalance = totalBalance.add(\n                balance.scaleBy(int8(18 - decimals))\n            );\n        }\n        // Calculate totalOutputRatio\n        for (uint256 i = 0; i < allAssets.length; i++) {\n            uint256 price = assetPrices[i];\n            // Never give out more than one\n            // stablecoin per dollar of OUSD\n            if (price < 1e18) {\n                price = 1e18;\n            }\n            uint256 ratio = assetBalances[i]\n                .scaleBy(int8(18 - assetDecimals[i]))\n                .mul(price)\n                .div(totalBalance);\n            totalOutputRatio = totalOutputRatio.add(ratio);\n        }\n        // Calculate final outputs\n        uint256 factor = _amount.divPrecisely(totalOutputRatio);\n        for (uint256 i = 0; i < allAssets.length; i++) {\n            outputs[i] = assetBalances[i].mul(factor).div(totalBalance);\n        }\n    }\n\n    /**\n     * @notice Get an array of the supported asset prices in USD.\n     * @return uint256[] Array of asset prices in USD (1e18)\n     */\n    function _getAssetPrices(bool useMax)\n        internal\n        view\n        returns (uint256[] memory assetPrices)\n    {\n        assetPrices = new uint256[](getAssetCount());\n\n        IOracle oracle = IOracle(priceProvider);\n        // Price from Oracle is returned with 8 decimals\n        // _amount is in assetDecimals\n        for (uint256 i = 0; i < allAssets.length; i++) {\n            assetPrices[i] = oracle.price(allAssets[i]).scaleBy(int8(18 - 8));\n        }\n    }\n\n    /***************************************\n                    Utils\n    ****************************************/\n\n    /**\n     * @dev Return the number of assets suppported by the Vault.\n     */\n    function getAssetCount() public view returns (uint256) {\n        return allAssets.length;\n    }\n\n    /**\n     * @dev Return all asset addresses in order\n     */\n    function getAllAssets() external view returns (address[] memory) {\n        return allAssets;\n    }\n\n    /**\n     * @dev Return the number of strategies active on the Vault.\n     */\n    function getStrategyCount() external view returns (uint256) {\n        return allStrategies.length;\n    }\n\n    function isSupportedAsset(address _asset) external view returns (bool) {\n        return assets[_asset].isSupported;\n    }\n\n    /**\n     * @dev Falldown to the admin implementation\n     * @notice This is a catch all for all functions not declared in core\n     */\n    function() external payable {\n        bytes32 slot = adminImplPosition;\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize)\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas, sload(slot), 0, calldatasize, 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize)\n\n            switch result\n                // delegatecall returns 0 on error.\n                case 0 {\n                    revert(0, returndatasize)\n                }\n                default {\n                    return(0, returndatasize)\n                }\n        }\n    }\n}"
    }
  ]
}