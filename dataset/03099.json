{
  "Title": "Strongly coupled contracts can break core functionality",
  "Content": "The [`OgvStaking`](https://github.com/OriginProtocol/ousd-governance/blob/2b9761606d4ac4062b69367ebbad88220cea45ce/contracts/OgvStaking.sol) contract is strongly coupled with the [`RewardsSource`](https://github.com/OriginProtocol/ousd-governance/blob/2b9761606d4ac4062b69367ebbad88220cea45ce/contracts/RewardsSource.sol) contract:\n\n\n* In `OgvStaking` the external functions `stake`, `unstake` and `extend` must call the internal function `_collectRewards` to update and transfer a user’s rewards.\n* `_collectRewards` calls [`RewardsSource.collectRewards`](https://github.com/OriginProtocol/ousd-governance/blob/2b9761606d4ac4062b69367ebbad88220cea45ce/contracts/RewardsSource.sol#L34) to update the `accRewardPerShare` variable and receive all rewards that accrued within `RewardsSource` since the last call to `collectRewards`.\n\n\nIn consequence, any issue within the rewards distribution of the `RewardsSource.collectRewards` function will escalate into the governance-related functions of the `OgvStaking` contract.\n\n\nThis issue is further amplified by misleading documentation in the [`RewardsSource.setRewardsTarget`](https://github.com/OriginProtocol/ousd-governance/blob/2b9761606d4ac4062b69367ebbad88220cea45ce/contracts/RewardsSource.sol#L123) function, which contains the comment “Okay to be zero, just disables collecting rewards”. However, setting the `rewardTarget` to the zero address would cause any calls from `OgvStaking` to `RewardsSource.collectRewards` to revert, which will disable `staking`, thereby not allowing any new `OGV` holders to participate in governance.\n\n\nConsider wrapping the external call to [`RewardsSource.collectReward`](https://github.com/OriginProtocol/ousd-governance/blob/2b9761606d4ac4062b69367ebbad88220cea45ce/contracts/OgvStaking.sol#L189) into a try/catch block to achieve decoupling of reward mechanics and staking-based governance. Additionally, consider removing the `noRewards` parameter of the `unstake` function which was originally intended for emergency withdrawals.\n\n\n**Update**: *Fixed in pull request [#97](https://github.com/OriginProtocol/ousd-governance/pull/97). In addition, consider catching the error reason and emitting it as an event parameter to allow detection of the otherwise silent error.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/RewardsSource.sol",
      "content": "pragma solidity 0.8.10;\nimport {ERC20Votes} from \"OpenZeppelin/openzeppelin-contracts@4.6.0/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport {ERC20Permit} from \"OpenZeppelin/openzeppelin-contracts@4.6.0/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport {ERC20} from \"OpenZeppelin/openzeppelin-contracts@4.6.0/contracts/token/ERC20/ERC20.sol\";\nimport {PRBMathUD60x18} from \"paulrberg/prb-math@2.5.0/contracts/PRBMathUD60x18.sol\";\nimport {Governable} from \"./Governable.sol\";\n\ninterface Mintable {\n    function mint(address to, uint256 amount) external;\n}\n\ncontract RewardsSource is Governable {\n    ERC20 public immutable ogv;\n    address public rewardsTarget; // Contract that receives rewards\n    uint256 public lastRewardTime; // Start of the time to calculate rewards over\n    uint256 private currentSlopeIndex = 0; // Allows us to start with the correct slope\n\n    struct Slope {\n        uint64 start; // uint64 = billions and billions of years\n        uint64 end; // Internal use only. By duplicating the start of the next slope, we can save a slot read\n        uint128 ratePerDay;\n    }\n    Slope[] public inflationSlopes;\n\n    uint256 constant MAX_KNEES = 48;\n    uint256 constant MAX_INFLATION_PER_DAY = (5 * 1e6 * 1e18);\n\n    constructor(address ogv_) {\n        require(ogv_ != address(0), \"Rewards: OGV must be set\");\n        ogv = ERC20(ogv_);\n        lastRewardTime = block.timestamp; // No possible rewards from before contract deployed\n    }\n\n    function collectRewards() external returns (uint256) {\n        require(msg.sender == rewardsTarget, \"Rewards: Not rewardsTarget\");\n        if (block.timestamp <= lastRewardTime) {\n            return 0;\n        }\n        (uint256 rewards, uint256 _nextSlopeIndex) = _calcRewards();\n        if (_nextSlopeIndex != 0) {\n            currentSlopeIndex = _nextSlopeIndex;\n        }\n        lastRewardTime = block.timestamp;\n        Mintable(address(ogv)).mint(rewardsTarget, rewards);\n        return rewards;\n    }\n\n    function previewRewards() external view returns (uint256) {\n        (uint256 rewards, ) = _calcRewards();\n        return rewards;\n    }\n\n    function _calcRewards() internal view returns (uint256, uint256) {\n        uint256 last = lastRewardTime;\n        if (last >= block.timestamp) {\n            return (0, currentSlopeIndex);\n        }\n        if (inflationSlopes.length == 0) {\n            return (0, 0); // Save a slot read by returning a zero constant\n        } \n        uint256 total = 0;\n        uint256 nextSlopeIndex = 0; // Zero means no change\n        uint256 _currentSlopeIndex = currentSlopeIndex;\n        uint256 i;\n        for (i = _currentSlopeIndex; i < inflationSlopes.length; i++) {\n            Slope memory slope = inflationSlopes[i];\n            uint256 slopeStart = slope.start;\n            uint256 slopeEnd = slope.end;\n            uint256 rangeStart = last;\n            uint256 rangeEnd = block.timestamp;\n            if (rangeStart > slopeEnd) {\n                continue; // no duration possible in this slope\n            } \n            if (rangeEnd < slopeStart) {\n                continue; // no duration possible in this slope\n            } \n            if (rangeStart < slopeStart) {\n                rangeStart = slopeStart; // trim to slope edge\n            } \n            if (rangeEnd > slopeEnd) {\n                rangeEnd = slopeEnd; // trim to slope edge\n            } \n            uint256 duration = rangeEnd - rangeStart;\n            total += (duration * slope.ratePerDay) / 1 days;\n            if (i > _currentSlopeIndex && duration > 0) {\n                nextSlopeIndex = i; // We have moved into a new slope\n            }\n            if (slopeEnd < rangeEnd) {\n                break; // No future slope could match\n            } \n        }\n        return (total, nextSlopeIndex);\n    }\n\n    function setInflation(Slope[] memory slopes) external onlyGovernor {\n        // slope ends intentionally are overwritten\n        require(slopes.length <= MAX_KNEES, \"Rewards: Too many slopes\");\n        delete inflationSlopes; // Delete all before rebuilding\n        currentSlopeIndex = 0; // Reset\n        uint256 minSlopeStart = 0;\n        if (slopes.length == 0) {\n            return;\n        }\n        slopes[slopes.length - 1].end = type(uint64).max;\n        for (uint256 i = 0; i < slopes.length; i++) {\n            require(\n                slopes[i].ratePerDay <= MAX_INFLATION_PER_DAY,\n                \"Rewards: RatePerDay too high\"\n            );\n            require(\n                slopes[i].start > minSlopeStart,\n                \"Rewards: Start times must increase\"\n            );\n            if (i < slopes.length - 1) {\n                slopes[i].end = slopes[i + 1].start;\n            }\n            inflationSlopes.push(slopes[i]);\n            minSlopeStart = slopes[i].start;\n        }\n    }\n\n    function setRewardsTarget(address rewardsTarget_) external onlyGovernor {\n        rewardsTarget = rewardsTarget_; // Okay to be zero, just disables collecting rewards\n    }\n}"
    },
    {
      "filename": "contracts/RewardsSource.sol",
      "content": "pragma solidity 0.8.10;\nimport {ERC20Votes} from \"OpenZeppelin/openzeppelin-contracts@4.6.0/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport {ERC20Permit} from \"OpenZeppelin/openzeppelin-contracts@4.6.0/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport {ERC20} from \"OpenZeppelin/openzeppelin-contracts@4.6.0/contracts/token/ERC20/ERC20.sol\";\nimport {PRBMathUD60x18} from \"paulrberg/prb-math@2.5.0/contracts/PRBMathUD60x18.sol\";\nimport {Governable} from \"./Governable.sol\";\n\ninterface Mintable {\n    function mint(address to, uint256 amount) external;\n}\n\ncontract RewardsSource is Governable {\n    ERC20 public immutable ogv;\n    address public rewardsTarget; // Contract that receives rewards\n    uint256 public lastRewardTime; // Start of the time to calculate rewards over\n    uint256 private currentSlopeIndex = 0; // Allows us to start with the correct slope\n\n    struct Slope {\n        uint64 start; // uint64 = billions and billions of years\n        uint64 end; // Internal use only. By duplicating the start of the next slope, we can save a slot read\n        uint128 ratePerDay;\n    }\n    Slope[] public inflationSlopes;\n\n    uint256 constant MAX_KNEES = 48;\n    uint256 constant MAX_INFLATION_PER_DAY = (5 * 1e6 * 1e18);\n\n    constructor(address ogv_) {\n        require(ogv_ != address(0), \"Rewards: OGV must be set\");\n        ogv = ERC20(ogv_);\n        lastRewardTime = block.timestamp; // No possible rewards from before contract deployed\n    }\n\n    function collectRewards() external returns (uint256) {\n        require(msg.sender == rewardsTarget, \"Rewards: Not rewardsTarget\");\n        if (block.timestamp <= lastRewardTime) {\n            return 0;\n        }\n        (uint256 rewards, uint256 _nextSlopeIndex) = _calcRewards();\n        if (_nextSlopeIndex != 0) {\n            currentSlopeIndex = _nextSlopeIndex;\n        }\n        lastRewardTime = block.timestamp;\n        Mintable(address(ogv)).mint(rewardsTarget, rewards);\n        return rewards;\n    }\n\n    function previewRewards() external view returns (uint256) {\n        (uint256 rewards, ) = _calcRewards();\n        return rewards;\n    }\n\n    function _calcRewards() internal view returns (uint256, uint256) {\n        uint256 last = lastRewardTime;\n        if (last >= block.timestamp) {\n            return (0, currentSlopeIndex);\n        }\n        if (inflationSlopes.length == 0) {\n            return (0, 0); // Save a slot read by returning a zero constant\n        } \n        uint256 total = 0;\n        uint256 nextSlopeIndex = 0; // Zero means no change\n        uint256 _currentSlopeIndex = currentSlopeIndex;\n        uint256 i;\n        for (i = _currentSlopeIndex; i < inflationSlopes.length; i++) {\n            Slope memory slope = inflationSlopes[i];\n            uint256 slopeStart = slope.start;\n            uint256 slopeEnd = slope.end;\n            uint256 rangeStart = last;\n            uint256 rangeEnd = block.timestamp;\n            if (rangeStart > slopeEnd) {\n                continue; // no duration possible in this slope\n            } \n            if (rangeEnd < slopeStart) {\n                continue; // no duration possible in this slope\n            } \n            if (rangeStart < slopeStart) {\n                rangeStart = slopeStart; // trim to slope edge\n            } \n            if (rangeEnd > slopeEnd) {\n                rangeEnd = slopeEnd; // trim to slope edge\n            } \n            uint256 duration = rangeEnd - rangeStart;\n            total += (duration * slope.ratePerDay) / 1 days;\n            if (i > _currentSlopeIndex && duration > 0) {\n                nextSlopeIndex = i; // We have moved into a new slope\n            }\n            if (slopeEnd < rangeEnd) {\n                break; // No future slope could match\n            } \n        }\n        return (total, nextSlopeIndex);\n    }\n\n    function setInflation(Slope[] memory slopes) external onlyGovernor {\n        // slope ends intentionally are overwritten\n        require(slopes.length <= MAX_KNEES, \"Rewards: Too many slopes\");\n        delete inflationSlopes; // Delete all before rebuilding\n        currentSlopeIndex = 0; // Reset\n        uint256 minSlopeStart = 0;\n        if (slopes.length == 0) {\n            return;\n        }\n        slopes[slopes.length - 1].end = type(uint64).max;\n        for (uint256 i = 0; i < slopes.length; i++) {\n            require(\n                slopes[i].ratePerDay <= MAX_INFLATION_PER_DAY,\n                \"Rewards: RatePerDay too high\"\n            );\n            require(\n                slopes[i].start > minSlopeStart,\n                \"Rewards: Start times must increase\"\n            );\n            if (i < slopes.length - 1) {\n                slopes[i].end = slopes[i + 1].start;\n            }\n            inflationSlopes.push(slopes[i]);\n            minSlopeStart = slopes[i].start;\n        }\n    }\n\n    function setRewardsTarget(address rewardsTarget_) external onlyGovernor {\n        rewardsTarget = rewardsTarget_; // Okay to be zero, just disables collecting rewards\n    }\n}"
    },
    {
      "filename": "contracts/OgvStaking.sol",
      "content": "pragma solidity 0.8.10;\nimport {ERC20Votes} from \"OpenZeppelin/openzeppelin-contracts@4.6.0/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport {ERC20Permit} from \"OpenZeppelin/openzeppelin-contracts@4.6.0/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport {ERC20} from \"OpenZeppelin/openzeppelin-contracts@4.6.0/contracts/token/ERC20/ERC20.sol\";\nimport {PRBMathUD60x18} from \"paulrberg/prb-math@2.5.0/contracts/PRBMathUD60x18.sol\";\nimport {RewardsSource} from \"./RewardsSource.sol\";\n\ncontract OgvStaking is ERC20Votes {\n    // 1. Core Storage\n    uint256 public immutable epoch;\n\n    // 2. Staking and Lockup Storage\n    uint256 constant YEAR_BASE = 18e17;\n    struct Lockup {\n        uint128 amount;\n        uint128 end;\n        uint256 points;\n    }\n    mapping(address => Lockup[]) public lockups;\n\n    // 3. Reward Storage\n    ERC20 public immutable ogv;\n    RewardsSource public rewardsSource;\n    mapping(address => uint256) public rewardDebt;\n    uint256 public accRewardPerShare; // As of the start of the block\n\n    // Events\n    event Stake(\n        address indexed user,\n        uint256 lockupId,\n        uint256 amount,\n        uint256 end,\n        uint256 points\n    );\n    event Unstake(\n        address indexed user,\n        uint256 lockupId,\n        uint256 amount,\n        uint256 end,\n        uint256 points\n    );\n    event Reward(address indexed user, uint256 amount);\n\n    // 1. Core Functions\n\n    constructor(\n        address ogv_,\n        uint256 epoch_,\n        address rewardsSource_\n    ) ERC20(\"\", \"\") ERC20Permit(\"OGV Staking\") {\n        ogv = ERC20(ogv_);\n        epoch = epoch_;\n        rewardsSource = RewardsSource(rewardsSource_);\n    }\n\n    function name() public pure override returns (string memory) {\n        return \"OGVe\";\n    }\n\n    function symbol() public pure override returns (string memory) {\n        return \"Staked OGV\";\n    }\n\n    function transfer(address, uint256) public override returns (bool) {\n        revert(\"Staking: Transfers disabled\");\n    }\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public override returns (bool) {\n        revert(\"Staking: Transfers disabled\");\n    }\n\n    // 2. Staking and Lockup Functions\n\n    function stake(\n        uint256 amount,\n        uint256 duration,\n        address to\n    ) external {\n        if (to == address(0)) {\n            to = msg.sender;\n        }\n        require(amount <= type(uint128).max, \"Staking: Too much\");\n        require(amount > 0, \"Staking: Not enough\");\n        // duration checked inside previewPoints\n        (uint256 points, uint256 end) = previewPoints(amount, duration);\n        require(\n            points + totalSupply() <= type(uint192).max,\n            \"Staking: Max points exceeded\"\n        );\n        _collectRewards(to);\n        lockups[to].push(\n            Lockup({\n                amount: uint128(amount), // max checked in require above\n                end: uint128(end),\n                points: points\n            })\n        );\n        _mint(to, points);\n        rewardDebt[to] = (balanceOf(to) * accRewardPerShare) / 1e12;\n        ogv.transferFrom(msg.sender, address(this), amount); // Important that it's sender\n        emit Stake(to, lockups[to].length - 1, amount, end, points);\n    }\n\n    function unstake(uint256 lockupId, bool noRewards) external {\n        Lockup memory lockup = lockups[msg.sender][lockupId];\n        uint256 amount = lockup.amount;\n        uint256 end = lockup.end;\n        uint256 points = lockup.points;\n        require(block.timestamp >= end, \"Staking: End of lockup not reached\");\n        require(end != 0, \"Staking: Already unstaked this lockup\");\n        if (!noRewards) {\n            _collectRewards(msg.sender);\n        }\n        delete lockups[msg.sender][lockupId]; // Keeps empty in array, so indexes are stable\n        _burn(msg.sender, points);\n        rewardDebt[msg.sender] =\n            (balanceOf(msg.sender) * accRewardPerShare) /\n            1e12;\n        ogv.transfer(msg.sender, amount);\n        emit Unstake(msg.sender, lockupId, amount, end, points);\n    }\n\n    function extend(uint256 lockupId, uint256 duration) external {\n        // duration checked inside previewPoints\n        Lockup memory lockup = lockups[msg.sender][lockupId];\n        uint256 oldAmount = lockup.amount;\n        uint256 oldEnd = lockup.end;\n        uint256 oldPoints = lockup.points;\n        (uint256 newPoints, uint256 newEnd) = previewPoints(\n            oldAmount,\n            duration\n        );\n        require(newEnd > oldEnd, \"New lockup must be longer\");\n        lockup.end = uint128(newEnd);\n        lockup.points = newPoints;\n        lockups[msg.sender][lockupId] = lockup;\n        _mint(msg.sender, newPoints - oldPoints);\n        rewardDebt[msg.sender] =\n            (balanceOf(msg.sender) * accRewardPerShare) /\n            1e12;\n        emit Unstake(msg.sender, lockupId, oldAmount, oldEnd, oldPoints);\n        emit Stake(msg.sender, lockupId, oldAmount, newEnd, newPoints);\n    }\n\n    function previewPoints(uint256 amount, uint256 duration)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        require(duration >= 7 days, \"Staking: Too short\");\n        require(duration <= 1461 days, \"Staking: Too long\");\n        uint256 start = block.timestamp > epoch ? block.timestamp : epoch;\n        uint256 end = start + duration;\n        uint256 endYearpoc = ((end - epoch) * 1e18) / 365 days;\n        uint256 multiplier = PRBMathUD60x18.pow(YEAR_BASE, endYearpoc);\n        return ((amount * multiplier) / 1e18, end);\n    }\n\n    // 3. Reward functions\n\n    function collectRewards() external {\n        _collectRewards(msg.sender);\n        rewardDebt[msg.sender] =\n            (balanceOf(msg.sender) * accRewardPerShare) /\n            1e12;\n    }\n\n    function previewRewards(address user) external view returns (uint256) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            return 0; // No one has any points to even get rewards\n        }\n        uint256 _accRewardPerShare = accRewardPerShare;\n        _accRewardPerShare += (rewardsSource.previewRewards() * 1e12) / supply;\n        uint256 balance = balanceOf(user);\n        uint256 grossReward = (balance * _accRewardPerShare) / 1e12;\n        return grossReward - rewardDebt[user];\n    }\n\n    function _collectRewards(address user) internal {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            return; // Increasing accRewardPerShare would be meaningless.\n        }\n        accRewardPerShare += (rewardsSource.collectRewards() * 1e12) / supply;\n        uint256 balance = balanceOf(user);\n        if (balance == 0) {\n            return; // Do NOT move this check before `accRewardPerShare +=`\n        }\n        uint256 grossReward = (balance * accRewardPerShare) / 1e12;\n        uint256 netReward = grossReward - rewardDebt[user];\n        ogv.transfer(user, netReward);\n        emit Reward(user, netReward);\n    }\n}"
    }
  ]
}