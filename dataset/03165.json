{
  "Title": "Polygon bridger does not enforce chainId requirements",
  "Content": "The [`PolygonTokenBridger`](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/PolygonTokenBridger.sol#L30) contract’s primary functions are only intended to be called either on l1 *or* l2, but not both. In fact, calling the functions on the wrong chain could result in unexpected behavior and unnecessary confusion.\n\n\nIn the best case, the functions will simply revert if called from the wrong chain because they will attempt to interact with other contracts that do not exist on that chain. For example, calling the [`receive` function](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/PolygonTokenBridger.sol#L81) (by sending the contract some native asset) could trigger reverts on Polygon, but not on Ethereum, because there is a WETH contract at the `l1Weth` address on the latter but not the former.\n\n\nHowever, in the worst case, it is possible that such calls will *not* revert, but result in lost funds instead. For example, if a WETH-like contract was later deployed to the `l1Weth` address on Polygon, then the call would not revert. Instead, tokens would be sent to that contract and could remain stuck there.\n\n\nAlthough the inline documentation details which function should be called on which chain, consider having the functions in this contract actively enforce these requirements via limiting execution to the correct `block.chainid`.\n\n\n**Update**: *Fixed in [pull request #115](https://github.com/across-protocol/contracts-v2/pull/115) as of commit [`b80d7a5396d31662265bb28b61a1a3d09ed76760`](https://github.com/across-protocol/contracts-v2/pull/115/commits/b80d7a5396d31662265bb28b61a1a3d09ed76760) and [pull request #128](https://github.com/across-protocol/contracts-v2/pull/128) as of commit [`811ac20674d28189fd01297c05ce5b9e89f7a183`](https://github.com/across-protocol/contracts-v2/pull/128/commits/811ac20674d28189fd01297c05ce5b9e89f7a183).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/PolygonTokenBridger.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./Lockable.sol\";\nimport \"./interfaces/WETH9.sol\";\n\n// ERC20s (on polygon) compatible with polygon's bridge have a withdraw method.\ninterface PolygonIERC20 is IERC20 {\n    function withdraw(uint256 amount) external;\n}\n\ninterface MaticToken {\n    function withdraw(uint256 amount) external payable;\n}\n\n/**\n * @notice Contract deployed on Ethereum and Polygon to facilitate token transfers from Polygon to the HubPool and back.\n * @dev Because Polygon only allows withdrawals from a particular address to go to that same address on mainnet, we need to\n * have some sort of contract that can guarantee identical addresses on Polygon and Ethereum. This contract is intended\n * to be completely immutable, so it's guaranteed that the contract on each side is  configured identically as long as\n * it is created via create2. create2 is an alternative creation method that uses a different address determination\n * mechanism from normal create.\n * Normal create: address = hash(deployer_address, deployer_nonce)\n * create2:       address = hash(0xFF, sender, salt, bytecode)\n *  This ultimately allows create2 to generate deterministic addresses that don't depend on the transaction count of the\n * sender.\n */\ncontract PolygonTokenBridger is Lockable {\n    using SafeERC20 for PolygonIERC20;\n    using SafeERC20 for IERC20;\n\n    // Gas token for Polygon.\n    MaticToken public constant maticToken = MaticToken(0x0000000000000000000000000000000000001010);\n\n    // Should be set to HubPool on Ethereum, or unused on Polygon.\n    address public immutable destination;\n\n    // WETH contract on Ethereum.\n    WETH9 public immutable l1Weth;\n\n    /**\n     * @notice Constructs Token Bridger contract.\n     * @param _destination Where to send tokens to for this network.\n     * @param _l1Weth Ethereum WETH address.\n     */\n    constructor(address _destination, WETH9 _l1Weth) {\n        destination = _destination;\n        l1Weth = _l1Weth;\n    }\n\n    /**\n     * @notice Called by Polygon SpokePool to send tokens over bridge to contract with the same address as this.\n     * @param token Token to bridge.\n     * @param amount Amount to bridge.\n     * @param isMatic True if token is MATIC.\n     */\n    function send(\n        PolygonIERC20 token,\n        uint256 amount,\n        bool isMatic\n    ) public nonReentrant {\n        token.safeTransferFrom(msg.sender, address(this), amount);\n\n        // In the wMatic case, this unwraps. For other ERC20s, this is the burn/send action.\n        token.withdraw(amount);\n\n        // This takes the token that was withdrawn and calls withdraw on the \"native\" ERC20.\n        if (isMatic) maticToken.withdraw{ value: amount }(amount);\n    }\n\n    /**\n     * @notice Called by someone to send tokens to the destination, which should be set to the HubPool.\n     * @param token Token to send to destination.\n     */\n    function retrieve(IERC20 token) public nonReentrant {\n        token.safeTransfer(destination, token.balanceOf(address(this)));\n    }\n\n    receive() external payable {\n        // Note: this should only happen on the mainnet side where ETH is sent to the contract directly by the bridge.\n        if (functionCallStackOriginatesFromOutsideThisContract()) l1Weth.deposit{ value: address(this).balance }();\n    }\n}"
    },
    {
      "filename": "contracts/PolygonTokenBridger.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./Lockable.sol\";\nimport \"./interfaces/WETH9.sol\";\n\n// ERC20s (on polygon) compatible with polygon's bridge have a withdraw method.\ninterface PolygonIERC20 is IERC20 {\n    function withdraw(uint256 amount) external;\n}\n\ninterface MaticToken {\n    function withdraw(uint256 amount) external payable;\n}\n\n/**\n * @notice Contract deployed on Ethereum and Polygon to facilitate token transfers from Polygon to the HubPool and back.\n * @dev Because Polygon only allows withdrawals from a particular address to go to that same address on mainnet, we need to\n * have some sort of contract that can guarantee identical addresses on Polygon and Ethereum. This contract is intended\n * to be completely immutable, so it's guaranteed that the contract on each side is  configured identically as long as\n * it is created via create2. create2 is an alternative creation method that uses a different address determination\n * mechanism from normal create.\n * Normal create: address = hash(deployer_address, deployer_nonce)\n * create2:       address = hash(0xFF, sender, salt, bytecode)\n *  This ultimately allows create2 to generate deterministic addresses that don't depend on the transaction count of the\n * sender.\n */\ncontract PolygonTokenBridger is Lockable {\n    using SafeERC20 for PolygonIERC20;\n    using SafeERC20 for IERC20;\n\n    // Gas token for Polygon.\n    MaticToken public constant maticToken = MaticToken(0x0000000000000000000000000000000000001010);\n\n    // Should be set to HubPool on Ethereum, or unused on Polygon.\n    address public immutable destination;\n\n    // WETH contract on Ethereum.\n    WETH9 public immutable l1Weth;\n\n    /**\n     * @notice Constructs Token Bridger contract.\n     * @param _destination Where to send tokens to for this network.\n     * @param _l1Weth Ethereum WETH address.\n     */\n    constructor(address _destination, WETH9 _l1Weth) {\n        destination = _destination;\n        l1Weth = _l1Weth;\n    }\n\n    /**\n     * @notice Called by Polygon SpokePool to send tokens over bridge to contract with the same address as this.\n     * @param token Token to bridge.\n     * @param amount Amount to bridge.\n     * @param isMatic True if token is MATIC.\n     */\n    function send(\n        PolygonIERC20 token,\n        uint256 amount,\n        bool isMatic\n    ) public nonReentrant {\n        token.safeTransferFrom(msg.sender, address(this), amount);\n\n        // In the wMatic case, this unwraps. For other ERC20s, this is the burn/send action.\n        token.withdraw(amount);\n\n        // This takes the token that was withdrawn and calls withdraw on the \"native\" ERC20.\n        if (isMatic) maticToken.withdraw{ value: amount }(amount);\n    }\n\n    /**\n     * @notice Called by someone to send tokens to the destination, which should be set to the HubPool.\n     * @param token Token to send to destination.\n     */\n    function retrieve(IERC20 token) public nonReentrant {\n        token.safeTransfer(destination, token.balanceOf(address(this)));\n    }\n\n    receive() external payable {\n        // Note: this should only happen on the mainnet side where ETH is sent to the contract directly by the bridge.\n        if (functionCallStackOriginatesFromOutsideThisContract()) l1Weth.deposit{ value: address(this).balance }();\n    }\n}"
    }
  ]
}