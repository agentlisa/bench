{
  "Title": "[G-05] No need to `inherit` `ERC721` again",
  "Content": "\nSince `OwnableApprovableERC721` already inherits `ERC721`, there's no need to inherit `ERC721` again in `LiquidInfrastructureNFT` contract.\n\n```solidity\n20: abstract contract OwnableApprovableERC721 is Context, ERC721 {\n```\n\nAdditionally, removing the unnecessary import of `ERC721` above will streamline the code.\n\n```solidity\nFile : contracts/LiquidInfrastructureNFT.sol\n\n5:  import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\n...\n\n33: contract LiquidInfrastructureNFT is ERC721, OwnableApprovableERC721 {\n```\n\n[LiquidInfrastructureNFT.sol#L5C1-L33C70](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure/blob/main/liquid-infrastructure/contracts/LiquidInfrastructureNFT.sol#L5C1-L33C70)<br>\n[OwnableApprovableERC721.sol#L20](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure/blob/main/liquid-infrastructure/contracts/OwnableApprovableERC721.sol#L20)\n\n### Recommended Mitigation steps\n\n```diff\nFile : contracts/LiquidInfrastructureNFT.sol\n\n-5:  import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\n...\n\n-33: contract LiquidInfrastructureNFT is ERC721, OwnableApprovableERC721 {\n+33: contract LiquidInfrastructureNFT is  OwnableApprovableERC721 {\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-02-althea-liquid-infrastructure",
  "Code": [
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureNFT.sol",
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.12; // Force solidity compliance\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"./OwnableApprovableERC721.sol\";\n\n/**\n * @title Liquid Infrastructure NFT\n * @author Christian Borst <christian@althea.systems>\n *\n * @dev An NFT contract used to control a Liquid Infrastructure Account - a Cosmos Bank module account intrinsically connected to the EVM\n * through Althea's x/microtx module. On chains which are not Althea-L1 this is a standalone ERC721 which should receive revenue periodically,\n * and the protocol manager must ensure LiquidInfrastructureNFTs receive the revenue they are owed.\n *\n * A Liquid Infrastructure Account typically represents some form of infrastructure involved in an Althea pay-per-forward network\n * which frequently receives payments from peers on the network for performing an automated service (e.g. providing internet).\n * Each instance of this LiquidInfrastructureNFT contract represents one x/bank module account, the address of which is a part of\n * the ERC1155 URI.\n *\n * As the x/microtx module is used to conduct microtransactions (the payment layer for Althea networks), receiving accounts\n * will accrue Cosmos Coins and likely spend these same tokens to pay their upstream costs. If any such account is a Liquid\n * account (see x/microtx documentation), the x/microtx module will query this LiquidInfrastructureNFT's BalanceThresholds\n * values to determine how much of which tokens to leave in the x/bank account. All excess amounts will be converted\n * from Cosmos Coins to ERC20s and deposited here. The owner of the Liquid Account may later withdraw the balances\n * this NFT holds via the withdrawBalances() function.\n *\n * Occassionally devices and wallets can be lost, in which case the owner of this contract can call recoverAccount()\n * to begin a recovery process which will finish after the transaction completes. Asynchronously the x/microtx module\n * will ignore thresholds and transfer all of the Liquid Account's balances to this NFT, which may be withdrawn\n * normally with withdrawBalances().\n */\ncontract LiquidInfrastructureNFT is ERC721, OwnableApprovableERC721 {\n    event SuccessfulWithdrawal(address to, address[] erc20s, uint256[] amounts);\n    event TryRecover();\n    event SuccessfulRecovery(address[] erc20s, uint256[] amounts);\n    event ThresholdsChanged(address[] newErc20s, uint256[] newAmounts);\n\n    address[] private thresholdErc20s;\n    uint256[] private thresholdAmounts;\n\n    /**\n     * @notice This is the current version of the contract. Every update to the contract will introduce a new\n     * version, regardless of anticipated compatibility.\n     */\n    uint256 public constant Version = 1;\n\n    /**\n     * @notice This NFT holds only 1 token in it, which is the Account token. Its Id is `1`.\n     * This Id is used for access control via the onlyOwner/onlyOwnerOrApproved modifiers.\n     * See OwnableApprovableERC721 for more info.\n     */\n    uint256 public constant AccountId = 1;\n\n    /**\n     * Constructs the underlying ERC721 with a URI like \"althea://liquid-infrastructure-account/{accountName}\", and\n     * a symbol like \"LIA:{accountName}\".\n     * Mints the Account token (ID=1), the only token held in this NFT.\n     *\n     * @param accountName The bech32 address of the controlled x/bank account\n     */\n    constructor(\n        string memory accountName\n    )\n        ERC721(\n            string.concat(\n                \"althea://liquid-infrastructure-account/\",\n                accountName\n            ),\n            string.concat(\"LIA:\", accountName)\n        )\n    {\n        _mint(msg.sender, AccountId);\n    }\n\n    /**\n     * @dev Returns the current thresholds as a collection of ERC20 addresses and a collection of balance thresholds.\n     * These thresholds will be used by the x/microtx module to control the operating balances that the\n     * liquid account is allowed to hold. Anything in excess of these balances are transferred to this contract.\n     *\n     * @return address[]: The ERC20 balances to control\n     * @return uint256[]: The maximum operating amount of the associated ERC20\n     */\n    function getThresholds()\n        public\n        view\n        virtual\n        returns (address[] memory, uint256[] memory)\n    {\n        return (thresholdErc20s, thresholdAmounts);\n    }\n\n    /**\n     * @dev Updates the threshold values used by the x/microtx module which determine precisely how much\n     * of each token should be left in the Liquid Account's x/bank account.\n     *\n     * Any excess balances will accumulate here, and may be retrieved by the owner with\n     * the withdrawBalances(erc20s) method\n     *\n     * The ERC20s specified here have EVM addressses, querying the x/erc20 module will reveal their\n     * Cosmos Coin counterparts\n     *\n     * @param newErc20s The new threshold addresses to set\n     * @param newAmounts The new threshold amounts to set\n     *\n     * @notice this function is access controlled, only the owner or an approved msg.sender may call this function\n     */\n    function setThresholds(\n        address[] calldata newErc20s,\n        uint256[] calldata newAmounts\n    ) public virtual onlyOwnerOrApproved(AccountId) {\n        require(\n            newErc20s.length == newAmounts.length,\n            \"threshold values must have the same length\"\n        );\n        // Clear the thresholds before overwriting\n        delete thresholdErc20s;\n        delete thresholdAmounts;\n\n        for (uint i = 0; i < newErc20s.length; i++) {\n            thresholdErc20s.push(newErc20s[i]);\n            thresholdAmounts.push(newAmounts[i]);\n        }\n        emit ThresholdsChanged(newErc20s, newAmounts);\n    }\n\n    /**\n     * @dev Withdraws ERC20 balances from this contract to the owner, throws on any erc20 transfer() failure\n     * Emits a {SuccessfulWithdrawal} event upon success.\n     *\n     * @param erc20s A list of ERC20 tokens to withdraw NFT balances from\n     *\n     * @notice This function is access controlled, only the owner or an approved msg.sender may call this function\n     */\n    function withdrawBalances(address[] calldata erc20s) public virtual {\n        require(\n            _isApprovedOrOwner(_msgSender(), AccountId),\n            \"caller is not the owner of the Account token and is not approved either\"\n        );\n        address destination = ownerOf(AccountId);\n        _withdrawBalancesTo(erc20s, destination);\n    }\n\n    /**\n     * @dev Withdraws ERC20 balances from this contract to `destination`, throws on any erc20 transfer() failure\n     * Emits a {SuccessfulWithdrawal} event upon success.\n     *\n     * @param erc20s A list of ERC20 tokens to withdraw NFT balances from\n     * @param destination The address to send all the NFT's ERC20 balances to\n     *\n     * @notice This function is access controlled, only the owner or an approved msg.sender may call this function\n     */\n    function withdrawBalancesTo(\n        address[] calldata erc20s,\n        address destination\n    ) public virtual {\n        require(\n            _isApprovedOrOwner(_msgSender(), AccountId),\n            \"caller is not the owner of the Account token and is not approved either\"\n        );\n        _withdrawBalancesTo(erc20s, destination);\n    }\n\n    /**\n     * @dev Internal withdrawal used because withdrawBalances cannot call withdrawBalancesTo without error\n     *\n     * @param erc20s A list of ERC20 tokens to withdraw NFT balances from\n     * @param destination The address to send all the NFT's ERC20 balances to\n     */\n    function _withdrawBalancesTo(\n        address[] calldata erc20s,\n        address destination\n    ) internal {\n        uint256[] memory amounts = new uint256[](erc20s.length);\n        for (uint i = 0; i < erc20s.length; i++) {\n            address erc20 = erc20s[i];\n            uint256 balance = IERC20(erc20).balanceOf(address(this));\n            if (balance > 0) {\n                bool result = IERC20(erc20).transfer(destination, balance);\n                require(result, \"unsuccessful withdrawal\");\n                amounts[i] = balance;\n            }\n        }\n        emit SuccessfulWithdrawal(destination, erc20s, amounts);\n    }\n\n    /**\n     * @dev Begins the Liquid Infrastructure Account recovery process, which must be detected by the x/microtx module.\n     * Emits a {TryRecover} event which must be detected by the x/microtx module.\n     * Expected behavior is that all tokens held in the x/bank account of the Liquid Account will be\n     * converted to ERC20s and transferred to the control of this contract. If the recovery is successful\n     * then the x/microtx module will append a {SuccessfulRecovery} event with the ERC20 addresses and amounts\n     * sent to this contract.\n     *\n     * After a successful recovery, use withdrawBalances(erc20s) to send the token balances to the owner account.\n     *\n     * @notice Due to the EVM <> Cosmos interactions, the tokens will not be transferred to this contract until\n     * the entire transaction is resolved. It will not be possible to recoverAccount() and immediately withdrawBalances()\n     * in the same transaction!\n     *\n     * @notice This function is access controlled, only the owner may call this function\n     */\n    function recoverAccount() public virtual onlyOwner(AccountId) {\n        emit TryRecover();\n    }\n}"
    },
    {
      "filename": "liquid-infrastructure/contracts/OwnableApprovableERC721.sol",
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.12; // Force solidity compliance\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\n/**\n * An abstract contract which provides onlyOwner(id) and onlyOwnerOrApproved(id) modifiers derived from ERC721's\n * onwerOf, getApproved, and isApprovedForAll functions\n *\n * @dev For contracts with manually enumerated tokens (e.g. RockId = 1, PaperId = 2, ScissorsId = 3) use the modifiers like so:\n * ```\n *      // Only the owner of RockId gets to use this function, regardless of approval status\n *      function throwRock() public onlyOwner(RockId) { ... }\n *\n *      // Either the owner, a sender approved for all the tokens the owner of PaperId, or a sender approved for specifically PaperId gets to call this\n *      function wrapWithPaper() public onlyOwnerOrApproved(PaperId) { ... }\n * ```\n */\nabstract contract OwnableApprovableERC721 is Context, ERC721 {\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner(uint256 tokenId) {\n        require(\n            ERC721(this).ownerOf(tokenId) == _msgSender(),\n            \"OwnableApprovable: caller is not the owner\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner or someone approved by the owner\n     */\n    modifier onlyOwnerOrApproved(uint256 tokenId) {\n        // Get approval directly from ERC721's internal method\n        if (_isApprovedOrOwner(_msgSender(), tokenId)) {\n            _;\n        } else {\n            revert(\"OwnableApprovable: caller is not owner nor approved\");\n        }\n    }\n}"
    }
  ]
}