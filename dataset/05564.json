{
  "Title": "[L-03] Unused modifier",
  "Content": "https://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/EBTCToken.sol#L323\n\nThis modifier is not used in `EBTCTokem.sol`.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-badger",
  "Code": [
    {
      "filename": "packages/contracts/contracts/EBTCToken.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./Interfaces/IEBTCToken.sol\";\n\nimport \"./Dependencies/AuthNoOwner.sol\";\nimport \"./Dependencies/PermitNonce.sol\";\n\n/*\n *\n * Based upon OpenZeppelin's ERC20 contract:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol\n *\n * and their EIP2612 (ERC20Permit / ERC712) functionality:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/53516bc555a454862470e7860a9b5254db4d00f5/contracts/token/ERC20/ERC20Permit.sol\n *\n *\n * --- Functionality added specific to the EBTCToken ---\n *\n * 1) Transfer protection: blocklist of addresses that are invalid recipients (i.e. core Ebtc contracts) in external transfer() and transferFrom() calls.\n * The purpose is to protect users from losing tokens by mistakenly sending EBTC directly to a Liquity.\n * core contract, when they should rather call the right function.\n */\n\ncontract EBTCToken is IEBTCToken, AuthNoOwner, PermitNonce {\n    uint256 private _totalSupply;\n    string internal constant _NAME = \"EBTC Stablecoin\";\n    string internal constant _SYMBOL = \"EBTC\";\n    string internal constant _VERSION = \"1\";\n    uint8 internal constant _DECIMALS = 18;\n\n    // --- Data for EIP2612 ---\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant _PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    // keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    bytes32 private constant _TYPE_HASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n\n    // User data for EBTC token\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    // --- Addresses ---\n    address public immutable cdpManagerAddress;\n    address public immutable borrowerOperationsAddress;\n\n    /// @param _cdpManagerAddress Address of the CDP Manager\n    /// @param _borrowerOperationsAddress Address of the Borrower Operations\n    /// @param _authorityAddress Address of the authority for the contract\n    constructor(\n        address _cdpManagerAddress,\n        address _borrowerOperationsAddress,\n        address _authorityAddress\n    ) {\n        _initializeAuthority(_authorityAddress);\n\n        cdpManagerAddress = _cdpManagerAddress;\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n\n        bytes32 hashedName = keccak256(bytes(_NAME));\n        bytes32 hashedVersion = keccak256(bytes(_VERSION));\n\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = _chainID();\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(_TYPE_HASH, hashedName, hashedVersion);\n    }\n\n    /// @notice Mint new tokens\n    /// @dev Internal system function - only callable by BorrowerOperations or CDPManager\n    /// @dev Governance can also expand the list of approved minters to enable other systems to mint tokens\n    /// @param _account The address to receive the newly minted tokens\n    /// @param _amount The amount of tokens to mint\n    function mint(address _account, uint256 _amount) external override {\n        _requireCallerIsBOorCdpMOrAuth();\n        _mint(_account, _amount);\n    }\n\n    /// @notice Burn existing tokens\n    /// @dev Internal system function - only callable by BorrowerOperations or CDPManager\n    /// @dev Governance can also expand the list of approved burners to enable other systems to burn tokens\n    /// @param _account The address to burn tokens from\n    /// @param _amount The amount of tokens to burn\n    function burn(address _account, uint256 _amount) external override {\n        _requireCallerIsBOorCdpMOrAuth();\n        _burn(_account, _amount);\n    }\n\n    /// @notice Burn existing tokens from caller\n    /// @dev Internal system function - only callable by BorrowerOperations or CDPManager\n    /// @dev Governance can also expand the list of approved burners to enable other systems to burn tokens\n    /// @param _amount The amount of tokens to burn\n    function burn(uint256 _amount) external {\n        _requireCallerIsBOorCdpMOrAuth();\n        _burn(msg.sender, _amount);\n    }\n\n    // --- External functions ---\n\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\n        _requireValidRecipient(recipient);\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external override returns (bool) {\n        _requireValidRecipient(recipient);\n        _transfer(sender, recipient, amount);\n\n        uint256 cachedAllowance = _allowances[sender][msg.sender];\n        if (cachedAllowance != type(uint256).max) {\n            require(cachedAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n            unchecked {\n                _approve(sender, msg.sender, cachedAllowance - amount);\n            }\n        }\n        return true;\n    }\n\n    function increaseAllowance(\n        address spender,\n        uint256 addedValue\n    ) external override returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(\n        address spender,\n        uint256 subtractedValue\n    ) external override returns (bool) {\n        uint256 cachedAllowances = _allowances[msg.sender][spender];\n        require(cachedAllowances >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(msg.sender, spender, cachedAllowances - subtractedValue);\n        }\n        return true;\n    }\n\n    // --- EIP 2612 Functionality (https://eips.ethereum.org/EIPS/eip-2612) ---\n\n    /// @notice This function returns the domain separator for current chain\n    /// @return EIP712 compatible Domain definition\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return domainSeparator();\n    }\n\n    /// @notice This function returns the domain separator for current chain\n    /// @return EIP712 compatible Domain definition\n    function domainSeparator() public view override returns (bytes32) {\n        if (_chainID() == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    /// @notice This function approve given amount for specified owner and spender\n    /// @notice by verifying the validity of given deadline and signature parameters (v, r, s).\n    /// @param owner The token owner\n    /// @param spender The consumer to which owner want to grant approval\n    /// @param amount The token expenditure budget to be set\n    /// @param deadline The permit valid deadline\n    /// @param v The v part of signature from owner\n    /// @param r The r part of signature from owner\n    /// @param s The s part of signature from owner\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(deadline >= block.timestamp, \"EBTC: expired deadline\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator(),\n                keccak256(\n                    abi.encode(_PERMIT_TYPEHASH, owner, spender, amount, _nonces[owner]++, deadline)\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress == owner, \"EBTC: invalid signature\");\n        _approve(owner, spender, amount);\n    }\n\n    /// @dev Return current nonce for specified owner fOR EIP-2612 compatibility\n    /// @param owner The address whose nonce to be queried\n    function nonces(address owner) external view override(IERC2612, PermitNonce) returns (uint256) {\n        return _nonces[owner];\n    }\n\n    // --- Internal operations ---\n\n    function _chainID() private view returns (uint256) {\n        return block.chainid;\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 name,\n        bytes32 version\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, name, version, _chainID(), address(this)));\n    }\n\n    // --- Internal operations ---\n    // Warning: sanity checks (for sender and recipient) should have been done before calling these internal functions\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"EBTCToken: zero sender!\");\n        require(recipient != address(0), \"EBTCToken: zero recipient!\");\n\n        uint256 cachedSenderBalances = _balances[sender];\n        require(cachedSenderBalances >= amount, \"ERC20: transfer amount exceeds balance\");\n\n        unchecked {\n            // Safe because of the check above\n            _balances[sender] = cachedSenderBalances - amount;\n        }\n\n        _balances[recipient] = _balances[recipient] + amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"EBTCToken: mint to zero recipient!\");\n\n        _totalSupply = _totalSupply + amount;\n        _balances[account] = _balances[account] + amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"EBTCToken: burn from zero account!\");\n\n        uint256 cachedBalance = _balances[account];\n        require(cachedBalance >= amount, \"ERC20: burn amount exceeds balance\");\n\n        unchecked {\n            // Safe because of the check above\n            _balances[account] = cachedBalance - amount;\n        }\n\n        _totalSupply = _totalSupply - amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"EBTCToken: zero approve owner!\");\n        require(spender != address(0), \"EBTCToken: zero approve spender!\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireValidRecipient(address _recipient) internal view {\n        require(\n            _recipient != address(0) && _recipient != address(this),\n            \"EBTC: Cannot transfer tokens directly to the EBTC token contract or the zero address\"\n        );\n        require(\n            _recipient != cdpManagerAddress && _recipient != borrowerOperationsAddress,\n            \"EBTC: Cannot transfer tokens directly to the CdpManager or BorrowerOps\"\n        );\n    }\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress,\n            \"EBTCToken: Caller is not BorrowerOperations\"\n        );\n    }\n\n    /// @dev authority check last to short-circuit in the case of use by usual immutable addresses\n    function _requireCallerIsBOorCdpMOrAuth() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress ||\n                msg.sender == cdpManagerAddress ||\n                isAuthorized(msg.sender, msg.sig),\n            \"EBTC: Caller is neither BorrowerOperations nor CdpManager nor authorized\"\n        );\n    }\n\n    function _requireCallerIsCdpM() internal view {\n        require(msg.sender == cdpManagerAddress, \"EBTC: Caller is not CdpManager\");\n    }\n\n    // --- Optional functions ---\n\n    /// @notice Returns the name of the token\n    /// @return Name of the token\n    function name() external pure override returns (string memory) {\n        return _NAME;\n    }\n\n    /// @notice Returns the symbol of the token\n    /// @return Symbol of the token\n    function symbol() external pure override returns (string memory) {\n        return _SYMBOL;\n    }\n\n    /// @notice Returns the number of decimals used to represent token amounts\n    /// @return Number of decimals used by the token\n    function decimals() external pure override returns (uint8) {\n        return _DECIMALS;\n    }\n\n    /// @notice Returns the version of the token\n    /// @return Version of the token\n    function version() external pure override returns (string memory) {\n        return _VERSION;\n    }\n\n    /// @notice Returns the type hash used for permit() function as per EIP-2612\n    /// @return EIP-2612 permit type hash\n    function permitTypeHash() external pure override returns (bytes32) {\n        return _PERMIT_TYPEHASH;\n    }\n}"
    }
  ]
}