{
  "Title": "[G-05] State variables should be cached in stack variables rather than re-reading them from storage",
  "Content": "\nDeployment Gas Saved: **24 021**<br>\nMethod Call Gas Saved: **614**<br>\n\nSLOADs are expensive (100 gas after the 1st one) compared to MLOADs/MSTOREs (3 gas each). Storage values read multiple times should instead be cached in memory the first time (costing 1 SLOAD) and then read from this cache to avoid multiple SLOADs.\n\n*   src/policies/Heart.sol:[112-113](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Heart.sol#L112-L113)\n\n```solidity\n112        rewardToken.safeTransfer(to_, reward);\n113        emit RewardIssued(to_, reward);\n```\n\nfix:\n\n```solidity\n        uint256 reward = reward;\n        rewardToken.safeTransfer(to_, reward);\n        emit RewardIssued(to_, reward);\n```\n\n*   src/policies/BondCallback.sol:[68-75](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/BondCallback.sol#L68-L75)\n\n```solidity\n68         Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();\n69         Keycode MINTR_KEYCODE = MINTR.KEYCODE();\n70\n71         requests = new Permissions[](4);\n72         requests[0] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);\n73         requests[1] = Permissions(TRSRY_KEYCODE, TRSRY.withdrawReserves.selector);\n74         requests[2] = Permissions(MINTR_KEYCODE, MINTR.mintOhm.selector);\n75         requests[3] = Permissions(MINTR_KEYCODE, MINTR.burnOhm.selector);\n```\n\nfix(similar for other policies):\n\n```solidity\n    OlympusTreasury ltrsry = TRSRY;\n    OlympusMinter lmintr = MINTR;\n    Keycode TRSRY_KEYCODE = ltrsry.KEYCODE();\n    Keycode MINTR_KEYCODE = lmintr.KEYCODE();\n\n    requests = new Permissions[](4);\n\n    requests[0] = Permissions(TRSRY_KEYCODE, ltrsry.setApprovalFor.selector);\n    requests[1] = Permissions(TRSRY_KEYCODE, ltrsry.withdrawReserves.selector);\n    requests[2] = Permissions(MINTR_KEYCODE, lmintr.mintOhm.selector);\n    requests[3] = Permissions(MINTR_KEYCODE, lmintr.burnOhm.selector);\n```\n\n*   src/policies/Governance.sol:[77-79](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L77-L79)\n\n```solidity\n77         requests = new Permissions[](2);\n78         requests[0] = Permissions(INSTR.KEYCODE(), INSTR.store.selector);\n79         requests[1] = Permissions(VOTES.KEYCODE(), VOTES.transferFrom.selector);\n```\n\n*   src/policies/Operator.sol:[172-185](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L172-L185)\n\n```solidity\n172        Keycode RANGE_KEYCODE = RANGE.KEYCODE();\n173        Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();\n174        Keycode MINTR_KEYCODE = MINTR.KEYCODE();\n175\n176        requests = new Permissions[](9);\n177        requests[0] = Permissions(RANGE_KEYCODE, RANGE.updateCapacity.selector);\n178        requests[1] = Permissions(RANGE_KEYCODE, RANGE.updateMarket.selector);\n179        requests[2] = Permissions(RANGE_KEYCODE, RANGE.updatePrices.selector);\n180        requests[3] = Permissions(RANGE_KEYCODE, RANGE.regenerate.selector);\n181        requests[4] = Permissions(RANGE_KEYCODE, RANGE.setSpreads.selector);\n182        requests[5] = Permissions(RANGE_KEYCODE, RANGE.setThresholdFactor.selector);\n183        requests[6] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);\n184        requests[7] = Permissions(MINTR_KEYCODE, MINTR.mintOhm.selector);\n185        requests[8] = Permissions(MINTR_KEYCODE, MINTR.burnOhm.selector);\n```\n\n*   src/policies/PriceConfig.sol:[32-34](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/PriceConfig.sol#L32-L34)\n\n```solidity\n32        permissions[0] = Permissions(PRICE.KEYCODE(), PRICE.initialize.selector);\n33        permissions[1] = Permissions(PRICE.KEYCODE(), PRICE.changeMovingAverageDuration.selector);\n34        permissions[2] = Permissions(PRICE.KEYCODE(), PRICE.changeObservationFrequency.selector);\n```\n\n*   src/policies/TreasuryCustodian.sol:[35-39](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/TreasuryCustodian.sol#L35-L39)\n\n```solidity\n35        Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();\n36\n37        requests = new Permissions[](2);\n38        requests[0] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);\n39        requests[1] = Permissions(TRSRY_KEYCODE, TRSRY.setDebt.selector);\n```\n\n*   src/policies/VoterRegistration.sol:[33-35](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/VoterRegistration.sol#L34-L35)\n\n```solidity\n33        permissions = new Permissions[](2);\n34        permissions[0] = Permissions(VOTES.KEYCODE(), VOTES.mintTo.selector);\n35        permissions[1] = Permissions(VOTES.KEYCODE(), VOTES.burnFrom.selector);\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-08-olympus-dao-contest",
  "Code": [
    {
      "filename": "src/policies/Heart.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {IHeart} from \"policies/interfaces/IHeart.sol\";\nimport {IOperator} from \"policies/interfaces/IOperator.sol\";\n\nimport {OlympusPrice} from \"modules/PRICE.sol\";\n\nimport \"src/Kernel.sol\";\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n/// @title  Olympus Heart\n/// @notice Olympus Heart (Policy) Contract\n/// @dev    The Olympus Heart contract provides keeper rewards to call the heart beat function which fuels\n///         Olympus market operations. The Heart orchestrates state updates in the correct order to ensure\n///         market operations use up to date information.\ncontract OlympusHeart is IHeart, Policy, ReentrancyGuard {\n    using TransferHelper for ERC20;\n\n    error Heart_OutOfCycle();\n    error Heart_BeatStopped();\n    error Heart_InvalidParams();\n\n    event Beat(uint256 timestamp_);\n    event RewardIssued(address to_, uint256 rewardAmount_);\n    event RewardUpdated(ERC20 token_, uint256 rewardAmount_);\n\n    /// @notice Status of the Heart, false = stopped, true = beating\n    bool public active;\n\n    /// @notice Timestamp of the last beat (UTC, in seconds)\n    uint256 public lastBeat;\n\n    /// @notice Reward for beating the Heart (in reward token decimals)\n    uint256 public reward;\n\n    /// @notice Reward token address that users are sent for beating the Heart\n    ERC20 public rewardToken;\n\n    // Modules\n    OlympusPrice internal PRICE;\n\n    // Policies\n    IOperator internal _operator;\n\n    /*//////////////////////////////////////////////////////////////\n                            POLICY INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        Kernel kernel_,\n        IOperator operator_,\n        ERC20 rewardToken_,\n        uint256 reward_\n    ) Policy(kernel_) {\n        _operator = operator_;\n\n        active = true;\n        lastBeat = block.timestamp;\n        rewardToken = rewardToken_;\n        reward = reward_;\n    }\n\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](1);\n        dependencies[0] = toKeycode(\"PRICE\");\n\n        PRICE = OlympusPrice(getModuleAddress(dependencies[0]));\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions()\n        external\n        view\n        override\n        returns (Permissions[] memory permissions)\n    {\n        permissions = new Permissions[](1);\n        permissions[0] = Permissions(PRICE.KEYCODE(), PRICE.updateMovingAverage.selector);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IHeart\n    function beat() external nonReentrant {\n        if (!active) revert Heart_BeatStopped();\n        if (block.timestamp < lastBeat + frequency()) revert Heart_OutOfCycle();\n\n        // Update the moving average on the Price module\n        PRICE.updateMovingAverage();\n\n        // Trigger price range update and market operations\n        _operator.operate();\n\n        // Update the last beat timestamp\n        lastBeat += frequency();\n\n        // Issue reward to sender\n        _issueReward(msg.sender);\n\n        emit Beat(block.timestamp);\n    }\n\n    function _issueReward(address to_) internal {\n        rewardToken.safeTransfer(to_, reward);\n        emit RewardIssued(to_, reward);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IHeart\n    function frequency() public view returns (uint256) {\n        return uint256(PRICE.observationFrequency());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IHeart\n    function resetBeat() external onlyRole(\"heart_admin\") {\n        lastBeat = block.timestamp - frequency();\n    }\n\n    /// @inheritdoc IHeart\n    function toggleBeat() external onlyRole(\"heart_admin\") {\n        active = !active;\n    }\n\n    /// @inheritdoc IHeart\n    function setRewardTokenAndAmount(ERC20 token_, uint256 reward_)\n        external\n        onlyRole(\"heart_admin\")\n    {\n        rewardToken = token_;\n        reward = reward_;\n        emit RewardUpdated(token_, reward_);\n    }\n\n    /// @inheritdoc IHeart\n    function withdrawUnspentRewards(ERC20 token_) external onlyRole(\"heart_admin\") {\n        token_.safeTransfer(msg.sender, token_.balanceOf(address(this)));\n    }\n}"
    },
    {
      "filename": "src/policies/BondCallback.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {IBondCallback} from \"interfaces/IBondCallback.sol\";\nimport {IBondAggregator} from \"interfaces/IBondAggregator.sol\";\nimport {OlympusTreasury} from \"modules/TRSRY.sol\";\nimport {OlympusMinter} from \"modules/MINTR.sol\";\nimport {Operator} from \"policies/Operator.sol\";\nimport \"src/Kernel.sol\";\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\n\n/// @title Olympus Bond Callback\ncontract BondCallback is Policy, ReentrancyGuard, IBondCallback {\n    using TransferHelper for ERC20;\n\n    error Callback_MarketNotSupported(uint256 id);\n    error Callback_TokensNotReceived();\n    error Callback_InvalidParams();\n\n    mapping(address => mapping(uint256 => bool)) public approvedMarkets;\n    mapping(uint256 => uint256[2]) internal _amountsPerMarket;\n    mapping(ERC20 => uint256) public priorBalances;\n\n    IBondAggregator public aggregator;\n    OlympusTreasury public TRSRY;\n    OlympusMinter public MINTR;\n    Operator public operator;\n    ERC20 public ohm;\n\n    /*//////////////////////////////////////////////////////////////\n                            POLICY INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        Kernel kernel_,\n        IBondAggregator aggregator_,\n        ERC20 ohm_\n    ) Policy(kernel_) {\n        aggregator = aggregator_;\n        ohm = ohm_;\n    }\n\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](2);\n        dependencies[0] = toKeycode(\"TRSRY\");\n        dependencies[1] = toKeycode(\"MINTR\");\n\n        TRSRY = OlympusTreasury(getModuleAddress(dependencies[0]));\n        MINTR = OlympusMinter(getModuleAddress(dependencies[1]));\n\n        // Approve MINTR for burning OHM (called here so that it is re-approved on updates)\n        ohm.safeApprove(address(MINTR), type(uint256).max);\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();\n        Keycode MINTR_KEYCODE = MINTR.KEYCODE();\n\n        requests = new Permissions[](4);\n        requests[0] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);\n        requests[1] = Permissions(TRSRY_KEYCODE, TRSRY.withdrawReserves.selector);\n        requests[2] = Permissions(MINTR_KEYCODE, MINTR.mintOhm.selector);\n        requests[3] = Permissions(MINTR_KEYCODE, MINTR.burnOhm.selector);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBondCallback\n    function whitelist(address teller_, uint256 id_)\n        external\n        override\n        onlyRole(\"callback_whitelist\")\n    {\n        approvedMarkets[teller_][id_] = true;\n\n        // Get payout tokens for market\n        (, , ERC20 payoutToken, , , ) = aggregator.getAuctioneer(id_).getMarketInfoForPurchase(id_);\n\n        /// If payout token is not OHM, request approval from TRSRY for withdrawals\n        if (address(payoutToken) != address(ohm)) {\n            TRSRY.setApprovalFor(address(this), payoutToken, type(uint256).max);\n        }\n    }\n\n    /// @inheritdoc IBondCallback\n    function callback(\n        uint256 id_,\n        uint256 inputAmount_,\n        uint256 outputAmount_\n    ) external override nonReentrant {\n        /// Confirm that the teller and market id are whitelisted\n        if (!approvedMarkets[msg.sender][id_]) revert Callback_MarketNotSupported(id_);\n\n        // Get tokens for market\n        (, , ERC20 payoutToken, ERC20 quoteToken, , ) = aggregator\n            .getAuctioneer(id_)\n            .getMarketInfoForPurchase(id_);\n\n        // Check that quoteTokens were transferred prior to the call\n        if (quoteToken.balanceOf(address(this)) < priorBalances[quoteToken] + inputAmount_)\n            revert Callback_TokensNotReceived();\n\n        // Handle payout\n        if (quoteToken == payoutToken && quoteToken == ohm) {\n            // If OHM-OHM bond, only mint the difference and transfer back to teller\n            uint256 toMint = outputAmount_ - inputAmount_;\n            MINTR.mintOhm(address(this), toMint);\n\n            // Transfer payoutTokens to sender\n            payoutToken.safeTransfer(msg.sender, outputAmount_);\n        } else if (quoteToken == ohm) {\n            // If inverse bond (buying ohm), transfer payout tokens to sender\n            TRSRY.withdrawReserves(msg.sender, payoutToken, outputAmount_);\n\n            // Burn OHM received from sender\n            MINTR.burnOhm(address(this), inputAmount_);\n        } else if (payoutToken == ohm) {\n            // Else (selling ohm), mint OHM to sender\n            MINTR.mintOhm(msg.sender, outputAmount_);\n        } else {\n            // Revert since this callback only handles OHM bonds\n            revert Callback_MarketNotSupported(id_);\n        }\n\n        // Store amounts in/out.\n        // Updated after internal call so previous balances are available to check against\n        priorBalances[quoteToken] = quoteToken.balanceOf(address(this));\n        priorBalances[payoutToken] = payoutToken.balanceOf(address(this));\n        _amountsPerMarket[id_][0] += inputAmount_;\n        _amountsPerMarket[id_][1] += outputAmount_;\n\n        // Check if the market is deployed by range operator and update capacity if so\n        operator.bondPurchase(id_, outputAmount_);\n    }\n\n    /// @notice Send tokens to the TRSRY in a batch\n    /// @param  tokens_ - Array of tokens to send\n    function batchToTreasury(ERC20[] memory tokens_) external onlyRole(\"callback_admin\") {\n        ERC20 token;\n        uint256 balance;\n        uint256 len = tokens_.length;\n        for (uint256 i; i < len; ) {\n            token = tokens_[i];\n            balance = token.balanceOf(address(this));\n            token.safeTransfer(address(TRSRY), balance);\n            priorBalances[token] = token.balanceOf(address(this));\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBondCallback\n    function amountsForMarket(uint256 id_)\n        external\n        view\n        override\n        returns (uint256 in_, uint256 out_)\n    {\n        uint256[2] memory marketAmounts = _amountsPerMarket[id_];\n        return (marketAmounts[0], marketAmounts[1]);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Sets the operator contract for the callback to use to report bond purchases\n    /// @notice Must be set before the callback is used\n    /// @param  operator_ - Address of the Operator contract\n    function setOperator(Operator operator_) external onlyRole(\"callback_admin\") {\n        if (address(operator_) == address(0)) revert Callback_InvalidParams();\n        operator = operator_;\n    }\n}"
    },
    {
      "filename": "src/policies/Governance.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// The Governance Policy submits & activates instructions in a INSTR module\n\nimport {OlympusInstructions} from \"modules/INSTR.sol\";\nimport {OlympusVotes} from \"modules/VOTES.sol\";\nimport \"src/Kernel.sol\";\n\n// proposing\nerror NotEnoughVotesToPropose();\n\n// endorsing\nerror CannotEndorseNullProposal();\nerror CannotEndorseInvalidProposal();\n\n// activating\nerror NotAuthorizedToActivateProposal();\nerror NotEnoughEndorsementsToActivateProposal();\nerror ProposalAlreadyActivated();\nerror ActiveProposalNotExpired();\nerror SubmittedProposalHasExpired();\n\n// voting\nerror NoActiveProposalDetected();\nerror UserAlreadyVoted();\n\n// executing\nerror NotEnoughVotesToExecute();\nerror ExecutionTimelockStillActive();\n\n// claiming\nerror VotingTokensAlreadyReclaimed();\nerror CannotReclaimTokensForActiveVote();\nerror CannotReclaimZeroVotes();\n\nstruct ProposalMetadata {\n    bytes32 title;\n    address submitter;\n    uint256 submissionTimestamp;\n    string proposalURI;\n}\n\nstruct ActivatedProposal {\n    uint256 proposalId;\n    uint256 activationTimestamp;\n}\n\n/// @notice OlympusGovernance\n/// @dev The Governor Policy is also the Kernel's Executor.\ncontract OlympusGovernance is Policy {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    OlympusInstructions public INSTR;\n    OlympusVotes public VOTES;\n\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](2);\n        dependencies[0] = toKeycode(\"INSTR\");\n        dependencies[1] = toKeycode(\"VOTES\");\n\n        INSTR = OlympusInstructions(getModuleAddress(dependencies[0]));\n        VOTES = OlympusVotes(getModuleAddress(dependencies[1]));\n    }\n\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](2);\n        requests[0] = Permissions(INSTR.KEYCODE(), INSTR.store.selector);\n        requests[1] = Permissions(VOTES.KEYCODE(), VOTES.transferFrom.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                             Policy Variables                                //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    event ProposalSubmitted(uint256 proposalId);\n    event ProposalEndorsed(uint256 proposalId, address voter, uint256 amount);\n    event ProposalActivated(uint256 proposalId, uint256 timestamp);\n    event WalletVoted(uint256 proposalId, address voter, bool for_, uint256 userVotes);\n    event ProposalExecuted(uint256 proposalId);\n\n    /// @notice The currently activated proposal in the governance system.\n    ActivatedProposal public activeProposal;\n\n    /// @notice Return a proposal metadata object for a given proposal id.\n    mapping(uint256 => ProposalMetadata) public getProposalMetadata;\n\n    /// @notice Return the total endorsements for a proposal id.\n    mapping(uint256 => uint256) public totalEndorsementsForProposal;\n\n    /// @notice Return the number of endorsements a user has given a proposal id.\n    mapping(uint256 => mapping(address => uint256)) public userEndorsementsForProposal;\n\n    /// @notice Return whether a proposal id has been activated. Once this is true, it should never be flipped false.\n    mapping(uint256 => bool) public proposalHasBeenActivated;\n\n    /// @notice Return the total yes votes for a proposal id used in calculating net votes.\n    mapping(uint256 => uint256) public yesVotesForProposal;\n\n    /// @notice Return the total no votes for a proposal id used in calculating net votes.\n    mapping(uint256 => uint256) public noVotesForProposal;\n\n    /// @notice Return the amount of votes a user has applied to a proposal id. This does not record how the user voted.\n    mapping(uint256 => mapping(address => uint256)) public userVotesForProposal;\n\n    /// @notice Return the amount of tokens reclaimed by a user after voting on a proposal id.\n    mapping(uint256 => mapping(address => bool)) public tokenClaimsForProposal;\n\n    /// @notice The amount of votes a proposer needs in order to submit a proposal as a percentage of total supply (in basis points).\n    /// @dev    This is set to 1% of the total supply.\n    uint256 public constant SUBMISSION_REQUIREMENT = 100;\n\n    /// @notice Amount of time a submitted proposal has to activate before it expires.\n    uint256 public constant ACTIVATION_DEADLINE = 2 weeks;\n\n    /// @notice Amount of time an activated proposal must stay up before it can be replaced by a new activated proposal.\n    uint256 public constant GRACE_PERIOD = 1 weeks;\n\n    /// @notice Endorsements required to activate a proposal as percentage of total supply.\n    uint256 public constant ENDORSEMENT_THRESHOLD = 20;\n\n    /// @notice Net votes required to execute a proposal on chain as a percentage of total supply.\n    uint256 public constant EXECUTION_THRESHOLD = 33;\n\n    /// @notice Required time for a proposal to be active before it can be executed.\n    /// @dev    This amount should be greater than 0 to prevent flash loan attacks.\n    uint256 public constant EXECUTION_TIMELOCK = 3 days;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                               User Actions                                  //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Return the metadata for a proposal.\n    /// @dev    Used to return & access the entire metadata struct in solidity\n    function getMetadata(uint256 proposalId_) public view returns (ProposalMetadata memory) {\n        return getProposalMetadata[proposalId_];\n    }\n\n    /// @notice Return the currently active proposal in governance.\n    /// @dev    Used to return & access the entire struct active proposal struct in solidity.\n    function getActiveProposal() public view returns (ActivatedProposal memory) {\n        return activeProposal;\n    }\n\n    /// @notice Submit an on chain governance proposal.\n    /// @param  instructions_ - an array of Instruction objects each containing a Kernel Action and a target Contract address.\n    /// @param  title_ - a human-readable title of the proposal â€” i.e. \"OIP XX - My Proposal Title\".\n    /// @param  proposalURI_ - an arbitrary url linking to a human-readable description of the proposal - i.e. Snapshot, Discourse, Google Doc.\n    function submitProposal(\n        Instruction[] calldata instructions_,\n        bytes32 title_,\n        string memory proposalURI_\n    ) external {\n        if (VOTES.balanceOf(msg.sender) * 10000 < VOTES.totalSupply() * SUBMISSION_REQUIREMENT)\n            revert NotEnoughVotesToPropose();\n\n        uint256 proposalId = INSTR.store(instructions_);\n        getProposalMetadata[proposalId] = ProposalMetadata(\n            title_,\n            msg.sender,\n            block.timestamp,\n            proposalURI_\n        );\n\n        emit ProposalSubmitted(proposalId);\n    }\n\n    /// @notice Endorse a proposal.\n    /// @param  proposalId_ - The ID of the proposal being endorsed.\n    function endorseProposal(uint256 proposalId_) external {\n        uint256 userVotes = VOTES.balanceOf(msg.sender);\n\n        if (proposalId_ == 0) {\n            revert CannotEndorseNullProposal();\n        }\n\n        Instruction[] memory instructions = INSTR.getInstructions(proposalId_);\n        if (instructions.length == 0) {\n            revert CannotEndorseInvalidProposal();\n        }\n\n        // undo any previous endorsement the user made on these instructions\n        uint256 previousEndorsement = userEndorsementsForProposal[proposalId_][msg.sender];\n        totalEndorsementsForProposal[proposalId_] -= previousEndorsement;\n\n        // reapply user endorsements with most up-to-date votes\n        userEndorsementsForProposal[proposalId_][msg.sender] = userVotes;\n        totalEndorsementsForProposal[proposalId_] += userVotes;\n\n        emit ProposalEndorsed(proposalId_, msg.sender, userVotes);\n    }\n\n    /// @notice Activate a proposal.\n    /// @param  proposalId_ - The ID of the proposal being activated.\n    function activateProposal(uint256 proposalId_) external {\n        ProposalMetadata memory proposal = getProposalMetadata[proposalId_];\n\n        if (msg.sender != proposal.submitter) {\n            revert NotAuthorizedToActivateProposal();\n        }\n\n        if (block.timestamp > proposal.submissionTimestamp + ACTIVATION_DEADLINE) {\n            revert SubmittedProposalHasExpired();\n        }\n\n        if (\n            (totalEndorsementsForProposal[proposalId_] * 100) <\n            VOTES.totalSupply() * ENDORSEMENT_THRESHOLD\n        ) {\n            revert NotEnoughEndorsementsToActivateProposal();\n        }\n\n        if (proposalHasBeenActivated[proposalId_] == true) {\n            revert ProposalAlreadyActivated();\n        }\n\n        if (block.timestamp < activeProposal.activationTimestamp + GRACE_PERIOD) {\n            revert ActiveProposalNotExpired();\n        }\n\n        activeProposal = ActivatedProposal(proposalId_, block.timestamp);\n\n        proposalHasBeenActivated[proposalId_] = true;\n\n        emit ProposalActivated(proposalId_, block.timestamp);\n    }\n\n    /// @notice Cast a vote for the currently active proposal.\n    /// @param  for_ - A boolean representing the vote: true for yes, false for no.\n    function vote(bool for_) external {\n        uint256 userVotes = VOTES.balanceOf(msg.sender);\n\n        if (activeProposal.proposalId == 0) {\n            revert NoActiveProposalDetected();\n        }\n\n        if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) {\n            revert UserAlreadyVoted();\n        }\n\n        if (for_) {\n            yesVotesForProposal[activeProposal.proposalId] += userVotes;\n        } else {\n            noVotesForProposal[activeProposal.proposalId] += userVotes;\n        }\n\n        userVotesForProposal[activeProposal.proposalId][msg.sender] = userVotes;\n\n        VOTES.transferFrom(msg.sender, address(this), userVotes);\n\n        emit WalletVoted(activeProposal.proposalId, msg.sender, for_, userVotes);\n    }\n\n    /// @notice Execute the currently active proposal.\n    function executeProposal() external {\n        uint256 netVotes = yesVotesForProposal[activeProposal.proposalId] -\n            noVotesForProposal[activeProposal.proposalId];\n        if (netVotes * 100 < VOTES.totalSupply() * EXECUTION_THRESHOLD) {\n            revert NotEnoughVotesToExecute();\n        }\n\n        if (block.timestamp < activeProposal.activationTimestamp + EXECUTION_TIMELOCK) {\n            revert ExecutionTimelockStillActive();\n        }\n\n        Instruction[] memory instructions = INSTR.getInstructions(activeProposal.proposalId);\n\n        for (uint256 step; step < instructions.length; ) {\n            kernel.executeAction(instructions[step].action, instructions[step].target);\n            unchecked {\n                ++step;\n            }\n        }\n\n        emit ProposalExecuted(activeProposal.proposalId);\n\n        // deactivate the active proposal\n        activeProposal = ActivatedProposal(0, 0);\n    }\n\n    /// @notice Reclaim locked votes from the contract after the proposal is no longer active.\n    /// @dev    The governance contract locks casted votes into the contract until the proposal\n    ///         is no longer active to prevent repeated voting with the same tokens.\n    /// @param  proposalId_ - The proposal that the user is reclaiming tokens for.\n    function reclaimVotes(uint256 proposalId_) external {\n        uint256 userVotes = userVotesForProposal[proposalId_][msg.sender];\n\n        if (userVotes == 0) {\n            revert CannotReclaimZeroVotes();\n        }\n\n        if (proposalId_ == activeProposal.proposalId) {\n            revert CannotReclaimTokensForActiveVote();\n        }\n\n        if (tokenClaimsForProposal[proposalId_][msg.sender] == true) {\n            revert VotingTokensAlreadyReclaimed();\n        }\n\n        tokenClaimsForProposal[proposalId_][msg.sender] = true;\n\n        VOTES.transferFrom(address(this), msg.sender, userVotes);\n    }\n}"
    },
    {
      "filename": "src/policies/Operator.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IOperator} from \"policies/interfaces/IOperator.sol\";\nimport {IBondAuctioneer} from \"interfaces/IBondAuctioneer.sol\";\nimport {IBondCallback} from \"interfaces/IBondCallback.sol\";\n\nimport {OlympusTreasury} from \"modules/TRSRY.sol\";\nimport {OlympusMinter} from \"modules/MINTR.sol\";\nimport {OlympusPrice} from \"modules/PRICE.sol\";\nimport {OlympusRange} from \"modules/RANGE.sol\";\n\nimport \"src/Kernel.sol\";\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\nimport {FullMath} from \"libraries/FullMath.sol\";\n\n/// @title  Olympus Range Operator\n/// @notice Olympus Range Operator (Policy) Contract\n/// @dev    The Olympus Range Operator performs market operations to enforce OlympusDAO's OHM price range\n///         guidance policies against a specific reserve asset. The Operator is maintained by a keeper-triggered\n///         function on the Olympus Heart contract, which orchestrates state updates in the correct order to ensure\n///         market operations use up to date information. When the price of OHM against the reserve asset exceeds\n///         the cushion spread, the Operator deploys bond markets to support the price. The Operator also offers\n///         zero slippage swaps at prices dictated by the wall spread from the moving average. These market operations\n///         are performed up to a specific capacity before the market must stabilize to regenerate the capacity.\ncontract Operator is IOperator, Policy, ReentrancyGuard {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    /* ========== ERRORS =========== */\n\n    error Operator_InvalidParams();\n    error Operator_InsufficientCapacity();\n    error Operator_AmountLessThanMinimum(uint256 amountOut, uint256 minAmountOut);\n    error Operator_WallDown();\n    error Operator_AlreadyInitialized();\n    error Operator_NotInitialized();\n    error Operator_Inactive();\n\n    /* ========== EVENTS =========== */\n    event Swap(\n        ERC20 indexed tokenIn_,\n        ERC20 indexed tokenOut_,\n        uint256 amountIn_,\n        uint256 amountOut_\n    );\n    event CushionFactorChanged(uint32 cushionFactor_);\n    event CushionParamsChanged(uint32 duration_, uint32 debtBuffer_, uint32 depositInterval_);\n    event ReserveFactorChanged(uint32 reserveFactor_);\n    event RegenParamsChanged(uint32 wait_, uint32 threshold_, uint32 observe_);\n\n    /* ========== STATE VARIABLES ========== */\n\n    /// Operator variables, defined in the interface on the external getter functions\n    Status internal _status;\n    Config internal _config;\n\n    /// @notice    Whether the Operator has been initialized\n    bool public initialized;\n\n    /// @notice    Whether the Operator is active\n    bool public active;\n\n    /// Modules\n    OlympusPrice internal PRICE;\n    OlympusRange internal RANGE;\n    OlympusTreasury internal TRSRY;\n    OlympusMinter internal MINTR;\n\n    /// External contracts\n    /// @notice     Auctioneer contract used for cushion bond market deployments\n    IBondAuctioneer public auctioneer;\n    /// @notice     Callback contract used for cushion bond market payouts\n    IBondCallback public callback;\n\n    /// Tokens\n    /// @notice     OHM token contract\n    ERC20 public immutable ohm;\n    uint8 public immutable ohmDecimals;\n    /// @notice     Reserve token contract\n    ERC20 public immutable reserve;\n    uint8 public immutable reserveDecimals;\n\n    /// Constants\n    uint32 public constant FACTOR_SCALE = 1e4;\n\n    /* ========== CONSTRUCTOR ========== */\n    constructor(\n        Kernel kernel_,\n        IBondAuctioneer auctioneer_,\n        IBondCallback callback_,\n        ERC20[2] memory tokens_, // [ohm, reserve]\n        uint32[8] memory configParams // [cushionFactor, cushionDuration, cushionDebtBuffer, cushionDepositInterval, reserveFactor, regenWait, regenThreshold, regenObserve]\n    ) Policy(kernel_) {\n        /// Check params are valid\n        if (address(auctioneer_) == address(0) || address(callback_) == address(0))\n            revert Operator_InvalidParams();\n\n        if (configParams[1] > uint256(7 days) || configParams[1] < uint256(1 days))\n            revert Operator_InvalidParams();\n\n        if (configParams[2] < uint32(10_000)) revert Operator_InvalidParams();\n\n        if (configParams[3] < uint32(1 hours) || configParams[3] > configParams[1])\n            revert Operator_InvalidParams();\n\n        if (configParams[4] > 10000 || configParams[4] < 100) revert Operator_InvalidParams();\n\n        if (\n            configParams[5] < 1 hours ||\n            configParams[6] > configParams[7] ||\n            configParams[7] == uint32(0)\n        ) revert Operator_InvalidParams();\n\n        auctioneer = auctioneer_;\n        callback = callback_;\n        ohm = tokens_[0];\n        ohmDecimals = tokens_[0].decimals();\n        reserve = tokens_[1];\n        reserveDecimals = tokens_[1].decimals();\n\n        Regen memory regen = Regen({\n            count: uint32(0),\n            lastRegen: uint48(block.timestamp),\n            nextObservation: uint32(0),\n            observations: new bool[](configParams[7])\n        });\n\n        _config = Config({\n            cushionFactor: configParams[0],\n            cushionDuration: configParams[1],\n            cushionDebtBuffer: configParams[2],\n            cushionDepositInterval: configParams[3],\n            reserveFactor: configParams[4],\n            regenWait: configParams[5],\n            regenThreshold: configParams[6],\n            regenObserve: configParams[7]\n        });\n\n        _status = Status({low: regen, high: regen});\n\n        emit CushionFactorChanged(configParams[0]);\n        emit CushionParamsChanged(configParams[1], configParams[2], configParams[3]);\n        emit ReserveFactorChanged(configParams[4]);\n        emit RegenParamsChanged(configParams[5], configParams[6], configParams[7]);\n    }\n\n    /* ========== FRAMEWORK CONFIGURATION ========== */\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](4);\n        dependencies[0] = toKeycode(\"PRICE\");\n        dependencies[1] = toKeycode(\"RANGE\");\n        dependencies[2] = toKeycode(\"TRSRY\");\n        dependencies[3] = toKeycode(\"MINTR\");\n\n        PRICE = OlympusPrice(getModuleAddress(dependencies[0]));\n        RANGE = OlympusRange(getModuleAddress(dependencies[1]));\n        TRSRY = OlympusTreasury(getModuleAddress(dependencies[2]));\n        MINTR = OlympusMinter(getModuleAddress(dependencies[3]));\n\n        /// Approve MINTR for burning OHM (called here so that it is re-approved on updates)\n        ohm.safeApprove(address(MINTR), type(uint256).max);\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions() external view override returns (Permissions[] memory requests) {\n        Keycode RANGE_KEYCODE = RANGE.KEYCODE();\n        Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();\n        Keycode MINTR_KEYCODE = MINTR.KEYCODE();\n\n        requests = new Permissions[](9);\n        requests[0] = Permissions(RANGE_KEYCODE, RANGE.updateCapacity.selector);\n        requests[1] = Permissions(RANGE_KEYCODE, RANGE.updateMarket.selector);\n        requests[2] = Permissions(RANGE_KEYCODE, RANGE.updatePrices.selector);\n        requests[3] = Permissions(RANGE_KEYCODE, RANGE.regenerate.selector);\n        requests[4] = Permissions(RANGE_KEYCODE, RANGE.setSpreads.selector);\n        requests[5] = Permissions(RANGE_KEYCODE, RANGE.setThresholdFactor.selector);\n        requests[6] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);\n        requests[7] = Permissions(MINTR_KEYCODE, MINTR.mintOhm.selector);\n        requests[8] = Permissions(MINTR_KEYCODE, MINTR.burnOhm.selector);\n    }\n\n    modifier onlyWhileActive() {\n        if (!active) revert Operator_Inactive();\n        _;\n    }\n\n    /* ========== HEART FUNCTIONS ========== */\n    /// @inheritdoc IOperator\n    function operate() external over"
    }
  ]
}