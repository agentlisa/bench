{
  "Title": "[04] Protocol might overvalue the asset transferred in by a user and unintentionally flaw their accounting logic",
  "Content": "\nFirst would be key to note that protocol is to support different types of ERC20, which include tokens that apply fee whenever being transferred, this can be seen from the _### ERC20 token behaviours in scope_ section of the audit's README [here](https://github.com/code-423n4/2024-04-dyad/blob/4a987e536576139793a1c04690336d06c93fca90/README.md#L155).\n\nhttps://github.com/code-423n4/2024-04-dyad/blob/4a987e536576139793a1c04690336d06c93fca90/src/core/VaultManagerV2.sol#L122-L134\n\n```solidity\n  function deposit(\n    uint    id,\n    address vault,\n    uint    amount\n  )\n    external\n      isValidDNft(id)\n  {\n    idToBlockOfLastDeposit[id] = block.number;\n    Vault _vault = Vault(vault);\n    _vault.asset().safeTransferFrom(msg.sender, address(vault), amount);\n    _vault.deposit(id, amount);\n  }\n```\n\nThis function allows a `dNFT` owner to deposit collateral into a vault, it first transfers the amount from the caller and then deposits it to the vault with the function [here](https://github.com/code-423n4/2024-04-dyad/blob/4a987e536576139793a1c04690336d06c93fca90/src/core/Vault.sol#L42-L52).\n\n```solidity\n  function deposit(\n    uint id,\n    uint amount\n  )\n    external\n      onlyVaultManager\n  {\n    id2asset[id] += amount;\n    emit Deposit(id, amount);\n  }\n```\n\nThe issue with this implementation is that it could get very faulty for some assets, that's to say for tokens that remove fees whenever they are being transferred, then protocol is going to have an accounting flaw as it assumes the amount of assets sent with this line: `_vault.asset().safeTransferFrom(msg.sender, address(vault), amount);` is what's being received. It would be key to note that the impact of this varies on the logic of the `asset` in some cases this could be just fees that might amount to little value which would still be considered as a leak of value.\n\nHowever in some cases, for some tokens such as the [`cUSDCv3`](https://etherscan.io/address/0xbfc4feec175996c08c8f3a0469793a7979526065#code), it contains a special case for when the amount to be `deposited == type(uint256).max` in their transfer functions that result in only the user's balance being transferred. This can easily be used to exploit or rug pull the vault depending on the context, as in the vault during deposits, this execution `id2asset[id] += amount` would assume `amount` to be `type(uint256).max` and depositor can then withdraw as much tokens as they like in [consequent withdrawals](https://github.com/code-423n4/2024-04-dyad/blob/4a987e536576139793a1c04690336d06c93fca90/src/core/Vault.sol#L53-L64), breaking the intended rate of redemption `1 DYAD` to always be `$1`, as they are no collaterals to back this.\n\nAlso the protocol has stated that among tokens to consider as collaterals, we should consider LSTs and LRTs; however, even these set of tokens are vulnerable to this, from LSTs that support positive/negative rebases to LSTs that [have 1-2 wei corner cases when querying their transfers](https://docs.lido.fi/guides/lido-tokens-integration-guide/).\n\n### Impact\n\nAs explained in the last section, this could lead to multiple bug cases depending on the specific `fee/transfer` logic applied to the asset, but in both cases this leads to a heavy accounting flaw and one might easily game the system by coupling this with the minting/withdrawal logic.\n\nKeep in mind that protocol already integrates Lido's `WSTETH` on the mainnet, but since Chainlink does not have a specific feed for `WSTETH/USD` on the mainnet, protocol uses the Chainlink mainnet's `STETH/USD` feed instead as seen [here](https://github.com/code-423n4/2024-04-dyad/blob/4a987e536576139793a1c04690336d06c93fca90/script/deploy/Deploy.V2.s.sol#L55-L61), since this is not for the asset used as collateral. The protocol would decide to change and decide to integrate into protocol `STETH` directly instead which still opens them up to this issue, specifically the ` 1-2 wei corner case`, otherwise this bug case is still applicable to other.\n\nAdditional note to judge: This finding was first submitted as a H/M finding and then withdrawn after the scope of tokens to consider were refactored; however, going through the docs and information passed by sponsors we can see that protocol plans on integrating LSTs and LRTs and in that case the `1-2` wei corner case is applicable to LSTs which still makes protocol vulnerable to bug case, so consider upgrading.\n\n### Recommended Mitigation Steps\n\nDo not support these tokens; alternatively a pseudo fix would be to only account for the difference in balance when receiving tokens, but this might not suffice for all tokens considering the future integration of LSTs/LRTs that have rebasing logic attached to them.\n\n### Additional Note\n\nThis bug case is applicable to attempts of `safeTransfer/safeTransferFrom` in scope, and can be pinpointed using these search commands\n\n- [https://github.com/search?q=repo%3Acode-423n4%2F2024-04-dyad+safeTransfer%28&type=code](https://github.com/search?q=repo%3Acode-423n4%2F2024-04-dyad+safeTransfer%28&type=code)\n- [https://github.com/search?q=repo%3Acode-423n4%2F2024-04-dyad+safeTransferFrom%28&type=code](https://github.com/search?q=repo%3Acode-423n4%2F2024-04-dyad+safeTransferFrom%28&type=code)\n\nMain focus should be in the instances where these tokens are being deposited to protocol.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-04-dyad",
  "Code": [
    {
      "filename": "README.md",
      "content": "# DYAD audit details\n- Total Prize Pool: $36,500 in USDC\n  - HM awards: $28,800 in USDC\n  - QA awards: $1,200 in USDC \n  - Judge awards: $3,600 in USDC\n  - Lookout awards: $2,400 USDC\n  - Scout awards: $500 in USDC\n \n- Join [C4 Discord](https://discord.gg/code4rena) to register\n- Submit findings [using the C4 form](https://code4rena.com/contests/2024-04-dyad/submit)\n- [Read our guidelines for more details](https://docs.code4rena.com/roles/wardens)\n- Starts April 18, 2024 20:00 UTC\n- Ends April 25, 2024 20:00 UTC\n\n## Automated Findings / Publicly Known Issues\n\nThe 4naly3er report can be found [here](https://github.com/code-423n4/2024-04-dyad/blob/main/4naly3er-report.md).\n\n\n\n_Note for C4 wardens: Anything included in this `Automated Findings / Publicly Known Issues` section is considered a publicly known issue and is ineligible for awards._\n* DYAD Multisig controls most of the protocol right now.\n* Unlicensing a vault can cause issues.\n\n# Overview\nDYAD is the first truly capital efficient decentralized stablecoin. Traditionally, two costs make stablecoins inefficient: surplus collateral and DEX liquidity. DYAD minimizes both of these costs through Kerosene, a token that lowers the individual cost to mint DYAD. \n# DYAD\n\n![dyad](https://github.com/code-423n4/2024-04-dyad/blob/main/dyadlogo.jpg?raw=true)\n\n## Contracts\n\n```ml\ncore\n├─ DNft — \"A dNFT gives you the right to mint DYAD\"\n├─ Dyad — \"Stablecoin backed by ETH\"\n├─ VaultManager - \"Manage Vaults for DNfts\"\n├─ VaultManagerV2 - \"VaultManager with flash loan protection\"\n├─ Vault - \"Holds different collateral types\"\n├─ Licenser - \"License VaultManagers or Vaults\"\n├─ KerosineManager - \"Add/Remove Vaults to the Kerosene Calculation\"\n\nstaking\n├─ Kerosine - \"Kerosene ERC20\"\n├─ KerosineDenominator\n├─ Staking - \"Simple staking contract\"\n\nperiphery\n├─ Payments\n```\n\n### Deployed Contracts\n\nAll on Ethereum Mainnet\n\n| Contract | Address |\n|----------|----------|\n| DYAD             | [0x305B58c5F6B5b6606fb13edD11FbDD5e532d5A26](https://etherscan.io/address/0x305b58c5f6b5b6606fb13edd11fbdd5e532d5a26) |\n| dNFT             | [0xDc400bBe0B8B79C07A962EA99a642F5819e3b712](https://etherscan.io/address/0xdc400bbe0b8b79c07a962ea99a642f5819e3b712) |\n| Vault Manager v1 | [0xfaa785c041181a54c700fD993CDdC61dbBfb420f](https://etherscan.io/address/0xfaa785c041181a54c700fd993cddc61dbbfb420f) |\n| wETH Vault       | [0xcF97cEc1907CcF9d4A0DC4F492A3448eFc744F6c](https://etherscan.io/address/0xcf97cec1907ccf9d4a0dc4f492a3448efc744f6c) |\n| wstETH Vault     | [0x7aE80418051b2897729Cbdf388b07C5158C557A1](https://etherscan.io/address/0x7ae80418051b2897729cbdf388b07c5158c557a1)|\n\n### Migration\nThe goal is to migrate from VaultManager to VaultManagerV2. The main reason is the need for a flash loan protection which makes it harder to manipulate the deterministic Kerosene price.\nThe whole migration is described in `Deploy.V2.s.sol`. The only transaction that needs to be done by the multi-sig after the deployment is licensing the new Vault Manager.\n\n## Links\n\n- **Previous audits:**  None\n- **Documentation:** https://dyadstable.notion.site/DYAD-design-outline-v5-1-3fa96f99425e458abbe574f67b795145?pvs=4\n- **Website:** https://www.dyadstable.xyz/\n- **X/Twitter:** https://twitter.com/0xDYAD\n- **Discord:** https://t.co/nzml0Wapkt\n\n---\n\n# Scope\n\n*See [scope.txt](https://github.com/code-423n4/2024-04-dyad/blob/main/scope.txt)*\n\n### Files in scope\n\n\n| File   | Logic Contracts | Interfaces | SLOC  | Purpose | Libraries used |\n| ------ | --------------- | ---------- | ----- | -----   | ------------ |\n| [/src/staking/KerosineDenominator.sol](https://github.com/code-423n4/2024-04-dyad/blob/main/src/staking/KerosineDenominator.sol) | 1| **** | 14 | ||\n| [/src/core/VaultManagerV2.sol](https://github.com/code-423n4/2024-04-dyad/blob/main/src/core/VaultManagerV2.sol) | 1| **** | 166 | ||\n| [/src/core/Vault.kerosine.sol](https://github.com/code-423n4/2024-04-dyad/blob/main/src/core/Vault.kerosine.sol) | 1| **** | 62 | |@solmate/src/utils/SafeTransferLib.sol<br>@solmate/src/tokens/ERC20.sol<br>@solmate/src/auth/Owned.sol|\n| [/src/core/KerosineManager.sol](https://github.com/code-423n4/2024-04-dyad/blob/main/src/core/KerosineManager.sol) | 1| **** | 34 | |@openzeppelin/contracts/utils/structs/EnumerableSet.sol<br>@solmate/src/auth/Owned.sol|\n| [/src/core/Vault.kerosine.bounded.sol](https://github.com/code-423n4/2024-04-dyad/blob/main/src/core/Vault.kerosine.bounded.sol) | 1| **** | 42 | |@solmate/src/tokens/ERC20.sol|\n| [/src/core/Vault.kerosine.unbounded.sol](https://github.com/code-423n4/2024-04-dyad/blob/main/src/core/Vault.kerosine.unbounded.sol) | 1| **** | 60 | |@solmate/src/tokens/ERC20.sol<br>@solmate/src/utils/SafeTransferLib.sol|\n| [/script/deploy/Deploy.V2.s.sol](https://github.com/code-423n4/2024-04-dyad/blob/main/script/deploy/Deploy.V2.s.sol) | 1| **** | 87 | |forge-std/Script.sol<br>@solmate/src/tokens/ERC20.sol|\n| **Totals** | **7** | **** | **465** | | |\n\n### Files out of scope\n\n*See [out_of_scope.txt](https://github.com/code-423n4/2024-04-dyad/blob/main/out_of_scope.txt)*\n\n| File         |\n| ------------ |\n| ./script/Read.s.sol |\n| ./script/deploy/DeployBase.s.sol |\n| ./script/mock/transfer.wsteth.s.sol |\n| ./src/core/DNft.sol |\n| ./src/core/Dyad.sol |\n| ./src/core/Licenser.sol |\n| ./src/core/Vault.sol |\n| ./src/core/Vault.wsteth.sol |\n| ./src/interfaces/IAggregatorV3.sol |\n| ./src/interfaces/IDNft.sol |\n| ./src/interfaces/IDyad.sol |\n| ./src/interfaces/IStaking.sol |\n| ./src/interfaces/IVault.sol |\n| ./src/interfaces/IVaultManager.sol |\n| ./src/interfaces/IWETH.sol |\n| ./src/interfaces/IWstETH.sol |\n| ./src/params/DNftParameters.sol |\n| ./src/params/Parameters.sol |\n| ./src/periphery/Payments.sol |\n| ./src/staking/Kerosine.sol |\n| ./src/staking/Staking.sol |\n| ./test/BaseTest.sol |\n| ./test/ERC20Mock.sol |\n| ./test/OracleMock.sol |\n| ./test/Payments.t.sol |\n| ./test/Vault.wsteth.t.sol |\n| ./test/VaultManager.t.sol |\n| ./test/VaultManagerHelper.t.sol |\n| ./test/WETH.sol |\n| ./test/fork/v2.t.sol |\n|./src/core/VaultManager.sol|\n| Totals: 31 |\n\n## Scoping Q &amp; A\n\n### General questions\n\n| Question                                | Answer                       |\n| --------------------------------------- | ---------------------------- |\n| ERC20 used by the protocol              |       Kerosene             |\n| Test coverage                           | 33.64%                        |\n| ERC721 used  by the protocol            |            DNFT             |\n| ERC777 used by the protocol             |           None                |\n| ERC1155 used by the protocol            |              None            |\n| Chains the protocol will be deployed on | Ethereum |\n\n### ERC20 token behaviors in scope\n\n| Question                                                                                                                                                   | Answer |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------- | ------ |\n| [Missing return values](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#missing-return-values)                                                      |   ❌  |\n| [Fee on transfer](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#fee-on-transfer)                                                                  |  ✅   |\n| [Balance changes outside of transfers](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#balance-modifications-outside-of-transfers-rebasingairdrops) | ✅     |\n| [Upgradeability](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#upgradable-tokens)                                                                 |   ✅   |\n| [Flash minting](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#flash-mintable-tokens)                                                              | ✅     |\n| [Pausability](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#pausable-tokens)                                                                      | ❌    |\n| [Approval race protections](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#approval-race-protections)                                              | ✅     |\n| [Revert on approval to zero address](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#revert-on-approval-to-zero-address)                            | ✅     |\n| [Revert on zero value approvals](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#revert-on-zero-value-approvals)                                    | ✅     |\n| [Revert on zero value transfers](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#revert-on-zero-value-transfers)                                    | ❌    |\n| [Revert on transfer to the zero address](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#revert-on-transfer-to-the-zero-address)                    | ❌    |\n| [Revert on large approvals and/or transfers](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#revert-on-large-approvals--transfers)                  | ✅     |\n| [Doesn't revert on failure](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#no-revert-on-failure)                                                   |  ✅    |\n| [Multiple token addresses](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#revert-on-zero-value-transfers)                                          | ✅     |\n| [Low decimals ( < 6)](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#low-decimals)                                                                 |   ✅   |\n| [High decimals ( > 18)](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#high-decimals)                                                              | ✅     |\n| [Blocklists](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#tokens-with-blocklists)                                                                | ✅     |\n\n### External integrations (e.g., Uniswap) behavior in scope:\n\n\n| Question                                                  | Answer |\n| --------------------------------------------------------- | ------ |\n| Enabling/disabling fees (e.g. Blur disables/enables fees) | No   |\n| Pausability (e.g. Uniswap pool gets paused)               |  Yes   |\n| Upgradeability (e.g. Uniswap gets upgraded)               |   Yes  |\n\n\n### EIP compliance\nNone\n\n\n# Additional context\n\n## Main invariants\n\n- TVL > DYAD total supply\n\n\n## Attack ideas (where to focus for bugs)\n* Manipulation of Kerosene Price.\n\n* Flash Loan attacks.\n\n\n\n## All trusted roles in the protocol\n\nDYAD Multisig: 0xDeD796De6a14E255487191963dEe436c45995813\n\n\n| Role                                | Description                       |\n| --------------------------------------- | ---------------------------- |\n| DYAD Multisig                          | Ability to: License new Vault Manager, License new Vaults, Change the kerosene denominator contract, Add new vaults to the Kerosene Manager               |\n\n\n## Any novel or unique curve logic or mathematical models implemented in the contracts:\n\nNone\n\n\n## Running tests\n\n\n```bash\ngit clone https://github.com/code-423n4/2024-04-dyad.git\ngit submodule update --init --recursive\ncd 2024-04-dyad\nforge install\nforge test\n```\nTo run code coverage\n```bash\nforge coverage\n```\nTo run gas benchmarks\n```bash\nforge test --gas-report\n```\n\n![Screenshot from 2024-04-18 17-44-08](https://github.com/code-423n4/2024-04-dyad/blob/main/screenshot1.png?raw=true)\n![Screenshot from 2024-04-18 17-45-57](https://github.com/code-423n4/2024-04-dyad/blob/main/screenshot2.png?raw=true)\n![Screenshot from 2024-04-18 17-46-17](https://github.com/code-423n4/2024-04-dyad/blob/main/screenshot3.png?raw=true)\n![Screenshot from 2024-04-18 17-47-42](https://github.com/code-423n4/2024-04-dyad/blob/main/screenshot4.png?raw=true)\n![Screenshot from 2024-04-18 17-48-09](https://github.com/code-423n4/2024-04-dyad/blob/main/screenshot5.png?raw=true)\n\n\n\n\n## Miscellaneous\nEmployees of DYAD and employees' family members are ineligible to participate in this audit."
    },
    {
      "filename": "src/core/VaultManagerV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport {DNft}            from \"./DNft.sol\";\nimport {Dyad}            from \"./Dyad.sol\";\nimport {Licenser}        from \"./Licenser.sol\";\nimport {Vault}           from \"./Vault.sol\";\nimport {IVaultManager}   from \"../interfaces/IVaultManager.sol\";\nimport {KerosineManager} from \"../../src/core/KerosineManager.sol\";\n\nimport {FixedPointMathLib} from \"@solmate/src/utils/FixedPointMathLib.sol\";\nimport {ERC20}             from \"@solmate/src/tokens/ERC20.sol\";\nimport {SafeTransferLib}   from \"@solmate/src/utils/SafeTransferLib.sol\";\nimport {EnumerableSet}     from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {Initializable}     from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\ncontract VaultManagerV2 is IVaultManager, Initializable {\n  using EnumerableSet     for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint;\n  using SafeTransferLib   for ERC20;\n\n  uint public constant MAX_VAULTS          = 5;\n  uint public constant MAX_VAULTS_KEROSENE = 5;\n\n  uint public constant MIN_COLLATERIZATION_RATIO = 1.5e18; // 150%\n  uint public constant LIQUIDATION_REWARD        = 0.2e18; //  20%\n\n  DNft     public immutable dNft;\n  Dyad     public immutable dyad;\n  Licenser public immutable vaultLicenser;\n\n  KerosineManager public keroseneManager;\n\n  mapping (uint => EnumerableSet.AddressSet) internal vaults; \n  mapping (uint => EnumerableSet.AddressSet) internal vaultsKerosene; \n\n  mapping (uint => uint) public idToBlockOfLastDeposit;\n\n  modifier isDNftOwner(uint id) {\n    if (dNft.ownerOf(id) != msg.sender)   revert NotOwner();    _;\n  }\n  modifier isValidDNft(uint id) {\n    if (dNft.ownerOf(id) == address(0))   revert InvalidDNft(); _;\n  }\n  modifier isLicensed(address vault) {\n    if (!vaultLicenser.isLicensed(vault)) revert NotLicensed(); _;\n  }\n\n  constructor(\n    DNft          _dNft,\n    Dyad          _dyad,\n    Licenser      _licenser\n  ) {\n    dNft          = _dNft;\n    dyad          = _dyad;\n    vaultLicenser = _licenser;\n  }\n\n  function setKeroseneManager(KerosineManager _keroseneManager) \n    external\n      initializer \n    {\n      keroseneManager = _keroseneManager;\n  }\n\n  /// @inheritdoc IVaultManager\n  function add(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (vaults[id].length() >= MAX_VAULTS) revert TooManyVaults();\n    if (!vaultLicenser.isLicensed(vault))  revert VaultNotLicensed();\n    if (!vaults[id].add(vault))            revert VaultAlreadyAdded();\n    emit Added(id, vault);\n  }\n\n  function addKerosene(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (vaultsKerosene[id].length() >= MAX_VAULTS_KEROSENE) revert TooManyVaults();\n    if (!keroseneManager.isLicensed(vault))                 revert VaultNotLicensed();\n    if (!vaultsKerosene[id].add(vault))                     revert VaultAlreadyAdded();\n    emit Added(id, vault);\n  }\n\n  /// @inheritdoc IVaultManager\n  function remove(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (Vault(vault).id2asset(id) > 0) revert VaultHasAssets();\n    if (!vaults[id].remove(vault))     revert VaultNotAdded();\n    emit Removed(id, vault);\n  }\n\n  function removeKerosene(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (Vault(vault).id2asset(id) > 0)     revert VaultHasAssets();\n    if (!vaultsKerosene[id].remove(vault)) revert VaultNotAdded();\n    emit Removed(id, vault);\n  }\n\n  /// @inheritdoc IVaultManager\n  function deposit(\n    uint    id,\n    address vault,\n    uint    amount\n  ) \n    external \n      isValidDNft(id)\n  {\n    idToBlockOfLastDeposit[id] = block.number;\n    Vault _vault = Vault(vault);\n    _vault.asset().safeTransferFrom(msg.sender, address(vault), amount);\n    _vault.deposit(id, amount);\n  }\n\n  /// @inheritdoc IVaultManager\n  function withdraw(\n    uint    id,\n    address vault,\n    uint    amount,\n    address to\n  ) \n    public\n      isDNftOwner(id)\n  {\n    if (idToBlockOfLastDeposit[id] == block.number) revert DepositedInSameBlock();\n    uint dyadMinted = dyad.mintedDyad(address(this), id);\n    Vault _vault = Vault(vault);\n    uint value = amount * _vault.assetPrice() \n                  * 1e18 \n                  / 10**_vault.oracle().decimals() \n                  / 10**_vault.asset().decimals();\n    if (getNonKeroseneValue(id) - value < dyadMinted) revert NotEnoughExoCollat();\n    _vault.withdraw(id, to, amount);\n    if (collatRatio(id) < MIN_COLLATERIZATION_RATIO)  revert CrTooLow(); \n  }\n\n  /// @inheritdoc IVaultManager\n  function mintDyad(\n    uint    id,\n    uint    amount,\n    address to\n  )\n    external \n      isDNftOwner(id)\n  {\n    uint newDyadMinted = dyad.mintedDyad(address(this), id) + amount;\n    if (getNonKeroseneValue(id) < newDyadMinted)     revert NotEnoughExoCollat();\n    dyad.mint(id, to, amount);\n    if (collatRatio(id) < MIN_COLLATERIZATION_RATIO) revert CrTooLow(); \n    emit MintDyad(id, amount, to);\n  }\n\n  /// @inheritdoc IVaultManager\n  function burnDyad(\n    uint id,\n    uint amount\n  ) \n    external \n      isValidDNft(id)\n  {\n    dyad.burn(id, msg.sender, amount);\n    emit BurnDyad(id, amount, msg.sender);\n  }\n\n  /// @inheritdoc IVaultManager\n  function redeemDyad(\n    uint    id,\n    address vault,\n    uint    amount,\n    address to\n  )\n    external \n      isDNftOwner(id)\n    returns (uint) { \n      dyad.burn(id, msg.sender, amount);\n      Vault _vault = Vault(vault);\n      uint asset = amount \n                    * (10**(_vault.oracle().decimals() + _vault.asset().decimals())) \n                    / _vault.assetPrice() \n                    / 1e18;\n      withdraw(id, vault, asset, to);\n      emit RedeemDyad(id, vault, amount, to);\n      return asset;\n  }\n\n  /// @inheritdoc IVaultManager\n  function liquidate(\n    uint id,\n    uint to\n  ) \n    external \n      isValidDNft(id)\n      isValidDNft(to)\n    {\n      uint cr = collatRatio(id);\n      if (cr >= MIN_COLLATERIZATION_RATIO) revert CrTooHigh();\n      dyad.burn(id, msg.sender, dyad.mintedDyad(address(this), id));\n\n      uint cappedCr               = cr < 1e18 ? 1e18 : cr;\n      uint liquidationEquityShare = (cappedCr - 1e18).mulWadDown(LIQUIDATION_REWARD);\n      uint liquidationAssetShare  = (liquidationEquityShare + 1e18).divWadDown(cappedCr);\n\n      uint numberOfVaults = vaults[id].length();\n      for (uint i = 0; i < numberOfVaults; i++) {\n          Vault vault      = Vault(vaults[id].at(i));\n          uint  collateral = vault.id2asset(id).mulWadUp(liquidationAssetShare);\n          vault.move(id, to, collateral);\n      }\n      emit Liquidate(id, msg.sender, to);\n  }\n\n  function collatRatio(\n    uint id\n  )\n    public \n    view\n    returns (uint) {\n      uint _dyad = dyad.mintedDyad(address(this), id);\n      if (_dyad == 0) return type(uint).max;\n      return getTotalUsdValue(id).divWadDown(_dyad);\n  }\n\n  function getTotalUsdValue(\n    uint id\n  ) \n    public \n    view\n    returns (uint) {\n      return getNonKeroseneValue(id) + getKeroseneValue(id);\n  }\n\n  function getNonKeroseneValue(\n    uint id\n  ) \n    public \n    view\n    returns (uint) {\n      uint totalUsdValue;\n      uint numberOfVaults = vaults[id].length(); \n      for (uint i = 0; i < numberOfVaults; i++) {\n        Vault vault = Vault(vaults[id].at(i));\n        uint usdValue;\n        if (vaultLicenser.isLicensed(address(vault))) {\n          usdValue = vault.getUsdValue(id);        \n        }\n        totalUsdValue += usdValue;\n      }\n      return totalUsdValue;\n  }\n\n  function getKeroseneValue(\n    uint id\n  ) \n    public \n    view\n    returns (uint) {\n      uint totalUsdValue;\n      uint numberOfVaults = vaultsKerosene[id].length(); \n      for (uint i = 0; i < numberOfVaults; i++) {\n        Vault vault = Vault(vaultsKerosene[id].at(i));\n        uint usdValue;\n        if (keroseneManager.isLicensed(address(vault))) {\n          usdValue = vault.getUsdValue(id);        \n        }\n        totalUsdValue += usdValue;\n      }\n      return totalUsdValue;\n  }\n\n  // ----------------- MISC ----------------- //\n\n  function getVaults(\n    uint id\n  ) \n    external \n    view \n    returns (address[] memory) {\n      return vaults[id].values();\n  }\n\n  function hasVault(\n    uint    id,\n    address vault\n  ) \n    external \n    view \n    returns (bool) {\n      return vaults[id].contains(vault);\n  }\n}"
    },
    {
      "filename": "src/core/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport {IVaultManager} from \"../interfaces/IVaultManager.sol\";\nimport {IDNft}         from \"../interfaces/IDNft.sol\";\nimport {IVault}        from \"../interfaces/IVault.sol\";\nimport {IAggregatorV3} from \"../interfaces/IAggregatorV3.sol\";\n\nimport {SafeCast}          from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {SafeTransferLib}   from \"@solmate/src/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"@solmate/src/utils/FixedPointMathLib.sol\";\nimport {ERC20}             from \"@solmate/src/tokens/ERC20.sol\";\n\ncontract Vault is IVault {\n  using SafeTransferLib   for ERC20;\n  using SafeCast          for int;\n  using FixedPointMathLib for uint;\n\n  uint public constant STALE_DATA_TIMEOUT = 90 minutes; \n\n  IVaultManager public immutable vaultManager;\n  ERC20         public immutable asset;\n  IAggregatorV3 public immutable oracle;\n\n  mapping(uint => uint) public id2asset;\n\n  modifier onlyVaultManager() {\n    if (msg.sender != address(vaultManager)) revert NotVaultManager();\n    _;\n  }\n\n  constructor(\n    IVaultManager _vaultManager,\n    ERC20         _asset,\n    IAggregatorV3 _oracle\n  ) {\n    vaultManager   = _vaultManager;\n    asset          = _asset;\n    oracle         = _oracle;\n  }\n\n  function deposit(\n    uint id,\n    uint amount\n  )\n    external \n      onlyVaultManager\n  {\n    id2asset[id] += amount;\n    emit Deposit(id, amount);\n  }\n\n  function withdraw(\n    uint    id,\n    address to,\n    uint    amount\n  ) \n    external \n      onlyVaultManager\n  {\n    id2asset[id] -= amount;\n    asset.safeTransfer(to, amount); \n    emit Withdraw(id, to, amount);\n  }\n\n  function move(\n    uint from,\n    uint to,\n    uint amount\n  )\n    external\n      onlyVaultManager\n  {\n    id2asset[from] -= amount;\n    id2asset[to]   += amount;\n    emit Move(from, to, amount);\n  }\n\n  function getUsdValue(\n    uint id\n  )\n    external\n    view \n    returns (uint) {\n      return id2asset[id] * assetPrice() \n              * 1e18 \n              / 10**oracle.decimals() \n              / 10**asset.decimals();\n  }\n\n  function assetPrice() \n    public \n    view \n    returns (uint) {\n      (\n        ,\n        int256 answer,\n        , \n        uint256 updatedAt, \n      ) = oracle.latestRoundData();\n      if (block.timestamp > updatedAt + STALE_DATA_TIMEOUT) revert StaleData();\n      return answer.toUint256();\n  }\n}"
    },
    {
      "filename": "src/core/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport {IVaultManager} from \"../interfaces/IVaultManager.sol\";\nimport {IDNft}         from \"../interfaces/IDNft.sol\";\nimport {IVault}        from \"../interfaces/IVault.sol\";\nimport {IAggregatorV3} from \"../interfaces/IAggregatorV3.sol\";\n\nimport {SafeCast}          from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {SafeTransferLib}   from \"@solmate/src/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"@solmate/src/utils/FixedPointMathLib.sol\";\nimport {ERC20}             from \"@solmate/src/tokens/ERC20.sol\";\n\ncontract Vault is IVault {\n  using SafeTransferLib   for ERC20;\n  using SafeCast          for int;\n  using FixedPointMathLib for uint;\n\n  uint public constant STALE_DATA_TIMEOUT = 90 minutes; \n\n  IVaultManager public immutable vaultManager;\n  ERC20         public immutable asset;\n  IAggregatorV3 public immutable oracle;\n\n  mapping(uint => uint) public id2asset;\n\n  modifier onlyVaultManager() {\n    if (msg.sender != address(vaultManager)) revert NotVaultManager();\n    _;\n  }\n\n  constructor(\n    IVaultManager _vaultManager,\n    ERC20         _asset,\n    IAggregatorV3 _oracle\n  ) {\n    vaultManager   = _vaultManager;\n    asset          = _asset;\n    oracle         = _oracle;\n  }\n\n  function deposit(\n    uint id,\n    uint amount\n  )\n    external \n      onlyVaultManager\n  {\n    id2asset[id] += amount;\n    emit Deposit(id, amount);\n  }\n\n  function withdraw(\n    uint    id,\n    address to,\n    uint    amount\n  ) \n    external \n      onlyVaultManager\n  {\n    id2asset[id] -= amount;\n    asset.safeTransfer(to, amount); \n    emit Withdraw(id, to, amount);\n  }\n\n  function move(\n    uint from,\n    uint to,\n    uint amount\n  )\n    external\n      onlyVaultManager\n  {\n    id2asset[from] -= amount;\n    id2asset[to]   += amount;\n    emit Move(from, to, amount);\n  }\n\n  function getUsdValue(\n    uint id\n  )\n    external\n    view \n    returns (uint) {\n      return id2asset[id] * assetPrice() \n              * 1e18 \n              / 10**oracle.decimals() \n              / 10**asset.decimals();\n  }\n\n  function assetPrice() \n    public \n    view \n    returns (uint) {\n      (\n        ,\n        int256 answer,\n        , \n        uint256 updatedAt, \n      ) = oracle.latestRoundData();\n      if (block.timestamp > updatedAt + STALE_DATA_TIMEOUT) revert StaleData();\n      return answer.toUint256();\n  }\n}"
    },
    {
      "filename": "script/deploy/Deploy.V2.s.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport \"forge-std/Script.sol\";\n\nimport {Parameters}             from \"../../src/params/Parameters.sol\";\nimport {VaultManagerV2}         from \"../../src/core/VaultManagerV2.sol\";\nimport {DNft}                   from \"../../src/core/DNft.sol\";\nimport {Dyad}                   from \"../../src/core/Dyad.sol\";\nimport {Licenser}               from \"../../src/core/Licenser.sol\";\nimport {Vault}                  from \"../../src/core/Vault.sol\";\nimport {VaultWstEth}            from \"../../src/core/Vault.wsteth.sol\";\nimport {IWETH}                  from \"../../src/interfaces/IWETH.sol\";\nimport {IAggregatorV3}          from \"../../src/interfaces/IAggregatorV3.sol\";\nimport {KerosineManager}        from \"../../src/core/KerosineManager.sol\";\nimport {UnboundedKerosineVault} from \"../../src/core/Vault.kerosine.unbounded.sol\";\nimport {BoundedKerosineVault}   from \"../../src/core/Vault.kerosine.bounded.sol\";\nimport {Kerosine}               from \"../../src/staking/Kerosine.sol\";\nimport {KerosineDenominator}    from \"../../src/staking/KerosineDenominator.sol\";\n\nimport {ERC20} from \"@solmate/src/tokens/ERC20.sol\";\n\nstruct Contracts {\n  Kerosine               kerosene;\n  Licenser               vaultLicenser;\n  VaultManagerV2         vaultManager;\n  Vault                  ethVault;\n  VaultWstEth            wstEth;\n  KerosineManager        kerosineManager;\n  UnboundedKerosineVault unboundedKerosineVault;\n  BoundedKerosineVault   boundedKerosineVault;\n  KerosineDenominator    kerosineDenominator;\n}\n\ncontract DeployV2 is Script, Parameters {\n  function run() public returns (Contracts memory) {\n    vm.startBroadcast();  // ----------------------\n\n    Licenser vaultLicenser = new Licenser();\n\n    // Vault Manager needs to be licensed through the Vault Manager Licenser\n    VaultManagerV2 vaultManager = new VaultManagerV2(\n      DNft(MAINNET_DNFT),\n      Dyad(MAINNET_DYAD),\n      vaultLicenser\n    );\n\n    // weth vault\n    Vault ethVault = new Vault(\n      vaultManager,\n      ERC20        (MAINNET_WETH),\n      IAggregatorV3(MAINNET_WETH_ORACLE)\n    );\n\n    // wsteth vault\n    VaultWstEth wstEth = new VaultWstEth(\n      vaultManager, \n      ERC20        (MAINNET_WSTETH), \n      IAggregatorV3(MAINNET_CHAINLINK_STETH)\n    );\n\n    KerosineManager kerosineManager = new KerosineManager();\n\n    kerosineManager.add(address(ethVault));\n    kerosineManager.add(address(wstEth));\n\n    vaultManager.setKeroseneManager(kerosineManager);\n\n    kerosineManager.transferOwnership(MAINNET_OWNER);\n\n    UnboundedKerosineVault unboundedKerosineVault = new UnboundedKerosineVault(\n      vaultManager,\n      Kerosine(MAINNET_KEROSENE), \n      Dyad    (MAINNET_DYAD),\n      kerosineManager\n    );\n\n    BoundedKerosineVault boundedKerosineVault     = new BoundedKerosineVault(\n      vaultManager,\n      Kerosine(MAINNET_KEROSENE), \n      kerosineManager\n    );\n\n    KerosineDenominator kerosineDenominator       = new KerosineDenominator(\n      Kerosine(MAINNET_KEROSENE)\n    );\n\n    unboundedKerosineVault.setDenominator(kerosineDenominator);\n\n    unboundedKerosineVault.transferOwnership(MAINNET_OWNER);\n    boundedKerosineVault.  transferOwnership(MAINNET_OWNER);\n\n    vaultLicenser.add(address(ethVault));\n    vaultLicenser.add(address(wstEth));\n    vaultLicenser.add(address(unboundedKerosineVault));\n    // vaultLicenser.add(address(boundedKerosineVault));\n\n    vaultLicenser.transferOwnership(MAINNET_OWNER);\n\n    vm.stopBroadcast();  // ----------------------------\n\n    return Contracts(\n      Kerosine(MAINNET_KEROSENE),\n      vaultLicenser,\n      vaultManager,\n      ethVault,\n      wstEth,\n      kerosineManager,\n      unboundedKerosineVault,\n      boundedKerosineVault,\n      kerosineDenominator\n    );\n  }\n}"
    }
  ]
}