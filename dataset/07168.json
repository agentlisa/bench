{
  "Title": "[G-07] Using ``delete``  instead of setting struct ``0`` saves gas",
  "Content": "\n10 results - 2 files:\n\n```solidity\npackages\\v2-pool\\src\\structs\\LiquidityPosition.sol:\n   93:    liquidityPosition.long0Fees = 0;\n\n  101:    liquidityPosition.long1Fees = 0;\n\n  109:    liquidityPosition.shortFees = 0;\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/structs/LiquidityPosition.sol#L93\n\n\n```solidity\npackages\\v2-pool\\src\\structs\\Pool.sol:\n  228:    pool.long0ProtocolFees = 0;\n\n  236:    pool.long1ProtocolFees = 0;\n\n  244:    pool.shortProtocolFees = 0;\n\n  633:    pool.long0Balance = 0;\n\n  646:    pool.long1Balance = 0;\n\n  685:    pool.long1Balance = 0;\n\n  706:    pool.long0Balance = 0;\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/structs/Pool.sol#L228\n\n\n**Recommendation code:**\n\n```diff\npackages\\v2-pool\\src\\structs\\Pool.sol#L228\n-  228:    pool.long0ProtocolFees = 0;\n+ 228:    delete pool.long0ProtocolFees;\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-01-timeswap",
  "Code": [
    {
      "filename": "packages/v2-pool/src/structs/LiquidityPosition.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {Math} from \"@timeswap-labs/v2-library/src/Math.sol\";\n\nimport {FeeCalculation} from \"../libraries/FeeCalculation.sol\";\n\n/// @param liquidity The amount of liquidity owned.\n/// @param long0FeeGrowth The long0 position fee growth stored when the user entered the positions.\n/// @param long1FeeGrowth The long1 position fee growth stored when the user entered the positions.\n/// @param shortFeeGrowth The short position fee growth stored when the user entered the positions.\n/// @param long0Fees The stored amount of long0 position fees owned.\n/// @param long1Fees The stored amount of long1 position fees owned.\n/// @param shortFees The stored amount of short position fees owned.\nstruct LiquidityPosition {\n    uint160 liquidity;\n    uint256 long0FeeGrowth;\n    uint256 long1FeeGrowth;\n    uint256 shortFeeGrowth;\n    uint256 long0Fees;\n    uint256 long1Fees;\n    uint256 shortFees;\n}\n\nlibrary LiquidityPositionLibrary {\n    using Math for uint256;\n\n    /// @dev Get the total fees earned by the owner.\n    /// @param liquidityPosition The liquidity position of the owner.\n    /// @param long0FeeGrowth The current global long0 position fee growth to be compared.\n    /// @param long1FeeGrowth The current global long1 position fee growth to be compared.\n    /// @param shortFeeGrowth The current global short position fee growth to be compared.\n    function feesEarnedOf(\n        LiquidityPosition memory liquidityPosition,\n        uint256 long0FeeGrowth,\n        uint256 long1FeeGrowth,\n        uint256 shortFeeGrowth\n    ) internal pure returns (uint256 long0Fee, uint256 long1Fee, uint256 shortFee) {\n        uint160 liquidity = liquidityPosition.liquidity;\n\n        long0Fee = liquidityPosition.long0Fees.unsafeAdd(FeeCalculation.getFees(liquidity, liquidityPosition.long0FeeGrowth, long0FeeGrowth));\n        long1Fee = liquidityPosition.long1Fees.unsafeAdd(FeeCalculation.getFees(liquidity, liquidityPosition.long1FeeGrowth, long1FeeGrowth));\n        shortFee = liquidityPosition.shortFees.unsafeAdd(FeeCalculation.getFees(liquidity, liquidityPosition.shortFeeGrowth, shortFeeGrowth));\n    }\n\n    /// @dev Update the liquidity position after mint and/or burn functions.\n    /// @param liquidityPosition The liquidity position of the owner.\n    /// @param long0FeeGrowth The current global long0 position fee growth to be compared.\n    /// @param long1FeeGrowth The current global long1 position fee growth to be compared.\n    /// @param shortFeeGrowth The current global short position fee growth to be compared.\n    function update(LiquidityPosition storage liquidityPosition, uint256 long0FeeGrowth, uint256 long1FeeGrowth, uint256 shortFeeGrowth) internal {\n        uint160 liquidity = liquidityPosition.liquidity;\n\n        if (liquidity != 0) {\n            liquidityPosition.long0Fees += FeeCalculation.getFees(liquidity, liquidityPosition.long0FeeGrowth, long0FeeGrowth);\n            liquidityPosition.long1Fees += FeeCalculation.getFees(liquidity, liquidityPosition.long1FeeGrowth, long1FeeGrowth);\n            liquidityPosition.shortFees += FeeCalculation.getFees(liquidity, liquidityPosition.shortFeeGrowth, shortFeeGrowth);\n        }\n\n        liquidityPosition.long0FeeGrowth = long0FeeGrowth;\n        liquidityPosition.long1FeeGrowth = long1FeeGrowth;\n        liquidityPosition.shortFeeGrowth = shortFeeGrowth;\n    }\n\n    function mint(LiquidityPosition storage liquidityPosition, uint160 liquidityAmount) internal {\n        liquidityPosition.liquidity += liquidityAmount;\n    }\n\n    function mintFees(LiquidityPosition storage liquidityPosition, uint256 long0Fees, uint256 long1Fees, uint256 shortFees) internal {\n        liquidityPosition.long0Fees += long0Fees;\n        liquidityPosition.long1Fees += long1Fees;\n        liquidityPosition.shortFees += shortFees;\n    }\n\n    function burn(LiquidityPosition storage liquidityPosition, uint160 liquidityAmount) internal {\n        liquidityPosition.liquidity -= liquidityAmount;\n    }\n\n    function burnFees(LiquidityPosition storage liquidityPosition, uint256 long0Fees, uint256 long1Fees, uint256 shortFees) internal {\n        liquidityPosition.long0Fees -= long0Fees;\n        liquidityPosition.long1Fees -= long1Fees;\n        liquidityPosition.shortFees -= shortFees;\n    }\n\n    function collectTransactionFees(\n        LiquidityPosition storage liquidityPosition,\n        uint256 long0Requested,\n        uint256 long1Requested,\n        uint256 shortRequested\n    ) internal returns (uint256 long0Fees, uint256 long1Fees, uint256 shortFees) {\n        if (long0Requested >= liquidityPosition.long0Fees) {\n            long0Fees = liquidityPosition.long0Fees;\n            liquidityPosition.long0Fees = 0;\n        } else {\n            long0Fees = long0Requested;\n            liquidityPosition.long0Fees = liquidityPosition.long0Fees.unsafeSub(long0Requested);\n        }\n\n        if (long1Requested >= liquidityPosition.long1Fees) {\n            long1Fees = liquidityPosition.long1Fees;\n            liquidityPosition.long1Fees = 0;\n        } else {\n            long1Fees = long1Requested;\n            liquidityPosition.long1Fees = liquidityPosition.long1Fees.unsafeSub(long1Requested);\n        }\n\n        if (shortRequested >= liquidityPosition.shortFees) {\n            shortFees = liquidityPosition.shortFees;\n            liquidityPosition.shortFees = 0;\n        } else {\n            shortFees = shortRequested;\n            liquidityPosition.shortFees = liquidityPosition.shortFees.unsafeSub(shortRequested);\n        }\n    }\n}"
    },
    {
      "filename": "packages/v2-pool/src/structs/Pool.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {SafeCast} from \"@timeswap-labs/v2-library/src/SafeCast.sol\";\nimport {Error} from \"@timeswap-labs/v2-library/src/Error.sol\";\nimport {Math} from \"@timeswap-labs/v2-library/src/Math.sol\";\n\nimport {ITimeswapV2Option} from \"@timeswap-labs/v2-option/src/interfaces/ITimeswapV2Option.sol\";\n\nimport {StrikeConversion} from \"@timeswap-labs/v2-library/src/StrikeConversion.sol\";\n\nimport {DurationCalculation} from \"../libraries/DurationCalculation.sol\";\nimport {DurationWeight} from \"../libraries/DurationWeight.sol\";\nimport {ConstantProduct} from \"../libraries/ConstantProduct.sol\";\nimport {ConstantSum} from \"../libraries/ConstantSum.sol\";\nimport {FeeCalculation} from \"../libraries/FeeCalculation.sol\";\n\nimport {ITimeswapV2PoolMintCallback} from \"../interfaces/callbacks/ITimeswapV2PoolMintCallback.sol\";\nimport {ITimeswapV2PoolBurnCallback} from \"../interfaces/callbacks/ITimeswapV2PoolBurnCallback.sol\";\nimport {ITimeswapV2PoolDeleverageCallback} from \"../interfaces/callbacks/ITimeswapV2PoolDeleverageCallback.sol\";\nimport {ITimeswapV2PoolLeverageCallback} from \"../interfaces/callbacks/ITimeswapV2PoolLeverageCallback.sol\";\n\nimport {LiquidityPosition, LiquidityPositionLibrary} from \"./LiquidityPosition.sol\";\n\nimport {TimeswapV2PoolMint, TimeswapV2PoolBurn, TimeswapV2PoolDeleverage, TimeswapV2PoolLeverage, TimeswapV2PoolRebalance, TransactionLibrary} from \"../enums/Transaction.sol\";\n\nimport {TimeswapV2PoolCollectParam, TimeswapV2PoolMintParam, TimeswapV2PoolBurnParam, TimeswapV2PoolDeleverageParam, TimeswapV2PoolLeverageParam, TimeswapV2PoolRebalanceParam} from \"./Param.sol\";\nimport {TimeswapV2PoolMintChoiceCallbackParam, TimeswapV2PoolBurnChoiceCallbackParam, TimeswapV2PoolDeleverageChoiceCallbackParam, TimeswapV2PoolLeverageChoiceCallbackParam} from \"./CallbackParam.sol\";\n/// @param liquidity The current total liquidity of the pool.\n/// @param lastTimestamp The last block timestamp the pool was interacted with.\n/// @param sqrtInterestRate The current square root interest rate of the pool. Follows UQ64.96.\n/// @param long0Balance The current amount of long0 positions in the pool.\n/// @param long1Balance The current amount of long1 positions in the pool.\n/// @param long0FeeGrowth The global long0 position fee growth the last time the pool was interacted with.\n/// @param long1FeeGrowth The global long1 position fee growth the last time the pool was interacted with.\n/// @param shortFeeGrowth The global short position fee growth the last time the pool was interacted with.\n/// @param long0ProtocolFees The amount of long0 position protocol fees earned.\n/// @param long1ProtocolFees The amount of long1 position protocol fees earned.\n/// @param shortProtocolFees The amount of short position protocol fees earned.\n/// @param liquidityPositions The mapping of liquidity positions owned by liquidity providers.\nstruct Pool {\n    uint160 liquidity;\n    uint96 lastTimestamp;\n    uint160 sqrtInterestRate;\n    uint256 long0Balance;\n    uint256 long1Balance;\n    uint256 long0FeeGrowth;\n    uint256 long1FeeGrowth;\n    uint256 shortFeeGrowth;\n    uint256 long0ProtocolFees;\n    uint256 long1ProtocolFees;\n    uint256 shortProtocolFees;\n    mapping(address => LiquidityPosition) liquidityPositions;\n}\n\nlibrary PoolLibrary {\n    using LiquidityPositionLibrary for LiquidityPosition;\n    using Math for uint256;\n    using SafeCast for uint256;\n\n    /// @dev It calculates the global fee growth, which is fee increased per unit of liquidity token.\n    /// @param pool The state of the pool.\n    /// @return long0FeeGrowth The global fee increased per unit of liquidity token for long0.\n    /// @return long1FeeGrowth The global fee increased per unit of liquidity token for long1.\n    /// @return  shortFeeGrowth The global fee increased per unit of liquidity token for short.\n    function feeGrowth(Pool storage pool) external view returns (uint256 long0FeeGrowth, uint256 long1FeeGrowth, uint256 shortFeeGrowth) {\n        return (pool.long0FeeGrowth, pool.long1FeeGrowth, pool.shortFeeGrowth);\n    }\n\n    /// @param pool The state of the pool.\n    /// @param owner The address to query the fees earned of.\n    /// @return long0Fees The amount of long0 fees owned by the given address.\n    /// @return long1Fees The amount of long1 fees owned by the given address.\n    /// @return shortFees The amount of short fees owned by the given address.\n    function feesEarnedOf(Pool storage pool, address owner) external view returns (uint256 long0Fees, uint256 long1Fees, uint256 shortFees) {\n        return pool.liquidityPositions[owner].feesEarnedOf(pool.long0FeeGrowth, pool.long1FeeGrowth, pool.shortFeeGrowth);\n    }\n\n    /// @param pool The state of the pool.\n    /// @return long0ProtocolFees The amount of long0 protocol fees owned by the owner of the factory contract.\n    /// @return long1ProtocolFees The amount of long1 protocol fees owned by the owner of the factory contract.\n    /// @return shortProtocolFees The amount of short protocol fees owned by the owner of the factory contract.\n    function protocolFeesEarned(Pool storage pool) external view returns (uint256 long0ProtocolFees, uint256 long1ProtocolFees, uint256 shortProtocolFees) {\n        return (pool.long0ProtocolFees, pool.long1ProtocolFees, pool.shortProtocolFees);\n    }\n\n    /// @dev Returns the amount of long0 and long1 adjusted for the protocol and transaction fee.\n    /// @param pool The state of the pool.\n    /// @return long0Amount The amount of long0 in the pool, adjusted for the protocol and transaction fee.\n    /// @return long1Amount The amount of long1 in the pool, adjusted for the protocol and transaction fee.\n    function totalLongBalanceAdjustFees(Pool storage pool, uint256 transactionFee) external view returns (uint256 long0Amount, uint256 long1Amount) {\n        long0Amount = FeeCalculation.removeFees(pool.long0Balance, transactionFee);\n        long1Amount = FeeCalculation.removeFees(pool.long1Balance, transactionFee);\n    }\n\n    /// @dev Returns the amount of sum of long0 and long1 converted to base denomination in the pool.\n    /// @dev Returns the amount of short positions in the pool.\n    /// @param pool The state of the pool.\n    /// @return longAmount The amount of sum of long0 and long1 converted to base denomination in the pool.\n    /// @return shortAmount The amount of short in the pool.\n    function totalPositions(Pool storage pool, uint256 maturity, uint96 blockTimestamp) external view returns (uint256 longAmount, uint256 shortAmount) {\n        longAmount = ConstantProduct.getLong(pool.liquidity, pool.sqrtInterestRate, false);\n        shortAmount = ConstantProduct.getShort(pool.liquidity, pool.sqrtInterestRate, DurationCalculation.unsafeDurationFromNowToMaturity(maturity, blockTimestamp), false);\n    }\n\n    /// @dev Move short positions to short fee growth due to duration of the pool decreasing as time moves forward.\n    /// @param liquidity The liquidity in the pool.\n    /// @param rate The square root interest rate in the pool.\n    /// @param shortFeeGrowth The previous short fee growth from last transaction in the pool.\n    /// @param duration The duration time of the pool.\n    /// @param blockTimestamp The block timestamp.\n    /// @return newLastTimestamp The new current last timestamp.\n    /// @return newShortFeeGrowth The newly updated short fee growth.\n    function updateDurationWeight(\n        uint160 liquidity,\n        uint160 rate,\n        uint256 shortFeeGrowth,\n        uint96 duration,\n        uint96 blockTimestamp\n    ) private pure returns (uint96 newLastTimestamp, uint256 newShortFeeGrowth) {\n        newLastTimestamp = blockTimestamp;\n        newShortFeeGrowth = DurationWeight.update(liquidity, shortFeeGrowth, ConstantProduct.getShort(liquidity, rate, duration, false));\n    }\n\n    /// @dev Move short positions to short fee growth due to duration of the pool decreasing as time moves forward when pool is before maturity.\n    /// @param pool The state of the pool.\n    /// @param blockTimestamp The block timestamp.\n    function updateDurationWeightBeforeMaturity(Pool storage pool, uint96 blockTimestamp) private {\n        if (pool.lastTimestamp < blockTimestamp)\n            (pool.lastTimestamp, pool.shortFeeGrowth) = updateDurationWeight(\n                pool.liquidity,\n                pool.sqrtInterestRate,\n                pool.shortFeeGrowth,\n                DurationCalculation.unsafeDurationFromLastTimestampToNow(pool.lastTimestamp, blockTimestamp),\n                blockTimestamp\n            );\n    }\n\n    /// @dev Move short positions to short fee growth due to duration of the pool decreasing as time moves forward when pool is after maturity.\n    /// @param pool The state of the pool.\n    /// @param blockTimestamp The block timestamp.\n    function updateDurationWeightAfterMaturity(Pool storage pool, uint256 maturity, uint96 blockTimestamp) private {\n        (pool.lastTimestamp, pool.shortFeeGrowth) = updateDurationWeight(\n            pool.liquidity,\n            pool.sqrtInterestRate,\n            pool.shortFeeGrowth,\n            DurationCalculation.unsafeDurationFromLastTimestampToMaturity(pool.lastTimestamp, maturity),\n            blockTimestamp\n        );\n    }\n\n    /// @dev Transfer liquidity positions to another address.\n    /// @notice Does not transfer the transaction fees earned by the sender.\n    /// @param pool The state of the pool.\n    /// @param to The receipient of the liquidity positions.\n    /// @param liquidityAmount The amount of liquidity positions transferred.\n    /// @param blockTimestamp The current block timestamp.\n    function transferLiquidity(Pool storage pool, address to, uint160 liquidityAmount, uint96 blockTimestamp) external {\n        // Update the state of the pool first for the short fee growth.\n        if (pool.liquidity != 0) updateDurationWeightBeforeMaturity(pool, blockTimestamp);\n\n        // Update the fee growth and fees of msg.sender.\n        LiquidityPosition storage liquidityPosition = pool.liquidityPositions[msg.sender];\n\n        liquidityPosition.update(pool.long0FeeGrowth, pool.long1FeeGrowth, pool.shortFeeGrowth);\n        liquidityPosition.burn(liquidityAmount);\n\n        // Update the fee growth and fees of receipient.\n        LiquidityPosition storage newLiquidityPosition = pool.liquidityPositions[to];\n\n        newLiquidityPosition.update(pool.long0FeeGrowth, pool.long1FeeGrowth, pool.shortFeeGrowth);\n        newLiquidityPosition.mint(liquidityAmount);\n    }\n\n    /// @dev Transfer fees earned of the sender to another address.\n    /// @notice Does not transfer the liquidity positions of the sender.\n    /// @param pool The state of the pool.\n    /// @param to The receipient of the transaction fees.\n    /// @param long0Fees The amount of long0 position fees transferrred.\n    /// @param long1Fees The amount of long1 position fees transferrred.\n    /// @param shortFees The amount of short position fees transferrred.\n    /// @param blockTimestamp The current block timestamp.\n    function transferFees(Pool storage pool, uint256 maturity, address to, uint256 long0Fees, uint256 long1Fees, uint256 shortFees, uint96 blockTimestamp) external {\n        // Update the state of the pool first for the short fee growth.\n        if (pool.liquidity != 0) {\n            if (maturity > blockTimestamp) updateDurationWeightBeforeMaturity(pool, blockTimestamp);\n            else if (pool.lastTimestamp < maturity) updateDurationWeightAfterMaturity(pool, maturity, blockTimestamp);\n        }\n        // Update the fee growth and fees of msg.sender.\n        LiquidityPosition storage liquidityPosition = pool.liquidityPositions[msg.sender];\n\n        liquidityPosition.update(pool.long0FeeGrowth, pool.long1FeeGrowth, pool.shortFeeGrowth);\n        liquidityPosition.burnFees(long0Fees, long1Fees, shortFees);\n\n        // Update the fee growth and fees of recipient.\n        liquidityPosition = pool.liquidityPositions[to];\n\n        liquidityPosition.update(pool.long0FeeGrowth, pool.long1FeeGrowth, pool.shortFeeGrowth);\n        liquidityPosition.mintFees(long0Fees, long1Fees, shortFees);\n    }\n\n    /// @dev initializes the pool with the given parameters.\n    /// @param pool The state of the pool.\n    /// @param rate The square root of the interest rate of the pool.\n    function initialize(Pool storage pool, uint160 rate) external {\n        if (pool.liquidity != 0) Error.alreadyHaveLiquidity(pool.liquidity);\n        pool.sqrtInterestRate = rate;\n    }\n\n    /// @dev Collects the protocol fees of the pool.\n    /// @dev only protocol owner can call this function.\n    /// @dev if the owner enters an amount which is greater than the fee amount they have earned, withdraw only the amount they have.\n    /// @param pool The state of the pool.\n    /// @param long0Requested The maximum amount of long0 positions wanted.\n    /// @param long1Requested The maximum amount of long1 positions wanted.\n    /// @param shortRequested The maximum amount of short positions wanted.\n    /// @return long0Amount The amount of long0 collected.\n    /// @return long1Amount The amount of long1 collected.\n    /// @return shortAmount The amount of short collected.\n    function collectProtocolFees(\n        Pool storage pool,\n        uint256 long0Requested,\n        uint256 long1Requested,\n        uint256 shortRequested\n    ) external returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount) {\n        if (long0Requested >= pool.long0ProtocolFees) {\n            long0Amount = pool.long0ProtocolFees;\n            pool.long0ProtocolFees = 0;\n        } else {\n            long0Amount = long0Requested;\n            pool.long0ProtocolFees = pool.long0ProtocolFees.unsafeSub(long0Requested);\n        }\n\n        if (long1Requested >= pool.long1ProtocolFees) {\n            long1Amount = pool.long1ProtocolFees;\n            pool.long1ProtocolFees = 0;\n        } else {\n            long1Amount = long1Requested;\n            pool.long1ProtocolFees = pool.long1ProtocolFees.unsafeSub(long1Requested);\n        }\n\n        if (shortRequested >= pool.shortProtocolFees) {\n            shortAmount = pool.shortProtocolFees;\n            pool.shortProtocolFees = 0;\n        } else {\n            shortAmount = shortRequested;\n            pool.shortProtocolFees = pool.shortProtocolFees.unsafeSub(shortRequested);\n        }\n    }\n\n    /// @dev Collects the transaction fees of the pool.\n    /// @dev only liquidity provider can call this function.\n    /// @dev if the owner enters an amount which is greater than the fee amount they have earned, withdraw only the amount they have.\n    /// @param pool The state of the pool.\n    /// @param blockTimestamp The current block timestamp.\n    /// @param long0Requested The maximum amount of long0 positions wanted.\n    /// @param long1Requested The maximum amount of long1 positions wanted.\n    /// @param shortRequested The maximum amount of short positions wanted.\n    /// @return long0Amount The amount of long0 collected.\n    /// @return long1Amount The amount of long1 collected.\n    /// @return shortAmount The amount of short collected.\n    function collectTransactionFees(\n        Pool storage pool,\n        uint256 maturity,\n        uint256 long0Requested,\n        uint256 long1Requested,\n        uint256 shortRequested,\n        uint96 blockTimestamp\n    ) external returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount) {\n        // Update the state of the pool first for the short fee growth.\n        if (pool.liquidity != 0) {\n            if (maturity > blockTimestamp) updateDurationWeightBeforeMaturity(pool, blockTimestamp);\n            else if (pool.lastTimestamp < maturity) updateDurationWeightAfterMaturity(pool, maturity, blockTimestamp);\n        }\n\n        // Update the fee growth and fees of caller.\n        LiquidityPosition storage liquidityPosition = pool.liquidityPositions[msg.sender];\n\n        if (pool.liquidity != 0) liquidityPosition.update(pool.long0FeeGrowth, pool.long1FeeGrowth, pool.shortFeeGrowth);\n\n        (long0Amount, long1Amount, shortAmount) = liquidityPosition.collectTransactionFees(long0Requested, long1Requested, shortRequested);\n    }\n\n    /// @dev deposit Short and Long tokens and mints Liquidity\n    /// @dev can be only called before the maturity.\n    /// @param pool The state of the pool.\n    /// @param param it is a struct that contains the parameters of the mint function.\n    /// @param blockTimestamp The current block timestamp.\n    /// @return liquidityAmount The amount of liquidity minted.\n    /// @return long0Amount The amount of long0 deposited.\n    /// @return long1Amount The amount of long1 deposited.\n    /// @return shortAmount The amount of short deposited.\n    /// @return data the data used for the callbacks.\n    function mint(\n        Pool storage pool,\n        TimeswapV2PoolMintParam memory param,\n        uint96 blockTimestamp\n    ) external returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        // Update the state of the pool first for the short fee growth.\n        if (pool.liquidity != 0) updateDurationWeightBeforeMaturity(pool, blockTimestamp);\n        // Update the fee growth and fees of caller.\n        LiquidityPosition storage liquidityPosition = pool.liquidityPositions[param.to];\n\n        uint256 longAmount;\n        if (param.transaction == TimeswapV2PoolMint.GivenLiquidity) {\n            (longAmount, shortAmount) = ConstantProduct.calculateGivenLiquidityDelta(\n                pool.sqrtInterestRate,\n                liquidityAmount = param.delta.toUint160(),\n                DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),\n                true\n            );\n\n            if (longAmount == 0) Error.zeroOutput();\n            if (shortAmount == 0) Error.zeroOutput();\n        } else if (param.transaction == TimeswapV2PoolMint.GivenLong) {\n            (liquidityAmount, shortAmount) = ConstantProduct.calculateGivenLiquidityLong(\n                pool.sqrtInterestRate,\n                longAmount = param.delta,\n                DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),\n                true\n            );\n\n            if (liquidityAmount == 0) Error.zeroOutput();\n            if (shortAmount == 0) Error.zeroOutput();\n        } else if (param.transaction == TimeswapV2PoolMint.GivenShort) {\n            (liquidityAmount, longAmount) = ConstantProduct.calculateGivenLiquidityShort(\n                pool.sqrtInterestRate,\n                shortAmount = param.delta,\n                DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),\n                true\n            );\n\n            if (liquidityAmount == 0) Error.zeroOutput();\n            if (longAmount == 0) Error.zeroOutput();\n        } else if (param.transaction == TimeswapV2PoolMint.GivenLarger) {\n            (liquidityAmount, longAmount, shortAmount) = ConstantProduct.calculateGivenLiquidityLargerOrSmaller(\n                pool.sqrtInterestRate,\n                param.delta,\n                DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),\n                true\n            );\n\n            if (liquidityAmount == 0) Error.zeroOutput();\n            if (longAmount == 0) Error.zeroOutput();\n            if (shortAmount == 0) Error.zeroOutput();\n        }\n\n        // Ask the msg.sender how much long0 position and long1 position wanted.\n        (long0Amount, long1Amount, data) = ITimeswapV2PoolMintCallback(msg.sender).timeswapV2PoolMintChoiceCallback(\n            TimeswapV2PoolMintChoiceCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                longAmount: longAmount,\n                shortAmount: shortAmount,\n                liquidityAmount: liquidityAmount,\n                data: param.data\n            })\n        );\n        Error.checkEnough(StrikeConversion.combine(long0Amount, long1Amount, param.strike, false), longAmount);\n\n        if (long0Amount != 0) pool.long0Balance += long0Amount;\n        if (long1Amount != 0) pool.long1Balance += long1Amount;\n\n        liquidityPosition.mint(liquidityAmount);\n        pool.liquidity += liquidityAmount;\n    }\n\n    /// @dev burn Liquidity and receive Short and Long tokens\n    /// @dev can be only called before the maturity.\n    /// @dev after the maturity of the pool, the long0 and long1 tokens are zero. And the short tokens are added into the transaction fees.\n    /// @dev if the user wants to burn the liquidity after the maturity, they should call the collectTransactionFee function.\n    /// @param pool The state of the pool.\n    /// @param param it is a struct that contains the parameters of the burn function.\n    /// @param blockTimestamp The current block timestamp.\n    /// @return liquidityAmount The amount of liquidity burned.\n    /// @return long0Amount The amount of long0 withdrawn.\n    /// @return long1Amount The amount of long1 withdrawn.\n    /// @return shortAmount The amount of short withdrawn.\n    /// @return data the data used for the callbacks.\n    function burn(\n        Pool storage pool,\n        TimeswapV2PoolBurnParam memory param,\n        uint96 blockTimestamp\n    ) external returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        if (pool.liquidity == 0) Error.requireLiquidity();\n\n        // Update the state of the pool first for the short fee growth.\n        updateDurationWeightBeforeMaturity(pool, blockTimestamp);\n\n        LiquidityPosition storage liquidityPosition = pool.liquidityPositions[msg.sender];\n\n        liquidityPosition.update(pool.long0FeeGrowth, pool.long1FeeGrowth, pool.shortFeeGrowth);\n\n        uint256 longAmount;\n        if (param.transaction == TimeswapV2PoolBurn.GivenLiquidity) {\n            (longAmount, shortAmount) = ConstantProduct.calculateGivenLiquidityDelta(\n                pool.sqrtInterestRate,\n                liquidityAmount = param.delta.toUint160(),\n                DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),\n                false\n            );\n\n            if (longAmount == 0) Error.zeroOutput();\n            if (shortAmount == 0) Error.zeroOutput();\n        } else if (param.transaction == TimeswapV2PoolBurn.GivenLong) {\n            (liquidityAmount, shortAmount) = ConstantProduct.calculateGivenLiquidityLong(\n                pool.sqrtInterestRate,\n                longAmount = param.delta,\n                DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),\n                false\n            );\n\n            if (liquidityAmount == 0) Error.zeroOutput();\n            if (shortAmount == 0) Error.zeroOutput();\n        } else if (param.transaction == TimeswapV2PoolBurn.GivenShort) {\n            (liquidityAmount, longAmount) = ConstantProduct.calculateGivenLiquidityShort(\n                pool.sqrtInterestRate,\n                shortAmount = param.delta,\n                DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),\n                false\n            );\n\n            if (liquidityAmount == 0) Error.zeroOutput();\n            if (longAmount == 0) Error.zeroOutput();\n        } else if (param.transaction == TimeswapV2PoolBurn.GivenSmaller) {\n            (liquidityAmount, longAmount, shortAmount) = ConstantProduct.calculateGivenLiquidityLargerOrSmaller(\n                pool.sqrtInterestRate,\n                param.delta,\n                DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),\n                false\n            );\n\n            if (liquidityAmount == 0) Error.zeroOutput();\n            if (longAmount == 0) Error.zeroOutput();\n            if (shortAmount == 0) Error.zeroOutput();\n        }\n\n        (long0Amount, long1Amount, data) = ITimeswapV2PoolBurnCallback(msg.sender).timeswapV2PoolBurnChoiceCallback(\n            TimeswapV2PoolBurnChoiceCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                long0Balance: pool.long0Balance,\n                long1Balance: pool.long1Balance,\n                longAmount: longAmount,\n                shortAmount: shortAmount,\n                liquidityAmount: liquidityAmount,\n                data: param.data\n            })\n        );\n        Error.checkEnough(longAmount, StrikeConversion.combine(long0Amount, long1Amount, param.strike, true));\n\n        if (long0Amount != 0) pool.long0Balance -= long0Amount;\n        if (long1Amount != 0) pool.long1Balance -= long1Amount;\n\n        pool.liquidity -= liquidityAmount;\n    }\n\n    /// @dev deposit Long tokens and receive Short tokens\n    /// @dev can be only called before the maturity.\n    /// @param pool The state of the pool.\n    /// @param param it is a struct that contains the parameters of the deleverage function\n    /// @param transactionFee The transaction fee rate.\n    /// @param protocolFee The protocol fee rate.\n    /// @param blockTimestamp The current block timestamp.\n    /// @return long0Amount The amount of long0 deposited.\n    /// @return long1Amount The amount of long1 deposited.\n    /// @return shortAmount The amount of short received.\n    /// @return data the data used for the callbacks.\n    function deleverage(\n        Pool storage pool,\n        TimeswapV2PoolDeleverageParam memory param,\n        uint256 transactionFee,\n        uint256 protocolFee,\n        uint96 blockTimestamp\n    ) external returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        if (pool.liquidity == 0) Error.requireLiquidity();\n        // Update the state of the pool first for the short fee growth.\n        updateDurationWeightBeforeMaturity(pool, blockTimestamp);\n\n        uint256 longAmount;\n        uint256 shortFees;\n        if (param.transaction == TimeswapV2PoolDeleverage.GivenDeltaSqrtInterestRate) {\n            (pool.sqrtInterestRate, longAmount, shortAmount, shortFees) = ConstantProduct.updateGivenSqrtInterestRateDelta(\n                pool.liquidity,\n                pool.sqrtInterestRate,\n                param.delta.toUint160(),\n                DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),\n                transactionFee,\n                false\n            );\n\n            if (longAmount == 0) Error.zeroOutput();\n            if (shortAmount == 0) Error.zeroOutput();\n        } else if (param.transaction == TimeswapV2PoolDeleverage.GivenLong) {\n            (pool.sqrtInterestRate, shortAmount, shortFees) = ConstantProduct.updateGivenLong(\n                pool.liquidity,\n                pool.sqrtInterestRate,\n                longAmount = param.delta,\n                DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),\n                transactionFee,\n                true\n            );\n\n            if (shortAmount == 0) Error.zeroOutput();\n        } else if (param.transaction == TimeswapV2PoolDeleverage.GivenShort) {\n            (pool.sqrtInteres"
    }
  ]
}