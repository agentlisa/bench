{
  "Title": "[M-05] Investors claiming their `maxDeposit` by using the `LiquidityPool.deposit()` will cause other users to be unable to claim their `maxDeposit`/`maxMint`",
  "Content": "\nClaiming deposits using the [`LiquidityPool.deposit()`](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/LiquidityPool.sol#L141-L144) will cause the Escrow contract to not have enough shares to allow other investors to claim their maxDeposit or maxMint values for their deposited assets.\n\n### Proof of Concept\n\n*   Before an investor can claim their deposits, they first needs to request the deposit and wait for the Centrigue Chain to validate it in the next epoch.\n\n*   Investors can request deposits at different epochs without the need to claim all the approved deposits before requesting a new deposit, in the end, the maxDeposit and maxMint values that the investor can claim will be increased accordingly based on all the request deposits that the investor makes.\n\n*   When the requestDeposit of the investor is processed in the Centrifuge chain, a number of TrancheShares will be minted based on the price at the moment when the request was processed and the total amount of deposited assets, this TrancheShares will be deposited to the Escrow contract, and the TrancheShares will be waiting for the investors to claim their deposits.\n\n*   When investors decide to claim their deposit they can use the [`LiquidityPool.deposit()`](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/LiquidityPool.sol#L141-L144) function, this function receives as arguments the number of assets that are being claimed and the address of the account to claim the deposits for.\n\n```solidity\nfunction deposit(uint256 assets, address receiver) public returns (uint256 shares) {\n    shares = investmentManager.processDeposit(receiver, assets);\n    emit Deposit(address(this), receiver, assets, shares);\n}\n```\n\n*   The [`LiquidityPool.deposit()`](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/LiquidityPool.sol#L141-L144) function calls the [`InvestmentManager::processDeposit()`](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/InvestmentManager.sol#L427-L441) which will validate that the amount of assets being claimed doesn't exceed the investor's deposit limits, will compute the deposit price in the [`InvestmentManager::calculateDepositPrice()`](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/InvestmentManager.sol#L551-L558), which basically computes an average price for all the request deposits that have been accepted in the Centrifuge Chain, each of those request deposits could've been executed at a different price, so, this function, based on the values of maxDeposit and maxMint will estimate an average price for all the unclaimed deposits, later, using this computed price for the deposits will compute the equivalent of TrancheTokens for the CurrencyAmount being claimed, and finally, processDeposit() will transferFrom the escrow to the investor account the computed amount of TranchTokens.\n\n```solidity\nfunction processDeposit(address user, uint256 currencyAmount) public auth returns (uint256 trancheTokenAmount) {\n    address liquidityPool = msg.sender;\n    uint128 _currencyAmount = _toUint128(currencyAmount);\n    require(\n        //@audit-info => orderbook[][].maxDeposit is updated when the handleExecutedCollectInvest() was executed!\n        //@audit-info => The orderbook keeps track of the number of TrancheToken shares that have been minted to the Escrow contract on the user's behalf!\n        (_currencyAmount <= orderbook[user][liquidityPool].maxDeposit && _currencyAmount != 0),\n        \"InvestmentManager/amount-exceeds-deposit-limits\"\n    );\n\n    //@audit-info => computes an average price for all the request deposits that have been accepted in the Centrifuge Chain and haven't been claimed yet!\n    uint256 depositPrice = calculateDepositPrice(user, liquidityPool);\n    require(depositPrice != 0, \"LiquidityPool/deposit-token-price-0\");\n\n    //@audit-info => Based on the computed depositPrice will compute the equivalent of TrancheTokens for the CurrencyAmount being claimed\n    uint128 _trancheTokenAmount = _calculateTrancheTokenAmount(_currencyAmount, liquidityPool, depositPrice);\n\n    //@audit-info => transferFrom the escrow to the investor account the computed amount of TranchTokens.\n    _deposit(_trancheTokenAmount, _currencyAmount, liquidityPool, user);\n    trancheTokenAmount = uint256(_trancheTokenAmount);\n}\n```\n\n**The problem** occurs when an investor hasn't claimed their deposits and has requested multiple deposits on different epochs at different prices. The [`InvestmentManager::calculateDepositPrice()`](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/InvestmentManager.sol#L551-L558) function will compute an equivalent/average price for all the requestDeposits that haven't been claimed yet. Because of the different prices that the request deposits where processed at, the computed price will compute the most accurate average of the deposit's price, but there is a slight rounding error that causes the computed value of trancheTokenAmount to be slightly different from what it should exactly be.\n\n*   That slight difference will make that the Escrow contract transfers slightly more shares to the investor claiming the deposits by using the [`LiquidityPool.deposit()`](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/LiquidityPool.sol#L141-L144)\n*   **As a result**, when another investor tries to claim their [maxDeposit](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/LiquidityPool.sol#L129-L132) or [maxMint](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/LiquidityPool.sol#L154-L157), now the Escrow contract doesn't have enough shares to make whole the request of the other investor, and as a consequence the other investor transaction will be reverted. That means the second investor won't be able to claim all the shares that it is entitled to claim because the Escrow contract doesn't have all those shares anymore.\n\n**Coded PoC**\n\n*   I used the [`LiquidityPool.t.sol`](https://github.com/code-423n4/2023-09-centrifuge/blob/main/test/LiquidityPool.t.sol) test file as the base file for this PoC, please add the below testPoC to the LiquidityPool.t.sol file\n\n*   In this PoC I demonstrate that Alice (A second investor) won't be able to claim her maxDeposit or maxMint amounts after the first investor uses the [`LiquidityPool.deposit()`](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/LiquidityPool.sol#L141-L144) function to claim his [maxDeposit() assets](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/LiquidityPool.sol#L129-L132). The first investor makes two requestDeposit, each of them at a different epoch and at a different price, Alice on the other hand only does 1 requestDeposit in the second epoch.\n\n*   Run this PoC two times, check the comments on the last 4 lines, one time we want to test Alice claiming her deposits using LiquidityPool::deposit(), and the second time using LiquidityPool::mint()\n    *   The two executions should fail with the same problem.\n\n<details>\n\n```solidity\n    function testDepositAtDifferentPricesPoC(uint64 poolId, bytes16 trancheId, uint128 currencyId) public {\n        vm.assume(currencyId > 0);\n\n        uint8 TRANCHE_TOKEN_DECIMALS = 18; // Like DAI\n        uint8 INVESTMENT_CURRENCY_DECIMALS = 6; // 6, like USDC\n\n        ERC20 currency = _newErc20(\"Currency\", \"CR\", INVESTMENT_CURRENCY_DECIMALS);\n        address lPool_ =\n            deployLiquidityPool(poolId, TRANCHE_TOKEN_DECIMALS, \"\", \"\", trancheId, currencyId, address(currency));\n        LiquidityPool lPool = LiquidityPool(lPool_);\n        homePools.updateTrancheTokenPrice(poolId, trancheId, currencyId, 1000000000000000000);\n\n        //@audit-info => Add Alice as a Member\n        address alice = address(0x23232323);\n        homePools.updateMember(poolId, trancheId, alice, type(uint64).max);\n\n        // invest\n        uint256 investmentAmount = 100000000; // 100 * 10**6\n        homePools.updateMember(poolId, trancheId, self, type(uint64).max);\n        currency.approve(address(investmentManager), investmentAmount);\n        currency.mint(self, investmentAmount);\n        lPool.requestDeposit(investmentAmount, self);\n\n        // trigger executed collectInvest at a price of 1.25\n        uint128 _currencyId = poolManager.currencyAddressToId(address(currency)); // retrieve currencyId\n        uint128 currencyPayout = 100000000; // 100 * 10**6                                          \n        uint128 firstTrancheTokenPayout = 80000000000000000000; // 100 * 10**18 / 1.25, rounded down\n        homePools.isExecutedCollectInvest(\n            poolId, trancheId, bytes32(bytes20(self)), _currencyId, currencyPayout, firstTrancheTokenPayout\n        );\n\n        // assert deposit & mint values adjusted\n        assertEq(lPool.maxDeposit(self), currencyPayout);\n        assertEq(lPool.maxMint(self), firstTrancheTokenPayout);\n\n        // deposit price should be ~1.25*10**18 === 1250000000000000000\n        assertEq(investmentManager.calculateDepositPrice(self, address(lPool)), 1250000000000000000);\n\n\n        // second investment in a different epoch => different price\n        currency.approve(address(investmentManager), investmentAmount);\n        currency.mint(self, investmentAmount);\n        lPool.requestDeposit(investmentAmount, self);\n\n        // trigger executed collectInvest at a price of 2\n        currencyPayout = 100000000; // 100 * 10**6\n        uint128 secondTrancheTokenPayout = 50000000000000000000; // 100 * 10**18 / 1.4, rounded down\n        homePools.isExecutedCollectInvest(\n            poolId, trancheId, bytes32(bytes20(self)), _currencyId, currencyPayout, secondTrancheTokenPayout\n        );\n\n        // Alice invests the same amount as the other investor in the second epoch - Price is at 2\n        currency.mint(alice, investmentAmount);\n\n        vm.startPrank(alice);\n        currency.approve(address(investmentManager), investmentAmount);\n        lPool.requestDeposit(investmentAmount, alice);\n        vm.stopPrank();\n\n        homePools.isExecutedCollectInvest(\n            poolId, trancheId, bytes32(bytes20(alice)), _currencyId, currencyPayout, secondTrancheTokenPayout\n        );\n\n        uint128 AliceTrancheTokenPayout = 50000000000000000000; // 100 * 10**18 / 1.4, rounded down\n\n        //@audit-info => At this point, the Escrow contract should have the firstTrancheTokenPayout + secondTrancheTokenPayout + AliceTrancheTokenPayout\n        assertEq(lPool.balanceOf(address(escrow)),firstTrancheTokenPayout + secondTrancheTokenPayout + AliceTrancheTokenPayout);\n\n\n        // Investor collects his the deposited assets using the LiquidityPool::deposit()\n        lPool.deposit(lPool.maxDeposit(self), self);\n        \n\n        // Alice tries to collect her deposited assets and gets her transactions reverted because the Escrow doesn't have the required TokenShares for Alice!\n        vm.startPrank(alice);\n\n        //@audit-info => Run the PoC one time to test Alice trying to claim their deposit using LiquidityPool.deposit()\n        lPool.deposit(lPool.maxDeposit(alice), alice);\n        \n        //@audit-info => Run the PoC a second time, but now using LiquidityPool.mint()\n        // lPool.mint(lPool.maxMint(alice), alice);\n        vm.stopPrank();\n    }\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\n*   I'd recommend to add a check to the computed value of the [`_trancheTokenAmount`](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/InvestmentManager.sol#L438) in the `InvestmentManager::processDeposit()`, if the `_trancheTokenAmount` exceeds the `maxMint()` of the user, update it and set it to be the maxMint(), in this way, the rounding differences will be discarded before doing the actual transfer of shares from the Escrow to the user, and this will prevent the Escrow from not having all the required TranchToken for the other investors\n\n```solidity\nfunction processDeposit(address user, uint256 currencyAmount) public auth returns (uint256 trancheTokenAmount) {\n    address liquidityPool = msg.sender;\n    uint128 _currencyAmount = _toUint128(currencyAmount);\n    require(\n        (_currencyAmount <= orderbook[user][liquidityPool].maxDeposit && _currencyAmount != 0),\n        \"InvestmentManager/amount-exceeds-deposit-limits\"\n    );\n\n    uint256 depositPrice = calculateDepositPrice(user, liquidityPool);\n    require(depositPrice != 0, \"LiquidityPool/deposit-token-price-0\");\n\n    uint128 _trancheTokenAmount = _calculateTrancheTokenAmount(_currencyAmount, liquidityPool, depositPrice);\n    \n    //@audit => Add this check to prevent any rounding errors from causing problems when transfering shares from the Escrow to the Investor!\n+   if (_trancheTokenAmount > orderbook[user][liquidityPool].maxMint) _trancheTokenAmount = orderbook[user][liquidityPool].maxMint;\n    \n    _deposit(_trancheTokenAmount, _currencyAmount, liquidityPool, user);\n    trancheTokenAmount = uint256(_trancheTokenAmount);\n}\n```\n\n*   After applying the suggested recommendation, you can use the provided PoC on this report to verify that the problem has been solved.\n\n### Assessed type\n\nMath\n\n**[hieronx (Centrifuge) confirmed](https://github.com/code-423n4/2023-09-centrifuge-findings/issues/118#issuecomment-1728512469)**\n\n**[hieronx (Centrifuge) commented via duplicate issue `#210`](https://github.com/code-423n4/2023-09-centrifuge-findings/issues/210#issuecomment-1728512207):**\n > I believe issues [210](https://github.com/code-423n4/2023-09-centrifuge-findings/issues/210), [34](https://github.com/code-423n4/2023-09-centrifuge-findings/issues/34) and [118](https://github.com/code-423n4/2023-09-centrifuge-findings/issues/118) all come down to the same underlying issues, and I will try to respond with our current understanding (although we are still digging further).\n> \n> There are actually multiple rounding issues coming together in the system right now:\n> 1. If there are multiple executions of an order, there can be loss of precision when these values are added to each other.\n> 2. If there are multiple `deposit` or `mint` calls, there can be loss of precision in the amount of tranche tokens they receive, based on the computed deposit price.\n> 3. If there are multiple `deposit` or `mint` calls, there can be loss of precision in the implied new price through the subtracted `maxDeposit` / `maxMint` values.\n> \n> We've written [a new fuzz test](https://github.com/code-423n4/2023-09-centrifuge-findings/issues/210#issuecomment-1728512207), building on the work from the reported findings, that clearly shows the underlying issue.\n> \n> Unfortunately it also makes clear that this issue cannot be solved by the recommended mitigation steps from the 3 different findings on their own, and it requires deeper changes. We are still investigating this.\n> \n> Now, in terms of the severity, it does not directly lead to a loss of funds. As noted in [issue 210](https://github.com/code-423n4/2023-09-centrifuge-findings/issues/210), the `UserEscrow` logic prevents users from withdrawing more currency/funds than they are entitled to. However, it does lead to users being able to receive more tranche tokens (shares). I will leave it to the judges to make a decision on the severity for this.\n> \n> Thanks to the 3 wardens for reporting these issues!\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2023-09-centrifuge-findings/issues/118#issuecomment-1733725182):**\n > This issue described a protocol specific issue with multiple deposit/withdrawal, where [issue 34](https://github.com/code-423n4/2023-09-centrifuge-findings/issues/34) is a generic 4626 rounding issue, and therefore not marked as duplicate of issue 34. In terms of severity, this does not directly lead to a loss of fund but will affect the availability of the protocol, hence Medium.\n\n**[hieronx (Centrifuge) commented](https://github.com/code-423n4/2023-09-centrifuge-findings/issues/118#issuecomment-1745029786):**\n > Mitigated in https://github.com/centrifuge/liquidity-pools/pull/166\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-09-centrifuge",
  "Code": [
    {
      "filename": "src/LiquidityPool.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.21;\n\nimport {Auth} from \"./util/Auth.sol\";\nimport {MathLib} from \"./util/MathLib.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport {IERC4626} from \"./interfaces/IERC4626.sol\";\n\ninterface ERC20PermitLike {\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external;\n    function PERMIT_TYPEHASH() external view returns (bytes32);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\ninterface TrancheTokenLike is IERC20, ERC20PermitLike {\n    function checkTransferRestriction(address from, address to, uint256 value) external view returns (bool);\n}\n\ninterface InvestmentManagerLike {\n    function processDeposit(address receiver, uint256 assets) external returns (uint256);\n    function processMint(address receiver, uint256 shares) external returns (uint256);\n    function processWithdraw(uint256 assets, address receiver, address owner) external returns (uint256);\n    function processRedeem(uint256 shares, address receiver, address owner) external returns (uint256);\n    function maxDeposit(address user, address _tranche) external view returns (uint256);\n    function maxMint(address user, address _tranche) external view returns (uint256);\n    function maxWithdraw(address user, address _tranche) external view returns (uint256);\n    function maxRedeem(address user, address _tranche) external view returns (uint256);\n    function totalAssets(uint256 totalSupply, address liquidityPool) external view returns (uint256);\n    function convertToShares(uint256 assets, address liquidityPool) external view returns (uint256);\n    function convertToAssets(uint256 shares, address liquidityPool) external view returns (uint256);\n    function previewDeposit(address user, address liquidityPool, uint256 assets) external view returns (uint256);\n    function previewMint(address user, address liquidityPool, uint256 shares) external view returns (uint256);\n    function previewWithdraw(address user, address liquidityPool, uint256 assets) external view returns (uint256);\n    function previewRedeem(address user, address liquidityPool, uint256 shares) external view returns (uint256);\n    function requestRedeem(uint256 shares, address receiver) external;\n    function requestDeposit(uint256 assets, address receiver) external;\n    function collectDeposit(address receiver) external;\n    function collectRedeem(address receiver) external;\n    function decreaseDepositRequest(uint256 assets, address receiver) external;\n    function decreaseRedeemRequest(uint256 shares, address receiver) external;\n}\n\n/// @title  Liquidity Pool\n/// @notice Liquidity Pool implementation for Centrifuge pools\n///         following the EIP4626 standard, with asynchronous extension methods.\n///\n/// @dev    Each Liquidity Pool is a tokenized vault issuing shares of Centrifuge tranches as restricted ERC20 tokens against currency deposits based on the current share price.\n///         This is extending the EIP4626 standard by 'requestRedeem' & 'requestDeposit' functions, where redeem and deposit orders are submitted to the pools\n///         to be included in the execution of the following epoch. After execution users can use the deposit, mint, redeem and withdraw functions to\n///         get their shares and/or assets from the pools.\ncontract LiquidityPool is Auth, IERC4626 {\n    using MathLib for uint256;\n\n    uint64 public immutable poolId;\n    bytes16 public immutable trancheId;\n\n    /// @notice The investment currency for this Liquidity Pool.\n    ///         Each tranche of a Centrifuge pool can have multiple Liquidity Pools. A Liquidity Pool for each supported asset.\n    ///         Thus tranche shares can be linked to multiple LiquidityPools with different assets.\n    /// @dev    Also known as the investment currency.\n    address public immutable asset;\n\n    /// @notice The restricted ERC-20 Liquidity Pool token. Has a ratio (token price) of underlying assets\n    ///         exchanged on deposit/withdraw/redeem.\n    /// @dev    Also known as tranche tokens.\n    TrancheTokenLike public immutable share;\n\n    InvestmentManagerLike public investmentManager;\n\n    /// @notice Tranche token price, denominated in the asset\n    uint128 public latestPrice;\n\n    /// @notice Timestamp of the last price update\n    uint256 public lastPriceUpdate;\n\n    // --- Events ---\n    event File(bytes32 indexed what, address data);\n    event DepositRequested(address indexed owner, uint256 assets);\n    event RedeemRequested(address indexed owner, uint256 shares);\n    event DepositCollected(address indexed owner);\n    event RedeemCollected(address indexed owner);\n    event UpdatePrice(uint128 price);\n\n    constructor(uint64 poolId_, bytes16 trancheId_, address asset_, address share_, address investmentManager_) {\n        poolId = poolId_;\n        trancheId = trancheId_;\n        asset = asset_;\n        share = TrancheTokenLike(share_);\n        investmentManager = InvestmentManagerLike(investmentManager_);\n\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    /// @dev Either msg.sender is the owner or a ward on the contract\n    modifier withApproval(address owner) {\n        require(msg.sender == owner, \"LiquidityPool/no-approval\");\n        _;\n    }\n\n    // --- Administration ---\n    function file(bytes32 what, address data) public auth {\n        if (what == \"investmentManager\") investmentManager = InvestmentManagerLike(data);\n        else revert(\"LiquidityPool/file-unrecognized-param\");\n        emit File(what, data);\n    }\n\n    // --- ERC4626 functions ---\n    /// @return Total value of the shares, denominated in the asset of this Liquidity Pools\n    function totalAssets() public view returns (uint256) {\n        return investmentManager.totalAssets(totalSupply(), address(this));\n    }\n\n    /// @notice Calculates the amount of shares that any user would approximately get for the amount of assets provided.\n    ///         The calcultion is based on the token price from the most recent epoch retrieved from Centrifuge.\n    ///         The actual conversion will likely differ as the price changes between order submission and execution.\n    function convertToShares(uint256 assets) public view returns (uint256 shares) {\n        shares = investmentManager.convertToShares(assets, address(this));\n    }\n\n    /// @notice Calculates the asset value for an amount of shares provided.\n    ///         The calculation is based on the token price from the most recent epoch retrieved from Centrifuge.\n    ///         The actual conversion will likely differ as the price changes between order submission and execution.\n    function convertToAssets(uint256 shares) public view returns (uint256 assets) {\n        assets = investmentManager.convertToAssets(shares, address(this));\n    }\n\n    /// @return Maximum amount of assets that can be deposited into the Tranche by the receiver after the epoch had been executed on Centrifuge.\n    function maxDeposit(address receiver) public view returns (uint256) {\n        return investmentManager.maxDeposit(receiver, address(this));\n    }\n\n    /// @return shares that any user would get for an amount of assets provided\n    function previewDeposit(uint256 assets) public view returns (uint256 shares) {\n        shares = investmentManager.previewDeposit(msg.sender, address(this), assets);\n    }\n\n    /// @notice Collect shares for deposited assets after Centrifuge epoch execution.\n    ///         maxDeposit is the max amount of shares that can be collected.\n    function deposit(uint256 assets, address receiver) public returns (uint256 shares) {\n        shares = investmentManager.processDeposit(receiver, assets);\n        emit Deposit(address(this), receiver, assets, shares);\n    }\n\n    /// @notice Collect shares for deposited assets after Centrifuge epoch execution.\n    ///         maxMint is the max amount of shares that can be collected.\n    function mint(uint256 shares, address receiver) public returns (uint256 assets) {\n        // require(receiver == msg.sender, \"LiquidityPool/not-authorized-to-mint\");\n        assets = investmentManager.processMint(receiver, shares);\n        emit Deposit(address(this), receiver, assets, shares);\n    }\n\n    /// @notice Maximum amount of shares that can be claimed by the receiver after the epoch has been executed on the Centrifuge side.\n    function maxMint(address receiver) external view returns (uint256 maxShares) {\n        maxShares = investmentManager.maxMint(receiver, address(this));\n    }\n\n    /// @return assets that any user would get for an amount of shares provided -> convertToAssets\n    function previewMint(uint256 shares) external view returns (uint256 assets) {\n        assets = investmentManager.previewMint(msg.sender, address(this), shares);\n    }\n\n    /// @return maxAssets that the receiver can withdraw\n    function maxWithdraw(address receiver) public view returns (uint256 maxAssets) {\n        return investmentManager.maxWithdraw(receiver, address(this));\n    }\n\n    /// @return shares that a user would need to redeem in order to receive the given amount of assets -> convertToAssets\n    function previewWithdraw(uint256 assets) public view returns (uint256 shares) {\n        shares = investmentManager.previewWithdraw(msg.sender, address(this), assets);\n    }\n\n    /// @notice Withdraw assets after successful epoch execution. Receiver will receive an exact amount of assets for a certain amount of shares that has been redeemed from Owner during epoch execution.\n    /// @return shares that have been redeemed for the exact assets amount\n    function withdraw(uint256 assets, address receiver, address owner)\n        public\n        withApproval(owner)\n        returns (uint256 shares)\n    {\n        uint256 sharesRedeemed = investmentManager.processWithdraw(assets, receiver, owner);\n        emit Withdraw(address(this), receiver, owner, assets, sharesRedeemed);\n        return sharesRedeemed;\n    }\n\n    /// @notice Max amount of shares that can be redeemed by the owner after redemption was requested\n    function maxRedeem(address owner) public view returns (uint256 maxShares) {\n        return investmentManager.maxRedeem(owner, address(this));\n    }\n\n    /// @return assets that any user could redeem for a given amount of shares\n    function previewRedeem(uint256 shares) public view returns (uint256 assets) {\n        assets = investmentManager.previewRedeem(msg.sender, address(this), shares);\n    }\n\n    /// @notice Redeem shares after successful epoch execution. Receiver will receive assets for\n    /// @notice Redeem shares can only be called by the Owner or an authorized admin.\n    ///         the exact amount of redeemed shares from Owner after epoch execution.\n    /// @return assets payout for the exact amount of redeemed shares\n    function redeem(uint256 shares, address receiver, address owner)\n        public\n        withApproval(owner)\n        returns (uint256 assets)\n    {\n        uint256 currencyPayout = investmentManager.processRedeem(shares, receiver, owner);\n        emit Withdraw(address(this), receiver, owner, currencyPayout, shares);\n        return currencyPayout;\n    }\n\n    // --- Asynchronous 4626 functions ---\n    /// @notice Request asset deposit for a receiver to be included in the next epoch execution.\n    /// @notice Request can only be called by the Owner of the assets or an authorized admin.\n    ///         Asset is locked in the escrow on request submission\n    function requestDeposit(uint256 assets, address owner) public withApproval(owner) {\n        investmentManager.requestDeposit(assets, owner);\n        emit DepositRequested(owner, assets);\n    }\n\n    /// @notice Similar to requestDeposit, but with a permit option.\n    function requestDepositWithPermit(uint256 assets, address owner, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        public\n    {\n        ERC20PermitLike(asset).permit(owner, address(investmentManager), assets, deadline, v, r, s);\n        investmentManager.requestDeposit(assets, owner);\n        emit DepositRequested(owner, assets);\n    }\n\n    /// @notice Request share redemption for a receiver to be included in the next epoch execution.\n    /// @notice Request can only be called by the Owner of the shares or an authorized admin.\n    ///         Shares are locked in the escrow on request submission\n    function requestRedeem(uint256 shares, address owner) public withApproval(owner) {\n        investmentManager.requestRedeem(shares, owner);\n        emit RedeemRequested(owner, shares);\n    }\n\n    /// @notice Similar to requestRedeem, but with a permit option.\n    function requestRedeemWithPermit(uint256 shares, address owner, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        public\n    {\n        share.permit(owner, address(investmentManager), shares, deadline, v, r, s);\n        investmentManager.requestRedeem(shares, owner);\n        emit RedeemRequested(owner, shares);\n    }\n\n    /// @notice Request decreasing the outstanding deposit orders. Will return the assets once the order\n    ///         on Centrifuge is successfully decreased.\n    function decreaseDepositRequest(uint256 assets, address owner) public withApproval(owner) {\n        investmentManager.decreaseDepositRequest(assets, owner);\n    }\n\n    /// @notice Request decreasing the outstanding redemption orders. Will return the shares once the order\n    ///         on Centrifuge is successfully decreased.\n    function decreaseRedeemRequest(uint256 shares, address owner) public withApproval(owner) {\n        investmentManager.decreaseRedeemRequest(shares, owner);\n    }\n\n    // --- Miscellaneous investment functions ---\n    /// @notice Trigger collecting the deposited funds.\n    function collectDeposit(address receiver) public {\n        investmentManager.collectDeposit(receiver);\n        emit DepositCollected(receiver);\n    }\n\n    /// @notice Trigger collecting the deposited tokens.\n    function collectRedeem(address receiver) public {\n        investmentManager.collectRedeem(receiver);\n        emit RedeemCollected(receiver);\n    }\n\n    // --- ERC20 overrides ---\n    function name() public view returns (string memory) {\n        return share.name();\n    }\n\n    function symbol() public view returns (string memory) {\n        return share.symbol();\n    }\n\n    function decimals() public view returns (uint8) {\n        return share.decimals();\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return share.totalSupply();\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return share.balanceOf(owner);\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return share.allowance(owner, spender);\n    }\n\n    function transferFrom(address, address, uint256) public returns (bool) {\n        (bool success, bytes memory data) = address(share).call(bytes.concat(msg.data, bytes20(msg.sender)));\n        _successCheck(success);\n        return abi.decode(data, (bool));\n    }\n\n    function transfer(address, uint256) public returns (bool) {\n        (bool success, bytes memory data) = address(share).call(bytes.concat(msg.data, bytes20(msg.sender)));\n        _successCheck(success);\n        return abi.decode(data, (bool));\n    }\n\n    function approve(address, uint256) public returns (bool) {\n        (bool success, bytes memory data) = address(share).call(bytes.concat(msg.data, bytes20(msg.sender)));\n        _successCheck(success);\n        return abi.decode(data, (bool));\n    }\n\n    function mint(address, uint256) public auth {\n        (bool success,) = address(share).call(bytes.concat(msg.data, bytes20(address(this))));\n        _successCheck(success);\n    }\n\n    function burn(address, uint256) public auth {\n        (bool success,) = address(share).call(bytes.concat(msg.data, bytes20(address(this))));\n        _successCheck(success);\n    }\n\n    // --- Pricing ---\n    function updatePrice(uint128 price) public auth {\n        latestPrice = price;\n        lastPriceUpdate = block.timestamp;\n        emit UpdatePrice(price);\n    }\n\n    // --- Restriction overrides ---\n    /// @notice Check if the shares are allowed to be transferred.\n    function checkTransferRestriction(address from, address to, uint256 value) public view returns (bool) {\n        return share.checkTransferRestriction(from, to, value);\n    }\n\n    // --- Helpers ---\n    /// @dev In case of unsuccessful tx, parse the revert message\n    function _successCheck(bool success) internal pure {\n        if (!success) {\n            assembly {\n                let ptr := mload(0x40)\n                let size := returndatasize()\n                returndatacopy(ptr, 0, size)\n                revert(ptr, size)\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/LiquidityPool.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.21;\n\nimport {Auth} from \"./util/Auth.sol\";\nimport {MathLib} from \"./util/MathLib.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport {IERC4626} from \"./interfaces/IERC4626.sol\";\n\ninterface ERC20PermitLike {\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external;\n    function PERMIT_TYPEHASH() external view returns (bytes32);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\ninterface TrancheTokenLike is IERC20, ERC20PermitLike {\n    function checkTransferRestriction(address from, address to, uint256 value) external view returns (bool);\n}\n\ninterface InvestmentManagerLike {\n    function processDeposit(address receiver, uint256 assets) external returns (uint256);\n    function processMint(address receiver, uint256 shares) external returns (uint256);\n    function processWithdraw(uint256 assets, address receiver, address owner) external returns (uint256);\n    function processRedeem(uint256 shares, address receiver, address owner) external returns (uint256);\n    function maxDeposit(address user, address _tranche) external view returns (uint256);\n    function maxMint(address user, address _tranche) external view returns (uint256);\n    function maxWithdraw(address user, address _tranche) external view returns (uint256);\n    function maxRedeem(address user, address _tranche) external view returns (uint256);\n    function totalAssets(uint256 totalSupply, address liquidityPool) external view returns (uint256);\n    function convertToShares(uint256 assets, address liquidityPool) external view returns (uint256);\n    function convertToAssets(uint256 shares, address liquidityPool) external view returns (uint256);\n    function previewDeposit(address user, address liquidityPool, uint256 assets) external view returns (uint256);\n    function previewMint(address user, address liquidityPool, uint256 shares) external view returns (uint256);\n    function previewWithdraw(address user, address liquidityPool, uint256 assets) external view returns (uint256);\n    function previewRedeem(address user, address liquidityPool, uint256 shares) external view returns (uint256);\n    function requestRedeem(uint256 shares, address receiver) external;\n    function requestDeposit(uint256 assets, address receiver) external;\n    function collectDeposit(address receiver) external;\n    function collectRedeem(address receiver) external;\n    function decreaseDepositRequest(uint256 assets, address receiver) external;\n    function decreaseRedeemRequest(uint256 shares, address receiver) external;\n}\n\n/// @title  Liquidity Pool\n/// @notice Liquidity Pool implementation for Centrifuge pools\n///         following the EIP4626 standard, with asynchronous extension methods.\n///\n/// @dev    Each Liquidity Pool is a tokenized vault issuing shares of Centrifuge tranches as restricted ERC20 tokens against currency deposits based on the current share price.\n///         This is extending the EIP4626 standard by 'requestRedeem' & 'requestDeposit' functions, where redeem and deposit orders are submitted to the pools\n///         to be included in the execution of the following epoch. After execution users can use the deposit, mint, redeem and withdraw functions to\n///         get their shares and/or assets from the pools.\ncontract LiquidityPool is Auth, IERC4626 {\n    using MathLib for uint256;\n\n    uint64 public immutable poolId;\n    bytes16 public immutable trancheId;\n\n    /// @notice The investment currency for this Liquidity Pool.\n    ///         Each tranche of a Centrifuge pool can have multiple Liquidity Pools. A Liquidity Pool for each supported asset.\n    ///         Thus tranche shares can be linked to multiple LiquidityPools with different assets.\n    /// @dev    Also known as the investment currency.\n    address public immutable asset;\n\n    /// @notice The restricted ERC-20 Liquidity Pool token. Has a ratio (token price) of underlying assets\n    ///         exchanged on deposit/withdraw/redeem.\n    /// @dev    Also known as tranche tokens.\n    TrancheTokenLike public immutable share;\n\n    InvestmentManagerLike public investmentManager;\n\n    /// @notice Tranche token price, denominated in the asset\n    uint128 public latestPrice;\n\n    /// @notice Timestamp of the last price update\n    uint256 public lastPriceUpdate;\n\n    // --- Events ---\n    event File(bytes32 indexed what, address data);\n    event DepositRequested(address indexed owner, uint256 assets);\n    event RedeemRequested(address indexed owner, uint256 shares);\n    event DepositCollected(address indexed owner);\n    event RedeemCollected(address indexed owner);\n    event UpdatePrice(uint128 price);\n\n    constructor(uint64 poolId_, bytes16 trancheId_, address asset_, address share_, address investmentManager_) {\n        poolId = poolId_;\n        trancheId = trancheId_;\n        asset = asset_;\n        share = TrancheTokenLike(share_);\n        investmentManager = InvestmentManagerLike(investmentManager_);\n\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    /// @dev Either msg.sender is the owner or a ward on the contract\n    modifier withApproval(address owner) {\n        require(msg.sender == owner, \"LiquidityPool/no-approval\");\n        _;\n    }\n\n    // --- Administration ---\n    function file(bytes32 what, address data) public auth {\n        if (what == \"investmentManager\") investmentManager = InvestmentManagerLike(data);\n        else revert(\"LiquidityPool/file-unrecognized-param\");\n        emit File(what, data);\n    }\n\n    // --- ERC4626 functions ---\n    /// @return Total value of the shares, denominated in the asset of this Liquidity Pools\n    function totalAssets() public view returns (uint256) {\n        return investmentManager.totalAssets(totalSupply(), address(this));\n    }\n\n    /// @notice Calculates the amount of shares that any user would approximately get for the amount of assets provided.\n    ///         The calcultion is based on the token price from the most recent epoch retrieved from Centrifuge.\n    ///         The actual conversion will likely differ as the price changes between order submission and execution.\n    function convertToShares(uint256 assets) public view returns (uint256 shares) {\n        shares = investmentManager.convertToShares(assets, address(this));\n    }\n\n    /// @notice Calculates the asset value for an amount of shares provided.\n    ///         The calculation is based on the token price from the most recent epoch retrieved from Centrifuge.\n    ///         The actual conversion will likely differ as the price changes between order submission and execution.\n    function convertToAssets(uint256 shares) public view returns (uint256 assets) {\n        assets = investmentManager.convertToAssets(shares, address(this));\n    }\n\n    /// @return Maximum amount of assets that can be deposited into the Tranche by the receiver after the epoch had been executed on Centrifuge.\n    function maxDeposit(address receiver) public view returns (uint256) {\n        return investmentManager.maxDeposit(receiver, address(this));\n    }\n\n    /// @return shares that any user would get for an amount of assets provided\n    function previewDeposit(uint256 assets) public view returns (uint256 shares) {\n        shares = investmentManager.previewDeposit(msg.sender, address(this), assets);\n    }\n\n    /// @notice Collect shares for deposited assets after Centrifuge epoch execution.\n    ///         maxDeposit is the max amount of shares that can be collected.\n    function deposit(uint256 assets, address receiver) public returns (uint256 shares) {\n        shares = investmentManager.processDeposit(receiver, assets);\n        emit Deposit(address(this), receiver, assets, shares);\n    }\n\n    /// @notice Collect shares for deposited assets after Centrifuge epoch execution.\n    ///         maxMint is the max amount of shares that can be collected.\n    function mint(uint256 shares, address receiver) public returns (uint256 assets) {\n        // require(receiver == msg.sender, \"LiquidityPool/not-authorized-to-mint\");\n        assets = investmentManager.processMint(receiver, shares);\n        emit Deposit(address(this), receiver, assets, shares);\n    }\n\n    /// @notice Maximum amount of shares that can be claimed by the receiver after the epoch has been executed on the Centrifuge side.\n    function maxMint(address receiver) external view returns (uint256 maxShares) {\n        maxShares = investmentManager.maxMint(receiver, address(this));\n    }\n\n    /// @return assets that any user would get for an amount of shares provided -> convertToAssets\n    function previewMint(uint256 shares) external view returns (uint256 assets) {\n        assets = investmentManager.previewMint(msg.sender, address(this), shares);\n    }\n\n    /// @return maxAssets that the receiver can withdraw\n    function maxWithdraw(address receiver) public view returns (uint256 maxAssets) {\n        return investmentManager.maxWithdraw(receiver, address(this));\n    }\n\n    /// @return shares that a user would need to redeem in order to receive the given amount of assets -> convertToAssets\n    function previewWithdraw(uint256 assets) public view returns (uint256 shares) {\n        shares = investmentManager.previewWithdraw(msg.sender, address(this), assets);\n    }\n\n    /// @notice Withdraw assets after successful epoch execution. Receiver will receive an exact amount of assets for a certain amount of shares that has been redeemed from Owner during epoch execution.\n    /// @return shares that have been redeemed for the exact assets amount\n    function withdraw(uint256 assets, address receiver, address owner)\n        public\n        withApproval(owner)\n        returns (uint256 shares)\n    {\n        uint256 sharesRedeemed = investmentManager.processWithdraw(assets, receiver, owner);\n        emit Withdraw(address(this), receiver, owner, assets, sharesRedeemed);\n        return sharesRedeemed;\n    }\n\n    /// @notice Max amount of shares that can be redeemed by the owner after redemption was requested\n    function maxRedeem(address owner) public view returns (uint256 maxShares) {\n        return investmentManager.maxRedeem(owner, address(this));\n    }\n\n    /// @return assets that any user could redeem for a given amount of shares\n    function previewRedeem(uint256 shares) public view returns (uint256 assets) {\n        assets = investmentManager.previewRedeem(msg.sender, address(this), shares);\n    }\n\n    /// @notice Redeem shares after successful epoch execution. Receiver will receive assets for\n    /// @notice Redeem shares can only be called by the Owner or an authorized admin.\n    ///         the exact amount of redeemed shares from Owner after epoch execution.\n    /// @return assets payout for the exact amount of redeemed shares\n    function redeem(uint256 shares, address receiver, address owner)\n        public\n        withApproval(owner)\n        returns (uint256 assets)\n    {\n        uint256 currencyPayout = investmentManager.processRedeem(shares, receiver, owner);\n        emit Withdraw(address(this), receiver, owner, currencyPayout, shares);\n        return currencyPayout;\n    }\n\n    // --- Asynchronous 4626 functions ---\n    /// @notice Request asset deposit for a receiver to be included in the next epoch execution.\n    /// @notice Request can only be called by the Owner of the assets or an authorized admin.\n    ///         Asset is locked in the escrow on request submission\n    function requestDeposit(uint256 assets, address owner) public withApproval(owner) {\n        investmentManager.requestDeposit(assets, owner);\n        emit DepositRequested(owner, assets);\n    }\n\n    /// @notice Similar to requestDeposit, but with a permit option.\n    function requestDepositWithPermit(uint256 assets, address owner, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        public\n    {\n        ERC20PermitLike(asset).permit(owner, address(investmentManager), assets, deadline, v, r, s);\n        investmentManager.requestDeposit(assets, owner);\n        emit DepositRequested(owner, assets);\n    }\n\n    /// @notice Request share redemption for a receiver to be included in the next epoch execution.\n    /// @notice Request can only be called by the Owner of the shares or an authorized admin.\n    ///         Shares are locked in the escrow on request submission\n    function requestRedeem(uint256 shares, address owner) public withApproval(owner) {\n        investmentManager.requestRedeem(shares, owner);\n        emit RedeemRequested(owner, shares);\n    }\n\n    /// @notice Similar to requestRedeem, but with a permit option.\n    function requestRedeemWithPermit(uint256 shares, address owner, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        public\n    {\n        share.permit(owner, address(investmentManager), shares, deadline, v, r, s);\n        investmentManager.requestRedeem(shares, owner);\n        emit RedeemRequested(owner, shares);\n    }\n\n    /// @notice Request decreasing the outstanding deposit orders. Will return the assets once the order\n    ///         on Centrifuge is successfully decreased.\n    function decreaseDepositRequest(uint256 assets, address owner) public withApproval(owner) {\n        investmentManager.decreaseDepositRequest(assets, owner);\n    }\n\n    /// @notice Request decreasing the outstanding redemption orders. Will return the shares once the order\n    ///         on Centrifuge is successfully decreased.\n    function decreaseRedeemRequest(uint256 shares, address owner) public withApproval(owner) {\n        investmentManager.decreaseRedeemRequest(shares, owner);\n    }\n\n    // --- Miscellaneous investment functions ---\n    /// @notice Trigger collecting the deposited funds.\n    function collectDeposit(address receiver) public {\n        investmentManager.collectDeposit(receiver);\n        emit DepositCollected(receiver);\n    }\n\n    /// @notice Trigger collecting the deposited tokens.\n    function collectRedeem(address receiver) public {\n        investmentManager.collectRedeem(receiver);\n        emit RedeemCollected(receiver);\n    }\n\n    // --- ERC20 overrides ---\n    function name() public view returns (string memory) {\n        return share.name();\n    }\n\n    function symbol() public view returns (string memory) {\n        return share.symbol();\n    }\n\n    function decimals() public view returns (uint8) {\n        return share.decimals();\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return share.totalSupply();\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return share.balanceOf(owner);\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return share.allowance(owner, spender);\n    }\n\n    function transferFrom(address, address, uint256) public returns (bool) {\n        (bool success, bytes memory data) = address(share).call(bytes.concat(msg.data, bytes20(msg.sender)));\n        _successCheck(success);\n        return abi.decode(data, (bool));\n    }\n\n    function transfer(address, uint256) public returns (bool) {\n        (bool success, bytes memory data) = address(share).call(bytes.concat(msg.data, bytes20(msg.sender)));\n        _successCheck(success);\n        return abi.decode(data, (bool));\n    }\n\n    function approve(address, uint256) public returns (bool) {\n        (bool success, bytes memory data) = address(share).call(bytes.concat(msg.data, bytes20(msg.sender)));\n        _successCheck(success);\n        return abi.decode(data, (bool));\n    }\n\n    function mint(address, uint256) public auth {\n        (bool success,) = address(share).call(bytes.concat(msg.data, bytes20(address(this))));\n        _successCheck(success);\n    }\n\n    function burn(address, uint256) public auth {\n        (bool success,) = address(share).call(bytes.concat(msg.data, bytes20(address(this))));"
    }
  ]
}