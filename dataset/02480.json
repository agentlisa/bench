{
  "Title": "M-9: Migration can be bricked by sending a message directly to the LegacyMessagePasser",
  "Content": "# Issue M-9: Migration can be bricked by sending a message directly to the LegacyMessagePasser \n\nSource: https://github.com/sherlock-audit/2023-01-optimism-judging/issues/105 \n\n## Found by \n0xdeadbeef, obront, Bobface, unforgiven, xiaoming90\n\n## Summary\n\nThe migration process halts and returns an error if any of the withdrawal data breaks from the specified format. However, the data for this migration comes from every call that has been made to the LegacyMessagePasser (0x00) address, and it is possible to send a transaction that would violate the requirements. The result is that the migration process would be bricked and need to be rebuilt, with some difficult technical challenges that we'll outline below.\n\n## Vulnerability Detail\n\nWithdrawal data is saved in l2geth whenever a call is made to the LegacyMessagePasser address:\n\n```go\nif addr == dump.MessagePasserAddress {\n    statedumper.WriteMessage(caller.Address(), input)\n}\n```\n\nThis will save all the calls that came via the L2CrossDomainMessenger. The expected format for the data is encoded in the L2CrossDomainMessenger. It encodes the calldata to be executed on the L1 side as:\n`abi.encodeWithSignature(\"relayMessage(...)\", target, sender, message, nonce)`\n\nThe migration process expects the calldata to follow this format, and expects the call to come from L2CrossDomainMessenger, implemented with the following two checks:\n\n```go\nselector := crypto.Keccak256([]byte(\"relayMessage(address,address,bytes,uint256)\"))[0:4]\nif !bytes.Equal(data[0:4], selector) {\n    return fmt.Errorf(\"invalid selector: 0x%x\", data[0:4])\n}\n\nmsgSender := data[len(data)-len(predeploys.L2CrossDomainMessengerAddr):]\nif !bytes.Equal(msgSender, predeploys.L2CrossDomainMessengerAddr.Bytes()) {\n    return errors.New(\"invalid msg.sender\")\n}\n```\n\nThe migration process will be exited and the migration will fail if this assumption is violated.\n\nHowever, since the function on the LegacyMessagePasser is public, it can also be called directly with arbitrary calldata:\n\n```solidity\nfunction passMessageToL1(bytes memory _message) external {\n    sentMessages[keccak256(abi.encodePacked(_message, msg.sender))] = true;\n}\n```\n\nThis allows us to submit calldata that would violate both of these checks and cause the migration to panic and fail.\n\nWhile it may seem easy to filter these withdrawals out and rerun the migration, this solution would not work either. That's because, later in the process, we check that easy storage slot in the LegacyMessagePasser contract has a corresponding withdrawal in the migration:\n\n```go\nfor slot := range slotsAct {\n    _, ok := slotsInp[slot]\n    if !ok {\n        return nil, fmt.Errorf(\"unknown storage slot in state: %s\", slot)\n    }\n}\n```\n\nThe result is that the Optimism team would need to unwind the migration, develop a new migration process to account for this issue, and remigrate with an untested system.\n\n## Impact\n\nExploitation of this bug would lead to significant challenges for the Optimism team, needing to run a less tested migration process (which could lead to further issues), and a significant amount of FUD in pausing a partially completed migration partway through. We think that the ability to unexpectedly shut down the migration causes enough structural damage as well as second-order financial damage to warrant high severity.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/l2geth/core/vm/evm.go#L207-L209\n\nhttps://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/op-chain-ops/crossdomain/legacy_withdrawal.go#L58-L66\n\nhttps://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts/contracts/L2/predeploys/OVM_L2ToL1MessagePasser.sol#L29-L34\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRather than throwing an error if withdrawal data doesn't meet the requirements, save a list of these withdrawals and continue. Include this list when prechecking withdrawals to ensure that they are included in the storage slot matching process, but not included in withdrawals to be transferred to the new system.\n\n## Special note\n\nAfter coming up with this attack, we've noticed that someone has [done](https://optimistic.etherscan.io/address/0x4200000000000000000000000000000000000000) exactly what we described and sent a message directly to the MessagePasser! Obviously this TX has nothing to do with us and we want to make sure Optimism is absolutely safe during migration. Furthermore, this TX should be traced and if a contestant is linked to this then they should clearly be disqualified from being rewarded.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/38",
  "Code": [
    {
      "filename": "optimism/l2geth/core/vm/evm.go",
      "content": "// Copyright 2014 The go-ethereum Authors\n// This file is part of the go-ethereum library.\n//\n// The go-ethereum library is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// The go-ethereum library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.\n\npackage vm\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/ethereum-optimism/optimism/l2geth/statedumper\"\n\n\t\"github.com/ethereum-optimism/optimism/l2geth/common\"\n\t\"github.com/ethereum-optimism/optimism/l2geth/crypto\"\n\t\"github.com/ethereum-optimism/optimism/l2geth/params\"\n\t\"github.com/ethereum-optimism/optimism/l2geth/rollup/dump\"\n\t\"github.com/ethereum-optimism/optimism/l2geth/rollup/rcfg\"\n\t\"github.com/ethereum-optimism/optimism/l2geth/rollup/util\"\n\t\"golang.org/x/crypto/sha3\"\n)\n\n// emptyCodeHash is used by create to ensure deployment is disallowed to already\n// deployed contract addresses (relevant after the account abstraction).\nvar emptyCodeHash = crypto.Keccak256Hash(nil)\n\n// mintSigHash is the function signature of mint(address,uint256)\nvar mintSigHash = common.FromHex(\"0x40c10f19\")\n\ntype (\n\t// CanTransferFunc is the signature of a transfer guard function\n\tCanTransferFunc func(StateDB, common.Address, *big.Int) bool\n\t// TransferFunc is the signature of a transfer function\n\tTransferFunc func(StateDB, common.Address, common.Address, *big.Int)\n\t// GetHashFunc returns the n'th block hash in the blockchain\n\t// and is used by the BLOCKHASH EVM op code.\n\tGetHashFunc func(uint64) common.Hash\n)\n\n// run runs the given contract and takes care of running precompiles with a fallback to the byte code interpreter.\nfunc run(evm *EVM, contract *Contract, input []byte, readOnly bool) ([]byte, error) {\n\tif contract.CodeAddr != nil {\n\t\tprecompiles := PrecompiledContractsHomestead\n\t\tif evm.chainRules.IsByzantium {\n\t\t\tprecompiles = PrecompiledContractsByzantium\n\t\t}\n\t\tif evm.chainRules.IsIstanbul {\n\t\t\tprecompiles = PrecompiledContractsIstanbul\n\t\t}\n\t\tif evm.chainRules.IsBerlin {\n\t\t\tprecompiles = PrecompiledContractsBerlin\n\t\t}\n\t\tif p := precompiles[*contract.CodeAddr]; p != nil {\n\t\t\treturn RunPrecompiledContract(p, input, contract)\n\t\t}\n\t}\n\tfor _, interpreter := range evm.interpreters {\n\t\tif interpreter.CanRun(contract.Code) {\n\t\t\tif evm.interpreter != interpreter {\n\t\t\t\t// Ensure that the interpreter pointer is set back\n\t\t\t\t// to its current value upon return.\n\t\t\t\tdefer func(i Interpreter) {\n\t\t\t\t\tevm.interpreter = i\n\t\t\t\t}(evm.interpreter)\n\t\t\t\tevm.interpreter = interpreter\n\t\t\t}\n\t\t\treturn interpreter.Run(contract, input, readOnly)\n\t\t}\n\t}\n\treturn nil, ErrNoCompatibleInterpreter\n}\n\n// Context provides the EVM with auxiliary information. Once provided\n// it shouldn't be modified.\ntype Context struct {\n\t// CanTransfer returns whether the account contains\n\t// sufficient ether to transfer the value\n\tCanTransfer CanTransferFunc\n\t// Transfer transfers ether from one account to the other\n\tTransfer TransferFunc\n\t// GetHash returns the hash corresponding to n\n\tGetHash GetHashFunc\n\n\t// Message information\n\tOrigin   common.Address // Provides information for ORIGIN\n\tGasPrice *big.Int       // Provides information for GASPRICE\n\n\t// Block information\n\tCoinbase    common.Address // Provides information for COINBASE\n\tGasLimit    uint64         // Provides information for GASLIMIT\n\tBlockNumber *big.Int       // Provides information for NUMBER\n\tTime        *big.Int       // Provides information for TIME\n\tDifficulty  *big.Int       // Provides information for DIFFICULTY\n\n\t// OVM information\n\tL1BlockNumber *big.Int // Provides information for L1BLOCKNUMBER\n}\n\n// EVM is the Ethereum Virtual Machine base object and provides\n// the necessary tools to run a contract on the given state with\n// the provided context. It should be noted that any error\n// generated through any of the calls should be considered a\n// revert-state-and-consume-all-gas operation, no checks on\n// specific errors should ever be performed. The interpreter makes\n// sure that any errors generated are to be considered faulty code.\n//\n// The EVM should never be reused and is not thread safe.\ntype EVM struct {\n\t// Context provides auxiliary blockchain related information\n\tContext\n\t// StateDB gives access to the underlying state\n\tStateDB StateDB\n\t// Depth is the current call stack\n\tdepth int\n\n\t// chainConfig contains information about the current chain\n\tchainConfig *params.ChainConfig\n\t// chain rules contains the chain rules for the current epoch\n\tchainRules params.Rules\n\t// virtual machine configuration options used to initialise the\n\t// evm.\n\tvmConfig Config\n\t// global (to this context) ethereum virtual machine\n\t// used throughout the execution of the tx.\n\tinterpreters []Interpreter\n\tinterpreter  Interpreter\n\t// abort is used to abort the EVM calling operations\n\t// NOTE: must be set atomically\n\tabort int32\n\t// callGasTemp holds the gas available for the current call. This is needed because the\n\t// available gas is calculated in gasCall* according to the 63/64 rule and later\n\t// applied in opCall*.\n\tcallGasTemp uint64\n}\n\n// NewEVM returns a new EVM. The returned EVM is not thread safe and should\n// only ever be used *once*.\nfunc NewEVM(ctx Context, statedb StateDB, chainConfig *params.ChainConfig, vmConfig Config) *EVM {\n\tevm := &EVM{\n\t\tContext:      ctx,\n\t\tStateDB:      statedb,\n\t\tvmConfig:     vmConfig,\n\t\tchainConfig:  chainConfig,\n\t\tchainRules:   chainConfig.Rules(ctx.BlockNumber),\n\t\tinterpreters: make([]Interpreter, 0, 1),\n\t}\n\n\tif chainConfig.IsEWASM(ctx.BlockNumber) {\n\t\t// to be implemented by EVM-C and Wagon PRs.\n\t\t// if vmConfig.EWASMInterpreter != \"\" {\n\t\t//  extIntOpts := strings.Split(vmConfig.EWASMInterpreter, \":\")\n\t\t//  path := extIntOpts[0]\n\t\t//  options := []string{}\n\t\t//  if len(extIntOpts) > 1 {\n\t\t//    options = extIntOpts[1..]\n\t\t//  }\n\t\t//  evm.interpreters = append(evm.interpreters, NewEVMVCInterpreter(evm, vmConfig, options))\n\t\t// } else {\n\t\t// \tevm.interpreters = append(evm.interpreters, NewEWASMInterpreter(evm, vmConfig))\n\t\t// }\n\t\tpanic(\"No supported ewasm interpreter yet.\")\n\t}\n\n\t// vmConfig.EVMInterpreter will be used by EVM-C, it won't be checked here\n\t// as we always want to have the built-in EVM as the failover option.\n\tevm.interpreters = append(evm.interpreters, NewEVMInterpreter(evm, vmConfig))\n\tevm.interpreter = evm.interpreters[0]\n\n\treturn evm\n}\n\n// Cancel cancels any running EVM operation. This may be called concurrently and\n// it's safe to be called multiple times.\nfunc (evm *EVM) Cancel() {\n\tatomic.StoreInt32(&evm.abort, 1)\n}\n\n// Cancelled returns true if Cancel has been called\nfunc (evm *EVM) Cancelled() bool {\n\treturn atomic.LoadInt32(&evm.abort) == 1\n}\n\n// Interpreter returns the current interpreter\nfunc (evm *EVM) Interpreter() Interpreter {\n\treturn evm.interpreter\n}\n\n// Call executes the contract associated with the addr with the given input as\n// parameters. It also handles any necessary value transfer required and takes\n// the necessary steps to create accounts and reverses the state in case of an\n// execution error or failed value transfer.\nfunc (evm *EVM) Call(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) {\n\tif addr == dump.MessagePasserAddress {\n\t\tstatedumper.WriteMessage(caller.Address(), input)\n\t}\n\n\tif addr == dump.OvmEthAddress {\n\t\t// We need at least 4 bytes + 32 bytes for the recipient address, then\n\t\t// address will be found at bytes 16-36. 0x40c10f19 is the function\n\t\t// selector for mint(address,uint256).\n\t\tif len(input) >= 36 && bytes.Equal(input[:4], mintSigHash) {\n\t\t\trecipient := common.BytesToAddress(input[16:36])\n\t\t\tstatedumper.WriteETH(recipient)\n\t\t}\n\t}\n\n\tif evm.vmConfig.NoRecursion && evm.depth > 0 {\n\t\treturn nil, gas, nil\n\t}\n\n\t// Fail if we're trying to execute above the call depth limit\n\tif evm.depth > int(params.CallCreateDepth) {\n\t\treturn nil, gas, ErrDepth\n\t}\n\t// Fail if we're trying to transfer more than the available balance\n\tif !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) {\n\t\treturn nil, gas, ErrInsufficientBalance\n\t}\n\n\tvar (\n\t\tto       = AccountRef(addr)\n\t\tsnapshot = evm.StateDB.Snapshot()\n\t)\n\tif !evm.StateDB.Exist(addr) {\n\t\tprecompiles := PrecompiledContractsHomestead\n\t\tif evm.chainRules.IsByzantium {\n\t\t\tprecompiles = PrecompiledContractsByzantium\n\t\t}\n\t\tif evm.chainRules.IsIstanbul {\n\t\t\tprecompiles = PrecompiledContractsIstanbul\n\t\t}\n\t\tif evm.chainRules.IsBerlin {\n\t\t\tprecompiles = PrecompiledContractsBerlin\n\t\t}\n\t\tif precompiles[addr] == nil && evm.chainRules.IsEIP158 && value.Sign() == 0 {\n\t\t\t// Calling a non existing account, don't do anything, but ping the tracer\n\t\t\tif evm.vmConfig.Debug && evm.depth == 0 {\n\t\t\t\tevm.vmConfig.Tracer.CaptureStart(caller.Address(), addr, false, input, gas, value)\n\t\t\t\tevm.vmConfig.Tracer.CaptureEnd(ret, 0, 0, nil)\n\t\t\t}\n\t\t\treturn nil, gas, nil\n\t\t}\n\t\tevm.StateDB.CreateAccount(addr)\n\t}\n\tevm.Transfer(evm.StateDB, caller.Address(), to.Address(), value)\n\t// Initialise a new contract and set the code that is to be used by the EVM.\n\t// The contract is a scoped environment for this execution context only.\n\tcontract := NewContract(caller, to, value, gas)\n\tcontract.SetCallCode(&addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))\n\n\t// Even if the account has no code, we need to continue because it might be a precompile\n\tstart := time.Now()\n\n\t// Capture the tracer start/end events in debug mode\n\tif evm.vmConfig.Debug && evm.depth == 0 {\n\t\tevm.vmConfig.Tracer.CaptureStart(caller.Address(), addr, false, input, gas, value)\n\n\t\tdefer func() { // Lazy evaluation of the parameters\n\t\t\tevm.vmConfig.Tracer.CaptureEnd(ret, gas-contract.Gas, time.Since(start), err)\n\t\t}()\n\t}\n\tret, err = run(evm, contract, input, false)\n\n\t// When an error was returned by the EVM or when setting the creation code\n\t// above we revert to the snapshot and consume any gas remaining. Additionally\n\t// when we're in homestead this also counts for code storage gas errors.\n\tif err != nil {\n\t\tevm.StateDB.RevertToSnapshot(snapshot)\n\t\tif err != errExecutionReverted {\n\t\t\tcontract.UseGas(contract.Gas)\n\t\t}\n\t}\n\treturn ret, contract.Gas, err\n}\n\n// CallCode executes the contract associated with the addr with the given input\n// as parameters. It also handles any necessary value transfer required and takes\n// the necessary steps to create accounts and reverses the state in case of an\n// execution error or failed value transfer.\n//\n// CallCode differs from Call in the sense that it executes the given address'\n// code with the caller as context.\nfunc (evm *EVM) CallCode(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) {\n\tif evm.vmConfig.NoRecursion && evm.depth > 0 {\n\t\treturn nil, gas, nil\n\t}\n\n\t// Fail if we're trying to execute above the call depth limit\n\tif evm.depth > int(params.CallCreateDepth) {\n\t\treturn nil, gas, ErrDepth\n\t}\n\t// Fail if we're trying to transfer more than the available balance\n\tif !evm.CanTransfer(evm.StateDB, caller.Address(), value) {\n\t\treturn nil, gas, ErrInsufficientBalance\n\t}\n\n\tvar (\n\t\tsnapshot = evm.StateDB.Snapshot()\n\t\tto       = AccountRef(caller.Address())\n\t)\n\t// Initialise a new contract and set the code that is to be used by the EVM.\n\t// The contract is a scoped environment for this execution context only.\n\tcontract := NewContract(caller, to, value, gas)\n\tcontract.SetCallCode(&addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))\n\n\tret, err = run(evm, contract, input, false)\n\tif err != nil {\n\t\tevm.StateDB.RevertToSnapshot(snapshot)\n\t\tif err != errExecutionReverted {\n\t\t\tcontract.UseGas(contract.Gas)\n\t\t}\n\t}\n\treturn ret, contract.Gas, err\n}\n\n// DelegateCall executes the contract associated with the addr with the given input\n// as parameters. It reverses the state in case of an execution error.\n//\n// DelegateCall differs from CallCode in the sense that it executes the given address'\n// code with the caller as context and the caller is set to the caller of the caller.\nfunc (evm *EVM) DelegateCall(caller ContractRef, addr common.Address, input []byte, gas uint64) (ret []byte, leftOverGas uint64, err error) {\n\tif evm.vmConfig.NoRecursion && evm.depth > 0 {\n\t\treturn nil, gas, nil\n\t}\n\t// Fail if we're trying to execute above the call depth limit\n\tif evm.depth > int(params.CallCreateDepth) {\n\t\treturn nil, gas, ErrDepth\n\t}\n\n\tvar (\n\t\tsnapshot = evm.StateDB.Snapshot()\n\t\tto       = AccountRef(caller.Address())\n\t)\n\n\t// Initialise a new contract and make initialise the delegate values\n\tcontract := NewContract(caller, to, nil, gas).AsDelegate()\n\tcontract.SetCallCode(&addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))\n\n\tret, err = run(evm, contract, input, false)\n\tif err != nil {\n\t\tevm.StateDB.RevertToSnapshot(snapshot)\n\t\tif err != errExecutionReverted {\n\t\t\tcontract.UseGas(contract.Gas)\n\t\t}\n\t}\n\treturn ret, contract.Gas, err\n}\n\n// StaticCall executes the contract associated with the addr with the given input\n// as parameters while disallowing any modifications to the state during the call.\n// Opcodes that attempt to perform such modifications will result in exceptions\n// instead of performing the modifications.\nfunc (evm *EVM) StaticCall(caller ContractRef, addr common.Address, input []byte, gas uint64) (ret []byte, leftOverGas uint64, err error) {\n\tif evm.vmConfig.NoRecursion && evm.depth > 0 {\n\t\treturn nil, gas, nil\n\t}\n\t// Fail if we're trying to execute above the call depth limit\n\tif evm.depth > int(params.CallCreateDepth) {\n\t\treturn nil, gas, ErrDepth\n\t}\n\n\tvar (\n\t\tto       = AccountRef(addr)\n\t\tsnapshot = evm.StateDB.Snapshot()\n\t)\n\t// Initialise a new contract and set the code that is to be used by the EVM.\n\t// The contract is a scoped environment for this execution context only.\n\tcontract := NewContract(caller, to, new(big.Int), gas)\n\tcontract.SetCallCode(&addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))\n\n\t// We do an AddBalance of zero here, just in order to trigger a touch.\n\t// This doesn't matter on Mainnet, where all empties are gone at the time of Byzantium,\n\t// but is the correct thing to do and matters on other networks, in tests, and potential\n\t// future scenarios\n\tevm.StateDB.AddBalance(addr, bigZero)\n\n\t// When an error was returned by the EVM or when setting the creation code\n\t// above we revert to the snapshot and consume any gas remaining. Additionally\n\t// when we're in Homestead this also counts for code storage gas errors.\n\tret, err = run(evm, contract, input, true)\n\tif err != nil {\n\t\tevm.StateDB.RevertToSnapshot(snapshot)\n\t\tif err != errExecutionReverted {\n\t\t\tcontract.UseGas(contract.Gas)\n\t\t}\n\t}\n\treturn ret, contract.Gas, err\n}\n\ntype codeAndHash struct {\n\tcode []byte\n\thash common.Hash\n}\n\nfunc (c *codeAndHash) Hash() common.Hash {\n\tif c.hash == (common.Hash{}) {\n\t\tc.hash = crypto.Keccak256Hash(c.code)\n\t}\n\treturn c.hash\n}\n\n// create creates a new contract using code as deployment code.\nfunc (evm *EVM) create(caller ContractRef, codeAndHash *codeAndHash, gas uint64, value *big.Int, address common.Address) ([]byte, common.Address, uint64, error) {\n\t// Depth check execution. Fail if we're trying to execute above the\n\t// limit.\n\tif evm.depth > int(params.CallCreateDepth) {\n\t\treturn nil, common.Address{}, gas, ErrDepth\n\t}\n\tif !evm.CanTransfer(evm.StateDB, caller.Address(), value) {\n\t\treturn nil, common.Address{}, gas, ErrInsufficientBalance\n\t}\n\tif rcfg.UsingOVM {\n\t\t// Make sure the creator address should be able to deploy.\n\t\tif !evm.AddressWhitelisted(caller.Address()) {\n\t\t\t// Try to encode this error as a Solidity error message so it's more clear to end-users\n\t\t\t// what's going on when a contract creation fails.\n\t\t\tsolerr := fmt.Errorf(\"deployer address not whitelisted: %s\", caller.Address().Hex())\n\t\t\tret, err := util.EncodeSolidityError(solerr)\n\t\t\tif err != nil {\n\t\t\t\t// If we're unable to properly encode the error then just return the original message.\n\t\t\t\treturn nil, common.Address{}, gas, solerr\n\t\t\t}\n\t\t\treturn ret, common.Address{}, gas, errExecutionReverted\n\t\t}\n\n\t\t// Get the system address for this caller.\n\t\tsysAddr := rcfg.SystemAddressFor(evm.ChainConfig().ChainID, caller.Address())\n\n\t\t// If there is a configured system address for this caller, and the caller's nonce is zero,\n\t\t// and there is no contract already deployed at this system address, then set the created\n\t\t// address to the system address.\n\t\tif sysAddr != rcfg.ZeroSystemAddress && evm.StateDB.GetNonce(caller.Address()) == 0 {\n\t\t\taddress = sysAddr\n\t\t}\n\t}\n\tnonce := evm.StateDB.GetNonce(caller.Address())\n\tevm.StateDB.SetNonce(caller.Address(), nonce+1)\n\t// We add this to the access list _before_ taking a snapshot. Even if the creation fails,\n\t// the access-list change should not be rolled back\n\tif evm.chainRules.IsBerlin {\n\t\tevm.StateDB.AddAddressToAccessList(address)\n\t}\n\t// Ensure there's no existing contract already at the designated address\n\tcontractHash := evm.StateDB.GetCodeHash(address)\n\tif evm.StateDB.GetNonce(address) != 0 || (contractHash != (common.Hash{}) && contractHash != emptyCodeHash) {\n\t\treturn nil, common.Address{}, 0, ErrContractAddressCollision\n\t}\n\t// Create a new account on the state\n\tsnapshot := evm.StateDB.Snapshot()\n\tevm.StateDB.CreateAccount(address)\n\tif evm.chainRules.IsEIP158 {\n\t\tevm.StateDB.SetNonce(address, 1)\n\t}\n\tevm.Transfer(evm.StateDB, caller.Address(), address, value)\n\n\t// Initialise a new contract and set the code that is to be used by the EVM.\n\t// The contract is a scoped environment for this execution context only.\n\tcontract := NewContract(caller, AccountRef(address), value, gas)\n\tcontract.SetCodeOptionalHash(&address, codeAndHash)\n\n\tif evm.vmConfig.NoRecursion && evm.depth > 0 {\n\t\treturn nil, address, gas, nil\n\t}\n\n\tif evm.vmConfig.Debug && evm.depth == 0 {\n\t\tevm.vmConfig.Tracer.CaptureStart(caller.Address(), address, true, codeAndHash.code, gas, value)\n\t}\n\tstart := time.Now()\n\n\tret, err := run(evm, contract, nil, false)\n\n\t// check whether the max code size has been exceeded\n\tmaxCodeSizeExceeded := evm.chainRules.IsEIP158 && len(ret) > params.MaxCodeSize\n\t// if the contract creation ran successfully and no errors were returned\n\t// calculate the gas required to store the code. If the code could not\n\t// be stored due to not enough gas set an error and let it be handled\n\t// by the error checking condition below.\n\tif err == nil && !maxCodeSizeExceeded {\n\t\tcreateDataGas := uint64(len(ret)) * params.CreateDataGas\n\t\tif contract.UseGas(createDataGas) {\n\t\t\tevm.StateDB.SetCode(address, ret)\n\t\t} else {\n\t\t\terr = ErrCodeStoreOutOfGas\n\t\t}\n\t}\n\n\t// When an error was returned by the EVM or when setting the creation code\n\t// above we revert to the snapshot and consume any gas remaining. Additionally\n\t// when we're in homestead this also counts for code storage gas errors.\n\tif maxCodeSizeExceeded || (err != nil && (evm.chainRules.IsHomestead || err != ErrCodeStoreOutOfGas)) {\n\t\tevm.StateDB.RevertToSnapshot(snapshot)\n\t\tif err != errExecutionReverted {\n\t\t\tcontract.UseGas(contract.Gas)\n\t\t}\n\t}\n\t// Assign err if contract code size exceeds the max while the err is still empty.\n\tif maxCodeSizeExceeded && err == nil {\n\t\terr = errMaxCodeSizeExceeded\n\t}\n\tif evm.vmConfig.Debug && evm.depth == 0 {\n\t\tevm.vmConfig.Tracer.CaptureEnd(ret, gas-contract.Gas, time.Since(start), err)\n\t}\n\treturn ret, address, contract.Gas, err\n\n}\n\n// Create creates a new contract using code as deployment code.\nfunc (evm *EVM) Create(caller ContractRef, code []byte, gas uint64, value *big.Int) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) {\n\tcontractAddr = crypto.CreateAddress(caller.Address(), evm.StateDB.GetNonce(caller.Address()))\n\treturn evm.create(caller, &codeAndHash{code: code}, gas, value, contractAddr)\n}\n\n// Create2 creates a new contract using code as deployment code.\n//\n// The different between Create2 with Create is Create2 uses sha3(0xff ++ msg.sender ++ salt ++ sha3(init_code))[12:]\n// instead of the usual sender-and-nonce-hash as the address where the contract is initialized at.\nfunc (evm *EVM) Create2(caller ContractRef, code []byte, gas uint64, endowment *big.Int, salt *big.Int) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) {\n\tcodeAndHash := &codeAndHash{code: code}\n\tcontractAddr = crypto.CreateAddress2(caller.Address(), common.BigToHash(salt), codeAndHash.Hash().Bytes())\n\treturn evm.create(caller, codeAndHash, gas, endowment, contractAddr)\n}\n\n// ChainConfig returns the environment's chain configuration\nfunc (evm *EVM) ChainConfig() *params.ChainConfig { return evm.chainConfig }\n\nfunc (evm *EVM) AddressWhitelisted(addr common.Address) bool {\n\t// First check if the owner is address(0), which implicitly disables the whitelist.\n\townerKey := common.Hash{}\n\towner := evm.StateDB.GetState(dump.OvmWhitelistAddress, ownerKey)\n\tif (owner == common.Hash{}) {\n\t\treturn true\n\t}\n\n\t// Next check if the user is whitelisted by resolving the position where the\n\t// true/false value would be.\n\tposition := common.Big1\n\thasher := sha3.NewLegacyKeccak256()\n\thasher.Write(common.LeftPadBytes(addr.Bytes(), 32))\n\thasher.Write(common.LeftPadBytes(position.Bytes(), 32))\n\tdigest := hasher.Sum(nil)\n\tkey := common.BytesToHash(digest)\n\tisWhitelisted := evm.StateDB.GetState(dump.OvmWhitelistAddress, key)\n\treturn isWhitelisted != common.Hash{}\n}"
    },
    {
      "filename": "optimism/op-chain-ops/crossdomain/legacy_withdrawal.go",
      "content": "package crossdomain\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/big\"\n\n\t\"github.com/ethereum-optimism/optimism/op-bindings/bindings\"\n\t\"github.com/ethereum-optimism/optimism/op-bindings/predeploys\"\n\t\"github.com/ethereum/go-ethereum/accounts/abi\"\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/crypto\"\n)\n\n// LegacyWithdrawal represents a pre bedrock upgrade withdrawal.\ntype LegacyWithdrawal struct {\n\tTarget *common.Address `json:\"target\"`\n\tSender *common.Address `json:\"sender\"`\n\tData   []byte          `json:\"data\"`\n\tNonce  *big.Int        `json:\"nonce\"`\n}\n\nvar _ WithdrawalMessage = (*LegacyWithdrawal)(nil)\n\n// NewLegacyWithdrawal will construct a LegacyWithdrawal\nfunc NewLegacyWithdrawal(target, sender *common.Address, data []byte, nonce *big.Int) *LegacyWithdrawal {\n\treturn &LegacyWithdrawal{\n\t\tTarget: target,\n\t\tSender: sender,\n\t\tData:   data,\n\t\tNonce:  nonce,\n\t}\n}\n\n// Encode will serialze the Withdrawal in the legacy format so that it\n// is suitable for hashing. This assumes that the message is being withdrawn\n// through the standard optimism cross domain messaging system by hashing in\n// the L2CrossDomainMessenger address.\nfunc (w *LegacyWithdrawal) Encode() ([]byte, error) {\n\tenc, err := EncodeCrossDomainMessageV0(w.Target, w.Sender, w.Data, w.Nonce)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot encode LegacyWithdrawal: %w\", err)\n\t}\n\n\tout := make([]byte, len(enc)+len(predeploys.L2CrossDomainMessengerAddr.Bytes()))\n\tcopy(out, enc)\n\tcopy(out[len(enc):], predeploys.L2CrossDomainMessengerAddr.Bytes())\n\treturn out, nil\n}\n\n// Decode will decode a serialized LegacyWithdrawal\nfunc (w *LegacyWithdrawal) Decode(data []byte) error {\n\tif len(data) < len(predeploys.L2CrossDomainMessengerAddr)+4 {\n\t\treturn fmt.Errorf(\"withdrawal data too short: %d\", len(data))\n\t}\n\n\tselector := crypto.Keccak256([]byte(\"relayMessage(address,address,bytes,uint256)\"))[0:4]\n\tif !bytes.Equal(data[0:4], selector) {\n\t\treturn fmt.Errorf(\"invalid selector: 0x%x\", data[0:4])\n\t}\n\n\tmsgSender := data[len(data)-len(predeploys.L2CrossDomainMessengerAddr):]\n\tif !bytes.Equal(msgSender, predeploys.L2CrossDomainMessengerAddr.Bytes()) {\n\t\treturn errors.New(\"invalid msg.sender\")\n\t}\n\n\traw := data[4 : len(data)-len(predeploys.L2CrossDomainMessengerAddr)]\n\n\targs := abi.Arguments{\n\t\t{Name: \"target\", Type: AddressType},\n\t\t{Name: \"sender\", Type: AddressType},\n\t\t{Name: \"data\", Type: BytesType},\n\t\t{Name: \"nonce\", Type: Uint256Type},\n\t}\n\n\tdecoded, err := args.Unpack(raw)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttarget, ok := decoded[0].(common.Address)\n\tif !ok {\n\t\treturn errors.New(\"cannot abi decode target\")\n\t}\n\tsender, ok := decoded[1].(common.Address)\n\tif !ok {\n\t\treturn errors.New(\"cannot abi decode sender\")\n\t}\n\tmsgData, ok := decoded[2].([]byte)\n\tif !ok {\n\t\treturn errors.New(\"cannot abi decode data\")\n\t}\n\tnonce, ok := decoded[3].(*big.Int)\n\tif !ok {\n\t\treturn errors.New(\"cannot abi decode nonce\")\n\t}\n\n\tw.Target = &target\n\tw.Sender = &sender\n\tw.Data = msgData\n\tw.Nonce = nonce\n\treturn nil\n}\n\n// Hash will compute the legacy style hash that is computed in the\n// OVM_L2ToL1MessagePasser.\nfunc (w *LegacyWithdrawal) Hash() (common.Hash, error) {\n\tencoded, err := w.Encode()\n\tif err != nil {\n\t\treturn common.Hash{}, fmt.Errorf(\"cannot hash LegacyWithdrawal: %w\", err)\n\t}\n\thash := crypto.Keccak256(encoded)\n\treturn common.BytesToHash(hash), nil\n}\n\n// StorageSlot will compute the storage slot that is set\n// to true in the legacy L2ToL1MessagePasser.\nfunc (w *LegacyWithdrawal) StorageSlot() (common.Hash, error) {\n\thash, err := w.Hash()\n\tif err != nil {\n\t\treturn common.Hash{}, fmt.Errorf(\"cannot compute storage slot: %w\", err)\n\t}\n\tpreimage := make([]byte, 64)\n\tcopy(preimage, hash.Bytes())\n\n\tslot := crypto.Keccak256(preimage)\n\treturn common.BytesToHash(slot), nil\n}\n\n// Value returns the ETH value associated with the withdrawal. Since\n// ETH was represented as an ERC20 token before the Bedrock upgrade,\n// the sender and calldata must be observed and the value must be parsed\n// out if \"finalizeETHWithdrawal\" is the method.\nfunc (w *LegacyWithdrawal) Value() (*big.Int, error) {\n\tabi, err := bindings.L1StandardBridgeMetaData.GetAbi()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvalue := new(big.Int)\n\n\t// Parse the 4byte selector\n\tmethod, err := abi.MethodById(w.Data)\n\t// If it is an unknown selector, there is no value\n\tif err != nil {\n\t\treturn value, nil\n\t}\n\n\tif w.Sender == nil {\n\t\treturn nil, errors.New(\"sender is nil\")\n\t}\n\n\tisFromL2StandardBridge := *w.Sender == predeploys.L2StandardBridgeAddr\n\tif isFromL2StandardBridge && method.Name == \"finalizeETHWithdrawal\" {\n\t\tdata, err := method.Inputs.Unpack(w.Data[4:])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// bounds check\n\t\tif len(data) < 3 {\n\t\t\treturn nil, errors.New(\"not enough data\")\n\t\t}\n\t\tvar ok bool\n\t\tvalue, ok = data[2].(*big.Int)\n\t\tif !ok {\n\t\t\treturn nil, errors.New(\"not big.Int\")\n\t\t}\n\t}\n\n\treturn value, nil\n}"
    },
    {
      "filename": "optimism/packages/contracts/contracts/L2/predeploys/OVM_L2ToL1MessagePasser.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Interface Imports */\nimport { iOVM_L2ToL1MessagePasser } from \"./iOVM_L2ToL1MessagePasser.sol\";\n\n/**\n * @title OVM_L2ToL1MessagePasser\n * @dev The L2 to L1 Message Passer is a utility contract which facilitate an L1 proof of the\n * of a message on L2. The L1 Cross Domain Messenger performs this proof in its\n * _verifyStorageProof function, which verifies the existence of the transaction hash in this\n * contract's `sentMessages` mapping.\n */\ncontract OVM_L2ToL1MessagePasser is iOVM_L2ToL1MessagePasser {\n    /**********************\n     * Contract Variables *\n     **********************/\n\n    mapping(bytes32 => bool) public sentMessages;\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @inheritdoc iOVM_L2ToL1MessagePasser\n     */\n    // slither-disable-next-line external-function\n    function passMessageToL1(bytes memory _message) public {\n        // Note: although this function is public, only messages sent from the\n        // L2CrossDomainMessenger will be relayed by the L1CrossDomainMessenger.\n        // This is enforced by a check in L1CrossDomainMessenger._verifyStorageProof().\n        sentMessages[keccak256(abi.encodePacked(_message, msg.sender))] = true;\n    }\n}"
    }
  ]
}