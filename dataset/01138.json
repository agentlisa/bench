{
  "Title": "Misleading and Incorrect Comments",
  "Content": "Throughout the code, we found several comments that were either misleading or incorrect. Some examples are:\n\n\n* This [comment](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L1/gateways/L1ERC20Gateway.sol#L128C14-L128C32) in `ScrollMessengerBase` suggests moving the declaration of `_lock_status` to `ScrollMessengerBase` in the next big refactor, which has already been done.\n* The comments on lines [36](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L1/rollup/L1MessageQueue.sol#L102) and [172](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L1/gateways/L1CustomERC20Gateway.sol) in `L1ERC721Gateway` should say `_l2Token` instead of `_l1Token`.\n* The [comment on line 134](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L1/gateways/L1CustomERC20Gateway.sol#L122) in `L2USDCGateway.sol` should say `L2GatewayRouter` instead of `L1GatewayRouter`.\n\n\nConsider resolving these instances of incorrect documentation to improve the clarity and readability of the codebase.\n\n\n***Update:** Resolved in [pull request #851](https://github.com/scroll-tech/scroll/pull/851) at commit [b933adb](https://github.com/scroll-tech/scroll/pull/851/commits/b933adb279290665c362f3d264dec52733d34348).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/L1/gateways/L1ERC20Gateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IL1ERC20Gateway} from \"./IL1ERC20Gateway.sol\";\nimport {IL1GatewayRouter} from \"./IL1GatewayRouter.sol\";\n\nimport {ScrollGatewayBase} from \"../../libraries/gateway/ScrollGatewayBase.sol\";\n\nimport {IL2ERC20Gateway} from \"../../L2/gateways/IL2ERC20Gateway.sol\";\nimport {IScrollMessenger} from \"../../libraries/IScrollMessenger.sol\";\nimport {ScrollConstants} from \"../../libraries/constants/ScrollConstants.sol\";\nimport {ScrollGatewayBase} from \"../../libraries/gateway/ScrollGatewayBase.sol\";\nimport {IMessageDropCallback} from \"../../libraries/callbacks/IMessageDropCallback.sol\";\n\n// solhint-disable no-empty-blocks\n\nabstract contract L1ERC20Gateway is IL1ERC20Gateway, IMessageDropCallback, ScrollGatewayBase {\n    using SafeERC20 for IERC20;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @dev The storage slots for future usage.\n    uint256[50] private __gap;\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        _deposit(_token, msg.sender, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        _deposit(_token, _to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) external payable override {\n        _deposit(_token, _to, _amount, _data, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function finalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable override onlyCallByCounterpart nonReentrant {\n        _beforeFinalizeWithdrawERC20(_l1Token, _l2Token, _from, _to, _amount, _data);\n\n        // @note can possible trigger reentrant call to this contract or messenger,\n        // but it seems not a big problem.\n        IERC20(_l1Token).safeTransfer(_to, _amount);\n\n        _doCallback(_to, _data);\n\n        emit FinalizeWithdrawERC20(_l1Token, _l2Token, _from, _to, _amount, _data);\n    }\n\n    /// @inheritdoc IMessageDropCallback\n    function onDropMessage(bytes calldata _message) external payable virtual onlyInDropContext nonReentrant {\n        // _message should start with 0x8431f5c1  =>  finalizeDepositERC20(address,address,address,address,uint256,bytes)\n        require(bytes4(_message[0:4]) == IL2ERC20Gateway.finalizeDepositERC20.selector, \"invalid selector\");\n\n        // decode (token, receiver, amount)\n        (address _token, , address _receiver, , uint256 _amount, ) = abi.decode(\n            _message[4:],\n            (address, address, address, address, uint256, bytes)\n        );\n\n        // do dome check for each custom gateway\n        _beforeDropMessage(_token, _receiver, _amount);\n\n        IERC20(_token).safeTransfer(_receiver, _amount);\n\n        emit RefundERC20(_token, _receiver, _amount);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function hook to perform checks and actions before finalizing the withdrawal.\n    /// @param _l1Token The address of corresponding L1 token in L1.\n    /// @param _l2Token The address of corresponding L2 token in L2.\n    /// @param _from The address of account who withdraw the token in L2.\n    /// @param _to The address of recipient in L1 to receive the token.\n    /// @param _amount The amount of the token to withdraw.\n    /// @param _data Optional data to forward to recipient's account.\n    function _beforeFinalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) internal virtual;\n\n    /// @dev Internal function hook to perform checks and actions before dropping the message.\n    /// @param _token The L1 token address.\n    /// @param _receiver The recipient address on L1.\n    /// @param _amount The amount of token to refund.\n    function _beforeDropMessage(\n        address _token,\n        address _receiver,\n        uint256 _amount\n    ) internal virtual;\n\n    /// @dev Internal function to transfer ERC20 token to this contract.\n    /// @param _token The address of token to transfer.\n    /// @param _amount The amount of token to transfer.\n    /// @param _data The data passed by caller.\n    function _transferERC20In(\n        address _token,\n        uint256 _amount,\n        bytes memory _data\n    )\n        internal\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        address _from = msg.sender;\n        if (router == msg.sender) {\n            // Extract real sender if this call is from L1GatewayRouter.\n            (_from, _data) = abi.decode(_data, (address, bytes));\n            _amount = IL1GatewayRouter(msg.sender).requestERC20(_from, _token, _amount);\n        } else {\n            // common practice to handle fee on transfer token.\n            uint256 _before = IERC20(_token).balanceOf(address(this));\n            IERC20(_token).safeTransferFrom(_from, address(this), _amount);\n            uint256 _after = IERC20(_token).balanceOf(address(this));\n            // no unchecked here, since some weird token may return arbitrary balance.\n            _amount = _after - _before;\n        }\n        // ignore weird fee on transfer token\n        require(_amount > 0, \"deposit zero amount\");\n\n        return (_from, _amount, _data);\n    }\n\n    /// @dev Internal function to do all the deposit operations.\n    ///\n    /// @param _token The token to deposit.\n    /// @param _to The recipient address to recieve the token in L2.\n    /// @param _amount The amount of token to deposit.\n    /// @param _data Optional data to forward to recipient's account.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function _deposit(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) internal virtual;\n}"
    },
    {
      "filename": "contracts/src/L1/rollup/L1MessageQueue.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.16;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {IL2GasPriceOracle} from \"./IL2GasPriceOracle.sol\";\nimport {IL1MessageQueue} from \"./IL1MessageQueue.sol\";\n\nimport {AddressAliasHelper} from \"../../libraries/common/AddressAliasHelper.sol\";\n\n// solhint-disable no-empty-blocks\n// solhint-disable no-inline-assembly\n// solhint-disable reason-string\n\n/// @title L1MessageQueue\n/// @notice This contract will hold all L1 to L2 messages.\n/// Each appended message is assigned with a unique and increasing `uint256` index.\ncontract L1MessageQueue is OwnableUpgradeable, IL1MessageQueue {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address _oldGasOracle, address _newGasOracle);\n\n    /// @notice Emitted when owner updates EnforcedTxGateway contract.\n    /// @param _oldGateway The address of old EnforcedTxGateway contract.\n    /// @param _newGateway The address of new EnforcedTxGateway contract.\n    event UpdateEnforcedTxGateway(address _oldGateway, address _newGateway);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of L1ScrollMessenger contract.\n    address public messenger;\n\n    /// @notice The address of ScrollChain contract.\n    address public scrollChain;\n\n    /// @notice The address EnforcedTxGateway contract.\n    address public enforcedTxGateway;\n\n    /// @notice The address of GasOracle contract.\n    address public gasOracle;\n\n    /// @notice The list of queued cross domain messages.\n    bytes32[] public messageQueue;\n\n    /// @inheritdoc IL1MessageQueue\n    uint256 public pendingQueueIndex;\n\n    /// @notice The max gas limit of L1 transactions.\n    uint256 public maxGasLimit;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier onlyMessenger() {\n        require(msg.sender == messenger, \"Only callable by the L1ScrollMessenger\");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _messenger,\n        address _scrollChain,\n        address _enforcedTxGateway,\n        address _gasOracle,\n        uint256 _maxGasLimit\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        messenger = _messenger;\n        scrollChain = _scrollChain;\n        enforcedTxGateway = _enforcedTxGateway;\n        gasOracle = _gasOracle;\n        maxGasLimit = _maxGasLimit;\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1MessageQueue\n    function nextCrossDomainMessageIndex() external view returns (uint256) {\n        return messageQueue.length;\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function getCrossDomainMessage(uint256 _queueIndex) external view returns (bytes32) {\n        return messageQueue[_queueIndex];\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function estimateCrossDomainMessageFee(uint256 _gasLimit) external view override returns (uint256) {\n        address _oracle = gasOracle;\n        if (_oracle == address(0)) return 0;\n        return IL2GasPriceOracle(_oracle).estimateCrossDomainMessageFee(_gasLimit);\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function calculateIntrinsicGasFee(bytes memory _calldata) public view override returns (uint256) {\n        address _oracle = gasOracle;\n        if (_oracle == address(0)) return 0;\n        return IL2GasPriceOracle(_oracle).calculateIntrinsicGasFee(_calldata);\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function computeTransactionHash(\n        address _sender,\n        uint256 _queueIndex,\n        uint256 _value,\n        address _target,\n        uint256 _gasLimit,\n        bytes calldata _data\n    ) public pure override returns (bytes32) {\n        // We use EIP-2718 to encode the L1 message, and the encoding of the message is\n        //      `TransactionType || TransactionPayload`\n        // where\n        //  1. `TransactionType` is 0x7E\n        //  2. `TransactionPayload` is `rlp([queueIndex, gasLimit, to, value, data, sender])`\n        //\n        // The spec of rlp: https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/\n        uint256 transactionType = 0x7E;\n        bytes32 hash;\n        assembly {\n            function get_uint_bytes(v) -> len {\n                if eq(v, 0) {\n                    len := 1\n                    leave\n                }\n                for {\n\n                } gt(v, 0) {\n\n                } {\n                    len := add(len, 1)\n                    v := shr(8, v)\n                }\n            }\n\n            // This is used for both store uint and single byte.\n            // Integer zero is special handled by geth to encode as `0x80`\n            function store_uint_or_byte(_ptr, v, is_uint) -> ptr {\n                ptr := _ptr\n                switch lt(v, 128)\n                case 1 {\n                    switch and(iszero(v), is_uint)\n                    case 1 {\n                        // integer 0\n                        mstore8(ptr, 0x80)\n                    }\n                    default {\n                        // single byte in the [0x00, 0x7f]\n                        mstore8(ptr, v)\n                    }\n                    ptr := add(ptr, 1)\n                }\n                default {\n                    // 1-32 bytes long\n                    let len := get_uint_bytes(v)\n                    mstore8(ptr, add(len, 0x80))\n                    ptr := add(ptr, 1)\n                    mstore(ptr, shl(mul(8, sub(32, len)), v))\n                    ptr := add(ptr, len)\n                }\n            }\n\n            function store_address(_ptr, v) -> ptr {\n                ptr := _ptr\n                // 20 bytes long\n                mstore8(ptr, 0x94) // 0x80 + 0x14\n                ptr := add(ptr, 1)\n                mstore(ptr, shl(96, v))\n                ptr := add(ptr, 0x14)\n            }\n\n            // 1 byte for TransactionType\n            // 4 byte for list payload length\n            let start_ptr := add(mload(0x40), 5)\n            let ptr := start_ptr\n            ptr := store_uint_or_byte(ptr, _queueIndex, 1)\n            ptr := store_uint_or_byte(ptr, _gasLimit, 1)\n            ptr := store_address(ptr, _target)\n            ptr := store_uint_or_byte(ptr, _value, 1)\n\n            switch eq(_data.length, 1)\n            case 1 {\n                // single byte\n                ptr := store_uint_or_byte(ptr, byte(0, calldataload(_data.offset)), 0)\n            }\n            default {\n                switch lt(_data.length, 56)\n                case 1 {\n                    // a string is 0-55 bytes long\n                    mstore8(ptr, add(0x80, _data.length))\n                    ptr := add(ptr, 1)\n                    calldatacopy(ptr, _data.offset, _data.length)\n                    ptr := add(ptr, _data.length)\n                }\n                default {\n                    // a string is more than 55 bytes long\n                    let len_bytes := get_uint_bytes(_data.length)\n                    mstore8(ptr, add(0xb7, len_bytes))\n                    ptr := add(ptr, 1)\n                    mstore(ptr, shl(mul(8, sub(32, len_bytes)), _data.length))\n                    ptr := add(ptr, len_bytes)\n                    calldatacopy(ptr, _data.offset, _data.length)\n                    ptr := add(ptr, _data.length)\n                }\n            }\n            ptr := store_address(ptr, _sender)\n\n            let payload_len := sub(ptr, start_ptr)\n            let value\n            let value_bytes\n            switch lt(payload_len, 56)\n            case 1 {\n                // the total payload of a list is 0-55 bytes long\n                value := add(0xc0, payload_len)\n                value_bytes := 1\n            }\n            default {\n                // If the total payload of a list is more than 55 bytes long\n                let len_bytes := get_uint_bytes(payload_len)\n                value_bytes := add(len_bytes, 1)\n                value := add(0xf7, len_bytes)\n                value := shl(mul(len_bytes, 8), value)\n                value := or(value, payload_len)\n            }\n            value := or(value, shl(mul(8, value_bytes), transactionType))\n            value_bytes := add(value_bytes, 1)\n            let value_bits := mul(8, value_bytes)\n            value := or(shl(sub(256, value_bits), value), shr(value_bits, mload(start_ptr)))\n            start_ptr := sub(start_ptr, value_bytes)\n            mstore(start_ptr, value)\n            hash := keccak256(start_ptr, sub(ptr, start_ptr))\n        }\n        return hash;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1MessageQueue\n    function appendCrossDomainMessage(\n        address _target,\n        uint256 _gasLimit,\n        bytes calldata _data\n    ) external override onlyMessenger {\n        // validate gas limit\n        _validateGasLimit(_gasLimit, _data);\n\n        // do address alias to avoid replay attack in L2.\n        address _sender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n\n        _queueTransaction(_sender, _target, 0, _gasLimit, _data);\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function appendEnforcedTransaction(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes calldata _data\n    ) external override {\n        require(msg.sender == enforcedTxGateway, \"Only callable by the EnforcedTxGateway\");\n        // We will check it in EnforcedTxGateway, just in case.\n        require(_sender.code.length == 0, \"only EOA\");\n\n        // validate gas limit\n        _validateGasLimit(_gasLimit, _data);\n\n        _queueTransaction(_sender, _target, _value, _gasLimit, _data);\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function popCrossDomainMessage(\n        uint256 _startIndex,\n        uint256 _count,\n        uint256 _skippedBitmap\n    ) external {\n        require(msg.sender == scrollChain, \"Only callable by the ScrollChain\");\n\n        require(_count <= 256, \"pop too many messages\");\n        require(pendingQueueIndex == _startIndex, \"start index mismatch\");\n\n        unchecked {\n            for (uint256 i = 0; i < _count; i++) {\n                if ((_skippedBitmap >> i) & 1 == 0) {\n                    messageQueue[_startIndex + i] = bytes32(0);\n                }\n            }\n\n            pendingQueueIndex = _startIndex + _count;\n        }\n\n        emit DequeueTransaction(_startIndex, _count, _skippedBitmap);\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function dropCrossDomainMessage(uint256 _index) external onlyMessenger {\n        require(_index < pendingQueueIndex, \"cannot drop pending message\");\n        require(messageQueue[_index] != bytes32(0), \"message already dropped or executed\");\n\n        messageQueue[_index] = bytes32(0);\n\n        emit DropTransaction(_index);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the address of gas oracle.\n    /// @dev This function can only called by contract owner.\n    /// @param _newGasOracle The address to update.\n    function updateGasOracle(address _newGasOracle) external onlyOwner {\n        address _oldGasOracle = gasOracle;\n        gasOracle = _newGasOracle;\n\n        emit UpdateGasOracle(_oldGasOracle, _newGasOracle);\n    }\n\n    /// @notice Update the address of EnforcedTxGateway.\n    /// @dev This function can only called by contract owner.\n    /// @param _newGateway The address to update.\n    function updateEnforcedTxGateway(address _newGateway) external onlyOwner {\n        address _oldGateway = enforcedTxGateway;\n        enforcedTxGateway = _newGateway;\n\n        emit UpdateEnforcedTxGateway(_oldGateway, _newGateway);\n    }\n\n    /// @notice Update the max gas limit.\n    /// @dev This function can only called by contract owner.\n    /// @param _newMaxGasLimit The new max gas limit.\n    function updateMaxGasLimit(uint256 _newMaxGasLimit) external onlyOwner {\n        uint256 _oldMaxGasLimit = maxGasLimit;\n        maxGasLimit = _newMaxGasLimit;\n\n        emit UpdateMaxGasLimit(_oldMaxGasLimit, _newMaxGasLimit);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to queue a L1 transaction.\n    /// @param _sender The address of sender who will initiate this transaction in L2.\n    /// @param _target The address of target contract to call in L2.\n    /// @param _value The value passed\n    /// @param _gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param _data The calldata passed to target contract.\n    function _queueTransaction(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes calldata _data\n    ) internal {\n        // compute transaction hash\n        uint256 _queueIndex = messageQueue.length;\n        bytes32 _hash = computeTransactionHash(_sender, _queueIndex, _value, _target, _gasLimit, _data);\n        messageQueue.push(_hash);\n\n        // emit event\n        emit QueueTransaction(_sender, _target, _value, uint64(_queueIndex), _gasLimit, _data);\n    }\n\n    function _validateGasLimit(uint256 _gasLimit, bytes memory _calldata) internal view {\n        require(_gasLimit <= maxGasLimit, \"Gas limit must not exceed maxGasLimit\");\n        // check if the gas limit is above intrinsic gas\n        uint256 intrinsicGas = calculateIntrinsicGasFee(_calldata);\n        require(_gasLimit >= intrinsicGas, \"Insufficient gas limit, must be above intrinsic gas\");\n    }\n}"
    },
    {
      "filename": "contracts/src/L1/gateways/L1CustomERC20Gateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.16;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {IL2ERC20Gateway} from \"../../L2/gateways/IL2ERC20Gateway.sol\";\nimport {IL1ScrollMessenger} from \"../IL1ScrollMessenger.sol\";\nimport {IL1ERC20Gateway} from \"./IL1ERC20Gateway.sol\";\n\nimport {ScrollGatewayBase} from \"../../libraries/gateway/ScrollGatewayBase.sol\";\nimport {L1ERC20Gateway} from \"./L1ERC20Gateway.sol\";\n\n/// @title L1CustomERC20Gateway\n/// @notice The `L1CustomERC20Gateway` is used to deposit custom ERC20 compatible tokens in layer 1 and\n/// finalize withdraw the tokens from layer 2.\n/// @dev The deposited tokens are held in this gateway. On finalizing withdraw, the corresponding\n/// tokens will be transfer to the recipient directly.\ncontract L1CustomERC20Gateway is OwnableUpgradeable, ScrollGatewayBase, L1ERC20Gateway {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when token mapping for ERC20 token is updated.\n    /// @param _l1Token The address of ERC20 token in layer 1.\n    /// @param _l2Token The address of corresponding ERC20 token in layer 2.\n    event UpdateTokenMapping(address _l1Token, address _l2Token);\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from l1 token address to l2 token address for ERC20 token.\n    mapping(address => address) public tokenMapping;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the storage of L1CustomERC20Gateway.\n    /// @param _counterpart The address of L2CustomERC20Gateway in L2.\n    /// @param _router The address of L1GatewayRouter.\n    /// @param _messenger The address of L1ScrollMessenger.\n    function initialize(\n        address _counterpart,\n        address _router,\n        address _messenger\n    ) external initializer {\n        require(_router != address(0), \"zero router address\");\n\n        OwnableUpgradeable.__Ownable_init();\n        ScrollGatewayBase._initialize(_counterpart, _router, _messenger);\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function getL2ERC20Address(address _l1Token) public view override returns (address) {\n        return tokenMapping[_l1Token];\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update layer 1 to layer 2 token mapping.\n    /// @param _l1Token The address of ERC20 token in layer 1.\n    /// @param _l2Token The address of corresponding ERC20 token in layer 2.\n    function updateTokenMapping(address _l1Token, address _l2Token) external onlyOwner {\n        require(_l2Token != address(0), \"token address cannot be 0\");\n\n        tokenMapping[_l1Token] = _l2Token;\n\n        emit UpdateTokenMapping(_l1Token, _l2Token);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @inheritdoc L1ERC20Gateway\n    function _beforeFinalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) internal virtual override {\n        require(msg.value == 0, \"nonzero msg.value\");\n        require(_l2Token != address(0), \"token address cannot be 0\");\n        require(_l2Token == tokenMapping[_l1Token], \"l2 token mismatch\");\n    }\n\n    /// @inheritdoc L1ERC20Gateway\n    function _beforeDropMessage(\n        address,\n        address,\n        uint256\n    ) internal virtual override {\n        require(msg.value == 0, \"nonzero msg.value\");\n    }\n\n    /// @inheritdoc L1ERC20Gateway\n    function _deposit(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) internal virtual override nonReentrant {\n        address _l2Token = tokenMapping[_token];\n        require(_l2Token != address(0), \"no corresponding l2 token\");\n\n        // 1. Transfer token into this contract.\n        address _from;\n        (_from, _amount, _data) = _transferERC20In(_token, _amount, _data);\n\n        // 2. Generate message passed to L2CustomERC20Gateway.\n        bytes memory _message = abi.encodeCall(\n            IL2ERC20Gateway.finalizeDepositERC20,\n            (_token, _l2Token, _from, _to, _amount, _data)\n        );\n\n        // 3. Send message to L1ScrollMessenger.\n        IL1ScrollMessenger(messenger).sendMessage{value: msg.value}(counterpart, 0, _message, _gasLimit, _from);\n\n        emit DepositERC20(_token, _l2Token, _from, _to, _amount, _data);\n    }\n}"
    }
  ]
}