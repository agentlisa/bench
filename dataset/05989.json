{
  "Title": "[07] Possible reverse order of `if else` logic",
  "Content": "The order of the `if else` logic seems to have been reversed. Depending on the values of `_emissionRate.unwrap()` and `_emissionRate` involved, this could be crucial enough to make the function truncate to zero when `_emissionRate` was more than one (1e18) and used as the divisor. On the other hand, the function could also overflow when `_emissionRate` was less than one and used as the divisor. If that's the case, I suggest removing the `if` clause and keep only the `else` clause (with one of the parentheses removed) that will cater to both circumstances.\n\nhttps://github.com/GenerationSoftware/pt-v5-cgda-liquidator/blob/7f95bcacd4a566c2becb98d55c1886cadbaa8897/src/libraries/ContinuousGDA.sol#L38-L42\n\n```diff\n-    if (_emissionRate.unwrap() > 1e18) {\n-      result = _k.div(_emissionRate).mul(topE).div(bottomE);\n-    } else {\n-      result = _k.mul(topE.div(_emissionRate.mul(bottomE)));\n+      result = _k.mul.topE.div(_emissionRate.mul(bottomE));\n-    }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-08-pooltogether",
  "Code": [
    {
      "filename": "src/libraries/ContinuousGDA.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport { SD59x18, convert, unwrap } from \"prb-math/SD59x18.sol\";\n\n/// @title ContinuousGDA\n/// @author G9 Software Inc.\n/// @notice Implements the Continous Gradual Dutch Auction formula\n/// See https://www.paradigm.xyz/2022/04/gda\n/// @dev Pricing formula adapted from https://github.com/FrankieIsLost/gradual-dutch-auction/blob/master/src/ContinuousGDA.sol\nlibrary ContinuousGDA {\n\n  /// @notice a helpful constant\n  SD59x18 internal constant ONE = SD59x18.wrap(1e18);\n\n  /// @notice Calculate purchase price for a given amount of tokens\n  /// @param _amount The amount of tokens to purchase\n  /// @param _emissionRate The emission rate of the CGDA\n  /// @param _k The initial price of the CGDA\n  /// @param _decayConstant The decay constant of the CGDA\n  /// @param _timeSinceLastAuctionStart The elapsed time since the last consumed timestamp\n  /// @return The purchase price for the given amount of tokens\n  function purchasePrice(\n    SD59x18 _amount,\n    SD59x18 _emissionRate,\n    SD59x18 _k,\n    SD59x18 _decayConstant,\n    SD59x18 _timeSinceLastAuctionStart\n  ) internal pure returns (SD59x18) {\n    if (_amount.unwrap() == 0) {\n      return SD59x18.wrap(0);\n    }\n    SD59x18 topE = _decayConstant.mul(_amount).div(_emissionRate);\n    topE = topE.exp().sub(ONE);\n    SD59x18 bottomE = _decayConstant.mul(_timeSinceLastAuctionStart);\n    bottomE = bottomE.exp();\n    SD59x18 result;\n    if (_emissionRate.unwrap() > 1e18) {\n      result = _k.div(_emissionRate).mul(topE).div(bottomE);\n    } else {\n      result = _k.mul(topE.div(_emissionRate.mul(bottomE)));\n    }\n    return result;\n  }\n\n  /// @notice Computes the amount of tokens that can be purchased for a given price\n  /// @dev Note that this formula has significant floating point differences to the above. Either one, not both, should be used.\n  /// @param _price The price willing to be paid\n  /// @param _emissionRate The emission rate of the CGDA\n  /// @param _k The initial price of the CGDA\n  /// @param _decayConstant The decay constant of the CGDA\n  /// @param _timeSinceLastAuctionStart The elapsed time since the last consumed timestamp\n  /// @return The number of tokens that can be purchased for the given price\n  function purchaseAmount(\n    SD59x18 _price,\n    SD59x18 _emissionRate,\n    SD59x18 _k,\n    SD59x18 _decayConstant,\n    SD59x18 _timeSinceLastAuctionStart\n  ) internal pure returns (SD59x18) {\n    if (_price.unwrap() == 0) {\n      return SD59x18.wrap(0);\n    }\n    SD59x18 exp = _decayConstant.mul(_timeSinceLastAuctionStart).exp();\n    SD59x18 lnParam = _k.add(_price.mul(_emissionRate).mul(exp)).div(_k);\n    SD59x18 numerator = _emissionRate.mul(lnParam.ln());\n    SD59x18 amount = numerator.div(_decayConstant);\n    return amount;\n  }\n\n  /// @notice Computes an initial price for the CGDA such that the purchase amount will cost the price at the given timestamp\n  /// @param _emissionRate The emission rate of the CGDA\n  /// @param _decayConstant The decay constant of the CGDA\n  /// @param _targetFirstSaleTime The timestamp at which the CGDA price for the given amount matches the given price\n  /// @param _purchaseAmount The amount of tokens to purchase\n  /// @param _price The price to be paid for the amount of tokens\n  function computeK(\n    SD59x18 _emissionRate,\n    SD59x18 _decayConstant,\n    SD59x18 _targetFirstSaleTime,\n    SD59x18 _purchaseAmount,\n    SD59x18 _price\n  ) internal pure returns (SD59x18) {\n    SD59x18 exponent = _decayConstant.mul(_targetFirstSaleTime);\n    SD59x18 eValue = exponent.exp();\n    SD59x18 multiplier = _emissionRate.mul(_price);\n    SD59x18 denominator = (_decayConstant.mul(_purchaseAmount).div(_emissionRate)).exp().sub(ONE);\n    SD59x18 result = eValue.div(denominator);\n    return result.mul(multiplier);\n  }\n}"
    }
  ]
}