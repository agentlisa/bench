{
  "Title": "[H-06] Discrepency in the Uniswap V3 position price calculation because of decimals",
  "Content": "\nWhen the squared root of the Uniswap V3 position is calculated from the [`_getOracleData()` function](https://github.com/code-423n4/2022-11-paraspace/blob/main/paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol#L221-L280), the price may return a very high number (in the case that the token1 decimals are strictly superior to the token0 decimals). See: <https://github.com/code-423n4/2022-11-paraspace/blob/main/paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol#L249-L260>\n\nThe reason is that at the denominator, the `1E9` (10&ast;&ast;9) value is hard-coded, but should take into account the delta between both decimals.<br>\nAs a result, in the case of `token1Decimal > token0Decimal`, the [`getAmountsForLiquidity()`](https://github.com/code-423n4/2022-11-paraspace/blob/main/paraspace-core/contracts/dependencies/uniswap/LiquidityAmounts.sol#L172-L205) is going to return a huge value for the amount of token0 and token1 as the user position liquidity.\n\nThe [`getTokenPrice()`](https://github.com/code-423n4/2022-11-paraspace/blob/main/paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol#L156), using this amount of liquidity to [calculate the token price](https://github.com/code-423n4/2022-11-paraspace/blob/main/paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol#L176-L180) is as its turn going to return a huge value.\n\n### Proof of Concept\n\nThis POC demonstrates in which case the returned squared root price of the position is over inflated\n\n```solidity\n// SPDX-License-Identifier: UNLISENCED\npragma solidity 0.8.10;\n\nimport {SqrtLib} from \"../contracts/dependencies/math/SqrtLib.sol\";\nimport \"forge-std/Test.sol\";\n\ncontract Audit is Test {\n    function testSqrtPriceX96() public {\n        // ok\n        uint160 price1 = getSqrtPriceX96(1e18, 5 * 1e18, 18, 18);\n\n        // ok\n        uint160 price2 = getSqrtPriceX96(1e18, 5 * 1e18, 18, 9);\n\n        // Has an over-inflated squared root price by 9 magnitudes as token0Decimal < token1Decimal\n        uint160 price3 = getSqrtPriceX96(1e18, 5 * 1e18, 9, 18);\n    }\n\n    function getSqrtPriceX96(\n        uint256 token0Price,\n        uint256 token1Price,\n        uint256 token0Decimal,\n        uint256 token1Decimal\n    ) private view returns (uint160 sqrtPriceX96) {\n        if (oracleData.token1Decimal == oracleData.token0Decimal) {\n            // multiply by 10^18 then divide by 10^9 to preserve price in wei\n            sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(((token0Price * (10**18)) / (token1Price))) *\n                    2**96) / 1E9\n            );\n        } else if (token1Decimal > token0Decimal) {\n            // multiple by 10^(decimalB - decimalA) to preserve price in wei\n            sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(\n                    (token0Price * (10**(18 + token1Decimal - token0Decimal))) /\n                        (token1Price)\n                ) * 2**96) / 1E9\n            );\n        } else {\n            // multiple by 10^(decimalA - decimalB) to preserve price in wei then divide by the same number\n            sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(\n                    (token0Price * (10**(18 + token0Decimal - token1Decimal))) /\n                        (token1Price)\n                ) * 2**96) / 10**(9 + token0Decimal - token1Decimal)\n            );\n        }\n    }\n}\n```\n\n### Recommended Mitigation Steps\n\n```solidity\n        if (oracleData.token1Decimal == oracleData.token0Decimal) {\n            // multiply by 10^18 then divide by 10^9 to preserve price in wei\n            oracleData.sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(\n                    ((oracleData.token0Price * (10**18)) /\n                        (oracleData.token1Price))\n                ) * 2**96) / 1E9\n            );\n        } else if (oracleData.token1Decimal > oracleData.token0Decimal) {\n            // multiple by 10^(decimalB - decimalA) to preserve price in wei\n            oracleData.sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(\n                    (oracleData.token0Price *\n                        (10 **\n                            (18 +\n                                oracleData.token1Decimal -\n                                oracleData.token0Decimal))) /\n                        (oracleData.token1Price)\n                ) * 2**96) /\n                    10 **\n                        (9 +\n                            oracleData.token1Decimal -\n                            oracleData.token0Decimal)\n            );\n        } else {\n            // multiple by 10^(decimalA - decimalB) to preserve price in wei then divide by the same number\n            oracleData.sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(\n                    (oracleData.token0Price *\n                        (10 **\n                            (18 +\n                                oracleData.token0Decimal -\n                                oracleData.token1Decimal))) /\n                        (oracleData.token1Price)\n                ) * 2**96) /\n                    10 **\n                        (9 +\n                            oracleData.token0Decimal -\n                            oracleData.token1Decimal)\n            );\n        }\n```\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-11-paraspace-contest",
  "Code": [
    {
      "filename": "paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IUniswapV3OracleWrapper} from \"../interfaces/IUniswapV3OracleWrapper.sol\";\nimport {IPoolAddressesProvider} from \"../interfaces/IPoolAddressesProvider.sol\";\nimport {IPriceOracleGetter} from \"../interfaces/IPriceOracleGetter.sol\";\nimport {IUniswapV3Factory} from \"../dependencies/uniswap/IUniswapV3Factory.sol\";\nimport {IUniswapV3PoolState} from \"../dependencies/uniswap/IUniswapV3PoolState.sol\";\nimport {INonfungiblePositionManager} from \"../dependencies/uniswap/INonfungiblePositionManager.sol\";\nimport {LiquidityAmounts} from \"../dependencies/uniswap/LiquidityAmounts.sol\";\nimport {TickMath} from \"../dependencies/uniswap/libraries/TickMath.sol\";\nimport {SqrtLib} from \"../dependencies/math/SqrtLib.sol\";\nimport {FullMath} from \"../dependencies/uniswap/libraries/FullMath.sol\";\nimport {IERC20Detailed} from \"../dependencies/openzeppelin/contracts/IERC20Detailed.sol\";\nimport {UinswapV3PositionData} from \"../interfaces/IUniswapV3PositionInfoProvider.sol\";\n\ncontract UniswapV3OracleWrapper is IUniswapV3OracleWrapper {\n    IUniswapV3Factory immutable UNISWAP_V3_FACTORY;\n    INonfungiblePositionManager immutable UNISWAP_V3_POSITION_MANAGER;\n    IPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\n\n    constructor(\n        address _factory,\n        address _manager,\n        address _addressProvider\n    ) {\n        UNISWAP_V3_FACTORY = IUniswapV3Factory(_factory);\n        UNISWAP_V3_POSITION_MANAGER = INonfungiblePositionManager(_manager);\n        ADDRESSES_PROVIDER = IPoolAddressesProvider(_addressProvider);\n    }\n\n    struct FeeParams {\n        uint256 feeGrowthOutside0X128Lower;\n        uint256 feeGrowthOutside1X128Lower;\n        uint256 feeGrowthOutside0X128Upper;\n        uint256 feeGrowthOutside1X128Upper;\n    }\n\n    struct PairOracleData {\n        uint256 token0Price;\n        uint256 token1Price;\n        uint8 token0Decimal;\n        uint8 token1Decimal;\n        uint160 sqrtPriceX96;\n    }\n\n    /**\n     * @notice get onchain position data from uniswap for the specified tokenId.\n     */\n    function getOnchainPositionData(uint256 tokenId)\n        public\n        view\n        returns (UinswapV3PositionData memory)\n    {\n        (\n            ,\n            ,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint256 tokensOwed0,\n            uint256 tokensOwed1\n        ) = UNISWAP_V3_POSITION_MANAGER.positions(tokenId);\n\n        IUniswapV3PoolState pool = IUniswapV3PoolState(\n            UNISWAP_V3_FACTORY.getPool(token0, token1, fee)\n        );\n        (uint160 currentPrice, int24 currentTick, , , , , ) = pool.slot0();\n\n        return\n            UinswapV3PositionData({\n                token0: token0,\n                token1: token1,\n                fee: fee,\n                tickLower: tickLower,\n                tickUpper: tickUpper,\n                currentTick: currentTick,\n                currentPrice: currentPrice,\n                liquidity: liquidity,\n                feeGrowthInside0LastX128: feeGrowthInside0LastX128,\n                feeGrowthInside1LastX128: feeGrowthInside1LastX128,\n                tokensOwed0: tokensOwed0,\n                tokensOwed1: tokensOwed1\n            });\n    }\n\n    /**\n     * @notice get onchain liquidity amount for the specified tokenId.\n     */\n    function getLiquidityAmount(uint256 tokenId)\n        external\n        view\n        returns (uint256 token0Amount, uint256 token1Amount)\n    {\n        UinswapV3PositionData memory positionData = getOnchainPositionData(\n            tokenId\n        );\n        (token0Amount, token1Amount) = getLiquidityAmountFromPositionData(\n            positionData\n        );\n    }\n\n    /**\n     * @notice calculate liquidity amount for the position data.\n     * @param positionData The specified position data\n     */\n    function getLiquidityAmountFromPositionData(\n        UinswapV3PositionData memory positionData\n    ) public pure returns (uint256 token0Amount, uint256 token1Amount) {\n        (token0Amount, token1Amount) = LiquidityAmounts.getAmountsForLiquidity(\n            positionData.currentPrice,\n            TickMath.getSqrtRatioAtTick(positionData.tickLower),\n            TickMath.getSqrtRatioAtTick(positionData.tickUpper),\n            positionData.liquidity\n        );\n    }\n\n    /**\n     * @notice get liquidity provider fee amount for the specified tokenId.\n     */\n    function getLpFeeAmount(uint256 tokenId)\n        external\n        view\n        returns (uint256 token0Amount, uint256 token1Amount)\n    {\n        UinswapV3PositionData memory positionData = getOnchainPositionData(\n            tokenId\n        );\n        (token0Amount, token1Amount) = getLpFeeAmountFromPositionData(\n            positionData\n        );\n    }\n\n    /**\n     * @notice calculate liquidity provider fee amount for the position data.\n     * @param positionData The specified position data\n     */\n    function getLpFeeAmountFromPositionData(\n        UinswapV3PositionData memory positionData\n    ) public view returns (uint256 token0Amount, uint256 token1Amount) {\n        (token0Amount, token1Amount) = _getPendingFeeAmounts(positionData);\n\n        token0Amount += positionData.tokensOwed0;\n        token1Amount += positionData.tokensOwed1;\n    }\n\n    /**\n     * @notice Returns the price for the specified tokenId.\n     */\n    function getTokenPrice(uint256 tokenId) public view returns (uint256) {\n        UinswapV3PositionData memory positionData = getOnchainPositionData(\n            tokenId\n        );\n\n        PairOracleData memory oracleData = _getOracleData(positionData);\n\n        (uint256 liquidityAmount0, uint256 liquidityAmount1) = LiquidityAmounts\n            .getAmountsForLiquidity(\n                oracleData.sqrtPriceX96,\n                TickMath.getSqrtRatioAtTick(positionData.tickLower),\n                TickMath.getSqrtRatioAtTick(positionData.tickUpper),\n                positionData.liquidity\n            );\n\n        (\n            uint256 feeAmount0,\n            uint256 feeAmount1\n        ) = getLpFeeAmountFromPositionData(positionData);\n\n        return\n            (((liquidityAmount0 + feeAmount0) * oracleData.token0Price) /\n                10**oracleData.token0Decimal) +\n            (((liquidityAmount1 + feeAmount1) * oracleData.token1Price) /\n                10**oracleData.token1Decimal);\n    }\n\n    /**\n     * @notice Returns the price for the specified tokenId array.\n     */\n    function getTokensPrices(uint256[] calldata tokenIds)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory prices = new uint256[](tokenIds.length);\n\n        for (uint256 index = 0; index < tokenIds.length; index++) {\n            prices[index] = getTokenPrice(tokenIds[index]);\n        }\n\n        return prices;\n    }\n\n    /**\n     * @notice Returns the total price for the specified tokenId array.\n     */\n    function getTokensPricesSum(uint256[] calldata tokenIds)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 sum = 0;\n\n        for (uint256 index = 0; index < tokenIds.length; index++) {\n            sum += getTokenPrice(tokenIds[index]);\n        }\n\n        return sum;\n    }\n\n    function latestAnswer() external pure returns (int256) {\n        revert(\"unimplemented\");\n    }\n\n    function _getOracleData(UinswapV3PositionData memory positionData)\n        internal\n        view\n        returns (PairOracleData memory)\n    {\n        PairOracleData memory oracleData;\n        IPriceOracleGetter oracle = IPriceOracleGetter(\n            ADDRESSES_PROVIDER.getPriceOracle()\n        );\n        oracleData.token0Price = oracle.getAssetPrice(positionData.token0);\n        oracleData.token1Price = oracle.getAssetPrice(positionData.token1);\n\n        oracleData.token0Decimal = IERC20Detailed(positionData.token0)\n            .decimals();\n        oracleData.token1Decimal = IERC20Detailed(positionData.token1)\n            .decimals();\n\n        // TODO using bit shifting for the 2^96\n        // positionData.sqrtPriceX96;\n\n        if (oracleData.token1Decimal == oracleData.token0Decimal) {\n            // multiply by 10^18 then divide by 10^9 to preserve price in wei\n            oracleData.sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(\n                    ((oracleData.token0Price * (10**18)) /\n                        (oracleData.token1Price))\n                ) * 2**96) / 1E9\n            );\n        } else if (oracleData.token1Decimal > oracleData.token0Decimal) {\n            // multiple by 10^(decimalB - decimalA) to preserve price in wei\n            oracleData.sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(\n                    (oracleData.token0Price *\n                        (10 **\n                            (18 +\n                                oracleData.token1Decimal -\n                                oracleData.token0Decimal))) /\n                        (oracleData.token1Price)\n                ) * 2**96) / 1E9\n            );\n        } else {\n            // multiple by 10^(decimalA - decimalB) to preserve price in wei then divide by the same number\n            oracleData.sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(\n                    (oracleData.token0Price *\n                        (10 **\n                            (18 +\n                                oracleData.token0Decimal -\n                                oracleData.token1Decimal))) /\n                        (oracleData.token1Price)\n                ) * 2**96) /\n                    10 **\n                        (9 +\n                            oracleData.token0Decimal -\n                            oracleData.token1Decimal)\n            );\n        }\n\n        return oracleData;\n    }\n\n    function _getPendingFeeAmounts(UinswapV3PositionData memory positionData)\n        internal\n        view\n        returns (uint256 token0Amount, uint256 token1Amount)\n    {\n        IUniswapV3PoolState pool = IUniswapV3PoolState(\n            UNISWAP_V3_FACTORY.getPool(\n                positionData.token0,\n                positionData.token1,\n                positionData.fee\n            )\n        );\n        FeeParams memory feeParams;\n\n        (\n            ,\n            ,\n            feeParams.feeGrowthOutside0X128Lower,\n            feeParams.feeGrowthOutside1X128Lower,\n            ,\n            ,\n            ,\n\n        ) = pool.ticks(positionData.tickLower);\n        (\n            ,\n            ,\n            feeParams.feeGrowthOutside0X128Upper,\n            feeParams.feeGrowthOutside1X128Upper,\n            ,\n            ,\n            ,\n\n        ) = pool.ticks(positionData.tickUpper);\n\n        uint256 feeGrowthGlobal0X128 = pool.feeGrowthGlobal0X128();\n        uint256 feeGrowthGlobal1X128 = pool.feeGrowthGlobal1X128();\n\n        unchecked {\n            // calculate fee growth below\n            uint256 feeGrowthBelow0X128;\n            uint256 feeGrowthBelow1X128;\n            if (positionData.currentTick >= positionData.tickLower) {\n                feeGrowthBelow0X128 = feeParams.feeGrowthOutside0X128Lower;\n                feeGrowthBelow1X128 = feeParams.feeGrowthOutside1X128Lower;\n            } else {\n                feeGrowthBelow0X128 =\n                    feeGrowthGlobal0X128 -\n                    feeParams.feeGrowthOutside0X128Lower;\n                feeGrowthBelow1X128 =\n                    feeGrowthGlobal1X128 -\n                    feeParams.feeGrowthOutside1X128Lower;\n            }\n\n            // calculate fee growth above\n            uint256 feeGrowthAbove0X128;\n            uint256 feeGrowthAbove1X128;\n            if (positionData.currentTick < positionData.tickUpper) {\n                feeGrowthAbove0X128 = feeParams.feeGrowthOutside0X128Upper;\n                feeGrowthAbove1X128 = feeParams.feeGrowthOutside1X128Upper;\n            } else {\n                feeGrowthAbove0X128 =\n                    feeGrowthGlobal0X128 -\n                    feeParams.feeGrowthOutside0X128Upper;\n                feeGrowthAbove1X128 =\n                    feeGrowthGlobal1X128 -\n                    feeParams.feeGrowthOutside1X128Upper;\n            }\n            uint256 feeGrowthInside0X128;\n            uint256 feeGrowthInside1X128;\n\n            feeGrowthInside0X128 =\n                feeGrowthGlobal0X128 -\n                feeGrowthBelow0X128 -\n                feeGrowthAbove0X128;\n            feeGrowthInside1X128 =\n                feeGrowthGlobal1X128 -\n                feeGrowthBelow1X128 -\n                feeGrowthAbove1X128;\n\n            token0Amount = uint128(\n                FullMath.mulDiv(\n                    feeGrowthInside0X128 -\n                        positionData.feeGrowthInside0LastX128,\n                    positionData.liquidity,\n                    Q128\n                )\n            );\n\n            token1Amount = uint128(\n                FullMath.mulDiv(\n                    feeGrowthInside1X128 -\n                        positionData.feeGrowthInside1LastX128,\n                    positionData.liquidity,\n                    Q128\n                )\n            );\n        }\n    }\n}"
    },
    {
      "filename": "paraspace-core/contracts/dependencies/uniswap/LiquidityAmounts.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport \"./libraries/FullMath.sol\";\nimport \"./libraries/FixedPoint96.sol\";\n\n/// @title Liquidity amount functions\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\nlibrary LiquidityAmounts {\n    /// @notice Downcasts uint256 to uint128\n    /// @param x The uint258 to be downcasted\n    /// @return y The passed value, downcasted to uint128\n    function toUint128(uint256 x) private pure returns (uint128 y) {\n        require((y = uint128(x)) == x);\n    }\n\n    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\n    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param amount0 The amount0 being sent in\n    /// @return liquidity The amount of returned liquidity\n    function getLiquidityForAmount0(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint256 amount0\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtRatioAX96 > sqrtRatioBX96)\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        uint256 intermediate = FullMath.mulDiv(\n            sqrtRatioAX96,\n            sqrtRatioBX96,\n            FixedPoint96.Q96\n        );\n        unchecked {\n            return\n                toUint128(\n                    FullMath.mulDiv(\n                        amount0,\n                        intermediate,\n                        sqrtRatioBX96 - sqrtRatioAX96\n                    )\n                );\n        }\n    }\n\n    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\n    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param amount1 The amount1 being sent in\n    /// @return liquidity The amount of returned liquidity\n    function getLiquidityForAmount1(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint256 amount1\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtRatioAX96 > sqrtRatioBX96)\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        unchecked {\n            return\n                toUint128(\n                    FullMath.mulDiv(\n                        amount1,\n                        FixedPoint96.Q96,\n                        sqrtRatioBX96 - sqrtRatioAX96\n                    )\n                );\n        }\n    }\n\n    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\n    /// pool prices and the prices at the tick boundaries\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param amount0 The amount of token0 being sent in\n    /// @param amount1 The amount of token1 being sent in\n    /// @return liquidity The maximum amount of liquidity received\n    function getLiquidityForAmounts(\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint256 amount0,\n        uint256 amount1\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtRatioAX96 > sqrtRatioBX96)\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\n            liquidity = getLiquidityForAmount0(\n                sqrtRatioAX96,\n                sqrtRatioBX96,\n                amount0\n            );\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\n            uint128 liquidity0 = getLiquidityForAmount0(\n                sqrtRatioX96,\n                sqrtRatioBX96,\n                amount0\n            );\n            uint128 liquidity1 = getLiquidityForAmount1(\n                sqrtRatioAX96,\n                sqrtRatioX96,\n                amount1\n            );\n\n            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\n        } else {\n            liquidity = getLiquidityForAmount1(\n                sqrtRatioAX96,\n                sqrtRatioBX96,\n                amount1\n            );\n        }\n    }\n\n    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount0 The amount of token0\n    function getAmount0ForLiquidity(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount0) {\n        unchecked {\n            if (sqrtRatioAX96 > sqrtRatioBX96)\n                (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n            return\n                FullMath.mulDiv(\n                    uint256(liquidity) << FixedPoint96.RESOLUTION,\n                    sqrtRatioBX96 - sqrtRatioAX96,\n                    sqrtRatioBX96\n                ) / sqrtRatioAX96;\n        }\n    }\n\n    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount1 The amount of token1\n    function getAmount1ForLiquidity(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount1) {\n        if (sqrtRatioAX96 > sqrtRatioBX96)\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        unchecked {\n            return\n                FullMath.mulDiv(\n                    liquidity,\n                    sqrtRatioBX96 - sqrtRatioAX96,\n                    FixedPoint96.Q96\n                );\n        }\n    }\n\n    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\n    /// pool prices and the prices at the tick boundaries\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount0 The amount of token0\n    /// @return amount1 The amount of token1\n    function getAmountsForLiquidity(\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\n        if (sqrtRatioAX96 > sqrtRatioBX96)\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\n            amount0 = getAmount0ForLiquidity(\n                sqrtRatioAX96,\n                sqrtRatioBX96,\n                liquidity\n            );\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\n            amount0 = getAmount0ForLiquidity(\n                sqrtRatioX96,\n                sqrtRatioBX96,\n                liquidity\n            );\n            amount1 = getAmount1ForLiquidity(\n                sqrtRatioAX96,\n                sqrtRatioX96,\n                liquidity\n            );\n        } else {\n            amount1 = getAmount1ForLiquidity(\n                sqrtRatioAX96,\n                sqrtRatioBX96,\n                liquidity\n            );\n        }\n    }\n}"
    },
    {
      "filename": "paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IUniswapV3OracleWrapper} from \"../interfaces/IUniswapV3OracleWrapper.sol\";\nimport {IPoolAddressesProvider} from \"../interfaces/IPoolAddressesProvider.sol\";\nimport {IPriceOracleGetter} from \"../interfaces/IPriceOracleGetter.sol\";\nimport {IUniswapV3Factory} from \"../dependencies/uniswap/IUniswapV3Factory.sol\";\nimport {IUniswapV3PoolState} from \"../dependencies/uniswap/IUniswapV3PoolState.sol\";\nimport {INonfungiblePositionManager} from \"../dependencies/uniswap/INonfungiblePositionManager.sol\";\nimport {LiquidityAmounts} from \"../dependencies/uniswap/LiquidityAmounts.sol\";\nimport {TickMath} from \"../dependencies/uniswap/libraries/TickMath.sol\";\nimport {SqrtLib} from \"../dependencies/math/SqrtLib.sol\";\nimport {FullMath} from \"../dependencies/uniswap/libraries/FullMath.sol\";\nimport {IERC20Detailed} from \"../dependencies/openzeppelin/contracts/IERC20Detailed.sol\";\nimport {UinswapV3PositionData} from \"../interfaces/IUniswapV3PositionInfoProvider.sol\";\n\ncontract UniswapV3OracleWrapper is IUniswapV3OracleWrapper {\n    IUniswapV3Factory immutable UNISWAP_V3_FACTORY;\n    INonfungiblePositionManager immutable UNISWAP_V3_POSITION_MANAGER;\n    IPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\n\n    constructor(\n        address _factory,\n        address _manager,\n        address _addressProvider\n    ) {\n        UNISWAP_V3_FACTORY = IUniswapV3Factory(_factory);\n        UNISWAP_V3_POSITION_MANAGER = INonfungiblePositionManager(_manager);\n        ADDRESSES_PROVIDER = IPoolAddressesProvider(_addressProvider);\n    }\n\n    struct FeeParams {\n        uint256 feeGrowthOutside0X128Lower;\n        uint256 feeGrowthOutside1X128Lower;\n        uint256 feeGrowthOutside0X128Upper;\n        uint256 feeGrowthOutside1X128Upper;\n    }\n\n    struct PairOracleData {\n        uint256 token0Price;\n        uint256 token1Price;\n        uint8 token0Decimal;\n        uint8 token1Decimal;\n        uint160 sqrtPriceX96;\n    }\n\n    /**\n     * @notice get onchain position data from uniswap for the specified tokenId.\n     */\n    function getOnchainPositionData(uint256 tokenId)\n        public\n        view\n        returns (UinswapV3PositionData memory)\n    {\n        (\n            ,\n            ,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint256 tokensOwed0,\n            uint256 tokensOwed1\n        ) = UNISWAP_V3_POSITION_MANAGER.positions(tokenId);\n\n        IUniswapV3PoolState pool = IUniswapV3PoolState(\n            UNISWAP_V3_FACTORY.getPool(token0, token1, fee)\n        );\n        (uint160 currentPrice, int24 currentTick, , , , , ) = pool.slot0();\n\n        return\n            UinswapV3PositionData({\n                token0: token0,\n                token1: token1,\n                fee: fee,\n                tickLower: tickLower,\n                tickUpper: tickUpper,\n                currentTick: currentTick,\n                currentPrice: currentPrice,\n                liquidity: liquidity,\n                feeGrowthInside0LastX128: feeGrowthInside0LastX128,\n                feeGrowthInside1LastX128: feeGrowthInside1LastX128,\n                tokensOwed0: tokensOwed0,\n                tokensOwed1: tokensOwed1\n            });\n    }\n\n    /**\n     * @notice get onchain liquidity amount for the specified tokenId.\n     */\n    function getLiquidityAmount(uint256 tokenId)\n        external\n        view\n        returns (uint256 token0Amount, uint256 token1Amount)\n    {\n        UinswapV3PositionData memory positionData = getOnchainPositionData(\n            tokenId\n        );\n        (token0Amount, token1Amount) = getLiquidityAmountFromPositionData(\n            positionData\n        );\n    }\n\n    /**\n     * @notice calculate liquidity amount for the position data.\n     * @param positionData The specified position data\n     */\n    function getLiquidityAmountFromPositionData(\n        UinswapV3PositionData memory positionData\n    ) public pure returns (uint256 token0Amount, uint256 token1Amount) {\n        (token0Amount, token1Amount) = LiquidityAmounts.getAmountsForLiquidity(\n            positionData.currentPrice,\n            TickMath.getSqrtRatioAtTick(positionData.tickLower),\n            TickMath.getSqrtRatioAtTick(positionData.tickUpper),\n            positionData.liquidity\n        );\n    }\n\n    /**\n     * @notice get liquidity provider fee amount for the specified tokenId.\n     */\n    function getLpFeeAmount(uint256 tokenId)\n        external\n        view\n        returns (uint256 token0Amount, uint256 token1Amount)\n    {\n        UinswapV3PositionData memory positionData = getOnchainPositionData(\n            tokenId\n        );\n        (token0Amount, token1Amount) = getLpFeeAmountFromPositionData(\n            positionData\n        );\n    }\n\n    /**\n     * @notice calculate liquidity provider fee amount for the position data.\n     * @param positionData The specified position data\n     */\n    function getLpFeeAmountFromPositionData(\n        UinswapV3PositionData memory positionData\n    ) public view returns (uint256 token0Amount, uint256 token1Amount) {\n        (token0Amount, token1Amount) = _getPendingFeeAmounts(positionData);\n\n        token0Amount += positionData.tokensOwed0;\n        token1Amount += positionData.tokensOwed1;\n    }\n\n    /**\n     * @notice Returns the price for the specified tokenId.\n     */\n    function getTokenPrice(uint256 tokenId) public view returns (uint256) {\n        UinswapV3PositionData memory positionData = getOnchainPositionData(\n            tokenId\n        );\n\n        PairOracleData memory oracleData = _getOracleData(positionData);\n\n        (uint256 liquidityAmount0, uint256 liquidityAmount1) = LiquidityAmounts\n            .getAmountsForLiquidity(\n                oracleData.sqrtPriceX96,\n                TickMath.getSqrtRatioAtTick(positionData.tickLower),\n                TickMath.getSqrtRatioAtTick(positionData.tickUpper),\n                positionData.liquidity\n            );\n\n        (\n            uint256 feeAmount0,\n            uint256 feeAmount1\n        ) = getLpFeeAmountFromPositionData(positionData);\n\n        return\n            (((liquidityAmount0 + feeAmount0) * oracleData.token0Price) /\n                10**oracleData.token0Decimal) +\n            (((liquidityAmount1 + feeAmount1) * oracleData.token1Price) /\n                10**oracleData.token1Decimal);\n    }\n\n    /**\n     * @notice Returns the price for the specified tokenId array.\n     */\n    function getTokensPrices(uint256[] calldata tokenIds)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory prices = new uint256[](tokenIds.length);\n\n        for (uint256 index = 0; index < tokenIds.length; index++) {\n            prices[index] = getTokenPrice(tokenIds[index]);\n        }\n\n        return prices;\n    }\n\n    /**\n     * @notice Returns the total price for the specified tokenId array.\n     */\n    function getTokensPricesSum(uint256[] calldata tokenIds)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 sum = 0;\n\n        for (uint256 index = 0; index < tokenIds.length; index++) {\n            sum += getTokenPrice(tokenIds[index]);\n        }\n\n        return sum;\n    }\n\n    function latestAnswer() external pure returns (int256) {\n        revert(\"unimplemented\");\n    }\n\n    function _getOracleData(UinswapV3PositionData memory positionData)\n        internal\n        view\n        returns (PairOracleData memory)\n    {\n        PairOracleData memory oracleData;\n        IPriceOracleGetter oracle = IPriceOracleGetter(\n            ADDRESSES_PROVIDER.getPriceOracle()\n        );\n        oracleData.token0Price = oracle.getAssetPrice(positionData.token0);\n        oracleData.token1Price = oracle.getAssetPrice(positionData.token1);\n\n        oracleData.token0Decimal = IERC20Detailed(positionData.token0)\n            .decimals();\n        oracleData.token1Decimal = IERC20Detailed(positionData.token1)\n            .decimals();\n\n        // TODO using bit shifting for the 2^96\n        // positionData.sqrtPriceX96;\n\n        if (oracleData.token1Decimal == oracleData.token0Decimal) {\n            // multiply by 10^18 then divide by 10^9 to preserve price in wei\n            oracleData.sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(\n                    ((oracleData.token0Price * (10**18)) /\n                        (oracleData.token1Price))\n                ) * 2**96) / 1E9\n            );\n        } else if (oracleData.token1Decimal > oracleData.token0Decimal) {\n            // multiple by 10^(decimalB - decimalA) to preserve price in wei\n            oracleData.sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(\n                    (oracleData.token0Price *\n                        (10 **\n                            (18 +\n                                oracleData.token1Decimal -\n                                oracleData.token0Decimal))) /\n                        (oracleData.token1Price)\n                ) * 2**96) / 1E9\n            );\n        } else {\n            // multiple by 10^(decimalA - decimalB) to preserve price in wei then divide by the same number\n            oracleData.sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(\n                    (oracleData.token0Price *\n                        (10 **\n                            (18 +\n                                oracleData.token0Decimal -\n                                oracleData.token1Decimal))) /\n                        (oracleData.token1Price)\n                ) * 2**96) /\n                    10 **\n                        (9 +\n                            oracleData.token0Decimal -\n                            oracleData.token1Decimal)\n            );\n        }\n\n        return oracleData;\n    }\n\n    function _getPendingFeeAmounts(UinswapV3PositionData memory positionData)\n        internal\n        view\n        returns (uint256 token0Amount, uint256 token1Amount)\n    {\n        IUniswapV3PoolState pool = IUniswapV3PoolState(\n            UNISWAP_V3_FACTORY.getPool(\n                positionData.token0,\n                positionData.token1,\n                positionData.fee\n            )\n        );\n        FeeParams memory feeParams;\n\n        (\n            ,\n            ,\n            feeParams.feeGrowthOutside0X128Lower,\n            feeParams.feeGrowthOutside1X128Lower,\n            ,\n            ,\n            ,\n\n        ) = pool.ticks(positionData.tickLower);\n        (\n            ,\n            ,\n            feeParams.feeGrowthOutside0X128Upper,\n            feeParams.feeGrowthOutside1X128Upper,\n            ,\n            ,\n            ,\n\n        ) = pool.ticks(positionData.tickUpper);\n\n        uint256 feeGrowthGlobal0X128 = pool.feeGrowthGlobal0X128();\n        uint256 feeGrowthGlobal1X128 = pool.feeGrowthGlobal1X128();\n\n        unchecked {\n            // calculate fee growth below\n            uint256 feeGrowthBelow0X128;\n            uint256 feeGrowthBelow1X128;\n            if (positionData.currentTick >= positionData.tickLower) {\n                feeGrowthBelow0X128 = feeParams.feeGrowthOutside0X128Lower;\n                feeGrowthBelow1X128 = fee"
    }
  ]
}