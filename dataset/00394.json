{
  "Title": "M-2: In certain cases, users are unable to settle their orders with the PartialFill trade type.",
  "Content": "# Issue M-2: In certain cases, users are unable to settle their orders with the PartialFill trade type. \n\nSource: https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/95 \n\n## Found by \nether\\_sky\n## Summary\nThere are 2 `trade` types available:  `FoK` or `PartialFill`.\nUsers have the option to partially settle their `orders`.\nHowever, in some cases, they can't settle their `orders.\n## Vulnerability Detail\nA user creates an `order` with the `PartialFill` `trade` type and a size of `S`.\nInitially, he settles `50%` of this `order`.\nAt this point, the `totalFilledAmount` of this `order` has a value of `S/2`.\n```solidity\nfunction _fillTakerOrder(\n    InternalContext memory context,\n    SettleOrderParam memory settleOrderParams\n) internal returns (InternalWithdrawMarginParam memory, uint256) {\n    _getOrderGatewayV2Storage().totalFilledAmount[takerOrder.getKey()] += settleOrderParams.fillAmount;\n}\n```\nAfter some time, the user attempts to settle the remaining `50%` of that `order`.\nIn the `_verifyOrder` function, we check whether there is enough `positionSize` available to settle this `order` if the `action` of the `order` is `ReduceOnly`.\nHowever, the issue arises from not accounting for the previously settled amount.\n```solidity\nfunction _verifyOrder(IVault vault, Order memory order, uint256 fillAmount) internal view {\n      uint256 totalFilledAmount = getOrderFilledAmount(order.owner, order.id);\n      if (fillAmount > openAmount - totalFilledAmount) {\n          revert LibError.ExceedOrderAmount(order.owner, order.id, totalFilledAmount);\n      }\n      if (order.action == ActionType.ReduceOnly) {\n          int256 ownerPositionSize = vault.getPositionSize(order.marketId, order.owner);\n\n          if (order.amount * ownerPositionSize > 0) {\n              revert LibError.ReduceOnlySideMismatch(order.owner, order.id, order.amount, ownerPositionSize);\n          }\n\n          if (openAmount > ownerPositionSize.abs()) {  // @audit, here\n              revert LibError.UnableToReduceOnly(order.owner, order.id, openAmount, ownerPositionSize.abs());  \n          }\n      }\n}\n```\nIn the initial settlement, half of the `order` was settled.\nAfter the settlement, the `positionSize` decreases by `S/2` also and there are only `S/2` remaining in the `order`.\nTherefore, we should compare `S/2` with the current `positionSize`.\nHowever,  we compare `S` again without accounting for the previously settled amount.\nAs a result, the current `positionSize` might be lower than `S`, leading to the potential reversal of the settlement.\n## Impact\nThis is a DoS and users can lose funds as gas fees.\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/orderGatewayV2/OrderGatewayV2.sol#L336\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/orderGatewayV2/OrderGatewayV2.sol#L513-L515\n## Tool used\n\nManual Review\n\n## Recommendation\n```solidity\nfunction _verifyOrder(IVault vault, Order memory order, uint256 fillAmount) internal view {\n      uint256 totalFilledAmount = getOrderFilledAmount(order.owner, order.id);\n      if (fillAmount > openAmount - totalFilledAmount) {\n          revert LibError.ExceedOrderAmount(order.owner, order.id, totalFilledAmount);\n      }\n      if (order.action == ActionType.ReduceOnly) {\n          int256 ownerPositionSize = vault.getPositionSize(order.marketId, order.owner);\n\n          if (order.amount * ownerPositionSize > 0) {\n              revert LibError.ReduceOnlySideMismatch(order.owner, order.id, order.amount, ownerPositionSize);\n          }\n\n-          if (openAmount > ownerPositionSize.abs()) { \n+          if (openAmount - totalFilledAmount > ownerPositionSize.abs()) { \n              revert LibError.UnableToReduceOnly(order.owner, order.id, openAmount, ownerPositionSize.abs());  \n          }\n      }\n}\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**santipu_** commented:\n> Medium\n\n\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/perpetual-protocol/perp-contract-v3/pull/6\n\n\n**sherlock-admin3**\n\nThe Lead Senior Watson signed off on the fix.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/219",
  "Code": [
    {
      "filename": "perp-contract-v3/src/orderGatewayV2/OrderGatewayV2.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport { EIP712Upgradeable } from \"@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol\";\n// solhint-disable-next-line max-line-length\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\nimport { IAddressManager } from \"../addressManager/IAddressManager.sol\";\nimport { AddressResolverUpgradeable } from \"../addressResolver/AddressResolverUpgradeable.sol\";\nimport { LibAddressResolver } from \"../addressResolver/LibAddressResolver.sol\";\nimport { LibFormatter } from \"../common/LibFormatter.sol\";\nimport { LibError } from \"../common/LibError.sol\";\nimport { INTERNAL_DECIMALS, WAD } from \"../common/LibConstant.sol\";\nimport { IClearingHouse } from \"../clearingHouse/IClearingHouse.sol\";\nimport { Config } from \"../config/Config.sol\";\nimport { IVault } from \"../vault/IVault.sol\";\nimport { IMaker } from \"../maker/IMaker.sol\";\nimport { IPythOracleAdapter } from \"../oracle/pythOracleAdapter/IPythOracleAdapter.sol\";\nimport { ContextBase } from \"../common/ContextBase.sol\";\nimport { LibOrder } from \"./LibOrder.sol\";\n\n// Unlike OrderGateway, all orders are stored off-chain in OrderGatewayV2, and only whitelisted matchers (relayers)\n// can settle orders. This is configurable via OrderGatewayV2.setRelayer().\n//\n// We require any trade on OracleMaker must be 2-step in OrderGateway. However, we didn't have such requirements\n// in OrderGatewayV2 since orders can only be settled by whitelisted matchers.\n// TODO: Is this assumption safe enough to prevent front-running?\ncontract OrderGatewayV2 is EIP712Upgradeable, ContextBase, AddressResolverUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20Metadata;\n    using LibAddressResolver for IAddressManager;\n    using LibFormatter for *;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using FixedPointMathLib for int256;\n    using LibOrder for Order;\n\n    enum ActionType {\n        OpenPosition,\n        ReduceOnly\n    }\n\n    enum TradeType {\n        PartialFill,\n        FoK\n    }\n\n    //\n    // STRUCT\n    //\n\n    /// @custom:storage-location erc7201:perp.storage.orderGatewayV2\n    struct OrderGatewayV2Storage {\n        mapping(address => bool) isRelayer;\n        mapping(bytes32 => uint256) totalFilledAmount;\n        mapping(bytes32 => bool) isMarginTransferred;\n        mapping(bytes32 => bool) isRelayFeeTaken;\n        mapping(bytes32 => bool) isOrderCanceled;\n    }\n\n    struct Order {\n        ActionType action;\n        uint256 marketId;\n        int256 amount;\n        uint256 price;\n        uint256 expiry;\n        TradeType tradeType;\n        address owner;\n        uint256 marginXCD;\n        uint256 relayFee;\n        bytes32 id;\n    }\n\n    struct SignedOrder {\n        Order order;\n        bytes signature;\n    }\n\n    struct SettleOrderParam {\n        SignedOrder signedOrder;\n        uint256 fillAmount;\n        address maker;\n        bytes makerData;\n    }\n\n    //\n    // STATE\n    //\n\n    // keccak256(abi.encode(uint256(keccak256(\"perp.storage.orderGatewayV2\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 constant _ORDER_GATEWAY_V2_STORAGE_LOCATION =\n        0x16459c8cdc185adffd42f3aaeca8a1a10f7af2dfd66eb7d81c6f96679ffbde00;\n\n    // keccak256 value: 0x112f24273953496214afa22f35960e8571a3ae064d87213f08f46499ee5faf09\n    bytes32 public constant ORDER_TYPEHASH =\n        keccak256(\n            \"Order(uint8 action,uint256 marketId,int256 amount,uint256 price,uint256 expiry,uint8 tradeType,address owner,uint256 marginXCD,uint256 relayFee,bytes32 id)\"\n        );\n\n    event OrderFilled(\n        address indexed owner,\n        bytes32 indexed orderId,\n        ActionType action,\n        TradeType tradeType,\n        uint256 marketId,\n        int256 amount,\n        uint256 fillAmount,\n        uint256 price,\n        uint256 fillPrice,\n        uint256 expiry,\n        uint256 marginXCD,\n        uint256 relayFee,\n        address maker\n    );\n\n    event OrderCanceled(address indexed owner, bytes32 indexed id, string reason);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(string memory name_, string memory version_, address addressManager_) external initializer {\n        __AddressResolver_init(addressManager_);\n        __ReentrancyGuard_init();\n        __EIP712_init(name_, version_); // ex: \"OrderGateway\" and \"1\"\n    }\n\n    //\n    // MODIFIER\n    //\n    modifier onlyOwner() {\n        if (msg.sender != address(getAddressManager().getConfig().owner())) revert LibError.Unauthorized();\n        _;\n    }\n\n    modifier onlyRelayer(address sender) {\n        if (!_getOrderGatewayV2Storage().isRelayer[sender]) revert LibError.Unauthorized();\n        _;\n    }\n\n    //\n    // EXTERNAL NON VIEW\n    //\n\n    function setRelayer(address address_, bool isRelayer_) external onlyOwner {\n        _getOrderGatewayV2Storage().isRelayer[address_] = isRelayer_;\n    }\n\n    // NOTE: matcherFee will managed by admin\n    function withdrawMatcherFee() external onlyOwner {\n        IVault vault = getAddressManager().getVault();\n        vault.withdraw(vault.getFund(address(this)));\n        IERC20Metadata collateralToken = IERC20Metadata(_getAsset(vault));\n        collateralToken.safeTransfer(msg.sender, IERC20Metadata(collateralToken).balanceOf(address(this)));\n    }\n\n    function settleOrder(SettleOrderParam[] calldata settleOrderParams) external onlyRelayer(_sender()) nonReentrant {\n        uint256 settleOrderParamsLength = settleOrderParams.length;\n\n        // NOTE: only support 1 <-> 1 order matching for now\n        if (settleOrderParamsLength != 1) {\n            revert LibError.SettleOrderParamsLengthError();\n        }\n\n        IAddressManager addressManager = getAddressManager();\n        IClearingHouse clearingHouse = addressManager.getClearingHouse();\n        InternalContext memory context;\n        // we cache some storage reads in \"context\" since we will use them multiple times in other internal functions\n        context.vault = addressManager.getVault();\n        context.config = addressManager.getConfig();\n        context.pythOracleAdapter = addressManager.getPythOracleAdapter();\n        context.collateralTokenDecimals = IERC20Metadata(_getAsset(context.vault)).decimals();\n\n        for (uint256 i = 0; i < settleOrderParamsLength; i++) {\n            SettleOrderParam memory settleOrderParam = settleOrderParams[i];\n            uint256 marketId = settleOrderParam.signedOrder.order.marketId;\n            context.imRatio = context.config.getInitialMarginRatio(marketId);\n            context.oraclePrice = _getPrice(context.pythOracleAdapter, context.config, marketId);\n\n            (InternalWithdrawMarginParam memory takerWithdrawMarginParam, uint256 takerRelayFee) = _fillTakerOrder(\n                context,\n                settleOrderParam\n            );\n\n            (\n                bytes memory makerData,\n                InternalWithdrawMarginParam memory makerWithdrawMarginParam,\n                uint256 makerRelayFee\n            ) = _fillMakerOrder(context, settleOrderParam);\n\n            _openPosition(\n                InternalOpenPositionParams({\n                    clearingHouse: clearingHouse,\n                    settleOrderParam: settleOrderParam,\n                    makerData: makerData,\n                    takerRelayFee: takerRelayFee,\n                    makerRelayFee: makerRelayFee\n                })\n            );\n\n            // withdraw margin for taker reduce order\n            if (takerWithdrawMarginParam.trader != address(0)) {\n                _withdrawMargin(\n                    context,\n                    marketId,\n                    takerWithdrawMarginParam.trader,\n                    takerWithdrawMarginParam.requiredMarginRatio\n                );\n            }\n\n            // withdraw margin for maker reduce order\n            if (makerWithdrawMarginParam.trader != address(0)) {\n                _withdrawMargin(\n                    context,\n                    marketId,\n                    makerWithdrawMarginParam.trader,\n                    makerWithdrawMarginParam.requiredMarginRatio\n                );\n            }\n        }\n    }\n\n    function cancelOrder(SignedOrder memory signedOrder) external {\n        Order memory order = verifyOrderSignature(signedOrder);\n        if (order.owner != _sender()) {\n            revert LibError.Unauthorized();\n        }\n\n        // cannot use order.id as key, anyone can sign an arbitrary order and set order.id to other trader's order.id\n        // since we didn't store the whole order on-chain\n        _getOrderGatewayV2Storage().isOrderCanceled[order.getKey()] = true;\n        emit OrderCanceled(order.owner, order.id, \"Canceled\");\n    }\n\n    //\n    // EXTERNAL VIEW\n    //\n\n    function isRelayer(address address_) external view returns (bool) {\n        return _getOrderGatewayV2Storage().isRelayer[address_];\n    }\n\n    //\n    // PUBLIC VIEW\n    //\n\n    function isOrderCanceled(address orderOwner, bytes32 orderId) public view returns (bool) {\n        bytes32 key = LibOrder.getOrderKey(orderOwner, orderId);\n        return _getOrderGatewayV2Storage().isOrderCanceled[key];\n    }\n\n    function getOrderFilledAmount(address orderOwner, bytes32 orderId) public view returns (uint256) {\n        bytes32 key = LibOrder.getOrderKey(orderOwner, orderId);\n        return _getOrderGatewayV2Storage().totalFilledAmount[key];\n    }\n\n    function getOrderHash(Order memory order) public view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(abi.encode(ORDER_TYPEHASH, order)));\n    }\n\n    // TODO rename\n    function verifyOrderSignature(SignedOrder memory signedOrder) public returns (Order memory) {\n        Order memory order = signedOrder.order;\n        bytes32 orderHash = getOrderHash(order);\n\n        // UniversalSigValidator can verify the following signature types:\n        // 1. EIP-712 signature (signed by an EOA)\n        // 2. EIP-1271 signature (signed by a contract)\n        // 3. EIP-6492 signature (signed by a contract which is not yet deployed)\n        try\n            getAddressManager().getUniversalSigValidator().isValidSig(order.owner, orderHash, signedOrder.signature)\n        returns (bool isValidSig) {\n            if (!isValidSig) {\n                revert LibError.OrderSignatureOwnerError(order.owner, order.id, \"Invalid signature\");\n            }\n        } catch (bytes memory reason) {\n            revert LibError.OrderSignatureOwnerError(order.owner, order.id, reason);\n        }\n\n        return order;\n    }\n\n    //\n    // INTERNAL NON VIEW\n    //\n\n    struct InternalContext {\n        IVault vault;\n        Config config;\n        IPythOracleAdapter pythOracleAdapter;\n        uint256 imRatio;\n        uint8 collateralTokenDecimals;\n        uint256 oraclePrice;\n    }\n\n    /// @notice every order should only be took relay fee once\n    /// @param order the order being charged matcher fee\n    /// @return the actual fee it is going to ask ClearingHouse to pay for relaying the order\n    function _takeRelayFee(Order memory order) internal returns (uint256) {\n        bytes32 orderKey = order.getKey();\n        if (!_getOrderGatewayV2Storage().isRelayFeeTaken[orderKey] && order.relayFee > 0) {\n            _getOrderGatewayV2Storage().isRelayFeeTaken[orderKey] = true;\n            return order.relayFee;\n        }\n        return 0;\n    }\n\n    function _transferFundToMargin(IVault vault, Order memory order) internal {\n        bytes32 orderKey = order.getKey();\n        if (!_getOrderGatewayV2Storage().isMarginTransferred[orderKey] && order.marginXCD > 0) {\n            vault.transferFundToMargin(order.marketId, order.owner, order.marginXCD);\n            _getOrderGatewayV2Storage().isMarginTransferred[orderKey] = true;\n        }\n    }\n\n    struct InternalWithdrawMarginParam {\n        address trader;\n        uint256 requiredMarginRatio;\n    }\n\n    function _fillTakerOrder(\n        InternalContext memory context,\n        SettleOrderParam memory settleOrderParams\n    ) internal returns (InternalWithdrawMarginParam memory, uint256) {\n        Order memory takerOrder = verifyOrderSignature(settleOrderParams.signedOrder);\n\n        _verifyOrder(context.vault, takerOrder, settleOrderParams.fillAmount);\n\n        // deposit margin for taker\n        _transferFundToMargin(context.vault, takerOrder);\n\n        _getOrderGatewayV2Storage().totalFilledAmount[takerOrder.getKey()] += settleOrderParams.fillAmount;\n\n        // withdraw margin only for reduceOnly order\n        InternalWithdrawMarginParam memory withdrawParam;\n        if (takerOrder.action == ActionType.ReduceOnly) {\n            withdrawParam.trader = takerOrder.owner;\n            withdrawParam.requiredMarginRatio = FixedPointMathLib\n                .max(context.vault.getMarginRatio(takerOrder.marketId, takerOrder.owner, context.oraclePrice), 0)\n                .toUint256();\n        }\n\n        return (withdrawParam, _takeRelayFee(takerOrder));\n    }\n\n    function _fillMakerOrder(\n        InternalContext memory context,\n        SettleOrderParam memory settleOrderParams\n    ) internal returns (bytes memory, InternalWithdrawMarginParam memory, uint256) {\n        InternalWithdrawMarginParam memory withdrawParam;\n\n        // if settleOrderParams.maker is one of whitelistedMakers -> settle with pools\n        // settleOrderParams.makerData depends on which whitelistedMaker it is\n        // makerData is usually retrieved from our backend service: maker-router\n        if (context.config.isWhitelistedMaker(settleOrderParams.signedOrder.order.marketId, settleOrderParams.maker)) {\n            return (settleOrderParams.makerData, withdrawParam, 0);\n        }\n\n        // if settleOrderParams.maker is makerOrder.owner -> settle with another limit order\n        // settleOrderParams.makerData is the entire makerOrder\n        Order memory takerOrder = settleOrderParams.signedOrder.order;\n        Order memory makerOrder = verifyOrderSignature(abi.decode(settleOrderParams.makerData, (SignedOrder)));\n        _verifyOrder(context.vault, makerOrder, settleOrderParams.fillAmount);\n        _verifyBothOrders(takerOrder, makerOrder);\n        _transferFundToMargin(context.vault, makerOrder);\n        _getOrderGatewayV2Storage().totalFilledAmount[makerOrder.getKey()] += settleOrderParams.fillAmount;\n\n        // Maker order's maker is himself\n        _emitOrderFilled(makerOrder, makerOrder.owner, settleOrderParams.fillAmount, makerOrder.price);\n\n        if (makerOrder.action == ActionType.ReduceOnly) {\n            withdrawParam.trader = makerOrder.owner;\n            withdrawParam.requiredMarginRatio = FixedPointMathLib\n                .max(context.vault.getMarginRatio(takerOrder.marketId, makerOrder.owner, context.oraclePrice), 0)\n                .toUint256();\n        }\n\n        return (\n            abi.encode(\n                IClearingHouse.MakerOrder({\n                    amount: FixedPointMathLib.fullMulDiv(makerOrder.price, settleOrderParams.fillAmount, WAD)\n                })\n            ),\n            withdrawParam,\n            _takeRelayFee(makerOrder)\n        );\n    }\n\n    struct InternalOpenPositionParams {\n        IClearingHouse clearingHouse;\n        SettleOrderParam settleOrderParam;\n        bytes makerData;\n        uint256 takerRelayFee;\n        uint256 makerRelayFee;\n    }\n\n    function _openPosition(InternalOpenPositionParams memory params) internal {\n        Order memory takerOrder = params.settleOrderParam.signedOrder.order;\n        bool isBaseToQuote = takerOrder.amount < 0;\n\n        (int256 base, int256 quote) = params.clearingHouse.openPositionFor(\n            IClearingHouse.OpenPositionForParams({\n                marketId: takerOrder.marketId,\n                maker: params.settleOrderParam.maker,\n                isBaseToQuote: isBaseToQuote,\n                isExactInput: isBaseToQuote,\n                amount: params.settleOrderParam.fillAmount,\n                oppositeAmountBound: FixedPointMathLib.fullMulDiv(\n                    takerOrder.price,\n                    params.settleOrderParam.fillAmount,\n                    WAD\n                ),\n                deadline: takerOrder.expiry,\n                makerData: params.makerData,\n                taker: takerOrder.owner,\n                takerRelayFee: params.takerRelayFee,\n                makerRelayFee: params.makerRelayFee\n            })\n        );\n\n        // may not need this guardian\n        if (base.abs() != params.settleOrderParam.fillAmount) {\n            revert LibError.FilledAmountMismatched(\n                takerOrder.owner,\n                takerOrder.id,\n                params.settleOrderParam.fillAmount,\n                base.abs()\n            );\n        }\n\n        // calculate taker filled price\n        _emitOrderFilled(\n            takerOrder,\n            params.settleOrderParam.maker,\n            params.settleOrderParam.fillAmount,\n            FixedPointMathLib.fullMulDiv(quote.abs(), WAD, base.abs())\n        );\n    }\n\n    function _emitOrderFilled(Order memory order, address maker, uint256 fillAmount, uint256 fillPrice) internal {\n        emit OrderFilled(\n            order.owner,\n            order.id,\n            order.action,\n            order.tradeType,\n            order.marketId,\n            order.amount,\n            fillAmount,\n            order.price,\n            fillPrice,\n            order.expiry,\n            order.marginXCD,\n            order.relayFee,\n            maker\n        );\n    }\n\n    function _withdrawMargin(\n        InternalContext memory context,\n        uint256 marketId,\n        address trader,\n        uint256 requiredMarginRatio\n    ) internal {\n        uint256 withdrawableMargin = _getWithdrawableMargin(context, marketId, trader, requiredMarginRatio);\n        if (withdrawableMargin > 0) {\n            context.vault.transferMarginToFund(\n                marketId,\n                trader,\n                withdrawableMargin.formatDecimals(INTERNAL_DECIMALS, context.collateralTokenDecimals)\n            );\n        }\n    }\n\n    //\n    // INTERNAL VIEW\n    //\n\n    function _verifyOrder(IVault vault, Order memory order, uint256 fillAmount) internal view {\n        if (block.timestamp > order.expiry) {\n            revert LibError.OrderHasExpired(order.owner, order.id);\n        }\n\n        if (isOrderCanceled(order.owner, order.id)) {\n            revert LibError.OrderWasCanceled(order.owner, order.id);\n        }\n\n        if (order.amount == 0) {\n            revert LibError.OrderAmountZero(order.owner, order.id);\n        }\n\n        uint256 openAmount = order.amount.abs();\n\n        if (order.tradeType == TradeType.FoK && fillAmount != openAmount) {\n            revert LibError.UnableToFillFok(order.owner, order.id);\n        }\n\n        uint256 totalFilledAmount = getOrderFilledAmount(order.owner, order.id);\n        if (fillAmount > openAmount - totalFilledAmount) {\n            revert LibError.ExceedOrderAmount(order.owner, order.id, totalFilledAmount);\n        }\n\n        if (order.action == ActionType.ReduceOnly) {\n            int256 ownerPositionSize = vault.getPositionSize(order.marketId, order.owner);\n\n            if (order.amount * ownerPositionSize > 0) {\n                revert LibError.ReduceOnlySideMismatch(order.owner, order.id, order.amount, ownerPositionSize);\n            }\n\n            if (openAmount > ownerPositionSize.abs()) {\n                revert LibError.UnableToReduceOnly(order.owner, order.id, openAmount, ownerPositionSize.abs());\n            }\n        }\n    }\n\n    function _verifyBothOrders(Order memory takerOrder, Order memory makerOrder) internal pure {\n        if (takerOrder.marketId != makerOrder.marketId) {\n            revert LibError.OrderMarketMismatched(\n                takerOrder.owner,\n                takerOrder.id,\n                takerOrder.marketId,\n                makerOrder.owner,\n                makerOrder.id,\n                makerOrder.marketId\n            );\n        }\n\n        if (takerOrder.amount * makerOrder.amount >= 0) {\n            revert LibError.OrderSideMismatched(takerOrder.owner, takerOrder.id, makerOrder.owner, makerOrder.id);\n        }\n    }\n\n    function _getAsset(IVault vault) internal view returns (address) {\n        return vault.getCollateralToken();\n    }\n\n    /// @dev get withdrawable margin after reduce position to keep same leverage\n    /// @notice the amount is in INTERNAL_DECIMALS\n    function _getWithdrawableMargin(\n        InternalContext memory context,\n        uint256 marketId,\n        address trader,\n        uint256 requiredMarginRatio\n    ) internal view returns (uint256 amount) {\n        int256 positionSize = context.vault.getPositionSize(marketId, trader);\n        uint256 freeCollateral = context.vault.getFreeCollateral(marketId, trader, context.oraclePrice);\n        if (positionSize == 0) {\n            return freeCollateral;\n        }\n\n        int256 marginRatio = context.vault.getMarginRatio(marketId, trader, context.oraclePrice);\n        if (marginRatio < context.imRatio.toInt256() || marginRatio <= requiredMarginRatio.toInt256()) {\n            return 0;\n        }\n\n        int256 openNotional = context.vault.getOpenNotional(marketId, trader);\n        uint256 requiredAccountValue = FixedPointMathLib.fullMulDiv(requiredMarginRatio, openNotional.abs(), WAD);\n        int256 accountValue = context.vault.getAccountValue(marketId, trader, context.oraclePrice);\n        if (accountValue <= requiredAccountValue.toInt256()) {\n            return 0;\n        }\n\n        int256 tryToWithdraw = accountValue - requiredAccountValue.toInt256();\n        return FixedPointMathLib.min(tryToWithdraw.toUint256(), freeCollateral);\n    }\n\n    function _getPrice(\n        IPythOracleAdapter pythOracleAdapter,\n        Config config,\n        uint256 marketId\n    ) internal view returns (uint256) {\n        (uint256 price, ) = pythOracleAdapter.getPrice(config.getPriceFeedId(marketId));\n        return price;\n    }\n\n    //\n    // PRIVATE\n    //\n\n    function _getOrderGatewayV2Storage() private pure returns (OrderGatewayV2Storage storage $) {\n        assembly {\n            $.slot := _ORDER_GATEWAY_V2_STORAGE_LOCATION\n        }\n    }\n}"
    },
    {
      "filename": "perp-contract-v3/src/orderGatewayV2/OrderGatewayV2.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport { EIP712Upgradeable } from \"@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol\";\n// solhint-disable-next-line max-line-length\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\nimport { IAddressManager } from \"../addressManager/IAddressManager.sol\";\nimport { AddressResolverUpgradeable } from \"../addressResolver/AddressResolverUpgradeable.sol\";\nimport { LibAddressResolver } from \"../addressResolver/LibAddressResolver.sol\";\nimport { LibFormatter } from \"../common/LibFormatter.sol\";\nimport { LibError } from \"../common/LibError.sol\";\nimport { INTERNAL_DECIMALS, WAD } from \"../common/LibConstant.sol\";\nimport { IClearingHouse } from \"../clearingHouse/IClearingHouse.sol\";\nimport { Config } from \"../config/Config.sol\";\nimport { IVault } from \"../vault/IVault.sol\";\nimport { IMaker } from \"../maker/IMaker.sol\";\nimport { IPythOracleAdapter } from \"../oracle/pythOracleAdapter/IPythOracleAdapter.sol\";\nimport { ContextBase } from \"../common/ContextBase.sol\";\nimport { LibOrder } from \"./LibOrder.sol\";\n\n// Unlike OrderGateway, all orders are stored off-chain in OrderGatewayV2, and only whitelisted matchers (relayers)\n// can settle orders. This is configurable via OrderGatewayV2.setRelayer().\n//\n// We require any trade on OracleMaker must be 2-step in OrderGateway. However, we didn't have such requirements\n// in OrderGatewayV2 since orders can only be settled by whitelisted matchers.\n// TODO: Is this assumption safe enough to prevent front-running?\ncontract OrderGatewayV2 is EIP712Upgradeable, ContextBase, AddressResolverUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20Metadata;\n    using LibAddressResolver for IAddressManager;\n    using LibFormatter for *;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using FixedPointMathLib for int256;\n    using LibOrder for Order;\n\n    enum ActionType {\n        OpenPosition,\n        ReduceOnly\n    }\n\n    enum TradeType {\n        PartialFill,\n        FoK\n    }\n\n    //\n    // STRUCT\n    //\n\n    /// @custom:storage-location erc7201:perp.storage.orderGatewayV2\n    struct OrderGatewayV2Storage {\n        mapping(address => bool) isRelayer;\n        mapping(bytes32 => uint256) totalFilledAmount;\n        mapping(bytes32 => bool) isMarginTransferred;\n        mapping(bytes32 => bool) isRelayFeeTaken;\n        mapping(bytes32 => bool) isOrderCanceled;\n    }\n\n    struct Order {\n        ActionType action;\n        uint256 marketId;\n        int256 amount;\n        uint256 price;\n        uint256 expiry;\n        TradeType tradeType;\n        address owner;\n        uint256 marginXCD;\n        uint256 relayFee;\n        bytes32 id;\n    }\n\n    struct SignedOrder {\n        Order order;\n        bytes signature;\n    }\n\n    struct SettleOrderParam {\n        SignedOrder signedOrder;\n        uint256 fillAmount;\n        address maker;\n        bytes makerData;\n    }\n\n    //\n    // STATE\n    //\n\n    // keccak256(abi.encode(uint256(keccak256(\"perp.storage.orderGatewayV2\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 constant _ORDER_GATEWAY_V2_STORAGE_LOCATION =\n        0x16459c8cdc185adffd42f3aaeca8a1a10f7af2dfd66eb7d81c6f96679ffbde00;\n\n    // keccak256 value: 0x112f24273953496214afa22f35960e8571a3ae064d87213f08f46499ee5faf09\n    bytes32 public constant ORDER_TYPEHASH =\n        keccak256(\n            \"Order(uint8 action,uint256 marketId,int256 amount,uint256 price,uint256 expiry,uint8 tradeType,address owner,uint256 marginXCD,uint256 relayFee,bytes32 id)\"\n        );\n\n    event OrderFilled(\n        address indexed owner,\n        bytes32 indexed orderId,\n        ActionType action,\n        TradeType tradeType,\n        uint256 marketId,\n        int256 amount,\n        uint256 fillAmount,\n        uint256 price,\n        uint256 fillPrice,\n        uint256 expiry,\n        uint256 marginXCD,\n        uint256 relayFee,\n        address maker\n    );\n\n    event OrderCanceled(address indexed owner, bytes32 indexed id, string reason);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(string memory name_, string memory version_, address addressManager_) external initializer {\n        __AddressResolver_init(addressManager_);\n        __ReentrancyGuard_init();\n        __EIP712_init(name_, version_); // ex: \"OrderGateway\" and \"1\"\n    }\n\n    //\n    // MODIFIER\n    //\n    modifier onlyOwner() {\n        if (msg.sender != address(getAddressManager().getConfig().owner())) revert LibError.Unauthorized();\n        _;\n    }\n\n    modifier onlyRelayer(address sender) {\n        if (!_getOrderGatewayV2Storage().isRelayer[sender]) revert LibError.Unauthorized();\n        _;\n    }\n\n    //\n    // EXTERNAL NON VIEW\n    //\n\n    function setRelayer(address address_, bool isRelayer_) external onlyOwner {\n        _getOrderGatewayV2Storage().isRelayer[address_] = isRelayer_;\n    }\n\n    // NOTE: matcherFee will managed by admin\n    function withdrawMatcherFee() external onlyOwner {\n        IVault vault = getAddressManager().getVault();\n        vault.withdraw(vault.getFund(address(this)));\n        IERC20Metadata collateralToken = IERC20Metadata(_getAsset(vault));\n        collateralToken.safeTransfer(msg.sender, IERC20Metadata(collateralToken).balanceOf(address(this)));\n    }\n\n    function settleOrder(SettleOrderParam[] calldata settleOrderParams) external onlyRelayer(_sender()) nonReentrant {\n        uint256 settleOrderParamsLength = settleOrderParams.length;\n\n        // NOTE: only support 1 <-> 1 order matching for now\n        if (settleOrderParamsLength != 1) {\n            revert LibError.SettleOrderParamsLengthError();\n        }\n\n        IAddressManager addressManager = getAddressManager();\n        IClearingHouse clearingHouse = addressManager.getClearingHouse();\n        InternalContext memory context;\n        // we cache some storage reads in \"context\" since we will use them multiple times in other internal functions\n        context.vault = addressManager.getVault();\n        context.config = addressManager.getConfig();\n        context.pythOracleAdapter = addressManager.getPythOracleAdapter();\n        context.collateralTokenDecimals = IERC20Metadata(_getAsset(context.vault)).decimals();\n\n        for (uint256 i = 0; i < settleOrderParamsLength; i++) {\n            SettleOrderParam memory settleOrderParam = settleOrderParams[i];\n            uint256 marketId = settleOrderParam.signedOrder.order.marketId;\n            context.imRatio = context.config.getInitialMarginRatio(marketId);\n            context.oraclePrice = _getPrice(context.pythOracleAdapter, context.config, marketId);\n\n            (InternalWithdrawMarginParam memory takerWithdrawMarginParam, uint256 takerRelayFee) = _fillTakerOrder(\n                context,\n                settleOrderParam\n            );\n\n            (\n                bytes memory makerData,\n                InternalWithdrawMarginParam memory makerWithdrawMarginParam,\n                uint256 makerRelayFee\n            ) = _fillMakerOrder(context, settleOrderParam);\n\n            _openPosition(\n                InternalOpenPositionParams({\n                    clearingHouse: clearingHouse,\n                    settleOrderParam: settleOrderParam,\n                    makerData: makerData,\n                    takerRelayFee: takerRelayFee,\n                    makerRelayFee: makerRelayFee\n                })\n            );\n\n            // withdraw margin for taker reduce order\n            if (takerWithdrawMarginParam.trader != address(0)) {\n                _withdrawMargin(\n                    context,\n                    marketId,\n                    takerWithdrawMarginParam.trader,\n                    takerWithdrawMarginParam.requiredMarginRatio\n                );\n            }\n\n            // withdraw margin for maker reduce order\n            if (makerWithdrawMarginParam.trader != address(0)) {\n                _withdrawMargin(\n                    context,\n                    marketId,\n                    makerWithdrawMarginParam.trader,\n                    makerWithdrawMarginParam.requiredMarginRatio\n                );\n            }\n        }\n    }\n\n    function cancelOrder(SignedOrder memory signedOrder) external {\n        Order memory order = verifyOrderSignature(signedOrder);\n        if (order.owner != _sender()) {\n            revert LibError.Unauthorized();\n        }\n\n        // cannot use order.id as key, anyone can sign an arbitrary order and set order.id to other trader's order.id\n        // since we didn't store the whole order on-chain\n        _getOrderGatewayV2Storage().isOrderCanceled[order.getKey()] = true;\n        emit OrderCanceled(order.owner, order.id, \"Canceled\");\n    }\n\n    //\n    // EXTERNAL VIEW\n    //\n\n    function isRelayer(address address_) external view returns (bool) {\n        return _getOrderGatewayV2Storage().isRelayer[address_];\n    }\n\n    //\n    // PUBLIC VIEW\n    //\n\n    function isOrderCanceled(address orderOwner, bytes32 orderId) public view returns (bool) {\n        bytes32 key = LibOrder.getOrderKey(orderOwner, orderId);\n        return _getOrderGatewayV2Storage().isOrderCanceled[key];\n    }\n\n    function getOrderFilledAmount(address orderOwner, bytes32 orderId) public view returns (uint256) {\n        bytes32 key = LibOrder.getOrderKey(orderOwner, orderId);\n        return _getOrderGatewayV2Storage().totalFilledAmount[key];\n    }\n\n    function getOrderHash(Order memory order) public view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(abi.encode(ORDER_TYPEHASH, order)));\n    }\n\n    // TODO rename\n    function veri"
    }
  ]
}