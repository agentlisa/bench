{
  "Title": "[G-22] Use ``assembly`` to write _address storage values_",
  "Content": "\n2 results - 2 files:\n\n```solidity\npackages\\v2-pool\\src\\base\\OwnableTwoSteps.sol:\n  18     constructor(address chosenOwner) {\n  19:         owner = chosenOwner;```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/base/OwnableTwoSteps.sol#L19\n\n\n```solidity\npackages\\v2-token\\src\\TimeswapV2Token.sol:\n  41     constructor(address chosenOptionFactory) ERC1155(\"Timeswap V2 address\") {\n  42:           optionFactory = chosenOptionFactory;\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-token/src/TimeswapV2Token.sol#L42\n\n\n**Recommendation Code:**\n\n```diff\n  41     constructor(address chosenOptionFactory) ERC1155(\"Timeswap V2 address\") {\n- 42:           optionFactory = chosenOptionFactory;\n+                  assembly {                      \n+                      sstore(optionFactory.slot, chosenOptionFactory)\n+                  }                               \n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-01-timeswap",
  "Code": [
    {
      "filename": "packages/v2-pool/src/base/OwnableTwoSteps.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {Error} from \"@timeswap-labs/v2-library/src/Error.sol\";\nimport {Ownership} from \"@timeswap-labs/v2-library/src/Ownership.sol\";\n\nimport {IOwnableTwoSteps} from \"../interfaces/IOwnableTwoSteps.sol\";\n\n/// @dev contract for ownable implementation with a safety two step owner transfership.\ncontract OwnableTwoSteps is IOwnableTwoSteps {\n    using Ownership for address;\n\n    /// @dev The current owner of the contract.\n    address public override owner;\n    /// @dev The pending owner of the contract. Is zero when none is pending.\n    address public override pendingOwner;\n\n    constructor(address chosenOwner) {\n        owner = chosenOwner;\n    }\n\n    /// @inheritdoc IOwnableTwoSteps\n    function setPendingOwner(address chosenPendingOwner) external override {\n        Ownership.checkIfOwner(owner);\n\n        if (chosenPendingOwner == address(0)) Error.zeroAddress();\n        chosenPendingOwner.checkIfAlreadyOwner(owner);\n\n        pendingOwner = chosenPendingOwner;\n\n        emit SetOwner(pendingOwner);\n    }\n\n    /// @inheritdoc IOwnableTwoSteps\n    function acceptOwner() external override {\n        msg.sender.checkIfPendingOwner(pendingOwner);\n\n        owner = msg.sender;\n        delete pendingOwner;\n\n        emit AcceptOwner(msg.sender);\n    }\n}"
    },
    {
      "filename": "packages/v2-token/src/TimeswapV2Token.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport {ERC1155} from \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"forge-std/console.sol\";\n\nimport {ITimeswapV2Option} from \"@timeswap-labs/v2-option/src/interfaces/ITimeswapV2Option.sol\";\n\nimport {OptionFactoryLibrary} from \"@timeswap-labs/v2-option/src/libraries/OptionFactory.sol\";\nimport {ReentrancyGuard} from \"@timeswap-labs/v2-pool/src/libraries/ReentrancyGuard.sol\";\n\nimport {TimeswapV2OptionPosition} from \"@timeswap-labs/v2-option/src/enums/Position.sol\";\n\nimport {ITimeswapV2Token} from \"./interfaces/ITimeswapV2Token.sol\";\n\nimport {ITimeswapV2TokenMintCallback} from \"./interfaces/callbacks/ITimeswapV2TokenMintCallback.sol\";\nimport {ITimeswapV2TokenBurnCallback} from \"./interfaces/callbacks/ITimeswapV2TokenBurnCallback.sol\";\n\nimport {ERC1155Enumerable} from \"./base/ERC1155Enumerable.sol\";\n\nimport {TimeswapV2TokenPosition, PositionLibrary} from \"./structs/Position.sol\";\nimport {TimeswapV2TokenMintParam, TimeswapV2TokenBurnParam, ParamLibrary} from \"./structs/Param.sol\";\nimport {TimeswapV2TokenMintCallbackParam, TimeswapV2TokenBurnCallbackParam} from \"./structs/CallbackParam.sol\";\nimport {Error} from \"@timeswap-labs/v2-library/src/Error.sol\";\n\n/// @title\n/// @author Timeswap Labs\n/// @notice TimeswapV2Token tokenizes the TimeswapV2 native option positions (long0, long1, short)\ncontract TimeswapV2Token is ITimeswapV2Token, ERC1155Enumerable {\n    using ReentrancyGuard for uint96;\n\n    using PositionLibrary for TimeswapV2TokenPosition;\n\n    address public immutable optionFactory;\n\n    mapping(bytes32 => uint96) private reentrancyGuards;\n\n    mapping(uint256 => TimeswapV2TokenPosition) private _timeswapV2TokenPositions;\n    mapping(bytes32 => uint256) private _timeswapV2TokenPositionIds;\n\n    constructor(address chosenOptionFactory) ERC1155(\"Timeswap V2 address\") {\n        optionFactory = chosenOptionFactory;\n    }\n\n    function changeInteractedIfNecessary(address token0, address token1, uint256 strike, uint256 maturity) private {\n        bytes32 key = keccak256(abi.encode(token0, token1, strike, maturity));\n\n        if (reentrancyGuards[key] == ReentrancyGuard.NOT_INTERACTED) reentrancyGuards[key] = ReentrancyGuard.NOT_ENTERED;\n    }\n\n    /// @dev internal function to start the reentrancy guard\n    function raiseGuard(address token0, address token1, uint256 strike, uint256 maturity) private {\n        bytes32 key = keccak256(abi.encode(token0, token1, strike, maturity));\n\n        reentrancyGuards[key].check();\n        reentrancyGuards[key] = ReentrancyGuard.ENTERED;\n    }\n\n    /// @dev internal function to end the reentrancy guard\n    function lowerGuard(address token0, address token1, uint256 strike, uint256 maturity) private {\n        bytes32 key = keccak256(abi.encode(token0, token1, strike, maturity));\n        reentrancyGuards[key] = ReentrancyGuard.NOT_ENTERED;\n    }\n\n    /// @inheritdoc ITimeswapV2Token\n    function positionOf(address owner, TimeswapV2TokenPosition calldata timeswapV2TokenPosition) public view returns (uint256 amount) {\n        amount = ERC1155.balanceOf(owner, _timeswapV2TokenPositionIds[timeswapV2TokenPosition.toKey()]);\n    }\n\n    /// @inheritdoc ITimeswapV2Token\n    function transferTokenPositionFrom(address from, address to, TimeswapV2TokenPosition calldata timeswapV2TokenPosition, uint256 amount) external override {\n        safeTransferFrom(from, to, _timeswapV2TokenPositionIds[timeswapV2TokenPosition.toKey()], (amount), bytes(\"\"));\n    }\n\n    /// @inheritdoc ITimeswapV2Token\n    function mint(TimeswapV2TokenMintParam calldata param) external override returns (bytes memory data) {\n        ParamLibrary.check(param);\n        changeInteractedIfNecessary(param.token0, param.token1, param.strike, param.maturity);\n        raiseGuard(param.token0, param.token1, param.strike, param.maturity);\n\n        address optionPair = OptionFactoryLibrary.getWithCheck(optionFactory, param.token0, param.token1);\n\n        uint256 long0BalanceTarget;\n        // mints TimeswapV2Token in case of the long0 position\n        if (param.long0Amount != 0) {\n            // get the initial balance of the long0 position and add the long0 amount to mint\n            long0BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0) + param.long0Amount;\n\n            TimeswapV2TokenPosition memory timeswapV2TokenPosition = TimeswapV2TokenPosition({\n                token0: param.token0,\n                token1: param.token1,\n                strike: param.strike,\n                maturity: param.maturity,\n                position: TimeswapV2OptionPosition.Long0\n            });\n\n            bytes32 key = timeswapV2TokenPosition.toKey();\n            // get the unique id of the TimeswapV2Token position\n            uint256 id = _timeswapV2TokenPositionIds[key];\n\n            // if the id is 0, it means that the position has not been minted yet\n            if (id == 0) {\n                id = totalSupply() + 1;\n                _timeswapV2TokenPositions[id] = timeswapV2TokenPosition;\n                _timeswapV2TokenPositionIds[key] = id;\n            }\n\n            // mint the TimeswapV2Token long0 position\n            console.log(\"reaches right before mint in timeswapv2Tokne::mint\");\n            _mint(param.long0To, id, (param.long0Amount), bytes(\"\"));\n        }\n\n        uint256 long1BalanceTarget;\n        // mints TimeswapV2Token in case of the long1 position\n        if (param.long1Amount != 0) {\n            // get the initial balance of the long1 position and add the long1 amount to mint\n            long1BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1) + param.long1Amount;\n\n            TimeswapV2TokenPosition memory timeswapV2TokenPosition = TimeswapV2TokenPosition({\n                token0: param.token0,\n                token1: param.token1,\n                strike: param.strike,\n                maturity: param.maturity,\n                position: TimeswapV2OptionPosition.Long1\n            });\n\n            bytes32 key = timeswapV2TokenPosition.toKey();\n            // get the unique id of the TimeswapV2Token position\n            uint256 id = _timeswapV2TokenPositionIds[key];\n\n            // if the id is 0, it means that the position has not been minted yet\n            if (id == 0) {\n                id = totalSupply() + 1;\n                _timeswapV2TokenPositions[id] = timeswapV2TokenPosition;\n                _timeswapV2TokenPositionIds[key] = id;\n            }\n\n            // mint the TimeswapV2Token long1 position\n            _mint(param.long1To, id, (param.long1Amount), bytes(\"\"));\n        }\n\n        uint256 shortBalanceTarget;\n        // mints TimeswapV2Token in case of the short position\n        if (param.shortAmount != 0) {\n            // get the initial balance of the short position and add the short amount to mint\n            shortBalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short) + param.shortAmount;\n\n            TimeswapV2TokenPosition memory timeswapV2TokenPosition = TimeswapV2TokenPosition({\n                token0: param.token0,\n                token1: param.token1,\n                strike: param.strike,\n                maturity: param.maturity,\n                position: TimeswapV2OptionPosition.Short\n            });\n\n            bytes32 key = timeswapV2TokenPosition.toKey();\n            // get the unique id of the TimeswapV2Token position\n            uint256 id = _timeswapV2TokenPositionIds[key];\n\n            // if the id is 0, it means that the position has not been minted yet\n            if (id == 0) {\n                id = totalSupply() + 1;\n                _timeswapV2TokenPositions[id] = timeswapV2TokenPosition;\n                _timeswapV2TokenPositionIds[key] = id;\n            }\n\n            // mint the TimeswapV2Token short position\n            _mint(param.shortTo, id, (param.shortAmount), bytes(\"\"));\n        }\n        // console.log()\n        // ask the msg.sender to transfer the long0/long1/short amount to the this contract\n        data = ITimeswapV2TokenMintCallback(msg.sender).timeswapV2TokenMintCallback(\n            TimeswapV2TokenMintCallbackParam({\n                token0: param.token0,\n                token1: param.token1,\n                strike: param.strike,\n                maturity: param.maturity,\n                long0Amount: param.long0Amount,\n                long1Amount: param.long1Amount,\n                shortAmount: param.shortAmount,\n                data: param.data\n            })\n        );\n\n        // check if the long0 position token balance target is achieved. If not, revert the transaction\n        if (param.long0Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0), long0BalanceTarget);\n\n        // check if the long1 position token balance target is achieved. If not, revert the transaction\n        if (param.long1Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1), long1BalanceTarget);\n\n        // check if the short position token balance target is achieved. If not, revert the transaction\n        if (param.shortAmount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short), shortBalanceTarget);\n\n        lowerGuard(param.token0, param.token1, param.strike, param.maturity);\n    }\n\n    /// @inheritdoc ITimeswapV2Token\n    function burn(TimeswapV2TokenBurnParam calldata param) external override returns (bytes memory data) {\n        ParamLibrary.check(param);\n        raiseGuard(param.token0, param.token1, param.strike, param.maturity);\n\n        address optionPair = OptionFactoryLibrary.getWithCheck(optionFactory, param.token0, param.token1);\n\n        // case when the long0 position is to be burned\n        if (param.long0Amount != 0) ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.long0To, TimeswapV2OptionPosition.Long0, param.long0Amount);\n\n        // case when the long1 position is to be burned\n        if (param.long1Amount != 0)\n            // transfer the underlying equivalent long1 position amount to address of the recipient of long1 position.\n            ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.long1To, TimeswapV2OptionPosition.Long1, param.long1Amount);\n\n        // case when the short position is to be burned\n        if (param.shortAmount != 0) ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.shortTo, TimeswapV2OptionPosition.Short, param.shortAmount);\n\n        if (param.data.length != 0)\n            data = ITimeswapV2TokenBurnCallback(msg.sender).timeswapV2TokenBurnCallback(\n                TimeswapV2TokenBurnCallbackParam({\n                    token0: param.token0,\n                    token1: param.token1,\n                    strike: param.strike,\n                    maturity: param.maturity,\n                    long0Amount: param.long0Amount,\n                    long1Amount: param.long1Amount,\n                    shortAmount: param.shortAmount,\n                    data: param.data\n                })\n            );\n\n        // case when the long0 position is to be burned\n        if (param.long0Amount != 0) {\n            TimeswapV2TokenPosition memory timeswapV2TokenPosition = TimeswapV2TokenPosition({\n                token0: param.token0,\n                token1: param.token1,\n                strike: param.strike,\n                maturity: param.maturity,\n                position: TimeswapV2OptionPosition.Long0\n            });\n\n            // burn the TimeswapV2Token representing long0 position\n            _burn(msg.sender, _timeswapV2TokenPositionIds[timeswapV2TokenPosition.toKey()], param.long0Amount);\n        }\n\n        // case when the long1 position is to be burned\n        if (param.long1Amount != 0) {\n            TimeswapV2TokenPosition memory timeswapV2TokenPosition = TimeswapV2TokenPosition({\n                token0: param.token0,\n                token1: param.token1,\n                strike: param.strike,\n                maturity: param.maturity,\n                position: TimeswapV2OptionPosition.Long1\n            });\n\n            // burn the TimeswapV2Token representing long1 position\n            _burn(msg.sender, _timeswapV2TokenPositionIds[timeswapV2TokenPosition.toKey()], param.long1Amount);\n        }\n\n        // case when the short position is to be burned\n        if (param.shortAmount != 0) {\n            TimeswapV2TokenPosition memory timeswapV2TokenPosition = TimeswapV2TokenPosition({\n                token0: param.token0,\n                token1: param.token1,\n                strike: param.strike,\n                maturity: param.maturity,\n                position: TimeswapV2OptionPosition.Short\n            });\n\n            // burn the TimeswapV2Token representing short position\n            _burn(msg.sender, _timeswapV2TokenPositionIds[timeswapV2TokenPosition.toKey()], param.shortAmount);\n        }\n\n        // stop the guard of reentrancy\n        lowerGuard(param.token0, param.token1, param.strike, param.maturity);\n    }\n}"
    }
  ]
}