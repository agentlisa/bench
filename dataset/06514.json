{
  "Title": "[G-24] Access mappings directly rather than using accessor functions",
  "Content": "\nSaves having to do two `JUMP` instructions, along with stack setup.\n\n```solidity\nFile: src/erc-20/ERC20Boost.sol\n87   return _userGauges[user].values();\n\n108  return _userGauges[user].length();\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/erc-20/ERC20Boost.sol#L87\n\n```solidity\nFile: src/erc-20/ERC20Gauges.sol\n144   return _userGauges[user].values();\n\n165   return _userGauges[user].length();\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/erc-20/ERC20Gauges.sol#L144\n\n```solidity\nFile: src/erc-20/ERC20MultiVotes.sol\n132   return _delegates[delegator].values();\n\n137   return _delegates[delegator].length();\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/erc-20/ERC20MultiVotes.sol#L132\n\n```solidity\nFile: src/erc-4626/ERC4626.sol\n164   return balanceOf[owner];\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/erc-4626/ERC4626.sol#L164\n\n```solidity\nFile: src/erc-4626/ERC4626MultiToken.sol\n285   return balanceOf[owner];\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/erc-4626/ERC4626MultiToken.sol#L285\n\n```solidity\nFile: src/erc-4626/UlyssesERC4626.sol\n121   return balanceOf[owner];\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/erc-4626/UlyssesERC4626.sol#L121\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/erc-20/ERC20Boost.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {EnumerableSet} from \"@lib/EnumerableSet.sol\";\n\nimport {IBaseV2Gauge} from \"@gauges/interfaces/IBaseV2Gauge.sol\";\n\nimport {Errors} from \"./interfaces/Errors.sol\";\nimport {IERC20Boost} from \"./interfaces/IERC20Boost.sol\";\n\n/// @title An ERC20 with an embedded attachment mechanism to keep track of boost\n///        allocations to gauges.\nabstract contract ERC20Boost is ERC20, Ownable, IERC20Boost {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeCastLib for *;\n\n    /*///////////////////////////////////////////////////////////////\n                            GAUGE STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    mapping(address => mapping(address => GaugeState)) public override getUserGaugeBoost;\n\n    /// @inheritdoc IERC20Boost\n    mapping(address => uint256) public override getUserBoost;\n\n    mapping(address => EnumerableSet.AddressSet) internal _userGauges;\n\n    EnumerableSet.AddressSet internal _gauges;\n\n    // Store deprecated gauges in case a user needs to free dead boost\n    EnumerableSet.AddressSet internal _deprecatedGauges;\n\n    /*///////////////////////////////////////////////////////////////\n                            VIEW HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function gauges() external view returns (address[] memory) {\n        return _gauges.values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function gauges(uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _gauges.at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function isGauge(address gauge) external view returns (bool) {\n        return _gauges.contains(gauge) && !_deprecatedGauges.contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numGauges() external view returns (uint256) {\n        return _gauges.length();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function deprecatedGauges() external view returns (address[] memory) {\n        return _deprecatedGauges.values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numDeprecatedGauges() external view returns (uint256) {\n        return _deprecatedGauges.length();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function freeGaugeBoost(address user) public view returns (uint256) {\n        return balanceOf[user] - getUserBoost[user];\n    }\n\n    /// @inheritdoc IERC20Boost\n    function userGauges(address user) external view returns (address[] memory) {\n        return _userGauges[user].values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function isUserGauge(address user, address gauge) external view returns (bool) {\n        return _userGauges[user].contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function userGauges(address user, uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _userGauges[user].at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numUserGauges(address user) external view returns (uint256) {\n        return _userGauges[user].length();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function attach(address user) external {\n        if (!_gauges.contains(msg.sender) || _deprecatedGauges.contains(msg.sender)) {\n            revert InvalidGauge();\n        }\n\n        // idempotent add\n        if (!_userGauges[user].add(msg.sender)) revert GaugeAlreadyAttached();\n\n        uint128 userGaugeBoost = balanceOf[user].toUint128();\n\n        if (getUserBoost[user] < userGaugeBoost) {\n            getUserBoost[user] = userGaugeBoost;\n            emit UpdateUserBoost(user, userGaugeBoost);\n        }\n\n        getUserGaugeBoost[user][msg.sender] =\n            GaugeState({userGaugeBoost: userGaugeBoost, totalGaugeBoost: totalSupply.toUint128()});\n\n        emit Attach(user, msg.sender, userGaugeBoost);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function detach(address user) external {\n        require(_userGauges[user].remove(msg.sender));\n        delete getUserGaugeBoost[user][msg.sender];\n\n        emit Detach(user, msg.sender);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        USER GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function updateUserBoost(address user) external {\n        uint256 userBoost = 0;\n\n        address[] memory gaugeList = _userGauges[user].values();\n\n        uint256 length = gaugeList.length;\n        for (uint256 i = 0; i < length;) {\n            address gauge = gaugeList[i];\n\n            if (!_deprecatedGauges.contains(gauge)) {\n                uint256 gaugeBoost = getUserGaugeBoost[user][gauge].userGaugeBoost;\n\n                if (userBoost < gaugeBoost) userBoost = gaugeBoost;\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n        getUserBoost[user] = userBoost;\n\n        emit UpdateUserBoost(user, userBoost);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugeBoost(address gauge, uint256 boost) public {\n        GaugeState storage gaugeState = getUserGaugeBoost[msg.sender][gauge];\n        if (boost >= gaugeState.userGaugeBoost) {\n            _userGauges[msg.sender].remove(gauge);\n            delete getUserGaugeBoost[msg.sender][gauge];\n\n            emit Detach(msg.sender, gauge);\n        } else {\n            gaugeState.userGaugeBoost -= boost.toUint128();\n\n            emit DecrementUserGaugeBoost(msg.sender, gauge, gaugeState.userGaugeBoost);\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugeAllBoost(address gauge) external {\n        require(_userGauges[msg.sender].remove(gauge));\n        delete getUserGaugeBoost[msg.sender][gauge];\n\n        emit Detach(msg.sender, gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementAllGaugesBoost(uint256 boost) external {\n        decrementGaugesBoostIndexed(boost, 0, _userGauges[msg.sender].length());\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugesBoostIndexed(uint256 boost, uint256 offset, uint256 num) public {\n        address[] memory gaugeList = _userGauges[msg.sender].values();\n\n        uint256 length = gaugeList.length;\n        for (uint256 i = 0; i < num && i < length;) {\n            address gauge = gaugeList[offset + i];\n\n            GaugeState storage gaugeState = getUserGaugeBoost[msg.sender][gauge];\n\n            if (_deprecatedGauges.contains(gauge) || boost >= gaugeState.userGaugeBoost) {\n                require(_userGauges[msg.sender].remove(gauge)); // Remove from set. Should never fail.\n                delete getUserGaugeBoost[msg.sender][gauge];\n\n                emit Detach(msg.sender, gauge);\n            } else {\n                gaugeState.userGaugeBoost -= boost.toUint128();\n\n                emit DecrementUserGaugeBoost(msg.sender, gauge, gaugeState.userGaugeBoost);\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementAllGaugesAllBoost() external {\n        // Loop through all user gauges, live and deprecated\n        address[] memory gaugeList = _userGauges[msg.sender].values();\n\n        // Free gauges until through the entire list\n        uint256 size = gaugeList.length;\n        for (uint256 i = 0; i < size;) {\n            address gauge = gaugeList[i];\n\n            require(_userGauges[msg.sender].remove(gauge)); // Remove from set. Should never fail.\n            delete getUserGaugeBoost[msg.sender][gauge];\n\n            emit Detach(msg.sender, gauge);\n\n            unchecked {\n                i++;\n            }\n        }\n\n        getUserBoost[msg.sender] = 0;\n\n        emit UpdateUserBoost(msg.sender, 0);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function addGauge(address gauge) external onlyOwner {\n        _addGauge(gauge);\n    }\n\n    function _addGauge(address gauge) internal {\n        bool newAdd = _gauges.add(gauge);\n        bool previouslyDeprecated = _deprecatedGauges.remove(gauge);\n        // add and fail loud if zero address or already present and not deprecated\n        if (gauge == address(0) || !(newAdd || previouslyDeprecated)) revert InvalidGauge();\n\n        emit AddGauge(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function removeGauge(address gauge) external onlyOwner {\n        _removeGauge(gauge);\n    }\n\n    function _removeGauge(address gauge) internal {\n        // add to deprecated and fail loud if not present\n        if (!_deprecatedGauges.add(gauge)) revert InvalidGauge();\n\n        emit RemoveGauge(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function replaceGauge(address oldGauge, address newGauge) external onlyOwner {\n        _removeGauge(oldGauge);\n        _addGauge(newGauge);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// NOTE: any \"removal\" of tokens from a user requires notAttached < amount.\n\n    /**\n     * @notice Burns `amount` of tokens from `from` address.\n     * @dev User must have enough free boost.\n     * @param from The address to burn tokens from.\n     * @param amount The amount of tokens to burn.\n     */\n    function _burn(address from, uint256 amount) internal override notAttached(from, amount) {\n        super._burn(from, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `msg.sender` to `to` address.\n     * @dev User must have enough free boost.\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transfer(address to, uint256 amount) public override notAttached(msg.sender, amount) returns (bool) {\n        return super.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `from` address to `to` address.\n     * @dev User must have enough free boost.\n     * @param from the address to transfer from.\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transferFrom(address from, address to, uint256 amount)\n        public\n        override\n        notAttached(from, amount)\n        returns (bool)\n    {\n        return super.transferFrom(from, to, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Reverts if the user does not have enough free boost.\n     * @param user The user address.\n     * @param amount The amount of boost.\n     */\n    modifier notAttached(address user, uint256 amount) {\n        if (freeGaugeBoost(user) < amount) revert AttachedBoost();\n        _;\n    }\n}"
    },
    {
      "filename": "src/erc-20/ERC20Gauges.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Gauge weight logic inspired by Tribe DAO Contracts (flywheel-v2/src/token/ERC20Gauges.sol)\npragma solidity ^0.8.0;\n\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {EnumerableSet} from \"@lib/EnumerableSet.sol\";\n\nimport {IBaseV2Gauge} from \"@gauges/interfaces/IBaseV2Gauge.sol\";\n\nimport {ERC20MultiVotes} from \"./ERC20MultiVotes.sol\";\n\nimport {Errors} from \"./interfaces/Errors.sol\";\nimport {IERC20Gauges} from \"./interfaces/IERC20Gauges.sol\";\n\n/// @title  An ERC20 with an embedded \"Gauge\" style vote with liquid weights\nabstract contract ERC20Gauges is ERC20MultiVotes, ReentrancyGuard, IERC20Gauges {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeCastLib for *;\n\n    /**\n     * @notice Construct a new ERC20Gauges\n     * @param _gaugeCycleLength the length of a gauge cycle in seconds\n     * @param _incrementFreezeWindow the length of the grace period in seconds\n     */\n    constructor(uint32 _gaugeCycleLength, uint32 _incrementFreezeWindow) {\n        if (_incrementFreezeWindow >= _gaugeCycleLength) revert IncrementFreezeError();\n        gaugeCycleLength = _gaugeCycleLength;\n        incrementFreezeWindow = _incrementFreezeWindow;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            GAUGE STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Gauges\n    uint32 public immutable override gaugeCycleLength;\n\n    /// @inheritdoc IERC20Gauges\n    uint32 public immutable override incrementFreezeWindow;\n\n    /// @inheritdoc IERC20Gauges\n    mapping(address => mapping(address => uint112)) public override getUserGaugeWeight;\n\n    /// @inheritdoc IERC20Gauges\n    /// @dev NOTE this may contain weights for deprecated gauges\n    mapping(address => uint112) public override getUserWeight;\n\n    /// @notice a mapping from a gauge to the total weight allocated to it\n    /// @dev NOTE this may contain weights for deprecated gauges\n    mapping(address => Weight) internal _getGaugeWeight;\n\n    /// @notice the total global allocated weight ONLY of live gauges\n    Weight internal _totalWeight;\n\n    mapping(address => EnumerableSet.AddressSet) internal _userGauges;\n\n    EnumerableSet.AddressSet internal _gauges;\n\n    // Store deprecated gauges in case a user needs to free dead weight\n    EnumerableSet.AddressSet internal _deprecatedGauges;\n\n    /*///////////////////////////////////////////////////////////////\n                              VIEW HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Gauges\n    function getGaugeCycleEnd() external view returns (uint32) {\n        return _getGaugeCycleEnd();\n    }\n\n    function _getGaugeCycleEnd() internal view returns (uint32) {\n        uint32 nowPlusOneCycle = block.timestamp.toUint32() + gaugeCycleLength;\n        unchecked {\n            return (nowPlusOneCycle / gaugeCycleLength) * gaugeCycleLength; // cannot divide by zero and always <= nowPlusOneCycle so no overflow\n        }\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function getGaugeWeight(address gauge) external view returns (uint112) {\n        return _getGaugeWeight[gauge].currentWeight;\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function getStoredGaugeWeight(address gauge) external view returns (uint112) {\n        if (_deprecatedGauges.contains(gauge)) return 0;\n        return _getStoredWeight(_getGaugeWeight[gauge], _getGaugeCycleEnd());\n    }\n\n    function _getStoredWeight(Weight storage gaugeWeight, uint32 currentCycle) internal view returns (uint112) {\n        return gaugeWeight.currentCycle < currentCycle ? gaugeWeight.currentWeight : gaugeWeight.storedWeight;\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function totalWeight() external view returns (uint112) {\n        return _totalWeight.currentWeight;\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function storedTotalWeight() external view returns (uint112) {\n        return _getStoredWeight(_totalWeight, _getGaugeCycleEnd());\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function gauges() external view returns (address[] memory) {\n        return _gauges.values();\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function gauges(uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _gauges.at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function isGauge(address gauge) external view returns (bool) {\n        return _gauges.contains(gauge) && !_deprecatedGauges.contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function numGauges() external view returns (uint256) {\n        return _gauges.length();\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function deprecatedGauges() external view returns (address[] memory) {\n        return _deprecatedGauges.values();\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function numDeprecatedGauges() external view returns (uint256) {\n        return _deprecatedGauges.length();\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function userGauges(address user) external view returns (address[] memory) {\n        return _userGauges[user].values();\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function isUserGauge(address user, address gauge) external view returns (bool) {\n        return _userGauges[user].contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function userGauges(address user, uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _userGauges[user].at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function numUserGauges(address user) external view returns (uint256) {\n        return _userGauges[user].length();\n    }\n\n    /// @inheritdoc ERC20MultiVotes\n    function userUnusedVotes(address user) public view override returns (uint256) {\n        return super.userUnusedVotes(user) - getUserWeight[user];\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function calculateGaugeAllocation(address gauge, uint256 quantity) external view returns (uint256) {\n        if (_deprecatedGauges.contains(gauge)) return 0;\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        uint112 total = _getStoredWeight(_totalWeight, currentCycle);\n        uint112 weight = _getStoredWeight(_getGaugeWeight[gauge], currentCycle);\n        return (quantity * weight) / total;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        USER GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Gauges\n    function incrementGauge(address gauge, uint112 weight) external nonReentrant returns (uint112 newUserWeight) {\n        uint32 currentCycle = _getGaugeCycleEnd();\n        _incrementGaugeWeight(msg.sender, gauge, weight, currentCycle);\n        return _incrementUserAndGlobalWeights(msg.sender, weight, currentCycle);\n    }\n\n    /**\n     * @notice Increment the weight of a gauge for a user\n     * @dev This function calls accrueBribes for the gauge to ensure the gauge handles the balance change.\n     * @param user the user to increment the weight of\n     * @param gauge the gauge to increment the weight of\n     * @param weight the weight to increment by\n     * @param cycle the cycle to increment the weight for\n     */\n    function _incrementGaugeWeight(address user, address gauge, uint112 weight, uint32 cycle) internal {\n        if (!_gauges.contains(gauge) || _deprecatedGauges.contains(gauge)) revert InvalidGaugeError();\n        unchecked {\n            if (cycle - block.timestamp <= incrementFreezeWindow) revert IncrementFreezeError();\n        }\n\n        IBaseV2Gauge(gauge).accrueBribes(user);\n\n        bool added = _userGauges[user].add(gauge); // idempotent add\n        if (added && _userGauges[user].length() > maxGauges && !canContractExceedMaxGauges[user]) {\n            revert MaxGaugeError();\n        }\n\n        getUserGaugeWeight[user][gauge] += weight;\n\n        _writeGaugeWeight(_getGaugeWeight[gauge], _add112, weight, cycle);\n\n        emit IncrementGaugeWeight(user, gauge, weight, cycle);\n    }\n\n    /**\n     * @notice Increment the weight of a gauge for a user and the total weight\n     * @param user the user to increment the weight of\n     * @param weight the weight to increment by\n     * @param cycle the cycle to increment the weight for\n     * @return newUserWeight the new user's weight\n     */\n    function _incrementUserAndGlobalWeights(address user, uint112 weight, uint32 cycle)\n        internal\n        returns (uint112 newUserWeight)\n    {\n        newUserWeight = getUserWeight[user] + weight;\n\n        // new user weight must be less than or equal to the total user weight\n        if (newUserWeight > getVotes(user)) revert OverWeightError();\n\n        // Update gauge state\n        getUserWeight[user] = newUserWeight;\n\n        _writeGaugeWeight(_totalWeight, _add112, weight, cycle);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function incrementGauges(address[] calldata gaugeList, uint112[] calldata weights)\n        external\n        nonReentrant\n        returns (uint256 newUserWeight)\n    {\n        uint256 size = gaugeList.length;\n        if (weights.length != size) revert SizeMismatchError();\n\n        // store total in summary for a batch update on user/global state\n        uint112 weightsSum;\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // Update a gauge's specific state\n        for (uint256 i = 0; i < size;) {\n            address gauge = gaugeList[i];\n            uint112 weight = weights[i];\n            weightsSum += weight;\n\n            _incrementGaugeWeight(msg.sender, gauge, weight, currentCycle);\n            unchecked {\n                i++;\n            }\n        }\n        return _incrementUserAndGlobalWeights(msg.sender, weightsSum, currentCycle);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function decrementGauge(address gauge, uint112 weight) external nonReentrant returns (uint112 newUserWeight) {\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // All operations will revert on underflow, protecting against bad inputs\n        _decrementGaugeWeight(msg.sender, gauge, weight, currentCycle);\n        if (!_deprecatedGauges.contains(gauge)) {\n            _writeGaugeWeight(_totalWeight, _subtract112, weight, currentCycle);\n        }\n        return _decrementUserWeights(msg.sender, weight);\n    }\n\n    /**\n     * @notice Decrement the weight of a gauge for a user\n     * @dev This function calls accrueBribes for the gauge to ensure the gauge handles the balance change.\n     * @param user the user to decrement the weight of\n     * @param gauge the gauge to decrement the weight of\n     * @param weight the weight to decrement by\n     * @param cycle the cycle to decrement the weight for\n     */\n    function _decrementGaugeWeight(address user, address gauge, uint112 weight, uint32 cycle) internal {\n        if (!_gauges.contains(gauge)) revert InvalidGaugeError();\n\n        uint112 oldWeight = getUserGaugeWeight[user][gauge];\n\n        IBaseV2Gauge(gauge).accrueBribes(user);\n\n        getUserGaugeWeight[user][gauge] = oldWeight - weight;\n        if (oldWeight == weight) {\n            // If removing all weight, remove gauge from user list.\n            require(_userGauges[user].remove(gauge));\n        }\n\n        _writeGaugeWeight(_getGaugeWeight[gauge], _subtract112, weight, cycle);\n\n        emit DecrementGaugeWeight(user, gauge, weight, cycle);\n    }\n\n    /**\n     * @notice Decrement the weight of a gauge for a user and the total weight\n     * @param user the user to decrement the weight of\n     * @param weight the weight to decrement by\n     * @return newUserWeight the new user's weight\n     */\n    function _decrementUserWeights(address user, uint112 weight) internal returns (uint112 newUserWeight) {\n        newUserWeight = getUserWeight[user] - weight;\n        getUserWeight[user] = newUserWeight;\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function decrementGauges(address[] calldata gaugeList, uint112[] calldata weights)\n        external\n        nonReentrant\n        returns (uint112 newUserWeight)\n    {\n        uint256 size = gaugeList.length;\n        if (weights.length != size) revert SizeMismatchError();\n\n        // store total in summary for the batch update on user and global state\n        uint112 weightsSum;\n        uint112 globalWeightsSum;\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // Update the gauge's specific state\n        // All operations will revert on underflow, protecting against bad inputs\n        for (uint256 i = 0; i < size;) {\n            address gauge = gaugeList[i];\n            uint112 weight = weights[i];\n            weightsSum += weight;\n            if (!_deprecatedGauges.contains(gauge)) globalWeightsSum += weight;\n\n            _decrementGaugeWeight(msg.sender, gauge, weight, currentCycle);\n            unchecked {\n                i++;\n            }\n        }\n        _writeGaugeWeight(_totalWeight, _subtract112, globalWeightsSum, currentCycle);\n\n        return _decrementUserWeights(msg.sender, weightsSum);\n    }\n\n    /**\n     * @dev this function is the key to the entire contract.\n     *  The storage weight it operates on is either a global or gauge-specific weight.\n     *  The operation applied is either addition for incrementing gauges or subtraction for decrementing a gauge.\n     * @param weight the weight to apply the operation to\n     * @param op the operation to apply\n     * @param delta the amount to apply the operation by\n     * @param cycle the cycle to apply the operation for\n     */\n    function _writeGaugeWeight(\n        Weight storage weight,\n        function(uint112, uint112) view returns (uint112) op,\n        uint112 delta,\n        uint32 cycle\n    ) private {\n        uint112 currentWeight = weight.currentWeight;\n        // If the last cycle of the weight is before the current cycle, use the current weight as the stored.\n        uint112 stored = weight.currentCycle < cycle ? currentWeight : weight.storedWeight;\n        uint112 newWeight = op(currentWeight, delta);\n\n        weight.storedWeight = stored;\n        weight.currentWeight = newWeight;\n        weight.currentCycle = cycle;\n    }\n\n    function _add112(uint112 a, uint112 b) private pure returns (uint112) {\n        return a + b;\n    }\n\n    function _subtract112(uint112 a, uint112 b) private pure returns (uint112) {\n        return a - b;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Gauges\n    uint256 public override maxGauges;\n\n    /// @inheritdoc IERC20Gauges\n    mapping(address => bool) public override canContractExceedMaxGauges;\n\n    /// @inheritdoc IERC20Gauges\n    function addGauge(address gauge) external onlyOwner returns (uint112) {\n        return _addGauge(gauge);\n    }\n\n    /**\n     * @notice Add a gauge to the contract\n     * @param gauge the gauge to add\n     * @return weight the previous weight of the gauge, if it was already added\n     */\n    function _addGauge(address gauge) internal returns (uint112 weight) {\n        bool newAdd = _gauges.add(gauge);\n        bool previouslyDeprecated = _deprecatedGauges.remove(gauge);\n        // add and fail loud if zero address or already present and not deprecated\n        if (gauge == address(0) || !(newAdd || previouslyDeprecated)) revert InvalidGaugeError();\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // Check if some previous weight exists and re-add to the total. Gauge and user weights are preserved.\n        weight = _getGaugeWeight[gauge].currentWeight;\n        if (weight > 0) {\n            _writeGaugeWeight(_totalWeight, _add112, weight, currentCycle);\n        }\n\n        emit AddGauge(gauge);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function removeGauge(address gauge) external onlyOwner {\n        _removeGauge(gauge);\n    }\n\n    /**\n     * @notice Remove a gauge from the contract\n     * @param gauge the gauge to remove\n     */\n    function _removeGauge(address gauge) internal {\n        // add to deprecated and fail loud if not present\n        if (!_deprecatedGauges.add(gauge)) revert InvalidGaugeError();\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // Remove weight from total but keep the gauge and user weights in storage in case the gauge is re-added.\n        uint112 weight = _getGaugeWeight[gauge].currentWeight;\n        if (weight > 0) {\n            _writeGaugeWeight(_totalWeight, _subtract112, weight, currentCycle);\n        }\n\n        emit RemoveGauge(gauge);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function replaceGauge(address oldGauge, address newGauge) external onlyOwner {\n        _removeGauge(oldGauge);\n        _addGauge(newGauge);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function setMaxGauges(uint256 newMax) external onlyOwner {\n        uint256 oldMax = maxGauges;\n        maxGauges = newMax;\n\n        emit MaxGaugesUpdate(oldMax, newMax);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function setContractExceedMaxGauges(address account, bool canExceedMax) external onlyOwner {\n        if (canExceedMax && account.code.length == 0) revert Errors.NonContractError(); // can only approve contracts\n\n        canContractExceedMaxGauges[account] = canExceedMax;\n\n        emit CanContractExceedMaxGaugesUpdate(account, canExceedMax);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// NOTE: any \"removal\" of tokens from a user requires userUnusedVotes < amount.\n    /// _decrementWeightUntilFree is called as a greedy algorithm to free up weight.\n    /// It may be more gas efficient to free weight before burning or transferring tokens.\n\n    /**\n     * @notice Burns `amount` of tokens from `from` address.\n     * @dev Frees weights and votes with a greedy algorithm if needed to burn tokens\n     * @param from The address to burn tokens from.\n     * @param amount The amount of tokens to burn.\n     */\n    function _burn(address from, uint256 amount) internal virtual override {\n        _decrementWeightUntilFree(from, amount);\n        super._burn(from, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `msg.sender` to `to` address.\n     * @dev Frees weights and votes with a greedy algorithm if needed to burn tokens\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        _decrementWeightUntilFree(msg.sender, amount);\n        return super.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `from` address to `to` address.\n     * @dev Frees weights and votes with a greedy algorithm if needed to burn tokens\n     * @param from the address to transfer from.\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        _decrementWeightUntilFree(from, amount);\n        return super.transferFrom(from, to, amount);\n    }\n\n    /**\n     * @notice A greedy algorithm for freeing weight before a token burn/transfer\n     * @dev Frees up entire gauges, so likely will free more than `weight`\n     * @param user the user to free weight for\n     * @param weight the weight to free\n     */\n    function _decrementWeightUntilFree(address user, uint256 weight) internal nonReentrant {\n        uint256 userFreeWeight = freeVotes(user) + userUnusedVotes(user);\n\n        // early return if already free\n        if (userFreeWeight >= weight) return;\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // cache totals for batch updates\n        uint112 userFreed;\n        uint112 totalFreed;\n\n        // Loop through all user gauges, live and deprecated\n        address[] memory gaugeList = _userGauges[user].values();\n\n        // Free gauges through the entire list or until underweight\n        uint256 size = gaugeList.length;\n        for (uint256 i = 0; i < size && (userFreeWeight + totalFreed) < weight;) {\n            address gauge = gaugeList[i];\n            uint112 userGaugeWeight = getUserGaugeWeight[user][gauge];\n            if (userGaugeWeight != 0) {\n                // If the gauge is live (not deprecated), include its weigh"
    }
  ]
}