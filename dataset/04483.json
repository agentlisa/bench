{
  "Title": "Encapsulation issues make the code hard to read",
  "Content": "Encapsulation is essential for writing clean and readable code. However, in a language like Solidity it is very hard to encapsulate the code. Contract oriented programming is not quite like object oriented programming, so its flexibility and limitations affect the design of the project.\n\n\nThe Solo team decided to heavily use structs and libraries for encapsulation. This is a nice idea, but it brings its own challenges due to important details for understanding functions being spread across many files.\n\n\nMost of the readability problems can be mitigated by adding extensive comments as explained in the *Missing docstrings* issue reported above. Some other parts can be improved by following the rule of “low coupling and high cohesion”. And some others by making layers of code as minimal as possible, which has the added benefit of reducing the attack surface and making each layer easier to test.\n\n\nFollowing are examples of encapsulation pain points that made it difficult to review the Solo code, or possible improvements for the encapsulation design.\n\n\n* Rather than passing the entire `State` struct into functions, only pass in the specific pieces of state that will be operated on. This makes it easier to understand what a function is doing and ensures only the intended pieces of state are changed.\n* There is a circular dependency between the [`Storage`](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/lib/Storage.sol) and [`Cache`](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/lib/Cache.sol) contracts. As suggested above, consider passing in only the necessary parameters rather a `State` struct to [`Cache.addMarket()`](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/lib/Cache.sol#L61) to remove `Cache`‘s dependency on `Storage`.\n* There is a contract called [`Getters`](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/Getters.sol). This fails at cohesion because it is too generic and it is too far from the setter functions and the state it is querying. Consider moving all the getter and setter functions, and state variables they manipulate, to the same contract.\n* The same functionality to revert if a market does not exist is implemented in two different contracts: [`requireValidMarket`](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/Getters.sol#L393) [in](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/Getters.sol#L393) [`Getters.sol`](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/Getters.sol#L393) and [`validateMarketId`](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/impl/AdminImpl.sol#L345) [`in`](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/impl/AdminImpl.sol#L345) [`AdminImpl.sol`](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/impl/AdminImpl.sol#L345). Consider moving this function to a single place, either the [`Storage`](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/lib/Storage.sol) [library](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/lib/Storage.sol) or the [`State`](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/State.sol) [contract](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/State.sol).\n* The `getMarketCurrentIndex` function [calls the](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/Getters.sol#L154) [`fetchNewIndex`](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/Getters.sol#L154) [function of the](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/Getters.sol#L154) [`Storage`](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/Getters.sol#L154) [library](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/Getters.sol#L154), passing as an argument the return value of a function of the same `Storage` library. Instead of calling two functions from the same library in a single statement, consider defining a new function `fetchCurrentIndex` in the `Storage` library.\n* The [`Admin`](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/Admin.sol) [contract](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/Admin.sol) is just a thin layer that adds security modifiers to the [`AdminImpl`](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/impl/AdminImpl.sol) [contract](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/impl/AdminImpl.sol) where it forwards all the calls. This means that `AdminImpl` is not usable on its own because it is not safe. Consider moving all the implementations into the `Admin` contract and dropping `AdminImpl`. It could make sense to define an [interface](https://solidity.readthedocs.io/en/v0.5.4/contracts.html#interfaces) to specify the Administrator functions in a clear way, and to make it easy to have alternate implementations.\n* When an [index is updated](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/lib/Storage.sol#L540), the corresponding [event is emitted by](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/impl/OperationImpl.sol#L211) [`OperationImpl`](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/impl/OperationImpl.sol#L211). Consider emitting the event inside the `updateIndex` function. This would be a clearer assignment of responsibilities, and it ensures that it is not possible to update the index and forget to emit the event.\n\n\nWhen the more readable design cannot be implemented because of the Ethereum contract size limitations, consider explaining this in the comments of the source code, and supplement the sub-optimal implementation with extra comments to guide the readers and future contributors.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/protocol/Getters.sol",
      "content": "/*\n\n    Copyright 2018 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.4;\npragma experimental ABIEncoderV2;\n\nimport { State } from \"./State.sol\";\nimport { IInterestSetter } from \"./interfaces/IInterestSetter.sol\";\nimport { IPriceOracle } from \"./interfaces/IPriceOracle.sol\";\nimport { Account } from \"./lib/Account.sol\";\nimport { Cache } from \"./lib/Cache.sol\";\nimport { Decimal } from \"./lib/Decimal.sol\";\nimport { Interest } from \"./lib/Interest.sol\";\nimport { Monetary } from \"./lib/Monetary.sol\";\nimport { Require } from \"./lib/Require.sol\";\nimport { Storage } from \"./lib/Storage.sol\";\nimport { Token } from \"./lib/Token.sol\";\nimport { Types } from \"./lib/Types.sol\";\n\n\n/**\n * @title Getters\n * @author dYdX\n *\n * Public read-only functions that allow transparency into the state of Solo\n */\ncontract Getters is\n    State\n{\n    using Cache for Cache.MarketCache;\n    using Storage for Storage.State;\n    using Types for Types.Par;\n\n    // ============ Constants ============\n\n    bytes32 FILE = \"Getters\";\n\n    // ============ Getters for Risk ============\n\n    function getMarginRatio()\n        public\n        view\n        returns (Decimal.D256 memory)\n    {\n        return g_state.riskParams.marginRatio;\n    }\n\n    function getLiquidationSpread()\n        public\n        view\n        returns (Decimal.D256 memory)\n    {\n        return g_state.riskParams.liquidationSpread;\n    }\n\n    function getEarningsRate()\n        public\n        view\n        returns (Decimal.D256 memory)\n    {\n        return g_state.riskParams.earningsRate;\n    }\n\n    function getMinBorrowedValue()\n        public\n        view\n        returns (Monetary.Value memory)\n    {\n        return g_state.riskParams.minBorrowedValue;\n    }\n\n    function getRiskParams()\n        public\n        view\n        returns (Storage.RiskParams memory)\n    {\n        return g_state.riskParams;\n    }\n\n    function getRiskLimits()\n        public\n        view\n        returns (Storage.RiskLimits memory)\n    {\n        return g_state.riskLimits;\n    }\n\n    // ============ Getters for Markets ============\n\n    function getNumMarkets()\n        public\n        view\n        returns (uint256)\n    {\n        return g_state.numMarkets;\n    }\n\n    function getMarketTokenAddress(\n        uint256 marketId\n    )\n        public\n        view\n        returns (address)\n    {\n        _requireValidMarket(marketId);\n        return g_state.getToken(marketId);\n    }\n\n    function getMarketTotalPar(\n        uint256 marketId\n    )\n        public\n        view\n        returns (Types.TotalPar memory)\n    {\n        _requireValidMarket(marketId);\n        return g_state.getTotalPar(marketId);\n    }\n\n    function getMarketCachedIndex(\n        uint256 marketId\n    )\n        public\n        view\n        returns (Interest.Index memory)\n    {\n        _requireValidMarket(marketId);\n        return g_state.getIndex(marketId);\n    }\n\n    function getMarketCurrentIndex(\n        uint256 marketId\n    )\n        public\n        view\n        returns (Interest.Index memory)\n    {\n        _requireValidMarket(marketId);\n        return g_state.fetchNewIndex(marketId, g_state.getIndex(marketId));\n    }\n\n    function getMarketPriceOracle(\n        uint256 marketId\n    )\n        public\n        view\n        returns (IPriceOracle)\n    {\n        _requireValidMarket(marketId);\n        return g_state.markets[marketId].priceOracle;\n    }\n\n    function getMarketInterestSetter(\n        uint256 marketId\n    )\n        public\n        view\n        returns (IInterestSetter)\n    {\n        _requireValidMarket(marketId);\n        return g_state.markets[marketId].interestSetter;\n    }\n\n    function getMarketMarginPremium(\n        uint256 marketId\n    )\n        public\n        view\n        returns (Decimal.D256 memory)\n    {\n        _requireValidMarket(marketId);\n        return g_state.markets[marketId].marginPremium;\n    }\n\n    function getMarketSpreadPremium(\n        uint256 marketId\n    )\n        public\n        view\n        returns (Decimal.D256 memory)\n    {\n        _requireValidMarket(marketId);\n        return g_state.markets[marketId].spreadPremium;\n    }\n\n    function getMarketIsClosing(\n        uint256 marketId\n    )\n        public\n        view\n        returns (bool)\n    {\n        _requireValidMarket(marketId);\n        return g_state.markets[marketId].isClosing;\n    }\n\n    function getMarketPrice(\n        uint256 marketId\n    )\n        public\n        view\n        returns (Monetary.Price memory)\n    {\n        _requireValidMarket(marketId);\n        return g_state.fetchPrice(marketId);\n    }\n\n    function getMarketInterestRate(\n        uint256 marketId\n    )\n        public\n        view\n        returns (Interest.Rate memory)\n    {\n        _requireValidMarket(marketId);\n        return g_state.fetchInterestRate(\n            marketId,\n            g_state.getIndex(marketId)\n        );\n    }\n\n    function getMarket(\n        uint256 marketId\n    )\n        public\n        view\n        returns (Storage.Market memory)\n    {\n        _requireValidMarket(marketId);\n        return g_state.markets[marketId];\n    }\n\n    function getMarketWithInfo(\n        uint256 marketId\n    )\n        public\n        view\n        returns (\n            Storage.Market memory,\n            Interest.Index memory,\n            Monetary.Price memory,\n            Interest.Rate memory\n        )\n    {\n        _requireValidMarket(marketId);\n        return (\n            getMarket(marketId),\n            getMarketCurrentIndex(marketId),\n            getMarketPrice(marketId),\n            getMarketInterestRate(marketId)\n        );\n    }\n\n    function getNumExcessTokens(\n        uint256 marketId\n    )\n        public\n        view\n        returns (Types.Wei memory)\n    {\n        _requireValidMarket(marketId);\n        return g_state.getNumExcessTokens(marketId);\n    }\n\n    // ============ Getters for Accounts ============\n\n    function getAccountPar(\n        Account.Info memory account,\n        uint256 marketId\n    )\n        public\n        view\n        returns (Types.Par memory)\n    {\n        _requireValidMarket(marketId);\n        return g_state.getPar(account, marketId);\n    }\n\n    function getAccountWei(\n        Account.Info memory account,\n        uint256 marketId\n    )\n        public\n        view\n        returns (Types.Wei memory)\n    {\n        _requireValidMarket(marketId);\n        return Interest.parToWei(\n            g_state.getPar(account, marketId),\n            g_state.fetchNewIndex(marketId, g_state.getIndex(marketId))\n        );\n    }\n\n    function getAccountStatus(\n        Account.Info memory account\n    )\n        public\n        view\n        returns (Account.Status)\n    {\n        return g_state.getStatus(account);\n    }\n\n    function getAccountValues(\n        Account.Info memory account\n    )\n        public\n        view\n        returns (Monetary.Value memory, Monetary.Value memory)\n    {\n        return getAccountValuesInternal(account, false);\n    }\n\n    function getAdjustedAccountValues(\n        Account.Info memory account\n    )\n        public\n        view\n        returns (Monetary.Value memory, Monetary.Value memory)\n    {\n        return getAccountValuesInternal(account, true);\n    }\n\n    function getAccountBalances(\n        Account.Info memory account\n    )\n        public\n        view\n        returns (\n            address[] memory,\n            Types.Par[] memory,\n            Types.Wei[] memory\n        )\n    {\n        uint256 numMarkets = g_state.numMarkets;\n        address[] memory tokens = new address[](numMarkets);\n        Types.Par[] memory pars = new Types.Par[](numMarkets);\n        Types.Wei[] memory weis = new Types.Wei[](numMarkets);\n\n        for (uint256 m = 0; m < numMarkets; m++) {\n            tokens[m] = getMarketTokenAddress(m);\n            pars[m] = getAccountPar(account, m);\n            weis[m] = getAccountWei(account, m);\n        }\n\n        return (\n            tokens,\n            pars,\n            weis\n        );\n    }\n\n    // ============ Getters for Permissions ============\n\n    function getIsLocalOperator(\n        address owner,\n        address operator\n    )\n        public\n        view\n        returns (bool)\n    {\n        return g_state.isLocalOperator(owner, operator);\n    }\n\n    function getIsGlobalOperator(\n        address operator\n    )\n        public\n        view\n        returns (bool)\n    {\n        return g_state.isGlobalOperator(operator);\n    }\n\n    // ============ Private Helper Functions ============\n\n    function _requireValidMarket(\n        uint256 marketId\n    )\n        private\n        view\n    {\n        Require.that(\n            marketId < g_state.numMarkets,\n            FILE,\n            \"Market OOB\"\n        );\n    }\n\n    function getAccountValuesInternal(\n        Account.Info memory account,\n        bool adjustForLiquidity\n    )\n        private\n        view\n        returns (Monetary.Value memory, Monetary.Value memory)\n    {\n        uint256 numMarkets = g_state.numMarkets;\n\n        // populate cache\n        Cache.MarketCache memory cache = Cache.create(numMarkets);\n        for (uint256 m = 0; m < numMarkets; m++) {\n            if (!g_state.getPar(account, m).isZero()) {\n                cache.addMarket(g_state, m);\n            }\n        }\n\n        return g_state.getAccountValues(account, cache, adjustForLiquidity);\n    }\n}"
    },
    {
      "filename": "contracts/protocol/Getters.sol",
      "content": "/*\n\n    Copyright 2018 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.4;\npragma experimental ABIEncoderV2;\n\nimport { State } from \"./State.sol\";\nimport { IInterestSetter } from \"./interfaces/IInterestSetter.sol\";\nimport { IPriceOracle } from \"./interfaces/IPriceOracle.sol\";\nimport { Account } from \"./lib/Account.sol\";\nimport { Cache } from \"./lib/Cache.sol\";\nimport { Decimal } from \"./lib/Decimal.sol\";\nimport { Interest } from \"./lib/Interest.sol\";\nimport { Monetary } from \"./lib/Monetary.sol\";\nimport { Require } from \"./lib/Require.sol\";\nimport { Storage } from \"./lib/Storage.sol\";\nimport { Token } from \"./lib/Token.sol\";\nimport { Types } from \"./lib/Types.sol\";\n\n\n/**\n * @title Getters\n * @author dYdX\n *\n * Public read-only functions that allow transparency into the state of Solo\n */\ncontract Getters is\n    State\n{\n    using Cache for Cache.MarketCache;\n    using Storage for Storage.State;\n    using Types for Types.Par;\n\n    // ============ Constants ============\n\n    bytes32 FILE = \"Getters\";\n\n    // ============ Getters for Risk ============\n\n    function getMarginRatio()\n        public\n        view\n        returns (Decimal.D256 memory)\n    {\n        return g_state.riskParams.marginRatio;\n    }\n\n    function getLiquidationSpread()\n        public\n        view\n        returns (Decimal.D256 memory)\n    {\n        return g_state.riskParams.liquidationSpread;\n    }\n\n    function getEarningsRate()\n        public\n        view\n        returns (Decimal.D256 memory)\n    {\n        return g_state.riskParams.earningsRate;\n    }\n\n    function getMinBorrowedValue()\n        public\n        view\n        returns (Monetary.Value memory)\n    {\n        return g_state.riskParams.minBorrowedValue;\n    }\n\n    function getRiskParams()\n        public\n        view\n        returns (Storage.RiskParams memory)\n    {\n        return g_state.riskParams;\n    }\n\n    function getRiskLimits()\n        public\n        view\n        returns (Storage.RiskLimits memory)\n    {\n        return g_state.riskLimits;\n    }\n\n    // ============ Getters for Markets ============\n\n    function getNumMarkets()\n        public\n        view\n        returns (uint256)\n    {\n        return g_state.numMarkets;\n    }\n\n    function getMarketTokenAddress(\n        uint256 marketId\n    )\n        public\n        view\n        returns (address)\n    {\n        _requireValidMarket(marketId);\n        return g_state.getToken(marketId);\n    }\n\n    function getMarketTotalPar(\n        uint256 marketId\n    )\n        public\n        view\n        returns (Types.TotalPar memory)\n    {\n        _requireValidMarket(marketId);\n        return g_state.getTotalPar(marketId);\n    }\n\n    function getMarketCachedIndex(\n        uint256 marketId\n    )\n        public\n        view\n        returns (Interest.Index memory)\n    {\n        _requireValidMarket(marketId);\n        return g_state.getIndex(marketId);\n    }\n\n    function getMarketCurrentIndex(\n        uint256 marketId\n    )\n        public\n        view\n        returns (Interest.Index memory)\n    {\n        _requireValidMarket(marketId);\n        return g_state.fetchNewIndex(marketId, g_state.getIndex(marketId));\n    }\n\n    function getMarketPriceOracle(\n        uint256 marketId\n    )\n        public\n        view\n        returns (IPriceOracle)\n    {\n        _requireValidMarket(marketId);\n        return g_state.markets[marketId].priceOracle;\n    }\n\n    function getMarketInterestSetter(\n        uint256 marketId\n    )\n        public\n        view\n        returns (IInterestSetter)\n    {\n        _requireValidMarket(marketId);\n        return g_state.markets[marketId].interestSetter;\n    }\n\n    function getMarketMarginPremium(\n        uint256 marketId\n    )\n        public\n        view\n        returns (Decimal.D256 memory)\n    {\n        _requireValidMarket(marketId);\n        return g_state.markets[marketId].marginPremium;\n    }\n\n    function getMarketSpreadPremium(\n        uint256 marketId\n    )\n        public\n        view\n        returns (Decimal.D256 memory)\n    {\n        _requireValidMarket(marketId);\n        return g_state.markets[marketId].spreadPremium;\n    }\n\n    function getMarketIsClosing(\n        uint256 marketId\n    )\n        public\n        view\n        returns (bool)\n    {\n        _requireValidMarket(marketId);\n        return g_state.markets[marketId].isClosing;\n    }\n\n    function getMarketPrice(\n        uint256 marketId\n    )\n        public\n        view\n        returns (Monetary.Price memory)\n    {\n        _requireValidMarket(marketId);\n        return g_state.fetchPrice(marketId);\n    }\n\n    function getMarketInterestRate(\n        uint256 marketId\n    )\n        public\n        view\n        returns (Interest.Rate memory)\n    {\n        _requireValidMarket(marketId);\n        return g_state.fetchInterestRate(\n            marketId,\n            g_state.getIndex(marketId)\n        );\n    }\n\n    function getMarket(\n        uint256 marketId\n    )\n        public\n        view\n        returns (Storage.Market memory)\n    {\n        _requireValidMarket(marketId);\n        return g_state.markets[marketId];\n    }\n\n    function getMarketWithInfo(\n        uint256 marketId\n    )\n        public\n        view\n        returns (\n            Storage.Market memory,\n            Interest.Index memory,\n            Monetary.Price memory,\n            Interest.Rate memory\n        )\n    {\n        _requireValidMarket(marketId);\n        return (\n            getMarket(marketId),\n            getMarketCurrentIndex(marketId),\n            getMarketPrice(marketId),\n            getMarketInterestRate(marketId)\n        );\n    }\n\n    function getNumExcessTokens(\n        uint256 marketId\n    )\n        public\n        view\n        returns (Types.Wei memory)\n    {\n        _requireValidMarket(marketId);\n        return g_state.getNumExcessTokens(marketId);\n    }\n\n    // ============ Getters for Accounts ============\n\n    function getAccountPar(\n        Account.Info memory account,\n        uint256 marketId\n    )\n        public\n        view\n        returns (Types.Par memory)\n    {\n        _requireValidMarket(marketId);\n        return g_state.getPar(account, marketId);\n    }\n\n    function getAccountWei(\n        Account.Info memory account,\n        uint256 marketId\n    )\n        public\n        view\n        returns (Types.Wei memory)\n    {\n        _requireValidMarket(marketId);\n        return Interest.parToWei(\n            g_state.getPar(account, marketId),\n            g_state.fetchNewIndex(marketId, g_state.getIndex(marketId))\n        );\n    }\n\n    function getAccountStatus(\n        Account.Info memory account\n    )\n        public\n        view\n        returns (Account.Status)\n    {\n        return g_state.getStatus(account);\n    }\n\n    function getAccountValues(\n        Account.Info memory account\n    )\n        public\n        view\n        returns (Monetary.Value memory, Monetary.Value memory)\n    {\n        return getAccountValuesInternal(account, false);\n    }\n\n    function getAdjustedAccountValues(\n        Account.Info memory account\n    )\n        public\n        view\n        returns (Monetary.Value memory, Monetary.Value memory)\n    {\n        return getAccountValuesInternal(account, true);\n    }\n\n    function getAccountBalances(\n        Account.Info memory account\n    )\n        public\n        view\n        returns (\n            address[] memory,\n            Types.Par[] memory,\n            Types.Wei[] memory\n        )\n    {\n        uint256 numMarkets = g_state.numMarkets;\n        address[] memory tokens = new address[](numMarkets);\n        Types.Par[] memory pars = new Types.Par[](numMarkets);\n        Types.Wei[] memory weis = new Types.Wei[](numMarkets);\n\n        for (uint256 m = 0; m < numMarkets; m++) {\n            tokens[m] = getMarketTokenAddress(m);\n            pars[m] = getAccountPar(account, m);\n            weis[m] = getAccountWei(account, m);\n        }\n\n        return (\n            tokens,\n            pars,\n            weis\n        );\n    }\n\n    // ============ Getters for Permissions ============\n\n    function getIsLocalOperator(\n        address owner,\n        address operator\n    )\n        public\n        view\n        returns (bool)\n    {\n        return g_state.isLocalOperator(owner, operator);\n    }\n\n    function getIsGlobalOperator(\n        address operator\n    )\n        public\n        view\n        returns (bool)\n    {\n        return g_state.isGlobalOperator(operator);\n    }\n\n    // ============ Private Helper Functions ============\n\n    function _requireValidMarket(\n        uint256 marketId\n    )\n        private\n        view\n    {\n        Require.that(\n            marketId < g_state.numMarkets,\n            FILE,\n            \"Market OOB\"\n        );\n    }\n\n    function getAccountValuesInternal(\n        Account.Info memory account,\n        bool adjustForLiquidity\n    )\n        private\n        view\n        returns (Monetary.Value memory, Monetary.Value memory)\n    {\n        uint256 numMarkets = g_state.numMarkets;\n\n        // populate cache\n        Cache.MarketCache memory cache = Cache.create(numMarkets);\n        for (uint256 m = 0; m < numMarkets; m++) {\n            if (!g_state.getPar(account, m).isZero()) {\n                cache.addMarket(g_state, m);\n            }\n        }\n\n        return g_state.getAccountValues(account, cache, adjustForLiquidity);\n    }\n}"
    },
    {
      "filename": "contracts/protocol/lib/Storage.sol",
      "content": "/*\n\n    Copyright 2018 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.4;\npragma experimental ABIEncoderV2;\n\nimport { SafeMath } from \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport { Account } from \"./Account.sol\";\nimport { Cache } from \"./Cache.sol\";\nimport { Decimal } from \"./Decimal.sol\";\nimport { Interest } from \"./Interest.sol\";\nimport { Math } from \"./Math.sol\";\nimport { Monetary } from \"./Monetary.sol\";\nimport { Require } from \"./Require.sol\";\nimport { Time } from \"./Time.sol\";\nimport { Token } from \"./Token.sol\";\nimport { Types } from \"./Types.sol\";\nimport { IInterestSetter } from \"../interfaces/IInterestSetter.sol\";\nimport { IPriceOracle } from \"../interfaces/IPriceOracle.sol\";\n\n\n/**\n * @title Storage\n * @author dYdX\n *\n * Functions for reading, writing, and verifying state in Solo\n */\nlibrary Storage {\n    using Cache for Cache.MarketCache;\n    using Storage for Storage.State;\n    using Math for uint256;\n    using Types for Types.Par;\n    using Types for Types.Wei;\n    using SafeMath for uint256;\n\n    // ============ Constants ============\n\n    bytes32 constant FILE = \"Storage\";\n\n    // ============ Structs ============\n\n    struct Market {\n        // Contract address of the associated ERC20 token\n        address token;\n\n        // Total aggregated supply and borrow amount of the entire market\n        Types.TotalPar totalPar;\n\n        // Interest index of the market\n        Interest.Index index;\n\n        // Contract address of the price oracle for this market\n        IPriceOracle priceOracle;\n\n        // Contract address of the interest setter for this market\n        IInterestSetter interestSetter;\n\n        // Multiplier on the marginRatio for this market\n        Decimal.D256 marginPremium;\n\n        // Multiplier on the liquidationSpread for this market\n        Decimal.D256 spreadPremium;\n\n        // Whether additional borrows are allowed for this market\n        bool isClosing;\n    }\n\n    struct RiskParams {\n        // Required ratio of over-collateralization\n        Decimal.D256 marginRatio;\n\n        // Percentage penalty incurred by liquidated accounts\n        Decimal.D256 liquidationSpread;\n\n        // Percentage of the borrower's interest fee that gets passed to the suppliers\n        Decimal.D256 earningsRate;\n\n        // The minimum absolute borrow value of an account\n        // There must be sufficient incentivize to liquidate undercollateralized accounts\n        Monetary.Value minBorrowedValue;\n    }\n\n    struct RiskLimits {\n        uint64 marginRatioMax;\n        uint64 liquidationSpreadMax;\n        uint64 earningsRateMax;\n        uint64 marginPremiumMax;\n        uint64 spreadPremiumMax;\n        uint128 minBorrowedValueMax;\n    }\n\n    struct State {\n        // number of markets\n        uint256 numMarkets;\n\n        // marketId => Market\n        mapping (uint256 => Market) markets;\n\n        // owner => account number => Account\n        mapping (address => mapping (uint256 => Account.Storage)) accounts;\n\n        // Addresses that can control other users accounts\n        mapping (address => mapping (address => bool)) operators;\n\n        // Addresses that can control all users accounts\n        mapping (address => bool) globalOperators;\n\n        // mutable risk parameters of the system\n        RiskParams riskParams;\n\n        // immutable risk limits of the system\n        RiskLimits riskLimits;\n    }\n\n    // ============ Functions ============\n\n    function getToken(\n        Storage.State storage state,\n        uint256 marketId\n    )\n        internal\n        view\n        returns (address)\n    {\n        return state.markets[marketId].token;\n    }\n\n    function getTotalPar(\n        Storage.State storage state,\n        uint256 marketId\n    )\n        internal\n        view\n        returns (Types.TotalPar memory)\n    {\n        return state.markets[marketId].totalPar;\n    }\n\n    function getIndex(\n        Storage.State storage state,\n        uint256 marketId\n    )\n        internal\n        view\n        returns (Interest.Index memory)\n    {\n        return state.markets[marketId].index;\n    }\n\n    function getNumExcessTokens(\n        Storage.State storage state,\n        uint256 marketId\n    )\n        internal\n        view\n        returns (Types.Wei memory)\n    {\n        Interest.Index memory index = state.getIndex(marketId);\n        Types.TotalPar memory totalPar = state.getTotalPar(marketId);\n\n        address token = state.getToken(marketId);\n\n        Types.Wei memory balanceWei = Types.Wei({\n            sign: true,\n            value: Token.balanceOf(token, address(this))\n        });\n\n        (\n            Types.Wei memory supplyWei,\n            Types.Wei memory borrowWei\n        ) = Interest.totalParToWei(totalPar, index);\n\n        // borrowWei is negative, so subtracting it makes the value more positive\n        return balanceWei.sub(borrowWei).sub(supplyWei);\n    }\n\n    function getStatus(\n        Storage.State storage state,\n        Account.Info memory account\n    )\n        internal\n        view\n        returns (Account.Status)\n    {\n        return state.accounts[account.owner][account.number].status;\n    }\n\n    function getPar(\n        Storage.State storage state,\n        Account.Info memory account,\n        uint256 marketId\n    )\n        internal\n        view\n        returns (Types.Par memory)\n    {\n        return state.accounts[account.owner][account.number].balances[marketId];\n    }\n\n    function getWei(\n        Storage.State storage state,\n        Account.Info memory account,\n        uint256 marketId\n    )\n        internal\n        view\n        returns (Types.Wei memory)\n    {\n        Types.Par memory par = state.getPar(account, marketId);\n\n        if (par.isZero()) {\n            return Types.zeroWei();\n        }\n\n        Interest.Index memory index = state.getIndex(marketId);\n        return Interest.parToWei(par, index);\n    }\n\n    function fetchNewIndex(\n        Storage.State storage state,\n        uint256 marketId,\n        Interest.Index memory index\n    )\n        internal\n        view\n        returns (Interest.Index memory)\n    {\n        Interest.Rate memory rate = state.fetchInterestRate(marketId, index);\n\n        return Interest.calculateNewIndex(\n            index,\n            rate,\n            state.getTotalPar(marketId),\n            state.riskParams.earningsRate\n        );\n    }\n\n    function fetchInterestRate(\n        Storage.State storage state,\n        uint256 marketId,\n        Interest.Index memory index\n    )\n        internal\n        view\n        returns (Interest.Rate memory)\n    {\n        Types.TotalPar memory totalPar = state.getTotalPar(marketId);\n        (\n            Types.Wei memory supplyWei,\n            Types.Wei memory borrowWei\n        ) = Interest.totalParToWei(totalPar, index);\n\n        Interest.Rate memory rate = state.markets[marketId].interestSetter.getInterestRate(\n            state.getToken(marketId),\n            borrowWei.value,\n            supplyWei.value\n        );\n\n        return rate;\n    }\n\n    function fetchPrice(\n        Storage.State storage state,\n        uint256 marketId\n    )\n        internal\n        view\n        returns (Monetary.Price memory)\n    {\n        IPriceOracle oracle = IPriceOracle(state.markets[marketId].priceOracle);\n        Monetary.Price memory price = oracle.getPrice(state.getToken(marketId));\n        Require.that(\n            price.value != 0,\n            FILE,\n            \"Price cannot be zero\",\n            marketId\n        );\n        return price;\n    }\n\n    function getAccountValues(\n        Storage.State storage state,\n        Account.Info memory account,\n        Cache.MarketCache memory cache,\n        bool adjustForLiquidity\n    )\n        internal\n        view\n        returns (Monetary.Value memory, Monetary.Value memory)\n    {\n        Monetary.Value memory supplyValue;\n        Monetary.Value memory borrowValue;\n\n        uint256 numMarkets = cache.getNumMarkets();\n        for (uint256 m = 0; m < numMarkets; m++) {\n            if (!cache.hasMarket(m)) {\n                continue;\n            }\n\n            Types.Wei memory userWei = state.getWei(account, m);\n\n            if (userWei.isZero()) {\n                continue;\n            }\n\n            uint256 assetValue = userWei.value.mul(cache.getPrice(m).value);\n            Decimal.D256 memory adjust = Decimal.one();\n            if (adjustForLiquidity) {\n                adjust = Decimal.add(adjust, state.markets[m].marginPremium);\n            }\n\n            if (userWei.sign) {\n                supplyValue.value = supplyValue.value.add(Decimal.div(assetValue, adjust));\n            } else {\n                borrowValue.value = borrowValue.value.add(Decimal.mul(assetValue, adjust));\n            }\n        }\n\n        return (supplyValue, borrowValue);\n    }\n\n    function isCollateralized(\n        Storage.State storage state,\n        Account.Info memory account,\n        Cache.MarketCache memory cache,\n        bool requireMinBorrow\n    )\n        internal\n        view\n        returns (bool)\n    {\n        (\n            Monetary.Value memory supplyValue,\n            Monetary.Value memory borrowValue\n        ) = state.getAccountValues(account, cache, true);\n\n        if (borrowValue.value == 0) {\n            return true;\n        }\n\n        if (requireMinBorrow) {\n            Require.that(\n                borrowValue.value >= state.riskParams.minBorrowedValue.value,\n                FILE,\n                \"Borrow value too low\",\n                borrowValue.value\n            );\n        }\n\n        uint256 requiredMargin = Decimal.mul(borrowValue.value, state.riskParams.marginRatio);\n\n        return supplyValue.value >= borrowValue.value.add(requiredMargin);\n    }\n\n    function isGlobalOperator(\n        Storage.State storage state,\n        address operator\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return state.globalOperators[operator];\n    }\n\n    function isLocalOperator(\n        Storage.State storage state,\n        address owner,\n        address operator\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return state.operators[owner][operator];\n    }\n\n    function requireIsOperator(\n        Storage.State storage state,\n        Account.Info memory account,\n        address operator\n    )\n        internal\n        view\n    {\n        bool isValidOperator =\n            operator == account.owner\n            || state.isGlobalOperator(operator)\n            || state.isLocalOperator(account.owner, operator);\n\n        Require.that(\n            isValidOperator,\n            FILE,\n            \"Unpermissioned operator\",\n            operator\n        );\n    }\n\n    /**\n     * Determines and sets an account's balance based on the intended balance change. Returns the\n     * equivalent amount in wei\n     */\n    function getNewParAndDeltaWei(\n        Storage.State storage state,\n        Account.Info memory account,\n        uint256 marketId,\n        Types.AssetAmount memory amount\n    )\n        internal\n        view\n        returns (Types.Par memory, Types.Wei memory)\n    {\n        Types.Par memory oldPar = state.getPar(account, marketId);\n\n        if (amount.value == 0 && amount.ref == Types.AssetReference.Delta) {\n            return (oldPar, Types.zeroWei());\n        }\n\n        Interest.Index memory index = state.getIndex(marketId);\n        Types.Wei memory oldWei = Interest.parToWei(oldPar, index);\n        Types.Par memory newPar;\n        Types.Wei memory deltaWei;\n\n        if (amount.denomination == Types.AssetDenomination.Wei) {\n            deltaWei = Types.Wei({\n                sign: amount.sign,\n                value: amount.value\n            });\n            if (amount.ref == Types.AssetReference.Target) {\n                deltaWei = deltaWei.sub(oldWei);\n            }\n            newPar = Interest.weiToPar(oldWei.add(deltaWei), index);\n        } else { // AssetDenomination.Par\n            newPar = Types.Par({\n                sign: amount.sign,\n                value: amount.value.to128()\n            });\n            if (amount.ref == Types.AssetReference.Delta) {\n                newPar = oldPar.add(newPar);\n            }\n            deltaWei = Interest.parToWei(newPar, index).sub(oldWei);\n        }\n\n        return (newPar, deltaWei);\n    }\n\n    function getNewParAndDeltaWeiForLiquidation(\n        Storage.State storage state,\n        Account.Info memory account,\n        uint256 marketId,\n        Types.AssetAmount memory amount\n    )\n        internal\n        view\n        returns (Types.Par memory, Types.We"
    }
  ]
}