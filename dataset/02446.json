{
  "Title": "Unused return value from executeTransaction",
  "Content": "The [`executeTransaction`](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/vendor/Timelock.sol#L76) function from the [`Timelock`](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/vendor/Timelock.sol#L6) contract has a return value that contains the output from the `target.call` call.\n\n\nHowever, the return value is not used in the [`executeProposal`](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/bridges/BaseBridgeReceiver.sol#L160) function from the [`BaseBridgeReceiver`](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/bridges/BaseBridgeReceiver.sol#L6) contract. This makes it impossible to access the return value of a transaction that is executed by the `BaseBridgeReceiver` contract, which may be useful for debugging erratic or unintended behaviors.\n\n\nConsider retrieving these outputs from the `executeTransaction` function calls in the `executeProposal` function.\n\n\n***Update:** Acknowledged, not resolved. The Compound team stated:*\n\n\n\n> *It’s unclear if exposing these return values would actually improve our ability to debug or monitor execution of transactions, especially given that reverted transactions won’t emit any events or return any values. We will not make an update related to this recommendation.*\n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/vendor/Timelock.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.15;\n\nimport \"../ITimelock.sol\";\n\ncontract Timelock is ITimelock {\n    uint public immutable GRACE_PERIOD;\n    uint public immutable MINIMUM_DELAY;\n    uint public immutable MAXIMUM_DELAY;\n\n    address public admin;\n    address public pendingAdmin;\n    uint public delay;\n\n    mapping (bytes32 => bool) public queuedTransactions;\n\n\n    constructor(address admin_, uint delay_, uint gracePeriod_, uint minimumDelay_, uint maxiumumDelay_) public {\n        require(delay_ >= minimumDelay_, \"Timelock::constructor: Delay must exceed minimum delay.\");\n        require(delay_ <= maxiumumDelay_, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\n        GRACE_PERIOD = gracePeriod_;\n        MINIMUM_DELAY = minimumDelay_;\n        MAXIMUM_DELAY = maxiumumDelay_;\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n    fallback() external payable { }\n\n    function setDelay(uint delay_) public {\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) public {\n        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= (getBlockTimestamp() + delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() <= (eta + GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        (bool success, bytes memory returnData) = target.call{value: value}(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint) {\n        return block.timestamp;\n    }\n}"
    },
    {
      "filename": "contracts/bridges/BaseBridgeReceiver.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.15;\n\nimport \"../ITimelock.sol\";\n\ncontract BaseBridgeReceiver {\n    /** Custom errors **/\n    error AlreadyInitialized();\n    error BadData();\n    error InvalidProposalId();\n    error ProposalNotQueued();\n    error TransactionAlreadyQueued();\n    error Unauthorized();\n\n    /** Events **/\n    event Initialized(address indexed govTimelock, address indexed localTimelock);\n    event NewLocalTimelock(address indexed oldLocalTimelock, address indexed newLocalTimelock);\n    event NewGovTimelock(address indexed oldGovTimelock, address indexed newGovTimelock);\n    event ProposalCreated(address indexed messageSender, uint id, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, uint eta);\n    event ProposalExecuted(uint id);\n\n    /** Public variables **/\n\n    /// @notice Address of the governing contract that this bridge receiver expects to\n    ///  receive messages from; likely an address from another chain (e.g. mainnet)\n    address public govTimelock;\n\n    /// @notice Address of the timelock on this chain that the bridge receiver\n    /// will send messages to\n    address public localTimelock;\n\n    /// @notice Whether contract has been initialized\n    bool public initialized;\n\n    /// @notice Total count of proposals generated\n    uint public proposalCount;\n\n    struct Proposal {\n        uint id;\n        address[] targets;\n        uint[] values;\n        string[] signatures;\n        bytes[] calldatas;\n        uint eta;\n        bool executed;\n    }\n\n    /// @notice Mapping of proposal ids to their full proposal data\n    mapping (uint => Proposal) public proposals;\n\n    enum ProposalState {\n        Queued,\n        Expired,\n        Executed\n    }\n\n    /**\n     * @notice Initialize the contract\n     * @param _govTimelock Address of the governing contract that this contract\n     * will receive messages from (likely on another chain)\n     * @param _localTimelock Address of the timelock contract that this contract\n     * will send messages to\n     */\n    function initialize(address _govTimelock, address _localTimelock) external {\n        if (initialized) revert AlreadyInitialized();\n        govTimelock = _govTimelock;\n        localTimelock = _localTimelock;\n        initialized = true;\n        emit Initialized(_govTimelock, _localTimelock);\n    }\n\n    /**\n     * @notice Accept admin role for the localTimelock\n     */\n    function acceptLocalTimelockAdmin() external {\n        if (msg.sender != localTimelock) revert Unauthorized();\n        ITimelock(localTimelock).acceptAdmin();\n    }\n\n    /**\n     * @notice Set localTimelock address\n     * @param newTimelock Address to set as the localTimelock\n     */\n    function setLocalTimelock(address newTimelock) public {\n        if (msg.sender != localTimelock) revert Unauthorized();\n        address oldLocalTimelock = localTimelock;\n        localTimelock = newTimelock;\n        emit NewLocalTimelock(oldLocalTimelock, newTimelock);\n    }\n\n    /**\n     * @notice Set govTimelock address\n     * @param newTimelock Address to set as the govTimelock\n     */\n    function setGovTimelock(address newTimelock) public {\n        if (msg.sender != localTimelock) revert Unauthorized();\n        address oldGovTimelock = govTimelock;\n        govTimelock = newTimelock;\n        emit NewGovTimelock(oldGovTimelock, newTimelock);\n    }\n\n    /**\n     * @notice Process a message sent from the governing timelock (across a bridge)\n     * @param messageSender Address of the contract that sent the bridged message\n     * @param data ABI-encoded bytes containing the transactions to be queued on the local timelock\n     */\n    function processMessage(\n        address messageSender,\n        bytes calldata data\n    ) internal {\n        if (messageSender != govTimelock) revert Unauthorized();\n\n        address[] memory targets;\n        uint256[] memory values;\n        string[] memory signatures;\n        bytes[] memory calldatas;\n\n        (targets, values, signatures, calldatas) = abi.decode(\n            data,\n            (address[], uint256[], string[], bytes[])\n        );\n\n        if (values.length != targets.length) revert BadData();\n        if (signatures.length != targets.length) revert BadData();\n        if (calldatas.length != targets.length) revert BadData();\n\n        uint delay = ITimelock(localTimelock).delay();\n        uint eta = block.timestamp + delay;\n\n        for (uint8 i = 0; i < targets.length; ) {\n            if (ITimelock(localTimelock).queuedTransactions(keccak256(abi.encode(targets[i], values[i], signatures[i], calldatas[i], eta)))) revert TransactionAlreadyQueued();\n            ITimelock(localTimelock).queueTransaction(targets[i], values[i], signatures[i], calldatas[i], eta);\n            unchecked { i++; }\n        }\n\n        proposalCount++;\n        Proposal memory proposal = Proposal({\n            id: proposalCount,\n            targets: targets,\n            values: values,\n            signatures: signatures,\n            calldatas: calldatas,\n            eta: eta,\n            executed: false\n        });\n\n        proposals[proposal.id] = proposal;\n        emit ProposalCreated(messageSender, proposal.id, targets, values, signatures, calldatas, eta);\n    }\n\n    /**\n     * @notice Execute a queued proposal\n     * @param proposalId The id of the proposal to execute\n     */\n    function executeProposal(uint proposalId) external {\n        if (state(proposalId) != ProposalState.Queued) revert ProposalNotQueued();\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        for (uint i = 0; i < proposal.targets.length; i++) {\n            ITimelock(localTimelock).executeTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * @notice Get the state of a proposal\n     * @param proposalId Id of the proposal\n     * @return The state of the given proposal (queued, expired or executed)\n     */\n    function state(uint proposalId) public view returns (ProposalState) {\n        if (proposalId > proposalCount || proposalId == 0) revert InvalidProposalId();\n        Proposal memory proposal = proposals[proposalId];\n        if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= (proposal.eta + ITimelock(localTimelock).GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n}"
    }
  ]
}