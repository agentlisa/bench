{
  "Title": "[M-11] Return values of `transfer()`/`transferFrom()` not checked and unsafe usage",
  "Content": "\n\n*Note: This finding was reported via the winning [Automated Findings report](https://gist.github.com/code423n4/265e1707379b9a3f89cf18aa0bffcb7c). It was declared out of scope for the audit, but is being included here for completeness.*\n\n### [Return values not checked](https://gist.github.com/code423n4/265e1707379b9a3f89cf18aa0bffcb7c#m02-return-values-of-transfertransferfrom-not-checked)\n\nNot all ERC20 implementations `revert()` when there's a failure in `transfer()` or `transferFrom()`. The function signature has a boolean return value and they indicate errors that way instead. By not checking the return value, operations that should have marked as failed, may potentially go through without actually transfer anything.\n\n### [Unsafe usage](https://gist.github.com/code423n4/265e1707379b9a3f89cf18aa0bffcb7c#m03-unsafe-use-of-erc20-transfertransferfrom)\nSome tokens do not implement the ERC20 standard properly. For example, Tether (USDT)'s `transfer()` and `transferFrom()` functions do not return booleans as the ERC20 specification requires, and instead have no return value. When these sorts of tokens are cast to IERC20/ERC20, their function signatures do not match and therefore the calls made will revert.\nIt is recommended to use the [`SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/f347b410cf6aeeaaf5197e1fece139c793c03b2b/contracts/token/ERC20/utils/SafeERC20.sol#L19)'s `safeTransfer()` and `safeTransferFrom()` from OpenZeppelin instead.\n\n### Instances\n*There is 1 instance of these issues:*\n\nWildcatSanctionsEscrow.sol ([#L38](https://github.com/code-423n4/2023-10-wildcat/blob/bbeea97c94114731d809674546210b5a56d7bc6c/src/WildcatSanctionsEscrow.sol#L38))\n\n```solidity\n38:     IERC20(asset).transfer(account, amount);\n```\n\n**[laurenceday (Wildcat) confirmed and commented](https://gist.github.com/code423n4/265e1707379b9a3f89cf18aa0bffcb7c?permalink_comment_id=4781687#gistcomment-4781687)**:\n> Fixed by utilising `SafeERC20`.\n\n**[0xTheC0der (judge) commented](https://gist.github.com/code423n4/265e1707379b9a3f89cf18aa0bffcb7c?permalink_comment_id=4781801#gistcomment-4781801):**\n> Even checking the return values of ERC-20 transfers is problematic and insufficient due to popular tokens like USDT deviating from the spec. One always has to use SafeERC20 (as already mentioned by the sponsor), otherwise this is a valid Medium severity finding.\n>\n> However, there is an exception in case the transferred tokens cannot be chosen freely by the users but need to be whitelisted. Also there are occasions where only a protocol's own correctly implemented tokens can be used (Wildcat market tokens for example). In these cases, the severity is only Informational, since no malfunction can occur.\n>\n> In case of Wildcat, if I remember correctly, the `WildcatSanctionsEscrow` contract could hold user-defined assets and not only their own market tokens. Therefore, Medium severity is justified.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-wildcat",
  "Code": [
    {
      "filename": "contracts/token/ERC20/utils/SafeERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.19;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        if (nonceAfter != nonceBefore + 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}"
    },
    {
      "filename": "src/WildcatSanctionsEscrow.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { IERC20 } from './interfaces/IERC20.sol';\nimport { IChainalysisSanctionsList } from './interfaces/IChainalysisSanctionsList.sol';\nimport { SanctionsList } from './libraries/Chainalysis.sol';\nimport { WildcatSanctionsSentinel } from './WildcatSanctionsSentinel.sol';\nimport { IWildcatSanctionsEscrow } from './interfaces/IWildcatSanctionsEscrow.sol';\n\ncontract WildcatSanctionsEscrow is IWildcatSanctionsEscrow {\n  address public immutable override sentinel;\n  address public immutable override borrower;\n  address public immutable override account;\n  address internal immutable asset;\n\n  constructor() {\n    sentinel = msg.sender;\n    (borrower, account, asset) = WildcatSanctionsSentinel(sentinel).tmpEscrowParams();\n  }\n\n  function balance() public view override returns (uint256) {\n    return IERC20(asset).balanceOf(address(this));\n  }\n\n  function canReleaseEscrow() public view override returns (bool) {\n    return !WildcatSanctionsSentinel(sentinel).isSanctioned(borrower, account);\n  }\n\n  function escrowedAsset() public view override returns (address, uint256) {\n    return (asset, balance());\n  }\n\n  function releaseEscrow() public override {\n    if (!canReleaseEscrow()) revert CanNotReleaseEscrow();\n\n    uint256 amount = balance();\n\n    IERC20(asset).transfer(account, amount);\n\n    emit EscrowReleased(account, asset, amount);\n  }\n}"
    }
  ]
}